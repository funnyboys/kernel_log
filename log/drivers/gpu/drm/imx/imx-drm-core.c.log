commit 62fbddda2f72b86d6126da2bdbddc330544c6e9f
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Mar 5 16:59:36 2020 +0100

    drm/imx: Use simple encoder
    
    The imx driver uses empty implementations for its encoders. Replace
    the code with the generic simple encoder.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200305155950.2705-9-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9e8e0b703498..2e38f1a5cf8d 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -42,12 +42,6 @@ void imx_drm_connector_destroy(struct drm_connector *connector)
 }
 EXPORT_SYMBOL_GPL(imx_drm_connector_destroy);
 
-void imx_drm_encoder_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-EXPORT_SYMBOL_GPL(imx_drm_encoder_destroy);
-
 static int imx_drm_atomic_check(struct drm_device *dev,
 				struct drm_atomic_state *state)
 {

commit 9cb6a97621ae35fd84e93b6c8e4defcdc53161f2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Feb 11 18:22:05 2020 +0200

    drm/imx: Remove the bogus possible_clones setup
    
    It's not at all clear what cloning options this driver supports.
    So let's just clear possible_clones instead of setting it to some
    bogus value.
    
    v2: Adjust the FIXME (Daniel)
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162208.16224-5-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index da87c70e413b..9e8e0b703498 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -139,8 +139,8 @@ int imx_drm_encoder_parse_of(struct drm_device *drm,
 
 	encoder->possible_crtcs = crtc_mask;
 
-	/* FIXME: this is the mask of outputs which can clone this output. */
-	encoder->possible_clones = ~0;
+	/* FIXME: cloning support not clear, disable it all for now */
+	encoder->possible_clones = 0;
 
 	return 0;
 }

commit 05f0940b4de0a3e3ac1c9c0fec30b650fb73be63
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jul 16 08:42:18 2019 +0200

    drm/imx: drop use of drmP.h
    
    Drop use of the deprecated drmP.h header file.
    While touching the include files divide them in blocks and sort the
    include files within each block.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: Fabio Estevam <festevam@gmail.com>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190716064220.18157-18-sam@ravnborg.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index bdefaa1635eb..da87c70e413b 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -4,14 +4,18 @@
  *
  * Copyright (C) 2011 Sascha Hauer, Pengutronix
  */
+
 #include <linux/component.h>
 #include <linux/device.h>
 #include <linux/dma-buf.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <drm/drmP.h>
+
+#include <video/imx-ipu-v3.h>
+
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_gem_cma_helper.h>
@@ -19,7 +23,7 @@
 #include <drm/drm_of.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_probe_helper.h>
-#include <video/imx-ipu-v3.h>
+#include <drm/drm_vblank.h>
 
 #include "imx-drm.h"
 #include "ipuv3-plane.h"

commit c5be0ddd500dd6201d168b4fdd1ffa90846cb437
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 22:35:33 2019 +0200

    drm/imx: Drop drm_gem_prime_export/import
    
    They're the default.
    
    Aside: Would be really nice to switch the others over to
    drm_gem_object_funcs.
    
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: Fabio Estevam <festevam@gmail.com>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190614203615.12639-18-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 384db6d86da0..bdefaa1635eb 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -154,8 +154,6 @@ static struct drm_driver imx_drm_driver = {
 
 	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
-	.gem_prime_import	= drm_gem_prime_import,
-	.gem_prime_export	= drm_gem_prime_export,
 	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
 	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
 	.gem_prime_vmap		= drm_gem_cma_prime_vmap,

commit 0424fdaf883a689d5185c0d0665b265373945898
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 17 17:39:24 2019 +0200

    drm/prime: Actually remove DRIVER_PRIME everywhere
    
    Split out to make the functional changes stick out more.
    
    All places where DRIVER_PRIME was used have been removed in previous
    patches already.
    
    v2: amdgpu gained DRIVER_SYNCOBJ_TIMELINE.
    
    v3: amdgpu lost DRIVER_SYNCOBJ_TIMELINE.
    
    v4: Don't add a space in i915_drv.c (Sam)
    
    v5: Add note that previous patches removed all the DRIVER_PRIME users
    already (Emil).
    
    v6: Fixupe ingenic (new driver) while applying.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: freedreno@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: lima@lists.freedesktop.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: linux-aspeed@lists.ozlabs.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: nouveau@lists.freedesktop.org
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: spice-devel@lists.freedesktop.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: xen-devel@lists.xenproject.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617153924.414-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 3e8bece620df..384db6d86da0 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -147,8 +147,7 @@ static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 };
 
 static struct drm_driver imx_drm_driver = {
-	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME |
-				  DRIVER_ATOMIC,
+	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,

commit cd7d3a1bb42e0756b17ccfafbd956ca7ed757846
Merge: 6b5c029df5e4 4b057e73f28f
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Mar 6 09:22:18 2019 -0500

    Merge drm/drm-next into drm-misc-next
    
    Picking up v5.0 + missed misc-fixes from last release
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

commit 7fbd5d784f75750199c21918da9b2fc92af371e6
Merge: fbac3c48fa6b a0ea4ffff266
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 28 12:53:11 2019 +1000

    Merge tag 'imx-drm-next-2019-02-22' of git://git.pengutronix.de/pza/linux into drm-next
    
    drm/imx: handle pending updates better, add plane zpos property support
    
    - Add a mechanism to only send commit done events once all pending
      updates have been applied. This closes a small race window where
      already armed events could fire even though the double buffered
      hardware update just missed the update window.
    - Add plane zpos property support to allow placing the overlay plane
      behind the primary plane.
    - Allow building imx-drm on all platforms under COMPILE_TEST.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Philipp Zabel <pza@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190222112350.m3ucezilqx6cyest@pengutronix.de

commit 74a3dba26c606adc29f6ba6484d5cdaaf877cccc
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Jan 10 16:20:01 2018 +0100

    drm/imx: ipuv3-plane: add zpos property
    
    Add a zpos property to planes. Call drm_atomic_helper_check() instead of
    calling drm_atomic_helper_check_modeset() and drm_atomic_check_planes()
    manually. This effectively adds a call to drm_atomic_normalize_zpos()
    before checking planes. Reorder atomic update to allow changing plane
    zpos without modeset.
    
    Note that the initial zpos is set in ipu_plane_state_reset(). The
    initial value set in ipu_plane_init() is just for show. The zpos
    parameter of drm_plane_create_zpos_property() is ignored because
    the newly created plane do not have state yet.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Marius Vlad <marius.vlad@collabora.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 820c7e3878f0..687cfb9d410e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -49,11 +49,7 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 {
 	int ret;
 
-	ret = drm_atomic_helper_check_modeset(dev, state);
-	if (ret)
-		return ret;
-
-	ret = drm_atomic_helper_check_planes(dev, state);
+	ret = drm_atomic_helper_check(dev, state);
 	if (ret)
 		return ret;
 
@@ -229,6 +225,7 @@ static int imx_drm_bind(struct device *dev)
 	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
 	drm->mode_config.helper_private = &imx_drm_mode_config_helpers;
 	drm->mode_config.allow_fb_modifiers = true;
+	drm->mode_config.normalize_zpos = true;
 
 	drm_mode_config_init(drm);
 

commit 1220935be2bb62b3aef6740f29e954bbad9b1845
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:23 2018 -0600

    drm: imx: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    For instances using of_node_cmp, this has the side effect of now using
    case sensitive comparisons. This should not matter for any FDT based
    system which this is.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181205195050.4759-7-robh@kernel.org
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 44da0f5d0ed9..4d8e7685706e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -189,7 +189,7 @@ static int compare_of(struct device *dev, void *data)
 	}
 
 	/* Special case for LDB, one device for two channels */
-	if (of_node_cmp(np->name, "lvds-channel") == 0) {
+	if (of_node_name_eq(np, "lvds-channel")) {
 		np = of_get_parent(np);
 		of_node_put(np);
 	}

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 820c7e3878f0..44da0f5d0ed9 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -12,13 +12,13 @@
 #include <drm/drmP.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_fb_helper.h>
-#include <drm/drm_crtc_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_plane_helper.h>
 #include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
 #include <video/imx-ipu-v3.h>
 
 #include "imx-drm.h"

commit 946485d0ede5bb29d3aad55bf7afd35cee1ef529
Author: Fabio Estevam <festevam@gmail.com>
Date:   Fri Sep 28 16:13:25 2018 -0300

    drm/imx: Switch to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management.
    
    Signed-off-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 0e6942f21a4e..820c7e3878f0 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Freescale i.MX drm driver
  *
  * Copyright (C) 2011 Sascha Hauer, Pengutronix
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 #include <linux/component.h>
 #include <linux/device.h>

commit 8c1d1bb0f0bdebd174a6188ca345e44a03becda5
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Sep 26 21:38:36 2018 +0200

    drm/imx: fix build failure without CONFIG_DRM_FBDEV_EMULATION
    
    The variable is declared in an #ifdef section, but the user is
    now unconditional, which leads to a build failure:
    
    drivers/gpu/drm/imx/imx-drm-core.c: In function 'imx_drm_bind':
    drivers/gpu/drm/imx/imx-drm-core.c:264:6: error: 'legacyfb_depth' undeclared (first use in this function); did you mean 'lockdep_depth'?
    
    Remove the remaining #ifdef as well.
    
    Fixes: f53705fd9803 ("drm/imx: Use drm_fbdev_generic_setup()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180926193846.2490574-1-arnd@arndb.de

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index a70f3131a377..0e6942f21a4e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -35,10 +35,8 @@
 
 #define MAX_CRTC	4
 
-#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
-#endif
 
 DEFINE_DRM_GEM_CMA_FOPS(imx_drm_driver_fops);
 

commit f53705fd98030a814fb8e9c05bbed9d0c49d211b
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Sat Sep 8 15:46:39 2018 +0200

    drm/imx: Use drm_fbdev_generic_setup()
    
    The CMA helper is already using the drm_fb_helper_generic_probe part of
    the generic fbdev emulation. This patch makes full use of the generic
    fbdev emulation by using its drm_client callbacks. This means that
    drm_mode_config_funcs->output_poll_changed and drm_driver->lastclose are
    now handled by the emulation code. Additionally fbdev unregister happens
    automatically on drm_dev_unregister().
    
    The drm_fbdev_generic_setup() call is put after drm_dev_register() in the
    driver. This is done to highlight the fact that fbdev emulation is an
    internal client that makes use of the driver, it is not part of the
    driver as such. If fbdev setup fails, an error is printed, but the driver
    succeeds probing.
    
    CONFIG_DRM_FBDEV_EMULATION wasn't honoured by the CMA helper, but it is by
    drm_fb_helper.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180908134648.2582-12-noralf@tronnes.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 5ea0c82f9957..a70f3131a377 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -86,7 +86,6 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_gem_fb_create,
-	.output_poll_changed = drm_fb_helper_output_poll_changed,
 	.atomic_check = imx_drm_atomic_check,
 	.atomic_commit = drm_atomic_helper_commit,
 };
@@ -165,7 +164,6 @@ static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 static struct drm_driver imx_drm_driver = {
 	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME |
 				  DRIVER_ATOMIC,
-	.lastclose		= drm_fb_helper_lastclose,
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,
@@ -263,30 +261,23 @@ static int imx_drm_bind(struct device *dev)
 	 * The fb helper takes copies of key hardware information, so the
 	 * crtcs/connectors/encoders must not change after this point.
 	 */
-#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 	if (legacyfb_depth != 16 && legacyfb_depth != 32) {
 		dev_warn(dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
-	ret = drm_fb_cma_fbdev_init(drm, legacyfb_depth, MAX_CRTC);
-	if (ret)
-		goto err_unbind;
-#endif
 
 	drm_kms_helper_poll_init(drm);
 
 	ret = drm_dev_register(drm, 0);
 	if (ret)
-		goto err_fbhelper;
+		goto err_poll_fini;
+
+	drm_fbdev_generic_setup(drm, legacyfb_depth);
 
 	return 0;
 
-err_fbhelper:
+err_poll_fini:
 	drm_kms_helper_poll_fini(drm);
-#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
-	drm_fb_cma_fbdev_fini(drm);
-err_unbind:
-#endif
 	component_unbind_all(drm->dev, drm);
 err_kms:
 	drm_mode_config_cleanup(drm);
@@ -303,8 +294,6 @@ static void imx_drm_unbind(struct device *dev)
 
 	drm_kms_helper_poll_fini(drm);
 
-	drm_fb_cma_fbdev_fini(drm);
-
 	drm_mode_config_cleanup(drm);
 
 	component_unbind_all(drm->dev, drm);

commit 64f2cafc3da77da7b176f2cdc3eb3fdb031c639f
Author: Souptick Joarder <jrdr.linux@gmail.com>
Date:   Wed Aug 1 00:58:33 2018 +0530

    drm/imx: Convert drm_atomic_helper_suspend/resume()
    
    convert drm_atomic_helper_suspend/resume() to use
    drm_mode_config_helper_suspend/resume().
    
    with this conversion, the remaining member of struct
    imx_drm_device, state, will be no more useful and it
    could be removed forever.
    
    Signed-off-by: Souptick Joarder <jrdr.linux@gmail.com>
    Signed-off-by: Ajit Negi <ajitn.linux@gmail.com>
    [p.zabel@pengutronix.de: rebased onto drm-next, updated commit message]
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f0122afcf2a8..5ea0c82f9957 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -35,11 +35,6 @@
 
 #define MAX_CRTC	4
 
-struct imx_drm_device {
-	struct drm_device			*drm;
-	struct drm_atomic_state			*state;
-};
-
 #if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
@@ -218,22 +213,12 @@ static int compare_of(struct device *dev, void *data)
 static int imx_drm_bind(struct device *dev)
 {
 	struct drm_device *drm;
-	struct imx_drm_device *imxdrm;
 	int ret;
 
 	drm = drm_dev_alloc(&imx_drm_driver, dev);
 	if (IS_ERR(drm))
 		return PTR_ERR(drm);
 
-	imxdrm = devm_kzalloc(dev, sizeof(*imxdrm), GFP_KERNEL);
-	if (!imxdrm) {
-		ret = -ENOMEM;
-		goto err_put;
-	}
-
-	imxdrm->drm = drm;
-	drm->dev_private = imxdrm;
-
 	/*
 	 * enable drm irq mode.
 	 * - with irq_enabled = true, we can use the vblank feature.
@@ -305,7 +290,6 @@ static int imx_drm_bind(struct device *dev)
 	component_unbind_all(drm->dev, drm);
 err_kms:
 	drm_mode_config_cleanup(drm);
-err_put:
 	drm_dev_put(drm);
 
 	return ret;
@@ -354,37 +338,15 @@ static int imx_drm_platform_remove(struct platform_device *pdev)
 static int imx_drm_suspend(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
-	struct imx_drm_device *imxdrm;
-
-	/* The drm_dev is NULL before .load hook is called */
-	if (drm_dev == NULL)
-		return 0;
-
-	drm_kms_helper_poll_disable(drm_dev);
 
-	imxdrm = drm_dev->dev_private;
-	imxdrm->state = drm_atomic_helper_suspend(drm_dev);
-	if (IS_ERR(imxdrm->state)) {
-		drm_kms_helper_poll_enable(drm_dev);
-		return PTR_ERR(imxdrm->state);
-	}
-
-	return 0;
+	return drm_mode_config_helper_suspend(drm_dev);
 }
 
 static int imx_drm_resume(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
-	struct imx_drm_device *imx_drm;
 
-	if (drm_dev == NULL)
-		return 0;
-
-	imx_drm = drm_dev->dev_private;
-	drm_atomic_helper_resume(drm_dev, imx_drm->state);
-	drm_kms_helper_poll_enable(drm_dev);
-
-	return 0;
+	return drm_mode_config_helper_resume(drm_dev);
 }
 #endif
 

commit 81f2b25adddeff2fc7fdd1f23f889d018ba65466
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Jul 17 15:11:28 2018 +0300

    drm/imx: Remove unused field imx_drm_device.pipes
    
    This has been unused since commit 44b460cfe554 ("drm: imx: remove struct
    imx_drm_crtc and imx_drm_crtc_helper_funcs")
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index c895fe78fb48..f0122afcf2a8 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -37,7 +37,6 @@
 
 struct imx_drm_device {
 	struct drm_device			*drm;
-	unsigned int				pipes;
 	struct drm_atomic_state			*state;
 };
 

commit 1ef2917d1d9e6cce41c8794b2e3e81552b1668e4
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Tue Jul 17 10:33:49 2018 +0200

    drm/imx: Replace drm_dev_unref with drm_dev_put
    
    This patch unifies the naming of DRM functions for reference counting
    of struct drm_device. The resulting code is more aligned with the rest
    of the Linux kernel interfaces.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 1d053bbefc02..c895fe78fb48 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -229,7 +229,7 @@ static int imx_drm_bind(struct device *dev)
 	imxdrm = devm_kzalloc(dev, sizeof(*imxdrm), GFP_KERNEL);
 	if (!imxdrm) {
 		ret = -ENOMEM;
-		goto err_unref;
+		goto err_put;
 	}
 
 	imxdrm->drm = drm;
@@ -306,8 +306,8 @@ static int imx_drm_bind(struct device *dev)
 	component_unbind_all(drm->dev, drm);
 err_kms:
 	drm_mode_config_cleanup(drm);
-err_unref:
-	drm_dev_unref(drm);
+err_put:
+	drm_dev_put(drm);
 
 	return ret;
 }
@@ -327,7 +327,7 @@ static void imx_drm_unbind(struct device *dev)
 	component_unbind_all(drm->dev, drm);
 	dev_set_drvdata(dev, NULL);
 
-	drm_dev_unref(drm);
+	drm_dev_put(drm);
 }
 
 static const struct component_master_ops imx_drm_ops = {

commit b0caa1333b6d2d928a00304e9fb6674526c37b79
Merge: bcd21a4786ea 4cfea3c1f271
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 5 11:33:24 2018 +1000

    Merge tag 'imx-drm-next-2018-01-02' of git://git.pengutronix.de/git/pza/linux into drm-next
    
    drm/imx: format modifier support
    
    - Add tiled prefetch support to PRE
    - Add format modifier support to PRG and imx-drm-core
    - Use runtime PM to control PRG clock
    - Allow building ipu-v3 under COMPILE_TEST
    
    * tag 'imx-drm-next-2018-01-02' of git://git.pengutronix.de/git/pza/linux:
      gpu: ipu-v3: allow to build with COMPILE_TEST
      drm/imx: advertise supported plane format modifiers
      drm/imx: add FB modifier support
      gpu: ipu-v3: prg: add modifier support
      gpu: ipu-v3: pre: add tiled prefetch support
      gpu: ipu-v3: prg: switch to runtime PM

commit 9222f768f7b09fea4f12914b376ec975ef758a60
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Fri Nov 10 17:10:00 2017 +0100

    drm/imx: add FB modifier support
    
    This adds FB modifier support for the Vivante single buffer tiled formats,
    when the PRG/PRE engines are present.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 17d2f3a1c562..1887a668c55e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -272,6 +272,7 @@ static int imx_drm_bind(struct device *dev)
 	drm->mode_config.max_height = 4096;
 	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
 	drm->mode_config.helper_private = &imx_drm_mode_config_helpers;
+	drm->mode_config.allow_fb_modifiers = true;
 
 	drm_mode_config_init(drm);
 

commit b2ad94721047c0f047f36c172d68fed93a8f3fcd
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Wed Nov 15 15:19:46 2017 +0100

    drm/imx: Use drm_fb_cma_fbdev_init/fini()
    
    Use drm_fb_cma_fbdev_init() and drm_fb_cma_fbdev_fini() which relies on
    the fact that drm_device holds a pointer to the drm_fb_helper structure.
    This means that the driver doesn't have to keep track of that.
    Also use the drm_fb_helper functions directly.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171115142001.45358-8-noralf@tronnes.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 17d2f3a1c562..3f2b4afcb8a7 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -38,7 +38,6 @@
 struct imx_drm_device {
 	struct drm_device			*drm;
 	unsigned int				pipes;
-	struct drm_fbdev_cma			*fbhelper;
 	struct drm_atomic_state			*state;
 };
 
@@ -47,13 +46,6 @@ static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
 #endif
 
-static void imx_drm_driver_lastclose(struct drm_device *drm)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-
-	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
-}
-
 DEFINE_DRM_GEM_CMA_FOPS(imx_drm_driver_fops);
 
 void imx_drm_connector_destroy(struct drm_connector *connector)
@@ -69,13 +61,6 @@ void imx_drm_encoder_destroy(struct drm_encoder *encoder)
 }
 EXPORT_SYMBOL_GPL(imx_drm_encoder_destroy);
 
-static void imx_drm_output_poll_changed(struct drm_device *drm)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-
-	drm_fbdev_cma_hotplug_event(imxdrm->fbhelper);
-}
-
 static int imx_drm_atomic_check(struct drm_device *dev,
 				struct drm_atomic_state *state)
 {
@@ -107,7 +92,7 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_gem_fb_create,
-	.output_poll_changed = imx_drm_output_poll_changed,
+	.output_poll_changed = drm_fb_helper_output_poll_changed,
 	.atomic_check = imx_drm_atomic_check,
 	.atomic_commit = drm_atomic_helper_commit,
 };
@@ -186,7 +171,7 @@ static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 static struct drm_driver imx_drm_driver = {
 	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME |
 				  DRIVER_ATOMIC,
-	.lastclose		= imx_drm_driver_lastclose,
+	.lastclose		= drm_fb_helper_lastclose,
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,
@@ -298,12 +283,9 @@ static int imx_drm_bind(struct device *dev)
 		dev_warn(dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
-	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth, MAX_CRTC);
-	if (IS_ERR(imxdrm->fbhelper)) {
-		ret = PTR_ERR(imxdrm->fbhelper);
-		imxdrm->fbhelper = NULL;
+	ret = drm_fb_cma_fbdev_init(drm, legacyfb_depth, MAX_CRTC);
+	if (ret)
 		goto err_unbind;
-	}
 #endif
 
 	drm_kms_helper_poll_init(drm);
@@ -317,8 +299,7 @@ static int imx_drm_bind(struct device *dev)
 err_fbhelper:
 	drm_kms_helper_poll_fini(drm);
 #if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
-	if (imxdrm->fbhelper)
-		drm_fbdev_cma_fini(imxdrm->fbhelper);
+	drm_fb_cma_fbdev_fini(drm);
 err_unbind:
 #endif
 	component_unbind_all(drm->dev, drm);
@@ -333,14 +314,12 @@ static int imx_drm_bind(struct device *dev)
 static void imx_drm_unbind(struct device *dev)
 {
 	struct drm_device *drm = dev_get_drvdata(dev);
-	struct imx_drm_device *imxdrm = drm->dev_private;
 
 	drm_dev_unregister(drm);
 
 	drm_kms_helper_poll_fini(drm);
 
-	if (imxdrm->fbhelper)
-		drm_fbdev_cma_fini(imxdrm->fbhelper);
+	drm_fb_cma_fbdev_fini(drm);
 
 	drm_mode_config_cleanup(drm);
 

commit a152992062aa3803eeabfda84b5b844721ddf6ed
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Nov 30 14:31:46 2017 +0100

    drm/imx: always call wait_for_flip_done in commit_tail
    
    drm_atomic_helper_wait_for_vblanks will go away in the future.
    
    The new drm_atomic_helper_setup_commit in 4.15 expects that blocking commits
    have completed flipping before the commit_tail returns. This must be ensured
    by calling wait_for_vblanks or wait_for_flip_done, where flip_done might do
    a less agressive wait, which is fine for imx-drm.
    
    Fixes: 080de2e5be2d (drm/atomic: Check for busy planes/connectors before
                         setting the commit)
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 93c7e3f9b4a8..17d2f3a1c562 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -133,9 +133,16 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 			plane_disabling = true;
 	}
 
-	if (plane_disabling) {
-		drm_atomic_helper_wait_for_vblanks(dev, state);
+	/*
+	 * The flip done wait is only strictly required by imx-drm if a deferred
+	 * plane disable is in-flight. As the core requires blocking commits
+	 * to wait for the flip it is done here unconditionally. This keeps the
+	 * workitem around a bit longer than required for the majority of
+	 * non-blocking commits, but we accept that for the sake of simplicity.
+	 */
+	drm_atomic_helper_wait_for_flip_done(dev, state);
 
+	if (plane_disabling) {
 		for_each_old_plane_in_state(state, plane, old_plane_state, i)
 			ipu_plane_disable_deferred(plane);
 

commit bd10635335cd5555d4f3d7eec0df32033443bc4b
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Sun Aug 13 15:31:53 2017 +0200

    drm/imx: Use drm_gem_fb_create() and drm_gem_fb_prepare_fb()
    
    drm_fb_cma_create() and drm_fb_cma_prepare_fb() are just wrappers now,
    use drm_gem_fb_create() and drm_gem_fb_prepare_fb() directly.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/1502631125-13557-11-git-send-email-noralf@tronnes.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f91cb72d0830..93c7e3f9b4a8 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -24,6 +24,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_of.h>
@@ -105,7 +106,7 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 }
 
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
-	.fb_create = drm_fb_cma_create,
+	.fb_create = drm_gem_fb_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
 	.atomic_check = imx_drm_atomic_check,
 	.atomic_commit = drm_atomic_helper_commit,

commit a58980baee42763e11f55302fbf618d389549b65
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Sun Jul 23 21:16:25 2017 +0200

    drm/imx: Use .dumb_map_offset and .dumb_destroy defaults
    
    This driver can use the drm_driver.dumb_destroy and
    drm_driver.dumb_map_offset defaults, so no need to set them.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/1500837417-40580-10-git-send-email-noralf@tronnes.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f5c621219113..f91cb72d0830 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -182,8 +182,6 @@ static struct drm_driver imx_drm_driver = {
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,
-	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
-	.dumb_destroy		= drm_gem_dumb_destroy,
 
 	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,

commit 30ea752146e147c5a1f0367aa5303929f7bfd697
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Jul 12 10:13:40 2017 +0200

    drm/imx: Use atomic iterator macros
    
    for_each_obj_in_state is about to be removed, so use the new atomic
    iterator macros.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170712081344.25495-13-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 95e2181963d9..f5c621219113 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -115,7 +115,7 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 {
 	struct drm_device *dev = state->dev;
 	struct drm_plane *plane;
-	struct drm_plane_state *old_plane_state;
+	struct drm_plane_state *old_plane_state, *new_plane_state;
 	bool plane_disabling = false;
 	int i;
 
@@ -127,15 +127,15 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 
 	drm_atomic_helper_commit_modeset_enables(dev, state);
 
-	for_each_plane_in_state(state, plane, old_plane_state, i) {
-		if (drm_atomic_plane_disabling(old_plane_state, plane->state))
+	for_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {
+		if (drm_atomic_plane_disabling(old_plane_state, new_plane_state))
 			plane_disabling = true;
 	}
 
 	if (plane_disabling) {
 		drm_atomic_helper_wait_for_vblanks(dev, state);
 
-		for_each_plane_in_state(state, plane, old_plane_state, i)
+		for_each_old_plane_in_state(state, plane, old_plane_state, i)
 			ipu_plane_disable_deferred(plane);
 
 	}

commit 85769cf7cd7f015ac7c8e45ee8a8f7f485c99481
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:58 2017 +0200

    drm/imx: Drop drm_vblank_cleanup
    
    It's only done in the driver load error path, where vblanks don't need
    to be quiescent anyway. And that's all drm_vblank_cleanup does, since
    the core will release the vblank allocations on its own already. So
    drop it.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-24-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 50add2f9e250..95e2181963d9 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -278,7 +278,7 @@ static int imx_drm_bind(struct device *dev)
 	/* Now try and bind all our sub-components */
 	ret = component_bind_all(dev, drm);
 	if (ret)
-		goto err_vblank;
+		goto err_kms;
 
 	drm_mode_config_reset(drm);
 
@@ -316,8 +316,6 @@ static int imx_drm_bind(struct device *dev)
 err_unbind:
 #endif
 	component_unbind_all(drm->dev, drm);
-err_vblank:
-	drm_vblank_cleanup(drm);
 err_kms:
 	drm_mode_config_cleanup(drm);
 err_unref:

commit 0e961332147851d16038d52323fc50e23dcbdfa3
Merge: 3eda2f5983f6 3d1df96ad468
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 7 05:34:46 2017 +1000

    Merge tag 'imx-drm-next-2017-04-04' of git://git.pengutronix.de/git/pza/linux into drm-next
    
    imx-drm module/dependency changes
    
    - The PRE/PRG drivers added an unwanted DRM dependency to the ipu-v3 driver.
      Remove the dependency by conditionally disabling PRE/PRG support depending
      on CONFIG_DRM.
    - Merge the imx-ipuv3-crtc module into the imxdrm module. There is no reason
      anymore for a separation between core drm driver and crtc/plane drivers,
      especially since commit eb8c88808c83 ("drm/imx: add deferred plane
      disabling"), which added a dependency on imx-ipuv3-crtc to the imxdrm
      module.
    
    * tag 'imx-drm-next-2017-04-04' of git://git.pengutronix.de/git/pza/linux:
      drm/imx: merge imx-drm-core and ipuv3-crtc in one module
      gpu: ipu-v3: don't depend on DRM being enabled

commit 3d1df96ad46856ce850be5ac112eab919cbe1cab
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Mar 23 17:18:37 2017 +0100

    drm/imx: merge imx-drm-core and ipuv3-crtc in one module
    
    While it is possible to hook other CRTC implementations into imx-drm
    in practice there are none yet and the option to disable ipuv3-crtc
    support has been hidden for a long time.
    
    Now that the imx-drm-core has learned to deal with some of the
    specifics of IPUv3 there is a cyclic dependency between both parts.
    To get rid of this and to decimate the Kconfig maze a bit, simply
    merge both parts into one module.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index b6dbcd17f1e6..bf77f4c2ffc0 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -431,7 +431,23 @@ static struct platform_driver imx_drm_pdrv = {
 		.of_match_table = imx_drm_dt_ids,
 	},
 };
-module_platform_driver(imx_drm_pdrv);
+
+static struct platform_driver * const drivers[] = {
+	&imx_drm_pdrv,
+	&ipu_drm_driver,
+};
+
+static int __init imx_drm_init(void)
+{
+	return platform_register_drivers(drivers, ARRAY_SIZE(drivers));
+}
+module_init(imx_drm_init);
+
+static void __exit imx_drm_exit(void)
+{
+	platform_unregister_drivers(drivers, ARRAY_SIZE(drivers));
+}
+module_exit(imx_drm_exit);
 
 MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
 MODULE_DESCRIPTION("i.MX drm driver core");

commit edd849e5448c4f6ddc04a5fa1ac5479176660c27
Merge: be5df20a34d7 62c58af32c93
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 23 08:53:41 2017 +1000

    Merge tag 'drm-misc-next-2017-03-21' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    drm-misc for 4.12, 2nd attempt this week:
    
    - topic branch from Jon Corbet for the new graph kerneldoc support
    - lots of graphs for kms/atomic things using the above
    - some vblank query tuning from Chris
    - gem/cma_fops macros
    - moar docs
    
    Driver stuff:
    - vc4 hdmi audio, yay (Eric)
    - dw-hdmi polish from a bunch of people
    - some rockchip dp updates that didn't make last week (Chris Zhong)
    - misc bridge&driver updates
    
    * tag 'drm-misc-next-2017-03-21' of git://anongit.freedesktop.org/git/drm-misc: (37 commits)
      drm/edid: detect SCDC support in HF-VSDB
      drm/edid: detect SCDC support in HF-VSDB
      drm/edid: check for HF-VSDB block
      drm: Add SCDC helpers
      drm: bridge: dw-hdmi: add HDMI vendor specific infoframe config
      drm/bridge: dw_hdmi: support i2c extended read mode
      drm/msm: add stubs for msm_{perf,rd}_debugfs_cleanup
      drm: bochs: Don't remove uninitialized fbdev framebuffer
      drm: vc4: remove redundant check of plane being non-null
      drm/vc4: use platform_register_drivers
      dma-fence: add dma_fence_match_context helper
      drm/vc4: Add HDMI audio support
      dt-bindings: Document the dmas and dma-names properties for VC4 HDMI
      drm/atmel-hlcdc: Fix suspend/resume implementation
      drm: Skip the waitqueue setup for vblank queries
      drm: Defer disabling the vblank IRQ until the next interrupt (for instant-off)
      drm/doc: atomic overview, with graph
      drm/doc: diagram for mode objects and properties
      drm/doc: Consistent kerneldoc include order
      drm/doc: Add KMS overview graphs
      ...

commit 7d5ed2920d15a8583084f7ca689a30277ef9af55
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Wed Mar 15 14:52:17 2017 +0800

    drm/imx: Remove unneeded definition for structure imx_drm_component
    
    No one is using the structure imx_drm_component, so let's remove the
    definition to save several lines.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f42cf9ea911b..b6dbcd17f1e6 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -34,11 +34,6 @@
 
 #define MAX_CRTC	4
 
-struct imx_drm_component {
-	struct device_node *of_node;
-	struct list_head list;
-};
-
 struct imx_drm_device {
 	struct drm_device			*drm;
 	unsigned int				pipes;

commit 00514e8593350498790d19c7e21b720fee899cf7
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Wed Mar 8 12:13:21 2017 +0100

    drm/imx: use PRG/PRE when possible
    
    Allow the planes to use the PRG/PRE units as linear prefetchers when
    possible. This improves DRAM efficiency a bit and reduces the chance
    for display underflow when the memory subsystem is under load.
    
    This does not yet support scanning out tiled buffers directly, as this
    needs more work, but it already wires up the basic interaction between
    imx-drm, the IPUv3 driver and the PRG and PRE drivers.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index cd3c2013ea70..f42cf9ea911b 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -110,6 +110,11 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 	if (ret)
 		return ret;
 
+	/* Assign PRG/PRE channels and check if all constrains are satisfied. */
+	ret = ipu_planes_assign_pre(dev, state);
+	if (ret)
+		return ret;
+
 	return ret;
 }
 

commit eb8c88808c8307b05ce42e101753cb2518c6d14e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Feb 24 18:31:05 2017 +0100

    drm/imx: add deferred plane disabling
    
    The DP (display processor) channel disable code tried to busy wait for
    the DP sync flow end interrupt status bit when disabling the partial
    plane without a full modeset. That never worked reliably, and it was
    disabled completely by the recent "gpu: ipu-v3: remove IRQ dance on DC
    channel disable" patch, causing ipu_wait_interrupt to always time out
    after 50 ms, which in turn would trigger a timeout in
    drm_atomic_helper_wait_for_vblanks.
    
    This patch changes ipu_plane_atomic_disable to only queue a DP channel
    register update at the next frame boundary and set a flag, which can be
    done without any waiting whatsoever. The imx_drm_atomic_commit_tail then
    calls a new ipu_plane_disable_deferred function that does the actual
    IDMAC teardown of the planes that are flagged for deferred disabling,
    after waiting for the vblank.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 2566e4dbe92e..cd3c2013ea70 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -30,6 +30,7 @@
 #include <video/imx-ipu-v3.h>
 
 #include "imx-drm.h"
+#include "ipuv3-plane.h"
 
 #define MAX_CRTC	4
 
@@ -122,6 +123,10 @@ static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 {
 	struct drm_device *dev = state->dev;
+	struct drm_plane *plane;
+	struct drm_plane_state *old_plane_state;
+	bool plane_disabling = false;
+	int i;
 
 	drm_atomic_helper_commit_modeset_disables(dev, state);
 
@@ -131,6 +136,19 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 
 	drm_atomic_helper_commit_modeset_enables(dev, state);
 
+	for_each_plane_in_state(state, plane, old_plane_state, i) {
+		if (drm_atomic_plane_disabling(old_plane_state, plane->state))
+			plane_disabling = true;
+	}
+
+	if (plane_disabling) {
+		drm_atomic_helper_wait_for_vblanks(dev, state);
+
+		for_each_plane_in_state(state, plane, old_plane_state, i)
+			ipu_plane_disable_deferred(plane);
+
+	}
+
 	drm_atomic_helper_commit_hw_done(state);
 }
 

commit cf92fefd040e6117fbcd4ce2baa9c54ae515e0c6
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Feb 24 18:16:47 2017 +0100

    drm/imx: don't wait for vblank and stop calling cleanup_planes in commit_tail
    
    drm_atomic_helper_cleanup_planes only calls the cleanup_fb plane
    helpers, which we don't implement as a CMA framebuffer based driver.
    There is no reason to wait for vblanks in commit_tail only to do nothing
    afterwards.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 4b7b92a7bcf7..2566e4dbe92e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -132,10 +132,6 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 	drm_atomic_helper_commit_modeset_enables(dev, state);
 
 	drm_atomic_helper_commit_hw_done(state);
-
-	drm_atomic_helper_wait_for_vblanks(dev, state);
-
-	drm_atomic_helper_cleanup_planes(dev, state);
 }
 
 static const struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {

commit d55f7e5d54c31c8ed61fdbfc59835cd6804ba954
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:56 2017 +0100

    drm: Create DEFINE_DRM_GEM_CMA_FOPS and roll it out to drivers
    
    Less code ftw.
    
    This converts all drivers except the tinydrm helper module. That one
    needs more work, since it gets the THIS_MODULE reference from
    tinydrm.ko instead of the actual driver module like it should.
    Probably needs a similar trick like I used here with generating the
    entire struct with a macro.
    
    Cc: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-24-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 4b7b92a7bcf7..70736615983c 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -57,16 +57,7 @@ static void imx_drm_driver_lastclose(struct drm_device *drm)
 	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
 }
 
-static const struct file_operations imx_drm_driver_fops = {
-	.owner = THIS_MODULE,
-	.open = drm_open,
-	.release = drm_release,
-	.unlocked_ioctl = drm_ioctl,
-	.mmap = drm_gem_cma_mmap,
-	.poll = drm_poll,
-	.read = drm_read,
-	.llseek = noop_llseek,
-};
+DEFINE_DRM_GEM_CMA_FOPS(imx_drm_driver_fops);
 
 void imx_drm_connector_destroy(struct drm_connector *connector)
 {

commit 8e22e1b3499a446df48c2b26667ca36c55bf864c
Merge: 00d3c14f14d5 64a577196d66
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Feb 26 21:34:42 2017 +0100

    Merge airlied/drm-next into drm-misc-next
    
    Backmerge the main pull request to sync up with all the newly landed
    drivers. Otherwise we'll have chaos even before 4.12 started in
    earnest.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 43f86c9470b8a4c2c26ae678843465aac3831145
Merge: 94000cc32988 0e47b0275bdb
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 23 12:10:42 2017 +1000

    Merge tag 'imx-drm-fixes-2017-02-17' of https://git.pengutronix.de/git/pza/linux into drm-next
    
    imx-drm: TVE regulator, fb size limit, and ipu-v3 module fixes
    
    - Fix i.MX5 TV encoder probing in case no dac-supply regulator
      is set in the device tree.
    - Remove 64 pixel min_width/height limit, which unnecessarily
      prohibits creation of small frame buffers.
    - Add missing ipu_csi_set_downsize export, for media drivers
      built as modules.
    - Stop modifying pdev->dev.of_node for IPU client devices that
      do not have an OF modalias to fix module autoloading.
    
    * tag 'imx-drm-fixes-2017-02-17' of https://git.pengutronix.de/git/pza/linux:
      gpu: ipu-v3: Stop overwriting pdev->dev.of_node of child devices
      gpu: ipu-v3: export ipu_csi_set_downsize
      drm/imx: lift 64x64 pixel minimum framebuffer size requirement
      drm/imx: imx-tve: Do not set the regulator voltage

commit f57c511a9d1e8625879abd032e3cbf4bd25bbafa
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Jan 27 11:57:19 2017 +0100

    drm/imx: lift 64x64 pixel minimum framebuffer size requirement
    
    There is no reason to limit framebuffer size to 64x64 pixels at a
    minimum on creation. The actual scanout limitations (width >= 13 for the
    base plane and height >= 2) are checked in atomic_check.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 33404295b447..bef76cb0d05d 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -357,8 +357,8 @@ static int imx_drm_bind(struct device *dev)
 	 * this value would be used to check framebuffer size limitation
 	 * at drm_mode_addfb().
 	 */
-	drm->mode_config.min_width = 64;
-	drm->mode_config.min_height = 64;
+	drm->mode_config.min_width = 1;
+	drm->mode_config.min_height = 1;
 	drm->mode_config.max_width = 4096;
 	drm->mode_config.max_height = 4096;
 	drm->mode_config.funcs = &imx_drm_mode_config_funcs;

commit a4b10ccead4de0cf46bffb32fcb9e134b202676b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 2 11:16:13 2017 +0200

    drm: Constify drm_mode_config atomic helper private pointer
    
    The drm_mode_config helper private field points to a structure of
    function pointers that don't need to be modified at runtime. Make it
    const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Acked-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170102091613.6310-1-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 65bd8b8a2494..45dceb672e20 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -138,7 +138,7 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 	drm_atomic_helper_cleanup_planes(dev, state);
 }
 
-static struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
+static const struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
 	.atomic_commit_tail = imx_drm_atomic_commit_tail,
 };
 

commit 44b460cfe55483f4b14dd8beb4953f452be1a005
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:24 2017 +0800

    drm: imx: remove struct imx_drm_crtc and imx_drm_crtc_helper_funcs
    
    With the vblank hooks in struct drm_crtc_funcs, we do not need to
    maintain the CRTC specific vblank callbacks with struct
    imx_drm_crtc_helper_funcs any more.  By moving the stuff that we
    currently do in imx_drm_add_crtc(), like of_node setting and
    drm_crtc_helper_add()/drm_crtc_init_with_planes() invoking, we can kill
    things like struct imx_drm_crtc, imx_drm_crtc_helper_funcs and related
    functions completely.
    
    Functions ipu_enable_vblank() and ipu_disable_vblank() are moved around
    without changes, only for saving the forward declarations.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-13-git-send-email-shawnguo@kernel.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 4badbb66d69e..65bd8b8a2494 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -40,17 +40,11 @@ struct imx_drm_component {
 
 struct imx_drm_device {
 	struct drm_device			*drm;
-	struct imx_drm_crtc			*crtc[MAX_CRTC];
 	unsigned int				pipes;
 	struct drm_fbdev_cma			*fbhelper;
 	struct drm_atomic_state			*state;
 };
 
-struct imx_drm_crtc {
-	struct drm_crtc				*crtc;
-	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
-};
-
 #if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
@@ -63,38 +57,6 @@ static void imx_drm_driver_lastclose(struct drm_device *drm)
 	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
 }
 
-static int imx_drm_enable_vblank(struct drm_device *drm, unsigned int pipe)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[pipe];
-	int ret;
-
-	if (!imx_drm_crtc)
-		return -EINVAL;
-
-	if (!imx_drm_crtc->imx_drm_helper_funcs.enable_vblank)
-		return -ENOSYS;
-
-	ret = imx_drm_crtc->imx_drm_helper_funcs.enable_vblank(
-			imx_drm_crtc->crtc);
-
-	return ret;
-}
-
-static void imx_drm_disable_vblank(struct drm_device *drm, unsigned int pipe)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[pipe];
-
-	if (!imx_drm_crtc)
-		return;
-
-	if (!imx_drm_crtc->imx_drm_helper_funcs.disable_vblank)
-		return;
-
-	imx_drm_crtc->imx_drm_helper_funcs.disable_vblank(imx_drm_crtc->crtc);
-}
-
 static const struct file_operations imx_drm_driver_fops = {
 	.owner = THIS_MODULE,
 	.open = drm_open,
@@ -180,67 +142,6 @@ static struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
 	.atomic_commit_tail = imx_drm_atomic_commit_tail,
 };
 
-/*
- * imx_drm_add_crtc - add a new crtc
- */
-int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
-		struct imx_drm_crtc **new_crtc, struct drm_plane *primary_plane,
-		const struct imx_drm_crtc_helper_funcs *imx_drm_helper_funcs,
-		struct device_node *port)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct imx_drm_crtc *imx_drm_crtc;
-
-	/*
-	 * The vblank arrays are dimensioned by MAX_CRTC - we can't
-	 * pass IDs greater than this to those functions.
-	 */
-	if (imxdrm->pipes >= MAX_CRTC)
-		return -EINVAL;
-
-	if (imxdrm->drm->open_count)
-		return -EBUSY;
-
-	imx_drm_crtc = kzalloc(sizeof(*imx_drm_crtc), GFP_KERNEL);
-	if (!imx_drm_crtc)
-		return -ENOMEM;
-
-	imx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;
-	imx_drm_crtc->crtc = crtc;
-
-	crtc->port = port;
-
-	imxdrm->crtc[imxdrm->pipes++] = imx_drm_crtc;
-
-	*new_crtc = imx_drm_crtc;
-
-	drm_crtc_helper_add(crtc,
-			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);
-
-	drm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,
-			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs, NULL);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(imx_drm_add_crtc);
-
-/*
- * imx_drm_remove_crtc - remove a crtc
- */
-int imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)
-{
-	struct imx_drm_device *imxdrm = imx_drm_crtc->crtc->dev->dev_private;
-	unsigned int pipe = drm_crtc_index(imx_drm_crtc->crtc);
-
-	drm_crtc_cleanup(imx_drm_crtc->crtc);
-
-	imxdrm->crtc[pipe] = NULL;
-
-	kfree(imx_drm_crtc);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(imx_drm_remove_crtc);
 
 int imx_drm_encoder_parse_of(struct drm_device *drm,
 	struct drm_encoder *encoder, struct device_node *np)
@@ -288,8 +189,6 @@ static struct drm_driver imx_drm_driver = {
 	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
 	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
 	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
-	.enable_vblank		= imx_drm_enable_vblank,
-	.disable_vblank		= imx_drm_disable_vblank,
 	.ioctls			= imx_drm_ioctls,
 	.num_ioctls		= ARRAY_SIZE(imx_drm_ioctls),
 	.fops			= &imx_drm_driver_fops,

commit 967dd48417874dd25491a4e933648f394a64f70f
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:14 2017 +0800

    drm: remove drm_vblank_no_hw_counter assignment from driver code
    
    Core code already makes drm_driver.get_vblank_counter hook optional by
    letting drm_vblank_no_hw_counter be the default implementation for the
    function hook.  So the drm_vblank_no_hw_counter assignment in the driver
    code becomes redundant and can be removed now.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Xinliang Liu <z.liuxinliang@hisilicon.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Marek Vasut <marex@denx.de>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Eric Anholt <eric@anholt.net>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-3-git-send-email-shawnguo@kernel.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 5ae48836652e..4badbb66d69e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -288,7 +288,6 @@ static struct drm_driver imx_drm_driver = {
 	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
 	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
 	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
-	.get_vblank_counter	= drm_vblank_no_hw_counter,
 	.enable_vblank		= imx_drm_enable_vblank,
 	.disable_vblank		= imx_drm_disable_vblank,
 	.ioctls			= imx_drm_ioctls,

commit e4563f6ba71792c77aeccb2092cc23149b44e642
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Feb 2 14:26:40 2017 -0200

    drm: Rely on mode_config data for fb_helper initialization
    
    Instead of receiving the num_crts as a parameter, we can read it
    directly from the mode_config structure.  I audited the drivers that
    invoke this helper and I believe all of them initialize the mode_config
    struct accordingly, prior to calling the fb_helper.
    
    I used the following coccinelle hack to make this transformation, except
    for the function headers and comment updates.  The first and second
    rules are split because I couldn't find a way to remove the unused
    temporary variables at the same time I removed the parameter.
    
    // <smpl>
    @r@
    expression A,B,D,E;
    identifier C;
    @@
    (
    - drm_fb_helper_init(A,B,C,D)
    + drm_fb_helper_init(A,B,D)
    |
    - drm_fbdev_cma_init_with_funcs(A,B,C,D,E)
    + drm_fbdev_cma_init_with_funcs(A,B,D,E)
    |
    - drm_fbdev_cma_init(A,B,C,D)
    + drm_fbdev_cma_init(A,B,D)
    )
    
    @@
    expression A,B,C,D,E;
    @@
    (
    - drm_fb_helper_init(A,B,C,D)
    + drm_fb_helper_init(A,B,D)
    |
    - drm_fbdev_cma_init_with_funcs(A,B,C,D,E)
    + drm_fbdev_cma_init_with_funcs(A,B,D,E)
    |
    - drm_fbdev_cma_init(A,B,C,D)
    + drm_fbdev_cma_init(A,B,D)
    )
    
    @@
    identifier r.C;
    type T;
    expression V;
    @@
    - T C;
    <...
    when != C
    - C = V;
    ...>
    // </smpl>
    
    Changes since v1:
     - Rebased on top of the tip of drm-misc-next.
     - Remove mention to sti since a proper fix got merged.
    
    Suggested-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170202162640.27261-1-krisman@collabora.co.uk

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 33404295b447..5ae48836652e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -389,8 +389,7 @@ static int imx_drm_bind(struct device *dev)
 		dev_warn(dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
-	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
-				drm->mode_config.num_crtc, MAX_CRTC);
+	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth, MAX_CRTC);
 	if (IS_ERR(imxdrm->fbhelper)) {
 		ret = PTR_ERR(imxdrm->fbhelper);
 		imxdrm->fbhelper = NULL;

commit 782ea2a493ba908008cbf2ce50d1b4047c1bba0f
Author: Marek Vasut <marex@denx.de>
Date:   Mon Nov 14 11:07:32 2016 +0100

    drm/imx: Switch to drm_fb_cma_prepare_fb() helper
    
    Remove the common code from the driver and use the
    drm_fb_cma_prepare_fb() helper instead.
    Moveover, call the helper from prepare_fb() plane hook .
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114100732.3446-2-marex@denx.de
    Link: http://patchwork.freedesktop.org/patch/msgid/1476451342-146510-1-git-send-email-dvyukov@google.com

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index a16e8b7df120..33404295b447 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -18,7 +18,6 @@
 #include <linux/dma-buf.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/reservation.h>
 #include <drm/drmP.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
@@ -151,40 +150,11 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 	return ret;
 }
 
-static int imx_drm_atomic_commit(struct drm_device *dev,
-				 struct drm_atomic_state *state,
-				 bool nonblock)
-{
-	struct drm_plane_state *plane_state;
-	struct drm_plane *plane;
-	struct dma_buf *dma_buf;
-	struct dma_fence *fence;
-	int i;
-
-	/*
-	 * If the plane fb has an dma-buf attached, fish out the exclusive
-	 * fence for the atomic helper to wait on.
-	 */
-	for_each_plane_in_state(state, plane, plane_state, i) {
-		if ((plane->state->fb != plane_state->fb) && plane_state->fb) {
-			dma_buf = drm_fb_cma_get_gem_obj(plane_state->fb,
-							 0)->base.dma_buf;
-			if (!dma_buf)
-				continue;
-			fence = reservation_object_get_excl_rcu(dma_buf->resv);
-
-			drm_atomic_set_fence_for_plane(plane_state, fence);
-		}
-	}
-
-	return drm_atomic_helper_commit(dev, state, nonblock);
-}
-
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_fb_cma_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
 	.atomic_check = imx_drm_atomic_check,
-	.atomic_commit = imx_drm_atomic_commit,
+	.atomic_commit = drm_atomic_helper_commit,
 };
 
 static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)

commit 3e91168a6a76f7e21c44f04ebf953589ca59f03c
Merge: db8feb6979e9 4b514e10157a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Nov 11 09:28:44 2016 +1000

    Merge tag 'topic/drm-misc-2016-11-10' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - better atomic state debugging from Rob
    - fence prep from gustavo
    - sumits flushed out his backlog of pending dma-buf/fence patches from
      various people
    - drm_mm leak debugging plus trying to appease Kconfig (Chris)
    - a few misc things all over
    
    * tag 'topic/drm-misc-2016-11-10' of git://anongit.freedesktop.org/drm-intel: (35 commits)
      drm: Make DRM_DEBUG_MM depend on STACKTRACE_SUPPORT
      drm/i915: Restrict DRM_DEBUG_MM automatic selection
      drm: Restrict stackdepot usage to builtin drm.ko
      drm/msm: module param to dump state on error irq
      drm/msm/mdp5: add atomic_print_state support
      drm/atomic: add debugfs file to dump out atomic state
      drm/atomic: add new drm_debug bit to dump atomic state
      drm: add helpers to go from plane state to drm_rect
      drm: add helper for printing to log or seq_file
      drm: helper macros to print composite types
      reservation: revert "wait only with non-zero timeout specified (v3)" v2
      drm/ttm: fix ttm_bo_wait
      dma-buf/fence: revert "don't wait when specified timeout is zero" (v2)
      dma-buf/fence: make timeout handling in fence_default_wait consistent (v2)
      drm/amdgpu: add the interface of waiting multiple fences (v4)
      dma-buf: return index of the first signaled fence (v2)
      MAINTAINERS: update Sync File Framework files
      dma-buf/sw_sync: put fence reference from the fence creation
      dma-buf/sw_sync: mark sync_timeline_create() static
      drm: Add stackdepot include for DRM_DEBUG_MM
      ...

commit aee2586490e9c1ff73bdc4fbf705469a6fa4e074
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Mon Nov 7 19:03:31 2016 +0900

    drm/imx: use drm_atomic_set_fence_for_plane() to set the fence
    
    drm_atomic_set_fence_for_plane() is smart and won't overwrite
    plane_state->fence if the user already set an explicit fence there.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478513013-3221-2-git-send-email-gustavo@padovan.org

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 98df09c2b388..07fe9556c7aa 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -158,6 +158,7 @@ static int imx_drm_atomic_commit(struct drm_device *dev,
 	struct drm_plane_state *plane_state;
 	struct drm_plane *plane;
 	struct dma_buf *dma_buf;
+	struct dma_fence *fence;
 	int i;
 
 	/*
@@ -170,8 +171,9 @@ static int imx_drm_atomic_commit(struct drm_device *dev,
 							 0)->base.dma_buf;
 			if (!dma_buf)
 				continue;
-			plane_state->fence =
-				reservation_object_get_excl_rcu(dma_buf->resv);
+			fence = reservation_object_get_excl_rcu(dma_buf->resv);
+
+			drm_atomic_set_fence_for_plane(plane_state, fence);
 		}
 	}
 

commit 8cca354816adacb91280e19c50f81ffddc0460a4
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 13 11:53:21 2016 +0300

    drm/imx: drm_dev_alloc() returns error pointers
    
    We are checking for NULL here, when we should be checking for error
    pointers.
    
    Fixes: 54db5decce17 ("drm/imx: drop deprecated load/unload drm_driver ops")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index b084c571b23f..9672b579f950 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -357,8 +357,8 @@ static int imx_drm_bind(struct device *dev)
 	int ret;
 
 	drm = drm_dev_alloc(&imx_drm_driver, dev);
-	if (!drm)
-		return -ENOMEM;
+	if (IS_ERR(drm))
+		return PTR_ERR(drm);
 
 	imxdrm = devm_kzalloc(dev, sizeof(*imxdrm), GFP_KERNEL);
 	if (!imxdrm) {

commit 3e3affe549ebd228501d160886c1b3999d99e0c6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 22 11:50:52 2016 +0200

    drm/imx: hide an unused label
    
    The imx_drm_bind function causes a warning in linux-next when
    CONFIG_DRM_FBDEV_EMULATION is not set:
    
    drivers/gpu/drm/imx/imx-drm-core.c: In function 'imx_drm_bind':
    drivers/gpu/drm/imx/imx-drm-core.c:441:1: error: label 'err_unbind' defined but not used [-Werror=unused-label]
    
    I don't understand why the warning only showed up now, as the
    code has not been modified recently, but there is an obvious
    fix in adding another #if for the symbol.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: c1ff5a7aa3c3 ("drm/imx: Remove local fbdev emulation Kconfig option")
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 98df09c2b388..b084c571b23f 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -436,9 +436,11 @@ static int imx_drm_bind(struct device *dev)
 
 err_fbhelper:
 	drm_kms_helper_poll_fini(drm);
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 	if (imxdrm->fbhelper)
 		drm_fbdev_cma_fini(imxdrm->fbhelper);
 err_unbind:
+#endif
 	component_unbind_all(drm->dev, drm);
 err_vblank:
 	drm_vblank_cleanup(drm);

commit a40e65b76430a6ce0bb22ed8327c56dd5044a4a3
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Aug 11 11:18:51 2016 +0200

    drm/imx: add exclusive fence to plane state
    
    This allows the atomic helper to wait on them, instead of open-coding
    the same in the imx-drm driver.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 3cc8e4ad639b..98df09c2b388 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -151,50 +151,43 @@ static int imx_drm_atomic_check(struct drm_device *dev,
 	return ret;
 }
 
+static int imx_drm_atomic_commit(struct drm_device *dev,
+				 struct drm_atomic_state *state,
+				 bool nonblock)
+{
+	struct drm_plane_state *plane_state;
+	struct drm_plane *plane;
+	struct dma_buf *dma_buf;
+	int i;
+
+	/*
+	 * If the plane fb has an dma-buf attached, fish out the exclusive
+	 * fence for the atomic helper to wait on.
+	 */
+	for_each_plane_in_state(state, plane, plane_state, i) {
+		if ((plane->state->fb != plane_state->fb) && plane_state->fb) {
+			dma_buf = drm_fb_cma_get_gem_obj(plane_state->fb,
+							 0)->base.dma_buf;
+			if (!dma_buf)
+				continue;
+			plane_state->fence =
+				reservation_object_get_excl_rcu(dma_buf->resv);
+		}
+	}
+
+	return drm_atomic_helper_commit(dev, state, nonblock);
+}
+
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_fb_cma_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
 	.atomic_check = imx_drm_atomic_check,
-	.atomic_commit = drm_atomic_helper_commit,
+	.atomic_commit = imx_drm_atomic_commit,
 };
 
 static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 {
 	struct drm_device *dev = state->dev;
-	struct drm_crtc *crtc;
-	struct drm_crtc_state *crtc_state;
-	struct drm_plane_state *plane_state;
-	struct drm_gem_cma_object *cma_obj;
-	struct fence *excl;
-	unsigned shared_count;
-	struct fence **shared;
-	unsigned int i, j;
-	int ret;
-
-	/* Wait for fences. */
-	for_each_crtc_in_state(state, crtc, crtc_state, i) {
-		plane_state = crtc->primary->state;
-		if (plane_state->fb) {
-			cma_obj = drm_fb_cma_get_gem_obj(plane_state->fb, 0);
-			if (cma_obj->base.dma_buf) {
-				ret = reservation_object_get_fences_rcu(
-					cma_obj->base.dma_buf->resv, &excl,
-					&shared_count, &shared);
-				if (unlikely(ret))
-					DRM_ERROR("failed to get fences "
-						  "for buffer\n");
-
-				if (excl) {
-					fence_wait(excl, false);
-					fence_put(excl);
-				}
-				for (j = 0; j < shared_count; i++) {
-					fence_wait(shared[j], false);
-					fence_put(shared[j]);
-				}
-			}
-		}
-	}
 
 	drm_atomic_helper_commit_modeset_disables(dev, state);
 

commit 8e3b16e2117409625b89807de3912ff773aea354
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Aug 11 11:18:49 2016 +0200

    drm/imx: don't destroy mode objects manually on driver unbind
    
    Instead let drm_mode_config_cleanup() do the work when taking down
    the master device. This requires all cleanup functions to be
    properly hooked up to the mode object .destroy callback.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 7a1ddf8b04cf..3cc8e4ad639b 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -469,11 +469,11 @@ static void imx_drm_unbind(struct device *dev)
 	if (imxdrm->fbhelper)
 		drm_fbdev_cma_fini(imxdrm->fbhelper);
 
+	drm_mode_config_cleanup(drm);
+
 	component_unbind_all(drm->dev, drm);
 	dev_set_drvdata(dev, NULL);
 
-	drm_mode_config_cleanup(drm);
-
 	drm_dev_unref(drm);
 }
 

commit 54db5decce17b3258475a011a00b9c5c51c57a35
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Thu Aug 11 11:18:48 2016 +0200

    drm/imx: drop deprecated load/unload drm_driver ops
    
    Drop the load/unload driver ops, as they are deprecated because of their
    inherent races, with devices being visible to userspace before they are
    fully initialized.
    
    Move this code into the driver bind/unbind routines bracketed by the
    proper drm_dev_alloc/register and drm_dev_unregister/unref calls.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 75f35eaffb78..7a1ddf8b04cf 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -64,25 +64,6 @@ static void imx_drm_driver_lastclose(struct drm_device *drm)
 	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
 }
 
-static int imx_drm_driver_unload(struct drm_device *drm)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-
-	drm_kms_helper_poll_fini(drm);
-
-	if (imxdrm->fbhelper)
-		drm_fbdev_cma_fini(imxdrm->fbhelper);
-
-	component_unbind_all(drm->dev, drm);
-
-	drm_vblank_cleanup(drm);
-	drm_mode_config_cleanup(drm);
-
-	platform_set_drvdata(drm->platformdev, NULL);
-
-	return 0;
-}
-
 static int imx_drm_enable_vblank(struct drm_device *drm, unsigned int pipe)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;
@@ -234,111 +215,6 @@ static struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
 	.atomic_commit_tail = imx_drm_atomic_commit_tail,
 };
 
-/*
- * Main DRM initialisation. This binds, initialises and registers
- * with DRM the subcomponents of the driver.
- */
-static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
-{
-	struct imx_drm_device *imxdrm;
-	struct drm_connector *connector;
-	int ret;
-
-	imxdrm = devm_kzalloc(drm->dev, sizeof(*imxdrm), GFP_KERNEL);
-	if (!imxdrm)
-		return -ENOMEM;
-
-	imxdrm->drm = drm;
-
-	drm->dev_private = imxdrm;
-
-	/*
-	 * enable drm irq mode.
-	 * - with irq_enabled = true, we can use the vblank feature.
-	 *
-	 * P.S. note that we wouldn't use drm irq handler but
-	 *      just specific driver own one instead because
-	 *      drm framework supports only one irq handler and
-	 *      drivers can well take care of their interrupts
-	 */
-	drm->irq_enabled = true;
-
-	/*
-	 * set max width and height as default value(4096x4096).
-	 * this value would be used to check framebuffer size limitation
-	 * at drm_mode_addfb().
-	 */
-	drm->mode_config.min_width = 64;
-	drm->mode_config.min_height = 64;
-	drm->mode_config.max_width = 4096;
-	drm->mode_config.max_height = 4096;
-	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
-	drm->mode_config.helper_private = &imx_drm_mode_config_helpers;
-
-	drm_mode_config_init(drm);
-
-	ret = drm_vblank_init(drm, MAX_CRTC);
-	if (ret)
-		goto err_kms;
-
-	platform_set_drvdata(drm->platformdev, drm);
-
-	/* Now try and bind all our sub-components */
-	ret = component_bind_all(drm->dev, drm);
-	if (ret)
-		goto err_vblank;
-
-	/*
-	 * All components are now added, we can publish the connector sysfs
-	 * entries to userspace.  This will generate hotplug events and so
-	 * userspace will expect to be able to access DRM at this point.
-	 */
-	list_for_each_entry(connector, &drm->mode_config.connector_list, head) {
-		ret = drm_connector_register(connector);
-		if (ret) {
-			dev_err(drm->dev,
-				"[CONNECTOR:%d:%s] drm_connector_register failed: %d\n",
-				connector->base.id,
-				connector->name, ret);
-			goto err_unbind;
-		}
-	}
-
-	drm_mode_config_reset(drm);
-
-	/*
-	 * All components are now initialised, so setup the fb helper.
-	 * The fb helper takes copies of key hardware information, so the
-	 * crtcs/connectors/encoders must not change after this point.
-	 */
-#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
-	if (legacyfb_depth != 16 && legacyfb_depth != 32) {
-		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
-		legacyfb_depth = 16;
-	}
-	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
-				drm->mode_config.num_crtc, MAX_CRTC);
-	if (IS_ERR(imxdrm->fbhelper)) {
-		ret = PTR_ERR(imxdrm->fbhelper);
-		imxdrm->fbhelper = NULL;
-		goto err_unbind;
-	}
-#endif
-
-	drm_kms_helper_poll_init(drm);
-
-	return 0;
-
-err_unbind:
-	component_unbind_all(drm->dev, drm);
-err_vblank:
-	drm_vblank_cleanup(drm);
-err_kms:
-	drm_mode_config_cleanup(drm);
-
-	return ret;
-}
-
 /*
  * imx_drm_add_crtc - add a new crtc
  */
@@ -431,8 +307,6 @@ static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 static struct drm_driver imx_drm_driver = {
 	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME |
 				  DRIVER_ATOMIC,
-	.load			= imx_drm_driver_load,
-	.unload			= imx_drm_driver_unload,
 	.lastclose		= imx_drm_driver_lastclose,
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
@@ -485,12 +359,122 @@ static int compare_of(struct device *dev, void *data)
 
 static int imx_drm_bind(struct device *dev)
 {
-	return drm_platform_init(&imx_drm_driver, to_platform_device(dev));
+	struct drm_device *drm;
+	struct imx_drm_device *imxdrm;
+	int ret;
+
+	drm = drm_dev_alloc(&imx_drm_driver, dev);
+	if (!drm)
+		return -ENOMEM;
+
+	imxdrm = devm_kzalloc(dev, sizeof(*imxdrm), GFP_KERNEL);
+	if (!imxdrm) {
+		ret = -ENOMEM;
+		goto err_unref;
+	}
+
+	imxdrm->drm = drm;
+	drm->dev_private = imxdrm;
+
+	/*
+	 * enable drm irq mode.
+	 * - with irq_enabled = true, we can use the vblank feature.
+	 *
+	 * P.S. note that we wouldn't use drm irq handler but
+	 *      just specific driver own one instead because
+	 *      drm framework supports only one irq handler and
+	 *      drivers can well take care of their interrupts
+	 */
+	drm->irq_enabled = true;
+
+	/*
+	 * set max width and height as default value(4096x4096).
+	 * this value would be used to check framebuffer size limitation
+	 * at drm_mode_addfb().
+	 */
+	drm->mode_config.min_width = 64;
+	drm->mode_config.min_height = 64;
+	drm->mode_config.max_width = 4096;
+	drm->mode_config.max_height = 4096;
+	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
+	drm->mode_config.helper_private = &imx_drm_mode_config_helpers;
+
+	drm_mode_config_init(drm);
+
+	ret = drm_vblank_init(drm, MAX_CRTC);
+	if (ret)
+		goto err_kms;
+
+	dev_set_drvdata(dev, drm);
+
+	/* Now try and bind all our sub-components */
+	ret = component_bind_all(dev, drm);
+	if (ret)
+		goto err_vblank;
+
+	drm_mode_config_reset(drm);
+
+	/*
+	 * All components are now initialised, so setup the fb helper.
+	 * The fb helper takes copies of key hardware information, so the
+	 * crtcs/connectors/encoders must not change after this point.
+	 */
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
+	if (legacyfb_depth != 16 && legacyfb_depth != 32) {
+		dev_warn(dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
+		legacyfb_depth = 16;
+	}
+	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
+				drm->mode_config.num_crtc, MAX_CRTC);
+	if (IS_ERR(imxdrm->fbhelper)) {
+		ret = PTR_ERR(imxdrm->fbhelper);
+		imxdrm->fbhelper = NULL;
+		goto err_unbind;
+	}
+#endif
+
+	drm_kms_helper_poll_init(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		goto err_fbhelper;
+
+	return 0;
+
+err_fbhelper:
+	drm_kms_helper_poll_fini(drm);
+	if (imxdrm->fbhelper)
+		drm_fbdev_cma_fini(imxdrm->fbhelper);
+err_unbind:
+	component_unbind_all(drm->dev, drm);
+err_vblank:
+	drm_vblank_cleanup(drm);
+err_kms:
+	drm_mode_config_cleanup(drm);
+err_unref:
+	drm_dev_unref(drm);
+
+	return ret;
 }
 
 static void imx_drm_unbind(struct device *dev)
 {
-	drm_put_dev(dev_get_drvdata(dev));
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct imx_drm_device *imxdrm = drm->dev_private;
+
+	drm_dev_unregister(drm);
+
+	drm_kms_helper_poll_fini(drm);
+
+	if (imxdrm->fbhelper)
+		drm_fbdev_cma_fini(imxdrm->fbhelper);
+
+	component_unbind_all(drm->dev, drm);
+	dev_set_drvdata(dev, NULL);
+
+	drm_mode_config_cleanup(drm);
+
+	drm_dev_unref(drm);
 }
 
 static const struct component_master_ops imx_drm_ops = {

commit 1780999ced6df8ce833232852dc6854a388fc248
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Aug 26 15:30:44 2016 +0800

    drm/imx: Add active plane reconfiguration support
    
    We don't support configuring active plane on-the-fly for imx-drm.
    The relevant CRTC should be disabled before the plane configuration.
    Of course, the plane itself should be disabled as well.
    
    This patch adds active plane reconfiguration support by forcing CRTC
    mode change in plane's ->atomic_check callback so that the CRTC
    will be disabled before the plane configuration.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 99fff6c7bb4a..75f35eaffb78 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -146,10 +146,34 @@ static void imx_drm_output_poll_changed(struct drm_device *drm)
 	drm_fbdev_cma_hotplug_event(imxdrm->fbhelper);
 }
 
+static int imx_drm_atomic_check(struct drm_device *dev,
+				struct drm_atomic_state *state)
+{
+	int ret;
+
+	ret = drm_atomic_helper_check_modeset(dev, state);
+	if (ret)
+		return ret;
+
+	ret = drm_atomic_helper_check_planes(dev, state);
+	if (ret)
+		return ret;
+
+	/*
+	 * Check modeset again in case crtc_state->mode_changed is
+	 * updated in plane's ->atomic_check callback.
+	 */
+	ret = drm_atomic_helper_check_modeset(dev, state);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_fb_cma_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
-	.atomic_check = drm_atomic_helper_check,
+	.atomic_check = imx_drm_atomic_check,
 	.atomic_commit = drm_atomic_helper_commit,
 };
 

commit 5f4df0c769a9c3cc731464112ddeb0e61c9386d8
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Aug 26 15:30:43 2016 +0800

    drm/imx: Use DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET flag
    
    The IPUv3 display controller behind imx-drm needs all planes of
    a CRTC be disabled when the CRTC is disabled.
    The DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET flag reflects this
    hardware requirement.  Let's use the flag for imx-drm.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 56dfc4cd50c6..99fff6c7bb4a 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -194,7 +194,8 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 	drm_atomic_helper_commit_modeset_disables(dev, state);
 
 	drm_atomic_helper_commit_planes(dev, state,
-					DRM_PLANE_COMMIT_ACTIVE_ONLY);
+				DRM_PLANE_COMMIT_ACTIVE_ONLY |
+				DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET);
 
 	drm_atomic_helper_commit_modeset_enables(dev, state);
 

commit 2b58e98d42af854037439f51bd89f83dbfa8e30d
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Mon Aug 29 17:12:03 2016 +0800

    drm/atomic-helper: Add NO_DISABLE_AFTER_MODESET flag support for plane commit
    
    Drivers may set the NO_DISABLE_AFTER_MODESET flag in the 'flags' parameter
    of the helper drm_atomic_helper_commit_planes() if the relevant display
    controllers(e.g., IPUv3 for imx-drm) require to disable a CRTC's planes
    when the CRTC is disabled. The helper would skip the ->atomic_disable
    call for a plane if the CRTC of the old plane state needs a modesetting
    operation. Of course, the drivers need to disable the planes in their CRTC
    disable callbacks since no one else would do that.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1472461923-14364-1-git-send-email-gnuiyl@gmail.com

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 438bac8fbc2b..56dfc4cd50c6 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -193,7 +193,8 @@ static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
 
 	drm_atomic_helper_commit_modeset_disables(dev, state);
 
-	drm_atomic_helper_commit_planes(dev, state, true);
+	drm_atomic_helper_commit_planes(dev, state,
+					DRM_PLANE_COMMIT_ACTIVE_ONLY);
 
 	drm_atomic_helper_commit_modeset_enables(dev, state);
 

commit f8725ad1da5182aea9b08c8ef300e83bac74f756
Merge: a02b5a155e21 3590d50e2313
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 15 16:46:36 2016 +1000

    Merge tag 'topic/drm-misc-2016-08-12' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - more fence destaging and cleanup (Gustavo&Sumit)
    - DRIVER_LEGACY to untangle from DRIVER_MODESET
    - drm_mm refactor (Chris)
    - fbdev-less compile fies
    - clipped plane src/dst rects (Ville)
    - + a few mediatek patches that build on top of that (Bibby+Daniel)
    - small stuff all over really
    
    * tag 'topic/drm-misc-2016-08-12' of git://anongit.freedesktop.org/drm-intel: (43 commits)
      dma-buf/fence: kerneldoc: remove spurious section header
      dma-buf/fence: kerneldoc: remove unused struct members
      Revert "gpu: drm: omapdrm: dss-of: add missing of_node_put after calling of_parse_phandle"
      drm: Protect fb_defio in drivers with CONFIG_KMS_FBDEV_EMULATION
      drm/radeon|amgpu: Make fbdev emulation optional
      drm/vmwgfx: select CONFIG_FB
      drm: Remove superflous linux/fb.h includes
      drm/fb-helper: Add a dummy remove_conflicting_framebuffers
      dma-buf/sync_file: only enable fence signalling on poll()
      Documentation: add doc for sync_file_get_fence()
      dma-buf/sync_file: add sync_file_get_fence()
      dma-buf/sync_file: refactor fence storage in struct sync_file
      dma-buf/fence-array: add fence_is_array()
      drm/dp_helper: Rate limit timeout errors from drm_dp_i2c_do_msg()
      drm/dp_helper: Print first error received on failure in drm_dp_dpcd_access()
      drm: Add ratelimited versions of the DRM_DEBUG* macros
      drm: Make sure drm_vblank_no_hw_counter isn't abused
      drm/mediatek: Fix mtk_atomic_complete for runtime_pm
      drm/mediatek: plane: Use FB's format's cpp to compute x offset
      drm/mediatek: plane: Merge mtk_plane_enable into mtk_plane_atomic_update
      ...

commit b1116f645cb548fb73995509c210e24ab7782eb5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 10 18:52:35 2016 +0200

    drm: Remove superflous linux/fb.h includes
    
    Everyone who uses the fbdev emulation helpers doesn't need to include
    fb.h directly. Remove it.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470847958-28465-3-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9f7dafce3a4c..0f579206489a 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -16,7 +16,6 @@
 #include <linux/component.h>
 #include <linux/device.h>
 #include <linux/dma-buf.h>
-#include <linux/fb.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/reservation.h>

commit 3ec2e506f98f8464798d11217617421368711e34
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Jul 29 14:00:21 2016 +0800

    drm/imx: Remove imx_drm_handle_vblank()
    
    imx_drm_handle_vblank() is just a simple wrapper of drm_crtc_handle_vblank()
    without doing any thing fancy - drm_crtc_handle_vblank() can be called
    directly.  So, let's remove the wrapper.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 1aefced3a81e..6dc0ef4cc677 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -84,12 +84,6 @@ static int imx_drm_driver_unload(struct drm_device *drm)
 	return 0;
 }
 
-void imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)
-{
-	drm_crtc_handle_vblank(imx_drm_crtc->crtc);
-}
-EXPORT_SYMBOL_GPL(imx_drm_handle_vblank);
-
 static int imx_drm_enable_vblank(struct drm_device *drm, unsigned int pipe)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;

commit 8892cc899e15fb896231539c902b813c3f7ab915
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Mon Jul 18 15:44:24 2016 +0800

    drm/imx: Remove imx_drm_crtc_id()
    
    There is no one calling imx_drm_crtc_id() and it is just a simple
    wrapper of drm_crtc_index() without doing any thing fancy - the
    drivers may call drm_crtc_index() directly.  So, let's remove the
    wrapper.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 1fd1900d1b27..1aefced3a81e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -58,12 +58,6 @@ static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
 #endif
 
-unsigned int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
-{
-	return drm_crtc_index(crtc->crtc);
-}
-EXPORT_SYMBOL_GPL(imx_drm_crtc_id);
-
 static void imx_drm_driver_lastclose(struct drm_device *drm)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;

commit 2fd911bc5b5e647902fd319cbf8c75f98555e188
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Mon Jul 18 15:44:23 2016 +0800

    drm/imx: Remove imx_drm_crtc_vblank_get/_put()
    
    There is no one calling imx_drm_crtc_vblank_get/_put() and
    they are just two simple wrappers of drm_crtc_vblank_get/_put()
    without doing any thing fancy - the drivers may call
    drm_crtc_vblank_get/_put() directly.  So, let's remove the two
    wrappers.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9f7dafce3a4c..1fd1900d1b27 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -90,18 +90,6 @@ static int imx_drm_driver_unload(struct drm_device *drm)
 	return 0;
 }
 
-int imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)
-{
-	return drm_crtc_vblank_get(imx_drm_crtc->crtc);
-}
-EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_get);
-
-void imx_drm_crtc_vblank_put(struct imx_drm_crtc *imx_drm_crtc)
-{
-	drm_crtc_vblank_put(imx_drm_crtc->crtc);
-}
-EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_put);
-
 void imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)
 {
 	drm_crtc_handle_vblank(imx_drm_crtc->crtc);

commit 8535c0220e0541eeaf5c2feb0d9daacf35fc29b3
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Jul 8 17:41:02 2016 +0800

    drm/imx: atomic phase 3 step 3: Advertise DRIVER_ATOMIC
    
    With all the beforehand phases and steps done, we can adverstise DRIVER_ATOMIC.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f14ad2bbc1d7..9f7dafce3a4c 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -428,7 +428,8 @@ static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 };
 
 static struct drm_driver imx_drm_driver = {
-	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME,
+	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME |
+				  DRIVER_ATOMIC,
 	.load			= imx_drm_driver_load,
 	.unload			= imx_drm_driver_unload,
 	.lastclose		= imx_drm_driver_lastclose,

commit 5f2f911578fb13b0110e125d43775f08cf1dd281
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Jul 8 17:40:59 2016 +0800

    drm/imx: atomic phase 3 step 1: Use atomic configuration
    
    Replacing drm_crtc_helper_set_config() by drm_atomic_helper_set_config()
    and converting the suspend/resume operations to atomic make us be able
    to use atomic configurations.  All of these allow us to remove the
    crtc_funcs->mode_set callback as it is no longer used.  Also, change
    the plane_funcs->update/disable_plane callbacks from the transitional
    version to the atomic version.  Furthermore, switching to the pure atomic
    version of set_config callback means that we may implement CRTC/plane
    atomic checks by using the new CRTC/plane states instead of the legacy
    ones and we may remove the private ipu_crtc->enabled state which was left
    there for the transitional atomic helpers in phase 1.  Page flip is also
    switched to the atomic version.  Last, the legacy function
    drm_helper_disable_unused_functions() is removed from ->load in order
    not to confuse the atomic driver.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index f6e44c220874..f14ad2bbc1d7 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -15,10 +15,14 @@
  */
 #include <linux/component.h>
 #include <linux/device.h>
+#include <linux/dma-buf.h>
 #include <linux/fb.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/reservation.h>
 #include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_gem_cma_helper.h>
@@ -41,6 +45,7 @@ struct imx_drm_device {
 	struct imx_drm_crtc			*crtc[MAX_CRTC];
 	unsigned int				pipes;
 	struct drm_fbdev_cma			*fbhelper;
+	struct drm_atomic_state			*state;
 };
 
 struct imx_drm_crtc {
@@ -169,6 +174,63 @@ static void imx_drm_output_poll_changed(struct drm_device *drm)
 static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_fb_cma_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
+{
+	struct drm_device *dev = state->dev;
+	struct drm_crtc *crtc;
+	struct drm_crtc_state *crtc_state;
+	struct drm_plane_state *plane_state;
+	struct drm_gem_cma_object *cma_obj;
+	struct fence *excl;
+	unsigned shared_count;
+	struct fence **shared;
+	unsigned int i, j;
+	int ret;
+
+	/* Wait for fences. */
+	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+		plane_state = crtc->primary->state;
+		if (plane_state->fb) {
+			cma_obj = drm_fb_cma_get_gem_obj(plane_state->fb, 0);
+			if (cma_obj->base.dma_buf) {
+				ret = reservation_object_get_fences_rcu(
+					cma_obj->base.dma_buf->resv, &excl,
+					&shared_count, &shared);
+				if (unlikely(ret))
+					DRM_ERROR("failed to get fences "
+						  "for buffer\n");
+
+				if (excl) {
+					fence_wait(excl, false);
+					fence_put(excl);
+				}
+				for (j = 0; j < shared_count; i++) {
+					fence_wait(shared[j], false);
+					fence_put(shared[j]);
+				}
+			}
+		}
+	}
+
+	drm_atomic_helper_commit_modeset_disables(dev, state);
+
+	drm_atomic_helper_commit_planes(dev, state, true);
+
+	drm_atomic_helper_commit_modeset_enables(dev, state);
+
+	drm_atomic_helper_commit_hw_done(state);
+
+	drm_atomic_helper_wait_for_vblanks(dev, state);
+
+	drm_atomic_helper_cleanup_planes(dev, state);
+}
+
+static struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
+	.atomic_commit_tail = imx_drm_atomic_commit_tail,
 };
 
 /*
@@ -210,6 +272,7 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 	drm->mode_config.max_width = 4096;
 	drm->mode_config.max_height = 4096;
 	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
+	drm->mode_config.helper_private = &imx_drm_mode_config_helpers;
 
 	drm_mode_config_init(drm);
 
@@ -252,7 +315,6 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
-	drm_helper_disable_unused_functions(drm);
 	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
 				drm->mode_config.num_crtc, MAX_CRTC);
 	if (IS_ERR(imxdrm->fbhelper)) {
@@ -454,6 +516,7 @@ static int imx_drm_platform_remove(struct platform_device *pdev)
 static int imx_drm_suspend(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	struct imx_drm_device *imxdrm;
 
 	/* The drm_dev is NULL before .load hook is called */
 	if (drm_dev == NULL)
@@ -461,17 +524,26 @@ static int imx_drm_suspend(struct device *dev)
 
 	drm_kms_helper_poll_disable(drm_dev);
 
+	imxdrm = drm_dev->dev_private;
+	imxdrm->state = drm_atomic_helper_suspend(drm_dev);
+	if (IS_ERR(imxdrm->state)) {
+		drm_kms_helper_poll_enable(drm_dev);
+		return PTR_ERR(imxdrm->state);
+	}
+
 	return 0;
 }
 
 static int imx_drm_resume(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	struct imx_drm_device *imx_drm;
 
 	if (drm_dev == NULL)
 		return 0;
 
-	drm_helper_resume_force_mode(drm_dev);
+	imx_drm = drm_dev->dev_private;
+	drm_atomic_helper_resume(drm_dev, imx_drm->state);
 	drm_kms_helper_poll_enable(drm_dev);
 
 	return 0;

commit 032003c5cd744e8e0baf5430fc5b3fd5462208e4
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Jul 8 17:40:58 2016 +0800

    drm/imx: Remove encoders' ->prepare callbacks
    
    The main task of imx encoders' ->prepare callbacks is to set bus_format,
    bus_flags, di_vsync_pin and di_hsync_pin.  We may create a structure named
    imx_encoder to cache them.  The atomic encoder callback ->disable may
    replace ->prepare later, so let's remove ->prepare.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index b5a5173b05af..f6e44c220874 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -85,45 +85,6 @@ static int imx_drm_driver_unload(struct drm_device *drm)
 	return 0;
 }
 
-static struct imx_drm_crtc *imx_drm_find_crtc(struct drm_crtc *crtc)
-{
-	struct imx_drm_device *imxdrm = crtc->dev->dev_private;
-	unsigned i;
-
-	for (i = 0; i < MAX_CRTC; i++)
-		if (imxdrm->crtc[i] && imxdrm->crtc[i]->crtc == crtc)
-			return imxdrm->crtc[i];
-
-	return NULL;
-}
-
-int imx_drm_set_bus_config(struct drm_encoder *encoder, u32 bus_format,
-		int hsync_pin, int vsync_pin, u32 bus_flags)
-{
-	struct imx_drm_crtc_helper_funcs *helper;
-	struct imx_drm_crtc *imx_crtc;
-
-	imx_crtc = imx_drm_find_crtc(encoder->crtc);
-	if (!imx_crtc)
-		return -EINVAL;
-
-	helper = &imx_crtc->imx_drm_helper_funcs;
-	if (helper->set_interface_pix_fmt)
-		return helper->set_interface_pix_fmt(encoder->crtc,
-					bus_format, hsync_pin, vsync_pin,
-					bus_flags);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(imx_drm_set_bus_config);
-
-int imx_drm_set_bus_format(struct drm_encoder *encoder, u32 bus_format)
-{
-	return imx_drm_set_bus_config(encoder, bus_format, 2, 3,
-				      DRM_BUS_FLAG_DE_HIGH |
-				      DRM_BUS_FLAG_PIXDATA_NEGEDGE);
-}
-EXPORT_SYMBOL_GPL(imx_drm_set_bus_format);
-
 int imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)
 {
 	return drm_crtc_vblank_get(imx_drm_crtc->crtc);

commit 255c35f8fe6a9c345320e512c681c03678f3e0b4
Author: Liu Ying <gnuiyl@gmail.com>
Date:   Fri Jul 8 17:40:56 2016 +0800

    drm/imx: atomic phase 2 step 1: Wire up state ->reset, ->duplicate and ->destroy
    
    Wire up CRTCs', planes' and connectors' ->reset, ->duplicate and ->destroy state
    hooks to use the default implementations from the atomic helper library.
    The helpers track each DRM object state.
    
    Signed-off-by: Liu Ying <gnuiyl@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 7746418a4c08..b5a5173b05af 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -279,6 +279,8 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 		}
 	}
 
+	drm_mode_config_reset(drm);
+
 	/*
 	 * All components are now initialised, so setup the fb helper.
 	 * The fb helper takes copies of key hardware information, so the

commit a325725633c26aa66ab940f762a6b0778edf76c0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jun 21 14:08:33 2016 +0200

    drm: Lobotomize set_busid nonsense for !pci drivers
    
    We already have a fallback in place to fill out the unique from
    dev->unique, which is set to something reasonable in drm_dev_alloc.
    
    Which means we only need to have a special set_busid for pci devices,
    to be able to care the backwards compat code for drm 1.1 around, which
    libdrm still needs.
    
    While developing and testing this patch things blew up in really
    interesting ways, and the code is rather confusing in naming things
    between the kernel code, ioctl #defines and libdrm. For the next brave
    dragon slayer, document all this madness properly in the userspace
    interface section of gpu.tmpl.
    
    v2: Make drm_dev_set_unique static and update kerneldoc.
    
    v3: Entire rewrite, plus document what's going on for posterity in the
    gpu docbook uapi section.
    
    v4: Drop accidental amdgpu hunk (Emil).
    
    v5: Drop accidental omapdrm vblank counter change (Emil).
    
    v6: Rebase on top of the sphinx conversion.
    
    Cc: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk> (virt_gpu)
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 82656654fb21..7746418a4c08 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -407,7 +407,6 @@ static struct drm_driver imx_drm_driver = {
 	.load			= imx_drm_driver_load,
 	.unload			= imx_drm_driver_unload,
 	.lastclose		= imx_drm_driver_lastclose,
-	.set_busid		= drm_platform_set_busid,
 	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,

commit 4ed094fd73a7c0b8534685d2ed0f0f3ccdb96bdf
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon May 9 17:02:13 2016 +0200

    drm/imx: use bus_flags for pixel clock polarity
    
    This patch allows panels to set pixel clock and data enable pin polarity
    other than the default of driving data at the falling pixel clock edge
    and active high display enable.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 1f14b602882b..82656654fb21 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -97,8 +97,8 @@ static struct imx_drm_crtc *imx_drm_find_crtc(struct drm_crtc *crtc)
 	return NULL;
 }
 
-int imx_drm_set_bus_format_pins(struct drm_encoder *encoder, u32 bus_format,
-		int hsync_pin, int vsync_pin)
+int imx_drm_set_bus_config(struct drm_encoder *encoder, u32 bus_format,
+		int hsync_pin, int vsync_pin, u32 bus_flags)
 {
 	struct imx_drm_crtc_helper_funcs *helper;
 	struct imx_drm_crtc *imx_crtc;
@@ -110,14 +110,17 @@ int imx_drm_set_bus_format_pins(struct drm_encoder *encoder, u32 bus_format,
 	helper = &imx_crtc->imx_drm_helper_funcs;
 	if (helper->set_interface_pix_fmt)
 		return helper->set_interface_pix_fmt(encoder->crtc,
-					bus_format, hsync_pin, vsync_pin);
+					bus_format, hsync_pin, vsync_pin,
+					bus_flags);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(imx_drm_set_bus_format_pins);
+EXPORT_SYMBOL_GPL(imx_drm_set_bus_config);
 
 int imx_drm_set_bus_format(struct drm_encoder *encoder, u32 bus_format)
 {
-	return imx_drm_set_bus_format_pins(encoder, bus_format, 2, 3);
+	return imx_drm_set_bus_config(encoder, bus_format, 2, 3,
+				      DRM_BUS_FLAG_DE_HIGH |
+				      DRM_BUS_FLAG_PIXDATA_NEGEDGE);
 }
 EXPORT_SYMBOL_GPL(imx_drm_set_bus_format);
 

commit e411295e3ec0b470795a860ec3cc51edf64407c4
Merge: 92181d47ee74 310944d148e3
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 25 12:36:20 2016 +1000

    Merge tag 'imx-drm-fixes-2016-05-24' of git://git.pengutronix.de/git/pza/linux into drm-next
    
    imx-drm probing fix
    
    Commit 950b410dd1ab ("gpu: ipu-v3: Fix imx-ipuv3-crtc module autoloading")
    broke probing of the imx-drm driver in the non-modular case because the
    unset dev->of_node during probing of imx-ipuv3-crtc would cause the
    component matching to fail. This patch patch instead matches against
    an of_node pointer stored in platform data, allowing dev->of_node to
    be left unset for the platform probed imx-ipuv3-crtc devices.
    
    * tag 'imx-drm-fixes-2016-05-24' of git://git.pengutronix.de/git/pza/linux:
      drm/imx: Match imx-ipuv3-crtc components using device node in platform data

commit 310944d148e3600dcff8b346bee7fa01d34903b1
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu May 12 15:00:44 2016 +0200

    drm/imx: Match imx-ipuv3-crtc components using device node in platform data
    
    The component master driver imx-drm-core matches component devices using
    their of_node. Since commit 950b410dd1ab ("gpu: ipu-v3: Fix imx-ipuv3-crtc
    module autoloading"), the imx-ipuv3-crtc dev->of_node is not set during
    probing. Before that, of_node was set and caused an of: modalias to be
    used instead of the platform: modalias, which broke module autoloading.
    
    On the other hand, if dev->of_node is not set yet when the imx-ipuv3-crtc
    probe function calls component_add, component matching in imx-drm-core
    fails. While dev->of_node will be set once the next component tries to
    bring up the component master, imx-drm-core component binding will never
    succeed if one of the crtc devices is probed last.
    
    Add of_node to the component platform data and match against the
    pdata->of_node instead of dev->of_node in imx-drm-core to work around
    this problem.
    
    Cc: <stable@vger.kernel.org> # 4.4.x
    Fixes: 950b410dd1ab ("gpu: ipu-v3: Fix imx-ipuv3-crtc module autoloading")
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Tested-by: Lothar Waßmann <LW@KARO-electronics.de>
    Tested-by: Heiko Schocher <hs@denx.de>
    Tested-by: Chris Ruehl <chris.ruehl@gtsys.com.hk>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index e26dcdec2aba..05229b960e0c 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -25,6 +25,7 @@
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_of.h>
+#include <video/imx-ipu-v3.h>
 
 #include "imx-drm.h"
 
@@ -444,6 +445,13 @@ static int compare_of(struct device *dev, void *data)
 {
 	struct device_node *np = data;
 
+	/* Special case for DI, dev->of_node may not be set yet */
+	if (strcmp(dev->driver->name, "imx-ipuv3-crtc") == 0) {
+		struct ipu_client_platformdata *pdata = dev->platform_data;
+
+		return pdata->of_node == np;
+	}
+
 	/* Special case for LDB, one device for two channels */
 	if (of_node_cmp(np->name, "lvds-channel") == 0) {
 		np = of_get_parent(np);

commit fcee59065e58498682c60069cc6fb90694bab27e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 18 21:47:38 2016 +0200

    drm: Nuke ->vblank_disable_allowed
    
    This was added in
    
    commit 0a3e67a4caac273a3bfc4ced3da364830b1ab241
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Tue Sep 30 12:14:26 2008 -0700
    
        drm: Rework vblank-wait handling to allow interrupt reduction.
    
    to stay backwards-compatible with old UMS code that didn't even tell
    the kernel when it did a modeset, so that the kernel could
    save/restore vblank counters. At worst this means vblanks will be
    somewhat funky on a setup that very likely no one still runs.
    
    So let's just nuke it.
    
    Plan B would be to set it unconditionally in drm_vblank_init for kms
    drivers, instead of in each driver separately. So if this patch breaks
    anything please only restore the hunks in drmP.h and drm_irq.c, plus
    add a check for DRIVER_MODESET in drm_vblank_init.
    
    Stumbled over this in a discussion on irc with Chris.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 2453fb1c68a7..1080019e7b17 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -252,13 +252,6 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 	if (ret)
 		goto err_kms;
 
-	/*
-	 * with vblank_disable_allowed = true, vblank interrupt will be
-	 * disabled by drm timer once a current process gives up ownership
-	 * of vblank event. (after drm_vblank_put function is called)
-	 */
-	drm->vblank_disable_allowed = true;
-
 	platform_set_drvdata(drm->platformdev, drm);
 
 	/* Now try and bind all our sub-components */

commit 4b193663dbc915a1f9c61d1785d3f0b4d98cfafd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 26 19:29:52 2016 +0200

    drm/imx: Use lockless gem BO free callback
    
    No dev->struct_mutex anywhere to be seen.
    
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461691808-12414-20-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index e26dcdec2aba..2453fb1c68a7 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -411,7 +411,7 @@ static struct drm_driver imx_drm_driver = {
 	.unload			= imx_drm_driver_unload,
 	.lastclose		= imx_drm_driver_lastclose,
 	.set_busid		= drm_platform_set_busid,
-	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_free_object_unlocked = drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,
 	.dumb_create		= drm_gem_cma_dumb_create,
 	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,

commit e51f17a049d102a3bc9af3e43f2f45b0538da871
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 11:51:23 2016 +0200

    drm/imx: Don't set a gamma table size
    
    imx doesn't have any functions for setting the gamma table, so this is
    completely defunct.
    
    Not nice to lie to userspace, so let's stop!
    
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9876e0f0c3e1..e26dcdec2aba 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -326,7 +326,6 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;
 	struct imx_drm_crtc *imx_drm_crtc;
-	int ret;
 
 	/*
 	 * The vblank arrays are dimensioned by MAX_CRTC - we can't
@@ -351,10 +350,6 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 
 	*new_crtc = imx_drm_crtc;
 
-	ret = drm_mode_crtc_set_gamma_size(imx_drm_crtc->crtc, 256);
-	if (ret)
-		goto err_register;
-
 	drm_crtc_helper_add(crtc,
 			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);
 
@@ -362,11 +357,6 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs, NULL);
 
 	return 0;
-
-err_register:
-	imxdrm->crtc[--imxdrm->pipes] = NULL;
-	kfree(imx_drm_crtc);
-	return ret;
 }
 EXPORT_SYMBOL_GPL(imx_drm_add_crtc);
 

commit 53141e42cfab7c7910688bbcee813acf4b478f5b
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Feb 24 11:41:28 2015 +0100

    drm/imx: remove imx_drm_encoder_get_mux_id
    
    It is replaced by drm_of_encoder_active_port_id.
    
    Suggested-by: Daniel Kurtz <djkurtz@chromium.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 7c4d1250e071..9876e0f0c3e1 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -17,7 +17,6 @@
 #include <linux/device.h>
 #include <linux/fb.h>
 #include <linux/module.h>
-#include <linux/of_graph.h>
 #include <linux/platform_device.h>
 #include <drm/drmP.h>
 #include <drm/drm_fb_helper.h>
@@ -412,36 +411,6 @@ int imx_drm_encoder_parse_of(struct drm_device *drm,
 }
 EXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);
 
-/*
- * @node: device tree node containing encoder input ports
- * @encoder: drm_encoder
- */
-int imx_drm_encoder_get_mux_id(struct device_node *node,
-			       struct drm_encoder *encoder)
-{
-	struct imx_drm_crtc *imx_crtc = imx_drm_find_crtc(encoder->crtc);
-	struct device_node *ep;
-	struct of_endpoint endpoint;
-	struct device_node *port;
-	int ret;
-
-	if (!node || !imx_crtc)
-		return -EINVAL;
-
-	for_each_endpoint_of_node(node, ep) {
-		port = of_graph_get_remote_port(ep);
-		of_node_put(port);
-		if (port == imx_crtc->crtc->port) {
-			ret = of_graph_parse_endpoint(ep, &endpoint);
-			of_node_put(ep);
-			return ret ? ret : endpoint.port;
-		}
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(imx_drm_encoder_get_mux_id);
-
 static const struct drm_ioctl_desc imx_drm_ioctls[] = {
 	/* none so far */
 };

commit 4eced321bf3d2f45b9dd221ba806a9b3c7d3a67a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jan 25 22:16:48 2016 +0100

    drm/imx: Unconfuse preclose logic
    
    So this one is special, since it tries to prevent races when userspace
    crashes simply by disabling the vblank machinery. Well except that imx
    always has vblanks enabled, and the disable_vblank hook actually just
    tries to cancel a pending pageflip. Without any locking whatsoever. Of
    course this is wrong, since it'll result in the hw not actually
    displaying what drm thinks is the current frontbuffer.
    
    Well since the core takes care of the disappearing DRM fd now. So we
    can nuke all this confused code without ill side-effects.
    
    Someone else needs to audit the locking for ->newfb and
    ->page_flip_event and fix it up. Common approach is to reuse
    dev->event_lock for this.
    
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453756616-28942-7-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 2f57d7967417..7c4d1250e071 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -171,18 +171,6 @@ static void imx_drm_disable_vblank(struct drm_device *drm, unsigned int pipe)
 	imx_drm_crtc->imx_drm_helper_funcs.disable_vblank(imx_drm_crtc->crtc);
 }
 
-static void imx_drm_driver_preclose(struct drm_device *drm,
-		struct drm_file *file)
-{
-	int i;
-
-	if (!file->is_master)
-		return;
-
-	for (i = 0; i < MAX_CRTC; i++)
-		imx_drm_disable_vblank(drm, i);
-}
-
 static const struct file_operations imx_drm_driver_fops = {
 	.owner = THIS_MODULE,
 	.open = drm_open,
@@ -463,7 +451,6 @@ static struct drm_driver imx_drm_driver = {
 	.load			= imx_drm_driver_load,
 	.unload			= imx_drm_driver_unload,
 	.lastclose		= imx_drm_driver_lastclose,
-	.preclose		= imx_drm_driver_preclose,
 	.set_busid		= drm_platform_set_busid,
 	.gem_free_object	= drm_gem_cma_free_object,
 	.gem_vm_ops		= &drm_gem_cma_vm_ops,

commit 4314e19ef4ae0ba8872bd8610f6fef5e8743e236
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Jan 14 16:24:56 2016 +0100

    drm/fb_cma_helper: Remove implicit call to disable_unused_functions
    
    The drm_fbdev_cma_init function always calls the
    drm_helper_disable_unused_functions. Since it's part of the usual probe
    process, all the drivers using that helper will end up having their encoder
    and CRTC disable functions called at probe if their device has not been
    reported as enabled.
    
    This could be fixed by reading out from the registers the current state of
    the device if it is enabled, but even that will not handle the case where
    the device is actually disabled.
    
    Moreover, the drivers using the atomic modesetting expect that their enable
    and disable callback to be called when the device is already enabled or
    disabled (respectively).
    
    We can however fix this issue by moving the call to
    drm_helper_disable_unused_functions out of drm_fbdev_cma_init and make the
    drivers needing it (all the drivers calling drm_fbdev_cma_init and not
    using the atomic modesetting) explicitly call it.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452785109-6172-14-git-send-email-maxime.ripard@free-electrons.com
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 7be7ac808304..2f57d7967417 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -305,6 +305,7 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
+	drm_helper_disable_unused_functions(drm);
 	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
 				drm->mode_config.num_crtc, MAX_CRTC);
 	if (IS_ERR(imxdrm->fbhelper)) {

commit 7ae847dd379af68d4887d9a2e0b9d0de227662e1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 15 12:21:09 2015 +0100

    drm/imx: Constify function pointer structs
    
    Moves a bunch of junk to .rodata from .data.
    
     drivers/gpu/drm/imx/imxdrm.ko:
    -.rodata                      624
    +.rodata                      652
    -.data                        372
    +.data                        344
    
     drivers/gpu/drm/imx/imx-ipuv3-crtc.ko:
    -.rodata                      224
    +.rodata                      280
    -.data                        184
    +.data                        128
    
     drivers/gpu/drm/imx/imx-ldb.ko:
    -.rodata                      660
    +.rodata                      784
    -.data                        240
    +.data                        116
    
     drivers/gpu/drm/imx/imx-tve.ko:
    -.rodata                      400
    +.rodata                      524
    -.data                        416
    +.data                        292
    
     drivers/gpu/drm/imx/parallel-display.ko:
    -.rodata                      400
    +.rodata                      524
    -.data                        216
    +.data                         92
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450178476-26284-22-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 303a6737b87e..7be7ac808304 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -214,7 +214,7 @@ static void imx_drm_output_poll_changed(struct drm_device *drm)
 	drm_fbdev_cma_hotplug_event(imxdrm->fbhelper);
 }
 
-static struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
+static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
 	.fb_create = drm_fb_cma_create,
 	.output_poll_changed = imx_drm_output_poll_changed,
 };

commit d4b20e4dcbb3bb08362c55b2f9183588a4a3af33
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Dec 15 12:20:52 2015 +0100

    drm/imx: Drop pipe field from struct imx_drm_crtc
    
    Use the drm_crtc_index() helper to determine the pipe number of the CRTC
    instead.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450178476-26284-5-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9211473f62a1..303a6737b87e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -45,7 +45,6 @@ struct imx_drm_device {
 
 struct imx_drm_crtc {
 	struct drm_crtc				*crtc;
-	unsigned int				pipe;
 	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
 };
 
@@ -56,7 +55,7 @@ module_param(legacyfb_depth, int, 0444);
 
 unsigned int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
 {
-	return crtc->pipe;
+	return drm_crtc_index(crtc->crtc);
 }
 EXPORT_SYMBOL_GPL(imx_drm_crtc_id);
 
@@ -124,19 +123,19 @@ EXPORT_SYMBOL_GPL(imx_drm_set_bus_format);
 
 int imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)
 {
-	return drm_vblank_get(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+	return drm_crtc_vblank_get(imx_drm_crtc->crtc);
 }
 EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_get);
 
 void imx_drm_crtc_vblank_put(struct imx_drm_crtc *imx_drm_crtc)
 {
-	drm_vblank_put(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+	drm_crtc_vblank_put(imx_drm_crtc->crtc);
 }
 EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_put);
 
 void imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)
 {
-	drm_handle_vblank(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+	drm_crtc_handle_vblank(imx_drm_crtc->crtc);
 }
 EXPORT_SYMBOL_GPL(imx_drm_handle_vblank);
 
@@ -356,12 +355,11 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 		return -ENOMEM;
 
 	imx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;
-	imx_drm_crtc->pipe = imxdrm->pipes++;
 	imx_drm_crtc->crtc = crtc;
 
 	crtc->port = port;
 
-	imxdrm->crtc[imx_drm_crtc->pipe] = imx_drm_crtc;
+	imxdrm->crtc[imxdrm->pipes++] = imx_drm_crtc;
 
 	*new_crtc = imx_drm_crtc;
 
@@ -378,7 +376,7 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 	return 0;
 
 err_register:
-	imxdrm->crtc[imx_drm_crtc->pipe] = NULL;
+	imxdrm->crtc[--imxdrm->pipes] = NULL;
 	kfree(imx_drm_crtc);
 	return ret;
 }
@@ -390,10 +388,11 @@ EXPORT_SYMBOL_GPL(imx_drm_add_crtc);
 int imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)
 {
 	struct imx_drm_device *imxdrm = imx_drm_crtc->crtc->dev->dev_private;
+	unsigned int pipe = drm_crtc_index(imx_drm_crtc->crtc);
 
 	drm_crtc_cleanup(imx_drm_crtc->crtc);
 
-	imxdrm->crtc[imx_drm_crtc->pipe] = NULL;
+	imxdrm->crtc[pipe] = NULL;
 
 	kfree(imx_drm_crtc);
 

commit d2ab8ad9713de1bd5e0da187263e35b2eea57e1c
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Dec 15 12:20:51 2015 +0100

    drm/imx: Make pipe number unsigned
    
    There's no reason whatsoever why this should ever be negative. The same
    goes for the number of pipes added to the DRM device.
    
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450178476-26284-4-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 09e20ea69419..9211473f62a1 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -39,13 +39,13 @@ struct imx_drm_component {
 struct imx_drm_device {
 	struct drm_device			*drm;
 	struct imx_drm_crtc			*crtc[MAX_CRTC];
-	int					pipes;
+	unsigned int				pipes;
 	struct drm_fbdev_cma			*fbhelper;
 };
 
 struct imx_drm_crtc {
 	struct drm_crtc				*crtc;
-	int					pipe;
+	unsigned int				pipe;
 	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
 };
 
@@ -54,7 +54,7 @@ static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
 #endif
 
-int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
+unsigned int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
 {
 	return crtc->pipe;
 }

commit f98828769c8838f526703ef180b3088a714af2f9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:19:31 2015 +0200

    drm: Pass 'name' to drm_crtc_init_with_planes()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    I didn't convert drm_crtc_init() since passing the varargs through
    would mean either cpp macros or va_list, and I figured we don't
    care about these legacy functions enough to warrant the extra pain.
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   )
    { ... }
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   );
    
    @@
    expression E1, E2, E3, E4, E5;
    @@
     drm_crtc_init_with_planes(E1, E2, E3, E4, E5
    +                          ,NULL
                               )
    
    v2: Split crtc and plane changes apart
        Pass NULL for no-name instead of ""
        Leave drm_crtc_init() alone
    v3: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670771-2751-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 882cf3d4b7a8..09e20ea69419 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -373,7 +373,7 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);
 
 	drm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,
-			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);
+			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs, NULL);
 
 	return 0;
 

commit e876b41ab074561d65f213bf5e0fc68cf5bc7380
Merge: 47c0fd728221 527e9316f8ec
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 8 11:04:26 2015 +1000

    Back merge tag 'v4.4-rc4' into drm-next
    
    We've picked up a few conflicts and it would be nice
    to resolve them before we move onwards.

commit c1ff5a7aa3c385aea6badd1351cf92b02a65f145
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Oct 27 13:40:57 2015 +0530

    drm/imx: Remove local fbdev emulation Kconfig option
    
    DRM_IMX_FB_HELPER config is currently used to enable/disable fbdev
    emulation for the imx kms driver.
    
    Remove this local config option and use the top level DRM_FBDEV_EMULATION
    config option where applicable. Using this config lets us also prevent
    wrapping around drm_fb_helper_* calls with #ifdefs in certain places.
    
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445933459-5249-2-git-send-email-architt@codeaurora.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 64f16ea779ef..6faa735376ec 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -49,8 +49,10 @@ struct imx_drm_crtc {
 	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
 };
 
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 static int legacyfb_depth = 16;
 module_param(legacyfb_depth, int, 0444);
+#endif
 
 int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
 {
@@ -60,26 +62,20 @@ EXPORT_SYMBOL_GPL(imx_drm_crtc_id);
 
 static void imx_drm_driver_lastclose(struct drm_device *drm)
 {
-#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
 	struct imx_drm_device *imxdrm = drm->dev_private;
 
 	if (imxdrm->fbhelper)
 		drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
-#endif
 }
 
 static int imx_drm_driver_unload(struct drm_device *drm)
 {
-#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
 	struct imx_drm_device *imxdrm = drm->dev_private;
-#endif
 
 	drm_kms_helper_poll_fini(drm);
 
-#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
 	if (imxdrm->fbhelper)
 		drm_fbdev_cma_fini(imxdrm->fbhelper);
-#endif
 
 	component_unbind_all(drm->dev, drm);
 
@@ -215,11 +211,9 @@ EXPORT_SYMBOL_GPL(imx_drm_encoder_destroy);
 
 static void imx_drm_output_poll_changed(struct drm_device *drm)
 {
-#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
 	struct imx_drm_device *imxdrm = drm->dev_private;
 
 	drm_fbdev_cma_hotplug_event(imxdrm->fbhelper);
-#endif
 }
 
 static struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
@@ -308,7 +302,7 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
 	 * The fb helper takes copies of key hardware information, so the
 	 * crtcs/connectors/encoders must not change after this point.
 	 */
-#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+#if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 	if (legacyfb_depth != 16 && legacyfb_depth != 32) {
 		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;

commit 3f3a7280d4cafd28036378198280640dfc6492aa
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Jul 5 22:45:23 2015 +0200

    GPU-DRM-IMX: Delete an unnecessary check before drm_fbdev_cma_restore_mode()
    
    The drm_fbdev_cma_restore_mode() function tests whether its argument
    is NULL and then returns immediately.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 7b00ab8084a8..7b990b4e96d2 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -63,8 +63,7 @@ static void imx_drm_driver_lastclose(struct drm_device *drm)
 #if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
 	struct imx_drm_device *imxdrm = drm->dev_private;
 
-	if (imxdrm->fbhelper)
-		drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
+	drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
 #endif
 }
 

commit 4389559980599ad99f39a004d6e9aaf9c2180ab8
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Nov 6 11:08:02 2015 +0100

    drm/imx: switch to universal planes
    
    Use drm_universal_plane_init to create the planes, create the primary
    plane first and use drm_crtc_init_with_planes to associate it with
    the crtc.
    This gets rid of the unused fallback primary plane previously created
    by drm_crtc_init and fixes a NULL pointer dereference issue that can
    be triggered by a modeset from userspace when fbdev helpers are
    enabled [1].
    
    [1] https://lkml.org/lkml/2015/11/4/107
    
    Reported-by: Liu Ying <Ying.Liu@freescale.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Liu Ying <Ying.Liu@freescale.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 64f16ea779ef..7b00ab8084a8 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -340,7 +340,7 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
  * imx_drm_add_crtc - add a new crtc
  */
 int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
-		struct imx_drm_crtc **new_crtc,
+		struct imx_drm_crtc **new_crtc, struct drm_plane *primary_plane,
 		const struct imx_drm_crtc_helper_funcs *imx_drm_helper_funcs,
 		struct device_node *port)
 {
@@ -379,7 +379,7 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc,
 			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);
 
-	drm_crtc_init(drm, crtc,
+	drm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,
 			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);
 
 	return 0;

commit 9cace32f7e9fb3d506bab2bfda2cafd11e0b5825
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Oct 20 10:23:13 2015 +0100

    drm/imx: Convert the probe function to the generic drm_of_component_probe()
    
    The generic function is functionally equivalent to the driver's
    imx_drm_platform_probe(). Use the generic function and reduce the
    overall code size.
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445332995-11212-3-git-send-email-Liviu.Dudau@arm.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index de00a6c31ab6..64f16ea779ef 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -531,59 +531,12 @@ static const struct component_master_ops imx_drm_ops = {
 
 static int imx_drm_platform_probe(struct platform_device *pdev)
 {
-	struct device_node *ep, *port, *remote;
-	struct component_match *match = NULL;
-	int ret;
-	int i;
-
-	/*
-	 * Bind the IPU display interface ports first, so that
-	 * imx_drm_encoder_parse_of called from encoder .bind callbacks
-	 * works as expected.
-	 */
-	for (i = 0; ; i++) {
-		port = of_parse_phandle(pdev->dev.of_node, "ports", i);
-		if (!port)
-			break;
-
-		component_match_add(&pdev->dev, &match, compare_of, port);
-	}
+	int ret = drm_of_component_probe(&pdev->dev, compare_of, &imx_drm_ops);
 
-	if (i == 0) {
-		dev_err(&pdev->dev, "missing 'ports' property\n");
-		return -ENODEV;
-	}
+	if (!ret)
+		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 
-	/* Then bind all encoders */
-	for (i = 0; ; i++) {
-		port = of_parse_phandle(pdev->dev.of_node, "ports", i);
-		if (!port)
-			break;
-
-		for_each_child_of_node(port, ep) {
-			remote = of_graph_get_remote_port_parent(ep);
-			if (!remote || !of_device_is_available(remote)) {
-				of_node_put(remote);
-				continue;
-			} else if (!of_device_is_available(remote->parent)) {
-				dev_warn(&pdev->dev, "parent device of %s is not available\n",
-					 remote->full_name);
-				of_node_put(remote);
-				continue;
-			}
-
-			component_match_add(&pdev->dev, &match, compare_of,
-					    remote);
-			of_node_put(remote);
-		}
-		of_node_put(port);
-	}
-
-	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
-	if (ret)
-		return ret;
-
-	return component_master_add_with_match(&pdev->dev, &imx_drm_ops, match);
+	return ret;
 }
 
 static int imx_drm_platform_remove(struct platform_device *pdev)

commit b44f84081b8db1b5830cbd30280ba1109cc1a084
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Sep 30 16:46:48 2015 +0300

    drm: Stop using drm_vblank_count() as the hw frame counter
    
    drm_vblank_count() returns the software counter. We should not pretend
    it's the hw counter since we use the hw counter to figuere out what the
    software counter value should be. So instead provide a new function
    drm_vblank_no_hw_counter() for drivers that don't have a real hw
    counter. The new function simply returns 0, which is about the only
    thing it can do.
    
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>
    [danvet: s/int pipe/unsigned int pipe/ to follow Thierry's interface
    change.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index b880c12c6521..de00a6c31ab6 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -487,7 +487,7 @@ static struct drm_driver imx_drm_driver = {
 	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
 	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
 	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
-	.get_vblank_counter	= drm_vblank_count,
+	.get_vblank_counter	= drm_vblank_no_hw_counter,
 	.enable_vblank		= imx_drm_enable_vblank,
 	.disable_vblank		= imx_drm_disable_vblank,
 	.ioctls			= imx_drm_ioctls,

commit 88e72717c2de4181d8a6de1b04315953ad2bebdf
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Sep 24 18:35:31 2015 +0200

    drm/irq: Use unsigned int pipe in public API
    
    This continues the pattern started in commit cc1ef118fc09 ("drm/irq:
    Make pipe unsigned and name consistent"). This is applied to the public
    APIs and driver callbacks, so pretty much all drivers need to be updated
    to match the new prototypes.
    
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Jianwei Wang <jianwei.wang.chn@gmail.com>
    Cc: Alison Wang <alison.wang@freescale.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 74f505b0dd02..b880c12c6521 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -145,10 +145,10 @@ void imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)
 }
 EXPORT_SYMBOL_GPL(imx_drm_handle_vblank);
 
-static int imx_drm_enable_vblank(struct drm_device *drm, int crtc)
+static int imx_drm_enable_vblank(struct drm_device *drm, unsigned int pipe)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];
+	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[pipe];
 	int ret;
 
 	if (!imx_drm_crtc)
@@ -163,10 +163,10 @@ static int imx_drm_enable_vblank(struct drm_device *drm, int crtc)
 	return ret;
 }
 
-static void imx_drm_disable_vblank(struct drm_device *drm, int crtc)
+static void imx_drm_disable_vblank(struct drm_device *drm, unsigned int pipe)
 {
 	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];
+	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[pipe];
 
 	if (!imx_drm_crtc)
 		return;

commit 1d2add28edd268a8290801ccf46b37f6d5239cdb
Merge: bb1dc08c94ea 5e501ed7253b
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Apr 13 17:28:57 2015 +1000

    Merge tag 'imx-drm-next-2015-03-31' of git://git.pengutronix.de/git/pza/linux into drm-next
    
    imx-drm changes to use media bus formats and LDB drm_panel support
    
    - Add media bus formats needed by imx-drm
    - Switch to use media bus formats to describe the pixel format
      on the internal parallel bus between display interface and
      encoders
    - Some preparations for TV Output via TVEv2 on i.MX5
    - Add drm_panel support to the i.MX LVDS driver, allow to
      determine the bus pixel format from the panel descriptor.
    
    * tag 'imx-drm-next-2015-03-31' of git://git.pengutronix.de/git/pza/linux:
      drm/imx: imx-ldb: allow to determine bus format from the connected panel
      drm/imx: imx-ldb: reset display clock input when disabling LVDS
      drm/imx: imx-ldb: add drm_panel support
      drm/imx: consolidate bus format variable names
      drm/imx: switch to use media bus formats
      Add RGB666_1X24_CPADHI media bus format
      Add YUV8_1X24 media bus format
      Add BGR888_1X24 and GBR888_1X24 media bus formats
      Add LVDS RGB media bus formats
      Add RGB444_1X12 and RGB565_1X16 media bus formats
      drm/imx: ipuv3-crtc: Allow to divide DI clock from TVEv2
      drm/imx: Add support for interlaced scanout

commit 539bb6a248858edd99d8645677345799f37ca51d
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu Jul 3 23:07:49 2014 +0200

    drm/imx: use for_each_endpoint_of_node macro in imx_drm_encoder_get_mux_id
    
    Using the for_each_... macro should make the code bit shorter and
    easier to read. This patch also properly decrements the endpoint node
    reference count before returning out of the loop.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 84cf99f8d957..db2f5a739e05 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -439,7 +439,7 @@ int imx_drm_encoder_get_mux_id(struct device_node *node,
 			       struct drm_encoder *encoder)
 {
 	struct imx_drm_crtc *imx_crtc = imx_drm_find_crtc(encoder->crtc);
-	struct device_node *ep = NULL;
+	struct device_node *ep;
 	struct of_endpoint endpoint;
 	struct device_node *port;
 	int ret;
@@ -447,18 +447,15 @@ int imx_drm_encoder_get_mux_id(struct device_node *node,
 	if (!node || !imx_crtc)
 		return -EINVAL;
 
-	do {
-		ep = of_graph_get_next_endpoint(node, ep);
-		if (!ep)
-			break;
-
+	for_each_endpoint_of_node(node, ep) {
 		port = of_graph_get_remote_port(ep);
 		of_node_put(port);
 		if (port == imx_crtc->crtc->port) {
 			ret = of_graph_parse_endpoint(ep, &endpoint);
+			of_node_put(ep);
 			return ret ? ret : endpoint.port;
 		}
-	} while (ep);
+	}
 
 	return -EINVAL;
 }

commit 2872c8072aae65fa55cafea50e73d69d423df168
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Feb 2 17:25:59 2015 +0100

    drm/imx: consolidate bus format variable names
    
    This patch consolidates the different interface_pix_fmt, pixel_fmt, pix_fmt,
    and pixfmt variables to a common name "bus_format" wherever they describe the
    pixel format on the bus between display controller and encoder hardware.
    At the same time, it renames imx_drm_panel_format to imx_drm_set_bus_format.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Emil Renner Berthing <kernel@esmil.dk>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index a002f53aab0e..c6f2c4723b1b 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -103,8 +103,8 @@ static struct imx_drm_crtc *imx_drm_find_crtc(struct drm_crtc *crtc)
 	return NULL;
 }
 
-int imx_drm_panel_format_pins(struct drm_encoder *encoder,
-		u32 interface_pix_fmt, int hsync_pin, int vsync_pin)
+int imx_drm_set_bus_format_pins(struct drm_encoder *encoder, u32 bus_format,
+		int hsync_pin, int vsync_pin)
 {
 	struct imx_drm_crtc_helper_funcs *helper;
 	struct imx_drm_crtc *imx_crtc;
@@ -116,16 +116,16 @@ int imx_drm_panel_format_pins(struct drm_encoder *encoder,
 	helper = &imx_crtc->imx_drm_helper_funcs;
 	if (helper->set_interface_pix_fmt)
 		return helper->set_interface_pix_fmt(encoder->crtc,
-				interface_pix_fmt, hsync_pin, vsync_pin);
+					bus_format, hsync_pin, vsync_pin);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(imx_drm_panel_format_pins);
+EXPORT_SYMBOL_GPL(imx_drm_set_bus_format_pins);
 
-int imx_drm_panel_format(struct drm_encoder *encoder, u32 interface_pix_fmt)
+int imx_drm_set_bus_format(struct drm_encoder *encoder, u32 bus_format)
 {
-	return imx_drm_panel_format_pins(encoder, interface_pix_fmt, 2, 3);
+	return imx_drm_set_bus_format_pins(encoder, bus_format, 2, 3);
 }
-EXPORT_SYMBOL_GPL(imx_drm_panel_format);
+EXPORT_SYMBOL_GPL(imx_drm_set_bus_format);
 
 int imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)
 {

commit f033c0bcc53675562200680f4cb4a86710d9fbae
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Dec 1 13:32:32 2014 +0100

    of: Decrement refcount of previous endpoint in of_graph_get_next_endpoint
    
    Decrementing the reference count of the previous endpoint node allows to
    use the of_graph_get_next_endpoint function in a for_each_... style macro.
    All current users of this function that pass a non-NULL prev parameter
    (that is, soc_camera and imx-drm) are changed to not decrement the passed
    prev argument's refcount themselves.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index a002f53aab0e..84cf99f8d957 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -431,15 +431,6 @@ int imx_drm_encoder_parse_of(struct drm_device *drm,
 }
 EXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);
 
-static struct device_node *imx_drm_of_get_next_endpoint(
-		const struct device_node *parent, struct device_node *prev)
-{
-	struct device_node *node = of_graph_get_next_endpoint(parent, prev);
-
-	of_node_put(prev);
-	return node;
-}
-
 /*
  * @node: device tree node containing encoder input ports
  * @encoder: drm_encoder
@@ -457,7 +448,7 @@ int imx_drm_encoder_get_mux_id(struct device_node *node,
 		return -EINVAL;
 
 	do {
-		ep = imx_drm_of_get_next_endpoint(node, ep);
+		ep = of_graph_get_next_endpoint(node, ep);
 		if (!ep)
 			break;
 

commit d50141d8072e5322ee0518a8c967b5c9caf463d2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 21 15:58:19 2014 +0000

    imx-drm: core: handling of DI clock flags to ipu_crtc_mode_set()
    
    We do not need to track the state of the IPU DI's clock flags by having
    each display bridge calling back into imx-drm-core, and then back out
    into ipuv3-crtc.c.
    
    ipuv3-crtc can instead just scan the list of encoders to retrieve their
    type, and build up a picture of which types of encoders are attached.
    We can then use this information to configure the IPU DI clocking mode
    without any uncertainty - if we have multiple bridges connected to the
    same DI, if one of them requires a synchronous DI clock, that's what we
    must use.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 06cd2e516db6..a002f53aab0e 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -116,8 +116,7 @@ int imx_drm_panel_format_pins(struct drm_encoder *encoder,
 	helper = &imx_crtc->imx_drm_helper_funcs;
 	if (helper->set_interface_pix_fmt)
 		return helper->set_interface_pix_fmt(encoder->crtc,
-				encoder->encoder_type, interface_pix_fmt,
-				hsync_pin, vsync_pin);
+				interface_pix_fmt, hsync_pin, vsync_pin);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(imx_drm_panel_format_pins);

commit 6457b9716bca99b95a07e85ff8b00f9bf471ac2c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 3 17:52:57 2014 +0100

    drm/imx: convert imx-drm to use the generic DRM OF helper
    
    Use the generic DRM OF helper to locate the possible CRTCs for the
    encoder, thereby shrinking the imx-drm driver some more.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index b250130debc8..06cd2e516db6 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -25,6 +25,7 @@
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_plane_helper.h>
+#include <drm/drm_of.h>
 
 #include "imx-drm.h"
 
@@ -46,7 +47,6 @@ struct imx_drm_crtc {
 	struct drm_crtc				*crtc;
 	int					pipe;
 	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
-	struct device_node			*port;
 };
 
 static int legacyfb_depth = 16;
@@ -365,9 +365,10 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
 
 	imx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;
 	imx_drm_crtc->pipe = imxdrm->pipes++;
-	imx_drm_crtc->port = port;
 	imx_drm_crtc->crtc = crtc;
 
+	crtc->port = port;
+
 	imxdrm->crtc[imx_drm_crtc->pipe] = imx_drm_crtc;
 
 	*new_crtc = imx_drm_crtc;
@@ -408,33 +409,28 @@ int imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)
 }
 EXPORT_SYMBOL_GPL(imx_drm_remove_crtc);
 
-/*
- * Find the DRM CRTC possible mask for the connected endpoint.
- *
- * The encoder possible masks are defined by their position in the
- * mode_config crtc_list.  This means that CRTCs must not be added
- * or removed once the DRM device has been fully initialised.
- */
-static uint32_t imx_drm_find_crtc_mask(struct imx_drm_device *imxdrm,
-	struct device_node *endpoint)
+int imx_drm_encoder_parse_of(struct drm_device *drm,
+	struct drm_encoder *encoder, struct device_node *np)
 {
-	struct device_node *port;
-	unsigned i;
+	uint32_t crtc_mask = drm_of_find_possible_crtcs(drm, np);
 
-	port = of_graph_get_remote_port(endpoint);
-	if (!port)
-		return 0;
-	of_node_put(port);
+	/*
+	 * If we failed to find the CRTC(s) which this encoder is
+	 * supposed to be connected to, it's because the CRTC has
+	 * not been registered yet.  Defer probing, and hope that
+	 * the required CRTC is added later.
+	 */
+	if (crtc_mask == 0)
+		return -EPROBE_DEFER;
 
-	for (i = 0; i < MAX_CRTC; i++) {
-		struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[i];
+	encoder->possible_crtcs = crtc_mask;
 
-		if (imx_drm_crtc && imx_drm_crtc->port == port)
-			return drm_crtc_mask(imx_drm_crtc->crtc);
-	}
+	/* FIXME: this is the mask of outputs which can clone this output. */
+	encoder->possible_clones = ~0;
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);
 
 static struct device_node *imx_drm_of_get_next_endpoint(
 		const struct device_node *parent, struct device_node *prev)
@@ -445,48 +441,6 @@ static struct device_node *imx_drm_of_get_next_endpoint(
 	return node;
 }
 
-int imx_drm_encoder_parse_of(struct drm_device *drm,
-	struct drm_encoder *encoder, struct device_node *np)
-{
-	struct imx_drm_device *imxdrm = drm->dev_private;
-	struct device_node *ep = NULL;
-	uint32_t crtc_mask = 0;
-	int i;
-
-	for (i = 0; ; i++) {
-		u32 mask;
-
-		ep = imx_drm_of_get_next_endpoint(np, ep);
-		if (!ep)
-			break;
-
-		mask = imx_drm_find_crtc_mask(imxdrm, ep);
-
-		/*
-		 * If we failed to find the CRTC(s) which this encoder is
-		 * supposed to be connected to, it's because the CRTC has
-		 * not been registered yet.  Defer probing, and hope that
-		 * the required CRTC is added later.
-		 */
-		if (mask == 0)
-			return -EPROBE_DEFER;
-
-		crtc_mask |= mask;
-	}
-
-	of_node_put(ep);
-	if (i == 0)
-		return -ENOENT;
-
-	encoder->possible_crtcs = crtc_mask;
-
-	/* FIXME: this is the mask of outputs which can clone this output. */
-	encoder->possible_clones = ~0;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);
-
 /*
  * @node: device tree node containing encoder input ports
  * @encoder: drm_encoder
@@ -510,7 +464,7 @@ int imx_drm_encoder_get_mux_id(struct device_node *node,
 
 		port = of_graph_get_remote_port(ep);
 		of_node_put(port);
-		if (port == imx_crtc->port) {
+		if (port == imx_crtc->crtc->port) {
 			ret = of_graph_parse_endpoint(ep, &endpoint);
 			return ret ? ret : endpoint.port;
 		}

commit dab363f938a53ddaee60bfecc1aebdbb3d3af5f0
Merge: a68db9cb858d 17d2c6439be6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 15 18:06:13 2014 -0800

    Merge tag 'staging-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the big staging tree pull request for 3.19-rc1.
    
      We continued to delete more lines than were added, always a good
      thing, but not at a huge rate this release, only about 70k lines
      removed overall mostly from removing the horrid bcm driver.
    
      Lots of normal staging driver cleanups and fixes all over the place,
      well over a thousand of them, the shortlog shows all the horrid
      details.
    
      The "contentious" thing here is the movement of the Android binder
      code out of staging into the "real" part of the kernel.  This is code
      that has been stable for a few years now and is working as-is in the
      tens of millions of devices with no issues.  Yes, the code is horrid,
      and the userspace api leaves a lot to be desired, but it's not going
      to change due to legacy issues that we have no control over.  Because
      so many devices and companies rely on this, and the code is stable,
      might as well promote it out of staging.
    
      This was all discussed at the Linux Plumbers conference, and everyone
      participating agreed that this was the best way forward.
    
      There is work happening to replace the binder code with something new
      that is happening right now, but I don't expect to see the results of
      that work for another year at the earliest.  If that ever happens, and
      Android switches over to it, I'll gladly remove this version.
    
      As for maintainers, I'll be glad to maintain this code, I've been
      doing it for the past few years with no problems.  I'll send a
      MAINTAINERS entry for it before 3.19-final is out, still need to talk
      to the Google developers about if they are willing to help with it or
      not, last I checked they were, which was good.
    
      All of these patches have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1382 commits)
      Staging: slicoss: Fix long line issues in slicoss.c
      staging: rtl8712: remove unnecessary else after return
      staging: comedi: change some printk calls to pr_err
      staging: rtl8723au: hal: Removed the extra semicolon
      lustre: Deletion of unnecessary checks before three function calls
      staging: lustre: fix sparse warnings: static function declaration
      staging: lustre: fixed sparse warnings related to static declarations
      staging: unisys: remove duplicate header
      staging: unisys: remove unneeded structure
      staging: ft1000 : replace __attribute ((__packed__) with __packed
      drivers: staging: rtl8192e: Include "asm/unaligned.h" instead of "access_ok.h" in "rtl819x_BAProc.c"
      Drivers:staging:rtl8192e: Fixed checkpatch warning
      Drivers:staging:clocking-wizard: Added a newline
      staging: clocking-wizard: check for a valid clk_name pointer
      staging: rtl8723au: Hal_InitPGData() avoid unnecessary typecasts
      staging: rtl8723au: _DisableAnalog(): Avoid zero-init variables unnecessarily
      staging: rtl8723au: Remove unnecessary wrapper _ResetDigitalProcedure1()
      staging: rtl8723au: _ResetDigitalProcedure1_92C() reduce code obfuscation
      staging: rtl8723au: Remove unnecessary wrapper _DisableRFAFEAndResetBB()
      staging: rtl8723au: _DisableRFAFEAndResetBB8192C(): Reduce code obfuscation
      ...

commit 988adfdffdd43cfd841df734664727993076d7cb
Merge: 26178ec11ef3 4e0cd6811562
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 15 15:52:01 2014 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Highlights:
    
       - AMD KFD driver merge
    
         This is the AMD HSA interface for exposing a lowlevel interface for
         GPGPU use.  They have an open source userspace built on top of this
         interface, and the code looks as good as it was going to get out of
         tree.
    
       - Initial atomic modesetting work
    
         The need for an atomic modesetting interface to allow userspace to
         try and send a complete set of modesetting state to the driver has
         arisen, and been suffering from neglect this past year.  No more,
         the start of the common code and changes for msm driver to use it
         are in this tree.  Ongoing work to get the userspace ioctl finished
         and the code clean will probably wait until next kernel.
    
       - DisplayID 1.3 and tiled monitor exposed to userspace.
    
         Tiled monitor property is now exposed for userspace to make use of.
    
       - Rockchip drm driver merged.
    
       - imx gpu driver moved out of staging
    
      Other stuff:
    
       - core:
            panel - MIPI DSI + new panels.
            expose suggested x/y properties for virtual GPUs
    
       - i915:
            Initial Skylake (SKL) support
            gen3/4 reset work
            start of dri1/ums removal
            infoframe tracking
            fixes for lots of things.
    
       - nouveau:
            tegra k1 voltage support
            GM204 modesetting support
            GT21x memory reclocking work
    
       - radeon:
            CI dpm fixes
            GPUVM improvements
            Initial DPM fan control
    
       - rcar-du:
            HDMI support added
            removed some support for old boards
            slave encoder driver for Analog Devices adv7511
    
       - exynos:
            Exynos4415 SoC support
    
       - msm:
            a4xx gpu support
            atomic helper conversion
    
       - tegra:
            iommu support
            universal plane support
            ganged-mode DSI support
    
       - sti:
            HDMI i2c improvements
    
       - vmwgfx:
            some late fixes.
    
       - qxl:
            use suggested x/y properties"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (969 commits)
      drm: sti: fix module compilation issue
      drm/i915: save/restore GMBUS freq across suspend/resume on gen4
      drm: sti: correctly cleanup CRTC and planes
      drm: sti: add HQVDP plane
      drm: sti: add cursor plane
      drm: sti: enable auxiliary CRTC
      drm: sti: fix delay in VTG programming
      drm: sti: prepare sti_tvout to support auxiliary crtc
      drm: sti: use drm_crtc_vblank_{on/off} instead of drm_vblank_{on/off}
      drm: sti: fix hdmi avi infoframe
      drm: sti: remove event lock while disabling vblank
      drm: sti: simplify gdp code
      drm: sti: clear all mixer control
      drm: sti: remove gpio for HDMI hot plug detection
      drm: sti: allow to change hdmi ddc i2c adapter
      drm/doc: Document drm_add_modes_noedid() usage
      drm/i915: Remove '& 0xffff' from the mask given to WA_REG()
      drm/i915: Invert the mask and val arguments in wa_add() and WA_REG()
      drm: Zero out DRM object memory upon cleanup
      drm/i915/bdw: Fix the write setting up the WIZ hashing mode
      ...

commit 6556f7f82b9c401950d703072c0d8137b6f9f516
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Nov 24 16:33:34 2014 +0100

    drm: imx: Move imx-drm driver out of staging
    
    The imx-drm driver was put into staging mostly for the following reasons,
    all of which have been addressed or superseded:
     - convert the irq driver to use linear irq domains
     - work out the device tree bindings, this lead to the common of_graph
       bindings being used
     - factor out common helper functions, this mostly resulted in the
       component framework and drm of_graph helpers.
    
    Before adding new fixes, and certainly before adding new features,
    move it into its proper place below drivers/gpu/drm.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
new file mode 100644
index 000000000000..2f8007241734
--- /dev/null
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -0,0 +1,705 @@
+/*
+ * Freescale i.MX drm driver
+ *
+ * Copyright (C) 2011 Sascha Hauer, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <drm/drmP.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "imx-drm.h"
+
+#define MAX_CRTC	4
+
+struct imx_drm_crtc;
+
+struct imx_drm_component {
+	struct device_node *of_node;
+	struct list_head list;
+};
+
+struct imx_drm_device {
+	struct drm_device			*drm;
+	struct imx_drm_crtc			*crtc[MAX_CRTC];
+	int					pipes;
+	struct drm_fbdev_cma			*fbhelper;
+};
+
+struct imx_drm_crtc {
+	struct drm_crtc				*crtc;
+	int					pipe;
+	struct imx_drm_crtc_helper_funcs	imx_drm_helper_funcs;
+	struct device_node			*port;
+};
+
+static int legacyfb_depth = 16;
+module_param(legacyfb_depth, int, 0444);
+
+int imx_drm_crtc_id(struct imx_drm_crtc *crtc)
+{
+	return crtc->pipe;
+}
+EXPORT_SYMBOL_GPL(imx_drm_crtc_id);
+
+static void imx_drm_driver_lastclose(struct drm_device *drm)
+{
+#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+	struct imx_drm_device *imxdrm = drm->dev_private;
+
+	if (imxdrm->fbhelper)
+		drm_fbdev_cma_restore_mode(imxdrm->fbhelper);
+#endif
+}
+
+static int imx_drm_driver_unload(struct drm_device *drm)
+{
+#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+	struct imx_drm_device *imxdrm = drm->dev_private;
+#endif
+
+	drm_kms_helper_poll_fini(drm);
+
+#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+	if (imxdrm->fbhelper)
+		drm_fbdev_cma_fini(imxdrm->fbhelper);
+#endif
+
+	component_unbind_all(drm->dev, drm);
+
+	drm_vblank_cleanup(drm);
+	drm_mode_config_cleanup(drm);
+
+	platform_set_drvdata(drm->platformdev, NULL);
+
+	return 0;
+}
+
+static struct imx_drm_crtc *imx_drm_find_crtc(struct drm_crtc *crtc)
+{
+	struct imx_drm_device *imxdrm = crtc->dev->dev_private;
+	unsigned i;
+
+	for (i = 0; i < MAX_CRTC; i++)
+		if (imxdrm->crtc[i] && imxdrm->crtc[i]->crtc == crtc)
+			return imxdrm->crtc[i];
+
+	return NULL;
+}
+
+int imx_drm_panel_format_pins(struct drm_encoder *encoder,
+		u32 interface_pix_fmt, int hsync_pin, int vsync_pin)
+{
+	struct imx_drm_crtc_helper_funcs *helper;
+	struct imx_drm_crtc *imx_crtc;
+
+	imx_crtc = imx_drm_find_crtc(encoder->crtc);
+	if (!imx_crtc)
+		return -EINVAL;
+
+	helper = &imx_crtc->imx_drm_helper_funcs;
+	if (helper->set_interface_pix_fmt)
+		return helper->set_interface_pix_fmt(encoder->crtc,
+				encoder->encoder_type, interface_pix_fmt,
+				hsync_pin, vsync_pin);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(imx_drm_panel_format_pins);
+
+int imx_drm_panel_format(struct drm_encoder *encoder, u32 interface_pix_fmt)
+{
+	return imx_drm_panel_format_pins(encoder, interface_pix_fmt, 2, 3);
+}
+EXPORT_SYMBOL_GPL(imx_drm_panel_format);
+
+int imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)
+{
+	return drm_vblank_get(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+}
+EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_get);
+
+void imx_drm_crtc_vblank_put(struct imx_drm_crtc *imx_drm_crtc)
+{
+	drm_vblank_put(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+}
+EXPORT_SYMBOL_GPL(imx_drm_crtc_vblank_put);
+
+void imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)
+{
+	drm_handle_vblank(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);
+}
+EXPORT_SYMBOL_GPL(imx_drm_handle_vblank);
+
+static int imx_drm_enable_vblank(struct drm_device *drm, int crtc)
+{
+	struct imx_drm_device *imxdrm = drm->dev_private;
+	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];
+	int ret;
+
+	if (!imx_drm_crtc)
+		return -EINVAL;
+
+	if (!imx_drm_crtc->imx_drm_helper_funcs.enable_vblank)
+		return -ENOSYS;
+
+	ret = imx_drm_crtc->imx_drm_helper_funcs.enable_vblank(
+			imx_drm_crtc->crtc);
+
+	return ret;
+}
+
+static void imx_drm_disable_vblank(struct drm_device *drm, int crtc)
+{
+	struct imx_drm_device *imxdrm = drm->dev_private;
+	struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];
+
+	if (!imx_drm_crtc)
+		return;
+
+	if (!imx_drm_crtc->imx_drm_helper_funcs.disable_vblank)
+		return;
+
+	imx_drm_crtc->imx_drm_helper_funcs.disable_vblank(imx_drm_crtc->crtc);
+}
+
+static void imx_drm_driver_preclose(struct drm_device *drm,
+		struct drm_file *file)
+{
+	int i;
+
+	if (!file->is_master)
+		return;
+
+	for (i = 0; i < MAX_CRTC; i++)
+		imx_drm_disable_vblank(drm, i);
+}
+
+static const struct file_operations imx_drm_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.release = drm_release,
+	.unlocked_ioctl = drm_ioctl,
+	.mmap = drm_gem_cma_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+	.llseek = noop_llseek,
+};
+
+void imx_drm_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+EXPORT_SYMBOL_GPL(imx_drm_connector_destroy);
+
+void imx_drm_encoder_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+}
+EXPORT_SYMBOL_GPL(imx_drm_encoder_destroy);
+
+static void imx_drm_output_poll_changed(struct drm_device *drm)
+{
+#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+	struct imx_drm_device *imxdrm = drm->dev_private;
+
+	drm_fbdev_cma_hotplug_event(imxdrm->fbhelper);
+#endif
+}
+
+static struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = imx_drm_output_poll_changed,
+};
+
+/*
+ * Main DRM initialisation. This binds, initialises and registers
+ * with DRM the subcomponents of the driver.
+ */
+static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
+{
+	struct imx_drm_device *imxdrm;
+	struct drm_connector *connector;
+	int ret;
+
+	imxdrm = devm_kzalloc(drm->dev, sizeof(*imxdrm), GFP_KERNEL);
+	if (!imxdrm)
+		return -ENOMEM;
+
+	imxdrm->drm = drm;
+
+	drm->dev_private = imxdrm;
+
+	/*
+	 * enable drm irq mode.
+	 * - with irq_enabled = true, we can use the vblank feature.
+	 *
+	 * P.S. note that we wouldn't use drm irq handler but
+	 *      just specific driver own one instead because
+	 *      drm framework supports only one irq handler and
+	 *      drivers can well take care of their interrupts
+	 */
+	drm->irq_enabled = true;
+
+	/*
+	 * set max width and height as default value(4096x4096).
+	 * this value would be used to check framebuffer size limitation
+	 * at drm_mode_addfb().
+	 */
+	drm->mode_config.min_width = 64;
+	drm->mode_config.min_height = 64;
+	drm->mode_config.max_width = 4096;
+	drm->mode_config.max_height = 4096;
+	drm->mode_config.funcs = &imx_drm_mode_config_funcs;
+
+	drm_mode_config_init(drm);
+
+	ret = drm_vblank_init(drm, MAX_CRTC);
+	if (ret)
+		goto err_kms;
+
+	/*
+	 * with vblank_disable_allowed = true, vblank interrupt will be
+	 * disabled by drm timer once a current process gives up ownership
+	 * of vblank event. (after drm_vblank_put function is called)
+	 */
+	drm->vblank_disable_allowed = true;
+
+	platform_set_drvdata(drm->platformdev, drm);
+
+	/* Now try and bind all our sub-components */
+	ret = component_bind_all(drm->dev, drm);
+	if (ret)
+		goto err_vblank;
+
+	/*
+	 * All components are now added, we can publish the connector sysfs
+	 * entries to userspace.  This will generate hotplug events and so
+	 * userspace will expect to be able to access DRM at this point.
+	 */
+	list_for_each_entry(connector, &drm->mode_config.connector_list, head) {
+		ret = drm_connector_register(connector);
+		if (ret) {
+			dev_err(drm->dev,
+				"[CONNECTOR:%d:%s] drm_connector_register failed: %d\n",
+				connector->base.id,
+				connector->name, ret);
+			goto err_unbind;
+		}
+	}
+
+	/*
+	 * All components are now initialised, so setup the fb helper.
+	 * The fb helper takes copies of key hardware information, so the
+	 * crtcs/connectors/encoders must not change after this point.
+	 */
+#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)
+	if (legacyfb_depth != 16 && legacyfb_depth != 32) {
+		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
+		legacyfb_depth = 16;
+	}
+	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
+				drm->mode_config.num_crtc, MAX_CRTC);
+	if (IS_ERR(imxdrm->fbhelper)) {
+		ret = PTR_ERR(imxdrm->fbhelper);
+		imxdrm->fbhelper = NULL;
+		goto err_unbind;
+	}
+#endif
+
+	drm_kms_helper_poll_init(drm);
+
+	return 0;
+
+err_unbind:
+	component_unbind_all(drm->dev, drm);
+err_vblank:
+	drm_vblank_cleanup(drm);
+err_kms:
+	drm_mode_config_cleanup(drm);
+
+	return ret;
+}
+
+/*
+ * imx_drm_add_crtc - add a new crtc
+ */
+int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
+		struct imx_drm_crtc **new_crtc,
+		const struct imx_drm_crtc_helper_funcs *imx_drm_helper_funcs,
+		struct device_node *port)
+{
+	struct imx_drm_device *imxdrm = drm->dev_private;
+	struct imx_drm_crtc *imx_drm_crtc;
+	int ret;
+
+	/*
+	 * The vblank arrays are dimensioned by MAX_CRTC - we can't
+	 * pass IDs greater than this to those functions.
+	 */
+	if (imxdrm->pipes >= MAX_CRTC)
+		return -EINVAL;
+
+	if (imxdrm->drm->open_count)
+		return -EBUSY;
+
+	imx_drm_crtc = kzalloc(sizeof(*imx_drm_crtc), GFP_KERNEL);
+	if (!imx_drm_crtc)
+		return -ENOMEM;
+
+	imx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;
+	imx_drm_crtc->pipe = imxdrm->pipes++;
+	imx_drm_crtc->port = port;
+	imx_drm_crtc->crtc = crtc;
+
+	imxdrm->crtc[imx_drm_crtc->pipe] = imx_drm_crtc;
+
+	*new_crtc = imx_drm_crtc;
+
+	ret = drm_mode_crtc_set_gamma_size(imx_drm_crtc->crtc, 256);
+	if (ret)
+		goto err_register;
+
+	drm_crtc_helper_add(crtc,
+			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);
+
+	drm_crtc_init(drm, crtc,
+			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);
+
+	return 0;
+
+err_register:
+	imxdrm->crtc[imx_drm_crtc->pipe] = NULL;
+	kfree(imx_drm_crtc);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(imx_drm_add_crtc);
+
+/*
+ * imx_drm_remove_crtc - remove a crtc
+ */
+int imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)
+{
+	struct imx_drm_device *imxdrm = imx_drm_crtc->crtc->dev->dev_private;
+
+	drm_crtc_cleanup(imx_drm_crtc->crtc);
+
+	imxdrm->crtc[imx_drm_crtc->pipe] = NULL;
+
+	kfree(imx_drm_crtc);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(imx_drm_remove_crtc);
+
+/*
+ * Find the DRM CRTC possible mask for the connected endpoint.
+ *
+ * The encoder possible masks are defined by their position in the
+ * mode_config crtc_list.  This means that CRTCs must not be added
+ * or removed once the DRM device has been fully initialised.
+ */
+static uint32_t imx_drm_find_crtc_mask(struct imx_drm_device *imxdrm,
+	struct device_node *endpoint)
+{
+	struct device_node *port;
+	unsigned i;
+
+	port = of_graph_get_remote_port(endpoint);
+	if (!port)
+		return 0;
+	of_node_put(port);
+
+	for (i = 0; i < MAX_CRTC; i++) {
+		struct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[i];
+
+		if (imx_drm_crtc && imx_drm_crtc->port == port)
+			return drm_crtc_mask(imx_drm_crtc->crtc);
+	}
+
+	return 0;
+}
+
+static struct device_node *imx_drm_of_get_next_endpoint(
+		const struct device_node *parent, struct device_node *prev)
+{
+	struct device_node *node = of_graph_get_next_endpoint(parent, prev);
+
+	of_node_put(prev);
+	return node;
+}
+
+int imx_drm_encoder_parse_of(struct drm_device *drm,
+	struct drm_encoder *encoder, struct device_node *np)
+{
+	struct imx_drm_device *imxdrm = drm->dev_private;
+	struct device_node *ep = NULL;
+	uint32_t crtc_mask = 0;
+	int i;
+
+	for (i = 0; ; i++) {
+		u32 mask;
+
+		ep = imx_drm_of_get_next_endpoint(np, ep);
+		if (!ep)
+			break;
+
+		mask = imx_drm_find_crtc_mask(imxdrm, ep);
+
+		/*
+		 * If we failed to find the CRTC(s) which this encoder is
+		 * supposed to be connected to, it's because the CRTC has
+		 * not been registered yet.  Defer probing, and hope that
+		 * the required CRTC is added later.
+		 */
+		if (mask == 0)
+			return -EPROBE_DEFER;
+
+		crtc_mask |= mask;
+	}
+
+	of_node_put(ep);
+	if (i == 0)
+		return -ENOENT;
+
+	encoder->possible_crtcs = crtc_mask;
+
+	/* FIXME: this is the mask of outputs which can clone this output. */
+	encoder->possible_clones = ~0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);
+
+/*
+ * @node: device tree node containing encoder input ports
+ * @encoder: drm_encoder
+ */
+int imx_drm_encoder_get_mux_id(struct device_node *node,
+			       struct drm_encoder *encoder)
+{
+	struct imx_drm_crtc *imx_crtc = imx_drm_find_crtc(encoder->crtc);
+	struct device_node *ep = NULL;
+	struct of_endpoint endpoint;
+	struct device_node *port;
+	int ret;
+
+	if (!node || !imx_crtc)
+		return -EINVAL;
+
+	do {
+		ep = imx_drm_of_get_next_endpoint(node, ep);
+		if (!ep)
+			break;
+
+		port = of_graph_get_remote_port(ep);
+		of_node_put(port);
+		if (port == imx_crtc->port) {
+			ret = of_graph_parse_endpoint(ep, &endpoint);
+			return ret ? ret : endpoint.port;
+		}
+	} while (ep);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(imx_drm_encoder_get_mux_id);
+
+static const struct drm_ioctl_desc imx_drm_ioctls[] = {
+	/* none so far */
+};
+
+static struct drm_driver imx_drm_driver = {
+	.driver_features	= DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME,
+	.load			= imx_drm_driver_load,
+	.unload			= imx_drm_driver_unload,
+	.lastclose		= imx_drm_driver_lastclose,
+	.preclose		= imx_drm_driver_preclose,
+	.set_busid		= drm_platform_set_busid,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_dumb_destroy,
+
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_export	= drm_gem_prime_export,
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
+	.get_vblank_counter	= drm_vblank_count,
+	.enable_vblank		= imx_drm_enable_vblank,
+	.disable_vblank		= imx_drm_disable_vblank,
+	.ioctls			= imx_drm_ioctls,
+	.num_ioctls		= ARRAY_SIZE(imx_drm_ioctls),
+	.fops			= &imx_drm_driver_fops,
+	.name			= "imx-drm",
+	.desc			= "i.MX DRM graphics",
+	.date			= "20120507",
+	.major			= 1,
+	.minor			= 0,
+	.patchlevel		= 0,
+};
+
+static int compare_of(struct device *dev, void *data)
+{
+	struct device_node *np = data;
+
+	/* Special case for LDB, one device for two channels */
+	if (of_node_cmp(np->name, "lvds-channel") == 0) {
+		np = of_get_parent(np);
+		of_node_put(np);
+	}
+
+	return dev->of_node == np;
+}
+
+static int imx_drm_bind(struct device *dev)
+{
+	return drm_platform_init(&imx_drm_driver, to_platform_device(dev));
+}
+
+static void imx_drm_unbind(struct device *dev)
+{
+	drm_put_dev(dev_get_drvdata(dev));
+}
+
+static const struct component_master_ops imx_drm_ops = {
+	.bind = imx_drm_bind,
+	.unbind = imx_drm_unbind,
+};
+
+static int imx_drm_platform_probe(struct platform_device *pdev)
+{
+	struct device_node *ep, *port, *remote;
+	struct component_match *match = NULL;
+	int ret;
+	int i;
+
+	/*
+	 * Bind the IPU display interface ports first, so that
+	 * imx_drm_encoder_parse_of called from encoder .bind callbacks
+	 * works as expected.
+	 */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(pdev->dev.of_node, "ports", i);
+		if (!port)
+			break;
+
+		component_match_add(&pdev->dev, &match, compare_of, port);
+	}
+
+	if (i == 0) {
+		dev_err(&pdev->dev, "missing 'ports' property\n");
+		return -ENODEV;
+	}
+
+	/* Then bind all encoders */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(pdev->dev.of_node, "ports", i);
+		if (!port)
+			break;
+
+		for_each_child_of_node(port, ep) {
+			remote = of_graph_get_remote_port_parent(ep);
+			if (!remote || !of_device_is_available(remote)) {
+				of_node_put(remote);
+				continue;
+			} else if (!of_device_is_available(remote->parent)) {
+				dev_warn(&pdev->dev, "parent device of %s is not available\n",
+					 remote->full_name);
+				of_node_put(remote);
+				continue;
+			}
+
+			component_match_add(&pdev->dev, &match, compare_of, remote);
+			of_node_put(remote);
+		}
+		of_node_put(port);
+	}
+
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	return component_master_add_with_match(&pdev->dev, &imx_drm_ops, match);
+}
+
+static int imx_drm_platform_remove(struct platform_device *pdev)
+{
+	component_master_del(&pdev->dev, &imx_drm_ops);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int imx_drm_suspend(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	/* The drm_dev is NULL before .load hook is called */
+	if (drm_dev == NULL)
+		return 0;
+
+	drm_kms_helper_poll_disable(drm_dev);
+
+	return 0;
+}
+
+static int imx_drm_resume(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	if (drm_dev == NULL)
+		return 0;
+
+	drm_helper_resume_force_mode(drm_dev);
+	drm_kms_helper_poll_enable(drm_dev);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(imx_drm_pm_ops, imx_drm_suspend, imx_drm_resume);
+
+static const struct of_device_id imx_drm_dt_ids[] = {
+	{ .compatible = "fsl,imx-display-subsystem", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, imx_drm_dt_ids);
+
+static struct platform_driver imx_drm_pdrv = {
+	.probe		= imx_drm_platform_probe,
+	.remove		= imx_drm_platform_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "imx-drm",
+		.pm	= &imx_drm_pm_ops,
+		.of_match_table = imx_drm_dt_ids,
+	},
+};
+module_platform_driver(imx_drm_pdrv);
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_DESCRIPTION("i.MX drm driver core");
+MODULE_LICENSE("GPL");
