commit fb55c735522352704c35d899d0b253453cf0e799
Author: Yan Zhao <yan.y.zhao@intel.com>
Date:   Fri Apr 17 05:13:34 2020 -0400

    drm/i915/gvt: skip populate shadow context if guest context not changed
    
    Software is not expected to populate engine context except when using
    restore inhibit bit or golden state to initialize it for the first time.
    
    Therefore, if a newly submitted guest context is the same as the last
    shadowed one, no need to populate its engine context from guest again.
    
    Currently using lrca + ring_context_gpa to identify whether two guest
    contexts are the same.
    
    The reason of why context id is not included as an identifier is that
    i915 recently changed the code and context id is only unique for a
    context when OA is enabled. And when OA is on, context id is generated
    based on lrca. Therefore, in that case, if two contexts are of the same
    lrca, they have identical context ids as well.
    (This patch also works with old guest kernel like 4.20.)
    
    for guest context, if its ggtt entry is modified after last context
    shadowing, it is also deemed as not the same context as last shadowed one.
    
    v7:
    -removed local variable "valid". use the one in s->last_ctx diretly
    
    v6:
    -change type of lrca of last ctx to be u32. as currently it's all
    protected by vgpu lock (Kevin Tian)
    -reset valid of last ctx to false once it needs to be repopulated before
    population completes successfully (Kevin Tian)
    
    v5:
    -merge all 3 patches into one patch  (Zhenyu Wang)
    
    v4:
    - split the series into 3 patches.
    - don't turn on optimization until last patch in this series (Kevin Tian)
    - define lrca to be atomic in this patch rather than update its type in
    the second patch (Kevin Tian)
    
    v3: updated commit message to describe engine context and context id
    clearly (Kevin Tian)
    v2: rebased to 5.6.0-rc4+Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Cc: Kevin Tian <kevin.tian@intel.com>
    Suggested-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200417091334.32628-1-yan.y.zhao@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 58c2c7932e3f..a4a6db6b7f90 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -163,6 +163,11 @@ struct intel_vgpu_submission {
 	const struct intel_vgpu_submission_ops *ops;
 	int virtual_submission_interface;
 	bool active;
+	struct {
+		u32 lrca;
+		bool valid;
+		u64 ring_context_gpa;
+	} last_ctx[I915_NUM_ENGINES];
 };
 
 struct intel_vgpu {

commit a61ac1e75105a077ec1efd6923ae3c619f862304
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 6 10:08:10 2020 +0800

    drm/i915/gvt: Wean gvt off using dev_priv
    
    Teach gvt to use intel_gt directly as it currently assumes direct HW
    access.
    
    [Zhenyu: rebase, fix compiling]
    
    Cc: Ding Zhuocheng <zhuocheng.ding@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200304032307.2983-3-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 8cf292a8d6bd..58c2c7932e3f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -286,7 +286,7 @@ struct intel_gvt {
 	/* scheduler scope lock, protect gvt and vgpu schedule related data */
 	struct mutex sched_lock;
 
-	struct drm_i915_private *dev_priv;
+	struct intel_gt *gt;
 	struct idr vgpu_idr;	/* vGPU IDR pool */
 
 	struct intel_gvt_device_info device_info;
@@ -356,14 +356,15 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 #define HOST_HIGH_GM_SIZE MB_TO_BYTES(384)
 #define HOST_FENCE 4
 
+#define gvt_to_ggtt(gvt)	((gvt)->gt->ggtt)
+
 /* Aperture/GM space definitions for GVT device */
-#define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
-#define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.gmadr.start)
+#define gvt_aperture_sz(gvt)	  gvt_to_ggtt(gvt)->mappable_end
+#define gvt_aperture_pa_base(gvt) gvt_to_ggtt(gvt)->gmadr.start
 
-#define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.vm.total)
-#define gvt_ggtt_sz(gvt) \
-	((gvt->dev_priv->ggtt.vm.total >> PAGE_SHIFT) << 3)
-#define gvt_hidden_sz(gvt)	  (gvt_ggtt_gm_sz(gvt) - gvt_aperture_sz(gvt))
+#define gvt_ggtt_gm_sz(gvt)	gvt_to_ggtt(gvt)->vm.total
+#define gvt_ggtt_sz(gvt)	(gvt_to_ggtt(gvt)->vm.total >> PAGE_SHIFT << 3)
+#define gvt_hidden_sz(gvt)	(gvt_ggtt_gm_sz(gvt) - gvt_aperture_sz(gvt))
 
 #define gvt_aperture_gmadr_base(gvt) (0)
 #define gvt_aperture_gmadr_end(gvt) (gvt_aperture_gmadr_base(gvt) \
@@ -374,7 +375,7 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 #define gvt_hidden_gmadr_end(gvt) (gvt_hidden_gmadr_base(gvt) \
 				   + gvt_hidden_sz(gvt) - 1)
 
-#define gvt_fence_sz(gvt) ((gvt)->dev_priv->ggtt.num_fences)
+#define gvt_fence_sz(gvt) (gvt_to_ggtt(gvt)->num_fences)
 
 /* Aperture/GM space definitions for vGPU */
 #define vgpu_aperture_offset(vgpu)	((vgpu)->gm.low_gm_node.start)
@@ -565,14 +566,14 @@ enum {
 	GVT_FAILSAFE_GUEST_ERR,
 };
 
-static inline void mmio_hw_access_pre(struct drm_i915_private *dev_priv)
+static inline void mmio_hw_access_pre(struct intel_gt *gt)
 {
-	intel_runtime_pm_get(&dev_priv->runtime_pm);
+	intel_runtime_pm_get(gt->uncore->rpm);
 }
 
-static inline void mmio_hw_access_post(struct drm_i915_private *dev_priv)
+static inline void mmio_hw_access_post(struct intel_gt *gt)
 {
-	intel_runtime_pm_put_unchecked(&dev_priv->runtime_pm);
+	intel_runtime_pm_put_unchecked(gt->uncore->rpm);
 }
 
 /**

commit 06d63c48dd30b968d2a56e3ece02d6b635cf369a
Author: Julian Stecklina <julian.stecklina@cyberus-technology.de>
Date:   Mon Feb 17 17:38:58 2020 +0100

    drm/i915/gvt: make gvt oblivious of kvmgt data structures
    
    Instead of defining KVMGT per-device state in struct intel_vgpu
    directly, add an indirection. This makes the GVT code oblivious of
    what state KVMGT needs to keep.
    
    The intention here is to eventually make it possible to build
    hypervisor backends for the mediator, without having to touch the
    mediator itself. This is a first step.
    
    v2:
    - rebased onto gvt-staging (no conflicts)
    
    Signed-off-by: Julian Stecklina <julian.stecklina@cyberus-technology.de>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200217163858.26496-1-julian.stecklina@cyberus-technology.de

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9fe9decc0d86..8cf292a8d6bd 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -196,31 +196,8 @@ struct intel_vgpu {
 
 	struct dentry *debugfs;
 
-#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
-	struct {
-		struct mdev_device *mdev;
-		struct vfio_region *region;
-		int num_regions;
-		struct eventfd_ctx *intx_trigger;
-		struct eventfd_ctx *msi_trigger;
-
-		/*
-		 * Two caches are used to avoid mapping duplicated pages (eg.
-		 * scratch pages). This help to reduce dma setup overhead.
-		 */
-		struct rb_root gfn_cache;
-		struct rb_root dma_addr_cache;
-		unsigned long nr_cache_entries;
-		struct mutex cache_lock;
-
-		struct notifier_block iommu_notifier;
-		struct notifier_block group_notifier;
-		struct kvm *kvm;
-		struct work_struct release_work;
-		atomic_t released;
-		struct vfio_device *vfio_device;
-	} vdev;
-#endif
+	/* Hypervisor-specific device state. */
+	void *vdev;
 
 	struct list_head dmabuf_obj_list_head;
 	struct mutex dmabuf_lock;
@@ -229,6 +206,11 @@ struct intel_vgpu {
 	u32 scan_nonprivbb;
 };
 
+static inline void *intel_vgpu_vdev(struct intel_vgpu *vgpu)
+{
+	return vgpu->vdev;
+}
+
 /* validating GM healthy status*/
 #define vgpu_is_vm_unhealthy(ret_val) \
 	(((ret_val) == -EBADRQC) || ((ret_val) == -EFAULT))

commit 690c3df85f107c7e2b5726392e0f53bb18ec9f73
Author: Julian Stecklina <julian.stecklina@cyberus-technology.de>
Date:   Thu Jan 9 19:13:55 2020 +0200

    drm/i915/gvt: remove unused vblank_done completion
    
    This variable is used nowhere, so remove it.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Julian Stecklina <julian.stecklina@cyberus-technology.de>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200109171357.115936-3-julian.stecklina@cyberus-technology.de

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0081b051d3e0..9fe9decc0d86 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -226,8 +226,6 @@ struct intel_vgpu {
 	struct mutex dmabuf_lock;
 	struct idr object_idr;
 
-	struct completion vblank_done;
-
 	u32 scan_nonprivbb;
 };
 

commit c5bd85353c0e2dac3e30855a9e4953c0c408dfef
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Mon Dec 2 15:01:07 2019 +0800

    drm/i915/gvt: remove unused type attributes
    
    Only need to get attribute group instead of attributes and it has
    no use, so remove it.
    
    Reviewed-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20191202070109.73924-1-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b47c6acaf9c0..0081b051d3e0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -570,8 +570,7 @@ struct intel_gvt_ops {
 	void (*vgpu_deactivate)(struct intel_vgpu *);
 	struct intel_vgpu_type *(*gvt_find_vgpu_type)(struct intel_gvt *gvt,
 			const char *name);
-	bool (*get_gvt_attrs)(struct attribute ***type_attrs,
-			struct attribute_group ***intel_vgpu_type_groups);
+	bool (*get_gvt_attrs)(struct attribute_group ***intel_vgpu_type_groups);
 	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);
 	int (*vgpu_get_dmabuf)(struct intel_vgpu *vgpu, unsigned int);
 	int (*write_protect_handler)(struct intel_vgpu *, u64, void *,

commit 8cfbca7848ffe3f5d49155748814cd68a774e449
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Jul 22 14:07:07 2019 +0300

    drm/i915/gvt: factor out tlb and mocs register offset table
    
    Factor out tlb and mocs register offset table to fix the issues reported
    by klocwork, #512 and #550. Mostly, the reason why the klocwork reports
    these problems is because there can be possbilities for platforms, which
    have more rings than the ring offset table, to take the dirty data from
    the stack as the register offset. It results to a random HW register
    offset writting in this scenairo when doing context switch between vGPUs.
    
    After the factoring, the ring offset table of TLB and MOCS should be per
    platform.
    
    v2:
    
    - Enable TLB register switch for GEN8. (Zhenyu)
    
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 3ff59dcf6977..b47c6acaf9c0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -334,6 +334,10 @@ struct intel_gvt {
 	struct {
 		struct engine_mmio *mmio;
 		int ctx_mmio_count[I915_NUM_ENGINES];
+		u32 *tlb_mmio_offset_list;
+		u32 tlb_mmio_offset_list_cnt;
+		u32 *mocs_mmio_offset_list;
+		u32 mocs_mmio_offset_list_cnt;
 	} engine_mmio_list;
 
 	struct dentry *debugfs_root;

commit f8871ec8fc73f57295703a8d61c8c33d7ab4805b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:34:19 2019 +0200

    drm/i915/gvt: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Because there is no need to check these functions, a number of local
    functions can be made to return void to simplify things as nothing can
    fail.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: intel-gvt-dev@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 7a1fe44d45af..3ff59dcf6977 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -682,9 +682,9 @@ static inline void intel_gvt_mmio_set_in_ctx(
 	gvt->mmio.mmio_attribute[offset >> 2] |= F_IN_CTX;
 }
 
-int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu);
-int intel_gvt_debugfs_init(struct intel_gvt *gvt);
+void intel_gvt_debugfs_init(struct intel_gvt *gvt);
 void intel_gvt_debugfs_clean(struct intel_gvt *gvt);
 
 

commit d858d5695f3897d55df68452066a90d7560cb845
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:54 2019 -0700

    drm/i915: update rpm_get/put to use the rpm structure
    
    The functions where internally already only using the structure, so we
    need to just flip the interface.
    
    v2: rebase
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-7-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index dfd10cf82b65..7a1fe44d45af 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -584,12 +584,12 @@ enum {
 
 static inline void mmio_hw_access_pre(struct drm_i915_private *dev_priv)
 {
-	intel_runtime_pm_get(dev_priv);
+	intel_runtime_pm_get(&dev_priv->runtime_pm);
 }
 
 static inline void mmio_hw_access_post(struct drm_i915_private *dev_priv)
 {
-	intel_runtime_pm_put_unchecked(dev_priv);
+	intel_runtime_pm_put_unchecked(&dev_priv->runtime_pm);
 }
 
 /**

commit 0cf289bd5de3f26d28781d81650e5bf022702a7e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 13 08:32:54 2019 +0100

    drm/i915: Move fence register tracking from i915->mm to ggtt
    
    As the fence registers only apply to regions inside the GGTT is makes
    more sense that we track these as part of the i915_ggtt and not the
    general mm. In the next patch, we will then pull the register locking
    underneath the i915_ggtt.mutex.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613073254.24048-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b54f2bdc13a4..dfd10cf82b65 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -87,7 +87,7 @@ struct intel_vgpu_gm {
 
 /* Fences owned by a vGPU */
 struct intel_vgpu_fence {
-	struct drm_i915_fence_reg *regs[INTEL_GVT_MAX_NUM_FENCES];
+	struct i915_fence_reg *regs[INTEL_GVT_MAX_NUM_FENCES];
 	u32 base;
 	u32 size;
 };
@@ -390,7 +390,7 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 #define gvt_hidden_gmadr_end(gvt) (gvt_hidden_gmadr_base(gvt) \
 				   + gvt_hidden_sz(gvt) - 1)
 
-#define gvt_fence_sz(gvt) (gvt->dev_priv->num_fence_regs)
+#define gvt_fence_sz(gvt) ((gvt)->dev_priv->ggtt.num_fences)
 
 /* Aperture/GM space definitions for vGPU */
 #define vgpu_aperture_offset(vgpu)	((vgpu)->gm.low_gm_node.start)

commit 251d46b0875c7bb9ff4571a5248550a7427e0b50
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 26 17:33:28 2019 +0100

    drm/i915/gvt: Pin the per-engine GVT shadow contexts
    
    Our eventual goal is to rid request construction of struct_mutex, with
    the short term step of lifting the struct_mutex requirements into the
    higher levels (i.e. the caller must ensure that the context is already
    pinned into the GTT). In this patch, we pin GVT's shadow context upon
    allocation and so keep them pinned into the GGTT for as long as the
    virtual machine is alive, and so we can use the simpler request
    construction path safe in the knowledge that the hard work is already
    done.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190426163336.15906-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index f5a328b5290a..b54f2bdc13a4 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -149,9 +149,9 @@ struct intel_vgpu_submission_ops {
 struct intel_vgpu_submission {
 	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
 	struct list_head workload_q_head[I915_NUM_ENGINES];
+	struct intel_context *shadow[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
-	struct i915_gem_context *shadow_ctx;
 	union {
 		u64 i915_context_pml4;
 		u64 i915_context_pdps[GEN8_3LVL_PDPES];

commit 95d002e0a34cb0f238abb39987f9980f325d8332
Merge: d57b39e3ee3c 28d618e9ab86
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Apr 16 16:50:34 2019 +0800

    Merge tag 'drm-intel-next-2019-04-04' into gvt-next
    
    Merge back drm-intel-next for engine name definition refinement
    and 54939ea0bd85 ("drm/i915: Switch to use HWS indices rather than addresses")
    that would need gvt fixes to depend on.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

commit 3a891a62679424e5625a551b9af9c33af6ea59b3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Apr 1 17:26:39 2019 +0100

    drm/i915: Move intel_engine_mask_t around for use by i915_request_types.h
    
    We want to use intel_engine_mask_t inside i915_request.h, which means
    extracting it from the general header file mess and placing it inside a
    types.h. A knock on effect is that the compiler wants to warn about
    type-contraction of ALL_ENGINES into intel_engine_maskt_t, so prepare
    for the worst.
    
    v2: Use intel_engine_mask_t consistently
    v3: Move I915_NUM_ENGINES to its natural home at the end of the enum
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190401162641.10963-1-chris@chris-wilson.co.uk
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 8bce09de4b82..7a4e1a6387e5 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -144,9 +144,9 @@ enum {
 
 struct intel_vgpu_submission_ops {
 	const char *name;
-	int (*init)(struct intel_vgpu *vgpu, unsigned long engine_mask);
-	void (*clean)(struct intel_vgpu *vgpu, unsigned long engine_mask);
-	void (*reset)(struct intel_vgpu *vgpu, unsigned long engine_mask);
+	int (*init)(struct intel_vgpu *vgpu, intel_engine_mask_t engine_mask);
+	void (*clean)(struct intel_vgpu *vgpu, intel_engine_mask_t engine_mask);
+	void (*reset)(struct intel_vgpu *vgpu, intel_engine_mask_t engine_mask);
 };
 
 struct intel_vgpu_submission {
@@ -488,7 +488,7 @@ struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_release_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
-				 unsigned int engine_mask);
+				 intel_engine_mask_t engine_mask);
 void intel_gvt_reset_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_activate_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_deactivate_vgpu(struct intel_vgpu *vgpu);

commit 9c1c8416fc3759d52e6e173d4059149d5d2c6c00
Author: Yan Zhao <yan.y.zhao@intel.com>
Date:   Sun Mar 10 21:40:45 2019 -0400

    drm/i915/gvt: remove the unused sreg
    
    code cleanup. sreg is not used now. remove it for code cleanness.
    
    v3: remove unnecessary array_size in vreg's memory allocation (min he)
    v2: do not allocate memory for sreg. (min he)
    
    Reviewed-by: He, Min <min.he@intel.com>
    Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index db82a420efcc..05e9c2dd6183 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -94,7 +94,6 @@ struct intel_vgpu_fence {
 
 struct intel_vgpu_mmio {
 	void *vreg;
-	void *sreg;
 };
 
 #define INTEL_GVT_MAX_BAR_NUM 4
@@ -447,10 +446,6 @@ void intel_vgpu_write_fence(struct intel_vgpu *vgpu,
 	(*(u64 *)(vgpu->mmio.vreg + i915_mmio_reg_offset(reg)))
 #define vgpu_vreg64(vgpu, offset) \
 	(*(u64 *)(vgpu->mmio.vreg + (offset)))
-#define vgpu_sreg_t(vgpu, reg) \
-	(*(u32 *)(vgpu->mmio.sreg + i915_mmio_reg_offset(reg)))
-#define vgpu_sreg(vgpu, offset) \
-	(*(u32 *)(vgpu->mmio.sreg + (offset)))
 
 #define for_each_active_vgpu(gvt, vgpu, id) \
 	idr_for_each_entry((&(gvt)->vgpu_idr), (vgpu), (id)) \

commit 2c7f9a4df9def07867087a520bc32169e2eec9f8
Author: Colin Xu <colin.xu@intel.com>
Date:   Thu Feb 14 12:56:33 2019 +0800

    drm/i915/gvt: Use consist max display pipe numbers as i915 definition
    
    GVT implements a homogeneous vGPU as host GPU so max vGPU display pipes
    can't exceed HW. The inconsistency definition has potential risks which
    could cause array indexing overflow.
    
    Remove the unnecessary define of INTEL_GVT_MAX_PIPE and align with i915.
    
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0ba4b42e3bb0..db82a420efcc 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -111,11 +111,9 @@ struct intel_vgpu_cfg_space {
 
 #define vgpu_cfg_space(vgpu) ((vgpu)->cfg_space.virtual_cfg_space)
 
-#define INTEL_GVT_MAX_PIPE 4
-
 struct intel_vgpu_irq {
 	bool irq_warn_once[INTEL_GVT_EVENT_MAX];
-	DECLARE_BITMAP(flip_done_event[INTEL_GVT_MAX_PIPE],
+	DECLARE_BITMAP(flip_done_event[I915_MAX_PIPES],
 		       INTEL_GVT_EVENT_MAX);
 };
 

commit 1b4fd5d38c633344bca57c1dd874c49474c94462
Merge: 7360c9f6b857 39c68e87bc50
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Feb 1 09:03:23 2019 -0800

    Merge tag 'gvt-next-2019-02-01' of https://github.com/intel/gvt-linux into drm-intel-next-queued
    
    gvt-next-2019-02-01
    
    - new VFIO EDID region support (Henry)
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    From: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190201061523.GE5588@zhen-hp.sh.intel.com

commit 1ca20f33df42ee61a4ae1bf4f2abf8e5f77a16fc
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Wed Jan 30 18:25:53 2019 +0800

    drm/i915/gvt: add hotplug emulation
    
    Add function to emulate hotplug interrupt for SKL/KBL platforms
    
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 8a4cf995d755..0ba4b42e3bb0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -536,6 +536,8 @@ int intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,
 int intel_vgpu_emulate_cfg_write(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 
+void intel_vgpu_emulate_hotplug(struct intel_vgpu *vgpu, bool connected);
+
 static inline u64 intel_vgpu_get_bar_gpa(struct intel_vgpu *vgpu, int bar)
 {
 	/* We are 64bit bar. */
@@ -577,6 +579,7 @@ struct intel_gvt_ops {
 	int (*vgpu_get_dmabuf)(struct intel_vgpu *vgpu, unsigned int);
 	int (*write_protect_handler)(struct intel_vgpu *, u64, void *,
 				     unsigned int);
+	void (*emulate_hotplug)(struct intel_vgpu *vgpu, bool connected);
 };
 
 

commit ff00d85b4df97bf9cc7082b3d0dc2c317b946aa2
Merge: 0cdc1d07b461 2e679d48f38c
Author: Rodrigo Vivi <vivijim@rdvivi-cozumel.jf.intel.com>
Date:   Thu Jan 24 14:50:02 2019 -0800

    Merge tag 'gvt-next-2019-01-24' of https://github.com/intel/gvt-linux into drm-intel-next-queued
    
    gvt-next-2019-01-24
    
    - split kvmgt as seperate module (Zhenyu)
    - Coffeelake GVT support (Fred)
    - const treatment and change for kernel type (Jani)
    
    Signed-off-by: Rodrigo Vivi <vivijim@rdvivi-cozumel.jf.intel.com>
    From: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190124054048.GO7203@zhen-hp.sh.intel.com

commit 16e4dd0342a804090fd0958bb271d3a6b57056ac
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 14 14:21:10 2019 +0000

    drm/i915: Markup paired operations on wakerefs
    
    The majority of runtime-pm operations are bounded and scoped within a
    function; these are easy to verify that the wakeref are handled
    correctly. We can employ the compiler to help us, and reduce the number
    of wakerefs tracked when debugging, by passing around cookies provided
    by the various rpm_get functions to their rpm_put counterpart. This
    makes the pairing explicit, and given the required wakeref cookie the
    compiler can verify that we pass an initialised value to the rpm_put
    (quite handy for double checking error paths).
    
    For regular builds, the compiler should be able to eliminate the unused
    local variables and the program growth should be minimal. Fwiw, it came
    out as a net improvement as gcc was able to refactor rpm_get and
    rpm_get_if_in_use together,
    
    v2: Just s/rpm_put/rpm_put_unchecked/ everywhere, leaving the manual
    mark up for smaller more targeted patches.
    v3: Mention the cookie in Returns
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190114142129.24398-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b4ab1dad0143..435c746c3f73 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -597,7 +597,7 @@ static inline void mmio_hw_access_pre(struct drm_i915_private *dev_priv)
 
 static inline void mmio_hw_access_post(struct drm_i915_private *dev_priv)
 {
-	intel_runtime_pm_put(dev_priv);
+	intel_runtime_pm_put_unchecked(dev_priv);
 }
 
 /**

commit 9bdb073464d6008ed1839d358e320108ed12daae
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:53 2018 +0800

    drm/i915/gvt: Change KVMGT as self load module
    
    This trys to make 'kvmgt' module as self loadable instead of loading
    by i915/gvt device model. So hypervisor specific module could be
    stand-alone, e.g only after loading hypervisor specific module, GVT
    feature could be enabled via specific hypervisor interface, e.g VFIO/mdev.
    
    So this trys to use hypervisor module register/unregister interface
    for that. Hypervisor module needs to take care of module reference
    itself when working for hypervisor interface, e.g for VFIO/mdev,
    hypervisor module would reference counting mdev when open and release.
    
    This makes 'kvmgt' module really split from GVT device model. User
    needs to load 'kvmgt' to enable VFIO/mdev interface.
    
    v6:
    - remove unused variable
    
    v5:
    - put module reference in register error path
    
    v4:
    - fix checkpatch warning
    
    v3:
    - Fix module reference handling for device open and release. Unused
      mdev devices would be cleaned up in device unregister when module unload.
    
    v2:
    - Fix kvmgt order after i915 for built-in case
    
    Cc: "Yuan, Hang" <hang.yuan@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: "He, Min" <min.he@intel.com>
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b4ab1dad0143..8a4cf995d755 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -52,12 +52,8 @@
 
 #define GVT_MAX_VGPU 8
 
-enum {
-	INTEL_GVT_HYPERVISOR_XEN = 0,
-	INTEL_GVT_HYPERVISOR_KVM,
-};
-
 struct intel_gvt_host {
+	struct device *dev;
 	bool initialized;
 	int hypervisor_type;
 	struct intel_gvt_mpt *mpt;

commit f39a89b8f738b683e720185cdbbd1e6d626fada9
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Thu Nov 29 16:25:54 2018 +0800

    drm/i915/gvt: Fix shadow ctx ppgtt destroy function
    
    Recently gvt shadow ctx create ppgtt table and this ppgtt's root
    pointer is modified at workload dispatch, then we lose the original
    ppgtt's root pointer, this causes the ppgtt destroy function abnormal
    as it will release the wrong root table.
    
    This patch save i915 context ppgtt root pointer at shadow
    ctx creation and restore it at shadow ctx destruction.
    
    v2: Split save and restore function (Zhenyu)
    
    Fixes:4f15665ccbba("drm/i915: Add ppgtt to GVT GEM context")
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 31f6cdbe5c42..b4ab1dad0143 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -159,6 +159,10 @@ struct intel_vgpu_submission {
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
 	struct i915_gem_context *shadow_ctx;
+	union {
+		u64 i915_context_pml4;
+		u64 i915_context_pdps[GEN8_3LVL_PDPES];
+	};
 	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	void *ring_scan_buffer[I915_NUM_ENGINES];

commit f9090d4c22130c861b9e00e063812ac69d93a4a2
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Tue Aug 7 18:29:21 2018 +0800

    drm/i915/gvt: free workload in vgpu release
    
    Some workloads may be prepared in vgpu's queue but not be scheduled
    to run yet. If vgpu is released at this time, they will not be freed
    in workload complete callback and so need to be freed in vgpu release
    operation.
    
    Add new vgpu_release operation in gvt_ops to stop vgpu and release
    runtime resources. gvt_ops vgpu_deactivate operation will only stop
    vgpu.
    
    v2: add new gvt ops to clean vgpu running status (Xiong Zhang)
    
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Reviewed-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9a9671522774..31f6cdbe5c42 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -486,6 +486,7 @@ void intel_gvt_destroy_idle_vgpu(struct intel_vgpu *vgpu);
 struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 					 struct intel_vgpu_type *type);
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_release_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
 				 unsigned int engine_mask);
 void intel_gvt_reset_vgpu(struct intel_vgpu *vgpu);
@@ -563,7 +564,8 @@ struct intel_gvt_ops {
 				unsigned int);
 	struct intel_vgpu *(*vgpu_create)(struct intel_gvt *,
 				struct intel_vgpu_type *);
-	void (*vgpu_destroy)(struct intel_vgpu *);
+	void (*vgpu_destroy)(struct intel_vgpu *vgpu);
+	void (*vgpu_release)(struct intel_vgpu *vgpu);
 	void (*vgpu_reset)(struct intel_vgpu *);
 	void (*vgpu_activate)(struct intel_vgpu *);
 	void (*vgpu_deactivate)(struct intel_vgpu *);

commit 3fce4618279373efc59a91adb16c11da46cd69e5
Merge: ecd7963f7cf9 acb1872577b3
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jul 30 10:39:22 2018 +1000

    BackMerge v4.18-rc7 into drm-next
    
    rmk requested this for armada and I think we've had a few
    conflicts build up.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 6cef21a1964933b77c855c55bac2723053cc676d
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Tue Jul 3 17:31:17 2018 +0800

    drm/i915/gvt: update vreg on inhibit context lri command
    
    Commit cd7e 61b9"init mmio by lri command in vgpu inhibit context"
    initializes registers saved/restored in context with its vreg value
    through lri command in ring buffer. It relies on vreg got updated
    on every guest access. There is a case found that Linux guest uses
    lri command in inhibit-ctx to update the register. This patch adds
    vreg update on this case.
    
    v2: move mmio_attribute functions to gvt.h (Zhenyu)
    v3: use mask_mmio_write in vreg update
    v4: refine codes and add more comments (Zhenyu)
    
    Fixes: cd7e61b9("drm/i915/gvt: init mmio by lri command in vgpu inhibit context")
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Weinan Li <weinan.z.li@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 05d15a095310..858967daf04b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -268,6 +268,8 @@ struct intel_gvt_mmio {
 #define F_CMD_ACCESSED	(1 << 5)
 /* This reg could be accessed by unaligned address */
 #define F_UNALIGN	(1 << 6)
+/* This reg is saved/restored in context */
+#define F_IN_CTX	(1 << 7)
 
 	struct gvt_mmio_block *mmio_block;
 	unsigned int num_mmio_block;
@@ -639,6 +641,33 @@ static inline bool intel_gvt_mmio_has_mode_mask(
 	return gvt->mmio.mmio_attribute[offset >> 2] & F_MODE_MASK;
 }
 
+/**
+ * intel_gvt_mmio_is_in_ctx - check if a MMIO has in-ctx mask
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ * Returns:
+ * True if a MMIO has a in-context mask, false if it isn't.
+ *
+ */
+static inline bool intel_gvt_mmio_is_in_ctx(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	return gvt->mmio.mmio_attribute[offset >> 2] & F_IN_CTX;
+}
+
+/**
+ * intel_gvt_mmio_set_in_ctx - mask a MMIO in logical context
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ */
+static inline void intel_gvt_mmio_set_in_ctx(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	gvt->mmio.mmio_attribute[offset >> 2] |= F_IN_CTX;
+}
+
 int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu);
 int intel_gvt_debugfs_init(struct intel_gvt *gvt);

commit 0766e2efc6968179ceec9828caf740ec0ac58a15
Merge: 9a512e23f173 14c3f8425080
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Jun 7 10:24:50 2018 +0800

    Merge tag 'drm-intel-next-2018-06-06' into gvt-next
    
    Backmerge for recent request->hw_context change and
    new vGPU huge page capability definition.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

commit 82ad6443a55ea274ab2f0e24ada71f0529f3238b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jun 5 16:37:58 2018 +0100

    drm/i915/gtt: Rename i915_hw_ppgtt base member
    
    In the near future, I want to subclass gen6_hw_ppgtt as it contains a
    few specialised members and I wish to add more. To avoid the ugliness of
    using ppgtt->base.base, rename the i915_hw_ppgtt base member
    (i915_address_space) as vm, which is our common shorthand for an
    i915_address_space local.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Matthew Auld <matthew.william.auld@gmail.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180605153758.18422-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 05d15a095310..2ff0d40281a9 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -361,9 +361,9 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 #define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
 #define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.gmadr.start)
 
-#define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.base.total)
+#define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.vm.total)
 #define gvt_ggtt_sz(gvt) \
-	((gvt->dev_priv->ggtt.base.total >> PAGE_SHIFT) << 3)
+	((gvt->dev_priv->ggtt.vm.total >> PAGE_SHIFT) << 3)
 #define gvt_hidden_sz(gvt)	  (gvt_ggtt_gm_sz(gvt) - gvt_aperture_sz(gvt))
 
 #define gvt_aperture_gmadr_base(gvt) (0)

commit 9a512e23f173a3598709b74d6ccf9a6616403967
Author: Colin Xu <colin.xu@intel.com>
Date:   Sat May 19 12:28:55 2018 +0800

    drm/i915/gvt: Use sched_lock to protect gvt scheduler logic.
    
    The scheduler lock(gvt->sched_lock) is used to protect gvt
    scheduler logic, including the gvt scheduler structure(gvt->scheduler
    and per vgpu schedule data(vgpu->sched_data, vgpu->sched_ctl).
    
    v9:
      - Change commit author since the patches are improved a lot compared
        with original version.
        Original author: Pei Zhang <pei.zhang@intel.com>
      - Rebase to latest gvt-staging.
    v8:
      - Correct coding wqstyle.
      - Rebase to latest gvt-staging.
    v7:
      - Remove gtt_lock since already proteced by gvt_lock and vgpu_lock.
    v6:
      - Rebase to latest gvt-staging.
    v5:
      - Rebase to latest gvt-staging.
    v4:
      - Rebase to latest gvt-staging.
    v3: update to latest code base
    
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 3600553c8b56..362e3d506d2d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -177,6 +177,11 @@ struct intel_vgpu {
 	bool pv_notified;
 	bool failsafe;
 	unsigned int resetting_eng;
+
+	/* Both sched_data and sched_ctl can be seen a part of the global gvt
+	 * scheduler structure. So below 2 vgpu data are protected
+	 * by sched_lock, not vgpu_lock.
+	 */
 	void *sched_data;
 	struct vgpu_sched_ctl sched_ctl;
 
@@ -299,6 +304,9 @@ struct intel_gvt {
 	 * not yet protected by special locks(vgpu and scheduler lock).
 	 */
 	struct mutex lock;
+	/* scheduler scope lock, protect gvt and vgpu schedule related data */
+	struct mutex sched_lock;
+
 	struct drm_i915_private *dev_priv;
 	struct idr vgpu_idr;	/* vGPU IDR pool */
 

commit f25a49ab8ab9c1b5587837c8a386b276403f315c
Author: Colin Xu <colin.xu@intel.com>
Date:   Sat May 19 12:28:54 2018 +0800

    drm/i915/gvt: Use vgpu_lock to protect per vgpu access
    
    The patch set splits out 2 small locks from the original big gvt lock:
      - vgpu_lock protects per-vGPU data and logic, especially the vGPU
        trap emulation path.
      - sched_lock protects gvt scheudler structure, context schedule logic
        and vGPU's schedule data.
    
    Use vgpu_lock to replace the gvt big lock. By doing this, the
    mmio read/write trap path, vgpu virtual event emulation and other
    vgpu related process, would be protected under per vgpu_lock.
    
    v9:
      - Change commit author since the patches are improved a lot compared
        with original version.
        Original author: Pei Zhang <pei.zhang@intel.com>
      - Rebase to latest gvt-staging.
    v8:
      - Correct coding and comment style.
      - Rebase to latest gvt-staging.
    v7:
      - Remove gtt_lock since already proteced by gvt_lock and vgpu_lock.
      - Fix a typo in intel_gvt_deactivate_vgpu, unlock the wrong lock.
    v6:
      - Rebase to latest gvt-staging.
    v5:
      - Rebase to latest gvt-staging.
      - intel_vgpu_page_track_handler should use vgpu_lock.
    v4:
      - Rebase to latest gvt-staging.
      - Protect vgpu->active access with vgpu_lock.
      - Do not wait gpu idle in vgpu_lock.
    v3: update to latest code base
    v2: add gvt->lock in function gvt_check_vblank_emulation
    
    Performance comparison on Kabylake platform.
      - Configuration:
        Host: Ubuntu 16.04.
        Guest 1 & 2: Ubuntu 16.04.
    
    glmark2 score comparison:
      - Configuration:
        Host: glxgears.
        Guests: glmark2.
    +--------------------------------+-----------------+
    | Setup                          | glmark2 score   |
    +--------------------------------+-----------------+
    | unified lock, iommu=on         | 58~62 (avg. 60) |
    +--------------------------------+-----------------+
    | unified lock, iommu=igfx_off   | 57~61 (avg. 59) |
    +--------------------------------+-----------------+
    | per-logic lock, iommu=on       | 60~68 (avg. 64) |
    +--------------------------------+-----------------+
    | per-logic lock, iommu=igfx_off | 61~67 (avg. 64) |
    +--------------------------------+-----------------+
    
    lock_stat comparison:
      - Configuration:
        Stop lock stat immediately after boot up.
        Boot 2 VM Guests.
        Run glmark2 in guests.
        Start perf lock_stat for 20 seconds and stop again.
      - Legend: c - contentions; w - waittime-avg
    +------------+-----------------+-----------+---------------+------------+
    |            | gvt_lock        |sched_lock | vgpu_lock     | gtt_lock   |
    + lock type; +-----------------+-----------+---------------+------------+
    | iommu set  | c     | w       | c  | w    | c    | w      | c   | w    |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | unified;   | 20697 | 839     |N/A | N/A  | N/A  | N/A    | N/A | N/A  |
    | on         |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | unified;   | 21838 | 658.15  |N/A | N/A  | N/A  | N/A    | N/A | N/A  |
    | igfx_off   |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | per-logic; | 1553  | 1599.96 |9458|429.97| 5846 | 274.33 | 0   | 0.00 |
    | on         |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | per-logic; | 1911  | 1678.32 |8335|445.16| 5451 | 244.80 | 0   | 0.00 |
    | igfx_off   |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 05d15a095310..3600553c8b56 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -170,6 +170,7 @@ struct intel_vgpu_submission {
 
 struct intel_vgpu {
 	struct intel_gvt *gvt;
+	struct mutex vgpu_lock;
 	int id;
 	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
 	bool active;
@@ -294,6 +295,9 @@ struct intel_vgpu_type {
 };
 
 struct intel_gvt {
+	/* GVT scope lock, protect GVT itself, and all resource currently
+	 * not yet protected by special locks(vgpu and scheduler lock).
+	 */
 	struct mutex lock;
 	struct drm_i915_private *dev_priv;
 	struct idr vgpu_idr;	/* vGPU IDR pool */
@@ -314,6 +318,10 @@ struct intel_gvt {
 
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;
+
+	/* service_request is always used in bit operation, we should always
+	 * use it with atomic bit ops so that no need to use gvt big lock.
+	 */
 	unsigned long service_request;
 
 	struct {

commit b99f514f5dfa38e04ef0b628d82a97772945cae7
Author: Changbin Du <changbin.du@intel.com>
Date:   Thu Apr 19 12:12:37 2018 +0800

    drm/i915/gvt: Remove disable_warn_untrack and print untracked mmio with debug level
    
    The disable_warn_untrack never prevent gvt from printing untracked
    mmio errors. We were disturbed by this error storm and the fix is
    just adding them to the list with no essential new change.
    
    This message is only useful for enabling new platform during
    developing process. So lower the message level to debug and then
    remove disable_warn_untrack.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 6ec888822a0f..05d15a095310 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -99,7 +99,6 @@ struct intel_vgpu_fence {
 struct intel_vgpu_mmio {
 	void *vreg;
 	void *sreg;
-	bool disable_warn_untrack;
 };
 
 #define INTEL_GVT_MAX_BAR_NUM 4

commit 96bebe39b2f4533af14c509061cd2b551ca81e8d
Author: Zhao Yan <yan.y.zhao@intel.com>
Date:   Wed Apr 4 13:57:09 2018 +0800

    drm/i915/gvt: scan non-privileged batch buffer for debug purpose
    
    For perfomance purpose, scanning of non-privileged batch buffer is turned
    off by default. But for debugging purpose, it can be turned on via debugfs.
    After scanning, we submit the original non-privileged batch buffer into
    hardware, so that the scanning is only a peeking window of guest submitted
    commands and will not affect the execution results.
    
    v4:
    - refine debugfs print format&content (zhenyu wang)
    - print engine id instread of engine name to prevent potential memory leak
      in debugfs warning message. (zhenyu wang)
    
    v3:
    - change vgpu->scan_nonprivbb from type bool to u32, so it is able to
      selectively turn on/off scanning of non-privileged batch buffer on engine
      level. e.g.
      if vgpu->scan_nonprivbb=3, then it will scan non-privileged batch buffer
      on engine 0 and 1.
    - in debugfs interface to set vgpu->scan_nonprivbb, print warning message
      to warn user and explicitly tell state change in kernel log (zhenyu wang)
    v2:
    - rebase
    - update comments for start_gma_offset (henry)
    
    Signed-off-by: Zhao Yan <yan.y.zhao@intel.com>
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index efacd8abbedc..6ec888822a0f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -226,6 +226,7 @@ struct intel_vgpu {
 
 	struct completion vblank_done;
 
+	u32 scan_nonprivbb;
 };
 
 /* validating GM healthy status*/

commit 6846dfeb87a623e0bf31df4b6a7041d70277b0e5
Author: Changbin Du <changbin.du@intel.com>
Date:   Mon Mar 5 15:30:34 2018 +0800

    drm/i915/kvmgt: Add kvmgt debugfs entry nr_cache_entries under vgpu
    
    Add a new debugfs entry kvmgt_nr_cache_entries under vgpu which shows
    the number of entry in dma cache.
    
    $ cat /sys/kernel/debug/gvt/vgpu1/kvmgt_nr_cache_entries
    10101
    
    v3: fix compiling error for some configuration. (Xiong Zhang <xiong.y.zhang@intel.com>)
    v2: keep debugfs layout flat.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index eda41448c196..efacd8abbedc 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -208,6 +208,7 @@ struct intel_vgpu {
 		 */
 		struct rb_root gfn_cache;
 		struct rb_root dma_addr_cache;
+		unsigned long nr_cache_entries;
 		struct mutex cache_lock;
 
 		struct notifier_block iommu_notifier;

commit cf4ee73fd9b6d31fa7530f72cff5cc97b94f1272
Author: Changbin Du <changbin.du@intel.com>
Date:   Thu Mar 1 15:49:59 2018 +0800

    drm/i915/gvt: Fix guest vGPU hang caused by very high dma setup overhead
    
    The implementation of current kvmgt implicitly setup dma mapping at MPT
    API gfn_to_mfn. First this design against the API's original purpose.
    Second, there is no unmap hit in this design. The result is that the
    dma mapping keep growing larger and larger. For mutl-vm case, they will
    consume IOMMU IOVA low 4GB address space quickly and so tons of rbtree
    entries crated in the IOMMU IOVA allocator. Finally, single IOVA
    allocation can take as long as ~70ms. Such latency is intolerable.
    
    To address both above issues, this patch introduced two new MPT API:
      o dma_map_guest_page - setup dma map for guest page
      o dma_unmap_guest_page - cancel dma map for guest page
    
    The kvmgt implements these 2 API. And to reduce dma setup overhead for
    duplicated pages (eg. scratch pages), two caches are used: one is for
    mapping gfn to struct gvt_dma, another is for mapping dma addr to
    struct gvt_dma.
    
    With these 2 new API, the gtt now is able to cancel dma mapping when page
    table is invalidated. The dma mapping is not in a gradual increase now.
    
    v2: follow the old logic for VFIO_IOMMU_NOTIFY_DMA_UNMAP at this point.
    
    Cc: Hang Yuan <hang.yuan@intel.com>
    Cc: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1df5a2a2dfdf..eda41448c196 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -201,8 +201,15 @@ struct intel_vgpu {
 		int num_regions;
 		struct eventfd_ctx *intx_trigger;
 		struct eventfd_ctx *msi_trigger;
-		struct rb_root cache;
+
+		/*
+		 * Two caches are used to avoid mapping duplicated pages (eg.
+		 * scratch pages). This help to reduce dma setup overhead.
+		 */
+		struct rb_root gfn_cache;
+		struct rb_root dma_addr_cache;
 		struct mutex cache_lock;
+
 		struct notifier_block iommu_notifier;
 		struct notifier_block group_notifier;
 		struct kvm *kvm;

commit 0102d0d9227ae7412e3419973c8cefa69369a9a7
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Feb 22 15:16:12 2018 +0800

    drm/i915/gvt: remove gvt max port definition
    
    Remove GVT-g private max port definition but use i915 one.
    
    Fix error caused by:
    drivers/gpu/drm/i915//gvt/handlers.c:871 dp_aux_ch_ctl_mmio_write() error: buffer overflow 'display->ports' 5 <= 5
    
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9131638e3999..1df5a2a2dfdf 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -132,11 +132,9 @@ struct intel_vgpu_opregion {
 
 #define vgpu_opregion(vgpu) (&(vgpu->opregion))
 
-#define INTEL_GVT_MAX_PORT 5
-
 struct intel_vgpu_display {
 	struct intel_vgpu_i2c_edid i2c_edid;
-	struct intel_vgpu_port ports[INTEL_GVT_MAX_PORT];
+	struct intel_vgpu_port ports[I915_MAX_PORTS];
 	struct intel_vgpu_sbi sbi;
 };
 

commit cd7e61b93d068a80bfe6cb55bf00f17332d831a1
Author: Weinan Li <weinan.z.li@intel.com>
Date:   Fri Feb 23 14:46:45 2018 +0800

    drm/i915/gvt: init mmio by lri command in vgpu inhibit context
    
    There is one issue relates to Coarse Power Gating(CPG) on KBL NUC in GVT-g,
    vgpu can't get the correct default context by updating the registers before
    inhibit context submission. It always get back the hardware default value
    unless the inhibit context submission happened before the 1st time
    forcewake put. With this wrong default context, vgpu will run with
    incorrect state and meet unknown issues.
    
    The solution is initialize these mmios by adding lri command in ring buffer
    of the inhibit context, then gpu hardware has no chance to go down RC6 when
    lri commands are right being executed, and then vgpu can get correct
    default context for further use.
    
    v3:
    - fix code fault, use 'for' to loop through mmio render list(Zhenyu)
    
    v4:
    - save the count of engine mmio need to be restored for inhibit context and
      refine some comments. (Kevin)
    
    v5:
    - code rebase
    
    Cc: Kevin Tian <kevin.tian@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Weinan Li <weinan.z.li@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 2b28b523376d..9131638e3999 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -310,7 +310,10 @@ struct intel_gvt {
 	wait_queue_head_t service_thread_wq;
 	unsigned long service_request;
 
-	struct engine_mmio *engine_mmio_list;
+	struct {
+		struct engine_mmio *mmio;
+		int ctx_mmio_count[I915_NUM_ENGINES];
+	} engine_mmio_list;
 
 	struct dentry *debugfs_root;
 };

commit e502a2af4c358d14ecf8fce51bf4988ebb4d10b4
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jan 30 19:19:53 2018 +0800

    drm/i915/gvt: Provide generic page_track infrastructure for write-protected page
    
    This patch provide generic page_track infrastructure for write-protected
    guest page. The old page_track logic gets rewrote and now stays in a new
    standalone page_track.c. This page track infrastructure can be both used
    by vGUC and GTT shadowing.
    
    The important change is that it uses radix tree instead of hash table.
    We don't have a predictable number of pages that will be tracked.
    
    Here is some performance data (duration in us) of looking up a element:
    Before: (aka. intel_vgpu_find_tracked_page)
     0.091 0.089 0.090 ... 0.093 0.091 0.087 ... 0.292 0.285 0.292 0.291
    After: (aka. intel_vgpu_find_page_track)
     0.104 0.105 0.100 0.102 0.102 0.100 ... 0.101 0.101 0.105 0.105
    
    The hash table has good performance at beginning, but turns bad with
    more pages being tracked even no 3D applications are running. As
    expected, radix tree has stable duration and very quick.
    
    The overall benchmark (tested with Heaven Benchmark) marginally improved
    since this is not the bottleneck. What we benefit more from this change
    is scalability.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index c6197d990818..2b28b523376d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -48,6 +48,7 @@
 #include "cmd_parser.h"
 #include "fb_decoder.h"
 #include "dmabuf.h"
+#include "page_track.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -190,6 +191,7 @@ struct intel_vgpu {
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
 	struct intel_vgpu_submission submission;
+	struct radix_tree_root page_track_tree;
 	u32 hws_pga[I915_NUM_ENGINES];
 
 	struct dentry *debugfs;

commit 95925b9595d95fdf2bfb73fc73dfb696f0c3fc7f
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Wed Jan 31 14:42:44 2018 +0800

    drm/i915/gvt: Use KVM r/w to access guest opregion
    
    For KVMGT, the guest opregion, which is handled by VFIO, is actually a
    piece of guest memory which won't be accessed by devices. So, its mfn
    shouldn't be obtained through VFIO interface. This patch uses KVM r/w
    interface to access the data in guest opregion.
    
    Fix the guest opregion accessing issue when host "intel_iommu=on".
    
    v3:
    - Remove mapped flag for KVM/VFIO usage, as it's useless for KVM.
    
    v2:
    - Set the gpa correctly when invoking KVM r/w operations. (Zhenyu)
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Cc: Yan Zhao <yan.y.zhao@intel.com>
    Cc: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 39bfe81f79ab..c6197d990818 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -126,7 +126,6 @@ struct intel_vgpu_irq {
 struct intel_vgpu_opregion {
 	bool mapped;
 	void *va;
-	void *va_gopregion;
 	u32 gfn[INTEL_GVT_OPREGION_PAGES];
 };
 

commit d480b28a41a628e356dbacfa1c9f6d05b9baf838
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jan 30 13:51:31 2018 +0800

    drm/i915/gvt: Fix aperture read/write emulation when enable x-no-mmap=on
    
    When add 'x-no-mmap=on' for vfio-pci option, aperture access in guest
    is emulated. But the vgpu_aperture_rw() function take wrong offset when
    do memcpy, since vgpu->gm.aperture_va is not the base of entire aperture.
    This mistake cause GPU command in guest get lost and so the seqno is not
    updated in engine HWSP.
    
    This patch fix this, and it also move the emulation code to kvmgt.
    Because only vfio need to emulate it. Put aperture rw to MMIO emulation
    path breaks assumptions in xengt.
    
    v2: Remove PAGE_ALIGN for size (zhenyu)
    
    Fixes: f090a00df9ec ("drm/i915/gvt: Add emulation for BAR2 (aperture) with normal file RW approach")
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index c88c48989822..39bfe81f79ab 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -82,7 +82,6 @@ struct intel_gvt_device_info {
 struct intel_vgpu_gm {
 	u64 aperture_sz;
 	u64 hidden_sz;
-	void *aperture_va;
 	struct drm_mm_node low_gm_node;
 	struct drm_mm_node high_gm_node;
 };

commit 7569a06dc80ec05c96783f541fa706ea3bebec79
Author: Weinan Li <weinan.z.li@intel.com>
Date:   Fri Jan 26 15:09:07 2018 +0800

    drm/i915/gvt: refine intel_vgpu_submission_ops as per engine ops
    
    Using per engine ops will be more flexible, here refine sub-ops(init,
    clean) as per engine operation align with reset operation. This change also
    will be used in next fix patch for VM engine reset.
    
    Cc: Fred Gao <fred.gao@intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Weinan Li <weinan.z.li@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 7dc7a80213a8..c88c48989822 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -152,8 +152,8 @@ enum {
 
 struct intel_vgpu_submission_ops {
 	const char *name;
-	int (*init)(struct intel_vgpu *vgpu);
-	void (*clean)(struct intel_vgpu *vgpu);
+	int (*init)(struct intel_vgpu *vgpu, unsigned long engine_mask);
+	void (*clean)(struct intel_vgpu *vgpu, unsigned long engine_mask);
 	void (*reset)(struct intel_vgpu *vgpu, unsigned long engine_mask);
 };
 

commit 4fafba2d73fcaf1b433c26e753a98ad4b231754a
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Mon Dec 18 11:58:46 2017 +0800

    drm/i915/gvt: move write protect handler out of mmio emulation function
    
    It's a bit confusing that page write protect handler is live in
    mmio emulation handler. This moves it to stand alone gvt ops.
    
    Also remove unnecessary check of write protected page access
    in mmio read handler and cleanup handling of failsafe case.
    
    v2: rebase
    
    Reviewed-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0822d0fd45da..7dc7a80213a8 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -546,6 +546,8 @@ struct intel_gvt_ops {
 			struct attribute_group ***intel_vgpu_type_groups);
 	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);
 	int (*vgpu_get_dmabuf)(struct intel_vgpu *vgpu, unsigned int);
+	int (*write_protect_handler)(struct intel_vgpu *, u64, void *,
+				     unsigned int);
 };
 
 

commit 90551a1296d4dbe0dccc4c3cb5e57e7f2c929009
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Dec 19 13:02:51 2017 +0800

    drm/i915/gvt: cleanup usage for typed mmio reg vs. offset
    
    We had previous hack that tried to accept either i915_reg_t or offset
    value to access vGPU virtual/shadow regs which broke that purpose to
    be type safe in context. This one trys to explicitly separate the usage
    of typed mmio reg with real offset.
    
    Old vgpu_vreg(offset) helper is used only for offset now with new
    vgpu_vreg_t(reg) is used for i915_reg_t only. Convert left usage
    of that to new helper.
    
    Also fixed left KASAN warning issues caused by previous hack.
    
    v2: rebase, fixup against recent mmio switch change
    
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1e9f11c8b7bb..0822d0fd45da 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -412,23 +412,20 @@ void intel_vgpu_free_resource(struct intel_vgpu *vgpu);
 void intel_vgpu_write_fence(struct intel_vgpu *vgpu,
 	u32 fence, u64 value);
 
-/* Macros for easily accessing vGPU virtual/shadow register */
-#define vgpu_vreg(vgpu, reg) \
-	(*(u32 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_vreg8(vgpu, reg) \
-	(*(u8 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_vreg16(vgpu, reg) \
-	(*(u16 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_vreg64(vgpu, reg) \
-	(*(u64 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_sreg(vgpu, reg) \
-	(*(u32 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_sreg8(vgpu, reg) \
-	(*(u8 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_sreg16(vgpu, reg) \
-	(*(u16 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
-#define vgpu_sreg64(vgpu, reg) \
-	(*(u64 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
+/* Macros for easily accessing vGPU virtual/shadow register.
+   Explicitly seperate use for typed MMIO reg or real offset.*/
+#define vgpu_vreg_t(vgpu, reg) \
+	(*(u32 *)(vgpu->mmio.vreg + i915_mmio_reg_offset(reg)))
+#define vgpu_vreg(vgpu, offset) \
+	(*(u32 *)(vgpu->mmio.vreg + (offset)))
+#define vgpu_vreg64_t(vgpu, reg) \
+	(*(u64 *)(vgpu->mmio.vreg + i915_mmio_reg_offset(reg)))
+#define vgpu_vreg64(vgpu, offset) \
+	(*(u64 *)(vgpu->mmio.vreg + (offset)))
+#define vgpu_sreg_t(vgpu, reg) \
+	(*(u32 *)(vgpu->mmio.sreg + i915_mmio_reg_offset(reg)))
+#define vgpu_sreg(vgpu, offset) \
+	(*(u32 *)(vgpu->mmio.sreg + (offset)))
 
 #define for_each_active_vgpu(gvt, vgpu, id) \
 	idr_for_each_entry((&(gvt)->vgpu_idr), (vgpu), (id)) \

commit 07825e4b9311b11df02365a35cdf997d69426b29
Merge: 8d8c46fad4a1 461bd6227ede
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Thu Dec 14 10:57:39 2017 -0800

    Merge tag 'gvt-next-2017-12-14' of https://github.com/intel/gvt-linux into drm-intel-next-queued
    
    gvt-next-2017-12-14:
    
    - fixes for two coverity scan errors (Colin)
    - mmio switch code refine (Changbin)
    - more virtual display dmabuf fixes (Tina/Gustavo)
    - misc cleanups (Pei)
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171214033434.jlppjlyal5d67ya7@zhen-hp.sh.intel.com

commit 73ebd503034c1abe31137df02dd4493eb7a522d4
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Mon Dec 11 15:18:20 2017 +0000

    drm/i915: make mappable struct resource centric
    
    Now that we are using struct resource to track the stolen region, it is
    more convenient if we track the mappable region in a resource as well.
    
    v2: prefer iomap and gmadr naming scheme
        prefer DEFINE_RES_MEM
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211151822.20953-8-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 77df9bad5dea..103910a24e4b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -348,7 +348,7 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 
 /* Aperture/GM space definitions for GVT device */
 #define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
-#define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.mappable_base)
+#define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.gmadr.start)
 
 #define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.base.total)
 #define gvt_ggtt_sz(gvt) \

commit 1aec75ee327f2f2085a4e2b060a3d999b8f4d925
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Dec 8 14:56:23 2017 +0800

    drm/i915/gvt: Rename file render.{c, h} to mmio_context.{c, h}
    
    Rename the files to reflect their real role - to switch the mmio context of
    each vGPU engine.
    
    v2: update Makefile.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 39c2f3a4588e..b4747c270dcb 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -44,7 +44,7 @@
 #include "execlist.h"
 #include "scheduler.h"
 #include "sched_policy.h"
-#include "render.h"
+#include "mmio_context.h"
 #include "cmd_parser.h"
 #include "fb_decoder.h"
 #include "dmabuf.h"

commit 83164886e4559f87015a33780852a64cdd6e4e50
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Dec 8 14:56:21 2017 +0800

    drm/i915/gvt: Select appropriate mmio list at initialization time
    
    Select appropriate mmio list at initialization time, so we don't need to
    do duplicated work at where requires the mmio list.
    
    V2:
      - Add a termination mark of mmio list.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 77df9bad5dea..39c2f3a4588e 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -310,6 +310,8 @@ struct intel_gvt {
 	wait_queue_head_t service_thread_wq;
 	unsigned long service_request;
 
+	struct engine_mmio *engine_mmio_list;
+
 	struct dentry *debugfs_root;
 };
 

commit e546e281d33d1fc275651aa06f0659045db67e68
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Thu Nov 23 16:26:36 2017 +0800

    drm/i915/gvt: Dmabuf support for GVT-g
    
    This patch introduces a guest's framebuffer sharing mechanism based on
    dma-buf subsystem. With this sharing mechanism, guest's framebuffer can
    be shared between guest VM and host.
    
    v17:
    - modify VFIO_DEVICE_GET_GFX_DMABUF interface. (Alex)
    
    v16:
    - add x_hot and y_hot. (Gerd)
    - add flag validation for VFIO_DEVICE_GET_GFX_DMABUF. (Alex)
    - rebase 4.14.0-rc6.
    
    v15:
    - add VFIO_DEVICE_GET_GFX_DMABUF ABI. (Gerd)
    - add intel_vgpu_dmabuf_cleanup() to clean up the vGPU's dmabuf. (Gerd)
    
    v14:
    - add PROBE, DMABUF and REGION flags. (Alex)
    
    v12:
    - refine the lifecycle of dmabuf.
    
    v9:
    - remove dma-buf management. (Alex)
    - track the dma-buf create and release in kernel mode. (Gerd) (Daniel)
    
    v8:
    - refine the dma-buf ioctl definition.(Alex)
    - add a lock to protect the dmabuf list. (Alex)
    
    v7:
    - release dma-buf related allocations in dma-buf's associated release
      function. (Alex)
    - refine ioctl interface for querying plane info or create dma-buf.
      (Alex)
    
    v6:
    - align the dma-buf life cycle with the vfio device. (Alex)
    - add the dma-buf related operations in a separate patch. (Gerd)
    - i915 related changes. (Chris)
    
    v5:
    - fix bug while checking whether the gem obj is gvt's dma-buf when user
      change caching mode or domains. Add a helper function to do it.
      (Xiaoguang)
    - add definition for the query plane and create dma-buf. (Xiaoguang)
    
    v4:
    - fix bug while checking whether the gem obj is gvt's dma-buf when set
      caching mode or doamins. (Xiaoguang)
    
    v3:
    - declare a new flag I915_GEM_OBJECT_IS_GVT_DMABUF in drm_i915_gem_object
      to represent the gem obj for gvt's dma-buf. The tiling mode, caching
      mode and domains can not be changed for this kind of gem object. (Alex)
    - change dma-buf related information to be more generic. So other vendor
      can use the same interface. (Alex)
    
    v2:
    - create a management fd for dma-buf operations. (Alex)
    - alloc gem object's backing storage in gem obj's get_pages() callback.
      (Chris)
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 357d458cded0..77df9bad5dea 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -47,6 +47,7 @@
 #include "render.h"
 #include "cmd_parser.h"
 #include "fb_decoder.h"
+#include "dmabuf.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -209,8 +210,16 @@ struct intel_vgpu {
 		struct kvm *kvm;
 		struct work_struct release_work;
 		atomic_t released;
+		struct vfio_device *vfio_device;
 	} vdev;
 #endif
+
+	struct list_head dmabuf_obj_list_head;
+	struct mutex dmabuf_lock;
+	struct idr object_idr;
+
+	struct completion vblank_done;
+
 };
 
 /* validating GM healthy status*/
@@ -536,6 +545,8 @@ struct intel_gvt_ops {
 			const char *name);
 	bool (*get_gvt_attrs)(struct attribute ***type_attrs,
 			struct attribute_group ***intel_vgpu_type_groups);
+	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);
+	int (*vgpu_get_dmabuf)(struct intel_vgpu *vgpu, unsigned int);
 };
 
 

commit 9f31d1063b434c2d54317461d78285b08538c01a
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Thu Nov 23 16:26:32 2017 +0800

    drm/i915/gvt: Add framebuffer decoder support
    
    This patch is to introduce the framebuffer decoder which can decode guest
    OS's framebuffer information, including primary, cursor and sprite plane.
    
    v16:
    - rebase to 4.14.0-rc6.
    
    v14:
    - refine pixel format table. (Zhenyu)
    
    v9:
    - move drm format change to a separate patch. (Xiaoguang)
    
    v8:
    - fix a bug in decoding primary plane. (Tina)
    
    v7:
    - refine framebuffer decoder code. (Zhenyu)
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index f3999f251cd5..357d458cded0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -46,6 +46,7 @@
 #include "sched_policy.h"
 #include "render.h"
 #include "cmd_parser.h"
+#include "fb_decoder.h"
 
 #define GVT_MAX_VGPU 8
 

commit b851adeac0858c7d257b32eee2142b1519d45ccf
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Mon Nov 20 15:31:16 2017 +0800

    drm/i915/gvt: Add opregion support
    
    Windows guest driver needs vbt in opregion, to configure the setting
    for display. Without opregion support, the display registers won't
    be set and this blocks display model to get the correct information
    of the guest display plane.
    
    This patch is to provide a virtual opregion for guest. The original
    author of this patch is Xiaoguang Chen.
    
    This patch is split from the "Dma-buf support for GVT-g" patch set,
    with being rebased to the latest gvt-staging branch.
    
    v3:
    - add checking region index during intel_vgpu_rw. (Xiong)
    
    v2:
    - refine intel_vgpu_reg_release_opregion. (Xiong)
    
    Here are the previous version comments:
    
    v18:
    - unmap vgpu's opregion when destroying vgpu.
    
    v16:
    - rebase to 4.14.0-rc6.
    
    Signed-off-by: Bing Niu <bing.niu@intel.com>
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Tested-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 07d3ba0f7277..f3999f251cd5 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -125,6 +125,7 @@ struct intel_vgpu_irq {
 struct intel_vgpu_opregion {
 	bool mapped;
 	void *va;
+	void *va_gopregion;
 	u32 gfn[INTEL_GVT_OPREGION_PAGES];
 };
 

commit 4dff110b15aea2f7653957a70921a7be1f45d59b
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Mon Nov 20 15:31:15 2017 +0800

    drm/i915/gvt: Alloc and Init guest opregion at vgpu creation
    
    Currently guest opregion is allocated and initialised when guest
    write opregion base register. This is too late for kvmgt, so
    move it to vgpu_create time.
    
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Tested-by: Tina Zhang <tina.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 393066726993..07d3ba0f7277 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -123,6 +123,7 @@ struct intel_vgpu_irq {
 };
 
 struct intel_vgpu_opregion {
+	bool mapped;
 	void *va;
 	u32 gfn[INTEL_GVT_OPREGION_PAGES];
 };
@@ -505,7 +506,8 @@ static inline u64 intel_vgpu_get_bar_gpa(struct intel_vgpu *vgpu, int bar)
 }
 
 void intel_vgpu_clean_opregion(struct intel_vgpu *vgpu);
-int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
+int intel_vgpu_init_opregion(struct intel_vgpu *vgpu);
+int intel_vgpu_opregion_base_write_handler(struct intel_vgpu *vgpu, u32 gpa);
 
 int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
 void populate_pvinfo_page(struct intel_vgpu *vgpu);

commit b2d6ef70614e9e9dacfa9fc7dac49e7dc22dc8b3
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Wed Nov 8 00:45:21 2017 +0800

    drm/i915/gvt: Let each vgpu has separate opregion memory
    
    Currently every vgpu share a common gvt opregion memory, but
    it is freed at vgpu destroy, then the later vgpu doesn't have
    opregion memory once the first vgpu is destroyed. This cause
    guest function failure like reboot, second or later boot.
    
    This patch allocate and init virt opregion memory for each
    vgpu, so this memory could be freed at vgpu destroy.
    
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 27e8186cbc81..393066726993 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -125,7 +125,6 @@ struct intel_vgpu_irq {
 struct intel_vgpu_opregion {
 	void *va;
 	u32 gfn[INTEL_GVT_OPREGION_PAGES];
-	struct page *pages[INTEL_GVT_OPREGION_PAGES];
 };
 
 #define vgpu_opregion(vgpu) (&(vgpu->opregion))
@@ -265,11 +264,6 @@ struct intel_gvt_firmware {
 	bool firmware_loaded;
 };
 
-struct intel_gvt_opregion {
-	void *opregion_va;
-	u32 opregion_pa;
-};
-
 #define NR_MAX_INTEL_VGPU_TYPES 20
 struct intel_vgpu_type {
 	char name[16];
@@ -293,7 +287,6 @@ struct intel_gvt {
 	struct intel_gvt_firmware firmware;
 	struct intel_gvt_irq irq;
 	struct intel_gvt_gtt gtt;
-	struct intel_gvt_opregion opregion;
 	struct intel_gvt_workload_scheduler scheduler;
 	struct notifier_block shadow_ctx_notifier_block[I915_NUM_ENGINES];
 	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
@@ -511,9 +504,6 @@ static inline u64 intel_vgpu_get_bar_gpa(struct intel_vgpu *vgpu, int bar)
 			PCI_BASE_ADDRESS_MEM_MASK;
 }
 
-void intel_gvt_clean_opregion(struct intel_gvt *gvt);
-int intel_gvt_init_opregion(struct intel_gvt *gvt);
-
 void intel_vgpu_clean_opregion(struct intel_vgpu *vgpu);
 int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
 

commit a2ae95af9646316aaf86e2d18f46de1a5f746f1a
Author: Weinan Li <weinan.z.li@intel.com>
Date:   Fri Oct 20 15:16:46 2017 +0800

    drm/i915/gvt: update CSB and CSB write pointer in virtual HWSP
    
    The engine provides a mirror of the CSB and CSB write pointer in the HWSP.
    Read these status from virtual HWSP in VM can reduce CPU utilization while
    applications have much more short GPU workloads. Here we update the
    corresponding data in virtual HWSP as it in virtual MMIO.
    
    Before read these status from HWSP in GVT-g VM, please ensure the host
    support it by checking the BIT(3) of caps in PVINFO.
    
    Virtual HWSP only support GEN8+ platform, since the HWSP MMIO may change
    follow the platform update, please add the corresponding MMIO emulation
    when enable new platforms in GVT-g.
    
    v3 : Add address audit in HWSP address update.
    
    v4 :
         Separate this patch with enalbe virtual HWSP in VM.
         Use intel_gvt_render_mmio_to_ring_id() to determine ring_id by offset.
    
    v5 : Remove unnessary check about Gen8, GVT-g only support Gen8+.
    
    Signed-off-by: Weinan Li <weinan.z.li@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index f08d194f639f..27e8186cbc81 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -189,6 +189,7 @@ struct intel_vgpu {
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
 	struct intel_vgpu_submission submission;
+	u32 hws_pga[I915_NUM_ENGINES];
 
 	struct dentry *debugfs;
 

commit bc7b0be316aebac42eb9e8e54c984609555944da
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Sep 26 16:19:13 2017 +0800

    drm/i915/gvt: Add basic debugfs infrastructure
    
    We need debugfs entry to expose some debug information of gvt and vGPUs.
    The first tool will be added is mmio-diff, which help to find the
    difference values of host and vGPU mmio. It's useful for platform
    enabling.
    
    This patch just add a basic debugfs infrastructure, each vGPU has its own
    sub-folder. Two simple attributes are created as a template.
    .
    ├── num_tracked_mmio
    ├── vgpu1
    |   └── active
    └── vgpu2
        └── active
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 35c8d87151dd..f08d194f639f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -190,6 +190,8 @@ struct intel_vgpu {
 	struct intel_vgpu_display display;
 	struct intel_vgpu_submission submission;
 
+	struct dentry *debugfs;
+
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {
 		struct mdev_device *mdev;
@@ -253,7 +255,7 @@ struct intel_gvt_mmio {
 	unsigned int num_mmio_block;
 
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
-	unsigned int num_tracked_mmio;
+	unsigned long num_tracked_mmio;
 };
 
 struct intel_gvt_firmware {
@@ -301,6 +303,8 @@ struct intel_gvt {
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;
 	unsigned long service_request;
+
+	struct dentry *debugfs_root;
 };
 
 static inline struct intel_gvt *to_gvt(struct drm_i915_private *i915)
@@ -619,6 +623,12 @@ static inline bool intel_gvt_mmio_has_mode_mask(
 	return gvt->mmio.mmio_attribute[offset >> 2] & F_MODE_MASK;
 }
 
+int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu);
+int intel_gvt_debugfs_init(struct intel_gvt *gvt);
+void intel_gvt_debugfs_clean(struct intel_gvt *gvt);
+
+
 #include "trace.h"
 #include "mpt.h"
 

commit c5d71cb31723135dbaa54b32bf046342fe538210
Author: fred gao <fred.gao@intel.com>
Date:   Thu Sep 28 11:03:02 2017 +0800

    drm/i915/gvt: Move vGPU type related code into gvt file
    
    In this patch, all the vGPU type related code will be merged into
    same gvt file and the common interface will be exposed to both
    XenGT and KvmGT.
    
    v2:
    - remove the useless mdev_* gvt_ops.
      add get_gvt_attr ops for MPT module.
      intel_gvt_{init,cleanup}_vgpu_type_groups are initialized in
      gvt part. (Wang, Zhi)
    - set gvt_vgpu_type_groups[i] to NULL. (Zhang,Xiong)
    
    Signed-off-by: fred gao <fred.gao@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b7253d7daf72..35c8d87151dd 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -533,6 +533,10 @@ struct intel_gvt_ops {
 	void (*vgpu_reset)(struct intel_vgpu *);
 	void (*vgpu_activate)(struct intel_vgpu *);
 	void (*vgpu_deactivate)(struct intel_vgpu *);
+	struct intel_vgpu_type *(*gvt_find_vgpu_type)(struct intel_gvt *gvt,
+			const char *name);
+	bool (*get_gvt_attrs)(struct attribute ***type_attrs,
+			struct attribute_group ***intel_vgpu_type_groups);
 };
 
 

commit 06bb372f9ace47296aeaaca8e130d948ea2855cf
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Wed Sep 13 01:41:35 2017 +0800

    drm/i915/gvt: Introduce intel_vgpu_reset_submission
    
    Introduce an generic API to reset vGPU virtual submission interface.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1be41505c4ba..b7253d7daf72 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -151,6 +151,7 @@ struct intel_vgpu_submission_ops {
 	const char *name;
 	int (*init)(struct intel_vgpu *vgpu);
 	void (*clean)(struct intel_vgpu *vgpu);
+	void (*reset)(struct intel_vgpu *vgpu, unsigned long engine_mask);
 };
 
 struct intel_vgpu_submission {

commit ad1d36369b07f6b9db81897802ee5d8764eaa922
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Wed Sep 13 00:31:29 2017 +0800

    drm/i915/gvt: Introduce vGPU submission ops
    
    Introduce vGPU submission ops to support easy switching submission mode
    of one vGPU between different OSes.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index be1bb6dbcbd2..1be41505c4ba 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -142,6 +142,17 @@ struct vgpu_sched_ctl {
 	int weight;
 };
 
+enum {
+	INTEL_VGPU_EXECLIST_SUBMISSION = 1,
+	INTEL_VGPU_GUC_SUBMISSION,
+};
+
+struct intel_vgpu_submission_ops {
+	const char *name;
+	int (*init)(struct intel_vgpu *vgpu);
+	void (*clean)(struct intel_vgpu *vgpu);
+};
+
 struct intel_vgpu_submission {
 	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
 	struct list_head workload_q_head[I915_NUM_ENGINES];
@@ -152,6 +163,9 @@ struct intel_vgpu_submission {
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	void *ring_scan_buffer[I915_NUM_ENGINES];
 	int ring_scan_buffer_size[I915_NUM_ENGINES];
+	const struct intel_vgpu_submission_ops *ops;
+	int virtual_submission_interface;
+	bool active;
 };
 
 struct intel_vgpu {

commit e011c6ce2b4fc7c577ade41485d74431a4e6ea1a
Author: fred gao <fred.gao@intel.com>
Date:   Tue Sep 19 15:11:28 2017 +0800

    drm/i915/gvt: Add VM healthy check for workload_thread
    
    When a scan error occurs in dispatch_workload, this patch is to
    check the healthy state and free all the queued workloads before
    the failsafe mode is entered.
    
    Signed-off-by: fred gao <fred.gao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 7a770b1c99d6..be1bb6dbcbd2 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -193,6 +193,10 @@ struct intel_vgpu {
 #endif
 };
 
+/* validating GM healthy status*/
+#define vgpu_is_vm_unhealthy(ret_val) \
+	(((ret_val) == -EBADRQC) || ((ret_val) == -EFAULT))
+
 struct intel_gvt_gm {
 	unsigned long vgpu_allocated_low_gm_size;
 	unsigned long vgpu_allocated_high_gm_size;
@@ -497,6 +501,7 @@ int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
 void populate_pvinfo_page(struct intel_vgpu *vgpu);
 
 int intel_gvt_scan_and_shadow_workload(struct intel_vgpu_workload *workload);
+void enter_failsafe_mode(struct intel_vgpu *vgpu, int reason);
 
 struct intel_gvt_ops {
 	int (*emulate_cfg_read)(struct intel_vgpu *, unsigned int, void *,
@@ -519,6 +524,7 @@ struct intel_gvt_ops {
 enum {
 	GVT_FAILSAFE_UNSUPPORTED_GUEST,
 	GVT_FAILSAFE_INSUFFICIENT_RESOURCE,
+	GVT_FAILSAFE_GUEST_ERR,
 };
 
 static inline void mmio_hw_access_pre(struct drm_i915_private *dev_priv)

commit 8652a8aca614cc2576cf5d4c73d3b87e871ce004
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun Sep 10 22:01:10 2017 +0800

    drm/i915/gvt: Do not allocate initial ring scan buffer
    
    Theoretically, the largest bulk of commands in the ring buffer of an
    engine might be the first submission, which usually contains a lot
    of commands to initialize the HW. After removing the initial allocation
    of the ring scan buffer and let krealloc() do everything we need, we
    still have a big chance to get the buffer of suitable size in the first
    submission.
    
    Tested on my SKL NUC.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 49fe54870000..7a770b1c99d6 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -150,7 +150,6 @@ struct intel_vgpu_submission {
 	struct i915_gem_context *shadow_ctx;
 	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
-	/* 1/2K for each engine */
 	void *ring_scan_buffer[I915_NUM_ENGINES];
 	int ring_scan_buffer_size[I915_NUM_ENGINES];
 };

commit 325eb94a33451db138e8da7393ad8e9a0e22dd18
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun Sep 10 21:58:11 2017 +0800

    drm/i915/gvt: Move ring scan buffers into intel_vgpu_submission
    
    Move ring scan buffers into intel_vgpu_submission since they belongs to
    a part of vGPU submission stuffs.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 5b723fa00fcb..49fe54870000 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -150,6 +150,9 @@ struct intel_vgpu_submission {
 	struct i915_gem_context *shadow_ctx;
 	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
+	/* 1/2K for each engine */
+	void *ring_scan_buffer[I915_NUM_ENGINES];
+	int ring_scan_buffer_size[I915_NUM_ENGINES];
 };
 
 struct intel_vgpu {
@@ -172,10 +175,6 @@ struct intel_vgpu {
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
 	struct intel_vgpu_submission submission;
-	/* 1/2K for each engine */
-	void *ring_scan_buffer[I915_NUM_ENGINES];
-	int ring_scan_buffer_size[I915_NUM_ENGINES];
-
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {

commit 8cf80a2e4b313d1aba7d10ce6ebfbb44a119c66c
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun Sep 10 21:46:06 2017 +0800

    drm/i915/gvt: Rename reserved ring buffer
    
    "reserved" means reserve something from somewhere. Actually they are
    buffers used by command scanner. Rename it to ring_scan_buffer.
    
    v2:
    
    - Remove the usage of an extra variable. (Zhenyu)
    
    Fixes: 0a53bc07f044 ("drm/i915/gvt: Separate cmd scan from request allocation")
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 93ff530eee30..5b723fa00fcb 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -172,9 +172,9 @@ struct intel_vgpu {
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
 	struct intel_vgpu_submission submission;
-	/* 1/2K for each reserve ring buffer */
-	void *reserve_ring_buffer_va[I915_NUM_ENGINES];
-	int reserve_ring_buffer_size[I915_NUM_ENGINES];
+	/* 1/2K for each engine */
+	void *ring_scan_buffer[I915_NUM_ENGINES];
+	int ring_scan_buffer_size[I915_NUM_ENGINES];
 
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)

commit 91d5d85442b2a65e5f4e1726565c1c1a8ba9976f
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun Sep 10 21:33:20 2017 +0800

    drm/i915/gvt: Move tlb_handle_pending into intel_vgpu_submission
    
    Move tlb_handle_pending into intel_vgpu_submssion since it belongs to a
    part of vGPU submission stuffs
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index c3f84f26090a..93ff530eee30 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -149,6 +149,7 @@ struct intel_vgpu_submission {
 	atomic_t running_workload_num;
 	struct i915_gem_context *shadow_ctx;
 	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
+	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 };
 
 struct intel_vgpu {
@@ -174,7 +175,6 @@ struct intel_vgpu {
 	/* 1/2K for each reserve ring buffer */
 	void *reserve_ring_buffer_va[I915_NUM_ENGINES];
 	int reserve_ring_buffer_size[I915_NUM_ENGINES];
-	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)

commit 1406a14b0ed977fc18f43398b391e4bb5d744174
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun Sep 10 21:15:18 2017 +0800

    drm/i915/gvt: Introduce intel_vgpu_submission
    
    Introduce intel_vgpu_submission to hold all members related to submission
    in struct intel_vgpu before.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9c2e7c0aa38f..c3f84f26090a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -142,6 +142,15 @@ struct vgpu_sched_ctl {
 	int weight;
 };
 
+struct intel_vgpu_submission {
+	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
+	struct list_head workload_q_head[I915_NUM_ENGINES];
+	struct kmem_cache *workloads;
+	atomic_t running_workload_num;
+	struct i915_gem_context *shadow_ctx;
+	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
+};
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
@@ -161,16 +170,12 @@ struct intel_vgpu {
 	struct intel_vgpu_gtt gtt;
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
-	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
-	struct list_head workload_q_head[I915_NUM_ENGINES];
-	struct kmem_cache *workloads;
-	atomic_t running_workload_num;
+	struct intel_vgpu_submission submission;
 	/* 1/2K for each reserve ring buffer */
 	void *reserve_ring_buffer_va[I915_NUM_ENGINES];
 	int reserve_ring_buffer_size[I915_NUM_ENGINES];
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
-	struct i915_gem_context *shadow_ctx;
-	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
+
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {

commit 02d578e5edd980eac3fbed15db4d9e5665f22089
Author: Changbin Du <changbin.du@intel.com>
Date:   Wed Aug 23 14:08:10 2017 +0800

    drm/i915/gvt: Add support for PCIe extended configuration space
    
    IGD is PCIe device and has extended configuration space. Checking
    the binary dump, we can see we have Caps located out of PCI compatible
    Configuration Space range.
    
    0x000: 86 80 12 19 17 04 10 00 06 00 00 03 00 00 00 00
    0x010: 04 00 00 10 08 00 00 00 0c 00 00 00 08 00 00 00
    0x020: 00 00 00 00 00 00 00 00 00 00 00 00 28 10 b9 06
    0x030: 00 f8 ff ff 40 00 00 00 00 00 00 00 0b 01 00 00
    0x040: 09 70 0c 01 71 26 01 62 c8 00 04 84 00 00 00 00
    0x050: c1 00 00 00 39 00 00 00 00 00 00 00 01 00 00 a2
    0x060: 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x070: 10 ac 92 00 00 80 00 10 00 00 00 00 00 00 00 00
    0x080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x0a0: 00 00 00 00 00 00 00 00 00 00 00 00 05 d0 01 00
    0x0b0: 18 00 e0 fe 00 00 00 00 00 00 00 00 00 00 00 00
    0x0c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x0d0: 01 00 22 00 00 80 00 00 00 00 00 00 00 00 00 00
    0x0e0: 00 00 00 00 00 00 00 00 00 80 00 00 00 00 00 00
    0x0f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x100: 1b 00 01 20 02 14 00 00 00 00 00 00 00 00 00 00
    ...
    
    Currently, we only emulate the PCI compatible Configuration Space.
    This is okay if we attach vGPU to PCI bus. But when we attach to
    a PCI Express bus (when Qemu emulates a Intel Q35 chipset which has
    PCIe slot), it will not work. Extended Configuration Space is required
    for a PCIe device.
    
    This patch extended the virtual configuration space from 256 bytes
    to 4KB bytes. So we are to be a *real* PCIe device. And for the
    Extended CapList we keep same to physical GPU.
    
    Cc: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 031868f08e1c..9c2e7c0aa38f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -100,7 +100,6 @@ struct intel_vgpu_mmio {
 	bool disable_warn_untrack;
 };
 
-#define INTEL_GVT_MAX_CFG_SPACE_SZ 256
 #define INTEL_GVT_MAX_BAR_NUM 4
 
 struct intel_vgpu_pci_bar {
@@ -109,7 +108,7 @@ struct intel_vgpu_pci_bar {
 };
 
 struct intel_vgpu_cfg_space {
-	unsigned char virtual_cfg_space[INTEL_GVT_MAX_CFG_SPACE_SZ];
+	unsigned char virtual_cfg_space[PCI_CFG_SPACE_EXP_SIZE];
 	struct intel_vgpu_pci_bar bar[INTEL_GVT_MAX_BAR_NUM];
 };
 

commit 0a53bc07f044c4c51eb0dc1386c504db80ca8d00
Author: fred gao <fred.gao@intel.com>
Date:   Fri Aug 18 15:41:06 2017 +0800

    drm/i915/gvt: Separate cmd scan from request allocation
    
    Currently i915 request structure and shadow ring buffer are allocated
    before command scan, so it will have to restore to previous states once
    any error happens afterwards in the long dispatch_workload path.
    
    This patch is to introduce a reserved ring buffer created at the beginning
    of vGPU initialization. Workload will be coped to this reserved buffer and
    be scanned first, the i915 request and shadow ring buffer are only
    allocated after the result of scan is successful.
    
    To balance the memory usage and buffer alloc time, the coming bigger ring
    buffer will be reallocated and kept until more bigger buffer is coming.
    
    v2:
    - use kmalloc for the smaller ring buffer, realloc if required. (Zhenyu)
    
    v3:
    - remove the dynamically allocated ring buffer. (Zhenyu)
    
    v4:
    - code style polish.
    - kfree previous allocated buffer once kmalloc failed. (Zhenyu)
    
    Signed-off-by: fred gao <fred.gao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 2fe22e1b517c..031868f08e1c 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -166,6 +166,9 @@ struct intel_vgpu {
 	struct list_head workload_q_head[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
+	/* 1/2K for each reserve ring buffer */
+	void *reserve_ring_buffer_va[I915_NUM_ENGINES];
+	int reserve_ring_buffer_size[I915_NUM_ENGINES];
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
 	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);

commit f090a00df9ecdab5d066b099c1797e0070e27a36
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Aug 15 13:14:04 2017 +0800

    drm/i915/gvt: Add emulation for BAR2 (aperture) with normal file RW approach
    
    For vfio-pci, if the region support MMAP then it should support both
    mmap and normal file access. The user-space is free to choose which is
    being used. For qemu, we just need add 'x-no-mmap=on' for vfio-pci
    option.
    
    Currently GVTg only support MMAP for BAR2. So GVTg will not work when
    user turn on x-no-mmap option.
    
    This patch added file style access for BAR2, aka the GPU aperture. We
    map the entire aperture partition of active vGPU to kernel space when
    guest driver try to enable PCI Memory Space. Then we redirect the file
    RW operation from kvmgt to this mapped area.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1458032
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 44b719eda8c4..2fe22e1b517c 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -80,6 +80,7 @@ struct intel_gvt_device_info {
 struct intel_vgpu_gm {
 	u64 aperture_sz;
 	u64 hidden_sz;
+	void *aperture_va;
 	struct drm_mm_node low_gm_node;
 	struct drm_mm_node high_gm_node;
 };
@@ -474,6 +475,13 @@ int intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,
 int intel_vgpu_emulate_cfg_write(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 
+static inline u64 intel_vgpu_get_bar_gpa(struct intel_vgpu *vgpu, int bar)
+{
+	/* We are 64bit bar. */
+	return (*(u64 *)(vgpu->cfg_space.virtual_cfg_space + bar)) &
+			PCI_BASE_ADDRESS_MEM_MASK;
+}
+
 void intel_gvt_clean_opregion(struct intel_gvt *gvt);
 int intel_gvt_init_opregion(struct intel_gvt *gvt);
 

commit 735f463af70e9601881ec879961ec42aef051733
Merge: 3aadb888b1b6 a42894ebb50d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Aug 22 10:03:07 2017 +1000

    Merge tag 'drm-intel-next-2017-08-18' of git://anongit.freedesktop.org/git/drm-intel into drm-next
    
    Final pile of features for 4.14
    
    - New ioctl to change NOA configurations, plus prep (Lionel)
    - CCS (color compression) scanout support, based on the fancy new
      modifier additions (Ville&Ben)
    - Document i915 register macro style (Jani)
    - Many more gen10/cnl patches (Rodrigo, Pualo, ...)
    - More gpu reset vs. modeset duct-tape to restore the old way.
    - prep work for cnl: hpd_pin reorg (Rodrigo), support for more power
      wells (Imre), i2c pin reorg (Anusha)
    - drm_syncobj support (Jason Ekstrand)
    - forcewake vs gpu reset fix (Chris)
    - execbuf speedup for the no-relocs fastpath, anv/vk low-overhead ftw (Chris)
    - switch to idr/radixtree instead of the resizing ht for execbuf id->vma
      lookups (Chris)
    
    gvt:
    - MMIO save/restore optimization (Changbin)
    - Split workload scan vs. dispatch for more parallel exec (Ping)
    - vGPU full 48bit ppgtt support (Joonas, Tina)
    - vGPU hw id expose for perf (Zhenyu)
    
    Bunch of work all over to make the igt CI runs more complete/stable.
    Watch https://intel-gfx-ci.01.org/tree/drm-tip/shards-all.html for
    progress in getting this ready. Next week we're going into production
    mode (i.e. will send results to intel-gfx) on hsw, more platforms to
    come.
    
    Also, a new maintainer tram, I'm stepping out. Huge thanks to Jani for
    being an awesome co-maintainer the past few years, and all the best
    for Jani, Joonas&Rodrigo as the new maintainers!
    
    * tag 'drm-intel-next-2017-08-18' of git://anongit.freedesktop.org/git/drm-intel: (179 commits)
      drm/i915: Update DRIVER_DATE to 20170818
      drm/i915/bxt: use NULL for GPIO connection ID
      drm/i915: Mark the GT as busy before idling the previous request
      drm/i915: Trivial grammar fix s/opt of/opt out of/ in comment
      drm/i915: Replace execbuf vma ht with an idr
      drm/i915: Simplify eb_lookup_vmas()
      drm/i915: Convert execbuf to use struct-of-array packing for critical fields
      drm/i915: Check context status before looking up our obj/vma
      drm/i915: Don't use MI_STORE_DWORD_IMM on Sandybridge/vcs
      drm/i915: Stop touching forcewake following a gen6+ engine reset
      MAINTAINERS: drm/i915 has a new maintainer team
      drm/i915: Split pin mapping into per platform functions
      drm/i915/opregion: let user specify override VBT via firmware load
      drm/i915/cnl: Reuse skl_wm_get_hw_state on Cannonlake.
      drm/i915/gen10: implement gen 10 watermarks calculations
      drm/i915/cnl: Fix LSPCON support.
      drm/i915/vbt: ignore extraneous child devices for a port
      drm/i915/cnl: Setup PAT Index.
      drm/i915/edp: Allow alternate fixed mode for eDP if available.
      drm/i915: Add support for drm syncobjs
      ...

commit 9dfb8e5b9112483530429c96d463e6d45e0106ed
Author: Kechen Lu <kechen.lu@intel.com>
Date:   Thu Aug 10 07:41:36 2017 +0800

    drm/i915/gvt: Add shadow context descriptor updating
    
    The current context logic only updates the descriptor of context when
    it's being pinned to graphics memory space. But this cannot satisfy the
    requirement of shadow context. The addressing mode of the pinned shadow
    context descriptor may be changed according to the guest addressing mode.
    And this won't be updated, as the already pinned shadow context has no
    chance to update its descriptor. And this will lead to GPU hang issue,
    as shadow context is used with wrong descriptor. This patch fixes this
    issue by letting the pinned shadow context descriptor update its
    addressing mode on demand.
    
    This patch fixes GPU HANG issue which happends after changing the
    grub parameter i915.enable_ppgtt form 0x01 to 0x03 or vice versa and
    then rebooting the guest.
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Signed-off-by: Kechen Lu <kechen.lu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index ba53ad17900b..ea736717e051 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -167,6 +167,7 @@ struct intel_vgpu {
 	atomic_t running_workload_num;
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
+	DECLARE_BITMAP(shadow_ctx_desc_updated, I915_NUM_ENGINES);
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {

commit 89ea20b930cb7372095645acae8928a75f7d5be5
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Jun 29 12:22:42 2017 +0800

    drm/i915/gvt: Factor out scan and shadow from workload dispatch
    
    To perform the workload scan and shadow in ELSP writing stage for
    performance consideration, the workload scan and shadow stuffs
    should be factored out from dispatch_workload().
    
    v2:Put context pin before i915_add_request;
       Refine the comments;
       Rename some APIs;
    
    v3:workload->status should set only when error happens.
    v4:i915_add_request is must to have after i915_gem_request_alloc.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 3a74e79eac2f..ba53ad17900b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -470,6 +470,8 @@ int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
 int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
 void populate_pvinfo_page(struct intel_vgpu *vgpu);
 
+int intel_gvt_scan_and_shadow_workload(struct intel_vgpu_workload *workload);
+
 struct intel_gvt_ops {
 	int (*emulate_cfg_read)(struct intel_vgpu *, unsigned int, void *,
 				unsigned int);

commit 02b6ed44304e458d68e454493ab272f4e3c3c53a
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Fri Aug 4 17:39:41 2017 +0800

    drm/i915/gvt: Initialize MMIO Block with HW state
    
    MMIO block with tracked mmio, is introduced for the sake of performance
    of searching tracked mmio. All the tracked mmio needs to get the initial
    value from the HW state during vGPU being created. This patch is to
    initialize the tracked registers in MMIO block with the HW state.
    
    v2: Add "Fixes:" line for this patch (Zhenyu)
    
    Fixes: 65f9f6febf12 ("drm/i915/gvt: Optimize MMIO register handling for some large MMIO blocks")
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index d96c41aa5aa7..2964a4d01a66 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -195,6 +195,15 @@ struct intel_gvt_fence {
 	unsigned long vgpu_allocated_fence_num;
 };
 
+/* Special MMIO blocks. */
+struct gvt_mmio_block {
+	unsigned int device;
+	i915_reg_t   offset;
+	unsigned int size;
+	gvt_mmio_func read;
+	gvt_mmio_func write;
+};
+
 #define INTEL_GVT_MMIO_HASH_BITS 11
 
 struct intel_gvt_mmio {
@@ -214,6 +223,9 @@ struct intel_gvt_mmio {
 /* This reg could be accessed by unaligned address */
 #define F_UNALIGN	(1 << 6)
 
+	struct gvt_mmio_block *mmio_block;
+	unsigned int num_mmio_block;
+
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
 	unsigned int num_tracked_mmio;
 };

commit 6184cc8ddbb318758a000da68c5285fc2dd74338
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Tue Aug 1 17:47:25 2017 +0800

    drm/i915/gvt: change resetting to resetting_eng
    
    Use resetting_eng to identify which engine is resetting
    so the rest ones' workload won't be impacted
    
    v2:
    - use ENGINE_MASK(ring_id) instead of (1 << ring_id). (Zhenyu)
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 3a74e79eac2f..d96c41aa5aa7 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -149,7 +149,7 @@ struct intel_vgpu {
 	bool active;
 	bool pv_notified;
 	bool failsafe;
-	bool resetting;
+	unsigned int resetting_eng;
 	void *sched_data;
 	struct vgpu_sched_ctl sched_ctl;
 

commit 08673c3e27aa4407899e4fbb4738dac25370f706
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Fri Jul 7 13:21:52 2017 +0800

    drm/i915/gvt: Revert "drm/i915/gvt: Fix possible recursive locking issue"
    
    This reverts commit 62d02fd1f807bf5a259a242c483c9fb98a242630.
    
    The rwsem recursive trace should not be fixed from kvmgt side by using
    a workqueue and it is an issue should be fixed in VFIO. So this one
    should be reverted.
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: stable@vger.kernel.org # v4.10+
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 28d817e96e58..3a74e79eac2f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -182,9 +182,6 @@ struct intel_vgpu {
 		struct kvm *kvm;
 		struct work_struct release_work;
 		atomic_t released;
-		struct work_struct unpin_work;
-		spinlock_t unpin_lock; /* To protect unpin_list */
-		struct list_head unpin_list;
 	} vdev;
 #endif
 };

commit 507ad75736f896f705663f22d8fd045cac99afae
Merge: bdbbf7d619d1 5cd82b757795
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Jun 30 12:49:44 2017 +0300

    Merge tag 'gvt-fixes-2017-06-29' of https://github.com/01org/gvt-linux into drm-intel-next-fixes
    
    gvt-fixes-2017-06-29
    
    - two race fixes for VFIO locks from Chuanxiao
    - virtual display fix for BDW from Xiong
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170629065424.kxopjbvntuakbyz2@zhen-hp.sh.intel.com

commit 62d02fd1f807bf5a259a242c483c9fb98a242630
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Mon Jun 26 15:20:49 2017 +0800

    drm/i915/gvt: Fix possible recursive locking issue
    
    vfio_unpin_pages will hold a read semaphore however it is already hold
    in the same thread by vfio ioctl. It will cause below warning:
    
    [ 5102.127454] ============================================
    [ 5102.133379] WARNING: possible recursive locking detected
    [ 5102.139304] 4.12.0-rc4+ #3 Not tainted
    [ 5102.143483] --------------------------------------------
    [ 5102.149407] qemu-system-x86/1620 is trying to acquire lock:
    [ 5102.155624]  (&container->group_lock){++++++}, at: [<ffffffff817768c6>] vfio_unpin_pages+0x96/0xf0
    [ 5102.165626]
    but task is already holding lock:
    [ 5102.172134]  (&container->group_lock){++++++}, at: [<ffffffff8177728f>] vfio_fops_unl_ioctl+0x5f/0x280
    [ 5102.182522]
    other info that might help us debug this:
    [ 5102.189806]  Possible unsafe locking scenario:
    
    [ 5102.196411]        CPU0
    [ 5102.199136]        ----
    [ 5102.201861]   lock(&container->group_lock);
    [ 5102.206527]   lock(&container->group_lock);
    [ 5102.211191]
    *** DEADLOCK ***
    
    [ 5102.217796]  May be due to missing lock nesting notation
    
    [ 5102.225370] 3 locks held by qemu-system-x86/1620:
    [ 5102.230618]  #0:  (&container->group_lock){++++++}, at: [<ffffffff8177728f>] vfio_fops_unl_ioctl+0x5f/0x280
    [ 5102.241482]  #1:  (&(&iommu->notifier)->rwsem){++++..}, at: [<ffffffff810de775>] __blocking_notifier_call_chain+0x35/0x70
    [ 5102.253713]  #2:  (&vgpu->vdev.cache_lock){+.+...}, at: [<ffffffff8157b007>] intel_vgpu_iommu_notifier+0x77/0x120
    [ 5102.265163]
    stack backtrace:
    [ 5102.270022] CPU: 5 PID: 1620 Comm: qemu-system-x86 Not tainted 4.12.0-rc4+ #3
    [ 5102.277991] Hardware name: Intel Corporation S1200RP/S1200RP, BIOS S1200RP.86B.03.01.APER.061220151418 06/12/2015
    [ 5102.289445] Call Trace:
    [ 5102.292175]  dump_stack+0x85/0xc7
    [ 5102.295871]  validate_chain.isra.21+0x9da/0xaf0
    [ 5102.300925]  __lock_acquire+0x405/0x820
    [ 5102.305202]  lock_acquire+0xc7/0x220
    [ 5102.309191]  ? vfio_unpin_pages+0x96/0xf0
    [ 5102.313666]  down_read+0x2b/0x50
    [ 5102.317259]  ? vfio_unpin_pages+0x96/0xf0
    [ 5102.321732]  vfio_unpin_pages+0x96/0xf0
    [ 5102.326024]  intel_vgpu_iommu_notifier+0xe5/0x120
    [ 5102.331283]  notifier_call_chain+0x4a/0x70
    [ 5102.335851]  __blocking_notifier_call_chain+0x4d/0x70
    [ 5102.341490]  blocking_notifier_call_chain+0x16/0x20
    [ 5102.346935]  vfio_iommu_type1_ioctl+0x87b/0x920
    [ 5102.351994]  vfio_fops_unl_ioctl+0x81/0x280
    [ 5102.356660]  ? __fget+0xf0/0x210
    [ 5102.360261]  do_vfs_ioctl+0x93/0x6a0
    [ 5102.364247]  ? __fget+0x111/0x210
    [ 5102.367942]  SyS_ioctl+0x41/0x70
    [ 5102.371542]  entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    put the vfio_unpin_pages in a workqueue can fix this.
    
    v2:
    - use for style instead of do{}while(1). (Zhenyu)
    v3:
    - rename gvt_cache_mark to gvt_cache_mark_remove. (Zhenyu)
    
    Fixes: 659643f7d814 ("drm/i915/gvt/kvmgt: add vfio/mdev support to KVMGT")
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: stable@vger.kernel.org # v4.10+
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 930732e5c780..8b5876d63624 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -183,6 +183,9 @@ struct intel_vgpu {
 		struct kvm *kvm;
 		struct work_struct release_work;
 		atomic_t released;
+		struct work_struct unpin_work;
+		spinlock_t unpin_lock; /* To protect unpin_list */
+		struct list_head unpin_list;
 	} vdev;
 #endif
 };

commit 178cd160c6652f57571ba3dc0a9091a1f41d9bc8
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jun 6 15:56:14 2017 +0800

    drm/i915/gvt: Tuning the size of MMIO hash lookup table to 2048
    
    On Skylake platform, The traced virtual mmio registers are up to 2039.
    So tuning the hash table size to improve lookup performance.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index ffb9ebbbcf5a..3a74e79eac2f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -195,7 +195,7 @@ struct intel_gvt_fence {
 	unsigned long vgpu_allocated_fence_num;
 };
 
-#define INTEL_GVT_MMIO_HASH_BITS 9
+#define INTEL_GVT_MMIO_HASH_BITS 11
 
 struct intel_gvt_mmio {
 	u8 *mmio_attribute;

commit fbfd76c3746a322a9f33f77b66f85d4f68cabe4a
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jun 6 15:56:13 2017 +0800

    drm/i915/gvt: Add helper for tuning MMIO hash table
    
    We count all the tracked virtual MMIO registers, which can help us to
    tune the MMIO hash table.
    
    v2: Move num_tracked_mmio into gvt structure.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b9a277c726cb..ffb9ebbbcf5a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -215,6 +215,7 @@ struct intel_gvt_mmio {
 #define F_UNALIGN	(1 << 6)
 
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
+	unsigned int num_tracked_mmio;
 };
 
 struct intel_gvt_firmware {

commit 5c6d4c676d0ccba2dcd97e47e1f10321da423e7d
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jun 6 15:56:12 2017 +0800

    drm/i915/gvt: Make the MMIO attribute wrappers be inline
    
    Function calls are expensive. I have see obvious overhead call to
    these wrappers in perf data, especially from the cmd parser side.
    So make these simple wrappers be inline to kill them all.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9ff371b81835..b9a277c726cb 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -199,6 +199,21 @@ struct intel_gvt_fence {
 
 struct intel_gvt_mmio {
 	u8 *mmio_attribute;
+/* Register contains RO bits */
+#define F_RO		(1 << 0)
+/* Register contains graphics address */
+#define F_GMADR		(1 << 1)
+/* Mode mask registers with high 16 bits as the mask bits */
+#define F_MODE_MASK	(1 << 2)
+/* This reg can be accessed by GPU commands */
+#define F_CMD_ACCESS	(1 << 3)
+/* This reg has been accessed by a VM */
+#define F_ACCESSED	(1 << 4)
+/* This reg has been accessed through GPU commands */
+#define F_CMD_ACCESSED	(1 << 5)
+/* This reg could be accessed by unaligned address */
+#define F_UNALIGN	(1 << 6)
+
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
 };
 
@@ -487,6 +502,69 @@ static inline void mmio_hw_access_post(struct drm_i915_private *dev_priv)
 	intel_runtime_pm_put(dev_priv);
 }
 
+/**
+ * intel_gvt_mmio_set_accessed - mark a MMIO has been accessed
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ */
+static inline void intel_gvt_mmio_set_accessed(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	gvt->mmio.mmio_attribute[offset >> 2] |= F_ACCESSED;
+}
+
+/**
+ * intel_gvt_mmio_is_cmd_accessed - mark a MMIO could be accessed by command
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ */
+static inline bool intel_gvt_mmio_is_cmd_access(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	return gvt->mmio.mmio_attribute[offset >> 2] & F_CMD_ACCESS;
+}
+
+/**
+ * intel_gvt_mmio_is_unalign - mark a MMIO could be accessed unaligned
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ */
+static inline bool intel_gvt_mmio_is_unalign(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	return gvt->mmio.mmio_attribute[offset >> 2] & F_UNALIGN;
+}
+
+/**
+ * intel_gvt_mmio_set_cmd_accessed - mark a MMIO has been accessed by command
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ */
+static inline void intel_gvt_mmio_set_cmd_accessed(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	gvt->mmio.mmio_attribute[offset >> 2] |= F_CMD_ACCESSED;
+}
+
+/**
+ * intel_gvt_mmio_has_mode_mask - if a MMIO has a mode mask
+ * @gvt: a GVT device
+ * @offset: register offset
+ *
+ * Returns:
+ * True if a MMIO has a mode mask in its higher 16 bits, false if it isn't.
+ *
+ */
+static inline bool intel_gvt_mmio_has_mode_mask(
+			struct intel_gvt *gvt, unsigned int offset)
+{
+	return gvt->mmio.mmio_attribute[offset >> 2] & F_MODE_MASK;
+}
+
 #include "trace.h"
 #include "mpt.h"
 

commit 56a78de54964894de2f65c9fa8066d5e9843e1ce
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jun 6 15:56:11 2017 +0800

    drm/i915/gvt: Make mmio_attribute as type u8 to save 1.5MB memory
    
    Type u8 is big enough to contain all MMIO attribute flags. As the
    total MMIO size is 2MB so we saved 1.5MB memory.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1fca76bf7f73..9ff371b81835 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -198,7 +198,7 @@ struct intel_gvt_fence {
 #define INTEL_GVT_MMIO_HASH_BITS 9
 
 struct intel_gvt_mmio {
-	u32 *mmio_attribute;
+	u8 *mmio_attribute;
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
 };
 

commit 9b7bd65ecdf347b33c37d73b610fd85774b12e87
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Fri Jun 2 15:34:23 2017 +0800

    drm/i915/gvt: Add runtime_pm get/put to proctect MMIO accessing
    
    In some cases, GVT-g is accessing MMIO without holding runtime_pm
    and this patch can add the inline API for doing the runtime_pm get/put
    to make sure when accessing HW MMIO the i915 HW is really powered on.
    
    Suggested-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 8fd40f55caf1..1fca76bf7f73 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -477,6 +477,16 @@ enum {
 	GVT_FAILSAFE_INSUFFICIENT_RESOURCE,
 };
 
+static inline void mmio_hw_access_pre(struct drm_i915_private *dev_priv)
+{
+	intel_runtime_pm_get(dev_priv);
+}
+
+static inline void mmio_hw_access_post(struct drm_i915_private *dev_priv)
+{
+	intel_runtime_pm_put(dev_priv);
+}
+
 #include "trace.h"
 #include "mpt.h"
 

commit c713cb2f9b7e1e9ffa8a379cecb13bc6eacd49b6
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Wed May 24 20:30:17 2017 +0800

    drm/i915/gvt: Support event based scheduling
    
    This patch decouple the time slice calculation and scheduler, let
    other event be able to trigger scheduling without impact the
    calculation for QoS.
    
    v2: add only one new enum definition.
    v3: fix typo.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index d3b4d42063da..8fd40f55caf1 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -256,7 +256,12 @@ static inline struct intel_gvt *to_gvt(struct drm_i915_private *i915)
 
 enum {
 	INTEL_GVT_REQUEST_EMULATE_VBLANK = 0,
+
+	/* Scheduling trigger by timer */
 	INTEL_GVT_REQUEST_SCHED = 1,
+
+	/* Scheduling trigger by event */
+	INTEL_GVT_REQUEST_EVENT_SCHED = 2,
 };
 
 static inline void intel_gvt_request_service(struct intel_gvt *gvt,

commit 7fb6a7d65292a524256ed6e2d0e94071b0c53936
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Tue May 23 05:38:08 2017 +0800

    drm/i915/gvt: Change flood gvt dmesg into trace
    
    Currently gvt dmesg is so heavy at drm.debug=0x2 that guest and
    host almost couldn't run on xengt.
    
    This patch transfer these repeated messages into trace, so dmesg
    is light at drm.debug=0x2, and user could get the target message through
    trace event and trace filter.
    
    Suggested-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0b2a4a11ae9b..d3b4d42063da 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -472,6 +472,7 @@ enum {
 	GVT_FAILSAFE_INSUFFICIENT_RESOURCE,
 };
 
+#include "trace.h"
 #include "mpt.h"
 
 #endif

commit 7b8d57587025dc294094b73f08b389a498fb107f
Author: Changbin Du <changbin.du@intel.com>
Date:   Mon May 22 17:46:47 2017 +0800

    drm/i915/gvt: clean up the unused last_ctx_submit_time of struct intel_vgpu
    
    Clean up it as it is not used now.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 930732e5c780..0b2a4a11ae9b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -165,7 +165,6 @@ struct intel_vgpu {
 	struct list_head workload_q_head[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
-	ktime_t last_ctx_submit_time;
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
 

commit 856ee92e8602bd86d34388ac08381c5cb3918756
Merge: a6a5c983b35e 4f7d029b9bf0
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 19 11:07:14 2017 +1000

    Merge tag 'v4.11-rc7' into drm-next
    
    Backmerge Linux 4.11-rc7 from Linus tree, to fix some
    conflicts that were causing problems with the rerere cache
    in drm-tip.

commit cf082a4a264d5e0bb79f0055be02d255438836a4
Merge: ecf8e89917d6 aa4ce4493c88
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 3 18:14:06 2017 +0300

    Merge tag 'gvt-fixes-2017-04-01' of https://github.com/01org/gvt-linux into drm-intel-fixes
    
    gvt-fixes-2017-04-01
    
    - Fix cfg space in failsafe (Changbin)
    - Fix a race for irq inject with vgpu release (Zhi)
    - Fix golden state firmware load (Zhi)
    
    Link: http://patchwork.freedesktop.org/patch/msgid/20170401080650.6cvqon7nsbziwnyc@zhen-hp.sh.intel.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit b79c52aef3cdee903017c1e9834b53996d70010e
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Mar 30 01:48:39 2017 +0800

    drm/i915/gvt: Activate/de-activate vGPU in mdev ops.
    
    This patch introduces two functions for activating/de-activating vGPU in
    mdev ops.
    
    A racing condition was found between virtual vblank emulation and KVGMT
    mdev release path. V-blank emulation will emulate and inject V-blank
    interrupt for every active vGPU with holding gvt->lock, while in mdev
    release path, it will directly release hypervisor handle without changing
    vGPU status or taking gvt->lock, so a kernel oops is encountered when
    vblank emulation is injecting a interrupt with a invalid hypervisor
    handle. (Reported by Terrence)
    
    To solve this problem, we factor out vGPU activation/de-activation from
    vGPU creation/destruction path and let KVMGT mdev release ops de-activate
    the vGPU before release hypervisor handle. Once a vGPU is de-activated,
    GVT-g will not emulate v-blank for it or touch the hypervisor handle.
    
    Fixes: 659643f ("drm/i915/gvt/kvmgt: add vfio/mdev support to KVMGT")
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 23791920ced1..2387eacf74bb 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -382,7 +382,8 @@ void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
 void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
 				 unsigned int engine_mask);
 void intel_gvt_reset_vgpu(struct intel_vgpu *vgpu);
-
+void intel_gvt_activate_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_deactivate_vgpu(struct intel_vgpu *vgpu);
 
 /* validating GM functions */
 #define vgpu_gmadr_is_aperture(vgpu, gmadr) \
@@ -449,6 +450,8 @@ struct intel_gvt_ops {
 				struct intel_vgpu_type *);
 	void (*vgpu_destroy)(struct intel_vgpu *);
 	void (*vgpu_reset)(struct intel_vgpu *);
+	void (*vgpu_activate)(struct intel_vgpu *);
+	void (*vgpu_deactivate)(struct intel_vgpu *);
 };
 
 

commit afe04fbe6c522e73d5cc61a6660cce0e78630786
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:39 2017 +0800

    drm/i915/gvt: create an idle vGPU
    
    vGPU resource is allocated by scheduler. To account for non-allocated
    free cycles, we create an idle vGPU as the placeholder similar to idle task
    concept, which is useful to handle some corner cases in scheduling policy.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0631f64e06db..806da96b6a92 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -243,6 +243,7 @@ struct intel_gvt {
 	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
 	struct intel_vgpu_type *types;
 	unsigned int num_types;
+	struct intel_vgpu *idle_vgpu;
 
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;
@@ -386,6 +387,8 @@ static inline void intel_vgpu_write_pci_bar(struct intel_vgpu *vgpu,
 int intel_gvt_init_vgpu_types(struct intel_gvt *gvt);
 void intel_gvt_clean_vgpu_types(struct intel_gvt *gvt);
 
+struct intel_vgpu *intel_gvt_create_idle_vgpu(struct intel_gvt *gvt);
+void intel_gvt_destroy_idle_vgpu(struct intel_vgpu *vgpu);
 struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 					 struct intel_vgpu_type *type);
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);

commit bc90d097ae144fab1f789f8523b621de7125c6a8
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:37 2017 +0800

    drm/i915/gvt: define weight according to vGPU type
    
    The weight defines proportional control of physical GPU resource
    shared between vGPUs. So far the weight is tied to a specific vGPU
    type, i.e when creating multiple vGPUs with different types, they
    will inherit different weights.
    
    e.g. The weight of type GVTg_V5_2 is 8, the weight of type GVTg_V5_4
    is 4, so vGPU of type GVTg_V5_2 has double vGPU resource of vGPU type
    GVTg_V5_4.
    
    TODO: allow user control the weight setting in the future.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index fe7f5ae8884a..0631f64e06db 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -151,6 +151,7 @@ struct intel_vgpu {
 	bool failsafe;
 	bool resetting;
 	void *sched_data;
+	struct vgpu_sched_ctl sched_ctl;
 
 	struct intel_vgpu_fence fence;
 	struct intel_vgpu_gm gm;
@@ -220,6 +221,7 @@ struct intel_vgpu_type {
 	unsigned int low_gm_size;
 	unsigned int high_gm_size;
 	unsigned int fence;
+	unsigned int weight;
 	enum intel_vgpu_edid resolution;
 };
 
@@ -328,6 +330,8 @@ struct intel_vgpu_creation_params {
 	__u64 resolution;
 	__s32 primary;
 	__u64 vgpu_id;
+
+	__u32 weight;
 };
 
 int intel_vgpu_alloc_resource(struct intel_vgpu *vgpu,

commit f6504cce54b26e4318697a854a50cf1a1cb3c066
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:35 2017 +0800

    drm/i915/gvt: add some statistic routine for scheduler
    
    Add some statistic routine to collect the time when vGPU is
    scheduled in/out and the time of the last ctx submission.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 7455214b242c..fe7f5ae8884a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -138,6 +138,10 @@ struct intel_vgpu_display {
 	struct intel_vgpu_sbi sbi;
 };
 
+struct vgpu_sched_ctl {
+	int weight;
+};
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
@@ -160,6 +164,7 @@ struct intel_vgpu {
 	struct list_head workload_q_head[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
+	ktime_t last_ctx_submit_time;
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
 

commit 91d0101ad30bd1bd7f7f805f4fa314c6b70bb602
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:34 2017 +0800

    drm/i915/gvt: use hrtimer replace delayed_work in scheduler
    
    Currently the scheduler is triggered by delayed_work, which doesn't
    provide precision at microsecond level. Move to hrtimer instead for
    more accurate control.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 6dfc48b63b71..7455214b242c 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -249,6 +249,7 @@ static inline struct intel_gvt *to_gvt(struct drm_i915_private *i915)
 
 enum {
 	INTEL_GVT_REQUEST_EMULATE_VBLANK = 0,
+	INTEL_GVT_REQUEST_SCHED = 1,
 };
 
 static inline void intel_gvt_request_service(struct intel_gvt *gvt,

commit 65d1086c44791112188f6aebbdc3a27cab3736d3
Merge: edd849e5448c 97da3854c526
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 23 12:05:13 2017 +1000

    BackMerge tag 'v4.11-rc3' into drm-next
    
    Linux 4.11-rc3 as requested by Daniel

commit 590379aef2e3fb7d00a093ed556c0a2714f86916
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Mar 21 14:47:20 2017 +0000

    drm/i915: make context status notifier head be per engine
    
    GVTg has introduced the context status notifier to schedule the GVTg
    workload. At that time, the notifier is bound to GVTg context only,
    so GVTg is not aware of host workloads.
    
    Now we are going to improve GVTg's guest workload scheduler policy,
    and add Guc emulation support for new Gen graphics. Both these two
    features require acknowledgment for all contexts running on hardware.
    (But will not alter host workload.) So here try to make some change.
    
    The change is simple:
      1. Move the context status notifier head from i915_gem_context to
         intel_engine_cs. Which means there is a notifier head per engine
         instead of per context. Execlist driver still call notifier for
         each context sched-in/out events of current engine.
      2. At GVTg side, it binds a notifier_block for each physical engine
         at GVTg initialization period. Then GVTg can hear all context
         status events.
    
    In this patch, GVTg do nothing for host context event, but later
    will add a function there. But in any case, the notifier callback is
    a noop if this is no active vGPU.
    
    Since intel_gvt_init() is called at early initialization stage and
    require the status notifier head has been initiated, I initiate it in
    intel_engine_setup().
    
    v2: remove a redundant newline. (chris)
    
    Fixes: 3c7ba6359d70 ("drm/i915: Introduce execlist context status change notification")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100232
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170313024711.28591-1-changbin.du@intel.com
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 3fc03069bc6e6c316f19bb526e3c8ce784677477)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170321144720.17020-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 23791920ced1..6dfc48b63b71 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -162,7 +162,6 @@ struct intel_vgpu {
 	atomic_t running_workload_num;
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
-	struct notifier_block shadow_ctx_notifier_block;
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {
@@ -233,6 +232,7 @@ struct intel_gvt {
 	struct intel_gvt_gtt gtt;
 	struct intel_gvt_opregion opregion;
 	struct intel_gvt_workload_scheduler scheduler;
+	struct notifier_block shadow_ctx_notifier_block[I915_NUM_ENGINES];
 	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
 	struct intel_vgpu_type *types;
 	unsigned int num_types;

commit 3fc03069bc6e6c316f19bb526e3c8ce784677477
Author: Changbin Du <changbin.du@intel.com>
Date:   Mon Mar 13 10:47:11 2017 +0800

    drm/i915: make context status notifier head be per engine
    
    GVTg has introduced the context status notifier to schedule the GVTg
    workload. At that time, the notifier is bound to GVTg context only,
    so GVTg is not aware of host workloads.
    
    Now we are going to improve GVTg's guest workload scheduler policy,
    and add Guc emulation support for new Gen graphics. Both these two
    features require acknowledgment for all contexts running on hardware.
    (But will not alter host workload.) So here try to make some change.
    
    The change is simple:
      1. Move the context status notifier head from i915_gem_context to
         intel_engine_cs. Which means there is a notifier head per engine
         instead of per context. Execlist driver still call notifier for
         each context sched-in/out events of current engine.
      2. At GVTg side, it binds a notifier_block for each physical engine
         at GVTg initialization period. Then GVTg can hear all context
         status events.
    
    In this patch, GVTg do nothing for host context event, but later
    will add a function there. But in any case, the notifier callback is
    a noop if this is no active vGPU.
    
    Since intel_gvt_init() is called at early initialization stage and
    require the status notifier head has been initiated, I initiate it in
    intel_engine_setup().
    
    v2: remove a redundant newline. (chris)
    
    Fixes: 3c7ba6359d70 ("drm/i915: Introduce execlist context status change notification")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100232
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170313024711.28591-1-changbin.du@intel.com
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index e227caf5859e..ce9ac1569cbc 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -160,7 +160,6 @@ struct intel_vgpu {
 	atomic_t running_workload_num;
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
-	struct notifier_block shadow_ctx_notifier_block;
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {
@@ -231,6 +230,7 @@ struct intel_gvt {
 	struct intel_gvt_gtt gtt;
 	struct intel_gvt_opregion opregion;
 	struct intel_gvt_workload_scheduler scheduler;
+	struct notifier_block shadow_ctx_notifier_block[I915_NUM_ENGINES];
 	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
 	struct intel_vgpu_type *types;
 	unsigned int num_types;

commit d1a513be1f0a25f094e1577d059b9aebaa279bb2
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Feb 24 10:58:21 2017 +0800

    drm/i915/gvt: add resolution definition for vGPU type
    
    This assigns resolution definition for each vGPU type. For smaller
    resource type we should limit max resolution, so e.g limit to 1024x768
    for 64M type, others are still default to 1920x1200.
    
    v2: Fix for actual 1920x1200 resolution
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index faff044c6434..23791920ced1 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -216,6 +216,7 @@ struct intel_vgpu_type {
 	unsigned int low_gm_size;
 	unsigned int high_gm_size;
 	unsigned int fence;
+	enum intel_vgpu_edid resolution;
 };
 
 struct intel_gvt {
@@ -318,6 +319,7 @@ struct intel_vgpu_creation_params {
 	__u64 low_gm_sz;  /* in MB */
 	__u64 high_gm_sz; /* in MB */
 	__u64 fence_sz;
+	__u64 resolution;
 	__s32 primary;
 	__u64 vgpu_id;
 };

commit 191020b670f84f5e2edfaa906c3801df20485610
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Feb 23 14:46:23 2017 +0800

    drm/i915/gvt: adjust to fixed vGPU types
    
    Previous vGPU type create tried to determine vGPU type name e.g _1, _2
    based on the number of mdev devices can be created, but different type
    might have very different resource size depending on physical device.
    We need to split type name vs. actual mdev resource and create fixed
    vGPU type with determined size for consistence.
    
    With this we'd like to fix vGPU types for _1, _2, _4 and _8 now, each
    type has fixed defined resource size. Available mdev instances that could
    be created is determined by physical resource, and user should query
    for that before creating.
    
    Cc: Kevin Tian <kevin.tian@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index a41b322d8957..faff044c6434 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -212,7 +212,6 @@ struct intel_gvt_opregion {
 #define NR_MAX_INTEL_VGPU_TYPES 20
 struct intel_vgpu_type {
 	char name[16];
-	unsigned int max_instance;
 	unsigned int avail_instance;
 	unsigned int low_gm_size;
 	unsigned int high_gm_size;

commit a33fc7a0482a40068c022aefcefd50f9f0f44f87
Author: Min He <min.he@intel.com>
Date:   Fri Feb 17 16:42:38 2017 +0800

    drm/i915/gvt: enter failsafe mode when guest requires more resources
    
    Windows guest will notitfy GVT-g to request more resources through g2v
    interface, when its resources are not enough.
    This patch is to handle this case and let vgpu enter failsafe mode to
    avoid too many error messages.
    
    Signed-off-by: Min He <min.he@intel.com>
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 48ef0771d772..a41b322d8957 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -453,6 +453,7 @@ struct intel_gvt_ops {
 
 enum {
 	GVT_FAILSAFE_UNSUPPORTED_GUEST,
+	GVT_FAILSAFE_INSUFFICIENT_RESOURCE,
 };
 
 #include "mpt.h"

commit fd64be636708d808852c4c8c1efce0a0a51c24c5
Author: Min He <min.he@intel.com>
Date:   Fri Feb 17 15:02:36 2017 +0800

    drm/i915/gvt: introduced failsafe mode into vgpu
    
    New failsafe mode is introduced, when we detect guest not supporting
    GVT-g.
    In failsafe mode, we will ignore all the MMIO and cfg space read/write
    from guest.
    
    This patch can fix the issue that when guest kernel or graphics driver
    version is too low, there will be a lot of kernel traces in host.
    
    V5: rebased onto latest gvt-staging
    V4: changed coding style by Zhenyu and Ping's advice
    V3: modified coding style and error messages according to Zhenyu's comment
    V2: 1) implemented MMIO/GTT/WP pages read/write logic; 2) used a unified
    function to enter failsafe mode
    
    Signed-off-by: Min He <min.he@intel.com>
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 5ee660077b0c..48ef0771d772 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -143,6 +143,8 @@ struct intel_vgpu {
 	int id;
 	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
 	bool active;
+	bool pv_notified;
+	bool failsafe;
 	bool resetting;
 	void *sched_data;
 
@@ -449,6 +451,10 @@ struct intel_gvt_ops {
 };
 
 
+enum {
+	GVT_FAILSAFE_UNSUPPORTED_GUEST,
+};
+
 #include "mpt.h"
 
 #endif

commit f655e67ac8d797425abb0404d0878758f3f71c1a
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Feb 16 14:10:01 2017 +0800

    drm/i915/gvt: Fix check error on opregion.c
    
    As we switched to memremap for opregion, shouldn't use any __iomem
    for that, and move to use memcpy instead.
    
    This fixed static check errors for:
    
      CHECK   drivers/gpu/drm/i915//gvt/opregion.c
      drivers/gpu/drm/i915//gvt/opregion.c:142:31: warning: incorrect type in argument 1 (different address spaces)
      drivers/gpu/drm/i915//gvt/opregion.c:142:31:    expected void *addr
      drivers/gpu/drm/i915//gvt/opregion.c:142:31:    got void [noderef] <asn:2>*opregion_va
      drivers/gpu/drm/i915//gvt/opregion.c:160:35: warning: incorrect type in assignment (different address spaces)
      drivers/gpu/drm/i915//gvt/opregion.c:160:35:    expected void [noderef] <asn:2>*opregion_va
      drivers/gpu/drm/i915//gvt/opregion.c:160:35:    got void *
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index e227caf5859e..5ee660077b0c 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -203,7 +203,7 @@ struct intel_gvt_firmware {
 };
 
 struct intel_gvt_opregion {
-	void __iomem *opregion_va;
+	void *opregion_va;
 	u32 opregion_pa;
 };
 

commit cfe65f4037cedb911a840ebcf6dafc5b69e535b4
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Jan 13 11:16:02 2017 +0800

    drm/i915/gvt: fix vGPU instance reuse issues by vGPU reset function
    
    Our function tests found several issues related to reusing vGPU
    instance. They are qemu reboot failure, guest tdr after reboot, host
    hang when reboot guest. All these issues are caused by dirty status
    inherited from last VM.
    
    This patch fix all these issues by resetting a virtual GPU before VM
    use it. The reset logical is put into a low level function
    _intel_gvt_reset_vgpu(), which supports Device Model Level Reset, Full
    GT Reset and Per-Engine Reset.
    
    vGPU Device Model Level Reset (DMLR) simulates the PCI reset to reset
    the whole vGPU to default state as when it is created, including GTT,
    execlist, scratch pages, cfg space, mmio space, pvinfo page, scheduler
    and fence registers. The ultimate goal of vGPU DMLR is that reuse a
    vGPU instance by different virtual machines. When we reassign a vGPU
    to a virtual machine we must issue such reset first.
    
    Full GT Reset and Per-Engine GT Reset are soft reset flow for GPU engines
    (Render, Blitter, Video, Video Enhancement). It is defined by GPU Spec.
    Unlike the FLR, GT reset only reset particular resource of a vGPU per
    the reset request. Guest driver can issue a GT reset by programming
    the virtual GDRST register to reset specific virtual GPU engine or all
    engines.
    
    Since vGPU DMLR and GT reset can share some code so we implement both
    these two into one single function intel_gvt_reset_vgpu_locked(). The
    parameter dmlr is to identify if we will do FLR or GT reset. The
    parameter engine_mask is to specific the engines that need to be
    resetted. If value ALL_ENGINES is given for engine_mask, it means
    the caller requests a full gt reset that we will reset all virtual
    GPU engines.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Reviewed-by: Jike Song <jike.song@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9832e7f2a662..e227caf5859e 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -376,6 +376,8 @@ void intel_gvt_clean_vgpu_types(struct intel_gvt *gvt);
 struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 					 struct intel_vgpu_type *type);
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_reset_vgpu_locked(struct intel_vgpu *vgpu, bool dmlr,
+				 unsigned int engine_mask);
 void intel_gvt_reset_vgpu(struct intel_vgpu *vgpu);
 
 

commit cdcc43479c9b929940a1955d2e7bae696d2b9496
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Jan 13 11:16:00 2017 +0800

    drm/i915/gvt: move mmio init/clean function to mmio.c
    
    Move the mmio space inititation function setup_vgpu_mmio()
    and cleanup function clean_vgpu_mmio() in vgpu.c to dedicated
    source file mmio.c, and rename them as intel_vgpu_init_mmio()
    and intel_vgpu_clean_mmio() respectively.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 9c97d7d36449..9832e7f2a662 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -429,7 +429,6 @@ void intel_vgpu_clean_opregion(struct intel_vgpu *vgpu);
 int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
 
 int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
-int setup_vgpu_mmio(struct intel_vgpu *vgpu);
 void populate_pvinfo_page(struct intel_vgpu *vgpu);
 
 struct intel_gvt_ops {

commit c64ff6c774413fdbffd7f0f3ef5b04127d461cf4
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Jan 13 11:15:59 2017 +0800

    drm/i915/gvt: introduce intel_vgpu_reset_cfg_space to reset configuration space
    
    This patch introduces a new function intel_vgpu_reset_cfg_space()
    to reset vGPU configuration space. This function will unmap gttmmio
    and aperture if they are mapped before. Then entire cfg space will
    be restored to default values.
    
    Currently we only do such reset when vGPU is not owned by any VM
    so we simply restore entire cfg space to default value, not following
    the PCIe FLR spec that some fields should remain unchanged.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index ab505552d313..9c97d7d36449 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -414,6 +414,8 @@ int intel_gvt_ggtt_h2g_index(struct intel_vgpu *vgpu, unsigned long h_index,
 
 void intel_vgpu_init_cfg_space(struct intel_vgpu *vgpu,
 		bool primary);
+void intel_vgpu_reset_cfg_space(struct intel_vgpu *vgpu);
+
 int intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 

commit 536fc234074b09adae1763d8fb5b2d947847ad1d
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Jan 13 11:15:58 2017 +0800

    drm/i915/gvt: move cfg space inititation function to cfg_space.c
    
    Move the configuration space inititation function setup_vgpu_cfg_space()
    in vgpu.c to dedicated source file cfg_space.c, and rename the function
    as intel_vgpu_init_cfg_space().
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 455281d07d75..ab505552d313 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -412,6 +412,8 @@ int intel_gvt_ggtt_index_g2h(struct intel_vgpu *vgpu, unsigned long g_index,
 int intel_gvt_ggtt_h2g_index(struct intel_vgpu *vgpu, unsigned long h_index,
 			     unsigned long *g_index);
 
+void intel_vgpu_init_cfg_space(struct intel_vgpu *vgpu,
+		bool primary);
 int intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 

commit d22a48bf7302ef064295749fa79cd47093c5a000
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Jan 13 11:15:56 2017 +0800

    drm/i915/gvt: introudce intel_vgpu_reset_resource() to reset vgpu resource state
    
    This patch introudces a new function intel_vgpu_reset_resource() to
    reset allocated vgpu resources by intel_vgpu_alloc_resource(). So far
    we only need clear the fence registers. The function _clear_vgpu_fence()
    will reset both virtual and physical fence registers to 0.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 0af17016f33f..455281d07d75 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -323,6 +323,7 @@ struct intel_vgpu_creation_params {
 
 int intel_vgpu_alloc_resource(struct intel_vgpu *vgpu,
 			      struct intel_vgpu_creation_params *param);
+void intel_vgpu_reset_resource(struct intel_vgpu *vgpu);
 void intel_vgpu_free_resource(struct intel_vgpu *vgpu);
 void intel_vgpu_write_fence(struct intel_vgpu *vgpu,
 	u32 fence, u64 value);

commit 364fb6b789ffce44c1b5429086c47b0df6c36aff
Author: Jike Song <jike.song@intel.com>
Date:   Fri Dec 16 10:51:06 2016 +0800

    drm/i915/gvt/kvmgt: prevent double-release of vgpu
    
    The release action might be triggered from either user's closing
    mdev or the detaching event of kvm and vfio_group, so this patch
    introduces an atomic to prevent double-release.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index ad0e9364ee70..0af17016f33f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -175,6 +175,7 @@ struct intel_vgpu {
 		struct notifier_block group_notifier;
 		struct kvm *kvm;
 		struct work_struct release_work;
+		atomic_t released;
 	} vdev;
 #endif
 };

commit 659643f7d81432189c2c87230e2feee4c75c14c1
Author: Jike Song <jike.song@intel.com>
Date:   Thu Dec 8 11:00:36 2016 +0800

    drm/i915/gvt/kvmgt: add vfio/mdev support to KVMGT
    
    KVMGT leverages vfio/mdev to mediate device accesses from guest,
    this patch adds the vfio/mdev support, thereby completes the
    functionality. An intel_vgpu is presented as a mdev device,
    and full userspace API compatibility with vfio-pci is kept.
    An intel_vgpu_ops is provided to mdev framework, methods get
    called to create/remove a vgpu, to open/close it, and to
    access it.
    
    Signed-off-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Xiaoguang Chen <xiaoguang.chen@intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index b1a7c8dd4b5f..ad0e9364ee70 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -164,15 +164,17 @@ struct intel_vgpu {
 
 #if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 	struct {
-		struct device *mdev;
+		struct mdev_device *mdev;
 		struct vfio_region *region;
 		int num_regions;
 		struct eventfd_ctx *intx_trigger;
 		struct eventfd_ctx *msi_trigger;
 		struct rb_root cache;
 		struct mutex cache_lock;
-		void *vfio_group;
 		struct notifier_block iommu_notifier;
+		struct notifier_block group_notifier;
+		struct kvm *kvm;
+		struct work_struct release_work;
 	} vdev;
 #endif
 };

commit 550dd77ebb6360120269d9a7102ae2c0cea41290
Author: Xiaoguang Chen <xiaoguang.chen@intel.com>
Date:   Thu Nov 24 13:13:00 2016 +0800

    drm/i915/gvt: fix getting 64bit bar size error
    
    For 64bit bar while reading the higher 32bit the value should be returned
    directly.
    
    In the current implementation the higher 32bit value was discarded and not
    written to the cfg space of vgpu which lead to an incorrect bar size.
    
    Signed-off-by: Xiaoguang Chen <xiaoguang.chen@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 3d4223e8ebe3..b1a7c8dd4b5f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -361,6 +361,8 @@ static inline void intel_vgpu_write_pci_bar(struct intel_vgpu *vgpu,
 		 * leave the bit 3 - bit 0 unchanged.
 		 */
 		*pval = (val & GENMASK(31, 4)) | (*pval & GENMASK(3, 0));
+	} else {
+		*pval = val;
 	}
 }
 

commit f30437c5e7bfa9d8acc18058040efb4f474907c3
Author: Jike Song <jike.song@intel.com>
Date:   Wed Nov 9 20:30:59 2016 +0800

    drm/i915/gvt: add KVMGT support
    
    KVMGT is the MPT implementation based on VFIO/KVM. It provides
    a kvmgt_mpt ops to gvt for vGPU access mediation, e.g. to
    mediate and emulate the MMIO accesses, to inject interrupts
    to vGPU user, to intercept the GTT writing and replace it with
    DMA-able address, to write-protect guest PPGTT table for
    shadowing synchronization, etc. This patch provides the MPT
    implementation for GVT, not yet functional due to theabsence
    of mdev.
    
    It's built as kvmgt.ko, depends on vfio.ko, kvm.ko and mdev.ko,
    and being required by i915.ko. To not introduce hard dependency
    in i915.ko, we used indirect symbol reference. But that means
    users have to include kvmgt.ko into init ramdisk if their
    i915.ko is included.
    
    Signed-off-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Xiaoguang Chen <xiaoguang.chen@intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 5e7b0bd01695..3d4223e8ebe3 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -161,6 +161,20 @@ struct intel_vgpu {
 	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
 	struct notifier_block shadow_ctx_notifier_block;
+
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
+	struct {
+		struct device *mdev;
+		struct vfio_region *region;
+		int num_regions;
+		struct eventfd_ctx *intx_trigger;
+		struct eventfd_ctx *msi_trigger;
+		struct rb_root cache;
+		struct mutex cache_lock;
+		void *vfio_group;
+		struct notifier_block iommu_notifier;
+	} vdev;
+#endif
 };
 
 struct intel_gvt_gm {

commit 9ec1e66b8084f24d41046bd9711fbd7ec6e3850f
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:35 2016 +0800

    drm/i915/gvt: refactor intel_gvt_io_emulation_ops to be intel_gvt_ops
    
    There are currently 4 methods in intel_gvt_io_emulation_ops
    to emulate CFG/MMIO reading/writing for intel vGPU. A possibly
    better scope is: add 3 more methods for vgpu create/destroy/reset
    respectively, and rename the ops to 'intel_gvt_ops', then pass
    it to the MPT module (say the future kvmgt) to use: they are
    all methods for external usage.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 33e6a6447025..5e7b0bd01695 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -356,6 +356,7 @@ void intel_gvt_clean_vgpu_types(struct intel_gvt *gvt);
 struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 					 struct intel_vgpu_type *type);
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
+void intel_gvt_reset_vgpu(struct intel_vgpu *vgpu);
 
 
 /* validating GM functions */
@@ -391,10 +392,10 @@ int intel_gvt_ggtt_index_g2h(struct intel_vgpu *vgpu, unsigned long g_index,
 int intel_gvt_ggtt_h2g_index(struct intel_vgpu *vgpu, unsigned long h_index,
 			     unsigned long *g_index);
 
-int intel_vgpu_emulate_cfg_read(void *__vgpu, unsigned int offset,
+int intel_vgpu_emulate_cfg_read(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 
-int intel_vgpu_emulate_cfg_write(void *__vgpu, unsigned int offset,
+int intel_vgpu_emulate_cfg_write(struct intel_vgpu *vgpu, unsigned int offset,
 		void *p_data, unsigned int bytes);
 
 void intel_gvt_clean_opregion(struct intel_gvt *gvt);
@@ -407,6 +408,22 @@ int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
 int setup_vgpu_mmio(struct intel_vgpu *vgpu);
 void populate_pvinfo_page(struct intel_vgpu *vgpu);
 
+struct intel_gvt_ops {
+	int (*emulate_cfg_read)(struct intel_vgpu *, unsigned int, void *,
+				unsigned int);
+	int (*emulate_cfg_write)(struct intel_vgpu *, unsigned int, void *,
+				unsigned int);
+	int (*emulate_mmio_read)(struct intel_vgpu *, u64, void *,
+				unsigned int);
+	int (*emulate_mmio_write)(struct intel_vgpu *, u64, void *,
+				unsigned int);
+	struct intel_vgpu *(*vgpu_create)(struct intel_gvt *,
+				struct intel_vgpu_type *);
+	void (*vgpu_destroy)(struct intel_vgpu *);
+	void (*vgpu_reset)(struct intel_vgpu *);
+};
+
+
 #include "mpt.h"
 
 #endif

commit 1f31c8294880d1ac99b1b477efd9de23b36cd5ec
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Nov 3 18:38:31 2016 +0800

    drm/i915/gvt: add intel vgpu types support
    
    By providing predefined vGPU types, users can choose which type a vgpu
    to create and use, without specifying detailed parameters.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 62fc9e3ac5c6..33e6a6447025 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -190,6 +190,16 @@ struct intel_gvt_opregion {
 	u32 opregion_pa;
 };
 
+#define NR_MAX_INTEL_VGPU_TYPES 20
+struct intel_vgpu_type {
+	char name[16];
+	unsigned int max_instance;
+	unsigned int avail_instance;
+	unsigned int low_gm_size;
+	unsigned int high_gm_size;
+	unsigned int fence;
+};
+
 struct intel_gvt {
 	struct mutex lock;
 	struct drm_i915_private *dev_priv;
@@ -205,6 +215,8 @@ struct intel_gvt {
 	struct intel_gvt_opregion opregion;
 	struct intel_gvt_workload_scheduler scheduler;
 	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
+	struct intel_vgpu_type *types;
+	unsigned int num_types;
 
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;
@@ -230,6 +242,14 @@ static inline void intel_gvt_request_service(struct intel_gvt *gvt,
 void intel_gvt_free_firmware(struct intel_gvt *gvt);
 int intel_gvt_load_firmware(struct intel_gvt *gvt);
 
+/* Aperture/GM space definitions for GVT device */
+#define MB_TO_BYTES(mb) ((mb) << 20ULL)
+#define BYTES_TO_MB(b) ((b) >> 20ULL)
+
+#define HOST_LOW_GM_SIZE MB_TO_BYTES(128)
+#define HOST_HIGH_GM_SIZE MB_TO_BYTES(384)
+#define HOST_FENCE 4
+
 /* Aperture/GM space definitions for GVT device */
 #define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
 #define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.mappable_base)
@@ -330,12 +350,14 @@ static inline void intel_vgpu_write_pci_bar(struct intel_vgpu *vgpu,
 	}
 }
 
-struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
-					 struct intel_vgpu_creation_params *
-					 param);
+int intel_gvt_init_vgpu_types(struct intel_gvt *gvt);
+void intel_gvt_clean_vgpu_types(struct intel_gvt *gvt);
 
+struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
+					 struct intel_vgpu_type *type);
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
 
+
 /* validating GM functions */
 #define vgpu_gmadr_is_aperture(vgpu, gmadr) \
 	((gmadr >= vgpu_aperture_gmadr_base(vgpu)) && \

commit 23736d1b1b2321f7e4647d8d5f8ff16fab11d24f
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Wed Oct 26 09:38:52 2016 +0800

    drm/i915/gvt: add full vGPU reset support
    
    Full vGPU reset need to release all the shadow PPGGT pages to avoid
    unnecessary write-protect and also should re-initialize pvinfo after
    resetting vregs to keep pvinfo correct.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 11df62b542b1..62fc9e3ac5c6 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -382,6 +382,8 @@ void intel_vgpu_clean_opregion(struct intel_vgpu *vgpu);
 int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
 
 int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
+int setup_vgpu_mmio(struct intel_vgpu *vgpu);
+void populate_pvinfo_page(struct intel_vgpu *vgpu);
 
 #include "mpt.h"
 

commit 321927db98320f0121adc50a8325f23e08735c34
Author: Du, Changbin <changbin.du@intel.com>
Date:   Thu Oct 20 14:08:46 2016 +0800

    drm/i915/gvt: fix sparse warnings on different address spaces
    
    Add proper __iomem annotation for pointers obtained via ioremap().
    
    Signed-off-by: Du, Changbin <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 15c595e0a63b..11df62b542b1 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -186,7 +186,7 @@ struct intel_gvt_firmware {
 };
 
 struct intel_gvt_opregion {
-	void *opregion_va;
+	void __iomem *opregion_va;
 	u32 opregion_pa;
 };
 

commit feddf6e866c9cdbdec45b09f0a9566ea538a0da3
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Oct 20 17:15:03 2016 +0800

    drm/i915/gvt: clean up intel_gvt.h as interface for i915 core
    
    i915 core should only call functions and structures exposed through
    intel_gvt.h. Remove internal gvt.h and i915_pvinfo.h.
    
    Change for internal intel_gvt structure as private handler which
    not requires to expose gvt internal structure for i915 core.
    
    v2: Fix per Chris's comment
    - carefully handle dev_priv->gvt assignment
    - add necessary bracket for macro helper
    - forward declartion struct intel_gvt
    - keep free operation within same file handling alloc
    
    v3: fix use after free and remove intel_gvt.initialized
    
    v4: change to_gvt() to an inline
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1564554b7459..15c595e0a63b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -192,8 +192,6 @@ struct intel_gvt_opregion {
 
 struct intel_gvt {
 	struct mutex lock;
-	bool initialized;
-
 	struct drm_i915_private *dev_priv;
 	struct idr vgpu_idr;	/* vGPU IDR pool */
 
@@ -213,6 +211,11 @@ struct intel_gvt {
 	unsigned long service_request;
 };
 
+static inline struct intel_gvt *to_gvt(struct drm_i915_private *i915)
+{
+	return i915->gvt;
+}
+
 enum {
 	INTEL_GVT_REQUEST_EMULATE_VBLANK = 0,
 };

commit be1da7070aeaee23ff659c1a8cd992789ff86da4
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue May 3 18:26:57 2016 -0400

    drm/i915/gvt: vGPU command scanner
    
    This patch introduces a command scanner to scan guest command buffers.
    
    Signed-off-by: Yulei Zhang <yulei.zhang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index dfe398d47496..1564554b7459 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -45,6 +45,7 @@
 #include "scheduler.h"
 #include "sched_policy.h"
 #include "render.h"
+#include "cmd_parser.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -71,6 +72,8 @@ struct intel_gvt_device_info {
 	u32 gtt_start_offset;
 	u32 gtt_entry_size;
 	u32 gtt_entry_size_shift;
+	int gmadr_bytes_in_cmd;
+	u32 max_surface_size;
 };
 
 /* GM resources owned by a vGPU */
@@ -203,6 +206,7 @@ struct intel_gvt {
 	struct intel_gvt_gtt gtt;
 	struct intel_gvt_opregion opregion;
 	struct intel_gvt_workload_scheduler scheduler;
+	DECLARE_HASHTABLE(cmd_table, GVT_CMD_HASH_BITS);
 
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;

commit 178657139307126b22d226df0823223d6dfe91ba
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 19:02:37 2016 -0400

    drm/i915/gvt: vGPU context switch
    
    As different VM may configure different render MMIOs when executing
    workload, to schedule workloads between different VM, the render MMIOs
    have to be switched.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 6d37468631b7..dfe398d47496 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -44,6 +44,7 @@
 #include "execlist.h"
 #include "scheduler.h"
 #include "sched_policy.h"
+#include "render.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -154,6 +155,7 @@ struct intel_vgpu {
 	struct list_head workload_q_head[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
 	atomic_t running_workload_num;
+	DECLARE_BITMAP(tlb_handle_pending, I915_NUM_ENGINES);
 	struct i915_gem_context *shadow_ctx;
 	struct notifier_block shadow_ctx_notifier_block;
 };

commit 4b63960ebd3f4c41caca6a8dca68751b34e61e9b
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 17:09:58 2016 -0400

    drm/i915/gvt: vGPU schedule policy framework
    
    This patch introduces a vGPU schedule policy framework, with a timer based
    schedule policy module for now
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index ae716cf22f69..6d37468631b7 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -43,6 +43,7 @@
 #include "edid.h"
 #include "execlist.h"
 #include "scheduler.h"
+#include "sched_policy.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -139,6 +140,7 @@ struct intel_vgpu {
 	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
 	bool active;
 	bool resetting;
+	void *sched_data;
 
 	struct intel_vgpu_fence fence;
 	struct intel_vgpu_gm gm;

commit e473405783c064a9d859d108010581bae8e9af40
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 07:42:16 2016 -0400

    drm/i915/gvt: vGPU workload scheduler
    
    This patch introduces the vGPU workload scheduler routines.
    
    GVT workload scheduler is responsible for picking and executing GVT workload
    from current scheduled vGPU. Before the workload is submitted to host i915,
    the guest execlist context will be shadowed in the host GVT shadow context.
    the instructions in guest ring buffer will be copied into GVT shadow ring
    buffer. Then GVT-g workload scheduler will scan the instructions in guest
    ring buffer and submit it to host i915.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 414163695e07..ae716cf22f69 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -151,6 +151,9 @@ struct intel_vgpu {
 	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
 	struct list_head workload_q_head[I915_NUM_ENGINES];
 	struct kmem_cache *workloads;
+	atomic_t running_workload_num;
+	struct i915_gem_context *shadow_ctx;
+	struct notifier_block shadow_ctx_notifier_block;
 };
 
 struct intel_gvt_gm {

commit 28c4c6ca7f794b2d5ac8773d43311e95f6518415
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 05:22:47 2016 -0400

    drm/i915/gvt: vGPU workload submission
    
    This patch introduces the vGPU workload submission logics.
    
    Under virtualization environment, guest will submit workload through
    virtual execlist submit port. The submitted workload load will be wrapped
    into an gvt workload which will be picked by GVT workload scheduler and
    executed on host i915 later.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 82f932a24e7d..414163695e07 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -42,6 +42,7 @@
 #include "display.h"
 #include "edid.h"
 #include "execlist.h"
+#include "scheduler.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -147,8 +148,9 @@ struct intel_vgpu {
 	struct intel_vgpu_gtt gtt;
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
-	/* TODO: move the declaration of intel_gvt.h to a proper place. */
 	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
+	struct list_head workload_q_head[I915_NUM_ENGINES];
+	struct kmem_cache *workloads;
 };
 
 struct intel_gvt_gm {
@@ -193,6 +195,7 @@ struct intel_gvt {
 	struct intel_gvt_irq irq;
 	struct intel_gvt_gtt gtt;
 	struct intel_gvt_opregion opregion;
+	struct intel_gvt_workload_scheduler scheduler;
 
 	struct task_struct *service_thread;
 	wait_queue_head_t service_thread_wq;

commit 8453d674ae7e63f629a91fe4124df7a7dc9c74cd
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 02:48:25 2016 -0400

    drm/i915/gvt: vGPU execlist virtualization
    
    This patch introduces the vGPU execlist virtualization.
    
    Under virtulization environment, HW execlist interface are fully emulated
    including virtual CSB emulation, virtual execlist emulation. The framework
    will emulate the virtual CSB according to the guest workload running status
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 1619881dbd51..82f932a24e7d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -41,6 +41,7 @@
 #include "gtt.h"
 #include "display.h"
 #include "edid.h"
+#include "execlist.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -146,6 +147,8 @@ struct intel_vgpu {
 	struct intel_vgpu_gtt gtt;
 	struct intel_vgpu_opregion opregion;
 	struct intel_vgpu_display display;
+	/* TODO: move the declaration of intel_gvt.h to a proper place. */
+	struct intel_vgpu_execlist execlist[I915_NUM_ENGINES];
 };
 
 struct intel_gvt_gm {

commit 04d348ae3f0aea6523bc3b0688b5fc90c1c60d0e
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Apr 25 18:28:56 2016 -0400

    drm/i915/gvt: vGPU display virtualization
    
    This patch introduces the GVT-g display virtualization.
    
    It consists a collection of display MMIO handlers, like power well register
    handler, pipe register handler, plane register handler, which will emulate
    all display MMIOs behavior to support virtual mode setting sequence for
    guest.
    
    Signed-off-by: Bing Niu <bing.niu@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 2560c3aaac45..1619881dbd51 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -39,6 +39,8 @@
 #include "reg.h"
 #include "interrupt.h"
 #include "gtt.h"
+#include "display.h"
+#include "edid.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -105,8 +107,12 @@ struct intel_vgpu_cfg_space {
 
 #define vgpu_cfg_space(vgpu) ((vgpu)->cfg_space.virtual_cfg_space)
 
+#define INTEL_GVT_MAX_PIPE 4
+
 struct intel_vgpu_irq {
 	bool irq_warn_once[INTEL_GVT_EVENT_MAX];
+	DECLARE_BITMAP(flip_done_event[INTEL_GVT_MAX_PIPE],
+		       INTEL_GVT_EVENT_MAX);
 };
 
 struct intel_vgpu_opregion {
@@ -117,6 +123,14 @@ struct intel_vgpu_opregion {
 
 #define vgpu_opregion(vgpu) (&(vgpu->opregion))
 
+#define INTEL_GVT_MAX_PORT 5
+
+struct intel_vgpu_display {
+	struct intel_vgpu_i2c_edid i2c_edid;
+	struct intel_vgpu_port ports[INTEL_GVT_MAX_PORT];
+	struct intel_vgpu_sbi sbi;
+};
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
@@ -131,6 +145,7 @@ struct intel_vgpu {
 	struct intel_vgpu_irq irq;
 	struct intel_vgpu_gtt gtt;
 	struct intel_vgpu_opregion opregion;
+	struct intel_vgpu_display display;
 };
 
 struct intel_gvt_gm {
@@ -175,8 +190,23 @@ struct intel_gvt {
 	struct intel_gvt_irq irq;
 	struct intel_gvt_gtt gtt;
 	struct intel_gvt_opregion opregion;
+
+	struct task_struct *service_thread;
+	wait_queue_head_t service_thread_wq;
+	unsigned long service_request;
 };
 
+enum {
+	INTEL_GVT_REQUEST_EMULATE_VBLANK = 0,
+};
+
+static inline void intel_gvt_request_service(struct intel_gvt *gvt,
+		int service)
+{
+	set_bit(service, (void *)&gvt->service_request);
+	wake_up(&gvt->service_thread_wq);
+}
+
 void intel_gvt_free_firmware(struct intel_gvt *gvt);
 int intel_gvt_load_firmware(struct intel_gvt *gvt);
 

commit e39c5add322184de3be052d438dfd24375bfeaea
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Fri Sep 2 13:33:29 2016 +0800

    drm/i915/gvt: vGPU MMIO virtualization
    
    This patch introduces the generic vGPU MMIO emulation intercept
    framework.  The MPT modules will request GVT-g core logic to
    emulate MMIO read/write through IO emulation operations
    callback when hypervisor trapped a guest GTTMMIO read/write.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index f895c9242a28..2560c3aaac45 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -87,6 +87,7 @@ struct intel_vgpu_fence {
 struct intel_vgpu_mmio {
 	void *vreg;
 	void *sreg;
+	bool disable_warn_untrack;
 };
 
 #define INTEL_GVT_MAX_CFG_SPACE_SZ 256
@@ -184,6 +185,8 @@ int intel_gvt_load_firmware(struct intel_gvt *gvt);
 #define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.mappable_base)
 
 #define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.base.total)
+#define gvt_ggtt_sz(gvt) \
+	((gvt->dev_priv->ggtt.base.total >> PAGE_SHIFT) << 3)
 #define gvt_hidden_sz(gvt)	  (gvt_ggtt_gm_sz(gvt) - gvt_aperture_sz(gvt))
 
 #define gvt_aperture_gmadr_base(gvt) (0)

commit 4d60c5fd3f8751ea751d6dc6cfe0c1620420ccf8
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Wed Jul 20 01:14:38 2016 -0400

    drm/i915/gvt: vGPU PCI configuration space virtualization
    
    This patch introduces vGPU PCI configuration space virtualization.
    
    - Adjust the trapped GPFN(Guest Page Frame Number) window of virtual GEN
    PCI BAR 0 when guest initializes PCI BAR 0 address.
    
    - Emulate OpRegion when guest touches OpRegion.
    
    - Pass-through a part of aperture to guest when guest initializes
    aperture BAR.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 11267e73671a..f895c9242a28 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -108,6 +108,14 @@ struct intel_vgpu_irq {
 	bool irq_warn_once[INTEL_GVT_EVENT_MAX];
 };
 
+struct intel_vgpu_opregion {
+	void *va;
+	u32 gfn[INTEL_GVT_OPREGION_PAGES];
+	struct page *pages[INTEL_GVT_OPREGION_PAGES];
+};
+
+#define vgpu_opregion(vgpu) (&(vgpu->opregion))
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
@@ -121,6 +129,7 @@ struct intel_vgpu {
 	struct intel_vgpu_mmio mmio;
 	struct intel_vgpu_irq irq;
 	struct intel_vgpu_gtt gtt;
+	struct intel_vgpu_opregion opregion;
 };
 
 struct intel_gvt_gm {
@@ -145,6 +154,11 @@ struct intel_gvt_firmware {
 	bool firmware_loaded;
 };
 
+struct intel_gvt_opregion {
+	void *opregion_va;
+	u32 opregion_pa;
+};
+
 struct intel_gvt {
 	struct mutex lock;
 	bool initialized;
@@ -159,6 +173,7 @@ struct intel_gvt {
 	struct intel_gvt_firmware firmware;
 	struct intel_gvt_irq irq;
 	struct intel_gvt_gtt gtt;
+	struct intel_gvt_opregion opregion;
 };
 
 void intel_gvt_free_firmware(struct intel_gvt *gvt);
@@ -300,6 +315,21 @@ int intel_gvt_ggtt_index_g2h(struct intel_vgpu *vgpu, unsigned long g_index,
 			     unsigned long *h_index);
 int intel_gvt_ggtt_h2g_index(struct intel_vgpu *vgpu, unsigned long h_index,
 			     unsigned long *g_index);
+
+int intel_vgpu_emulate_cfg_read(void *__vgpu, unsigned int offset,
+		void *p_data, unsigned int bytes);
+
+int intel_vgpu_emulate_cfg_write(void *__vgpu, unsigned int offset,
+		void *p_data, unsigned int bytes);
+
+void intel_gvt_clean_opregion(struct intel_gvt *gvt);
+int intel_gvt_init_opregion(struct intel_gvt *gvt);
+
+void intel_vgpu_clean_opregion(struct intel_vgpu *vgpu);
+int intel_vgpu_init_opregion(struct intel_vgpu *vgpu, u32 gpa);
+
+int intel_vgpu_emulate_opregion_request(struct intel_vgpu *vgpu, u32 swsci);
+
 #include "mpt.h"
 
 #endif

commit 2707e44466881d6b0a8ed05a429dcf0940c22f60
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Mar 28 23:23:16 2016 +0800

    drm/i915/gvt: vGPU graphics memory virtualization
    
    The vGPU graphics memory emulation framework is responsible for graphics
    memory table virtualization. Under virtualization environment, a VM will
    populate the page table entry with guest page frame number(GPFN/GFN), while
    HW needs a page table filled with MFN(Machine frame number). The
    relationship between GFN and MFN(Machine frame number) is managed by
    hypervisor, while GEN HW doesn't have such knowledge to translate a GFN.
    
    To solve this gap, shadow GGTT/PPGTT page table is introdcued.
    
    For GGTT, the GFN inside the guest GGTT page table entry will be translated
    into MFN and written into physical GTT MMIO registers when guest write
    virtual GTT MMIO registers.
    
    For PPGTT, a shadow PPGTT page table will be created and write-protected
    translated from guest PPGTT page table.  And the shadow page table root
    pointers will be written into the shadow context after a guest workload
    is shadowed.
    
    vGPU graphics memory emulation framework consists:
    
    - Per-GEN HW platform page table entry bits extract/de-extract routines.
    - GTT MMIO register emulation handlers, which will call hypercall to do
    GFN->MFN translation when guest write GTT MMIO register
    - PPGTT shadow page table routines, e.g. shadow create/destroy/out-of-sync
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 655e6afb0aca..11267e73671a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -38,6 +38,7 @@
 #include "mmio.h"
 #include "reg.h"
 #include "interrupt.h"
+#include "gtt.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -61,6 +62,9 @@ struct intel_gvt_device_info {
 	u32 mmio_size;
 	u32 mmio_bar;
 	unsigned long msi_cap_offset;
+	u32 gtt_start_offset;
+	u32 gtt_entry_size;
+	u32 gtt_entry_size_shift;
 };
 
 /* GM resources owned by a vGPU */
@@ -116,6 +120,7 @@ struct intel_vgpu {
 	struct intel_vgpu_cfg_space cfg_space;
 	struct intel_vgpu_mmio mmio;
 	struct intel_vgpu_irq irq;
+	struct intel_vgpu_gtt gtt;
 };
 
 struct intel_gvt_gm {
@@ -153,6 +158,7 @@ struct intel_gvt {
 	struct intel_gvt_mmio mmio;
 	struct intel_gvt_firmware firmware;
 	struct intel_gvt_irq irq;
+	struct intel_gvt_gtt gtt;
 };
 
 void intel_gvt_free_firmware(struct intel_gvt *gvt);
@@ -262,6 +268,38 @@ struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
 
 void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
 
+/* validating GM functions */
+#define vgpu_gmadr_is_aperture(vgpu, gmadr) \
+	((gmadr >= vgpu_aperture_gmadr_base(vgpu)) && \
+	 (gmadr <= vgpu_aperture_gmadr_end(vgpu)))
+
+#define vgpu_gmadr_is_hidden(vgpu, gmadr) \
+	((gmadr >= vgpu_hidden_gmadr_base(vgpu)) && \
+	 (gmadr <= vgpu_hidden_gmadr_end(vgpu)))
+
+#define vgpu_gmadr_is_valid(vgpu, gmadr) \
+	 ((vgpu_gmadr_is_aperture(vgpu, gmadr) || \
+	  (vgpu_gmadr_is_hidden(vgpu, gmadr))))
+
+#define gvt_gmadr_is_aperture(gvt, gmadr) \
+	 ((gmadr >= gvt_aperture_gmadr_base(gvt)) && \
+	  (gmadr <= gvt_aperture_gmadr_end(gvt)))
+
+#define gvt_gmadr_is_hidden(gvt, gmadr) \
+	  ((gmadr >= gvt_hidden_gmadr_base(gvt)) && \
+	   (gmadr <= gvt_hidden_gmadr_end(gvt)))
+
+#define gvt_gmadr_is_valid(gvt, gmadr) \
+	  (gvt_gmadr_is_aperture(gvt, gmadr) || \
+	    gvt_gmadr_is_hidden(gvt, gmadr))
+
+bool intel_gvt_ggtt_validate_range(struct intel_vgpu *vgpu, u64 addr, u32 size);
+int intel_gvt_ggtt_gmadr_g2h(struct intel_vgpu *vgpu, u64 g_addr, u64 *h_addr);
+int intel_gvt_ggtt_gmadr_h2g(struct intel_vgpu *vgpu, u64 h_addr, u64 *g_addr);
+int intel_gvt_ggtt_index_g2h(struct intel_vgpu *vgpu, unsigned long g_index,
+			     unsigned long *h_index);
+int intel_gvt_ggtt_h2g_index(struct intel_vgpu *vgpu, unsigned long h_index,
+			     unsigned long *g_index);
 #include "mpt.h"
 
 #endif

commit c8fe6a6811a7186656379d0c27e85325a966077a
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Sep 17 09:22:08 2015 +0800

    drm/i915/gvt: vGPU interrupt virtualization.
    
    This patch introduces vGPU interrupt emulation framework.
    
    The vGPU intrerrupt emulation framework is an event-based interrupt
    emulation framework. It's responsible for emulating GEN hardware interrupts
    during emulating other HW behaviour.
    
    It consists several components:
    
    - Descriptions of interrupt register bit
    - Upper level <-> lower level interrupt mapping
    - GEN HW IER/IMR/IIR register emulation routines
    - Event-based interrupt propagation interface
    
    When a GVT-g component wants to inject an interrupt to a VM during a
    emulation, first it should specify the event needs to be emulated and the
    framework will deal with the rest of emulation:
    
    - Generating related virtual IIR bit according to virtual IER and IMRs,
    - Generate related virtual upper level virtual IIR bit accodring to the
    per-platform interrupt mapping
    - Injecting a MSI to VM
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index e00c2d66f658..655e6afb0aca 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -37,6 +37,7 @@
 #include "hypercall.h"
 #include "mmio.h"
 #include "reg.h"
+#include "interrupt.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -56,9 +57,10 @@ extern struct intel_gvt_host intel_gvt_host;
 /* Describe per-platform limitations. */
 struct intel_gvt_device_info {
 	u32 max_support_vgpus;
-	u32 mmio_size;
 	u32 cfg_space_size;
+	u32 mmio_size;
 	u32 mmio_bar;
+	unsigned long msi_cap_offset;
 };
 
 /* GM resources owned by a vGPU */
@@ -98,6 +100,10 @@ struct intel_vgpu_cfg_space {
 
 #define vgpu_cfg_space(vgpu) ((vgpu)->cfg_space.virtual_cfg_space)
 
+struct intel_vgpu_irq {
+	bool irq_warn_once[INTEL_GVT_EVENT_MAX];
+};
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
@@ -109,6 +115,7 @@ struct intel_vgpu {
 	struct intel_vgpu_gm gm;
 	struct intel_vgpu_cfg_space cfg_space;
 	struct intel_vgpu_mmio mmio;
+	struct intel_vgpu_irq irq;
 };
 
 struct intel_gvt_gm {
@@ -145,6 +152,7 @@ struct intel_gvt {
 	struct intel_gvt_fence fence;
 	struct intel_gvt_mmio mmio;
 	struct intel_gvt_firmware firmware;
+	struct intel_gvt_irq irq;
 };
 
 void intel_gvt_free_firmware(struct intel_gvt *gvt);

commit 82d375d1b56820fd094da15c82562661b6a8f344
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue Jul 5 12:40:49 2016 -0400

    drm/i915/gvt: Introduce basic vGPU life cycle management
    
    A vGPU represents a virtual Intel GEN hardware, which consists following
    virtual resources:
    
    - Configuration space (virtualized)
    - HW registers (virtualized)
    - GGTT memory space (partitioned)
    - GPU page table (shadowed)
    - Fence registers (partitioned)
    
    * virtualized: fully emulated by GVT-g.
    * partitioned: Only a part of the HW resource is allowed to be accessed
    by VM.
    * shadowed: Resource needs to be translated and shadowed before getting
    applied into HW.
    
    This patch introduces vGPU life cycle management framework, which is
    responsible for creating/destroying a vGPU and preparing/free resources
    related to a vGPU.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index e8759680e952..e00c2d66f658 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -36,6 +36,7 @@
 #include "debug.h"
 #include "hypercall.h"
 #include "mmio.h"
+#include "reg.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -77,13 +78,37 @@ struct intel_vgpu_fence {
 	u32 size;
 };
 
+struct intel_vgpu_mmio {
+	void *vreg;
+	void *sreg;
+};
+
+#define INTEL_GVT_MAX_CFG_SPACE_SZ 256
+#define INTEL_GVT_MAX_BAR_NUM 4
+
+struct intel_vgpu_pci_bar {
+	u64 size;
+	bool tracked;
+};
+
+struct intel_vgpu_cfg_space {
+	unsigned char virtual_cfg_space[INTEL_GVT_MAX_CFG_SPACE_SZ];
+	struct intel_vgpu_pci_bar bar[INTEL_GVT_MAX_BAR_NUM];
+};
+
+#define vgpu_cfg_space(vgpu) ((vgpu)->cfg_space.virtual_cfg_space)
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
 	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
+	bool active;
+	bool resetting;
 
 	struct intel_vgpu_fence fence;
 	struct intel_vgpu_gm gm;
+	struct intel_vgpu_cfg_space cfg_space;
+	struct intel_vgpu_mmio mmio;
 };
 
 struct intel_gvt_gm {
@@ -183,6 +208,52 @@ void intel_vgpu_free_resource(struct intel_vgpu *vgpu);
 void intel_vgpu_write_fence(struct intel_vgpu *vgpu,
 	u32 fence, u64 value);
 
+/* Macros for easily accessing vGPU virtual/shadow register */
+#define vgpu_vreg(vgpu, reg) \
+	(*(u32 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_vreg8(vgpu, reg) \
+	(*(u8 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_vreg16(vgpu, reg) \
+	(*(u16 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_vreg64(vgpu, reg) \
+	(*(u64 *)(vgpu->mmio.vreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_sreg(vgpu, reg) \
+	(*(u32 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_sreg8(vgpu, reg) \
+	(*(u8 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_sreg16(vgpu, reg) \
+	(*(u16 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
+#define vgpu_sreg64(vgpu, reg) \
+	(*(u64 *)(vgpu->mmio.sreg + INTEL_GVT_MMIO_OFFSET(reg)))
+
+#define for_each_active_vgpu(gvt, vgpu, id) \
+	idr_for_each_entry((&(gvt)->vgpu_idr), (vgpu), (id)) \
+		for_each_if(vgpu->active)
+
+static inline void intel_vgpu_write_pci_bar(struct intel_vgpu *vgpu,
+					    u32 offset, u32 val, bool low)
+{
+	u32 *pval;
+
+	/* BAR offset should be 32 bits algiend */
+	offset = rounddown(offset, 4);
+	pval = (u32 *)(vgpu_cfg_space(vgpu) + offset);
+
+	if (low) {
+		/*
+		 * only update bit 31 - bit 4,
+		 * leave the bit 3 - bit 0 unchanged.
+		 */
+		*pval = (val & GENMASK(31, 4)) | (*pval & GENMASK(3, 0));
+	}
+}
+
+struct intel_vgpu *intel_gvt_create_vgpu(struct intel_gvt *gvt,
+					 struct intel_vgpu_creation_params *
+					 param);
+
+void intel_gvt_destroy_vgpu(struct intel_vgpu *vgpu);
+
 #include "mpt.h"
 
 #endif

commit 579cea5f30f2c70215492e987bb439a3e50c6371
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Jun 30 12:45:34 2016 -0400

    drm/i915/gvt: golden virtual HW state management
    
    Each vGPU expects a golden virtual HW state, which is just the state after
    system is freshly powered on. GVT-g will try to load the golden virtual HW
    state via kernel firmware interface.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index 024ad97eba12..e8759680e952 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -56,6 +56,8 @@ extern struct intel_gvt_host intel_gvt_host;
 struct intel_gvt_device_info {
 	u32 max_support_vgpus;
 	u32 mmio_size;
+	u32 cfg_space_size;
+	u32 mmio_bar;
 };
 
 /* GM resources owned by a vGPU */
@@ -100,6 +102,12 @@ struct intel_gvt_mmio {
 	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
 };
 
+struct intel_gvt_firmware {
+	void *cfg_space;
+	void *mmio;
+	bool firmware_loaded;
+};
+
 struct intel_gvt {
 	struct mutex lock;
 	bool initialized;
@@ -111,8 +119,12 @@ struct intel_gvt {
 	struct intel_gvt_gm gm;
 	struct intel_gvt_fence fence;
 	struct intel_gvt_mmio mmio;
+	struct intel_gvt_firmware firmware;
 };
 
+void intel_gvt_free_firmware(struct intel_gvt *gvt);
+int intel_gvt_load_firmware(struct intel_gvt *gvt);
+
 /* Aperture/GM space definitions for GVT device */
 #define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
 #define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.mappable_base)

commit 12d14cc43b34706283246917329b2182163ba9aa
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue Aug 30 11:06:17 2016 +0800

    drm/i915/gvt: Introduce a framework for tracking HW registers.
    
    This patch introduces a framework for tracking HW registers on different
    GEN platforms.
    
    Accesses to GEN HW registers from VMs will be trapped by hypervisor. It
    will forward these emulation requests to GVT-g device model, which
    requires this framework to search for related register descriptions.
    
    Each MMIO entry in this framework describes a GEN HW registers, e.g.
    offset, length, whether it contains RO bits, whether it can be accessed by
    LRIs...and also emulation handlers for emulating register reading and
    writing.
    
    - Use i915 MMIO register definition & statement.(Joonas)
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index f42cdf74d577..024ad97eba12 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -19,6 +19,15 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
+ *
+ * Authors:
+ *    Kevin Tian <kevin.tian@intel.com>
+ *    Eddie Dong <eddie.dong@intel.com>
+ *
+ * Contributors:
+ *    Niu Bing <bing.niu@intel.com>
+ *    Zhi Wang <zhi.a.wang@intel.com>
+ *
  */
 
 #ifndef _GVT_H_
@@ -26,6 +35,7 @@
 
 #include "debug.h"
 #include "hypercall.h"
+#include "mmio.h"
 
 #define GVT_MAX_VGPU 8
 
@@ -45,7 +55,7 @@ extern struct intel_gvt_host intel_gvt_host;
 /* Describe per-platform limitations. */
 struct intel_gvt_device_info {
 	u32 max_support_vgpus;
-	/* This data structure will grow bigger in GVT device model patches */
+	u32 mmio_size;
 };
 
 /* GM resources owned by a vGPU */
@@ -83,6 +93,13 @@ struct intel_gvt_fence {
 	unsigned long vgpu_allocated_fence_num;
 };
 
+#define INTEL_GVT_MMIO_HASH_BITS 9
+
+struct intel_gvt_mmio {
+	u32 *mmio_attribute;
+	DECLARE_HASHTABLE(mmio_info_table, INTEL_GVT_MMIO_HASH_BITS);
+};
+
 struct intel_gvt {
 	struct mutex lock;
 	bool initialized;
@@ -93,6 +110,7 @@ struct intel_gvt {
 	struct intel_gvt_device_info device_info;
 	struct intel_gvt_gm gm;
 	struct intel_gvt_fence fence;
+	struct intel_gvt_mmio mmio;
 };
 
 /* Aperture/GM space definitions for GVT device */

commit 28a60dee2ce6021fa6b304bc6761b71120635ad8
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Fri Sep 2 12:41:29 2016 +0800

    drm/i915/gvt: vGPU HW resource management
    
    This patch introduces the GVT-g vGPU HW resource management. Under
    GVT-g virtualizaion environment, each vGPU requires portions HW
    resources, including aperture, hidden GM space, and fence registers.
    
    When creating a vGPU, GVT-g will request these HW resources from host,
    and return them to host after a vGPU is destroyed.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
index fb619a6e519d..f42cdf74d577 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -48,10 +48,39 @@ struct intel_gvt_device_info {
 	/* This data structure will grow bigger in GVT device model patches */
 };
 
+/* GM resources owned by a vGPU */
+struct intel_vgpu_gm {
+	u64 aperture_sz;
+	u64 hidden_sz;
+	struct drm_mm_node low_gm_node;
+	struct drm_mm_node high_gm_node;
+};
+
+#define INTEL_GVT_MAX_NUM_FENCES 32
+
+/* Fences owned by a vGPU */
+struct intel_vgpu_fence {
+	struct drm_i915_fence_reg *regs[INTEL_GVT_MAX_NUM_FENCES];
+	u32 base;
+	u32 size;
+};
+
 struct intel_vgpu {
 	struct intel_gvt *gvt;
 	int id;
 	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
+
+	struct intel_vgpu_fence fence;
+	struct intel_vgpu_gm gm;
+};
+
+struct intel_gvt_gm {
+	unsigned long vgpu_allocated_low_gm_size;
+	unsigned long vgpu_allocated_high_gm_size;
+};
+
+struct intel_gvt_fence {
+	unsigned long vgpu_allocated_fence_num;
 };
 
 struct intel_gvt {
@@ -62,8 +91,68 @@ struct intel_gvt {
 	struct idr vgpu_idr;	/* vGPU IDR pool */
 
 	struct intel_gvt_device_info device_info;
+	struct intel_gvt_gm gm;
+	struct intel_gvt_fence fence;
 };
 
+/* Aperture/GM space definitions for GVT device */
+#define gvt_aperture_sz(gvt)	  (gvt->dev_priv->ggtt.mappable_end)
+#define gvt_aperture_pa_base(gvt) (gvt->dev_priv->ggtt.mappable_base)
+
+#define gvt_ggtt_gm_sz(gvt)	  (gvt->dev_priv->ggtt.base.total)
+#define gvt_hidden_sz(gvt)	  (gvt_ggtt_gm_sz(gvt) - gvt_aperture_sz(gvt))
+
+#define gvt_aperture_gmadr_base(gvt) (0)
+#define gvt_aperture_gmadr_end(gvt) (gvt_aperture_gmadr_base(gvt) \
+				     + gvt_aperture_sz(gvt) - 1)
+
+#define gvt_hidden_gmadr_base(gvt) (gvt_aperture_gmadr_base(gvt) \
+				    + gvt_aperture_sz(gvt))
+#define gvt_hidden_gmadr_end(gvt) (gvt_hidden_gmadr_base(gvt) \
+				   + gvt_hidden_sz(gvt) - 1)
+
+#define gvt_fence_sz(gvt) (gvt->dev_priv->num_fence_regs)
+
+/* Aperture/GM space definitions for vGPU */
+#define vgpu_aperture_offset(vgpu)	((vgpu)->gm.low_gm_node.start)
+#define vgpu_hidden_offset(vgpu)	((vgpu)->gm.high_gm_node.start)
+#define vgpu_aperture_sz(vgpu)		((vgpu)->gm.aperture_sz)
+#define vgpu_hidden_sz(vgpu)		((vgpu)->gm.hidden_sz)
+
+#define vgpu_aperture_pa_base(vgpu) \
+	(gvt_aperture_pa_base(vgpu->gvt) + vgpu_aperture_offset(vgpu))
+
+#define vgpu_ggtt_gm_sz(vgpu) ((vgpu)->gm.aperture_sz + (vgpu)->gm.hidden_sz)
+
+#define vgpu_aperture_pa_end(vgpu) \
+	(vgpu_aperture_pa_base(vgpu) + vgpu_aperture_sz(vgpu) - 1)
+
+#define vgpu_aperture_gmadr_base(vgpu) (vgpu_aperture_offset(vgpu))
+#define vgpu_aperture_gmadr_end(vgpu) \
+	(vgpu_aperture_gmadr_base(vgpu) + vgpu_aperture_sz(vgpu) - 1)
+
+#define vgpu_hidden_gmadr_base(vgpu) (vgpu_hidden_offset(vgpu))
+#define vgpu_hidden_gmadr_end(vgpu) \
+	(vgpu_hidden_gmadr_base(vgpu) + vgpu_hidden_sz(vgpu) - 1)
+
+#define vgpu_fence_base(vgpu) (vgpu->fence.base)
+#define vgpu_fence_sz(vgpu) (vgpu->fence.size)
+
+struct intel_vgpu_creation_params {
+	__u64 handle;
+	__u64 low_gm_sz;  /* in MB */
+	__u64 high_gm_sz; /* in MB */
+	__u64 fence_sz;
+	__s32 primary;
+	__u64 vgpu_id;
+};
+
+int intel_vgpu_alloc_resource(struct intel_vgpu *vgpu,
+			      struct intel_vgpu_creation_params *param);
+void intel_vgpu_free_resource(struct intel_vgpu *vgpu);
+void intel_vgpu_write_fence(struct intel_vgpu *vgpu,
+	u32 fence, u64 value);
+
 #include "mpt.h"
 
 #endif

commit 0ad35fed618cec78af8f40cc47702e13e5ba82b1
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Jun 16 08:07:00 2016 -0400

    drm/i915: gvt: Introduce the basic architecture of GVT-g
    
    This patch introduces the very basic framework of GVT-g device model,
    includes basic prototypes, definitions, initialization.
    
    v12:
    - Call intel_gvt_init() in driver early initialization stage. (Chris)
    
    v8:
    - Remove the GVT idr and mutex in intel_gvt_host. (Joonas)
    
    v7:
    - Refine the URL link in Kconfig. (Joonas)
    - Refine the introduction of GVT-g host support in Kconfig. (Joonas)
    - Remove the macro GVT_ALIGN(), use round_down() instead. (Joonas)
    - Make "struct intel_gvt" a data member in struct drm_i915_private.(Joonas)
            - Remove {alloc, free}_gvt_device()
            - Rename intel_gvt_{create, destroy}_gvt_device()
            - Expost intel_gvt_init_host()
    - Remove the dummy "struct intel_gvt" declaration in intel_gvt.h (Joonas)
    
    v6:
    - Refine introduction in Kconfig. (Chris)
    - The exposed API functions will take struct intel_gvt * instead of
    void *. (Chris/Tvrtko)
    - Remove most memebers of strct intel_gvt_device_info. Will add them
    in the device model patches.(Chris)
    - Remove gvt_info() and gvt_err() in debug.h. (Chris)
    - Move GVT kernel parameter into i915_params. (Chris)
    - Remove include/drm/i915_gvt.h, as GVT-g will be built within i915.
    - Remove the redundant struct i915_gvt *, as the functions in i915
    will directly take struct intel_gvt *.
    - Add more comments for reviewer.
    
    v5:
    Take Tvrtko's comments:
    - Fix the misspelled words in Kconfig
    - Let functions take drm_i915_private * instead of struct drm_device *
    - Remove redundant prints/local varible initialization
    
    v3:
    Take Joonas' comments:
    - Change file name i915_gvt.* to intel_gvt.*
    - Move GVT kernel parameter into intel_gvt.c
    - Remove redundant debug macros
    - Change error handling style
    - Add introductions for some stub functions
    - Introduce drm/i915_gvt.h.
    
    Take Kevin's comments:
    - Move GVT-g host/guest check into intel_vgt_balloon in i915_gem_gtt.c
    
    v2:
    - Introduce i915_gvt.c.
    It's necessary to introduce the stubs between i915 driver and GVT-g host,
    as GVT-g components is configurable in kernel config. When disabled, the
    stubs here do nothing.
    
    Take Joonas' comments:
    - Replace boolean return value with int.
    - Replace customized info/warn/debug macros with DRM macros.
    - Document all non-static functions like i915.
    - Remove empty and unused functions.
    - Replace magic number with marcos.
    - Set GVT-g in kernel config to "n" by default.
    
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466078825-6662-5-git-send-email-zhi.a.wang@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h
new file mode 100644
index 000000000000..fb619a6e519d
--- /dev/null
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright(c) 2011-2016 Intel Corporation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _GVT_H_
+#define _GVT_H_
+
+#include "debug.h"
+#include "hypercall.h"
+
+#define GVT_MAX_VGPU 8
+
+enum {
+	INTEL_GVT_HYPERVISOR_XEN = 0,
+	INTEL_GVT_HYPERVISOR_KVM,
+};
+
+struct intel_gvt_host {
+	bool initialized;
+	int hypervisor_type;
+	struct intel_gvt_mpt *mpt;
+};
+
+extern struct intel_gvt_host intel_gvt_host;
+
+/* Describe per-platform limitations. */
+struct intel_gvt_device_info {
+	u32 max_support_vgpus;
+	/* This data structure will grow bigger in GVT device model patches */
+};
+
+struct intel_vgpu {
+	struct intel_gvt *gvt;
+	int id;
+	unsigned long handle; /* vGPU handle used by hypervisor MPT modules */
+};
+
+struct intel_gvt {
+	struct mutex lock;
+	bool initialized;
+
+	struct drm_i915_private *dev_priv;
+	struct idr vgpu_idr;	/* vGPU IDR pool */
+
+	struct intel_gvt_device_info device_info;
+};
+
+#include "mpt.h"
+
+#endif
