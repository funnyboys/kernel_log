commit 8b46ed57f34df111c224d4319c891b43e0e03806
Merge: 79eb8c7f015a fb55c7355223
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 30 10:53:20 2020 +0300

    Merge tag 'gvt-next-2020-04-22' of https://github.com/intel/gvt-linux into drm-intel-next-queued
    
    gvt-next-2020-04-22
    
    - remove non-upstream xen support bits (Christoph)
    - guest context shadow copy optimization (Yan)
    - guest context tracking for shadow skip optimization (Yan)
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    From: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200422051230.GH11247@zhen-hp.sh.intel.com

commit 07f2fee91937283fddebd4b2f666da024738e84c
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 4 11:40:58 2020 +0200

    i915/gvt: remove unused xen bits
    
    No Xen support anywhere here.  Remove a dead declaration and an unused
    include.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200404094101.672954-4-hch@lst.de

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index a6c4fcefa83b..ed7be1b39a06 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -31,7 +31,6 @@
  */
 
 #include <linux/types.h>
-#include <xen/xen.h>
 #include <linux/kthread.h>
 
 #include "i915_drv.h"

commit 75e675f81f33fa0a1c66180c32eb05a5061ed19a
Merge: 765e7cd9a6fd a61ac1e75105
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Mar 10 15:46:28 2020 -0700

    Merge tag 'gvt-next-2020-03-10' of https://github.com/intel/gvt-linux into drm-intel-next-queued
    
    gvt-next-2020-03-10
    
    - Fix CFL dmabuf display after vfio edid enabling (Tina)
    - Clean up scan non-priv batch debugfs entry (Chris)
    - Use intel engines initialized in gvt, cleanup previous ring id (Chris)
    - Use intel_gt instead (Chris)
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    From: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200310081928.GG28483@zhen-hp.sh.intel.com

commit a61ac1e75105a077ec1efd6923ae3c619f862304
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 6 10:08:10 2020 +0800

    drm/i915/gvt: Wean gvt off using dev_priv
    
    Teach gvt to use intel_gt directly as it currently assumes direct HW
    access.
    
    [Zhenyu: rebase, fix compiling]
    
    Cc: Ding Zhuocheng <zhuocheng.ding@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200304032307.2983-3-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 0ba3a7c8522f..a6c4fcefa83b 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -49,15 +49,15 @@ static const char * const supported_hypervisors[] = {
 static struct intel_vgpu_type *intel_gvt_find_vgpu_type(struct intel_gvt *gvt,
 		const char *name)
 {
+	const char *driver_name =
+		dev_driver_string(&gvt->gt->i915->drm.pdev->dev);
 	int i;
-	struct intel_vgpu_type *t;
-	const char *driver_name = dev_driver_string(
-			&gvt->dev_priv->drm.pdev->dev);
 
+	name += strlen(driver_name) + 1;
 	for (i = 0; i < gvt->num_types; i++) {
-		t = &gvt->types[i];
-		if (!strncmp(t->name, name + strlen(driver_name) + 1,
-			sizeof(t->name)))
+		struct intel_vgpu_type *t = &gvt->types[i];
+
+		if (!strncmp(t->name, name, sizeof(t->name)))
 			return t;
 	}
 
@@ -189,7 +189,7 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 static void init_device_info(struct intel_gvt *gvt)
 {
 	struct intel_gvt_device_info *info = &gvt->device_info;
-	struct pci_dev *pdev = gvt->dev_priv->drm.pdev;
+	struct pci_dev *pdev = gvt->gt->i915->drm.pdev;
 
 	info->max_support_vgpus = 8;
 	info->cfg_space_size = PCI_CFG_SPACE_EXP_SIZE;
@@ -255,17 +255,17 @@ static int init_service_thread(struct intel_gvt *gvt)
 
 /**
  * intel_gvt_clean_device - clean a GVT device
- * @dev_priv: i915 private
+ * @i915: i915 private
  *
  * This function is called at the driver unloading stage, to free the
  * resources owned by a GVT device.
  *
  */
-void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
+void intel_gvt_clean_device(struct drm_i915_private *i915)
 {
-	struct intel_gvt *gvt = to_gvt(dev_priv);
+	struct intel_gvt *gvt = fetch_and_zero(&i915->gvt);
 
-	if (drm_WARN_ON(&dev_priv->drm, !gvt))
+	if (drm_WARN_ON(&i915->drm, !gvt))
 		return;
 
 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
@@ -283,13 +283,12 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_mmio_info(gvt);
 	idr_destroy(&gvt->vgpu_idr);
 
-	kfree(dev_priv->gvt);
-	dev_priv->gvt = NULL;
+	kfree(i915->gvt);
 }
 
 /**
  * intel_gvt_init_device - initialize a GVT device
- * @dev_priv: drm i915 private data
+ * @i915: drm i915 private data
  *
  * This function is called at the initialization stage, to initialize
  * necessary GVT components.
@@ -298,13 +297,13 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
  * Zero on success, negative error code if failed.
  *
  */
-int intel_gvt_init_device(struct drm_i915_private *dev_priv)
+int intel_gvt_init_device(struct drm_i915_private *i915)
 {
 	struct intel_gvt *gvt;
 	struct intel_vgpu *vgpu;
 	int ret;
 
-	if (drm_WARN_ON(&dev_priv->drm, dev_priv->gvt))
+	if (drm_WARN_ON(&i915->drm, i915->gvt))
 		return -EEXIST;
 
 	gvt = kzalloc(sizeof(struct intel_gvt), GFP_KERNEL);
@@ -317,8 +316,8 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	spin_lock_init(&gvt->scheduler.mmio_context_lock);
 	mutex_init(&gvt->lock);
 	mutex_init(&gvt->sched_lock);
-	gvt->dev_priv = dev_priv;
-	dev_priv->gvt = gvt;
+	gvt->gt = &i915->gt;
+	i915->gvt = gvt;
 
 	init_device_info(gvt);
 
@@ -377,7 +376,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	intel_gvt_debugfs_init(gvt);
 
 	gvt_dbg_core("gvt device initialization is done\n");
-	intel_gvt_host.dev = &dev_priv->drm.pdev->dev;
+	intel_gvt_host.dev = &i915->drm.pdev->dev;
 	intel_gvt_host.initialized = true;
 	return 0;
 
@@ -402,7 +401,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 out_clean_idr:
 	idr_destroy(&gvt->vgpu_idr);
 	kfree(gvt);
-	dev_priv->gvt = NULL;
+	i915->gvt = NULL;
 	return ret;
 }
 

commit 8fde41076f6df53db84cb13051efed6482986ce3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Mar 4 11:23:06 2020 +0800

    drm/i915/gvt: Wean gvt off dev_priv->engine[]
    
    Stop trying to escape out of the gvt layer to find the engine that we
    initially setup for use with gvt. Record the engines during initialisation
    and use them henceforth.
    
    add/remove: 1/4 grow/shrink: 22/28 up/down: 341/-1410 (-1069)
    
    [Zhenyu: rebase, fix nonpriv register check fault, fix gvt engine
    thread run failure.]
    
    Cc: Ding Zhuocheng <zhuocheng.ding@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200304032307.2983-2-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 87bed32f1191..0ba3a7c8522f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -318,6 +318,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	mutex_init(&gvt->lock);
 	mutex_init(&gvt->sched_lock);
 	gvt->dev_priv = dev_priv;
+	dev_priv->gvt = gvt;
 
 	init_device_info(gvt);
 
@@ -376,7 +377,6 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	intel_gvt_debugfs_init(gvt);
 
 	gvt_dbg_core("gvt device initialization is done\n");
-	dev_priv->gvt = gvt;
 	intel_gvt_host.dev = &dev_priv->drm.pdev->dev;
 	intel_gvt_host.initialized = true;
 	return 0;
@@ -402,6 +402,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 out_clean_idr:
 	idr_destroy(&gvt->vgpu_idr);
 	kfree(gvt);
+	dev_priv->gvt = NULL;
 	return ret;
 }
 

commit b54fc5f5b7b5bdfad261206edaaf46d585a2d88a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Mar 4 00:23:31 2020 +0000

    drm/i915/gvt: Inlcude intel_gvt.h where needed
    
    drivers/gpu/drm/i915/gvt/gvt.c:264:6: error: no previous prototype for ‘intel_gvt_clean_device’ [-Werror=missing-prototypes]
    drivers/gpu/drm/i915/gvt/gvt.c:301:5: error: no previous prototype for ‘intel_gvt_init_device’ [-Werror=missing-prototypes]
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200304002331.2126072-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 87bed32f1191..a1367bd4fe50 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -35,6 +35,7 @@
 #include <linux/kthread.h>
 
 #include "i915_drv.h"
+#include "intel_gvt.h"
 #include "gvt.h"
 #include <linux/vfio.h>
 #include <linux/mdev.h>

commit db19c724cb185a5abac81073cc5124835ed500ce
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Thu Feb 20 22:25:06 2020 +0530

    drm/i915/gvt: Make WARN* drm specific where drm_priv ptr is available
    
    drm specific WARN* calls include device information in the
    backtrace, so we know what device the warnings originate from.
    
    Covert all the calls of WARN* with device specific drm_WARN*
    variants in functions where drm_i915_private struct pointer is
    readily available.
    
    The conversion was done automatically with below coccinelle semantic
    patch. checkpatch errors/warnings are fixed manually.
    
    @rule1@
    identifier func, T;
    @@
    func(...) {
    ...
    struct drm_i915_private *T = ...;
    <+...
    (
    -WARN(
    +drm_WARN(&T->drm,
    ...)
    |
    -WARN_ON(
    +drm_WARN_ON(&T->drm,
    ...)
    |
    -WARN_ONCE(
    +drm_WARN_ONCE(&T->drm,
    ...)
    |
    -WARN_ON_ONCE(
    +drm_WARN_ON_ONCE(&T->drm,
    ...)
    )
    ...+>
    }
    
    @rule2@
    identifier func, T;
    @@
    func(struct drm_i915_private *T,...) {
    <+...
    (
    -WARN(
    +drm_WARN(&T->drm,
    ...)
    |
    -WARN_ON(
    +drm_WARN_ON(&T->drm,
    ...)
    |
    -WARN_ONCE(
    +drm_WARN_ONCE(&T->drm,
    ...)
    |
    -WARN_ON_ONCE(
    +drm_WARN_ON_ONCE(&T->drm,
    ...)
    )
    ...+>
    }
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200220165507.16823-8-pankaj.laxminarayan.bharadiya@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index cb5fa30b8e63..87bed32f1191 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -265,7 +265,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 {
 	struct intel_gvt *gvt = to_gvt(dev_priv);
 
-	if (WARN_ON(!gvt))
+	if (drm_WARN_ON(&dev_priv->drm, !gvt))
 		return;
 
 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
@@ -304,7 +304,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	struct intel_vgpu *vgpu;
 	int ret;
 
-	if (WARN_ON(dev_priv->gvt))
+	if (drm_WARN_ON(&dev_priv->drm, dev_priv->gvt))
 		return -EEXIST;
 
 	gvt = kzalloc(sizeof(struct intel_gvt), GFP_KERNEL);

commit c5bd85353c0e2dac3e30855a9e4953c0c408dfef
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Mon Dec 2 15:01:07 2019 +0800

    drm/i915/gvt: remove unused type attributes
    
    Only need to get attribute group instead of attributes and it has
    no use, so remove it.
    
    Reviewed-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20191202070109.73924-1-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 8f37eefa0a02..cb5fa30b8e63 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -120,10 +120,8 @@ static struct attribute_group *gvt_vgpu_type_groups[] = {
 	[0 ... NR_MAX_INTEL_VGPU_TYPES - 1] = NULL,
 };
 
-static bool intel_get_gvt_attrs(struct attribute ***type_attrs,
-		struct attribute_group ***intel_vgpu_type_groups)
+static bool intel_get_gvt_attrs(struct attribute_group ***intel_vgpu_type_groups)
 {
-	*type_attrs = gvt_type_attrs;
 	*intel_vgpu_type_groups = gvt_vgpu_type_groups;
 	return true;
 }

commit f8871ec8fc73f57295703a8d61c8c33d7ab4805b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:34:19 2019 +0200

    drm/i915/gvt: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Because there is no need to check these functions, a number of local
    functions can be made to return void to simplify things as nothing can
    fail.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: intel-gvt-dev@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 43f4242062dd..8f37eefa0a02 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -375,9 +375,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	}
 	gvt->idle_vgpu = vgpu;
 
-	ret = intel_gvt_debugfs_init(gvt);
-	if (ret)
-		gvt_err("debugfs registration failed, go on.\n");
+	intel_gvt_debugfs_init(gvt);
 
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;

commit 1ca20f33df42ee61a4ae1bf4f2abf8e5f77a16fc
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Wed Jan 30 18:25:53 2019 +0800

    drm/i915/gvt: add hotplug emulation
    
    Add function to emulate hotplug interrupt for SKL/KBL platforms
    
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 4e8947f33bd0..43f4242062dd 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -185,6 +185,7 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.vgpu_query_plane = intel_vgpu_query_plane,
 	.vgpu_get_dmabuf = intel_vgpu_get_dmabuf,
 	.write_protect_handler = intel_vgpu_page_track_handler,
+	.emulate_hotplug = intel_vgpu_emulate_hotplug,
 };
 
 static void init_device_info(struct intel_gvt *gvt)

commit 9bdb073464d6008ed1839d358e320108ed12daae
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:53 2018 +0800

    drm/i915/gvt: Change KVMGT as self load module
    
    This trys to make 'kvmgt' module as self loadable instead of loading
    by i915/gvt device model. So hypervisor specific module could be
    stand-alone, e.g only after loading hypervisor specific module, GVT
    feature could be enabled via specific hypervisor interface, e.g VFIO/mdev.
    
    So this trys to use hypervisor module register/unregister interface
    for that. Hypervisor module needs to take care of module reference
    itself when working for hypervisor interface, e.g for VFIO/mdev,
    hypervisor module would reference counting mdev when open and release.
    
    This makes 'kvmgt' module really split from GVT device model. User
    needs to load 'kvmgt' to enable VFIO/mdev interface.
    
    v6:
    - remove unused variable
    
    v5:
    - put module reference in register error path
    
    v4:
    - fix checkpatch warning
    
    v3:
    - Fix module reference handling for device open and release. Unused
      mdev devices would be cleaned up in device unregister when module unload.
    
    v2:
    - Fix kvmgt order after i915 for built-in case
    
    Cc: "Yuan, Hang" <hang.yuan@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: "He, Min" <min.he@intel.com>
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index a5b760b7bc10..4e8947f33bd0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -187,52 +187,6 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.write_protect_handler = intel_vgpu_page_track_handler,
 };
 
-/**
- * intel_gvt_init_host - Load MPT modules and detect if we're running in host
- *
- * This function is called at the driver loading stage. If failed to find a
- * loadable MPT module or detect currently we're running in a VM, then GVT-g
- * will be disabled
- *
- * Returns:
- * Zero on success, negative error code if failed.
- *
- */
-int intel_gvt_init_host(void)
-{
-	if (intel_gvt_host.initialized)
-		return 0;
-
-	/* Xen DOM U */
-	if (xen_domain() && !xen_initial_domain())
-		return -ENODEV;
-
-	/* Try to load MPT modules for hypervisors */
-	if (xen_initial_domain()) {
-		/* In Xen dom0 */
-		intel_gvt_host.mpt = try_then_request_module(
-				symbol_get(xengt_mpt), "xengt");
-		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_XEN;
-	} else {
-#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
-		/* not in Xen. Try KVMGT */
-		intel_gvt_host.mpt = try_then_request_module(
-				symbol_get(kvmgt_mpt), "kvmgt");
-		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_KVM;
-#endif
-	}
-
-	/* Fail to load MPT modules - bail out */
-	if (!intel_gvt_host.mpt)
-		return -EINVAL;
-
-	gvt_dbg_core("Running with hypervisor %s in host mode\n",
-			supported_hypervisors[intel_gvt_host.hypervisor_type]);
-
-	intel_gvt_host.initialized = true;
-	return 0;
-}
-
 static void init_device_info(struct intel_gvt *gvt)
 {
 	struct intel_gvt_device_info *info = &gvt->device_info;
@@ -316,7 +270,6 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
-	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev);
 	intel_gvt_cleanup_vgpu_type_groups(gvt);
 	intel_gvt_clean_vgpu_types(gvt);
 
@@ -352,13 +305,6 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	struct intel_vgpu *vgpu;
 	int ret;
 
-	/*
-	 * Cannot initialize GVT device without intel_gvt_host gets
-	 * initialized first.
-	 */
-	if (WARN_ON(!intel_gvt_host.initialized))
-		return -EINVAL;
-
 	if (WARN_ON(dev_priv->gvt))
 		return -EEXIST;
 
@@ -420,13 +366,6 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 		goto out_clean_types;
 	}
 
-	ret = intel_gvt_hypervisor_host_init(&dev_priv->drm.pdev->dev, gvt,
-				&intel_gvt_ops);
-	if (ret) {
-		gvt_err("failed to register gvt-g host device: %d\n", ret);
-		goto out_clean_types;
-	}
-
 	vgpu = intel_gvt_create_idle_vgpu(gvt);
 	if (IS_ERR(vgpu)) {
 		ret = PTR_ERR(vgpu);
@@ -441,6 +380,8 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;
+	intel_gvt_host.dev = &dev_priv->drm.pdev->dev;
+	intel_gvt_host.initialized = true;
 	return 0;
 
 out_clean_types:
@@ -467,6 +408,45 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
-MODULE_SOFTDEP("pre: kvmgt");
-#endif
+int
+intel_gvt_register_hypervisor(struct intel_gvt_mpt *m)
+{
+	int ret;
+	void *gvt;
+
+	if (!intel_gvt_host.initialized)
+		return -ENODEV;
+
+	if (m->type != INTEL_GVT_HYPERVISOR_KVM &&
+	    m->type != INTEL_GVT_HYPERVISOR_XEN)
+		return -EINVAL;
+
+	/* Get a reference for device model module */
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
+
+	intel_gvt_host.mpt = m;
+	intel_gvt_host.hypervisor_type = m->type;
+	gvt = (void *)kdev_to_i915(intel_gvt_host.dev)->gvt;
+
+	ret = intel_gvt_hypervisor_host_init(intel_gvt_host.dev, gvt,
+					     &intel_gvt_ops);
+	if (ret < 0) {
+		gvt_err("Failed to init %s hypervisor module\n",
+			supported_hypervisors[intel_gvt_host.hypervisor_type]);
+		module_put(THIS_MODULE);
+		return -ENODEV;
+	}
+	gvt_dbg_core("Running with hypervisor %s in host mode\n",
+		     supported_hypervisors[intel_gvt_host.hypervisor_type]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_gvt_register_hypervisor);
+
+void
+intel_gvt_unregister_hypervisor(void)
+{
+	intel_gvt_hypervisor_host_exit(intel_gvt_host.dev);
+	module_put(THIS_MODULE);
+}
+EXPORT_SYMBOL_GPL(intel_gvt_unregister_hypervisor);

commit a2b8419a9e2975d19c0cd85f4912f2873bd974e0
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:52 2018 +0800

    drm/i915/gvt: remove unused parameter for hypervisor's host_exit call
    
    The parameter 'void *gvt' is not used and required for hypervisor's
    exit call. Even for non-merged Xen hypervisor support. So just remove it.
    
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 733a2a0d0c30..a5b760b7bc10 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -316,7 +316,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
-	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
+	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev);
 	intel_gvt_cleanup_vgpu_type_groups(gvt);
 	intel_gvt_clean_vgpu_types(gvt);
 

commit 77453c9f2b67956911d0074e07e30a5e59e51a6e
Author: Peng Hao <peng.hao2@zte.com.cn>
Date:   Thu Oct 4 12:04:34 2018 -0400

    drm/i915/gvt: fix a typo: "registeration" -> "registration".
    
    Fix a typo in the error message reporting.
    
    Signed-off-by: Peng Hao <peng.hao2@zte.com.cn>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 6ef5a7fc70df..733a2a0d0c30 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -437,7 +437,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 
 	ret = intel_gvt_debugfs_init(gvt);
 	if (ret)
-		gvt_err("debugfs registeration failed, go on.\n");
+		gvt_err("debugfs registration failed, go on.\n");
 
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;

commit b1c1566822ab489a945dfdafee651aa29de160c7
Merge: 1f3eb3461f58 a28957b8f10b
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Sep 11 11:52:54 2018 +1000

    Merge tag 'drm-intel-next-2018-09-06-2' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Merge tag 'gvt-next-2018-09-04'
    drm-intel-next-2018-09-06-1:
    UAPI Changes:
    - GGTT coherency GETPARAM: GGTT has turned out to be non-coherent for some
      platforms, which we've failed to communicate to userspace so far. SNA was
      modified to do extra flushing on non-coherent GGTT access, while Mesa will
      mitigate by always requiring WC mapping (which is non-coherent anyway).
    - Neuter Resource Streamer uAPI: There never really were users for the feature,
      so neuter it while keeping the interface bits for compatibility. This is a
      long due item from past.
    
    Cross-subsystem Changes:
    - Backmerge of branch drm-next-4.19 for DP_DPCD_REV_14 changes
    
    Core Changes:
    - None
    
    Driver Changes:
    
    - A load of Icelake (ICL) enabling patches (Paulo, Manasi)
    - Enabled full PPGTT for IVB,VLV and HSW (Chris)
    - Bugzilla #107113: Distribute DDB based on display resolutions (Mahesh)
    - Bugzillas #100023,#107476,#94921: Support limited range DP displays (Jani)
    - Bugzilla #107503: Increase LSPCON timeout (Fredrik)
    - Avoid boosting GPU due to an occasional stall in interactive workloads (Chris)
    - Apply GGTT coherency W/A only for affected systems instead of all (Chris)
    - Fix for infinite link training loop for faulty USB-C MST hubs (Nathan)
    - Keep KMS functional on Gen4 and earlier when GPU is wedged (Chris)
    - Stop holding ppGTT reference from closed VMAs (Chris)
    - Clear error registers after error capture (Lionel)
    - Various Icelake fixes (Anusha, Jyoti, Ville, Tvrtko)
    - Add missing Coffeelake (CFL) PCI IDs (Rodrigo)
    - Flush execlists tasklet directly from reset-finish (Chris)
    - Fix LPE audio runtime PM (Chris)
    - Fix detection of out of range surface positions (GLK/CNL) (Ville)
    - Remove wait-for-idle for PSR2 (Dhinakaran)
    - Power down existing display hardware resources when display is disabled (Chris)
    - Don't allow runtime power management if RC6 doesn't exist (Chris)
    - Add debugging checks for runtime power management paths (Imre)
    - Increase symmetry in display power init/fini paths (Imre)
    - Isolate GVT specific macros from i915_reg.h (Lucas)
    - Increase symmetry in power management enable/disable paths (Chris)
    - Increase IP disable timeout to 100 ms to avoid DRM_ERROR (Imre)
    - Fix memory leak from HDMI HDCP write function (Brian, Rodrigo)
    - Reject Y/Yf tiling on interlaced modes (Ville)
    - Use a cached mapping for the physical HWS on older gens (Chris)
    - Force slow path of writing relocations to buffer if unable to write to userspace (Chris)
    - Do a full device reset after being wedged (Chris)
    - Keep forcewake counts over reset (in case of debugfs user) (Imre, Chris)
    - Avoid false-positive errors from power wells during init (Imre)
    - Reset engines forcibly in exchange of declaring whole device wedged (Mika)
    - Reduce context HW ID lifetime in preparation for Icelake (Chris)
    - Attempt to recover from module load failures (Chris)
    - Keep select interrupts over a reset to avoid missing/losing them (Chris)
    - GuC submission backend improvements (Jakub)
    - Terminate context images with BB_END (Chris, Lionel)
    - Make GCC evaluate GGTT view struct size assertions again (Ville)
    - Add selftest to exercise suspend/hibernate code-paths for GEM (Chris)
    - Use a full emulation of a user ppgtt context in selftests (Chris)
    - Exercise resetting in the middle of a wait-on-fence in selftests (Chris)
    - Fix coherency issues on selftests for Baytrail (Chris)
    - Various other GEM fixes / self-test updates (Chris, Matt)
    - GuC doorbell self-tests (Daniele)
    - PSR mode control through debugfs for IGTs (Maarten)
    - Degrade expected WM latency errors to DRM_DEBUG_KMS (Chris)
    - Cope with errors better in MST link training (Dhinakaran)
    - Fix WARN on KBL external displays (Azhar)
    - Power well code cleanups (Imre)
    - Fixes to PSR debugging (Dhinakaran)
    - Make forcewake errors louder for easier catching in CI (WARNs) (Chris)
    - Fortify tiling code against programmer errors (Chris)
    - Bunch of fixes for CI exposed corner cases (multiple authors, mostly Chris)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180907105446.GA22860@jlahtine-desk.ger.corp.intel.com

commit 3fd34ac02ae8cc20d78e3aed2cf6e67f0ae109ea
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Mon Jul 23 20:15:46 2018 +0800

    drm/i915/gvt: fix cleanup sequence in intel_gvt_clean_device
    
    Create one vGPU and then unbind IGD device from i915 driver. The following
    oops will happen. This patch will free vgpu resource first and then gvt
    resource to remove these oops.
    
    BUG: unable to handle kernel NULL pointer dereference at       00000000000000a8
      PGD 80000003c9d2c067 P4D 80000003c9d2c067 PUD 3c817c067 P      MD 0
      Oops: 0002 [#1] SMP PTI
      RIP: 0010:down_write+0x1b/0x40
    Call Trace:
      debugfs_remove_recursive+0x46/0x1a0
      intel_gvt_debugfs_remove_vgpu+0x15/0x30 [i915]
      intel_gvt_destroy_vgpu+0x2d/0xf0 [i915]
      intel_vgpu_remove+0x2c/0x30 [kvmgt]
      mdev_device_remove_ops+0x23/0x50 [mdev]
      mdev_device_remove+0xdb/0x190 [mdev]
      mdev_device_remove+0x190/0x190 [mdev]
      device_for_each_child+0x47/0x90
      mdev_unregister_device+0xd5/0x120 [mdev]
      intel_gvt_clean_device+0x91/0x120 [i915]
      i915_driver_unload+0x9d/0x120 [i915]
      i915_pci_remove+0x15/0x20 [i915]
      pci_device_remove+0x3b/0xc0
      device_release_driver_internal+0x157/0x230
      unbind_store+0xfc/0x150
      kernfs_fop_write+0x10f/0x180
      __vfs_write+0x36/0x180
      ? common_file_perm+0x41/0x130
      ? _cond_resched+0x16/0x40
      vfs_write+0xb3/0x1a0
      ksys_write+0x52/0xc0
      do_syscall_64+0x55/0x100
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    BUG: unable to handle kernel NULL pointer dereference at 0      000000000000038
      PGD 8000000405bce067 P4D 8000000405bce067 PUD 405bcd067 PM      D 0
      Oops: 0000 [#1] SMP PTI
      RIP: 0010:hrtimer_active+0x5/0x40
    Call Trace:
      hrtimer_try_to_cancel+0x25/0x120
      ? tbs_sched_clean_vgpu+0x1f/0x50 [i915]
      hrtimer_cancel+0x15/0x20
      intel_gvt_destroy_vgpu+0x4c/0xf0 [i915]
      intel_vgpu_remove+0x2c/0x30 [kvmgt]
      mdev_device_remove_ops+0x23/0x50 [mdev]
      mdev_device_remove+0xdb/0x190 [mdev]
      ? mdev_device_remove+0x190/0x190 [mdev]
      device_for_each_child+0x47/0x90
      mdev_unregister_device+0xd5/0x120 [mdev]
      intel_gvt_clean_device+0x89/0x120 [i915]
      i915_driver_unload+0x9d/0x120 [i915]
      i915_pci_remove+0x15/0x20 [i915]
      pci_device_remove+0x3b/0xc0
      device_release_driver_internal+0x157/0x230
      unbind_store+0xfc/0x150
      kernfs_fop_write+0x10f/0x180
      __vfs_write+0x36/0x180
      ? common_file_perm+0x41/0x130
      ? _cond_resched+0x16/0x40
      vfs_write+0xb3/0x1a0
      ksys_write+0x52/0xc0
      do_syscall_64+0x55/0x100
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fixes: bc7b0be316ae("drm/i915/gvt: Add basic debugfs infrastructure")
    Fixes: afe04fbe6c52("drm/i915/gvt: create an idle vGPU")
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 195a3b24e624..46c8b720e336 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -316,6 +316,11 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt))
 		return;
 
+	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
+	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
+	intel_gvt_cleanup_vgpu_type_groups(gvt);
+	intel_gvt_clean_vgpu_types(gvt);
+
 	intel_gvt_debugfs_clean(gvt);
 	clean_service_thread(gvt);
 	intel_gvt_clean_cmd_parser(gvt);
@@ -323,17 +328,10 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_workload_scheduler(gvt);
 	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
-	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
-
-	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
-	intel_gvt_cleanup_vgpu_type_groups(gvt);
-	intel_gvt_clean_vgpu_types(gvt);
-
+	intel_gvt_clean_mmio_info(gvt);
 	idr_destroy(&gvt->vgpu_idr);
 
-	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
-
 	kfree(dev_priv->gvt);
 	dev_priv->gvt = NULL;
 }

commit f9090d4c22130c861b9e00e063812ac69d93a4a2
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Tue Aug 7 18:29:21 2018 +0800

    drm/i915/gvt: free workload in vgpu release
    
    Some workloads may be prepared in vgpu's queue but not be scheduled
    to run yet. If vgpu is released at this time, they will not be freed
    in workload complete callback and so need to be freed in vgpu release
    operation.
    
    Add new vgpu_release operation in gvt_ops to stop vgpu and release
    runtime resources. gvt_ops vgpu_deactivate operation will only stop
    vgpu.
    
    v2: add new gvt ops to clean vgpu running status (Xiong Zhang)
    
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Reviewed-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 712f9d14e720..195a3b24e624 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -176,6 +176,7 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.emulate_mmio_write = intel_vgpu_emulate_mmio_write,
 	.vgpu_create = intel_gvt_create_vgpu,
 	.vgpu_destroy = intel_gvt_destroy_vgpu,
+	.vgpu_release = intel_gvt_release_vgpu,
 	.vgpu_reset = intel_gvt_reset_vgpu,
 	.vgpu_activate = intel_gvt_activate_vgpu,
 	.vgpu_deactivate = intel_gvt_deactivate_vgpu,

commit a752b070a67823174565322cc48b2668daf9a8da
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Jul 31 11:02:12 2018 +0800

    drm/i915/gvt: Fix function comment doc errors
    
    Caught by W=1 to fix left wrong function comment doc.
    
    Reviewed-by: Hang Yuan <hang.yuan@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 712f9d14e720..e14416d97e73 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -188,7 +188,6 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 
 /**
  * intel_gvt_init_host - Load MPT modules and detect if we're running in host
- * @gvt: intel gvt device
  *
  * This function is called at the driver loading stage. If failed to find a
  * loadable MPT module or detect currently we're running in a VM, then GVT-g
@@ -302,7 +301,7 @@ static int init_service_thread(struct intel_gvt *gvt)
 
 /**
  * intel_gvt_clean_device - clean a GVT device
- * @gvt: intel gvt device
+ * @dev_priv: i915 private
  *
  * This function is called at the driver unloading stage, to free the
  * resources owned by a GVT device.

commit 279ce5d117078ee8ea40c40199399889981fd808
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Mon Jul 9 18:24:10 2018 +0800

    drm/i915/gvt: declare gvt as i915's soft dependency
    
    This helps initramfs builder and other tools to know the full dependencies
    of i915 and have gvt module loaded with i915.
    
    v2: add condition and change to pre-dependency (Chris)
    v3: move declaration to gvt.c. (Chris)
    v4: remove xengt (Zhenyu)
    
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 4e65266e7b95..712f9d14e720 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -468,3 +468,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	kfree(gvt);
 	return ret;
 }
+
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
+MODULE_SOFTDEP("pre: kvmgt");
+#endif

commit 6fa6616b8f7adaf8380d72e53733bc2472b0d157
Author: Colin Xu <colin.xu@intel.com>
Date:   Mon Jun 11 15:39:31 2018 +0800

    drm/i915/gvt: Enable device info initialization for BXT.
    
    Initialize BXT device info as SKL/KBL.
    
    v2: All supported platforms share the same device configuration.
        Remove the platform check by now and let is_supported_device()
        be the gate keeper.
    
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 22a3ddff38a3..4e65266e7b95 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -238,18 +238,15 @@ static void init_device_info(struct intel_gvt *gvt)
 	struct intel_gvt_device_info *info = &gvt->device_info;
 	struct pci_dev *pdev = gvt->dev_priv->drm.pdev;
 
-	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)
-		|| IS_KABYLAKE(gvt->dev_priv)) {
-		info->max_support_vgpus = 8;
-		info->cfg_space_size = PCI_CFG_SPACE_EXP_SIZE;
-		info->mmio_size = 2 * 1024 * 1024;
-		info->mmio_bar = 0;
-		info->gtt_start_offset = 8 * 1024 * 1024;
-		info->gtt_entry_size = 8;
-		info->gtt_entry_size_shift = 3;
-		info->gmadr_bytes_in_cmd = 8;
-		info->max_surface_size = 36 * 1024 * 1024;
-	}
+	info->max_support_vgpus = 8;
+	info->cfg_space_size = PCI_CFG_SPACE_EXP_SIZE;
+	info->mmio_size = 2 * 1024 * 1024;
+	info->mmio_bar = 0;
+	info->gtt_start_offset = 8 * 1024 * 1024;
+	info->gtt_entry_size = 8;
+	info->gtt_entry_size_shift = 3;
+	info->gmadr_bytes_in_cmd = 8;
+	info->max_surface_size = 36 * 1024 * 1024;
 	info->msi_cap_offset = pdev->msi_cap;
 }
 

commit 9a512e23f173a3598709b74d6ccf9a6616403967
Author: Colin Xu <colin.xu@intel.com>
Date:   Sat May 19 12:28:55 2018 +0800

    drm/i915/gvt: Use sched_lock to protect gvt scheduler logic.
    
    The scheduler lock(gvt->sched_lock) is used to protect gvt
    scheduler logic, including the gvt scheduler structure(gvt->scheduler
    and per vgpu schedule data(vgpu->sched_data, vgpu->sched_ctl).
    
    v9:
      - Change commit author since the patches are improved a lot compared
        with original version.
        Original author: Pei Zhang <pei.zhang@intel.com>
      - Rebase to latest gvt-staging.
    v8:
      - Correct coding wqstyle.
      - Rebase to latest gvt-staging.
    v7:
      - Remove gtt_lock since already proteced by gvt_lock and vgpu_lock.
    v6:
      - Rebase to latest gvt-staging.
    v5:
      - Rebase to latest gvt-staging.
    v4:
      - Rebase to latest gvt-staging.
    v3: update to latest code base
    
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 769e06c3ae23..22a3ddff38a3 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -376,6 +376,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	idr_init(&gvt->vgpu_idr);
 	spin_lock_init(&gvt->scheduler.mmio_context_lock);
 	mutex_init(&gvt->lock);
+	mutex_init(&gvt->sched_lock);
 	gvt->dev_priv = dev_priv;
 
 	init_device_info(gvt);

commit f25a49ab8ab9c1b5587837c8a386b276403f315c
Author: Colin Xu <colin.xu@intel.com>
Date:   Sat May 19 12:28:54 2018 +0800

    drm/i915/gvt: Use vgpu_lock to protect per vgpu access
    
    The patch set splits out 2 small locks from the original big gvt lock:
      - vgpu_lock protects per-vGPU data and logic, especially the vGPU
        trap emulation path.
      - sched_lock protects gvt scheudler structure, context schedule logic
        and vGPU's schedule data.
    
    Use vgpu_lock to replace the gvt big lock. By doing this, the
    mmio read/write trap path, vgpu virtual event emulation and other
    vgpu related process, would be protected under per vgpu_lock.
    
    v9:
      - Change commit author since the patches are improved a lot compared
        with original version.
        Original author: Pei Zhang <pei.zhang@intel.com>
      - Rebase to latest gvt-staging.
    v8:
      - Correct coding and comment style.
      - Rebase to latest gvt-staging.
    v7:
      - Remove gtt_lock since already proteced by gvt_lock and vgpu_lock.
      - Fix a typo in intel_gvt_deactivate_vgpu, unlock the wrong lock.
    v6:
      - Rebase to latest gvt-staging.
    v5:
      - Rebase to latest gvt-staging.
      - intel_vgpu_page_track_handler should use vgpu_lock.
    v4:
      - Rebase to latest gvt-staging.
      - Protect vgpu->active access with vgpu_lock.
      - Do not wait gpu idle in vgpu_lock.
    v3: update to latest code base
    v2: add gvt->lock in function gvt_check_vblank_emulation
    
    Performance comparison on Kabylake platform.
      - Configuration:
        Host: Ubuntu 16.04.
        Guest 1 & 2: Ubuntu 16.04.
    
    glmark2 score comparison:
      - Configuration:
        Host: glxgears.
        Guests: glmark2.
    +--------------------------------+-----------------+
    | Setup                          | glmark2 score   |
    +--------------------------------+-----------------+
    | unified lock, iommu=on         | 58~62 (avg. 60) |
    +--------------------------------+-----------------+
    | unified lock, iommu=igfx_off   | 57~61 (avg. 59) |
    +--------------------------------+-----------------+
    | per-logic lock, iommu=on       | 60~68 (avg. 64) |
    +--------------------------------+-----------------+
    | per-logic lock, iommu=igfx_off | 61~67 (avg. 64) |
    +--------------------------------+-----------------+
    
    lock_stat comparison:
      - Configuration:
        Stop lock stat immediately after boot up.
        Boot 2 VM Guests.
        Run glmark2 in guests.
        Start perf lock_stat for 20 seconds and stop again.
      - Legend: c - contentions; w - waittime-avg
    +------------+-----------------+-----------+---------------+------------+
    |            | gvt_lock        |sched_lock | vgpu_lock     | gtt_lock   |
    + lock type; +-----------------+-----------+---------------+------------+
    | iommu set  | c     | w       | c  | w    | c    | w      | c   | w    |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | unified;   | 20697 | 839     |N/A | N/A  | N/A  | N/A    | N/A | N/A  |
    | on         |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | unified;   | 21838 | 658.15  |N/A | N/A  | N/A  | N/A    | N/A | N/A  |
    | igfx_off   |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | per-logic; | 1553  | 1599.96 |9458|429.97| 5846 | 274.33 | 0   | 0.00 |
    | on         |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    | per-logic; | 1911  | 1678.32 |8335|445.16| 5451 | 244.80 | 0   | 0.00 |
    | igfx_off   |       |         |    |      |      |        |     |      |
    +------------+-------+---------+----+------+------+--------+-----+------+
    
    Signed-off-by: Pei Zhang <pei.zhang@intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 61bd14fcb649..769e06c3ae23 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -271,11 +271,8 @@ static int gvt_service_thread(void *data)
 			continue;
 
 		if (test_and_clear_bit(INTEL_GVT_REQUEST_EMULATE_VBLANK,
-					(void *)&gvt->service_request)) {
-			mutex_lock(&gvt->lock);
+					(void *)&gvt->service_request))
 			intel_gvt_emulate_vblank(gvt);
-			mutex_unlock(&gvt->lock);
-		}
 
 		if (test_bit(INTEL_GVT_REQUEST_SCHED,
 				(void *)&gvt->service_request) ||

commit e502a2af4c358d14ecf8fce51bf4988ebb4d10b4
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jan 30 19:19:53 2018 +0800

    drm/i915/gvt: Provide generic page_track infrastructure for write-protected page
    
    This patch provide generic page_track infrastructure for write-protected
    guest page. The old page_track logic gets rewrote and now stays in a new
    standalone page_track.c. This page track infrastructure can be both used
    by vGUC and GTT shadowing.
    
    The important change is that it uses radix tree instead of hash table.
    We don't have a predictable number of pages that will be tracked.
    
    Here is some performance data (duration in us) of looking up a element:
    Before: (aka. intel_vgpu_find_tracked_page)
     0.091 0.089 0.090 ... 0.093 0.091 0.087 ... 0.292 0.285 0.292 0.291
    After: (aka. intel_vgpu_find_page_track)
     0.104 0.105 0.100 0.102 0.102 0.100 ... 0.101 0.101 0.105 0.105
    
    The hash table has good performance at beginning, but turns bad with
    more pages being tracked even no 3D applications are running. As
    expected, radix tree has stable duration and very quick.
    
    The overall benchmark (tested with Heaven Benchmark) marginally improved
    since this is not the bottleneck. What we benefit more from this change
    is scalability.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index fac54f32d33f..61bd14fcb649 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -183,7 +183,7 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.get_gvt_attrs = intel_get_gvt_attrs,
 	.vgpu_query_plane = intel_vgpu_query_plane,
 	.vgpu_get_dmabuf = intel_vgpu_get_dmabuf,
-	.write_protect_handler = intel_vgpu_write_protect_handler,
+	.write_protect_handler = intel_vgpu_page_track_handler,
 };
 
 /**

commit 4fafba2d73fcaf1b433c26e753a98ad4b231754a
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Mon Dec 18 11:58:46 2017 +0800

    drm/i915/gvt: move write protect handler out of mmio emulation function
    
    It's a bit confusing that page write protect handler is live in
    mmio emulation handler. This moves it to stand alone gvt ops.
    
    Also remove unnecessary check of write protected page access
    in mmio read handler and cleanup handling of failsafe case.
    
    v2: rebase
    
    Reviewed-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 643bb961d40d..fac54f32d33f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -183,6 +183,7 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.get_gvt_attrs = intel_get_gvt_attrs,
 	.vgpu_query_plane = intel_vgpu_query_plane,
 	.vgpu_get_dmabuf = intel_vgpu_get_dmabuf,
+	.write_protect_handler = intel_vgpu_write_protect_handler,
 };
 
 /**

commit 83164886e4559f87015a33780852a64cdd6e4e50
Author: Changbin Du <changbin.du@intel.com>
Date:   Fri Dec 8 14:56:21 2017 +0800

    drm/i915/gvt: Select appropriate mmio list at initialization time
    
    Select appropriate mmio list at initialization time, so we don't need to
    do duplicated work at where requires the mmio list.
    
    V2:
      - Add a termination mark of mmio list.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 9a5dce3aa10a..643bb961d40d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -386,6 +386,8 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_idr;
 
+	intel_gvt_init_engine_mmio_context(gvt);
+
 	ret = intel_gvt_load_firmware(gvt);
 	if (ret)
 		goto out_clean_mmio_info;

commit e546e281d33d1fc275651aa06f0659045db67e68
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Thu Nov 23 16:26:36 2017 +0800

    drm/i915/gvt: Dmabuf support for GVT-g
    
    This patch introduces a guest's framebuffer sharing mechanism based on
    dma-buf subsystem. With this sharing mechanism, guest's framebuffer can
    be shared between guest VM and host.
    
    v17:
    - modify VFIO_DEVICE_GET_GFX_DMABUF interface. (Alex)
    
    v16:
    - add x_hot and y_hot. (Gerd)
    - add flag validation for VFIO_DEVICE_GET_GFX_DMABUF. (Alex)
    - rebase 4.14.0-rc6.
    
    v15:
    - add VFIO_DEVICE_GET_GFX_DMABUF ABI. (Gerd)
    - add intel_vgpu_dmabuf_cleanup() to clean up the vGPU's dmabuf. (Gerd)
    
    v14:
    - add PROBE, DMABUF and REGION flags. (Alex)
    
    v12:
    - refine the lifecycle of dmabuf.
    
    v9:
    - remove dma-buf management. (Alex)
    - track the dma-buf create and release in kernel mode. (Gerd) (Daniel)
    
    v8:
    - refine the dma-buf ioctl definition.(Alex)
    - add a lock to protect the dmabuf list. (Alex)
    
    v7:
    - release dma-buf related allocations in dma-buf's associated release
      function. (Alex)
    - refine ioctl interface for querying plane info or create dma-buf.
      (Alex)
    
    v6:
    - align the dma-buf life cycle with the vfio device. (Alex)
    - add the dma-buf related operations in a separate patch. (Gerd)
    - i915 related changes. (Chris)
    
    v5:
    - fix bug while checking whether the gem obj is gvt's dma-buf when user
      change caching mode or domains. Add a helper function to do it.
      (Xiaoguang)
    - add definition for the query plane and create dma-buf. (Xiaoguang)
    
    v4:
    - fix bug while checking whether the gem obj is gvt's dma-buf when set
      caching mode or doamins. (Xiaoguang)
    
    v3:
    - declare a new flag I915_GEM_OBJECT_IS_GVT_DMABUF in drm_i915_gem_object
      to represent the gem obj for gvt's dma-buf. The tiling mode, caching
      mode and domains can not be changed for this kind of gem object. (Alex)
    - change dma-buf related information to be more generic. So other vendor
      can use the same interface. (Alex)
    
    v2:
    - create a management fd for dma-buf operations. (Alex)
    - alloc gem object's backing storage in gem obj's get_pages() callback.
      (Chris)
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 3a74a408a966..9a5dce3aa10a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -181,6 +181,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
 	.gvt_find_vgpu_type = intel_gvt_find_vgpu_type,
 	.get_gvt_attrs = intel_get_gvt_attrs,
+	.vgpu_query_plane = intel_vgpu_query_plane,
+	.vgpu_get_dmabuf = intel_vgpu_get_dmabuf,
 };
 
 /**

commit b2d6ef70614e9e9dacfa9fc7dac49e7dc22dc8b3
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Wed Nov 8 00:45:21 2017 +0800

    drm/i915/gvt: Let each vgpu has separate opregion memory
    
    Currently every vgpu share a common gvt opregion memory, but
    it is freed at vgpu destroy, then the later vgpu doesn't have
    opregion memory once the first vgpu is destroyed. This cause
    guest function failure like reboot, second or later boot.
    
    This patch allocate and init virt opregion memory for each
    vgpu, so this memory could be freed at vgpu destroy.
    
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index cef06d59884e..3a74a408a966 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -323,7 +323,6 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_cmd_parser(gvt);
 	intel_gvt_clean_sched_policy(gvt);
 	intel_gvt_clean_workload_scheduler(gvt);
-	intel_gvt_clean_opregion(gvt);
 	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
 	intel_gvt_clean_mmio_info(gvt);
@@ -397,13 +396,9 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_irq;
 
-	ret = intel_gvt_init_opregion(gvt);
-	if (ret)
-		goto out_clean_gtt;
-
 	ret = intel_gvt_init_workload_scheduler(gvt);
 	if (ret)
-		goto out_clean_opregion;
+		goto out_clean_gtt;
 
 	ret = intel_gvt_init_sched_policy(gvt);
 	if (ret)
@@ -460,8 +455,6 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_sched_policy(gvt);
 out_clean_workload_scheduler:
 	intel_gvt_clean_workload_scheduler(gvt);
-out_clean_opregion:
-	intel_gvt_clean_opregion(gvt);
 out_clean_gtt:
 	intel_gvt_clean_gtt(gvt);
 out_clean_irq:

commit bc7b0be316aebac42eb9e8e54c984609555944da
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Sep 26 16:19:13 2017 +0800

    drm/i915/gvt: Add basic debugfs infrastructure
    
    We need debugfs entry to expose some debug information of gvt and vGPUs.
    The first tool will be added is mmio-diff, which help to find the
    difference values of host and vGPU mmio. It's useful for platform
    enabling.
    
    This patch just add a basic debugfs infrastructure, each vGPU has its own
    sub-folder. Two simple attributes are created as a template.
    .
    ├── num_tracked_mmio
    ├── vgpu1
    |   └── active
    └── vgpu2
        └── active
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index ed313811fa76..cef06d59884e 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -318,6 +318,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt))
 		return;
 
+	intel_gvt_debugfs_clean(gvt);
 	clean_service_thread(gvt);
 	intel_gvt_clean_cmd_parser(gvt);
 	intel_gvt_clean_sched_policy(gvt);
@@ -441,6 +442,10 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	}
 	gvt->idle_vgpu = vgpu;
 
+	ret = intel_gvt_debugfs_init(gvt);
+	if (ret)
+		gvt_err("debugfs registeration failed, go on.\n");
+
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;
 	return 0;

commit c5d71cb31723135dbaa54b32bf046342fe538210
Author: fred gao <fred.gao@intel.com>
Date:   Thu Sep 28 11:03:02 2017 +0800

    drm/i915/gvt: Move vGPU type related code into gvt file
    
    In this patch, all the vGPU type related code will be merged into
    same gvt file and the common interface will be exposed to both
    XenGT and KvmGT.
    
    v2:
    - remove the useless mdev_* gvt_ops.
      add get_gvt_attr ops for MPT module.
      intel_gvt_{init,cleanup}_vgpu_type_groups are initialized in
      gvt part. (Wang, Zhi)
    - set gvt_vgpu_type_groups[i] to NULL. (Zhang,Xiong)
    
    Signed-off-by: fred gao <fred.gao@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index aaa347f8620c..ed313811fa76 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -36,6 +36,8 @@
 
 #include "i915_drv.h"
 #include "gvt.h"
+#include <linux/vfio.h>
+#include <linux/mdev.h>
 
 struct intel_gvt_host intel_gvt_host;
 
@@ -44,6 +46,129 @@ static const char * const supported_hypervisors[] = {
 	[INTEL_GVT_HYPERVISOR_KVM] = "KVM",
 };
 
+static struct intel_vgpu_type *intel_gvt_find_vgpu_type(struct intel_gvt *gvt,
+		const char *name)
+{
+	int i;
+	struct intel_vgpu_type *t;
+	const char *driver_name = dev_driver_string(
+			&gvt->dev_priv->drm.pdev->dev);
+
+	for (i = 0; i < gvt->num_types; i++) {
+		t = &gvt->types[i];
+		if (!strncmp(t->name, name + strlen(driver_name) + 1,
+			sizeof(t->name)))
+			return t;
+	}
+
+	return NULL;
+}
+
+static ssize_t available_instances_show(struct kobject *kobj,
+					struct device *dev, char *buf)
+{
+	struct intel_vgpu_type *type;
+	unsigned int num = 0;
+	void *gvt = kdev_to_i915(dev)->gvt;
+
+	type = intel_gvt_find_vgpu_type(gvt, kobject_name(kobj));
+	if (!type)
+		num = 0;
+	else
+		num = type->avail_instance;
+
+	return sprintf(buf, "%u\n", num);
+}
+
+static ssize_t device_api_show(struct kobject *kobj, struct device *dev,
+		char *buf)
+{
+	return sprintf(buf, "%s\n", VFIO_DEVICE_API_PCI_STRING);
+}
+
+static ssize_t description_show(struct kobject *kobj, struct device *dev,
+		char *buf)
+{
+	struct intel_vgpu_type *type;
+	void *gvt = kdev_to_i915(dev)->gvt;
+
+	type = intel_gvt_find_vgpu_type(gvt, kobject_name(kobj));
+	if (!type)
+		return 0;
+
+	return sprintf(buf, "low_gm_size: %dMB\nhigh_gm_size: %dMB\n"
+		       "fence: %d\nresolution: %s\n"
+		       "weight: %d\n",
+		       BYTES_TO_MB(type->low_gm_size),
+		       BYTES_TO_MB(type->high_gm_size),
+		       type->fence, vgpu_edid_str(type->resolution),
+		       type->weight);
+}
+
+static MDEV_TYPE_ATTR_RO(available_instances);
+static MDEV_TYPE_ATTR_RO(device_api);
+static MDEV_TYPE_ATTR_RO(description);
+
+static struct attribute *gvt_type_attrs[] = {
+	&mdev_type_attr_available_instances.attr,
+	&mdev_type_attr_device_api.attr,
+	&mdev_type_attr_description.attr,
+	NULL,
+};
+
+static struct attribute_group *gvt_vgpu_type_groups[] = {
+	[0 ... NR_MAX_INTEL_VGPU_TYPES - 1] = NULL,
+};
+
+static bool intel_get_gvt_attrs(struct attribute ***type_attrs,
+		struct attribute_group ***intel_vgpu_type_groups)
+{
+	*type_attrs = gvt_type_attrs;
+	*intel_vgpu_type_groups = gvt_vgpu_type_groups;
+	return true;
+}
+
+static bool intel_gvt_init_vgpu_type_groups(struct intel_gvt *gvt)
+{
+	int i, j;
+	struct intel_vgpu_type *type;
+	struct attribute_group *group;
+
+	for (i = 0; i < gvt->num_types; i++) {
+		type = &gvt->types[i];
+
+		group = kzalloc(sizeof(struct attribute_group), GFP_KERNEL);
+		if (WARN_ON(!group))
+			goto unwind;
+
+		group->name = type->name;
+		group->attrs = gvt_type_attrs;
+		gvt_vgpu_type_groups[i] = group;
+	}
+
+	return true;
+
+unwind:
+	for (j = 0; j < i; j++) {
+		group = gvt_vgpu_type_groups[j];
+		kfree(group);
+	}
+
+	return false;
+}
+
+static void intel_gvt_cleanup_vgpu_type_groups(struct intel_gvt *gvt)
+{
+	int i;
+	struct attribute_group *group;
+
+	for (i = 0; i < gvt->num_types; i++) {
+		group = gvt_vgpu_type_groups[i];
+		gvt_vgpu_type_groups[i] = NULL;
+		kfree(group);
+	}
+}
+
 static const struct intel_gvt_ops intel_gvt_ops = {
 	.emulate_cfg_read = intel_vgpu_emulate_cfg_read,
 	.emulate_cfg_write = intel_vgpu_emulate_cfg_write,
@@ -54,6 +179,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.vgpu_reset = intel_gvt_reset_vgpu,
 	.vgpu_activate = intel_gvt_activate_vgpu,
 	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
+	.gvt_find_vgpu_type = intel_gvt_find_vgpu_type,
+	.get_gvt_attrs = intel_get_gvt_attrs,
 };
 
 /**
@@ -202,6 +329,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_free_firmware(gvt);
 
 	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
+	intel_gvt_cleanup_vgpu_type_groups(gvt);
 	intel_gvt_clean_vgpu_types(gvt);
 
 	idr_destroy(&gvt->vgpu_idr);
@@ -292,6 +420,12 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_thread;
 
+	ret = intel_gvt_init_vgpu_type_groups(gvt);
+	if (ret == false) {
+		gvt_err("failed to init vgpu type groups: %d\n", ret);
+		goto out_clean_types;
+	}
+
 	ret = intel_gvt_hypervisor_host_init(&dev_priv->drm.pdev->dev, gvt,
 				&intel_gvt_ops);
 	if (ret) {

commit 02d578e5edd980eac3fbed15db4d9e5665f22089
Author: Changbin Du <changbin.du@intel.com>
Date:   Wed Aug 23 14:08:10 2017 +0800

    drm/i915/gvt: Add support for PCIe extended configuration space
    
    IGD is PCIe device and has extended configuration space. Checking
    the binary dump, we can see we have Caps located out of PCI compatible
    Configuration Space range.
    
    0x000: 86 80 12 19 17 04 10 00 06 00 00 03 00 00 00 00
    0x010: 04 00 00 10 08 00 00 00 0c 00 00 00 08 00 00 00
    0x020: 00 00 00 00 00 00 00 00 00 00 00 00 28 10 b9 06
    0x030: 00 f8 ff ff 40 00 00 00 00 00 00 00 0b 01 00 00
    0x040: 09 70 0c 01 71 26 01 62 c8 00 04 84 00 00 00 00
    0x050: c1 00 00 00 39 00 00 00 00 00 00 00 01 00 00 a2
    0x060: 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x070: 10 ac 92 00 00 80 00 10 00 00 00 00 00 00 00 00
    0x080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x0a0: 00 00 00 00 00 00 00 00 00 00 00 00 05 d0 01 00
    0x0b0: 18 00 e0 fe 00 00 00 00 00 00 00 00 00 00 00 00
    0x0c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x0d0: 01 00 22 00 00 80 00 00 00 00 00 00 00 00 00 00
    0x0e0: 00 00 00 00 00 00 00 00 00 80 00 00 00 00 00 00
    0x0f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0x100: 1b 00 01 20 02 14 00 00 00 00 00 00 00 00 00 00
    ...
    
    Currently, we only emulate the PCI compatible Configuration Space.
    This is okay if we attach vGPU to PCI bus. But when we attach to
    a PCI Express bus (when Qemu emulates a Intel Q35 chipset which has
    PCIe slot), it will not work. Extended Configuration Space is required
    for a PCIe device.
    
    This patch extended the virtual configuration space from 256 bytes
    to 4KB bytes. So we are to be a *real* PCIe device. And for the
    Extended CapList we keep same to physical GPU.
    
    Cc: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index c27c6838eaca..aaa347f8620c 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -111,7 +111,7 @@ static void init_device_info(struct intel_gvt *gvt)
 	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)
 		|| IS_KABYLAKE(gvt->dev_priv)) {
 		info->max_support_vgpus = 8;
-		info->cfg_space_size = 256;
+		info->cfg_space_size = PCI_CFG_SPACE_EXP_SIZE;
 		info->mmio_size = 2 * 1024 * 1024;
 		info->mmio_bar = 0;
 		info->gtt_start_offset = 8 * 1024 * 1024;

commit c713cb2f9b7e1e9ffa8a379cecb13bc6eacd49b6
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Wed May 24 20:30:17 2017 +0800

    drm/i915/gvt: Support event based scheduling
    
    This patch decouple the time slice calculation and scheduler, let
    other event be able to trigger scheduling without impact the
    calculation for QoS.
    
    v2: add only one new enum definition.
    v3: fix typo.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 20329171e4ab..c27c6838eaca 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -147,7 +147,9 @@ static int gvt_service_thread(void *data)
 			mutex_unlock(&gvt->lock);
 		}
 
-		if (test_and_clear_bit(INTEL_GVT_REQUEST_SCHED,
+		if (test_bit(INTEL_GVT_REQUEST_SCHED,
+				(void *)&gvt->service_request) ||
+			test_bit(INTEL_GVT_REQUEST_EVENT_SCHED,
 					(void *)&gvt->service_request)) {
 			intel_gvt_schedule(gvt);
 		}

commit 0e86cc9ccc3bf557348befaddf5cb613cf3c4458
Author: Changbin Du <changbin.du@intel.com>
Date:   Thu May 4 10:52:38 2017 +0800

    drm/i915/gvt: implement per-vm mmio switching optimization
    
    Commit ab9da627906a ("drm/i915: make context status notifier head be
    per engine") gives us a chance to inspect every single request. Then
    we can eliminate unnecessary mmio switching for same vGPU. We only
    need mmio switching for different VMs (including host).
    
    This patch introduced a new general API intel_gvt_switch_mmio() to
    replace the old intel_gvt_load/restore_render_mmio(). This function
    can be further optimized for vGPU to vGPU switching.
    
    To support individual ring switch, we track the owner who occupy
    each ring. When another VM or host request a ring we do the mmio
    context switching. Otherwise no need to switch the ring.
    
    This optimization is very useful if only one guest has plenty of
    workloads and the host is mostly idle. The best case is no mmio
    switching will happen.
    
    v2:
      o fix missing ring switch issue. (chuanxiao)
      o support individual ring switch.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Reviewed-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 7dea5e5d5567..20329171e4ab 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -244,7 +244,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	gvt_dbg_core("init gvt device\n");
 
 	idr_init(&gvt->vgpu_idr);
-
+	spin_lock_init(&gvt->scheduler.mmio_context_lock);
 	mutex_init(&gvt->lock);
 	gvt->dev_priv = dev_priv;
 

commit 856ee92e8602bd86d34388ac08381c5cb3918756
Merge: a6a5c983b35e 4f7d029b9bf0
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 19 11:07:14 2017 +1000

    Merge tag 'v4.11-rc7' into drm-next
    
    Backmerge Linux 4.11-rc7 from Linus tree, to fix some
    conflicts that were causing problems with the rerere cache
    in drm-tip.

commit b79c52aef3cdee903017c1e9834b53996d70010e
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Mar 30 01:48:39 2017 +0800

    drm/i915/gvt: Activate/de-activate vGPU in mdev ops.
    
    This patch introduces two functions for activating/de-activating vGPU in
    mdev ops.
    
    A racing condition was found between virtual vblank emulation and KVGMT
    mdev release path. V-blank emulation will emulate and inject V-blank
    interrupt for every active vGPU with holding gvt->lock, while in mdev
    release path, it will directly release hypervisor handle without changing
    vGPU status or taking gvt->lock, so a kernel oops is encountered when
    vblank emulation is injecting a interrupt with a invalid hypervisor
    handle. (Reported by Terrence)
    
    To solve this problem, we factor out vGPU activation/de-activation from
    vGPU creation/destruction path and let KVMGT mdev release ops de-activate
    the vGPU before release hypervisor handle. Once a vGPU is de-activated,
    GVT-g will not emulate v-blank for it or touch the hypervisor handle.
    
    Fixes: 659643f ("drm/i915/gvt/kvmgt: add vfio/mdev support to KVMGT")
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 3b9d59e457ba..ef3baa0c4754 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -52,6 +52,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {
 	.vgpu_create = intel_gvt_create_vgpu,
 	.vgpu_destroy = intel_gvt_destroy_vgpu,
 	.vgpu_reset = intel_gvt_reset_vgpu,
+	.vgpu_activate = intel_gvt_activate_vgpu,
+	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
 };
 
 /**

commit afe04fbe6c522e73d5cc61a6660cce0e78630786
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:39 2017 +0800

    drm/i915/gvt: create an idle vGPU
    
    vGPU resource is allocated by scheduler. To account for non-allocated
    free cycles, we create an idle vGPU as the placeholder similar to idle task
    concept, which is useful to handle some corner cases in scheduling policy.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 894735c77f63..0f3a98865a58 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -202,6 +202,8 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 
 	idr_destroy(&gvt->vgpu_idr);
 
+	intel_gvt_destroy_idle_vgpu(gvt->idle_vgpu);
+
 	kfree(dev_priv->gvt);
 	dev_priv->gvt = NULL;
 }
@@ -220,6 +222,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 {
 	struct intel_gvt *gvt;
+	struct intel_vgpu *vgpu;
 	int ret;
 
 	/*
@@ -292,6 +295,14 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 		goto out_clean_types;
 	}
 
+	vgpu = intel_gvt_create_idle_vgpu(gvt);
+	if (IS_ERR(vgpu)) {
+		ret = PTR_ERR(vgpu);
+		gvt_err("failed to create idle vgpu\n");
+		goto out_clean_types;
+	}
+	gvt->idle_vgpu = vgpu;
+
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;
 	return 0;

commit 91d0101ad30bd1bd7f7f805f4fa314c6b70bb602
Author: Ping Gao <ping.a.gao@intel.com>
Date:   Thu Mar 30 00:36:34 2017 +0800

    drm/i915/gvt: use hrtimer replace delayed_work in scheduler
    
    Currently the scheduler is triggered by delayed_work, which doesn't
    provide precision at microsecond level. Move to hrtimer instead for
    more accurate control.
    
    Signed-off-by: Ping Gao <ping.a.gao@intel.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index b84b7ca3f66f..894735c77f63 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -144,6 +144,11 @@ static int gvt_service_thread(void *data)
 			intel_gvt_emulate_vblank(gvt);
 			mutex_unlock(&gvt->lock);
 		}
+
+		if (test_and_clear_bit(INTEL_GVT_REQUEST_SCHED,
+					(void *)&gvt->service_request)) {
+			intel_gvt_schedule(gvt);
+		}
 	}
 
 	return 0;

commit e3476c0021c31b64070c40f02bfb7faab55591b4
Author: Xu Han <xu.han@intel.com>
Date:   Wed Mar 29 10:13:59 2017 +0800

    drm/i915/gvt: Add KBL dispatch logic in each function.
    
    Extend function dispatch logic to support KBL platform.
    
    Signed-off-by: Xu Han <xu.han@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 3b9d59e457ba..b84b7ca3f66f 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -106,7 +106,8 @@ static void init_device_info(struct intel_gvt *gvt)
 	struct intel_gvt_device_info *info = &gvt->device_info;
 	struct pci_dev *pdev = gvt->dev_priv->drm.pdev;
 
-	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)) {
+	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)
+		|| IS_KABYLAKE(gvt->dev_priv)) {
 		info->max_support_vgpus = 8;
 		info->cfg_space_size = 256;
 		info->mmio_size = 2 * 1024 * 1024;

commit 811a4cf273afc6f651e0ef3d5400084bf0aeb75e
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Thu Feb 9 11:38:38 2017 +0800

    drm/i915/gvt: enable IOMMU for gvt
    
    gvt driver has a check which doesn't allow to use gvt when host
    gpu iommu is enabled. This check can be removed after enable the
    iommu support in gvt
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 9a636a2c2077..3b9d59e457ba 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -75,13 +75,6 @@ int intel_gvt_init_host(void)
 	if (xen_domain() && !xen_initial_domain())
 		return -ENODEV;
 
-#ifdef CONFIG_INTEL_IOMMU
-	if (intel_iommu_gfx_mapped) {
-		gvt_err("Hardware IOMMU compatibility not yet supported, try to boot with intel_iommu=igfx_off\n");
-		return -ENODEV;
-	}
-#endif
-
 	/* Try to load MPT modules for hypervisors */
 	if (xen_initial_domain()) {
 		/* In Xen dom0 */

commit 3de49a7314c9e17d71e97af4ed4b0564609e9ba7
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Dec 27 14:47:04 2016 +0800

    drm/i915/gvt: remove detect_host() MPT hook
    
    We only depend on pvinfo register for GVT-g state detection,
    not require hypervisor host detect any more.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 0beb17e92928..9a636a2c2077 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -68,8 +68,6 @@ static const struct intel_gvt_ops intel_gvt_ops = {
  */
 int intel_gvt_init_host(void)
 {
-	int ret;
-
 	if (intel_gvt_host.initialized)
 		return 0;
 
@@ -103,11 +101,6 @@ int intel_gvt_init_host(void)
 	if (!intel_gvt_host.mpt)
 		return -EINVAL;
 
-	/* Try to detect if we're running in host instead of VM. */
-	ret = intel_gvt_hypervisor_detect_host();
-	if (ret)
-		return -ENODEV;
-
 	gvt_dbg_core("Running with hypervisor %s in host mode\n",
 			supported_hypervisors[intel_gvt_host.hypervisor_type]);
 

commit d2896e34eb6f10b4f76b42df34b7e075b203c5ff
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Jan 13 15:31:58 2017 +0800

    drm/i915/gvt: move intel iommu detection to intel_gvt_init()
    
    Prepare to remove detect_host() hook. Move intel iommu detection early
    in intel_gvt_init().
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index e6bf5c533fbe..0beb17e92928 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -77,6 +77,13 @@ int intel_gvt_init_host(void)
 	if (xen_domain() && !xen_initial_domain())
 		return -ENODEV;
 
+#ifdef CONFIG_INTEL_IOMMU
+	if (intel_iommu_gfx_mapped) {
+		gvt_err("Hardware IOMMU compatibility not yet supported, try to boot with intel_iommu=igfx_off\n");
+		return -ENODEV;
+	}
+#endif
+
 	/* Try to load MPT modules for hypervisors */
 	if (xen_initial_domain()) {
 		/* In Xen dom0 */

commit 59c0573dfbd5f66e3aa54c2ce0bebcb0953d4db4
Author: Jike Song <jike.song@intel.com>
Date:   Fri Jan 6 15:16:21 2017 +0800

    drm/i915/gvt: init/destroy vgpu_idr properly
    
    An idr should be initialized before use and destroyed afterwards.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 398877c3d2fd..e6bf5c533fbe 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -201,6 +201,8 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
 	intel_gvt_clean_vgpu_types(gvt);
 
+	idr_destroy(&gvt->vgpu_idr);
+
 	kfree(dev_priv->gvt);
 	dev_priv->gvt = NULL;
 }
@@ -237,6 +239,8 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 
 	gvt_dbg_core("init gvt device\n");
 
+	idr_init(&gvt->vgpu_idr);
+
 	mutex_init(&gvt->lock);
 	gvt->dev_priv = dev_priv;
 
@@ -244,7 +248,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 
 	ret = intel_gvt_setup_mmio_info(gvt);
 	if (ret)
-		return ret;
+		goto out_clean_idr;
 
 	ret = intel_gvt_load_firmware(gvt);
 	if (ret)
@@ -313,6 +317,8 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	intel_gvt_free_firmware(gvt);
 out_clean_mmio_info:
 	intel_gvt_clean_mmio_info(gvt);
+out_clean_idr:
+	idr_destroy(&gvt->vgpu_idr);
 	kfree(gvt);
 	return ret;
 }

commit f30437c5e7bfa9d8acc18058040efb4f474907c3
Author: Jike Song <jike.song@intel.com>
Date:   Wed Nov 9 20:30:59 2016 +0800

    drm/i915/gvt: add KVMGT support
    
    KVMGT is the MPT implementation based on VFIO/KVM. It provides
    a kvmgt_mpt ops to gvt for vGPU access mediation, e.g. to
    mediate and emulate the MMIO accesses, to inject interrupts
    to vGPU user, to intercept the GTT writing and replace it with
    DMA-able address, to write-protect guest PPGTT table for
    shadowing synchronization, etc. This patch provides the MPT
    implementation for GVT, not yet functional due to theabsence
    of mdev.
    
    It's built as kvmgt.ko, depends on vfio.ko, kvm.ko and mdev.ko,
    and being required by i915.ko. To not introduce hard dependency
    in i915.ko, we used indirect symbol reference. But that means
    users have to include kvmgt.ko into init ramdisk if their
    i915.ko is included.
    
    Signed-off-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Xiaoguang Chen <xiaoguang.chen@intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 7af265ac8d74..398877c3d2fd 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -84,10 +84,12 @@ int intel_gvt_init_host(void)
 				symbol_get(xengt_mpt), "xengt");
 		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_XEN;
 	} else {
+#if IS_ENABLED(CONFIG_DRM_I915_GVT_KVMGT)
 		/* not in Xen. Try KVMGT */
 		intel_gvt_host.mpt = try_then_request_module(
-				symbol_get(kvmgt_mpt), "kvm");
+				symbol_get(kvmgt_mpt), "kvmgt");
 		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_KVM;
+#endif
 	}
 
 	/* Fail to load MPT modules - bail out */

commit 9ec1e66b8084f24d41046bd9711fbd7ec6e3850f
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:35 2016 +0800

    drm/i915/gvt: refactor intel_gvt_io_emulation_ops to be intel_gvt_ops
    
    There are currently 4 methods in intel_gvt_io_emulation_ops
    to emulate CFG/MMIO reading/writing for intel vGPU. A possibly
    better scope is: add 3 more methods for vgpu create/destroy/reset
    respectively, and rename the ops to 'intel_gvt_ops', then pass
    it to the MPT module (say the future kvmgt) to use: they are
    all methods for external usage.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 13db29d045a4..7af265ac8d74 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -44,11 +44,14 @@ static const char * const supported_hypervisors[] = {
 	[INTEL_GVT_HYPERVISOR_KVM] = "KVM",
 };
 
-struct intel_gvt_io_emulation_ops intel_gvt_io_emulation_ops = {
+static const struct intel_gvt_ops intel_gvt_ops = {
 	.emulate_cfg_read = intel_vgpu_emulate_cfg_read,
 	.emulate_cfg_write = intel_vgpu_emulate_cfg_write,
 	.emulate_mmio_read = intel_vgpu_emulate_mmio_read,
 	.emulate_mmio_write = intel_vgpu_emulate_mmio_write,
+	.vgpu_create = intel_gvt_create_vgpu,
+	.vgpu_destroy = intel_gvt_destroy_vgpu,
+	.vgpu_reset = intel_gvt_reset_vgpu,
 };
 
 /**
@@ -278,7 +281,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 		goto out_clean_thread;
 
 	ret = intel_gvt_hypervisor_host_init(&dev_priv->drm.pdev->dev, gvt,
-				&intel_gvt_io_emulation_ops);
+				&intel_gvt_ops);
 	if (ret) {
 		gvt_err("failed to register gvt-g host device: %d\n", ret);
 		goto out_clean_types;

commit 40df6ea07a15032e33b6f3d415bed0774547ec7e
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:33 2016 +0800

    drm/i915/gvt: introduce host_init/host_exit to MPT
    
    GVT host needs init/exit hooks to do some initialization/cleanup
    work, e.g.: vfio mdev host device register/unregister.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 48a67d1e1893..13db29d045a4 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -193,6 +193,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
 
+	intel_gvt_hypervisor_host_exit(&dev_priv->drm.pdev->dev, gvt);
 	intel_gvt_clean_vgpu_types(gvt);
 
 	kfree(dev_priv->gvt);
@@ -276,11 +277,19 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_thread;
 
+	ret = intel_gvt_hypervisor_host_init(&dev_priv->drm.pdev->dev, gvt,
+				&intel_gvt_io_emulation_ops);
+	if (ret) {
+		gvt_err("failed to register gvt-g host device: %d\n", ret);
+		goto out_clean_types;
+	}
 
 	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;
 	return 0;
 
+out_clean_types:
+	intel_gvt_clean_vgpu_types(gvt);
 out_clean_thread:
 	clean_service_thread(gvt);
 out_clean_cmd_parser:

commit 1f31c8294880d1ac99b1b477efd9de23b36cd5ec
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Nov 3 18:38:31 2016 +0800

    drm/i915/gvt: add intel vgpu types support
    
    By providing predefined vGPU types, users can choose which type a vgpu
    to create and use, without specifying detailed parameters.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 385969a89216..48a67d1e1893 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -193,6 +193,8 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
 
+	intel_gvt_clean_vgpu_types(gvt);
+
 	kfree(dev_priv->gvt);
 	dev_priv->gvt = NULL;
 }
@@ -270,10 +272,17 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_cmd_parser;
 
-	gvt_dbg_core("gvt device creation is done\n");
+	ret = intel_gvt_init_vgpu_types(gvt);
+	if (ret)
+		goto out_clean_thread;
+
+
+	gvt_dbg_core("gvt device initialization is done\n");
 	dev_priv->gvt = gvt;
 	return 0;
 
+out_clean_thread:
+	clean_service_thread(gvt);
 out_clean_cmd_parser:
 	intel_gvt_clean_cmd_parser(gvt);
 out_clean_sched_policy:

commit b0122f3114e20f7d73520761648f8f0c141f3a30
Author: Xiaoguang Chen <xiaoguang.chen@intel.com>
Date:   Tue Oct 25 16:56:45 2016 +0800

    drm/i915/gvt: fix detect_host calling logic
    
    Like other routines, intel_gvt_hypervisor_detect_host returns 0
    for success.
    
    Signed-off-by: Xiaoguang Chen <xiaoguang.chen@intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index bf0377768a0d..385969a89216 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -65,6 +65,8 @@ struct intel_gvt_io_emulation_ops intel_gvt_io_emulation_ops = {
  */
 int intel_gvt_init_host(void)
 {
+	int ret;
+
 	if (intel_gvt_host.initialized)
 		return 0;
 
@@ -90,7 +92,8 @@ int intel_gvt_init_host(void)
 		return -EINVAL;
 
 	/* Try to detect if we're running in host instead of VM. */
-	if (!intel_gvt_hypervisor_detect_host())
+	ret = intel_gvt_hypervisor_detect_host();
+	if (ret)
 		return -ENODEV;
 
 	gvt_dbg_core("Running with hypervisor %s in host mode\n",

commit 49129204c31cb3b6f0fbc23d6afe66c88c1c12ae
Author: Du, Changbin <changbin.du@intel.com>
Date:   Mon Oct 24 15:58:44 2016 +0800

    drm/i915/gvt: get msi cap offset from pdev directly
    
    Linux PCI driver saves the msi and msix capability offset
    in pci_dev->msi_cap and pci_dev->msix_cap. We can use msi_cap
    in pci_dev directly, no need hardcode.
    
    Signed-off-by: Du, Changbin <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 31b59d40f3fb..bf0377768a0d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -103,19 +103,20 @@ int intel_gvt_init_host(void)
 static void init_device_info(struct intel_gvt *gvt)
 {
 	struct intel_gvt_device_info *info = &gvt->device_info;
+	struct pci_dev *pdev = gvt->dev_priv->drm.pdev;
 
 	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)) {
 		info->max_support_vgpus = 8;
 		info->cfg_space_size = 256;
 		info->mmio_size = 2 * 1024 * 1024;
 		info->mmio_bar = 0;
-		info->msi_cap_offset = IS_SKYLAKE(gvt->dev_priv) ? 0xac : 0x90;
 		info->gtt_start_offset = 8 * 1024 * 1024;
 		info->gtt_entry_size = 8;
 		info->gtt_entry_size_shift = 3;
 		info->gmadr_bytes_in_cmd = 8;
 		info->max_surface_size = 36 * 1024 * 1024;
 	}
+	info->msi_cap_offset = pdev->msi_cap;
 }
 
 static int gvt_service_thread(void *data)

commit feddf6e866c9cdbdec45b09f0a9566ea538a0da3
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Oct 20 17:15:03 2016 +0800

    drm/i915/gvt: clean up intel_gvt.h as interface for i915 core
    
    i915 core should only call functions and structures exposed through
    intel_gvt.h. Remove internal gvt.h and i915_pvinfo.h.
    
    Change for internal intel_gvt structure as private handler which
    not requires to expose gvt internal structure for i915 core.
    
    v2: Fix per Chris's comment
    - carefully handle dev_priv->gvt assignment
    - add necessary bracket for macro helper
    - forward declartion struct intel_gvt
    - keep free operation within same file handling alloc
    
    v3: fix use after free and remove intel_gvt.initialized
    
    v4: change to_gvt() to an inline
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index e72e26c61a15..31b59d40f3fb 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -35,6 +35,7 @@
 #include <linux/kthread.h>
 
 #include "i915_drv.h"
+#include "gvt.h"
 
 struct intel_gvt_host intel_gvt_host;
 
@@ -173,9 +174,9 @@ static int init_service_thread(struct intel_gvt *gvt)
  */
 void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 {
-	struct intel_gvt *gvt = &dev_priv->gvt;
+	struct intel_gvt *gvt = to_gvt(dev_priv);
 
-	if (WARN_ON(!gvt->initialized))
+	if (WARN_ON(!gvt))
 		return;
 
 	clean_service_thread(gvt);
@@ -188,7 +189,8 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
 
-	gvt->initialized = false;
+	kfree(dev_priv->gvt);
+	dev_priv->gvt = NULL;
 }
 
 /**
@@ -204,7 +206,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
  */
 int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 {
-	struct intel_gvt *gvt = &dev_priv->gvt;
+	struct intel_gvt *gvt;
 	int ret;
 
 	/*
@@ -214,9 +216,13 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!intel_gvt_host.initialized))
 		return -EINVAL;
 
-	if (WARN_ON(gvt->initialized))
+	if (WARN_ON(dev_priv->gvt))
 		return -EEXIST;
 
+	gvt = kzalloc(sizeof(struct intel_gvt), GFP_KERNEL);
+	if (!gvt)
+		return -ENOMEM;
+
 	gvt_dbg_core("init gvt device\n");
 
 	mutex_init(&gvt->lock);
@@ -261,7 +267,7 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 		goto out_clean_cmd_parser;
 
 	gvt_dbg_core("gvt device creation is done\n");
-	gvt->initialized = true;
+	dev_priv->gvt = gvt;
 	return 0;
 
 out_clean_cmd_parser:
@@ -280,5 +286,6 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	intel_gvt_free_firmware(gvt);
 out_clean_mmio_info:
 	intel_gvt_clean_mmio_info(gvt);
+	kfree(gvt);
 	return ret;
 }

commit be1da7070aeaee23ff659c1a8cd992789ff86da4
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue May 3 18:26:57 2016 -0400

    drm/i915/gvt: vGPU command scanner
    
    This patch introduces a command scanner to scan guest command buffers.
    
    Signed-off-by: Yulei Zhang <yulei.zhang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 7f13efbbd93a..e72e26c61a15 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -112,6 +112,8 @@ static void init_device_info(struct intel_gvt *gvt)
 		info->gtt_start_offset = 8 * 1024 * 1024;
 		info->gtt_entry_size = 8;
 		info->gtt_entry_size_shift = 3;
+		info->gmadr_bytes_in_cmd = 8;
+		info->max_surface_size = 36 * 1024 * 1024;
 	}
 }
 
@@ -177,6 +179,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	clean_service_thread(gvt);
+	intel_gvt_clean_cmd_parser(gvt);
 	intel_gvt_clean_sched_policy(gvt);
 	intel_gvt_clean_workload_scheduler(gvt);
 	intel_gvt_clean_opregion(gvt);
@@ -249,14 +252,20 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_workload_scheduler;
 
-	ret = init_service_thread(gvt);
+	ret = intel_gvt_init_cmd_parser(gvt);
 	if (ret)
 		goto out_clean_sched_policy;
 
+	ret = init_service_thread(gvt);
+	if (ret)
+		goto out_clean_cmd_parser;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_cmd_parser:
+	intel_gvt_clean_cmd_parser(gvt);
 out_clean_sched_policy:
 	intel_gvt_clean_sched_policy(gvt);
 out_clean_workload_scheduler:

commit 4b63960ebd3f4c41caca6a8dca68751b34e61e9b
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 17:09:58 2016 -0400

    drm/i915/gvt: vGPU schedule policy framework
    
    This patch introduces a vGPU schedule policy framework, with a timer based
    schedule policy module for now
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 5bf8488beaef..7f13efbbd93a 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -177,6 +177,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	clean_service_thread(gvt);
+	intel_gvt_clean_sched_policy(gvt);
 	intel_gvt_clean_workload_scheduler(gvt);
 	intel_gvt_clean_opregion(gvt);
 	intel_gvt_clean_gtt(gvt);
@@ -244,14 +245,20 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_opregion;
 
-	ret = init_service_thread(gvt);
+	ret = intel_gvt_init_sched_policy(gvt);
 	if (ret)
 		goto out_clean_workload_scheduler;
 
+	ret = init_service_thread(gvt);
+	if (ret)
+		goto out_clean_sched_policy;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_sched_policy:
+	intel_gvt_clean_sched_policy(gvt);
 out_clean_workload_scheduler:
 	intel_gvt_clean_workload_scheduler(gvt);
 out_clean_opregion:

commit e473405783c064a9d859d108010581bae8e9af40
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Sun May 1 07:42:16 2016 -0400

    drm/i915/gvt: vGPU workload scheduler
    
    This patch introduces the vGPU workload scheduler routines.
    
    GVT workload scheduler is responsible for picking and executing GVT workload
    from current scheduled vGPU. Before the workload is submitted to host i915,
    the guest execlist context will be shadowed in the host GVT shadow context.
    the instructions in guest ring buffer will be copied into GVT shadow ring
    buffer. Then GVT-g workload scheduler will scan the instructions in guest
    ring buffer and submit it to host i915.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 27e1dd9a2570..5bf8488beaef 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -177,6 +177,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	clean_service_thread(gvt);
+	intel_gvt_clean_workload_scheduler(gvt);
 	intel_gvt_clean_opregion(gvt);
 	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
@@ -239,14 +240,20 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_gtt;
 
-	ret = init_service_thread(gvt);
+	ret = intel_gvt_init_workload_scheduler(gvt);
 	if (ret)
 		goto out_clean_opregion;
 
+	ret = init_service_thread(gvt);
+	if (ret)
+		goto out_clean_workload_scheduler;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_workload_scheduler:
+	intel_gvt_clean_workload_scheduler(gvt);
 out_clean_opregion:
 	intel_gvt_clean_opregion(gvt);
 out_clean_gtt:

commit 04d348ae3f0aea6523bc3b0688b5fc90c1c60d0e
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Apr 25 18:28:56 2016 -0400

    drm/i915/gvt: vGPU display virtualization
    
    This patch introduces the GVT-g display virtualization.
    
    It consists a collection of display MMIO handlers, like power well register
    handler, pipe register handler, plane register handler, which will emulate
    all display MMIOs behavior to support virtual mode setting sequence for
    guest.
    
    Signed-off-by: Bing Niu <bing.niu@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 6b5061bfebb0..27e1dd9a2570 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -32,6 +32,7 @@
 
 #include <linux/types.h>
 #include <xen/xen.h>
+#include <linux/kthread.h>
 
 #include "i915_drv.h"
 
@@ -114,6 +115,52 @@ static void init_device_info(struct intel_gvt *gvt)
 	}
 }
 
+static int gvt_service_thread(void *data)
+{
+	struct intel_gvt *gvt = (struct intel_gvt *)data;
+	int ret;
+
+	gvt_dbg_core("service thread start\n");
+
+	while (!kthread_should_stop()) {
+		ret = wait_event_interruptible(gvt->service_thread_wq,
+				kthread_should_stop() || gvt->service_request);
+
+		if (kthread_should_stop())
+			break;
+
+		if (WARN_ONCE(ret, "service thread is waken up by signal.\n"))
+			continue;
+
+		if (test_and_clear_bit(INTEL_GVT_REQUEST_EMULATE_VBLANK,
+					(void *)&gvt->service_request)) {
+			mutex_lock(&gvt->lock);
+			intel_gvt_emulate_vblank(gvt);
+			mutex_unlock(&gvt->lock);
+		}
+	}
+
+	return 0;
+}
+
+static void clean_service_thread(struct intel_gvt *gvt)
+{
+	kthread_stop(gvt->service_thread);
+}
+
+static int init_service_thread(struct intel_gvt *gvt)
+{
+	init_waitqueue_head(&gvt->service_thread_wq);
+
+	gvt->service_thread = kthread_run(gvt_service_thread,
+			gvt, "gvt_service_thread");
+	if (IS_ERR(gvt->service_thread)) {
+		gvt_err("fail to start service thread.\n");
+		return PTR_ERR(gvt->service_thread);
+	}
+	return 0;
+}
+
 /**
  * intel_gvt_clean_device - clean a GVT device
  * @gvt: intel gvt device
@@ -129,6 +176,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt->initialized))
 		return;
 
+	clean_service_thread(gvt);
 	intel_gvt_clean_opregion(gvt);
 	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
@@ -191,10 +239,16 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_gtt;
 
+	ret = init_service_thread(gvt);
+	if (ret)
+		goto out_clean_opregion;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_opregion:
+	intel_gvt_clean_opregion(gvt);
 out_clean_gtt:
 	intel_gvt_clean_gtt(gvt);
 out_clean_irq:

commit e39c5add322184de3be052d438dfd24375bfeaea
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Fri Sep 2 13:33:29 2016 +0800

    drm/i915/gvt: vGPU MMIO virtualization
    
    This patch introduces the generic vGPU MMIO emulation intercept
    framework.  The MPT modules will request GVT-g core logic to
    emulate MMIO read/write through IO emulation operations
    callback when hypervisor trapped a guest GTTMMIO read/write.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index c6e063ec6c5d..6b5061bfebb0 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -45,6 +45,8 @@ static const char * const supported_hypervisors[] = {
 struct intel_gvt_io_emulation_ops intel_gvt_io_emulation_ops = {
 	.emulate_cfg_read = intel_vgpu_emulate_cfg_read,
 	.emulate_cfg_write = intel_vgpu_emulate_cfg_write,
+	.emulate_mmio_read = intel_vgpu_emulate_mmio_read,
+	.emulate_mmio_write = intel_vgpu_emulate_mmio_write,
 };
 
 /**

commit 4d60c5fd3f8751ea751d6dc6cfe0c1620420ccf8
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Wed Jul 20 01:14:38 2016 -0400

    drm/i915/gvt: vGPU PCI configuration space virtualization
    
    This patch introduces vGPU PCI configuration space virtualization.
    
    - Adjust the trapped GPFN(Guest Page Frame Number) window of virtual GEN
    PCI BAR 0 when guest initializes PCI BAR 0 address.
    
    - Emulate OpRegion when guest touches OpRegion.
    
    - Pass-through a part of aperture to guest when guest initializes
    aperture BAR.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 5063c672736d..c6e063ec6c5d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -42,6 +42,11 @@ static const char * const supported_hypervisors[] = {
 	[INTEL_GVT_HYPERVISOR_KVM] = "KVM",
 };
 
+struct intel_gvt_io_emulation_ops intel_gvt_io_emulation_ops = {
+	.emulate_cfg_read = intel_vgpu_emulate_cfg_read,
+	.emulate_cfg_write = intel_vgpu_emulate_cfg_write,
+};
+
 /**
  * intel_gvt_init_host - Load MPT modules and detect if we're running in host
  * @gvt: intel gvt device
@@ -122,6 +127,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt->initialized))
 		return;
 
+	intel_gvt_clean_opregion(gvt);
 	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
 	intel_gvt_clean_mmio_info(gvt);
@@ -179,10 +185,16 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_irq;
 
+	ret = intel_gvt_init_opregion(gvt);
+	if (ret)
+		goto out_clean_gtt;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_gtt:
+	intel_gvt_clean_gtt(gvt);
 out_clean_irq:
 	intel_gvt_clean_irq(gvt);
 out_free_firmware:

commit 2707e44466881d6b0a8ed05a429dcf0940c22f60
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Mar 28 23:23:16 2016 +0800

    drm/i915/gvt: vGPU graphics memory virtualization
    
    The vGPU graphics memory emulation framework is responsible for graphics
    memory table virtualization. Under virtualization environment, a VM will
    populate the page table entry with guest page frame number(GPFN/GFN), while
    HW needs a page table filled with MFN(Machine frame number). The
    relationship between GFN and MFN(Machine frame number) is managed by
    hypervisor, while GEN HW doesn't have such knowledge to translate a GFN.
    
    To solve this gap, shadow GGTT/PPGTT page table is introdcued.
    
    For GGTT, the GFN inside the guest GGTT page table entry will be translated
    into MFN and written into physical GTT MMIO registers when guest write
    virtual GTT MMIO registers.
    
    For PPGTT, a shadow PPGTT page table will be created and write-protected
    translated from guest PPGTT page table.  And the shadow page table root
    pointers will be written into the shadow context after a guest workload
    is shadowed.
    
    vGPU graphics memory emulation framework consists:
    
    - Per-GEN HW platform page table entry bits extract/de-extract routines.
    - GTT MMIO register emulation handlers, which will call hypercall to do
    GFN->MFN translation when guest write GTT MMIO register
    - PPGTT shadow page table routines, e.g. shadow create/destroy/out-of-sync
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 29efe454b1cd..5063c672736d 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -101,6 +101,9 @@ static void init_device_info(struct intel_gvt *gvt)
 		info->mmio_size = 2 * 1024 * 1024;
 		info->mmio_bar = 0;
 		info->msi_cap_offset = IS_SKYLAKE(gvt->dev_priv) ? 0xac : 0x90;
+		info->gtt_start_offset = 8 * 1024 * 1024;
+		info->gtt_entry_size = 8;
+		info->gtt_entry_size_shift = 3;
 	}
 }
 
@@ -119,6 +122,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt->initialized))
 		return;
 
+	intel_gvt_clean_gtt(gvt);
 	intel_gvt_clean_irq(gvt);
 	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
@@ -171,10 +175,16 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_free_firmware;
 
+	ret = intel_gvt_init_gtt(gvt);
+	if (ret)
+		goto out_clean_irq;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_clean_irq:
+	intel_gvt_clean_irq(gvt);
 out_free_firmware:
 	intel_gvt_free_firmware(gvt);
 out_clean_mmio_info:

commit c8fe6a6811a7186656379d0c27e85325a966077a
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Sep 17 09:22:08 2015 +0800

    drm/i915/gvt: vGPU interrupt virtualization.
    
    This patch introduces vGPU interrupt emulation framework.
    
    The vGPU intrerrupt emulation framework is an event-based interrupt
    emulation framework. It's responsible for emulating GEN hardware interrupts
    during emulating other HW behaviour.
    
    It consists several components:
    
    - Descriptions of interrupt register bit
    - Upper level <-> lower level interrupt mapping
    - GEN HW IER/IMR/IIR register emulation routines
    - Event-based interrupt propagation interface
    
    When a GVT-g component wants to inject an interrupt to a VM during a
    emulation, first it should specify the event needs to be emulated and the
    framework will deal with the rest of emulation:
    
    - Generating related virtual IIR bit according to virtual IER and IMRs,
    - Generate related virtual upper level virtual IIR bit accodring to the
    per-platform interrupt mapping
    - Injecting a MSI to VM
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 2c03dad28718..29efe454b1cd 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -97,9 +97,10 @@ static void init_device_info(struct intel_gvt *gvt)
 
 	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)) {
 		info->max_support_vgpus = 8;
-		info->mmio_size = 2 * 1024 * 1024;
 		info->cfg_space_size = 256;
+		info->mmio_size = 2 * 1024 * 1024;
 		info->mmio_bar = 0;
+		info->msi_cap_offset = IS_SKYLAKE(gvt->dev_priv) ? 0xac : 0x90;
 	}
 }
 
@@ -118,6 +119,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt->initialized))
 		return;
 
+	intel_gvt_clean_irq(gvt);
 	intel_gvt_clean_mmio_info(gvt);
 	intel_gvt_free_firmware(gvt);
 
@@ -165,10 +167,16 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto out_clean_mmio_info;
 
+	ret = intel_gvt_init_irq(gvt);
+	if (ret)
+		goto out_free_firmware;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
 
+out_free_firmware:
+	intel_gvt_free_firmware(gvt);
 out_clean_mmio_info:
 	intel_gvt_clean_mmio_info(gvt);
 	return ret;

commit 579cea5f30f2c70215492e987bb439a3e50c6371
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Jun 30 12:45:34 2016 -0400

    drm/i915/gvt: golden virtual HW state management
    
    Each vGPU expects a golden virtual HW state, which is just the state after
    system is freshly powered on. GVT-g will try to load the golden virtual HW
    state via kernel firmware interface.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 9f5c9bd83bc9..2c03dad28718 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -98,6 +98,8 @@ static void init_device_info(struct intel_gvt *gvt)
 	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)) {
 		info->max_support_vgpus = 8;
 		info->mmio_size = 2 * 1024 * 1024;
+		info->cfg_space_size = 256;
+		info->mmio_bar = 0;
 	}
 }
 
@@ -117,6 +119,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 		return;
 
 	intel_gvt_clean_mmio_info(gvt);
+	intel_gvt_free_firmware(gvt);
 
 	gvt->initialized = false;
 }
@@ -158,7 +161,15 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	if (ret)
 		return ret;
 
+	ret = intel_gvt_load_firmware(gvt);
+	if (ret)
+		goto out_clean_mmio_info;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;
+
+out_clean_mmio_info:
+	intel_gvt_clean_mmio_info(gvt);
+	return ret;
 }

commit 12d14cc43b34706283246917329b2182163ba9aa
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue Aug 30 11:06:17 2016 +0800

    drm/i915/gvt: Introduce a framework for tracking HW registers.
    
    This patch introduces a framework for tracking HW registers on different
    GEN platforms.
    
    Accesses to GEN HW registers from VMs will be trapped by hypervisor. It
    will forward these emulation requests to GVT-g device model, which
    requires this framework to search for related register descriptions.
    
    Each MMIO entry in this framework describes a GEN HW registers, e.g.
    offset, length, whether it contains RO bits, whether it can be accessed by
    LRIs...and also emulation handlers for emulating register reading and
    writing.
    
    - Use i915 MMIO register definition & statement.(Joonas)
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 6ec5b937af63..9f5c9bd83bc9 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -19,6 +19,15 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
+ *
+ * Authors:
+ *    Kevin Tian <kevin.tian@intel.com>
+ *    Eddie Dong <eddie.dong@intel.com>
+ *
+ * Contributors:
+ *    Niu Bing <bing.niu@intel.com>
+ *    Zhi Wang <zhi.a.wang@intel.com>
+ *
  */
 
 #include <linux/types.h>
@@ -84,9 +93,12 @@ int intel_gvt_init_host(void)
 
 static void init_device_info(struct intel_gvt *gvt)
 {
-	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv))
-		gvt->device_info.max_support_vgpus = 8;
-	/* This function will grow large in GVT device model patches. */
+	struct intel_gvt_device_info *info = &gvt->device_info;
+
+	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv)) {
+		info->max_support_vgpus = 8;
+		info->mmio_size = 2 * 1024 * 1024;
+	}
 }
 
 /**
@@ -104,7 +116,7 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 	if (WARN_ON(!gvt->initialized))
 		return;
 
-	/* Other de-initialization of GVT components will be introduced. */
+	intel_gvt_clean_mmio_info(gvt);
 
 	gvt->initialized = false;
 }
@@ -123,6 +135,8 @@ void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
 int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 {
 	struct intel_gvt *gvt = &dev_priv->gvt;
+	int ret;
+
 	/*
 	 * Cannot initialize GVT device without intel_gvt_host gets
 	 * initialized first.
@@ -139,9 +153,11 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 	gvt->dev_priv = dev_priv;
 
 	init_device_info(gvt);
-	/*
-	 * Other initialization of GVT components will be introduce here.
-	 */
+
+	ret = intel_gvt_setup_mmio_info(gvt);
+	if (ret)
+		return ret;
+
 	gvt_dbg_core("gvt device creation is done\n");
 	gvt->initialized = true;
 	return 0;

commit 28a60dee2ce6021fa6b304bc6761b71120635ad8
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Fri Sep 2 12:41:29 2016 +0800

    drm/i915/gvt: vGPU HW resource management
    
    This patch introduces the GVT-g vGPU HW resource management. Under
    GVT-g virtualizaion environment, each vGPU requires portions HW
    resources, including aperture, hidden GM space, and fence registers.
    
    When creating a vGPU, GVT-g will request these HW resources from host,
    and return them to host after a vGPU is destroyed.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
index 927f4579f5b6..6ec5b937af63 100644
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -84,7 +84,7 @@ int intel_gvt_init_host(void)
 
 static void init_device_info(struct intel_gvt *gvt)
 {
-	if (IS_BROADWELL(gvt->dev_priv))
+	if (IS_BROADWELL(gvt->dev_priv) || IS_SKYLAKE(gvt->dev_priv))
 		gvt->device_info.max_support_vgpus = 8;
 	/* This function will grow large in GVT device model patches. */
 }
@@ -135,6 +135,9 @@ int intel_gvt_init_device(struct drm_i915_private *dev_priv)
 
 	gvt_dbg_core("init gvt device\n");
 
+	mutex_init(&gvt->lock);
+	gvt->dev_priv = dev_priv;
+
 	init_device_info(gvt);
 	/*
 	 * Other initialization of GVT components will be introduce here.

commit 0ad35fed618cec78af8f40cc47702e13e5ba82b1
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Jun 16 08:07:00 2016 -0400

    drm/i915: gvt: Introduce the basic architecture of GVT-g
    
    This patch introduces the very basic framework of GVT-g device model,
    includes basic prototypes, definitions, initialization.
    
    v12:
    - Call intel_gvt_init() in driver early initialization stage. (Chris)
    
    v8:
    - Remove the GVT idr and mutex in intel_gvt_host. (Joonas)
    
    v7:
    - Refine the URL link in Kconfig. (Joonas)
    - Refine the introduction of GVT-g host support in Kconfig. (Joonas)
    - Remove the macro GVT_ALIGN(), use round_down() instead. (Joonas)
    - Make "struct intel_gvt" a data member in struct drm_i915_private.(Joonas)
            - Remove {alloc, free}_gvt_device()
            - Rename intel_gvt_{create, destroy}_gvt_device()
            - Expost intel_gvt_init_host()
    - Remove the dummy "struct intel_gvt" declaration in intel_gvt.h (Joonas)
    
    v6:
    - Refine introduction in Kconfig. (Chris)
    - The exposed API functions will take struct intel_gvt * instead of
    void *. (Chris/Tvrtko)
    - Remove most memebers of strct intel_gvt_device_info. Will add them
    in the device model patches.(Chris)
    - Remove gvt_info() and gvt_err() in debug.h. (Chris)
    - Move GVT kernel parameter into i915_params. (Chris)
    - Remove include/drm/i915_gvt.h, as GVT-g will be built within i915.
    - Remove the redundant struct i915_gvt *, as the functions in i915
    will directly take struct intel_gvt *.
    - Add more comments for reviewer.
    
    v5:
    Take Tvrtko's comments:
    - Fix the misspelled words in Kconfig
    - Let functions take drm_i915_private * instead of struct drm_device *
    - Remove redundant prints/local varible initialization
    
    v3:
    Take Joonas' comments:
    - Change file name i915_gvt.* to intel_gvt.*
    - Move GVT kernel parameter into intel_gvt.c
    - Remove redundant debug macros
    - Change error handling style
    - Add introductions for some stub functions
    - Introduce drm/i915_gvt.h.
    
    Take Kevin's comments:
    - Move GVT-g host/guest check into intel_vgt_balloon in i915_gem_gtt.c
    
    v2:
    - Introduce i915_gvt.c.
    It's necessary to introduce the stubs between i915 driver and GVT-g host,
    as GVT-g components is configurable in kernel config. When disabled, the
    stubs here do nothing.
    
    Take Joonas' comments:
    - Replace boolean return value with int.
    - Replace customized info/warn/debug macros with DRM macros.
    - Document all non-static functions like i915.
    - Remove empty and unused functions.
    - Replace magic number with marcos.
    - Set GVT-g in kernel config to "n" by default.
    
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466078825-6662-5-git-send-email-zhi.a.wang@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c
new file mode 100644
index 000000000000..927f4579f5b6
--- /dev/null
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright(c) 2011-2016 Intel Corporation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <xen/xen.h>
+
+#include "i915_drv.h"
+
+struct intel_gvt_host intel_gvt_host;
+
+static const char * const supported_hypervisors[] = {
+	[INTEL_GVT_HYPERVISOR_XEN] = "XEN",
+	[INTEL_GVT_HYPERVISOR_KVM] = "KVM",
+};
+
+/**
+ * intel_gvt_init_host - Load MPT modules and detect if we're running in host
+ * @gvt: intel gvt device
+ *
+ * This function is called at the driver loading stage. If failed to find a
+ * loadable MPT module or detect currently we're running in a VM, then GVT-g
+ * will be disabled
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ *
+ */
+int intel_gvt_init_host(void)
+{
+	if (intel_gvt_host.initialized)
+		return 0;
+
+	/* Xen DOM U */
+	if (xen_domain() && !xen_initial_domain())
+		return -ENODEV;
+
+	/* Try to load MPT modules for hypervisors */
+	if (xen_initial_domain()) {
+		/* In Xen dom0 */
+		intel_gvt_host.mpt = try_then_request_module(
+				symbol_get(xengt_mpt), "xengt");
+		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_XEN;
+	} else {
+		/* not in Xen. Try KVMGT */
+		intel_gvt_host.mpt = try_then_request_module(
+				symbol_get(kvmgt_mpt), "kvm");
+		intel_gvt_host.hypervisor_type = INTEL_GVT_HYPERVISOR_KVM;
+	}
+
+	/* Fail to load MPT modules - bail out */
+	if (!intel_gvt_host.mpt)
+		return -EINVAL;
+
+	/* Try to detect if we're running in host instead of VM. */
+	if (!intel_gvt_hypervisor_detect_host())
+		return -ENODEV;
+
+	gvt_dbg_core("Running with hypervisor %s in host mode\n",
+			supported_hypervisors[intel_gvt_host.hypervisor_type]);
+
+	intel_gvt_host.initialized = true;
+	return 0;
+}
+
+static void init_device_info(struct intel_gvt *gvt)
+{
+	if (IS_BROADWELL(gvt->dev_priv))
+		gvt->device_info.max_support_vgpus = 8;
+	/* This function will grow large in GVT device model patches. */
+}
+
+/**
+ * intel_gvt_clean_device - clean a GVT device
+ * @gvt: intel gvt device
+ *
+ * This function is called at the driver unloading stage, to free the
+ * resources owned by a GVT device.
+ *
+ */
+void intel_gvt_clean_device(struct drm_i915_private *dev_priv)
+{
+	struct intel_gvt *gvt = &dev_priv->gvt;
+
+	if (WARN_ON(!gvt->initialized))
+		return;
+
+	/* Other de-initialization of GVT components will be introduced. */
+
+	gvt->initialized = false;
+}
+
+/**
+ * intel_gvt_init_device - initialize a GVT device
+ * @dev_priv: drm i915 private data
+ *
+ * This function is called at the initialization stage, to initialize
+ * necessary GVT components.
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ *
+ */
+int intel_gvt_init_device(struct drm_i915_private *dev_priv)
+{
+	struct intel_gvt *gvt = &dev_priv->gvt;
+	/*
+	 * Cannot initialize GVT device without intel_gvt_host gets
+	 * initialized first.
+	 */
+	if (WARN_ON(!intel_gvt_host.initialized))
+		return -EINVAL;
+
+	if (WARN_ON(gvt->initialized))
+		return -EEXIST;
+
+	gvt_dbg_core("init gvt device\n");
+
+	init_device_info(gvt);
+	/*
+	 * Other initialization of GVT components will be introduce here.
+	 */
+	gvt_dbg_core("gvt device creation is done\n");
+	gvt->initialized = true;
+	return 0;
+}
