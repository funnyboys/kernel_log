commit a291e4fba259a56a6a274c1989997acb6f0bb03a
Author: Colin Xu <colin.xu@intel.com>
Date:   Mon Jun 1 11:55:56 2020 +0800

    drm/i915/gvt: Use GFP_ATOMIC instead of GFP_KERNEL in atomic context
    
    GFP_KERNEL flag specifies a normal kernel allocation in which executing
    in process context without any locks and can sleep.
    mmio_diff takes sometime to finish all the diff compare and it has
    locks, continue using GFP_KERNEL will output below trace if LOCKDEP
    enabled.
    
    Use GFP_ATOMIC instead.
    
    V2: Rebase.
    
    =====================================================
    WARNING: SOFTIRQ-safe -> SOFTIRQ-unsafe lock order detected
    5.7.0-rc2 #400 Not tainted
    -----------------------------------------------------
    is trying to acquire:
    ffffffffb47bea20 (fs_reclaim){+.+.}-{0:0}, at: fs_reclaim_acquire.part.0+0x0/0x30
    
                   and this task is already holding:
    ffff88845b85cc90 (&gvt->scheduler.mmio_context_lock){+.-.}-{2:2}, at: vgpu_mmio_diff_show+0xcf/0x2e0
    which would create a new lock dependency:
     (&gvt->scheduler.mmio_context_lock){+.-.}-{2:2} -> (fs_reclaim){+.+.}-{0:0}
    
                   but this new dependency connects a SOFTIRQ-irq-safe lock:
     (&gvt->scheduler.mmio_context_lock){+.-.}-{2:2}
    
                   ... which became SOFTIRQ-irq-safe at:
      lock_acquire+0x175/0x4e0
      _raw_spin_lock_irqsave+0x2b/0x40
      shadow_context_status_change+0xfe/0x2f0
      notifier_call_chain+0x6a/0xa0
      __atomic_notifier_call_chain+0x5f/0xf0
      execlists_schedule_out+0x42a/0x820
      process_csb+0xe7/0x3e0
      execlists_submission_tasklet+0x5c/0x1d0
      tasklet_action_common.isra.0+0xeb/0x260
      __do_softirq+0x11d/0x56f
      irq_exit+0xf6/0x100
      do_IRQ+0x7f/0x160
      ret_from_intr+0x0/0x2a
      cpuidle_enter_state+0xcd/0x5b0
      cpuidle_enter+0x37/0x60
      do_idle+0x337/0x3f0
      cpu_startup_entry+0x14/0x20
      start_kernel+0x58b/0x5c5
      secondary_startup_64+0xa4/0xb0
    
                   to a SOFTIRQ-irq-unsafe lock:
     (fs_reclaim){+.+.}-{0:0}
    
                   ... which became SOFTIRQ-irq-unsafe at:
    ...
      lock_acquire+0x175/0x4e0
      fs_reclaim_acquire.part.0+0x20/0x30
      kmem_cache_alloc_node_trace+0x2e/0x290
      alloc_worker+0x2b/0xb0
      init_rescuer.part.0+0x17/0xe0
      workqueue_init+0x293/0x3bb
      kernel_init_freeable+0x149/0x325
      kernel_init+0x8/0x116
      ret_from_fork+0x3a/0x50
    
                   other info that might help us debug this:
    
     Possible interrupt unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(fs_reclaim);
                                   local_irq_disable();
                                   lock(&gvt->scheduler.mmio_context_lock);
                                   lock(fs_reclaim);
      <Interrupt>
        lock(&gvt->scheduler.mmio_context_lock);
    
                    *** DEADLOCK ***
    
    3 locks held by cat/1439:
     #0: ffff888444a23698 (&p->lock){+.+.}-{3:3}, at: seq_read+0x49/0x680
     #1: ffff88845b858068 (&gvt->lock){+.+.}-{3:3}, at: vgpu_mmio_diff_show+0xc7/0x2e0
     #2: ffff88845b85cc90 (&gvt->scheduler.mmio_context_lock){+.-.}-{2:2}, at: vgpu_mmio_diff_show+0xcf/0x2e0
    
                   the dependencies between SOFTIRQ-irq-safe lock and the holding lock:
    -> (&gvt->scheduler.mmio_context_lock){+.-.}-{2:2} ops: 31 {
       HARDIRQ-ON-W at:
                        lock_acquire+0x175/0x4e0
                        _raw_spin_lock_bh+0x2f/0x40
                        vgpu_mmio_diff_show+0xcf/0x2e0
                        seq_read+0x242/0x680
                        full_proxy_read+0x95/0xc0
                        vfs_read+0xc2/0x1b0
                        ksys_read+0xc4/0x160
                        do_syscall_64+0x63/0x290
                        entry_SYSCALL_64_after_hwframe+0x49/0xb3
       IN-SOFTIRQ-W at:
                        lock_acquire+0x175/0x4e0
                        _raw_spin_lock_irqsave+0x2b/0x40
                        shadow_context_status_change+0xfe/0x2f0
                        notifier_call_chain+0x6a/0xa0
                        __atomic_notifier_call_chain+0x5f/0xf0
                        execlists_schedule_out+0x42a/0x820
                        process_csb+0xe7/0x3e0
                        execlists_submission_tasklet+0x5c/0x1d0
                        tasklet_action_common.isra.0+0xeb/0x260
                        __do_softirq+0x11d/0x56f
                        irq_exit+0xf6/0x100
                        do_IRQ+0x7f/0x160
                        ret_from_intr+0x0/0x2a
                        cpuidle_enter_state+0xcd/0x5b0
                        cpuidle_enter+0x37/0x60
                        do_idle+0x337/0x3f0
                        cpu_startup_entry+0x14/0x20
                        start_kernel+0x58b/0x5c5
                        secondary_startup_64+0xa4/0xb0
       INITIAL USE at:
                       lock_acquire+0x175/0x4e0
                       _raw_spin_lock_irqsave+0x2b/0x40
                       shadow_context_status_change+0xfe/0x2f0
                       notifier_call_chain+0x6a/0xa0
                       __atomic_notifier_call_chain+0x5f/0xf0
                       execlists_schedule_in+0x2c8/0x690
                       __execlists_submission_tasklet+0x1303/0x1930
                       execlists_submit_request+0x1e7/0x230
                       submit_notify+0x105/0x2a4
                       __i915_sw_fence_complete+0xaa/0x380
                       __engine_park+0x313/0x5a0
                       ____intel_wakeref_put_last+0x3e/0x90
                       intel_gt_resume+0x41e/0x440
                       intel_gt_init+0x283/0xbc0
                       i915_gem_init+0x197/0x240
                       i915_driver_probe+0xc2d/0x12e0
                       i915_pci_probe+0xa2/0x1e0
                       local_pci_probe+0x6f/0xb0
                       pci_device_probe+0x171/0x230
                       really_probe+0x17a/0x380
                       driver_probe_device+0x70/0xf0
                       device_driver_attach+0x82/0x90
                       __driver_attach+0x60/0x100
                       bus_for_each_dev+0xe4/0x140
                       bus_add_driver+0x257/0x2a0
                       driver_register+0xd3/0x150
                       i915_init+0x6d/0x80
                       do_one_initcall+0xb8/0x3a0
                       kernel_init_freeable+0x2b4/0x325
                       kernel_init+0x8/0x116
                       ret_from_fork+0x3a/0x50
     }
    __key.77812+0x0/0x40
     ... acquired at:
       lock_acquire+0x175/0x4e0
       fs_reclaim_acquire.part.0+0x20/0x30
       kmem_cache_alloc_trace+0x2e/0x260
       mmio_diff_handler+0xc0/0x150
       intel_gvt_for_each_tracked_mmio+0x7b/0x140
       vgpu_mmio_diff_show+0x111/0x2e0
       seq_read+0x242/0x680
       full_proxy_read+0x95/0xc0
       vfs_read+0xc2/0x1b0
       ksys_read+0xc4/0x160
       do_syscall_64+0x63/0x290
       entry_SYSCALL_64_after_hwframe+0x49/0xb3
    
                   the dependencies between the lock to be acquired
     and SOFTIRQ-irq-unsafe lock:
    -> (fs_reclaim){+.+.}-{0:0} ops: 1999031 {
       HARDIRQ-ON-W at:
                        lock_acquire+0x175/0x4e0
                        fs_reclaim_acquire.part.0+0x20/0x30
                        kmem_cache_alloc_node_trace+0x2e/0x290
                        alloc_worker+0x2b/0xb0
                        init_rescuer.part.0+0x17/0xe0
                        workqueue_init+0x293/0x3bb
                        kernel_init_freeable+0x149/0x325
                        kernel_init+0x8/0x116
                        ret_from_fork+0x3a/0x50
       SOFTIRQ-ON-W at:
                        lock_acquire+0x175/0x4e0
                        fs_reclaim_acquire.part.0+0x20/0x30
                        kmem_cache_alloc_node_trace+0x2e/0x290
                        alloc_worker+0x2b/0xb0
                        init_rescuer.part.0+0x17/0xe0
                        workqueue_init+0x293/0x3bb
                        kernel_init_freeable+0x149/0x325
                        kernel_init+0x8/0x116
                        ret_from_fork+0x3a/0x50
       INITIAL USE at:
                       lock_acquire+0x175/0x4e0
                       fs_reclaim_acquire.part.0+0x20/0x30
                       kmem_cache_alloc_node_trace+0x2e/0x290
                       alloc_worker+0x2b/0xb0
                       init_rescuer.part.0+0x17/0xe0
                       workqueue_init+0x293/0x3bb
                       kernel_init_freeable+0x149/0x325
                       kernel_init+0x8/0x116
                       ret_from_fork+0x3a/0x50
     }
    __fs_reclaim_map+0x0/0x60
     ... acquired at:
       lock_acquire+0x175/0x4e0
       fs_reclaim_acquire.part.0+0x20/0x30
       kmem_cache_alloc_trace+0x2e/0x260
       mmio_diff_handler+0xc0/0x150
       intel_gvt_for_each_tracked_mmio+0x7b/0x140
       vgpu_mmio_diff_show+0x111/0x2e0
       seq_read+0x242/0x680
       full_proxy_read+0x95/0xc0
       vfs_read+0xc2/0x1b0
       ksys_read+0xc4/0x160
       do_syscall_64+0x63/0x290
       entry_SYSCALL_64_after_hwframe+0x49/0xb3
    
                   stack backtrace:
    CPU: 5 PID: 1439 Comm: cat Not tainted 5.7.0-rc2 #400
    Hardware name: Intel(R) Client Systems NUC8i7BEH/NUC8BEB, BIOS BECFL357.86A.0056.2018.1128.1717 11/28/2018
    Call Trace:
     dump_stack+0x97/0xe0
     check_irq_usage.cold+0x428/0x434
     ? check_usage_forwards+0x2c0/0x2c0
     ? class_equal+0x11/0x20
     ? __bfs+0xd2/0x2d0
     ? in_any_class_list+0xa0/0xa0
     ? check_path+0x22/0x40
     ? check_noncircular+0x150/0x2b0
     ? print_circular_bug.isra.0+0x1b0/0x1b0
     ? mark_lock+0x13d/0xc50
     ? __lock_acquire+0x1e32/0x39b0
     __lock_acquire+0x1e32/0x39b0
     ? timerqueue_add+0xc1/0x130
     ? register_lock_class+0xa60/0xa60
     ? mark_lock+0x13d/0xc50
     lock_acquire+0x175/0x4e0
     ? __zone_pcp_update+0x80/0x80
     ? check_flags.part.0+0x210/0x210
     ? mark_held_locks+0x65/0x90
     ? _raw_spin_unlock_irqrestore+0x32/0x40
     ? lockdep_hardirqs_on+0x190/0x290
     ? fwtable_read32+0x163/0x480
     ? mmio_diff_handler+0xc0/0x150
     fs_reclaim_acquire.part.0+0x20/0x30
     ? __zone_pcp_update+0x80/0x80
     kmem_cache_alloc_trace+0x2e/0x260
     mmio_diff_handler+0xc0/0x150
     ? vgpu_mmio_diff_open+0x30/0x30
     intel_gvt_for_each_tracked_mmio+0x7b/0x140
     vgpu_mmio_diff_show+0x111/0x2e0
     ? mmio_diff_handler+0x150/0x150
     ? rcu_read_lock_sched_held+0xa0/0xb0
     ? rcu_read_lock_bh_held+0xc0/0xc0
     ? kasan_unpoison_shadow+0x33/0x40
     ? __kasan_kmalloc.constprop.0+0xc2/0xd0
     seq_read+0x242/0x680
     ? debugfs_locked_down.isra.0+0x70/0x70
     full_proxy_read+0x95/0xc0
     vfs_read+0xc2/0x1b0
     ksys_read+0xc4/0x160
     ? kernel_write+0xb0/0xb0
     ? mark_held_locks+0x24/0x90
     do_syscall_64+0x63/0x290
     entry_SYSCALL_64_after_hwframe+0x49/0xb3
    RIP: 0033:0x7ffbe3e6efb2
    Code: c0 e9 c2 fe ff ff 50 48 8d 3d ca cb 0a 00 e8 f5 19 02 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24
    RSP: 002b:00007ffd021c08a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
    RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007ffbe3e6efb2
    RDX: 0000000000020000 RSI: 00007ffbe34cd000 RDI: 0000000000000003
    RBP: 00007ffbe34cd000 R08: 00007ffbe34cc010 R09: 0000000000000000
    R10: 0000000000000022 R11: 0000000000000246 R12: 0000562b6f0a11f0
    R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000
    ------------[ cut here ]------------
    
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200601035556.19999-1-colin.xu@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index ec47d4114554..62e6a14ad58e 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -66,7 +66,7 @@ static inline int mmio_diff_handler(struct intel_gvt *gvt,
 	vreg = vgpu_vreg(param->vgpu, offset);
 
 	if (preg != vreg) {
-		node = kmalloc(sizeof(*node), GFP_KERNEL);
+		node = kmalloc(sizeof(*node), GFP_ATOMIC);
 		if (!node)
 			return -ENOMEM;
 

commit a61ac1e75105a077ec1efd6923ae3c619f862304
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 6 10:08:10 2020 +0800

    drm/i915/gvt: Wean gvt off using dev_priv
    
    Teach gvt to use intel_gt directly as it currently assumes direct HW
    access.
    
    [Zhenyu: rebase, fix compiling]
    
    Cc: Ding Zhuocheng <zhuocheng.ding@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200304032307.2983-3-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 874ee1de6b49..ec47d4114554 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -58,12 +58,11 @@ static int mmio_offset_compare(void *priv,
 static inline int mmio_diff_handler(struct intel_gvt *gvt,
 				    u32 offset, void *data)
 {
-	struct drm_i915_private *i915 = gvt->dev_priv;
 	struct mmio_diff_param *param = data;
 	struct diff_mmio *node;
 	u32 preg, vreg;
 
-	preg = intel_uncore_read_notrace(&i915->uncore, _MMIO(offset));
+	preg = intel_uncore_read_notrace(gvt->gt->uncore, _MMIO(offset));
 	vreg = vgpu_vreg(param->vgpu, offset);
 
 	if (preg != vreg) {
@@ -98,10 +97,10 @@ static int vgpu_mmio_diff_show(struct seq_file *s, void *unused)
 	mutex_lock(&gvt->lock);
 	spin_lock_bh(&gvt->scheduler.mmio_context_lock);
 
-	mmio_hw_access_pre(gvt->dev_priv);
+	mmio_hw_access_pre(gvt->gt);
 	/* Recognize all the diff mmios to list. */
 	intel_gvt_for_each_tracked_mmio(gvt, mmio_diff_handler, &param);
-	mmio_hw_access_post(gvt->dev_priv);
+	mmio_hw_access_post(gvt->gt);
 
 	spin_unlock_bh(&gvt->scheduler.mmio_context_lock);
 	mutex_unlock(&gvt->lock);
@@ -186,7 +185,7 @@ void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu)
  */
 void intel_gvt_debugfs_init(struct intel_gvt *gvt)
 {
-	struct drm_minor *minor = gvt->dev_priv->drm.primary;
+	struct drm_minor *minor = gvt->gt->i915->drm.primary;
 
 	gvt->debugfs_root = debugfs_create_dir("gvt", minor->debugfs_root);
 

commit aa444fc7fb887c205c31a38d398f95467a493e66
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Mar 4 11:23:05 2020 +0800

    drm/i915/gvt: cleanup debugfs scan_nonprivbb
    
    Remove extra chatty message for debugfs scan_nonprivbb which is used
    to enable scan for non privileged batch on specific engine. Just write
    target i915 engine mask instead.
    
    Cc: Ding Zhuocheng <zhuocheng.ding@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20200304032307.2983-1-zhenyuw@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 285f6011a537..874ee1de6b49 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -128,6 +128,7 @@ static int
 vgpu_scan_nonprivbb_get(void *data, u64 *val)
 {
 	struct intel_vgpu *vgpu = (struct intel_vgpu *)data;
+
 	*val = vgpu->scan_nonprivbb;
 	return 0;
 }
@@ -142,42 +143,7 @@ static int
 vgpu_scan_nonprivbb_set(void *data, u64 val)
 {
 	struct intel_vgpu *vgpu = (struct intel_vgpu *)data;
-	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
-	enum intel_engine_id id;
-	char buf[128], *s;
-	int len;
-
-	val &= (1 << I915_NUM_ENGINES) - 1;
-
-	if (vgpu->scan_nonprivbb == val)
-		return 0;
-
-	if (!val)
-		goto done;
-
-	len = sprintf(buf,
-		"gvt: vgpu %d turns on non-privileged batch buffers scanning on Engines:",
-		vgpu->id);
-
-	s = buf + len;
-
-	for (id = 0; id < I915_NUM_ENGINES; id++) {
-		struct intel_engine_cs *engine;
-
-		engine = dev_priv->engine[id];
-		if (engine && (val & (1 << id))) {
-			len = snprintf(s, 4, "%d, ", engine->id);
-			s += len;
-		} else
-			val &=  ~(1 << id);
-	}
-
-	if (val)
-		sprintf(s, "low performance expected.");
-
-	pr_warn("%s\n", buf);
 
-done:
 	vgpu->scan_nonprivbb = val;
 	return 0;
 }

commit f8871ec8fc73f57295703a8d61c8c33d7ab4805b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:34:19 2019 +0200

    drm/i915/gvt: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Because there is no need to check these functions, a number of local
    functions can be made to return void to simplify things as nothing can
    fail.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: intel-gvt-dev@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 2fb7b73b260d..285f6011a537 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -189,36 +189,19 @@ DEFINE_SIMPLE_ATTRIBUTE(vgpu_scan_nonprivbb_fops,
 /**
  * intel_gvt_debugfs_add_vgpu - register debugfs entries for a vGPU
  * @vgpu: a vGPU
- *
- * Returns:
- * Zero on success, negative error code if failed.
  */
-int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
+void intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
 {
-	struct dentry *ent;
 	char name[16] = "";
 
 	snprintf(name, 16, "vgpu%d", vgpu->id);
 	vgpu->debugfs = debugfs_create_dir(name, vgpu->gvt->debugfs_root);
-	if (!vgpu->debugfs)
-		return -ENOMEM;
-
-	ent = debugfs_create_bool("active", 0444, vgpu->debugfs,
-				  &vgpu->active);
-	if (!ent)
-		return -ENOMEM;
-
-	ent = debugfs_create_file("mmio_diff", 0444, vgpu->debugfs,
-				  vgpu, &vgpu_mmio_diff_fops);
-	if (!ent)
-		return -ENOMEM;
 
-	ent = debugfs_create_file("scan_nonprivbb", 0644, vgpu->debugfs,
-				 vgpu, &vgpu_scan_nonprivbb_fops);
-	if (!ent)
-		return -ENOMEM;
-
-	return 0;
+	debugfs_create_bool("active", 0444, vgpu->debugfs, &vgpu->active);
+	debugfs_create_file("mmio_diff", 0444, vgpu->debugfs, vgpu,
+			    &vgpu_mmio_diff_fops);
+	debugfs_create_file("scan_nonprivbb", 0644, vgpu->debugfs, vgpu,
+			    &vgpu_scan_nonprivbb_fops);
 }
 
 /**
@@ -234,27 +217,15 @@ void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu)
 /**
  * intel_gvt_debugfs_init - register gvt debugfs root entry
  * @gvt: GVT device
- *
- * Returns:
- * zero on success, negative if failed.
  */
-int intel_gvt_debugfs_init(struct intel_gvt *gvt)
+void intel_gvt_debugfs_init(struct intel_gvt *gvt)
 {
 	struct drm_minor *minor = gvt->dev_priv->drm.primary;
-	struct dentry *ent;
 
 	gvt->debugfs_root = debugfs_create_dir("gvt", minor->debugfs_root);
-	if (!gvt->debugfs_root) {
-		gvt_err("Cannot create debugfs dir\n");
-		return -ENOMEM;
-	}
 
-	ent = debugfs_create_ulong("num_tracked_mmio", 0444, gvt->debugfs_root,
-				   &gvt->mmio.num_tracked_mmio);
-	if (!ent)
-		return -ENOMEM;
-
-	return 0;
+	debugfs_create_ulong("num_tracked_mmio", 0444, gvt->debugfs_root,
+			     &gvt->mmio.num_tracked_mmio);
 }
 
 /**

commit 5a31d30b22c04615329132f0c7fa20b4b6079b43
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Jun 11 11:45:47 2019 +0100

    drm/i915: Remove I915_READ_NOTRACE
    
    Only a few call sites remain which have been converted to uncore mmio
    accessors and so the macro can be removed.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190611104548.30545-5-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 8a9606f91e68..2fb7b73b260d 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -58,12 +58,12 @@ static int mmio_offset_compare(void *priv,
 static inline int mmio_diff_handler(struct intel_gvt *gvt,
 				    u32 offset, void *data)
 {
-	struct drm_i915_private *dev_priv = gvt->dev_priv;
+	struct drm_i915_private *i915 = gvt->dev_priv;
 	struct mmio_diff_param *param = data;
 	struct diff_mmio *node;
 	u32 preg, vreg;
 
-	preg = I915_READ_NOTRACE(_MMIO(offset));
+	preg = intel_uncore_read_notrace(&i915->uncore, _MMIO(offset));
 	vreg = vgpu_vreg(param->vgpu, offset);
 
 	if (preg != vreg) {

commit 4feeea1d8d7713c5838d99c1fdfcc2e90c0f977d
Author: Aleksei Gimbitskii <aleksei.gimbitskii@intel.com>
Date:   Tue Apr 23 15:04:10 2019 +0300

    drm/i915/gvt: Use snprintf() to prevent possible buffer overflow.
    
    For printing the intel_vgpu->id, a buffer with fixed length is allocated
    on the stack. But if vgpu->id is greater than 6 characters, the buffer
    overflow will happen. Even the string of the amount of max vgpu is less
    that the length buffer right now, it's better to replace sprintf() with
    snprintf().
    
    v2:
    - Increase the size of the buffer. (Colin Xu)
    
    This patch fixed the critical issue #673 reported by klocwork.
    
    Signed-off-by: Aleksei Gimbitskii <aleksei.gimbitskii@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Colin Xu <colin.xu@intel.com>
    Reviewed-by: Colin Xu <colin.xu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 2ec89bcb59f1..8a9606f91e68 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -196,9 +196,9 @@ DEFINE_SIMPLE_ATTRIBUTE(vgpu_scan_nonprivbb_fops,
 int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
 {
 	struct dentry *ent;
-	char name[10] = "";
+	char name[16] = "";
 
-	sprintf(name, "vgpu%d", vgpu->id);
+	snprintf(name, 16, "vgpu%d", vgpu->id);
 	vgpu->debugfs = debugfs_create_dir(name, vgpu->gvt->debugfs_root);
 	if (!vgpu->debugfs)
 		return -ENOMEM;

commit 96bebe39b2f4533af14c509061cd2b551ca81e8d
Author: Zhao Yan <yan.y.zhao@intel.com>
Date:   Wed Apr 4 13:57:09 2018 +0800

    drm/i915/gvt: scan non-privileged batch buffer for debug purpose
    
    For perfomance purpose, scanning of non-privileged batch buffer is turned
    off by default. But for debugging purpose, it can be turned on via debugfs.
    After scanning, we submit the original non-privileged batch buffer into
    hardware, so that the scanning is only a peeking window of guest submitted
    commands and will not affect the execution results.
    
    v4:
    - refine debugfs print format&content (zhenyu wang)
    - print engine id instread of engine name to prevent potential memory leak
      in debugfs warning message. (zhenyu wang)
    
    v3:
    - change vgpu->scan_nonprivbb from type bool to u32, so it is able to
      selectively turn on/off scanning of non-privileged batch buffer on engine
      level. e.g.
      if vgpu->scan_nonprivbb=3, then it will scan non-privileged batch buffer
      on engine 0 and 1.
    - in debugfs interface to set vgpu->scan_nonprivbb, print warning message
      to warn user and explicitly tell state change in kernel log (zhenyu wang)
    v2:
    - rebase
    - update comments for start_gma_offset (henry)
    
    Signed-off-by: Zhao Yan <yan.y.zhao@intel.com>
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index f7d0078eb61b..2ec89bcb59f1 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -124,6 +124,68 @@ static int vgpu_mmio_diff_show(struct seq_file *s, void *unused)
 }
 DEFINE_SHOW_ATTRIBUTE(vgpu_mmio_diff);
 
+static int
+vgpu_scan_nonprivbb_get(void *data, u64 *val)
+{
+	struct intel_vgpu *vgpu = (struct intel_vgpu *)data;
+	*val = vgpu->scan_nonprivbb;
+	return 0;
+}
+
+/*
+ * set/unset bit engine_id of vgpu->scan_nonprivbb to turn on/off scanning
+ * of non-privileged batch buffer. e.g.
+ * if vgpu->scan_nonprivbb=3, then it will scan non-privileged batch buffer
+ * on engine 0 and 1.
+ */
+static int
+vgpu_scan_nonprivbb_set(void *data, u64 val)
+{
+	struct intel_vgpu *vgpu = (struct intel_vgpu *)data;
+	struct drm_i915_private *dev_priv = vgpu->gvt->dev_priv;
+	enum intel_engine_id id;
+	char buf[128], *s;
+	int len;
+
+	val &= (1 << I915_NUM_ENGINES) - 1;
+
+	if (vgpu->scan_nonprivbb == val)
+		return 0;
+
+	if (!val)
+		goto done;
+
+	len = sprintf(buf,
+		"gvt: vgpu %d turns on non-privileged batch buffers scanning on Engines:",
+		vgpu->id);
+
+	s = buf + len;
+
+	for (id = 0; id < I915_NUM_ENGINES; id++) {
+		struct intel_engine_cs *engine;
+
+		engine = dev_priv->engine[id];
+		if (engine && (val & (1 << id))) {
+			len = snprintf(s, 4, "%d, ", engine->id);
+			s += len;
+		} else
+			val &=  ~(1 << id);
+	}
+
+	if (val)
+		sprintf(s, "low performance expected.");
+
+	pr_warn("%s\n", buf);
+
+done:
+	vgpu->scan_nonprivbb = val;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(vgpu_scan_nonprivbb_fops,
+			vgpu_scan_nonprivbb_get, vgpu_scan_nonprivbb_set,
+			"0x%llx\n");
+
 /**
  * intel_gvt_debugfs_add_vgpu - register debugfs entries for a vGPU
  * @vgpu: a vGPU
@@ -151,6 +213,11 @@ int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
 	if (!ent)
 		return -ENOMEM;
 
+	ent = debugfs_create_file("scan_nonprivbb", 0644, vgpu->debugfs,
+				 vgpu, &vgpu_scan_nonprivbb_fops);
+	if (!ent)
+		return -ENOMEM;
+
 	return 0;
 }
 

commit e4006713d16567c203ba710f6a2b709ed6107db5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 16 16:12:13 2018 +0200

    i915: Re-use DEFINE_SHOW_ATTRIBUTE() macro
    
    ...instead of open coding file operations followed by custom ->open()
    callbacks per each attribute.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180316141213.38774-1-andriy.shevchenko@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 32a66dfdf112..f7d0078eb61b 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -122,18 +122,7 @@ static int vgpu_mmio_diff_show(struct seq_file *s, void *unused)
 	seq_printf(s, "Total: %d, Diff: %d\n", param.total, param.diff);
 	return 0;
 }
-
-static int vgpu_mmio_diff_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, vgpu_mmio_diff_show, inode->i_private);
-}
-
-static const struct file_operations vgpu_mmio_diff_fops = {
-	.open		= vgpu_mmio_diff_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(vgpu_mmio_diff);
 
 /**
  * intel_gvt_debugfs_add_vgpu - register debugfs entries for a vGPU

commit cea9083e35b2f771624a18126b10ef1fd7806040
Author: Changbin Du <changbin.du@intel.com>
Date:   Mon Oct 23 11:46:44 2017 +0800

    drm/i915/gvt: Add new debugfs tool mmio_diff
    
    This new debugfs entry is used to figure out which registers of vGPU
    is different to host. It is a useful tool for new platform enabling
    and debugging. When read this entry, all the diff mmio are recognized
    and sorted by mmio offset. Besides, the bit positions of different
    value are listed in 'Diff' column. Here is a show:
    
    $ sudo cat ./mmio_diff
    Offset   HW       vGPU     Diff
    00002030 000025f8 00000000 3-8,10,13
    00002034 012025f8 00000000 3-8,10,13,21,24
    00002038 027fb000 00000000 12-13,15-22,25
    0000203c 00003000 00000000 12-13
    00002054 0000000a 00000040 1,3,6
    00002074 012025f8 00000000 3-8,10,13,21,24
    00002080 fffe6000 00000000 13-14,17-31
    000020a8 fffffeff ffffffff 8
    000020d4 00000004 00000000 2
    ....
    00145974 eb42718c 010c11b0 2-5,13-14,17-19,22,25,27,29-31
    00145978 0000002f 0000002a 0,2
    0014597c 0000002f 0000002a 0,2
    00145980 0000002b 00000028 0-1
    00145984 a5a87c9e b27d20c0 1-4,6,10-12,14,16,18,20,22-26,28
    001459c0 88390000 883c0000 16,18
    00146200 88350000 883a0000 16-19
    Total: 72432, Diff: 901
    
    v3: fix a typo.
    v2: add mmio_hw_access_pre/post().
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
index 02acd5842605..32a66dfdf112 100644
--- a/drivers/gpu/drm/i915/gvt/debugfs.c
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -21,9 +21,119 @@
  * SOFTWARE.
  */
 #include <linux/debugfs.h>
+#include <linux/list_sort.h>
 #include "i915_drv.h"
 #include "gvt.h"
 
+struct mmio_diff_param {
+	struct intel_vgpu *vgpu;
+	int total;
+	int diff;
+	struct list_head diff_mmio_list;
+};
+
+struct diff_mmio {
+	struct list_head node;
+	u32 offset;
+	u32 preg;
+	u32 vreg;
+};
+
+/* Compare two diff_mmio items. */
+static int mmio_offset_compare(void *priv,
+	struct list_head *a, struct list_head *b)
+{
+	struct diff_mmio *ma;
+	struct diff_mmio *mb;
+
+	ma = container_of(a, struct diff_mmio, node);
+	mb = container_of(b, struct diff_mmio, node);
+	if (ma->offset < mb->offset)
+		return -1;
+	else if (ma->offset > mb->offset)
+		return 1;
+	return 0;
+}
+
+static inline int mmio_diff_handler(struct intel_gvt *gvt,
+				    u32 offset, void *data)
+{
+	struct drm_i915_private *dev_priv = gvt->dev_priv;
+	struct mmio_diff_param *param = data;
+	struct diff_mmio *node;
+	u32 preg, vreg;
+
+	preg = I915_READ_NOTRACE(_MMIO(offset));
+	vreg = vgpu_vreg(param->vgpu, offset);
+
+	if (preg != vreg) {
+		node = kmalloc(sizeof(*node), GFP_KERNEL);
+		if (!node)
+			return -ENOMEM;
+
+		node->offset = offset;
+		node->preg = preg;
+		node->vreg = vreg;
+		list_add(&node->node, &param->diff_mmio_list);
+		param->diff++;
+	}
+	param->total++;
+	return 0;
+}
+
+/* Show the all the different values of tracked mmio. */
+static int vgpu_mmio_diff_show(struct seq_file *s, void *unused)
+{
+	struct intel_vgpu *vgpu = s->private;
+	struct intel_gvt *gvt = vgpu->gvt;
+	struct mmio_diff_param param = {
+		.vgpu = vgpu,
+		.total = 0,
+		.diff = 0,
+	};
+	struct diff_mmio *node, *next;
+
+	INIT_LIST_HEAD(&param.diff_mmio_list);
+
+	mutex_lock(&gvt->lock);
+	spin_lock_bh(&gvt->scheduler.mmio_context_lock);
+
+	mmio_hw_access_pre(gvt->dev_priv);
+	/* Recognize all the diff mmios to list. */
+	intel_gvt_for_each_tracked_mmio(gvt, mmio_diff_handler, &param);
+	mmio_hw_access_post(gvt->dev_priv);
+
+	spin_unlock_bh(&gvt->scheduler.mmio_context_lock);
+	mutex_unlock(&gvt->lock);
+
+	/* In an ascending order by mmio offset. */
+	list_sort(NULL, &param.diff_mmio_list, mmio_offset_compare);
+
+	seq_printf(s, "%-8s %-8s %-8s %-8s\n", "Offset", "HW", "vGPU", "Diff");
+	list_for_each_entry_safe(node, next, &param.diff_mmio_list, node) {
+		u32 diff = node->preg ^ node->vreg;
+
+		seq_printf(s, "%08x %08x %08x %*pbl\n",
+			   node->offset, node->preg, node->vreg,
+			   32, &diff);
+		list_del(&node->node);
+		kfree(node);
+	}
+	seq_printf(s, "Total: %d, Diff: %d\n", param.total, param.diff);
+	return 0;
+}
+
+static int vgpu_mmio_diff_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, vgpu_mmio_diff_show, inode->i_private);
+}
+
+static const struct file_operations vgpu_mmio_diff_fops = {
+	.open		= vgpu_mmio_diff_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 /**
  * intel_gvt_debugfs_add_vgpu - register debugfs entries for a vGPU
@@ -47,6 +157,11 @@ int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
 	if (!ent)
 		return -ENOMEM;
 
+	ent = debugfs_create_file("mmio_diff", 0444, vgpu->debugfs,
+				  vgpu, &vgpu_mmio_diff_fops);
+	if (!ent)
+		return -ENOMEM;
+
 	return 0;
 }
 

commit bc7b0be316aebac42eb9e8e54c984609555944da
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Sep 26 16:19:13 2017 +0800

    drm/i915/gvt: Add basic debugfs infrastructure
    
    We need debugfs entry to expose some debug information of gvt and vGPUs.
    The first tool will be added is mmio-diff, which help to find the
    difference values of host and vGPU mmio. It's useful for platform
    enabling.
    
    This patch just add a basic debugfs infrastructure, each vGPU has its own
    sub-folder. Two simple attributes are created as a template.
    .
    ├── num_tracked_mmio
    ├── vgpu1
    |   └── active
    └── vgpu2
        └── active
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/debugfs.c b/drivers/gpu/drm/i915/gvt/debugfs.c
new file mode 100644
index 000000000000..02acd5842605
--- /dev/null
+++ b/drivers/gpu/drm/i915/gvt/debugfs.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright(c) 2011-2017 Intel Corporation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#include <linux/debugfs.h>
+#include "i915_drv.h"
+#include "gvt.h"
+
+
+/**
+ * intel_gvt_debugfs_add_vgpu - register debugfs entries for a vGPU
+ * @vgpu: a vGPU
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+int intel_gvt_debugfs_add_vgpu(struct intel_vgpu *vgpu)
+{
+	struct dentry *ent;
+	char name[10] = "";
+
+	sprintf(name, "vgpu%d", vgpu->id);
+	vgpu->debugfs = debugfs_create_dir(name, vgpu->gvt->debugfs_root);
+	if (!vgpu->debugfs)
+		return -ENOMEM;
+
+	ent = debugfs_create_bool("active", 0444, vgpu->debugfs,
+				  &vgpu->active);
+	if (!ent)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * intel_gvt_debugfs_remove_vgpu - remove debugfs entries of a vGPU
+ * @vgpu: a vGPU
+ */
+void intel_gvt_debugfs_remove_vgpu(struct intel_vgpu *vgpu)
+{
+	debugfs_remove_recursive(vgpu->debugfs);
+	vgpu->debugfs = NULL;
+}
+
+/**
+ * intel_gvt_debugfs_init - register gvt debugfs root entry
+ * @gvt: GVT device
+ *
+ * Returns:
+ * zero on success, negative if failed.
+ */
+int intel_gvt_debugfs_init(struct intel_gvt *gvt)
+{
+	struct drm_minor *minor = gvt->dev_priv->drm.primary;
+	struct dentry *ent;
+
+	gvt->debugfs_root = debugfs_create_dir("gvt", minor->debugfs_root);
+	if (!gvt->debugfs_root) {
+		gvt_err("Cannot create debugfs dir\n");
+		return -ENOMEM;
+	}
+
+	ent = debugfs_create_ulong("num_tracked_mmio", 0444, gvt->debugfs_root,
+				   &gvt->mmio.num_tracked_mmio);
+	if (!ent)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * intel_gvt_debugfs_clean - remove debugfs entries
+ * @gvt: GVT device
+ */
+void intel_gvt_debugfs_clean(struct intel_gvt *gvt)
+{
+	debugfs_remove_recursive(gvt->debugfs_root);
+	gvt->debugfs_root = NULL;
+}
