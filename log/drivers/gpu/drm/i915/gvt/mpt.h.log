commit 9f674c811740b5db4b34668b72d47f6e7b879b0a
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Fri Dec 13 11:23:14 2019 +0800

    drm/i915/gvt: Pin vgpu dma address before using
    
    Dma-buf display uses the vgpu dma address saved in the guest part GGTT
    table which is updated by vCPU thread. In host side, when the dma
    address is used by qemu ui thread, gvt-g must make sure the dma address
    is validated before letting it go to the HW. Invalid guest dma address
    will easily cause DMA fault and make GPU hang.
    
    v2: Rebase
    
    Fixes: e546e281d33d ("drm/i915/gvt: Dmabuf support for GVT-g")
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20191212141342.3417-1-tina.zhang@intel.com

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 0f9440128123..9ad224df9c68 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -254,6 +254,21 @@ static inline void intel_gvt_hypervisor_dma_unmap_guest_page(
 	intel_gvt_host.mpt->dma_unmap_guest_page(vgpu->handle, dma_addr);
 }
 
+/**
+ * intel_gvt_hypervisor_dma_pin_guest_page - pin guest dma buf
+ * @vgpu: a vGPU
+ * @dma_addr: guest dma addr
+ *
+ * Returns:
+ * 0 on success, negative error code if failed.
+ */
+static inline int
+intel_gvt_hypervisor_dma_pin_guest_page(struct intel_vgpu *vgpu,
+					dma_addr_t dma_addr)
+{
+	return intel_gvt_host.mpt->dma_pin_guest_page(vgpu->handle, dma_addr);
+}
+
 /**
  * intel_gvt_hypervisor_map_gfn_to_mfn - map a GFN region to MFN
  * @vgpu: a vGPU

commit c06de56121e3ac0f0f1f4a081c041654ffcacd62
Merge: 8d451a4b6e9f a3b22b9f11d9
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 18 13:27:15 2019 +1000

    Merge v5.0-rc7 into drm-next
    
    Backmerging for nouveau and imx that needed some fixes for next pulls.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 39c68e87bc50a71bcfe93582d9b0673ef30db418
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Wed Jan 30 18:25:54 2019 +0800

    drm/i915/gvt: add VFIO EDID region
    
    Implement VFIO EDID region for vgpu. Support EDID blob update and notify
    guest on link state change via hotplug event.
    
    v3: move struct edid_region to kvmgt.c <zhenyu>
    v2: add EDID sanity check and size update <zhenyu>
    
    Tested-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 9b4225d44243..5d8b8f228d8f 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -313,6 +313,23 @@ static inline int intel_gvt_hypervisor_set_opregion(struct intel_vgpu *vgpu)
 	return intel_gvt_host.mpt->set_opregion(vgpu);
 }
 
+/**
+ * intel_gvt_hypervisor_set_edid - Set EDID region for guest
+ * @vgpu: a vGPU
+ * @port_num: display port number
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_set_edid(struct intel_vgpu *vgpu,
+						int port_num)
+{
+	if (!intel_gvt_host.mpt->set_edid)
+		return 0;
+
+	return intel_gvt_host.mpt->set_edid(vgpu, port_num);
+}
+
 /**
  * intel_gvt_hypervisor_get_vfio_device - increase vfio device ref count
  * @vgpu: a vGPU

commit 6c2d0f9976ad19eca6d03dad5d726f8eff848b70
Author: Hang Yuan <hang.yuan@linux.intel.com>
Date:   Mon Jan 14 18:43:39 2019 +0800

    drm/i915/gvt: free VFIO region space in vgpu detach
    
    VFIO region space is allocated when one region is registered for
    one vgpu. So free the space when destroy the vgpu.
    
    Also change the parameter of detach_vgpu callback to use vgpu directly.
    
    Fixes: b851adeac0858c7d257b3 ("drm/i915/gvt: Add opregion support")
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Hang Yuan <hang.yuan@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 67f19992b226..3ed34123d8d1 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -101,7 +101,7 @@ static inline void intel_gvt_hypervisor_detach_vgpu(struct intel_vgpu *vgpu)
 	if (!intel_gvt_host.mpt->detach_vgpu)
 		return;
 
-	intel_gvt_host.mpt->detach_vgpu(vgpu->handle);
+	intel_gvt_host.mpt->detach_vgpu(vgpu);
 }
 
 #define MSI_CAP_CONTROL(offset) (offset + 2)

commit 9bdb073464d6008ed1839d358e320108ed12daae
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:53 2018 +0800

    drm/i915/gvt: Change KVMGT as self load module
    
    This trys to make 'kvmgt' module as self loadable instead of loading
    by i915/gvt device model. So hypervisor specific module could be
    stand-alone, e.g only after loading hypervisor specific module, GVT
    feature could be enabled via specific hypervisor interface, e.g VFIO/mdev.
    
    So this trys to use hypervisor module register/unregister interface
    for that. Hypervisor module needs to take care of module reference
    itself when working for hypervisor interface, e.g for VFIO/mdev,
    hypervisor module would reference counting mdev when open and release.
    
    This makes 'kvmgt' module really split from GVT device model. User
    needs to load 'kvmgt' to enable VFIO/mdev interface.
    
    v6:
    - remove unused variable
    
    v5:
    - put module reference in register error path
    
    v4:
    - fix checkpatch warning
    
    v3:
    - Fix module reference handling for device open and release. Unused
      mdev devices would be cleaned up in device unregister when module unload.
    
    v2:
    - Fix kvmgt order after i915 for built-in case
    
    Cc: "Yuan, Hang" <hang.yuan@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: "He, Min" <min.he@intel.com>
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index c95ef77da62c..9b4225d44243 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -360,4 +360,7 @@ static inline bool intel_gvt_hypervisor_is_valid_gfn(
 	return intel_gvt_host.mpt->is_valid_gfn(vgpu->handle, gfn);
 }
 
+int intel_gvt_register_hypervisor(struct intel_gvt_mpt *);
+void intel_gvt_unregister_hypervisor(void);
+
 #endif /* _GVT_MPT_H_ */

commit a2b8419a9e2975d19c0cd85f4912f2873bd974e0
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:52 2018 +0800

    drm/i915/gvt: remove unused parameter for hypervisor's host_exit call
    
    The parameter 'void *gvt' is not used and required for hypervisor's
    exit call. Even for non-merged Xen hypervisor support. So just remove it.
    
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index ce721099a020..c95ef77da62c 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -61,14 +61,13 @@ static inline int intel_gvt_hypervisor_host_init(struct device *dev,
 /**
  * intel_gvt_hypervisor_host_exit - exit GVT-g host side
  */
-static inline void intel_gvt_hypervisor_host_exit(struct device *dev,
-			void *gvt)
+static inline void intel_gvt_hypervisor_host_exit(struct device *dev)
 {
 	/* optional to provide */
 	if (!intel_gvt_host.mpt->host_exit)
 		return;
 
-	intel_gvt_host.mpt->host_exit(dev, gvt);
+	intel_gvt_host.mpt->host_exit(dev);
 }
 
 /**

commit 2313b1897f574e036635b25c501ec5e008407241
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Dec 7 16:16:51 2018 +0800

    drm/i915/gvt: mandatory require hypervisor's host_init
    
    Don't mark hypervisor module's host_init as optional,
    but mandatory required.
    
    Reviewed-by: Yuan, Hang <hang.yuan@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 67f19992b226..ce721099a020 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -50,11 +50,10 @@
  * Zero on success, negative error code if failed
  */
 static inline int intel_gvt_hypervisor_host_init(struct device *dev,
-			void *gvt, const void *ops)
+						 void *gvt, const void *ops)
 {
-	/* optional to provide */
 	if (!intel_gvt_host.mpt->host_init)
-		return 0;
+		return -ENODEV;
 
 	return intel_gvt_host.mpt->host_init(dev, gvt, ops);
 }

commit 79e542f5af79918e5e766c441561fb9bff8af3aa
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue May 15 10:35:42 2018 +0800

    drm/i915/kvmgt: Support setting dma map for huge pages
    
    To support huge gtt, we need to support huge pages in kvmgt first.
    This patch adds a 'size' param to the intel_gvt_mpt::dma_map_guest_page
    API and implements it in kvmgt.
    
    v2: rebase.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 32ffcd566cdd..67f19992b226 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -230,17 +230,18 @@ static inline unsigned long intel_gvt_hypervisor_gfn_to_mfn(
 /**
  * intel_gvt_hypervisor_dma_map_guest_page - setup dma map for guest page
  * @vgpu: a vGPU
- * @gpfn: guest pfn
+ * @gfn: guest pfn
+ * @size: page size
  * @dma_addr: retrieve allocated dma addr
  *
  * Returns:
  * 0 on success, negative error code if failed.
  */
 static inline int intel_gvt_hypervisor_dma_map_guest_page(
-		struct intel_vgpu *vgpu, unsigned long gfn,
+		struct intel_vgpu *vgpu, unsigned long gfn, unsigned long size,
 		dma_addr_t *dma_addr)
 {
-	return intel_gvt_host.mpt->dma_map_guest_page(vgpu->handle, gfn,
+	return intel_gvt_host.mpt->dma_map_guest_page(vgpu->handle, gfn, size,
 						      dma_addr);
 }
 

commit cf4ee73fd9b6d31fa7530f72cff5cc97b94f1272
Author: Changbin Du <changbin.du@intel.com>
Date:   Thu Mar 1 15:49:59 2018 +0800

    drm/i915/gvt: Fix guest vGPU hang caused by very high dma setup overhead
    
    The implementation of current kvmgt implicitly setup dma mapping at MPT
    API gfn_to_mfn. First this design against the API's original purpose.
    Second, there is no unmap hit in this design. The result is that the
    dma mapping keep growing larger and larger. For mutl-vm case, they will
    consume IOMMU IOVA low 4GB address space quickly and so tons of rbtree
    entries crated in the IOMMU IOVA allocator. Finally, single IOVA
    allocation can take as long as ~70ms. Such latency is intolerable.
    
    To address both above issues, this patch introduced two new MPT API:
      o dma_map_guest_page - setup dma map for guest page
      o dma_unmap_guest_page - cancel dma map for guest page
    
    The kvmgt implements these 2 API. And to reduce dma setup overhead for
    duplicated pages (eg. scratch pages), two caches are used: one is for
    mapping gfn to struct gvt_dma, another is for mapping dma addr to
    struct gvt_dma.
    
    With these 2 new API, the gtt now is able to cancel dma mapping when page
    table is invalidated. The dma mapping is not in a gradual increase now.
    
    v2: follow the old logic for VFIO_IOMMU_NOTIFY_DMA_UNMAP at this point.
    
    Cc: Hang Yuan <hang.yuan@intel.com>
    Cc: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 78fada9e3241..32ffcd566cdd 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -227,6 +227,34 @@ static inline unsigned long intel_gvt_hypervisor_gfn_to_mfn(
 	return intel_gvt_host.mpt->gfn_to_mfn(vgpu->handle, gfn);
 }
 
+/**
+ * intel_gvt_hypervisor_dma_map_guest_page - setup dma map for guest page
+ * @vgpu: a vGPU
+ * @gpfn: guest pfn
+ * @dma_addr: retrieve allocated dma addr
+ *
+ * Returns:
+ * 0 on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_dma_map_guest_page(
+		struct intel_vgpu *vgpu, unsigned long gfn,
+		dma_addr_t *dma_addr)
+{
+	return intel_gvt_host.mpt->dma_map_guest_page(vgpu->handle, gfn,
+						      dma_addr);
+}
+
+/**
+ * intel_gvt_hypervisor_dma_unmap_guest_page - cancel dma map for guest page
+ * @vgpu: a vGPU
+ * @dma_addr: the mapped dma addr
+ */
+static inline void intel_gvt_hypervisor_dma_unmap_guest_page(
+		struct intel_vgpu *vgpu, dma_addr_t dma_addr)
+{
+	intel_gvt_host.mpt->dma_unmap_guest_page(vgpu->handle, dma_addr);
+}
+
 /**
  * intel_gvt_hypervisor_map_gfn_to_mfn - map a GFN region to MFN
  * @vgpu: a vGPU

commit 0947572849cb3ca7028d9daa3958158639ae4d69
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jan 30 19:19:52 2018 +0800

    drm/i915/gvt: Don't extend page_track to mpt layer
    
    Don't extend page_track to mpt layer. Keep MPT simple and clean.
    Meanwhile remove gtt.n_tracked_guest_page which doesn't make much
    sense.
    
    v2: clean up gtt.n_tracked_guest_page.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 90fd83f98733..78fada9e3241 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -156,51 +156,29 @@ static inline unsigned long intel_gvt_hypervisor_virt_to_mfn(void *p)
 /**
  * intel_gvt_hypervisor_enable_page_track - track a guest page
  * @vgpu: a vGPU
- * @t: page track data structure
+ * @gfn: the gfn of guest
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
 static inline int intel_gvt_hypervisor_enable_page_track(
-		struct intel_vgpu *vgpu,
-		struct intel_vgpu_page_track *t)
+		struct intel_vgpu *vgpu, unsigned long gfn)
 {
-	int ret;
-
-	if (t->tracked)
-		return 0;
-
-	ret = intel_gvt_host.mpt->enable_page_track(vgpu->handle, t->gfn);
-	if (ret)
-		return ret;
-	t->tracked = true;
-	atomic_inc(&vgpu->gtt.n_tracked_guest_page);
-	return 0;
+	return intel_gvt_host.mpt->enable_page_track(vgpu->handle, gfn);
 }
 
 /**
  * intel_gvt_hypervisor_disable_page_track - untrack a guest page
  * @vgpu: a vGPU
- * @t: page track data structure
+ * @gfn: the gfn of guest
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
 static inline int intel_gvt_hypervisor_disable_page_track(
-		struct intel_vgpu *vgpu,
-		struct intel_vgpu_page_track *t)
+		struct intel_vgpu *vgpu, unsigned long gfn)
 {
-	int ret;
-
-	if (!t->tracked)
-		return 0;
-
-	ret = intel_gvt_host.mpt->disable_page_track(vgpu->handle, t->gfn);
-	if (ret)
-		return ret;
-	t->tracked = false;
-	atomic_dec(&vgpu->gtt.n_tracked_guest_page);
-	return 0;
+	return intel_gvt_host.mpt->disable_page_track(vgpu->handle, gfn);
 }
 
 /**

commit f66e5ff706038d03e8ef6d012e3aec7824442418
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Jan 30 19:19:51 2018 +0800

    drm/i915/gvt: Rename mpt api {set, unset}_wp_page to {enable, disable}_page_track
    
    The kvmgt's implementation of mpt api {set,unset}_wp_page is not real
    write-protection - the data get written before invoke this two api.
    As discussed, change the mpt api to match the real behavior.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 81aff4eacbfe..90fd83f98733 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -154,7 +154,7 @@ static inline unsigned long intel_gvt_hypervisor_virt_to_mfn(void *p)
 }
 
 /**
- * intel_gvt_hypervisor_enable - set a guest page to write-protected
+ * intel_gvt_hypervisor_enable_page_track - track a guest page
  * @vgpu: a vGPU
  * @t: page track data structure
  *
@@ -170,7 +170,7 @@ static inline int intel_gvt_hypervisor_enable_page_track(
 	if (t->tracked)
 		return 0;
 
-	ret = intel_gvt_host.mpt->set_wp_page(vgpu->handle, t->gfn);
+	ret = intel_gvt_host.mpt->enable_page_track(vgpu->handle, t->gfn);
 	if (ret)
 		return ret;
 	t->tracked = true;
@@ -179,8 +179,7 @@ static inline int intel_gvt_hypervisor_enable_page_track(
 }
 
 /**
- * intel_gvt_hypervisor_disable_page_track - remove the write-protection of a
- * guest page
+ * intel_gvt_hypervisor_disable_page_track - untrack a guest page
  * @vgpu: a vGPU
  * @t: page track data structure
  *
@@ -196,7 +195,7 @@ static inline int intel_gvt_hypervisor_disable_page_track(
 	if (!t->tracked)
 		return 0;
 
-	ret = intel_gvt_host.mpt->unset_wp_page(vgpu->handle, t->gfn);
+	ret = intel_gvt_host.mpt->disable_page_track(vgpu->handle, t->gfn);
 	if (ret)
 		return ret;
 	t->tracked = false;

commit cc753fbe1ac47560e1517e3e11fb0c8a3c95eef5
Author: Hang Yuan <hang.yuan@intel.com>
Date:   Fri Dec 22 18:06:31 2017 +0800

    drm/i915/gvt: validate gfn before set shadow page entry
    
    GVT may receive partial write on one guest PTE update. Validate gfn
    not to translate incomplete gfn. This avoids some unnecessary error
    messages incurred by the incomplete gfn translating. Also fix the
    bug that the whole PPGTT shadow page update is aborted on any invalid
    gfn entry.
    
    gfn validation relys on hypervisor's help. Add one MPT module function
    to provide the function.
    
    Signed-off-by: Hang Yuan <hang.yuan@intel.com>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index ca8005a6d5fa..81aff4eacbfe 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -339,4 +339,21 @@ static inline void intel_gvt_hypervisor_put_vfio_device(struct intel_vgpu *vgpu)
 	intel_gvt_host.mpt->put_vfio_device(vgpu);
 }
 
+/**
+ * intel_gvt_hypervisor_is_valid_gfn - check if a visible gfn
+ * @vgpu: a vGPU
+ * @gfn: guest PFN
+ *
+ * Returns:
+ * true on valid gfn, false on not.
+ */
+static inline bool intel_gvt_hypervisor_is_valid_gfn(
+		struct intel_vgpu *vgpu, unsigned long gfn)
+{
+	if (!intel_gvt_host.mpt->is_valid_gfn)
+		return true;
+
+	return intel_gvt_host.mpt->is_valid_gfn(vgpu->handle, gfn);
+}
+
 #endif /* _GVT_MPT_H_ */

commit e546e281d33d1fc275651aa06f0659045db67e68
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Thu Nov 23 16:26:36 2017 +0800

    drm/i915/gvt: Dmabuf support for GVT-g
    
    This patch introduces a guest's framebuffer sharing mechanism based on
    dma-buf subsystem. With this sharing mechanism, guest's framebuffer can
    be shared between guest VM and host.
    
    v17:
    - modify VFIO_DEVICE_GET_GFX_DMABUF interface. (Alex)
    
    v16:
    - add x_hot and y_hot. (Gerd)
    - add flag validation for VFIO_DEVICE_GET_GFX_DMABUF. (Alex)
    - rebase 4.14.0-rc6.
    
    v15:
    - add VFIO_DEVICE_GET_GFX_DMABUF ABI. (Gerd)
    - add intel_vgpu_dmabuf_cleanup() to clean up the vGPU's dmabuf. (Gerd)
    
    v14:
    - add PROBE, DMABUF and REGION flags. (Alex)
    
    v12:
    - refine the lifecycle of dmabuf.
    
    v9:
    - remove dma-buf management. (Alex)
    - track the dma-buf create and release in kernel mode. (Gerd) (Daniel)
    
    v8:
    - refine the dma-buf ioctl definition.(Alex)
    - add a lock to protect the dmabuf list. (Alex)
    
    v7:
    - release dma-buf related allocations in dma-buf's associated release
      function. (Alex)
    - refine ioctl interface for querying plane info or create dma-buf.
      (Alex)
    
    v6:
    - align the dma-buf life cycle with the vfio device. (Alex)
    - add the dma-buf related operations in a separate patch. (Gerd)
    - i915 related changes. (Chris)
    
    v5:
    - fix bug while checking whether the gem obj is gvt's dma-buf when user
      change caching mode or domains. Add a helper function to do it.
      (Xiaoguang)
    - add definition for the query plane and create dma-buf. (Xiaoguang)
    
    v4:
    - fix bug while checking whether the gem obj is gvt's dma-buf when set
      caching mode or doamins. (Xiaoguang)
    
    v3:
    - declare a new flag I915_GEM_OBJECT_IS_GVT_DMABUF in drm_i915_gem_object
      to represent the gem obj for gvt's dma-buf. The tiling mode, caching
      mode and domains can not be changed for this kind of gem object. (Alex)
    - change dma-buf related information to be more generic. So other vendor
      can use the same interface. (Alex)
    
    v2:
    - create a management fd for dma-buf operations. (Alex)
    - alloc gem object's backing storage in gem obj's get_pages() callback.
      (Chris)
    
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index c99e7964731c..ca8005a6d5fa 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -309,4 +309,34 @@ static inline int intel_gvt_hypervisor_set_opregion(struct intel_vgpu *vgpu)
 	return intel_gvt_host.mpt->set_opregion(vgpu);
 }
 
+/**
+ * intel_gvt_hypervisor_get_vfio_device - increase vfio device ref count
+ * @vgpu: a vGPU
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_get_vfio_device(struct intel_vgpu *vgpu)
+{
+	if (!intel_gvt_host.mpt->get_vfio_device)
+		return 0;
+
+	return intel_gvt_host.mpt->get_vfio_device(vgpu);
+}
+
+/**
+ * intel_gvt_hypervisor_put_vfio_device - decrease vfio device ref count
+ * @vgpu: a vGPU
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline void intel_gvt_hypervisor_put_vfio_device(struct intel_vgpu *vgpu)
+{
+	if (!intel_gvt_host.mpt->put_vfio_device)
+		return;
+
+	intel_gvt_host.mpt->put_vfio_device(vgpu);
+}
+
 #endif /* _GVT_MPT_H_ */

commit b851adeac0858c7d257b32eee2142b1519d45ccf
Author: Tina Zhang <tina.zhang@intel.com>
Date:   Mon Nov 20 15:31:16 2017 +0800

    drm/i915/gvt: Add opregion support
    
    Windows guest driver needs vbt in opregion, to configure the setting
    for display. Without opregion support, the display registers won't
    be set and this blocks display model to get the correct information
    of the guest display plane.
    
    This patch is to provide a virtual opregion for guest. The original
    author of this patch is Xiaoguang Chen.
    
    This patch is split from the "Dma-buf support for GVT-g" patch set,
    with being rebased to the latest gvt-staging branch.
    
    v3:
    - add checking region index during intel_vgpu_rw. (Xiong)
    
    v2:
    - refine intel_vgpu_reg_release_opregion. (Xiong)
    
    Here are the previous version comments:
    
    v18:
    - unmap vgpu's opregion when destroying vgpu.
    
    v16:
    - rebase to 4.14.0-rc6.
    
    Signed-off-by: Bing Niu <bing.niu@intel.com>
    Signed-off-by: Tina Zhang <tina.zhang@intel.com>
    Tested-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index c436e20ea59e..c99e7964731c 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -294,4 +294,19 @@ static inline int intel_gvt_hypervisor_set_trap_area(
 	return intel_gvt_host.mpt->set_trap_area(vgpu->handle, start, end, map);
 }
 
+/**
+ * intel_gvt_hypervisor_set_opregion - Set opregion for guest
+ * @vgpu: a vGPU
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_set_opregion(struct intel_vgpu *vgpu)
+{
+	if (!intel_gvt_host.mpt->set_opregion)
+		return 0;
+
+	return intel_gvt_host.mpt->set_opregion(vgpu);
+}
+
 #endif /* _GVT_MPT_H_ */

commit 7d1e5cdf01789729aff2da4005f51f58b491040c
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Fri Sep 29 02:47:55 2017 +0800

    drm/i915/gvt: Factor intel_vgpu_page_track
    
    As the data structure of "intel_vgpu_guest_page" will become much heavier
    in future, it's better to factor out the guest memory page track mechnisim
    as early as possible.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index f0e5487e6688..c436e20ea59e 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -154,51 +154,53 @@ static inline unsigned long intel_gvt_hypervisor_virt_to_mfn(void *p)
 }
 
 /**
- * intel_gvt_hypervisor_set_wp_page - set a guest page to write-protected
+ * intel_gvt_hypervisor_enable - set a guest page to write-protected
  * @vgpu: a vGPU
- * @p: intel_vgpu_guest_page
+ * @t: page track data structure
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
-static inline int intel_gvt_hypervisor_set_wp_page(struct intel_vgpu *vgpu,
-		struct intel_vgpu_guest_page *p)
+static inline int intel_gvt_hypervisor_enable_page_track(
+		struct intel_vgpu *vgpu,
+		struct intel_vgpu_page_track *t)
 {
 	int ret;
 
-	if (p->writeprotection)
+	if (t->tracked)
 		return 0;
 
-	ret = intel_gvt_host.mpt->set_wp_page(vgpu->handle, p->gfn);
+	ret = intel_gvt_host.mpt->set_wp_page(vgpu->handle, t->gfn);
 	if (ret)
 		return ret;
-	p->writeprotection = true;
-	atomic_inc(&vgpu->gtt.n_write_protected_guest_page);
+	t->tracked = true;
+	atomic_inc(&vgpu->gtt.n_tracked_guest_page);
 	return 0;
 }
 
 /**
- * intel_gvt_hypervisor_unset_wp_page - remove the write-protection of a
+ * intel_gvt_hypervisor_disable_page_track - remove the write-protection of a
  * guest page
  * @vgpu: a vGPU
- * @p: intel_vgpu_guest_page
+ * @t: page track data structure
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
-static inline int intel_gvt_hypervisor_unset_wp_page(struct intel_vgpu *vgpu,
-		struct intel_vgpu_guest_page *p)
+static inline int intel_gvt_hypervisor_disable_page_track(
+		struct intel_vgpu *vgpu,
+		struct intel_vgpu_page_track *t)
 {
 	int ret;
 
-	if (!p->writeprotection)
+	if (!t->tracked)
 		return 0;
 
-	ret = intel_gvt_host.mpt->unset_wp_page(vgpu->handle, p->gfn);
+	ret = intel_gvt_host.mpt->unset_wp_page(vgpu->handle, t->gfn);
 	if (ret)
 		return ret;
-	p->writeprotection = false;
-	atomic_dec(&vgpu->gtt.n_write_protected_guest_page);
+	t->tracked = false;
+	atomic_dec(&vgpu->gtt.n_tracked_guest_page);
 	return 0;
 }
 

commit 7fb6a7d65292a524256ed6e2d0e94071b0c53936
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Tue May 23 05:38:08 2017 +0800

    drm/i915/gvt: Change flood gvt dmesg into trace
    
    Currently gvt dmesg is so heavy at drm.debug=0x2 that guest and
    host almost couldn't run on xengt.
    
    This patch transfer these repeated messages into trace, so dmesg
    is light at drm.debug=0x2, and user could get the target message through
    trace event and trace filter.
    
    Suggested-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 419353624c5a..f0e5487e6688 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -133,8 +133,7 @@ static inline int intel_gvt_hypervisor_inject_msi(struct intel_vgpu *vgpu)
 	if (WARN(control & GENMASK(15, 1), "only support one MSI format\n"))
 		return -EINVAL;
 
-	gvt_dbg_irq("vgpu%d: inject msi address %x data%x\n", vgpu->id, addr,
-		    data);
+	trace_inject_msi(vgpu->id, addr, data);
 
 	ret = intel_gvt_host.mpt->inject_msi(vgpu->handle, addr, data);
 	if (ret)

commit 3de49a7314c9e17d71e97af4ed4b0564609e9ba7
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Dec 27 14:47:04 2016 +0800

    drm/i915/gvt: remove detect_host() MPT hook
    
    We only depend on pvinfo register for GVT-g state detection,
    not require hypervisor host detect any more.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 1af5830c0a56..419353624c5a 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -43,18 +43,6 @@
  * hypervisor.
  */
 
-/**
- * intel_gvt_hypervisor_detect_host - check if GVT-g is running within
- * hypervisor host/privilged domain
- *
- * Returns:
- * Zero on success, -ENODEV if current kernel is running inside a VM
- */
-static inline int intel_gvt_hypervisor_detect_host(void)
-{
-	return intel_gvt_host.mpt->detect_host();
-}
-
 /**
  * intel_gvt_hypervisor_host_init - init GVT-g host side
  *

commit 7b3343b7e804bb89ad24a0a8c4e8e1010a418f14
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:34 2016 +0800

    drm/i915/gvt: allow several MPT methods to be NULL
    
    Hypervisors are different, the MPT ops is a only superset of
    all possibly supported hypervisors. There might be other way
    out of the MPT to achieve same target. e.g. vfio-based kvmgt
    won't provide map_gfn_to_mfn method to establish guest EPT
    mapping for aperture, since it will be done in QEMU/KVM, MMIO
    is also trapped elsewhere, etc.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 93649b34798b..1af5830c0a56 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -64,6 +64,10 @@ static inline int intel_gvt_hypervisor_detect_host(void)
 static inline int intel_gvt_hypervisor_host_init(struct device *dev,
 			void *gvt, const void *ops)
 {
+	/* optional to provide */
+	if (!intel_gvt_host.mpt->host_init)
+		return 0;
+
 	return intel_gvt_host.mpt->host_init(dev, gvt, ops);
 }
 
@@ -73,6 +77,10 @@ static inline int intel_gvt_hypervisor_host_init(struct device *dev,
 static inline void intel_gvt_hypervisor_host_exit(struct device *dev,
 			void *gvt)
 {
+	/* optional to provide */
+	if (!intel_gvt_host.mpt->host_exit)
+		return;
+
 	intel_gvt_host.mpt->host_exit(dev, gvt);
 }
 
@@ -85,6 +93,10 @@ static inline void intel_gvt_hypervisor_host_exit(struct device *dev,
  */
 static inline int intel_gvt_hypervisor_attach_vgpu(struct intel_vgpu *vgpu)
 {
+	/* optional to provide */
+	if (!intel_gvt_host.mpt->attach_vgpu)
+		return 0;
+
 	return intel_gvt_host.mpt->attach_vgpu(vgpu, &vgpu->handle);
 }
 
@@ -97,6 +109,10 @@ static inline int intel_gvt_hypervisor_attach_vgpu(struct intel_vgpu *vgpu)
  */
 static inline void intel_gvt_hypervisor_detach_vgpu(struct intel_vgpu *vgpu)
 {
+	/* optional to provide */
+	if (!intel_gvt_host.mpt->detach_vgpu)
+		return;
+
 	intel_gvt_host.mpt->detach_vgpu(vgpu->handle);
 }
 
@@ -261,6 +277,10 @@ static inline int intel_gvt_hypervisor_map_gfn_to_mfn(
 		unsigned long mfn, unsigned int nr,
 		bool map)
 {
+	/* a MPT implementation could have MMIO mapped elsewhere */
+	if (!intel_gvt_host.mpt->map_gfn_to_mfn)
+		return 0;
+
 	return intel_gvt_host.mpt->map_gfn_to_mfn(vgpu->handle, gfn, mfn, nr,
 						  map);
 }
@@ -278,6 +298,10 @@ static inline int intel_gvt_hypervisor_map_gfn_to_mfn(
 static inline int intel_gvt_hypervisor_set_trap_area(
 		struct intel_vgpu *vgpu, u64 start, u64 end, bool map)
 {
+	/* a MPT implementation could have MMIO trapped elsewhere */
+	if (!intel_gvt_host.mpt->set_trap_area)
+		return 0;
+
 	return intel_gvt_host.mpt->set_trap_area(vgpu->handle, start, end, map);
 }
 

commit 40df6ea07a15032e33b6f3d415bed0774547ec7e
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:33 2016 +0800

    drm/i915/gvt: introduce host_init/host_exit to MPT
    
    GVT host needs init/exit hooks to do some initialization/cleanup
    work, e.g.: vfio mdev host device register/unregister.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 15e08dcb3199..93649b34798b 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -55,6 +55,27 @@ static inline int intel_gvt_hypervisor_detect_host(void)
 	return intel_gvt_host.mpt->detect_host();
 }
 
+/**
+ * intel_gvt_hypervisor_host_init - init GVT-g host side
+ *
+ * Returns:
+ * Zero on success, negative error code if failed
+ */
+static inline int intel_gvt_hypervisor_host_init(struct device *dev,
+			void *gvt, const void *ops)
+{
+	return intel_gvt_host.mpt->host_init(dev, gvt, ops);
+}
+
+/**
+ * intel_gvt_hypervisor_host_exit - exit GVT-g host side
+ */
+static inline void intel_gvt_hypervisor_host_exit(struct device *dev,
+			void *gvt)
+{
+	intel_gvt_host.mpt->host_exit(dev, gvt);
+}
+
 /**
  * intel_gvt_hypervisor_attach_vgpu - call hypervisor to initialize vGPU
  * related stuffs inside hypervisor.

commit 8f89743bddec87b7e0eefe9895274653ce341059
Author: Jike Song <jike.song@intel.com>
Date:   Thu Nov 3 18:38:32 2016 +0800

    drm/i915/gvt: remove obsolete code for old kvmgt opregion
    
    Current GVT contains some obsolete logic originally cooked to
    support the old, non-vfio kvmgt, which is actually workarounds.
    We don't support that anymore, so it's safe to remove it and
    make a better framework.
    
    Signed-off-by: Jike Song <jike.song@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 67858782d327..15e08dcb3199 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -224,11 +224,6 @@ static inline unsigned long intel_gvt_hypervisor_gfn_to_mfn(
 	return intel_gvt_host.mpt->gfn_to_mfn(vgpu->handle, gfn);
 }
 
-enum {
-	GVT_MAP_APERTURE = 0,
-	GVT_MAP_OPREGION,
-};
-
 /**
  * intel_gvt_hypervisor_map_gfn_to_mfn - map a GFN region to MFN
  * @vgpu: a vGPU
@@ -236,7 +231,6 @@ enum {
  * @mfn: host PFN
  * @nr: amount of PFNs
  * @map: map or unmap
- * @type: map type
  *
  * Returns:
  * Zero on success, negative error code if failed.
@@ -244,10 +238,10 @@ enum {
 static inline int intel_gvt_hypervisor_map_gfn_to_mfn(
 		struct intel_vgpu *vgpu, unsigned long gfn,
 		unsigned long mfn, unsigned int nr,
-		bool map, int type)
+		bool map)
 {
 	return intel_gvt_host.mpt->map_gfn_to_mfn(vgpu->handle, gfn, mfn, nr,
-						  map, type);
+						  map);
 }
 
 /**

commit 4d60c5fd3f8751ea751d6dc6cfe0c1620420ccf8
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Wed Jul 20 01:14:38 2016 -0400

    drm/i915/gvt: vGPU PCI configuration space virtualization
    
    This patch introduces vGPU PCI configuration space virtualization.
    
    - Adjust the trapped GPFN(Guest Page Frame Number) window of virtual GEN
    PCI BAR 0 when guest initializes PCI BAR 0 address.
    
    - Emulate OpRegion when guest touches OpRegion.
    
    - Pass-through a part of aperture to guest when guest initializes
    aperture BAR.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 46664771cc58..67858782d327 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -224,4 +224,46 @@ static inline unsigned long intel_gvt_hypervisor_gfn_to_mfn(
 	return intel_gvt_host.mpt->gfn_to_mfn(vgpu->handle, gfn);
 }
 
+enum {
+	GVT_MAP_APERTURE = 0,
+	GVT_MAP_OPREGION,
+};
+
+/**
+ * intel_gvt_hypervisor_map_gfn_to_mfn - map a GFN region to MFN
+ * @vgpu: a vGPU
+ * @gfn: guest PFN
+ * @mfn: host PFN
+ * @nr: amount of PFNs
+ * @map: map or unmap
+ * @type: map type
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_map_gfn_to_mfn(
+		struct intel_vgpu *vgpu, unsigned long gfn,
+		unsigned long mfn, unsigned int nr,
+		bool map, int type)
+{
+	return intel_gvt_host.mpt->map_gfn_to_mfn(vgpu->handle, gfn, mfn, nr,
+						  map, type);
+}
+
+/**
+ * intel_gvt_hypervisor_set_trap_area - Trap a guest PA region
+ * @vgpu: a vGPU
+ * @start: the beginning of the guest physical address region
+ * @end: the end of the guest physical address region
+ * @map: map or unmap
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_set_trap_area(
+		struct intel_vgpu *vgpu, u64 start, u64 end, bool map)
+{
+	return intel_gvt_host.mpt->set_trap_area(vgpu->handle, start, end, map);
+}
+
 #endif /* _GVT_MPT_H_ */

commit 2707e44466881d6b0a8ed05a429dcf0940c22f60
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Mon Mar 28 23:23:16 2016 +0800

    drm/i915/gvt: vGPU graphics memory virtualization
    
    The vGPU graphics memory emulation framework is responsible for graphics
    memory table virtualization. Under virtualization environment, a VM will
    populate the page table entry with guest page frame number(GPFN/GFN), while
    HW needs a page table filled with MFN(Machine frame number). The
    relationship between GFN and MFN(Machine frame number) is managed by
    hypervisor, while GEN HW doesn't have such knowledge to translate a GFN.
    
    To solve this gap, shadow GGTT/PPGTT page table is introdcued.
    
    For GGTT, the GFN inside the guest GGTT page table entry will be translated
    into MFN and written into physical GTT MMIO registers when guest write
    virtual GTT MMIO registers.
    
    For PPGTT, a shadow PPGTT page table will be created and write-protected
    translated from guest PPGTT page table.  And the shadow page table root
    pointers will be written into the shadow context after a guest workload
    is shadowed.
    
    vGPU graphics memory emulation framework consists:
    
    - Per-GEN HW platform page table entry bits extract/de-extract routines.
    - GTT MMIO register emulation handlers, which will call hypercall to do
    GFN->MFN translation when guest write GTT MMIO register
    - PPGTT shadow page table routines, e.g. shadow create/destroy/out-of-sync
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 31a837195745..46664771cc58 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -117,4 +117,111 @@ static inline int intel_gvt_hypervisor_inject_msi(struct intel_vgpu *vgpu)
 	return 0;
 }
 
+/**
+ * intel_gvt_hypervisor_set_wp_page - translate a host VA into MFN
+ * @p: host kernel virtual address
+ *
+ * Returns:
+ * MFN on success, INTEL_GVT_INVALID_ADDR if failed.
+ */
+static inline unsigned long intel_gvt_hypervisor_virt_to_mfn(void *p)
+{
+	return intel_gvt_host.mpt->from_virt_to_mfn(p);
+}
+
+/**
+ * intel_gvt_hypervisor_set_wp_page - set a guest page to write-protected
+ * @vgpu: a vGPU
+ * @p: intel_vgpu_guest_page
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_set_wp_page(struct intel_vgpu *vgpu,
+		struct intel_vgpu_guest_page *p)
+{
+	int ret;
+
+	if (p->writeprotection)
+		return 0;
+
+	ret = intel_gvt_host.mpt->set_wp_page(vgpu->handle, p->gfn);
+	if (ret)
+		return ret;
+	p->writeprotection = true;
+	atomic_inc(&vgpu->gtt.n_write_protected_guest_page);
+	return 0;
+}
+
+/**
+ * intel_gvt_hypervisor_unset_wp_page - remove the write-protection of a
+ * guest page
+ * @vgpu: a vGPU
+ * @p: intel_vgpu_guest_page
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_unset_wp_page(struct intel_vgpu *vgpu,
+		struct intel_vgpu_guest_page *p)
+{
+	int ret;
+
+	if (!p->writeprotection)
+		return 0;
+
+	ret = intel_gvt_host.mpt->unset_wp_page(vgpu->handle, p->gfn);
+	if (ret)
+		return ret;
+	p->writeprotection = false;
+	atomic_dec(&vgpu->gtt.n_write_protected_guest_page);
+	return 0;
+}
+
+/**
+ * intel_gvt_hypervisor_read_gpa - copy data from GPA to host data buffer
+ * @vgpu: a vGPU
+ * @gpa: guest physical address
+ * @buf: host data buffer
+ * @len: data length
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_read_gpa(struct intel_vgpu *vgpu,
+		unsigned long gpa, void *buf, unsigned long len)
+{
+	return intel_gvt_host.mpt->read_gpa(vgpu->handle, gpa, buf, len);
+}
+
+/**
+ * intel_gvt_hypervisor_write_gpa - copy data from host data buffer to GPA
+ * @vgpu: a vGPU
+ * @gpa: guest physical address
+ * @buf: host data buffer
+ * @len: data length
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_write_gpa(struct intel_vgpu *vgpu,
+		unsigned long gpa, void *buf, unsigned long len)
+{
+	return intel_gvt_host.mpt->write_gpa(vgpu->handle, gpa, buf, len);
+}
+
+/**
+ * intel_gvt_hypervisor_gfn_to_mfn - translate a GFN to MFN
+ * @vgpu: a vGPU
+ * @gpfn: guest pfn
+ *
+ * Returns:
+ * MFN on success, INTEL_GVT_INVALID_ADDR if failed.
+ */
+static inline unsigned long intel_gvt_hypervisor_gfn_to_mfn(
+		struct intel_vgpu *vgpu, unsigned long gfn)
+{
+	return intel_gvt_host.mpt->gfn_to_mfn(vgpu->handle, gfn);
+}
+
 #endif /* _GVT_MPT_H_ */

commit c8fe6a6811a7186656379d0c27e85325a966077a
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Sep 17 09:22:08 2015 +0800

    drm/i915/gvt: vGPU interrupt virtualization.
    
    This patch introduces vGPU interrupt emulation framework.
    
    The vGPU intrerrupt emulation framework is an event-based interrupt
    emulation framework. It's responsible for emulating GEN hardware interrupts
    during emulating other HW behaviour.
    
    It consists several components:
    
    - Descriptions of interrupt register bit
    - Upper level <-> lower level interrupt mapping
    - GEN HW IER/IMR/IIR register emulation routines
    - Event-based interrupt propagation interface
    
    When a GVT-g component wants to inject an interrupt to a VM during a
    emulation, first it should specify the event needs to be emulated and the
    framework will deal with the rest of emulation:
    
    - Generating related virtual IIR bit according to virtual IER and IMRs,
    - Generate related virtual upper level virtual IIR bit accodring to the
    per-platform interrupt mapping
    - Injecting a MSI to VM
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index f78186884a5c..31a837195745 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -79,4 +79,42 @@ static inline void intel_gvt_hypervisor_detach_vgpu(struct intel_vgpu *vgpu)
 	intel_gvt_host.mpt->detach_vgpu(vgpu->handle);
 }
 
+#define MSI_CAP_CONTROL(offset) (offset + 2)
+#define MSI_CAP_ADDRESS(offset) (offset + 4)
+#define MSI_CAP_DATA(offset) (offset + 8)
+#define MSI_CAP_EN 0x1
+
+/**
+ * intel_gvt_hypervisor_inject_msi - inject a MSI interrupt into vGPU
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_inject_msi(struct intel_vgpu *vgpu)
+{
+	unsigned long offset = vgpu->gvt->device_info.msi_cap_offset;
+	u16 control, data;
+	u32 addr;
+	int ret;
+
+	control = *(u16 *)(vgpu_cfg_space(vgpu) + MSI_CAP_CONTROL(offset));
+	addr = *(u32 *)(vgpu_cfg_space(vgpu) + MSI_CAP_ADDRESS(offset));
+	data = *(u16 *)(vgpu_cfg_space(vgpu) + MSI_CAP_DATA(offset));
+
+	/* Do not generate MSI if MSIEN is disable */
+	if (!(control & MSI_CAP_EN))
+		return 0;
+
+	if (WARN(control & GENMASK(15, 1), "only support one MSI format\n"))
+		return -EINVAL;
+
+	gvt_dbg_irq("vgpu%d: inject msi address %x data%x\n", vgpu->id, addr,
+		    data);
+
+	ret = intel_gvt_host.mpt->inject_msi(vgpu->handle, addr, data);
+	if (ret)
+		return ret;
+	return 0;
+}
+
 #endif /* _GVT_MPT_H_ */

commit 82d375d1b56820fd094da15c82562661b6a8f344
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Tue Jul 5 12:40:49 2016 -0400

    drm/i915/gvt: Introduce basic vGPU life cycle management
    
    A vGPU represents a virtual Intel GEN hardware, which consists following
    virtual resources:
    
    - Configuration space (virtualized)
    - HW registers (virtualized)
    - GGTT memory space (partitioned)
    - GPU page table (shadowed)
    - Fence registers (partitioned)
    
    * virtualized: fully emulated by GVT-g.
    * partitioned: Only a part of the HW resource is allowed to be accessed
    by VM.
    * shadowed: Resource needs to be translated and shadowed before getting
    applied into HW.
    
    This patch introduces vGPU life cycle management framework, which is
    responsible for creating/destroying a vGPU and preparing/free resources
    related to a vGPU.
    
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
index 03601e3ffa7c..f78186884a5c 100644
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -19,6 +19,15 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
+ *
+ * Authors:
+ *    Eddie Dong <eddie.dong@intel.com>
+ *    Dexuan Cui
+ *    Jike Song <jike.song@intel.com>
+ *
+ * Contributors:
+ *    Zhi Wang <zhi.a.wang@intel.com>
+ *
  */
 
 #ifndef _GVT_MPT_H_
@@ -46,4 +55,28 @@ static inline int intel_gvt_hypervisor_detect_host(void)
 	return intel_gvt_host.mpt->detect_host();
 }
 
+/**
+ * intel_gvt_hypervisor_attach_vgpu - call hypervisor to initialize vGPU
+ * related stuffs inside hypervisor.
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline int intel_gvt_hypervisor_attach_vgpu(struct intel_vgpu *vgpu)
+{
+	return intel_gvt_host.mpt->attach_vgpu(vgpu, &vgpu->handle);
+}
+
+/**
+ * intel_gvt_hypervisor_detach_vgpu - call hypervisor to release vGPU
+ * related stuffs inside hypervisor.
+ *
+ * Returns:
+ * Zero on success, negative error code if failed.
+ */
+static inline void intel_gvt_hypervisor_detach_vgpu(struct intel_vgpu *vgpu)
+{
+	intel_gvt_host.mpt->detach_vgpu(vgpu->handle);
+}
+
 #endif /* _GVT_MPT_H_ */

commit 0ad35fed618cec78af8f40cc47702e13e5ba82b1
Author: Zhi Wang <zhi.a.wang@intel.com>
Date:   Thu Jun 16 08:07:00 2016 -0400

    drm/i915: gvt: Introduce the basic architecture of GVT-g
    
    This patch introduces the very basic framework of GVT-g device model,
    includes basic prototypes, definitions, initialization.
    
    v12:
    - Call intel_gvt_init() in driver early initialization stage. (Chris)
    
    v8:
    - Remove the GVT idr and mutex in intel_gvt_host. (Joonas)
    
    v7:
    - Refine the URL link in Kconfig. (Joonas)
    - Refine the introduction of GVT-g host support in Kconfig. (Joonas)
    - Remove the macro GVT_ALIGN(), use round_down() instead. (Joonas)
    - Make "struct intel_gvt" a data member in struct drm_i915_private.(Joonas)
            - Remove {alloc, free}_gvt_device()
            - Rename intel_gvt_{create, destroy}_gvt_device()
            - Expost intel_gvt_init_host()
    - Remove the dummy "struct intel_gvt" declaration in intel_gvt.h (Joonas)
    
    v6:
    - Refine introduction in Kconfig. (Chris)
    - The exposed API functions will take struct intel_gvt * instead of
    void *. (Chris/Tvrtko)
    - Remove most memebers of strct intel_gvt_device_info. Will add them
    in the device model patches.(Chris)
    - Remove gvt_info() and gvt_err() in debug.h. (Chris)
    - Move GVT kernel parameter into i915_params. (Chris)
    - Remove include/drm/i915_gvt.h, as GVT-g will be built within i915.
    - Remove the redundant struct i915_gvt *, as the functions in i915
    will directly take struct intel_gvt *.
    - Add more comments for reviewer.
    
    v5:
    Take Tvrtko's comments:
    - Fix the misspelled words in Kconfig
    - Let functions take drm_i915_private * instead of struct drm_device *
    - Remove redundant prints/local varible initialization
    
    v3:
    Take Joonas' comments:
    - Change file name i915_gvt.* to intel_gvt.*
    - Move GVT kernel parameter into intel_gvt.c
    - Remove redundant debug macros
    - Change error handling style
    - Add introductions for some stub functions
    - Introduce drm/i915_gvt.h.
    
    Take Kevin's comments:
    - Move GVT-g host/guest check into intel_vgt_balloon in i915_gem_gtt.c
    
    v2:
    - Introduce i915_gvt.c.
    It's necessary to introduce the stubs between i915 driver and GVT-g host,
    as GVT-g components is configurable in kernel config. When disabled, the
    stubs here do nothing.
    
    Take Joonas' comments:
    - Replace boolean return value with int.
    - Replace customized info/warn/debug macros with DRM macros.
    - Document all non-static functions like i915.
    - Remove empty and unused functions.
    - Replace magic number with marcos.
    - Set GVT-g in kernel config to "n" by default.
    
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466078825-6662-5-git-send-email-zhi.a.wang@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h
new file mode 100644
index 000000000000..03601e3ffa7c
--- /dev/null
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright(c) 2011-2016 Intel Corporation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _GVT_MPT_H_
+#define _GVT_MPT_H_
+
+/**
+ * DOC: Hypervisor Service APIs for GVT-g Core Logic
+ *
+ * This is the glue layer between specific hypervisor MPT modules and GVT-g core
+ * logic. Each kind of hypervisor MPT module provides a collection of function
+ * callbacks and will be attached to GVT host when the driver is loading.
+ * GVT-g core logic will call these APIs to request specific services from
+ * hypervisor.
+ */
+
+/**
+ * intel_gvt_hypervisor_detect_host - check if GVT-g is running within
+ * hypervisor host/privilged domain
+ *
+ * Returns:
+ * Zero on success, -ENODEV if current kernel is running inside a VM
+ */
+static inline int intel_gvt_hypervisor_detect_host(void)
+{
+	return intel_gvt_host.mpt->detect_host();
+}
+
+#endif /* _GVT_MPT_H_ */
