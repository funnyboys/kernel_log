commit 4381bbd856d2cc481428fcad732854a92e6d3639
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Apr 2 14:48:19 2020 +0300

    drm/i915/uc: prefer struct drm_device based logging
    
    Prefer struct drm_device based logging over struct device based logging.
    
    No functional changes.
    
    Cc: Wambui Karuga <wambui.karugax@gmail.com>
    Reviewed-by: Wambui Karuga <wambui.karugax@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200402114819.17232-17-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 4681cdd24da4..f518fe05c6f9 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -63,25 +63,25 @@ static void __confirm_options(struct intel_uc *uc)
 	}
 
 	if (!intel_uc_supports_guc(uc))
-		dev_info(i915->drm.dev,
+		drm_info(&i915->drm,
 			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "GuC is not supported!");
 
 	if (i915_modparams.enable_guc & ENABLE_GUC_LOAD_HUC &&
 	    !intel_uc_supports_huc(uc))
-		dev_info(i915->drm.dev,
+		drm_info(&i915->drm,
 			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "HuC is not supported!");
 
 	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION &&
 	    !intel_uc_supports_guc_submission(uc))
-		dev_info(i915->drm.dev,
+		drm_info(&i915->drm,
 			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "GuC submission is N/A");
 
 	if (i915_modparams.enable_guc & ~(ENABLE_GUC_SUBMISSION |
 					  ENABLE_GUC_LOAD_HUC))
-		dev_info(i915->drm.dev,
+		drm_info(&i915->drm,
 			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "undocumented flag");
 }
@@ -480,14 +480,14 @@ static int __uc_init_hw(struct intel_uc *uc)
 	if (intel_uc_uses_guc_submission(uc))
 		intel_guc_submission_enable(guc);
 
-	dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
+	drm_info(&i915->drm, "%s firmware %s version %u.%u %s:%s\n",
 		 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_GUC), guc->fw.path,
 		 guc->fw.major_ver_found, guc->fw.minor_ver_found,
 		 "submission",
 		 enableddisabled(intel_uc_uses_guc_submission(uc)));
 
 	if (intel_uc_uses_huc(uc)) {
-		dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
+		drm_info(&i915->drm, "%s firmware %s version %u.%u %s:%s\n",
 			 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_HUC),
 			 huc->fw.path,
 			 huc->fw.major_ver_found, huc->fw.minor_ver_found,
@@ -508,7 +508,7 @@ static int __uc_init_hw(struct intel_uc *uc)
 	__uc_sanitize(uc);
 
 	if (!ret) {
-		dev_notice(i915->drm.dev, "GuC is uninitialized\n");
+		drm_notice(&i915->drm, "GuC is uninitialized\n");
 		/* We want to run without GuC submission */
 		return 0;
 	}

commit 61d5c507e93dda681b135c8fa694b8d56c816ba5
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Apr 2 14:48:12 2020 +0300

    drm/i915/uc: prefer struct drm_device based logging
    
    Prefer struct drm_device based logging over struct device based logging.
    
    No functional changes.
    
    Cc: Wambui Karuga <wambui.karugax@gmail.com>
    Reviewed-by: Wambui Karuga <wambui.karugax@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200402114819.17232-10-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index b11e564ef22e..4681cdd24da4 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -45,12 +45,12 @@ static void __confirm_options(struct intel_uc *uc)
 {
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
 
-	DRM_DEV_DEBUG_DRIVER(i915->drm.dev,
-			     "enable_guc=%d (guc:%s submission:%s huc:%s)\n",
-			     i915_modparams.enable_guc,
-			     yesno(intel_uc_wants_guc(uc)),
-			     yesno(intel_uc_wants_guc_submission(uc)),
-			     yesno(intel_uc_wants_huc(uc)));
+	drm_dbg(&i915->drm,
+		"enable_guc=%d (guc:%s submission:%s huc:%s)\n",
+		i915_modparams.enable_guc,
+		yesno(intel_uc_wants_guc(uc)),
+		yesno(intel_uc_wants_guc_submission(uc)),
+		yesno(intel_uc_wants_huc(uc)));
 
 	if (i915_modparams.enable_guc == -1)
 		return;

commit a9410a6250643079a614c500240fc5942e66b383
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Mar 26 11:11:21 2020 -0700

    drm/i915/uc: do not free err log on uc_fini
    
    We need to keep the GuC error logs around to debug the load failure,
    so we can't clean them in the error unwind, which includes uc_fini().
    Moving the cleanup to driver remove ensures that the logs stick around
    long enough for us to dump them.
    
    v2: reword commit msg (John)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200326181121.16869-7-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index a4cbe06e06bd..b11e564ef22e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -131,6 +131,13 @@ static void __uc_free_load_err_log(struct intel_uc *uc)
 		i915_gem_object_put(log);
 }
 
+void intel_uc_driver_remove(struct intel_uc *uc)
+{
+	intel_uc_fini_hw(uc);
+	intel_uc_fini(uc);
+	__uc_free_load_err_log(uc);
+}
+
 static inline bool guc_communication_enabled(struct intel_guc *guc)
 {
 	return intel_guc_ct_enabled(&guc->ct);
@@ -311,8 +318,6 @@ static void __uc_fini(struct intel_uc *uc)
 {
 	intel_huc_fini(&uc->huc);
 	intel_guc_fini(&uc->guc);
-
-	__uc_free_load_err_log(uc);
 }
 
 static int __uc_sanitize(struct intel_uc *uc)

commit 42f96e5bd41e91fc10f7adbcbf0031742eb56be1
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Feb 18 14:33:26 2020 -0800

    drm/i915/uc: consolidate firmware cleanup
    
    We are quite trigger happy in cleaning up the firmware blobs, as we do
    so from several error/fini paths in GuC/HuC/uC code. We do have the
    __uc_cleanup_firmwares cleanup function, which unwinds
    __uc_fetch_firmwares and is already called both from the error path of
    gem_init and from gem_driver_release, so let's stop cleaning up from
    all the other paths.
    
    The fact that we're not cleaning the firmware immediately means that
    we can't consider firmware availability as an indication of
    initialization success. A "LOADABLE" status has been added to
    indicate that the initialization was successful, to be used to
    selectively load HuC only if HuC init has completed (HuC init failure
    is not considered a fatal error).
    
    v2: s/ready_to_load/loadable (Michal), only run guc/huc_fini if the
        fw is in loadable state
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com> #v1
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200218223327.11058-9-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 1c74518c2459..a4cbe06e06bd 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -417,7 +417,7 @@ static int __uc_init_hw(struct intel_uc *uc)
 	GEM_BUG_ON(!intel_uc_supports_guc(uc));
 	GEM_BUG_ON(!intel_uc_wants_guc(uc));
 
-	if (!intel_uc_fw_is_available(&guc->fw)) {
+	if (!intel_uc_fw_is_loadable(&guc->fw)) {
 		ret = __uc_check_hw(uc) ||
 		      intel_uc_fw_is_overridden(&guc->fw) ||
 		      intel_uc_wants_guc_submission(uc) ?

commit 3acffa8cba757a60c0fe24874e0456df8e494778
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Feb 18 14:33:25 2020 -0800

    drm/i915/uc: Abort early on uc_init failure
    
    Now that we can differentiate wants vs uses GuC/HuC, intel_uc_init is
    restricted to running only if we have successfully fetched the required
    blob(s) and are committed to using the microcontroller(s).
    The only remaining thing that can go wrong in uc_init is the allocation
    of GuC/HuC related objects; if we get such a failure better to bail out
    immediately instead of wedging later, like we do for e.g.
    intel_engines_init, since without objects we can't use the HW, including
    not being able to attempt the firmware load.
    
    While at it, remove the unneeded fw_cleanup call (this is handled
    outside of gt_init) and add a probe failure injection point for testing.
    Also, update the logs for <g/h>uc_init failures to probe_failure() since
    they will cause the driver load to fail.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Cc: Matthew Brost <matthew.brost@intel.com>
    Reviewed-by: Fernando Pacheco <fernando.pacheco@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200218223327.11058-8-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index f81b4d40bc90..1c74518c2459 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -273,7 +273,7 @@ static void __uc_cleanup_firmwares(struct intel_uc *uc)
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
 }
 
-static void __uc_init(struct intel_uc *uc)
+static int __uc_init(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 	struct intel_huc *huc = &uc->huc;
@@ -282,19 +282,29 @@ static void __uc_init(struct intel_uc *uc)
 	GEM_BUG_ON(!intel_uc_wants_guc(uc));
 
 	if (!intel_uc_uses_guc(uc))
-		return;
+		return 0;
+
+	if (i915_inject_probe_failure(uc_to_gt(uc)->i915))
+		return -ENOMEM;
 
 	/* XXX: GuC submission is unavailable for now */
 	GEM_BUG_ON(intel_uc_uses_guc_submission(uc));
 
 	ret = intel_guc_init(guc);
-	if (ret) {
-		intel_uc_fw_cleanup_fetch(&huc->fw);
-		return;
+	if (ret)
+		return ret;
+
+	if (intel_uc_uses_huc(uc)) {
+		ret = intel_huc_init(huc);
+		if (ret)
+			goto out_guc;
 	}
 
-	if (intel_uc_uses_huc(uc))
-		intel_huc_init(huc);
+	return 0;
+
+out_guc:
+	intel_guc_fini(guc);
+	return ret;
 }
 
 static void __uc_fini(struct intel_uc *uc)

commit 202c98e7169248480d97a79416cbfb1154903d99
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Feb 18 14:33:24 2020 -0800

    drm/i915/guc: Apply new uC status tracking to GuC submission as well
    
    To be able to differentiate the before and after of our commitment to
    GuC submission, which will be used in follow-up patches to early set-up
    the submission structures.
    
    v2: move functions to guc_submission.h (Michal)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200218223327.11058-7-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 5825a6c3e0a0..f81b4d40bc90 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -49,7 +49,7 @@ static void __confirm_options(struct intel_uc *uc)
 			     "enable_guc=%d (guc:%s submission:%s huc:%s)\n",
 			     i915_modparams.enable_guc,
 			     yesno(intel_uc_wants_guc(uc)),
-			     yesno(intel_uc_uses_guc_submission(uc)),
+			     yesno(intel_uc_wants_guc_submission(uc)),
 			     yesno(intel_uc_wants_huc(uc)));
 
 	if (i915_modparams.enable_guc == -1)
@@ -57,7 +57,7 @@ static void __confirm_options(struct intel_uc *uc)
 
 	if (i915_modparams.enable_guc == 0) {
 		GEM_BUG_ON(intel_uc_wants_guc(uc));
-		GEM_BUG_ON(intel_uc_uses_guc_submission(uc));
+		GEM_BUG_ON(intel_uc_wants_guc_submission(uc));
 		GEM_BUG_ON(intel_uc_wants_huc(uc));
 		return;
 	}
@@ -285,7 +285,7 @@ static void __uc_init(struct intel_uc *uc)
 		return;
 
 	/* XXX: GuC submission is unavailable for now */
-	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
+	GEM_BUG_ON(intel_uc_uses_guc_submission(uc));
 
 	ret = intel_guc_init(guc);
 	if (ret) {
@@ -410,7 +410,7 @@ static int __uc_init_hw(struct intel_uc *uc)
 	if (!intel_uc_fw_is_available(&guc->fw)) {
 		ret = __uc_check_hw(uc) ||
 		      intel_uc_fw_is_overridden(&guc->fw) ||
-		      intel_uc_supports_guc_submission(uc) ?
+		      intel_uc_wants_guc_submission(uc) ?
 		      intel_uc_fw_status_to_error(guc->fw.status) : 0;
 		goto err_out;
 	}
@@ -462,14 +462,14 @@ static int __uc_init_hw(struct intel_uc *uc)
 	if (ret)
 		goto err_communication;
 
-	if (intel_uc_supports_guc_submission(uc))
+	if (intel_uc_uses_guc_submission(uc))
 		intel_guc_submission_enable(guc);
 
 	dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
 		 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_GUC), guc->fw.path,
 		 guc->fw.major_ver_found, guc->fw.minor_ver_found,
 		 "submission",
-		 enableddisabled(intel_uc_supports_guc_submission(uc)));
+		 enableddisabled(intel_uc_uses_guc_submission(uc)));
 
 	if (intel_uc_uses_huc(uc)) {
 		dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
@@ -511,7 +511,7 @@ static void __uc_fini_hw(struct intel_uc *uc)
 	if (!intel_guc_is_fw_running(guc))
 		return;
 
-	if (intel_uc_supports_guc_submission(uc))
+	if (intel_uc_uses_guc_submission(uc))
 		intel_guc_submission_disable(guc);
 
 	if (guc_communication_enabled(guc))

commit bfe5a40a7b9a967d11e3b1957216383bdd2acab8
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Feb 18 14:33:23 2020 -0800

    drm/i915/uc: Improve tracking of uC init status
    
    To be able to setup GuC submission functions during engine init we need
    to commit to using GuC as soon as possible.
    Currently, the only thing that can stop us from using the
    microcontrollers once we've fetched the blobs is a fundamental
    error (e.g. OOM); given that if we hit such an error we can't really
    fall-back to anything, we can "officialize" the FW fetching completion
    as the moment at which we're committing to using GuC.
    
    To better differentiate this case, the uses_guc check, which indicates
    that GuC is supported and was selected in modparam, is renamed to
    wants_guc and a new uses_guc is introduced to represent the case were
    we're committed to using the GuC. Note that uses_guc does still not imply
    that the blob is actually loaded on the HW (is_running is the check for
    that). Also, since we need to have attempted the fetch for the result
    of uses_guc to be meaningful, we need to make sure we've moved away
    from INTEL_UC_FIRMWARE_SELECTED.
    
    All the GuC changes have been mirrored on the HuC for coherency.
    
    v2: split fetch return changes and new macros to their own patches,
        support HuC only if GuC is wanted, improve "used" state
        description (Michal)
    
    v3: s/wants_huc/uses_huc in uc_init_wopcm
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Cc: Matthew Brost <matthew.brost@intel.com>
    Reviewed-by: Fernando Pacheco <fernando.pacheco@intel.com> #v1
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200218223327.11058-6-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index affc4d6f9ead..5825a6c3e0a0 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -48,17 +48,17 @@ static void __confirm_options(struct intel_uc *uc)
 	DRM_DEV_DEBUG_DRIVER(i915->drm.dev,
 			     "enable_guc=%d (guc:%s submission:%s huc:%s)\n",
 			     i915_modparams.enable_guc,
-			     yesno(intel_uc_uses_guc(uc)),
+			     yesno(intel_uc_wants_guc(uc)),
 			     yesno(intel_uc_uses_guc_submission(uc)),
-			     yesno(intel_uc_uses_huc(uc)));
+			     yesno(intel_uc_wants_huc(uc)));
 
 	if (i915_modparams.enable_guc == -1)
 		return;
 
 	if (i915_modparams.enable_guc == 0) {
-		GEM_BUG_ON(intel_uc_uses_guc(uc));
+		GEM_BUG_ON(intel_uc_wants_guc(uc));
 		GEM_BUG_ON(intel_uc_uses_guc_submission(uc));
-		GEM_BUG_ON(intel_uc_uses_huc(uc));
+		GEM_BUG_ON(intel_uc_wants_huc(uc));
 		return;
 	}
 
@@ -93,7 +93,7 @@ void intel_uc_init_early(struct intel_uc *uc)
 
 	__confirm_options(uc);
 
-	if (intel_uc_uses_guc(uc))
+	if (intel_uc_wants_guc(uc))
 		uc->ops = &uc_ops_on;
 	else
 		uc->ops = &uc_ops_off;
@@ -257,13 +257,13 @@ static void __uc_fetch_firmwares(struct intel_uc *uc)
 {
 	int err;
 
-	GEM_BUG_ON(!intel_uc_uses_guc(uc));
+	GEM_BUG_ON(!intel_uc_wants_guc(uc));
 
 	err = intel_uc_fw_fetch(&uc->guc.fw);
 	if (err)
 		return;
 
-	if (intel_uc_uses_huc(uc))
+	if (intel_uc_wants_huc(uc))
 		intel_uc_fw_fetch(&uc->huc.fw);
 }
 
@@ -279,7 +279,10 @@ static void __uc_init(struct intel_uc *uc)
 	struct intel_huc *huc = &uc->huc;
 	int ret;
 
-	GEM_BUG_ON(!intel_uc_uses_guc(uc));
+	GEM_BUG_ON(!intel_uc_wants_guc(uc));
+
+	if (!intel_uc_uses_guc(uc))
+		return;
 
 	/* XXX: GuC submission is unavailable for now */
 	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
@@ -402,7 +405,7 @@ static int __uc_init_hw(struct intel_uc *uc)
 	int ret, attempts;
 
 	GEM_BUG_ON(!intel_uc_supports_guc(uc));
-	GEM_BUG_ON(!intel_uc_uses_guc(uc));
+	GEM_BUG_ON(!intel_uc_wants_guc(uc));
 
 	if (!intel_uc_fw_is_available(&guc->fw)) {
 		ret = __uc_check_hw(uc) ||

commit e85de17703853e66ec97044c06163d774dbe605d
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 31 15:37:06 2020 +0000

    drm/i915/guc: Introduce guc_is_ready
    
    We already have guc_is_running function, but it only reflects
    firmware status, while to fully use GuC we need to know if we've
    already established communication with it.
    
    v2: also s/intel_guc_is_running/intel_guc_is_fw_running (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200131153706.109528-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 64934a876a50..affc4d6f9ead 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -505,7 +505,7 @@ static void __uc_fini_hw(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_guc_is_running(guc))
+	if (!intel_guc_is_fw_running(guc))
 		return;
 
 	if (intel_uc_supports_guc_submission(uc))
@@ -527,7 +527,7 @@ void intel_uc_reset_prepare(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_guc_is_running(guc))
+	if (!intel_guc_is_ready(guc))
 		return;
 
 	guc_disable_communication(guc);
@@ -539,7 +539,7 @@ void intel_uc_runtime_suspend(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	int err;
 
-	if (!intel_guc_is_running(guc))
+	if (!intel_guc_is_ready(guc))
 		return;
 
 	err = intel_guc_suspend(guc);
@@ -554,7 +554,7 @@ void intel_uc_suspend(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	intel_wakeref_t wakeref;
 
-	if (!intel_guc_is_running(guc))
+	if (!intel_guc_is_ready(guc))
 		return;
 
 	with_intel_runtime_pm(uc_to_gt(uc)->uncore->rpm, wakeref)
@@ -566,7 +566,7 @@ static int __uc_resume(struct intel_uc *uc, bool enable_communication)
 	struct intel_guc *guc = &uc->guc;
 	int err;
 
-	if (!intel_guc_is_running(guc))
+	if (!intel_guc_is_fw_running(guc))
 		return 0;
 
 	/* Make sure we enable communication if and only if it's disabled */

commit 1868c7579f3522423b2f31f39e9ce752a4d457ab
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 10 22:27:23 2020 +0000

    drm/i915/uc: Add sanitize to to intel_uc_ops
    
    uC sanitization is only meaningful if we are running with uC present
    or enabled. Make this function part of the uc_ops.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200110222723.14724-5-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 105b7792c9a0..64934a876a50 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -315,14 +315,6 @@ static int __uc_sanitize(struct intel_uc *uc)
 	return __intel_uc_reset_hw(uc);
 }
 
-void intel_uc_sanitize(struct intel_uc *uc)
-{
-	if (!intel_uc_supports_guc(uc))
-		return;
-
-	__uc_sanitize(uc);
-}
-
 /* Initialize and verify the uC regs related to uC positioning in WOPCM */
 static int uc_init_wopcm(struct intel_uc *uc)
 {
@@ -615,6 +607,8 @@ static const struct intel_uc_ops uc_ops_off = {
 };
 
 static const struct intel_uc_ops uc_ops_on = {
+	.sanitize = __uc_sanitize,
+
 	.init_fw = __uc_fetch_firmwares,
 	.fini_fw = __uc_cleanup_firmwares,
 

commit cc93f7b040c35e21bf6c477a37e042641c19e5ab
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 10 22:27:22 2020 +0000

    drm/i915/uc: Add init/fini to to intel_uc_ops
    
    uC preparation and cleanup steps are only meaningful if we are
    running with uC enabled. Make these functions part of the uc_ops.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200110222723.14724-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index cd0742f9ba4d..105b7792c9a0 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -273,14 +273,13 @@ static void __uc_cleanup_firmwares(struct intel_uc *uc)
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
 }
 
-void intel_uc_init(struct intel_uc *uc)
+static void __uc_init(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 	struct intel_huc *huc = &uc->huc;
 	int ret;
 
-	if (!intel_uc_uses_guc(uc))
-		return;
+	GEM_BUG_ON(!intel_uc_uses_guc(uc));
 
 	/* XXX: GuC submission is unavailable for now */
 	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
@@ -295,7 +294,7 @@ void intel_uc_init(struct intel_uc *uc)
 		intel_huc_init(huc);
 }
 
-void intel_uc_fini(struct intel_uc *uc)
+static void __uc_fini(struct intel_uc *uc)
 {
 	intel_huc_fini(&uc->huc);
 	intel_guc_fini(&uc->guc);
@@ -619,6 +618,9 @@ static const struct intel_uc_ops uc_ops_on = {
 	.init_fw = __uc_fetch_firmwares,
 	.fini_fw = __uc_cleanup_firmwares,
 
+	.init = __uc_init,
+	.fini = __uc_fini,
+
 	.init_hw = __uc_init_hw,
 	.fini_hw = __uc_fini_hw,
 };

commit 39ddb8632035d318c905f41a6c574341504f91f6
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 10 22:27:21 2020 +0000

    drm/i915/uc: Add init_fw/fini_fw to to intel_uc_ops
    
    Firmware fetching and cleanup steps are only meaningful if we are
    running with uC enabled. Make these functions part of the uc_ops.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200110222723.14724-3-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 9bcec6e0d370..cd0742f9ba4d 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -253,12 +253,11 @@ static void guc_disable_communication(struct intel_guc *guc)
 	DRM_INFO("GuC communication disabled\n");
 }
 
-void intel_uc_fetch_firmwares(struct intel_uc *uc)
+static void __uc_fetch_firmwares(struct intel_uc *uc)
 {
 	int err;
 
-	if (!intel_uc_uses_guc(uc))
-		return;
+	GEM_BUG_ON(!intel_uc_uses_guc(uc));
 
 	err = intel_uc_fw_fetch(&uc->guc.fw);
 	if (err)
@@ -268,7 +267,7 @@ void intel_uc_fetch_firmwares(struct intel_uc *uc)
 		intel_uc_fw_fetch(&uc->huc.fw);
 }
 
-void intel_uc_cleanup_firmwares(struct intel_uc *uc)
+static void __uc_cleanup_firmwares(struct intel_uc *uc)
 {
 	intel_uc_fw_cleanup_fetch(&uc->huc.fw);
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
@@ -617,6 +616,9 @@ static const struct intel_uc_ops uc_ops_off = {
 };
 
 static const struct intel_uc_ops uc_ops_on = {
+	.init_fw = __uc_fetch_firmwares,
+	.fini_fw = __uc_cleanup_firmwares,
+
 	.init_hw = __uc_init_hw,
 	.fini_hw = __uc_fini_hw,
 };

commit 6fbeda0bfd210f9bd6fef9b73e5d45b2612fbdcb
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 10 22:27:20 2020 +0000

    drm/i915/uc: Add ops to intel_uc
    
    Instead of spreading multiple conditionals across the uC code
    to find out current mode of uC operation, start using predefined
    set of function pointers that reflect that mode.
    
    Begin with pair of init_hw/fini_hw functions that are responsible
    for uC hardware initialization and cleanup.
    
    v2: drop ops_none, use macro to generate ops helpers
    v3: reuse __uc_check_hw to avoid redundant comment
    v4: forward declare ops struct vs functions
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200110222723.14724-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 3ffc6267f96e..9bcec6e0d370 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -12,6 +12,9 @@
 
 #include "i915_drv.h"
 
+static const struct intel_uc_ops uc_ops_off;
+static const struct intel_uc_ops uc_ops_on;
+
 /* Reset GuC providing us with fresh state for both GuC and HuC.
  */
 static int __intel_uc_reset_hw(struct intel_uc *uc)
@@ -89,6 +92,11 @@ void intel_uc_init_early(struct intel_uc *uc)
 	intel_huc_init_early(&uc->huc);
 
 	__confirm_options(uc);
+
+	if (intel_uc_uses_guc(uc))
+		uc->ops = &uc_ops_on;
+	else
+		uc->ops = &uc_ops_off;
 }
 
 void intel_uc_driver_late_release(struct intel_uc *uc)
@@ -380,13 +388,8 @@ static bool uc_is_wopcm_locked(struct intel_uc *uc)
 	       (intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET) & GUC_WOPCM_OFFSET_VALID);
 }
 
-int intel_uc_init_hw(struct intel_uc *uc)
+static int __uc_check_hw(struct intel_uc *uc)
 {
-	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
-	struct intel_guc *guc = &uc->guc;
-	struct intel_huc *huc = &uc->huc;
-	int ret, attempts;
-
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
@@ -395,11 +398,24 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	 * before on this system after reboot, otherwise we risk GPU hangs.
 	 * To check if GuC was loaded before we look at WOPCM registers.
 	 */
-	if (!intel_uc_uses_guc(uc) && !uc_is_wopcm_locked(uc))
-		return 0;
+	if (uc_is_wopcm_locked(uc))
+		return -EIO;
+
+	return 0;
+}
+
+static int __uc_init_hw(struct intel_uc *uc)
+{
+	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
+	struct intel_guc *guc = &uc->guc;
+	struct intel_huc *huc = &uc->huc;
+	int ret, attempts;
+
+	GEM_BUG_ON(!intel_uc_supports_guc(uc));
+	GEM_BUG_ON(!intel_uc_uses_guc(uc));
 
 	if (!intel_uc_fw_is_available(&guc->fw)) {
-		ret = uc_is_wopcm_locked(uc) ||
+		ret = __uc_check_hw(uc) ||
 		      intel_uc_fw_is_overridden(&guc->fw) ||
 		      intel_uc_supports_guc_submission(uc) ?
 		      intel_uc_fw_status_to_error(guc->fw.status) : 0;
@@ -495,7 +511,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	return -EIO;
 }
 
-void intel_uc_fini_hw(struct intel_uc *uc)
+static void __uc_fini_hw(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
@@ -595,3 +611,12 @@ int intel_uc_runtime_resume(struct intel_uc *uc)
 	 */
 	return __uc_resume(uc, true);
 }
+
+static const struct intel_uc_ops uc_ops_off = {
+	.init_hw = __uc_check_hw,
+};
+
+static const struct intel_uc_ops uc_ops_on = {
+	.init_hw = __uc_init_hw,
+	.fini_hw = __uc_fini_hw,
+};

commit e26b6d4341476f6944f57bb78fffcdf332c5948b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Dec 22 12:07:52 2019 +0000

    drm/i915/gt: Pull GT initialisation under intel_gt_init()
    
    Begin pulling the GT setup underneath a single GT umbrella; let intel_gt
    take ownership of its engines! As hinted, the complication is the
    lifetime of the probed engine versus the active lifetime of the GT
    backends. We need to detect the engine layout early and keep it until
    the end so that we can sanitize state on takeover and release.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Acked-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191222120752.1368352-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 782b8f95183f..3ffc6267f96e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -262,12 +262,7 @@ void intel_uc_fetch_firmwares(struct intel_uc *uc)
 
 void intel_uc_cleanup_firmwares(struct intel_uc *uc)
 {
-	if (!intel_uc_uses_guc(uc))
-		return;
-
-	if (intel_uc_uses_huc(uc))
-		intel_uc_fw_cleanup_fetch(&uc->huc.fw);
-
+	intel_uc_fw_cleanup_fetch(&uc->huc.fw);
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
 }
 
@@ -295,15 +290,8 @@ void intel_uc_init(struct intel_uc *uc)
 
 void intel_uc_fini(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &uc->guc;
-
-	if (!intel_uc_uses_guc(uc))
-		return;
-
-	if (intel_uc_uses_huc(uc))
-		intel_huc_fini(&uc->huc);
-
-	intel_guc_fini(guc);
+	intel_huc_fini(&uc->huc);
+	intel_guc_fini(&uc->guc);
 
 	__uc_free_load_err_log(uc);
 }

commit 8c69bd74a00baff85f4ef46b9f79263a42e0d82c
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Mon Dec 16 17:23:14 2019 -0800

    drm/i915/guc: Remove function pointers for send/receive calls
    
    Since we started using CT buffers on all gens, the function pointers can
    only be set to either the _nop() or the _ct() functions. Since the
    _nop() case applies to when the CT are disabled, we can just handle that
    case in the _ct() functions and call them directly.
    
    v2: keep intel_guc_send() and make the CT send/receive functions work on
        intel_guc_ct. (Michal)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Cc: Matthew Brost <matthew.brost@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191217012316.13271-5-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 6e17e449e0a8..782b8f95183f 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -123,6 +123,11 @@ static void __uc_free_load_err_log(struct intel_uc *uc)
 		i915_gem_object_put(log);
 }
 
+static inline bool guc_communication_enabled(struct intel_guc *guc)
+{
+	return intel_guc_ct_enabled(&guc->ct);
+}
+
 /*
  * Events triggered while CT buffers are disabled are logged in the SCRATCH_15
  * register using the same bits used in the CT message payload. Since our
@@ -158,7 +163,7 @@ static void guc_handle_mmio_msg(struct intel_guc *guc)
 	struct drm_i915_private *i915 = guc_to_gt(guc)->i915;
 
 	/* we need communication to be enabled to reply to GuC */
-	GEM_BUG_ON(guc->handler == intel_guc_to_host_event_handler_nop);
+	GEM_BUG_ON(!guc_communication_enabled(guc));
 
 	if (!guc->mmio_msg)
 		return;
@@ -185,11 +190,6 @@ static void guc_disable_interrupts(struct intel_guc *guc)
 	guc->interrupts.disable(guc);
 }
 
-static inline bool guc_communication_enabled(struct intel_guc *guc)
-{
-	return guc->send != intel_guc_send_nop;
-}
-
 static int guc_enable_communication(struct intel_guc *guc)
 {
 	struct drm_i915_private *i915 = guc_to_gt(guc)->i915;
@@ -205,9 +205,6 @@ static int guc_enable_communication(struct intel_guc *guc)
 	if (ret)
 		return ret;
 
-	guc->send = intel_guc_send_ct;
-	guc->handler = intel_guc_to_host_event_handler_ct;
-
 	/* check for mmio messages received before/during the CT enable */
 	guc_get_mmio_msg(guc);
 	guc_handle_mmio_msg(guc);
@@ -216,7 +213,7 @@ static int guc_enable_communication(struct intel_guc *guc)
 
 	/* check for CT messages received before we enabled interrupts */
 	spin_lock_irq(&i915->irq_lock);
-	intel_guc_to_host_event_handler_ct(guc);
+	intel_guc_ct_event_handler(&guc->ct);
 	spin_unlock_irq(&i915->irq_lock);
 
 	DRM_INFO("GuC communication enabled\n");
@@ -235,9 +232,6 @@ static void guc_disable_communication(struct intel_guc *guc)
 
 	guc_disable_interrupts(guc);
 
-	guc->send = intel_guc_send_nop;
-	guc->handler = intel_guc_to_host_event_handler_nop;
-
 	intel_guc_ct_disable(&guc->ct);
 
 	/*

commit e627ad50a2d787dcd8d1e7755a995ec31efa0e44
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Mon Dec 16 17:23:10 2019 -0800

    drm/i915/guc: Merge communication_stop and communication_disable
    
    The only difference from the GuC POV between guc_communication_stop and
    guc_communication_disable is that the former can be called after GuC
    has been reset. Instead of having two separate paths, we can just skip
    the call into GuC in the disabling path and re-use that.
    
    Note that by using the disable() path instead of the stop() one there
    are two additional changes in SW side for the stop path:
    
    - interrupts are now disabled before disabling the CT, which is ok
      because we do not want interrupts with CT disabled;
    - guc_get_mmio_msg() is called in the stop case as well, which is ok
      because if there are errors before the reset we do want to record
      them.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Cc: Matthew Brost <matthew.brost@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191217012316.13271-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index f42952403c0b..6e17e449e0a8 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -224,7 +224,7 @@ static int guc_enable_communication(struct intel_guc *guc)
 	return 0;
 }
 
-static void __guc_stop_communication(struct intel_guc *guc)
+static void guc_disable_communication(struct intel_guc *guc)
 {
 	/*
 	 * Events generated during or after CT disable are logged by guc in
@@ -237,20 +237,6 @@ static void __guc_stop_communication(struct intel_guc *guc)
 
 	guc->send = intel_guc_send_nop;
 	guc->handler = intel_guc_to_host_event_handler_nop;
-}
-
-static void guc_stop_communication(struct intel_guc *guc)
-{
-	intel_guc_ct_stop(&guc->ct);
-
-	__guc_stop_communication(guc);
-
-	DRM_INFO("GuC communication stopped\n");
-}
-
-static void guc_disable_communication(struct intel_guc *guc)
-{
-	__guc_stop_communication(guc);
 
 	intel_guc_ct_disable(&guc->ct);
 
@@ -556,7 +542,7 @@ void intel_uc_reset_prepare(struct intel_uc *uc)
 	if (!intel_guc_is_running(guc))
 		return;
 
-	guc_stop_communication(guc);
+	guc_disable_communication(guc);
 	__uc_sanitize(uc);
 }
 

commit cb1b7ad08c22c771500bdd842b01bc12ffcfbb50
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Dec 11 12:45:47 2019 +0000

    drm/i915/uc: Drop explicit i915 param in some uc_fw functions
    
    There is no need to pass explicit i915 since we already have
    a debug trick to get parent gt from uc_fw, we only need to
    make this trick available on non-debug builds.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191211124549.59516-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index c6519066a0f6..f42952403c0b 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -267,18 +267,17 @@ static void guc_disable_communication(struct intel_guc *guc)
 
 void intel_uc_fetch_firmwares(struct intel_uc *uc)
 {
-	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
 	int err;
 
 	if (!intel_uc_uses_guc(uc))
 		return;
 
-	err = intel_uc_fw_fetch(&uc->guc.fw, i915);
+	err = intel_uc_fw_fetch(&uc->guc.fw);
 	if (err)
 		return;
 
 	if (intel_uc_uses_huc(uc))
-		intel_uc_fw_fetch(&uc->huc.fw, i915);
+		intel_uc_fw_fetch(&uc->huc.fw);
 }
 
 void intel_uc_cleanup_firmwares(struct intel_uc *uc)

commit e9362e1336feb1e942da036aba9ec2aeffe9e4d2
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Dec 5 14:02:41 2019 -0800

    drm/i915/guc: kill doorbell code and selftests
    
    Instead of relying on the workqueue, the upcoming reworked GuC
    submission flow will offer the host driver indipendent control over
    the execution status of each context submitted to GuC. As part of this,
    the doorbell usage model has been reworked, with each doorbell being
    paired to a single lrc and a doorbell ring representing new work
    available for that specific context. This mechanism, however, limits
    the number of contexts that can be registered with GuC to the number of
    doorbells, which is an undesired limitation. To avoid this limitation,
    we requested the GuC team to also provide a H2G that will allow the host
    to notify the GuC of work available for a specified lrc, so we can use
    that mechanism instead of relying on the doorbells. We can therefore drop
    the doorbell code we currently have, also given the fact that in the
    unlikely case we'd want to switch back to using doorbells we'd have to
    heavily rework it.
    The workqueue will still have a use in the new interface to pass special
    commands, so that code has been retained for now.
    
    With the doorbells gone and the GuC client becoming even simpler, the
    existing GuC selftests don't give us any meaningful coverage so we can
    remove them as well. Some selftests might come with the new code, but
    they will look different from what we have now so if doesn't seem worth
    it to keep the file around in the meantime.
    
    v2: fix comments and commit message (John)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Cc: Matthew Brost <matthew.brost@intel.com>
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191205220243.27403-3-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 629b19377a29..c6519066a0f6 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -486,11 +486,8 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (ret)
 		goto err_communication;
 
-	if (intel_uc_supports_guc_submission(uc)) {
-		ret = intel_guc_submission_enable(guc);
-		if (ret)
-			goto err_communication;
-	}
+	if (intel_uc_supports_guc_submission(uc))
+		intel_guc_submission_enable(guc);
 
 	dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
 		 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_GUC), guc->fw.path,

commit dd6e38dfc1286d307489a1ad890a87e096d9873b
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Tue Oct 29 11:20:35 2019 +0100

    drm/i915: Fix i915_inject_load_error() name to read *_probe_*
    
    Commit 50d84418f586 ("drm/i915: Add i915 to i915_inject_probe_failure")
    introduced new functions unfortunately named incompatibly with rules
    established by commit f2db53f14d3d ("drm/i915: Replace "_load" with
    "_probe" consequently").  Fix it for consistency.
    
    Suggested-by: Michał Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Cc: Michał Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Piotr Piórkowski <piotr.piorkowski@intel.com>
    Cc: Tomasz Lis <tomasz.lis@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191029102036.6326-2-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 3fdbc935d155..629b19377a29 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -20,7 +20,7 @@ static int __intel_uc_reset_hw(struct intel_uc *uc)
 	int ret;
 	u32 guc_status;
 
-	ret = i915_inject_load_error(gt->i915, -ENXIO);
+	ret = i915_inject_probe_error(gt->i915, -ENXIO);
 	if (ret)
 		return ret;
 
@@ -197,7 +197,7 @@ static int guc_enable_communication(struct intel_guc *guc)
 
 	GEM_BUG_ON(guc_communication_enabled(guc));
 
-	ret = i915_inject_load_error(i915, -ENXIO);
+	ret = i915_inject_probe_error(i915, -ENXIO);
 	if (ret)
 		return ret;
 
@@ -372,7 +372,7 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	GEM_BUG_ON(!(size & GUC_WOPCM_SIZE_MASK));
 	GEM_BUG_ON(size & ~GUC_WOPCM_SIZE_MASK);
 
-	err = i915_inject_load_error(gt->i915, -ENXIO);
+	err = i915_inject_probe_error(gt->i915, -ENXIO);
 	if (err)
 		return err;
 

commit cd6a851385be878f086204aa0e7cd3bec9ea909f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Oct 7 16:45:31 2019 +0100

    drm/i915/gt: Prefer local path to runtime powermanagement
    
    Avoid going to the base i915 device when we already have a path from gt
    to the runtime powermanagement interface. The benefit is that it looks a
    bit more self-consistent to always be acquiring the gt->uncore->rpm for
    use with the gt->uncore.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191007154531.1750-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 29a9eec60d2e..3fdbc935d155 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -587,7 +587,7 @@ void intel_uc_suspend(struct intel_uc *uc)
 	if (!intel_guc_is_running(guc))
 		return;
 
-	with_intel_runtime_pm(&uc_to_gt(uc)->i915->runtime_pm, wakeref)
+	with_intel_runtime_pm(uc_to_gt(uc)->uncore->rpm, wakeref)
 		intel_uc_runtime_suspend(uc);
 }
 

commit 9be02fde93e5b564663f10a48f19159fba718e3d
Author: Fernando Pacheco <fernando.pacheco@intel.com>
Date:   Thu Aug 29 10:41:53 2019 -0700

    drm/i915/uc: Extract common code from GuC stop/disable comm
    
    During normal driver unload we attempt to disable GuC communication
    while it is currently stopped. This results in a nop'd call to
    intel_guc_ct_disable within guc_disable_communication because
    stop/disable rely on the same flag to prevent further comms with CT.
    
    We can avoid the call to disable and still leave communication in a
    satisfactory state by extracting a set of shared steps from stop/disable.
    This set can include guc_disable_interrupts as we do not require the
    single caller of guc_stop_communication to be atomic:
    "drm/i915/selftests: Fixup atomic reset checking".
    
    This situation (stop -> disable) only occurs during intel_uc_fini_hw,
    so during fini, call guc_disable_communication only if currently enabled.
    The symmetric calls to enable/disable remain unmodified for all other
    scenarios.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=110943
    Signed-off-by: Fernando Pacheco <fernando.pacheco@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190829174154.14675-1-fernando.pacheco@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 71ee7ab035cc..29a9eec60d2e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -224,17 +224,7 @@ static int guc_enable_communication(struct intel_guc *guc)
 	return 0;
 }
 
-static void guc_stop_communication(struct intel_guc *guc)
-{
-	intel_guc_ct_stop(&guc->ct);
-
-	guc->send = intel_guc_send_nop;
-	guc->handler = intel_guc_to_host_event_handler_nop;
-
-	guc_clear_mmio_msg(guc);
-}
-
-static void guc_disable_communication(struct intel_guc *guc)
+static void __guc_stop_communication(struct intel_guc *guc)
 {
 	/*
 	 * Events generated during or after CT disable are logged by guc in
@@ -247,6 +237,20 @@ static void guc_disable_communication(struct intel_guc *guc)
 
 	guc->send = intel_guc_send_nop;
 	guc->handler = intel_guc_to_host_event_handler_nop;
+}
+
+static void guc_stop_communication(struct intel_guc *guc)
+{
+	intel_guc_ct_stop(&guc->ct);
+
+	__guc_stop_communication(guc);
+
+	DRM_INFO("GuC communication stopped\n");
+}
+
+static void guc_disable_communication(struct intel_guc *guc)
+{
+	__guc_stop_communication(guc);
 
 	intel_guc_ct_disable(&guc->ct);
 
@@ -537,7 +541,9 @@ void intel_uc_fini_hw(struct intel_uc *uc)
 	if (intel_uc_supports_guc_submission(uc))
 		intel_guc_submission_disable(guc);
 
-	guc_disable_communication(guc);
+	if (guc_communication_enabled(guc))
+		guc_disable_communication(guc);
+
 	__uc_sanitize(uc);
 }
 

commit a8dc0f6d187bcccc7c1a41f0062badbf3d74e44c
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 18 09:52:04 2019 +0000

    drm/i915/uc: Never fail on HuC firmware errors
    
    There is no need to mark whole GPU as wedged just because
    of the custom HuC fw failure as users can always verify
    actual HuC firmware status using existing HUC_STATUS ioctl.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190818095204.31568-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 10978e7ff06d..71ee7ab035cc 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -457,12 +457,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		if (ret)
 			goto err_out;
 
-		if (intel_uc_uses_huc(uc)) {
-			ret = intel_huc_fw_upload(huc);
-			if (ret && intel_uc_fw_is_overridden(&huc->fw))
-				goto err_out;
-		}
-
+		intel_huc_fw_upload(huc);
 		intel_guc_ads_reset(guc);
 		intel_guc_write_params(guc);
 		ret = intel_guc_fw_upload(guc);
@@ -481,11 +476,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (ret)
 		goto err_log_capture;
 
-	if (intel_uc_fw_is_loaded(&huc->fw)) {
-		ret = intel_huc_auth(huc);
-		if (ret && intel_uc_fw_is_overridden(&huc->fw))
-			goto err_communication;
-	}
+	intel_huc_auth(huc);
 
 	ret = intel_guc_sample_forcewake(guc);
 	if (ret)

commit ee402140274e87030bbdcf92b145974f69ae01d3
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 18 09:52:03 2019 +0000

    drm/i915/uc: Don't always fail on unavailable GuC firmware
    
    If we failed to fetch default GuC firmware and we didn't plan
    to use it for the submission and we never have used GuC before
    then we may continue normal driver load, no need to declare
    GPU wedged (we can use execlist for submission) and it is safe
    to run without the HuC (users will check HuC status anyway).
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190818095204.31568-3-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 6f0b9e05a5f6..10978e7ff06d 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -400,6 +400,15 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	return err;
 }
 
+static bool uc_is_wopcm_locked(struct intel_uc *uc)
+{
+	struct intel_gt *gt = uc_to_gt(uc);
+	struct intel_uncore *uncore = gt->uncore;
+
+	return (intel_uncore_read(uncore, GUC_WOPCM_SIZE) & GUC_WOPCM_SIZE_LOCKED) ||
+	       (intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET) & GUC_WOPCM_OFFSET_VALID);
+}
+
 int intel_uc_init_hw(struct intel_uc *uc)
 {
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
@@ -410,11 +419,19 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
-	if (!intel_uc_uses_guc(uc))
+	/*
+	 * We can silently continue without GuC only if it was never enabled
+	 * before on this system after reboot, otherwise we risk GPU hangs.
+	 * To check if GuC was loaded before we look at WOPCM registers.
+	 */
+	if (!intel_uc_uses_guc(uc) && !uc_is_wopcm_locked(uc))
 		return 0;
 
 	if (!intel_uc_fw_is_available(&guc->fw)) {
-		ret = intel_uc_fw_status_to_error(guc->fw.status);
+		ret = uc_is_wopcm_locked(uc) ||
+		      intel_uc_fw_is_overridden(&guc->fw) ||
+		      intel_uc_supports_guc_submission(uc) ?
+		      intel_uc_fw_status_to_error(guc->fw.status) : 0;
 		goto err_out;
 	}
 
@@ -507,6 +524,12 @@ int intel_uc_init_hw(struct intel_uc *uc)
 err_out:
 	__uc_sanitize(uc);
 
+	if (!ret) {
+		dev_notice(i915->drm.dev, "GuC is uninitialized\n");
+		/* We want to run without GuC submission */
+		return 0;
+	}
+
 	i915_probe_error(i915, "GuC initialization failed %d\n", ret);
 
 	/* We want to keep KMS alive */

commit 0075a20a6dd150e12d9fcb8f22eb7bc4ba241baf
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sat Aug 17 13:11:44 2019 +0000

    drm/i915/uc: Never fail on uC preparation step
    
    Let's wait with decision about importance of uC failure to
    hardware initialization step.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190817131144.26884-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index d8e9be1d7b0e..6f0b9e05a5f6 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -288,27 +288,26 @@ void intel_uc_cleanup_firmwares(struct intel_uc *uc)
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
 }
 
-int intel_uc_init(struct intel_uc *uc)
+void intel_uc_init(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 	struct intel_huc *huc = &uc->huc;
 	int ret;
 
 	if (!intel_uc_uses_guc(uc))
-		return 0;
+		return;
 
 	/* XXX: GuC submission is unavailable for now */
 	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
 
 	ret = intel_guc_init(guc);
-	if (ret)
-		return ret;
-
-	if (intel_uc_uses_huc(uc)) {
-		intel_huc_init(huc);
+	if (ret) {
+		intel_uc_fw_cleanup_fetch(&huc->fw);
+		return;
 	}
 
-	return 0;
+	if (intel_uc_uses_huc(uc))
+		intel_huc_init(huc);
 }
 
 void intel_uc_fini(struct intel_uc *uc)

commit 4a600cb707e1249472bd9c1c7d63bb971fc6675d
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sat Aug 17 13:11:43 2019 +0000

    drm/i915/uc: Cleanup fw fetch on every GuC/HuC init failure
    
    Be consistent and always perform fw fetch cleanup in GuC/HuC specific
    init functions on every failure. Also while converting firmware
    status to error, stop treating SELECTED as non-error, as long term
    we should not see it.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190817131144.26884-3-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 449c432dd768..d8e9be1d7b0e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -305,16 +305,10 @@ int intel_uc_init(struct intel_uc *uc)
 		return ret;
 
 	if (intel_uc_uses_huc(uc)) {
-		ret = intel_huc_init(huc);
-		if (ret)
-			goto out_huc;
+		intel_huc_init(huc);
 	}
 
 	return 0;
-
-out_huc:
-	intel_uc_fw_cleanup_fetch(&huc->fw);
-	return 0;
 }
 
 void intel_uc_fini(struct intel_uc *uc)

commit 356c484822e6ac97dad6947c083fc45d07332c7c
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 16 20:56:58 2019 +0000

    drm/i915/uc: Add explicit DISABLED state for firmware
    
    We really need to have separate NOT_SUPPORTED state (for
    lack of hardware support) and DISABLED state (to indicate
    user decision) as we will have to take special steps even
    if GuC firmware is now disabled but hardware exists and
    could have been previously used.
    
    v2: fix logic (Chris/CI)
    v3: use proper check to avoid probe failure (CI)
    v4: explain status transitions (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190816205658.15020-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 0dc2b0cf4604..449c432dd768 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -45,17 +45,17 @@ static void __confirm_options(struct intel_uc *uc)
 	DRM_DEV_DEBUG_DRIVER(i915->drm.dev,
 			     "enable_guc=%d (guc:%s submission:%s huc:%s)\n",
 			     i915_modparams.enable_guc,
-			     yesno(intel_uc_supports_guc(uc)),
-			     yesno(intel_uc_supports_guc_submission(uc)),
-			     yesno(intel_uc_supports_huc(uc)));
+			     yesno(intel_uc_uses_guc(uc)),
+			     yesno(intel_uc_uses_guc_submission(uc)),
+			     yesno(intel_uc_uses_huc(uc)));
 
 	if (i915_modparams.enable_guc == -1)
 		return;
 
 	if (i915_modparams.enable_guc == 0) {
-		GEM_BUG_ON(intel_uc_supports_guc(uc));
-		GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
-		GEM_BUG_ON(intel_uc_supports_huc(uc));
+		GEM_BUG_ON(intel_uc_uses_guc(uc));
+		GEM_BUG_ON(intel_uc_uses_guc_submission(uc));
+		GEM_BUG_ON(intel_uc_uses_huc(uc));
 		return;
 	}
 
@@ -266,23 +266,23 @@ void intel_uc_fetch_firmwares(struct intel_uc *uc)
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
 	int err;
 
-	if (!intel_uc_supports_guc(uc))
+	if (!intel_uc_uses_guc(uc))
 		return;
 
 	err = intel_uc_fw_fetch(&uc->guc.fw, i915);
 	if (err)
 		return;
 
-	if (intel_uc_supports_huc(uc))
+	if (intel_uc_uses_huc(uc))
 		intel_uc_fw_fetch(&uc->huc.fw, i915);
 }
 
 void intel_uc_cleanup_firmwares(struct intel_uc *uc)
 {
-	if (!intel_uc_supports_guc(uc))
+	if (!intel_uc_uses_guc(uc))
 		return;
 
-	if (intel_uc_supports_huc(uc))
+	if (intel_uc_uses_huc(uc))
 		intel_uc_fw_cleanup_fetch(&uc->huc.fw);
 
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
@@ -294,7 +294,7 @@ int intel_uc_init(struct intel_uc *uc)
 	struct intel_huc *huc = &uc->huc;
 	int ret;
 
-	if (!intel_uc_supports_guc(uc))
+	if (!intel_uc_uses_guc(uc))
 		return 0;
 
 	/* XXX: GuC submission is unavailable for now */
@@ -304,7 +304,7 @@ int intel_uc_init(struct intel_uc *uc)
 	if (ret)
 		return ret;
 
-	if (intel_uc_supports_huc(uc)) {
+	if (intel_uc_uses_huc(uc)) {
 		ret = intel_huc_init(huc);
 		if (ret)
 			goto out_huc;
@@ -321,10 +321,10 @@ void intel_uc_fini(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_uc_supports_guc(uc))
+	if (!intel_uc_uses_guc(uc))
 		return;
 
-	if (intel_uc_supports_huc(uc))
+	if (intel_uc_uses_huc(uc))
 		intel_huc_fini(&uc->huc);
 
 	intel_guc_fini(guc);
@@ -360,7 +360,7 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	struct intel_uncore *uncore = gt->uncore;
 	u32 base = intel_wopcm_guc_base(&gt->i915->wopcm);
 	u32 size = intel_wopcm_guc_size(&gt->i915->wopcm);
-	u32 huc_agent = intel_uc_supports_huc(uc) ? HUC_LOADING_AGENT_GUC : 0;
+	u32 huc_agent = intel_uc_uses_huc(uc) ? HUC_LOADING_AGENT_GUC : 0;
 	u32 mask;
 	int err;
 
@@ -417,6 +417,9 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
+	if (!intel_uc_uses_guc(uc))
+		return 0;
+
 	if (!intel_uc_fw_is_available(&guc->fw)) {
 		ret = intel_uc_fw_status_to_error(guc->fw.status);
 		goto err_out;
@@ -444,7 +447,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		if (ret)
 			goto err_out;
 
-		if (intel_uc_supports_huc(uc)) {
+		if (intel_uc_uses_huc(uc)) {
 			ret = intel_huc_fw_upload(huc);
 			if (ret && intel_uc_fw_is_overridden(&huc->fw))
 				goto err_out;
@@ -490,7 +493,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		 "submission",
 		 enableddisabled(intel_uc_supports_guc_submission(uc)));
 
-	if (intel_uc_supports_huc(uc)) {
+	if (intel_uc_uses_huc(uc)) {
 		dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
 			 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_HUC),
 			 huc->fw.path,

commit 3ea5802910545d11180630d41dda0a81c91539f4
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Mon Aug 12 09:29:35 2019 +0000

    drm/i915/uc: Update copyright and license
    
    Include 2019 in copyright years and start using SPDX tag.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190812092935.21048-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 22fa88a7c661..0dc2b0cf4604 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -1,25 +1,6 @@
+// SPDX-License-Identifier: MIT
 /*
- * Copyright © 2016 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
+ * Copyright © 2016-2019 Intel Corporation
  */
 
 #include "gt/intel_gt.h"

commit a5f978c3609f02ae0ccff1bf010b32e41707ef66
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 11 19:51:32 2019 +0000

    drm/i915/uc: Use -EIO code for GuC initialization failures
    
    Since commit 6ca9a2beb54a ("drm/i915: Unwind i915_gem_init() failure")
    we believed that we correctly handle all errors encountered during
    GuC initialization, including special one that indicates request to
    run driver with disabled GPU submission (-EIO).
    
    Unfortunately since commit 121981fafe69 ("drm/i915/guc: Combine
    enable_guc_loading|submission modparams") we stopped using that
    error code to avoid unwanted fallback to execlist submission mode.
    
    In result any GuC initialization failure was treated as non-recoverable
    error leading to driver load abort, so we could not even read related
    GuC error log to investigate cause of the problem.
    
    For now always return -EIO on any uC hardware related failure.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190811195132.9660-5-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index a3a5918c6782..22fa88a7c661 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -530,15 +530,10 @@ int intel_uc_init_hw(struct intel_uc *uc)
 err_out:
 	__uc_sanitize(uc);
 
-	/*
-	 * Note that there is no fallback as either user explicitly asked for
-	 * the GuC or driver default option was to run with the GuC enabled.
-	 */
-	if (GEM_WARN_ON(ret == -EIO))
-		ret = -EINVAL;
-
 	i915_probe_error(i915, "GuC initialization failed %d\n", ret);
-	return ret;
+
+	/* We want to keep KMS alive */
+	return -EIO;
 }
 
 void intel_uc_fini_hw(struct intel_uc *uc)

commit d8d6e5eb2bad48a6a649e3d38fe30c15d965e149
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Mon Aug 12 07:39:49 2019 +0000

    drm/i915/uc: Include HuC firmware version in summary
    
    After successful uC initialization we are reporting GuC
    firmware version and status of GuC submission and HuC.
    Add HuC fw version to this report to make it complete,
    but also skip all HuC info if HuC is not supported.
    
    v2: squeeze to one line (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190812073949.24076-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index aa9701cfc754..a3a5918c6782 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -503,12 +503,20 @@ int intel_uc_init_hw(struct intel_uc *uc)
 			goto err_communication;
 	}
 
-	dev_info(i915->drm.dev, "GuC firmware version %u.%u\n",
-		 guc->fw.major_ver_found, guc->fw.minor_ver_found);
-	dev_info(i915->drm.dev, "GuC submission %s\n",
+	dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
+		 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_GUC), guc->fw.path,
+		 guc->fw.major_ver_found, guc->fw.minor_ver_found,
+		 "submission",
 		 enableddisabled(intel_uc_supports_guc_submission(uc)));
-	dev_info(i915->drm.dev, "HuC %s\n",
-		 enableddisabled(intel_huc_is_authenticated(huc)));
+
+	if (intel_uc_supports_huc(uc)) {
+		dev_info(i915->drm.dev, "%s firmware %s version %u.%u %s:%s\n",
+			 intel_uc_fw_type_repr(INTEL_UC_FW_TYPE_HUC),
+			 huc->fw.path,
+			 huc->fw.major_ver_found, huc->fw.minor_ver_found,
+			 "authenticated",
+			 yesno(intel_huc_is_authenticated(huc)));
+	}
 
 	return 0;
 

commit ae7a3166a708bee439c7f683327f7381bdfd08ec
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 11 19:51:29 2019 +0000

    drm/i915/uc: Fail early if there is no GuC fw available
    
    We don't want to rely on misleading WOPCM partitioning error.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190811195132.9660-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 32aa4509ba1d..aa9701cfc754 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -436,6 +436,11 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
+	if (!intel_uc_fw_is_available(&guc->fw)) {
+		ret = intel_uc_fw_status_to_error(guc->fw.status);
+		goto err_out;
+	}
+
 	ret = uc_init_wopcm(uc);
 	if (ret)
 		goto err_out;

commit a0752c87080ad72e838489a5807b791a117fcb11
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Aug 7 17:00:33 2019 +0000

    drm/i915/uc: WOPCM programming errors are not always real
    
    WOPCM programming error might be due to inserted earlier probe
    failure that could affects HuC firmware loading and thus impacts
    result of WOPCM partitioning that would be now incompatible with
    previously programmed values.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807170034.8440-7-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index c40eab290342..32aa4509ba1d 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -415,11 +415,13 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	return 0;
 
 err_out:
-	DRM_ERROR("Failed to init uC WOPCM registers:\n");
-	DRM_ERROR("DMA_GUC_WOPCM_OFFSET=%#x\n",
-		  intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET));
-	DRM_ERROR("GUC_WOPCM_SIZE=%#x\n",
-		  intel_uncore_read(uncore, GUC_WOPCM_SIZE));
+	i915_probe_error(gt->i915, "Failed to init uC WOPCM registers!\n");
+	i915_probe_error(gt->i915, "%s(%#x)=%#x\n", "DMA_GUC_WOPCM_OFFSET",
+			 i915_mmio_reg_offset(DMA_GUC_WOPCM_OFFSET),
+			 intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET));
+	i915_probe_error(gt->i915, "%s(%#x)=%#x\n", "GUC_WOPCM_SIZE",
+			 i915_mmio_reg_offset(GUC_WOPCM_SIZE),
+			 intel_uncore_read(uncore, GUC_WOPCM_SIZE));
 
 	return err;
 }

commit 4157a962f59d0261030355aaa1646f55c2bed8c9
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Aug 7 17:00:30 2019 +0000

    drm/i915/uc: Don't fetch HuC fw if GuC fw fetch already failed
    
    When we failed to fetch GuC firmware there is no point in fetching
    HuC firmware as we will not be able to use it without working GuC.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807170034.8440-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 3c007e0e1a20..c40eab290342 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -283,11 +283,14 @@ static void guc_disable_communication(struct intel_guc *guc)
 void intel_uc_fetch_firmwares(struct intel_uc *uc)
 {
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
+	int err;
 
 	if (!intel_uc_supports_guc(uc))
 		return;
 
-	intel_uc_fw_fetch(&uc->guc.fw, i915);
+	err = intel_uc_fw_fetch(&uc->guc.fw, i915);
+	if (err)
+		return;
 
 	if (intel_uc_supports_huc(uc))
 		intel_uc_fw_fetch(&uc->huc.fw, i915);

commit 12be4a4c75a2a41ba32b4b1368e9f40e43bfda0a
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Aug 7 17:00:28 2019 +0000

    drm/i915/uc: Prefer dev_info for reporting options
    
    While modparams are global for the i915 module, we are reporting
    status of the params applied against specific device instance.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807170034.8440-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index e87b7904ab7a..3c007e0e1a20 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -59,11 +59,14 @@ static int __intel_uc_reset_hw(struct intel_uc *uc)
 
 static void __confirm_options(struct intel_uc *uc)
 {
-	DRM_DEBUG_DRIVER("enable_guc=%d (guc:%s submission:%s huc:%s)\n",
-			 i915_modparams.enable_guc,
-			 yesno(intel_uc_supports_guc(uc)),
-			 yesno(intel_uc_supports_guc_submission(uc)),
-			 yesno(intel_uc_supports_huc(uc)));
+	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
+
+	DRM_DEV_DEBUG_DRIVER(i915->drm.dev,
+			     "enable_guc=%d (guc:%s submission:%s huc:%s)\n",
+			     i915_modparams.enable_guc,
+			     yesno(intel_uc_supports_guc(uc)),
+			     yesno(intel_uc_supports_guc_submission(uc)),
+			     yesno(intel_uc_supports_huc(uc)));
 
 	if (i915_modparams.enable_guc == -1)
 		return;
@@ -76,22 +79,26 @@ static void __confirm_options(struct intel_uc *uc)
 	}
 
 	if (!intel_uc_supports_guc(uc))
-		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+		dev_info(i915->drm.dev,
+			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "GuC is not supported!");
 
 	if (i915_modparams.enable_guc & ENABLE_GUC_LOAD_HUC &&
 	    !intel_uc_supports_huc(uc))
-		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+		dev_info(i915->drm.dev,
+			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "HuC is not supported!");
 
 	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION &&
 	    !intel_uc_supports_guc_submission(uc))
-		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+		dev_info(i915->drm.dev,
+			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "GuC submission is N/A");
 
 	if (i915_modparams.enable_guc & ~(ENABLE_GUC_SUBMISSION |
 					  ENABLE_GUC_LOAD_HUC))
-		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+		dev_info(i915->drm.dev,
+			 "Incompatible option enable_guc=%d - %s\n",
 			 i915_modparams.enable_guc, "undocumented flag");
 }
 

commit d9a910f5ed72c11773a11cff84e0b957d3634d5f
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 4 19:50:52 2019 +0000

    drm/i915/uc: Don't fail on HuC early init errors
    
    Since commit 301efe96f777 ("drm/i915/uc: Don't fail on HuC
    firmware failure") we can continue driver load after error
    during HuC firmware load or authentication, but we could
    still fail on any error during early HuC initialization.
    Change that by ignoring HuC related errors until hardware
    initialization phase where we can decide about next steps.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190804195052.31140-5-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 1ddd252419ec..e87b7904ab7a 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -316,14 +316,14 @@ int intel_uc_init(struct intel_uc *uc)
 	if (intel_uc_supports_huc(uc)) {
 		ret = intel_huc_init(huc);
 		if (ret)
-			goto err_guc;
+			goto out_huc;
 	}
 
 	return 0;
 
-err_guc:
-	intel_guc_fini(guc);
-	return ret;
+out_huc:
+	intel_uc_fw_cleanup_fetch(&huc->fw);
+	return 0;
 }
 
 void intel_uc_fini(struct intel_uc *uc)

commit 34f0a20fa4ea8ad08b2d1fd43fa6e2febb9a4eff
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Sun Aug 4 19:50:51 2019 +0000

    drm/i915/uc: Remove redundant GuC support checks
    
    Since commit db81bc6eb9c0 ("drm/i915/uc: Consider enable_guc
    modparam during fw selection") we have started using firmware
    status as main indicator of the GuC support. No need to use
    same checks twice.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190804195052.31140-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index fe526698eee2..1ddd252419ec 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -306,9 +306,6 @@ int intel_uc_init(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
-	if (!intel_uc_fw_supported(&guc->fw))
-		return -ENODEV;
-
 	/* XXX: GuC submission is unavailable for now */
 	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
 
@@ -336,8 +333,6 @@ void intel_uc_fini(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return;
 
-	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
-
 	if (intel_uc_supports_huc(uc))
 		intel_huc_fini(&uc->huc);
 
@@ -351,7 +346,7 @@ static int __uc_sanitize(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	struct intel_huc *huc = &uc->huc;
 
-	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
+	GEM_BUG_ON(!intel_uc_supports_guc(uc));
 
 	intel_huc_sanitize(huc);
 	intel_guc_sanitize(guc);
@@ -429,8 +424,6 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (!intel_uc_supports_guc(uc))
 		return 0;
 
-	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
-
 	ret = uc_init_wopcm(uc);
 	if (ret)
 		goto err_out;
@@ -530,8 +523,6 @@ void intel_uc_fini_hw(struct intel_uc *uc)
 	if (!intel_guc_is_running(guc))
 		return;
 
-	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
-
 	if (intel_uc_supports_guc_submission(uc))
 		intel_guc_submission_disable(guc);
 

commit 6bd0fbe156f1cc5dc97590ce994d1848f593569e
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 2 18:40:55 2019 +0000

    drm/i915/wopcm: Don't fail on WOPCM partitioning failure
    
    We don't have to immediately fail on WOPCM partitioning, we can wait
    until we will start programming WOPCM registers. This should give us
    more options if we decide to restore fallback in case of GuC failures.
    
    v3: rebased
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802184055.31988-7-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 66d6e0775c23..fe526698eee2 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -378,6 +378,11 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	u32 mask;
 	int err;
 
+	if (unlikely(!base || !size)) {
+		i915_probe_error(gt->i915, "Unsuccessful WOPCM partitioning\n");
+		return -E2BIG;
+	}
+
 	GEM_BUG_ON(!intel_uc_supports_guc(uc));
 	GEM_BUG_ON(!(base & GUC_WOPCM_OFFSET_MASK));
 	GEM_BUG_ON(base & ~GUC_WOPCM_OFFSET_MASK);

commit 5d1ef2b4270de45e1b1b40a00838e3b6196eefd7
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 2 18:40:54 2019 +0000

    drm/i915/uc: Inject probe errors into intel_uc_init_hw
    
    Inject probe errors into intel_uc_init_hw to make sure we
    correctly handle any uC initialization failure.
    
    To avoid complains from CI about injected errors use
    i915_probe_error to lower message level.
    
    v4: rebased after moving hot fixes moved to separate patches
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> #v1
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802184055.31988-6-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index e5421c0b9a25..66d6e0775c23 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -39,6 +39,10 @@ static int __intel_uc_reset_hw(struct intel_uc *uc)
 	int ret;
 	u32 guc_status;
 
+	ret = i915_inject_load_error(gt->i915, -ENXIO);
+	if (ret)
+		return ret;
+
 	ret = intel_reset_guc(gt);
 	if (ret) {
 		DRM_ERROR("Failed to reset GuC, ret = %d\n", ret);
@@ -205,6 +209,10 @@ static int guc_enable_communication(struct intel_guc *guc)
 
 	GEM_BUG_ON(guc_communication_enabled(guc));
 
+	ret = i915_inject_load_error(i915, -ENXIO);
+	if (ret)
+		return ret;
+
 	ret = intel_guc_ct_enable(&guc->ct);
 	if (ret)
 		return ret;
@@ -376,6 +384,10 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	GEM_BUG_ON(!(size & GUC_WOPCM_SIZE_MASK));
 	GEM_BUG_ON(size & ~GUC_WOPCM_SIZE_MASK);
 
+	err = i915_inject_load_error(gt->i915, -ENXIO);
+	if (err)
+		return err;
+
 	mask = GUC_WOPCM_SIZE_MASK | GUC_WOPCM_SIZE_LOCKED;
 	err = intel_uncore_write_and_verify(uncore, GUC_WOPCM_SIZE, size, mask,
 					    size | GUC_WOPCM_SIZE_LOCKED);
@@ -502,7 +514,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (GEM_WARN_ON(ret == -EIO))
 		ret = -EINVAL;
 
-	dev_err(i915->drm.dev, "GuC initialization failed %d\n", ret);
+	i915_probe_error(i915, "GuC initialization failed %d\n", ret);
 	return ret;
 }
 

commit 32ff76e80c2400c511b37a498eead9caba5656b8
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 2 18:40:53 2019 +0000

    drm/i915/uc: Move GuC error log to uc and release it on fini
    
    When we fail to load GuC and want to abort probe, we hit:
    
    <7> [229.915779] i915 0000:00:02.0: [drm:intel_uc_init_hw [i915]] GuC initialization failed -6
    <7> [229.915813] i915 0000:00:02.0: [drm:i915_gem_init_hw [i915]] Enabling uc failed (-6)
    <4> [229.953354] ------------[ cut here ]------------
    <4> [229.953355] WARN_ON(dev_priv->mm.shrink_count)
    <4> [229.953406] WARNING: CPU: 9 PID: 3287 at drivers/gpu/drm/i915/i915_gem.c:1684 i915_gem_cleanup_early+0xfc/0x110 [i915]
    <4> [229.953464] Call Trace:
    <4> [229.953489]  i915_driver_late_release+0x19/0x60 [i915]
    <4> [229.953514]  i915_driver_probe+0xb82/0x18a0 [i915]
    <4> [229.953519]  ? __pm_runtime_resume+0x4f/0x80
    <4> [229.953545]  i915_pci_probe+0x43/0x1b0 [i915]
    ...
    <4> [229.962951] ------------[ cut here ]------------
    <4> [229.962956] DEBUG_LOCKS_WARN_ON(lock->magic != lock)
    <4> [229.962959] WARNING: CPU: 8 PID: 2395 at kernel/locking/mutex.c:912 __mutex_lock+0x750/0x9b0
    <4> [229.963091] Call Trace:
    <4> [229.963129]  ? i915_vma_destroy+0x86/0x350 [i915]
    <4> [229.963166]  ? i915_vma_destroy+0x86/0x350 [i915]
    <4> [229.963201]  i915_vma_destroy+0x86/0x350 [i915]
    <4> [229.963236]  __i915_gem_free_objects+0xb8/0x510 [i915]
    <4> [229.963270]  __i915_gem_free_work+0x5a/0x90 [i915]
    <4> [229.963275]  process_one_work+0x245/0x610
    
    as since commit 6f76098fe0f3 ("drm/i915/uc: Move uC early functions
    inside the GT ones") we cleanup uc after gem.
    
    Move captured GuC load error log to uc struct and release it
    in intel_uc_fini() instead of intel_uc_driver_late_release()
    
    Note that intel_uc_driver_late_release() is now empty, but
    we can leave it as a placeholder for future code.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802184055.31988-5-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index f24860a86d0e..e5421c0b9a25 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -31,8 +31,6 @@
 
 #include "i915_drv.h"
 
-static void guc_free_load_err_log(struct intel_guc *guc);
-
 /* Reset GuC providing us with fresh state for both GuC and HuC.
  */
 static int __intel_uc_reset_hw(struct intel_uc *uc)
@@ -103,7 +101,6 @@ void intel_uc_init_early(struct intel_uc *uc)
 
 void intel_uc_driver_late_release(struct intel_uc *uc)
 {
-	guc_free_load_err_log(&uc->guc);
 }
 
 /**
@@ -118,21 +115,20 @@ void intel_uc_init_mmio(struct intel_uc *uc)
 	intel_guc_init_send_regs(&uc->guc);
 }
 
-static void guc_capture_load_err_log(struct intel_guc *guc)
+static void __uc_capture_load_err_log(struct intel_uc *uc)
 {
-	if (!guc->log.vma || !intel_guc_log_get_level(&guc->log))
-		return;
-
-	if (!guc->load_err_log)
-		guc->load_err_log = i915_gem_object_get(guc->log.vma->obj);
+	struct intel_guc *guc = &uc->guc;
 
-	return;
+	if (guc->log.vma && !uc->load_err_log)
+		uc->load_err_log = i915_gem_object_get(guc->log.vma->obj);
 }
 
-static void guc_free_load_err_log(struct intel_guc *guc)
+static void __uc_free_load_err_log(struct intel_uc *uc)
 {
-	if (guc->load_err_log)
-		i915_gem_object_put(guc->load_err_log);
+	struct drm_i915_gem_object *log = fetch_and_zero(&uc->load_err_log);
+
+	if (log)
+		i915_gem_object_put(log);
 }
 
 /*
@@ -338,6 +334,8 @@ void intel_uc_fini(struct intel_uc *uc)
 		intel_huc_fini(&uc->huc);
 
 	intel_guc_fini(guc);
+
+	__uc_free_load_err_log(uc);
 }
 
 static int __uc_sanitize(struct intel_uc *uc)
@@ -493,7 +491,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 err_communication:
 	guc_disable_communication(guc);
 err_log_capture:
-	guc_capture_load_err_log(guc);
+	__uc_capture_load_err_log(uc);
 err_out:
 	__uc_sanitize(uc);
 

commit 771051eaa74661f63d893589137f5d70515266c0
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 2 18:40:51 2019 +0000

    drm/i915/uc: Do full sanitize instead of pure reset
    
    On Gen9 when we try to reload HuC due to GuC upload error, we hit:
    
    <7> [229.656688] [drm:intel_uc_init_hw [i915]] GuC fw load failed: -8; will reset and retry 2 more time(s)
    <7> [229.656739] [drm:intel_uc_fw_upload [i915]] HuC fw load i915/kbl_huc_ver02_00_1810.bin
    <3> [229.656740] intel_uc_fw_upload:425 GEM_BUG_ON(intel_uc_fw_is_loaded(uc_fw))
    
    as we performed only pure reset and didn't sanitized HuC fw status.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802184055.31988-3-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index d1b08b28b1ad..f24860a86d0e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -340,7 +340,7 @@ void intel_uc_fini(struct intel_uc *uc)
 	intel_guc_fini(guc);
 }
 
-static void __uc_sanitize(struct intel_uc *uc)
+static int __uc_sanitize(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 	struct intel_huc *huc = &uc->huc;
@@ -350,7 +350,7 @@ static void __uc_sanitize(struct intel_uc *uc)
 	intel_huc_sanitize(huc);
 	intel_guc_sanitize(guc);
 
-	__intel_uc_reset_hw(uc);
+	return __intel_uc_reset_hw(uc);
 }
 
 void intel_uc_sanitize(struct intel_uc *uc)
@@ -434,7 +434,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		 * Always reset the GuC just before (re)loading, so
 		 * that the state and timing are fairly predictable
 		 */
-		ret = __intel_uc_reset_hw(uc);
+		ret = __uc_sanitize(uc);
 		if (ret)
 			goto err_out;
 

commit 01158da721c5fd5f321cfd7e3e955fbd83ba3124
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Aug 1 13:28:40 2019 +0000

    drm/i915/uc: Stop sanitizing enable_guc modparam
    
    As we already track GuC/HuC uses by other means than modparam
    there is no point in sanitizing it. Just scan modparam for
    major discrepancies between what was requested vs actual.
    
    v2: rebased, reworded info messages
    v3: oops
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190801132840.33176-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 65ce20efdba8..d1b08b28b1ad 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -55,78 +55,42 @@ static int __intel_uc_reset_hw(struct intel_uc *uc)
 	return ret;
 }
 
-static int __get_platform_enable_guc(struct intel_uc *uc)
+static void __confirm_options(struct intel_uc *uc)
 {
-	struct intel_uc_fw *guc_fw = &uc->guc.fw;
-	struct intel_uc_fw *huc_fw = &uc->huc.fw;
-	int enable_guc = 0;
-
-	if (!HAS_GT_UC(uc_to_gt(uc)->i915))
-		return 0;
-
-	/* We don't want to enable GuC/HuC on pre-Gen11 by default */
-	if (INTEL_GEN(uc_to_gt(uc)->i915) < 11)
-		return 0;
-
-	if (intel_uc_fw_supported(guc_fw) && intel_uc_fw_supported(huc_fw))
-		enable_guc |= ENABLE_GUC_LOAD_HUC;
-
-	return enable_guc;
-}
-
-/**
- * sanitize_options_early - sanitize uC related modparam options
- * @uc: the intel_uc structure
- *
- * In case of "enable_guc" option this function will attempt to modify
- * it only if it was initially set to "auto(-1)". Default value for this
- * modparam varies between platforms and it is hardcoded in driver code.
- * Any other modparam value is only monitored against availability of the
- * related hardware or firmware definitions.
- */
-static void sanitize_options_early(struct intel_uc *uc)
-{
-	struct intel_uc_fw *guc_fw = &uc->guc.fw;
-	struct intel_uc_fw *huc_fw = &uc->huc.fw;
-
-	/* A negative value means "use platform default" */
-	if (i915_modparams.enable_guc < 0)
-		i915_modparams.enable_guc = __get_platform_enable_guc(uc);
-
-	DRM_DEBUG_DRIVER("enable_guc=%d (submission:%s huc:%s)\n",
+	DRM_DEBUG_DRIVER("enable_guc=%d (guc:%s submission:%s huc:%s)\n",
 			 i915_modparams.enable_guc,
+			 yesno(intel_uc_supports_guc(uc)),
 			 yesno(intel_uc_supports_guc_submission(uc)),
 			 yesno(intel_uc_supports_huc(uc)));
 
-	/* Verify GuC firmware availability */
-	if (intel_uc_supports_guc(uc) && !intel_uc_fw_supported(guc_fw)) {
-		DRM_WARN("Incompatible option detected: enable_guc=%d, "
-			 "but GuC is not supported!\n",
-			 i915_modparams.enable_guc);
-		DRM_INFO("Disabling GuC/HuC loading!\n");
-		i915_modparams.enable_guc = 0;
-	}
+	if (i915_modparams.enable_guc == -1)
+		return;
 
-	/* Verify HuC firmware availability */
-	if (intel_uc_supports_huc(uc) && !intel_uc_fw_supported(huc_fw)) {
-		DRM_WARN("Incompatible option detected: enable_guc=%d, "
-			 "but HuC is not supported!\n",
-			 i915_modparams.enable_guc);
-		DRM_INFO("Disabling HuC loading!\n");
-		i915_modparams.enable_guc &= ~ENABLE_GUC_LOAD_HUC;
+	if (i915_modparams.enable_guc == 0) {
+		GEM_BUG_ON(intel_uc_supports_guc(uc));
+		GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
+		GEM_BUG_ON(intel_uc_supports_huc(uc));
+		return;
 	}
 
-	/* XXX: GuC submission is unavailable for now */
-	if (intel_uc_supports_guc_submission(uc)) {
-		DRM_INFO("Incompatible option detected: enable_guc=%d, "
-			 "but GuC submission is not supported!\n",
-			 i915_modparams.enable_guc);
-		DRM_INFO("Switching to non-GuC submission mode!\n");
-		i915_modparams.enable_guc &= ~ENABLE_GUC_SUBMISSION;
-	}
+	if (!intel_uc_supports_guc(uc))
+		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+			 i915_modparams.enable_guc, "GuC is not supported!");
+
+	if (i915_modparams.enable_guc & ENABLE_GUC_LOAD_HUC &&
+	    !intel_uc_supports_huc(uc))
+		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+			 i915_modparams.enable_guc, "HuC is not supported!");
+
+	if (i915_modparams.enable_guc & ENABLE_GUC_SUBMISSION &&
+	    !intel_uc_supports_guc_submission(uc))
+		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+			 i915_modparams.enable_guc, "GuC submission is N/A");
 
-	/* Make sure that sanitization was done */
-	GEM_BUG_ON(i915_modparams.enable_guc < 0);
+	if (i915_modparams.enable_guc & ~(ENABLE_GUC_SUBMISSION |
+					  ENABLE_GUC_LOAD_HUC))
+		DRM_INFO("Incompatible option enable_guc=%d - %s\n",
+			 i915_modparams.enable_guc, "undocumented flag");
 }
 
 void intel_uc_init_early(struct intel_uc *uc)
@@ -134,7 +98,7 @@ void intel_uc_init_early(struct intel_uc *uc)
 	intel_guc_init_early(&uc->guc);
 	intel_huc_init_early(&uc->huc);
 
-	sanitize_options_early(uc);
+	__confirm_options(uc);
 }
 
 void intel_uc_driver_late_release(struct intel_uc *uc)

commit 57a68c3507161bed25c97df8941fb45166acec99
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Jul 31 22:33:18 2019 +0000

    drm/i915/uc: Rename intel_uc_is_using* into intel_uc_supports*
    
    Rename intel_uc_is_using* into intel_uc_supports* to make clear
    distinction from actual state (compare intel_uc_fw_is_running)
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190731223321.36436-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 0d07f9fc4317..65ce20efdba8 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -95,11 +95,11 @@ static void sanitize_options_early(struct intel_uc *uc)
 
 	DRM_DEBUG_DRIVER("enable_guc=%d (submission:%s huc:%s)\n",
 			 i915_modparams.enable_guc,
-			 yesno(intel_uc_is_using_guc_submission(uc)),
-			 yesno(intel_uc_is_using_huc(uc)));
+			 yesno(intel_uc_supports_guc_submission(uc)),
+			 yesno(intel_uc_supports_huc(uc)));
 
 	/* Verify GuC firmware availability */
-	if (intel_uc_is_using_guc(uc) && !intel_uc_fw_supported(guc_fw)) {
+	if (intel_uc_supports_guc(uc) && !intel_uc_fw_supported(guc_fw)) {
 		DRM_WARN("Incompatible option detected: enable_guc=%d, "
 			 "but GuC is not supported!\n",
 			 i915_modparams.enable_guc);
@@ -108,7 +108,7 @@ static void sanitize_options_early(struct intel_uc *uc)
 	}
 
 	/* Verify HuC firmware availability */
-	if (intel_uc_is_using_huc(uc) && !intel_uc_fw_supported(huc_fw)) {
+	if (intel_uc_supports_huc(uc) && !intel_uc_fw_supported(huc_fw)) {
 		DRM_WARN("Incompatible option detected: enable_guc=%d, "
 			 "but HuC is not supported!\n",
 			 i915_modparams.enable_guc);
@@ -117,7 +117,7 @@ static void sanitize_options_early(struct intel_uc *uc)
 	}
 
 	/* XXX: GuC submission is unavailable for now */
-	if (intel_uc_is_using_guc_submission(uc)) {
+	if (intel_uc_supports_guc_submission(uc)) {
 		DRM_INFO("Incompatible option detected: enable_guc=%d, "
 			 "but GuC submission is not supported!\n",
 			 i915_modparams.enable_guc);
@@ -309,21 +309,21 @@ void intel_uc_fetch_firmwares(struct intel_uc *uc)
 {
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
 
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return;
 
 	intel_uc_fw_fetch(&uc->guc.fw, i915);
 
-	if (intel_uc_is_using_huc(uc))
+	if (intel_uc_supports_huc(uc))
 		intel_uc_fw_fetch(&uc->huc.fw, i915);
 }
 
 void intel_uc_cleanup_firmwares(struct intel_uc *uc)
 {
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return;
 
-	if (intel_uc_is_using_huc(uc))
+	if (intel_uc_supports_huc(uc))
 		intel_uc_fw_cleanup_fetch(&uc->huc.fw);
 
 	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
@@ -335,20 +335,20 @@ int intel_uc_init(struct intel_uc *uc)
 	struct intel_huc *huc = &uc->huc;
 	int ret;
 
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return 0;
 
 	if (!intel_uc_fw_supported(&guc->fw))
 		return -ENODEV;
 
 	/* XXX: GuC submission is unavailable for now */
-	GEM_BUG_ON(intel_uc_is_using_guc_submission(uc));
+	GEM_BUG_ON(intel_uc_supports_guc_submission(uc));
 
 	ret = intel_guc_init(guc);
 	if (ret)
 		return ret;
 
-	if (intel_uc_is_using_huc(uc)) {
+	if (intel_uc_supports_huc(uc)) {
 		ret = intel_huc_init(huc);
 		if (ret)
 			goto err_guc;
@@ -365,12 +365,12 @@ void intel_uc_fini(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
-	if (intel_uc_is_using_huc(uc))
+	if (intel_uc_supports_huc(uc))
 		intel_huc_fini(&uc->huc);
 
 	intel_guc_fini(guc);
@@ -391,7 +391,7 @@ static void __uc_sanitize(struct intel_uc *uc)
 
 void intel_uc_sanitize(struct intel_uc *uc)
 {
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return;
 
 	__uc_sanitize(uc);
@@ -404,11 +404,11 @@ static int uc_init_wopcm(struct intel_uc *uc)
 	struct intel_uncore *uncore = gt->uncore;
 	u32 base = intel_wopcm_guc_base(&gt->i915->wopcm);
 	u32 size = intel_wopcm_guc_size(&gt->i915->wopcm);
-	u32 huc_agent = intel_uc_is_using_huc(uc) ? HUC_LOADING_AGENT_GUC : 0;
+	u32 huc_agent = intel_uc_supports_huc(uc) ? HUC_LOADING_AGENT_GUC : 0;
 	u32 mask;
 	int err;
 
-	GEM_BUG_ON(!intel_uc_is_using_guc(uc));
+	GEM_BUG_ON(!intel_uc_supports_guc(uc));
 	GEM_BUG_ON(!(base & GUC_WOPCM_OFFSET_MASK));
 	GEM_BUG_ON(base & ~GUC_WOPCM_OFFSET_MASK);
 	GEM_BUG_ON(!(size & GUC_WOPCM_SIZE_MASK));
@@ -447,7 +447,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	struct intel_huc *huc = &uc->huc;
 	int ret, attempts;
 
-	if (!intel_uc_is_using_guc(uc))
+	if (!intel_uc_supports_guc(uc))
 		return 0;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
@@ -474,7 +474,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		if (ret)
 			goto err_out;
 
-		if (intel_uc_is_using_huc(uc)) {
+		if (intel_uc_supports_huc(uc)) {
 			ret = intel_huc_fw_upload(huc);
 			if (ret && intel_uc_fw_is_overridden(&huc->fw))
 				goto err_out;
@@ -508,7 +508,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (ret)
 		goto err_communication;
 
-	if (intel_uc_is_using_guc_submission(uc)) {
+	if (intel_uc_supports_guc_submission(uc)) {
 		ret = intel_guc_submission_enable(guc);
 		if (ret)
 			goto err_communication;
@@ -517,7 +517,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	dev_info(i915->drm.dev, "GuC firmware version %u.%u\n",
 		 guc->fw.major_ver_found, guc->fw.minor_ver_found);
 	dev_info(i915->drm.dev, "GuC submission %s\n",
-		 enableddisabled(intel_uc_is_using_guc_submission(uc)));
+		 enableddisabled(intel_uc_supports_guc_submission(uc)));
 	dev_info(i915->drm.dev, "HuC %s\n",
 		 enableddisabled(intel_huc_is_authenticated(huc)));
 
@@ -553,7 +553,7 @@ void intel_uc_fini_hw(struct intel_uc *uc)
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
-	if (intel_uc_is_using_guc_submission(uc))
+	if (intel_uc_supports_guc_submission(uc))
 		intel_guc_submission_disable(guc);
 
 	guc_disable_communication(guc);

commit 6f76098fe0f3f0b519b2ad528b4319195d6d0f73
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 31 17:57:08 2019 -0700

    drm/i915/uc: Move uC early functions inside the GT ones
    
    uC is a subcomponent of GT, so initialize/clean it as part of it. The
    wopcm_init_early doesn't have to be happen before the uC one, but since
    in other parts of the code we consider WOPCM first do the same for
    consistency.
    
    v2: s/cleanup_early/late_release to match the caller
    v3: s/late_release/driver_late_release/ (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com> #v1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190801005709.34092-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 66b226be6759..0d07f9fc4317 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -137,7 +137,7 @@ void intel_uc_init_early(struct intel_uc *uc)
 	sanitize_options_early(uc);
 }
 
-void intel_uc_cleanup_early(struct intel_uc *uc)
+void intel_uc_driver_late_release(struct intel_uc *uc)
 {
 	guc_free_load_err_log(&uc->guc);
 }

commit 63064d822c964c04107ead05b64eddccfa142005
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Jul 30 16:07:40 2019 -0700

    drm/i915/uc: Move uC WOPCM setup in uc_init_hw
    
    The register we write are not WOPCM regs but uC ones related to how
    GuC and HuC are going to use the WOPCM, so it makes logical sense
    for them to be programmed as part of uc_init_hw. The WOPCM map on the
    other side is not uC-specific (although that is our main use-case), so
    keep that separate.
    
    v2: move write_and_verify to uncore, fix log, re-use err_out tag,
        add intel_wopcm_guc_base, fix log
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190730230743.19542-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 26671f1daaf7..66b226be6759 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -397,6 +397,49 @@ void intel_uc_sanitize(struct intel_uc *uc)
 	__uc_sanitize(uc);
 }
 
+/* Initialize and verify the uC regs related to uC positioning in WOPCM */
+static int uc_init_wopcm(struct intel_uc *uc)
+{
+	struct intel_gt *gt = uc_to_gt(uc);
+	struct intel_uncore *uncore = gt->uncore;
+	u32 base = intel_wopcm_guc_base(&gt->i915->wopcm);
+	u32 size = intel_wopcm_guc_size(&gt->i915->wopcm);
+	u32 huc_agent = intel_uc_is_using_huc(uc) ? HUC_LOADING_AGENT_GUC : 0;
+	u32 mask;
+	int err;
+
+	GEM_BUG_ON(!intel_uc_is_using_guc(uc));
+	GEM_BUG_ON(!(base & GUC_WOPCM_OFFSET_MASK));
+	GEM_BUG_ON(base & ~GUC_WOPCM_OFFSET_MASK);
+	GEM_BUG_ON(!(size & GUC_WOPCM_SIZE_MASK));
+	GEM_BUG_ON(size & ~GUC_WOPCM_SIZE_MASK);
+
+	mask = GUC_WOPCM_SIZE_MASK | GUC_WOPCM_SIZE_LOCKED;
+	err = intel_uncore_write_and_verify(uncore, GUC_WOPCM_SIZE, size, mask,
+					    size | GUC_WOPCM_SIZE_LOCKED);
+	if (err)
+		goto err_out;
+
+	mask = GUC_WOPCM_OFFSET_MASK | GUC_WOPCM_OFFSET_VALID | huc_agent;
+	err = intel_uncore_write_and_verify(uncore, DMA_GUC_WOPCM_OFFSET,
+					    base | huc_agent, mask,
+					    base | huc_agent |
+					    GUC_WOPCM_OFFSET_VALID);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	DRM_ERROR("Failed to init uC WOPCM registers:\n");
+	DRM_ERROR("DMA_GUC_WOPCM_OFFSET=%#x\n",
+		  intel_uncore_read(uncore, DMA_GUC_WOPCM_OFFSET));
+	DRM_ERROR("GUC_WOPCM_SIZE=%#x\n",
+		  intel_uncore_read(uncore, GUC_WOPCM_SIZE));
+
+	return err;
+}
+
 int intel_uc_init_hw(struct intel_uc *uc)
 {
 	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
@@ -409,6 +452,10 @@ int intel_uc_init_hw(struct intel_uc *uc)
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
+	ret = uc_init_wopcm(uc);
+	if (ret)
+		goto err_out;
+
 	guc_reset_interrupts(guc);
 
 	/* WaEnableuKernelHeaderValidFix:skl */

commit 602776f96bfa50a6107af017522501c43a82b29a
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Jul 30 16:07:39 2019 -0700

    drm/i915/uc: Don't enable communication twice on resume
    
    When coming out of S3/S4 we sanitize and re-init the HW, which includes
    enabling communication during uc_init_hw. We therefore don't want to do
    that again in uc_resume and can just tell GuC to reload its state.
    
    v2: split uc_resume and uc_runtime_resume to match the suspend
        functions and to better differentiate the expected state in the 2
        scenarios (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190730230743.19542-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 6eb8bb3fa252..26671f1daaf7 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -233,11 +233,18 @@ static void guc_disable_interrupts(struct intel_guc *guc)
 	guc->interrupts.disable(guc);
 }
 
+static inline bool guc_communication_enabled(struct intel_guc *guc)
+{
+	return guc->send != intel_guc_send_nop;
+}
+
 static int guc_enable_communication(struct intel_guc *guc)
 {
 	struct drm_i915_private *i915 = guc_to_gt(guc)->i915;
 	int ret;
 
+	GEM_BUG_ON(guc_communication_enabled(guc));
+
 	ret = intel_guc_ct_enable(&guc->ct);
 	if (ret)
 		return ret;
@@ -550,7 +557,7 @@ void intel_uc_suspend(struct intel_uc *uc)
 		intel_uc_runtime_suspend(uc);
 }
 
-int intel_uc_resume(struct intel_uc *uc)
+static int __uc_resume(struct intel_uc *uc, bool enable_communication)
 {
 	struct intel_guc *guc = &uc->guc;
 	int err;
@@ -558,7 +565,11 @@ int intel_uc_resume(struct intel_uc *uc)
 	if (!intel_guc_is_running(guc))
 		return 0;
 
-	guc_enable_communication(guc);
+	/* Make sure we enable communication if and only if it's disabled */
+	GEM_BUG_ON(enable_communication == guc_communication_enabled(guc));
+
+	if (enable_communication)
+		guc_enable_communication(guc);
 
 	err = intel_guc_resume(guc);
 	if (err) {
@@ -568,3 +579,21 @@ int intel_uc_resume(struct intel_uc *uc)
 
 	return 0;
 }
+
+int intel_uc_resume(struct intel_uc *uc)
+{
+	/*
+	 * When coming out of S3/S4 we sanitize and re-init the HW, so
+	 * communication is already re-enabled at this point.
+	 */
+	return __uc_resume(uc, false);
+}
+
+int intel_uc_runtime_resume(struct intel_uc *uc)
+{
+	/*
+	 * During runtime resume we don't sanitize, so we need to re-init
+	 * communication as well.
+	 */
+	return __uc_resume(uc, true);
+}

commit 301efe96f777c0197502b9399694ae83779579b3
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Mon Jul 29 11:26:12 2019 +0000

    drm/i915/uc: Don't fail on HuC firmware failure
    
    HuC is usually not a critical component, so we can safely ignore
    firmware load or authentication failures unless HuC was explicitly
    requested by the user.
    
    v2: add convenient way to disable loading (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> #v1
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190729112612.37476-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index fafa9be1e12a..6eb8bb3fa252 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -422,7 +422,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 
 		if (intel_uc_is_using_huc(uc)) {
 			ret = intel_huc_fw_upload(huc);
-			if (ret)
+			if (ret && intel_uc_fw_is_overridden(&huc->fw))
 				goto err_out;
 		}
 
@@ -444,9 +444,9 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	if (ret)
 		goto err_log_capture;
 
-	if (intel_uc_is_using_huc(uc)) {
+	if (intel_uc_fw_is_loaded(&huc->fw)) {
 		ret = intel_huc_auth(huc);
-		if (ret)
+		if (ret && intel_uc_fw_is_overridden(&huc->fw))
 			goto err_communication;
 	}
 
@@ -465,7 +465,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 	dev_info(i915->drm.dev, "GuC submission %s\n",
 		 enableddisabled(intel_uc_is_using_guc_submission(uc)));
 	dev_info(i915->drm.dev, "HuC %s\n",
-		 enableddisabled(intel_uc_is_using_huc(uc)));
+		 enableddisabled(intel_huc_is_authenticated(huc)));
 
 	return 0;
 

commit f91bf7382856eb9b35664f92aab4c49b0407ac02
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Jul 25 20:51:06 2019 +0000

    drm/i915/uc: Don't sanitize guc_log_level modparam
    
    We are already storing runtime value of log level in private
    field, so there is no need to modify modparam.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725205106.36148-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 5b9b20d1cb6d..fafa9be1e12a 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -74,23 +74,6 @@ static int __get_platform_enable_guc(struct intel_uc *uc)
 	return enable_guc;
 }
 
-static int __get_default_guc_log_level(struct intel_uc *uc)
-{
-	int guc_log_level;
-
-	if (!intel_uc_fw_supported(&uc->guc.fw) || !intel_uc_is_using_guc(uc))
-		guc_log_level = GUC_LOG_LEVEL_DISABLED;
-	else if (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||
-		 IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
-		guc_log_level = GUC_LOG_LEVEL_MAX;
-	else
-		guc_log_level = GUC_LOG_LEVEL_NON_VERBOSE;
-
-	/* Any platform specific fine-tuning can be done here */
-
-	return guc_log_level;
-}
-
 /**
  * sanitize_options_early - sanitize uC related modparam options
  * @uc: the intel_uc structure
@@ -100,13 +83,6 @@ static int __get_default_guc_log_level(struct intel_uc *uc)
  * modparam varies between platforms and it is hardcoded in driver code.
  * Any other modparam value is only monitored against availability of the
  * related hardware or firmware definitions.
- *
- * In case of "guc_log_level" option this function will attempt to modify
- * it only if it was initially set to "auto(-1)" or if initial value was
- * "enable(1..4)" on platforms without the GuC. Default value for this
- * modparam varies between platforms and is usually set to "disable(0)"
- * unless GuC is enabled on given platform and the driver is compiled with
- * debug config when this modparam will default to "enable(1..4)".
  */
 static void sanitize_options_early(struct intel_uc *uc)
 {
@@ -149,34 +125,8 @@ static void sanitize_options_early(struct intel_uc *uc)
 		i915_modparams.enable_guc &= ~ENABLE_GUC_SUBMISSION;
 	}
 
-	/* A negative value means "use platform/config default" */
-	if (i915_modparams.guc_log_level < 0)
-		i915_modparams.guc_log_level =
-			__get_default_guc_log_level(uc);
-
-	if (i915_modparams.guc_log_level > 0 && !intel_uc_is_using_guc(uc)) {
-		DRM_WARN("Incompatible option detected: guc_log_level=%d, "
-			 "but GuC is not enabled!\n",
-			 i915_modparams.guc_log_level);
-		i915_modparams.guc_log_level = 0;
-	}
-
-	if (i915_modparams.guc_log_level > GUC_LOG_LEVEL_MAX) {
-		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
-			 "guc_log_level", i915_modparams.guc_log_level,
-			 "verbosity too high");
-		i915_modparams.guc_log_level = GUC_LOG_LEVEL_MAX;
-	}
-
-	DRM_DEBUG_DRIVER("guc_log_level=%d (enabled:%s, verbose:%s, verbosity:%d)\n",
-			 i915_modparams.guc_log_level,
-			 yesno(i915_modparams.guc_log_level),
-			 yesno(GUC_LOG_LEVEL_IS_VERBOSE(i915_modparams.guc_log_level)),
-			 GUC_LOG_LEVEL_TO_VERBOSITY(i915_modparams.guc_log_level));
-
 	/* Make sure that sanitization was done */
 	GEM_BUG_ON(i915_modparams.enable_guc < 0);
-	GEM_BUG_ON(i915_modparams.guc_log_level < 0);
 }
 
 void intel_uc_init_early(struct intel_uc *uc)

commit edad25476ba353cfc0f3b34b150888b46f18e8a6
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jul 25 10:46:55 2019 -0700

    drm/i915/guc: init submission structures as part of guc_init
    
    guc->stage_desc_pool is required as part of the init parameters and
    there is no reason we have to init them after HuC. This fixes a NULL
    ptr dereference due to guc->stage_desc_pool not being set (no fixes
    tag since GuC submission can't be enabled yet).
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725174655.24382-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 8205b3c81048..5b9b20d1cb6d 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -397,21 +397,8 @@ int intel_uc_init(struct intel_uc *uc)
 			goto err_guc;
 	}
 
-	if (intel_uc_is_using_guc_submission(uc)) {
-		/*
-		 * This is stuff we need to have available at fw load time
-		 * if we are planning to enable submission later
-		 */
-		ret = intel_guc_submission_init(guc);
-		if (ret)
-			goto err_huc;
-	}
-
 	return 0;
 
-err_huc:
-	if (intel_uc_is_using_huc(uc))
-		intel_huc_fini(huc);
 err_guc:
 	intel_guc_fini(guc);
 	return ret;
@@ -426,9 +413,6 @@ void intel_uc_fini(struct intel_uc *uc)
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
-	if (intel_uc_is_using_guc_submission(uc))
-		intel_guc_submission_fini(guc);
-
 	if (intel_uc_is_using_huc(uc))
 		intel_huc_fini(&uc->huc);
 

commit 97dee74bb34a1364c6b3f3f2e3f31165063d3c6e
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Jul 25 21:03:14 2019 +0000

    drm/i915/uc: Reorder params in intel_uc_fw_fetch
    
    All intel_uc_fw_* functions are taking uc_fw as first param
    except intel_uc_fw_fetch() which is taking i915. Fix that.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725210314.21188-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index b1815abecf30..8205b3c81048 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -355,10 +355,10 @@ void intel_uc_fetch_firmwares(struct intel_uc *uc)
 	if (!intel_uc_is_using_guc(uc))
 		return;
 
-	intel_uc_fw_fetch(i915, &uc->guc.fw);
+	intel_uc_fw_fetch(&uc->guc.fw, i915);
 
 	if (intel_uc_is_using_huc(uc))
-		intel_uc_fw_fetch(i915, &uc->huc.fw);
+		intel_uc_fw_fetch(&uc->huc.fw, i915);
 }
 
 void intel_uc_cleanup_firmwares(struct intel_uc *uc)

commit 91e55e545ab8bbedd3a518dbe6124c10388ff92f
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 24 17:18:09 2019 -0700

    drm/i915/uc: Unify uc_fw status tracking
    
    We currently track fetch and load status separately, but the 2 are
    actually sequential in the uc lifetime (fetch must complete before we
    can attempt the load!). Unifying the 2 variables we can better follow
    the sequential states and improve our trackng of the uC state.
    
    Also, sprinkle some GEM_BUG_ON to make sure we transition correctly
    between states.
    
    v2: rename states, add the running state (Michal), drop some logs in
        the fetch path (Michal, Chris)
    
    v3: re-rename states, extend early status check to all helpers (Michal)
    
    Suggested-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725001813.4740-5-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 3f672ea7456b..b1815abecf30 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -560,7 +560,7 @@ void intel_uc_fini_hw(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_guc_is_loaded(guc))
+	if (!intel_guc_is_running(guc))
 		return;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
@@ -582,7 +582,7 @@ void intel_uc_reset_prepare(struct intel_uc *uc)
 {
 	struct intel_guc *guc = &uc->guc;
 
-	if (!intel_guc_is_loaded(guc))
+	if (!intel_guc_is_running(guc))
 		return;
 
 	guc_stop_communication(guc);
@@ -594,7 +594,7 @@ void intel_uc_runtime_suspend(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	int err;
 
-	if (!intel_guc_is_loaded(guc))
+	if (!intel_guc_is_running(guc))
 		return;
 
 	err = intel_guc_suspend(guc);
@@ -609,7 +609,7 @@ void intel_uc_suspend(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	intel_wakeref_t wakeref;
 
-	if (!intel_guc_is_loaded(guc))
+	if (!intel_guc_is_running(guc))
 		return;
 
 	with_intel_runtime_pm(&uc_to_gt(uc)->i915->runtime_pm, wakeref)
@@ -621,7 +621,7 @@ int intel_uc_resume(struct intel_uc *uc)
 	struct intel_guc *guc = &uc->guc;
 	int err;
 
-	if (!intel_guc_is_loaded(guc))
+	if (!intel_guc_is_running(guc))
 		return 0;
 
 	guc_enable_communication(guc);

commit 305ceebd5284a3a6cbeb0f67f1f839cd92be1847
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 24 17:18:07 2019 -0700

    drm/i915: Fix handling of non-supported uC
    
    There are 2 issues around handling of missing uC support:
    
    - We treat lack of uC HW and lack of uC FW definition as 2 different
      cases, but both of them mean that we don't support the uC on the
      platform we're running on.
    
    - We rely on the modparam to decide if we can take uC paths or not, but
      we don't sanitize it if it is set incorrectly on platform with no uC
      support.
    
    To fix both of them, unify the 2 cases in a single one and sanitize the
    modparam on invalid configuration (after printing an error message).
    The log has been adapted as well, since the user doesn't care why we
    don't support GuC/HuC (no HW or no FW), just that we do not. Developers
    can easily find the answer based on the platform, so we can simplify the
    log.
    
    Correcting the modparam has been preferred over failing the load since
    this is what we usually do for non-supported feature (e.g. the now gone
    enable_ppgtt would fall back to the highest supported PPGTT mode if the
    selected one was not available).
    
    Note that this patch purposely doesn't change the behavior for platforms
    that do have uC support, in which case we will still fail if enable_guc
    is set and the firmware is not available on the system.
    
    Suggested-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725001813.4740-3-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index bdb171c3f36e..3f672ea7456b 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -68,7 +68,7 @@ static int __get_platform_enable_guc(struct intel_uc *uc)
 	if (INTEL_GEN(uc_to_gt(uc)->i915) < 11)
 		return 0;
 
-	if (intel_uc_fw_is_selected(guc_fw) && intel_uc_fw_is_selected(huc_fw))
+	if (intel_uc_fw_supported(guc_fw) && intel_uc_fw_supported(huc_fw))
 		enable_guc |= ENABLE_GUC_LOAD_HUC;
 
 	return enable_guc;
@@ -123,26 +123,28 @@ static void sanitize_options_early(struct intel_uc *uc)
 			 yesno(intel_uc_is_using_huc(uc)));
 
 	/* Verify GuC firmware availability */
-	if (intel_uc_is_using_guc(uc) && !intel_uc_fw_is_selected(guc_fw)) {
-		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
-			 "enable_guc", i915_modparams.enable_guc,
-			 !intel_uc_fw_supported(guc_fw) ?
-				"no GuC hardware" : "no GuC firmware");
+	if (intel_uc_is_using_guc(uc) && !intel_uc_fw_supported(guc_fw)) {
+		DRM_WARN("Incompatible option detected: enable_guc=%d, "
+			 "but GuC is not supported!\n",
+			 i915_modparams.enable_guc);
+		DRM_INFO("Disabling GuC/HuC loading!\n");
+		i915_modparams.enable_guc = 0;
 	}
 
 	/* Verify HuC firmware availability */
-	if (intel_uc_is_using_huc(uc) && !intel_uc_fw_is_selected(huc_fw)) {
-		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
-			 "enable_guc", i915_modparams.enable_guc,
-			 !intel_uc_fw_supported(huc_fw) ?
-				"no HuC hardware" : "no HuC firmware");
+	if (intel_uc_is_using_huc(uc) && !intel_uc_fw_supported(huc_fw)) {
+		DRM_WARN("Incompatible option detected: enable_guc=%d, "
+			 "but HuC is not supported!\n",
+			 i915_modparams.enable_guc);
+		DRM_INFO("Disabling HuC loading!\n");
+		i915_modparams.enable_guc &= ~ENABLE_GUC_LOAD_HUC;
 	}
 
 	/* XXX: GuC submission is unavailable for now */
 	if (intel_uc_is_using_guc_submission(uc)) {
-		DRM_INFO("Incompatible option detected: %s=%d, %s!\n",
-			 "enable_guc", i915_modparams.enable_guc,
-			 "GuC submission not supported");
+		DRM_INFO("Incompatible option detected: enable_guc=%d, "
+			 "but GuC submission is not supported!\n",
+			 i915_modparams.enable_guc);
 		DRM_INFO("Switching to non-GuC submission mode!\n");
 		i915_modparams.enable_guc &= ~ENABLE_GUC_SUBMISSION;
 	}
@@ -153,10 +155,9 @@ static void sanitize_options_early(struct intel_uc *uc)
 			__get_default_guc_log_level(uc);
 
 	if (i915_modparams.guc_log_level > 0 && !intel_uc_is_using_guc(uc)) {
-		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
-			 "guc_log_level", i915_modparams.guc_log_level,
-			 !intel_uc_fw_supported(guc_fw) ?
-				"no GuC hardware" : "GuC not enabled");
+		DRM_WARN("Incompatible option detected: guc_log_level=%d, "
+			 "but GuC is not enabled!\n",
+			 i915_modparams.guc_log_level);
 		i915_modparams.guc_log_level = 0;
 	}
 

commit 702668e606c0618fd62c7a5d051c9faee256c049
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 24 17:18:06 2019 -0700

    drm/i915/uc: Unify uC platform check
    
    We have several HAS_* checks for GuC and HuC but we mostly use HAS_GUC
    and HAS_HUC, with only 1 exception. Since our HW always has either
    both uC or neither of them, just replace all the checks with a unified
    HAS_UC.
    
    v2: use HAS_GT_UC (Michal)
    v3: fix comment (Michal)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725001813.4740-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 25a8ab3bd22c..bdb171c3f36e 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -61,7 +61,7 @@ static int __get_platform_enable_guc(struct intel_uc *uc)
 	struct intel_uc_fw *huc_fw = &uc->huc.fw;
 	int enable_guc = 0;
 
-	if (!HAS_GUC(uc_to_gt(uc)->i915))
+	if (!HAS_GT_UC(uc_to_gt(uc)->i915))
 		return 0;
 
 	/* We don't want to enable GuC/HuC on pre-Gen11 by default */

commit 2bf8fb39eb70b6cf1d0f7efbe9fa9fb27d55fdf4
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 24 09:58:49 2019 +0100

    drm/i915/guc: Set GuC init params only once
    
    All the GuC objects are perma-pinned, so their offset can't change at
    runtime. We can therefore set (and log!) the parameters only once during
    boot.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190724085849.18047-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 4480a3dc2449..25a8ab3bd22c 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -492,7 +492,7 @@ int intel_uc_init_hw(struct intel_uc *uc)
 		}
 
 		intel_guc_ads_reset(guc);
-		intel_guc_init_params(guc);
+		intel_guc_write_params(guc);
 		ret = intel_guc_fw_upload(guc);
 		if (ret == 0)
 			break;

commit 3fcba88188a85a398c2c9245d148c952e2d53889
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Jul 23 10:14:03 2019 +0100

    drm/i915/uc: Gt-fy uc reset
    
    This was the last place in gt/uc that was still using I915_READ
    with the global dev_priv.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190723091404.6449-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 5ebb0a534718..4480a3dc2449 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -37,17 +37,17 @@ static void guc_free_load_err_log(struct intel_guc *guc);
  */
 static int __intel_uc_reset_hw(struct intel_uc *uc)
 {
-	struct drm_i915_private *dev_priv = uc_to_gt(uc)->i915;
+	struct intel_gt *gt = uc_to_gt(uc);
 	int ret;
 	u32 guc_status;
 
-	ret = intel_reset_guc(&dev_priv->gt);
+	ret = intel_reset_guc(gt);
 	if (ret) {
 		DRM_ERROR("Failed to reset GuC, ret = %d\n", ret);
 		return ret;
 	}
 
-	guc_status = I915_READ(GUC_STATUS);
+	guc_status = intel_uncore_read(gt->uncore, GUC_STATUS);
 	WARN(!(guc_status & GS_MIA_IN_RESET),
 	     "GuC status: 0x%x, MIA core expected to be in reset\n",
 	     guc_status);

commit a8120bc23eeae8f09a49167e32fa79ce5336546e
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:16 2019 +0100

    drm/i915/uc: kill <g,h>uc_to_i915
    
    Get rid of them to avoid more users being added while the guc code
    transitions to use gt more than i915.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Acked-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-11-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 41a770865477..5ebb0a534718 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -252,7 +252,7 @@ static void guc_get_mmio_msg(struct intel_guc *guc)
 
 static void guc_handle_mmio_msg(struct intel_guc *guc)
 {
-	struct drm_i915_private *i915 = guc_to_i915(guc);
+	struct drm_i915_private *i915 = guc_to_gt(guc)->i915;
 
 	/* we need communication to be enabled to reply to GuC */
 	GEM_BUG_ON(guc->handler == intel_guc_to_host_event_handler_nop);
@@ -284,7 +284,7 @@ static void guc_disable_interrupts(struct intel_guc *guc)
 
 static int guc_enable_communication(struct intel_guc *guc)
 {
-	struct drm_i915_private *i915 = guc_to_i915(guc);
+	struct drm_i915_private *i915 = guc_to_gt(guc)->i915;
 	int ret;
 
 	ret = intel_guc_ct_enable(&guc->ct);

commit 84b1ca2f0e68e89186f552ab839dc8da7c3ddc87
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:14 2019 +0100

    drm/i915/uc: prefer intel_gt over i915 in GuC/HuC paths
    
    With our HW interface logic moving from i915 to gt and with GuC and HuC
    being part of the gt HW, it makes sense to use the intel_gt structure
    instead of i915 as our reference object in GuC/HuC paths.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-9-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 0c43d547bc94..41a770865477 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -228,7 +228,7 @@ static void guc_free_load_err_log(struct intel_guc *guc)
  */
 static void guc_clear_mmio_msg(struct intel_guc *guc)
 {
-	intel_uncore_write(&guc_to_i915(guc)->uncore, SOFT_SCRATCH(15), 0);
+	intel_uncore_write(guc_to_gt(guc)->uncore, SOFT_SCRATCH(15), 0);
 }
 
 static void guc_get_mmio_msg(struct intel_guc *guc)
@@ -237,7 +237,7 @@ static void guc_get_mmio_msg(struct intel_guc *guc)
 
 	spin_lock_irq(&guc->irq_lock);
 
-	val = intel_uncore_read(&guc_to_i915(guc)->uncore, SOFT_SCRATCH(15));
+	val = intel_uncore_read(guc_to_gt(guc)->uncore, SOFT_SCRATCH(15));
 	guc->mmio_msg |= val & guc->msg_enabled_mask;
 
 	/*

commit ca7b2c1bbede6187342dd0bec8666ab4481fa6ad
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:13 2019 +0100

    drm/i915/uc: Move intel functions to intel_uc
    
    All the intel_uc_* can now be moved to work on the intel_uc structure
    for better encapsulation of uc-related actions.
    
    Note: I've introduced uc_to_gt instead of uc_to_i915 because the aim is
    to move everything to be gt-focused in the medium term, so we would've
    had to replace it soon anyway.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Acked-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-8-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index f47ee7601a66..0c43d547bc94 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -22,19 +22,22 @@
  *
  */
 
+#include "gt/intel_gt.h"
 #include "gt/intel_reset.h"
-#include "intel_uc.h"
 #include "intel_guc.h"
 #include "intel_guc_ads.h"
 #include "intel_guc_submission.h"
+#include "intel_uc.h"
+
 #include "i915_drv.h"
 
 static void guc_free_load_err_log(struct intel_guc *guc);
 
 /* Reset GuC providing us with fresh state for both GuC and HuC.
  */
-static int __intel_uc_reset_hw(struct drm_i915_private *dev_priv)
+static int __intel_uc_reset_hw(struct intel_uc *uc)
 {
+	struct drm_i915_private *dev_priv = uc_to_gt(uc)->i915;
 	int ret;
 	u32 guc_status;
 
@@ -52,17 +55,17 @@ static int __intel_uc_reset_hw(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-static int __get_platform_enable_guc(struct drm_i915_private *i915)
+static int __get_platform_enable_guc(struct intel_uc *uc)
 {
-	struct intel_uc_fw *guc_fw = &i915->gt.uc.guc.fw;
-	struct intel_uc_fw *huc_fw = &i915->gt.uc.huc.fw;
+	struct intel_uc_fw *guc_fw = &uc->guc.fw;
+	struct intel_uc_fw *huc_fw = &uc->huc.fw;
 	int enable_guc = 0;
 
-	if (!HAS_GUC(i915))
+	if (!HAS_GUC(uc_to_gt(uc)->i915))
 		return 0;
 
 	/* We don't want to enable GuC/HuC on pre-Gen11 by default */
-	if (INTEL_GEN(i915) < 11)
+	if (INTEL_GEN(uc_to_gt(uc)->i915) < 11)
 		return 0;
 
 	if (intel_uc_fw_is_selected(guc_fw) && intel_uc_fw_is_selected(huc_fw))
@@ -71,12 +74,11 @@ static int __get_platform_enable_guc(struct drm_i915_private *i915)
 	return enable_guc;
 }
 
-static int __get_default_guc_log_level(struct drm_i915_private *i915)
+static int __get_default_guc_log_level(struct intel_uc *uc)
 {
 	int guc_log_level;
 
-	if (!intel_uc_fw_supported(&i915->gt.uc.guc.fw) ||
-	    !intel_uc_is_using_guc(i915))
+	if (!intel_uc_fw_supported(&uc->guc.fw) || !intel_uc_is_using_guc(uc))
 		guc_log_level = GUC_LOG_LEVEL_DISABLED;
 	else if (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||
 		 IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
@@ -91,7 +93,7 @@ static int __get_default_guc_log_level(struct drm_i915_private *i915)
 
 /**
  * sanitize_options_early - sanitize uC related modparam options
- * @i915: device private
+ * @uc: the intel_uc structure
  *
  * In case of "enable_guc" option this function will attempt to modify
  * it only if it was initially set to "auto(-1)". Default value for this
@@ -106,22 +108,22 @@ static int __get_default_guc_log_level(struct drm_i915_private *i915)
  * unless GuC is enabled on given platform and the driver is compiled with
  * debug config when this modparam will default to "enable(1..4)".
  */
-static void sanitize_options_early(struct drm_i915_private *i915)
+static void sanitize_options_early(struct intel_uc *uc)
 {
-	struct intel_uc_fw *guc_fw = &i915->gt.uc.guc.fw;
-	struct intel_uc_fw *huc_fw = &i915->gt.uc.huc.fw;
+	struct intel_uc_fw *guc_fw = &uc->guc.fw;
+	struct intel_uc_fw *huc_fw = &uc->huc.fw;
 
 	/* A negative value means "use platform default" */
 	if (i915_modparams.enable_guc < 0)
-		i915_modparams.enable_guc = __get_platform_enable_guc(i915);
+		i915_modparams.enable_guc = __get_platform_enable_guc(uc);
 
 	DRM_DEBUG_DRIVER("enable_guc=%d (submission:%s huc:%s)\n",
 			 i915_modparams.enable_guc,
-			 yesno(intel_uc_is_using_guc_submission(i915)),
-			 yesno(intel_uc_is_using_huc(i915)));
+			 yesno(intel_uc_is_using_guc_submission(uc)),
+			 yesno(intel_uc_is_using_huc(uc)));
 
 	/* Verify GuC firmware availability */
-	if (intel_uc_is_using_guc(i915) && !intel_uc_fw_is_selected(guc_fw)) {
+	if (intel_uc_is_using_guc(uc) && !intel_uc_fw_is_selected(guc_fw)) {
 		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
 			 "enable_guc", i915_modparams.enable_guc,
 			 !intel_uc_fw_supported(guc_fw) ?
@@ -129,7 +131,7 @@ static void sanitize_options_early(struct drm_i915_private *i915)
 	}
 
 	/* Verify HuC firmware availability */
-	if (intel_uc_is_using_huc(i915) && !intel_uc_fw_is_selected(huc_fw)) {
+	if (intel_uc_is_using_huc(uc) && !intel_uc_fw_is_selected(huc_fw)) {
 		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
 			 "enable_guc", i915_modparams.enable_guc,
 			 !intel_uc_fw_supported(huc_fw) ?
@@ -137,7 +139,7 @@ static void sanitize_options_early(struct drm_i915_private *i915)
 	}
 
 	/* XXX: GuC submission is unavailable for now */
-	if (intel_uc_is_using_guc_submission(i915)) {
+	if (intel_uc_is_using_guc_submission(uc)) {
 		DRM_INFO("Incompatible option detected: %s=%d, %s!\n",
 			 "enable_guc", i915_modparams.enable_guc,
 			 "GuC submission not supported");
@@ -148,9 +150,9 @@ static void sanitize_options_early(struct drm_i915_private *i915)
 	/* A negative value means "use platform/config default" */
 	if (i915_modparams.guc_log_level < 0)
 		i915_modparams.guc_log_level =
-			__get_default_guc_log_level(i915);
+			__get_default_guc_log_level(uc);
 
-	if (i915_modparams.guc_log_level > 0 && !intel_uc_is_using_guc(i915)) {
+	if (i915_modparams.guc_log_level > 0 && !intel_uc_is_using_guc(uc)) {
 		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
 			 "guc_log_level", i915_modparams.guc_log_level,
 			 !intel_uc_fw_supported(guc_fw) ?
@@ -176,34 +178,29 @@ static void sanitize_options_early(struct drm_i915_private *i915)
 	GEM_BUG_ON(i915_modparams.guc_log_level < 0);
 }
 
-void intel_uc_init_early(struct drm_i915_private *i915)
+void intel_uc_init_early(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
-	struct intel_huc *huc = &i915->gt.uc.huc;
+	intel_guc_init_early(&uc->guc);
+	intel_huc_init_early(&uc->huc);
 
-	intel_guc_init_early(guc);
-	intel_huc_init_early(huc);
-
-	sanitize_options_early(i915);
+	sanitize_options_early(uc);
 }
 
-void intel_uc_cleanup_early(struct drm_i915_private *i915)
+void intel_uc_cleanup_early(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
-
-	guc_free_load_err_log(guc);
+	guc_free_load_err_log(&uc->guc);
 }
 
 /**
  * intel_uc_init_mmio - setup uC MMIO access
- * @i915: device private
+ * @uc: the intel_uc structure
  *
  * Setup minimal state necessary for MMIO accesses later in the
  * initialization sequence.
  */
-void intel_uc_init_mmio(struct drm_i915_private *i915)
+void intel_uc_init_mmio(struct intel_uc *uc)
 {
-	intel_guc_init_send_regs(&i915->gt.uc.guc);
+	intel_guc_init_send_regs(&uc->guc);
 }
 
 static void guc_capture_load_err_log(struct intel_guc *guc)
@@ -350,54 +347,56 @@ static void guc_disable_communication(struct intel_guc *guc)
 	DRM_INFO("GuC communication disabled\n");
 }
 
-void intel_uc_fetch_firmwares(struct drm_i915_private *i915)
+void intel_uc_fetch_firmwares(struct intel_uc *uc)
 {
-	if (!USES_GUC(i915))
+	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
+
+	if (!intel_uc_is_using_guc(uc))
 		return;
 
-	intel_uc_fw_fetch(i915, &i915->gt.uc.guc.fw);
+	intel_uc_fw_fetch(i915, &uc->guc.fw);
 
-	if (USES_HUC(i915))
-		intel_uc_fw_fetch(i915, &i915->gt.uc.huc.fw);
+	if (intel_uc_is_using_huc(uc))
+		intel_uc_fw_fetch(i915, &uc->huc.fw);
 }
 
-void intel_uc_cleanup_firmwares(struct drm_i915_private *i915)
+void intel_uc_cleanup_firmwares(struct intel_uc *uc)
 {
-	if (!USES_GUC(i915))
+	if (!intel_uc_is_using_guc(uc))
 		return;
 
-	if (USES_HUC(i915))
-		intel_uc_fw_cleanup_fetch(&i915->gt.uc.huc.fw);
+	if (intel_uc_is_using_huc(uc))
+		intel_uc_fw_cleanup_fetch(&uc->huc.fw);
 
-	intel_uc_fw_cleanup_fetch(&i915->gt.uc.guc.fw);
+	intel_uc_fw_cleanup_fetch(&uc->guc.fw);
 }
 
-int intel_uc_init(struct drm_i915_private *i915)
+int intel_uc_init(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
-	struct intel_huc *huc = &i915->gt.uc.huc;
+	struct intel_guc *guc = &uc->guc;
+	struct intel_huc *huc = &uc->huc;
 	int ret;
 
-	if (!USES_GUC(i915))
+	if (!intel_uc_is_using_guc(uc))
 		return 0;
 
 	if (!intel_uc_fw_supported(&guc->fw))
 		return -ENODEV;
 
 	/* XXX: GuC submission is unavailable for now */
-	GEM_BUG_ON(USES_GUC_SUBMISSION(i915));
+	GEM_BUG_ON(intel_uc_is_using_guc_submission(uc));
 
 	ret = intel_guc_init(guc);
 	if (ret)
 		return ret;
 
-	if (USES_HUC(i915)) {
+	if (intel_uc_is_using_huc(uc)) {
 		ret = intel_huc_init(huc);
 		if (ret)
 			goto err_guc;
 	}
 
-	if (USES_GUC_SUBMISSION(i915)) {
+	if (intel_uc_is_using_guc_submission(uc)) {
 		/*
 		 * This is stuff we need to have available at fw load time
 		 * if we are planning to enable submission later
@@ -410,59 +409,60 @@ int intel_uc_init(struct drm_i915_private *i915)
 	return 0;
 
 err_huc:
-	if (USES_HUC(i915))
+	if (intel_uc_is_using_huc(uc))
 		intel_huc_fini(huc);
 err_guc:
 	intel_guc_fini(guc);
 	return ret;
 }
 
-void intel_uc_fini(struct drm_i915_private *i915)
+void intel_uc_fini(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 
-	if (!USES_GUC(i915))
+	if (!intel_uc_is_using_guc(uc))
 		return;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
-	if (USES_GUC_SUBMISSION(i915))
+	if (intel_uc_is_using_guc_submission(uc))
 		intel_guc_submission_fini(guc);
 
-	if (USES_HUC(i915))
-		intel_huc_fini(&i915->gt.uc.huc);
+	if (intel_uc_is_using_huc(uc))
+		intel_huc_fini(&uc->huc);
 
 	intel_guc_fini(guc);
 }
 
-static void __uc_sanitize(struct drm_i915_private *i915)
+static void __uc_sanitize(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
-	struct intel_huc *huc = &i915->gt.uc.huc;
+	struct intel_guc *guc = &uc->guc;
+	struct intel_huc *huc = &uc->huc;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
 	intel_huc_sanitize(huc);
 	intel_guc_sanitize(guc);
 
-	__intel_uc_reset_hw(i915);
+	__intel_uc_reset_hw(uc);
 }
 
-void intel_uc_sanitize(struct drm_i915_private *i915)
+void intel_uc_sanitize(struct intel_uc *uc)
 {
-	if (!USES_GUC(i915))
+	if (!intel_uc_is_using_guc(uc))
 		return;
 
-	__uc_sanitize(i915);
+	__uc_sanitize(uc);
 }
 
-int intel_uc_init_hw(struct drm_i915_private *i915)
+int intel_uc_init_hw(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
-	struct intel_huc *huc = &i915->gt.uc.huc;
+	struct drm_i915_private *i915 = uc_to_gt(uc)->i915;
+	struct intel_guc *guc = &uc->guc;
+	struct intel_huc *huc = &uc->huc;
 	int ret, attempts;
 
-	if (!USES_GUC(i915))
+	if (!intel_uc_is_using_guc(uc))
 		return 0;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
@@ -481,11 +481,11 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 		 * Always reset the GuC just before (re)loading, so
 		 * that the state and timing are fairly predictable
 		 */
-		ret = __intel_uc_reset_hw(i915);
+		ret = __intel_uc_reset_hw(uc);
 		if (ret)
 			goto err_out;
 
-		if (USES_HUC(i915)) {
+		if (intel_uc_is_using_huc(uc)) {
 			ret = intel_huc_fw_upload(huc);
 			if (ret)
 				goto err_out;
@@ -509,7 +509,7 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 	if (ret)
 		goto err_log_capture;
 
-	if (USES_HUC(i915)) {
+	if (intel_uc_is_using_huc(uc)) {
 		ret = intel_huc_auth(huc);
 		if (ret)
 			goto err_communication;
@@ -519,7 +519,7 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 	if (ret)
 		goto err_communication;
 
-	if (USES_GUC_SUBMISSION(i915)) {
+	if (intel_uc_is_using_guc_submission(uc)) {
 		ret = intel_guc_submission_enable(guc);
 		if (ret)
 			goto err_communication;
@@ -528,9 +528,9 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 	dev_info(i915->drm.dev, "GuC firmware version %u.%u\n",
 		 guc->fw.major_ver_found, guc->fw.minor_ver_found);
 	dev_info(i915->drm.dev, "GuC submission %s\n",
-		 enableddisabled(USES_GUC_SUBMISSION(i915)));
+		 enableddisabled(intel_uc_is_using_guc_submission(uc)));
 	dev_info(i915->drm.dev, "HuC %s\n",
-		 enableddisabled(USES_HUC(i915)));
+		 enableddisabled(intel_uc_is_using_huc(uc)));
 
 	return 0;
 
@@ -542,7 +542,7 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 err_log_capture:
 	guc_capture_load_err_log(guc);
 err_out:
-	__uc_sanitize(i915);
+	__uc_sanitize(uc);
 
 	/*
 	 * Note that there is no fallback as either user explicitly asked for
@@ -555,42 +555,42 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 	return ret;
 }
 
-void intel_uc_fini_hw(struct drm_i915_private *i915)
+void intel_uc_fini_hw(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 
 	if (!intel_guc_is_loaded(guc))
 		return;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
-	if (USES_GUC_SUBMISSION(i915))
+	if (intel_uc_is_using_guc_submission(uc))
 		intel_guc_submission_disable(guc);
 
 	guc_disable_communication(guc);
-	__uc_sanitize(i915);
+	__uc_sanitize(uc);
 }
 
 /**
  * intel_uc_reset_prepare - Prepare for reset
- * @i915: device private
+ * @uc: the intel_uc structure
  *
  * Preparing for full gpu reset.
  */
-void intel_uc_reset_prepare(struct drm_i915_private *i915)
+void intel_uc_reset_prepare(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 
 	if (!intel_guc_is_loaded(guc))
 		return;
 
 	guc_stop_communication(guc);
-	__uc_sanitize(i915);
+	__uc_sanitize(uc);
 }
 
-void intel_uc_runtime_suspend(struct drm_i915_private *i915)
+void intel_uc_runtime_suspend(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 	int err;
 
 	if (!intel_guc_is_loaded(guc))
@@ -603,21 +603,21 @@ void intel_uc_runtime_suspend(struct drm_i915_private *i915)
 	guc_disable_communication(guc);
 }
 
-void intel_uc_suspend(struct drm_i915_private *i915)
+void intel_uc_suspend(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 	intel_wakeref_t wakeref;
 
 	if (!intel_guc_is_loaded(guc))
 		return;
 
-	with_intel_runtime_pm(&i915->runtime_pm, wakeref)
-		intel_uc_runtime_suspend(i915);
+	with_intel_runtime_pm(&uc_to_gt(uc)->i915->runtime_pm, wakeref)
+		intel_uc_runtime_suspend(uc);
 }
 
-int intel_uc_resume(struct drm_i915_private *i915)
+int intel_uc_resume(struct intel_uc *uc)
 {
-	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_guc *guc = &uc->guc;
 	int err;
 
 	if (!intel_guc_is_loaded(guc))

commit 8b5689d7e3ca889a7e55c79bc335b33e3f170a18
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:12 2019 +0100

    drm/i915/uc: move GuC/HuC inside intel_gt under a new intel_uc
    
    Being part of the GT HW, it make sense to keep the guc/huc structures
    inside the GT structure. To help with the encapsulation work done by the
    following patches, both structures are placed inside a new intel_uc
    container. Although this results in code with ugly nested dereferences
    (i915->gt.uc.guc...), it saves us the extra work required in moving
    the structures twice (i915 -> gt -> uc). The following patches will
    reduce the number of places where we try to access the guc/huc
    structures directly from i915 and reduce the ugliness.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-7-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 4ea7661705b1..f47ee7601a66 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -54,8 +54,8 @@ static int __intel_uc_reset_hw(struct drm_i915_private *dev_priv)
 
 static int __get_platform_enable_guc(struct drm_i915_private *i915)
 {
-	struct intel_uc_fw *guc_fw = &i915->guc.fw;
-	struct intel_uc_fw *huc_fw = &i915->huc.fw;
+	struct intel_uc_fw *guc_fw = &i915->gt.uc.guc.fw;
+	struct intel_uc_fw *huc_fw = &i915->gt.uc.huc.fw;
 	int enable_guc = 0;
 
 	if (!HAS_GUC(i915))
@@ -75,7 +75,7 @@ static int __get_default_guc_log_level(struct drm_i915_private *i915)
 {
 	int guc_log_level;
 
-	if (!intel_uc_fw_supported(&i915->guc.fw) ||
+	if (!intel_uc_fw_supported(&i915->gt.uc.guc.fw) ||
 	    !intel_uc_is_using_guc(i915))
 		guc_log_level = GUC_LOG_LEVEL_DISABLED;
 	else if (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||
@@ -108,8 +108,8 @@ static int __get_default_guc_log_level(struct drm_i915_private *i915)
  */
 static void sanitize_options_early(struct drm_i915_private *i915)
 {
-	struct intel_uc_fw *guc_fw = &i915->guc.fw;
-	struct intel_uc_fw *huc_fw = &i915->huc.fw;
+	struct intel_uc_fw *guc_fw = &i915->gt.uc.guc.fw;
+	struct intel_uc_fw *huc_fw = &i915->gt.uc.huc.fw;
 
 	/* A negative value means "use platform default" */
 	if (i915_modparams.enable_guc < 0)
@@ -178,8 +178,8 @@ static void sanitize_options_early(struct drm_i915_private *i915)
 
 void intel_uc_init_early(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
-	struct intel_huc *huc = &i915->huc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_huc *huc = &i915->gt.uc.huc;
 
 	intel_guc_init_early(guc);
 	intel_huc_init_early(huc);
@@ -189,7 +189,7 @@ void intel_uc_init_early(struct drm_i915_private *i915)
 
 void intel_uc_cleanup_early(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 
 	guc_free_load_err_log(guc);
 }
@@ -203,7 +203,7 @@ void intel_uc_cleanup_early(struct drm_i915_private *i915)
  */
 void intel_uc_init_mmio(struct drm_i915_private *i915)
 {
-	intel_guc_init_send_regs(&i915->guc);
+	intel_guc_init_send_regs(&i915->gt.uc.guc);
 }
 
 static void guc_capture_load_err_log(struct intel_guc *guc)
@@ -355,10 +355,10 @@ void intel_uc_fetch_firmwares(struct drm_i915_private *i915)
 	if (!USES_GUC(i915))
 		return;
 
-	intel_uc_fw_fetch(i915, &i915->guc.fw);
+	intel_uc_fw_fetch(i915, &i915->gt.uc.guc.fw);
 
 	if (USES_HUC(i915))
-		intel_uc_fw_fetch(i915, &i915->huc.fw);
+		intel_uc_fw_fetch(i915, &i915->gt.uc.huc.fw);
 }
 
 void intel_uc_cleanup_firmwares(struct drm_i915_private *i915)
@@ -367,15 +367,15 @@ void intel_uc_cleanup_firmwares(struct drm_i915_private *i915)
 		return;
 
 	if (USES_HUC(i915))
-		intel_uc_fw_cleanup_fetch(&i915->huc.fw);
+		intel_uc_fw_cleanup_fetch(&i915->gt.uc.huc.fw);
 
-	intel_uc_fw_cleanup_fetch(&i915->guc.fw);
+	intel_uc_fw_cleanup_fetch(&i915->gt.uc.guc.fw);
 }
 
 int intel_uc_init(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
-	struct intel_huc *huc = &i915->huc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_huc *huc = &i915->gt.uc.huc;
 	int ret;
 
 	if (!USES_GUC(i915))
@@ -419,7 +419,7 @@ int intel_uc_init(struct drm_i915_private *i915)
 
 void intel_uc_fini(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 
 	if (!USES_GUC(i915))
 		return;
@@ -430,15 +430,15 @@ void intel_uc_fini(struct drm_i915_private *i915)
 		intel_guc_submission_fini(guc);
 
 	if (USES_HUC(i915))
-		intel_huc_fini(&i915->huc);
+		intel_huc_fini(&i915->gt.uc.huc);
 
 	intel_guc_fini(guc);
 }
 
 static void __uc_sanitize(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
-	struct intel_huc *huc = &i915->huc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_huc *huc = &i915->gt.uc.huc;
 
 	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
 
@@ -458,8 +458,8 @@ void intel_uc_sanitize(struct drm_i915_private *i915)
 
 int intel_uc_init_hw(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
-	struct intel_huc *huc = &i915->huc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
+	struct intel_huc *huc = &i915->gt.uc.huc;
 	int ret, attempts;
 
 	if (!USES_GUC(i915))
@@ -557,7 +557,7 @@ int intel_uc_init_hw(struct drm_i915_private *i915)
 
 void intel_uc_fini_hw(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 
 	if (!intel_guc_is_loaded(guc))
 		return;
@@ -579,7 +579,7 @@ void intel_uc_fini_hw(struct drm_i915_private *i915)
  */
 void intel_uc_reset_prepare(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 
 	if (!intel_guc_is_loaded(guc))
 		return;
@@ -590,7 +590,7 @@ void intel_uc_reset_prepare(struct drm_i915_private *i915)
 
 void intel_uc_runtime_suspend(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 	int err;
 
 	if (!intel_guc_is_loaded(guc))
@@ -605,7 +605,7 @@ void intel_uc_runtime_suspend(struct drm_i915_private *i915)
 
 void intel_uc_suspend(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 	intel_wakeref_t wakeref;
 
 	if (!intel_guc_is_loaded(guc))
@@ -617,7 +617,7 @@ void intel_uc_suspend(struct drm_i915_private *i915)
 
 int intel_uc_resume(struct drm_i915_private *i915)
 {
-	struct intel_guc *guc = &i915->guc;
+	struct intel_guc *guc = &i915->gt.uc.guc;
 	int err;
 
 	if (!intel_guc_is_loaded(guc))

commit 0f261b241d9cd01d58dce85a35df26fd38320b10
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:11 2019 +0100

    drm/i915/uc: move GuC and HuC files under gt/uc/
    
    Both microcontrollers are part of the GT HW and are closely related to
    GT operations. To keep all the files cleanly together, they've been
    placed in their own subdir inside the gt/ folder
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-6-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
new file mode 100644
index 000000000000..4ea7661705b1
--- /dev/null
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -0,0 +1,635 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include "gt/intel_reset.h"
+#include "intel_uc.h"
+#include "intel_guc.h"
+#include "intel_guc_ads.h"
+#include "intel_guc_submission.h"
+#include "i915_drv.h"
+
+static void guc_free_load_err_log(struct intel_guc *guc);
+
+/* Reset GuC providing us with fresh state for both GuC and HuC.
+ */
+static int __intel_uc_reset_hw(struct drm_i915_private *dev_priv)
+{
+	int ret;
+	u32 guc_status;
+
+	ret = intel_reset_guc(&dev_priv->gt);
+	if (ret) {
+		DRM_ERROR("Failed to reset GuC, ret = %d\n", ret);
+		return ret;
+	}
+
+	guc_status = I915_READ(GUC_STATUS);
+	WARN(!(guc_status & GS_MIA_IN_RESET),
+	     "GuC status: 0x%x, MIA core expected to be in reset\n",
+	     guc_status);
+
+	return ret;
+}
+
+static int __get_platform_enable_guc(struct drm_i915_private *i915)
+{
+	struct intel_uc_fw *guc_fw = &i915->guc.fw;
+	struct intel_uc_fw *huc_fw = &i915->huc.fw;
+	int enable_guc = 0;
+
+	if (!HAS_GUC(i915))
+		return 0;
+
+	/* We don't want to enable GuC/HuC on pre-Gen11 by default */
+	if (INTEL_GEN(i915) < 11)
+		return 0;
+
+	if (intel_uc_fw_is_selected(guc_fw) && intel_uc_fw_is_selected(huc_fw))
+		enable_guc |= ENABLE_GUC_LOAD_HUC;
+
+	return enable_guc;
+}
+
+static int __get_default_guc_log_level(struct drm_i915_private *i915)
+{
+	int guc_log_level;
+
+	if (!intel_uc_fw_supported(&i915->guc.fw) ||
+	    !intel_uc_is_using_guc(i915))
+		guc_log_level = GUC_LOG_LEVEL_DISABLED;
+	else if (IS_ENABLED(CONFIG_DRM_I915_DEBUG) ||
+		 IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
+		guc_log_level = GUC_LOG_LEVEL_MAX;
+	else
+		guc_log_level = GUC_LOG_LEVEL_NON_VERBOSE;
+
+	/* Any platform specific fine-tuning can be done here */
+
+	return guc_log_level;
+}
+
+/**
+ * sanitize_options_early - sanitize uC related modparam options
+ * @i915: device private
+ *
+ * In case of "enable_guc" option this function will attempt to modify
+ * it only if it was initially set to "auto(-1)". Default value for this
+ * modparam varies between platforms and it is hardcoded in driver code.
+ * Any other modparam value is only monitored against availability of the
+ * related hardware or firmware definitions.
+ *
+ * In case of "guc_log_level" option this function will attempt to modify
+ * it only if it was initially set to "auto(-1)" or if initial value was
+ * "enable(1..4)" on platforms without the GuC. Default value for this
+ * modparam varies between platforms and is usually set to "disable(0)"
+ * unless GuC is enabled on given platform and the driver is compiled with
+ * debug config when this modparam will default to "enable(1..4)".
+ */
+static void sanitize_options_early(struct drm_i915_private *i915)
+{
+	struct intel_uc_fw *guc_fw = &i915->guc.fw;
+	struct intel_uc_fw *huc_fw = &i915->huc.fw;
+
+	/* A negative value means "use platform default" */
+	if (i915_modparams.enable_guc < 0)
+		i915_modparams.enable_guc = __get_platform_enable_guc(i915);
+
+	DRM_DEBUG_DRIVER("enable_guc=%d (submission:%s huc:%s)\n",
+			 i915_modparams.enable_guc,
+			 yesno(intel_uc_is_using_guc_submission(i915)),
+			 yesno(intel_uc_is_using_huc(i915)));
+
+	/* Verify GuC firmware availability */
+	if (intel_uc_is_using_guc(i915) && !intel_uc_fw_is_selected(guc_fw)) {
+		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
+			 "enable_guc", i915_modparams.enable_guc,
+			 !intel_uc_fw_supported(guc_fw) ?
+				"no GuC hardware" : "no GuC firmware");
+	}
+
+	/* Verify HuC firmware availability */
+	if (intel_uc_is_using_huc(i915) && !intel_uc_fw_is_selected(huc_fw)) {
+		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
+			 "enable_guc", i915_modparams.enable_guc,
+			 !intel_uc_fw_supported(huc_fw) ?
+				"no HuC hardware" : "no HuC firmware");
+	}
+
+	/* XXX: GuC submission is unavailable for now */
+	if (intel_uc_is_using_guc_submission(i915)) {
+		DRM_INFO("Incompatible option detected: %s=%d, %s!\n",
+			 "enable_guc", i915_modparams.enable_guc,
+			 "GuC submission not supported");
+		DRM_INFO("Switching to non-GuC submission mode!\n");
+		i915_modparams.enable_guc &= ~ENABLE_GUC_SUBMISSION;
+	}
+
+	/* A negative value means "use platform/config default" */
+	if (i915_modparams.guc_log_level < 0)
+		i915_modparams.guc_log_level =
+			__get_default_guc_log_level(i915);
+
+	if (i915_modparams.guc_log_level > 0 && !intel_uc_is_using_guc(i915)) {
+		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
+			 "guc_log_level", i915_modparams.guc_log_level,
+			 !intel_uc_fw_supported(guc_fw) ?
+				"no GuC hardware" : "GuC not enabled");
+		i915_modparams.guc_log_level = 0;
+	}
+
+	if (i915_modparams.guc_log_level > GUC_LOG_LEVEL_MAX) {
+		DRM_WARN("Incompatible option detected: %s=%d, %s!\n",
+			 "guc_log_level", i915_modparams.guc_log_level,
+			 "verbosity too high");
+		i915_modparams.guc_log_level = GUC_LOG_LEVEL_MAX;
+	}
+
+	DRM_DEBUG_DRIVER("guc_log_level=%d (enabled:%s, verbose:%s, verbosity:%d)\n",
+			 i915_modparams.guc_log_level,
+			 yesno(i915_modparams.guc_log_level),
+			 yesno(GUC_LOG_LEVEL_IS_VERBOSE(i915_modparams.guc_log_level)),
+			 GUC_LOG_LEVEL_TO_VERBOSITY(i915_modparams.guc_log_level));
+
+	/* Make sure that sanitization was done */
+	GEM_BUG_ON(i915_modparams.enable_guc < 0);
+	GEM_BUG_ON(i915_modparams.guc_log_level < 0);
+}
+
+void intel_uc_init_early(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	struct intel_huc *huc = &i915->huc;
+
+	intel_guc_init_early(guc);
+	intel_huc_init_early(huc);
+
+	sanitize_options_early(i915);
+}
+
+void intel_uc_cleanup_early(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+
+	guc_free_load_err_log(guc);
+}
+
+/**
+ * intel_uc_init_mmio - setup uC MMIO access
+ * @i915: device private
+ *
+ * Setup minimal state necessary for MMIO accesses later in the
+ * initialization sequence.
+ */
+void intel_uc_init_mmio(struct drm_i915_private *i915)
+{
+	intel_guc_init_send_regs(&i915->guc);
+}
+
+static void guc_capture_load_err_log(struct intel_guc *guc)
+{
+	if (!guc->log.vma || !intel_guc_log_get_level(&guc->log))
+		return;
+
+	if (!guc->load_err_log)
+		guc->load_err_log = i915_gem_object_get(guc->log.vma->obj);
+
+	return;
+}
+
+static void guc_free_load_err_log(struct intel_guc *guc)
+{
+	if (guc->load_err_log)
+		i915_gem_object_put(guc->load_err_log);
+}
+
+/*
+ * Events triggered while CT buffers are disabled are logged in the SCRATCH_15
+ * register using the same bits used in the CT message payload. Since our
+ * communication channel with guc is turned off at this point, we can save the
+ * message and handle it after we turn it back on.
+ */
+static void guc_clear_mmio_msg(struct intel_guc *guc)
+{
+	intel_uncore_write(&guc_to_i915(guc)->uncore, SOFT_SCRATCH(15), 0);
+}
+
+static void guc_get_mmio_msg(struct intel_guc *guc)
+{
+	u32 val;
+
+	spin_lock_irq(&guc->irq_lock);
+
+	val = intel_uncore_read(&guc_to_i915(guc)->uncore, SOFT_SCRATCH(15));
+	guc->mmio_msg |= val & guc->msg_enabled_mask;
+
+	/*
+	 * clear all events, including the ones we're not currently servicing,
+	 * to make sure we don't try to process a stale message if we enable
+	 * handling of more events later.
+	 */
+	guc_clear_mmio_msg(guc);
+
+	spin_unlock_irq(&guc->irq_lock);
+}
+
+static void guc_handle_mmio_msg(struct intel_guc *guc)
+{
+	struct drm_i915_private *i915 = guc_to_i915(guc);
+
+	/* we need communication to be enabled to reply to GuC */
+	GEM_BUG_ON(guc->handler == intel_guc_to_host_event_handler_nop);
+
+	if (!guc->mmio_msg)
+		return;
+
+	spin_lock_irq(&i915->irq_lock);
+	intel_guc_to_host_process_recv_msg(guc, &guc->mmio_msg, 1);
+	spin_unlock_irq(&i915->irq_lock);
+
+	guc->mmio_msg = 0;
+}
+
+static void guc_reset_interrupts(struct intel_guc *guc)
+{
+	guc->interrupts.reset(guc);
+}
+
+static void guc_enable_interrupts(struct intel_guc *guc)
+{
+	guc->interrupts.enable(guc);
+}
+
+static void guc_disable_interrupts(struct intel_guc *guc)
+{
+	guc->interrupts.disable(guc);
+}
+
+static int guc_enable_communication(struct intel_guc *guc)
+{
+	struct drm_i915_private *i915 = guc_to_i915(guc);
+	int ret;
+
+	ret = intel_guc_ct_enable(&guc->ct);
+	if (ret)
+		return ret;
+
+	guc->send = intel_guc_send_ct;
+	guc->handler = intel_guc_to_host_event_handler_ct;
+
+	/* check for mmio messages received before/during the CT enable */
+	guc_get_mmio_msg(guc);
+	guc_handle_mmio_msg(guc);
+
+	guc_enable_interrupts(guc);
+
+	/* check for CT messages received before we enabled interrupts */
+	spin_lock_irq(&i915->irq_lock);
+	intel_guc_to_host_event_handler_ct(guc);
+	spin_unlock_irq(&i915->irq_lock);
+
+	DRM_INFO("GuC communication enabled\n");
+
+	return 0;
+}
+
+static void guc_stop_communication(struct intel_guc *guc)
+{
+	intel_guc_ct_stop(&guc->ct);
+
+	guc->send = intel_guc_send_nop;
+	guc->handler = intel_guc_to_host_event_handler_nop;
+
+	guc_clear_mmio_msg(guc);
+}
+
+static void guc_disable_communication(struct intel_guc *guc)
+{
+	/*
+	 * Events generated during or after CT disable are logged by guc in
+	 * via mmio. Make sure the register is clear before disabling CT since
+	 * all events we cared about have already been processed via CT.
+	 */
+	guc_clear_mmio_msg(guc);
+
+	guc_disable_interrupts(guc);
+
+	guc->send = intel_guc_send_nop;
+	guc->handler = intel_guc_to_host_event_handler_nop;
+
+	intel_guc_ct_disable(&guc->ct);
+
+	/*
+	 * Check for messages received during/after the CT disable. We do not
+	 * expect any messages to have arrived via CT between the interrupt
+	 * disable and the CT disable because GuC should've been idle until we
+	 * triggered the CT disable protocol.
+	 */
+	guc_get_mmio_msg(guc);
+
+	DRM_INFO("GuC communication disabled\n");
+}
+
+void intel_uc_fetch_firmwares(struct drm_i915_private *i915)
+{
+	if (!USES_GUC(i915))
+		return;
+
+	intel_uc_fw_fetch(i915, &i915->guc.fw);
+
+	if (USES_HUC(i915))
+		intel_uc_fw_fetch(i915, &i915->huc.fw);
+}
+
+void intel_uc_cleanup_firmwares(struct drm_i915_private *i915)
+{
+	if (!USES_GUC(i915))
+		return;
+
+	if (USES_HUC(i915))
+		intel_uc_fw_cleanup_fetch(&i915->huc.fw);
+
+	intel_uc_fw_cleanup_fetch(&i915->guc.fw);
+}
+
+int intel_uc_init(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	struct intel_huc *huc = &i915->huc;
+	int ret;
+
+	if (!USES_GUC(i915))
+		return 0;
+
+	if (!intel_uc_fw_supported(&guc->fw))
+		return -ENODEV;
+
+	/* XXX: GuC submission is unavailable for now */
+	GEM_BUG_ON(USES_GUC_SUBMISSION(i915));
+
+	ret = intel_guc_init(guc);
+	if (ret)
+		return ret;
+
+	if (USES_HUC(i915)) {
+		ret = intel_huc_init(huc);
+		if (ret)
+			goto err_guc;
+	}
+
+	if (USES_GUC_SUBMISSION(i915)) {
+		/*
+		 * This is stuff we need to have available at fw load time
+		 * if we are planning to enable submission later
+		 */
+		ret = intel_guc_submission_init(guc);
+		if (ret)
+			goto err_huc;
+	}
+
+	return 0;
+
+err_huc:
+	if (USES_HUC(i915))
+		intel_huc_fini(huc);
+err_guc:
+	intel_guc_fini(guc);
+	return ret;
+}
+
+void intel_uc_fini(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+
+	if (!USES_GUC(i915))
+		return;
+
+	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
+
+	if (USES_GUC_SUBMISSION(i915))
+		intel_guc_submission_fini(guc);
+
+	if (USES_HUC(i915))
+		intel_huc_fini(&i915->huc);
+
+	intel_guc_fini(guc);
+}
+
+static void __uc_sanitize(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	struct intel_huc *huc = &i915->huc;
+
+	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
+
+	intel_huc_sanitize(huc);
+	intel_guc_sanitize(guc);
+
+	__intel_uc_reset_hw(i915);
+}
+
+void intel_uc_sanitize(struct drm_i915_private *i915)
+{
+	if (!USES_GUC(i915))
+		return;
+
+	__uc_sanitize(i915);
+}
+
+int intel_uc_init_hw(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	struct intel_huc *huc = &i915->huc;
+	int ret, attempts;
+
+	if (!USES_GUC(i915))
+		return 0;
+
+	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
+
+	guc_reset_interrupts(guc);
+
+	/* WaEnableuKernelHeaderValidFix:skl */
+	/* WaEnableGuCBootHashCheckNotSet:skl,bxt,kbl */
+	if (IS_GEN(i915, 9))
+		attempts = 3;
+	else
+		attempts = 1;
+
+	while (attempts--) {
+		/*
+		 * Always reset the GuC just before (re)loading, so
+		 * that the state and timing are fairly predictable
+		 */
+		ret = __intel_uc_reset_hw(i915);
+		if (ret)
+			goto err_out;
+
+		if (USES_HUC(i915)) {
+			ret = intel_huc_fw_upload(huc);
+			if (ret)
+				goto err_out;
+		}
+
+		intel_guc_ads_reset(guc);
+		intel_guc_init_params(guc);
+		ret = intel_guc_fw_upload(guc);
+		if (ret == 0)
+			break;
+
+		DRM_DEBUG_DRIVER("GuC fw load failed: %d; will reset and "
+				 "retry %d more time(s)\n", ret, attempts);
+	}
+
+	/* Did we succeded or run out of retries? */
+	if (ret)
+		goto err_log_capture;
+
+	ret = guc_enable_communication(guc);
+	if (ret)
+		goto err_log_capture;
+
+	if (USES_HUC(i915)) {
+		ret = intel_huc_auth(huc);
+		if (ret)
+			goto err_communication;
+	}
+
+	ret = intel_guc_sample_forcewake(guc);
+	if (ret)
+		goto err_communication;
+
+	if (USES_GUC_SUBMISSION(i915)) {
+		ret = intel_guc_submission_enable(guc);
+		if (ret)
+			goto err_communication;
+	}
+
+	dev_info(i915->drm.dev, "GuC firmware version %u.%u\n",
+		 guc->fw.major_ver_found, guc->fw.minor_ver_found);
+	dev_info(i915->drm.dev, "GuC submission %s\n",
+		 enableddisabled(USES_GUC_SUBMISSION(i915)));
+	dev_info(i915->drm.dev, "HuC %s\n",
+		 enableddisabled(USES_HUC(i915)));
+
+	return 0;
+
+	/*
+	 * We've failed to load the firmware :(
+	 */
+err_communication:
+	guc_disable_communication(guc);
+err_log_capture:
+	guc_capture_load_err_log(guc);
+err_out:
+	__uc_sanitize(i915);
+
+	/*
+	 * Note that there is no fallback as either user explicitly asked for
+	 * the GuC or driver default option was to run with the GuC enabled.
+	 */
+	if (GEM_WARN_ON(ret == -EIO))
+		ret = -EINVAL;
+
+	dev_err(i915->drm.dev, "GuC initialization failed %d\n", ret);
+	return ret;
+}
+
+void intel_uc_fini_hw(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+
+	if (!intel_guc_is_loaded(guc))
+		return;
+
+	GEM_BUG_ON(!intel_uc_fw_supported(&guc->fw));
+
+	if (USES_GUC_SUBMISSION(i915))
+		intel_guc_submission_disable(guc);
+
+	guc_disable_communication(guc);
+	__uc_sanitize(i915);
+}
+
+/**
+ * intel_uc_reset_prepare - Prepare for reset
+ * @i915: device private
+ *
+ * Preparing for full gpu reset.
+ */
+void intel_uc_reset_prepare(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+
+	if (!intel_guc_is_loaded(guc))
+		return;
+
+	guc_stop_communication(guc);
+	__uc_sanitize(i915);
+}
+
+void intel_uc_runtime_suspend(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	int err;
+
+	if (!intel_guc_is_loaded(guc))
+		return;
+
+	err = intel_guc_suspend(guc);
+	if (err)
+		DRM_DEBUG_DRIVER("Failed to suspend GuC, err=%d", err);
+
+	guc_disable_communication(guc);
+}
+
+void intel_uc_suspend(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	intel_wakeref_t wakeref;
+
+	if (!intel_guc_is_loaded(guc))
+		return;
+
+	with_intel_runtime_pm(&i915->runtime_pm, wakeref)
+		intel_uc_runtime_suspend(i915);
+}
+
+int intel_uc_resume(struct drm_i915_private *i915)
+{
+	struct intel_guc *guc = &i915->guc;
+	int err;
+
+	if (!intel_guc_is_loaded(guc))
+		return 0;
+
+	guc_enable_communication(guc);
+
+	err = intel_guc_resume(guc);
+	if (err) {
+		DRM_DEBUG_DRIVER("Failed to resume GuC, err=%d", err);
+		return err;
+	}
+
+	return 0;
+}
