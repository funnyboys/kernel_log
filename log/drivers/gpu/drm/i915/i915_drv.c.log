commit a1fb548962397bb8609bb46e566809a9a1b30044
Merge: 3fd911b69b31 230982d8d8df
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 14 11:33:09 2020 +1000

    Merge tag 'drm-intel-next-2020-04-30' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Driver Changes:
    
    - Fix GitLab #1698: Performance regression with Linux 5.7-rc1 on
      Iris Plus 655 and 4K screen (Chris)
    - Add Wa_14011059788 for Tigerlake (Matt A)
    - Add per ctx batchbuffer wa for timestamp for Gen12 (Mika)
    - Use indirect ctx bb to load cmd buffer control value
      from context image to avoid corruption (Mika)
    - Enable DP Display Audio WA (Uma, Jani)
    - Update forcewake firmware ranges for Icelake (Radhakrishna)
    - Add missing deinitialization cases of load failure for display (Jose)
    - Implement TC cold sequences for Icelake and Tigerlake (Jose)
    - Unbreak enable_dpcd_backlight modparam (Lyude)
    - Move the late flush_submission in retire to the end (Chris)
    - Demote "Reducing compressed framebufer size" message to info (Peter)
    - Push MST link retraining to the hotplug work (Ville)
    - Hold obj->vma.lock over for_each_ggtt_vma() (Chris)
    - Fix timeout handling during TypeC AUX power well enabling for ICL (Imre)
    - Fix skl+ non-scaled pfit modes (Ville)
    - Prefer soft-rc6 over RPS DOWN_TIMEOUT (Chris)
    - Sanitize GT first before poisoning HWSP (Chris)
    - Fix up clock RPS frequency readout (Chris)
    - Avoid reusing the same logical CCID (Chris)
    - Avoid dereferencing a dead context (Chris)
    - Always enable busy-stats for execlists (Chris)
    - Apply the aggressive downclocking to parking (Chris)
    - Restore aggressive post-boost downclocking (Chris)
    
    - Scrub execlists state on resume (Chris)
    - Add debugfs attributes for LPSP (Ansuman)
    - Improvements to kernel selftests (Chris, Mika)
    - Add tiled blits selftest (Zbigniew)
    - Fix error handling in __live_lrc_indirect_ctx_bb() (Dan)
    - Add pre/post plane updates for SAGV (Stanislav)
    - Add ICL PG3 PW ID for EHL (Anshuman)
    - Fix Sphinx build duplicate label warning (Jani)
    - Error log non-zero audio power refcount after unbind (Jani)
    - Remove object_is_locked assertion from unpin_from_display_plane (Chris)
    - Use single set of AUX powerwell ops for gen11+ (Matt R)
    - Prefer drm_WARN_ON over WARN_ON (Pankaj)
    - Poison residual state [HWSP] across resume (Chris, Tvrtko)
    - Convert request-before-CS assertion to debug (Chris)
    - Carefully order virtual_submission_tasklet (Chris)
    - Check carefully for an idle engine in wait-for-idle (Chris)
    - Only close vma we open (Chris)
    - Trace RPS events (Chris)
    - Use the RPM config register to determine clk frequencies (Chris)
    - Drop rq->ring->vma peeking from error capture (Chris)
    - Check preempt-timeout target before submit_ports (Chris)
    - Check HWSP cacheline is valid before acquiring (Chris)
    - Use proper fault mask in interrupt postinstall too (Matt R)
    - Keep a no-frills swappable copy of the default context state (Chris)
    
    - Add atomic helpers for bandwidth (Stanislav)
    - Refactor setting dma info to a common helper from device info (Michael)
    - Refactor DDI transcoder code for clairty (Ville)
    - Extend PG3 power well ID to ICL (Anshuman)
    - Refactor PFIT code for readability and future extensibility (Ville)
    - Clarify code split between intel_ddi.c and intel_dp.c (Ville)
    - Move out code to return the digital_port of the aux ch (Jose)
    - Move rps.enabled/active  and use of RPS interrupts to flags (Chris)
    - Remove superfluous inlines and dead code (Jani)
    - Re-disable -Wframe-address from top-level Makefile (Nick)
    - Static checker and spelling fixes (Colin, Nathan)
    - Split long lines (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200430124904.GA100924@jlahtine-desk.ger.corp.intel.com

commit 3fd911b69b3117e03181262fc19ae6c3ef6962ce
Merge: 370fb6b0aaf0 0ea2ea42b31a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 8 15:16:36 2020 +1000

    Merge tag 'drm-misc-next-2020-05-07' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.8:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
     * MAINTAINERS: restore alphabetical order; update cirrus driver
     * Dcomuentation: document visionix, chronteli, ite vendor prefices; update
                      documentation for Chrontel CH7033, IT6505, IVO, BOE,
                      Panasonic, Chunghwa, AUO bindings; convert dw_mipi_dsi.txt
                      to YAML; remove todo item for drm_display_mode.hsync removal;
    
    Core Changes:
    
     * drm: add devm_drm_dev_alloc() for managed allocations of drm_device;
            use DRM_MODESET_LOCK_ALL_*() in mode-object code; remove
            drm_display_mode.hsync; small cleanups of unused variables,
            compiler warnings and static functions
     * drm/client: dual-lincensing: GPL-2.0 or MIT
     * drm/mm: optimize tree searches in rb_hole_addr()
    
    Driver Changes:
    
     * drm/{many}: use devm_drm_dev_alloc(); don't use drm_device.dev_private
     * drm/ast: don't double-assign to drm_crtc_funcs.set_config; drop
                drm_connector_register()
     * drm/bochs: drop drm_connector_register()
     * drm/bridge: add support for Chrontel ch7033; fix stack usage with
                   old gccs; return error pointer in drm_panel_bridge_add()
     * drm/cirrus: Move to tiny
     * drm/dp_mst: don't use 2nd sideband tx slot; revert "Remove single tx
                   msg restriction"
     * drm/lima: support runtime PM;
     * drm/meson: limit modes wrt chipset
     * drm/panel: add support for Visionox rm69299; fix clock on
                  boe-tv101wum-n16; fix panel type for AUO G101EVN10;
                  add support for Ivo M133NFW4 R0; add support for BOE
                  NV133FHM-N61; add support for AUO G121EAN01.4, G156XTN01.0,
                  G190EAN01
     * drm/pl111: improve vexpress init; fix module auto-loading
     * drm/stm: read number of endpoints from device tree
     * drm/vboxvideo: use managed PCI functions; drop DRM_MTRR_WC
     * drm/vkms: fix use-after-free in vkms_gem_create(); enable cursor
                 support by default
     * fbdev: use boolean values in several drivers
     * fbdev/controlfb: fix COMPILE_TEST
     * fbdev/w100fb: fix double-free bug
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200507072503.GA10979@linux-uq9g

commit 274ed9e9eabd23984ac03a8cebf5ce206c0b60bf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 15 09:40:13 2020 +0200

    drm/i915: Use devm_drm_dev_alloc
    
    Luckily we're already well set up in the main driver, with
    drm_dev_put() being the last thing in both the unload error case and
    the pci remove function.
    
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415074034.175360-39-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2b5f13ca5ec4..43b4146c25f3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -877,19 +877,11 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 		(struct intel_device_info *)ent->driver_data;
 	struct intel_device_info *device_info;
 	struct drm_i915_private *i915;
-	int err;
 
-	i915 = kzalloc(sizeof(*i915), GFP_KERNEL);
-	if (!i915)
-		return ERR_PTR(-ENOMEM);
-
-	err = drm_dev_init(&i915->drm, &driver, &pdev->dev);
-	if (err) {
-		kfree(i915);
-		return ERR_PTR(err);
-	}
-
-	drmm_add_final_kfree(&i915->drm, i915);
+	i915 = devm_drm_dev_alloc(&pdev->dev, &driver,
+				  struct drm_i915_private, drm);
+	if (IS_ERR(i915))
+		return i915;
 
 	i915->drm.pdev = pdev;
 	pci_set_drvdata(pdev, i915);
@@ -1006,7 +998,6 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_disable_device(pdev);
 out_fini:
 	i915_probe_error(i915, "Device initialization failed (%d)\n", ret);
-	drm_dev_put(&i915->drm);
 	return ret;
 }
 

commit 1aa63ddf726ea049279989b93b69b57ce6efd75b
Merge: 774f1eeb18b0 14d0066b8477
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 22 10:40:34 2020 +1000

    Merge tag 'drm-misc-next-2020-04-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.8:
    
    UAPI Changes:
    
      - drm: error out with EBUSY when device has existing master
      - drm: rework SET_MASTER and DROP_MASTER perm handling
    
    Cross-subsystem Changes:
    
      - mm: export two symbols from slub/slob
      - fbdev: savage: fix -Wextra build warning
      - video: omap2: Use scnprintf() for avoiding potential buffer overflow
    
    Core Changes:
    
      - Remove drm_pci.h
      - drm_pci_{alloc/free)() are now legacy
      - Introduce managed DRM resourcesA
      - Allow drivers to subclass struct drm_framebuffer
      - Introduce struct drm_afbc_framebuffer and helpers
      - fbdev: remove return value from generic fbdev setup
      - Introduce simple-encoder helper
      - vram-helpers: set fence on plane
      - dp_mst: ACT timeout improvements
      - dp_mst: Remove drm_dp_mst_has_audio()
      - TTM: ttm_trace_dma_{map/unmap}() cleanups
      - dma-buf: add flag for PCIP2P support
      - EDID: Various improvements
      - Encoder: cleanup semantics of possible_clones and possible_crtcs
      - VBLANK documentation updates
      - Writeback documentation updates
    
    Driver Changes:
    
      - Convert several drivers to i2c_new_client_device()
      - Drop explicit drm_mode_config_cleanup() calls from drivers
      - Auto-release device structures with drmm_add_final_kfree()
      - Init bfdev console after registering DRM device
      - Make various .debugfs functions return 0 unconditionally; ignore errors
      - video: Use scnprintf() to avoid buffer overflows
      - Convert drivers to simple encoders
    
      - drm/amdgpu: note that we can handle peer2peer DMA-buf
      - drm/amdgpu: add support for exporting VRAM using DMA-buf v3
      - drm/kirin: Revert change to register connectors
      - drm/lima: Add optional devfreq and cooling device support
      - drm/lima: Various improvements wrt. task handling
      - drm/panel: nt39016: Support multiple modes and 50Hz
      - drm/panel: Support Leadtek LTK050H3146W
      - drm/rockchip: Add support for afbc
      - drm/virtio: Various cleanups
      - drm/hisilicon/hibmc: Enforce 128-byte stride alignment
      - drm/qxl: Fix notify port address of cursor ring buffer
      - drm/sun4i: Improvements to format handling
      - drm/bridge: dw-hdmi: Various improvements
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200414090738.GA16827@linux-uq9g

commit 31a02eb70b8d9e68c848f2543fa8e745073363e2
Author: Michael J. Ruhl <michael.j.ruhl@intel.com>
Date:   Fri Apr 17 15:51:07 2020 -0400

    drm/i915: Refactor setting dma info to a common helper
    
    DMA_MASK bit values are different for different generations.
    
    This will become more difficult to manage over time with the open
    coded usage of different versions of the device.
    
    Fix by:
      disallow setting of dma mask in AGP path (< GEN(5) for i915,
      add dma_mask_size to the device info configuration,
      updating open code call sequence to the latest interface,
      refactoring into a common function for setting the dma segment
      and mask info
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
    cc: Brian Welty <brian.welty@intel.com>
    cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200417195107.68732-1-michael.j.ruhl@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b5c4cad93a46..c08b165a9cb4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -568,6 +568,62 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
+/**
+ * i915_set_dma_info - set all relevant PCI dma info as configured for the
+ * platform
+ * @i915: valid i915 instance
+ *
+ * Set the dma max segment size, device and coherent masks.  The dma mask set
+ * needs to occur before i915_ggtt_probe_hw.
+ *
+ * A couple of platforms have special needs.  Address them as well.
+ *
+ */
+static int i915_set_dma_info(struct drm_i915_private *i915)
+{
+	struct pci_dev *pdev = i915->drm.pdev;
+	unsigned int mask_size = INTEL_INFO(i915)->dma_mask_size;
+	int ret;
+
+	GEM_BUG_ON(!mask_size);
+
+	/*
+	 * We don't have a max segment size, so set it to the max so sg's
+	 * debugging layer doesn't complain
+	 */
+	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
+
+	ret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(mask_size));
+	if (ret)
+		goto mask_err;
+
+	/* overlay on gen2 is broken and can't address above 1G */
+	if (IS_GEN(i915, 2))
+		mask_size = 30;
+
+	/*
+	 * 965GM sometimes incorrectly writes to hardware status page (HWS)
+	 * using 32bit addressing, overwriting memory if HWS is located
+	 * above 4GB.
+	 *
+	 * The documentation also mentions an issue with undefined
+	 * behaviour if any general state is accessed within a page above 4GB,
+	 * which also needs to be handled carefully.
+	 */
+	if (IS_I965G(i915) || IS_I965GM(i915))
+		mask_size = 32;
+
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(mask_size));
+	if (ret)
+		goto mask_err;
+
+	return 0;
+
+mask_err:
+	drm_err(&i915->drm, "Can't set DMA mask/consistent mask (%d)\n", ret);
+	return ret;
+}
+
 /**
  * i915_driver_hw_probe - setup state requiring device access
  * @dev_priv: device private
@@ -613,6 +669,10 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	/* needs to be done before ggtt probe */
 	intel_dram_edram_detect(dev_priv);
 
+	ret = i915_set_dma_info(dev_priv);
+	if (ret)
+		return ret;
+
 	i915_perf_init(dev_priv);
 
 	ret = i915_ggtt_probe_hw(dev_priv);
@@ -641,40 +701,6 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 
 	pci_set_master(pdev);
 
-	/*
-	 * We don't have a max segment size, so set it to the max so sg's
-	 * debugging layer doesn't complain
-	 */
-	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
-
-	/* overlay on gen2 is broken and can't address above 1G */
-	if (IS_GEN(dev_priv, 2)) {
-		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));
-		if (ret) {
-			drm_err(&dev_priv->drm, "failed to set DMA mask\n");
-
-			goto err_mem_regions;
-		}
-	}
-
-	/* 965GM sometimes incorrectly writes to hardware status page (HWS)
-	 * using 32bit addressing, overwriting memory if HWS is located
-	 * above 4GB.
-	 *
-	 * The documentation also mentions an issue with undefined
-	 * behaviour if any general state is accessed within a page above 4GB,
-	 * which also needs to be handled carefully.
-	 */
-	if (IS_I965G(dev_priv) || IS_I965GM(dev_priv)) {
-		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
-
-		if (ret) {
-			drm_err(&dev_priv->drm, "failed to set DMA mask\n");
-
-			goto err_mem_regions;
-		}
-	}
-
 	cpu_latency_qos_add_request(&dev_priv->pm_qos, PM_QOS_DEFAULT_VALUE);
 
 	intel_gt_init_workarounds(dev_priv);

commit c0ff9e5e69f33ce5051f33cc4cb35afa754de01c
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Thu Apr 16 11:58:41 2020 -0700

    drm/i915: Add missing deinitialization cases of load failure
    
    The intel_display_power_put_async() used in TC cold sequences made
    easy to hit the missing deinitialization of driver in case of load
    failure as seen in the stack trace bellow.
    
    intel_modeset_driver_remove_noirq() had to be removed from
    i915_driver_modeset_remove_noirq() as those are different
    initialialition steps with IRQ and GEM initialization in between then.
    
    [drm:__intel_engine_init_ctx_wa [i915]] Initialized 3 context workarounds on rcs'0
    [drm:__i915_inject_probe_error [i915]] Injecting failure -19 at checkpoint 36 [__uc_init:294]
    [drm:i915_hdcp_component_unbind [i915]] I915 HDCP comp unbind
    [drm:edp_panel_vdd_off_sync [i915]] Turning [ENCODER:275:DDI A] VDD off
    [drm:edp_panel_vdd_off_sync [i915]] PP_STATUS: 0x00000000 PP_CONTROL: 0x00000060
    [drm:intel_power_well_disable [i915]] disabling AUX A
    general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI
    CPU: 3 PID: 1142 Comm: kworker/u16:20 Tainted: G     U            5.6.0-CI-Patchwork_17226+ #1
    Hardware name: Intel Corporation Tiger Lake Client Platform/TigerLake U DDR4 SODIMM RVP, BIOS TGLSFWI1.R00.2457.A16.1912270059 12/27/2019
    Workqueue: events_unbound intel_display_power_put_async_work [i915]
    RIP: 0010:__intel_display_power_put_domain+0xa5/0x180 [i915]
    Code: 48 85 c0 78 54 44 89 e1 41 bd 01 00 00 00 49 c7 c4 80 44 41 a0 49 d3 e5 eb 0d 48 83 eb 10 48 3b 9d 08 ad 00 00 78 32 48 8b 03 <4c> 85 68 10 74 ea 8b 53 08 85 d2 74 2d 83 ea 01 85 d2 89 53 08 75
    RSP: 0018:ffffc9000061fdb0 EFLAGS: 00010206
    RAX: 6b6b6b6b6b6b6b6b RBX: ffff8884948f5df0 RCX: 000000000000003d
    RDX: 0000000080000001 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffff888479be0000 R08: ffff88849a180920 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa0414480
    R13: 2000000000000000 R14: ffff888479beb320 R15: 2000000000000000
    FS:  0000000000000000(0000) GS:ffff88849ff80000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00005634fa8ed670 CR3: 0000000005610004 CR4: 0000000000760ee0
    PKRU: 55555554
    Call Trace:
     release_async_put_domains+0x9b/0x110 [i915]
     intel_display_power_put_async_work+0x91/0xf0 [i915]
     process_one_work+0x260/0x600
     ? worker_thread+0xc9/0x380
     worker_thread+0x37/0x380
     ? process_one_work+0x600/0x600
     kthread+0x119/0x130
     ? kthread_park+0x80/0x80
     ret_from_fork+0x24/0x50
    Modules linked in: i915(+) vgem snd_hda_codec_hdmi mei_hdcp x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul cdc_ether usbnet mii snd_intel_dspcfg ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core e1000e ptp mei_me snd_pcm pps_core mei intel_lpss_pci prime_numbers [last unloaded: i915]
    ---[ end trace b402d1b4060f8b97 ]---
    BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 1142, name: kworker/u16:20
    INFO: lockdep is turned off.
    Preemption disabled at:
    [<0000000000000000>] 0x0
    CPU: 3 PID: 1142 Comm: kworker/u16:20 Tainted: G     UD           5.6.0-CI-Patchwork_17226+ #1
    Hardware name: Intel Corporation Tiger Lake Client Platform/TigerLake U DDR4 SODIMM RVP, BIOS TGLSFWI1.R00.2457.A16.1912270059 12/27/2019
    Workqueue: events_unbound intel_display_power_put_async_work [i915]
    Call Trace:
     dump_stack+0x71/0x9b
     ___might_sleep+0x178/0x260
     wait_for_completion+0x37/0x1a0
     virt_efi_query_variable_info+0x161/0x1b0
     efi_query_variable_store+0xb3/0x1a0
     ? efivar_entry_set_safe+0x19c/0x220
     efivar_entry_set_safe+0x19c/0x220
     ? efi_pstore_write+0x10b/0x150
     ? efi_pstore_write+0xa0/0x150
     efi_pstore_write+0x10b/0x150
     pstore_dump+0x123/0x340
     kmsg_dump+0x87/0x1b0
     oops_end+0x3e/0x90
     do_general_protection+0x1c3/0x2f0
     general_protection+0x2d/0x40
    RIP: 0010:__intel_display_power_put_domain+0xa5/0x180 [i915]
    Code: 48 85 c0 78 54 44 89 e1 41 bd 01 00 00 00 49 c7 c4 80 44 41 a0 49 d3 e5 eb 0d 48 83 eb 10 48 3b 9d 08 ad 00 00 78 32 48 8b 03 <4c> 85 68 10 74 ea 8b 53 08 85 d2 74 2d 83 ea 01 85 d2 89 53 08 75
    RSP: 0018:ffffc9000061fdb0 EFLAGS: 00010206
    RAX: 6b6b6b6b6b6b6b6b RBX: ffff8884948f5df0 RCX: 000000000000003d
    RDX: 0000000080000001 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffff888479be0000 R08: ffff88849a180920 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa0414480
    R13: 2000000000000000 R14: ffff888479beb320 R15: 2000000000000000
     release_async_put_domains+0x9b/0x110 [i915]
     intel_display_power_put_async_work+0x91/0xf0 [i915]
     process_one_work+0x260/0x600
     ? worker_thread+0xc9/0x380
     worker_thread+0x37/0x380
     ? process_one_work+0x600/0x600
     kthread+0x119/0x130
     ? kthread_park+0x80/0x80
     ret_from_fork+0x24/0x50
    ------------[ cut here ]------------
    WARNING: CPU: 3 PID: 1142 at kernel/rcu/tree_plugin.h:293 rcu_note_context_switch+0x87/0x650
    Modules linked in: i915(+) vgem snd_hda_codec_hdmi mei_hdcp x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul cdc_ether usbnet mii snd_intel_dspcfg ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core e1000e ptp mei_me snd_pcm pps_core mei intel_lpss_pci prime_numbers [last unloaded: i915]
    
    v2:
    - fixed handling in case of failure in drm_vblank_init()
    - moved i915_gem_driver_remove() call to before
    i915_driver_modeset_remove_noirq() this match initialization order too
    
    v3:
    - reverting call swap between i915_reset_error_state() and i915_gem_driver_remove()
    call order
    - improved label naming in i915_driver_modeset_probe_noirq()
    
    Closes: https://gitlab.freedesktop.org/drm/intel/issues/1647
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200416185841.125686-1-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9ab4ad7ccac9..b5c4cad93a46 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -227,14 +227,14 @@ static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
 		ret = drm_vblank_init(&i915->drm,
 				      INTEL_NUM_PIPES(i915));
 		if (ret)
-			goto out;
+			return ret;
 	}
 
 	intel_bios_init(i915);
 
 	ret = intel_vga_register(i915);
 	if (ret)
-		goto out;
+		goto cleanup_bios;
 
 	intel_power_domains_init_hw(i915, false);
 
@@ -242,13 +242,16 @@ static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
 
 	ret = intel_modeset_init_noirq(i915);
 	if (ret)
-		goto cleanup_vga_client;
+		goto cleanup_vga_client_pw_domain_csr;
 
 	return 0;
 
-cleanup_vga_client:
+cleanup_vga_client_pw_domain_csr:
+	intel_csr_ucode_fini(i915);
+	intel_power_domains_driver_remove(i915);
 	intel_vga_unregister(i915);
-out:
+cleanup_bios:
+	intel_bios_driver_remove(i915);
 	return ret;
 }
 
@@ -307,13 +310,13 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 /* part #2: call after irq uninstall */
 static void i915_driver_modeset_remove_noirq(struct drm_i915_private *i915)
 {
-	intel_modeset_driver_remove_noirq(i915);
+	intel_csr_ucode_fini(i915);
 
-	intel_bios_driver_remove(i915);
+	intel_power_domains_driver_remove(i915);
 
 	intel_vga_unregister(i915);
 
-	intel_csr_ucode_fini(i915);
+	intel_bios_driver_remove(i915);
 }
 
 static void intel_init_dpio(struct drm_i915_private *dev_priv)
@@ -998,7 +1001,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_cleanup_irq:
 	intel_irq_uninstall(i915);
 out_cleanup_modeset:
-	/* FIXME */
+	i915_driver_modeset_remove_noirq(i915);
 out_cleanup_hw:
 	i915_driver_hw_remove(i915);
 	intel_memory_regions_driver_release(i915);
@@ -1035,12 +1038,12 @@ void i915_driver_remove(struct drm_i915_private *i915)
 
 	intel_irq_uninstall(i915);
 
-	i915_driver_modeset_remove_noirq(i915);
+	intel_modeset_driver_remove_noirq(i915);
 
 	i915_reset_error_state(i915);
 	i915_gem_driver_remove(i915);
 
-	intel_power_domains_driver_remove(i915);
+	i915_driver_modeset_remove_noirq(i915);
 
 	i915_driver_hw_remove(i915);
 

commit 08d99b2c23dfa84ca5b5e5c194062a0550888b71
Merge: 13e3d94110d8 8f3d9f354286
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Fri Apr 17 08:12:22 2020 +0200

    Merge drm/drm-next into drm-misc-next
    
    Backmerging required to pull topic/phy-compliance.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>

commit 2b703bbda2713fd2a7d98029ea6c44f9c3159f34
Merge: 3ffaf56e912e 8f3d9f354286
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 16 14:35:16 2020 +0300

    Merge drm/drm-next into drm-intel-next-queued
    
    Backmerging in order to pull "topic/phy-compliance".
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit f365ab31efacb70bed1e821f7435626e0b2528a6
Merge: 4646de87d325 59e7a8cc2dcf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 1 15:24:20 2020 -0700

    Merge tag 'drm-next-2020-04-01' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for 5.7-rc1.
    
      Highlights:
    
       - i915 enables Tigerlake by default
    
       - i915 and amdgpu have initial OLED backlight support
    
         [ Jani Nikula pipes up and points out that we've had a bunch of
           "initial support" code for a long time already, but only now
           Lyude made it actually work on real world machines ]
    
       - vmwgfx add support to enable OpenGL 4 userspace
    
       - zero length arrays are mostly removed.
    
      Detailed summary:
    
      new driver:
       - tidss: TI Keystone platform display subsystem
    
      core:
       - new drm device warn macros
       - mode config valid for memory constrained devices
       - bridge bus format negotation
       - consolidated fake vblank event handling
       - dma_alloc related cleanups
       - drop get_crtc callback
       - dp: DP1.4 EDID corruption test
       - EDID CEA detailed timings improvements
       - relicense some code to dual GPL2/MIT
       - convert core vblank support to per-crtc support
       - rework drm_global_mutex
       - bridge rework to allow omap_dss custom driver removeal
       - remove drm_fb_helper connector interrfaces
       - zero-length array removal
    
      scheduler:
       - support for modifying the sched list
       - revert job distribution optimization
       - helper to pick least loaded scheduler
       - race condition fix
    
      mst:
       - various fixes
       - remove register_connector callback
    
      i915:
       - uapi to allows userspace specific CS ring buffer sizes
       - Tigerlake enablement patches + Tigerlake enabled by default
       - new sysfs entries for engine properties
       - display/logging refactors
       - eDP/DP fixes for DPCD
       - Gen7 back to aliasing-ppgtt
       - Gen8+ irq refactor
       - Avoid globals
       - GEM locking fixes and simplifications
       - Ice Lake and Elkhart Lake fixes and workarounds
       - Baytrail/Haswell instability fix
       - GVT - VFIO edid better support
    
      amdgpu:
       - Rework VM update handling in preparation for HMM support
       - drm load/unload removal fixups
       - USB-C PD firmware updates
       - HDCP srm support
       - Navi/renoir PM watermark fixes
       - OLED panel support
       - Optimize debugging vram access
       - Use BACO for runtime pm
       - DC clock programming optimizations and fixes
       - PSP fw loading sequence updates
       - Drop DRIVER_USE_AGP
       - Remove legacy drm load and unload callbacks
       - ACP Kconfig fix
       - Lots of fixes across the driver
    
      amdkfd:
       - runtime pm support
       - more gfx config details in amdgpu
    
      radeon:
       - drop DRIVER_USE_AGP
    
      vmwgfx:
       - Disable DMA when SEV encryption in use
       - Shader Model 5 support - needed for GL4 support
    
      msm:
       - DPU resource manager refactor
       - dpu using atomic global state
    
      mediatek:
       - MT8183 DPI support
    
      etnaviv:
       - out-of-bounds read fix
       - expose feature flags for GC400 STM32MP1 SoC
       - runtime suspend entry fix
       - dma32 zone fix
    
      hisilicon:
       - mode selection fixes
    
      meson:
       - YUV420 support
    
      lima:
       - add support for heap buffers
    
      tinydrm:
       - removal of owner field
       - explicit DT dependency removal
       - YAML schema conversion
    
      tegra:
       - misc cleanups
    
      tidss:
       - new driver
    
      virtio:
       - better batching of notifications to host
       - memory handling reworked
       - shmem + gpu context fixes
    
      hibmc:
       - add gamma_set support
       - improve DPMS support
    
      pl111:
       - Integrator IM-PD1 support
    
      sun4i:
       - LVDS support for A20 + A33
       - DSI panel handling improvements"
    
    * tag 'drm-next-2020-04-01' of git://anongit.freedesktop.org/drm/drm: (1537 commits)
      drm/i915/display: Fix mode private_flags comparison at atomic_check
      drm/i915/gt: Stage the transfer of the virtual breadcrumb
      drm/i915/gt: Select the deepest available parking mode for rc6
      drm/i915: Avoid live-lock with i915_vma_parked()
      drm/i915/gt: Treat idling as a RPS downclock event
      drm/i915/gt: Cancel a hung context if already closed
      drm/i915: Use explicit flag to mark unreachable intel_context
      drm/amdgpu: don't try to reserve training bo for sriov (v2)
      drm/amdgpu/smu11: add support for SMU AC/DC interrupts
      drm/amdgpu/swSMU: handle manual AC/DC notifications
      drm/amdgpu/swSMU: handle DC controlled by GPIO for navi1x
      drm/amdgpu/swSMU: set AC/DC mode based on the current system state (v2)
      drm/amdgpu/swSMU: correct the bootup power source for Navi1X (v2)
      drm/amdgpu/swSMU: use the smu11 power source helper for navi1x
      drm/amdgpu/smu11: add a helper to set the power source
      drm/amd/swSMU: add callback to set AC/DC power source (v2)
      drm/scheduler: fix rare NULL ptr race
      drm/amdgpu: fix the coverage issue to clear ArcVPGRs
      drm/amd/display: Fix pageflip event race condition for DCN.
      drm/[radeon|amdgpu]: Remove HAINAN board from max_sclk override check
      ...

commit 8f1073ed8c18353ff2263294b243a315a71e9d48
Merge: 2f6bdb05e0b6 a534e924c58d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 30 14:45:57 2020 +0200

    Merge branch 'pm-qos'
    
    * pm-qos: (30 commits)
      PM: QoS: annotate data races in pm_qos_*_value()
      Documentation: power: fix pm_qos_interface.rst format warning
      PM: QoS: Make CPU latency QoS depend on CONFIG_CPU_IDLE
      Documentation: PM: QoS: Update to reflect previous code changes
      PM: QoS: Update file information comments
      PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY and rename related functions
      sound: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: usb: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: tty: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: spi: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: net: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: mmc: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: media: Call cpu_latency_qos_*() instead of pm_qos_*()
      drivers: hsi: Call cpu_latency_qos_*() instead of pm_qos_*()
      drm: i915: Call cpu_latency_qos_*() instead of pm_qos_*()
      x86: platform: iosf_mbi: Call cpu_latency_qos_*() instead of pm_qos_*()
      cpuidle: Call cpu_latency_qos_limit() instead of pm_qos_request()
      PM: QoS: Add CPU latency QoS API wrappers
      PM: QoS: Adjust pm_qos_request() signature and reorder pm_qos.h
      PM: QoS: Simplify definitions of CPU latency QoS trace events
      ...

commit d33b58d0115e7eee011fddee2d8e25c6a09fb279
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:24 2020 +0100

    drm: Garbage collect drm_dev_fini
    
    It has become empty. Given the few users I figured not much point
    splitting this up.
    
    v2: Rebase over i915 changes.
    
    v3: Rebase over patch split fix.
    
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-26-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 84624cad7089..6116dab3d059 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -906,11 +906,6 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return i915;
 }
 
-static void i915_driver_destroy(struct drm_i915_private *i915)
-{
-	drm_dev_fini(&i915->drm);
-}
-
 /**
  * i915_driver_probe - setup chip and create an initial config
  * @pdev: PCI device
@@ -1013,7 +1008,6 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_disable_device(pdev);
 out_fini:
 	i915_probe_error(i915, "Device initialization failed (%d)\n", ret);
-	i915_driver_destroy(i915);
 	drm_dev_put(&i915->drm);
 	return ret;
 }
@@ -1070,7 +1064,6 @@ static void i915_driver_release(struct drm_device *dev)
 	intel_runtime_pm_driver_release(rpm);
 
 	i915_driver_late_release(dev_priv);
-	i915_driver_destroy(dev_priv);
 }
 
 static int i915_driver_open(struct drm_device *dev, struct drm_file *file)

commit 7fb81e9d80738ee2673990f6be1e55494d5ea014
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:07 2020 +0100

    drm/i915: Use drmm_add_final_kfree
    
    With this we can drop the final kfree from the release function.
    
    The mock device in the selftests needed it's pci_device split
    up from the drm_device. In the future we could simplify this again
    by allocating the pci_device as a managed allocation too.
    
    v2: I overlooked that i915_driver_destroy is also called in the
    unwind code of the error path. There we need a drm_dev_put.
    Similar for the mock object.
    
    Now the problem with that is that the drm_driver->release callbacks
    for both the real driver and the mock one assume everything has been
    set up. Hence going through that path for a partially set up driver
    will result in issues. Quickest fix is to disable the ->release() hook
    until the driver is fully initialized, and keep the onion unwinding.
    Long term would be cleanest to move everything over to drmm_ release
    actions, but that's a lot of work for a big driver like i915. Plus
    more core work needed first anyway.
    
    v3: Fix i915_drm pointer wrangling in mock_gem_device. Also switch
    over to start using drm_dev_put() to clean up even on the error path.
    Aside I think the current error path is leaking the allocation.
    
    v4: more fixes for intel-gfx-ci, some if it damage from v3 :-/
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-9-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a7aaace22912..84624cad7089 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -43,6 +43,7 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_ioctl.h>
 #include <drm/drm_irq.h>
+#include <drm/drm_managed.h>
 #include <drm/drm_probe_helper.h>
 
 #include "display/intel_acpi.h"
@@ -890,6 +891,8 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return ERR_PTR(err);
 	}
 
+	drmm_add_final_kfree(&i915->drm, i915);
+
 	i915->drm.pdev = pdev;
 	pci_set_drvdata(pdev, i915);
 
@@ -906,7 +909,6 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 static void i915_driver_destroy(struct drm_i915_private *i915)
 {
 	drm_dev_fini(&i915->drm);
-	kfree(i915);
 }
 
 /**
@@ -990,6 +992,8 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	i915_welcome_messages(i915);
 
+	i915->do_release = true;
+
 	return 0;
 
 out_cleanup_irq:
@@ -1010,6 +1014,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_fini:
 	i915_probe_error(i915, "Device initialization failed (%d)\n", ret);
 	i915_driver_destroy(i915);
+	drm_dev_put(&i915->drm);
 	return ret;
 }
 
@@ -1049,6 +1054,9 @@ static void i915_driver_release(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 
+	if (!dev_priv->do_release)
+		return;
+
 	disable_rpm_wakeref_asserts(rpm);
 
 	i915_gem_driver_release(dev_priv);

commit c1b164a5f7ab932699923f58c95767bfc6921d91
Merge: 873863b6214a c2556238120b
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Mar 26 15:11:04 2020 +0100

    Merge remote-tracking branch 'drm/drm-next' into drm-misc-next
    
    Requested for getting some i915 fixes back into drm-misc-next by danvet.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

commit 0ce542f7317117a02d65183e047a09911fa08afe
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:01 2020 +0100

    drm/i915: Don't clear drvdata in ->release
    
    For two reasons:
    
    - The driver core clears this already for us after we're unloaded in
      __device_release_driver().
    
    - It's way too late, the drm_device ->release callback might massively
      outlive the underlying physical device, since a drm_device can be
      kept alive by open drm_file or well really anything else userspace
      is still hanging onto. So if we clear this ourselves, we should
      clear it in the pci ->remove callback, not in the drm_device
      ->release callback.
    
    Looking at git history this was fixed in the driver core with
    
    commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    Author: Hans de Goede <hdegoede@redhat.com>
    Date:   Wed May 23 00:09:34 2012 +0200
    
        device-core: Ensure drvdata = NULL when no driver is bound
    
    v2: Cite the core fix in the commit message (Chris).
    
    v3: Fix commit message and unused variable warning (Jani).
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dba5fe1391e8..1ab1de7961b8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1392,13 +1392,8 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 static void i915_driver_destroy(struct drm_i915_private *i915)
 {
-	struct pci_dev *pdev = i915->drm.pdev;
-
 	drm_dev_fini(&i915->drm);
 	kfree(i915);
-
-	/* And make sure we never chase our dangling pointer from pci_dev */
-	pci_set_drvdata(pdev, NULL);
 }
 
 /**

commit 9001b17698d86f842e2b13e0cafe8021d43209e9
Merge: bda1fb0ed000 217a485c8399
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 19 10:39:27 2020 +1000

    Merge tag 'drm-intel-next-2020-03-13' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    UAPI Changes:
    
    On i915 we have a new UAPI to allow userspace to specify CS ring buffer size on
    construction (I915_CONTEXT_PARAM_RINGSIZE) and also new sysfs entries exposing
    various engine properties
    
    GVT Changes:
    
    VFIO edid getting expanded to all platforms and a big cleanup around attr
    group, unused vblank complete, kvmgt, Intel engine and dev_priv usages.
    
    i915 Changes:
    
    - new UAPI to allow userspace to specify CS ring buffer size on construction
      (I915_CONTEXT_PARAM_RINGSIZE) -  (Chris)
    - New sysfs entries exposing various engine properties (Chris)
    - Tiger Lake is out of require_force_probe protection (Jose)
    - Changes in many places around active requests, reset and heartbeat (Chris)
    - Stop assigning drm-dev_private pointer (Jani)
    - Many code refactor in many places, including intel_modeset_init,
      increasing use of intel_uncore_*, vgpu, and gvt stuff (Jani)
    - Fixes around display pipe iterators (Anshuman)
    - Tigerlake enabling work (Matt Ropper, Matt Atwood, Ville, Lucas, Daniele,
      Jose, Anusha, Vivek, Swathi, Caz. Kai)
    - Code clean-up like reducing use of drm/i915_drv.h, removing unused
      registers, removing garbage warns, and some other code polishing (Jani, Lucas,
      Ville)
    - Selftests fixes, improvements and additions (Chris, Dan, Aditya, Matt Auld)
    - Fix plane possible_crtcs bit mask (Anshuman)
    - Fixes and cleanup on GLK pre production identification and w/a (Ville)
    - Fix display orientation on few cases (Hans, Ville)
    - dbuf clean-up and improvements for slice arrays handling (Ville)
    - Improvement around min cdclk calculation (Stanislav)
    - Fixes and refactor around display PLLs (Imre)
    - Other execlists and perf fixes (Chris)
    - Documentation fixes (Jani, Chris)
    - Fix build issue (Anshuman)
    - Many more fixes around the locking mechanisms (Chris)
    - Other fixes and debugability info around preemption (Chris, Tvrtko)
    - Add mechanism to submit a context WA on ring submission (Mika)
    - Clear all Eu/L3 resitual context (Prathap)
    - More changes around local memory (Abdiel, Matt, Chris)
    - Fix RPS (Chris)
    - DP MST fix (Lyude)
    - Display FBC fixes (Jose, RK)
    - debugfs cleanup (Tvrtko)
    - More convertion towards drm_debive based loggin (Wambui, Ram)
    - Avoid potential buffer overflow (Takashi)
    - Ice Lake and Elkhart Lake workarounds (Matt Roper)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200314001535.GA2969344@intel.com

commit dec9cf9ee8cb203d556bec3f650c480ba2a04735
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 16 11:38:44 2020 +0000

    drm/i915/gt: Pull restoration of GGTT fences underneath the GT
    
    Make the GT responsible for restoring its fence when it wakes up from
    suspend.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200316113846.4974-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9327d56dba5a..265a9df153c8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1288,7 +1288,6 @@ static int i915_drm_resume(struct drm_device *dev)
 		drm_err(&dev_priv->drm, "failed to re-enable GGTT\n");
 
 	i915_ggtt_resume(&dev_priv->ggtt);
-	intel_ggtt_restore_fences(&dev_priv->ggtt);
 
 	intel_csr_ucode_resume(dev_priv);
 
@@ -1606,8 +1605,6 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_gt_runtime_resume(&dev_priv->gt);
 
-		intel_ggtt_restore_fences(&dev_priv->ggtt);
-
 		enable_rpm_wakeref_asserts(rpm);
 
 		return ret;
@@ -1687,7 +1684,6 @@ static int intel_runtime_resume(struct device *kdev)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	intel_gt_runtime_resume(&dev_priv->gt);
-	intel_ggtt_restore_fences(&dev_priv->ggtt);
 
 	/*
 	 * On VLV/CHV display interrupts are part of the display

commit f899f786d181e03f6ca29319bd90ba62231cb44b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 16 11:38:43 2020 +0000

    drm/i915: Move GGTT fence registers under gt/
    
    Since the fence registers control HW detiling through the GGTT
    aperture, make them a part of the intel_ggtt under gt/
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200316113846.4974-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 480f756bdadc..9327d56dba5a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1288,7 +1288,7 @@ static int i915_drm_resume(struct drm_device *dev)
 		drm_err(&dev_priv->drm, "failed to re-enable GGTT\n");
 
 	i915_ggtt_resume(&dev_priv->ggtt);
-	i915_gem_restore_fences(&dev_priv->ggtt);
+	intel_ggtt_restore_fences(&dev_priv->ggtt);
 
 	intel_csr_ucode_resume(dev_priv);
 
@@ -1606,7 +1606,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_gt_runtime_resume(&dev_priv->gt);
 
-		i915_gem_restore_fences(&dev_priv->ggtt);
+		intel_ggtt_restore_fences(&dev_priv->ggtt);
 
 		enable_rpm_wakeref_asserts(rpm);
 
@@ -1687,7 +1687,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	intel_gt_runtime_resume(&dev_priv->gt);
-	i915_gem_restore_fences(&dev_priv->ggtt);
+	intel_ggtt_restore_fences(&dev_priv->ggtt);
 
 	/*
 	 * On VLV/CHV display interrupts are part of the display

commit 6e482b96b387d717302b6d281120121bf93b1936
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 16:44:08 2020 +0200

    drm/i915/gvt: only include intel_gvt.h where needed
    
    i915_drv.c is the only caller.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227144408.24345-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d05801c59566..480f756bdadc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -81,6 +81,7 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_dram.h"
+#include "intel_gvt.h"
 #include "intel_memory_region.h"
 #include "intel_pm.h"
 #include "vlv_suspend.h"

commit 9e859eb9d0f5e3ca553b53c4de149f0988814ad7
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 16:44:06 2020 +0200

    drm/i915/vgpu: improve vgpu abstractions
    
    Add intel_vgpu_register() abstraction, rename i915_detect_vgpu() to
    intel_vgpu_detect() to match other function naming, un-inline
    intel_vgpu_active(), intel_vgpu_has_full_ppgtt() and
    intel_vgpu_has_huge_gtt() to reduce header interdependencies.
    
    The i915_vgpu.[ch] filename and intel_vgpu_ prefix discrepancy remains.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227144408.24345-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 068a449a343c..d05801c59566 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -759,13 +759,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	i915_gem_driver_register(dev_priv);
 	i915_pmu_register(dev_priv);
 
-	/*
-	 * Notify a valid surface after modesetting,
-	 * when running inside a VM.
-	 */
-	if (intel_vgpu_active(dev_priv))
-		intel_uncore_write(&dev_priv->uncore, vgtif_reg(display_ready),
-				   VGT_DRV_DISPLAY_READY);
+	intel_vgpu_register(dev_priv);
 
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
@@ -972,7 +966,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	disable_rpm_wakeref_asserts(&i915->runtime_pm);
 
-	i915_detect_vgpu(i915);
+	intel_vgpu_detect(i915);
 
 	ret = i915_driver_mmio_probe(i915);
 	if (ret < 0)

commit 062705be45c8de79aee54620e5facc402eeee43a
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 19:00:45 2020 +0200

    drm/i915: add i915_ioc32.h for compat
    
    Keep reducing i915_drv.h.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227170047.31089-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77a2cec4ec5d..068a449a343c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -70,6 +70,7 @@
 
 #include "i915_debugfs.h"
 #include "i915_drv.h"
+#include "i915_ioc32.h"
 #include "i915_irq.h"
 #include "i915_memcpy.h"
 #include "i915_perf.h"
@@ -1762,7 +1763,7 @@ static const struct file_operations i915_driver_fops = {
 	.mmap = i915_gem_mmap,
 	.poll = drm_poll,
 	.read = drm_read,
-	.compat_ioctl = i915_compat_ioctl,
+	.compat_ioctl = i915_ioc32_compat_ioctl,
 	.llseek = noop_llseek,
 };
 

commit 00535527350c1ab139ae31e0128d936d44b11004
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 18:12:53 2020 +0200

    drm/i915/crc: move pipe_crc from drm_i915_private to intel_crtc
    
    Having an array pipe_crc[I915_MAX_PIPES] in struct drm_i915_private
    should be an obvious clue this should be located in struct intel_crtc
    instead. Make it so.
    
    As a side-effect, fix some errors in indexing pipe_crc with both pipe
    and crtc index. And, of course, reduce the size of i915_drv.h.
    
    Cc: Anshuman Gupta <anshuman.gupta@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227161253.15741-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f26021f26ef5..77a2cec4ec5d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -466,7 +466,6 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);
-	intel_display_crc_init(dev_priv);
 
 	intel_detect_preproduction_hw(dev_priv);
 

commit 33e059a2e4df454359f642f2235af39de9d3e914
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Thu Feb 27 12:55:40 2020 -0800

    drm/i915/psr: Force PSR probe only after full initialization
    
    Commit 60c6a14b489b ("drm/i915/display: Force the state compute phase
    once to enable PSR") was forcing the state compute too earlier
    causing errors because not everything was initialized, so here
    moving to the end of i915_driver_modeset_probe() when the display is
    all initialized.
    
    Also fixing the place where it disarm the force probe as during the
    atomic check phase errors could happen like the ones due locking and
    it would cause PSR to never be enabled if that happens.
    Leaving the disarm to the atomic commit phase, intel_psr_enable() or
    intel_psr_update() will be called even if the current state do not
    allow PSR to be enabled.
    
    v2: Check if intel_dp is null in intel_psr_force_mode_changed_set()
    v3: Check intel_dp before get dev_priv
    v4:
    - renamed intel_psr_force_mode_changed_set() to
    intel_psr_set_force_mode_changed()
    - removed the set parameter from intel_psr_set_force_mode_changed()
    - not calling intel_psr_set_force_mode_changed() from
    intel_psr_enable/update(), directly setting it after the same checks
    that intel_psr_set_force_mode_changed() does
    - moved intel_psr_set_force_mode_changed() arm call to
    i915_driver_modeset_probe() as it is a better for a PSR call, all the
    functions calls happening between the old and the new function call
    will cause issue
    
    [backported to v5.6-rc3]
    
    Fixes: 60c6a14b489b ("drm/i915/display: Force the state compute phase once to enable PSR")
    Closes: https://gitlab.freedesktop.org/drm/intel/issues/1151
    Tested-by: Ross Zwisler <zwisler@google.com>
    Reported-by: Ross Zwisler <zwisler@google.com>
    Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Anshuman Gupta <anshuman.gupta@intel.com>
    Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200221212635.11614-1-jose.souza@intel.com
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227205540.126135-1-jose.souza@intel.com
    (cherry picked from commit df1a5bfc16f3275a74f77d73375e69bc62c45c4b)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f7385abdd74b..8410330ce4f0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -56,6 +56,7 @@
 #include "display/intel_hotplug.h"
 #include "display/intel_overlay.h"
 #include "display/intel_pipe_crc.h"
+#include "display/intel_psr.h"
 #include "display/intel_sprite.h"
 #include "display/intel_vga.h"
 
@@ -330,6 +331,8 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	intel_init_ipc(i915);
 
+	intel_psr_set_force_mode_changed(i915->psr.dp);
+
 	return 0;
 
 cleanup_gem:

commit 834c6bb7ae4cc4307608abc00c85b21c90ec5fcc
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 28 17:51:52 2020 +0200

    drm/i915: Add glk to intel_detect_preproduction_hw()
    
    Detect GLK pre-production steppings. Not 100% of A2 being pre-prod
    since the spec is a bit of a mess but feels more or less correct.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200128155152.21977-4-ville.syrjala@linux.intel.com
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3f5946e8c5f2..f26021f26ef5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -387,6 +387,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	pre |= IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0);
 	pre |= IS_BXT_REVID(dev_priv, 0, BXT_REVID_B_LAST);
 	pre |= IS_KBL_REVID(dev_priv, 0, KBL_REVID_A0);
+	pre |= IS_GLK_REVID(dev_priv, 0, GLK_REVID_A2);
 
 	if (pre) {
 		drm_err(&dev_priv->drm, "This is a pre-production stepping. "

commit dd91ddcdd507d2964b3203886ca5d16a6fcced7e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 25 13:15:09 2020 +0200

    drm/i915/drv: use intel_uncore_write() for register access
    
    The implicit "dev_priv" local variable use has been a long-standing pain
    point in the register access macros I915_READ(), I915_WRITE(),
    POSTING_READ(), I915_READ_FW(), and I915_WRITE_FW().
    
    Replace the sole remaining I915_WRITE() in i915_drv.c with
    intel_uncore_write(), although it might be better to keep the entire
    file void of direct register access.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225111509.21879-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4e1fcee1d0f0..3f5946e8c5f2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -763,7 +763,8 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 * when running inside a VM.
 	 */
 	if (intel_vgpu_active(dev_priv))
-		I915_WRITE(vgtif_reg(display_ready), VGT_DRV_DISPLAY_READY);
+		intel_uncore_write(&dev_priv->uncore, vgtif_reg(display_ready),
+				   VGT_DRV_DISPLAY_READY);
 
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {

commit d28ae3b28187fd50a8eabe4befca71ec9ced9a5c
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 25 13:15:07 2020 +0200

    drm/i915: split out intel_dram.[ch] from i915_drv.c
    
    The DRAM related routines are pretty isolated from the rest of the
    i915_drv.c, split it out to a separate file. Put the eDRAM stuff in the
    same bag, and rename the visible functions to have intel_dram_
    prefix. Do some benign whitespace fixes and dev_priv -> i915 conversions
    while at it.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225111509.21879-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 76f4a269edd6..4e1fcee1d0f0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -79,6 +79,7 @@
 #include "i915_sysfs.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
+#include "intel_dram.h"
 #include "intel_memory_region.h"
 #include "intel_pm.h"
 #include "vlv_suspend.h"
@@ -563,494 +564,6 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
-#define DRAM_TYPE_STR(type) [INTEL_DRAM_ ## type] = #type
-
-static const char *intel_dram_type_str(enum intel_dram_type type)
-{
-	static const char * const str[] = {
-		DRAM_TYPE_STR(UNKNOWN),
-		DRAM_TYPE_STR(DDR3),
-		DRAM_TYPE_STR(DDR4),
-		DRAM_TYPE_STR(LPDDR3),
-		DRAM_TYPE_STR(LPDDR4),
-	};
-
-	if (type >= ARRAY_SIZE(str))
-		type = INTEL_DRAM_UNKNOWN;
-
-	return str[type];
-}
-
-#undef DRAM_TYPE_STR
-
-static int intel_dimm_num_devices(const struct dram_dimm_info *dimm)
-{
-	return dimm->ranks * 64 / (dimm->width ?: 1);
-}
-
-/* Returns total GB for the whole DIMM */
-static int skl_get_dimm_size(u16 val)
-{
-	return val & SKL_DRAM_SIZE_MASK;
-}
-
-static int skl_get_dimm_width(u16 val)
-{
-	if (skl_get_dimm_size(val) == 0)
-		return 0;
-
-	switch (val & SKL_DRAM_WIDTH_MASK) {
-	case SKL_DRAM_WIDTH_X8:
-	case SKL_DRAM_WIDTH_X16:
-	case SKL_DRAM_WIDTH_X32:
-		val = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
-		return 8 << val;
-	default:
-		MISSING_CASE(val);
-		return 0;
-	}
-}
-
-static int skl_get_dimm_ranks(u16 val)
-{
-	if (skl_get_dimm_size(val) == 0)
-		return 0;
-
-	val = (val & SKL_DRAM_RANK_MASK) >> SKL_DRAM_RANK_SHIFT;
-
-	return val + 1;
-}
-
-/* Returns total GB for the whole DIMM */
-static int cnl_get_dimm_size(u16 val)
-{
-	return (val & CNL_DRAM_SIZE_MASK) / 2;
-}
-
-static int cnl_get_dimm_width(u16 val)
-{
-	if (cnl_get_dimm_size(val) == 0)
-		return 0;
-
-	switch (val & CNL_DRAM_WIDTH_MASK) {
-	case CNL_DRAM_WIDTH_X8:
-	case CNL_DRAM_WIDTH_X16:
-	case CNL_DRAM_WIDTH_X32:
-		val = (val & CNL_DRAM_WIDTH_MASK) >> CNL_DRAM_WIDTH_SHIFT;
-		return 8 << val;
-	default:
-		MISSING_CASE(val);
-		return 0;
-	}
-}
-
-static int cnl_get_dimm_ranks(u16 val)
-{
-	if (cnl_get_dimm_size(val) == 0)
-		return 0;
-
-	val = (val & CNL_DRAM_RANK_MASK) >> CNL_DRAM_RANK_SHIFT;
-
-	return val + 1;
-}
-
-static bool
-skl_is_16gb_dimm(const struct dram_dimm_info *dimm)
-{
-	/* Convert total GB to Gb per DRAM device */
-	return 8 * dimm->size / (intel_dimm_num_devices(dimm) ?: 1) == 16;
-}
-
-static void
-skl_dram_get_dimm_info(struct drm_i915_private *dev_priv,
-		       struct dram_dimm_info *dimm,
-		       int channel, char dimm_name, u16 val)
-{
-	if (INTEL_GEN(dev_priv) >= 10) {
-		dimm->size = cnl_get_dimm_size(val);
-		dimm->width = cnl_get_dimm_width(val);
-		dimm->ranks = cnl_get_dimm_ranks(val);
-	} else {
-		dimm->size = skl_get_dimm_size(val);
-		dimm->width = skl_get_dimm_width(val);
-		dimm->ranks = skl_get_dimm_ranks(val);
-	}
-
-	drm_dbg_kms(&dev_priv->drm,
-		    "CH%u DIMM %c size: %u GB, width: X%u, ranks: %u, 16Gb DIMMs: %s\n",
-		    channel, dimm_name, dimm->size, dimm->width, dimm->ranks,
-		    yesno(skl_is_16gb_dimm(dimm)));
-}
-
-static int
-skl_dram_get_channel_info(struct drm_i915_private *dev_priv,
-			  struct dram_channel_info *ch,
-			  int channel, u32 val)
-{
-	skl_dram_get_dimm_info(dev_priv, &ch->dimm_l,
-			       channel, 'L', val & 0xffff);
-	skl_dram_get_dimm_info(dev_priv, &ch->dimm_s,
-			       channel, 'S', val >> 16);
-
-	if (ch->dimm_l.size == 0 && ch->dimm_s.size == 0) {
-		drm_dbg_kms(&dev_priv->drm, "CH%u not populated\n", channel);
-		return -EINVAL;
-	}
-
-	if (ch->dimm_l.ranks == 2 || ch->dimm_s.ranks == 2)
-		ch->ranks = 2;
-	else if (ch->dimm_l.ranks == 1 && ch->dimm_s.ranks == 1)
-		ch->ranks = 2;
-	else
-		ch->ranks = 1;
-
-	ch->is_16gb_dimm =
-		skl_is_16gb_dimm(&ch->dimm_l) ||
-		skl_is_16gb_dimm(&ch->dimm_s);
-
-	drm_dbg_kms(&dev_priv->drm, "CH%u ranks: %u, 16Gb DIMMs: %s\n",
-		    channel, ch->ranks, yesno(ch->is_16gb_dimm));
-
-	return 0;
-}
-
-static bool
-intel_is_dram_symmetric(const struct dram_channel_info *ch0,
-			const struct dram_channel_info *ch1)
-{
-	return !memcmp(ch0, ch1, sizeof(*ch0)) &&
-		(ch0->dimm_s.size == 0 ||
-		 !memcmp(&ch0->dimm_l, &ch0->dimm_s, sizeof(ch0->dimm_l)));
-}
-
-static int
-skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
-{
-	struct dram_info *dram_info = &dev_priv->dram_info;
-	struct dram_channel_info ch0 = {}, ch1 = {};
-	u32 val;
-	int ret;
-
-	val = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(dev_priv, &ch0, 0, val);
-	if (ret == 0)
-		dram_info->num_channels++;
-
-	val = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(dev_priv, &ch1, 1, val);
-	if (ret == 0)
-		dram_info->num_channels++;
-
-	if (dram_info->num_channels == 0) {
-		drm_info(&dev_priv->drm,
-			 "Number of memory channels is zero\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * If any of the channel is single rank channel, worst case output
-	 * will be same as if single rank memory, so consider single rank
-	 * memory.
-	 */
-	if (ch0.ranks == 1 || ch1.ranks == 1)
-		dram_info->ranks = 1;
-	else
-		dram_info->ranks = max(ch0.ranks, ch1.ranks);
-
-	if (dram_info->ranks == 0) {
-		drm_info(&dev_priv->drm,
-			 "couldn't get memory rank information\n");
-		return -EINVAL;
-	}
-
-	dram_info->is_16gb_dimm = ch0.is_16gb_dimm || ch1.is_16gb_dimm;
-
-	dram_info->symmetric_memory = intel_is_dram_symmetric(&ch0, &ch1);
-
-	drm_dbg_kms(&dev_priv->drm, "Memory configuration is symmetric? %s\n",
-		    yesno(dram_info->symmetric_memory));
-	return 0;
-}
-
-static enum intel_dram_type
-skl_get_dram_type(struct drm_i915_private *dev_priv)
-{
-	u32 val;
-
-	val = I915_READ(SKL_MAD_INTER_CHANNEL_0_0_0_MCHBAR_MCMAIN);
-
-	switch (val & SKL_DRAM_DDR_TYPE_MASK) {
-	case SKL_DRAM_DDR_TYPE_DDR3:
-		return INTEL_DRAM_DDR3;
-	case SKL_DRAM_DDR_TYPE_DDR4:
-		return INTEL_DRAM_DDR4;
-	case SKL_DRAM_DDR_TYPE_LPDDR3:
-		return INTEL_DRAM_LPDDR3;
-	case SKL_DRAM_DDR_TYPE_LPDDR4:
-		return INTEL_DRAM_LPDDR4;
-	default:
-		MISSING_CASE(val);
-		return INTEL_DRAM_UNKNOWN;
-	}
-}
-
-static int
-skl_get_dram_info(struct drm_i915_private *dev_priv)
-{
-	struct dram_info *dram_info = &dev_priv->dram_info;
-	u32 mem_freq_khz, val;
-	int ret;
-
-	dram_info->type = skl_get_dram_type(dev_priv);
-	drm_dbg_kms(&dev_priv->drm, "DRAM type: %s\n",
-		    intel_dram_type_str(dram_info->type));
-
-	ret = skl_dram_get_channels_info(dev_priv);
-	if (ret)
-		return ret;
-
-	val = I915_READ(SKL_MC_BIOS_DATA_0_0_0_MCHBAR_PCU);
-	mem_freq_khz = DIV_ROUND_UP((val & SKL_REQ_DATA_MASK) *
-				    SKL_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
-
-	dram_info->bandwidth_kbps = dram_info->num_channels *
-							mem_freq_khz * 8;
-
-	if (dram_info->bandwidth_kbps == 0) {
-		drm_info(&dev_priv->drm,
-			 "Couldn't get system memory bandwidth\n");
-		return -EINVAL;
-	}
-
-	dram_info->valid = true;
-	return 0;
-}
-
-/* Returns Gb per DRAM device */
-static int bxt_get_dimm_size(u32 val)
-{
-	switch (val & BXT_DRAM_SIZE_MASK) {
-	case BXT_DRAM_SIZE_4GBIT:
-		return 4;
-	case BXT_DRAM_SIZE_6GBIT:
-		return 6;
-	case BXT_DRAM_SIZE_8GBIT:
-		return 8;
-	case BXT_DRAM_SIZE_12GBIT:
-		return 12;
-	case BXT_DRAM_SIZE_16GBIT:
-		return 16;
-	default:
-		MISSING_CASE(val);
-		return 0;
-	}
-}
-
-static int bxt_get_dimm_width(u32 val)
-{
-	if (!bxt_get_dimm_size(val))
-		return 0;
-
-	val = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
-
-	return 8 << val;
-}
-
-static int bxt_get_dimm_ranks(u32 val)
-{
-	if (!bxt_get_dimm_size(val))
-		return 0;
-
-	switch (val & BXT_DRAM_RANK_MASK) {
-	case BXT_DRAM_RANK_SINGLE:
-		return 1;
-	case BXT_DRAM_RANK_DUAL:
-		return 2;
-	default:
-		MISSING_CASE(val);
-		return 0;
-	}
-}
-
-static enum intel_dram_type bxt_get_dimm_type(u32 val)
-{
-	if (!bxt_get_dimm_size(val))
-		return INTEL_DRAM_UNKNOWN;
-
-	switch (val & BXT_DRAM_TYPE_MASK) {
-	case BXT_DRAM_TYPE_DDR3:
-		return INTEL_DRAM_DDR3;
-	case BXT_DRAM_TYPE_LPDDR3:
-		return INTEL_DRAM_LPDDR3;
-	case BXT_DRAM_TYPE_DDR4:
-		return INTEL_DRAM_DDR4;
-	case BXT_DRAM_TYPE_LPDDR4:
-		return INTEL_DRAM_LPDDR4;
-	default:
-		MISSING_CASE(val);
-		return INTEL_DRAM_UNKNOWN;
-	}
-}
-
-static void bxt_get_dimm_info(struct dram_dimm_info *dimm,
-			      u32 val)
-{
-	dimm->width = bxt_get_dimm_width(val);
-	dimm->ranks = bxt_get_dimm_ranks(val);
-
-	/*
-	 * Size in register is Gb per DRAM device. Convert to total
-	 * GB to match the way we report this for non-LP platforms.
-	 */
-	dimm->size = bxt_get_dimm_size(val) * intel_dimm_num_devices(dimm) / 8;
-}
-
-static int
-bxt_get_dram_info(struct drm_i915_private *dev_priv)
-{
-	struct dram_info *dram_info = &dev_priv->dram_info;
-	u32 dram_channels;
-	u32 mem_freq_khz, val;
-	u8 num_active_channels;
-	int i;
-
-	val = I915_READ(BXT_P_CR_MC_BIOS_REQ_0_0_0);
-	mem_freq_khz = DIV_ROUND_UP((val & BXT_REQ_DATA_MASK) *
-				    BXT_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
-
-	dram_channels = val & BXT_DRAM_CHANNEL_ACTIVE_MASK;
-	num_active_channels = hweight32(dram_channels);
-
-	/* Each active bit represents 4-byte channel */
-	dram_info->bandwidth_kbps = (mem_freq_khz * num_active_channels * 4);
-
-	if (dram_info->bandwidth_kbps == 0) {
-		drm_info(&dev_priv->drm,
-			 "Couldn't get system memory bandwidth\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * Now read each DUNIT8/9/10/11 to check the rank of each dimms.
-	 */
-	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
-		struct dram_dimm_info dimm;
-		enum intel_dram_type type;
-
-		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
-		if (val == 0xFFFFFFFF)
-			continue;
-
-		dram_info->num_channels++;
-
-		bxt_get_dimm_info(&dimm, val);
-		type = bxt_get_dimm_type(val);
-
-		drm_WARN_ON(&dev_priv->drm, type != INTEL_DRAM_UNKNOWN &&
-			    dram_info->type != INTEL_DRAM_UNKNOWN &&
-			    dram_info->type != type);
-
-		drm_dbg_kms(&dev_priv->drm,
-			    "CH%u DIMM size: %u GB, width: X%u, ranks: %u, type: %s\n",
-			    i - BXT_D_CR_DRP0_DUNIT_START,
-			    dimm.size, dimm.width, dimm.ranks,
-			    intel_dram_type_str(type));
-
-		/*
-		 * If any of the channel is single rank channel,
-		 * worst case output will be same as if single rank
-		 * memory, so consider single rank memory.
-		 */
-		if (dram_info->ranks == 0)
-			dram_info->ranks = dimm.ranks;
-		else if (dimm.ranks == 1)
-			dram_info->ranks = 1;
-
-		if (type != INTEL_DRAM_UNKNOWN)
-			dram_info->type = type;
-	}
-
-	if (dram_info->type == INTEL_DRAM_UNKNOWN ||
-	    dram_info->ranks == 0) {
-		drm_info(&dev_priv->drm, "couldn't get memory information\n");
-		return -EINVAL;
-	}
-
-	dram_info->valid = true;
-	return 0;
-}
-
-static void
-intel_get_dram_info(struct drm_i915_private *dev_priv)
-{
-	struct dram_info *dram_info = &dev_priv->dram_info;
-	int ret;
-
-	/*
-	 * Assume 16Gb DIMMs are present until proven otherwise.
-	 * This is only used for the level 0 watermark latency
-	 * w/a which does not apply to bxt/glk.
-	 */
-	dram_info->is_16gb_dimm = !IS_GEN9_LP(dev_priv);
-
-	if (INTEL_GEN(dev_priv) < 9 || !HAS_DISPLAY(dev_priv))
-		return;
-
-	if (IS_GEN9_LP(dev_priv))
-		ret = bxt_get_dram_info(dev_priv);
-	else
-		ret = skl_get_dram_info(dev_priv);
-	if (ret)
-		return;
-
-	drm_dbg_kms(&dev_priv->drm, "DRAM bandwidth: %u kBps, channels: %u\n",
-		    dram_info->bandwidth_kbps,
-		    dram_info->num_channels);
-
-	drm_dbg_kms(&dev_priv->drm, "DRAM ranks: %u, 16Gb DIMMs: %s\n",
-		    dram_info->ranks, yesno(dram_info->is_16gb_dimm));
-}
-
-static u32 gen9_edram_size_mb(struct drm_i915_private *dev_priv, u32 cap)
-{
-	static const u8 ways[8] = { 4, 8, 12, 16, 16, 16, 16, 16 };
-	static const u8 sets[4] = { 1, 1, 2, 2 };
-
-	return EDRAM_NUM_BANKS(cap) *
-		ways[EDRAM_WAYS_IDX(cap)] *
-		sets[EDRAM_SETS_IDX(cap)];
-}
-
-static void edram_detect(struct drm_i915_private *dev_priv)
-{
-	u32 edram_cap = 0;
-
-	if (!(IS_HASWELL(dev_priv) ||
-	      IS_BROADWELL(dev_priv) ||
-	      INTEL_GEN(dev_priv) >= 9))
-		return;
-
-	edram_cap = __raw_uncore_read32(&dev_priv->uncore, HSW_EDRAM_CAP);
-
-	/* NB: We can't write IDICR yet because we don't have gt funcs set up */
-
-	if (!(edram_cap & EDRAM_ENABLED))
-		return;
-
-	/*
-	 * The needed capability bits for size calculation are not there with
-	 * pre gen9 so return 128MB always.
-	 */
-	if (INTEL_GEN(dev_priv) < 9)
-		dev_priv->edram_size_mb = 128;
-	else
-		dev_priv->edram_size_mb =
-			gen9_edram_size_mb(dev_priv, edram_cap);
-
-	dev_info(dev_priv->drm.dev,
-		 "Found %uMB of eDRAM\n", dev_priv->edram_size_mb);
-}
-
 /**
  * i915_driver_hw_probe - setup state requiring device access
  * @dev_priv: device private
@@ -1094,7 +607,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	intel_sanitize_options(dev_priv);
 
 	/* needs to be done before ggtt probe */
-	edram_detect(dev_priv);
+	intel_dram_edram_detect(dev_priv);
 
 	i915_perf_init(dev_priv);
 
@@ -1196,7 +709,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	 * Fill the dram structure to get the system raw bandwidth and
 	 * dram info. This will be used for memory latency calculation.
 	 */
-	intel_get_dram_info(dev_priv);
+	intel_dram_detect(dev_priv);
 
 	intel_bw_init_hw(dev_priv);
 

commit 83d2bdb6a0e088a0ec8fe1e2877c8aa1a4a80330
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 25 15:31:31 2020 +0200

    drm/i915: significantly reduce the use of <drm/i915_drm.h>
    
    The #include has been splattered all over the place, but there are
    precious few places, all .c files, that actually need it.
    
    v2: remove leftover double newlines
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225133131.3301-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a87b28ee2d90..76f4a269edd6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -44,7 +44,6 @@
 #include <drm/drm_ioctl.h>
 #include <drm/drm_irq.h>
 #include <drm/drm_probe_helper.h>
-#include <drm/i915_drm.h>
 
 #include "display/intel_acpi.h"
 #include "display/intel_audio.h"

commit 4825b61a3d39eceef7db723808103aa60fc24520
Merge: aaa9d265a21e 53e3ca674918
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 27 08:59:19 2020 +1000

    Merge tag 'drm-intel-next-2020-02-25' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    - A backmerge of drm-next solving conflicts on i915/gt/intel_lrc.c
    - Clean up shadow batch after I915_EXEC_SECURE
    - Drop assertion that active->fence is unchanged
    
    Here goes drm-intel-next-2020-02-25:
    - A backmerge of drm-next solving conflicts on i915/gt/intel_lrc.c
    - Clean up shadow batch after I915_EXEC_SECURE
    - Drop assertion that active->fence is unchanged
    drm-intel-next-2020-02-24-1:
    - RC6 fixes - Chris
    - Add extra slice common debug register - Lionel
    - Align virtual engines uabi_class/instance with i915_drm.h - Tvrtko
    - Avoid potential division by zero in computing CS timestamp - Chris
    - Avoid using various globals - Michal Winiarski, Matt Auld
    - Break up long lists of GEM object reclaim - Chris
    - Check that the vma hasn't been closed before we insert it - Chris
    - Consolidate SDVO HDMI force_dvi handling - Ville
    - Conversion to new logging and warn macros and functions - Pankaj, Wambul, Chris
    - DC3CO fixes - Jose
    - Disable use of hwsp_cacheline for kernel_context - Chris
    - Display IRQ pre/post uninstall refactor - Jani
    - Display port sync refactor for robustness and fixes - Ville, Manasi
    - Do not attempt to reprogram IA/ring frequencies for dgfx - Chris
    - Drop alpha_support for good in favor of force_probe - Jani
    - DSI ACPI related fixes and refactors - Vivek, Jani, Rajat
    - Encoder refactor for flexibility to add more information, especiallly DSI related - Jani, Vandita
    - Engine workarounds refactor for robustness around resue - Daniele
    - FBC simplification and tracepoints
    - Various fixes for build - Jani, Kees Cook, Chris, Zhang Xiaoxu
    - Fix cmdparser - Chris
    - Fix DRM_I915_GEM_MMAP_OFFFSET - Chris
    - Fix i915_request flags - Chris
    - Fix inconsistency between pfit enable and scaler freeing - Stanislav
    - Fix inverted warn_on on display code - Chris
    - Fix modeset locks in sanitize_watermarks - Ville
    - Fix OA context id overlap with idle context id - Umesh
    - Fix pipe and vblank enable for MST - Jani
    - Fix VBT handling for timing parameters - Vandita
    - Fixes o kernel doc - Chris, Ville
    - Force full modeset whenever DSC is enabled at probe - Jani
    - Various GEM locking simplification and fixes - Jani , Chris, Jose
      - Including some changes in preparation for making GEM execbuf parallel - Chris
    - Gen11 pcode error codes - Matt Roper
    - Gen8+ interrupt handler refactor - Chris
    - Many fixes and improvements around GuC code - Daniele, Michal Wajdeczko
    - i915 parameters improvements sfor flexible input and better debugability - Chris, Jani
    - Ice Lake and Elkhart Lake Fixes and workarounds - Matt Roper, Jose, Vivek, Matt Atwood
    - Improvements on execlists, requests and other areas, fixing hangs and also
      improving hang detection, recover and debugability - Chris
      - Also introducing offline GT error capture - Chris
    - Introduce encoder->compute_config_late() to help MST - Ville
    - Make dbuf configuration const - Jani
    - Few misc clean ups - Ville, Chris
    - Never allow userptr into the new mapping types - Janusz
    - Poison rings after use and GTT scratch pages - Chris
    - Protect signaler walk with RCU - Chris
    - PSR fixes - Jose
    - Pull sseu context updates under gt - Chris
    - Read rawclk_freq earlier - Chris
    - Refactor around VBT handling to allow geting information through the encoder - Jani
    - Refactor l3cc/mocs availability - Chris
    - Refactor to use intel_connector over drm_connector - Ville
    - Remove i915_energy_uJ from debugfs - Tvrtko
    - Remove lite restore defines - Mika Kuoppala
    - Remove prefault_disable modparam - Chris
    - Many selftests fixes and improvements - Chris
    - Set intel_dp_set_m_n() for MST slaves - Jose
    - Simplify hot plug pin handling and other fixes around pin and polled modes - Ville
    - Skip CPU synchronization on dma-buf attachments - chris
    - Skip global serialization of clear_range for bxt vtd - Chris
    - Skip rmw for marked register - Chris
    - Some other GEM Fixes - Chris
    - Some small changes for satisfying static code analysis - Colin, Chris
    - Suppress warnings for unused debugging locals
    - Tiger Lake enabling, including re-enable -f RPS, workarounds and other display fixes and changes - Chris, Matt Roper, Mika Kuoppala, Anshuman, Jose, Radhakrishna, Rafael.
    - Track hw reported context runtime - Tvrtko
    - Update bug filling URL - Jani
    - Use async bind for PIN_USER into bsw/bxt ggtt - Chris
    - Use the kernel_context to measuer the breadcrumb size - Chris
    - Userptr fixes and robustness for big pages - Matt Auld
    - Various Display refactors and clean-ups, specially around logs and use of drm_i915_private - Jani, Ville
    - Various display refactors and fixes, especially around cdclk, modeset, and encoder - Chris, Jani
    - Various eDP/DP fixes around DPCD - Lyude
    - Various fixes and refactors for better Display watermark handling - Ville, Stanislav
    - Various other display refactors - Ville
    - Various refactor for better handling of display plane states - Ville
    - Wean off drm_pci_alloc/drm_pci_free - Chris
    - Correctly terminate connector iteration- Ville
    - Downgrade gen7 (ivb, byt, hsw) back to aliasing-ppgtt - Chris
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225185853.GA3282832@intel.com

commit 80f286a552c6cc554199a7d14b76836cffabd451
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Feb 24 14:08:28 2020 +0200

    drm/i915: split intel_modeset_init() to pre/post irq install
    
    Split inte_modeset_init() to parts before and after irq install, to
    facilitate further cleanup. The error paths are a mess, otherwise no
    functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200224120828.22105-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0c6902884db0..a87b28ee2d90 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -238,8 +238,14 @@ static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
 
 	intel_csr_ucode_init(i915);
 
+	ret = intel_modeset_init_noirq(i915);
+	if (ret)
+		goto cleanup_vga_client;
+
 	return 0;
 
+cleanup_vga_client:
+	intel_vga_unregister(i915);
 out:
 	return ret;
 }

commit cf9bfa3c5ce8aba8e076a6d52a05d91435160744
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Feb 24 13:33:12 2020 +0200

    drm/i915: stop assigning drm->dev_private pointer
    
    We no longer need or use it as we subclass struct drm_device in our
    struct drm_i915_private, and can always use to_i915() to get at
    i915. Stop assigning the pointer to catch anyone trying to add new users
    for ->dev_private.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Dale B Stimson <dale.b.stimson@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200224113312.13674-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8d6c77e41177..0c6902884db0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1375,8 +1375,6 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return ERR_PTR(err);
 	}
 
-	i915->drm.dev_private = i915;
-
 	i915->drm.pdev = pdev;
 	pci_set_drvdata(pdev, i915);
 

commit ff36e78fdb251b9fa65028554689806961e011eb
Merge: 143d9c3e7b6a 1b245ec5b685
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Feb 25 09:29:58 2020 -0800

    Merge drm/drm-next into drm-intel-next-queued
    
    Some DSI and VBT pending patches from Hans will apply
    cleanly and with less ugly conflicts if they are rebuilt
    on top of other patches that recently landed on drm-next.
    
    Reference: https://patchwork.freedesktop.org/series/70952/
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com

commit df1a5bfc16f3275a74f77d73375e69bc62c45c4b
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Fri Feb 21 13:26:35 2020 -0800

    drm/i915/psr: Force PSR probe only after full initialization
    
    Commit 60c6a14b489b ("drm/i915/display: Force the state compute phase
    once to enable PSR") was forcing the state compute too earlier
    causing errors because not everything was initialized, so here
    moving to the end of i915_driver_modeset_probe() when the display is
    all initialized.
    
    Also fixing the place where it disarm the force probe as during the
    atomic check phase errors could happen like the ones due locking and
    it would cause PSR to never be enabled if that happens.
    Leaving the disarm to the atomic commit phase, intel_psr_enable() or
    intel_psr_update() will be called even if the current state do not
    allow PSR to be enabled.
    
    v2: Check if intel_dp is null in intel_psr_force_mode_changed_set()
    v3: Check intel_dp before get dev_priv
    v4:
    - renamed intel_psr_force_mode_changed_set() to
    intel_psr_set_force_mode_changed()
    - removed the set parameter from intel_psr_set_force_mode_changed()
    - not calling intel_psr_set_force_mode_changed() from
    intel_psr_enable/update(), directly setting it after the same checks
    that intel_psr_set_force_mode_changed() does
    - moved intel_psr_set_force_mode_changed() arm call to
    i915_driver_modeset_probe() as it is a better for a PSR call, all the
    functions calls happening between the old and the new function call
    will cause issue
    
    Fixes: 60c6a14b489b ("drm/i915/display: Force the state compute phase once to enable PSR")
    Closes: https://gitlab.freedesktop.org/drm/intel/issues/1151
    Tested-by: Ross Zwisler <zwisler@google.com>
    Reported-by: Ross Zwisler <zwisler@google.com>
    Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Anshuman Gupta <anshuman.gupta@intel.com>
    Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200221212635.11614-1-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2cea760f06fe..e2a0b6be8e04 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -58,6 +58,7 @@
 #include "display/intel_hotplug.h"
 #include "display/intel_overlay.h"
 #include "display/intel_pipe_crc.h"
+#include "display/intel_psr.h"
 #include "display/intel_sprite.h"
 #include "display/intel_vga.h"
 
@@ -272,6 +273,8 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	intel_init_ipc(i915);
 
+	intel_psr_set_force_mode_changed(i915->psr.dp);
+
 	return 0;
 
 cleanup_gem:

commit b664259f3fe2c7a967e9fa4ba6d3af6a2addaa99
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Feb 19 15:37:56 2020 +0200

    drm/i915: split i915_driver_modeset_probe() to pre/post irq install
    
    Pair the irq install and uninstall in the same layer. There are no
    functional changes in the happy day scenario. The cleanup paths are
    currently a mess though.
    
    Note that modeset probe pre-irq + post-irq install are matched by
    modeset driver remove pre-irq + post-irq uninstall, together, but not
    independently. They are not symmetric pairs.
    
    v2: don't add a new probe failure point here
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200219133756.13224-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6b216fc94b31..2cea760f06fe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -212,7 +212,8 @@ intel_teardown_mchbar(struct drm_i915_private *dev_priv)
 		release_resource(&dev_priv->mch_res);
 }
 
-static int i915_driver_modeset_probe(struct drm_i915_private *i915)
+/* part #1: call before irq install */
+static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
 {
 	int ret;
 
@@ -236,15 +237,22 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	intel_csr_ucode_init(i915);
 
-	ret = intel_irq_install(i915);
-	if (ret)
-		goto cleanup_csr;
+	return 0;
+
+out:
+	return ret;
+}
+
+/* part #2: call after irq install */
+static int i915_driver_modeset_probe(struct drm_i915_private *i915)
+{
+	int ret;
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
 	ret = intel_modeset_init(i915);
 	if (ret)
-		goto cleanup_irq;
+		goto out;
 
 	ret = i915_gem_init(i915);
 	if (ret)
@@ -271,16 +279,10 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	i915_gem_driver_remove(i915);
 	i915_gem_driver_release(i915);
 cleanup_modeset:
+	/* FIXME */
 	intel_modeset_driver_remove(i915);
 	intel_irq_uninstall(i915);
 	intel_modeset_driver_remove_noirq(i915);
-	goto cleanup_csr;
-cleanup_irq:
-	intel_irq_uninstall(i915);
-cleanup_csr:
-	intel_csr_ucode_fini(i915);
-	intel_power_domains_driver_remove(i915);
-	intel_vga_unregister(i915);
 out:
 	return ret;
 }
@@ -1459,10 +1461,18 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret < 0)
 		goto out_cleanup_mmio;
 
-	ret = i915_driver_modeset_probe(i915);
+	ret = i915_driver_modeset_probe_noirq(i915);
 	if (ret < 0)
 		goto out_cleanup_hw;
 
+	ret = intel_irq_install(i915);
+	if (ret)
+		goto out_cleanup_modeset;
+
+	ret = i915_driver_modeset_probe(i915);
+	if (ret < 0)
+		goto out_cleanup_irq;
+
 	i915_driver_register(i915);
 
 	enable_rpm_wakeref_asserts(&i915->runtime_pm);
@@ -1471,6 +1481,10 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	return 0;
 
+out_cleanup_irq:
+	intel_irq_uninstall(i915);
+out_cleanup_modeset:
+	/* FIXME */
 out_cleanup_hw:
 	i915_driver_hw_remove(i915);
 	intel_memory_regions_driver_release(i915);

commit 6065682f99542f6f255d13500f7e56cf194c3ca3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 21 23:51:35 2020 +0000

    drm/i915/gt: Push the GPU cancellation to the backend
    
    Upon unregistering the user interface, we mark the GPU as wedged to
    ensure we push no new work to the GPU, and to flush all current work
    from the GPU. Move this call to the GT backend.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200221235135.2883006-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4dd8294b68e1..6b216fc94b31 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1494,13 +1494,6 @@ void i915_driver_remove(struct drm_i915_private *i915)
 
 	i915_driver_unregister(i915);
 
-	/*
-	 * After unregistering the device to prevent any new users, cancel
-	 * all in-flight requests so that we can quickly unbind the active
-	 * resources.
-	 */
-	intel_gt_set_wedged(&i915->gt);
-
 	/* Flush any external code that still may be under the RCU lock */
 	synchronize_rcu();
 

commit 1b245ec5b685ebf8e6e5d1e6b5bcc03b6608e8b0
Merge: 11a48a5a18c6 06f749af622c
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 20 15:21:02 2020 +1000

    Merge tag 'drm-misc-next-2020-02-10' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.7:
    
    UAPI Changes:
      - lima: Add support for heap buffers
    
    Cross-subsystem Changes:
    
    Core Changes:
      - Implement mode_config mode_valid for memory constrained drivers
      - Bus format negociation between bridges
      - Consolidate fake vblank events for drivers without vblank interrupts
      - drm/bufs: dma_alloc related cleanups
      - drm/dp_mst: Various fixes
      - drm/print: New drm_device based print helpers
      - Thomas is a drm-misc maintainer now!
    
    Driver Changes:
      - DPMS cleanups for atomic drivers
      - Removal of owner field in SPI tinydrm drivers
      - Removal of explicit dependency on DT for tinydrm drivers
      - Conversion to YAML schemas for DT bindings
      - tidss: New driver
      - virtio: various reworks and fixes
      - Our usual dozen or so new panels or bridges
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime@cerno.tech>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200210093421.xu4sofldm6wm6xq6@gilmour.lan

commit f20a60fb7aef3f5aecee4a9c30e36ee3e518fa16
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Feb 14 15:50:58 2020 +0200

    drm/i915: split i915_driver_modeset_remove() to pre/post irq uninstall
    
    Push irq uninstall further up, by splitting i915_driver_modeset_remove()
    to two, the part with working irqs before irq uninstall, and the part
    after irq uninstall. No functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200214135058.7580-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e85078eb7b7d..4dd8294b68e1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -285,12 +285,15 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	return ret;
 }
 
+/* part #1: call before irq uninstall */
 static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 {
 	intel_modeset_driver_remove(i915);
+}
 
-	intel_irq_uninstall(i915);
-
+/* part #2: call after irq uninstall */
+static void i915_driver_modeset_remove_noirq(struct drm_i915_private *i915)
+{
 	intel_modeset_driver_remove_noirq(i915);
 
 	intel_bios_driver_remove(i915);
@@ -1509,6 +1512,10 @@ void i915_driver_remove(struct drm_i915_private *i915)
 
 	i915_driver_modeset_remove(i915);
 
+	intel_irq_uninstall(i915);
+
+	i915_driver_modeset_remove_noirq(i915);
+
 	i915_reset_error_state(i915);
 	i915_gem_driver_remove(i915);
 

commit 93a0ed6cc164bad2bc9afcf1d06186f8425020af
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Feb 14 15:50:57 2020 +0200

    drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall
    
    Split intel_modeset_driver_remove() to two, the part with working irqs
    before irq uninstall, and the part after irq uninstall. Move
    irq_unintall() closer to the layer it belongs.
    
    The error path in i915_driver_modeset_probe() looks obviously weird
    after this, but remains as good or broken as it ever was. No functional
    changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200214135058.7580-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0e8b56d8fce2..e85078eb7b7d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -272,6 +272,9 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	i915_gem_driver_release(i915);
 cleanup_modeset:
 	intel_modeset_driver_remove(i915);
+	intel_irq_uninstall(i915);
+	intel_modeset_driver_remove_noirq(i915);
+	goto cleanup_csr;
 cleanup_irq:
 	intel_irq_uninstall(i915);
 cleanup_csr:
@@ -288,6 +291,8 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 
 	intel_irq_uninstall(i915);
 
+	intel_modeset_driver_remove_noirq(i915);
+
 	intel_bios_driver_remove(i915);
 
 	intel_vga_unregister(i915);

commit 28f2aff1caa4997f58ca31179cad1b4a84a62827
Merge: 3e8a3844fefb 11a48a5a18c6
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Mon Feb 17 10:34:34 2020 +0100

    Merge v5.6-rc2 into drm-misc-next
    
    Lyude needs some patches in 5.6-rc2 and we didn't bring drm-misc-next
    forward yet, so it looks like a good occasion.
    
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>

commit fb5f432a66dd2b6d3d419c422b103482e627ee5a
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Feb 12 16:40:57 2020 +0200

    drm/i915: split out vlv/chv specific suspend/resume code
    
    i915_drv.c is a fairly big file, and having very specific vlv/chv
    suspend/resume code in it is a distraction. Split it out to a new
    vlv_suspend.[ch] file.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200212144058.5686-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 168d96b119e6..0e8b56d8fce2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -81,71 +81,10 @@
 #include "i915_vgpu.h"
 #include "intel_memory_region.h"
 #include "intel_pm.h"
+#include "vlv_suspend.h"
 
 static struct drm_driver driver;
 
-struct vlv_s0ix_state {
-	/* GAM */
-	u32 wr_watermark;
-	u32 gfx_prio_ctrl;
-	u32 arb_mode;
-	u32 gfx_pend_tlb0;
-	u32 gfx_pend_tlb1;
-	u32 lra_limits[GEN7_LRA_LIMITS_REG_NUM];
-	u32 media_max_req_count;
-	u32 gfx_max_req_count;
-	u32 render_hwsp;
-	u32 ecochk;
-	u32 bsd_hwsp;
-	u32 blt_hwsp;
-	u32 tlb_rd_addr;
-
-	/* MBC */
-	u32 g3dctl;
-	u32 gsckgctl;
-	u32 mbctl;
-
-	/* GCP */
-	u32 ucgctl1;
-	u32 ucgctl3;
-	u32 rcgctl1;
-	u32 rcgctl2;
-	u32 rstctl;
-	u32 misccpctl;
-
-	/* GPM */
-	u32 gfxpause;
-	u32 rpdeuhwtc;
-	u32 rpdeuc;
-	u32 ecobus;
-	u32 pwrdwnupctl;
-	u32 rp_down_timeout;
-	u32 rp_deucsw;
-	u32 rcubmabdtmr;
-	u32 rcedata;
-	u32 spare2gh;
-
-	/* Display 1 CZ domain */
-	u32 gt_imr;
-	u32 gt_ier;
-	u32 pm_imr;
-	u32 pm_ier;
-	u32 gt_scratch[GEN7_GT_SCRATCH_REG_NUM];
-
-	/* GT SA CZ domain */
-	u32 tilectl;
-	u32 gt_fifoctl;
-	u32 gtlc_wake_ctrl;
-	u32 gtlc_survive;
-	u32 pmwgicz;
-
-	/* Display 2 CZ domain */
-	u32 gu_ctl0;
-	u32 gu_ctl1;
-	u32 pcbr;
-	u32 clock_gate_dis2;
-};
-
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
 	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);
@@ -437,29 +376,6 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	}
 }
 
-static int vlv_alloc_s0ix_state(struct drm_i915_private *i915)
-{
-	if (!IS_VALLEYVIEW(i915))
-		return 0;
-
-	/* we write all the values in the struct, so no need to zero it out */
-	i915->vlv_s0ix_state = kmalloc(sizeof(*i915->vlv_s0ix_state),
-				       GFP_KERNEL);
-	if (!i915->vlv_s0ix_state)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void vlv_free_s0ix_state(struct drm_i915_private *i915)
-{
-	if (!i915->vlv_s0ix_state)
-		return;
-
-	kfree(i915->vlv_s0ix_state);
-	i915->vlv_s0ix_state = NULL;
-}
-
 static void sanitize_gpu(struct drm_i915_private *i915)
 {
 	if (!INTEL_INFO(i915)->gpu_reset_clobbers_display)
@@ -508,7 +424,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		return ret;
 
-	ret = vlv_alloc_s0ix_state(dev_priv);
+	ret = vlv_suspend_init(dev_priv);
 	if (ret < 0)
 		goto err_workqueues;
 
@@ -539,7 +455,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 err_gem:
 	i915_gem_cleanup_early(dev_priv);
 	intel_gt_driver_late_release(&dev_priv->gt);
-	vlv_free_s0ix_state(dev_priv);
+	vlv_suspend_cleanup(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 	return ret;
@@ -556,7 +472,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 	intel_power_domains_cleanup(dev_priv);
 	i915_gem_cleanup_early(dev_priv);
 	intel_gt_driver_late_release(&dev_priv->gt);
-	vlv_free_s0ix_state(dev_priv);
+	vlv_suspend_cleanup(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 
 	pm_qos_remove_request(&dev_priv->sb_qos);
@@ -1674,10 +1590,6 @@ static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 	drm_modeset_unlock_all(dev);
 }
 
-static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
-			      bool rpm_resume);
-static int vlv_suspend_complete(struct drm_i915_private *dev_priv);
-
 static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 {
 #if IS_ENABLED(CONFIG_ACPI_SLEEP)
@@ -1764,7 +1676,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
-	int ret = 0;
+	int ret;
 
 	disable_rpm_wakeref_asserts(rpm);
 
@@ -1777,9 +1689,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	intel_display_power_suspend_late(dev_priv);
 
-	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
-		ret = vlv_suspend_complete(dev_priv);
-
+	ret = vlv_suspend_complete(dev_priv);
 	if (ret) {
 		drm_err(&dev_priv->drm, "Suspend complete failed: %d\n", ret);
 		intel_power_domains_resume(dev_priv);
@@ -1954,12 +1864,10 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
-	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
-		ret = vlv_resume_prepare(dev_priv, false);
+	ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
 		drm_err(&dev_priv->drm,
-			"Resume prepare failed: %d, continuing anyway\n",
-			ret);
+			"Resume prepare failed: %d, continuing anyway\n", ret);
 
 	intel_uncore_resume_early(&dev_priv->uncore);
 
@@ -2126,390 +2034,11 @@ static int i915_pm_restore(struct device *kdev)
 	return i915_pm_resume(kdev);
 }
 
-/*
- * Save all Gunit registers that may be lost after a D3 and a subsequent
- * S0i[R123] transition. The list of registers needing a save/restore is
- * defined in the VLV2_S0IXRegs document. This documents marks all Gunit
- * registers in the following way:
- * - Driver: saved/restored by the driver
- * - Punit : saved/restored by the Punit firmware
- * - No, w/o marking: no need to save/restore, since the register is R/O or
- *                    used internally by the HW in a way that doesn't depend
- *                    keeping the content across a suspend/resume.
- * - Debug : used for debugging
- *
- * We save/restore all registers marked with 'Driver', with the following
- * exceptions:
- * - Registers out of use, including also registers marked with 'Debug'.
- *   These have no effect on the driver's operation, so we don't save/restore
- *   them to reduce the overhead.
- * - Registers that are fully setup by an initialization function called from
- *   the resume path. For example many clock gating and RPS/RC6 registers.
- * - Registers that provide the right functionality with their reset defaults.
- *
- * TODO: Except for registers that based on the above 3 criteria can be safely
- * ignored, we save/restore all others, practically treating the HW context as
- * a black-box for the driver. Further investigation is needed to reduce the
- * saved/restored registers even further, by following the same 3 criteria.
- */
-static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
-{
-	struct vlv_s0ix_state *s = dev_priv->vlv_s0ix_state;
-	int i;
-
-	if (!s)
-		return;
-
-	/* GAM 0x4000-0x4770 */
-	s->wr_watermark		= I915_READ(GEN7_WR_WATERMARK);
-	s->gfx_prio_ctrl	= I915_READ(GEN7_GFX_PRIO_CTRL);
-	s->arb_mode		= I915_READ(ARB_MODE);
-	s->gfx_pend_tlb0	= I915_READ(GEN7_GFX_PEND_TLB0);
-	s->gfx_pend_tlb1	= I915_READ(GEN7_GFX_PEND_TLB1);
-
-	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
-		s->lra_limits[i] = I915_READ(GEN7_LRA_LIMITS(i));
-
-	s->media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
-	s->gfx_max_req_count	= I915_READ(GEN7_GFX_MAX_REQ_COUNT);
-
-	s->render_hwsp		= I915_READ(RENDER_HWS_PGA_GEN7);
-	s->ecochk		= I915_READ(GAM_ECOCHK);
-	s->bsd_hwsp		= I915_READ(BSD_HWS_PGA_GEN7);
-	s->blt_hwsp		= I915_READ(BLT_HWS_PGA_GEN7);
-
-	s->tlb_rd_addr		= I915_READ(GEN7_TLB_RD_ADDR);
-
-	/* MBC 0x9024-0x91D0, 0x8500 */
-	s->g3dctl		= I915_READ(VLV_G3DCTL);
-	s->gsckgctl		= I915_READ(VLV_GSCKGCTL);
-	s->mbctl		= I915_READ(GEN6_MBCTL);
-
-	/* GCP 0x9400-0x9424, 0x8100-0x810C */
-	s->ucgctl1		= I915_READ(GEN6_UCGCTL1);
-	s->ucgctl3		= I915_READ(GEN6_UCGCTL3);
-	s->rcgctl1		= I915_READ(GEN6_RCGCTL1);
-	s->rcgctl2		= I915_READ(GEN6_RCGCTL2);
-	s->rstctl		= I915_READ(GEN6_RSTCTL);
-	s->misccpctl		= I915_READ(GEN7_MISCCPCTL);
-
-	/* GPM 0xA000-0xAA84, 0x8000-0x80FC */
-	s->gfxpause		= I915_READ(GEN6_GFXPAUSE);
-	s->rpdeuhwtc		= I915_READ(GEN6_RPDEUHWTC);
-	s->rpdeuc		= I915_READ(GEN6_RPDEUC);
-	s->ecobus		= I915_READ(ECOBUS);
-	s->pwrdwnupctl		= I915_READ(VLV_PWRDWNUPCTL);
-	s->rp_down_timeout	= I915_READ(GEN6_RP_DOWN_TIMEOUT);
-	s->rp_deucsw		= I915_READ(GEN6_RPDEUCSW);
-	s->rcubmabdtmr		= I915_READ(GEN6_RCUBMABDTMR);
-	s->rcedata		= I915_READ(VLV_RCEDATA);
-	s->spare2gh		= I915_READ(VLV_SPAREG2H);
-
-	/* Display CZ domain, 0x4400C-0x4402C, 0x4F000-0x4F11F */
-	s->gt_imr		= I915_READ(GTIMR);
-	s->gt_ier		= I915_READ(GTIER);
-	s->pm_imr		= I915_READ(GEN6_PMIMR);
-	s->pm_ier		= I915_READ(GEN6_PMIER);
-
-	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
-		s->gt_scratch[i] = I915_READ(GEN7_GT_SCRATCH(i));
-
-	/* GT SA CZ domain, 0x100000-0x138124 */
-	s->tilectl		= I915_READ(TILECTL);
-	s->gt_fifoctl		= I915_READ(GTFIFOCTL);
-	s->gtlc_wake_ctrl	= I915_READ(VLV_GTLC_WAKE_CTRL);
-	s->gtlc_survive		= I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-	s->pmwgicz		= I915_READ(VLV_PMWGICZ);
-
-	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
-	s->gu_ctl0		= I915_READ(VLV_GU_CTL0);
-	s->gu_ctl1		= I915_READ(VLV_GU_CTL1);
-	s->pcbr			= I915_READ(VLV_PCBR);
-	s->clock_gate_dis2	= I915_READ(VLV_GUNIT_CLOCK_GATE2);
-
-	/*
-	 * Not saving any of:
-	 * DFT,		0x9800-0x9EC0
-	 * SARB,	0xB000-0xB1FC
-	 * GAC,		0x5208-0x524C, 0x14000-0x14C000
-	 * PCI CFG
-	 */
-}
-
-static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
-{
-	struct vlv_s0ix_state *s = dev_priv->vlv_s0ix_state;
-	u32 val;
-	int i;
-
-	if (!s)
-		return;
-
-	/* GAM 0x4000-0x4770 */
-	I915_WRITE(GEN7_WR_WATERMARK,	s->wr_watermark);
-	I915_WRITE(GEN7_GFX_PRIO_CTRL,	s->gfx_prio_ctrl);
-	I915_WRITE(ARB_MODE,		s->arb_mode | (0xffff << 16));
-	I915_WRITE(GEN7_GFX_PEND_TLB0,	s->gfx_pend_tlb0);
-	I915_WRITE(GEN7_GFX_PEND_TLB1,	s->gfx_pend_tlb1);
-
-	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
-		I915_WRITE(GEN7_LRA_LIMITS(i), s->lra_limits[i]);
-
-	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->media_max_req_count);
-	I915_WRITE(GEN7_GFX_MAX_REQ_COUNT, s->gfx_max_req_count);
-
-	I915_WRITE(RENDER_HWS_PGA_GEN7,	s->render_hwsp);
-	I915_WRITE(GAM_ECOCHK,		s->ecochk);
-	I915_WRITE(BSD_HWS_PGA_GEN7,	s->bsd_hwsp);
-	I915_WRITE(BLT_HWS_PGA_GEN7,	s->blt_hwsp);
-
-	I915_WRITE(GEN7_TLB_RD_ADDR,	s->tlb_rd_addr);
-
-	/* MBC 0x9024-0x91D0, 0x8500 */
-	I915_WRITE(VLV_G3DCTL,		s->g3dctl);
-	I915_WRITE(VLV_GSCKGCTL,	s->gsckgctl);
-	I915_WRITE(GEN6_MBCTL,		s->mbctl);
-
-	/* GCP 0x9400-0x9424, 0x8100-0x810C */
-	I915_WRITE(GEN6_UCGCTL1,	s->ucgctl1);
-	I915_WRITE(GEN6_UCGCTL3,	s->ucgctl3);
-	I915_WRITE(GEN6_RCGCTL1,	s->rcgctl1);
-	I915_WRITE(GEN6_RCGCTL2,	s->rcgctl2);
-	I915_WRITE(GEN6_RSTCTL,		s->rstctl);
-	I915_WRITE(GEN7_MISCCPCTL,	s->misccpctl);
-
-	/* GPM 0xA000-0xAA84, 0x8000-0x80FC */
-	I915_WRITE(GEN6_GFXPAUSE,	s->gfxpause);
-	I915_WRITE(GEN6_RPDEUHWTC,	s->rpdeuhwtc);
-	I915_WRITE(GEN6_RPDEUC,		s->rpdeuc);
-	I915_WRITE(ECOBUS,		s->ecobus);
-	I915_WRITE(VLV_PWRDWNUPCTL,	s->pwrdwnupctl);
-	I915_WRITE(GEN6_RP_DOWN_TIMEOUT,s->rp_down_timeout);
-	I915_WRITE(GEN6_RPDEUCSW,	s->rp_deucsw);
-	I915_WRITE(GEN6_RCUBMABDTMR,	s->rcubmabdtmr);
-	I915_WRITE(VLV_RCEDATA,		s->rcedata);
-	I915_WRITE(VLV_SPAREG2H,	s->spare2gh);
-
-	/* Display CZ domain, 0x4400C-0x4402C, 0x4F000-0x4F11F */
-	I915_WRITE(GTIMR,		s->gt_imr);
-	I915_WRITE(GTIER,		s->gt_ier);
-	I915_WRITE(GEN6_PMIMR,		s->pm_imr);
-	I915_WRITE(GEN6_PMIER,		s->pm_ier);
-
-	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
-		I915_WRITE(GEN7_GT_SCRATCH(i), s->gt_scratch[i]);
-
-	/* GT SA CZ domain, 0x100000-0x138124 */
-	I915_WRITE(TILECTL,			s->tilectl);
-	I915_WRITE(GTFIFOCTL,			s->gt_fifoctl);
-	/*
-	 * Preserve the GT allow wake and GFX force clock bit, they are not
-	 * be restored, as they are used to control the s0ix suspend/resume
-	 * sequence by the caller.
-	 */
-	val = I915_READ(VLV_GTLC_WAKE_CTRL);
-	val &= VLV_GTLC_ALLOWWAKEREQ;
-	val |= s->gtlc_wake_ctrl & ~VLV_GTLC_ALLOWWAKEREQ;
-	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
-
-	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-	val &= VLV_GFX_CLK_FORCE_ON_BIT;
-	val |= s->gtlc_survive & ~VLV_GFX_CLK_FORCE_ON_BIT;
-	I915_WRITE(VLV_GTLC_SURVIVABILITY_REG, val);
-
-	I915_WRITE(VLV_PMWGICZ,			s->pmwgicz);
-
-	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
-	I915_WRITE(VLV_GU_CTL0,			s->gu_ctl0);
-	I915_WRITE(VLV_GU_CTL1,			s->gu_ctl1);
-	I915_WRITE(VLV_PCBR,			s->pcbr);
-	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
-}
-
-static int vlv_wait_for_pw_status(struct drm_i915_private *i915,
-				  u32 mask, u32 val)
-{
-	i915_reg_t reg = VLV_GTLC_PW_STATUS;
-	u32 reg_value;
-	int ret;
-
-	/* The HW does not like us polling for PW_STATUS frequently, so
-	 * use the sleeping loop rather than risk the busy spin within
-	 * intel_wait_for_register().
-	 *
-	 * Transitioning between RC6 states should be at most 2ms (see
-	 * valleyview_enable_rps) so use a 3ms timeout.
-	 */
-	ret = wait_for(((reg_value =
-			 intel_uncore_read_notrace(&i915->uncore, reg)) & mask)
-		       == val, 3);
-
-	/* just trace the final value */
-	trace_i915_reg_rw(false, reg, reg_value, sizeof(reg_value), true);
-
-	return ret;
-}
-
-int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
-{
-	u32 val;
-	int err;
-
-	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-	val &= ~VLV_GFX_CLK_FORCE_ON_BIT;
-	if (force_on)
-		val |= VLV_GFX_CLK_FORCE_ON_BIT;
-	I915_WRITE(VLV_GTLC_SURVIVABILITY_REG, val);
-
-	if (!force_on)
-		return 0;
-
-	err = intel_wait_for_register(&dev_priv->uncore,
-				      VLV_GTLC_SURVIVABILITY_REG,
-				      VLV_GFX_CLK_STATUS_BIT,
-				      VLV_GFX_CLK_STATUS_BIT,
-				      20);
-	if (err)
-		drm_err(&dev_priv->drm,
-			"timeout waiting for GFX clock force-on (%08x)\n",
-			I915_READ(VLV_GTLC_SURVIVABILITY_REG));
-
-	return err;
-}
-
-static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
-{
-	u32 mask;
-	u32 val;
-	int err;
-
-	val = I915_READ(VLV_GTLC_WAKE_CTRL);
-	val &= ~VLV_GTLC_ALLOWWAKEREQ;
-	if (allow)
-		val |= VLV_GTLC_ALLOWWAKEREQ;
-	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
-	POSTING_READ(VLV_GTLC_WAKE_CTRL);
-
-	mask = VLV_GTLC_ALLOWWAKEACK;
-	val = allow ? mask : 0;
-
-	err = vlv_wait_for_pw_status(dev_priv, mask, val);
-	if (err)
-		drm_err(&dev_priv->drm, "timeout disabling GT waking\n");
-
-	return err;
-}
-
-static void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
-				  bool wait_for_on)
-{
-	u32 mask;
-	u32 val;
-
-	mask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;
-	val = wait_for_on ? mask : 0;
-
-	/*
-	 * RC6 transitioning can be delayed up to 2 msec (see
-	 * valleyview_enable_rps), use 3 msec for safety.
-	 *
-	 * This can fail to turn off the rc6 if the GPU is stuck after a failed
-	 * reset and we are trying to force the machine to sleep.
-	 */
-	if (vlv_wait_for_pw_status(dev_priv, mask, val))
-		drm_dbg(&dev_priv->drm,
-			"timeout waiting for GT wells to go %s\n",
-			onoff(wait_for_on));
-}
-
-static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
-{
-	if (!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEERR))
-		return;
-
-	drm_dbg(&dev_priv->drm,
-		"GT register access while GT waking disabled\n");
-	I915_WRITE(VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);
-}
-
-static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
-{
-	u32 mask;
-	int err;
-
-	/*
-	 * Bspec defines the following GT well on flags as debug only, so
-	 * don't treat them as hard failures.
-	 */
-	vlv_wait_for_gt_wells(dev_priv, false);
-
-	mask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;
-	drm_WARN_ON(&dev_priv->drm,
-		    (I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);
-
-	vlv_check_no_gt_access(dev_priv);
-
-	err = vlv_force_gfx_clock(dev_priv, true);
-	if (err)
-		goto err1;
-
-	err = vlv_allow_gt_wake(dev_priv, false);
-	if (err)
-		goto err2;
-
-	vlv_save_gunit_s0ix_state(dev_priv);
-
-	err = vlv_force_gfx_clock(dev_priv, false);
-	if (err)
-		goto err2;
-
-	return 0;
-
-err2:
-	/* For safety always re-enable waking and disable gfx clock forcing */
-	vlv_allow_gt_wake(dev_priv, true);
-err1:
-	vlv_force_gfx_clock(dev_priv, false);
-
-	return err;
-}
-
-static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
-				bool rpm_resume)
-{
-	int err;
-	int ret;
-
-	/*
-	 * If any of the steps fail just try to continue, that's the best we
-	 * can do at this point. Return the first error code (which will also
-	 * leave RPM permanently disabled).
-	 */
-	ret = vlv_force_gfx_clock(dev_priv, true);
-
-	vlv_restore_gunit_s0ix_state(dev_priv);
-
-	err = vlv_allow_gt_wake(dev_priv, true);
-	if (!ret)
-		ret = err;
-
-	err = vlv_force_gfx_clock(dev_priv, false);
-	if (!ret)
-		ret = err;
-
-	vlv_check_no_gt_access(dev_priv);
-
-	if (rpm_resume)
-		intel_init_clock_gating(dev_priv);
-
-	return ret;
-}
-
 static int intel_runtime_suspend(struct device *kdev)
 {
 	struct drm_i915_private *dev_priv = kdev_to_i915(kdev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
-	int ret = 0;
+	int ret;
 
 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
@@ -2532,9 +2061,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	intel_display_power_suspend(dev_priv);
 
-	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
-		ret = vlv_suspend_complete(dev_priv);
-
+	ret = vlv_suspend_complete(dev_priv);
 	if (ret) {
 		drm_err(&dev_priv->drm,
 			"Runtime suspend failed, disabling it (%d)\n", ret);
@@ -2596,7 +2123,7 @@ static int intel_runtime_resume(struct device *kdev)
 {
 	struct drm_i915_private *dev_priv = kdev_to_i915(kdev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
-	int ret = 0;
+	int ret;
 
 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
@@ -2614,8 +2141,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_display_power_resume(dev_priv);
 
-	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
-		ret = vlv_resume_prepare(dev_priv, true);
+	ret = vlv_resume_prepare(dev_priv, true);
 
 	intel_uncore_runtime_resume(&dev_priv->uncore);
 

commit 926b005cd8c4e325ab918edea0fbdd1d25d1ba28
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 11 18:14:51 2020 +0200

    drm/i915: split out display debugfs to a separate file
    
    The i915_debugfs.c has grown more than a little unwieldy. Split out the
    display related debugfs code to a file of its own under display/,
    initialized with a separate call. No functional changes.
    
    v2:
    - Also moved i915_frontbuffer_tracking, i915_gem_framebuffer,
      i915_power_domain_info, i915_dmc_info, i915_ipc_status (Ville)
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211161451.6867-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 66d3dae65f52..168d96b119e6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -51,6 +51,7 @@
 #include "display/intel_bw.h"
 #include "display/intel_cdclk.h"
 #include "display/intel_csr.h"
+#include "display/intel_display_debugfs.h"
 #include "display/intel_display_types.h"
 #include "display/intel_dp.h"
 #include "display/intel_fbdev.h"
@@ -1320,6 +1321,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
 		i915_debugfs_register(dev_priv);
+		intel_display_debugfs_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
 
 		/* Depends on sysfs having been initialized */

commit 4d4dda487a364e601a926443adf731b6fe64ae21
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 12 00:12:10 2020 +0100

    drm: i915: Call cpu_latency_qos_*() instead of pm_qos_*()
    
    Call cpu_latency_qos_add/update/remove_request() instead of
    pm_qos_add/update/remove_request(), respectively, because the
    latter are going to be dropped.
    
    No intentional functional impact.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f7385abdd74b..74481a189cfc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -502,8 +502,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	mutex_init(&dev_priv->backlight_lock);
 
 	mutex_init(&dev_priv->sb_lock);
-	pm_qos_add_request(&dev_priv->sb_qos,
-			   PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
+	cpu_latency_qos_add_request(&dev_priv->sb_qos, PM_QOS_DEFAULT_VALUE);
 
 	mutex_init(&dev_priv->av_mutex);
 	mutex_init(&dev_priv->wm.wm_mutex);
@@ -568,7 +567,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 	vlv_free_s0ix_state(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 
-	pm_qos_remove_request(&dev_priv->sb_qos);
+	cpu_latency_qos_remove_request(&dev_priv->sb_qos);
 	mutex_destroy(&dev_priv->sb_lock);
 }
 
@@ -1226,8 +1225,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 		}
 	}
 
-	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
-			   PM_QOS_DEFAULT_VALUE);
+	cpu_latency_qos_add_request(&dev_priv->pm_qos, PM_QOS_DEFAULT_VALUE);
 
 	intel_gt_init_workarounds(dev_priv);
 
@@ -1273,7 +1271,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 err_msi:
 	if (pdev->msi_enabled)
 		pci_disable_msi(pdev);
-	pm_qos_remove_request(&dev_priv->pm_qos);
+	cpu_latency_qos_remove_request(&dev_priv->pm_qos);
 err_mem_regions:
 	intel_memory_regions_driver_release(dev_priv);
 err_ggtt:
@@ -1296,7 +1294,7 @@ static void i915_driver_hw_remove(struct drm_i915_private *dev_priv)
 	if (pdev->msi_enabled)
 		pci_disable_msi(pdev);
 
-	pm_qos_remove_request(&dev_priv->pm_qos);
+	cpu_latency_qos_remove_request(&dev_priv->pm_qos);
 }
 
 /**

commit 06d3ff6e745114852204ff6667df9a0420ab9931
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 11 18:14:50 2020 +0200

    drm/i915: move intel_csr.[ch] under display/
    
    The DMC firmware is about display. Move the handling under display. No
    functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211161451.6867-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e26986e76721..66d3dae65f52 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -50,6 +50,7 @@
 #include "display/intel_audio.h"
 #include "display/intel_bw.h"
 #include "display/intel_cdclk.h"
+#include "display/intel_csr.h"
 #include "display/intel_display_types.h"
 #include "display/intel_dp.h"
 #include "display/intel_fbdev.h"
@@ -77,7 +78,6 @@
 #include "i915_sysfs.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
-#include "intel_csr.h"
 #include "intel_memory_region.h"
 #include "intel_pm.h"
 

commit 8eecfb3985e8c8aac77ab77ef5c40f9f5bbe0bfd
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 11 18:28:02 2020 +0200

    drm/i915: switch i915_driver_probe() to use i915 local variable
    
    Prefer i915 over dev_priv where possible. No functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162802.16180-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d3dd648658ed..e26986e76721 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1485,16 +1485,16 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	const struct intel_device_info *match_info =
 		(struct intel_device_info *)ent->driver_data;
-	struct drm_i915_private *dev_priv;
+	struct drm_i915_private *i915;
 	int ret;
 
-	dev_priv = i915_driver_create(pdev, ent);
-	if (IS_ERR(dev_priv))
-		return PTR_ERR(dev_priv);
+	i915 = i915_driver_create(pdev, ent);
+	if (IS_ERR(i915))
+		return PTR_ERR(i915);
 
 	/* Disable nuclear pageflip by default on pre-ILK */
 	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
-		dev_priv->drm.driver_features &= ~DRIVER_ATOMIC;
+		i915->drm.driver_features &= ~DRIVER_ATOMIC;
 
 	/*
 	 * Check if we support fake LMEM -- for now we only unleash this for
@@ -1502,13 +1502,13 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 */
 #if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
 	if (IS_ENABLED(CONFIG_DRM_I915_UNSTABLE_FAKE_LMEM)) {
-		if (INTEL_GEN(dev_priv) >= 9 && i915_selftest.live < 0 &&
+		if (INTEL_GEN(i915) >= 9 && i915_selftest.live < 0 &&
 		    i915_modparams.fake_lmem_start) {
-			mkwrite_device_info(dev_priv)->memory_regions =
+			mkwrite_device_info(i915)->memory_regions =
 				REGION_SMEM | REGION_LMEM | REGION_STOLEN;
-			mkwrite_device_info(dev_priv)->is_dgfx = true;
-			GEM_BUG_ON(!HAS_LMEM(dev_priv));
-			GEM_BUG_ON(!IS_DGFX(dev_priv));
+			mkwrite_device_info(i915)->is_dgfx = true;
+			GEM_BUG_ON(!HAS_LMEM(i915));
+			GEM_BUG_ON(!IS_DGFX(i915));
 		}
 	}
 #endif
@@ -1517,48 +1517,48 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret)
 		goto out_fini;
 
-	ret = i915_driver_early_probe(dev_priv);
+	ret = i915_driver_early_probe(i915);
 	if (ret < 0)
 		goto out_pci_disable;
 
-	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	disable_rpm_wakeref_asserts(&i915->runtime_pm);
 
-	i915_detect_vgpu(dev_priv);
+	i915_detect_vgpu(i915);
 
-	ret = i915_driver_mmio_probe(dev_priv);
+	ret = i915_driver_mmio_probe(i915);
 	if (ret < 0)
 		goto out_runtime_pm_put;
 
-	ret = i915_driver_hw_probe(dev_priv);
+	ret = i915_driver_hw_probe(i915);
 	if (ret < 0)
 		goto out_cleanup_mmio;
 
-	ret = i915_driver_modeset_probe(dev_priv);
+	ret = i915_driver_modeset_probe(i915);
 	if (ret < 0)
 		goto out_cleanup_hw;
 
-	i915_driver_register(dev_priv);
+	i915_driver_register(i915);
 
-	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 
-	i915_welcome_messages(dev_priv);
+	i915_welcome_messages(i915);
 
 	return 0;
 
 out_cleanup_hw:
-	i915_driver_hw_remove(dev_priv);
-	intel_memory_regions_driver_release(dev_priv);
-	i915_ggtt_driver_release(dev_priv);
+	i915_driver_hw_remove(i915);
+	intel_memory_regions_driver_release(i915);
+	i915_ggtt_driver_release(i915);
 out_cleanup_mmio:
-	i915_driver_mmio_release(dev_priv);
+	i915_driver_mmio_release(i915);
 out_runtime_pm_put:
-	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
-	i915_driver_late_release(dev_priv);
+	enable_rpm_wakeref_asserts(&i915->runtime_pm);
+	i915_driver_late_release(i915);
 out_pci_disable:
 	pci_disable_device(pdev);
 out_fini:
-	i915_probe_error(dev_priv, "Device initialization failed (%d)\n", ret);
-	i915_driver_destroy(dev_priv);
+	i915_probe_error(i915, "Device initialization failed (%d)\n", ret);
+	i915_driver_destroy(i915);
 	return ret;
 }
 

commit 46edcdbdb6d885971b7b49a040053bd23f331f2c
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 11 18:28:01 2020 +0200

    drm/i915: register vga switcheroo later, unregister earlier
    
    Move vga switcheroo and dsm handler register later in
    i915_driver_register(), and unregister in i915_driver_unregister(). The
    dsm handler unregister is a nop, and is only added for completeness.
    
    My unsubstantiated suspicion is that the vga switcheroo state change
    would not work as early as we register the hooks currently. In any case
    exposing the interfaces to the world only after we've got everything set
    up seems prudent.
    
    Also replace the error handling in vga switcheroo register with a simple
    error message. This is done at the same time due to lack of error
    propagation from i915_driver_register().
    
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162802.16180-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2227dc91e75c..d3dd648658ed 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -292,12 +292,6 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	if (ret)
 		goto out;
 
-	intel_register_dsm_handler();
-
-	ret = i915_switcheroo_register(i915);
-	if (ret)
-		goto cleanup_vga_client;
-
 	intel_power_domains_init_hw(i915, false);
 
 	intel_csr_ucode_init(i915);
@@ -343,8 +337,6 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 cleanup_csr:
 	intel_csr_ucode_fini(i915);
 	intel_power_domains_driver_remove(i915);
-	i915_switcheroo_unregister(i915);
-cleanup_vga_client:
 	intel_vga_unregister(i915);
 out:
 	return ret;
@@ -358,8 +350,6 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 
 	intel_bios_driver_remove(i915);
 
-	i915_switcheroo_unregister(i915);
-
 	intel_vga_unregister(i915);
 
 	intel_csr_ucode_fini(i915);
@@ -1366,6 +1356,11 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 
 	intel_power_domains_enable(dev_priv);
 	intel_runtime_pm_enable(&dev_priv->runtime_pm);
+
+	intel_register_dsm_handler();
+
+	if (i915_switcheroo_register(dev_priv))
+		drm_err(&dev_priv->drm, "Failed to register vga switcheroo!\n");
 }
 
 /**
@@ -1374,6 +1369,10 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
+	i915_switcheroo_unregister(dev_priv);
+
+	intel_unregister_dsm_handler();
+
 	intel_runtime_pm_disable(&dev_priv->runtime_pm);
 	intel_power_domains_disable(dev_priv);
 

commit 4bbffbf3c19a517625104fd7161c4c23d631351e
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:28 2020 +0100

    drm/i915: Convert to CRTC VBLANK callbacks
    
    VBLANK callbacks in struct drm_driver are deprecated in favor of their
    equivalents in struct drm_crtc_funcs. Convert i915 over.
    
    The callback struct drm_driver.get_scanout_position() is deprecated
    in favor of struct drm_crtc_helper_funcs.get_scanout_position().
    i915 doesn't use CRTC helpers. Instead pass i915's implementation of
    get_scanout_position() to DRM core's
    drm_crtc_vblank_helper_get_vblank_timestamp_internal().
    
    v3:
            * rename dcrtc to _crtc
            * use intel_ prefix for i915_crtc_get_vblank_timestamp()
            * update for drm_crtc_vblank_helper_get_vblank_timestamp_internal()
    v2:
            * use DRM's implementation of get_vblank_timestamp()
            * simplify function names
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-8-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b790896ed809..3bfc777a7a34 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2760,9 +2760,6 @@ static struct drm_driver driver = {
 	.gem_prime_export = i915_gem_prime_export,
 	.gem_prime_import = i915_gem_prime_import,
 
-	.get_vblank_timestamp = drm_calc_vbltimestamp_from_scanoutpos,
-	.get_scanout_position = i915_get_crtc_scanoutpos,
-
 	.dumb_create = i915_gem_dumb_create,
 	.dumb_map_offset = i915_gem_dumb_mmap_offset,
 

commit 00376ccfb2a457fcd7041e2d5740faa8a81ab8cb
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Fri Jan 31 12:34:12 2020 +0300

    drm/i915: conversion to drm_device logging macros when drm_i915_private is present.
    
    Converts various instances of the printk drm logging macros to the
    struct drm_device based logging macros in the drm/i915 folder using the
    following coccinelle script that transforms based on the existence of
    the struct drm_i915_private device pointer:
    @@
    identifier fn, T;
    @@
    
    fn(...) {
    ...
    struct drm_i915_private *T = ...;
    <+...
    (
    -DRM_INFO(
    +drm_info(&T->drm,
    ...)
    |
    -DRM_ERROR(
    +drm_err(&T->drm,
    ...)
    |
    -DRM_WARN(
    +drm_warn(&T->drm,
    ...)
    |
    -DRM_DEBUG_KMS(
    +drm_dbg_kms(&T->drm,
    ...)
    |
    -DRM_DEBUG_DRIVER(
    +drm_dbg(&T->drm,
    ...)
    |
    -DRM_DEBUG_ATOMIC(
    +drm_dbg_atomic(&T->drm,
    ...)
    )
    ...+>
    }
    
    @@
    identifier fn, T;
    @@
    
    fn(...,struct drm_i915_private *T,...) {
    <+...
    (
    -DRM_INFO(
    +drm_info(&T->drm,
    ...)
    |
    -DRM_ERROR(
    +drm_err(&T->drm,
    ...)
    |
    -DRM_WARN(
    +drm_warn(&T->drm,
    ...)
    |
    -DRM_DEBUG_DRIVER(
    +drm_dbg(&T->drm,
    ...)
    |
    -DRM_DEBUG_KMS(
    +drm_dbg_kms(&T->drm,
    ...)
    |
    -DRM_DEBUG_ATOMIC(
    +drm_dbg_atomic(&T->drm,
    ...)
    )
    ...+>
    }
    
    Checkpatch warnings were fixed manually.
    
    Instances of the DRM_DEBUG macro were not converted due to lack of a
    consensus of an analogous struct drm_device based macro.
    
    References: https://lists.freedesktop.org/archives/dri-devel/2020-January/253381.html
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200131093416.28431-2-wambui.karugax@gmail.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 93c4dfacd61f..2227dc91e75c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -152,7 +152,7 @@ static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 	dev_priv->bridge_dev =
 		pci_get_domain_bus_and_slot(domain, 0, PCI_DEVFN(0, 0));
 	if (!dev_priv->bridge_dev) {
-		DRM_ERROR("bridge device not found\n");
+		drm_err(&dev_priv->drm, "bridge device not found\n");
 		return -1;
 	}
 	return 0;
@@ -189,7 +189,7 @@ intel_alloc_mchbar_resource(struct drm_i915_private *dev_priv)
 				     0, pcibios_align_resource,
 				     dev_priv->bridge_dev);
 	if (ret) {
-		DRM_DEBUG_DRIVER("failed bus alloc: %d\n", ret);
+		drm_dbg(&dev_priv->drm, "failed bus alloc: %d\n", ret);
 		dev_priv->mch_res.start = 0;
 		return ret;
 	}
@@ -409,7 +409,7 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 out_free_wq:
 	destroy_workqueue(dev_priv->wq);
 out_err:
-	DRM_ERROR("Failed to allocate workqueues.\n");
+	drm_err(&dev_priv->drm, "Failed to allocate workqueues.\n");
 
 	return -ENOMEM;
 }
@@ -440,7 +440,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	pre |= IS_KBL_REVID(dev_priv, 0, KBL_REVID_A0);
 
 	if (pre) {
-		DRM_ERROR("This is a pre-production stepping. "
+		drm_err(&dev_priv->drm, "This is a pre-production stepping. "
 			  "It may not be fully functional.\n");
 		add_taint(TAINT_MACHINE_CHECK, LOCKDEP_STILL_OK);
 	}
@@ -751,9 +751,10 @@ skl_dram_get_dimm_info(struct drm_i915_private *dev_priv,
 		dimm->ranks = skl_get_dimm_ranks(val);
 	}
 
-	DRM_DEBUG_KMS("CH%u DIMM %c size: %u GB, width: X%u, ranks: %u, 16Gb DIMMs: %s\n",
-		      channel, dimm_name, dimm->size, dimm->width, dimm->ranks,
-		      yesno(skl_is_16gb_dimm(dimm)));
+	drm_dbg_kms(&dev_priv->drm,
+		    "CH%u DIMM %c size: %u GB, width: X%u, ranks: %u, 16Gb DIMMs: %s\n",
+		    channel, dimm_name, dimm->size, dimm->width, dimm->ranks,
+		    yesno(skl_is_16gb_dimm(dimm)));
 }
 
 static int
@@ -767,7 +768,7 @@ skl_dram_get_channel_info(struct drm_i915_private *dev_priv,
 			       channel, 'S', val >> 16);
 
 	if (ch->dimm_l.size == 0 && ch->dimm_s.size == 0) {
-		DRM_DEBUG_KMS("CH%u not populated\n", channel);
+		drm_dbg_kms(&dev_priv->drm, "CH%u not populated\n", channel);
 		return -EINVAL;
 	}
 
@@ -782,8 +783,8 @@ skl_dram_get_channel_info(struct drm_i915_private *dev_priv,
 		skl_is_16gb_dimm(&ch->dimm_l) ||
 		skl_is_16gb_dimm(&ch->dimm_s);
 
-	DRM_DEBUG_KMS("CH%u ranks: %u, 16Gb DIMMs: %s\n",
-		      channel, ch->ranks, yesno(ch->is_16gb_dimm));
+	drm_dbg_kms(&dev_priv->drm, "CH%u ranks: %u, 16Gb DIMMs: %s\n",
+		    channel, ch->ranks, yesno(ch->is_16gb_dimm));
 
 	return 0;
 }
@@ -816,7 +817,8 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		dram_info->num_channels++;
 
 	if (dram_info->num_channels == 0) {
-		DRM_INFO("Number of memory channels is zero\n");
+		drm_info(&dev_priv->drm,
+			 "Number of memory channels is zero\n");
 		return -EINVAL;
 	}
 
@@ -831,7 +833,8 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		dram_info->ranks = max(ch0.ranks, ch1.ranks);
 
 	if (dram_info->ranks == 0) {
-		DRM_INFO("couldn't get memory rank information\n");
+		drm_info(&dev_priv->drm,
+			 "couldn't get memory rank information\n");
 		return -EINVAL;
 	}
 
@@ -839,8 +842,8 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 
 	dram_info->symmetric_memory = intel_is_dram_symmetric(&ch0, &ch1);
 
-	DRM_DEBUG_KMS("Memory configuration is symmetric? %s\n",
-		      yesno(dram_info->symmetric_memory));
+	drm_dbg_kms(&dev_priv->drm, "Memory configuration is symmetric? %s\n",
+		    yesno(dram_info->symmetric_memory));
 	return 0;
 }
 
@@ -874,7 +877,8 @@ skl_get_dram_info(struct drm_i915_private *dev_priv)
 	int ret;
 
 	dram_info->type = skl_get_dram_type(dev_priv);
-	DRM_DEBUG_KMS("DRAM type: %s\n", intel_dram_type_str(dram_info->type));
+	drm_dbg_kms(&dev_priv->drm, "DRAM type: %s\n",
+		    intel_dram_type_str(dram_info->type));
 
 	ret = skl_dram_get_channels_info(dev_priv);
 	if (ret)
@@ -888,7 +892,8 @@ skl_get_dram_info(struct drm_i915_private *dev_priv)
 							mem_freq_khz * 8;
 
 	if (dram_info->bandwidth_kbps == 0) {
-		DRM_INFO("Couldn't get system memory bandwidth\n");
+		drm_info(&dev_priv->drm,
+			 "Couldn't get system memory bandwidth\n");
 		return -EINVAL;
 	}
 
@@ -995,7 +1000,8 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 	dram_info->bandwidth_kbps = (mem_freq_khz * num_active_channels * 4);
 
 	if (dram_info->bandwidth_kbps == 0) {
-		DRM_INFO("Couldn't get system memory bandwidth\n");
+		drm_info(&dev_priv->drm,
+			 "Couldn't get system memory bandwidth\n");
 		return -EINVAL;
 	}
 
@@ -1019,10 +1025,11 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 			    dram_info->type != INTEL_DRAM_UNKNOWN &&
 			    dram_info->type != type);
 
-		DRM_DEBUG_KMS("CH%u DIMM size: %u GB, width: X%u, ranks: %u, type: %s\n",
-			      i - BXT_D_CR_DRP0_DUNIT_START,
-			      dimm.size, dimm.width, dimm.ranks,
-			      intel_dram_type_str(type));
+		drm_dbg_kms(&dev_priv->drm,
+			    "CH%u DIMM size: %u GB, width: X%u, ranks: %u, type: %s\n",
+			    i - BXT_D_CR_DRP0_DUNIT_START,
+			    dimm.size, dimm.width, dimm.ranks,
+			    intel_dram_type_str(type));
 
 		/*
 		 * If any of the channel is single rank channel,
@@ -1040,7 +1047,7 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 
 	if (dram_info->type == INTEL_DRAM_UNKNOWN ||
 	    dram_info->ranks == 0) {
-		DRM_INFO("couldn't get memory information\n");
+		drm_info(&dev_priv->drm, "couldn't get memory information\n");
 		return -EINVAL;
 	}
 
@@ -1071,12 +1078,12 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	if (ret)
 		return;
 
-	DRM_DEBUG_KMS("DRAM bandwidth: %u kBps, channels: %u\n",
-		      dram_info->bandwidth_kbps,
-		      dram_info->num_channels);
+	drm_dbg_kms(&dev_priv->drm, "DRAM bandwidth: %u kBps, channels: %u\n",
+		    dram_info->bandwidth_kbps,
+		    dram_info->num_channels);
 
-	DRM_DEBUG_KMS("DRAM ranks: %u, 16Gb DIMMs: %s\n",
-		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
+	drm_dbg_kms(&dev_priv->drm, "DRAM ranks: %u, 16Gb DIMMs: %s\n",
+		    dram_info->ranks, yesno(dram_info->is_16gb_dimm));
 }
 
 static u32 gen9_edram_size_mb(struct drm_i915_private *dev_priv, u32 cap)
@@ -1186,7 +1193,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
-		DRM_ERROR("failed to enable GGTT\n");
+		drm_err(&dev_priv->drm, "failed to enable GGTT\n");
 		goto err_mem_regions;
 	}
 
@@ -1202,7 +1209,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (IS_GEN(dev_priv, 2)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));
 		if (ret) {
-			DRM_ERROR("failed to set DMA mask\n");
+			drm_err(&dev_priv->drm, "failed to set DMA mask\n");
 
 			goto err_mem_regions;
 		}
@@ -1220,7 +1227,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 
 		if (ret) {
-			DRM_ERROR("failed to set DMA mask\n");
+			drm_err(&dev_priv->drm, "failed to set DMA mask\n");
 
 			goto err_mem_regions;
 		}
@@ -1252,7 +1259,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	 */
 	if (INTEL_GEN(dev_priv) >= 5) {
 		if (pci_enable_msi(pdev) < 0)
-			DRM_DEBUG_DRIVER("can't enable MSI");
+			drm_dbg(&dev_priv->drm, "can't enable MSI");
 	}
 
 	ret = intel_gvt_init(dev_priv);
@@ -1328,7 +1335,8 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		/* Depends on sysfs having been initialized */
 		i915_perf_register(dev_priv);
 	} else
-		DRM_ERROR("Failed to register driver for userspace access!\n");
+		drm_err(&dev_priv->drm,
+			"Failed to register driver for userspace access!\n");
 
 	if (HAS_DISPLAY(dev_priv) && INTEL_DISPLAY_ENABLED(dev_priv)) {
 		/* Must be done after probing outputs */
@@ -1410,11 +1418,12 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 	}
 
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
-		DRM_INFO("DRM_I915_DEBUG enabled\n");
+		drm_info(&dev_priv->drm, "DRM_I915_DEBUG enabled\n");
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
-		DRM_INFO("DRM_I915_DEBUG_GEM enabled\n");
+		drm_info(&dev_priv->drm, "DRM_I915_DEBUG_GEM enabled\n");
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM))
-		DRM_INFO("DRM_I915_DEBUG_RUNTIME_PM enabled\n");
+		drm_info(&dev_priv->drm,
+			 "DRM_I915_DEBUG_RUNTIME_PM enabled\n");
 }
 
 static struct drm_i915_private *
@@ -1771,7 +1780,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 		ret = vlv_suspend_complete(dev_priv);
 
 	if (ret) {
-		DRM_ERROR("Suspend complete failed: %d\n", ret);
+		drm_err(&dev_priv->drm, "Suspend complete failed: %d\n", ret);
 		intel_power_domains_resume(dev_priv);
 
 		goto out;
@@ -1830,7 +1839,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
-		DRM_ERROR("failed to re-enable GGTT\n");
+		drm_err(&dev_priv->drm, "failed to re-enable GGTT\n");
 
 	i915_ggtt_resume(&dev_priv->ggtt);
 	i915_gem_restore_fences(&dev_priv->ggtt);
@@ -1919,7 +1928,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 */
 	ret = pci_set_power_state(pdev, PCI_D0);
 	if (ret) {
-		DRM_ERROR("failed to set PCI D0 power state (%d)\n", ret);
+		drm_err(&dev_priv->drm,
+			"failed to set PCI D0 power state (%d)\n", ret);
 		return ret;
 	}
 
@@ -1946,8 +1956,9 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
-		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
-			  ret);
+		drm_err(&dev_priv->drm,
+			"Resume prepare failed: %d, continuing anyway\n",
+			ret);
 
 	intel_uncore_resume_early(&dev_priv->uncore);
 
@@ -2358,8 +2369,9 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 				      VLV_GFX_CLK_STATUS_BIT,
 				      20);
 	if (err)
-		DRM_ERROR("timeout waiting for GFX clock force-on (%08x)\n",
-			  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
+		drm_err(&dev_priv->drm,
+			"timeout waiting for GFX clock force-on (%08x)\n",
+			I915_READ(VLV_GTLC_SURVIVABILITY_REG));
 
 	return err;
 }
@@ -2382,7 +2394,7 @@ static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 
 	err = vlv_wait_for_pw_status(dev_priv, mask, val);
 	if (err)
-		DRM_ERROR("timeout disabling GT waking\n");
+		drm_err(&dev_priv->drm, "timeout disabling GT waking\n");
 
 	return err;
 }
@@ -2404,8 +2416,9 @@ static void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 	 * reset and we are trying to force the machine to sleep.
 	 */
 	if (vlv_wait_for_pw_status(dev_priv, mask, val))
-		DRM_DEBUG_DRIVER("timeout waiting for GT wells to go %s\n",
-				 onoff(wait_for_on));
+		drm_dbg(&dev_priv->drm,
+			"timeout waiting for GT wells to go %s\n",
+			onoff(wait_for_on));
 }
 
 static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
@@ -2413,7 +2426,8 @@ static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
 	if (!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEERR))
 		return;
 
-	DRM_DEBUG_DRIVER("GT register access while GT waking disabled\n");
+	drm_dbg(&dev_priv->drm,
+		"GT register access while GT waking disabled\n");
 	I915_WRITE(VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);
 }
 
@@ -2499,7 +2513,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
-	DRM_DEBUG_KMS("Suspending device\n");
+	drm_dbg_kms(&dev_priv->drm, "Suspending device\n");
 
 	disable_rpm_wakeref_asserts(rpm);
 
@@ -2521,7 +2535,8 @@ static int intel_runtime_suspend(struct device *kdev)
 		ret = vlv_suspend_complete(dev_priv);
 
 	if (ret) {
-		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
+		drm_err(&dev_priv->drm,
+			"Runtime suspend failed, disabling it (%d)\n", ret);
 		intel_uncore_runtime_resume(&dev_priv->uncore);
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
@@ -2539,7 +2554,8 @@ static int intel_runtime_suspend(struct device *kdev)
 	intel_runtime_pm_driver_release(rpm);
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))
-		DRM_ERROR("Unclaimed access detected prior to suspending\n");
+		drm_err(&dev_priv->drm,
+			"Unclaimed access detected prior to suspending\n");
 
 	rpm->suspended = true;
 
@@ -2571,7 +2587,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_poll_init(dev_priv);
 
-	DRM_DEBUG_KMS("Device suspended\n");
+	drm_dbg_kms(&dev_priv->drm, "Device suspended\n");
 	return 0;
 }
 
@@ -2584,7 +2600,7 @@ static int intel_runtime_resume(struct device *kdev)
 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
-	DRM_DEBUG_KMS("Resuming device\n");
+	drm_dbg_kms(&dev_priv->drm, "Resuming device\n");
 
 	drm_WARN_ON_ONCE(&dev_priv->drm, atomic_read(&rpm->wakeref_count));
 	disable_rpm_wakeref_asserts(rpm);
@@ -2592,7 +2608,8 @@ static int intel_runtime_resume(struct device *kdev)
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 	rpm->suspended = false;
 	if (intel_uncore_unclaimed_mmio(&dev_priv->uncore))
-		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
+		drm_dbg(&dev_priv->drm,
+			"Unclaimed access during suspend, bios?\n");
 
 	intel_display_power_resume(dev_priv);
 
@@ -2623,9 +2640,10 @@ static int intel_runtime_resume(struct device *kdev)
 	enable_rpm_wakeref_asserts(rpm);
 
 	if (ret)
-		DRM_ERROR("Runtime resume failed, disabling it (%d)\n", ret);
+		drm_err(&dev_priv->drm,
+			"Runtime resume failed, disabling it (%d)\n", ret);
 	else
-		DRM_DEBUG_KMS("Device resumed\n");
+		drm_dbg_kms(&dev_priv->drm, "Device resumed\n");
 
 	return ret;
 }

commit e986209c67024c7d1e7c4c9f0ac0d75ef9d968f5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 30 18:17:09 2020 +0000

    drm/i915/gt: Rename i915_gem_restore_ggtt_mappings() for its new placement
    
    The i915_ggtt now sits beneath gt/ outside of the auspices of gem/ and
    should be given a fresh name to reflect that. We also want to give it a
    name that reflects its role in the system suspend/resume, with the
    intention of pulling together all the GGTT operations (e.g. restoring
    the fence registers once they are pulled under gt/intel_ggtt_detiler.c)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Rreviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200130181710.2030251-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e9b42e962032..93c4dfacd61f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1719,7 +1719,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_suspend_hw(dev_priv);
 
-	i915_gem_suspend_gtt_mappings(dev_priv);
+	i915_ggtt_suspend(&dev_priv->ggtt);
 
 	i915_save_state(dev_priv);
 
@@ -1832,7 +1832,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
 
-	i915_gem_restore_gtt_mappings(dev_priv);
+	i915_ggtt_resume(&dev_priv->ggtt);
 	i915_gem_restore_fences(&dev_priv->ggtt);
 
 	intel_csr_ucode_resume(dev_priv);

commit 7a2c65dd32b1cfa8bae55250dfdfe3d049e2f336
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 24 12:56:26 2020 +0000

    drm: Release filp before global lock
    
    The file is not part of the global drm resource and can be released
    prior to take the global mutex to drop the open_count (and potentially
    close) the drm device. As the global mutex is indeed global, not only
    within the device but across devices, a slow file release mechanism can
    bottleneck the entire system.
    
    However, inside drm_close_helper() there are a number of dev->driver
    callbacks that take the drm_device as the first parameter... Worryingly
    some of those callbacks may be (implicitly) depending on the global
    mutex.
    
    v2: Drop the debug message for the open-count, it's included with the
    drm_file_free() debug message -- and for good measure make that up as
    reading outside of the mutex.
    
    v3: Separate the calling of the filp cleanup outside of
    drm_global_mutex into a new drm_release_noglobal() hook, so that we can
    phase the transition. drm/savage relies on the global mutex, and there
    may be more, so be cautious.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200124125627.125042-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 59525094d0e3..b790896ed809 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2663,7 +2663,7 @@ const struct dev_pm_ops i915_pm_ops = {
 static const struct file_operations i915_driver_fops = {
 	.owner = THIS_MODULE,
 	.open = drm_open,
-	.release = drm_release,
+	.release = drm_release_noglobal,
 	.unlocked_ioctl = drm_ioctl,
 	.mmap = i915_gem_mmap,
 	.poll = drm_poll,

commit 48a1b8d4af01abd38e51cef205a0f2c4deeb092a
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Wed Jan 15 09:14:53 2020 +0530

    drm/i915: Make WARN* drm specific where drm_priv ptr is available
    
    drm specific WARN* calls include device information in the
    backtrace, so we know what device the warnings originate from.
    
    Covert all the calls of WARN* with device specific drm_WARN*
    variants in functions where drm_i915_private struct pointer is readily
    available.
    
    The conversion was done automatically with below coccinelle semantic
    patch. checkpatch errors/warnings are fixed manually.
    
    @rule1@
    identifier func, T;
    @@
    func(...) {
    ...
    struct drm_i915_private *T = ...;
    <+...
    (
    -WARN(
    +drm_WARN(&T->drm,
    ...)
    |
    -WARN_ON(
    +drm_WARN_ON(&T->drm,
    ...)
    |
    -WARN_ONCE(
    +drm_WARN_ONCE(&T->drm,
    ...)
    |
    -WARN_ON_ONCE(
    +drm_WARN_ON_ONCE(&T->drm,
    ...)
    )
    ...+>
    }
    
    @rule2@
    identifier func, T;
    @@
    func(struct drm_i915_private *T,...) {
    <+...
    (
    -WARN(
    +drm_WARN(&T->drm,
    ...)
    |
    -WARN_ON(
    +drm_WARN_ON(&T->drm,
    ...)
    |
    -WARN_ONCE(
    +drm_WARN_ONCE(&T->drm,
    ...)
    |
    -WARN_ON_ONCE(
    +drm_WARN_ON_ONCE(&T->drm,
    ...)
    )
    ...+>
    }
    
    command: ls drivers/gpu/drm/i915/*.c | xargs spatch --sp-file \
                            <script> --linux-spacing --in-place
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200115034455.17658-10-pankaj.laxminarayan.bharadiya@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f7385abdd74b..e9b42e962032 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1015,9 +1015,9 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		bxt_get_dimm_info(&dimm, val);
 		type = bxt_get_dimm_type(val);
 
-		WARN_ON(type != INTEL_DRAM_UNKNOWN &&
-			dram_info->type != INTEL_DRAM_UNKNOWN &&
-			dram_info->type != type);
+		drm_WARN_ON(&dev_priv->drm, type != INTEL_DRAM_UNKNOWN &&
+			    dram_info->type != INTEL_DRAM_UNKNOWN &&
+			    dram_info->type != type);
 
 		DRM_DEBUG_KMS("CH%u DIMM size: %u GB, width: X%u, ranks: %u, type: %s\n",
 			      i - BXT_D_CR_DRP0_DUNIT_START,
@@ -1805,8 +1805,8 @@ int i915_suspend_switcheroo(struct drm_i915_private *i915, pm_message_t state)
 {
 	int error;
 
-	if (WARN_ON_ONCE(state.event != PM_EVENT_SUSPEND &&
-			 state.event != PM_EVENT_FREEZE))
+	if (drm_WARN_ON_ONCE(&i915->drm, state.event != PM_EVENT_SUSPEND &&
+			     state.event != PM_EVENT_FREEZE))
 		return -EINVAL;
 
 	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
@@ -2429,7 +2429,8 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	vlv_wait_for_gt_wells(dev_priv, false);
 
 	mask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;
-	WARN_ON((I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);
+	drm_WARN_ON(&dev_priv->drm,
+		    (I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);
 
 	vlv_check_no_gt_access(dev_priv);
 
@@ -2495,7 +2496,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 
-	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
+	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
 	DRM_DEBUG_KMS("Suspending device\n");
@@ -2580,12 +2581,12 @@ static int intel_runtime_resume(struct device *kdev)
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 
-	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
+	if (drm_WARN_ON_ONCE(&dev_priv->drm, !HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
-	WARN_ON_ONCE(atomic_read(&rpm->wakeref_count));
+	drm_WARN_ON_ONCE(&dev_priv->drm, atomic_read(&rpm->wakeref_count));
 	disable_rpm_wakeref_asserts(rpm);
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);

commit ec027b33c8bb164430224ce1f5cb733036b20d3f
Merge: 6251215fe56c a566696cf9f2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jan 9 17:19:12 2020 +0200

    Merge drm/drm-next into drm-intel-next-queued
    
    Sync with drm-next to get the new logging macros, among other things.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 640b50fa8c349135cb97d7430b8f8f0f87e56047
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Dec 28 11:12:55 2019 +0000

    drm/i915: Restore very early GPU reset
    
    In commit d03b224f4252 ("drm/i915/gt: Apply sanitiization just before
    resume") the GT sanitization was pulled into the resume path as we need
    to know the backend in order to do a full reset prior to resume.
    However, it is still imperative that we scrub existing GPU state before
    clobbering in our early setup, so restore a minimal GPU reset at the
    start of our init sequence.
    
    Fixes: d03b224f4252 ("drm/i915/gt: Apply sanitiization just before resume")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191228111255.3086901-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5e6e86c3fdca..fde5487925a2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -469,6 +469,12 @@ static void vlv_free_s0ix_state(struct drm_i915_private *i915)
 	i915->vlv_s0ix_state = NULL;
 }
 
+static void sanitize_gpu(struct drm_i915_private *i915)
+{
+	if (!INTEL_INFO(i915)->gpu_reset_clobbers_display)
+		__intel_gt_reset(&i915->gt, ALL_ENGINES);
+}
+
 /**
  * i915_driver_early_probe - setup state not requiring device access
  * @dev_priv: device private
@@ -602,6 +608,9 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_uncore;
 
+	/* As early as possible, scrub existing GPU state before clobbering */
+	sanitize_gpu(dev_priv);
+
 	return 0;
 
 err_uncore:
@@ -1817,6 +1826,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
+	sanitize_gpu(dev_priv);
+
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");

commit 3ae3271443b337c1cd421a9b73d51c5c2de52977
Merge: 5f773e551a3b 3446c63a0f2a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Dec 27 15:25:04 2019 +1000

    Merge tag 'drm-intel-next-2019-12-23' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    i915 features for v5.6:
    
    - Separate hardware and uapi state (Maarten)
    
    - Expose a number of sprite and plane formats (Ville)
    
    - DDC symlink in HDMI connector sysfs directory (Andrzej Pietrasiewicz)
    
    - Improve obj->mm.lock nesting lock annotation (Daniel)
      (Includes lockdep changes)
    
    - Selftest improvements across the board (Chris)
    
    - ICL/TGL VDSC support on DSI (Jani, Vandita)
    
    - TGL DSB fixes (Animesh, Lucas, Tvrtko)
    
    - VBT parsing improvements and fixes (Lucas, Matt, José, Jani, Dan Carpenter)
    
    - Fix LPSS vs. PMIC PWM backlight use on BYT/CHT (Hans)
      (Includes ACPI+MFD changes)
    
    - Display state, crtc, plane code refactoring (Ville)
    
    - Set opregion chpd value to indicate the driver handles hotplug (Hans de Goede)
    
    - DSI updates and fixes, TGL pipe D support, port mapping (José, Jani, Vandita)
    
    - Make HDCP 2.2 support cover CFL (Juston Li)
    
    - Fix CML PCI IDs and ULT (Shawn Lee)
    
    - CMP-V PCH fix (Imre)
    
    - TGL: Add another TGL PCH ID (James)
    
    - EHL/JSL: Add new PCI IDs (James)
    
    - Rename pipe update tracepoints (Ville)
    
    - Fix FBC on GLK+ (Ville)
    
    - GuC fixes and improvements (Daniele, Don Hiatt, Stuart Summers, Matthew Brost)
    
    - Display debugfs improvements (Ville)
    
    - Hotplug/irq fixes (Matt)
    
    - PSR fixes and improvements (José)
    
    - DRM_I915_GEM_MMAP_OFFSET ioctl (Abdiel)
    
    - Static analysis fixes (Colin Ian King)
    
    - Register sysctl path globally (Venkata Sandeep Dhanalakota)
    
    - Introduce new macros for tracing (Venkata Sandeep Dhanalakota)
    
    - Migrate gt towards intel_uncore_read/write (Andi)
    
    - Add rps frequency translation helpers (Andi)
    
    - Fix TGL transcoder clock off sequence (José)
    
    - Fix TGL port A audio (Kai Vehmanen)
    
    - TGL render decompression (DK)
    
    - GEM/GT improvements and fixes across the board (Chris)
    
    - Couple of backmerges (Jani)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Tue 24 Dec 2019 03:20:48 AM AEST
    # gpg:                using RSA key D398079D26ABEE6F
    # gpg: Good signature from "Jani Nikula <jani.nikula@intel.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 1565 A65B 77B0 632E 1124  E59C D398 079D 26AB EE6F
    
    # Conflicts:
    #       drivers/gpu/drm/i915/display/intel_fbc.c
    #       drivers/gpu/drm/i915/gt/intel_lrc.c
    #       drivers/gpu/drm/i915/i915_gem.c
    From: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/87lfr3rkry.fsf@intel.com

commit d03b224f425295ba17e5a6f29713da310e9a0d72
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Dec 26 11:18:34 2019 +0000

    drm/i915/gt: Apply sanitiization just before resume
    
    Bring sanitization completely underneath the umbrella of intel_gt, and
    perform it exclusively after suspend and before the next resume.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191226111834.2545953-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 01bbeb1c1841..5e6e86c3fdca 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1817,8 +1817,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
-	intel_gt_sanitize(&dev_priv->gt, true);
-
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");

commit e26b6d4341476f6944f57bb78fffcdf332c5948b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Dec 22 12:07:52 2019 +0000

    drm/i915/gt: Pull GT initialisation under intel_gt_init()
    
    Begin pulling the GT setup underneath a single GT umbrella; let intel_gt
    take ownership of its engines! As hinted, the complication is the
    lifetime of the probed engine versus the active lifetime of the GT
    backends. We need to detect the engine layout early and keep it until
    the end so that we can sanitize state on takeover and release.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Acked-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191222120752.1368352-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1234bd64db2f..01bbeb1c1841 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -619,7 +619,6 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_mmio_release(struct drm_i915_private *dev_priv)
 {
-	intel_engines_cleanup(&dev_priv->gt);
 	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini_mmio(&dev_priv->uncore);
 	pci_dev_put(dev_priv->bridge_dev);

commit 6c56e8adc0011b3bc01b6b2bab7e41d5ecb43c0f
Merge: d1eef1c61974 2156873f08c7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 17 13:57:54 2019 +0100

    Merge tag 'drm-misc-next-2019-12-16' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.6:
    
    UAPI Changes:
    - Add support for DMA-BUF HEAPS.
    
    Cross-subsystem Changes:
    - mipi dsi definition updates, pulled into drm-intel as well.
    - Add lockdep annotations for dma_resv vs mmap_sem and fs_reclaim.
    - Remove support for dma-buf kmap/kunmap.
    - Constify fb_ops in all fbdev drivers, including drm drivers and drm-core, and media as well.
    
    Core Changes:
    - Small cleanups to ttm.
    - Fix SCDC definition.
    - Assorted cleanups to core.
    - Add todo to remove load/unload hooks, and use generic fbdev emulation.
    - Assorted documentation updates.
    - Use blocking ww lock in ttm fault handler.
    - Remove drm_fb_helper_fbdev_setup/teardown.
    - Warning fixes with W=1 for atomic.
    - Use drm_debug_enabled() instead of drm_debug flag testing in various drivers.
    - Fallback to nontiled mode in fbdev emulation when not all tiles are present. (Later on reverted)
    - Various kconfig indentation fixes in core and drivers.
    - Fix freeing transactions in dp-mst correctly.
    - Sean Paul is steping down as core maintainer. :-(
    - Add lockdep annotations for atomic locks vs dma-resv.
    - Prevent use-after-free for a bad job in drm_scheduler.
    - Fill out all block sizes in the P01x and P210 definitions.
    - Avoid division by zero in drm/rect, and fix bounds.
    - Add drm/rect selftests.
    - Add aspect ratio and alternate clocks for HDMI 4k modes.
    - Add todo for drm_framebuffer_funcs and fb_create cleanup.
    - Drop DRM_AUTH for prime import/export ioctls.
    - Clear DP-MST payload id tables downstream when initializating.
    - Fix for DSC throughput definition.
    - Add extra FEC definitions.
    - Fix fake offset in drm_gem_object_funs.mmap.
    - Stop using encoder->bridge in core directly
    - Handle bridge chaining slightly better.
    - Add backlight support to drm/panel, and use it in many panel drivers.
    - Increase max number of y420 modes from 128 to 256, as preparation to add the new modes.
    
    Driver Changes:
    - Small fixes all over.
    - Fix documentation in vkms.
    - Fix mmap_sem vs dma_resv in nouveau.
    - Small cleanup in komeda.
    - Add page flip support in gma500 for psb/cdv.
    - Add ddc symlink in the connector sysfs directory for many drivers.
    - Add support for analogic an6345, and fix small bugs in it.
    - Add atomic modesetting support to ast.
    - Fix radeon fault handler VMA race.
    - Switch udl to use generic shmem helpers.
    - Unconditional vblank handling for mcde.
    - Miscellaneous fixes to mcde.
    - Tweak debug output from komeda using debugfs.
    - Add gamma and color transform support to komeda for DOU-IPS.
    - Add support for sony acx424AKP panel.
    - Various small cleanups to gma500.
    - Use generic fbdev emulation in udl, and replace udl_framebuffer with generic implementation.
    - Add support for Logic PD Type 28 panel.
    - Use drm_panel_* wrapper functions in exynos/tegra/msm.
    - Add devicetree bindings for generic DSI panels.
    - Don't include drm_pci.h directly in many drivers.
    - Add support for begin/end_cpu_access in udmabuf.
    - Stop using drm_get_pci_dev in gma500 and mga200.
    - Fixes to UDL damage handling, and use dma_buf_begin/end_cpu_access.
    - Add devfreq thermal support to panfrost.
    - Fix hotplug with daisy chained monitors by removing VCPI when disabling topology manager.
    - meson: Add support for OSD1 plane AFBC commit.
    - Stop displaying garbage when toggling ast primary plane on/off.
    - More cleanups and fixes to UDL.
    - Add D32 suport to komeda.
    - Remove globle copy of drm_dev in gma500.
    - Add support for Boe Himax8279d MIPI-DSI LCD panel.
    - Add support for ingenic JZ4770 panel.
    - Small null pointer deference fix in ingenic.
    - Remove support for the special tfp420 driver, as there is a generic way to do it.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ba73535a-9334-5302-2e1f-5208bd7390bd@linux.intel.com

commit 7240497850f76e698e27aca66664cd7ca4f1d5ff
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Dec 7 18:29:37 2019 +0000

    drm/i915: Flesh out device_info pretty printer
    
    Include all the number fields for describing the GT, as well as the
    current boolean flags, primarily for inclusion in error states.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207182937.2583002-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5d7e11927729..1234bd64db2f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1397,8 +1397,8 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 					     INTEL_INFO(dev_priv)->platform),
 			   INTEL_GEN(dev_priv));
 
-		intel_device_info_dump_flags(INTEL_INFO(dev_priv), &p);
-		intel_device_info_dump_runtime(RUNTIME_INFO(dev_priv), &p);
+		intel_device_info_print_static(INTEL_INFO(dev_priv), &p);
+		intel_device_info_print_runtime(RUNTIME_INFO(dev_priv), &p);
 	}
 
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))

commit cc662126b4134e25fcfb6cad480de0fa95a4d3d8
Author: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
Date:   Wed Dec 4 12:00:32 2019 +0000

    drm/i915: Introduce DRM_I915_GEM_MMAP_OFFSET
    
    This is really just an alias of mmap_gtt. The 'mmap offset' nomenclature
    comes from the value returned by this ioctl which is the offset into the
    device fd which userpace uses with mmap(2).
    
    mmap_gtt was our initial mmap_offset implementation, this extends
    our CPU mmap support to allow additional fault handlers that depends on
    the object's backing pages.
    
    Note that we multiplex mmap_gtt and mmap_offset through the same ioctl,
    and use the zero extending behaviour of drm to differentiate between
    them, when we inspect the flags.
    
    To support multiple mmap types on an object we need to support multiple
    mmap_offsets for an object (each offset in the global device address
    space corresponding to a unique instance of the object for a file + mmap
    type). As we drop the simplified drm core idea of a single mmap_offset,
    we need to provide replacement hooks for the dumb mmap interface as
    well.
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/1675
    Testcase: igt/gem_mmap_offset
    Signed-off-by: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204120032.3682839-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 018914ba2005..5d7e11927729 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,6 +61,7 @@
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
+#include "gem/i915_gem_mman.h"
 #include "gt/intel_gt.h"
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_rc6.h"
@@ -2660,18 +2661,12 @@ const struct dev_pm_ops i915_pm_ops = {
 	.runtime_resume = intel_runtime_resume,
 };
 
-static const struct vm_operations_struct i915_gem_vm_ops = {
-	.fault = i915_gem_fault,
-	.open = drm_gem_vm_open,
-	.close = drm_gem_vm_close,
-};
-
 static const struct file_operations i915_driver_fops = {
 	.owner = THIS_MODULE,
 	.open = drm_open,
 	.release = drm_release,
 	.unlocked_ioctl = drm_ioctl,
-	.mmap = drm_gem_mmap,
+	.mmap = i915_gem_mmap,
 	.poll = drm_poll,
 	.read = drm_read,
 	.compat_ioctl = i915_compat_ioctl,
@@ -2718,7 +2713,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_PREAD, i915_gem_pread_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_PWRITE, i915_gem_pwrite_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP, i915_gem_mmap_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP_GTT, i915_gem_mmap_gtt_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP_OFFSET, i915_gem_mmap_offset_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SET_DOMAIN, i915_gem_set_domain_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SW_FINISH, i915_gem_sw_finish_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling_ioctl, DRM_RENDER_ALLOW),
@@ -2760,7 +2755,6 @@ static struct drm_driver driver = {
 
 	.gem_close_object = i915_gem_close_object,
 	.gem_free_object_unlocked = i915_gem_free_object,
-	.gem_vm_ops = &i915_gem_vm_ops,
 
 	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
@@ -2771,7 +2765,8 @@ static struct drm_driver driver = {
 	.get_scanout_position = i915_get_crtc_scanoutpos,
 
 	.dumb_create = i915_gem_dumb_create,
-	.dumb_map_offset = i915_gem_mmap_gtt,
+	.dumb_map_offset = i915_gem_dumb_mmap_offset,
+
 	.ioctls = i915_ioctls,
 	.num_ioctls = ARRAY_SIZE(i915_ioctls),
 	.fops = &i915_driver_fops,

commit 65f6d12c6b0b610c92d6a2c3d964ff2943ac8fbf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Dec 2 11:08:36 2019 +0000

    drm/i915/gt: Simplify rc6 w/a application
    
    Quite simply we only need to check for prior corruption on enabling rc6
    on module load and resume, so by hooking into the common entry points.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191202110836.2342685-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aa1d9e25f934..018914ba2005 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1817,8 +1817,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
-	intel_rc6_ctx_wa_resume(&dev_priv->gt.rc6);
-
 	intel_gt_sanitize(&dev_priv->gt, true);
 
 	ret = i915_ggtt_enable_hw(dev_priv);

commit a6ed68d6468bd5a3da78a103344ded1435fed57a
Merge: 8c39f71ee201 acc61b892936
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 17:45:48 2019 -0800

    Merge tag 'drm-next-2019-11-27' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "Lots of stuff in here, though it hasn't been too insane this merge
      apart from dealing with the security fun.
    
      uapi:
       - export different colorspace properties on DP vs HDMI
       - new fourcc for ARM 16x16 block format
       - syncobj: allow querying last submitted timeline value
       - DRM_FORMAT_BIG_ENDIAN defined as unsigned
    
      core:
       - allow using gem vma manager in ttm
       - connector/encoder/bridge doc fixes
       - allow more than 3 encoders for a connector
       - displayport mst suspend/resume reprobing support
       - vram lazy unmapping, uniform vram mm and gem vram
       - edid cleanups + AVI informframe bar info
       - displayport helpers - dpcd parser added
    
      dp_cec:
       - Allow a connector to be associated with a cec device
    
      ttm:
       - pipelining with no_gpu_wait fix
       - always keep BOs on the LRU
    
      sched:
       - allow free_job routine to sleep
    
      i915:
       - Block userptr from mappable GTT
       - i915 perf uapi versioning
       - OA stream dynamic reconfiguration
       - make context persistence optional
       - introduce DRM_I915_UNSTABLE Kconfig
       - add fake lmem testing under unstable
       - BT.2020 support for DP MSA
       - struct mutex elimination
       - Tigerlake display/PLL/power management improvements
       - Jasper Lake PCH support
       - refactor PMU for multiple GPUs
       - Icelake firmware update
       - Split out vga + switcheroo code
    
      amdgpu:
       - implement dma-buf import/export without helpers
       - vega20 RAS enablement
       - DC i2c over aux fixes
       - renoir GPU reset
       - DC HDCP support
       - BACO support for CI/VI asics
       - MSI-X support
       - Arcturus EEPROM support
       - Arcturus VCN encode support
       - VCN dynamic powergating on RV/RV2
    
      amdkfd:
       - add navi12/14/renoir support to kfd
    
      radeon:
       - SI dpm fix ported from amdgpu
       - fix bad DMA on ppc platforms
    
      gma500:
       - memory leak fixes
    
      qxl:
       - convert to new gem mmap
    
      exynos:
       - build warning fix
    
      komeda:
       - add aclk sysfs attribute
    
      v3d:
       - userspace cleanup uapi change
    
      i810:
       - fix for underflow in dispatch ioctls
    
      ast:
       - refactor show_cursor
    
      mgag200:
       - refactor show_cursor
    
      arcgpu:
       - encoder finding improvements
    
      mediatek:
       - mipi_tx, dsi and partial crtc support for MT8183 SoC
       - rotation support
    
      meson:
       - add suspend/resume support
    
      omap:
       - misc refactors
    
      tegra:
       - DisplayPort support for Tegra 210, 186 and 194.
       - IOMMU-backed DMA API fixes
    
      panfrost:
       - fix lockdep issue
       - simplify devfreq integration
    
      rcar-du:
       - R8A774B1 SoC support
       - fixes for H2 ES2.0
    
      sun4i:
       - vcc-dsi regulator support
    
      virtio-gpu:
       - vmexit vs spinlock fix
       - move to gem shmem helpers
       - handle large command buffers with cma"
    
    * tag 'drm-next-2019-11-27' of git://anongit.freedesktop.org/drm/drm: (1855 commits)
      drm/amdgpu: invalidate mmhub semaphore workaround in gmc9/gmc10
      drm/amdgpu: initialize vm_inv_eng0_sem for gfxhub and mmhub
      drm/amd/amdgpu/sriov skip RLCG s/r list for arcturus VF.
      drm/amd/amdgpu/sriov temporarily skip ras,dtm,hdcp for arcturus VF
      drm/amdgpu/gfx10: re-init clear state buffer after gpu reset
      merge fix for "ftrace: Rework event_create_dir()"
      drm/amdgpu: Update Arcturus golden registers
      drm/amdgpu/gfx10: fix out-of-bound mqd_backup array access
      drm/amdgpu/gfx10: explicitly wait for cp idle after halt/unhalt
      Revert "drm/amd/display: enable S/G for RAVEN chip"
      drm/amdgpu: disable gfxoff on original raven
      drm/amdgpu: remove experimental flag for Navi14
      drm/amdgpu: disable gfxoff when using register read interface
      drm/amdgpu/powerplay: properly set PP_GFXOFF_MASK (v2)
      drm/amdgpu: fix bad DMA from INTERRUPT_CNTL2
      drm/radeon: fix bad DMA from INTERRUPT_CNTL2
      drm/amd/display: Fix debugfs on MST connectors
      drm/amdgpu/nv: add asic func for fetching vbios from rom directly
      drm/amdgpu: put flush_delayed_work at first
      drm/amdgpu/vcn2.5: fix the enc loop with hw fini
      ...

commit e7862f476e6f78ebf715d6090e922cd91b1a194c
Author: Stuart Summers <stuart.summers@intel.com>
Date:   Tue Nov 19 16:45:05 2019 -0800

    Skip MCHBAR queries when display is not available
    
    Platforms without display do not map the MCHBAR MMIO into the GFX
    device BAR. Skip this sequence when display is not available.
    
    Signed-off-by: Stuart Summers <stuart.summers@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191120004505.149516-1-stuart.summers@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fc8286809e62..aa1d9e25f934 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1052,7 +1052,7 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	 */
 	dram_info->is_16gb_dimm = !IS_GEN9_LP(dev_priv);
 
-	if (INTEL_GEN(dev_priv) < 9)
+	if (INTEL_GEN(dev_priv) < 9 || !HAS_DISPLAY(dev_priv))
 		return;
 
 	if (IS_GEN9_LP(dev_priv))

commit 37b49f31e800b563ed7a601816ea4b6fc3c5d165
Merge: b4c0800e4285 07ceccacfb27
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 08:47:34 2019 -0800

    Merge tag 'drm-fixes-2019-11-15' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm fixes from Dave Airlie:
     "Here is this weeks non-intel hw vuln fixes pull. Three drivers, all
      small fixes.
    
      i915:
       - MOCS table fixes for EHL and TGL
       - Update Display's rawclock on resume
       - GVT's dmabuf reference drop fix
    
      amdgpu:
       - Fix a potential crash in firmware parsing
    
      sun4i:
       - One fix to the dotclock dividers range for sun4i"
    
    * tag 'drm-fixes-2019-11-15' of git://anongit.freedesktop.org/drm/drm:
      drm/amdgpu: fix null pointer deref in firmware header printing
      drm/i915/tgl: MOCS table update
      Revert "drm/i915/ehl: Update MOCS table for EHL"
      drm/sun4i: tcon: Set min division of TCON0_DCLK to 1.
      drm/i915: update rawclk also on resume
      drm/i915/gvt: fix dropping obj reference twice

commit e205ceeb253723f4e4bdce619844ed678ae48276
Merge: 1cdc2330e8d3 17cc51390c14
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Nov 15 13:17:39 2019 +0200

    Merge drm/drm-next into drm-intel-next-queued
    
    Backmerge to get dfce90259d74 ("Backmerge i915 security patches from
    commit 'ea0b163b13ff' into drm-next") and thus 100d46bd72ec ("Merge
    Intel Gen8/Gen9 graphics fixes from Jon Bloomfield.").
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit bdbf43d739f4d2379419504747b589b421c67e20
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Oct 28 12:38:15 2019 +0200

    drm/i915: use drm_debug_enabled() to check for debug categories
    
    Allow better abstraction of the drm_debug global variable in the
    future. No functional changes.
    
    Reviewed-by: Eric Engestrom <eric@engestrom.ch>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Sean Paul <sean@poorly.run>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/e94fe4977c5b8cac68556318be81f8e422e973fd.1572258936.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 157ed22052a2..c795fa663bba 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1382,7 +1382,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 
 static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 {
-	if (drm_debug & DRM_UT_DRIVER) {
+	if (drm_debug_enabled(DRM_UT_DRIVER)) {
 		struct drm_printer p = drm_debug_printer("i915 device info:");
 
 		drm_printf(&p, "pciid=0x%04x rev=0x%02x platform=%s (subplatform=0x%x) gen=%i\n",

commit 2248a28384fedb84d1d068383bbec113cc4ce0fe
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 17 16:38:31 2019 +0300

    drm/i915/gen8+: Add RC6 CTX corruption WA
    
    In some circumstances the RC6 context can get corrupted. We can detect
    this and take the required action, that is disable RC6 and runtime PM.
    The HW recovers from the corrupted state after a system suspend/resume
    cycle, so detect the recovery and re-enable RC6 and runtime PM.
    
    v2: rebase (Mika)
    v3:
    - Move intel_suspend_gt_powersave() to the end of the GEM suspend
      sequence.
    - Add commit message.
    v4:
    - Rebased on intel_uncore_forcewake_put(i915->uncore, ...) API
      change.
    v5:
    - Rebased on latest upstream gt_pm refactoring.
    v6:
    - s/i915_rc6_/intel_rc6_/
    - Don't return a value from i915_rc6_ctx_wa_check().
    v7:
    - Rebased on latest gt rc6 refactoring.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    [airlied: pull this later version of this patch into drm-next
    to make resolving the conflict mess easier.]
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ccb5b566795f..87e05ca3646a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -63,6 +63,7 @@
 #include "gem/i915_gem_ioctls.h"
 #include "gt/intel_gt.h"
 #include "gt/intel_gt_pm.h"
+#include "gt/intel_rc6.h"
 
 #include "i915_debugfs.h"
 #include "i915_drv.h"
@@ -1819,6 +1820,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
+	intel_rc6_ctx_wa_resume(&dev_priv->gt.rc6);
+
 	intel_gt_sanitize(&dev_priv->gt, true);
 
 	ret = i915_ggtt_enable_hw(dev_priv);

commit 2f216a8507153578efc309c821528a6b81628cd2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Nov 1 16:20:24 2019 +0200

    drm/i915: update rawclk also on resume
    
    Since CNP it's possible for rawclk to have two different values, 19.2
    and 24 MHz. If the value indicated by SFUSE_STRAP register is different
    from the power on default for PCH_RAWCLK_FREQ, we'll end up having a
    mismatch between the rawclk hardware and software states after
    suspend/resume. On previous platforms this used to work by accident,
    because the power on defaults worked just fine.
    
    Update the rawclk also on resume. The natural place to do this would be
    intel_modeset_init_hw(), however VLV/CHV need it done before
    intel_power_domains_init_hw(). Thus put it there even if it feels
    slightly out of place.
    
    v2: Call intel_update_rawclck() in intel_power_domains_init_hw() for all
        platforms (Ville).
    
    Reported-by: Shawn Lee <shawn.c.lee@intel.com>
    Cc: Shawn Lee <shawn.c.lee@intel.com>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Shawn Lee <shawn.c.lee@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101142024.13877-1-jani.nikula@intel.com
    (cherry picked from commit 59ed05ccdded5eb18ce012eff3d01798ac8535fa)
    Cc: <stable@vger.kernel.org> # v4.15+
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bb6f86c7067a..916e6ca86a1d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -364,9 +364,6 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 	if (ret)
 		goto cleanup_vga_client;
 
-	/* must happen before intel_power_domains_init_hw() on VLV/CHV */
-	intel_update_rawclk(dev_priv);
-
 	intel_power_domains_init_hw(dev_priv, false);
 
 	intel_csr_ucode_init(dev_priv);

commit a8c9a7f52ec5a4b36ce183efd5fda4e4fd90ec45
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Nov 7 21:39:29 2019 +0000

    drm/i915/selftests: Complete transition to a real struct file mock
    
    Since drm provided us with a real struct file we can use for our
    anonymous internal clients (mock_file), complete our transition to using
    that as the primary interface (and not the mocked up struct drm_file we
    previous were using).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191107213929.23286-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82e4e6bf08c3..64f8ba3449ed 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2781,7 +2781,3 @@ static struct drm_driver driver = {
 	.minor = DRIVER_MINOR,
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
-
-#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
-#include "selftests/mock_drm.c"
-#endif

commit 7e34f4e4aad3fd34c02b294a3cf2321adf5b4438
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Jul 9 18:24:27 2018 +0300

    drm/i915/gen8+: Add RC6 CTX corruption WA
    
    In some circumstances the RC6 context can get corrupted. We can detect
    this and take the required action, that is disable RC6 and runtime PM.
    The HW recovers from the corrupted state after a system suspend/resume
    cycle, so detect the recovery and re-enable RC6 and runtime PM.
    
    v2: rebase (Mika)
    v3:
    - Move intel_suspend_gt_powersave() to the end of the GEM suspend
      sequence.
    - Add commit message.
    v4:
    - Rebased on intel_uncore_forcewake_put(i915->uncore, ...) API
      change.
    v5: rebased on gem/gt split (Mika)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bb6f86c7067a..fe4d7cabfdf1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1850,6 +1850,8 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	i915_gem_suspend_late(dev_priv);
 
+	i915_rc6_ctx_wa_suspend(dev_priv);
+
 	intel_uncore_suspend(&dev_priv->uncore);
 
 	intel_power_domains_suspend(dev_priv,
@@ -2053,6 +2055,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
+	i915_rc6_ctx_wa_resume(dev_priv);
+
 	intel_gt_sanitize(&dev_priv->gt, true);
 
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);

commit fd6fe087ca470439d554185a2f6bd4d8749bb385
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 1 14:10:06 2019 +0000

    drm/i915/gt: Call intel_gt_sanitize() directly
    
    Assume all responsibility for operating on the HW to sanitize the GT
    state upon load/resume in intel_gt_sanitize() itself.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101141009.15581-1-chris@chris-wilson.co.uk
    (cherry picked from commit 797a615357ac0feb79c9ce41f5eaac3eb738a51f)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3340485c12e3..ccb5b566795f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,8 +603,6 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_uncore;
 
-	i915_gem_init_mmio(dev_priv);
-
 	return 0;
 
 err_uncore:
@@ -1177,7 +1175,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_ggtt;
 
-	intel_gt_init_hw_early(dev_priv);
+	intel_gt_init_hw_early(&dev_priv->gt, &dev_priv->ggtt);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
@@ -1821,7 +1819,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
-	i915_gem_sanitize(dev_priv);
+	intel_gt_sanitize(&dev_priv->gt, true);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
@@ -1952,8 +1950,6 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
-	intel_gt_sanitize(&dev_priv->gt, true);
-
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	return ret;

commit 59ed05ccdded5eb18ce012eff3d01798ac8535fa
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Nov 1 16:20:24 2019 +0200

    drm/i915: update rawclk also on resume
    
    Since CNP it's possible for rawclk to have two different values, 19.2
    and 24 MHz. If the value indicated by SFUSE_STRAP register is different
    from the power on default for PCH_RAWCLK_FREQ, we'll end up having a
    mismatch between the rawclk hardware and software states after
    suspend/resume. On previous platforms this used to work by accident,
    because the power on defaults worked just fine.
    
    Update the rawclk also on resume. The natural place to do this would be
    intel_modeset_init_hw(), however VLV/CHV need it done before
    intel_power_domains_init_hw(). Thus put it there even if it feels
    slightly out of place.
    
    v2: Call intel_update_rawclck() in intel_power_domains_init_hw() for all
        platforms (Ville).
    
    Reported-by: Shawn Lee <shawn.c.lee@intel.com>
    Cc: Shawn Lee <shawn.c.lee@intel.com>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Shawn Lee <shawn.c.lee@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101142024.13877-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ccb5b566795f..82e4e6bf08c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -296,9 +296,6 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	if (ret)
 		goto cleanup_vga_client;
 
-	/* must happen before intel_power_domains_init_hw() on VLV/CHV */
-	intel_update_rawclk(i915);
-
 	intel_power_domains_init_hw(i915, false);
 
 	intel_csr_ucode_init(i915);

commit 797a615357ac0feb79c9ce41f5eaac3eb738a51f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 1 14:10:06 2019 +0000

    drm/i915/gt: Call intel_gt_sanitize() directly
    
    Assume all responsibility for operating on the HW to sanitize the GT
    state upon load/resume in intel_gt_sanitize() itself.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101141009.15581-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3340485c12e3..ccb5b566795f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,8 +603,6 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_uncore;
 
-	i915_gem_init_mmio(dev_priv);
-
 	return 0;
 
 err_uncore:
@@ -1177,7 +1175,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_ggtt;
 
-	intel_gt_init_hw_early(dev_priv);
+	intel_gt_init_hw_early(&dev_priv->gt, &dev_priv->ggtt);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
@@ -1821,7 +1819,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
-	i915_gem_sanitize(dev_priv);
+	intel_gt_sanitize(&dev_priv->gt, true);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
@@ -1952,8 +1950,6 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
-	intel_gt_sanitize(&dev_priv->gt, true);
-
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	return ret;

commit 292a27b0a807615f4c140b990802f109c72d6c8c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 1 09:51:47 2019 +0000

    drm/i915/lmem: Check against i915_selftest only under CONFIG_SELFTEST
    
    The i915_selftest module parameters only exist when
    CONFIG_DRM_I915_SELFTEST is set.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101095147.9769-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 480e2054f628..3340485c12e3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1487,6 +1487,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 * Check if we support fake LMEM -- for now we only unleash this for
 	 * the live selftests(test-and-exit).
 	 */
+#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
 	if (IS_ENABLED(CONFIG_DRM_I915_UNSTABLE_FAKE_LMEM)) {
 		if (INTEL_GEN(dev_priv) >= 9 && i915_selftest.live < 0 &&
 		    i915_modparams.fake_lmem_start) {
@@ -1497,6 +1498,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			GEM_BUG_ON(!IS_DGFX(dev_priv));
 		}
 	}
+#endif
 
 	ret = pci_enable_device(pdev);
 	if (ret)

commit 1629224324b6cab6f7f96e839c9b57b74cfd8349
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Wed Oct 30 17:33:20 2019 +0000

    drm/i915/lmem: add the fake lmem region
    
    Intended for upstream testing so that we can still exercise the LMEM
    plumbing and !i915_ggtt_has_aperture paths. Smoke tested on Skull Canyon
    device. This works by allocating an intel_memory_region for a reserved
    portion of system memory, which we treat like LMEM. For the LMEMBAR we
    steal the aperture and 1:1 it map to the stolen region.
    
    To enable simply set the i915 modparam fake_lmem_start= on the kernel
    cmdline with the start of reserved region(see memmap=). The size of the
    region we can use is determined by the size of the mappable aperture, so
    the size of reserved region should be >= mappable_end. For now we only
    enable for the selftests. Depends on CONFIG_DRM_I915_UNSTABLE being
    enabled.
    
    eg. memmap=2G$16G i915.fake_lmem_start=0x400000000
    
    v2: make fake_lmem_start an i915 modparam
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Cc: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191030173320.8850-1-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 21273b516dbe..480e2054f628 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1483,6 +1483,21 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
 		dev_priv->drm.driver_features &= ~DRIVER_ATOMIC;
 
+	/*
+	 * Check if we support fake LMEM -- for now we only unleash this for
+	 * the live selftests(test-and-exit).
+	 */
+	if (IS_ENABLED(CONFIG_DRM_I915_UNSTABLE_FAKE_LMEM)) {
+		if (INTEL_GEN(dev_priv) >= 9 && i915_selftest.live < 0 &&
+		    i915_modparams.fake_lmem_start) {
+			mkwrite_device_info(dev_priv)->memory_regions =
+				REGION_SMEM | REGION_LMEM | REGION_STOLEN;
+			mkwrite_device_info(dev_priv)->is_dgfx = true;
+			GEM_BUG_ON(!HAS_LMEM(dev_priv));
+			GEM_BUG_ON(!IS_DGFX(dev_priv));
+		}
+	}
+
 	ret = pci_enable_device(pdev);
 	if (ret)
 		goto out_fini;

commit 3fc794f27fec8f020907090fb866602a1c64a73c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Oct 26 21:20:32 2019 +0100

    drm/i915: Split memory_region initialisation into its own file
    
    Pull the memory region bookkeeping into its file. Let's start clean and
    see how long it lasts!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191026202032.4371-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 355526a35d58..21273b516dbe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -76,6 +76,7 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_csr.h"
+#include "intel_memory_region.h"
 #include "intel_pm.h"
 
 static struct drm_driver driver;
@@ -1172,12 +1173,16 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_ggtt;
 
+	ret = intel_memory_regions_hw_probe(dev_priv);
+	if (ret)
+		goto err_ggtt;
+
 	intel_gt_init_hw_early(dev_priv);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to enable GGTT\n");
-		goto err_ggtt;
+		goto err_mem_regions;
 	}
 
 	pci_set_master(pdev);
@@ -1194,7 +1199,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto err_ggtt;
+			goto err_mem_regions;
 		}
 	}
 
@@ -1212,7 +1217,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto err_ggtt;
+			goto err_mem_regions;
 		}
 	}
 
@@ -1264,6 +1269,8 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (pdev->msi_enabled)
 		pci_disable_msi(pdev);
 	pm_qos_remove_request(&dev_priv->pm_qos);
+err_mem_regions:
+	intel_memory_regions_driver_release(dev_priv);
 err_ggtt:
 	i915_ggtt_driver_release(dev_priv);
 err_perf:
@@ -1510,6 +1517,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 out_cleanup_hw:
 	i915_driver_hw_remove(dev_priv);
+	intel_memory_regions_driver_release(dev_priv);
 	i915_ggtt_driver_release(dev_priv);
 out_cleanup_mmio:
 	i915_driver_mmio_release(dev_priv);
@@ -1567,6 +1575,7 @@ static void i915_driver_release(struct drm_device *dev)
 
 	i915_gem_driver_release(dev_priv);
 
+	intel_memory_regions_driver_release(dev_priv);
 	i915_ggtt_driver_release(dev_priv);
 
 	i915_driver_mmio_release(dev_priv);

commit 3e7abf8141935ded77abeb622480bf4a14241ece
Author: Andi Shyti <andi@etezian.org>
Date:   Thu Oct 24 22:16:41 2019 +0100

    drm/i915: Extract GT render power state management
    
    i915_irq.c is large. One reason for this is that has a large chunk of
    the GT render power management stashed away in it. Extract that logic
    out of i915_irq.c and intel_pm.c and put it under one roof.
    
    Based on a patch by Chris Wilson.
    
    Signed-off-by: Andi Shyti <andi.shyti@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191024211642.7688-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 24a3988281d2..355526a35d58 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1794,7 +1794,6 @@ static int i915_drm_resume(struct drm_device *dev)
 	int ret;
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
-	intel_gt_pm_disable(&dev_priv->gt);
 
 	i915_gem_sanitize(dev_priv);
 
@@ -1925,8 +1924,6 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_display_power_resume_early(dev_priv);
 
-	intel_gt_pm_disable(&dev_priv->gt);
-
 	intel_power_domains_resume(dev_priv);
 
 	intel_gt_sanitize(&dev_priv->gt, true);

commit 058179e72e0956a2dfe4927db6cbe5fbfb2406aa
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 23 14:31:08 2019 +0100

    drm/i915/gt: Replace hangcheck by heartbeats
    
    Replace sampling the engine state every so often with a periodic
    heartbeat request to measure the health of an engine. This is coupled
    with the forced-preemption to allow long running requests to survive so
    long as they do not block other users.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Jon Bloomfield <jon.bloomfield@intel.com>
    Reviewed-by: Jon Bloomfield <jon.bloomfield@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191023133108.21401-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5138d1eed306..24a3988281d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1548,10 +1548,7 @@ void i915_driver_remove(struct drm_i915_private *i915)
 
 	i915_driver_modeset_remove(i915);
 
-	/* Free error state after interrupts are fully disabled. */
-	cancel_delayed_work_sync(&i915->gt.hangcheck.work);
 	i915_reset_error_state(i915);
-
 	i915_gem_driver_remove(i915);
 
 	intel_power_domains_driver_remove(i915);

commit b0258bf24252a487a03dfc94aeea72940ad3fe52
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Oct 22 10:47:17 2019 +0100

    drm/i915: Pass intel_gt to intel_engines_cleanup
    
    Engines belong to the GT so make it indicative in the API.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022094726.3001-4-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c4c7caa73f23..5138d1eed306 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -621,7 +621,7 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_mmio_release(struct drm_i915_private *dev_priv)
 {
-	intel_engines_cleanup(dev_priv);
+	intel_engines_cleanup(&dev_priv->gt);
 	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini_mmio(&dev_priv->uncore);
 	pci_dev_put(dev_priv->bridge_dev);

commit adcb52649498d1727da1f9137d3c611dedb0214c
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Oct 22 10:47:15 2019 +0100

    drm/i915: Pass intel_gt to intel_engines_init_mmio
    
    Engines belong to the GT so make it indicative in the API.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022094726.3001-2-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 157ed22052a2..c4c7caa73f23 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -598,7 +598,7 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 
 	intel_uc_init_mmio(&dev_priv->gt.uc);
 
-	ret = intel_engines_init_mmio(dev_priv);
+	ret = intel_engines_init_mmio(&dev_priv->gt);
 	if (ret)
 		goto err_uncore;
 

commit 789fa8746daf8561e8cd0870a66ba7a5bb05fbf7
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Oct 18 12:07:10 2019 +0200

    drm/i915: Restore full symmetry in i915_driver_modeset_probe/remove
    
    Commit 2d6f6f359fd8 ("drm/i915: add i915_driver_modeset_remove()")
    claimed removal of asymmetry in probe() and remove() calls, however, it
    didn't take care of calling intel_irq_uninstall() on driver remove.
    That doesn't hurt as long as we still call it from
    intel_modeset_driver_remove() but in order to have full symmetry we
    should call it again from i915_driver_modeset_remove().
    
    Note that it's safe to call intel_irq_uninstall() twice thanks to
    commit b318b82455bd ("drm/i915: Nuke drm_driver irq vfuncs").  We may
    only want to mention the case we are adding in a related FIXME comment
    provided by that commit.  While being at it, update the name of
    function mentioned as calling it out of sequence as that name has been
    changed meanwhile by commit 78dae1ac35dd ("drm/i915: Propagate
    "_remove" function name suffix down").
    
    Suggested-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/6250061.7lZMOAyebC@jkrzyszt-desk.ger.corp.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b3a92951f671..157ed22052a2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -354,6 +354,8 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 {
 	intel_modeset_driver_remove(i915);
 
+	intel_irq_uninstall(i915);
+
 	intel_bios_driver_remove(i915);
 
 	i915_switcheroo_unregister(i915);

commit 2edb3de9e599e79db4028335df2a64f3ad014b2a
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Oct 10 17:51:23 2019 +0300

    drm/i915: Shrink eDRAM ways/sets arrays
    
    Make the ways/sets arrays static cosnt u8 to shrink things a bit.
    
        text           data     bss     dec     hex filename
    -  23935            629     128   24692    6074 i915_drv.o
    +  23818            629     128   24575    5fff i915_drv.o
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191010145127.7487-1-ville.syrjala@linux.intel.com
    Reviewed-by: Ramalingam C <ramalingam.c@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fd532b8cfdb8..b3a92951f671 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1073,8 +1073,8 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 
 static u32 gen9_edram_size_mb(struct drm_i915_private *dev_priv, u32 cap)
 {
-	const unsigned int ways[8] = { 4, 8, 12, 16, 16, 16, 16, 16 };
-	const unsigned int sets[4] = { 1, 1, 2, 2 };
+	static const u8 ways[8] = { 4, 8, 12, 16, 16, 16, 16, 16 };
+	static const u8 sets[4] = { 1, 1, 2, 2 };
 
 	return EDRAM_NUM_BANKS(cap) *
 		ways[EDRAM_WAYS_IDX(cap)] *

commit e9d4c9245f54cd50b9bdbdf216a9c0d6404ced7b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 16 15:32:33 2019 +0100

    drm/i915: Store i915_ggtt as the backpointer on fence registers
    
    Now that i915_ggtt knows everything about its own paths to perform mmio,
    we can use that as our primary backpointer for individual fence
    registers. This reduces the amount of pointer dancing we have to perform
    on the common paths, but more importantly finishes our fence register
    encapsulation.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191016143234.4075-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9354924576c4..fd532b8cfdb8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1804,7 +1804,7 @@ static int i915_drm_resume(struct drm_device *dev)
 		DRM_ERROR("failed to re-enable GGTT\n");
 
 	i915_gem_restore_gtt_mappings(dev_priv);
-	i915_gem_restore_fences(dev_priv);
+	i915_gem_restore_fences(&dev_priv->ggtt);
 
 	intel_csr_ucode_resume(dev_priv);
 
@@ -2502,7 +2502,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_gt_runtime_resume(&dev_priv->gt);
 
-		i915_gem_restore_fences(dev_priv);
+		i915_gem_restore_fences(&dev_priv->ggtt);
 
 		enable_rpm_wakeref_asserts(rpm);
 
@@ -2582,7 +2582,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	intel_gt_runtime_resume(&dev_priv->gt);
-	i915_gem_restore_fences(dev_priv);
+	i915_gem_restore_fences(&dev_priv->ggtt);
 
 	/*
 	 * On VLV/CHV display interrupts are part of the display

commit 7ed093602e0e1b60a0fc074a9692687e7d2b723d
Merge: 97ea56540ffc 354c2d310082
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 09:30:52 2019 +1000

    Merge tag 'drm-misc-next-2019-10-09-2' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.5:
    
    UAPI Changes:
    -Colorspace: Expose different prop values for DP vs. HDMI (Gwan-gyeong Mun)
    -fourcc: Add DRM_FORMAT_MOD_ARM_16X16_BLOCK_U_INTERLEAVED (Raymond)
    -not_actually: s/ENOTSUPP/EOPNOTSUPP/ in drm_edid and drm_mipi_dbi. This should
        not reach userspace, but adding here to specifically call that out (Daniel)
    -i810: Prevent underflow in dispatch ioctls (Dan)
    -komeda: Add ACLK sysfs attribute (Mihail)
    -v3d: Allow userspace to clean up after render jobs (Iago)
    
    Cross-subsystem Changes:
    -MAINTAINERS:
     -Add Alyssa & Steven as panfrost reviewers (Rob)
     -Add Jernej as DE2 reviewer (Maxime)
     -Add Chen-Yu as Allwinner maintainer (Maxime)
    -staging: Make some stack arrays static const (Colin)
    
    Core Changes:
    -ttm: Allow drivers to specify their vma manager (to use gem mgr) (Gerd)
    -docs: Various fixes in connector/encoder/bridge docs (Daniel, Lyude, Laurent)
    -connector: Allow more than 3 possible encoders for a connector (José)
    -dp_cec: Allow a connector to be associated with a cec device (Dariusz)
    -various: Fix some compile/sparse warnings (Ville)
    -mm: Ensure mm node removals are properly serialised (Chris)
    -panel: Specify the type of panel for drm_panels for later use (Laurent)
    -panel: Use drm_panel_init to init device and funcs (Laurent)
    -mst: Refactors and cleanups in anticipation of suspend/resume support (Lyude)
    -vram:
     -Add lazy unmapping for gem bo's (Thomas)
     -Unify and rationalize vram mm and gem vram (Thomas)
     -Expose vmap and vunmap for gem vram objects (Thomas)
     -Allow objects to be pinned at the top of vram to avoid fragmentation (Thomas)
    
    Driver Changes:
    -various: Include drm_bridge.h instead of relying on drm_crtc.h (Boris)
    -ast/mgag200: Refactor show_cursor(), move cursor to top of video mem (Thomas)
    -komeda:
     -Add error event printing (behind CONFIG) and reg dump support (Lowry)
     -Add suspend/resume support (Lowry)
     -Workaround D71 shadow registers not flushing on disable (Lowry)
    -meson: Add suspend/resume support (Neil)
    -omap: Miscellaneous refactors and improvements (Tomi/Jyri)
    -panfrost/shmem: Silence lockdep by using mutex_trylock (Rob)
    -panfrost: Miscellaneous small fixes (Rob/Steven)
    -sti: Fix warnings (Benjamin/Linus)
    -sun4i:
     -Add vcc-dsi regulator to sun6i_mipi_dsi (Jagan)
     -A few patches to figure out the DRQ/start delay calc on dsi (Jagan/Icenowy)
    -virtio:
     -Add module param to switch resource reuse workaround on/off (Gerd)
     -Avoid calling vmexit while holding spinlock (Gerd)
     -Use gem shmem helpers instead of ttm (Gerd)
     -Accommodate command buffer allocations too big for cma (David)
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Lyude Paul <lyude@redhat.com>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Dariusz Marcinkiewicz <darekm@google.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Raymond Smith <raymond.smith@arm.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Mihail Atanassov <Mihail.Atanassov@arm.com>
    Cc: Lowry Li <Lowry.Li@arm.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
    Cc: Steven Price <steven.price@arm.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Icenowy Zheng <icenowy@aosc.io>
    Cc: Iago Toral Quiroga <itoral@igalia.com>
    Cc: David Riley <davidriley@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Thu 10 Oct 2019 01:00:47 AM AEST
    # gpg:                using RSA key 732C002572DCAF79
    # gpg: Can't check signature: public key not found
    
    # Conflicts:
    #       drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
    #       drivers/gpu/drm/i915/i915_drv.c
    #       drivers/gpu/drm/i915/i915_gem.c
    #       drivers/gpu/drm/i915/i915_gem_gtt.c
    #       drivers/gpu/drm/i915/i915_vma.c
    From: Sean Paul <sean@poorly.run>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191009150825.GA227673@art_vandelay

commit 6c76a93c453643e11a1063906c7c39168dd8d163
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Sep 9 12:00:08 2019 +0100

    drm/i915: Perform GGTT restore much earlier during resume
    
    As soon as we re-enable the various functions within the HW, they may go
    off and read data via a GGTT offset. Hence, if we have not yet restored
    the GGTT PTE before then, they may read and even *write* random locations
    in memory.
    
    Detected by DMAR faults during resume.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Martin Peres <martin.peres@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190909110011.8958-4-chris@chris-wilson.co.uk
    (cherry picked from commit cec5ca08e36fd18d2939b98055346b3b06f56c6c)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 020696726f9e..bb6f86c7067a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1924,6 +1924,11 @@ static int i915_drm_resume(struct drm_device *dev)
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
 
+	mutex_lock(&dev_priv->drm.struct_mutex);
+	i915_gem_restore_gtt_mappings(dev_priv);
+	i915_gem_restore_fences(dev_priv);
+	mutex_unlock(&dev_priv->drm.struct_mutex);
+
 	intel_csr_ucode_resume(dev_priv);
 
 	i915_restore_state(dev_priv);

commit 9bfcf1941302c471e8c8138b6b01f7b84d4f5ba4
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Oct 4 15:20:19 2019 +0300

    drm/i915: move gmbus setup down to intel_modeset_init()
    
    Pair the gmbus setup and teardown in the same layer. This also fixes the
    double gmbus teardown on the i915_driver_modeset_probe() error path.
    
    Move the gmbus setup a bit later in the sequence to make the follow-up
    refactoring easier, and to pinpoint any unexpected consequences of this
    change right here, instead of the later refactoring.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191004122019.12009-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 902a54bb46e0..15abad5c2d62 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -53,7 +53,6 @@
 #include "display/intel_display_types.h"
 #include "display/intel_dp.h"
 #include "display/intel_fbdev.h"
-#include "display/intel_gmbus.h"
 #include "display/intel_hotplug.h"
 #include "display/intel_overlay.h"
 #include "display/intel_pipe_crc.h"
@@ -307,8 +306,6 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	if (ret)
 		goto cleanup_csr;
 
-	intel_gmbus_setup(i915);
-
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
 	ret = intel_modeset_init(i915);
@@ -343,7 +340,6 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	intel_modeset_driver_remove(i915);
 cleanup_irq:
 	intel_irq_uninstall(i915);
-	intel_gmbus_teardown(i915);
 cleanup_csr:
 	intel_csr_ucode_fini(i915);
 	intel_power_domains_driver_remove(i915);

commit 63bf8301aac492d4c5fdf7b0ec42b142c05080e3
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Oct 4 15:20:18 2019 +0300

    drm/i915: split out i915_switcheroo.[ch] from i915_drv.c
    
    Split out code related to vga switcheroo register/unregister and state
    handling from i915_drv.c into new i915_switcheroo.[ch] files.
    
    It's a bit difficult to draw the line how much to move to the new file
    from i915_drv.c, but it seemed to me keeping i915_suspend_switcheroo()
    and i915_resume_switcheroo() in place was the cleanest.
    
    No functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191004122019.12009-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5183a40d3860..902a54bb46e0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -72,6 +72,7 @@
 #include "i915_perf.h"
 #include "i915_query.h"
 #include "i915_suspend.h"
+#include "i915_switcheroo.h"
 #include "i915_sysfs.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
@@ -269,56 +270,8 @@ intel_teardown_mchbar(struct drm_i915_private *dev_priv)
 		release_resource(&dev_priv->mch_res);
 }
 
-static int i915_resume_switcheroo(struct drm_i915_private *i915);
-static int i915_suspend_switcheroo(struct drm_i915_private *i915,
-				   pm_message_t state);
-
-static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
-{
-	struct drm_i915_private *i915 = pdev_to_i915(pdev);
-	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
-
-	if (!i915) {
-		dev_err(&pdev->dev, "DRM not initialized, aborting switch.\n");
-		return;
-	}
-
-	if (state == VGA_SWITCHEROO_ON) {
-		pr_info("switched on\n");
-		i915->drm.switch_power_state = DRM_SWITCH_POWER_CHANGING;
-		/* i915 resume handler doesn't set to D0 */
-		pci_set_power_state(pdev, PCI_D0);
-		i915_resume_switcheroo(i915);
-		i915->drm.switch_power_state = DRM_SWITCH_POWER_ON;
-	} else {
-		pr_info("switched off\n");
-		i915->drm.switch_power_state = DRM_SWITCH_POWER_CHANGING;
-		i915_suspend_switcheroo(i915, pmm);
-		i915->drm.switch_power_state = DRM_SWITCH_POWER_OFF;
-	}
-}
-
-static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
-{
-	struct drm_i915_private *i915 = pdev_to_i915(pdev);
-
-	/*
-	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
-	 * locking inversion with the driver load path. And the access here is
-	 * completely racy anyway. So don't bother with locking for now.
-	 */
-	return i915 && i915->drm.open_count == 0;
-}
-
-static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
-	.set_gpu_state = i915_switcheroo_set_state,
-	.reprobe = NULL,
-	.can_switch = i915_switcheroo_can_switch,
-};
-
 static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 {
-	struct pci_dev *pdev = i915->drm.pdev;
 	int ret;
 
 	if (i915_inject_probe_failure(i915))
@@ -339,7 +292,7 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	intel_register_dsm_handler();
 
-	ret = vga_switcheroo_register_client(pdev, &i915_switcheroo_ops, false);
+	ret = i915_switcheroo_register(i915);
 	if (ret)
 		goto cleanup_vga_client;
 
@@ -394,7 +347,7 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 cleanup_csr:
 	intel_csr_ucode_fini(i915);
 	intel_power_domains_driver_remove(i915);
-	vga_switcheroo_unregister_client(pdev);
+	i915_switcheroo_unregister(i915);
 cleanup_vga_client:
 	intel_vga_unregister(i915);
 out:
@@ -428,13 +381,12 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 
 static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 {
-	struct pci_dev *pdev = i915->drm.pdev;
-
 	intel_modeset_driver_remove(i915);
 
 	intel_bios_driver_remove(i915);
 
-	vga_switcheroo_unregister_client(pdev);
+	i915_switcheroo_unregister(i915);
+
 	intel_vga_unregister(i915);
 
 	intel_csr_ucode_fini(i915);
@@ -1860,8 +1812,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	return ret;
 }
 
-static int
-i915_suspend_switcheroo(struct drm_i915_private *i915, pm_message_t state)
+int i915_suspend_switcheroo(struct drm_i915_private *i915, pm_message_t state)
 {
 	int error;
 
@@ -2027,7 +1978,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-static int i915_resume_switcheroo(struct drm_i915_private *i915)
+int i915_resume_switcheroo(struct drm_i915_private *i915)
 {
 	int ret;
 

commit a4e7ccdac38ec8335d9e4e2656c1a041c77feae1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 4 14:40:09 2019 +0100

    drm/i915: Move context management under GEM
    
    Keep track of the GEM contexts underneath i915->gem.contexts and assign
    them their own lock for the purposes of list management.
    
    v2: Focus on lock tracking; ctx->vm is protected by ctx->mutex
    v3: Correct split with removal of logical HW ID
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191004134015.13204-15-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b711324ca294..5183a40d3860 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1702,10 +1702,8 @@ static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct drm_i915_file_private *file_priv = file->driver_priv;
 
-	mutex_lock(&dev->struct_mutex);
 	i915_gem_context_close(file);
 	i915_gem_release(dev, file);
-	mutex_unlock(&dev->struct_mutex);
 
 	kfree_rcu(file_priv, rcu);
 

commit 2850748ef8763ab46958e43a4d1c445f29eeb37d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 4 14:39:58 2019 +0100

    drm/i915: Pull i915_vma_pin under the vm->mutex
    
    Replace the struct_mutex requirement for pinning the i915_vma with the
    local vm->mutex instead. Note that the vm->mutex is tainted by the
    shrinker (we require unbinding from inside fs-reclaim) and so we cannot
    allocate while holding that mutex. Instead we have to preallocate
    workers to do allocate and apply the PTE updates after we have we
    reserved their slot in the drm_mm (using fences to order the PTE writes
    with the GPU work and with later unbind).
    
    In adding the asynchronous vma binding, one subtle requirement is to
    avoid coupling the binding fence into the backing object->resv. That is
    the asynchronous binding only applies to the vma timeline itself and not
    to the pages as that is a more global timeline (the binding of one vma
    does not need to be ordered with another vma, nor does the implicit GEM
    fencing depend on a vma, only on writes to the backing store). Keeping
    the vma binding distinct from the backing store timelines is verified by
    a number of async gem_exec_fence and gem_exec_schedule tests. The way we
    do this is quite simple, we keep the fence for the vma binding separate
    and only wait on it as required, and never add it to the obj->resv
    itself.
    
    Another consequence in reducing the locking around the vma is the
    destruction of the vma is no longer globally serialised by struct_mutex.
    A natural solution would be to add a kref to i915_vma, but that requires
    decoupling the reference cycles, possibly by introducing a new
    i915_mm_pages object that is own by both obj->mm and vma->pages.
    However, we have not taken that route due to the overshadowing lmem/ttm
    discussions, and instead play a series of complicated games with
    trylocks to (hopefully) ensure that only one destruction path is called!
    
    v2: Add some commentary, and some helpers to reduce patch churn.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191004134015.13204-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1d2246c59cde..b711324ca294 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1895,10 +1895,8 @@ static int i915_drm_resume(struct drm_device *dev)
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
 
-	mutex_lock(&dev_priv->drm.struct_mutex);
 	i915_gem_restore_gtt_mappings(dev_priv);
 	i915_gem_restore_fences(dev_priv);
-	mutex_unlock(&dev_priv->drm.struct_mutex);
 
 	intel_csr_ucode_resume(dev_priv);
 

commit 4092de1ba34eb376791809fb366bc15f8a9e0b7c
Merge: a00d17e0a71a 54ecb8f7028c
Author: Maxime Ripard <mripard@kernel.org>
Date:   Thu Oct 3 16:38:50 2019 +0200

    Merge drm/drm-next into drm-misc-next
    
    We haven't done any backmerge for a while due to the merge window, and it
    starts to become an issue for komeda. Let's bring 5.4-rc1 in.
    
    Signed-off-by: Maxime Ripard <mripard@kernel.org>

commit 4fb8783165b7c6fb4b52428dbb80da8554e5fd1e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Oct 1 18:25:06 2019 +0300

    drm/i915/display: abstract all vgaarb access to intel_vga.[ch]
    
    Split out the code related to vga client and vgaarb all over the place
    into new intel_vga.[ch]. No functional changes.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191001152506.7854-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 364f7d0b7e31..1d2246c59cde 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -36,7 +36,6 @@
 #include <linux/pm_runtime.h>
 #include <linux/pnp.h>
 #include <linux/slab.h>
-#include <linux/vgaarb.h>
 #include <linux/vga_switcheroo.h>
 #include <linux/vt.h>
 #include <acpi/video.h>
@@ -59,6 +58,7 @@
 #include "display/intel_overlay.h"
 #include "display/intel_pipe_crc.h"
 #include "display/intel_sprite.h"
+#include "display/intel_vga.h"
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
@@ -269,19 +269,6 @@ intel_teardown_mchbar(struct drm_i915_private *dev_priv)
 		release_resource(&dev_priv->mch_res);
 }
 
-/* true = enable decode, false = disable decoder */
-static unsigned int i915_vga_set_decode(void *cookie, bool state)
-{
-	struct drm_i915_private *dev_priv = cookie;
-
-	intel_modeset_vga_set_state(dev_priv, state);
-	if (state)
-		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
-		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
-	else
-		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
-}
-
 static int i915_resume_switcheroo(struct drm_i915_private *i915);
 static int i915_suspend_switcheroo(struct drm_i915_private *i915,
 				   pm_message_t state);
@@ -346,15 +333,8 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	intel_bios_init(i915);
 
-	/* If we have > 1 VGA cards, then we need to arbitrate access
-	 * to the common VGA resources.
-	 *
-	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
-	 * then we do not take part in VGA arbitration and the
-	 * vga_client_register() fails with -ENODEV.
-	 */
-	ret = vga_client_register(pdev, i915, NULL, i915_vga_set_decode);
-	if (ret && ret != -ENODEV)
+	ret = intel_vga_register(i915);
+	if (ret)
 		goto out;
 
 	intel_register_dsm_handler();
@@ -416,7 +396,7 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	intel_power_domains_driver_remove(i915);
 	vga_switcheroo_unregister_client(pdev);
 cleanup_vga_client:
-	vga_client_register(pdev, NULL, NULL, NULL);
+	intel_vga_unregister(i915);
 out:
 	return ret;
 }
@@ -455,7 +435,7 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 	intel_bios_driver_remove(i915);
 
 	vga_switcheroo_unregister_client(pdev);
-	vga_client_register(pdev, NULL, NULL, NULL);
+	intel_vga_unregister(i915);
 
 	intel_csr_ucode_fini(i915);
 }

commit a3f356b273f9b860cd28be1d4ec25cd2782cda0c
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Fri Sep 27 18:33:49 2019 +0100

    drm/i915: simplify i915_gem_init_early
    
    i915_gem_init_early doesn't need to return anything.
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190927173409.31175-3-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dd9613e45723..364f7d0b7e31 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -614,9 +614,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 	intel_gt_init_early(&dev_priv->gt, dev_priv);
 
-	ret = i915_gem_init_early(dev_priv);
-	if (ret < 0)
-		goto err_gt;
+	i915_gem_init_early(dev_priv);
 
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
@@ -638,7 +636,6 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 err_gem:
 	i915_gem_cleanup_early(dev_priv);
-err_gt:
 	intel_gt_driver_late_release(&dev_priv->gt);
 	vlv_free_s0ix_state(dev_priv);
 err_workqueues:

commit 6cd02e77757a8fb0089053045932455355d2c4fd
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 20 21:54:21 2019 +0300

    drm/i915: pass i915 to intel_modeset_init() and intel_modeset_init_hw()
    
    In general, prefer struct drm_i915_private * over struct drm_device *
    when either will do. Rename the local variables to i915. No functional
    changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920185421.17822-6-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9b1788b4589e..dd9613e45723 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -378,7 +378,7 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
-	ret = intel_modeset_init(&i915->drm);
+	ret = intel_modeset_init(i915);
 	if (ret)
 		goto cleanup_irq;
 
@@ -1946,7 +1946,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	i915_gem_resume(dev_priv);
 
-	intel_modeset_init_hw(dev);
+	intel_modeset_init_hw(dev_priv);
 	intel_init_clock_gating(dev_priv);
 
 	spin_lock_irq(&dev_priv->irq_lock);

commit 9980c3c11060e177e6ccb0012371ade24a9543a4
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 20 21:54:18 2019 +0300

    drm/i915: pass i915 to intel_modeset_driver_remove()
    
    In general, prefer struct drm_i915_private * over struct drm_device *
    when either will do. Rename the local variable to i915. Also propagate
    to intel_hpd_poll_fini(). No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920185421.17822-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fbf1b9e1e059..9b1788b4589e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -407,7 +407,7 @@ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 	i915_gem_driver_remove(i915);
 	i915_gem_driver_release(i915);
 cleanup_modeset:
-	intel_modeset_driver_remove(&i915->drm);
+	intel_modeset_driver_remove(i915);
 cleanup_irq:
 	intel_irq_uninstall(i915);
 	intel_gmbus_teardown(i915);
@@ -450,7 +450,7 @@ static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 {
 	struct pci_dev *pdev = i915->drm.pdev;
 
-	intel_modeset_driver_remove(&i915->drm);
+	intel_modeset_driver_remove(i915);
 
 	intel_bios_driver_remove(i915);
 

commit 5bcd53aa39f3dd054328e0a29a343e0254709908
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 20 21:54:17 2019 +0300

    drm/i915: pass i915 to i915_driver_modeset_probe()
    
    In general, prefer struct drm_i915_private * over struct drm_device *
    when either will do. Rename the local variable to i915. No functional
    changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920185421.17822-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index acccf852e654..fbf1b9e1e059 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -329,23 +329,22 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 	.can_switch = i915_switcheroo_can_switch,
 };
 
-static int i915_driver_modeset_probe(struct drm_device *dev)
+static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
-	struct pci_dev *pdev = dev_priv->drm.pdev;
+	struct pci_dev *pdev = i915->drm.pdev;
 	int ret;
 
-	if (i915_inject_probe_failure(dev_priv))
+	if (i915_inject_probe_failure(i915))
 		return -ENODEV;
 
-	if (HAS_DISPLAY(dev_priv) && INTEL_DISPLAY_ENABLED(dev_priv)) {
-		ret = drm_vblank_init(&dev_priv->drm,
-				      INTEL_NUM_PIPES(dev_priv));
+	if (HAS_DISPLAY(i915) && INTEL_DISPLAY_ENABLED(i915)) {
+		ret = drm_vblank_init(&i915->drm,
+				      INTEL_NUM_PIPES(i915));
 		if (ret)
 			goto out;
 	}
 
-	intel_bios_init(dev_priv);
+	intel_bios_init(i915);
 
 	/* If we have > 1 VGA cards, then we need to arbitrate access
 	 * to the common VGA resources.
@@ -354,7 +353,7 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 	 * then we do not take part in VGA arbitration and the
 	 * vga_client_register() fails with -ENODEV.
 	 */
-	ret = vga_client_register(pdev, dev_priv, NULL, i915_vga_set_decode);
+	ret = vga_client_register(pdev, i915, NULL, i915_vga_set_decode);
 	if (ret && ret != -ENODEV)
 		goto out;
 
@@ -365,56 +364,56 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 		goto cleanup_vga_client;
 
 	/* must happen before intel_power_domains_init_hw() on VLV/CHV */
-	intel_update_rawclk(dev_priv);
+	intel_update_rawclk(i915);
 
-	intel_power_domains_init_hw(dev_priv, false);
+	intel_power_domains_init_hw(i915, false);
 
-	intel_csr_ucode_init(dev_priv);
+	intel_csr_ucode_init(i915);
 
-	ret = intel_irq_install(dev_priv);
+	ret = intel_irq_install(i915);
 	if (ret)
 		goto cleanup_csr;
 
-	intel_gmbus_setup(dev_priv);
+	intel_gmbus_setup(i915);
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
-	ret = intel_modeset_init(dev);
+	ret = intel_modeset_init(&i915->drm);
 	if (ret)
 		goto cleanup_irq;
 
-	ret = i915_gem_init(dev_priv);
+	ret = i915_gem_init(i915);
 	if (ret)
 		goto cleanup_modeset;
 
-	intel_overlay_setup(dev_priv);
+	intel_overlay_setup(i915);
 
-	if (!HAS_DISPLAY(dev_priv) || !INTEL_DISPLAY_ENABLED(dev_priv))
+	if (!HAS_DISPLAY(i915) || !INTEL_DISPLAY_ENABLED(i915))
 		return 0;
 
-	ret = intel_fbdev_init(dev);
+	ret = intel_fbdev_init(&i915->drm);
 	if (ret)
 		goto cleanup_gem;
 
 	/* Only enable hotplug handling once the fbdev is fully set up. */
-	intel_hpd_init(dev_priv);
+	intel_hpd_init(i915);
 
-	intel_init_ipc(dev_priv);
+	intel_init_ipc(i915);
 
 	return 0;
 
 cleanup_gem:
-	i915_gem_suspend(dev_priv);
-	i915_gem_driver_remove(dev_priv);
-	i915_gem_driver_release(dev_priv);
+	i915_gem_suspend(i915);
+	i915_gem_driver_remove(i915);
+	i915_gem_driver_release(i915);
 cleanup_modeset:
-	intel_modeset_driver_remove(dev);
+	intel_modeset_driver_remove(&i915->drm);
 cleanup_irq:
-	intel_irq_uninstall(dev_priv);
-	intel_gmbus_teardown(dev_priv);
+	intel_irq_uninstall(i915);
+	intel_gmbus_teardown(i915);
 cleanup_csr:
-	intel_csr_ucode_fini(dev_priv);
-	intel_power_domains_driver_remove(dev_priv);
+	intel_csr_ucode_fini(i915);
+	intel_power_domains_driver_remove(i915);
 	vga_switcheroo_unregister_client(pdev);
 cleanup_vga_client:
 	vga_client_register(pdev, NULL, NULL, NULL);
@@ -1607,7 +1606,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret < 0)
 		goto out_cleanup_mmio;
 
-	ret = i915_driver_modeset_probe(&dev_priv->drm);
+	ret = i915_driver_modeset_probe(dev_priv);
 	if (ret < 0)
 		goto out_cleanup_hw;
 

commit 2d6f6f359fd841a6ce3133470859035037ff0f75
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 20 21:54:16 2019 +0300

    drm/i915: add i915_driver_modeset_remove()
    
    For completeness, add counterpart to i915_driver_modeset_probe() and
    remove the asymmetry in the probe/remove parts. No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920185421.17822-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c95986a984c8..acccf852e654 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -447,6 +447,20 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
+static void i915_driver_modeset_remove(struct drm_i915_private *i915)
+{
+	struct pci_dev *pdev = i915->drm.pdev;
+
+	intel_modeset_driver_remove(&i915->drm);
+
+	intel_bios_driver_remove(i915);
+
+	vga_switcheroo_unregister_client(pdev);
+	vga_client_register(pdev, NULL, NULL, NULL);
+
+	intel_csr_ucode_fini(i915);
+}
+
 static void intel_init_dpio(struct drm_i915_private *dev_priv)
 {
 	/*
@@ -1623,8 +1637,6 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 void i915_driver_remove(struct drm_i915_private *i915)
 {
-	struct pci_dev *pdev = i915->drm.pdev;
-
 	disable_rpm_wakeref_asserts(&i915->runtime_pm);
 
 	i915_driver_unregister(i915);
@@ -1645,14 +1657,7 @@ void i915_driver_remove(struct drm_i915_private *i915)
 
 	intel_gvt_driver_remove(i915);
 
-	intel_modeset_driver_remove(&i915->drm);
-
-	intel_bios_driver_remove(i915);
-
-	vga_switcheroo_unregister_client(pdev);
-	vga_client_register(pdev, NULL, NULL, NULL);
-
-	intel_csr_ucode_fini(i915);
+	i915_driver_modeset_remove(i915);
 
 	/* Free error state after interrupts are fully disabled. */
 	cancel_delayed_work_sync(&i915->gt.hangcheck.work);

commit 574cc4539762561d96b456dbc0544d8898bd4c6e
Merge: 3c2edc36a774 945b584c94f8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 16:24:24 2019 -0700

    Merge tag 'drm-next-2019-09-18' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This is the main pull request for 5.4-rc1 merge window. I don't think
      there is anything outstanding so next week should just be fixes, but
      we'll see if I missed anything. I landed some fixes earlier in the
      week but got delayed writing summary and sending it out, due to a mix
      of sick kid and jetlag!
    
      There are some fixes pending, but I'd rather get the main merge out of
      the way instead of delaying it longer.
    
      It's also pretty large in commit count and new amd header file size.
      The largest thing is four new amdgpu products (navi12/14, arcturus and
      renoir APU support).
    
      Otherwise it's pretty much lots of work across the board, i915 has
      started landing tigerlake support, lots of icelake fixes and lots of
      locking reworking for future gpu support, lots of header file rework
      (drmP.h is nearly gone), some old legacy hacks (DRM_WAIT_ON) have been
      put into the places they are needed.
    
      uapi:
       - content protection type property for HDCP
    
      core:
       - rework include dependencies
       - lots of drmP.h removals
       - link rate calculation robustness fix
       - make fb helper map only when required
       - add connector->DDC adapter link
       - DRM_WAIT_ON removed
       - drop DRM_AUTH usage from drivers
    
      dma-buf:
       - reservation object fence helper
    
      dma-fence:
       - shrink dma_fence struct
       - merge signal functions
       - store timestamps in dma_fence
       - selftests
    
      ttm:
       - embed drm_get_object struct into ttm_buffer_object
       - release_notify callback
    
      bridges:
       - sii902x - audio graph card support
       - tc358767 - aux data handling rework
       - ti-snd64dsi86 - debugfs support, DSI mode flags support
    
      panels:
       - Support for GiantPlus GPM940B0, Sharp LQ070Y3DG3B, Ortustech
         COM37H3M, Novatek NT39016, Sharp LS020B1DD01D, Raydium RM67191, Boe
         Himax8279d, Sharp LD-D5116Z01B
       - TI nspire, NEC NL8048HL11, LG Philips LB035Q02, Sharp LS037V7DW01,
         Sony ACX565AKM, Toppoly TD028TTEC1 Toppoly TD043MTEA1
    
      i915:
       - Initial tigerlake platform support
       - Locking simplification work, general all over refactoring.
       - Selftests
       - HDCP debug info improvements
       - DSI properties
       - Icelake display PLL fixes, colorspace fixes, bandwidth fixes, DSI
         suspend/resume
       - GuC fixes
       - Perf fixes
       - ElkhartLake enablement
       - DP MST fixes
       - GVT - command parser enhancements
    
      amdgpu:
       - add wipe memory on release flag for buffer creation
       - Navi12/14 support (may be marked experimental)
       - Arcturus support
       - Renoir APU support
       - mclk DPM for Navi
       - DC display fixes
       - Raven scatter/gather support
       - RAS support for GFX
       - Navi12 + Arcturus power features
       - GPU reset for Picasso
       - smu11 i2c controller support
    
      amdkfd:
       - navi12/14 support
       - Arcturus support
    
      radeon:
       - kexec fix
    
      nouveau:
       - improved display color management
       - detect lack of GPU power cables
    
      vmwgfx:
       - evicition priority support
       - remove unused security feature
    
      msm:
       - msm8998 display support
       - better async commit support for cursor updates
    
      etnaviv:
       - per-process address space support
       - performance counter fixes
       - softpin support
    
      mcde:
       - DCS transfers fix
    
      exynos:
       - drmP.h cleanup
    
      lima:
       - reduce logging
    
      kirin:
       - misc clenaups
    
      komeda:
       - dual-link support
       - DT memory regions
    
      hisilicon:
       - misc fixes
    
      imx:
       - IPUv3 image converter fixes
       - 32-bit RGB V4L2 pixel format support
    
      ingenic:
       - more support for panel related cases
    
      mgag200:
       - cursor support fix
    
      panfrost:
       - export GPU features register to userspace
       - gpu heap allocations
       - per-fd address space support
    
      pl111:
       - CLD pads wiring support removed from DT
    
      rockchip:
       - rework to use DRM PSR helpers
       - fix bug in VOP_WIN_GET macro
       - DSI DT binding rework
    
      sun4i:
       - improve support for color encoding and range
       - DDC enabled GPIO
    
      tinydrm:
       - rework SPI support
       - improve MIPI-DBI support
       - moved to drm/tiny
    
      vkms:
       - rework CRC tracking
    
      dw-hdmi:
       - get_eld and i2s improvements
    
      gm12u320:
       - misc fixes
    
      meson:
       - global code cleanup
       - vpu feature detect
    
      omap:
       - alpha/pixel blend mode properties
    
      rcar-du:
       - misc fixes"
    
    * tag 'drm-next-2019-09-18' of git://anongit.freedesktop.org/drm/drm: (2112 commits)
      drm/nouveau/bar/gm20b: Avoid BAR1 teardown during init
      drm/nouveau: Fix ordering between TTM and GEM release
      drm/nouveau/prime: Extend DMA reservation object lock
      drm/nouveau: Fix fallout from reservation object rework
      drm/nouveau/kms/nv50-: Don't create MSTMs for eDP connectors
      drm/i915: Use NOEVICT for first pass on attemping to pin a GGTT mmap
      drm/i915: to make vgpu ppgtt notificaiton as atomic operation
      drm/i915: Flush the existing fence before GGTT read/write
      drm/i915: Hold irq-off for the entire fake lock period
      drm/i915/gvt: update RING_START reg of vGPU when the context is submitted to i915
      drm/i915/gvt: update vgpu workload head pointer correctly
      drm/mcde: Fix DSI transfers
      drm/msm: Use the correct dma_sync calls harder
      drm/msm: remove unlikely() from WARN_ON() conditions
      drm/msm/dsi: Fix return value check for clk_get_parent
      drm/msm: add atomic traces
      drm/msm/dpu: async commit support
      drm/msm: async commit support
      drm/msm: split power control from prepare/complete_commit
      drm/msm: add kms->flush_commit()
      ...

commit a2b69ea4d26d1077b00924ff34e46b28d997aae2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 13 13:04:07 2019 +0300

    drm/i915: introduce INTEL_DISPLAY_ENABLED()
    
    Prepare for making a distinction between not having display and having
    disabled display. Add INTEL_DISPLAY_ENABLED() and use it where
    HAS_DISPLAY() is used after intel_device_info_runtime_init(). This is
    initially duplication, as disabling display still leads to ->pipe_mask =
    0 and HAS_DISPLAY() being false.
    
    Note that ever since i915.display_disable was introduced, it has not
    affected PCH detection even if it uses HAS_DISPLAY(), as display disable
    happens after that.
    
    Since INTEL_DISPLAY_ENABLED() will not make sense unless HAS_DISPLAY()
    is true, include a warning for catching misuses making decisions on
    INTEL_DISPLAY_ENABLED() when HAS_DISPLAY() is false.
    
    v2: Remove INTEL_DISPLAY_ENABLED() check from intel_detect_pch() (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190913100407.30991-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c52ef2223580..c95986a984c8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -338,7 +338,7 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 	if (i915_inject_probe_failure(dev_priv))
 		return -ENODEV;
 
-	if (HAS_DISPLAY(dev_priv)) {
+	if (HAS_DISPLAY(dev_priv) && INTEL_DISPLAY_ENABLED(dev_priv)) {
 		ret = drm_vblank_init(&dev_priv->drm,
 				      INTEL_NUM_PIPES(dev_priv));
 		if (ret)
@@ -389,7 +389,7 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 
 	intel_overlay_setup(dev_priv);
 
-	if (!HAS_DISPLAY(dev_priv))
+	if (!HAS_DISPLAY(dev_priv) || !INTEL_DISPLAY_ENABLED(dev_priv))
 		return 0;
 
 	ret = intel_fbdev_init(dev);
@@ -1415,7 +1415,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	} else
 		DRM_ERROR("Failed to register driver for userspace access!\n");
 
-	if (HAS_DISPLAY(dev_priv)) {
+	if (HAS_DISPLAY(dev_priv) && INTEL_DISPLAY_ENABLED(dev_priv)) {
 		/* Must be done after probing outputs */
 		intel_opregion_register(dev_priv);
 		acpi_video_register();
@@ -1438,7 +1438,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 * We need to coordinate the hotplugs with the asynchronous fbdev
 	 * configuration, for which we use the fbdev->async_cookie.
 	 */
-	if (HAS_DISPLAY(dev_priv))
+	if (HAS_DISPLAY(dev_priv) && INTEL_DISPLAY_ENABLED(dev_priv))
 		drm_kms_helper_poll_init(dev);
 
 	intel_power_domains_enable(dev_priv);

commit 249778704c01384d76984d83e6d6377ac96b2cc4
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Sep 11 12:26:08 2019 +0300

    drm/i915: add INTEL_NUM_PIPES() and use it
    
    Abstract away direct access to ->num_pipes to allow further
    refactoring. No functional changes.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190911092608.13009-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8966672b0294..c52ef2223580 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -340,7 +340,7 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 
 	if (HAS_DISPLAY(dev_priv)) {
 		ret = drm_vblank_init(&dev_priv->drm,
-				      INTEL_INFO(dev_priv)->num_pipes);
+				      INTEL_NUM_PIPES(dev_priv));
 		if (ret)
 			goto out;
 	}

commit 61fa60ff6e6a0e16e9bcc15f632ce5437afa6494
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Sep 10 15:38:20 2019 +0100

    drm/i915: Move GT init to intel_gt.c
    
    Code in i915_gem_init_hw is all about GT init so move it to intel_gt.c
    renaming to intel_gt_init_hw.
    
    Existing intel_gt_init_hw is renamed to intel_gt_init_hw_early since it
    is currently called from driver probe.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190910143823.10686-2-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0aadff9b8c88..8966672b0294 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1269,7 +1269,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_ggtt;
 
-	intel_gt_init_hw(dev_priv);
+	intel_gt_init_hw_early(dev_priv);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {

commit cec5ca08e36fd18d2939b98055346b3b06f56c6c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Sep 9 12:00:08 2019 +0100

    drm/i915: Perform GGTT restore much earlier during resume
    
    As soon as we re-enable the various functions within the HW, they may go
    off and read data via a GGTT offset. Hence, if we have not yet restored
    the GGTT PTE before then, they may read and even *write* random locations
    in memory.
    
    Detected by DMAR faults during resume.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Martin Peres <martin.peres@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190909110011.8958-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 63e52e153414..0aadff9b8c88 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1914,6 +1914,11 @@ static int i915_drm_resume(struct drm_device *dev)
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
 
+	mutex_lock(&dev_priv->drm.struct_mutex);
+	i915_gem_restore_gtt_mappings(dev_priv);
+	i915_gem_restore_fences(dev_priv);
+	mutex_unlock(&dev_priv->drm.struct_mutex);
+
 	intel_csr_ucode_resume(dev_priv);
 
 	i915_restore_state(dev_priv);

commit 42014f69bb235f1123a6f8befb58b3e350a6f180
Author: Andi Shyti <andi.shyti@intel.com>
Date:   Thu Sep 5 14:14:03 2019 +0300

    drm/i915: Hook up GT power management
    
    Refactor the GT power management interface to work through the GT now
    that it is under the control of gt/
    
    Based on a patch by Chris Wilson.
    
    Signed-off-by: Andi Shyti <andi.shyti@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190905111403.10071-1-andi.shyti@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9478f704a315..63e52e153414 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1316,9 +1316,6 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
 			   PM_QOS_DEFAULT_VALUE);
 
-	/* BIOS often leaves RC6 enabled, but disable it for hw init */
-	intel_sanitize_gt_powersave(dev_priv);
-
 	intel_gt_init_workarounds(dev_priv);
 
 	/* On the 945G/GM, the chipset reports the MSI capability on the
@@ -1424,8 +1421,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		acpi_video_register();
 	}
 
-	if (IS_GEN(dev_priv, 5))
-		intel_gpu_ips_init(dev_priv);
+	intel_gt_driver_register(&dev_priv->gt);
 
 	intel_audio_init(dev_priv);
 
@@ -1468,7 +1464,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	 */
 	drm_kms_helper_poll_fini(&dev_priv->drm);
 
-	intel_gpu_ips_teardown();
+	intel_gt_driver_unregister(&dev_priv->gt);
 	acpi_video_unregister();
 	intel_opregion_unregister(dev_priv);
 
@@ -1612,9 +1608,6 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_cleanup_hw:
 	i915_driver_hw_remove(dev_priv);
 	i915_ggtt_driver_release(dev_priv);
-
-	/* Paranoia: make sure we have disabled everything before we exit. */
-	intel_sanitize_gt_powersave(dev_priv);
 out_cleanup_mmio:
 	i915_driver_mmio_release(dev_priv);
 out_runtime_pm_put:
@@ -1685,9 +1678,6 @@ static void i915_driver_release(struct drm_device *dev)
 
 	i915_ggtt_driver_release(dev_priv);
 
-	/* Paranoia: make sure we have disabled everything before we exit. */
-	intel_sanitize_gt_powersave(dev_priv);
-
 	i915_driver_mmio_release(dev_priv);
 
 	enable_rpm_wakeref_asserts(rpm);
@@ -1916,7 +1906,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	int ret;
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
-	intel_sanitize_gt_powersave(dev_priv);
+	intel_gt_pm_disable(&dev_priv->gt);
 
 	i915_gem_sanitize(dev_priv);
 
@@ -2044,7 +2034,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_display_power_resume_early(dev_priv);
 
-	intel_sanitize_gt_powersave(dev_priv);
+	intel_gt_pm_disable(&dev_priv->gt);
 
 	intel_power_domains_resume(dev_priv);
 
@@ -2588,9 +2578,6 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 
-	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && HAS_RC6(dev_priv))))
-		return -ENODEV;
-
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 

commit 32f0a982650b123bdab36865617d3e03ebcacf3b
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Aug 23 16:52:51 2019 -0400

    drm/i915: Call dma_set_max_seg_size() in i915_driver_hw_probe()
    
    Currently, we don't call dma_set_max_seg_size() for i915 because we
    intentionally do not limit the segment length that the device supports.
    However, this results in a warning being emitted if we try to map
    anything larger than SZ_64K on a kernel with CONFIG_DMA_API_DEBUG_SG
    enabled:
    
    [    7.751926] DMA-API: i915 0000:00:02.0: mapping sg segment longer
    than device claims to support [len=98304] [max=65536]
    [    7.751934] WARNING: CPU: 5 PID: 474 at kernel/dma/debug.c:1220
    debug_dma_map_sg+0x20f/0x340
    
    This was originally brought up on
    https://bugs.freedesktop.org/show_bug.cgi?id=108517 , and the consensus
    there was it wasn't really useful to set a limit (and that dma-debug
    isn't really all that useful for i915 in the first place). Unfortunately
    though, CONFIG_DMA_API_DEBUG_SG is enabled in the debug configs for
    various distro kernels. Since a WARN_ON() will disable automatic problem
    reporting (and cause any CI with said option enabled to start
    complaining), we really should just fix the problem.
    
    Note that as me and Chris Wilson discussed, the other solution for this
    would be to make DMA-API not make such assumptions when a driver hasn't
    explicitly set a maximum segment size. But, taking a look at the commit
    which originally introduced this behavior, commit 78c47830a5cb
    ("dma-debug: check scatterlist segments"), there is an explicit mention
    of this assumption and how it applies to devices with no segment size:
    
            Conversely, devices which are less limited than the rather
            conservative defaults, or indeed have no limitations at all
            (e.g. GPUs with their own internal MMU), should be encouraged to
            set appropriate dma_parms, as they may get more efficient DMA
            mapping performance out of it.
    
    So unless there's any concerns (I'm open to discussion!), let's just
    follow suite and call dma_set_max_seg_size() with UINT_MAX as our limit
    to silence any warnings.
    
    Changes since v3:
    * Drop patch for enabling CONFIG_DMA_API_DEBUG_SG in CI. It looks like
      just turning it on causes the kernel to spit out bogus WARN_ONs()
      during some igt tests which would otherwise require teaching igt to
      disable the various DMA-API debugging options causing this. This is
      too much work to be worth it, since DMA-API debugging is useless for
      us. So, we'll just settle with this single patch to squelch WARN_ONs()
      during driver load for users that have CONFIG_DMA_API_DEBUG_SG turned
      on for some reason.
    * Move dma_set_max_seg_size() call into i915_driver_hw_probe() - Chris
      Wilson
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: <stable@vger.kernel.org> # v4.18+
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823205251.14298-1-lyude@redhat.com
    (cherry picked from commit acd674af95d3f627062007429b9c195c6b32361d)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f62e3397d936..bac1ee94f63f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1598,6 +1598,12 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	pci_set_master(pdev);
 
+	/*
+	 * We don't have a max segment size, so set it to the max so sg's
+	 * debugging layer doesn't complain
+	 */
+	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
+
 	/* overlay on gen2 is broken and can't address above 1G */
 	if (IS_GEN(dev_priv, 2)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));

commit acd674af95d3f627062007429b9c195c6b32361d
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Aug 23 16:52:51 2019 -0400

    drm/i915: Call dma_set_max_seg_size() in i915_driver_hw_probe()
    
    Currently, we don't call dma_set_max_seg_size() for i915 because we
    intentionally do not limit the segment length that the device supports.
    However, this results in a warning being emitted if we try to map
    anything larger than SZ_64K on a kernel with CONFIG_DMA_API_DEBUG_SG
    enabled:
    
    [    7.751926] DMA-API: i915 0000:00:02.0: mapping sg segment longer
    than device claims to support [len=98304] [max=65536]
    [    7.751934] WARNING: CPU: 5 PID: 474 at kernel/dma/debug.c:1220
    debug_dma_map_sg+0x20f/0x340
    
    This was originally brought up on
    https://bugs.freedesktop.org/show_bug.cgi?id=108517 , and the consensus
    there was it wasn't really useful to set a limit (and that dma-debug
    isn't really all that useful for i915 in the first place). Unfortunately
    though, CONFIG_DMA_API_DEBUG_SG is enabled in the debug configs for
    various distro kernels. Since a WARN_ON() will disable automatic problem
    reporting (and cause any CI with said option enabled to start
    complaining), we really should just fix the problem.
    
    Note that as me and Chris Wilson discussed, the other solution for this
    would be to make DMA-API not make such assumptions when a driver hasn't
    explicitly set a maximum segment size. But, taking a look at the commit
    which originally introduced this behavior, commit 78c47830a5cb
    ("dma-debug: check scatterlist segments"), there is an explicit mention
    of this assumption and how it applies to devices with no segment size:
    
            Conversely, devices which are less limited than the rather
            conservative defaults, or indeed have no limitations at all
            (e.g. GPUs with their own internal MMU), should be encouraged to
            set appropriate dma_parms, as they may get more efficient DMA
            mapping performance out of it.
    
    So unless there's any concerns (I'm open to discussion!), let's just
    follow suite and call dma_set_max_seg_size() with UINT_MAX as our limit
    to silence any warnings.
    
    Changes since v3:
    * Drop patch for enabling CONFIG_DMA_API_DEBUG_SG in CI. It looks like
      just turning it on causes the kernel to spit out bogus WARN_ONs()
      during some igt tests which would otherwise require teaching igt to
      disable the various DMA-API debugging options causing this. This is
      too much work to be worth it, since DMA-API debugging is useless for
      us. So, we'll just settle with this single patch to squelch WARN_ONs()
      during driver load for users that have CONFIG_DMA_API_DEBUG_SG turned
      on for some reason.
    * Move dma_set_max_seg_size() call into i915_driver_hw_probe() - Chris
      Wilson
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: <stable@vger.kernel.org> # v4.18+
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823205251.14298-1-lyude@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 723b9b7202b0..9478f704a315 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1279,6 +1279,12 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 
 	pci_set_master(pdev);
 
+	/*
+	 * We don't have a max segment size, so set it to the max so sg's
+	 * debugging layer doesn't complain
+	 */
+	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
+
 	/* overlay on gen2 is broken and can't address above 1G */
 	if (IS_GEN(dev_priv, 2)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));

commit 77715906921251bd9f75bcf4825f176df3f91208
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 23 19:14:55 2019 +0100

    drm/i915: Keep drm_i915_file_private around under RCU
    
    Ensure that the drm_i915_file_private continues to exist as we attempt
    to remove a request from its list, which may race with the destruction
    of the file.
    
    <6> [38.380714] [IGT] gem_ctx_create: starting subtest basic-files
    <0> [42.201329] BUG: spinlock bad magic on CPU#0, kworker/u16:0/7
    <4> [42.201356] general protection fault: 0000 [#1] PREEMPT SMP PTI
    <4> [42.201371] CPU: 0 PID: 7 Comm: kworker/u16:0 Tainted: G     U            5.3.0-rc5-CI-Patchwork_14169+ #1
    <4> [42.201391] Hardware name: Dell Inc.                 OptiPlex 745                 /0GW726, BIOS 2.3.1  05/21/2007
    <4> [42.201594] Workqueue: i915 retire_work_handler [i915]
    <4> [42.201614] RIP: 0010:spin_dump+0x5a/0x90
    <4> [42.201625] Code: 00 48 8d 88 c0 06 00 00 48 c7 c7 00 71 09 82 e8 35 ef 00 00 48 85 db 44 8b 4d 08 41 b8 ff ff ff ff 48 c7 c1 0b cd 0f 82 74 0e <44> 8b 83 e0 04 00 00 48 8d 8b c0 06 00 00 8b 55 04 48 89 ee 48 c7
    <4> [42.201660] RSP: 0018:ffffc9000004bd80 EFLAGS: 00010202
    <4> [42.201673] RAX: 0000000000000031 RBX: 6b6b6b6b6b6b6b6b RCX: ffffffff820fcd0b
    <4> [42.201688] RDX: 0000000000000000 RSI: ffff88803de266f8 RDI: 00000000ffffffff
    <4> [42.201703] RBP: ffff888038381ff8 R08: 00000000ffffffff R09: 000000006b6b6b6b
    <4> [42.201718] R10: 0000000041cb0b89 R11: 646162206b636f6c R12: ffff88802a618500
    <4> [42.201733] R13: ffff88802b32c288 R14: ffff888038381ff8 R15: ffff88802b32c250
    <4> [42.201748] FS:  0000000000000000(0000) GS:ffff88803de00000(0000) knlGS:0000000000000000
    <4> [42.201765] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    <4> [42.201778] CR2: 00007f2cefc6d180 CR3: 00000000381ee000 CR4: 00000000000006f0
    <4> [42.201793] Call Trace:
    <4> [42.201805]  do_raw_spin_lock+0x66/0xb0
    <4> [42.201898]  i915_request_retire+0x548/0x7c0 [i915]
    <4> [42.201989]  retire_requests+0x4d/0x60 [i915]
    <4> [42.202078]  i915_retire_requests+0x144/0x2e0 [i915]
    <4> [42.202169]  retire_work_handler+0x10/0x40 [i915]
    
    Recently, in commit 44c22f3f1a0a ("drm/i915: Serialize insertion into the
    file->mm.request_list"), we fixed a race on insertion. Now, it appears
    we also have a race with destruction!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823181455.31910-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b5b2a64753e6..723b9b7202b0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1730,7 +1730,7 @@ static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 	i915_gem_release(dev, file);
 	mutex_unlock(&dev->struct_mutex);
 
-	kfree(file_priv);
+	kfree_rcu(file_priv, rcu);
 
 	/* Catch up with all the deferred frees from "this" client */
 	i915_gem_flush_free_objects(to_i915(dev));

commit f2521f7731ed72a42c7ea24fd24acc3d1a806e0d
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Thu Aug 22 11:06:45 2019 +0200

    drm/i915: switch to drm_fb_helper_remove_conflicting_pci_framebuffers
    
    No need for a home-grown version, the generic helper should work just
    fine.  It also handles vgacon removal these days, see commit
    1c74ca7a1a9a ("drm/fb-helper: call vga_remove_vgacon automatically."),
    so that can be removed too.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190822090645.25410-4-kraxel@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b99d73c1c4db..ddc317ceb8de 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -766,31 +766,6 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	return ret;
 }
 
-static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
-{
-	struct apertures_struct *ap;
-	struct pci_dev *pdev = dev_priv->drm.pdev;
-	struct i915_ggtt *ggtt = &dev_priv->ggtt;
-	bool primary;
-	int ret;
-
-	ap = alloc_apertures(1);
-	if (!ap)
-		return -ENOMEM;
-
-	ap->ranges[0].base = ggtt->gmadr.start;
-	ap->ranges[0].size = ggtt->mappable_end;
-
-	primary =
-		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
-
-	ret = drm_fb_helper_remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
-
-	kfree(ap);
-
-	return ret;
-}
-
 static void intel_init_dpio(struct drm_i915_private *dev_priv)
 {
 	/*
@@ -1570,21 +1545,9 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_perf;
 
-	/*
-	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
-	 * otherwise the vga fbdev driver falls over.
-	 */
-	ret = i915_kick_out_firmware_fb(dev_priv);
-	if (ret) {
-		DRM_ERROR("failed to remove conflicting framebuffer drivers\n");
-		goto err_ggtt;
-	}
-
-	ret = vga_remove_vgacon(pdev);
-	if (ret) {
-		DRM_ERROR("failed to remove conflicting VGA console\n");
+	ret = drm_fb_helper_remove_conflicting_pci_framebuffers(pdev, "inteldrmfb");
+	if (ret)
 		goto err_ggtt;
-	}
 
 	ret = i915_ggtt_init_hw(dev_priv);
 	if (ret)

commit 829e8def7bd7b1e58028113ee5c2877da89d8f27
Merge: 8e40983dec63 ae4530062620
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Wed Aug 21 22:47:35 2019 -0700

    Merge drm/drm-next into drm-intel-next-queued
    
    We need the rename of reservation_object to dma_resv.
    
    The solution on this merge came from linux-next:
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    Date: Wed, 14 Aug 2019 12:48:39 +1000
    Subject: [PATCH] drm: fix up fallout from "dma-buf: rename reservation_object to dma_resv"
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    ---
     drivers/gpu/drm/i915/gt/intel_engine_pool.c | 8 ++++----
     3 files changed, 7 insertions(+), 7 deletions(-)
    
    diff --git a/drivers/gpu/drm/i915/gt/intel_engine_pool.c b/drivers/gpu/drm/i915/gt/intel_engine_pool.c
    index 03d90b49584a..4cd54c569911 100644
    --- a/drivers/gpu/drm/i915/gt/intel_engine_pool.c
    +++ b/drivers/gpu/drm/i915/gt/intel_engine_pool.c
    @@ -43,12 +43,12 @@ static int pool_active(struct i915_active *ref)
     {
            struct intel_engine_pool_node *node =
                    container_of(ref, typeof(*node), active);
    -       struct reservation_object *resv = node->obj->base.resv;
    +       struct dma_resv *resv = node->obj->base.resv;
            int err;
    
    -       if (reservation_object_trylock(resv)) {
    -               reservation_object_add_excl_fence(resv, NULL);
    -               reservation_object_unlock(resv);
    +       if (dma_resv_trylock(resv)) {
    +               dma_resv_add_excl_fence(resv, NULL);
    +               dma_resv_unlock(resv);
            }
    
            err = i915_gem_object_pin_pages(node->obj);
    
    which is a simplified version from a previous one which had:
    Reviewed-by: Christian König <christian.koenig@amd.com>
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

commit 1bcd8688bd9e122fdc47af97c5bed0c44ad60c98
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Mon Aug 19 19:01:46 2019 -0700

    drm/i915: Dynamically allocate s0ix struct for VLV
    
    This is only required for a single platform so no need to reserve the
    memory on all of them.
    
    This removes the last direct dependency of i915_drv.h on i915_reg.h
    (apart from the i915_reg_t definition).
    
    v2: drop unneeded diff, keep the vlv prefix, call functions
        unconditionally (Jani), fwd declaration of the struct (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190820020147.5667-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4ee12843171c..defe27bfcde5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -80,6 +80,68 @@
 
 static struct drm_driver driver;
 
+struct vlv_s0ix_state {
+	/* GAM */
+	u32 wr_watermark;
+	u32 gfx_prio_ctrl;
+	u32 arb_mode;
+	u32 gfx_pend_tlb0;
+	u32 gfx_pend_tlb1;
+	u32 lra_limits[GEN7_LRA_LIMITS_REG_NUM];
+	u32 media_max_req_count;
+	u32 gfx_max_req_count;
+	u32 render_hwsp;
+	u32 ecochk;
+	u32 bsd_hwsp;
+	u32 blt_hwsp;
+	u32 tlb_rd_addr;
+
+	/* MBC */
+	u32 g3dctl;
+	u32 gsckgctl;
+	u32 mbctl;
+
+	/* GCP */
+	u32 ucgctl1;
+	u32 ucgctl3;
+	u32 rcgctl1;
+	u32 rcgctl2;
+	u32 rstctl;
+	u32 misccpctl;
+
+	/* GPM */
+	u32 gfxpause;
+	u32 rpdeuhwtc;
+	u32 rpdeuc;
+	u32 ecobus;
+	u32 pwrdwnupctl;
+	u32 rp_down_timeout;
+	u32 rp_deucsw;
+	u32 rcubmabdtmr;
+	u32 rcedata;
+	u32 spare2gh;
+
+	/* Display 1 CZ domain */
+	u32 gt_imr;
+	u32 gt_ier;
+	u32 pm_imr;
+	u32 pm_ier;
+	u32 gt_scratch[GEN7_GT_SCRATCH_REG_NUM];
+
+	/* GT SA CZ domain */
+	u32 tilectl;
+	u32 gt_fifoctl;
+	u32 gtlc_wake_ctrl;
+	u32 gtlc_survive;
+	u32 pmwgicz;
+
+	/* Display 2 CZ domain */
+	u32 gu_ctl0;
+	u32 gu_ctl1;
+	u32 pcbr;
+	u32 clock_gate_dis2;
+};
+
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
 	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);
@@ -466,6 +528,29 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	}
 }
 
+static int vlv_alloc_s0ix_state(struct drm_i915_private *i915)
+{
+	if (!IS_VALLEYVIEW(i915))
+		return 0;
+
+	/* we write all the values in the struct, so no need to zero it out */
+	i915->vlv_s0ix_state = kmalloc(sizeof(*i915->vlv_s0ix_state),
+				       GFP_KERNEL);
+	if (!i915->vlv_s0ix_state)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void vlv_free_s0ix_state(struct drm_i915_private *i915)
+{
+	if (!i915->vlv_s0ix_state)
+		return;
+
+	kfree(i915->vlv_s0ix_state);
+	i915->vlv_s0ix_state = NULL;
+}
+
 /**
  * i915_driver_early_probe - setup state not requiring device access
  * @dev_priv: device private
@@ -508,13 +593,17 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		return ret;
 
+	ret = vlv_alloc_s0ix_state(dev_priv);
+	if (ret < 0)
+		goto err_workqueues;
+
 	intel_wopcm_init_early(&dev_priv->wopcm);
 
 	intel_gt_init_early(&dev_priv->gt, dev_priv);
 
 	ret = i915_gem_init_early(dev_priv);
 	if (ret < 0)
-		goto err_workqueues;
+		goto err_gt;
 
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
@@ -536,8 +625,10 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 err_gem:
 	i915_gem_cleanup_early(dev_priv);
-err_workqueues:
+err_gt:
 	intel_gt_driver_late_release(&dev_priv->gt);
+	vlv_free_s0ix_state(dev_priv);
+err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 	return ret;
 }
@@ -553,6 +644,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 	intel_power_domains_cleanup(dev_priv);
 	i915_gem_cleanup_early(dev_priv);
 	intel_gt_driver_late_release(&dev_priv->gt);
+	vlv_free_s0ix_state(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 
 	pm_qos_remove_request(&dev_priv->sb_qos);
@@ -2137,9 +2229,12 @@ static int i915_pm_restore(struct device *kdev)
  */
 static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 {
-	struct vlv_s0ix_state *s = &dev_priv->vlv_s0ix_state;
+	struct vlv_s0ix_state *s = dev_priv->vlv_s0ix_state;
 	int i;
 
+	if (!s)
+		return;
+
 	/* GAM 0x4000-0x4770 */
 	s->wr_watermark		= I915_READ(GEN7_WR_WATERMARK);
 	s->gfx_prio_ctrl	= I915_READ(GEN7_GFX_PRIO_CTRL);
@@ -2218,10 +2313,13 @@ static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 
 static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 {
-	struct vlv_s0ix_state *s = &dev_priv->vlv_s0ix_state;
+	struct vlv_s0ix_state *s = dev_priv->vlv_s0ix_state;
 	u32 val;
 	int i;
 
+	if (!s)
+		return;
+
 	/* GAM 0x4000-0x4770 */
 	I915_WRITE(GEN7_WR_WATERMARK,	s->wr_watermark);
 	I915_WRITE(GEN7_GFX_PRIO_CTRL,	s->gfx_prio_ctrl);
@@ -2430,8 +2528,7 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	if (err)
 		goto err2;
 
-	if (!IS_CHERRYVIEW(dev_priv))
-		vlv_save_gunit_s0ix_state(dev_priv);
+	vlv_save_gunit_s0ix_state(dev_priv);
 
 	err = vlv_force_gfx_clock(dev_priv, false);
 	if (err)
@@ -2461,8 +2558,7 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 	 */
 	ret = vlv_force_gfx_clock(dev_priv, true);
 
-	if (!IS_CHERRYVIEW(dev_priv))
-		vlv_restore_gunit_s0ix_state(dev_priv);
+	vlv_restore_gunit_s0ix_state(dev_priv);
 
 	err = vlv_allow_gt_wake(dev_priv, true);
 	if (!ret)

commit 88f8065ca73ff8d374fe640e651bc3d37ddc1954
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 15 10:36:04 2019 +0100

    drm/i915: Convert a few more bland dmesg info to be device specific
    
    Looking around the GT initialisation, we have a few log messages we
    think are interesting enough present to the user (such as the amount of L4
    cache) and a few to inform them of the result of actions or conflicting
    HW restrictions (i.e. quirks). These are device specific messages, so
    use the dev family of printk.
    
    v2: shave off a few bytes of .rodata!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190815093604.3618-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 96bf70b48cf7..4ee12843171c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1102,7 +1102,8 @@ static void edram_detect(struct drm_i915_private *dev_priv)
 		dev_priv->edram_size_mb =
 			gen9_edram_size_mb(dev_priv, edram_cap);
 
-	DRM_INFO("Found %uMB of eDRAM\n", dev_priv->edram_size_mb);
+	dev_info(dev_priv->drm.dev,
+		 "Found %uMB of eDRAM\n", dev_priv->edram_size_mb);
 }
 
 /**

commit 0a9b26306d6a10573cdc4dbbc804bfff264ae878
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Fri Aug 9 07:31:16 2019 +0100

    drm/i915: split out uncore_mmio_debug
    
    Multiple uncore structures will share the debug infrastructure, so
    move it to a common place and add extra locking around it.
    Also, since we now have a separate object, it is cleaner to have
    dedicated functions working on the object to stop and restart the
    mmio debug. Apart from the cosmetic changes, this patch introduces
    2 functional updates:
    
    - All calls to check_for_unclaimed_mmio will now return false when
      the debug is suspended, not just the ones that are active only when
      i915_modparams.mmio_debug is set. If we don't trust the result of the
      check while a user is doing mmio access then we shouldn't attempt the
      check anywhere.
    
    - i915_modparams.mmio_debug is not save/restored anymore around user
      access. The value is now never touched by the kernel while debug is
      disabled so no need for save/restore.
    
    v2: squash mmio_debug patches, restrict mmio_debug lock usage (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190809063116.7527-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca917583c411..96bf70b48cf7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -485,6 +485,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 	intel_device_info_subplatform_init(dev_priv);
 
+	intel_uncore_mmio_debug_init_early(&dev_priv->mmio_debug);
 	intel_uncore_init_early(&dev_priv->uncore, dev_priv);
 
 	spin_lock_init(&dev_priv->irq_lock);
@@ -1785,7 +1786,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 out:
 	enable_rpm_wakeref_asserts(rpm);
-	if (!dev_priv->uncore.user_forcewake.count)
+	if (!dev_priv->uncore.user_forcewake_count)
 		intel_runtime_pm_driver_release(rpm);
 
 	return ret;

commit 9c9082b98228b0fdb9ef3dec6d67169b05017859
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:47 2019 +0300

    drm/i915: extract i915_memcpy.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/f2b887002150acdf218385ea846f7aa617aa5f15.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0377ddf6ada9..ca917583c411 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -68,6 +68,7 @@
 #include "i915_debugfs.h"
 #include "i915_drv.h"
 #include "i915_irq.h"
+#include "i915_memcpy.h"
 #include "i915_perf.h"
 #include "i915_query.h"
 #include "i915_suspend.h"

commit bdd1510cc7c2940bdd12687559b24b04043dff9f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:46 2019 +0300

    drm/i915: extract i915_suspend.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/94f2884a3e5611c3e1f015104afb965e47bd8992.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2bc3c6ce5ed9..0377ddf6ada9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -70,6 +70,7 @@
 #include "i915_irq.h"
 #include "i915_perf.h"
 #include "i915_query.h"
+#include "i915_suspend.h"
 #include "i915_sysfs.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"

commit be68261d815f97940c0b776dcc42c2c5253acee3
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:45 2019 +0300

    drm/i915: extract i915_sysfs.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/2276d0401a52389fe3aafe7e62b07a198353045e.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cd5a17d38aba..2bc3c6ce5ed9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -70,6 +70,7 @@
 #include "i915_irq.h"
 #include "i915_perf.h"
 #include "i915_query.h"
+#include "i915_sysfs.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_csr.h"

commit db94e9f133a04169a0e119f5b85a76c365296ac2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:44 2019 +0300

    drm/i915: extract i915_perf.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/d7826e365695f691a3ac69a69ff6f2bbdb62700d.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 17e3338bd912..cd5a17d38aba 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -68,6 +68,7 @@
 #include "i915_debugfs.h"
 #include "i915_drv.h"
 #include "i915_irq.h"
+#include "i915_perf.h"
 #include "i915_query.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"

commit 358c855cb60a27a2e91e002604d2c9ed03bdcb96
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:43 2019 +0300

    drm/i915: move printing and load error inject to i915_utils.[ch]
    
    Seems like a better fit. Reduce clutter in i915_drv.[ch].
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/bc458fa5e62fc8dae46216666f64ed6976fafaee.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e4f63cfd528b..17e3338bd912 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -76,75 +76,6 @@
 
 static struct drm_driver driver;
 
-#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
-static unsigned int i915_probe_fail_count;
-
-int __i915_inject_load_error(struct drm_i915_private *i915, int err,
-			     const char *func, int line)
-{
-	if (i915_probe_fail_count >= i915_modparams.inject_load_failure)
-		return 0;
-
-	if (++i915_probe_fail_count < i915_modparams.inject_load_failure)
-		return 0;
-
-	__i915_printk(i915, KERN_INFO,
-		      "Injecting failure %d at checkpoint %u [%s:%d]\n",
-		      err, i915_modparams.inject_load_failure, func, line);
-	i915_modparams.inject_load_failure = 0;
-	return err;
-}
-
-bool i915_error_injected(void)
-{
-	return i915_probe_fail_count && !i915_modparams.inject_load_failure;
-}
-
-#endif
-
-#define FDO_BUG_URL "https://bugs.freedesktop.org/enter_bug.cgi?product=DRI"
-#define FDO_BUG_MSG "Please file a bug at " FDO_BUG_URL " against DRM/Intel " \
-		    "providing the dmesg log by booting with drm.debug=0xf"
-
-void
-__i915_printk(struct drm_i915_private *dev_priv, const char *level,
-	      const char *fmt, ...)
-{
-	static bool shown_bug_once;
-	struct device *kdev = dev_priv->drm.dev;
-	bool is_error = level[1] <= KERN_ERR[1];
-	bool is_debug = level[1] == KERN_DEBUG[1];
-	struct va_format vaf;
-	va_list args;
-
-	if (is_debug && !(drm_debug & DRM_UT_DRIVER))
-		return;
-
-	va_start(args, fmt);
-
-	vaf.fmt = fmt;
-	vaf.va = &args;
-
-	if (is_error)
-		dev_printk(level, kdev, "%pV", &vaf);
-	else
-		dev_printk(level, kdev, "[" DRM_NAME ":%ps] %pV",
-			   __builtin_return_address(0), &vaf);
-
-	va_end(args);
-
-	if (is_error && !shown_bug_once) {
-		/*
-		 * Ask the user to file a bug report for the error, except
-		 * if they may have caused the bug by fiddling with unsafe
-		 * module parameters.
-		 */
-		if (!test_taint(TAINT_USER))
-			dev_notice(kdev, "%s", FDO_BUG_MSG);
-		shown_bug_once = true;
-	}
-}
-
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
 	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);

commit b0383c0653c4bd2d2732c5767ec8fa223b3d6efd
Merge: dce14e36aea2 cc8f12996e24
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 9 16:04:15 2019 +1000

    Merge tag 'drm-misc-next-2019-08-08' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.4:
    
    UAPI Changes:
     - HDCP: Add a Content protection type property
    
    Cross-subsystem Changes:
    
    Core Changes:
     - Continue to rework the include dependencies
     - fb: Remove the unused drm_gem_fbdev_fb_create function
     - drm-dp-helper: Make the link rate calculation more tolerant to
                      non-explicitly defined, yet supported, rates
     - fb-helper: Map DRM client buffer only when required, and instanciate a
                  shadow buffer when the device has a dirty function or says so
     - connector: Add a helper to link the DDC adapter used by that connector to
                  the userspace
     - vblank: Switch from DRM_WAIT_ON to wait_event_interruptible_timeout
     - dma-buf: Fix a stack corruption
     - ttm: Embed a drm_gem_object struct to make ttm_buffer_object a
            superclass of GEM, and convert drivers to use it.
     - hdcp: Improvements to report the content protection type to the
             userspace
    
    Driver Changes:
     - Remove drm_gem_prime_import/export from being defined in the drivers
     - Drop DRM_AUTH usage from drivers
     - Continue to drop drmP.h
     - Convert drivers to the connector ddc helper
    
     - ingenic: Add support for more panel-related cases
     - komeda: Support for dual-link
     - lima: Reduce logging
     - mpag200: Fix the cursor support
     - panfrost: Export GPU features register to userspace through an ioctl
     - pl111: Remove the CLD pads wiring support from the DT
     - rockchip: Rework to use DRM PSR helpers, fix a bug in the VOP_WIN_GET
                 macro
     - sun4i: Improve support for color encoding and range
     - tinydrm: Rework SPI support, improve MIPI-DBI support, move to drm/tiny
     - vkms: Rework of the CRC tracking
    
     - bridges:
       - sii902x: Add support for audio graph card
       - tc358767: Rework AUX data handling code
       - ti-sn65dsi86: Add Debugfs and proper DSI mode flags support
    
     - panels
       - Support for GiantPlus GPM940B0, Sharp LQ070Y3DG3B, Ortustech
         COM37H3M, Novatek NT39016, Sharp LS020B1DD01D, Raydium RM67191,
         Boe Himax8279d, Sharp LD-D5116Z01B
       - Conversion of the device tree bindings to the YAML description
       - jh057n00900: Rework the enable / disable path
    
     - fbdev:
       - ssd1307fb: Support more devices based on that controller
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190808121423.xzpedzkpyecvsiy4@flea

commit 707d26dcc1765172031b3779bb03a9db249ad949
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Aug 7 15:04:15 2019 +0300

    drm/i915: split out intel_pch.[ch] from i915_drv.[ch]
    
    Abstract the rather self-contained piece of code from i915_drv.[ch]. No
    functional changes.
    
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807120415.17917-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9a6059e0bbe5..e4f63cfd528b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -145,200 +145,6 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	}
 }
 
-/* Map PCH device id to PCH type, or PCH_NONE if unknown. */
-static enum intel_pch
-intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
-{
-	switch (id) {
-	case INTEL_PCH_IBX_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-		WARN_ON(!IS_GEN(dev_priv, 5));
-		return PCH_IBX;
-	case INTEL_PCH_CPT_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-		WARN_ON(!IS_GEN(dev_priv, 6) && !IS_IVYBRIDGE(dev_priv));
-		return PCH_CPT;
-	case INTEL_PCH_PPT_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-		WARN_ON(!IS_GEN(dev_priv, 6) && !IS_IVYBRIDGE(dev_priv));
-		/* PantherPoint is CPT compatible */
-		return PCH_CPT;
-	case INTEL_PCH_LPT_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
-		WARN_ON(IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv));
-		return PCH_LPT;
-	case INTEL_PCH_LPT_LP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
-		WARN_ON(!IS_HSW_ULT(dev_priv) && !IS_BDW_ULT(dev_priv));
-		return PCH_LPT;
-	case INTEL_PCH_WPT_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
-		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
-		WARN_ON(IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv));
-		/* WildcatPoint is LPT compatible */
-		return PCH_LPT;
-	case INTEL_PCH_WPT_LP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
-		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
-		WARN_ON(!IS_HSW_ULT(dev_priv) && !IS_BDW_ULT(dev_priv));
-		/* WildcatPoint is LPT compatible */
-		return PCH_LPT;
-	case INTEL_PCH_SPT_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv));
-		return PCH_SPT;
-	case INTEL_PCH_SPT_LP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv));
-		return PCH_SPT;
-	case INTEL_PCH_KBP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
-		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv) &&
-			!IS_COFFEELAKE(dev_priv));
-		/* KBP is SPT compatible */
-		return PCH_SPT;
-	case INTEL_PCH_CNP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
-		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));
-		return PCH_CNP;
-	case INTEL_PCH_CNP_LP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
-		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));
-		return PCH_CNP;
-	case INTEL_PCH_CMP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Comet Lake PCH (CMP)\n");
-		WARN_ON(!IS_COFFEELAKE(dev_priv));
-		/* CometPoint is CNP Compatible */
-		return PCH_CNP;
-	case INTEL_PCH_ICP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Ice Lake PCH\n");
-		WARN_ON(!IS_ICELAKE(dev_priv));
-		return PCH_ICP;
-	case INTEL_PCH_MCC_DEVICE_ID_TYPE:
-	case INTEL_PCH_MCC2_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Mule Creek Canyon PCH\n");
-		WARN_ON(!IS_ELKHARTLAKE(dev_priv));
-		return PCH_MCC;
-	case INTEL_PCH_TGP_DEVICE_ID_TYPE:
-		DRM_DEBUG_KMS("Found Tiger Lake LP PCH\n");
-		WARN_ON(!IS_TIGERLAKE(dev_priv));
-		return PCH_TGP;
-	default:
-		return PCH_NONE;
-	}
-}
-
-static bool intel_is_virt_pch(unsigned short id,
-			      unsigned short svendor, unsigned short sdevice)
-{
-	return (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
-		id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
-		(id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
-		 svendor == PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
-		 sdevice == PCI_SUBDEVICE_ID_QEMU));
-}
-
-static unsigned short
-intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
-{
-	unsigned short id = 0;
-
-	/*
-	 * In a virtualized passthrough environment we can be in a
-	 * setup where the ISA bridge is not able to be passed through.
-	 * In this case, a south bridge can be emulated and we have to
-	 * make an educated guess as to which PCH is really there.
-	 */
-
-	if (IS_TIGERLAKE(dev_priv))
-		id = INTEL_PCH_TGP_DEVICE_ID_TYPE;
-	else if (IS_ELKHARTLAKE(dev_priv))
-		id = INTEL_PCH_MCC_DEVICE_ID_TYPE;
-	else if (IS_ICELAKE(dev_priv))
-		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;
-	else if (IS_CANNONLAKE(dev_priv) || IS_COFFEELAKE(dev_priv))
-		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;
-	else if (IS_KABYLAKE(dev_priv) || IS_SKYLAKE(dev_priv))
-		id = INTEL_PCH_SPT_DEVICE_ID_TYPE;
-	else if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
-		id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
-		id = INTEL_PCH_LPT_DEVICE_ID_TYPE;
-	else if (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))
-		id = INTEL_PCH_CPT_DEVICE_ID_TYPE;
-	else if (IS_GEN(dev_priv, 5))
-		id = INTEL_PCH_IBX_DEVICE_ID_TYPE;
-
-	if (id)
-		DRM_DEBUG_KMS("Assuming PCH ID %04x\n", id);
-	else
-		DRM_DEBUG_KMS("Assuming no PCH\n");
-
-	return id;
-}
-
-static void intel_detect_pch(struct drm_i915_private *dev_priv)
-{
-	struct pci_dev *pch = NULL;
-
-	/*
-	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
-	 * make graphics device passthrough work easy for VMM, that only
-	 * need to expose ISA bridge to let driver know the real hardware
-	 * underneath. This is a requirement from virtualization team.
-	 *
-	 * In some virtualized environments (e.g. XEN), there is irrelevant
-	 * ISA bridge in the system. To work reliably, we should scan trhough
-	 * all the ISA bridge devices and check for the first match, instead
-	 * of only checking the first one.
-	 */
-	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
-		unsigned short id;
-		enum intel_pch pch_type;
-
-		if (pch->vendor != PCI_VENDOR_ID_INTEL)
-			continue;
-
-		id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
-
-		pch_type = intel_pch_type(dev_priv, id);
-		if (pch_type != PCH_NONE) {
-			dev_priv->pch_type = pch_type;
-			dev_priv->pch_id = id;
-			break;
-		} else if (intel_is_virt_pch(id, pch->subsystem_vendor,
-					 pch->subsystem_device)) {
-			id = intel_virt_detect_pch(dev_priv);
-			pch_type = intel_pch_type(dev_priv, id);
-
-			/* Sanity check virtual PCH id */
-			if (WARN_ON(id && pch_type == PCH_NONE))
-				id = 0;
-
-			dev_priv->pch_type = pch_type;
-			dev_priv->pch_id = id;
-			break;
-		}
-	}
-
-	/*
-	 * Use PCH_NOP (PCH but no South Display) for PCH platforms without
-	 * display.
-	 */
-	if (pch && !HAS_DISPLAY(dev_priv)) {
-		DRM_DEBUG_KMS("Display disabled, reverting to NOP PCH\n");
-		dev_priv->pch_type = PCH_NOP;
-		dev_priv->pch_id = 0;
-	}
-
-	if (!pch)
-		DRM_DEBUG_KMS("No PCH found.\n");
-
-	pci_dev_put(pch);
-}
-
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
 	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);

commit 26f00514d944db8761d62ebf6f94766a81b97480
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 7 15:20:41 2019 +0100

    drm/i915: Isolate i915_getparam_ioctl()
    
    This giant switch has tendrils all other the struct and does not fit
    in with the rest of the driver bring up and control in i915_drv.c. Push
    it to one side so that it can grow in peace.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807142041.32699-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e92b194d2745..9a6059e0bbe5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -62,17 +62,12 @@
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
-#include "gt/intel_engine_user.h"
 #include "gt/intel_gt.h"
 #include "gt/intel_gt_pm.h"
-#include "gt/intel_reset.h"
-#include "gt/intel_workarounds.h"
-#include "gt/uc/intel_uc.h"
 
 #include "i915_debugfs.h"
 #include "i915_drv.h"
 #include "i915_irq.h"
-#include "i915_pmu.h"
 #include "i915_query.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
@@ -344,168 +339,6 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	pci_dev_put(pch);
 }
 
-static int i915_getparam_ioctl(struct drm_device *dev, void *data,
-			       struct drm_file *file_priv)
-{
-	struct drm_i915_private *dev_priv = to_i915(dev);
-	struct pci_dev *pdev = dev_priv->drm.pdev;
-	const struct sseu_dev_info *sseu = &RUNTIME_INFO(dev_priv)->sseu;
-	drm_i915_getparam_t *param = data;
-	int value;
-
-	switch (param->param) {
-	case I915_PARAM_IRQ_ACTIVE:
-	case I915_PARAM_ALLOW_BATCHBUFFER:
-	case I915_PARAM_LAST_DISPATCH:
-	case I915_PARAM_HAS_EXEC_CONSTANTS:
-		/* Reject all old ums/dri params. */
-		return -ENODEV;
-	case I915_PARAM_CHIPSET_ID:
-		value = pdev->device;
-		break;
-	case I915_PARAM_REVISION:
-		value = pdev->revision;
-		break;
-	case I915_PARAM_NUM_FENCES_AVAIL:
-		value = dev_priv->ggtt.num_fences;
-		break;
-	case I915_PARAM_HAS_OVERLAY:
-		value = dev_priv->overlay ? 1 : 0;
-		break;
-	case I915_PARAM_HAS_BSD:
-		value = !!intel_engine_lookup_user(dev_priv,
-						   I915_ENGINE_CLASS_VIDEO, 0);
-		break;
-	case I915_PARAM_HAS_BLT:
-		value = !!intel_engine_lookup_user(dev_priv,
-						   I915_ENGINE_CLASS_COPY, 0);
-		break;
-	case I915_PARAM_HAS_VEBOX:
-		value = !!intel_engine_lookup_user(dev_priv,
-						   I915_ENGINE_CLASS_VIDEO_ENHANCE, 0);
-		break;
-	case I915_PARAM_HAS_BSD2:
-		value = !!intel_engine_lookup_user(dev_priv,
-						   I915_ENGINE_CLASS_VIDEO, 1);
-		break;
-	case I915_PARAM_HAS_LLC:
-		value = HAS_LLC(dev_priv);
-		break;
-	case I915_PARAM_HAS_WT:
-		value = HAS_WT(dev_priv);
-		break;
-	case I915_PARAM_HAS_ALIASING_PPGTT:
-		value = INTEL_PPGTT(dev_priv);
-		break;
-	case I915_PARAM_HAS_SEMAPHORES:
-		value = !!(dev_priv->caps.scheduler & I915_SCHEDULER_CAP_SEMAPHORES);
-		break;
-	case I915_PARAM_HAS_SECURE_BATCHES:
-		value = capable(CAP_SYS_ADMIN);
-		break;
-	case I915_PARAM_CMD_PARSER_VERSION:
-		value = i915_cmd_parser_get_version(dev_priv);
-		break;
-	case I915_PARAM_SUBSLICE_TOTAL:
-		value = intel_sseu_subslice_total(sseu);
-		if (!value)
-			return -ENODEV;
-		break;
-	case I915_PARAM_EU_TOTAL:
-		value = sseu->eu_total;
-		if (!value)
-			return -ENODEV;
-		break;
-	case I915_PARAM_HAS_GPU_RESET:
-		value = i915_modparams.enable_hangcheck &&
-			intel_has_gpu_reset(dev_priv);
-		if (value && intel_has_reset_engine(dev_priv))
-			value = 2;
-		break;
-	case I915_PARAM_HAS_RESOURCE_STREAMER:
-		value = 0;
-		break;
-	case I915_PARAM_HAS_POOLED_EU:
-		value = HAS_POOLED_EU(dev_priv);
-		break;
-	case I915_PARAM_MIN_EU_IN_POOL:
-		value = sseu->min_eu_in_pool;
-		break;
-	case I915_PARAM_HUC_STATUS:
-		value = intel_huc_check_status(&dev_priv->gt.uc.huc);
-		if (value < 0)
-			return value;
-		break;
-	case I915_PARAM_MMAP_GTT_VERSION:
-		/* Though we've started our numbering from 1, and so class all
-		 * earlier versions as 0, in effect their value is undefined as
-		 * the ioctl will report EINVAL for the unknown param!
-		 */
-		value = i915_gem_mmap_gtt_version();
-		break;
-	case I915_PARAM_HAS_SCHEDULER:
-		value = dev_priv->caps.scheduler;
-		break;
-
-	case I915_PARAM_MMAP_VERSION:
-		/* Remember to bump this if the version changes! */
-	case I915_PARAM_HAS_GEM:
-	case I915_PARAM_HAS_PAGEFLIPPING:
-	case I915_PARAM_HAS_EXECBUF2: /* depends on GEM */
-	case I915_PARAM_HAS_RELAXED_FENCING:
-	case I915_PARAM_HAS_COHERENT_RINGS:
-	case I915_PARAM_HAS_RELAXED_DELTA:
-	case I915_PARAM_HAS_GEN7_SOL_RESET:
-	case I915_PARAM_HAS_WAIT_TIMEOUT:
-	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
-	case I915_PARAM_HAS_PINNED_BATCHES:
-	case I915_PARAM_HAS_EXEC_NO_RELOC:
-	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
-	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
-	case I915_PARAM_HAS_EXEC_SOFTPIN:
-	case I915_PARAM_HAS_EXEC_ASYNC:
-	case I915_PARAM_HAS_EXEC_FENCE:
-	case I915_PARAM_HAS_EXEC_CAPTURE:
-	case I915_PARAM_HAS_EXEC_BATCH_FIRST:
-	case I915_PARAM_HAS_EXEC_FENCE_ARRAY:
-	case I915_PARAM_HAS_EXEC_SUBMIT_FENCE:
-		/* For the time being all of these are always true;
-		 * if some supported hardware does not have one of these
-		 * features this value needs to be provided from
-		 * INTEL_INFO(), a feature macro, or similar.
-		 */
-		value = 1;
-		break;
-	case I915_PARAM_HAS_CONTEXT_ISOLATION:
-		value = intel_engines_has_context_isolation(dev_priv);
-		break;
-	case I915_PARAM_SLICE_MASK:
-		value = sseu->slice_mask;
-		if (!value)
-			return -ENODEV;
-		break;
-	case I915_PARAM_SUBSLICE_MASK:
-		value = sseu->subslice_mask[0];
-		if (!value)
-			return -ENODEV;
-		break;
-	case I915_PARAM_CS_TIMESTAMP_FREQUENCY:
-		value = 1000 * RUNTIME_INFO(dev_priv)->cs_timestamp_frequency_khz;
-		break;
-	case I915_PARAM_MMAP_GTT_COHERENT:
-		value = INTEL_INFO(dev_priv)->has_coherent_ggtt;
-		break;
-	default:
-		DRM_DEBUG("Unknown parameter %d\n", param->param);
-		return -EINVAL;
-	}
-
-	if (put_user(value, param->value))
-		return -EFAULT;
-
-	return 0;
-}
-
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
 	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);

commit 9ae06cad821bbeaca9b34dbb9bdb8591a1d9762a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 7 09:37:01 2019 +0100

    drm/i915: Use intel_engine_lookup_user for probing HAS_BSD etc
    
    Use the same mechanism to determine if a backend engine exists for a
    uabi mapping as used internally.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807083702.16349-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 76ee67b90104..e92b194d2745 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -373,16 +373,20 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = dev_priv->overlay ? 1 : 0;
 		break;
 	case I915_PARAM_HAS_BSD:
-		value = !!dev_priv->engine[VCS0];
+		value = !!intel_engine_lookup_user(dev_priv,
+						   I915_ENGINE_CLASS_VIDEO, 0);
 		break;
 	case I915_PARAM_HAS_BLT:
-		value = !!dev_priv->engine[BCS0];
+		value = !!intel_engine_lookup_user(dev_priv,
+						   I915_ENGINE_CLASS_COPY, 0);
 		break;
 	case I915_PARAM_HAS_VEBOX:
-		value = !!dev_priv->engine[VECS0];
+		value = !!intel_engine_lookup_user(dev_priv,
+						   I915_ENGINE_CLASS_VIDEO_ENHANCE, 0);
 		break;
 	case I915_PARAM_HAS_BSD2:
-		value = !!dev_priv->engine[VCS1];
+		value = !!intel_engine_lookup_user(dev_priv,
+						   I915_ENGINE_CLASS_VIDEO, 1);
 		break;
 	case I915_PARAM_HAS_LLC:
 		value = HAS_LLC(dev_priv);

commit 071b68cceee7e8232a221f464dd26667f57fbd8f
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Aug 6 15:22:08 2019 +0300

    drm/i915: abstract display suspend/resume operations
    
    Increase abstraction of display suspend/resume operations by providing
    higher level functions, and hiding the details inside
    intel_display_power.c.
    
    v2: Make checkpatch happy:
        - braces {} are not necessary for single statement blocks
    v3: Also move hsw/bdw PC8 sequences since they are related to
        display PM anyways. (Ville)
    v4: Rebase after a long time, plus Move functions to the new
        intel_display_power so we can stop exporting platform specific
        functions as pointed by Jani.
    v5: Remove unnecessary braces.
    v6 by Jani: make this purely non-functional cleanup, make functions static
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806122208.16786-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff26c4d1f20d..76ee67b90104 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2166,7 +2166,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
-	int ret;
+	int ret = 0;
 
 	disable_rpm_wakeref_asserts(rpm);
 
@@ -2177,12 +2177,9 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	intel_power_domains_suspend(dev_priv,
 				    get_suspend_mode(dev_priv, hibernation));
 
-	ret = 0;
-	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv))
-		bxt_enable_dc9(dev_priv);
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
-		hsw_enable_pc8(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
+	intel_display_power_suspend_late(dev_priv);
+
+	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_suspend_complete(dev_priv);
 
 	if (ret) {
@@ -2367,12 +2364,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_gt_check_and_clear_faults(&dev_priv->gt);
 
-	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv)) {
-		gen9_sanitize_dc_state(dev_priv);
-		bxt_disable_dc9(dev_priv);
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
-		hsw_disable_pc8(dev_priv);
-	}
+	intel_display_power_resume_early(dev_priv);
 
 	intel_sanitize_gt_powersave(dev_priv);
 
@@ -2912,7 +2904,7 @@ static int intel_runtime_suspend(struct device *kdev)
 {
 	struct drm_i915_private *dev_priv = kdev_to_i915(kdev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
-	int ret;
+	int ret = 0;
 
 	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && HAS_RC6(dev_priv))))
 		return -ENODEV;
@@ -2936,18 +2928,10 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	intel_uncore_suspend(&dev_priv->uncore);
 
-	ret = 0;
-	if (INTEL_GEN(dev_priv) >= 11) {
-		icl_display_core_uninit(dev_priv);
-		bxt_enable_dc9(dev_priv);
-	} else if (IS_GEN9_LP(dev_priv)) {
-		bxt_display_core_uninit(dev_priv);
-		bxt_enable_dc9(dev_priv);
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
-		hsw_enable_pc8(dev_priv);
-	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
+	intel_display_power_suspend(dev_priv);
+
+	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_suspend_complete(dev_priv);
-	}
 
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
@@ -3023,28 +3007,10 @@ static int intel_runtime_resume(struct device *kdev)
 	if (intel_uncore_unclaimed_mmio(&dev_priv->uncore))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
-	if (INTEL_GEN(dev_priv) >= 11) {
-		bxt_disable_dc9(dev_priv);
-		icl_display_core_init(dev_priv, true);
-		if (dev_priv->csr.dmc_payload) {
-			if (dev_priv->csr.allowed_dc_mask &
-			    DC_STATE_EN_UPTO_DC6)
-				skl_enable_dc6(dev_priv);
-			else if (dev_priv->csr.allowed_dc_mask &
-				 DC_STATE_EN_UPTO_DC5)
-				gen9_enable_dc5(dev_priv);
-		}
-	} else if (IS_GEN9_LP(dev_priv)) {
-		bxt_disable_dc9(dev_priv);
-		bxt_display_core_init(dev_priv, true);
-		if (dev_priv->csr.dmc_payload &&
-		    (dev_priv->csr.allowed_dc_mask & DC_STATE_EN_UPTO_DC5))
-			gen9_enable_dc5(dev_priv);
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
-		hsw_disable_pc8(dev_priv);
-	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
+	intel_display_power_resume(dev_priv);
+
+	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, true);
-	}
 
 	intel_uncore_runtime_resume(&dev_priv->uncore);
 

commit 1d455f8de8e8a211cc91e19484eeda2e454531a1
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Aug 6 14:39:33 2019 +0300

    drm/i915: rename intel_drv.h to display/intel_display_types.h
    
    Everything about the file is about display, and mostly about types
    related to display. Move under display/ as intel_display_types.h to
    reflect the facts.
    
    There's still plenty to clean up, but start off with moving the file
    where it logically belongs and naming according to contents.
    
    v2: fix the include guard name in the renamed file
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806113933.11799-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bea440ac8b0f..ff26c4d1f20d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -51,6 +51,7 @@
 #include "display/intel_audio.h"
 #include "display/intel_bw.h"
 #include "display/intel_cdclk.h"
+#include "display/intel_display_types.h"
 #include "display/intel_dp.h"
 #include "display/intel_fbdev.h"
 #include "display/intel_gmbus.h"
@@ -76,7 +77,6 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_csr.h"
-#include "intel_drv.h"
 #include "intel_pm.h"
 
 static struct drm_driver driver;

commit 750e76b4f9f63c95bf4c283ccf8e2af0e258d3bb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Aug 6 13:43:00 2019 +0100

    drm/i915/gt: Move the [class][inst] lookup for engines onto the GT
    
    To maintain a fast lookup from a GT centric irq handler, we want the
    engine lookup tables on the intel_gt. To avoid having multiple copies of
    the same multi-dimension lookup table, move the generic user engine
    lookup into an rbtree (for fast and flexible indexing).
    
    v2: Split uabi_instance cf uabi_class
    v3: Set uabi_class/uabi_instance after collating all engines to provide a
    stable uabi across parallel unordered construction.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com> #v2
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806124300.24945-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec61e8a7c818..bea440ac8b0f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,6 +61,7 @@
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
+#include "gt/intel_engine_user.h"
 #include "gt/intel_gt.h"
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"

commit c29579d2fabe7448a444681d8229384249d315f9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Aug 6 13:42:59 2019 +0100

    drm/i915/gem: Make caps.scheduler static
    
    We do not notify userspace when the scheduler capabilities are changed
    (due to wedging the driver) and as such userspace will expect the caps
    to be static and unchanging. Make it so, and so we only need to compute
    our caps once during driver registration.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806124300.24945-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 14ca719dcf30..ec61e8a7c818 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1719,7 +1719,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
 
-	i915_gem_shrinker_register(dev_priv);
+	i915_gem_driver_register(dev_priv);
 	i915_pmu_register(dev_priv);
 
 	/*
@@ -1799,7 +1799,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_teardown_sysfs(dev_priv);
 	drm_dev_unplug(&dev_priv->drm);
 
-	i915_gem_shrinker_unregister(dev_priv);
+	i915_gem_driver_unregister(dev_priv);
 }
 
 static void i915_welcome_messages(struct drm_i915_private *dev_priv)

commit 361f9dc2436812cbcf727fe73d0a4c11ca895fbb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Aug 6 08:42:19 2019 +0100

    drm/i915: Use drm_i915_private directly from drv_get_drvdata()
    
    As we store a pointer to i915 in the drvdata field (as the pointer is both
    an alias to the drm_device and drm_i915_private), we can use the stored
    pointer directly as the i915 device.
    
    v2: Store and use i915 inside drv_get_drvdata()
    v3: Only expect i915 inside drv_get_drvdata() so drop the assumed
    i915/drm equivalence.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Andi Shyti <andi.shyti@intel.com>
    Reviewed-by: Andi Shyti <andi.shyti@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806074219.11043-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b9c6ae09d61f..14ca719dcf30 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -641,39 +641,45 @@ static unsigned int i915_vga_set_decode(void *cookie, bool state)
 		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 }
 
-static int i915_resume_switcheroo(struct drm_device *dev);
-static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state);
+static int i915_resume_switcheroo(struct drm_i915_private *i915);
+static int i915_suspend_switcheroo(struct drm_i915_private *i915,
+				   pm_message_t state);
 
 static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
 {
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *i915 = pdev_to_i915(pdev);
 	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
 
+	if (!i915) {
+		dev_err(&pdev->dev, "DRM not initialized, aborting switch.\n");
+		return;
+	}
+
 	if (state == VGA_SWITCHEROO_ON) {
 		pr_info("switched on\n");
-		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
+		i915->drm.switch_power_state = DRM_SWITCH_POWER_CHANGING;
 		/* i915 resume handler doesn't set to D0 */
 		pci_set_power_state(pdev, PCI_D0);
-		i915_resume_switcheroo(dev);
-		dev->switch_power_state = DRM_SWITCH_POWER_ON;
+		i915_resume_switcheroo(i915);
+		i915->drm.switch_power_state = DRM_SWITCH_POWER_ON;
 	} else {
 		pr_info("switched off\n");
-		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
-		i915_suspend_switcheroo(dev, pmm);
-		dev->switch_power_state = DRM_SWITCH_POWER_OFF;
+		i915->drm.switch_power_state = DRM_SWITCH_POWER_CHANGING;
+		i915_suspend_switcheroo(i915, pmm);
+		i915->drm.switch_power_state = DRM_SWITCH_POWER_OFF;
 	}
 }
 
 static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
 {
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *i915 = pdev_to_i915(pdev);
 
 	/*
 	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
 	 * locking inversion with the driver load path. And the access here is
 	 * completely racy anyway. So don't bother with locking for now.
 	 */
-	return dev->open_count == 0;
+	return i915 && i915->drm.open_count == 0;
 }
 
 static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
@@ -1840,9 +1846,10 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return ERR_PTR(err);
 	}
 
-	i915->drm.pdev = pdev;
 	i915->drm.dev_private = i915;
-	pci_set_drvdata(pdev, &i915->drm);
+
+	i915->drm.pdev = pdev;
+	pci_set_drvdata(pdev, i915);
 
 	/* Setup the write-once "constant" device info */
 	device_info = mkwrite_device_info(i915);
@@ -1942,51 +1949,50 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return ret;
 }
 
-void i915_driver_remove(struct drm_device *dev)
+void i915_driver_remove(struct drm_i915_private *i915)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
-	struct pci_dev *pdev = dev_priv->drm.pdev;
+	struct pci_dev *pdev = i915->drm.pdev;
 
-	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	disable_rpm_wakeref_asserts(&i915->runtime_pm);
 
-	i915_driver_unregister(dev_priv);
+	i915_driver_unregister(i915);
 
 	/*
 	 * After unregistering the device to prevent any new users, cancel
 	 * all in-flight requests so that we can quickly unbind the active
 	 * resources.
 	 */
-	intel_gt_set_wedged(&dev_priv->gt);
+	intel_gt_set_wedged(&i915->gt);
 
 	/* Flush any external code that still may be under the RCU lock */
 	synchronize_rcu();
 
-	i915_gem_suspend(dev_priv);
+	i915_gem_suspend(i915);
 
-	drm_atomic_helper_shutdown(dev);
+	drm_atomic_helper_shutdown(&i915->drm);
 
-	intel_gvt_driver_remove(dev_priv);
+	intel_gvt_driver_remove(i915);
 
-	intel_modeset_driver_remove(dev);
+	intel_modeset_driver_remove(&i915->drm);
 
-	intel_bios_driver_remove(dev_priv);
+	intel_bios_driver_remove(i915);
 
 	vga_switcheroo_unregister_client(pdev);
 	vga_client_register(pdev, NULL, NULL, NULL);
 
-	intel_csr_ucode_fini(dev_priv);
+	intel_csr_ucode_fini(i915);
 
 	/* Free error state after interrupts are fully disabled. */
-	cancel_delayed_work_sync(&dev_priv->gt.hangcheck.work);
-	i915_reset_error_state(dev_priv);
+	cancel_delayed_work_sync(&i915->gt.hangcheck.work);
+	i915_reset_error_state(i915);
 
-	i915_gem_driver_remove(dev_priv);
+	i915_gem_driver_remove(i915);
 
-	intel_power_domains_driver_remove(dev_priv);
+	intel_power_domains_driver_remove(i915);
 
-	i915_driver_hw_remove(dev_priv);
+	i915_driver_hw_remove(i915);
 
-	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 }
 
 static void i915_driver_release(struct drm_device *dev)
@@ -2209,28 +2215,23 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	return ret;
 }
 
-static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
+static int
+i915_suspend_switcheroo(struct drm_i915_private *i915, pm_message_t state)
 {
 	int error;
 
-	if (!dev) {
-		DRM_ERROR("dev: %p\n", dev);
-		DRM_ERROR("DRM not initialized, aborting suspend.\n");
-		return -ENODEV;
-	}
-
 	if (WARN_ON_ONCE(state.event != PM_EVENT_SUSPEND &&
 			 state.event != PM_EVENT_FREEZE))
 		return -EINVAL;
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	error = i915_drm_suspend(dev);
+	error = i915_drm_suspend(&i915->drm);
 	if (error)
 		return error;
 
-	return i915_drm_suspend_late(dev, false);
+	return i915_drm_suspend_late(&i915->drm, false);
 }
 
 static int i915_drm_resume(struct drm_device *dev)
@@ -2383,53 +2384,53 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-static int i915_resume_switcheroo(struct drm_device *dev)
+static int i915_resume_switcheroo(struct drm_i915_private *i915)
 {
 	int ret;
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	ret = i915_drm_resume_early(dev);
+	ret = i915_drm_resume_early(&i915->drm);
 	if (ret)
 		return ret;
 
-	return i915_drm_resume(dev);
+	return i915_drm_resume(&i915->drm);
 }
 
 static int i915_pm_prepare(struct device *kdev)
 {
-	struct drm_device *dev = dev_get_drvdata(kdev);
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
-	if (!dev) {
+	if (!i915) {
 		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
 	}
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_prepare(dev);
+	return i915_drm_prepare(&i915->drm);
 }
 
 static int i915_pm_suspend(struct device *kdev)
 {
-	struct drm_device *dev = dev_get_drvdata(kdev);
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
-	if (!dev) {
+	if (!i915) {
 		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
 	}
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend(dev);
+	return i915_drm_suspend(&i915->drm);
 }
 
 static int i915_pm_suspend_late(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
 	/*
 	 * We have a suspend ordering issue with the snd-hda driver also
@@ -2440,55 +2441,55 @@ static int i915_pm_suspend_late(struct device *kdev)
 	 * FIXME: This should be solved with a special hdmi sink device or
 	 * similar so that power domains can be employed.
 	 */
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend_late(dev, false);
+	return i915_drm_suspend_late(&i915->drm, false);
 }
 
 static int i915_pm_poweroff_late(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend_late(dev, true);
+	return i915_drm_suspend_late(&i915->drm, true);
 }
 
 static int i915_pm_resume_early(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_resume_early(dev);
+	return i915_drm_resume_early(&i915->drm);
 }
 
 static int i915_pm_resume(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (i915->drm.switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_resume(dev);
+	return i915_drm_resume(&i915->drm);
 }
 
 /* freeze: before creating the hibernation_image */
 static int i915_pm_freeze(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 	int ret;
 
-	if (dev->switch_power_state != DRM_SWITCH_POWER_OFF) {
-		ret = i915_drm_suspend(dev);
+	if (i915->drm.switch_power_state != DRM_SWITCH_POWER_OFF) {
+		ret = i915_drm_suspend(&i915->drm);
 		if (ret)
 			return ret;
 	}
 
-	ret = i915_gem_freeze(kdev_to_i915(kdev));
+	ret = i915_gem_freeze(i915);
 	if (ret)
 		return ret;
 
@@ -2497,16 +2498,16 @@ static int i915_pm_freeze(struct device *kdev)
 
 static int i915_pm_freeze_late(struct device *kdev)
 {
-	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
+	struct drm_i915_private *i915 = kdev_to_i915(kdev);
 	int ret;
 
-	if (dev->switch_power_state != DRM_SWITCH_POWER_OFF) {
-		ret = i915_drm_suspend_late(dev, true);
+	if (i915->drm.switch_power_state != DRM_SWITCH_POWER_OFF) {
+		ret = i915_drm_suspend_late(&i915->drm, true);
 		if (ret)
 			return ret;
 	}
 
-	ret = i915_gem_freeze_late(kdev_to_i915(kdev));
+	ret = i915_gem_freeze_late(i915);
 	if (ret)
 		return ret;
 
@@ -2908,8 +2909,7 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 
 static int intel_runtime_suspend(struct device *kdev)
 {
-	struct drm_device *dev = dev_get_drvdata(kdev);
-	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct drm_i915_private *dev_priv = kdev_to_i915(kdev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret;
 
@@ -3005,8 +3005,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 static int intel_runtime_resume(struct device *kdev)
 {
-	struct drm_device *dev = dev_get_drvdata(kdev);
-	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct drm_i915_private *dev_priv = kdev_to_i915(kdev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 

commit 515b8b7e935ef3f59c4efda04a3b05353ed6fbb7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 2 22:21:37 2019 +0100

    drm/i915: Flush the freed object list on file close
    
    As we increase the number of RCU objects, it becomes easier for us to
    have several hundred thousand objects in the deferred RCU free queues.
    An example is gem_ctx_create/files which continually creates active
    contexts, which are not immediately freed upon close as they are kept
    alive by outstanding requests. This lack of backpressure allows the
    context objects to persist until they overwhelm and starve the system.
    We can increase our backpressure by flushing the freed object queue upon
    closing the device fd which should then not impact other clients.
    
    Testcase: igt/gem_ctx_create/*files
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802212137.22207-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 21f1b29d06a2..b9c6ae09d61f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2052,6 +2052,9 @@ static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 	mutex_unlock(&dev->struct_mutex);
 
 	kfree(file_priv);
+
+	/* Catch up with all the deferred frees from "this" client */
+	i915_gem_flush_free_objects(to_i915(dev));
 }
 
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)

commit 50d84418f58699272a9220f9447bf89f0440c671
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Aug 2 18:40:50 2019 +0000

    drm/i915: Add i915 to i915_inject_probe_failure
    
    With i915 added to i915_inject_probe_failure we can use dedicated
    printk when injecting artificial load failure.
    
    Also make this function look like other i915 functions that return
    error code and make it more flexible to return any provided error
    code instead of previously assumed -ENODEV.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190802184055.31988-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d6178f5c6b50..21f1b29d06a2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -83,19 +83,20 @@ static struct drm_driver driver;
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
 static unsigned int i915_probe_fail_count;
 
-bool __i915_inject_probe_failure(const char *func, int line)
+int __i915_inject_load_error(struct drm_i915_private *i915, int err,
+			     const char *func, int line)
 {
 	if (i915_probe_fail_count >= i915_modparams.inject_load_failure)
-		return false;
+		return 0;
 
-	if (++i915_probe_fail_count == i915_modparams.inject_load_failure) {
-		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
-			 i915_modparams.inject_load_failure, func, line);
-		i915_modparams.inject_load_failure = 0;
-		return true;
-	}
+	if (++i915_probe_fail_count < i915_modparams.inject_load_failure)
+		return 0;
 
-	return false;
+	__i915_printk(i915, KERN_INFO,
+		      "Injecting failure %d at checkpoint %u [%s:%d]\n",
+		      err, i915_modparams.inject_load_failure, func, line);
+	i915_modparams.inject_load_failure = 0;
+	return err;
 }
 
 bool i915_error_injected(void)
@@ -687,7 +688,7 @@ static int i915_driver_modeset_probe(struct drm_device *dev)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
-	if (i915_inject_probe_failure())
+	if (i915_inject_probe_failure(dev_priv))
 		return -ENODEV;
 
 	if (HAS_DISPLAY(dev_priv)) {
@@ -894,7 +895,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 {
 	int ret = 0;
 
-	if (i915_inject_probe_failure())
+	if (i915_inject_probe_failure(dev_priv))
 		return -ENODEV;
 
 	intel_device_info_subplatform_init(dev_priv);
@@ -985,7 +986,7 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 {
 	int ret;
 
-	if (i915_inject_probe_failure())
+	if (i915_inject_probe_failure(dev_priv))
 		return -ENODEV;
 
 	if (i915_get_bridge_dev(dev_priv))
@@ -1530,7 +1531,7 @@ static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
-	if (i915_inject_probe_failure())
+	if (i915_inject_probe_failure(dev_priv))
 		return -ENODEV;
 
 	intel_device_info_runtime_init(dev_priv);

commit 9dfe3459ef4152ca4cf66c78cdd1ae5f58aaf2ae
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 31 17:57:09 2019 -0700

    drm/i915/gt: Introduce intel_gt_runtime_suspend/resume
    
    To be called from the top level runtime functions, to hide the
    gt-specific bits (mainly related to intel_uc).
    
    v2: rebased
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190801005709.34092-3-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1fde2357e167..d6178f5c6b50 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2925,7 +2925,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 */
 	i915_gem_runtime_suspend(dev_priv);
 
-	intel_uc_runtime_suspend(&dev_priv->gt.uc);
+	intel_gt_runtime_suspend(&dev_priv->gt);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
@@ -2950,9 +2950,8 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
-		intel_uc_runtime_resume(&dev_priv->gt.uc);
+		intel_gt_runtime_resume(&dev_priv->gt);
 
-		intel_gt_init_swizzling(&dev_priv->gt);
 		i915_gem_restore_fences(dev_priv);
 
 		enable_rpm_wakeref_asserts(rpm);
@@ -3047,13 +3046,11 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
-	intel_uc_runtime_resume(&dev_priv->gt.uc);
-
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
-	intel_gt_init_swizzling(&dev_priv->gt);
+	intel_gt_runtime_resume(&dev_priv->gt);
 	i915_gem_restore_fences(dev_priv);
 
 	/*

commit 6f76098fe0f3f0b519b2ad528b4319195d6d0f73
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 31 17:57:08 2019 -0700

    drm/i915/uc: Move uC early functions inside the GT ones
    
    uC is a subcomponent of GT, so initialize/clean it as part of it. The
    wopcm_init_early doesn't have to be happen before the uC one, but since
    in other parts of the code we consider WOPCM first do the same for
    consistency.
    
    v2: s/cleanup_early/late_release to match the caller
    v3: s/late_release/driver_late_release/ (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com> #v1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190801005709.34092-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6381f7b1e858..1fde2357e167 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -921,6 +921,8 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		return ret;
 
+	intel_wopcm_init_early(&dev_priv->wopcm);
+
 	intel_gt_init_early(&dev_priv->gt, dev_priv);
 
 	ret = i915_gem_init_early(dev_priv);
@@ -930,13 +932,11 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
 
-	intel_wopcm_init_early(&dev_priv->wopcm);
-	intel_uc_init_early(&dev_priv->gt.uc);
 	intel_pm_setup(dev_priv);
 	intel_init_dpio(dev_priv);
 	ret = intel_power_domains_init(dev_priv);
 	if (ret < 0)
-		goto err_uc;
+		goto err_gem;
 	intel_irq_init(dev_priv);
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
@@ -947,8 +947,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 	return 0;
 
-err_uc:
-	intel_uc_cleanup_early(&dev_priv->gt.uc);
+err_gem:
 	i915_gem_cleanup_early(dev_priv);
 err_workqueues:
 	intel_gt_driver_late_release(&dev_priv->gt);
@@ -965,7 +964,6 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 {
 	intel_irq_fini(dev_priv);
 	intel_power_domains_cleanup(dev_priv);
-	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
 	intel_gt_driver_late_release(&dev_priv->gt);
 	i915_workqueues_cleanup(dev_priv);

commit 6cf72db68d20230380a7a37dae31943c4d1d6e07
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jul 31 17:57:07 2019 -0700

    drm/i915/gt: Move gt_cleanup_early out of gem_cleanup_early
    
    We don't call the init_early function from within the gem code, so we
    shouldn't do it for the cleanup either.
    
    v2: while at it, s/gt_cleanup_early/gt_late_release (Chris)
    v3: s/late_release/driver_late_release/ (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com> #v1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190801005709.34092-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 08c5504e040c..6381f7b1e858 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -951,6 +951,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
 err_workqueues:
+	intel_gt_driver_late_release(&dev_priv->gt);
 	i915_workqueues_cleanup(dev_priv);
 	return ret;
 }
@@ -966,6 +967,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 	intel_power_domains_cleanup(dev_priv);
 	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
+	intel_gt_driver_late_release(&dev_priv->gt);
 	i915_workqueues_cleanup(dev_priv);
 
 	pm_qos_remove_request(&dev_priv->sb_qos);

commit 602776f96bfa50a6107af017522501c43a82b29a
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Jul 30 16:07:39 2019 -0700

    drm/i915/uc: Don't enable communication twice on resume
    
    When coming out of S3/S4 we sanitize and re-init the HW, which includes
    enabling communication during uc_init_hw. We therefore don't want to do
    that again in uc_resume and can just tell GuC to reload its state.
    
    v2: split uc_resume and uc_runtime_resume to match the suspend
        functions and to better differentiate the expected state in the 2
        scenarios (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190730230743.19542-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7d0813150146..08c5504e040c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2950,7 +2950,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
-		intel_uc_resume(&dev_priv->gt.uc);
+		intel_uc_runtime_resume(&dev_priv->gt.uc);
 
 		intel_gt_init_swizzling(&dev_priv->gt);
 		i915_gem_restore_fences(dev_priv);
@@ -3047,7 +3047,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
-	intel_uc_resume(&dev_priv->gt.uc);
+	intel_uc_runtime_resume(&dev_priv->gt.uc);
 
 	/*
 	 * No point of rolling back things in case of an error, as the best

commit 906339a95e5a35f01cdf0430fca6dd526870a5ae
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Tue Jul 23 18:39:16 2019 +0800

    drm/i915: Use dev_get_drvdata
    
    Instead of using to_pci_dev + pci_get_drvdata,
    use dev_get_drvdata to make code simpler.
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190723103915.3964-1-hslester96@gmail.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c81a35f832d..7d0813150146 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2395,8 +2395,7 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 
 static int i915_pm_prepare(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(kdev);
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_device *dev = dev_get_drvdata(kdev);
 
 	if (!dev) {
 		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
@@ -2411,8 +2410,7 @@ static int i915_pm_prepare(struct device *kdev)
 
 static int i915_pm_suspend(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(kdev);
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_device *dev = dev_get_drvdata(kdev);
 
 	if (!dev) {
 		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
@@ -2906,8 +2904,7 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 
 static int intel_runtime_suspend(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(kdev);
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_device *dev = dev_get_drvdata(kdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret;
@@ -3005,8 +3002,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 static int intel_runtime_resume(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(kdev);
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_device *dev = dev_get_drvdata(kdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;

commit f3bcb0cccd36c6eb6e3afbd61f83eeca32d6cc50
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 18 08:00:10 2019 +0100

    drm/i915: Remove obsolete engine cleanup
    
    Remove the outer layer cleanup of engine stubs; as i915_drv itself no
    longer tries to preallocate and so is not responsible for either the
    allocation or free. By the time we call the cleanup function, we already
    have cleaned up the engines.
    
    v2: Lack of symmetry between mmio_probe and mmio_release for handling
    the error cleanup. engine->destroy() is a compound function that is
    called earlier in the normal release as it ties together other bits of
    state.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190718070024.21781-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0caf2f3ce279..8c81a35f832d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -848,15 +848,6 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 	return -ENOMEM;
 }
 
-static void i915_engines_cleanup(struct drm_i915_private *i915)
-{
-	struct intel_engine_cs *engine;
-	enum intel_engine_id id;
-
-	for_each_engine(engine, i915, id)
-		kfree(engine);
-}
-
 static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
 {
 	destroy_workqueue(dev_priv->hotplug.dp_wq);
@@ -928,7 +919,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
-		goto err_engines;
+		return ret;
 
 	intel_gt_init_early(&dev_priv->gt, dev_priv);
 
@@ -961,8 +952,6 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	i915_gem_cleanup_early(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
-err_engines:
-	i915_engines_cleanup(dev_priv);
 	return ret;
 }
 
@@ -978,7 +967,6 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
-	i915_engines_cleanup(dev_priv);
 
 	pm_qos_remove_request(&dev_priv->sb_qos);
 	mutex_destroy(&dev_priv->sb_lock);
@@ -1039,6 +1027,7 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_mmio_release(struct drm_i915_private *dev_priv)
 {
+	intel_engines_cleanup(dev_priv);
 	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini_mmio(&dev_priv->uncore);
 	pci_dev_put(dev_priv->bridge_dev);

commit 03b0f2ce735e97e9f49790d4563c82515b8fa702
Merge: e4f86e437164 5f9e832c1370
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Mon Jul 22 21:24:10 2019 +0200

    Merge v5.3-rc1 into drm-misc-next
    
    Noralf needs some SPI patches in 5.3 to merge some work on tinydrm.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit ca7b2c1bbede6187342dd0bec8666ab4481fa6ad
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:13 2019 +0100

    drm/i915/uc: Move intel functions to intel_uc
    
    All the intel_uc_* can now be moved to work on the intel_uc structure
    for better encapsulation of uc-related actions.
    
    Note: I've introduced uc_to_gt instead of uc_to_i915 because the aim is
    to move everything to be gt-focused in the medium term, so we would've
    had to replace it soon anyway.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Acked-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-8-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 434819deac5b..0caf2f3ce279 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -940,7 +940,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	intel_detect_pch(dev_priv);
 
 	intel_wopcm_init_early(&dev_priv->wopcm);
-	intel_uc_init_early(dev_priv);
+	intel_uc_init_early(&dev_priv->gt.uc);
 	intel_pm_setup(dev_priv);
 	intel_init_dpio(dev_priv);
 	ret = intel_power_domains_init(dev_priv);
@@ -957,7 +957,7 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	return 0;
 
 err_uc:
-	intel_uc_cleanup_early(dev_priv);
+	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
@@ -975,7 +975,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 {
 	intel_irq_fini(dev_priv);
 	intel_power_domains_cleanup(dev_priv);
-	intel_uc_cleanup_early(dev_priv);
+	intel_uc_cleanup_early(&dev_priv->gt.uc);
 	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 	i915_engines_cleanup(dev_priv);
@@ -1014,7 +1014,7 @@ static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 
 	intel_uncore_prune_mmio_domains(&dev_priv->uncore);
 
-	intel_uc_init_mmio(dev_priv);
+	intel_uc_init_mmio(&dev_priv->gt.uc);
 
 	ret = intel_engines_init_mmio(dev_priv);
 	if (ret)
@@ -2939,7 +2939,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 */
 	i915_gem_runtime_suspend(dev_priv);
 
-	intel_uc_runtime_suspend(dev_priv);
+	intel_uc_runtime_suspend(&dev_priv->gt.uc);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
@@ -2964,7 +2964,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
-		intel_uc_resume(dev_priv);
+		intel_uc_resume(&dev_priv->gt.uc);
 
 		intel_gt_init_swizzling(&dev_priv->gt);
 		i915_gem_restore_fences(dev_priv);
@@ -3062,7 +3062,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
-	intel_uc_resume(dev_priv);
+	intel_uc_resume(&dev_priv->gt.uc);
 
 	/*
 	 * No point of rolling back things in case of an error, as the best

commit 8b5689d7e3ca889a7e55c79bc335b33e3f170a18
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:12 2019 +0100

    drm/i915/uc: move GuC/HuC inside intel_gt under a new intel_uc
    
    Being part of the GT HW, it make sense to keep the guc/huc structures
    inside the GT structure. To help with the encapsulation work done by the
    following patches, both structures are placed inside a new intel_uc
    container. Although this results in code with ugly nested dereferences
    (i915->gt.uc.guc...), it saves us the extra work required in moving
    the structures twice (i915 -> gt -> uc). The following patches will
    reduce the number of places where we try to access the guc/huc
    structures directly from i915 and reduce the ugliness.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-7-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44e13b9c8e25..434819deac5b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -426,7 +426,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = sseu->min_eu_in_pool;
 		break;
 	case I915_PARAM_HUC_STATUS:
-		value = intel_huc_check_status(&dev_priv->huc);
+		value = intel_huc_check_status(&dev_priv->gt.uc.huc);
 		if (value < 0)
 			return value;
 		break;

commit 0f261b241d9cd01d58dce85a35df26fd38320b10
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Sat Jul 13 11:00:11 2019 +0100

    drm/i915/uc: move GuC and HuC files under gt/uc/
    
    Both microcontrollers are part of the GT HW and are closely related to
    GT operations. To keep all the files cleanly together, they've been
    placed in their own subdir inside the gt/ folder
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190713100016.8026-6-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6953732719e2..44e13b9c8e25 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -65,6 +65,7 @@
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"
 #include "gt/intel_workarounds.h"
+#include "gt/uc/intel_uc.h"
 
 #include "i915_debugfs.h"
 #include "i915_drv.h"
@@ -76,7 +77,6 @@
 #include "intel_csr.h"
 #include "intel_drv.h"
 #include "intel_pm.h"
-#include "intel_uc.h"
 
 static struct drm_driver driver;
 

commit cb823ed9915b0d4064f3f51e936fbe13c089948a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 12 20:29:53 2019 +0100

    drm/i915/gt: Use intel_gt as the primary object for handling resets
    
    Having taken the first step in encapsulating the functionality by moving
    the related files under gt/, the next step is to start encapsulating by
    passing around the relevant structs rather than the global
    drm_i915_private. In this step, we pass intel_gt to intel_reset.c
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712192953.9187-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e2d1bed9454c..6953732719e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -947,7 +947,6 @@ static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		goto err_uc;
 	intel_irq_init(dev_priv);
-	intel_hangcheck_init(dev_priv);
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);
@@ -1967,7 +1966,7 @@ void i915_driver_remove(struct drm_device *dev)
 	 * all in-flight requests so that we can quickly unbind the active
 	 * resources.
 	 */
-	i915_gem_set_wedged(dev_priv);
+	intel_gt_set_wedged(&dev_priv->gt);
 
 	/* Flush any external code that still may be under the RCU lock */
 	synchronize_rcu();
@@ -1988,7 +1987,7 @@ void i915_driver_remove(struct drm_device *dev)
 	intel_csr_ucode_fini(dev_priv);
 
 	/* Free error state after interrupts are fully disabled. */
-	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
+	cancel_delayed_work_sync(&dev_priv->gt.hangcheck.work);
 	i915_reset_error_state(dev_priv);
 
 	i915_gem_driver_remove(dev_priv);

commit 0b61b8b07f6bc54b3e255bc40f63c3adfa968594
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:30 2019 +0200

    drm/i915: Propagate "_probe" function name suffix down
    
    Similar to the "_release" and "_remove" cases, consequently replace
    "_init" components of names of functions called from
    i915_driver_probe() with "_probe" suffixes for better code readability.
    
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-7-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3af8e602befe..e2d1bed9454c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -681,7 +681,7 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 	.can_switch = i915_switcheroo_can_switch,
 };
 
-static int i915_load_modeset_init(struct drm_device *dev)
+static int i915_driver_modeset_probe(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
@@ -890,7 +890,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_init_early - setup state not requiring device access
+ * i915_driver_early_probe - setup state not requiring device access
  * @dev_priv: device private
  *
  * Initialize everything that is a "SW-only" state, that is state not
@@ -899,7 +899,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
  * system memory allocation, setting up device specific attributes and
  * function hooks not requiring accessing the device.
  */
-static int i915_driver_init_early(struct drm_i915_private *dev_priv)
+static int i915_driver_early_probe(struct drm_i915_private *dev_priv)
 {
 	int ret = 0;
 
@@ -969,7 +969,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 
 /**
  * i915_driver_late_release - cleanup the setup done in
- *			       i915_driver_init_early()
+ *			       i915_driver_early_probe()
  * @dev_priv: device private
  */
 static void i915_driver_late_release(struct drm_i915_private *dev_priv)
@@ -986,7 +986,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_init_mmio - setup device MMIO
+ * i915_driver_mmio_probe - setup device MMIO
  * @dev_priv: device private
  *
  * Setup minimal device state necessary for MMIO accesses later in the
@@ -994,7 +994,7 @@ static void i915_driver_late_release(struct drm_i915_private *dev_priv)
  * side effects or exposing the driver via kernel internal or user space
  * interfaces.
  */
-static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
+static int i915_driver_mmio_probe(struct drm_i915_private *dev_priv)
 {
 	int ret;
 
@@ -1035,7 +1035,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_mmio_release - cleanup the setup done in i915_driver_init_mmio()
+ * i915_driver_mmio_release - cleanup the setup done in i915_driver_mmio_probe()
  * @dev_priv: device private
  */
 static void i915_driver_mmio_release(struct drm_i915_private *dev_priv)
@@ -1531,13 +1531,13 @@ static void edram_detect(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_init_hw - setup state requiring device access
+ * i915_driver_hw_probe - setup state requiring device access
  * @dev_priv: device private
  *
  * Setup state that requires accessing the device, but doesn't require
  * exposing the driver via kernel internal or userspace interfaces.
  */
-static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
+static int i915_driver_hw_probe(struct drm_i915_private *dev_priv)
 {
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
@@ -1906,7 +1906,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret)
 		goto out_fini;
 
-	ret = i915_driver_init_early(dev_priv);
+	ret = i915_driver_early_probe(dev_priv);
 	if (ret < 0)
 		goto out_pci_disable;
 
@@ -1914,15 +1914,15 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	i915_detect_vgpu(dev_priv);
 
-	ret = i915_driver_init_mmio(dev_priv);
+	ret = i915_driver_mmio_probe(dev_priv);
 	if (ret < 0)
 		goto out_runtime_pm_put;
 
-	ret = i915_driver_init_hw(dev_priv);
+	ret = i915_driver_hw_probe(dev_priv);
 	if (ret < 0)
 		goto out_cleanup_mmio;
 
-	ret = i915_load_modeset_init(&dev_priv->drm);
+	ret = i915_driver_modeset_probe(&dev_priv->drm);
 	if (ret < 0)
 		goto out_cleanup_hw;
 

commit 78dae1ac35dd0c50d0f118e886b1f466cb9311fe
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:29 2019 +0200

    drm/i915: Propagate "_remove" function name suffix down
    
    Similar to the "_release" case, consistently replace mixed
    "_cleanup"/"_fini"/"_fini_hw" components found in names of functions
    called from i915_driver_remove() with "_remove" or "_driver_remove"
    suffixes for better code readability.
    
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-6-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 60dad4450e28..3af8e602befe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -757,16 +757,16 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 cleanup_gem:
 	i915_gem_suspend(dev_priv);
-	i915_gem_fini_hw(dev_priv);
+	i915_gem_driver_remove(dev_priv);
 	i915_gem_driver_release(dev_priv);
 cleanup_modeset:
-	intel_modeset_cleanup(dev);
+	intel_modeset_driver_remove(dev);
 cleanup_irq:
 	intel_irq_uninstall(dev_priv);
 	intel_gmbus_teardown(dev_priv);
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);
-	intel_power_domains_fini_hw(dev_priv);
+	intel_power_domains_driver_remove(dev_priv);
 	vga_switcheroo_unregister_client(pdev);
 cleanup_vga_client:
 	vga_client_register(pdev, NULL, NULL, NULL);
@@ -1698,10 +1698,10 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_cleanup_hw - cleanup the setup done in i915_driver_init_hw()
+ * i915_driver_hw_remove - cleanup the setup done in i915_driver_hw_probe()
  * @dev_priv: device private
  */
-static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
+static void i915_driver_hw_remove(struct drm_i915_private *dev_priv)
 {
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
@@ -1935,7 +1935,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return 0;
 
 out_cleanup_hw:
-	i915_driver_cleanup_hw(dev_priv);
+	i915_driver_hw_remove(dev_priv);
 	i915_ggtt_driver_release(dev_priv);
 
 	/* Paranoia: make sure we have disabled everything before we exit. */
@@ -1976,11 +1976,11 @@ void i915_driver_remove(struct drm_device *dev)
 
 	drm_atomic_helper_shutdown(dev);
 
-	intel_gvt_cleanup(dev_priv);
+	intel_gvt_driver_remove(dev_priv);
 
-	intel_modeset_cleanup(dev);
+	intel_modeset_driver_remove(dev);
 
-	intel_bios_cleanup(dev_priv);
+	intel_bios_driver_remove(dev_priv);
 
 	vga_switcheroo_unregister_client(pdev);
 	vga_client_register(pdev, NULL, NULL, NULL);
@@ -1991,11 +1991,11 @@ void i915_driver_remove(struct drm_device *dev)
 	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 	i915_reset_error_state(dev_priv);
 
-	i915_gem_fini_hw(dev_priv);
+	i915_gem_driver_remove(dev_priv);
 
-	intel_power_domains_fini_hw(dev_priv);
+	intel_power_domains_driver_remove(dev_priv);
 
-	i915_driver_cleanup_hw(dev_priv);
+	i915_driver_hw_remove(dev_priv);
 
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 }

commit 3b58a94551368924d8a49baa349bc7694fbd7ddd
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:28 2019 +0200

    drm/i915: Propagate "_release" function name suffix down
    
    Replace mixed "_fini"/"_cleanup"/"_cleanup_hw" suffixes found in names
    of functions called from i915_driver_release() with "_release" suffix
    consistently.  This provides better code readability, especially
    helpful when trying to work out which phase the code is in.
    
    Functions names starting with "i915_driver_", i.e., those defined in
    drivers/gpu/dri/i915/i915_drv.c, just have their "cleanup" or "fini"
    parts of their names replaced with the "_release" suffix, while names
    of functions coming from other source files have been suffixed with
    "_driver_release" to avoid ambiguity with other possible .release entry
    points.
    
    v2: early_probe pairs better with late_release (Chris)
    v3: fix typo in commit message (Joonas)
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-5-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7371571d735d..60dad4450e28 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -758,7 +758,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 cleanup_gem:
 	i915_gem_suspend(dev_priv);
 	i915_gem_fini_hw(dev_priv);
-	i915_gem_fini(dev_priv);
+	i915_gem_driver_release(dev_priv);
 cleanup_modeset:
 	intel_modeset_cleanup(dev);
 cleanup_irq:
@@ -968,10 +968,11 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_cleanup_early - cleanup the setup done in i915_driver_init_early()
+ * i915_driver_late_release - cleanup the setup done in
+ *			       i915_driver_init_early()
  * @dev_priv: device private
  */
-static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
+static void i915_driver_late_release(struct drm_i915_private *dev_priv)
 {
 	intel_irq_fini(dev_priv);
 	intel_power_domains_cleanup(dev_priv);
@@ -1034,10 +1035,10 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 }
 
 /**
- * i915_driver_cleanup_mmio - cleanup the setup done in i915_driver_init_mmio()
+ * i915_driver_mmio_release - cleanup the setup done in i915_driver_init_mmio()
  * @dev_priv: device private
  */
-static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
+static void i915_driver_mmio_release(struct drm_i915_private *dev_priv)
 {
 	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini_mmio(&dev_priv->uncore);
@@ -1690,7 +1691,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		pci_disable_msi(pdev);
 	pm_qos_remove_request(&dev_priv->pm_qos);
 err_ggtt:
-	i915_ggtt_cleanup_hw(dev_priv);
+	i915_ggtt_driver_release(dev_priv);
 err_perf:
 	i915_perf_fini(dev_priv);
 	return ret;
@@ -1935,15 +1936,15 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 out_cleanup_hw:
 	i915_driver_cleanup_hw(dev_priv);
-	i915_ggtt_cleanup_hw(dev_priv);
+	i915_ggtt_driver_release(dev_priv);
 
 	/* Paranoia: make sure we have disabled everything before we exit. */
 	intel_sanitize_gt_powersave(dev_priv);
 out_cleanup_mmio:
-	i915_driver_cleanup_mmio(dev_priv);
+	i915_driver_mmio_release(dev_priv);
 out_runtime_pm_put:
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
-	i915_driver_cleanup_early(dev_priv);
+	i915_driver_late_release(dev_priv);
 out_pci_disable:
 	pci_disable_device(pdev);
 out_fini:
@@ -2006,19 +2007,19 @@ static void i915_driver_release(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(rpm);
 
-	i915_gem_fini(dev_priv);
+	i915_gem_driver_release(dev_priv);
 
-	i915_ggtt_cleanup_hw(dev_priv);
+	i915_ggtt_driver_release(dev_priv);
 
 	/* Paranoia: make sure we have disabled everything before we exit. */
 	intel_sanitize_gt_powersave(dev_priv);
 
-	i915_driver_cleanup_mmio(dev_priv);
+	i915_driver_mmio_release(dev_priv);
 
 	enable_rpm_wakeref_asserts(rpm);
-	intel_runtime_pm_cleanup(rpm);
+	intel_runtime_pm_driver_release(rpm);
 
-	i915_driver_cleanup_early(dev_priv);
+	i915_driver_late_release(dev_priv);
 	i915_driver_destroy(dev_priv);
 }
 
@@ -2211,7 +2212,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 out:
 	enable_rpm_wakeref_asserts(rpm);
 	if (!dev_priv->uncore.user_forcewake.count)
-		intel_runtime_pm_cleanup(rpm);
+		intel_runtime_pm_driver_release(rpm);
 
 	return ret;
 }
@@ -2975,7 +2976,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	}
 
 	enable_rpm_wakeref_asserts(rpm);
-	intel_runtime_pm_cleanup(rpm);
+	intel_runtime_pm_driver_release(rpm);
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");

commit f2db53f14d3d1cde1d4c3b5b5aaba556c953f2f5
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:27 2019 +0200

    drm/i915: Replace "_load" with "_probe" consequently
    
    Use the "_probe" nomenclature not only in i915_driver_probe() helper
    name but also in other related function / variable names for
    consistency.  Only the userspace exposed name of a related module
    parameter is left untouched.
    
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-4-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9488aa3cb9cc..7371571d735d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -81,14 +81,14 @@
 static struct drm_driver driver;
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
-static unsigned int i915_load_fail_count;
+static unsigned int i915_probe_fail_count;
 
-bool __i915_inject_load_failure(const char *func, int line)
+bool __i915_inject_probe_failure(const char *func, int line)
 {
-	if (i915_load_fail_count >= i915_modparams.inject_load_failure)
+	if (i915_probe_fail_count >= i915_modparams.inject_load_failure)
 		return false;
 
-	if (++i915_load_fail_count == i915_modparams.inject_load_failure) {
+	if (++i915_probe_fail_count == i915_modparams.inject_load_failure) {
 		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
 			 i915_modparams.inject_load_failure, func, line);
 		i915_modparams.inject_load_failure = 0;
@@ -100,7 +100,7 @@ bool __i915_inject_load_failure(const char *func, int line)
 
 bool i915_error_injected(void)
 {
-	return i915_load_fail_count && !i915_modparams.inject_load_failure;
+	return i915_probe_fail_count && !i915_modparams.inject_load_failure;
 }
 
 #endif
@@ -687,7 +687,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
-	if (i915_inject_load_failure())
+	if (i915_inject_probe_failure())
 		return -ENODEV;
 
 	if (HAS_DISPLAY(dev_priv)) {
@@ -903,7 +903,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 {
 	int ret = 0;
 
-	if (i915_inject_load_failure())
+	if (i915_inject_probe_failure())
 		return -ENODEV;
 
 	intel_device_info_subplatform_init(dev_priv);
@@ -997,7 +997,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 {
 	int ret;
 
-	if (i915_inject_load_failure())
+	if (i915_inject_probe_failure())
 		return -ENODEV;
 
 	if (i915_get_bridge_dev(dev_priv))
@@ -1541,7 +1541,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
-	if (i915_inject_load_failure())
+	if (i915_inject_probe_failure())
 		return -ENODEV;
 
 	intel_device_info_runtime_init(dev_priv);
@@ -1947,7 +1947,7 @@ int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_pci_disable:
 	pci_disable_device(pdev);
 out_fini:
-	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
+	i915_probe_error(dev_priv, "Device initialization failed (%d)\n", ret);
 	i915_driver_destroy(dev_priv);
 	return ret;
 }

commit b01558e56f84866dcad5f3f99819ec560d639f09
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:26 2019 +0200

    drm/i915: Rename "_load"/"_unload" to match PCI entry points
    
    Current names of i915_driver_load/unload() functions originate in
    legacy DRM stubs.  Reduce nomenclature ambiguity by renaming them to
    match their current use as helpers called from PCI entry points.
    
    Suggested by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-3-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8502a2e4268e..9488aa3cb9cc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1876,17 +1876,17 @@ static void i915_driver_destroy(struct drm_i915_private *i915)
 }
 
 /**
- * i915_driver_load - setup chip and create an initial config
+ * i915_driver_probe - setup chip and create an initial config
  * @pdev: PCI device
  * @ent: matching PCI ID entry
  *
- * The driver load routine has to do several things:
+ * The driver probe routine has to do several things:
  *   - drive output discovery via intel_modeset_init()
  *   - initialize the memory manager
  *   - allocate initial config memory
  *   - setup the DRM framebuffer with the allocated memory
  */
-int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
+int i915_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	const struct intel_device_info *match_info =
 		(struct intel_device_info *)ent->driver_data;
@@ -1952,7 +1952,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return ret;
 }
 
-void i915_driver_unload(struct drm_device *dev)
+void i915_driver_remove(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;

commit d8df6bec1a30097f65781faf4877e4da7a520002
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Thu Jul 11 10:30:58 2019 -0700

    drm/i915/tgl: Add TGL PCH detection in virtualized environment
    
    Assume PCH_TGP when platform is TGL.
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190711173115.28296-5-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 93441f2aaf15..8502a2e4268e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -255,7 +255,9 @@ intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_ELKHARTLAKE(dev_priv))
+	if (IS_TIGERLAKE(dev_priv))
+		id = INTEL_PCH_TGP_DEVICE_ID_TYPE;
+	else if (IS_ELKHARTLAKE(dev_priv))
 		id = INTEL_PCH_MCC_DEVICE_ID_TYPE;
 	else if (IS_ICELAKE(dev_priv))
 		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;

commit 7f02889292e2e3fe6390b98d4ebc3dd67f20a812
Author: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
Date:   Thu Jul 11 10:30:57 2019 -0700

    drm/i915/tgl: Introduce Tiger Lake PCH
    
    Add the enum additions to TGP.
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: David Weinehall <david.weinehall@intel.com>
    Cc: James Ausmus <james.ausmus@intel.com>
    Signed-off-by: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190711173115.28296-4-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 12182d2fc03c..93441f2aaf15 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -224,6 +224,10 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 		DRM_DEBUG_KMS("Found Mule Creek Canyon PCH\n");
 		WARN_ON(!IS_ELKHARTLAKE(dev_priv));
 		return PCH_MCC;
+	case INTEL_PCH_TGP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Tiger Lake LP PCH\n");
+		WARN_ON(!IS_TIGERLAKE(dev_priv));
+		return PCH_TGP;
 	default:
 		return PCH_NONE;
 	}

commit 7d23e59376039d08728444cf05b2db6f7b86ff22
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Jun 19 20:08:42 2019 +0300

    drm/i915: Initialize drm_driver vblank funcs at compile time
    
    Move the .get_vblank_timestamp() and .get_scanout_position()
    initialization to happen at compile time. No point in delaying
    it since we always assign the same functions.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190619170842.20579-5-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 441a68338b9b..12182d2fc03c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3232,6 +3232,9 @@ static struct drm_driver driver = {
 	.gem_prime_export = i915_gem_prime_export,
 	.gem_prime_import = i915_gem_prime_import,
 
+	.get_vblank_timestamp = drm_calc_vbltimestamp_from_scanoutpos,
+	.get_scanout_position = i915_get_crtc_scanoutpos,
+
 	.dumb_create = i915_gem_dumb_create,
 	.dumb_map_offset = i915_gem_mmap_gtt,
 	.ioctls = i915_ioctls,

commit b318b82455bd9b2899a61108a6d84d4a2d4b6df8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jun 20 13:33:34 2019 +0300

    drm/i915: Nuke drm_driver irq vfuncs
    
    Stop using the irq vfuncs under drm_driver. That's not going to fly
    in a mixed gen environment since the structure is shared between all
    the devices.
    
    v2: Allow intel_irq_uninstall() to be called twice due to
        intel_modeset_cleanup() calling it as well. Toss in a
        FIXME to remind us that this is not great.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190620103334.15651-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f5b7c37c165f..441a68338b9b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -756,7 +756,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 cleanup_modeset:
 	intel_modeset_cleanup(dev);
 cleanup_irq:
-	drm_irq_uninstall(dev);
+	intel_irq_uninstall(dev_priv);
 	intel_gmbus_teardown(dev_priv);
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);

commit b402375699ae84880bf2af56e455239b8807c3a6
Author: Emil Velikov <emil.velikov@collabora.com>
Date:   Wed May 22 16:47:01 2019 +0100

    drm/i915: remove irrelevant DRM_UNLOCKED flag
    
    DRM_UNLOCKED doesn't do anything for non-legacy drivers. Remove it.
    
    Cc: intel-gfx@lists.freedesktop.org
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190522154702.16269-3-emil.l.velikov@gmail.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index db1f7d410c9a..bec6e4aad5da 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3162,9 +3162,9 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_OPEN, i915_perf_open_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_VM_CREATE, i915_gem_vm_create_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_VM_DESTROY, i915_gem_vm_destroy_ioctl, DRM_RENDER_ALLOW),
 };

commit 0c91621cad492e362c37330e1a0985bcdda00fda
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jun 25 14:01:10 2019 +0100

    drm/i915/gt: Pass intel_gt to pm routines
    
    Switch from passing the i915 container to newly named struct intel_gt.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190625130128.11009-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6241a4615501..f5b7c37c165f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2377,7 +2377,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
-	intel_gt_sanitize(dev_priv, true);
+	intel_gt_sanitize(&dev_priv->gt, true);
 
 	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 

commit fc25441c7b9d81dc18cce0a0fa5527370e386652
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Fri Jun 21 08:18:47 2019 -0700

    drm/i915/ehl: Add one additional PCH ID to MCC
    
    There's one additional ID that we should treat as Mule Creek Canyon.
    
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621151847.31302-1-matthew.d.roper@intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4a211d5e2701..6241a4615501 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -220,6 +220,7 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 		WARN_ON(!IS_ICELAKE(dev_priv));
 		return PCH_ICP;
 	case INTEL_PCH_MCC_DEVICE_ID_TYPE:
+	case INTEL_PCH_MCC2_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found Mule Creek Canyon PCH\n");
 		WARN_ON(!IS_ELKHARTLAKE(dev_priv));
 		return PCH_MCC;

commit 0424fdaf883a689d5185c0d0665b265373945898
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 17 17:39:24 2019 +0200

    drm/prime: Actually remove DRIVER_PRIME everywhere
    
    Split out to make the functional changes stick out more.
    
    All places where DRIVER_PRIME was used have been removed in previous
    patches already.
    
    v2: amdgpu gained DRIVER_SYNCOBJ_TIMELINE.
    
    v3: amdgpu lost DRIVER_SYNCOBJ_TIMELINE.
    
    v4: Don't add a space in i915_drv.c (Sam)
    
    v5: Add note that previous patches removed all the DRIVER_PRIME users
    already (Emil).
    
    v6: Fixupe ingenic (new driver) while applying.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: freedreno@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: lima@lists.freedesktop.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: linux-aspeed@lists.ozlabs.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: nouveau@lists.freedesktop.org
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: spice-devel@lists.freedesktop.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: xen-devel@lists.xenproject.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617153924.414-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83d2eb9e74cb..db1f7d410c9a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3174,7 +3174,7 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_GEM | DRIVER_PRIME |
+	    DRIVER_GEM |
 	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_SYNCOBJ,
 	.release = i915_driver_release,
 	.open = i915_driver_open,

commit d8a4424839eead6da07835e7d2f8b8f54ad6c6b0
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Jun 21 08:08:06 2019 +0100

    drm/i915: Store ggtt pointer in intel_gt
    
    This will become useful in the following patch.
    
    v2:
     * Assign the pointer through a helper on the top level to work around
       the layering violation. (Chris)
    
    v3:
     * Handle selftests.
    
    v4:
     * Move call to intel_gt_init_hw into mock_init_ggtt. (Chris)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-28-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c02fdefcb356..4a211d5e2701 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1593,6 +1593,8 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	if (ret)
 		goto err_ggtt;
 
+	intel_gt_init_hw(dev_priv);
+
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to enable GGTT\n");

commit 500bfa380e112f744f8ae316c88c0e849833d804
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Jun 21 08:07:45 2019 +0100

    drm/i915: Convert i915_gem_init_swizzling to intel_gt
    
    Start using the newly introduced struct intel_gt to fuse together correct
    logical init flow with uncore for more removal of implicit dev_priv in
    mmio access.
    
    v2:
     * Move code to i915_gem_fence_reg. (Chris)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-7-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ef4100ed49fd..c02fdefcb356 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2957,7 +2957,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_uc_resume(dev_priv);
 
-		i915_gem_init_swizzling(dev_priv);
+		intel_gt_init_swizzling(&dev_priv->gt);
 		i915_gem_restore_fences(dev_priv);
 
 		enable_rpm_wakeref_asserts(rpm);
@@ -3059,7 +3059,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
-	i915_gem_init_swizzling(dev_priv);
+	intel_gt_init_swizzling(&dev_priv->gt);
 	i915_gem_restore_fences(dev_priv);
 
 	/*

commit eaf522f62b7454c4c040c4672c36ad0f4cb21fcd
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Jun 21 08:07:44 2019 +0100

    drm/i915: Make i915_check_and_clear_faults take intel_gt
    
    Continuing the conversion and elimination of implicit dev_priv.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Suggested-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-6-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index df11a0d6d52d..ef4100ed49fd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2361,7 +2361,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_resume_early(&dev_priv->uncore);
 
-	i915_check_and_clear_faults(dev_priv);
+	intel_gt_check_and_clear_faults(&dev_priv->gt);
 
 	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv)) {
 		gen9_sanitize_dc_state(dev_priv);

commit 724e9564c5acd40c422db2ccb57b1f66433021aa
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Jun 21 08:07:42 2019 +0100

    drm/i915: Store some backpointers in struct intel_gt
    
    We need an easy way to get back to i915 and uncore.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-4-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 961f76d3efa4..df11a0d6d52d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -923,7 +923,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		goto err_engines;
 
-	intel_gt_init_early(&dev_priv->gt);
+	intel_gt_init_early(&dev_priv->gt, dev_priv);
 
 	ret = i915_gem_init_early(dev_priv);
 	if (ret < 0)

commit 24635c5152af5a6b79eec17d721685277f8d4cfc
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Jun 21 08:07:41 2019 +0100

    drm/i915: Move intel_gt initialization to a separate file
    
    As it will grow in a following patch make a new home for it.
    
    v2:
     * Convert mock_gem_device as well. (Chris)
    
    v3:
     * Rename to intel_gt_init_early and move call site to i915_drv.c. (Chris)
    
    v4:
     * Adjust SPDX tags.
     * No need to gt/ path when including intel_gt_types.h. (Chris)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621070811.7006-3-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8f84ed26e972..961f76d3efa4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,6 +61,7 @@
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
+#include "gt/intel_gt.h"
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"
 #include "gt/intel_workarounds.h"
@@ -922,6 +923,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		goto err_engines;
 
+	intel_gt_init_early(&dev_priv->gt);
+
 	ret = i915_gem_init_early(dev_priv);
 	if (ret < 0)
 		goto err_workqueues;

commit 9e138ea1bdb1d1c1f1c0b74f022f886196abf625
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jun 19 18:00:21 2019 -0700

    drm/i915/gvt: decouple check_vgpu() from uncore_init()
    
    With multiple uncore to initialize (GT vs Display), it makes little
    sense to have the vgpu_check inside uncore_init(). We also have
    a catch-22 scenario where the uncore is required to read the vgpu
    capabilities while the vgpu capabilities are required to decide if
    we need to initialize forcewake support. To remove this circular
    dependency, we can perform the required MMIO access by mmapping just
    the vgtif shared page in mmio space and use raw accessors.
    
    v2: rename check_vgpu to detect_vgpu (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190620010021.20637-7-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 00b6512cdee6..8f84ed26e972 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1899,6 +1899,8 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
+	i915_detect_vgpu(dev_priv);
+
 	ret = i915_driver_init_mmio(dev_priv);
 	if (ret < 0)
 		goto out_runtime_pm_put;

commit 013857580bbece05a89d6a323799960ffaefdb8c
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jun 19 18:00:18 2019 -0700

    drm/i915: kill uncore_to_i915
    
    Let's get rid of it before it proliferates, since with split GT/Display
    uncores the container_of won't work anymore.
    
    I've kept the rpm pointer as well to minimize the pointer chasing in the
    MMIO accessors.
    
    v2: swap parameter order for intel_uncore_init_early (Tvrtko)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190620010021.20637-4-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 458784fd556e..00b6512cdee6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -900,7 +900,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 
 	intel_device_info_subplatform_init(dev_priv);
 
-	intel_uncore_init_early(&dev_priv->uncore);
+	intel_uncore_init_early(&dev_priv->uncore, dev_priv);
 
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);

commit 19e0a8d454c3e581a877071a87b349a8bf6b9a7c
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Wed Jun 19 18:00:17 2019 -0700

    drm/i915: kill uncore_sanitize
    
    uncore_sanitize performs no action on the uncore structure and just
    calls intel_sanitize_gt_powersave, so we can just call the latter
    directly.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190620010021.20637-3-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f62e3397d936..458784fd556e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1629,7 +1629,8 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
 			   PM_QOS_DEFAULT_VALUE);
 
-	intel_uncore_sanitize(dev_priv);
+	/* BIOS often leaves RC6 enabled, but disable it for hw init */
+	intel_sanitize_gt_powersave(dev_priv);
 
 	intel_gt_init_workarounds(dev_priv);
 
@@ -1921,6 +1922,9 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_cleanup_hw:
 	i915_driver_cleanup_hw(dev_priv);
 	i915_ggtt_cleanup_hw(dev_priv);
+
+	/* Paranoia: make sure we have disabled everything before we exit. */
+	intel_sanitize_gt_powersave(dev_priv);
 out_cleanup_mmio:
 	i915_driver_cleanup_mmio(dev_priv);
 out_runtime_pm_put:
@@ -1991,6 +1995,10 @@ static void i915_driver_release(struct drm_device *dev)
 	i915_gem_fini(dev_priv);
 
 	i915_ggtt_cleanup_hw(dev_priv);
+
+	/* Paranoia: make sure we have disabled everything before we exit. */
+	intel_sanitize_gt_powersave(dev_priv);
+
 	i915_driver_cleanup_mmio(dev_priv);
 
 	enable_rpm_wakeref_asserts(rpm);
@@ -2357,7 +2365,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		hsw_disable_pc8(dev_priv);
 	}
 
-	intel_uncore_sanitize(dev_priv);
+	intel_sanitize_gt_powersave(dev_priv);
 
 	intel_power_domains_resume(dev_priv);
 

commit c6f7acb80abf5f73be4ee08541e3393a0146b15e
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Fri Jun 14 17:42:10 2019 -0700

    drm/i915/ehl: Introduce Mule Creek Canyon PCH
    
    Although EHL introduces a new PCH, the South Display part of the PCH
    that we care about is nearly identical to ICP, just with some pins
    remapped.  Most notably, Port C is mapped to the pins that ICP uses for
    TC Port 1.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190615004210.16656-1-matthew.d.roper@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 535b9be4fc58..f62e3397d936 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -218,6 +218,10 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 		DRM_DEBUG_KMS("Found Ice Lake PCH\n");
 		WARN_ON(!IS_ICELAKE(dev_priv));
 		return PCH_ICP;
+	case INTEL_PCH_MCC_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Mule Creek Canyon PCH\n");
+		WARN_ON(!IS_ELKHARTLAKE(dev_priv));
+		return PCH_MCC;
 	default:
 		return PCH_NONE;
 	}
@@ -245,7 +249,9 @@ intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_ICELAKE(dev_priv))
+	if (IS_ELKHARTLAKE(dev_priv))
+		id = INTEL_PCH_MCC_DEVICE_ID_TYPE;
+	else if (IS_ICELAKE(dev_priv))
 		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;
 	else if (IS_CANNONLAKE(dev_priv) || IS_COFFEELAKE(dev_priv))
 		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;

commit df0566a641f959108c152be748a0a58794280e0e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jun 13 11:44:16 2019 +0300

    drm/i915: move modesetting core code under display/
    
    Now that we have a new subdirectory for display code, continue by moving
    modesetting core code.
    
    display/intel_frontbuffer.h sticks out like a sore thumb, otherwise this
    is, again, a surprisingly clean operation.
    
    v2:
    - don't move intel_sideband.[ch] (Ville)
    - use tabs for Makefile file lists and sort them
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613084416.6794-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a9a26fe65266..535b9be4fc58 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,8 +47,17 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
+#include "display/intel_acpi.h"
+#include "display/intel_audio.h"
+#include "display/intel_bw.h"
+#include "display/intel_cdclk.h"
 #include "display/intel_dp.h"
+#include "display/intel_fbdev.h"
 #include "display/intel_gmbus.h"
+#include "display/intel_hotplug.h"
+#include "display/intel_overlay.h"
+#include "display/intel_pipe_crc.h"
+#include "display/intel_sprite.h"
 
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
@@ -63,18 +72,9 @@
 #include "i915_query.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
-#include "intel_acpi.h"
-#include "intel_audio.h"
-#include "intel_bw.h"
-#include "intel_cdclk.h"
 #include "intel_csr.h"
 #include "intel_drv.h"
-#include "intel_fbdev.h"
-#include "intel_hotplug.h"
-#include "intel_overlay.h"
-#include "intel_pipe_crc.h"
 #include "intel_pm.h"
-#include "intel_sprite.h"
 #include "intel_uc.h"
 
 static struct drm_driver driver;

commit 379bc100232acd45b19421bd0748f9f549da8a8a
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jun 13 11:44:15 2019 +0300

    drm/i915: move modesetting output/encoder code under display/
    
    Add a new subdirectory for display code, and start off by moving
    modesetting output/encoder code. Judging by the include changes, this is
    a surprisingly clean operation.
    
    v2:
    - move intel_sdvo_regs.h too
    - use tabs for Makefile file lists and sort them
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613084416.6794-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 65d599065709..a9a26fe65266 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,6 +47,9 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
+#include "display/intel_dp.h"
+#include "display/intel_gmbus.h"
+
 #include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
 #include "gt/intel_gt_pm.h"
@@ -65,10 +68,8 @@
 #include "intel_bw.h"
 #include "intel_cdclk.h"
 #include "intel_csr.h"
-#include "intel_dp.h"
 #include "intel_drv.h"
 #include "intel_fbdev.h"
-#include "intel_gmbus.h"
 #include "intel_hotplug.h"
 #include "intel_overlay.h"
 #include "intel_pipe_crc.h"

commit 69c663554452e6589144046331d08e597e7f5823
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:53 2019 -0700

    drm/i915: move a few more functions to accept the rpm structure
    
    Focusing on the functions called in few places.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-6-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6236d3323e71..65d599065709 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -909,7 +909,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	mutex_init(&dev_priv->hdcp_comp_mutex);
 
 	i915_memcpy_init_early(dev_priv);
-	intel_runtime_pm_init_early(dev_priv);
+	intel_runtime_pm_init_early(&dev_priv->runtime_pm);
 
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
@@ -1751,7 +1751,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		drm_kms_helper_poll_init(dev);
 
 	intel_power_domains_enable(dev_priv);
-	intel_runtime_pm_enable(dev_priv);
+	intel_runtime_pm_enable(&dev_priv->runtime_pm);
 }
 
 /**
@@ -1760,7 +1760,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
-	intel_runtime_pm_disable(dev_priv);
+	intel_runtime_pm_disable(&dev_priv->runtime_pm);
 	intel_power_domains_disable(dev_priv);
 
 	intel_fbdev_unregister(dev_priv);
@@ -1977,16 +1977,17 @@ void i915_driver_unload(struct drm_device *dev)
 static void i915_driver_release(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 
-	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	disable_rpm_wakeref_asserts(rpm);
 
 	i915_gem_fini(dev_priv);
 
 	i915_ggtt_cleanup_hw(dev_priv);
 	i915_driver_cleanup_mmio(dev_priv);
 
-	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
-	intel_runtime_pm_cleanup(dev_priv);
+	enable_rpm_wakeref_asserts(rpm);
+	intel_runtime_pm_cleanup(rpm);
 
 	i915_driver_cleanup_early(dev_priv);
 	i915_driver_destroy(dev_priv);
@@ -2135,9 +2136,10 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
+	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret;
 
-	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	disable_rpm_wakeref_asserts(rpm);
 
 	i915_gem_suspend_late(dev_priv);
 
@@ -2178,9 +2180,9 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 		pci_set_power_state(pdev, PCI_D3hot);
 
 out:
-	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
+	enable_rpm_wakeref_asserts(rpm);
 	if (!dev_priv->uncore.user_forcewake.count)
-		intel_runtime_pm_cleanup(dev_priv);
+		intel_runtime_pm_cleanup(rpm);
 
 	return ret;
 }
@@ -2944,7 +2946,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	}
 
 	enable_rpm_wakeref_asserts(rpm);
-	intel_runtime_pm_cleanup(dev_priv);
+	intel_runtime_pm_cleanup(rpm);
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");

commit 1bf676cc2dbaeec7a52ea93e71660f746123c2fe
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:52 2019 -0700

    drm/i915: move and rename i915_runtime_pm
    
    Asserts aside, all the code working on this structure is in
    intel_runtime_pm.c and uses the intel_ prefix, so move the
    structure to intel_runtime_pm.h and adopt the same prefix.
    
    Since all the asserts are now working on the runtime_pm structure,
    bring them across as well.
    
    v2: drop unneeded include (Chris), don't rename debugfs, rebase
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-5-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 118d774506ae..6236d3323e71 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2889,7 +2889,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
-	struct i915_runtime_pm *rpm = &dev_priv->runtime_pm;
+	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret;
 
 	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && HAS_RC6(dev_priv))))
@@ -2988,7 +2988,7 @@ static int intel_runtime_resume(struct device *kdev)
 	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
-	struct i915_runtime_pm *rpm = &dev_priv->runtime_pm;
+	struct intel_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))

commit 9102650fb97548f8a08120c7d0174b39092257d6
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:51 2019 -0700

    drm/i915: make enable/disable rpm assert function use the rpm structure
    
    With this all the rpm assert-related functions consistently work on
    the i915_runtime_pm structure
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-4-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 254f7b7df306..118d774506ae 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1889,7 +1889,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret < 0)
 		goto out_pci_disable;
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	ret = i915_driver_init_mmio(dev_priv);
 	if (ret < 0)
@@ -1905,7 +1905,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	i915_driver_register(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	i915_welcome_messages(dev_priv);
 
@@ -1917,7 +1917,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_cleanup_mmio:
 	i915_driver_cleanup_mmio(dev_priv);
 out_runtime_pm_put:
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 	i915_driver_cleanup_early(dev_priv);
 out_pci_disable:
 	pci_disable_device(pdev);
@@ -1932,7 +1932,7 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	i915_driver_unregister(dev_priv);
 
@@ -1971,21 +1971,21 @@ void i915_driver_unload(struct drm_device *dev)
 
 	i915_driver_cleanup_hw(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 }
 
 static void i915_driver_release(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	i915_gem_fini(dev_priv);
 
 	i915_ggtt_cleanup_hw(dev_priv);
 	i915_driver_cleanup_mmio(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 	intel_runtime_pm_cleanup(dev_priv);
 
 	i915_driver_cleanup_early(dev_priv);
@@ -2080,7 +2080,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	pci_power_t opregion_target_state;
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
@@ -2114,7 +2114,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_csr_ucode_suspend(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	return 0;
 }
@@ -2137,7 +2137,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	i915_gem_suspend_late(dev_priv);
 
@@ -2178,7 +2178,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 		pci_set_power_state(pdev, PCI_D3hot);
 
 out:
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 	if (!dev_priv->uncore.user_forcewake.count)
 		intel_runtime_pm_cleanup(dev_priv);
 
@@ -2214,7 +2214,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 	intel_sanitize_gt_powersave(dev_priv);
 
 	i915_gem_sanitize(dev_priv);
@@ -2274,7 +2274,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_power_domains_enable(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	return 0;
 }
@@ -2329,7 +2329,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	pci_set_master(pdev);
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
@@ -2354,7 +2354,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_gt_sanitize(dev_priv, true);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 
 	return ret;
 }
@@ -2889,6 +2889,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct i915_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret;
 
 	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && HAS_RC6(dev_priv))))
@@ -2899,7 +2900,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
-	disable_rpm_wakeref_asserts(dev_priv);
+	disable_rpm_wakeref_asserts(rpm);
 
 	/*
 	 * We are safe here against re-faults, since the fault handler takes
@@ -2937,18 +2938,18 @@ static int intel_runtime_suspend(struct device *kdev)
 		i915_gem_init_swizzling(dev_priv);
 		i915_gem_restore_fences(dev_priv);
 
-		enable_rpm_wakeref_asserts(dev_priv);
+		enable_rpm_wakeref_asserts(rpm);
 
 		return ret;
 	}
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(rpm);
 	intel_runtime_pm_cleanup(dev_priv);
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");
 
-	dev_priv->runtime_pm.suspended = true;
+	rpm->suspended = true;
 
 	/*
 	 * FIXME: We really should find a document that references the arguments
@@ -2987,6 +2988,7 @@ static int intel_runtime_resume(struct device *kdev)
 	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct i915_runtime_pm *rpm = &dev_priv->runtime_pm;
 	int ret = 0;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
@@ -2994,11 +2996,11 @@ static int intel_runtime_resume(struct device *kdev)
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
-	WARN_ON_ONCE(atomic_read(&dev_priv->runtime_pm.wakeref_count));
-	disable_rpm_wakeref_asserts(dev_priv);
+	WARN_ON_ONCE(atomic_read(&rpm->wakeref_count));
+	disable_rpm_wakeref_asserts(rpm);
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
-	dev_priv->runtime_pm.suspended = false;
+	rpm->suspended = false;
 	if (intel_uncore_unclaimed_mmio(&dev_priv->uncore))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
@@ -3048,7 +3050,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_enable_ipc(dev_priv);
 
-	enable_rpm_wakeref_asserts(dev_priv);
+	enable_rpm_wakeref_asserts(rpm);
 
 	if (ret)
 		DRM_ERROR("Runtime resume failed, disabling it (%d)\n", ret);

commit 0cf289bd5de3f26d28781d81650e5bf022702a7e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 13 08:32:54 2019 +0100

    drm/i915: Move fence register tracking from i915->mm to ggtt
    
    As the fence registers only apply to regions inside the GGTT is makes
    more sense that we track these as part of the i915_ggtt and not the
    general mm. In the next patch, we will then pull the register locking
    underneath the i915_ggtt.mutex.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613073254.24048-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 81ff2c78fd55..254f7b7df306 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -350,7 +350,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = pdev->revision;
 		break;
 	case I915_PARAM_NUM_FENCES_AVAIL:
-		value = dev_priv->num_fence_regs;
+		value = dev_priv->ggtt.num_fences;
 		break;
 	case I915_PARAM_HAS_OVERLAY:
 		value = dev_priv->overlay ? 1 : 0;
@@ -1625,7 +1625,6 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	intel_uncore_sanitize(dev_priv);
 
 	intel_gt_init_workarounds(dev_priv);
-	i915_gem_load_init_fences(dev_priv);
 
 	/* On the 945G/GM, the chipset reports the MSI capability on the
 	 * integrated graphics even though the support isn't actually there

commit 5a31d30b22c04615329132f0c7fa20b4b6079b43
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Jun 11 11:45:47 2019 +0100

    drm/i915: Remove I915_READ_NOTRACE
    
    Only a few call sites remain which have been converted to uncore mmio
    accessors and so the macro can be removed.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190611104548.30545-5-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1af6751e1b36..81ff2c78fd55 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2708,7 +2708,7 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
 }
 
-static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
+static int vlv_wait_for_pw_status(struct drm_i915_private *i915,
 				  u32 mask, u32 val)
 {
 	i915_reg_t reg = VLV_GTLC_PW_STATUS;
@@ -2722,7 +2722,9 @@ static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
 	 * Transitioning between RC6 states should be at most 2ms (see
 	 * valleyview_enable_rps) so use a 3ms timeout.
 	 */
-	ret = wait_for(((reg_value = I915_READ_NOTRACE(reg)) & mask) == val, 3);
+	ret = wait_for(((reg_value =
+			 intel_uncore_read_notrace(&i915->uncore, reg)) & mask)
+		       == val, 3);
 
 	/* just trace the final value */
 	trace_i915_reg_rw(false, reg, reg_value, sizeof(reg_value), true);

commit 47bc28d7ee6d8378ba4451c43885cb3241302243
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Thu May 30 15:31:05 2019 +0200

    drm/i915: Split off pci_driver.remove() tail to drm_driver.release()
    
    In order to support driver hot unbind, some cleanup operations, now
    performed on PCI driver remove, must be called later, after all device
    file descriptors are closed.
    
    Split out those operations from the tail of pci_driver.remove()
    callback and put them into drm_driver.release() which is called as soon
    as all references to the driver are put.  As a result, those cleanups
    will be now run on last drm_dev_put(), either still called from
    pci_driver.remove() if all device file descriptors are already closed,
    or on last drm_release() file operation.
    
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190530133105.30467-1-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6a8b31f631ac..1af6751e1b36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -742,6 +742,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 cleanup_gem:
 	i915_gem_suspend(dev_priv);
+	i915_gem_fini_hw(dev_priv);
 	i915_gem_fini(dev_priv);
 cleanup_modeset:
 	intel_modeset_cleanup(dev);
@@ -1690,7 +1691,6 @@ static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 		pci_disable_msi(pdev);
 
 	pm_qos_remove_request(&dev_priv->pm_qos);
-	i915_ggtt_cleanup_hw(dev_priv);
 }
 
 /**
@@ -1914,6 +1914,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 out_cleanup_hw:
 	i915_driver_cleanup_hw(dev_priv);
+	i915_ggtt_cleanup_hw(dev_priv);
 out_cleanup_mmio:
 	i915_driver_cleanup_mmio(dev_priv);
 out_runtime_pm_put:
@@ -1965,21 +1966,29 @@ void i915_driver_unload(struct drm_device *dev)
 	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 	i915_reset_error_state(dev_priv);
 
-	i915_gem_fini(dev_priv);
+	i915_gem_fini_hw(dev_priv);
 
 	intel_power_domains_fini_hw(dev_priv);
 
 	i915_driver_cleanup_hw(dev_priv);
-	i915_driver_cleanup_mmio(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
-	intel_runtime_pm_cleanup(dev_priv);
 }
 
 static void i915_driver_release(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 
+	disable_rpm_wakeref_asserts(dev_priv);
+
+	i915_gem_fini(dev_priv);
+
+	i915_ggtt_cleanup_hw(dev_priv);
+	i915_driver_cleanup_mmio(dev_priv);
+
+	enable_rpm_wakeref_asserts(dev_priv);
+	intel_runtime_pm_cleanup(dev_priv);
+
 	i915_driver_cleanup_early(dev_priv);
 	i915_driver_destroy(dev_priv);
 }

commit a10f361d176ce53c72d5b1b2e2913a1a222ee393
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 29 11:21:50 2019 +0300

    Revert "drm/i915: Expand subslice mask"
    
    This reverts commit 1ac159e23c2c ("drm/i915: Expand subslice mask"),
    which kills ICL due to GEM_BUG_ON() sanity checks before CI even gets a
    chance to do anything.
    
    The commit exposes an issue in commit 1e40d4aea57b ("drm/i915/cnl:
    Implement WaProgramMgsrForCorrectSliceSpecificMmioReads"), which will
    also need to be addressed.
    
    There's a proposed fix [1], but considering the seeming uncertainty with
    the fix as well as the size of the regressing commit (in this context,
    the one that actually brings down ICL), this warrants a revert to get
    ICL working, and gives us time to get all of this right without
    rushing. Even if this means shooting the messenger.
    
    <3>[    9.426327] intel_sseu_get_subslices:46 GEM_BUG_ON(slice >= sseu->max_slices)
    <4>[    9.426355] ------------[ cut here ]------------
    <2>[    9.426357] kernel BUG at drivers/gpu/drm/i915/gt/intel_sseu.c:46!
    <4>[    9.426371] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
    <4>[    9.426377] CPU: 1 PID: 364 Comm: systemd-udevd Not tainted 5.2.0-rc2-CI-CI_DRM_6159+ #1
    <4>[    9.426385] Hardware name: Intel Corporation Ice Lake Client Platform/IceLake U DDR4 SODIMM PD RVP TLC, BIOS ICLSFWR1.R00.3183.A00.1905020411 05/02/2019
    <4>[    9.426444] RIP: 0010:intel_sseu_get_subslices+0x8a/0xe0 [i915]
    <4>[    9.426452] Code: d5 76 b7 e0 48 8b 35 9d 24 21 00 49 c7 c0 07 f0 72 a0 b9 2e 00 00 00 48 c7 c2 00 8e 6d a0 48 c7 c7 a5 14 5b a0 e8 36 3c be e0 <0f> 0b 48 c7 c1 80 d5 6f a0 ba 30 00 00 00 48 c7 c6 00 8e 6d a0 48
    <4>[    9.426468] RSP: 0018:ffffc9000037b9c8 EFLAGS: 00010282
    <4>[    9.426475] RAX: 000000000000000f RBX: 0000000000000000 RCX: 0000000000000000
    <4>[    9.426482] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff88849e346f98
    <4>[    9.426490] RBP: ffff88848a200000 R08: 0000000000000004 R09: ffff88849d50b000
    <4>[    9.426497] R10: 0000000000000000 R11: ffff88849e346f98 R12: ffff88848a209e78
    <4>[    9.426505] R13: 0000000003000000 R14: ffff88848a20b1a8 R15: 0000000000000000
    <4>[    9.426513] FS:  00007f73d5ae8680(0000) GS:ffff88849fc80000(0000) knlGS:0000000000000000
    <4>[    9.426521] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    <4>[    9.426527] CR2: 0000561417b01260 CR3: 0000000494764003 CR4: 0000000000760ee0
    <4>[    9.426535] PKRU: 55555554
    <4>[    9.426538] Call Trace:
    <4>[    9.426585]  wa_init_mcr+0xd5/0x110 [i915]
    <4>[    9.426597]  ? lock_acquire+0xa6/0x1c0
    <4>[    9.426645]  icl_gt_workarounds_init+0x21/0x1a0 [i915]
    <4>[    9.426694]  ? i915_driver_load+0xfcf/0x18a0 [i915]
    <4>[    9.426739]  gt_init_workarounds+0x14c/0x230 [i915]
    <4>[    9.426748]  ? _raw_spin_unlock_irq+0x24/0x50
    <4>[    9.426789]  intel_gt_init_workarounds+0x1b/0x30 [i915]
    <4>[    9.426835]  i915_driver_load+0xfd7/0x18a0 [i915]
    <4>[    9.426843]  ? lock_acquire+0xa6/0x1c0
    <4>[    9.426850]  ? __pm_runtime_resume+0x4f/0x80
    <4>[    9.426857]  ? _raw_spin_unlock_irqrestore+0x4c/0x60
    <4>[    9.426863]  ? _raw_spin_unlock_irqrestore+0x4c/0x60
    <4>[    9.426870]  ? lockdep_hardirqs_on+0xe3/0x1b0
    <4>[    9.426915]  i915_pci_probe+0x29/0xa0 [i915]
    <4>[    9.426923]  pci_device_probe+0x9e/0x120
    <4>[    9.426930]  really_probe+0xea/0x3c0
    <4>[    9.426936]  driver_probe_device+0x10b/0x120
    <4>[    9.426942]  device_driver_attach+0x4a/0x50
    <4>[    9.426948]  __driver_attach+0x97/0x130
    <4>[    9.426954]  ? device_driver_attach+0x50/0x50
    <4>[    9.426960]  bus_for_each_dev+0x74/0xc0
    <4>[    9.426966]  bus_add_driver+0x13f/0x210
    <4>[    9.426971]  ? 0xffffffffa083b000
    <4>[    9.426976]  driver_register+0x56/0xe0
    <4>[    9.426982]  ? 0xffffffffa083b000
    <4>[    9.426987]  do_one_initcall+0x58/0x300
    <4>[    9.426994]  ? do_init_module+0x1d/0x1f6
    <4>[    9.427001]  ? rcu_read_lock_sched_held+0x6f/0x80
    <4>[    9.427007]  ? kmem_cache_alloc_trace+0x261/0x290
    <4>[    9.427014]  do_init_module+0x56/0x1f6
    <4>[    9.427020]  load_module+0x24d1/0x2990
    <4>[    9.427032]  ? __se_sys_finit_module+0xd3/0xf0
    <4>[    9.427037]  __se_sys_finit_module+0xd3/0xf0
    <4>[    9.427047]  do_syscall_64+0x55/0x1c0
    <4>[    9.427053]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    <4>[    9.427059] RIP: 0033:0x7f73d5609839
    <4>[    9.427064] Code: 00 f3 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 1f f6 2c 00 f7 d8 64 89 01 48
    <4>[    9.427082] RSP: 002b:00007ffdf34477b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    <4>[    9.427091] RAX: ffffffffffffffda RBX: 00005559fd5d7b40 RCX: 00007f73d5609839
    <4>[    9.427099] RDX: 0000000000000000 RSI: 00007f73d52e8145 RDI: 000000000000000f
    <4>[    9.427106] RBP: 00007f73d52e8145 R08: 0000000000000000 R09: 00007ffdf34478d0
    <4>[    9.427114] R10: 000000000000000f R11: 0000000000000246 R12: 0000000000000000
    <4>[    9.427121] R13: 00005559fd5c90f0 R14: 0000000000020000 R15: 00005559fd5d7b40
    <4>[    9.427131] Modules linked in: i915(+) mei_hdcp x86_pkg_temp_thermal coretemp snd_hda_intel crct10dif_pclmul crc32_pclmul snd_hda_codec snd_hwdep e1000e snd_hda_core ghash_clmulni_intel ptp snd_pcm cdc_ether usbnet mii pps_core mei_me mei prime_numbers btusb btrtl btbcm btintel bluetooth ecdh_generic ecc
    <4>[    9.427254] ---[ end trace af3eeb543bd66e66 ]---
    
    [1] http://patchwork.freedesktop.org/patch/msgid/20190528200655.11605-1-chris@chris-wilson.co.uk
    
    References: https://intel-gfx-ci.01.org/tree/drm-tip/CI_DRM_6159/fi-icl-u2/pstore0-1517155098_Oops_1.log
    References: 1e40d4aea57b ("drm/i915/cnl: Implement WaProgramMgsrForCorrectSliceSpecificMmioReads")
    Fixes: 1ac159e23c2c ("drm/i915: Expand subslice mask")
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Manasi Navare <manasi.d.navare@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Stuart Summers <stuart.summers@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Yunwei Zhang <yunwei.zhang@intel.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190529082150.31526-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 85e77889e6a6..6a8b31f631ac 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -334,7 +334,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	const struct sseu_dev_info *sseu = &RUNTIME_INFO(dev_priv)->sseu;
 	drm_i915_getparam_t *param = data;
-	int value = 0;
+	int value;
 
 	switch (param->param) {
 	case I915_PARAM_IRQ_ACTIVE:
@@ -464,9 +464,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 			return -ENODEV;
 		break;
 	case I915_PARAM_SUBSLICE_MASK:
-		/* Only copy bits from the first slice */
-		memcpy(&value, sseu->subslice_mask,
-		       min(sseu->ss_stride, (u8)sizeof(value)));
+		value = sseu->subslice_mask[0];
 		if (!value)
 			return -ENODEV;
 		break;

commit 1ac159e23c2c033f1fcbf7d60286b90335a4e9b2
Author: Stuart Summers <stuart.summers@intel.com>
Date:   Fri May 24 08:40:22 2019 -0700

    drm/i915: Expand subslice mask
    
    Currently, the subslice_mask runtime parameter is stored as an
    array of subslices per slice. Expand the subslice mask array to
    better match what is presented to userspace through the
    I915_QUERY_TOPOLOGY_INFO ioctl. The index into this array is
    then calculated:
      slice * subslice stride + subslice index / 8
    
    v2: fix spacing in set_sseu_info args
        use set_sseu_info to initialize sseu data when building
        device status in debugfs
        rename variables in intel_engine_types.h to avoid checkpatch
        warnings
    v3: update headers in intel_sseu.h
    v4: add const to some sseu_dev_info variables
        use sseu->eu_stride for EU stride calculations
    v5: address review comments from Tvrtko and Daniele
    v6: remove extra space in intel_sseu_get_subslices
        return the correct subslice enable in for_each_instdone
        add GEM_BUG_ON to ensure user doesn't pass invalid ss_mask size
        use printk formatted string for subslice mask
    v7: remove string.h header and rebase
    
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Acked-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Stuart Summers <stuart.summers@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190524154022.13575-6-stuart.summers@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6a8b31f631ac..85e77889e6a6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -334,7 +334,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	const struct sseu_dev_info *sseu = &RUNTIME_INFO(dev_priv)->sseu;
 	drm_i915_getparam_t *param = data;
-	int value;
+	int value = 0;
 
 	switch (param->param) {
 	case I915_PARAM_IRQ_ACTIVE:
@@ -464,7 +464,9 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 			return -ENODEV;
 		break;
 	case I915_PARAM_SUBSLICE_MASK:
-		value = sseu->subslice_mask[0];
+		/* Only copy bits from the first slice */
+		memcpy(&value, sseu->subslice_mask,
+		       min(sseu->ss_stride, (u8)sizeof(value)));
 		if (!value)
 			return -ENODEV;
 		break;

commit 0040fd19e7285f096523c14daef131a81468a6ea
Author: Stuart Summers <stuart.summers@intel.com>
Date:   Fri May 24 08:40:21 2019 -0700

    drm/i915: Refactor sseu helper functions
    
    Move functions to intel_sseu.h and remove inline qualifier.
    Additionally, ensure these are all prefixed with intel_sseu_*
    to match the convention of other functions in i915.
    
    v2: fix spacing from checkpatch warning
    v3: squash helper function changes into a single patch
        break 80 character line to fix checkpatch warning
        move get/set_eus helpers to intel_device_info.c
    v4: Remove intel_ prefix from static functions in
        intel_device_info.c and correctly copy changes
        to stride calculation in those functions.
    
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Stuart Summers <stuart.summers@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190524154022.13575-5-stuart.summers@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a75917489438..6a8b31f631ac 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -386,7 +386,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = sseu_subslice_total(sseu);
+		value = intel_sseu_subslice_total(sseu);
 		if (!value)
 			return -ENODEV;
 		break;

commit bd41ca49a2735eb2f016a3fa4fe9716b56b55d71
Author: Stuart Summers <stuart.summers@intel.com>
Date:   Fri May 24 08:40:18 2019 -0700

    drm/i915: Use local variable for SSEU info in GETPARAM ioctl
    
    In the GETPARAM ioctl handler, use a local variable to consolidate
    usage of SSEU runtime info.
    
    v2: add const to sseu_dev_info variable
    
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Stuart Summers <stuart.summers@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190524154022.13575-2-stuart.summers@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5ca1594f3075..a75917489438 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -332,6 +332,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
+	const struct sseu_dev_info *sseu = &RUNTIME_INFO(dev_priv)->sseu;
 	drm_i915_getparam_t *param = data;
 	int value;
 
@@ -385,12 +386,12 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = sseu_subslice_total(&RUNTIME_INFO(dev_priv)->sseu);
+		value = sseu_subslice_total(sseu);
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_EU_TOTAL:
-		value = RUNTIME_INFO(dev_priv)->sseu.eu_total;
+		value = sseu->eu_total;
 		if (!value)
 			return -ENODEV;
 		break;
@@ -407,7 +408,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = HAS_POOLED_EU(dev_priv);
 		break;
 	case I915_PARAM_MIN_EU_IN_POOL:
-		value = RUNTIME_INFO(dev_priv)->sseu.min_eu_in_pool;
+		value = sseu->min_eu_in_pool;
 		break;
 	case I915_PARAM_HUC_STATUS:
 		value = intel_huc_check_status(&dev_priv->huc);
@@ -458,12 +459,12 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = intel_engines_has_context_isolation(dev_priv);
 		break;
 	case I915_PARAM_SLICE_MASK:
-		value = RUNTIME_INFO(dev_priv)->sseu.slice_mask;
+		value = sseu->slice_mask;
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_SUBSLICE_MASK:
-		value = RUNTIME_INFO(dev_priv)->sseu.subslice_mask[0];
+		value = sseu->subslice_mask[0];
 		if (!value)
 			return -ENODEV;
 		break;

commit 10be98a77c558f8cfb823cd2777171fbb35040f6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 28 10:29:49 2019 +0100

    drm/i915: Move more GEM objects under gem/
    
    Continuing the theme of separating out the GEM clutter.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190528092956.14910-8-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a1f43dc5a8b5..5ca1594f3075 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,6 +47,7 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
+#include "gem/i915_gem_context.h"
 #include "gem/i915_gem_ioctls.h"
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"

commit afa1308596c9dbb8526efd21335ea45aaaafdbe4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 28 10:29:43 2019 +0100

    drm/i915: Pull GEM ioctls interface to its own file
    
    Declutter i915_drv/gem.h by moving the ioctl API into its own header.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190528092956.14910-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6699e3a94272..a1f43dc5a8b5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,6 +47,7 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
+#include "gem/i915_gem_ioctls.h"
 #include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"
 #include "gt/intel_workarounds.h"

commit c457d9cf256e942138a54a2e80349ee7fe20c391
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 24 18:36:14 2019 +0300

    drm/i915: Make sure we have enough memory bandwidth on ICL
    
    ICL has so many planes that it can easily exceed the maximum
    effective memory bandwidth of the system. We must therefore check
    that we don't exceed that limit.
    
    The algorithm is very magic number heavy and lacks sufficient
    explanation for now. We also have no sane way to query the
    memory clock and timings, so we must rely on a combination of
    raw readout from the memory controller and hardcoded assumptions.
    The memory controller values obviously change as the system
    jumps between the different SAGV points, so we try to stabilize
    it first by disabling SAGV for the duration of the readout.
    
    The utilized bandwidth is tracked via a device wide atomic
    private object. That is actually not robust because we can't
    afford to enforce strict global ordering between the pipes.
    Thus I think I'll need to change this to simply chop up the
    available bandwidth between all the active pipes. Each pipe
    can then do whatever it wants as long as it doesn't exceed
    its budget. That scheme will also require that we assume that
    any number of planes could be active at any time.
    
    TODO: make it robust and deal with all the open questions
    
    v2: Sleep longer after disabling SAGV
    v3: Poll for the dclk to get raised (seen it take 250ms!)
        If the system has 2133MT/s memory then we pointlessly
        wait one full second :(
    v4: Use the new pcode interface to get the qgv points rather
        that using hardcoded numbers
    v5: Move the pcode stuff into intel_bw.c (Matt)
        s/intel_sagv_info/intel_qgv_info/
        Do the NV12/P010 as per spec for now (Matt)
        s/IS_ICELAKE/IS_GEN11/
    v6: Ignore bandwidth limits if the pcode query fails
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Clint Taylor <Clinton.A.Taylor@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190524153614.32410-1-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83d2eb9e74cb..6699e3a94272 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -60,6 +60,7 @@
 #include "i915_vgpu.h"
 #include "intel_acpi.h"
 #include "intel_audio.h"
+#include "intel_bw.h"
 #include "intel_cdclk.h"
 #include "intel_csr.h"
 #include "intel_dp.h"
@@ -1657,6 +1658,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 */
 	intel_get_dram_info(dev_priv);
 
+	intel_bw_init_hw(dev_priv);
 
 	return 0;
 

commit a88b6e4cbafd6f23b3450c087acdbe23d90e7606
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:34 2019 +0100

    drm/i915: Allow specification of parallel execbuf
    
    There is a desire to split a task onto two engines and have them run at
    the same time, e.g. scanline interleaving to spread the workload evenly.
    Through the use of the out-fence from the first execbuf, we can
    coordinate secondary execbuf to only become ready simultaneously with
    the first, so that with all things idle the second execbufs are executed
    in parallel with the first. The key difference here between the new
    EXEC_FENCE_SUBMIT and the existing EXEC_FENCE_IN is that the in-fence
    waits for the completion of the first request (so that all of its
    rendering results are visible to the second execbuf, the more common
    userspace fence requirement).
    
    Since we only have a single input fence slot, userspace cannot mix an
    in-fence and a submit-fence. It has to use one or the other! This is not
    such a harsh requirement, since by virtue of the submit-fence, the
    secondary execbuf inherit all of the dependencies from the first
    request, and for the application the dependencies should be common
    between the primary and secondary execbuf.
    
    Suggested-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Testcase: igt/gem_exec_fence/parallel
    Link: https://github.com/intel/media-driver/pull/546
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-10-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5061cb32856b..83d2eb9e74cb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -443,6 +443,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_CAPTURE:
 	case I915_PARAM_HAS_EXEC_BATCH_FIRST:
 	case I915_PARAM_HAS_EXEC_FENCE_ARRAY:
+	case I915_PARAM_HAS_EXEC_SUBMIT_FENCE:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from

commit 7f3f317a66cac307f6fbc1b5dd74902fb1b48860
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:25 2019 +0100

    drm/i915: Restore control over ppgtt for context creation ABI
    
    Having hid the partially exposed new ABI from the PR, put it back again
    for completion of context recovery. A significant part of context
    recovery is the ability to reuse as much of the old context as is
    feasible (to avoid expensive reconstruction). The biggest chunk kept
    hidden at the moment is fine-control over the ctx->ppgtt (the GPU page
    tables and associated translation tables and kernel maps), so make
    control over the ctx->ppgtt explicit.
    
    This allows userspace to create and share virtual memory address spaces
    (within the limits of a single fd) between contexts they own, along with
    the ability to query the contexts for the vm state.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2c7a4318d13c..5061cb32856b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3164,6 +3164,8 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_VM_CREATE, i915_gem_vm_create_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_VM_DESTROY, i915_gem_vm_destroy_ioctl, DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 9ab91a30f2b95ed49404516b760577350cf1d245
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon May 6 18:26:27 2019 +0300

    drm/i915: Kill PCH_KBP
    
    For us KBP is 100% identical to SPT. Kill the redundant enum
    value. Also bspec doesn't talk about KBP either, so this might
    avoid some confusion when cross checking the code against the
    spec.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190506152627.20283-1-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5ed864752c7b..2c7a4318d13c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -195,7 +195,8 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 		DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
 		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv) &&
 			!IS_COFFEELAKE(dev_priv));
-		return PCH_KBP;
+		/* KBP is SPT compatible */
+		return PCH_SPT;
 	case INTEL_PCH_CNP_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
 		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));

commit 818f5cb3e8fb386609f7d3c751f195dd3050d22d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu May 2 21:30:09 2019 +0100

    drm/i915/guc: Fix runtime suspend
    
    We are not allowed to rpm_get() inside the runtime-suspend callback, so
    split the intel_uc_suspend() into the core that assumes the caller holds
    the wakeref (intel_uc_runtime_suspend), and one that acquires the wakeref
    as necessary (intel_uc_suspend).
    
    Reported-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Fixes: 79ffac8599c4 ("drm/i915: Invert the GEM wakeref hierarchy")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190502203009.15727-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e6ce530d7581..5ed864752c7b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2890,7 +2890,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 */
 	i915_gem_runtime_suspend(dev_priv);
 
-	intel_uc_suspend(dev_priv);
+	intel_uc_runtime_suspend(dev_priv);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 

commit 3ce2ea6574be67b6efd6fb1a7f6e2c7aa27b82f1
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 2 18:02:47 2019 +0300

    drm/i915: extract intel_gmbus.h from i915_drv.h and rename intel_i2c.c
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    While at it, rename intel_i2c.c to intel_gmbus.c and the functions to
    intel_gmbus_*.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/5834b8fbbfd4ac2e3d0159e69c87f6926066f537.1556809195.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 57060a663579..e6ce530d7581 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -65,6 +65,7 @@
 #include "intel_dp.h"
 #include "intel_drv.h"
 #include "intel_fbdev.h"
+#include "intel_gmbus.h"
 #include "intel_hotplug.h"
 #include "intel_overlay.h"
 #include "intel_pipe_crc.h"
@@ -705,7 +706,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_csr;
 
-	intel_setup_gmbus(dev_priv);
+	intel_gmbus_setup(dev_priv);
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
@@ -740,7 +741,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	intel_modeset_cleanup(dev);
 cleanup_irq:
 	drm_irq_uninstall(dev);
-	intel_teardown_gmbus(dev_priv);
+	intel_gmbus_teardown(dev_priv);
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);
 	intel_power_domains_fini_hw(dev_priv);

commit 2126d3e990a56c4cc4824c449bae0e98225fcbe0
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 2 18:02:43 2019 +0300

    drm/i915: extract i915_debugfs.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/2843b028d65e118dc40316aa84bf620a93f6c67b.1556809195.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c011a1b5720a..57060a663579 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -51,6 +51,7 @@
 #include "gt/intel_reset.h"
 #include "gt/intel_workarounds.h"
 
+#include "i915_debugfs.h"
 #include "i915_drv.h"
 #include "i915_irq.h"
 #include "i915_pmu.h"
@@ -66,6 +67,7 @@
 #include "intel_fbdev.h"
 #include "intel_hotplug.h"
 #include "intel_overlay.h"
+#include "intel_pipe_crc.h"
 #include "intel_pm.h"
 #include "intel_sprite.h"
 #include "intel_uc.h"

commit 4e49d35c3892b051586e80f5f67c9fe6b7d06d77
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 2 18:02:42 2019 +0300

    drm/i915: extract intel_acpi.h from i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    i915_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/9bc1317a67df0b9d019eca5b36f474b76a1cad26.1556809195.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 21dac5a09fbe..c011a1b5720a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -57,6 +57,7 @@
 #include "i915_query.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
+#include "intel_acpi.h"
 #include "intel_audio.h"
 #include "intel_cdclk.h"
 #include "intel_csr.h"

commit 05ca9306715c9fa80edc31c8c5a60d6c5328d795
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 29 15:29:31 2019 +0300

    drm/i915: extract intel_overlay.h from intel_drv.h and i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/2e4fb1e67ed38870df3040bb0a1b1a58fd90cc86.1556540890.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b891a6aa7980..21dac5a09fbe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -64,6 +64,7 @@
 #include "intel_drv.h"
 #include "intel_fbdev.h"
 #include "intel_hotplug.h"
+#include "intel_overlay.h"
 #include "intel_pm.h"
 #include "intel_sprite.h"
 #include "intel_uc.h"

commit dbeb38d93a6da89c99801a9c70607920be72b94e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 29 15:50:11 2019 +0300

    drm/i915: extract intel_hotplug.h from intel_drv.h and i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    v2: fix sparse warnings on undeclared global functions
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190429125011.10876-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4cfdc2741ef5..b891a6aa7980 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -63,6 +63,7 @@
 #include "intel_dp.h"
 #include "intel_drv.h"
 #include "intel_fbdev.h"
+#include "intel_hotplug.h"
 #include "intel_pm.h"
 #include "intel_sprite.h"
 #include "intel_uc.h"

commit 440e2b3d8051017ff934ccd8c0688d623add86e0
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 29 15:29:27 2019 +0300

    drm/i915: extract i915_irq.h from intel_drv.h and i915_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/64e46278dc8dccc9c548ef453cb2ceece5367bb2.1556540890.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aacc8dd6ecfd..4cfdc2741ef5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -52,6 +52,7 @@
 #include "gt/intel_workarounds.h"
 
 #include "i915_drv.h"
+#include "i915_irq.h"
 #include "i915_pmu.h"
 #include "i915_query.h"
 #include "i915_trace.h"

commit a75d035fedbdecf83f86767aa2e4d05c8c4ffd95
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 26 09:17:18 2019 +0100

    drm/i915: Disable preemption and sleeping while using the punit sideband
    
    While we talk to the punit over its sideband, we need to prevent the cpu
    from sleeping in order to prevent a potential machine hang.
    
    Note that by itself, it appears that pm_qos_update_request (via
    intel_idle) doesn't provide a sufficient barrier to ensure that all core
    are indeed awake (out of Cstate) and that the package is awake. To do so,
    we need to supplement the pm_qos with a manual ping on_each_cpu.
    
    v2: Restrict the heavy-weight wakeup to just the ISOF_PORT_PUNIT, there
    is insufficient evidence to implicate a wider problem atm. Similarly,
    restrict the w/a to Valleyview, as Cherryview doesn't have an angry cadre
    of users.
    
    The working theory, courtesy of Ville and Hans, is the issue lies within
    the power delivery and so is likely to be unit and board specific and
    occurs when both the unit/fw require extra power at the same time as the
    cpu package is changing its own power state.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=109051
    References: https://bugs.freedesktop.org/show_bug.cgi?id=102657
    References: https://bugzilla.kernel.org/show_bug.cgi?id=195255
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190426081725.31217-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 824409ffd03f..aacc8dd6ecfd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -886,6 +886,9 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	mutex_init(&dev_priv->backlight_lock);
 
 	mutex_init(&dev_priv->sb_lock);
+	pm_qos_add_request(&dev_priv->sb_qos,
+			   PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
+
 	mutex_init(&dev_priv->av_mutex);
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
@@ -945,6 +948,9 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 	i915_engines_cleanup(dev_priv);
+
+	pm_qos_remove_request(&dev_priv->sb_qos);
+	mutex_destroy(&dev_priv->sb_lock);
 }
 
 /**

commit 79ffac8599c4d8aa84d313920d3d86d7361c252b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 24 21:07:17 2019 +0100

    drm/i915: Invert the GEM wakeref hierarchy
    
    In the current scheme, on submitting a request we take a single global
    GEM wakeref, which trickles down to wake up all GT power domains. This
    is undesirable as we would like to be able to localise our power
    management to the available power domains and to remove the global GEM
    operations from the heart of the driver. (The intent there is to push
    global GEM decisions to the boundary as used by the GEM user interface.)
    
    Now during request construction, each request is responsible via its
    logical context to acquire a wakeref on each power domain it intends to
    utilize. Currently, each request takes a wakeref on the engine(s) and
    the engines themselves take a chipset wakeref. This gives us a
    transition on each engine which we can extend if we want to insert more
    powermangement control (such as soft rc6). The global GEM operations
    that currently require a struct_mutex are reduced to listening to pm
    events from the chipset GT wakeref. As we reduce the struct_mutex
    requirement, these listeners should evaporate.
    
    Perhaps the biggest immediate change is that this removes the
    struct_mutex requirement around GT power management, allowing us greater
    flexibility in request construction. Another important knock-on effect,
    is that by tracking engine usage, we can insert a switch back to the
    kernel context on that engine immediately, avoiding any extra delay or
    inserting global synchronisation barriers. This makes tracking when an
    engine and its associated contexts are idle much easier -- important for
    when we forgo our assumed execution ordering and need idle barriers to
    unpin used contexts. In the process, it means we remove a large chunk of
    code whose only purpose was to switch back to the kernel context.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190424200717.1686-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ac416d2c02ca..824409ffd03f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,8 +47,9 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
-#include "gt/intel_workarounds.h"
+#include "gt/intel_gt_pm.h"
 #include "gt/intel_reset.h"
+#include "gt/intel_workarounds.h"
 
 #include "i915_drv.h"
 #include "i915_pmu.h"
@@ -2323,7 +2324,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
-	intel_engines_sanitize(dev_priv, true);
+	intel_gt_sanitize(dev_priv, true);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 

commit 112ed2d31a46f4704085ad925435b77e62b8abee
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 24 18:48:39 2019 +0100

    drm/i915: Move GraphicsTechnology files under gt/
    
    Start partitioning off the code that talks to the hardware (GT) from the
    uapi layers and move the device facing code under gt/
    
    One casualty is s/intel_ringbuffer.h/intel_engine.h/ with the plan to
    subdivide that header and body further (and split out the submission
    code from the ringbuffer and logical context handling). This patch aims
    to be simple motion so git can fixup inflight patches with little mess.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190424174839.7141-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6354c68c94b3..ac416d2c02ca 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,10 +47,12 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
+#include "gt/intel_workarounds.h"
+#include "gt/intel_reset.h"
+
 #include "i915_drv.h"
 #include "i915_pmu.h"
 #include "i915_query.h"
-#include "i915_reset.h"
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_audio.h"
@@ -62,7 +64,6 @@
 #include "intel_pm.h"
 #include "intel_sprite.h"
 #include "intel_uc.h"
-#include "intel_workarounds.h"
 
 static struct drm_driver driver;
 

commit b972fffa114b18a120a7bbde105d69a080d24970
Author: Christian König <ckoenig.leichtzumerken@gmail.com>
Date:   Wed Apr 17 13:25:24 2019 +0200

    drm/i915: remove DRM_AUTH from IOCTLs which also have DRM_RENDER_ALLOW
    
    This is to work around problems with libva and vainfo.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190417112525.16848-1-christian.koenig@amd.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5e2ae2300454..6354c68c94b3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3098,7 +3098,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_BATCHBUFFER, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_IRQ_EMIT, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_IRQ_WAIT, drm_noop, DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_SETPARAM, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_ALLOC, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_FREE, drm_noop, DRM_AUTH),
@@ -3111,13 +3111,13 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_HWS_ADDR, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, i915_gem_execbuffer_ioctl, DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_PIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_UNPIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
-	DRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SET_CACHING, i915_gem_set_caching_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_GET_CACHING, i915_gem_get_caching_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_THROTTLE, i915_gem_throttle_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_THROTTLE, i915_gem_throttle_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_ENTERVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_LEAVEVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CREATE, i915_gem_create_ioctl, DRM_RENDER_ALLOW),
@@ -3136,7 +3136,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER),
-	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE_EXT, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_DESTROY, i915_gem_context_destroy_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_REG_READ, i915_reg_read_ioctl, DRM_RENDER_ALLOW),

commit d69990e0c399e4f7f9b50505d3285e5de991148a
Author: Janusz Krzysztofik <janusz.krzysztofik@intel.com>
Date:   Fri Apr 5 15:02:34 2019 +0200

    drm/i915: Use drm_dev_unplug()
    
    The driver does not currently support unbinding from a device which is
    in use.  Since open file descriptors may still be pointing into kernel
    memory where the device structures used to be, entirely correct kernel
    panics protect the driver from being unbound as we should not be
    unbinding it before those dangling pointers have been made safe.
    
    According to the documentation found inside drivers/gpu/drm/drm_drv.c,
    drm_dev_unplug() should be used instead of drm_dev_unregister() in
    order to make a device inaccessible to users as soon as it is unpluged.
    Follow that advice to make those possibly dangling pointers safe,
    protected by DRM layer from a user who is otherwise left pointing into
    possibly reused kernel memory after the driver has been unbound from
    the device.  Once done, also cancel inflight operations immediately by
    calling i915_gem_set_wedged().
    
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190405130235.7707-2-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1ad88e6d7c04..5e2ae2300454 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1760,7 +1760,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_pmu_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
-	drm_dev_unregister(&dev_priv->drm);
+	drm_dev_unplug(&dev_priv->drm);
 
 	i915_gem_shrinker_unregister(dev_priv);
 }

commit e7674ef682f2a018bc34a25f0b32ac9baddf44da
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:25 2019 +0300

    drm/i915: extract intel_cdclk.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/c128d7be3f621391e571e86b03f302f3ffd0ed2b.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0808f9459447..1ad88e6d7c04 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -54,6 +54,7 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_audio.h"
+#include "intel_cdclk.h"
 #include "intel_csr.h"
 #include "intel_dp.h"
 #include "intel_drv.h"

commit f9a79f9aeeee6e5e139e93d9e79915f313489d33
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:24 2019 +0300

    drm/i915: extract intel_sprite.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/679c857a1933ee3d0706f978ab05ca880cd30a00.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 91c75de8c6a5..0808f9459447 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -59,6 +59,7 @@
 #include "intel_drv.h"
 #include "intel_fbdev.h"
 #include "intel_pm.h"
+#include "intel_sprite.h"
 #include "intel_uc.h"
 #include "intel_workarounds.h"
 

commit 27fec1f9734d33539df6c05fceb84fd981792899
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:17 2019 +0300

    drm/i915: extract intel_dp.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/f86f9beed730eaad0bdcc18b18817b3d221e16e2.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b356d984dd5c..91c75de8c6a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -55,6 +55,7 @@
 #include "i915_vgpu.h"
 #include "intel_audio.h"
 #include "intel_csr.h"
+#include "intel_dp.h"
 #include "intel_drv.h"
 #include "intel_fbdev.h"
 #include "intel_pm.h"

commit 6dfccb95cf17cd7e144d5214f2c41c17e7e31ec4
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:16 2019 +0300

    drm/i915: extract intel_fbdev.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/82d11bf634094f44a7469a096de3d3768314d6bc.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ef799fe20510..b356d984dd5c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -56,6 +56,7 @@
 #include "intel_audio.h"
 #include "intel_csr.h"
 #include "intel_drv.h"
+#include "intel_fbdev.h"
 #include "intel_pm.h"
 #include "intel_uc.h"
 #include "intel_workarounds.h"

commit 696173b064c6dacd4e88d2ca15021e9bfc91328e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:15 2019 +0300

    drm/i915: extract intel_pm.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    v2: gen6_rps_reset_ei() is in i915_irq.c not intel_pm.c.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/adc6463b95eef3440fba9826793f7d1c5f3b0b4a.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b902b73b8b71..ef799fe20510 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -56,6 +56,7 @@
 #include "intel_audio.h"
 #include "intel_csr.h"
 #include "intel_drv.h"
+#include "intel_pm.h"
 #include "intel_uc.h"
 #include "intel_workarounds.h"
 

commit 174594db632a2d484ee462bda606239b400dd078
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:07 2019 +0300

    drm/i915: extract intel_csr.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    v2: Add function argument names to fix checkpatch warning
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/44ceebca0206de9c40dc6794b660d84b8994f700.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 24f915d95d8b..b902b73b8b71 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -54,6 +54,7 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_audio.h"
+#include "intel_csr.h"
 #include "intel_drv.h"
 #include "intel_uc.h"
 #include "intel_workarounds.h"

commit 331c201a07261120cceb50ee71736bdc3dd07368
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Apr 5 14:00:03 2019 +0300

    drm/i915: extract intel_audio.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/e0284c4d62effa5bad72ce034206c26e3aa02884.1554461791.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c695b3a4deae..24f915d95d8b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -48,11 +48,12 @@
 #include <drm/i915_drm.h>
 
 #include "i915_drv.h"
-#include "i915_trace.h"
 #include "i915_pmu.h"
-#include "i915_reset.h"
 #include "i915_query.h"
+#include "i915_reset.h"
+#include "i915_trace.h"
 #include "i915_vgpu.h"
+#include "intel_audio.h"
 #include "intel_drv.h"
 #include "intel_uc.h"
 #include "intel_workarounds.h"

commit 141f3767e7b8f32ce7210ef4b716d41bae72a54d
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Sat Apr 6 11:40:34 2019 +0100

    drm/i915: Mark GEM wedged right after marking device unplugged
    
    As soon as a device is considered unplugged, not only prevent pending
    users from accessing the device structures but also cancel all their
    pending requests so all consumed resources can be cleaned up as soon
    as possible.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190406104034.31380-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0bbf3f5db5fc..c695b3a4deae 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1907,6 +1907,13 @@ void i915_driver_unload(struct drm_device *dev)
 
 	i915_driver_unregister(dev_priv);
 
+	/*
+	 * After unregistering the device to prevent any new users, cancel
+	 * all in-flight requests so that we can quickly unbind the active
+	 * resources.
+	 */
+	i915_gem_set_wedged(dev_priv);
+
 	/* Flush any external code that still may be under the RCU lock */
 	synchronize_rcu();
 

commit 3de6f8529461706dcea78044dd4ccf1290a62e50
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Apr 2 13:10:32 2019 -0700

    drm/i915: rename init/fini/prune uncore functions
    
    Add "_mmio" postfix to be consistent from the init/fini phase they're
    called from.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190402201032.15841-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5bfacf353fa4..0bbf3f5db5fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -957,7 +957,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	if (i915_get_bridge_dev(dev_priv))
 		return -EIO;
 
-	ret = intel_uncore_init(&dev_priv->uncore);
+	ret = intel_uncore_init_mmio(&dev_priv->uncore);
 	if (ret < 0)
 		goto err_bridge;
 
@@ -966,7 +966,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 	intel_device_info_init_mmio(dev_priv);
 
-	intel_uncore_prune(&dev_priv->uncore);
+	intel_uncore_prune_mmio_domains(&dev_priv->uncore);
 
 	intel_uc_init_mmio(dev_priv);
 
@@ -980,7 +980,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 err_uncore:
 	intel_teardown_mchbar(dev_priv);
-	intel_uncore_fini(&dev_priv->uncore);
+	intel_uncore_fini_mmio(&dev_priv->uncore);
 err_bridge:
 	pci_dev_put(dev_priv->bridge_dev);
 
@@ -994,7 +994,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 {
 	intel_teardown_mchbar(dev_priv);
-	intel_uncore_fini(&dev_priv->uncore);
+	intel_uncore_fini_mmio(&dev_priv->uncore);
 	pci_dev_put(dev_priv->bridge_dev);
 }
 

commit 6cbe88303621b79ceba4cb00062312030f51d18e
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Apr 2 13:10:31 2019 -0700

    drm/i915: add intel_uncore_init_early
    
    Encapsulate the uncore early init and be consistent with the
    "_early" naming.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190402201032.15841-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0ca57dc5da5c..5bfacf353fa4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -870,10 +870,11 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 
 	intel_device_info_subplatform_init(dev_priv);
 
+	intel_uncore_init_early(&dev_priv->uncore);
+
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);
 	mutex_init(&dev_priv->backlight_lock);
-	spin_lock_init(&dev_priv->uncore.lock);
 
 	mutex_init(&dev_priv->sb_lock);
 	mutex_init(&dev_priv->av_mutex);

commit 805446c8347c9e743912cb7acf795683d9af7972
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Mar 27 14:23:28 2019 +0000

    drm/i915: Introduce concept of a sub-platform
    
    Concept of a sub-platform already exist in our code (like ULX and ULT
    platform variants and similar),implemented via the macros which check a
    list of device ids to determine a match.
    
    With this patch we consolidate device ids checking into a single function
    called during early driver load.
    
    A few low bits in the platform mask are reserved for sub-platform
    identification and defined as a per-platform namespace.
    
    At the same time it future proofs the platform_mask handling by preparing
    the code for easy extending, and tidies the very verbose WARN strings
    generated when IS_PLATFORM macros are embedded into a WARN type
    statements.
    
    v2: Fixed IS_SUBPLATFORM. Updated commit msg.
    v3: Chris was right, there is an ordering problem.
    
    v4:
     * Catch-up with new sub-platforms.
     * Rebase for RUNTIME_INFO.
     * Drop subplatform mask union tricks and convert platform_mask to an
       array for extensibility.
    
    v5:
     * Fix subplatform check.
     * Protect against forgetting to expand subplatform bits.
     * Remove platform enum tallying.
     * Add subplatform to error state. (Chris)
     * Drop macros and just use static inlines.
     * Remove redundant IRONLAKE_M. (Ville)
    
    v6:
     * Split out Ironlake change.
     * Optimize subplatform check.
     * Use __always_inline. (Lucas)
     * Add platform_mask comment. (Paulo)
     * Pass stored runtime info in error capture. (Chris)
    
    v7:
     * Rebased for new AML ULX device id.
     * Bump platform mask array size for EHL.
     * Stop mentioning device ids in intel_device_subplatform_init by using
       the trick of splitting macros i915_pciids.h. (Jani)
     * AML seems to be either a subplatform of KBL or CFL so express it like
       that.
    
    v8:
     * Use one device id table per subplatform. (Jani)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Lucas De Marchi <lucas.demarchi@intel.com>
    Cc: Jose Souza <jose.souza@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190327142328.31780-1-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4d5f3f2d94ee..0ca57dc5da5c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -868,6 +868,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
+	intel_device_info_subplatform_init(dev_priv);
+
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);
 	mutex_init(&dev_priv->backlight_lock);
@@ -1760,10 +1762,12 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 	if (drm_debug & DRM_UT_DRIVER) {
 		struct drm_printer p = drm_debug_printer("i915 device info:");
 
-		drm_printf(&p, "pciid=0x%04x rev=0x%02x platform=%s gen=%i\n",
+		drm_printf(&p, "pciid=0x%04x rev=0x%02x platform=%s (subplatform=0x%x) gen=%i\n",
 			   INTEL_DEVID(dev_priv),
 			   INTEL_REVID(dev_priv),
 			   intel_platform_name(INTEL_INFO(dev_priv)->platform),
+			   intel_subplatform(RUNTIME_INFO(dev_priv),
+					     INTEL_INFO(dev_priv)->platform),
 			   INTEL_GEN(dev_priv));
 
 		intel_device_info_dump_flags(INTEL_INFO(dev_priv), &p);
@@ -1806,8 +1810,6 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 	memcpy(device_info, match_info, sizeof(*device_info));
 	RUNTIME_INFO(i915)->device_id = pdev->device;
 
-	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
-		     BITS_PER_TYPE(device_info->platform_mask));
 	BUG_ON(device_info->gen > BITS_PER_TYPE(device_info->gen_mask));
 
 	return i915;

commit f6ac993fb0ca5d8c0233ac17a71aacb22f84ac54
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Mar 28 10:45:32 2019 -0700

    drm/i915: move the edram detection out of uncore init
    
    edram is not part of uncore and there is no requirement for the
    detection to be done before we initialize the uncore functions. The
    first check on HAS_EDRAM is in the ggtt_init path, so move it to
    i915_driver_init_hw, where other dram-related detection happens.
    
    While at it, save the size in MB instead of the capabilities because the
    size is the only thing we look at outside of the init function.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190328174533.31532-1-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bbe1a5d56480..4d5f3f2d94ee 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1441,6 +1441,45 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
 }
 
+static u32 gen9_edram_size_mb(struct drm_i915_private *dev_priv, u32 cap)
+{
+	const unsigned int ways[8] = { 4, 8, 12, 16, 16, 16, 16, 16 };
+	const unsigned int sets[4] = { 1, 1, 2, 2 };
+
+	return EDRAM_NUM_BANKS(cap) *
+		ways[EDRAM_WAYS_IDX(cap)] *
+		sets[EDRAM_SETS_IDX(cap)];
+}
+
+static void edram_detect(struct drm_i915_private *dev_priv)
+{
+	u32 edram_cap = 0;
+
+	if (!(IS_HASWELL(dev_priv) ||
+	      IS_BROADWELL(dev_priv) ||
+	      INTEL_GEN(dev_priv) >= 9))
+		return;
+
+	edram_cap = __raw_uncore_read32(&dev_priv->uncore, HSW_EDRAM_CAP);
+
+	/* NB: We can't write IDICR yet because we don't have gt funcs set up */
+
+	if (!(edram_cap & EDRAM_ENABLED))
+		return;
+
+	/*
+	 * The needed capability bits for size calculation are not there with
+	 * pre gen9 so return 128MB always.
+	 */
+	if (INTEL_GEN(dev_priv) < 9)
+		dev_priv->edram_size_mb = 128;
+	else
+		dev_priv->edram_size_mb =
+			gen9_edram_size_mb(dev_priv, edram_cap);
+
+	DRM_INFO("Found %uMB of eDRAM\n", dev_priv->edram_size_mb);
+}
+
 /**
  * i915_driver_init_hw - setup state requiring device access
  * @dev_priv: device private
@@ -1483,6 +1522,9 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_sanitize_options(dev_priv);
 
+	/* needs to be done before ggtt probe */
+	edram_detect(dev_priv);
+
 	i915_perf_init(dev_priv);
 
 	ret = i915_ggtt_probe_hw(dev_priv);

commit 0e2f54f88b8b9bbdb3a73b6e67cffb402187c73f
Merge: 96fd2c6633b0 0bec6219e5a0
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Wed Mar 27 18:23:53 2019 +0200

    Merge drm/drm-next into drm-intel-next-queued
    
    This is needed to get the fourcc code merged without conflicts.
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 96fd2c6633b0484b030eb15e646ad50426c41e6a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Mar 27 10:58:14 2019 +0000

    drm/i915: Drop new chunks of context creation ABI (for now)
    
    The intent was to expose these as part of the means to perform full
    context recovery (though not the SINGLE_TIMELINE, that is for later and
    just sucked as collateral damage). As that requires a couple more
    patches to complete the series, roll back the earlier chunks of ABI for
    an intervening PR. We keep all the internals intact and under selftests.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190327105814.14694-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca8a8891b7b3..a9fcb32f4989 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3122,8 +3122,6 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_VM_CREATE, i915_gem_vm_create_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_VM_DESTROY, i915_gem_vm_destroy_ioctl, DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 97a04e0d07c4b32dd76c6a03b3384170b738972f
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Mon Mar 25 14:49:39 2019 -0700

    drm/i915: switch intel_wait_for_register to uncore
    
    The intel_uncore structure is the owner of register access, so
    subclass the function to it.
    
    While at it, use a local uncore var and switch to the new read/write
    functions where it makes sense.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190325214940.23632-9-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 622b175b05fd..ca8a8891b7b3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2687,7 +2687,7 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	if (!force_on)
 		return 0;
 
-	err = intel_wait_for_register(dev_priv,
+	err = intel_wait_for_register(&dev_priv->uncore,
 				      VLV_GTLC_SURVIVABILITY_REG,
 				      VLV_GFX_CLK_STATUS_BIT,
 				      VLV_GFX_CLK_STATUS_BIT,

commit 2cf7bf6f2f206700d1560d68f1464b4cb7882291
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Mon Mar 25 14:49:34 2019 -0700

    drm/i915: add uncore flags for unclaimed mmio
    
    Save the HW capabilities to avoid having to jump back to dev_priv
    every time.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190325214940.23632-4-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d3df0ebaa09c..622b175b05fd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2887,7 +2887,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	enable_rpm_wakeref_asserts(dev_priv);
 	intel_runtime_pm_cleanup(dev_priv);
 
-	if (intel_uncore_arm_unclaimed_mmio_detection(dev_priv))
+	if (intel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");
 
 	dev_priv->runtime_pm.suspended = true;
@@ -2941,7 +2941,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 	dev_priv->runtime_pm.suspended = false;
-	if (intel_uncore_unclaimed_mmio(dev_priv))
+	if (intel_uncore_unclaimed_mmio(&dev_priv->uncore))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
 	if (INTEL_GEN(dev_priv) >= 11) {

commit b91715417244a7e478304425ba671bfafee9c43e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:24 2019 +0000

    drm/i915: Extend CONTEXT_CREATE to set parameters upon construction
    
    It can be useful to have a single ioctl to create a context with all
    the initial parameters instead of a series of create + setparam + setparam
    ioctls. This extension to create context allows any of the parameters
    to be passed in as a linked list to be applied to the newly constructed
    context.
    
    v2: Make a local copy of user setparam (Tvrtko)
    v3: Use flags to detect availability of extension interface
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f6403ba1d56a..d3df0ebaa09c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3111,7 +3111,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER),
 	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE_EXT, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_DESTROY, i915_gem_context_destroy_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_REG_READ, i915_reg_read_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GET_RESET_STATS, i915_gem_context_reset_stats_ioctl, DRM_RENDER_ALLOW),

commit e0695db7298ec2181d38bd3bfc5d0ff7a46f96f3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:23 2019 +0000

    drm/i915: Create/destroy VM (ppGTT) for use with contexts
    
    In preparation to making the ppGTT binding for a context explicit (to
    facilitate reusing the same ppGTT between different contexts), allow the
    user to create and destroy named ppGTT.
    
    v2: Replace global barrier for swapping over the ppgtt and tlbs with a
    local context barrier (Tvrtko)
    v3: serialise with struct_mutex; it's lazy but required dammit
    v4: Rewrite igt_ctx_shared_exec to be more different (aimed to be more
    similarly, turned out different!)
    
    v5: Fix up test unwind for aliasing-ppgtt (snb)
    v6: Tighten language for uapi struct drm_i915_gem_vm_control.
    v7: Patch the context image for runtime ppgtt switching!
    
    Testcase: igt/gem_vm_create
    Testcase: igt/gem_ctx_param/vm
    Testcase: igt/gem_ctx_clone/vm
    Testcase: igt/gem_ctx_shared
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d01689737f1e..f6403ba1d56a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3122,6 +3122,8 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_VM_CREATE, i915_gem_vm_create_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_VM_DESTROY, i915_gem_vm_destroy_ioctl, DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 25286aaca9cee11daa0cede2bcd62d48e440d9f3
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Mar 19 11:35:40 2019 -0700

    drm/i915: move regs pointer inside the uncore structure
    
    This will allow futher simplifications in the uncore handling.
    
    v2: move register access setup under uncore (Chris)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190319183543.13679-8-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fd2de1d58b64..d01689737f1e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -968,46 +968,6 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 	i915_engines_cleanup(dev_priv);
 }
 
-static int i915_mmio_setup(struct drm_i915_private *dev_priv)
-{
-	struct pci_dev *pdev = dev_priv->drm.pdev;
-	int mmio_bar;
-	int mmio_size;
-
-	mmio_bar = IS_GEN(dev_priv, 2) ? 1 : 0;
-	/*
-	 * Before gen4, the registers and the GTT are behind different BARs.
-	 * However, from gen4 onwards, the registers and the GTT are shared
-	 * in the same BAR, so we want to restrict this ioremap from
-	 * clobbering the GTT which we want ioremap_wc instead. Fortunately,
-	 * the register BAR remains the same size for all the earlier
-	 * generations up to Ironlake.
-	 */
-	if (INTEL_GEN(dev_priv) < 5)
-		mmio_size = 512 * 1024;
-	else
-		mmio_size = 2 * 1024 * 1024;
-	dev_priv->regs = pci_iomap(pdev, mmio_bar, mmio_size);
-	if (dev_priv->regs == NULL) {
-		DRM_ERROR("failed to map registers\n");
-
-		return -EIO;
-	}
-
-	/* Try to make sure MCHBAR is enabled before poking at it */
-	intel_setup_mchbar(dev_priv);
-
-	return 0;
-}
-
-static void i915_mmio_cleanup(struct drm_i915_private *dev_priv)
-{
-	struct pci_dev *pdev = dev_priv->drm.pdev;
-
-	intel_teardown_mchbar(dev_priv);
-	pci_iounmap(pdev, dev_priv->regs);
-}
-
 /**
  * i915_driver_init_mmio - setup device MMIO
  * @dev_priv: device private
@@ -1027,11 +987,12 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	if (i915_get_bridge_dev(dev_priv))
 		return -EIO;
 
-	ret = i915_mmio_setup(dev_priv);
+	ret = intel_uncore_init(&dev_priv->uncore);
 	if (ret < 0)
 		goto err_bridge;
 
-	intel_uncore_init(&dev_priv->uncore);
+	/* Try to make sure MCHBAR is enabled before poking at it */
+	intel_setup_mchbar(dev_priv);
 
 	intel_device_info_init_mmio(dev_priv);
 
@@ -1048,8 +1009,8 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	return 0;
 
 err_uncore:
+	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini(&dev_priv->uncore);
-	i915_mmio_cleanup(dev_priv);
 err_bridge:
 	pci_dev_put(dev_priv->bridge_dev);
 
@@ -1062,8 +1023,8 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 {
+	intel_teardown_mchbar(dev_priv);
 	intel_uncore_fini(&dev_priv->uncore);
-	i915_mmio_cleanup(dev_priv);
 	pci_dev_put(dev_priv->bridge_dev);
 }
 

commit f7de50278e5ccaa2741c0871a41db63d70058a4e
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Mar 19 11:35:37 2019 -0700

    drm/i915: make more uncore function work on intel_uncore
    
    Move the init, fini, prune, suspend, resume function to work on
    intel_uncore instead of dev_priv.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190319183543.13679-5-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4ec41c3a9038..fd2de1d58b64 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1031,11 +1031,11 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	if (ret < 0)
 		goto err_bridge;
 
-	intel_uncore_init(dev_priv);
+	intel_uncore_init(&dev_priv->uncore);
 
 	intel_device_info_init_mmio(dev_priv);
 
-	intel_uncore_prune(dev_priv);
+	intel_uncore_prune(&dev_priv->uncore);
 
 	intel_uc_init_mmio(dev_priv);
 
@@ -1048,7 +1048,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	return 0;
 
 err_uncore:
-	intel_uncore_fini(dev_priv);
+	intel_uncore_fini(&dev_priv->uncore);
 	i915_mmio_cleanup(dev_priv);
 err_bridge:
 	pci_dev_put(dev_priv->bridge_dev);
@@ -1062,7 +1062,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 {
-	intel_uncore_fini(dev_priv);
+	intel_uncore_fini(&dev_priv->uncore);
 	i915_mmio_cleanup(dev_priv);
 	pci_dev_put(dev_priv->bridge_dev);
 }
@@ -2124,7 +2124,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	i915_gem_suspend_late(dev_priv);
 
-	intel_uncore_suspend(dev_priv);
+	intel_uncore_suspend(&dev_priv->uncore);
 
 	intel_power_domains_suspend(dev_priv,
 				    get_suspend_mode(dev_priv, hibernation));
@@ -2320,7 +2320,9 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
 			  ret);
 
-	intel_uncore_resume_early(dev_priv);
+	intel_uncore_resume_early(&dev_priv->uncore);
+
+	i915_check_and_clear_faults(dev_priv);
 
 	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv)) {
 		gen9_sanitize_dc_state(dev_priv);
@@ -2890,7 +2892,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
-	intel_uncore_suspend(dev_priv);
+	intel_uncore_suspend(&dev_priv->uncore);
 
 	ret = 0;
 	if (INTEL_GEN(dev_priv) >= 11) {
@@ -2907,7 +2909,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
-		intel_uncore_runtime_resume(dev_priv);
+		intel_uncore_runtime_resume(&dev_priv->uncore);
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
@@ -3004,7 +3006,7 @@ static int intel_runtime_resume(struct device *kdev)
 		ret = vlv_resume_prepare(dev_priv, true);
 	}
 
-	intel_uncore_runtime_resume(dev_priv);
+	intel_uncore_runtime_resume(&dev_priv->uncore);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 

commit f568eeee535597dfcf7b84169b135ada8696ba59
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Tue Mar 19 11:35:35 2019 -0700

    drm/i915: use intel_uncore in fw get/put internal paths
    
    Get/put functions used outside of uncore.c are updated in the next
    patch for a nicer split.
    
    v2: use dev_priv where we still have it (Paulo)
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190319183543.13679-3-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b3d2524ce7cc..4ec41c3a9038 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2952,7 +2952,7 @@ static int intel_runtime_suspend(struct device *kdev)
 		intel_opregion_notify_adapter(dev_priv, PCI_D1);
 	}
 
-	assert_forcewakes_inactive(dev_priv);
+	assert_forcewakes_inactive(&dev_priv->uncore);
 
 	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_poll_init(dev_priv);

commit 729ae330a0f2e270db2ca70c06a83d0aa2776288
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Mon Mar 18 13:01:33 2019 -0700

    drm/i915/cml: Introduce Comet Lake PCH
    
    Comet Lake PCH is based off of Cannon Point(CNP).
    Add PCI ID for Comet Lake PCH.
    
    v2: Code cleanup (DK)
    
    v3: Comment cleanup (Jani)
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190318200133.9666-2-anusha.srivatsa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 707c3a0d1ed9..b3d2524ce7cc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -188,6 +188,11 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 		DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
 		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));
 		return PCH_CNP;
+	case INTEL_PCH_CMP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Comet Lake PCH (CMP)\n");
+		WARN_ON(!IS_COFFEELAKE(dev_priv));
+		/* CometPoint is CNP Compatible */
+		return PCH_CNP;
 	case INTEL_PCH_ICP_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found Ice Lake PCH\n");
 		WARN_ON(!IS_ICELAKE(dev_priv));

commit 51d623b675b6624a2b2409fd0c45d1d26c180827
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 14 22:38:37 2019 +0000

    drm/i915: Drop address size from ppgtt_type
    
    With the introduction of the separate addressable bits into the device
    info, we can remove the conflation of the ppgtt size from the ppgtt
    type.
    
    Based on a patch by Bob Paauwe.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Bob Paauwe <bob.j.paauwe@intel.com>
    Cc: Matthew Auld <matthew.william.auld@gmail.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190314223839.28258-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index df2a939eab5e..707c3a0d1ed9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -348,7 +348,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = HAS_WT(dev_priv);
 		break;
 	case I915_PARAM_HAS_ALIASING_PPGTT:
-		value = min_t(int, INTEL_PPGTT(dev_priv), I915_GEM_PPGTT_FULL);
+		value = INTEL_PPGTT(dev_priv);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
 		value = !!(dev_priv->caps.scheduler & I915_SCHEDULER_CAP_SEMAPHORES);

commit ca6ac684de5d8091cca4b4eb78c54610101a0033
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 14 22:38:35 2019 +0000

    drm/i915: Mark up vGPU support for full-ppgtt
    
    For compatibility reasons, we only care if the vGPU host provides
    support for full-ppgtt. This is independent of the addressable memory
    size, so remove the conflation of 48b from the capability name.
    
    Based on a patch by Bob Paauwe.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Bob Paauwe <bob.j.paauwe@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190314223839.28258-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a74fdec7137c..df2a939eab5e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1527,7 +1527,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	if (HAS_PPGTT(dev_priv)) {
 		if (intel_vgpu_active(dev_priv) &&
-		    !intel_vgpu_has_full_48bit_ppgtt(dev_priv)) {
+		    !intel_vgpu_has_full_ppgtt(dev_priv)) {
 			i915_report_error(dev_priv,
 					  "incompatible vGPU found, support for isolated ppGTT required\n");
 			return -ENXIO;

commit 5861b013e2c7328b10ff691e655ae678245fd6fd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 8 09:36:54 2019 +0000

    drm/i915: Do a synchronous switch-to-kernel-context on idling
    
    When the system idles, we switch to the kernel context as a defensive
    measure (no users are harmed if the kernel context is lost). Currently,
    we issue a switch to kernel context and then come back later to see if
    the kernel context is still current and the system is idle. However,
    if we are no longer privy to the runqueue ordering, then we have to
    relax our assumptions about the logical state of the GPU and the only
    way to ensure that the kernel context is currently loaded is by issuing
    a request to run after all others, and wait for it to complete all while
    preventing anyone else from issuing their own requests.
    
    v2: Pull wedging into switch_to_kernel_context_sync() but only after
    waiting (though only for the same short delay) for the active context to
    finish.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190308093657.8640-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bcfc12dd9dda..a74fdec7137c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -714,8 +714,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	return 0;
 
 cleanup_gem:
-	if (i915_gem_suspend(dev_priv))
-		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
+	i915_gem_suspend(dev_priv);
 	i915_gem_fini(dev_priv);
 cleanup_modeset:
 	intel_modeset_cleanup(dev);
@@ -1933,8 +1932,7 @@ void i915_driver_unload(struct drm_device *dev)
 	/* Flush any external code that still may be under the RCU lock */
 	synchronize_rcu();
 
-	if (i915_gem_suspend(dev_priv))
-		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
+	i915_gem_suspend(dev_priv);
 
 	drm_atomic_helper_shutdown(dev);
 
@@ -2042,7 +2040,6 @@ static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 static int i915_drm_prepare(struct drm_device *dev)
 {
 	struct drm_i915_private *i915 = to_i915(dev);
-	int err;
 
 	/*
 	 * NB intel_display_suspend() may issue new requests after we've
@@ -2050,12 +2047,9 @@ static int i915_drm_prepare(struct drm_device *dev)
 	 * split out that work and pull it forward so that after point,
 	 * the GPU is not woken again.
 	 */
-	err = i915_gem_suspend(i915);
-	if (err)
-		dev_err(&i915->drm.pdev->dev,
-			"GEM idle failed, suspend/resume might fail\n");
+	i915_gem_suspend(i915);
 
-	return err;
+	return 0;
 }
 
 static int i915_drm_suspend(struct drm_device *dev)

commit b185a35216c003f53149974981389f093523b137
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:51 2019 +0200

    drm/i915: Read out memory type
    
    We'll need to know the memory type in the system for some
    bandwidth limitations and whatnot. Let's read that out on
    gen9+.
    
    v2: Rebase
    v3: Fix the copy paste fail in the BXT bit definitions (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-13-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 611e15edcd66..bcfc12dd9dda 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1068,6 +1068,26 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
+#define DRAM_TYPE_STR(type) [INTEL_DRAM_ ## type] = #type
+
+static const char *intel_dram_type_str(enum intel_dram_type type)
+{
+	static const char * const str[] = {
+		DRAM_TYPE_STR(UNKNOWN),
+		DRAM_TYPE_STR(DDR3),
+		DRAM_TYPE_STR(DDR4),
+		DRAM_TYPE_STR(LPDDR3),
+		DRAM_TYPE_STR(LPDDR4),
+	};
+
+	if (type >= ARRAY_SIZE(str))
+		type = INTEL_DRAM_UNKNOWN;
+
+	return str[type];
+}
+
+#undef DRAM_TYPE_STR
+
 static int intel_dimm_num_devices(const struct dram_dimm_info *dimm)
 {
 	return dimm->ranks * 64 / (dimm->width ?: 1);
@@ -1254,6 +1274,28 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
+static enum intel_dram_type
+skl_get_dram_type(struct drm_i915_private *dev_priv)
+{
+	u32 val;
+
+	val = I915_READ(SKL_MAD_INTER_CHANNEL_0_0_0_MCHBAR_MCMAIN);
+
+	switch (val & SKL_DRAM_DDR_TYPE_MASK) {
+	case SKL_DRAM_DDR_TYPE_DDR3:
+		return INTEL_DRAM_DDR3;
+	case SKL_DRAM_DDR_TYPE_DDR4:
+		return INTEL_DRAM_DDR4;
+	case SKL_DRAM_DDR_TYPE_LPDDR3:
+		return INTEL_DRAM_LPDDR3;
+	case SKL_DRAM_DDR_TYPE_LPDDR4:
+		return INTEL_DRAM_LPDDR4;
+	default:
+		MISSING_CASE(val);
+		return INTEL_DRAM_UNKNOWN;
+	}
+}
+
 static int
 skl_get_dram_info(struct drm_i915_private *dev_priv)
 {
@@ -1261,6 +1303,9 @@ skl_get_dram_info(struct drm_i915_private *dev_priv)
 	u32 mem_freq_khz, val;
 	int ret;
 
+	dram_info->type = skl_get_dram_type(dev_priv);
+	DRM_DEBUG_KMS("DRAM type: %s\n", intel_dram_type_str(dram_info->type));
+
 	ret = skl_dram_get_channels_info(dev_priv);
 	if (ret)
 		return ret;
@@ -1327,6 +1372,26 @@ static int bxt_get_dimm_ranks(u32 val)
 	}
 }
 
+static enum intel_dram_type bxt_get_dimm_type(u32 val)
+{
+	if (!bxt_get_dimm_size(val))
+		return INTEL_DRAM_UNKNOWN;
+
+	switch (val & BXT_DRAM_TYPE_MASK) {
+	case BXT_DRAM_TYPE_DDR3:
+		return INTEL_DRAM_DDR3;
+	case BXT_DRAM_TYPE_LPDDR3:
+		return INTEL_DRAM_LPDDR3;
+	case BXT_DRAM_TYPE_DDR4:
+		return INTEL_DRAM_DDR4;
+	case BXT_DRAM_TYPE_LPDDR4:
+		return INTEL_DRAM_LPDDR4;
+	default:
+		MISSING_CASE(val);
+		return INTEL_DRAM_UNKNOWN;
+	}
+}
+
 static void bxt_get_dimm_info(struct dram_dimm_info *dimm,
 			      u32 val)
 {
@@ -1369,6 +1434,7 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 	 */
 	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
 		struct dram_dimm_info dimm;
+		enum intel_dram_type type;
 
 		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
 		if (val == 0xFFFFFFFF)
@@ -1377,10 +1443,16 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		dram_info->num_channels++;
 
 		bxt_get_dimm_info(&dimm, val);
+		type = bxt_get_dimm_type(val);
+
+		WARN_ON(type != INTEL_DRAM_UNKNOWN &&
+			dram_info->type != INTEL_DRAM_UNKNOWN &&
+			dram_info->type != type);
 
-		DRM_DEBUG_KMS("CH%u DIMM size: %u GB, width: X%u, ranks: %u\n",
+		DRM_DEBUG_KMS("CH%u DIMM size: %u GB, width: X%u, ranks: %u, type: %s\n",
 			      i - BXT_D_CR_DRP0_DUNIT_START,
-			      dimm.size, dimm.width, dimm.ranks);
+			      dimm.size, dimm.width, dimm.ranks,
+			      intel_dram_type_str(type));
 
 		/*
 		 * If any of the channel is single rank channel,
@@ -1391,10 +1463,14 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 			dram_info->ranks = dimm.ranks;
 		else if (dimm.ranks == 1)
 			dram_info->ranks = 1;
+
+		if (type != INTEL_DRAM_UNKNOWN)
+			dram_info->type = type;
 	}
 
-	if (dram_info->ranks == 0) {
-		DRM_INFO("couldn't get memory rank information\n");
+	if (dram_info->type == INTEL_DRAM_UNKNOWN ||
+	    dram_info->ranks == 0) {
+		DRM_INFO("couldn't get memory information\n");
 		return -EINVAL;
 	}
 

commit 6d9c1e92038507d03f6a25332719ad4b0ad00279
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:50 2019 +0200

    drm/i915: Extract DIMM info on cnl+
    
    We'll need information about the memory configuration on cnl+ too.
    Extend the code to parse the slightly changed register layout.
    
    v2: Document what cnl_get_dimm_size() returns (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-12-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0d00f837ba7f..611e15edcd66 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1106,6 +1106,39 @@ static int skl_get_dimm_ranks(u16 val)
 	return val + 1;
 }
 
+/* Returns total GB for the whole DIMM */
+static int cnl_get_dimm_size(u16 val)
+{
+	return (val & CNL_DRAM_SIZE_MASK) / 2;
+}
+
+static int cnl_get_dimm_width(u16 val)
+{
+	if (cnl_get_dimm_size(val) == 0)
+		return 0;
+
+	switch (val & CNL_DRAM_WIDTH_MASK) {
+	case CNL_DRAM_WIDTH_X8:
+	case CNL_DRAM_WIDTH_X16:
+	case CNL_DRAM_WIDTH_X32:
+		val = (val & CNL_DRAM_WIDTH_MASK) >> CNL_DRAM_WIDTH_SHIFT;
+		return 8 << val;
+	default:
+		MISSING_CASE(val);
+		return 0;
+	}
+}
+
+static int cnl_get_dimm_ranks(u16 val)
+{
+	if (cnl_get_dimm_size(val) == 0)
+		return 0;
+
+	val = (val & CNL_DRAM_RANK_MASK) >> CNL_DRAM_RANK_SHIFT;
+
+	return val + 1;
+}
+
 static bool
 skl_is_16gb_dimm(const struct dram_dimm_info *dimm)
 {
@@ -1114,12 +1147,19 @@ skl_is_16gb_dimm(const struct dram_dimm_info *dimm)
 }
 
 static void
-skl_dram_get_dimm_info(struct dram_dimm_info *dimm,
+skl_dram_get_dimm_info(struct drm_i915_private *dev_priv,
+		       struct dram_dimm_info *dimm,
 		       int channel, char dimm_name, u16 val)
 {
-	dimm->size = skl_get_dimm_size(val);
-	dimm->width = skl_get_dimm_width(val);
-	dimm->ranks = skl_get_dimm_ranks(val);
+	if (INTEL_GEN(dev_priv) >= 10) {
+		dimm->size = cnl_get_dimm_size(val);
+		dimm->width = cnl_get_dimm_width(val);
+		dimm->ranks = cnl_get_dimm_ranks(val);
+	} else {
+		dimm->size = skl_get_dimm_size(val);
+		dimm->width = skl_get_dimm_width(val);
+		dimm->ranks = skl_get_dimm_ranks(val);
+	}
 
 	DRM_DEBUG_KMS("CH%u DIMM %c size: %u GB, width: X%u, ranks: %u, 16Gb DIMMs: %s\n",
 		      channel, dimm_name, dimm->size, dimm->width, dimm->ranks,
@@ -1127,11 +1167,14 @@ skl_dram_get_dimm_info(struct dram_dimm_info *dimm,
 }
 
 static int
-skl_dram_get_channel_info(struct dram_channel_info *ch,
+skl_dram_get_channel_info(struct drm_i915_private *dev_priv,
+			  struct dram_channel_info *ch,
 			  int channel, u32 val)
 {
-	skl_dram_get_dimm_info(&ch->dimm_l, channel, 'L', val & 0xffff);
-	skl_dram_get_dimm_info(&ch->dimm_s, channel, 'S', val >> 16);
+	skl_dram_get_dimm_info(dev_priv, &ch->dimm_l,
+			       channel, 'L', val & 0xffff);
+	skl_dram_get_dimm_info(dev_priv, &ch->dimm_s,
+			       channel, 'S', val >> 16);
 
 	if (ch->dimm_l.size == 0 && ch->dimm_s.size == 0) {
 		DRM_DEBUG_KMS("CH%u not populated\n", channel);
@@ -1173,12 +1216,12 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 	int ret;
 
 	val = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch0, 0, val);
+	ret = skl_dram_get_channel_info(dev_priv, &ch0, 0, val);
 	if (ret == 0)
 		dram_info->num_channels++;
 
 	val = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch1, 1, val);
+	ret = skl_dram_get_channel_info(dev_priv, &ch1, 1, val);
 	if (ret == 0)
 		dram_info->num_channels++;
 
@@ -1375,13 +1418,10 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	if (INTEL_GEN(dev_priv) < 9)
 		return;
 
-	/* Need to calculate bandwidth only for Gen9 */
 	if (IS_GEN9_LP(dev_priv))
 		ret = bxt_get_dram_info(dev_priv);
-	else if (IS_GEN(dev_priv, 9))
-		ret = skl_get_dram_info(dev_priv);
 	else
-		ret = skl_dram_get_channels_info(dev_priv);
+		ret = skl_get_dram_info(dev_priv);
 	if (ret)
 		return;
 

commit 30a533e5774b726621fffdb910d5ae5830f509cc
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:49 2019 +0200

    drm/i915: Clean up intel_get_dram_info() a bit
    
    Remove the pointless zero initialization of bunch of things
    (the thing is kzalloc()ed).
    
    Also throw out the mostly useless on-stack string. I think
    it'll be clear enough from the logs that 0 means unknown.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-11-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 54b40c9ea1f7..0d00f837ba7f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1363,14 +1363,8 @@ static void
 intel_get_dram_info(struct drm_i915_private *dev_priv)
 {
 	struct dram_info *dram_info = &dev_priv->dram_info;
-	char bandwidth_str[32];
 	int ret;
 
-	dram_info->valid = false;
-	dram_info->ranks = 0;
-	dram_info->bandwidth_kbps = 0;
-	dram_info->num_channels = 0;
-
 	/*
 	 * Assume 16Gb DIMMs are present until proven otherwise.
 	 * This is only used for the level 0 watermark latency
@@ -1391,12 +1385,10 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	if (ret)
 		return;
 
-	if (dram_info->bandwidth_kbps)
-		sprintf(bandwidth_str, "%d KBps", dram_info->bandwidth_kbps);
-	else
-		sprintf(bandwidth_str, "unknown");
-	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
-		      bandwidth_str, dram_info->num_channels);
+	DRM_DEBUG_KMS("DRAM bandwidth: %u kBps, channels: %u\n",
+		      dram_info->bandwidth_kbps,
+		      dram_info->num_channels);
+
 	DRM_DEBUG_KMS("DRAM ranks: %u, 16Gb DIMMs: %s\n",
 		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
 }

commit 1d55967dc1cfb50906422f8068e8332ba3821bc7
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:48 2019 +0200

    drm/i914: s/l_info/dimm_l/ etc.
    
    Rename the dimm info structs for clarity.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-10-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 08914761303d..54b40c9ea1f7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1130,24 +1130,24 @@ static int
 skl_dram_get_channel_info(struct dram_channel_info *ch,
 			  int channel, u32 val)
 {
-	skl_dram_get_dimm_info(&ch->l_info, channel, 'L', val & 0xffff);
-	skl_dram_get_dimm_info(&ch->s_info, channel, 'S', val >> 16);
+	skl_dram_get_dimm_info(&ch->dimm_l, channel, 'L', val & 0xffff);
+	skl_dram_get_dimm_info(&ch->dimm_s, channel, 'S', val >> 16);
 
-	if (ch->l_info.size == 0 && ch->s_info.size == 0) {
+	if (ch->dimm_l.size == 0 && ch->dimm_s.size == 0) {
 		DRM_DEBUG_KMS("CH%u not populated\n", channel);
 		return -EINVAL;
 	}
 
-	if (ch->l_info.ranks == 2 || ch->s_info.ranks == 2)
+	if (ch->dimm_l.ranks == 2 || ch->dimm_s.ranks == 2)
 		ch->ranks = 2;
-	else if (ch->l_info.ranks == 1 && ch->s_info.ranks == 1)
+	else if (ch->dimm_l.ranks == 1 && ch->dimm_s.ranks == 1)
 		ch->ranks = 2;
 	else
 		ch->ranks = 1;
 
 	ch->is_16gb_dimm =
-		skl_is_16gb_dimm(&ch->l_info) ||
-		skl_is_16gb_dimm(&ch->s_info);
+		skl_is_16gb_dimm(&ch->dimm_l) ||
+		skl_is_16gb_dimm(&ch->dimm_s);
 
 	DRM_DEBUG_KMS("CH%u ranks: %u, 16Gb DIMMs: %s\n",
 		      channel, ch->ranks, yesno(ch->is_16gb_dimm));
@@ -1160,8 +1160,8 @@ intel_is_dram_symmetric(const struct dram_channel_info *ch0,
 			const struct dram_channel_info *ch1)
 {
 	return !memcmp(ch0, ch1, sizeof(*ch0)) &&
-		(ch0->s_info.size == 0 ||
-		 !memcmp(&ch0->l_info, &ch0->s_info, sizeof(ch0->l_info)));
+		(ch0->dimm_s.size == 0 ||
+		 !memcmp(&ch0->dimm_l, &ch0->dimm_s, sizeof(ch0->dimm_l)));
 }
 
 static int

commit d75434bc341eca20c4d094bc30946028b53d1281
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:47 2019 +0200

    drm/i915: Generalize intel_is_dram_symmetric()
    
    Decouple intel_is_dram_symmetric() from the raw register values
    by comparing just the dram_channel_info structs.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-9-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 71a4da5caee7..08914761303d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1156,14 +1156,12 @@ skl_dram_get_channel_info(struct dram_channel_info *ch,
 }
 
 static bool
-intel_is_dram_symmetric(u32 val_ch0, u32 val_ch1,
-			struct dram_channel_info *ch0)
+intel_is_dram_symmetric(const struct dram_channel_info *ch0,
+			const struct dram_channel_info *ch1)
 {
-	return (val_ch0 == val_ch1 &&
+	return !memcmp(ch0, ch1, sizeof(*ch0)) &&
 		(ch0->s_info.size == 0 ||
-		 (ch0->l_info.size == ch0->s_info.size &&
-		  ch0->l_info.width == ch0->s_info.width &&
-		  ch0->l_info.ranks == ch0->s_info.ranks)));
+		 !memcmp(&ch0->l_info, &ch0->s_info, sizeof(ch0->l_info)));
 }
 
 static int
@@ -1171,16 +1169,16 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 {
 	struct dram_info *dram_info = &dev_priv->dram_info;
 	struct dram_channel_info ch0 = {}, ch1 = {};
-	u32 val_ch0, val_ch1;
+	u32 val;
 	int ret;
 
-	val_ch0 = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch0, 0, val_ch0);
+	val = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch0, 0, val);
 	if (ret == 0)
 		dram_info->num_channels++;
 
-	val_ch1 = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch1, 1, val_ch1);
+	val = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch1, 1, val);
 	if (ret == 0)
 		dram_info->num_channels++;
 
@@ -1206,12 +1204,10 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 
 	dram_info->is_16gb_dimm = ch0.is_16gb_dimm || ch1.is_16gb_dimm;
 
-	dev_priv->dram_info.symmetric_memory = intel_is_dram_symmetric(val_ch0,
-								       val_ch1,
-								       &ch0);
+	dram_info->symmetric_memory = intel_is_dram_symmetric(&ch0, &ch1);
 
-	DRM_DEBUG_KMS("memory configuration is %sSymmetric memory\n",
-		      dev_priv->dram_info.symmetric_memory ? "" : "not ");
+	DRM_DEBUG_KMS("Memory configuration is symmetric? %s\n",
+		      yesno(dram_info->symmetric_memory));
 	return 0;
 }
 

commit 198b8dd91b7978c01a5cc719ce5bd75b3b9732f4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:46 2019 +0200

    drm/i915: Use dram_dimm_info more
    
    Reduce the code duplication a bit by sharing the same
    code for parsing both DIMMs on a channel.
    
    v2: s/%d/%u/ all over (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-8-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7f8bdebd9f1a..71a4da5caee7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1113,25 +1113,30 @@ skl_is_16gb_dimm(const struct dram_dimm_info *dimm)
 	return 8 * dimm->size / (intel_dimm_num_devices(dimm) ?: 1) == 16;
 }
 
-static int
-skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
+static void
+skl_dram_get_dimm_info(struct dram_dimm_info *dimm,
+		       int channel, char dimm_name, u16 val)
 {
-	u16 tmp_l, tmp_s;
+	dimm->size = skl_get_dimm_size(val);
+	dimm->width = skl_get_dimm_width(val);
+	dimm->ranks = skl_get_dimm_ranks(val);
 
-	tmp_l = val & 0xffff;
-	tmp_s = val >> 16;
+	DRM_DEBUG_KMS("CH%u DIMM %c size: %u GB, width: X%u, ranks: %u, 16Gb DIMMs: %s\n",
+		      channel, dimm_name, dimm->size, dimm->width, dimm->ranks,
+		      yesno(skl_is_16gb_dimm(dimm)));
+}
 
-	ch->l_info.size = skl_get_dimm_size(tmp_l);
-	ch->s_info.size = skl_get_dimm_size(tmp_s);
+static int
+skl_dram_get_channel_info(struct dram_channel_info *ch,
+			  int channel, u32 val)
+{
+	skl_dram_get_dimm_info(&ch->l_info, channel, 'L', val & 0xffff);
+	skl_dram_get_dimm_info(&ch->s_info, channel, 'S', val >> 16);
 
-	if (ch->l_info.size == 0 && ch->s_info.size == 0)
+	if (ch->l_info.size == 0 && ch->s_info.size == 0) {
+		DRM_DEBUG_KMS("CH%u not populated\n", channel);
 		return -EINVAL;
-
-	ch->l_info.width = skl_get_dimm_width(tmp_l);
-	ch->s_info.width = skl_get_dimm_width(tmp_s);
-
-	ch->l_info.ranks = skl_get_dimm_ranks(tmp_l);
-	ch->s_info.ranks = skl_get_dimm_ranks(tmp_s);
+	}
 
 	if (ch->l_info.ranks == 2 || ch->s_info.ranks == 2)
 		ch->ranks = 2;
@@ -1144,9 +1149,8 @@ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 		skl_is_16gb_dimm(&ch->l_info) ||
 		skl_is_16gb_dimm(&ch->s_info);
 
-	DRM_DEBUG_KMS("(size:width:ranks) L(%uGB:X%u:%u) S(%uGB:X%u:%u)\n",
-		      ch->l_info.size, ch->l_info.width, ch->l_info.ranks,
-		      ch->s_info.size, ch->s_info.width, ch->s_info.ranks);
+	DRM_DEBUG_KMS("CH%u ranks: %u, 16Gb DIMMs: %s\n",
+		      channel, ch->ranks, yesno(ch->is_16gb_dimm));
 
 	return 0;
 }
@@ -1166,17 +1170,17 @@ static int
 skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 {
 	struct dram_info *dram_info = &dev_priv->dram_info;
-	struct dram_channel_info ch0, ch1;
+	struct dram_channel_info ch0 = {}, ch1 = {};
 	u32 val_ch0, val_ch1;
 	int ret;
 
 	val_ch0 = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch0, val_ch0);
+	ret = skl_dram_get_channel_info(&ch0, 0, val_ch0);
 	if (ret == 0)
 		dram_info->num_channels++;
 
 	val_ch1 = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch1, val_ch1);
+	ret = skl_dram_get_channel_info(&ch1, 1, val_ch1);
 	if (ret == 0)
 		dram_info->num_channels++;
 

commit 331ecded7e6cb005a22fea99d3d02402cf19a7b1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:45 2019 +0200

    drm/i915: Extract DIMM info on GLK too
    
    The BXT code for parsing DIMM info works for GLK too. Let's
    dig it out even if we might not need it immediately.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-7-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a3cf74a00b3f..7f8bdebd9f1a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1378,11 +1378,11 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	 */
 	dram_info->is_16gb_dimm = !IS_GEN9_LP(dev_priv);
 
-	if (INTEL_GEN(dev_priv) < 9 || IS_GEMINILAKE(dev_priv))
+	if (INTEL_GEN(dev_priv) < 9)
 		return;
 
 	/* Need to calculate bandwidth only for Gen9 */
-	if (IS_BROXTON(dev_priv))
+	if (IS_GEN9_LP(dev_priv))
 		ret = bxt_get_dram_info(dev_priv);
 	else if (IS_GEN(dev_priv, 9))
 		ret = skl_get_dram_info(dev_priv);

commit 8860343cc9a7f31fa6d0fb904770924593f6c311
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:44 2019 +0200

    drm/i915: Fix DRAM size reporting for BXT
    
    The BXT DUNIT register tells us the size of each DRAM device
    in Gb. We want to report the size of the whole DIMM in GB, so
    that it matches how we report it for non-LP platforms.
    
    v2: Deobfuscate the math (Chris)
        s/GB/GBIT/ in the register bit definitions (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-6-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bba051d9f21d..a3cf74a00b3f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1242,15 +1242,15 @@ skl_get_dram_info(struct drm_i915_private *dev_priv)
 static int bxt_get_dimm_size(u32 val)
 {
 	switch (val & BXT_DRAM_SIZE_MASK) {
-	case BXT_DRAM_SIZE_4GB:
+	case BXT_DRAM_SIZE_4GBIT:
 		return 4;
-	case BXT_DRAM_SIZE_6GB:
+	case BXT_DRAM_SIZE_6GBIT:
 		return 6;
-	case BXT_DRAM_SIZE_8GB:
+	case BXT_DRAM_SIZE_8GBIT:
 		return 8;
-	case BXT_DRAM_SIZE_12GB:
+	case BXT_DRAM_SIZE_12GBIT:
 		return 12;
-	case BXT_DRAM_SIZE_16GB:
+	case BXT_DRAM_SIZE_16GBIT:
 		return 16;
 	default:
 		MISSING_CASE(val);
@@ -1287,9 +1287,14 @@ static int bxt_get_dimm_ranks(u32 val)
 static void bxt_get_dimm_info(struct dram_dimm_info *dimm,
 			      u32 val)
 {
-	dimm->size = bxt_get_dimm_size(val);
 	dimm->width = bxt_get_dimm_width(val);
 	dimm->ranks = bxt_get_dimm_ranks(val);
+
+	/*
+	 * Size in register is Gb per DRAM device. Convert to total
+	 * GB to match the way we report this for non-LP platforms.
+	 */
+	dimm->size = bxt_get_dimm_size(val) * intel_dimm_num_devices(dimm) / 8;
 }
 
 static int

commit a62819a301d8d68d6d305adc20fbea6fbcb67a14
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:43 2019 +0200

    drm/i915: Extract BXT DIMM helpers
    
    Polish the bxt DIMM parsing by extracting a few small helpers.
    
    v2: Use struct dram_dimm_info
    v3: Document what bxt_get_dimm_size() returns (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-5-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e35a75be3a2a..bba051d9f21d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1238,6 +1238,60 @@ skl_get_dram_info(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
+/* Returns Gb per DRAM device */
+static int bxt_get_dimm_size(u32 val)
+{
+	switch (val & BXT_DRAM_SIZE_MASK) {
+	case BXT_DRAM_SIZE_4GB:
+		return 4;
+	case BXT_DRAM_SIZE_6GB:
+		return 6;
+	case BXT_DRAM_SIZE_8GB:
+		return 8;
+	case BXT_DRAM_SIZE_12GB:
+		return 12;
+	case BXT_DRAM_SIZE_16GB:
+		return 16;
+	default:
+		MISSING_CASE(val);
+		return 0;
+	}
+}
+
+static int bxt_get_dimm_width(u32 val)
+{
+	if (!bxt_get_dimm_size(val))
+		return 0;
+
+	val = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
+
+	return 8 << val;
+}
+
+static int bxt_get_dimm_ranks(u32 val)
+{
+	if (!bxt_get_dimm_size(val))
+		return 0;
+
+	switch (val & BXT_DRAM_RANK_MASK) {
+	case BXT_DRAM_RANK_SINGLE:
+		return 1;
+	case BXT_DRAM_RANK_DUAL:
+		return 2;
+	default:
+		MISSING_CASE(val);
+		return 0;
+	}
+}
+
+static void bxt_get_dimm_info(struct dram_dimm_info *dimm,
+			      u32 val)
+{
+	dimm->size = bxt_get_dimm_size(val);
+	dimm->width = bxt_get_dimm_width(val);
+	dimm->ranks = bxt_get_dimm_ranks(val);
+}
+
 static int
 bxt_get_dram_info(struct drm_i915_private *dev_priv)
 {
@@ -1266,41 +1320,19 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 	 * Now read each DUNIT8/9/10/11 to check the rank of each dimms.
 	 */
 	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
-		u8 size, width, ranks;
-		u32 tmp;
+		struct dram_dimm_info dimm;
 
 		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
 		if (val == 0xFFFFFFFF)
 			continue;
 
 		dram_info->num_channels++;
-		tmp = val & BXT_DRAM_RANK_MASK;
-
-		if (tmp == BXT_DRAM_RANK_SINGLE)
-			ranks = 1;
-		else if (tmp == BXT_DRAM_RANK_DUAL)
-			ranks = 2;
-		else
-			ranks = 0;
-
-		tmp = val & BXT_DRAM_SIZE_MASK;
-		if (tmp == BXT_DRAM_SIZE_4GB)
-			size = 4;
-		else if (tmp == BXT_DRAM_SIZE_6GB)
-			size = 6;
-		else if (tmp == BXT_DRAM_SIZE_8GB)
-			size = 8;
-		else if (tmp == BXT_DRAM_SIZE_12GB)
-			size = 12;
-		else if (tmp == BXT_DRAM_SIZE_16GB)
-			size = 16;
-		else
-			size = 0;
-
-		tmp = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
-		width = (1 << tmp) * 8;
-		DRM_DEBUG_KMS("dram size:%uGB width:X%u ranks:%u\n",
-			      size, width, ranks);
+
+		bxt_get_dimm_info(&dimm, val);
+
+		DRM_DEBUG_KMS("CH%u DIMM size: %u GB, width: X%u, ranks: %u\n",
+			      i - BXT_D_CR_DRP0_DUNIT_START,
+			      dimm.size, dimm.width, dimm.ranks);
 
 		/*
 		 * If any of the channel is single rank channel,
@@ -1308,8 +1340,8 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		 * memory, so consider single rank memory.
 		 */
 		if (dram_info->ranks == 0)
-			dram_info->ranks = ranks;
-		else if (ranks == 1)
+			dram_info->ranks = dimm.ranks;
+		else if (dimm.ranks == 1)
 			dram_info->ranks = 1;
 	}
 

commit 54561b238b1994d7ffe586b9d85ddf3c39a5a37c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:42 2019 +0200

    drm/i915: Polish skl_is_16gb_dimm()
    
    Pass the dimm struct to skl_is_16gb_dimm() rather than passing each
    value separately. And let's replace the hardcoded set of values with
    some simple arithmetic.
    
    Also fix the byte vs. bit inconsistency in the debug message,
    and polish the wording otherwise as well.
    
    v2: Deobfuscate the math (Chris)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-4-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 45d70ecd9037..e35a75be3a2a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1068,6 +1068,11 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
+static int intel_dimm_num_devices(const struct dram_dimm_info *dimm)
+{
+	return dimm->ranks * 64 / (dimm->width ?: 1);
+}
+
 /* Returns total GB for the whole DIMM */
 static int skl_get_dimm_size(u16 val)
 {
@@ -1102,18 +1107,10 @@ static int skl_get_dimm_ranks(u16 val)
 }
 
 static bool
-skl_is_16gb_dimm(u8 ranks, u8 size, u8 width)
+skl_is_16gb_dimm(const struct dram_dimm_info *dimm)
 {
-	if (ranks == 1 && width == 8 && size == 16)
-		return true;
-	else if (ranks == 2 && width == 8 && size == 32)
-		return true;
-	else if (ranks == 1 && width == 16 && size == 8)
-		return true;
-	else if (ranks == 2 && width == 16 && size == 16)
-		return true;
-
-	return false;
+	/* Convert total GB to Gb per DRAM device */
+	return 8 * dimm->size / (intel_dimm_num_devices(dimm) ?: 1) == 16;
 }
 
 static int
@@ -1143,10 +1140,9 @@ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 	else
 		ch->ranks = 1;
 
-	ch->is_16gb_dimm = skl_is_16gb_dimm(ch->l_info.ranks, ch->l_info.size,
-					    ch->l_info.width) ||
-			   skl_is_16gb_dimm(ch->s_info.ranks, ch->s_info.size,
-					    ch->s_info.width);
+	ch->is_16gb_dimm =
+		skl_is_16gb_dimm(&ch->l_info) ||
+		skl_is_16gb_dimm(&ch->s_info);
 
 	DRM_DEBUG_KMS("(size:width:ranks) L(%uGB:X%u:%u) S(%uGB:X%u:%u)\n",
 		      ch->l_info.size, ch->l_info.width, ch->l_info.ranks,
@@ -1364,7 +1360,7 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 		sprintf(bandwidth_str, "unknown");
 	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
 		      bandwidth_str, dram_info->num_channels);
-	DRM_DEBUG_KMS("DRAM ranks: %u, 16GB-dimm:%s\n",
+	DRM_DEBUG_KMS("DRAM ranks: %u, 16Gb DIMMs: %s\n",
 		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
 }
 

commit ea411e6b85df938eaa3ec4e3e34e885ff496a3ce
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:41 2019 +0200

    drm/i915: Extract functions to derive SKL+ DIMM info
    
    Make the code less repetitive by extracting a few small helpers.
    
    v2: Squash in the switch removal for skl_get_dimm_ranks()
        (it got misplaced in a rebase accident)
        Document what skl_get_dimm_size() returns (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-3-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec3fb349d49e..45d70ecd9037 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1068,16 +1068,37 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
-static int skl_get_dimm_ranks(u8 size, u32 rank)
+/* Returns total GB for the whole DIMM */
+static int skl_get_dimm_size(u16 val)
 {
-	if (size == 0)
+	return val & SKL_DRAM_SIZE_MASK;
+}
+
+static int skl_get_dimm_width(u16 val)
+{
+	if (skl_get_dimm_size(val) == 0)
 		return 0;
-	if (rank == SKL_DRAM_RANK_SINGLE)
-		return 1;
-	else if (rank == SKL_DRAM_RANK_DUAL)
-		return 2;
 
-	return 0;
+	switch (val & SKL_DRAM_WIDTH_MASK) {
+	case SKL_DRAM_WIDTH_X8:
+	case SKL_DRAM_WIDTH_X16:
+	case SKL_DRAM_WIDTH_X32:
+		val = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
+		return 8 << val;
+	default:
+		MISSING_CASE(val);
+		return 0;
+	}
+}
+
+static int skl_get_dimm_ranks(u16 val)
+{
+	if (skl_get_dimm_size(val) == 0)
+		return 0;
+
+	val = (val & SKL_DRAM_RANK_MASK) >> SKL_DRAM_RANK_SHIFT;
+
+	return val + 1;
 }
 
 static bool
@@ -1098,30 +1119,22 @@ skl_is_16gb_dimm(u8 ranks, u8 size, u8 width)
 static int
 skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 {
-	u32 tmp_l, tmp_s;
-	u32 s_val = val >> SKL_DRAM_S_SHIFT;
+	u16 tmp_l, tmp_s;
 
-	if (!val)
-		return -EINVAL;
+	tmp_l = val & 0xffff;
+	tmp_s = val >> 16;
 
-	tmp_l = val & SKL_DRAM_SIZE_MASK;
-	tmp_s = s_val & SKL_DRAM_SIZE_MASK;
+	ch->l_info.size = skl_get_dimm_size(tmp_l);
+	ch->s_info.size = skl_get_dimm_size(tmp_s);
 
-	if (tmp_l == 0 && tmp_s == 0)
+	if (ch->l_info.size == 0 && ch->s_info.size == 0)
 		return -EINVAL;
 
-	ch->l_info.size = tmp_l;
-	ch->s_info.size = tmp_s;
-
-	tmp_l = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
-	tmp_s = (s_val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
-	ch->l_info.width = (1 << tmp_l) * 8;
-	ch->s_info.width = (1 << tmp_s) * 8;
+	ch->l_info.width = skl_get_dimm_width(tmp_l);
+	ch->s_info.width = skl_get_dimm_width(tmp_s);
 
-	tmp_l = val & SKL_DRAM_RANK_MASK;
-	tmp_s = s_val & SKL_DRAM_RANK_MASK;
-	ch->l_info.ranks = skl_get_dimm_ranks(ch->l_info.size, tmp_l);
-	ch->s_info.ranks = skl_get_dimm_ranks(ch->s_info.size, tmp_s);
+	ch->l_info.ranks = skl_get_dimm_ranks(tmp_l);
+	ch->s_info.ranks = skl_get_dimm_ranks(tmp_s);
 
 	if (ch->l_info.ranks == 2 || ch->s_info.ranks == 2)
 		ch->ranks = 2;

commit 80373fb6be9643d065c57c1030038fe927cfb478
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 6 22:35:40 2019 +0200

    drm/i915: Store DIMM rank information as a number
    
    Life will be easier later if we have the ranks stored
    as a bare number.
    
    v2: s/%d/%u/ all over (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-2-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b548c292738c..ec3fb349d49e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1068,28 +1068,28 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
-static enum dram_rank skl_get_dimm_rank(u8 size, u32 rank)
+static int skl_get_dimm_ranks(u8 size, u32 rank)
 {
 	if (size == 0)
-		return I915_DRAM_RANK_INVALID;
+		return 0;
 	if (rank == SKL_DRAM_RANK_SINGLE)
-		return I915_DRAM_RANK_SINGLE;
+		return 1;
 	else if (rank == SKL_DRAM_RANK_DUAL)
-		return I915_DRAM_RANK_DUAL;
+		return 2;
 
-	return I915_DRAM_RANK_INVALID;
+	return 0;
 }
 
 static bool
-skl_is_16gb_dimm(enum dram_rank rank, u8 size, u8 width)
+skl_is_16gb_dimm(u8 ranks, u8 size, u8 width)
 {
-	if (rank == I915_DRAM_RANK_SINGLE && width == 8 && size == 16)
+	if (ranks == 1 && width == 8 && size == 16)
 		return true;
-	else if (rank == I915_DRAM_RANK_DUAL && width == 8 && size == 32)
+	else if (ranks == 2 && width == 8 && size == 32)
 		return true;
-	else if (rank == SKL_DRAM_RANK_SINGLE && width == 16 && size == 8)
+	else if (ranks == 1 && width == 16 && size == 8)
 		return true;
-	else if (rank == SKL_DRAM_RANK_DUAL && width == 16 && size == 16)
+	else if (ranks == 2 && width == 16 && size == 16)
 		return true;
 
 	return false;
@@ -1120,28 +1120,24 @@ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 
 	tmp_l = val & SKL_DRAM_RANK_MASK;
 	tmp_s = s_val & SKL_DRAM_RANK_MASK;
-	ch->l_info.rank = skl_get_dimm_rank(ch->l_info.size, tmp_l);
-	ch->s_info.rank = skl_get_dimm_rank(ch->s_info.size, tmp_s);
-
-	if (ch->l_info.rank == I915_DRAM_RANK_DUAL ||
-	    ch->s_info.rank == I915_DRAM_RANK_DUAL)
-		ch->rank = I915_DRAM_RANK_DUAL;
-	else if (ch->l_info.rank == I915_DRAM_RANK_SINGLE &&
-		 ch->s_info.rank == I915_DRAM_RANK_SINGLE)
-		ch->rank = I915_DRAM_RANK_DUAL;
+	ch->l_info.ranks = skl_get_dimm_ranks(ch->l_info.size, tmp_l);
+	ch->s_info.ranks = skl_get_dimm_ranks(ch->s_info.size, tmp_s);
+
+	if (ch->l_info.ranks == 2 || ch->s_info.ranks == 2)
+		ch->ranks = 2;
+	else if (ch->l_info.ranks == 1 && ch->s_info.ranks == 1)
+		ch->ranks = 2;
 	else
-		ch->rank = I915_DRAM_RANK_SINGLE;
+		ch->ranks = 1;
 
-	ch->is_16gb_dimm = skl_is_16gb_dimm(ch->l_info.rank, ch->l_info.size,
+	ch->is_16gb_dimm = skl_is_16gb_dimm(ch->l_info.ranks, ch->l_info.size,
 					    ch->l_info.width) ||
-			   skl_is_16gb_dimm(ch->s_info.rank, ch->s_info.size,
+			   skl_is_16gb_dimm(ch->s_info.ranks, ch->s_info.size,
 					    ch->s_info.width);
 
-	DRM_DEBUG_KMS("(size:width:rank) L(%dGB:X%d:%s) S(%dGB:X%d:%s)\n",
-		      ch->l_info.size, ch->l_info.width,
-		      ch->l_info.rank ? "dual" : "single",
-		      ch->s_info.size, ch->s_info.width,
-		      ch->s_info.rank ? "dual" : "single");
+	DRM_DEBUG_KMS("(size:width:ranks) L(%uGB:X%u:%u) S(%uGB:X%u:%u)\n",
+		      ch->l_info.size, ch->l_info.width, ch->l_info.ranks,
+		      ch->s_info.size, ch->s_info.width, ch->s_info.ranks);
 
 	return 0;
 }
@@ -1154,7 +1150,7 @@ intel_is_dram_symmetric(u32 val_ch0, u32 val_ch1,
 		(ch0->s_info.size == 0 ||
 		 (ch0->l_info.size == ch0->s_info.size &&
 		  ch0->l_info.width == ch0->s_info.width &&
-		  ch0->l_info.rank == ch0->s_info.rank)));
+		  ch0->l_info.ranks == ch0->s_info.ranks)));
 }
 
 static int
@@ -1185,13 +1181,12 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 	 * will be same as if single rank memory, so consider single rank
 	 * memory.
 	 */
-	if (ch0.rank == I915_DRAM_RANK_SINGLE ||
-	    ch1.rank == I915_DRAM_RANK_SINGLE)
-		dram_info->rank = I915_DRAM_RANK_SINGLE;
+	if (ch0.ranks == 1 || ch1.ranks == 1)
+		dram_info->ranks = 1;
 	else
-		dram_info->rank = max(ch0.rank, ch1.rank);
+		dram_info->ranks = max(ch0.ranks, ch1.ranks);
 
-	if (dram_info->rank == I915_DRAM_RANK_INVALID) {
+	if (dram_info->ranks == 0) {
 		DRM_INFO("couldn't get memory rank information\n");
 		return -EINVAL;
 	}
@@ -1262,8 +1257,7 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 	 * Now read each DUNIT8/9/10/11 to check the rank of each dimms.
 	 */
 	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
-		u8 size, width;
-		enum dram_rank rank;
+		u8 size, width, ranks;
 		u32 tmp;
 
 		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
@@ -1274,11 +1268,11 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		tmp = val & BXT_DRAM_RANK_MASK;
 
 		if (tmp == BXT_DRAM_RANK_SINGLE)
-			rank = I915_DRAM_RANK_SINGLE;
+			ranks = 1;
 		else if (tmp == BXT_DRAM_RANK_DUAL)
-			rank = I915_DRAM_RANK_DUAL;
+			ranks = 2;
 		else
-			rank = I915_DRAM_RANK_INVALID;
+			ranks = 0;
 
 		tmp = val & BXT_DRAM_SIZE_MASK;
 		if (tmp == BXT_DRAM_SIZE_4GB)
@@ -1296,22 +1290,21 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 
 		tmp = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
 		width = (1 << tmp) * 8;
-		DRM_DEBUG_KMS("dram size:%dGB width:X%d rank:%s\n", size,
-			      width, rank == I915_DRAM_RANK_SINGLE ? "single" :
-			      rank == I915_DRAM_RANK_DUAL ? "dual" : "unknown");
+		DRM_DEBUG_KMS("dram size:%uGB width:X%u ranks:%u\n",
+			      size, width, ranks);
 
 		/*
 		 * If any of the channel is single rank channel,
 		 * worst case output will be same as if single rank
 		 * memory, so consider single rank memory.
 		 */
-		if (dram_info->rank == I915_DRAM_RANK_INVALID)
-			dram_info->rank = rank;
-		else if (rank == I915_DRAM_RANK_SINGLE)
-			dram_info->rank = I915_DRAM_RANK_SINGLE;
+		if (dram_info->ranks == 0)
+			dram_info->ranks = ranks;
+		else if (ranks == 1)
+			dram_info->ranks = 1;
 	}
 
-	if (dram_info->rank == I915_DRAM_RANK_INVALID) {
+	if (dram_info->ranks == 0) {
 		DRM_INFO("couldn't get memory rank information\n");
 		return -EINVAL;
 	}
@@ -1328,7 +1321,7 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	int ret;
 
 	dram_info->valid = false;
-	dram_info->rank = I915_DRAM_RANK_INVALID;
+	dram_info->ranks = 0;
 	dram_info->bandwidth_kbps = 0;
 	dram_info->num_channels = 0;
 
@@ -1358,9 +1351,8 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 		sprintf(bandwidth_str, "unknown");
 	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
 		      bandwidth_str, dram_info->num_channels);
-	DRM_DEBUG_KMS("DRAM rank: %s rank 16GB-dimm:%s\n",
-		      (dram_info->rank == I915_DRAM_RANK_DUAL) ?
-		      "dual" : "single", yesno(dram_info->is_16gb_dimm));
+	DRM_DEBUG_KMS("DRAM ranks: %u, 16GB-dimm:%s\n",
+		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
 }
 
 /**

commit c6b38fbbde91ee7b072febe4b83022e4850f934f
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Mar 1 10:24:59 2019 +0100

    drm: move i915_kick_out_vgacon to vgaarb
    
    Also rename it to vga_remove_vgacon and add kerneldoc text.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190301092502.30948-2-kraxel@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6630212f2faf..9df65d386d11 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -757,39 +757,6 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-#if !defined(CONFIG_VGA_CONSOLE)
-static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
-{
-	return 0;
-}
-#elif !defined(CONFIG_DUMMY_CONSOLE)
-static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
-{
-	return -ENODEV;
-}
-#else
-static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
-{
-	int ret = 0;
-
-	DRM_INFO("Replacing VGA console driver\n");
-
-	console_lock();
-	if (con_is_bound(&vga_con))
-		ret = do_take_over_console(&dummy_con, 0, MAX_NR_CONSOLES - 1, 1);
-	if (ret == 0) {
-		ret = do_unregister_con_driver(&vga_con);
-
-		/* Ignore "already unregistered". */
-		if (ret == -ENODEV)
-			ret = 0;
-	}
-	console_unlock();
-
-	return ret;
-}
-#endif
-
 static void intel_init_dpio(struct drm_i915_private *dev_priv)
 {
 	/*
@@ -1420,7 +1387,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		goto err_ggtt;
 	}
 
-	ret = i915_kick_out_vgacon(dev_priv);
+	ret = vga_remove_vgacon(pdev);
 	if (ret) {
 		DRM_ERROR("failed to remove conflicting VGA console\n");
 		goto err_ggtt;

commit 8a68d464366efb5b294fa11ccf23b51306cc2695
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Mar 5 18:03:30 2019 +0000

    drm/i915: Store the BIT(engine->id) as the engine's mask
    
    In the next patch, we are introducing a broad virtual engine to encompass
    multiple physical engines, losing the 1:1 nature of BIT(engine->id). To
    reflect the broader set of engines implied by the virtual instance, lets
    store the full bitmask.
    
    v2: Use intel_engine_mask_t (s/ring_mask/engine_mask/)
    v3: Tvrtko voted for moah churn so teach everyone to not mention ring
    and use $class$instance throughout.
    v4: Comment upon the disparity in bspec for using VCS1,VCS2 in gen8 and
    VCS[0-4] in later gen. We opt to keep the code consistent and use
    0-index naming throughout.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190305180332.30900-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b2f5a6f8c25..b548c292738c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -330,16 +330,16 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = dev_priv->overlay ? 1 : 0;
 		break;
 	case I915_PARAM_HAS_BSD:
-		value = !!dev_priv->engine[VCS];
+		value = !!dev_priv->engine[VCS0];
 		break;
 	case I915_PARAM_HAS_BLT:
-		value = !!dev_priv->engine[BCS];
+		value = !!dev_priv->engine[BCS0];
 		break;
 	case I915_PARAM_HAS_VEBOX:
-		value = !!dev_priv->engine[VECS];
+		value = !!dev_priv->engine[VECS0];
 		break;
 	case I915_PARAM_HAS_BSD2:
-		value = !!dev_priv->engine[VCS2];
+		value = !!dev_priv->engine[VCS1];
 		break;
 	case I915_PARAM_HAS_LLC:
 		value = HAS_LLC(dev_priv);

commit 993298af26b16f5cd45bd91977ee73b6cfb53292
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Mar 1 09:27:03 2019 -0800

    drm/i915: Yet another if/else sort of newer to older platforms.
    
    No functional change. Just a reorg to match the preferred
    behavior.
    
    When rebasing internal branch on top of latest sort I noticed
    few more cases that needs to get reordered.
    
    Let's do in a bundle this time and hoping there's no other
    missing places.
    
    v2: Check for HSW/BDW ULT before generic IS_HASWELL or
        IS_BROADWELL or it doesn't work as pointed by Ville.
        But also ULT came afterwards anyway.
    v3: Accepting suggestions from Lucas:
        Sort CNL/CFL, KBL/SKL, and use <= 8 removing chv and bdw.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190301172703.12139-1-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c08abdef5eb6..1b2f5a6f8c25 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -219,20 +219,20 @@ intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_GEN(dev_priv, 5))
-		id = INTEL_PCH_IBX_DEVICE_ID_TYPE;
-	else if (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))
-		id = INTEL_PCH_CPT_DEVICE_ID_TYPE;
+	if (IS_ICELAKE(dev_priv))
+		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;
+	else if (IS_CANNONLAKE(dev_priv) || IS_COFFEELAKE(dev_priv))
+		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;
+	else if (IS_KABYLAKE(dev_priv) || IS_SKYLAKE(dev_priv))
+		id = INTEL_PCH_SPT_DEVICE_ID_TYPE;
 	else if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
 		id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		id = INTEL_PCH_LPT_DEVICE_ID_TYPE;
-	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
-		id = INTEL_PCH_SPT_DEVICE_ID_TYPE;
-	else if (IS_COFFEELAKE(dev_priv) || IS_CANNONLAKE(dev_priv))
-		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;
-	else if (IS_ICELAKE(dev_priv))
-		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;
+	else if (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))
+		id = INTEL_PCH_CPT_DEVICE_ID_TYPE;
+	else if (IS_GEN(dev_priv, 5))
+		id = INTEL_PCH_IBX_DEVICE_ID_TYPE;
 
 	if (id)
 		DRM_DEBUG_KMS("Assuming PCH ID %04x\n", id);

commit e88619646971168e3baedc850c21243d303e31ca
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 1 17:09:00 2019 +0000

    drm/i915: Use HW semaphores for inter-engine synchronisation on gen8+
    
    Having introduced per-context seqno, we now have a means to identity
    progress across the system without feel of rollback as befell the
    global_seqno. That is we can program a MI_SEMAPHORE_WAIT operation in
    advance of submission safe in the knowledge that our target seqno and
    address is stable.
    
    However, since we are telling the GPU to busy-spin on the target address
    until it matches the signaling seqno, we only want to do so when we are
    sure that busy-spin will be completed quickly. To achieve this we only
    submit the request to HW once the signaler is itself executing (modulo
    preemption causing us to wait longer), and we only do so for default and
    above priority requests (so that idle priority tasks never themselves
    hog the GPU waiting for others).
    
    As might be reasonably expected, HW semaphores excel in inter-engine
    synchronisation microbenchmarks (where the 3x reduced latency / increased
    throughput more than offset the power cost of spinning on a second ring)
    and have significant improvement (can be up to ~10%, most see no change)
    for single clients that utilize multiple engines (typically media players
    and transcoders), without regressing multiple clients that can saturate
    the system or changing the power envelope dramatically.
    
    v3: Drop the older NEQ branch, now we pin the signaler's HWSP anyway.
    v4: Tell the world and include it as part of scheduler caps.
    
    Testcase: igt/gem_exec_whisper
    Testcase: igt/benchmarks/gem_wsim
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190301170901.8340-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c6354f6cdbdb..c08abdef5eb6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -351,7 +351,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = min_t(int, INTEL_PPGTT(dev_priv), I915_GEM_PPGTT_FULL);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
-		value = 0;
+		value = !!(dev_priv->caps.scheduler & I915_SCHEDULER_CAP_SEMAPHORES);
 		break;
 	case I915_PARAM_HAS_SECURE_BATCHES:
 		value = capable(CAP_SYS_ADMIN);

commit 9055aac76589c73fce8edc6abba9d214a4e983f2
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Sat Feb 16 23:06:51 2019 +0530

    drm/i915: MEI interface implementation
    
    Defining the mei-i915 interface functions and initialization of
    the interface.
    
    v2:
      Adjust to the new interface changes. [Tomas]
      Added further debug logs for the failures at MEI i/f.
      port in hdcp_port data is equipped to handle -ve values.
    v3:
      mei comp is matched for global i915 comp master. [Daniel]
      In hdcp_shim hdcp_protocol() is replaced with const variable. [Daniel]
      mei wrappers are adjusted as per the i/f change [Daniel]
    v4:
      port initialization is done only at hdcp2_init only [Danvet]
    v5:
      I915 registers a subcomponent to be matched with mei_hdcp [Daniel]
    v6:
      HDCP_disable for all connectors incase of comp_unbind.
      Tear down HDCP comp interface at i915_unload [Daniel]
    v7:
      Component init and fini are moved out of connector ops [Daniel]
      hdcp_disable is not called from unbind. [Daniel]
    v8:
      subcomponent name is dropped as it is already merged.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> [v11]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550338640-17470-5-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6630212f2faf..c6354f6cdbdb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -906,6 +906,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	mutex_init(&dev_priv->av_mutex);
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
+	mutex_init(&dev_priv->hdcp_comp_mutex);
 
 	i915_memcpy_init_early(dev_priv);
 	intel_runtime_pm_init_early(dev_priv);

commit d588100baa28dae6a5c32d02bfe744d0792ed2ad
Merge: 7bd0a3271e23 16065fcdd19d
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Mon Feb 11 10:35:35 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    We need to backmerge drm-next to fix the komeda build failure.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 5ea3998d56346975c2701df18fb5b6e3ab5c8d9e
Merge: 38f070eb125a c09d39166d8a
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 11 13:41:53 2019 +1000

    Merge tag 'drm-intel-next-2019-02-07' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    UAPI Changes:
    
    - Expose RPCS (SSEU) configuration to userspace for Ice Lake
    in order to allow userspace to reconfigure the subslice config
    per context basis. (Tvrtko, Lionel)
    
    Driver Changes:
    
    - Execbuf and preemption improvements including selftests (Chris)
    - Rename HAS_GMCH_DISPLAY/HAS_GMCH (Rodrigo)
    - Debugfs error handling fix for robustness (Greg)
    - Improve reg_rw traces (Ville)
    - Push clear_intel_crtc_state onto the heap (Chris)
    - Watermark fixes for Ice Lake (Ville)
    - Fix enable count array size and bounds checking (Tvrtko)
    - MST Fixes (Lyude)
    - Prevent race and handle error on I915_GEM_MMAP (Joonas)
    - Initial rework for an full atomic gamma mode (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190208165000.GA30314@intel.com

commit d0e93599d396db606489104a1166c425f365696c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jan 26 13:25:24 2019 +0100

    drm/i915: prepare for drmP.h removal from drm_modeset_helper.h
    
    The use of drmP.h is discouraged and removal of it from
    drm_modeset_helper.h caused i915 to fail to build.
    
    This patch introduce the necessary fixes to prepare for the
    drmP.h removal from drm_modeset_helper.h.
    
    In the files touched the lists of include files was grouped
    and sorted.
    
    Build tested on x86 and arm allmodconfig / allyesconfig.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: intel-gfx@lists.freedesktop.org
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190126122527.11647-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aba502dadd66..16fd5ae06997 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -41,8 +41,10 @@
 #include <linux/vt.h>
 #include <acpi/video.h>
 
-#include <drm/drm_probe_helper.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_irq.h>
+#include <drm/drm_probe_helper.h>
 #include <drm/i915_drm.h>
 
 #include "i915_drv.h"

commit 39806c3f11e206d03e76521c808a96aedfcc58d9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Feb 4 23:16:44 2019 +0200

    drm/i915: Include register polling in reg_rw traces
    
    We generally omit register polling from the i915_reg_rw tracepoint.
    Understandable since polling could generate a lot of noise in the
    trace. The downside is that the trace is incomplete. As a compromise
    let's trace the final register value observed while polling. That
    should be generally sufficient to observe what the code should be
    doing next.
    
    I suppose in some cases it might make sense to also trace the initial
    register value, and maybe the number of times we polled. But that
    would require a separate tracepoint so let's leave it for the future.
    
    The other users of _NOTRACE() are i915_pmu and i2c bitbanging,
    which I decided to leave alone.
    
    Next we should do something to claw back the tracepoints for
    planes and whatnot which were switched to _FW() a while back.
    I guess just new macros for raw_rw+trace. The question is
    what to call it?
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190204211644.21967-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f462a4d28af4..349ba9e23a5b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2543,6 +2543,10 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
 				  u32 mask, u32 val)
 {
+	i915_reg_t reg = VLV_GTLC_PW_STATUS;
+	u32 reg_value;
+	int ret;
+
 	/* The HW does not like us polling for PW_STATUS frequently, so
 	 * use the sleeping loop rather than risk the busy spin within
 	 * intel_wait_for_register().
@@ -2550,8 +2554,12 @@ static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
 	 * Transitioning between RC6 states should be at most 2ms (see
 	 * valleyview_enable_rps) so use a 3ms timeout.
 	 */
-	return wait_for((I915_READ_NOTRACE(VLV_GTLC_PW_STATUS) & mask) == val,
-			3);
+	ret = wait_for(((reg_value = I915_READ_NOTRACE(reg)) & mask) == val, 3);
+
+	/* just trace the final value */
+	trace_i915_reg_rw(false, reg, reg_value, sizeof(reg_value), true);
+
+	return ret;
 }
 
 int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)

commit 37fdaa3390cf3e0fde96941799543e85ea58f6ae
Merge: 74b7d6a91311 ba9877e2361c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 4 14:42:25 2019 +1000

    Merge tag 'drm-misc-next-2019-02-01' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.1:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
    Core Changes:
      - Split out some part of drm_crtc_helper.h into drm_probe_helper.h
      - DRIVER_* flags improvements
      - New tasks on the TODO-list
      - Improvements to the documentation
    
    Driver Changes:
      - Continual of drmP.h removal in multiple drivers
      - Removal of FBINFO_(FLAG_)DEFAULT in multiple drivers
      - sun4i: Addition of the A23 support, multiple fixes for the tiled
        formats
      - atmel-hlcdc: Fix of clipping and rotation properties
      - qxl: various BO-related improvements, prime and generic fbdev emulation
        support
      - dw-hdmi: Support for HDMI2.0 2160p modes and YUV420 output
      - New Sitronix ST7701 panel driver
      - New Kingdisplay KD097D04 panel driver
      - New LeMaker BL035-RGB-002 panel driver
      - New PDA 91-00156-A0 panel driver
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190201144749.t3abxvguhstu6bcl@flea

commit 1ff494813bafa127ecba1160262ba39b2fdde7ba
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jan 29 11:42:48 2019 +0100

    drm/irq: Ditch DRIVER_IRQ_SHARED
    
    This is only used by drm_irq_install(), which is an optional helper.
    For legacy pci devices this is required (due to interrupt sharing without
    msi/msi-x), and just making this the default exactly matches the behaviour
    of all existing drivers using the drm_irq_install() helpers. In case that
    ever becomes wrong drivers can roll their own irq handling, as many
    drivers already do (for other reasons like needing a threaded interrupt
    handler, or having an entire pile of different interrupt sources).
    
    v2: Rebase
    
    v3: Improve commit message (Emil)
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190129104248.26607-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b7d71083e320..aba502dadd66 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3209,7 +3209,7 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
+	    DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_SYNCOBJ,
 	.release = i915_driver_release,
 	.open = i915_driver_open,

commit 5b38e7475e3dc54c1091ee169fd050b3f10461fc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jan 29 11:42:46 2019 +0100

    drm/irq: Don't check for DRIVER_HAVE_IRQ in drm_irq_(un)install
    
    If a non-legacy driver calls these it's valid to assume there is
    interrupt support. The flag is really only needed for legacy drivers,
    which control IRQ enabling/disabling through the DRM_IOCTL_CONTROL
    legacy IOCTL.
    
    Also remove all the flag usage from non-legacy drivers.
    
    v2: Review from Emil:
    - improve commit message
    - I forgot hibmc, fix that
    
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190129104248.26607-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9883921013b1..b7d71083e320 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3209,7 +3209,7 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
+	    DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_SYNCOBJ,
 	.release = i915_driver_release,
 	.open = i915_driver_open,

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 75652dc1e24c..9883921013b1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -41,7 +41,7 @@
 #include <linux/vt.h>
 #include <acpi/video.h>
 
-#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/i915_drm.h>
 

commit 9f58892ea9962002399132fd3f40c6a273f8d9e1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jan 16 15:33:04 2019 +0000

    drm/i915: Pull all the reset functionality together into i915_reset.c
    
    Currently the code to reset the GPU and our state is spread widely
    across a few files. Pull the logic together into a common file.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190116153304.787-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dafbbfadd1ad..f462a4d28af4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -48,6 +48,7 @@
 #include "i915_drv.h"
 #include "i915_trace.h"
 #include "i915_pmu.h"
+#include "i915_reset.h"
 #include "i915_query.h"
 #include "i915_vgpu.h"
 #include "intel_drv.h"
@@ -2205,211 +2206,6 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 	return i915_drm_resume(dev);
 }
 
-/**
- * i915_reset - reset chip after a hang
- * @i915: #drm_i915_private to reset
- * @stalled_mask: mask of the stalled engines with the guilty requests
- * @reason: user error message for why we are resetting
- *
- * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
- * on failure.
- *
- * Caller must hold the struct_mutex.
- *
- * Procedure is fairly simple:
- *   - reset the chip using the reset reg
- *   - re-init context state
- *   - re-init hardware status page
- *   - re-init ring buffer
- *   - re-init interrupt state
- *   - re-init display
- */
-void i915_reset(struct drm_i915_private *i915,
-		unsigned int stalled_mask,
-		const char *reason)
-{
-	struct i915_gpu_error *error = &i915->gpu_error;
-	int ret;
-	int i;
-
-	GEM_TRACE("flags=%lx\n", error->flags);
-
-	might_sleep();
-	lockdep_assert_held(&i915->drm.struct_mutex);
-	assert_rpm_wakelock_held(i915);
-	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
-
-	if (!test_bit(I915_RESET_HANDOFF, &error->flags))
-		return;
-
-	/* Clear any previous failed attempts at recovery. Time to try again. */
-	if (!i915_gem_unset_wedged(i915))
-		goto wakeup;
-
-	if (reason)
-		dev_notice(i915->drm.dev, "Resetting chip for %s\n", reason);
-	error->reset_count++;
-
-	ret = i915_gem_reset_prepare(i915);
-	if (ret) {
-		dev_err(i915->drm.dev, "GPU recovery failed\n");
-		goto taint;
-	}
-
-	if (!intel_has_gpu_reset(i915)) {
-		if (i915_modparams.reset)
-			dev_err(i915->drm.dev, "GPU reset not supported\n");
-		else
-			DRM_DEBUG_DRIVER("GPU reset disabled\n");
-		goto error;
-	}
-
-	for (i = 0; i < 3; i++) {
-		ret = intel_gpu_reset(i915, ALL_ENGINES);
-		if (ret == 0)
-			break;
-
-		msleep(100);
-	}
-	if (ret) {
-		dev_err(i915->drm.dev, "Failed to reset chip\n");
-		goto taint;
-	}
-
-	/* Ok, now get things going again... */
-
-	/*
-	 * Everything depends on having the GTT running, so we need to start
-	 * there.
-	 */
-	ret = i915_ggtt_enable_hw(i915);
-	if (ret) {
-		DRM_ERROR("Failed to re-enable GGTT following reset (%d)\n",
-			  ret);
-		goto error;
-	}
-
-	i915_gem_reset(i915, stalled_mask);
-	intel_overlay_reset(i915);
-
-	/*
-	 * Next we need to restore the context, but we don't use those
-	 * yet either...
-	 *
-	 * Ring buffer needs to be re-initialized in the KMS case, or if X
-	 * was running at the time of the reset (i.e. we weren't VT
-	 * switched away).
-	 */
-	ret = i915_gem_init_hw(i915);
-	if (ret) {
-		DRM_ERROR("Failed to initialise HW following reset (%d)\n",
-			  ret);
-		goto error;
-	}
-
-	i915_queue_hangcheck(i915);
-
-finish:
-	i915_gem_reset_finish(i915);
-wakeup:
-	clear_bit(I915_RESET_HANDOFF, &error->flags);
-	wake_up_bit(&error->flags, I915_RESET_HANDOFF);
-	return;
-
-taint:
-	/*
-	 * History tells us that if we cannot reset the GPU now, we
-	 * never will. This then impacts everything that is run
-	 * subsequently. On failing the reset, we mark the driver
-	 * as wedged, preventing further execution on the GPU.
-	 * We also want to go one step further and add a taint to the
-	 * kernel so that any subsequent faults can be traced back to
-	 * this failure. This is important for CI, where if the
-	 * GPU/driver fails we would like to reboot and restart testing
-	 * rather than continue on into oblivion. For everyone else,
-	 * the system should still plod along, but they have been warned!
-	 */
-	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
-error:
-	i915_gem_set_wedged(i915);
-	i915_retire_requests(i915);
-	goto finish;
-}
-
-static inline int intel_gt_reset_engine(struct drm_i915_private *dev_priv,
-					struct intel_engine_cs *engine)
-{
-	return intel_gpu_reset(dev_priv, intel_engine_flag(engine));
-}
-
-/**
- * i915_reset_engine - reset GPU engine to recover from a hang
- * @engine: engine to reset
- * @msg: reason for GPU reset; or NULL for no dev_notice()
- *
- * Reset a specific GPU engine. Useful if a hang is detected.
- * Returns zero on successful reset or otherwise an error code.
- *
- * Procedure is:
- *  - identifies the request that caused the hang and it is dropped
- *  - reset engine (which will force the engine to idle)
- *  - re-init/configure engine
- */
-int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
-{
-	struct i915_gpu_error *error = &engine->i915->gpu_error;
-	struct i915_request *active_request;
-	int ret;
-
-	GEM_TRACE("%s flags=%lx\n", engine->name, error->flags);
-	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
-
-	active_request = i915_gem_reset_prepare_engine(engine);
-	if (IS_ERR_OR_NULL(active_request)) {
-		/* Either the previous reset failed, or we pardon the reset. */
-		ret = PTR_ERR(active_request);
-		goto out;
-	}
-
-	if (msg)
-		dev_notice(engine->i915->drm.dev,
-			   "Resetting %s for %s\n", engine->name, msg);
-	error->reset_engine_count[engine->id]++;
-
-	if (!engine->i915->guc.execbuf_client)
-		ret = intel_gt_reset_engine(engine->i915, engine);
-	else
-		ret = intel_guc_reset_engine(&engine->i915->guc, engine);
-	if (ret) {
-		/* If we fail here, we expect to fallback to a global reset */
-		DRM_DEBUG_DRIVER("%sFailed to reset %s, ret=%d\n",
-				 engine->i915->guc.execbuf_client ? "GuC " : "",
-				 engine->name, ret);
-		goto out;
-	}
-
-	/*
-	 * The request that caused the hang is stuck on elsp, we know the
-	 * active request and can drop it, adjust head to skip the offending
-	 * request to resume executing remaining requests in the queue.
-	 */
-	i915_gem_reset_engine(engine, active_request, true);
-
-	/*
-	 * The engine and its registers (and workarounds in case of render)
-	 * have been reset to their default values. Follow the init_ring
-	 * process to program RING_MODE, HWSP and re-enable submission.
-	 */
-	ret = engine->init_hw(engine);
-	if (ret)
-		goto out;
-
-out:
-	intel_engine_cancel_stop_cs(engine);
-	i915_gem_reset_finish_engine(engine);
-	return ret;
-}
-
 static int i915_pm_prepare(struct device *kdev)
 {
 	struct pci_dev *pdev = to_pci_dev(kdev);

commit 4a8ab5ea0cde753b03bfefe4c98a8c4c61f46550
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 14 14:21:29 2019 +0000

    drm/i915: Mark up Ironlake ips with rpm wakerefs
    
    Currently Ironlake operates under the assumption that rpm awake (and its
    error checking is disabled). As such, we have missed a few places where we
    access registers without taking the rpm wakeref and thus trigger
    warnings. intel_ips being one culprit.
    
    As this involved adding a potentially sleeping rpm_get, we have to
    rearrange the spinlocks slightly and so switch to acquiring a device-ref
    under the spinlock rather than hold the spinlock for the whole
    operation. To be consistent, we make the change in pattern common to the
    intel_ips interface even though this adds a few more atomic operations
    than necessary in a few cases.
    
    v2: Sagar noted the mb around setting mch_dev were overkill as we only
    need ordering there, and that i915_emon_status was still using
    struct_mutex for no reason, but lacked rpm.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: John Harrison <John.C.Harrison@Intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190114142129.24398-21-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5731f992cf44..dafbbfadd1ad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1780,6 +1780,9 @@ void i915_driver_unload(struct drm_device *dev)
 
 	i915_driver_unregister(dev_priv);
 
+	/* Flush any external code that still may be under the RCU lock */
+	synchronize_rcu();
+
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 

commit bd780f37a3617d3dda74b97013ae8aa9b07a1d91
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 14 14:21:09 2019 +0000

    drm/i915: Track all held rpm wakerefs
    
    Everytime we take a wakeref, record the stack trace of where it was
    taken; clearing the set if we ever drop back to no owners. For debugging
    a rpm leak, we can look at all the current wakerefs and check if they
    have a matching rpm_put.
    
    v2: Use skip=0 for unwinding the stack as it appears our noinline
    function doesn't appear on the stack (nor does save_stack_trace itself!)
    v3: Allow rpm->debug_count to disappear between inspections and so
    avoid calling krealloc(0) as that may return a ZERO_PTR not NULL! (Mika)
    v4: Show who last acquire/released the runtime pm
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Tested-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190114142129.24398-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 75652dc1e24c..5731f992cf44 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -905,6 +905,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 	mutex_init(&dev_priv->pps_mutex);
 
 	i915_memcpy_init_early(dev_priv);
+	intel_runtime_pm_init_early(dev_priv);
 
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
@@ -1807,8 +1808,7 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_driver_cleanup_mmio(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
-
-	WARN_ON(atomic_read(&dev_priv->runtime_pm.wakeref_count));
+	intel_runtime_pm_cleanup(dev_priv);
 }
 
 static void i915_driver_release(struct drm_device *dev)
@@ -2010,6 +2010,8 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 out:
 	enable_rpm_wakeref_asserts(dev_priv);
+	if (!dev_priv->uncore.user_forcewake.count)
+		intel_runtime_pm_cleanup(dev_priv);
 
 	return ret;
 }
@@ -2965,7 +2967,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	}
 
 	enable_rpm_wakeref_asserts(dev_priv);
-	WARN_ON_ONCE(atomic_read(&dev_priv->runtime_pm.wakeref_count));
+	intel_runtime_pm_cleanup(dev_priv);
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(dev_priv))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");

commit 2f80d7bd8d93cac9d80fee7339ef673609fa8164
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jan 8 10:27:09 2019 +0200

    drm/i915: drop all drmP.h includes
    
    Needs just a few additional includes here and there.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108082709.3748-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 17fca3ba343e..75652dc1e24c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -41,7 +41,6 @@
 #include <linux/vt.h>
 #include <acpi/video.h>
 
-#include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/i915_drm.h>

commit 55277e1f3107c0b7f18aaa1572ab97081ccde57a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 3 11:21:04 2019 +0000

    drm/i915: Always try to reset the GPU on takeover
    
    When we first introduced the reset to sanitize the GPU on taking over
    from the BIOS and before returning control to third parties (the BIOS!),
    we restricted it to only systems utilizing HW contexts as we were
    uncertain of how stable our reset mechanism truly was. We now have
    reasonable coverage across all machines that expose a GPU reset method,
    and so we should be safe to sanitize the GPU state everywhere.
    
    v2: We _have_ to skip the reset if it would clobber the display.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190103112104.19561-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fe01d090f9bb..17fca3ba343e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2180,7 +2180,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_power_domains_resume(dev_priv);
 
-	intel_engines_sanitize(dev_priv);
+	intel_engines_sanitize(dev_priv, true);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 

commit 1787a98439ccf0a38493a58e914f497a60dbc7c2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Dec 31 16:56:45 2018 +0200

    drm/i915: drop intel_device_info_dump()
    
    The debugfs, error state and regular dmesg logging dump needs seem to be
    different. Remove the generic dump function only used for the welcome
    message. This may be added back later when better abstractions are
    identified, but at the moment this seems to be the simplest considering
    the device info rework in progress. No longer rely on device info being
    a substruct of dev_priv.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/70ff0c7c0ec3ef8747af3c78e272b5a82be3d55b.1546267488.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8d7a3a852c10..fe01d090f9bb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1636,7 +1636,13 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 	if (drm_debug & DRM_UT_DRIVER) {
 		struct drm_printer p = drm_debug_printer("i915 device info:");
 
-		intel_device_info_dump(INTEL_INFO(dev_priv), &p);
+		drm_printf(&p, "pciid=0x%04x rev=0x%02x platform=%s gen=%i\n",
+			   INTEL_DEVID(dev_priv),
+			   INTEL_REVID(dev_priv),
+			   intel_platform_name(INTEL_INFO(dev_priv)->platform),
+			   INTEL_GEN(dev_priv));
+
+		intel_device_info_dump_flags(INTEL_INFO(dev_priv), &p);
 		intel_device_info_dump_runtime(RUNTIME_INFO(dev_priv), &p);
 	}
 

commit a0f04cc27c50a896a1369e809306be33fe0a3abf
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Dec 31 16:56:44 2018 +0200

    drm/i915: always use INTEL_INFO() to access device info
    
    Hide the way device info is stored, in preparation of making device info
    a pointer to the const rodata in i915_pci.c. No functional changes.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/3cd626f248c0d6638f1288938bbb577a12286050.1546267488.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 261932ee6837..8d7a3a852c10 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1636,7 +1636,7 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 	if (drm_debug & DRM_UT_DRIVER) {
 		struct drm_printer p = drm_debug_printer("i915 device info:");
 
-		intel_device_info_dump(&dev_priv->info, &p);
+		intel_device_info_dump(INTEL_INFO(dev_priv), &p);
 		intel_device_info_dump_runtime(RUNTIME_INFO(dev_priv), &p);
 	}
 

commit 1400cc7e0dcdf13454e64a402c097e3c8f5d5d29
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Dec 31 16:56:43 2018 +0200

    drm/i915: pass dev_priv to intel_device_info_runtime_init()
    
    With the static/runtime device info split, this makes more sense.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ad5b448e4e318df0d292d73e6c3378f3e6b9bae5.1546267488.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f884b9a138cd..261932ee6837 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1374,7 +1374,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	intel_device_info_runtime_init(mkwrite_device_info(dev_priv));
+	intel_device_info_runtime_init(dev_priv);
 
 	if (HAS_PPGTT(dev_priv)) {
 		if (intel_vgpu_active(dev_priv) &&

commit 0258404f9d3859b89f7b816f0549dd7d4357de01
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Dec 31 16:56:41 2018 +0200

    drm/i915: start moving runtime device info to a separate struct
    
    First move the low hanging fruit, the fields that are only initialized
    runtime. Use RUNTIME_INFO() exclusively to access the fields.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/c24fe7a4b0492a888690c46814c0ff21ce2f12b1.1546267488.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dcb935338c63..f884b9a138cd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -358,12 +358,12 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = sseu_subslice_total(&INTEL_INFO(dev_priv)->sseu);
+		value = sseu_subslice_total(&RUNTIME_INFO(dev_priv)->sseu);
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_EU_TOTAL:
-		value = INTEL_INFO(dev_priv)->sseu.eu_total;
+		value = RUNTIME_INFO(dev_priv)->sseu.eu_total;
 		if (!value)
 			return -ENODEV;
 		break;
@@ -380,7 +380,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = HAS_POOLED_EU(dev_priv);
 		break;
 	case I915_PARAM_MIN_EU_IN_POOL:
-		value = INTEL_INFO(dev_priv)->sseu.min_eu_in_pool;
+		value = RUNTIME_INFO(dev_priv)->sseu.min_eu_in_pool;
 		break;
 	case I915_PARAM_HUC_STATUS:
 		value = intel_huc_check_status(&dev_priv->huc);
@@ -430,17 +430,17 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = intel_engines_has_context_isolation(dev_priv);
 		break;
 	case I915_PARAM_SLICE_MASK:
-		value = INTEL_INFO(dev_priv)->sseu.slice_mask;
+		value = RUNTIME_INFO(dev_priv)->sseu.slice_mask;
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_SUBSLICE_MASK:
-		value = INTEL_INFO(dev_priv)->sseu.subslice_mask[0];
+		value = RUNTIME_INFO(dev_priv)->sseu.subslice_mask[0];
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_CS_TIMESTAMP_FREQUENCY:
-		value = 1000 * INTEL_INFO(dev_priv)->cs_timestamp_frequency_khz;
+		value = 1000 * RUNTIME_INFO(dev_priv)->cs_timestamp_frequency_khz;
 		break;
 	case I915_PARAM_MMAP_GTT_COHERENT:
 		value = INTEL_INFO(dev_priv)->has_coherent_ggtt;
@@ -1637,7 +1637,7 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 		struct drm_printer p = drm_debug_printer("i915 device info:");
 
 		intel_device_info_dump(&dev_priv->info, &p);
-		intel_device_info_dump_runtime(&dev_priv->info, &p);
+		intel_device_info_dump_runtime(RUNTIME_INFO(dev_priv), &p);
 	}
 
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
@@ -1674,7 +1674,7 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* Setup the write-once "constant" device info */
 	device_info = mkwrite_device_info(i915);
 	memcpy(device_info, match_info, sizeof(*device_info));
-	device_info->device_id = pdev->device;
+	RUNTIME_INFO(i915)->device_id = pdev->device;
 
 	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
 		     BITS_PER_TYPE(device_info->platform_mask));

commit 6faf5916e6beb0dedb0fcbbafbaa152adeaea758
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Dec 28 14:07:35 2018 +0000

    drm/i915: Remove HW semaphores for gen7 inter-engine synchronisation
    
    The writing is on the wall for the existence of a single execution queue
    along each engine, and as a consequence we will not be able to track
    dependencies along the HW queue itself, i.e. we will not be able to use
    HW semaphores on gen7 as they use a global set of registers (and unlike
    gen8+ we can not effectively target memory to keep per-context seqno and
    dependencies).
    
    On the positive side, when we implement request reordering for gen7 we
    also can not presume a simple execution queue and would also require
    removing the current semaphore generation code. So this bring us another
    step closer to request reordering for ringbuffer submission!
    
    The negative side is that using interrupts to drive inter-engine
    synchronisation is much slower (4us -> 15us to do a nop on each of the 3
    engines on ivb). This is much better than it was at the time of introducing
    the HW semaphores and equally important userspace weaned itself off
    intermixing dependent BLT/RENDER operations (the prime culprit was glyph
    rendering in UXA). So while we regress the microbenchmarks, it should not
    impact the user.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=108888
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181228140736.32606-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index caa055ac9472..dcb935338c63 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -349,7 +349,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = min_t(int, INTEL_PPGTT(dev_priv), I915_GEM_PPGTT_FULL);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
-		value = HAS_LEGACY_SEMAPHORES(dev_priv);
+		value = 0;
 		break;
 	case I915_PARAM_HAS_SECURE_BATCHES:
 		value = capable(CAP_SYS_ADMIN);

commit 5edd56d394dc30438cb627586eb471f5f339a603
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Dec 13 09:15:19 2018 +0000

    drm/i915/selftests: Check we can recover a wedged device
    
    After declaring a terminally wedged device, we allow ourselves to
    recover on the next GPU reset (manually triggered), or resume. Check
    that resetting a wedged device does work.
    
    v2: Add rpm (taken explicitly in the subtest in case we remove the outer
    wakeref) and early warning to i915_reset() for missed wakerefs
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181213091522.2926-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77c0f97fe77c..caa055ac9472 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2226,6 +2226,7 @@ void i915_reset(struct drm_i915_private *i915,
 
 	might_sleep();
 	lockdep_assert_held(&i915->drm.struct_mutex);
+	assert_rpm_wakelock_held(i915);
 	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
 
 	if (!test_bit(I915_RESET_HANDOFF, &error->flags))

commit cf819eff907ab49205ece97c96baeb909fd36f4d
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Wed Dec 12 10:10:43 2018 -0800

    drm/i915: replace IS_GEN<N> with IS_GEN(..., N)
    
    Define IS_GEN() similarly to our IS_GEN_RANGE(). but use gen instead of
    gen_mask to do the comparison. Now callers can pass then gen as a parameter,
    so we don't require one macro for each gen.
    
    The following spatch was used to convert the users of these macros:
    
    @@
    expression e;
    @@
    (
    - IS_GEN2(e)
    + IS_GEN(e, 2)
    |
    - IS_GEN3(e)
    + IS_GEN(e, 3)
    |
    - IS_GEN4(e)
    + IS_GEN(e, 4)
    |
    - IS_GEN5(e)
    + IS_GEN(e, 5)
    |
    - IS_GEN6(e)
    + IS_GEN(e, 6)
    |
    - IS_GEN7(e)
    + IS_GEN(e, 7)
    |
    - IS_GEN8(e)
    + IS_GEN(e, 8)
    |
    - IS_GEN9(e)
    + IS_GEN(e, 9)
    |
    - IS_GEN10(e)
    + IS_GEN(e, 10)
    |
    - IS_GEN11(e)
    + IS_GEN(e, 11)
    )
    
    v2: use IS_GEN rather than GT_GEN and compare to info.gen rather than
        using the bitmask
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181212181044.15886-2-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b310a897a4ad..77c0f97fe77c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -132,15 +132,15 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 	switch (id) {
 	case INTEL_PCH_IBX_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-		WARN_ON(!IS_GEN5(dev_priv));
+		WARN_ON(!IS_GEN(dev_priv, 5));
 		return PCH_IBX;
 	case INTEL_PCH_CPT_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-		WARN_ON(!IS_GEN6(dev_priv) && !IS_IVYBRIDGE(dev_priv));
+		WARN_ON(!IS_GEN(dev_priv, 6) && !IS_IVYBRIDGE(dev_priv));
 		return PCH_CPT;
 	case INTEL_PCH_PPT_DEVICE_ID_TYPE:
 		DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-		WARN_ON(!IS_GEN6(dev_priv) && !IS_IVYBRIDGE(dev_priv));
+		WARN_ON(!IS_GEN(dev_priv, 6) && !IS_IVYBRIDGE(dev_priv));
 		/* PantherPoint is CPT compatible */
 		return PCH_CPT;
 	case INTEL_PCH_LPT_DEVICE_ID_TYPE:
@@ -217,9 +217,9 @@ intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_GEN5(dev_priv))
+	if (IS_GEN(dev_priv, 5))
 		id = INTEL_PCH_IBX_DEVICE_ID_TYPE;
-	else if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv))
+	else if (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))
 		id = INTEL_PCH_CPT_DEVICE_ID_TYPE;
 	else if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
 		id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
@@ -966,7 +966,7 @@ static int i915_mmio_setup(struct drm_i915_private *dev_priv)
 	int mmio_bar;
 	int mmio_size;
 
-	mmio_bar = IS_GEN2(dev_priv) ? 1 : 0;
+	mmio_bar = IS_GEN(dev_priv, 2) ? 1 : 0;
 	/*
 	 * Before gen4, the registers and the GTT are behind different BARs.
 	 * However, from gen4 onwards, the registers and the GTT are shared
@@ -1341,7 +1341,7 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	/* Need to calculate bandwidth only for Gen9 */
 	if (IS_BROXTON(dev_priv))
 		ret = bxt_get_dram_info(dev_priv);
-	else if (IS_GEN9(dev_priv))
+	else if (IS_GEN(dev_priv, 9))
 		ret = skl_get_dram_info(dev_priv);
 	else
 		ret = skl_dram_get_channels_info(dev_priv);
@@ -1436,7 +1436,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	pci_set_master(pdev);
 
 	/* overlay on gen2 is broken and can't address above 1G */
-	if (IS_GEN2(dev_priv)) {
+	if (IS_GEN(dev_priv, 2)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
@@ -1574,7 +1574,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		acpi_video_register();
 	}
 
-	if (IS_GEN5(dev_priv))
+	if (IS_GEN(dev_priv, 5))
 		intel_gpu_ips_init(dev_priv);
 
 	intel_audio_init(dev_priv);

commit 094304beb4e1f4bfb2b59385a12d7074f4485e98
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Mon Dec 3 12:50:10 2018 +0000

    drm/i915: Verify GT workaround state after GPU init
    
    Since we now have all the GT workarounds in a table, by adding a simple
    shared helper function we can now verify that their values are still
    applied after some interesting events in the lifetime of the driver.
    
    Initially we only do this after GPU initialization.
    
    v2:
     Chris Wilson:
     * Simplify verification by realizing it's a simple xor and and.
     * Remove verification from engine reset path.
     * Return bool straight away from the verify API.
    
    v3:
     * API rename. (Chris Wilson)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181203125014.3219-4-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6f497cf31ffc..b310a897a4ad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -53,6 +53,7 @@
 #include "i915_vgpu.h"
 #include "intel_drv.h"
 #include "intel_uc.h"
+#include "intel_workarounds.h"
 
 static struct drm_driver driver;
 

commit 25d140faaa25f728159eb8c304eae53d88a7f14e
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Mon Dec 3 13:33:19 2018 +0000

    drm/i915: Record GT workarounds in a list
    
    To enable later verification of GT workaround state at various stages of
    driver lifetime, we record the list of applicable ones per platforms to a
    list, from which they are also applied.
    
    The added data structure is a simple array of register, mask and value
    items, which is allocated on demand as workarounds are added to the list.
    
    This is a temporary implementation which later in the series gets fused
    with the existing per context workaround list handling. It is separated at
    this stage since the following patch fixes a bug which needs to be as easy
    to backport as possible.
    
    Also, since in the following patch we will be adding a new class of
    workarounds (per engine) which can be applied from interrupt context, we
    straight away make the provision for safe read-modify-write cycle.
    
    v2:
     * Change dev_priv to i915 along the init path. (Chris Wilson)
     * API rename. (Chris Wilson)
    
    v3:
     * Remove explicit list size tracking in favour of growing the allocation
       in power of two chunks. (Chris Wilson)
    
    v4:
     Chris Wilson:
     * Change wa_list_finish to early return.
     * Copy workarounds using the compiler for static checking.
     * Do not bother zeroing unused entries.
     * Re-order struct i915_wa_list.
    
    v5:
     * kmalloc_array.
     * Whitespace cleanup.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181203133319.10174-1-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c2a3ba7e09e0..6f497cf31ffc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1467,6 +1467,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_uncore_sanitize(dev_priv);
 
+	intel_gt_init_workarounds(dev_priv);
 	i915_gem_load_init_fences(dev_priv);
 
 	/* On the 945G/GM, the chipset reports the MSI capability on the

commit e1bf094b3c7514934168dcb69f18b65aacb5a953
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Fri Nov 30 15:20:47 2018 -0800

    drm/i915: Add HAS_DISPLAY() and use it
    
    Right now it is decided if GEN has display by checking the num_pipes,
    so lets make it explicit and use a macro.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181130232048.14216-1-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3e5e2efce670..c2a3ba7e09e0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -287,7 +287,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	 * Use PCH_NOP (PCH but no South Display) for PCH platforms without
 	 * display.
 	 */
-	if (pch && INTEL_INFO(dev_priv)->num_pipes == 0) {
+	if (pch && !HAS_DISPLAY(dev_priv)) {
 		DRM_DEBUG_KMS("Display disabled, reverting to NOP PCH\n");
 		dev_priv->pch_type = PCH_NOP;
 		dev_priv->pch_id = 0;
@@ -645,7 +645,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	if (INTEL_INFO(dev_priv)->num_pipes) {
+	if (HAS_DISPLAY(dev_priv)) {
 		ret = drm_vblank_init(&dev_priv->drm,
 				      INTEL_INFO(dev_priv)->num_pipes);
 		if (ret)
@@ -696,7 +696,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	intel_overlay_setup(dev_priv);
 
-	if (INTEL_INFO(dev_priv)->num_pipes == 0)
+	if (!HAS_DISPLAY(dev_priv))
 		return 0;
 
 	ret = intel_fbdev_init(dev);
@@ -1566,7 +1566,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	} else
 		DRM_ERROR("Failed to register driver for userspace access!\n");
 
-	if (INTEL_INFO(dev_priv)->num_pipes) {
+	if (HAS_DISPLAY(dev_priv)) {
 		/* Must be done after probing outputs */
 		intel_opregion_register(dev_priv);
 		acpi_video_register();
@@ -1590,7 +1590,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 * We need to coordinate the hotplugs with the asynchronous fbdev
 	 * configuration, for which we use the fbdev->async_cookie.
 	 */
-	if (INTEL_INFO(dev_priv)->num_pipes)
+	if (HAS_DISPLAY(dev_priv))
 		drm_kms_helper_poll_init(dev);
 
 	intel_power_domains_enable(dev_priv);

commit 46592892e1a60f9e9de3287719143a148fce93cf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 30 12:59:54 2018 +0000

    drm/i915/vgpu: Disallow loading on old vGPU hosts
    
    Since commit fd8526e50902 ("drm/i915/execlists: Trust the CSB") we
    actually broke the force-mmio mode for our execlists implementation. No
    one noticed, so ergo no one is actually using an old vGPU host (where we
    required the older method) and so can simply remove the broken support.
    
    v2: csb_read can go as well (Mika)
    
    Reported-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Fixes: fd8526e50902 ("drm/i915/execlists: Trust the CSB")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181130125954.11924-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e39016713464..3e5e2efce670 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1384,6 +1384,20 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		}
 	}
 
+	if (HAS_EXECLISTS(dev_priv)) {
+		/*
+		 * Older GVT emulation depends upon intercepting CSB mmio,
+		 * which we no longer use, preferring to use the HWSP cache
+		 * instead.
+		 */
+		if (intel_vgpu_active(dev_priv) &&
+		    !intel_vgpu_has_hwsp_emulation(dev_priv)) {
+			i915_report_error(dev_priv,
+					  "old vGPU host found, support for HWSP emulation required\n");
+			return -ENXIO;
+		}
+	}
+
 	intel_sanitize_options(dev_priv);
 
 	i915_perf_init(dev_priv);

commit 1aca96cc545536fc00b533764135ced79a9a65ba
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Nov 28 13:53:25 2018 +0000

    drm/i915: Mark up early pre-production Kabylakes
    
    Mark A0 as the one and only pre-production variant of Kabylake and
    remove its couple of workarounds, consigning them to the annals of
    history.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181128135325.10641-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b1d23c73c147..e39016713464 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -868,6 +868,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	pre |= IS_HSW_EARLY_SDV(dev_priv);
 	pre |= IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0);
 	pre |= IS_BXT_REVID(dev_priv, 0, BXT_REVID_B_LAST);
+	pre |= IS_KBL_REVID(dev_priv, 0, KBL_REVID_A0);
 
 	if (pre) {
 		DRM_ERROR("This is a pre-production stepping. "

commit 58db08a73b75bfe0f718107bb4f09c57cd725c48
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Wed Nov 7 16:16:47 2018 -0800

    drm/i915: Keep overlay functions naming consistent
    
    All other overlay functions(almost all other functions in i915)
    follow intel_overlay_verb, so renaming overlay ones that do not match
    that.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181108001647.11276-4-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44903ce1b82d..b1d23c73c147 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -694,7 +694,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_modeset;
 
-	intel_setup_overlay(dev_priv);
+	intel_overlay_setup(dev_priv);
 
 	if (INTEL_INFO(dev_priv)->num_pipes == 0)
 		return 0;

commit a8147d0cd49f959faf2dd01b8cc52f93ef0e71ce
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Wed Nov 7 16:16:46 2018 -0800

    drm/i915: Move intel_init_ipc() call to i915_load_modeset_init()
    
    IPC is a display feature, so i915_load_modeset_init() is the right
    place to initialize it.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181108001647.11276-3-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 09208c73ca04..44903ce1b82d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -706,6 +706,8 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	/* Only enable hotplug handling once the fbdev is fully set up. */
 	intel_hpd_init(dev_priv);
 
+	intel_init_ipc(dev_priv);
+
 	return 0;
 
 cleanup_gem:
@@ -1725,8 +1727,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	i915_driver_register(dev_priv);
 
-	intel_init_ipc(dev_priv);
-
 	enable_rpm_wakeref_asserts(dev_priv);
 
 	i915_welcome_messages(dev_priv);

commit acde44b5008671b06a8a1c7c6443b9f54ef4be03
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Wed Nov 7 16:16:45 2018 -0800

    drm/i915: Move FBC init and cleanup calls to modeset functions
    
    Although FBC helps save power it do not belongs to power management
    also the cleanup was placed in i915_driver_unload() also not a good
    place. intel_modeset_init()/intel_modeset_cleanup() are better places
    also this will help make easy disable features that depends in
    display being enabled in driver.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181108001647.11276-2-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b9108a5821a5..09208c73ca04 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1778,7 +1778,6 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_reset_error_state(dev_priv);
 
 	i915_gem_fini(dev_priv);
-	intel_fbc_cleanup_cfb(dev_priv);
 
 	intel_power_domains_fini_hw(dev_priv);
 

commit 8d3bf1a3959f456d12f9b78dd8a666afd1057b58
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Wed Nov 7 16:16:44 2018 -0800

    drm/i915: Move drm_vblank_init() to i915_load_modeset_init()
    
    i915_load_modeset_init() is a more suitable place than
    i915_driver_load() as vblank is part of modeset.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181108001647.11276-1-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index acb516308262..b9108a5821a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -645,6 +645,13 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
+	if (INTEL_INFO(dev_priv)->num_pipes) {
+		ret = drm_vblank_init(&dev_priv->drm,
+				      INTEL_INFO(dev_priv)->num_pipes);
+		if (ret)
+			goto out;
+	}
+
 	intel_bios_init(dev_priv);
 
 	/* If we have > 1 VGA cards, then we need to arbitrate access
@@ -1712,18 +1719,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret < 0)
 		goto out_cleanup_mmio;
 
-	/*
-	 * TODO: move the vblank init and parts of modeset init steps into one
-	 * of the i915_driver_init_/i915_driver_register functions according
-	 * to the role/effect of the given init step.
-	 */
-	if (INTEL_INFO(dev_priv)->num_pipes) {
-		ret = drm_vblank_init(&dev_priv->drm,
-				      INTEL_INFO(dev_priv)->num_pipes);
-		if (ret)
-			goto out_cleanup_hw;
-	}
-
 	ret = i915_load_modeset_init(&dev_priv->drm);
 	if (ret < 0)
 		goto out_cleanup_hw;

commit 3b6ac43b48576d7b38539c31b4e370b2e942c3aa
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Wed Oct 31 13:27:26 2018 -0700

    drm/i915/icl: Fix DC9 Suspend for ICL.
    
    Add missing block that takes care of inline intel_suspend_complete
    for DC9 on ICL.
    
    Daniele noticed this was part of original patch but missed on
    on merged commit ("drm/i915/icl: Enable DC9 as lowest possible
     state during screen-off").
    
    Fixes: 3e68928b7d4c ("drm/i915/icl: Enable DC9 as lowest possible state during screen-off")
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Animesh Manna <animesh.manna@intel.com>
    Cc: James Ausmus <james.ausmus@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    [Rodrigo added a commit message while merging]
    Link: https://patchwork.freedesktop.org/patch/msgid/20181031202726.4021-1-anusha.srivatsa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 198d625f2871..acb516308262 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1962,7 +1962,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 				    get_suspend_mode(dev_priv, hibernation));
 
 	ret = 0;
-	if (IS_GEN9_LP(dev_priv))
+	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv))
 		bxt_enable_dc9(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_enable_pc8(dev_priv);

commit 3e68928b7d4c833726717ced2261f77479d98a47
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Mon Oct 29 15:14:10 2018 -0700

    drm/i915/icl: Enable DC9 as lowest possible state during screen-off
    
    ICL supports DC5, DC6, and DC9. Enable DC9 during screen-off, and enable
    DC5/6 when appropriate.
    
    v2: (James Ausmus)
     - Also handle ICL as GEN9_LP in i915_drm_suspend_late and
       i915_drm_suspend_early
     - Add DC9 to gen9_dc_mask for ICL
     - Re-order GEN checks for newest platform first
     - Use INTEL_GEN instead of INTEL_INFO->gen
     - Use INTEL_GEN >= 11 instead of IS_ICELAKE
     - Consolidate GEN checks
    
    v3: (James Ausmus)
     - Also allow DC6 for ICL (Imre, Art)
     - Simplify !(GEN >= 11) to GEN < 11 (Imre)
    
    v4: (James Ausmus)
     - Don't call intel_power_sequencer_reset after DC9 for Gen11+, as the
       PPS regs are Always On
     - Rebase against upstream changes
    
    v5: (Anusha Srivatsa)
    - rebased against the latest upstream changes.
    
    v6: (Anusha Srivatsa)
    - rebased.Use INTEL_GEN consistently.
    - Simplify the code (Rodrigo)
    
    v7: rebased. Change order according to platforms(Jyoti)
    
    v8: rebased. Change the check from platform specific to
    HAS_PCH_SPLIT(). Add comment in code to be more clear.(Rodrigo)
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: James Ausmus <james.ausmus@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Tested-by: Jyoti Yadav <jyoti.r.yadav@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181029221410.4423-1-anusha.srivatsa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f6416b1d3452..198d625f2871 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2152,7 +2152,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_resume_early(dev_priv);
 
-	if (IS_GEN9_LP(dev_priv)) {
+	if (INTEL_GEN(dev_priv) >= 11 || IS_GEN9_LP(dev_priv)) {
 		gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
@@ -2919,7 +2919,10 @@ static int intel_runtime_suspend(struct device *kdev)
 	intel_uncore_suspend(dev_priv);
 
 	ret = 0;
-	if (IS_GEN9_LP(dev_priv)) {
+	if (INTEL_GEN(dev_priv) >= 11) {
+		icl_display_core_uninit(dev_priv);
+		bxt_enable_dc9(dev_priv);
+	} else if (IS_GEN9_LP(dev_priv)) {
 		bxt_display_core_uninit(dev_priv);
 		bxt_enable_dc9(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
@@ -3004,7 +3007,18 @@ static int intel_runtime_resume(struct device *kdev)
 	if (intel_uncore_unclaimed_mmio(dev_priv))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
-	if (IS_GEN9_LP(dev_priv)) {
+	if (INTEL_GEN(dev_priv) >= 11) {
+		bxt_disable_dc9(dev_priv);
+		icl_display_core_init(dev_priv, true);
+		if (dev_priv->csr.dmc_payload) {
+			if (dev_priv->csr.allowed_dc_mask &
+			    DC_STATE_EN_UPTO_DC6)
+				skl_enable_dc6(dev_priv);
+			else if (dev_priv->csr.allowed_dc_mask &
+				 DC_STATE_EN_UPTO_DC5)
+				gen9_enable_dc5(dev_priv);
+		}
+	} else if (IS_GEN9_LP(dev_priv)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);
 		if (dev_priv->csr.dmc_payload &&

commit a950adc6c343c918e4728648f7a59ba42d79c1ce
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 30 11:05:54 2018 +0000

    drm/i915: Stop calling intel_opregion unregister/register in suspend/resume
    
    If we reduce the suspend function for intel_opregion to do the minimum
    required, the resume function can also do the simple task of notifier
    the ACPI bios that we are back. This avoid some nasty restrictions on
    the likes of register_acpi_notifier() that are not allowed during the
    early phase of resume.
    
    v2: Keep the order of acpi notify vs turning off ardy/drdy the same.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181030110554.4111-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1ad13da61d7a..f6416b1d3452 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1921,9 +1921,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	i915_save_state(dev_priv);
 
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
-	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
-
-	intel_opregion_unregister(dev_priv);
+	intel_opregion_suspend(dev_priv, opregion_target_state);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
 
@@ -2042,7 +2040,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	i915_restore_state(dev_priv);
 	intel_pps_unlock_regs_wa(dev_priv);
-	intel_opregion_setup(dev_priv);
 
 	intel_init_pch_refclk(dev_priv);
 
@@ -2084,12 +2081,10 @@ static int i915_drm_resume(struct drm_device *dev)
 	 * */
 	intel_hpd_init(dev_priv);
 
-	intel_opregion_register(dev_priv);
+	intel_opregion_resume(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);
 
-	intel_opregion_notify_adapter(dev_priv, PCI_D0);
-
 	intel_power_domains_enable(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);

commit 9e7833758b9feebc37b9988d13b017534c90a4a2
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Oct 26 12:51:42 2018 -0700

    drm/i915: Prefer IS_GEN<n> check with bitmask.
    
    Whenever possible we should stick with IS_GEN<n> checks.
    
    Bitmaks has been introduced on commit ae7617f0ef18 ("drm/i915:
    Allow optimized platform checks") for efficiency.
    
    Let's stick with it whenever possible.
    
    This patch was generated with coccinelle:
    
    spatch -sp_file is_gen.cocci *{c,h} --in-place
    
    is_gen.cocci:
    @gen2@ expression e; @@
    -INTEL_GEN(e) == 2
    +IS_GEN2(e)
    @gen3@ expression e; @@
    -INTEL_GEN(e) == 3
    +IS_GEN3(e)
    @gen4@ expression e; @@
    -INTEL_GEN(e) == 4
    +IS_GEN4(e)
    @gen5@ expression e; @@
    -INTEL_GEN(e) == 5
    +IS_GEN5(e)
    @gen6@ expression e; @@
    -INTEL_GEN(e) == 6
    +IS_GEN6(e)
    @gen7@ expression e; @@
    -INTEL_GEN(e) == 7
    +IS_GEN7(e)
    @gen8@ expression e; @@
    -INTEL_GEN(e) == 8
    +IS_GEN8(e)
    @gen9@ expression e; @@
    -INTEL_GEN(e) == 9
    +IS_GEN9(e)
    @gen10@ expression e; @@
    -INTEL_GEN(e) == 10
    +IS_GEN10(e)
    @gen11@ expression e; @@
    -INTEL_GEN(e) == 11
    +IS_GEN11(e)
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181026195143.20353-1-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6571044c9286..1ad13da61d7a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1330,7 +1330,7 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	/* Need to calculate bandwidth only for Gen9 */
 	if (IS_BROXTON(dev_priv))
 		ret = bxt_get_dram_info(dev_priv);
-	else if (INTEL_GEN(dev_priv) == 9)
+	else if (IS_GEN9(dev_priv))
 		ret = skl_get_dram_info(dev_priv);
 	else
 		ret = skl_dram_get_channels_info(dev_priv);

commit 5d6f36b27d2764f3dc940606ee6b7ec5c669af3e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Oct 23 21:21:02 2018 +0300

    drm/i915: Don't apply the 16Gb DIMM wm latency w/a to BXT/GLK
    
    The 16Gb DIMM w/a is not applicable to BXT or GLK. Limit it to
    the appropriate platforms.
    
    This was especially harsh on GLK since we don't even try to read
    the DIMM information on that platforms, hence valid_dimm was
    always false and thus we always tried to apply the w/a.
    Furthermore the w/a pushed the level 0 latency above the
    level 1 latency, which doesn't really make sense.
    
    v2: Do the check when populating is_16gb_dimm (Mahesh)
    
    Cc: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Fixes: 86b592876cb6 ("drm/i915: Implement 16GB dimm wa for latency level-0")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181023182102.31549-1-ville.syrjala@linux.intel.com
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Mahesh Kumar <mahesh1.sh.kumar@gmail.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index baac35f698f9..6571044c9286 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1165,8 +1165,6 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		return -EINVAL;
 	}
 
-	dram_info->valid_dimm = true;
-
 	/*
 	 * If any of the channel is single rank channel, worst case output
 	 * will be same as if single rank memory, so consider single rank
@@ -1183,8 +1181,7 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		return -EINVAL;
 	}
 
-	if (ch0.is_16gb_dimm || ch1.is_16gb_dimm)
-		dram_info->is_16gb_dimm = true;
+	dram_info->is_16gb_dimm = ch0.is_16gb_dimm || ch1.is_16gb_dimm;
 
 	dev_priv->dram_info.symmetric_memory = intel_is_dram_symmetric(val_ch0,
 								       val_ch1,
@@ -1304,7 +1301,6 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		return -EINVAL;
 	}
 
-	dram_info->valid_dimm = true;
 	dram_info->valid = true;
 	return 0;
 }
@@ -1317,12 +1313,17 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	int ret;
 
 	dram_info->valid = false;
-	dram_info->valid_dimm = false;
-	dram_info->is_16gb_dimm = false;
 	dram_info->rank = I915_DRAM_RANK_INVALID;
 	dram_info->bandwidth_kbps = 0;
 	dram_info->num_channels = 0;
 
+	/*
+	 * Assume 16Gb DIMMs are present until proven otherwise.
+	 * This is only used for the level 0 watermark latency
+	 * w/a which does not apply to bxt/glk.
+	 */
+	dram_info->is_16gb_dimm = !IS_GEN9_LP(dev_priv);
+
 	if (INTEL_GEN(dev_priv) < 9 || IS_GEMINILAKE(dev_priv))
 		return;
 

commit c5b083a1a174823e6c1fea727ef729415e03b34d
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Oct 11 13:00:07 2018 +0000

    drm/i915: Fix i915_driver_init_mmio error path
    
    In case of the error we missed to call i915_mmio_cleanup
    that matches earlier call to i915_mmio_setup.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181011130008.24640-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 193023427b40..baac35f698f9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1030,6 +1030,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 err_uncore:
 	intel_uncore_fini(dev_priv);
+	i915_mmio_cleanup(dev_priv);
 err_bridge:
 	pci_dev_put(dev_priv->bridge_dev);
 

commit 2ddcc982bdc51ad31bf5aa86ea02b3166cadd32e
Author: Andi Shyti <andi.shyti@intel.com>
Date:   Tue Oct 2 12:20:47 2018 +0300

    drm/i915: fix wrong error number report
    
    During driver load it's considered that the i915_driver_create()
    function fails only in case of insufficient memory. Indeed, in
    case of failure of i915_driver_create(), the load function
    returns indiscriminately -ENOMEM ignoring the real cause of
    failure.
    
    In i915_driver_create() get the consistent error value from
    drm_dev_init() and embed it in the pointer return value.
    
    Signed-off-by: Andi Shyti <andi.shyti@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181002092047.14705-1-andi.shyti@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b028f429e92..193023427b40 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1627,14 +1627,16 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 		(struct intel_device_info *)ent->driver_data;
 	struct intel_device_info *device_info;
 	struct drm_i915_private *i915;
+	int err;
 
 	i915 = kzalloc(sizeof(*i915), GFP_KERNEL);
 	if (!i915)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
-	if (drm_dev_init(&i915->drm, &driver, &pdev->dev)) {
+	err = drm_dev_init(&i915->drm, &driver, &pdev->dev);
+	if (err) {
 		kfree(i915);
-		return NULL;
+		return ERR_PTR(err);
 	}
 
 	i915->drm.pdev = pdev;
@@ -1683,8 +1685,8 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int ret;
 
 	dev_priv = i915_driver_create(pdev, ent);
-	if (!dev_priv)
-		return -ENOMEM;
+	if (IS_ERR(dev_priv))
+		return PTR_ERR(dev_priv);
 
 	/* Disable nuclear pageflip by default on pre-ILK */
 	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)

commit 4bdafb9ddfa4b3d970e2194d00e1c6d5002f513f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 26 21:12:22 2018 +0100

    drm/i915: Remove i915.enable_ppgtt override
    
    Now that we are confident in providing full-ppgtt where supported,
    remove the ability to override the context isolation.
    
    v2: Remove faked aliasing-ppgtt for testing as it no longer is accepted.
    v3: s/USES/HAS/ to match usage and reject attempts to load the module on
    old GVT-g setups that do not provide support for full-ppgtt.
    v4: Insulate ABI ppGTT values from our internal enum (later plans
    involve moving ppGTT depth out of the enum, thus potentially breaking
    ABI unless we document the current values).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Zhi Wang <zhi.a.wang@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180926201222.5643-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ade9bca250fa..1b028f429e92 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -345,7 +345,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = HAS_WT(dev_priv);
 		break;
 	case I915_PARAM_HAS_ALIASING_PPGTT:
-		value = USES_PPGTT(dev_priv);
+		value = min_t(int, INTEL_PPGTT(dev_priv), I915_GEM_PPGTT_FULL);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
 		value = HAS_LEGACY_SEMAPHORES(dev_priv);
@@ -1049,17 +1049,6 @@ static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 
 static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 {
-	/*
-	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
-	 * user's requested state against the hardware/driver capabilities.  We
-	 * do this now so that we can print out any log messages once rather
-	 * than every time we check intel_enable_ppgtt().
-	 */
-	i915_modparams.enable_ppgtt =
-		intel_sanitize_enable_ppgtt(dev_priv,
-					    i915_modparams.enable_ppgtt);
-	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915_modparams.enable_ppgtt);
-
 	intel_gvt_sanitize_options(dev_priv);
 }
 
@@ -1374,6 +1363,15 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_device_info_runtime_init(mkwrite_device_info(dev_priv));
 
+	if (HAS_PPGTT(dev_priv)) {
+		if (intel_vgpu_active(dev_priv) &&
+		    !intel_vgpu_has_full_48bit_ppgtt(dev_priv)) {
+			i915_report_error(dev_priv,
+					  "incompatible vGPU found, support for isolated ppGTT required\n");
+			return -ENXIO;
+		}
+	}
+
 	intel_sanitize_options(dev_priv);
 
 	i915_perf_init(dev_priv);

commit 74f6e183913b5dc90a004cafa84159ddb61cd0f0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 26 11:47:07 2018 +0100

    drm/i915: Convert to BITS_PER_TYPE
    
    In commit 9144d75e22ca ("include/linux/bitops.h: introduce BITS_PER_TYPE"),
    we made BITS_PER_TYPE available to all and now we can use the macro to
    replace some open-coded computation of sizeof(T) * BITS_PER_BYTE.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180926104707.17410-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44e2c0f5ec50..ade9bca250fa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1649,8 +1649,8 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 	device_info->device_id = pdev->device;
 
 	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
-		     sizeof(device_info->platform_mask) * BITS_PER_BYTE);
-	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
+		     BITS_PER_TYPE(device_info->platform_mask));
+	BUG_ON(device_info->gen > BITS_PER_TYPE(device_info->gen_mask));
 
 	return i915;
 }

commit 2863b00941bc3062ea3299ed4057acfd9e52c335
Merge: fc3fed5d297b 36c9c3c91128
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Sep 26 11:24:04 2018 +0300

    Merge drm/drm-next into drm-intel-next-queued
    
    Catch up in general, and get DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT
    specifically.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 795241040a9102b7dc925714f6a57ec92d84932e
Merge: 2dc7bad71cd3 e884818cc0ed
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Sep 20 10:14:59 2018 +1000

    Merge tag 'drm-misc-next-2018-09-19' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 4.20:
    
    UAPI Changes:
    - None
    
    Cross-subsystem Changes:
    - None
    
    Core Changes:
    - Allow drivers to disable features with per-device granularity (Ville)
    - Use EOPNOTSUPP when iface/feature is unsupported instead of
      EINVAL/errno soup (Chris)
    - Simplify M/N DP quirk by using constant N to limit size of M/N (Shawn)
    - add quirk for LG LP140WF6-SPM1 eDP panel (Shawn)
    
    Driver Changes:
    - i915/amdgpu: Disable DRIVER_ATOMIC for older/unsupported devices (Ville)
    - sun4i: add support for R40 HDMI PHY (Icenowy)
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Icenowy Zheng <icenowy@aosc.io>
    Cc: Lee, Shawn C <shawn.c.lee@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Sean Paul <sean@poorly.run>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180919200218.GA186644@art_vandelay

commit 8a6c5447635c4039eb51801fb5dcdb8c7ef93cfb
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Aug 24 15:02:25 2018 +0530

    drm/i915/kbl+: Enable IPC only for symmetric memory configurations
    
    IPC may cause underflows if not used with dual channel symmetric
    memory configuration. Disable IPC for non symmetric configurations in
    affected platforms.
    Display WA #1141
    
    Changes Since V1:
     - Re-arrange the code.
     - update wrapper to return if memory is symmetric (Rodrigo)
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180824093225.12598-6-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c293341a6ad6..dbe40b21fef8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1141,21 +1141,32 @@ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 	return 0;
 }
 
+static bool
+intel_is_dram_symmetric(u32 val_ch0, u32 val_ch1,
+			struct dram_channel_info *ch0)
+{
+	return (val_ch0 == val_ch1 &&
+		(ch0->s_info.size == 0 ||
+		 (ch0->l_info.size == ch0->s_info.size &&
+		  ch0->l_info.width == ch0->s_info.width &&
+		  ch0->l_info.rank == ch0->s_info.rank)));
+}
+
 static int
 skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 {
 	struct dram_info *dram_info = &dev_priv->dram_info;
 	struct dram_channel_info ch0, ch1;
-	u32 val;
+	u32 val_ch0, val_ch1;
 	int ret;
 
-	val = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch0, val);
+	val_ch0 = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch0, val_ch0);
 	if (ret == 0)
 		dram_info->num_channels++;
 
-	val = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
-	ret = skl_dram_get_channel_info(&ch1, val);
+	val_ch1 = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch1, val_ch1);
 	if (ret == 0)
 		dram_info->num_channels++;
 
@@ -1185,6 +1196,12 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 	if (ch0.is_16gb_dimm || ch1.is_16gb_dimm)
 		dram_info->is_16gb_dimm = true;
 
+	dev_priv->dram_info.symmetric_memory = intel_is_dram_symmetric(val_ch0,
+								       val_ch1,
+								       &ch0);
+
+	DRM_DEBUG_KMS("memory configuration is %sSymmetric memory\n",
+		      dev_priv->dram_info.symmetric_memory ? "" : "not ");
 	return 0;
 }
 

commit 86b592876cb6b277e5cb3c988fc5f748fdafa16f
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Aug 31 16:39:42 2018 +0530

    drm/i915: Implement 16GB dimm wa for latency level-0
    
    Memory with 16GB dimms require an increase of 1us in level-0 latency.
    This patch implements the same.
    Bspec: 4381
    
    changes since V1:
     - s/memdev_info/dram_info
     - make skl_is_16gb_dimm pure function
    Changes since V2:
     - make is_16gb_dimm more generic
     - rebase
    Changes since V3:
     - Simplify condition (Maarten)
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180831110942.9234-1-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 361dfcd44fe8..c293341a6ad6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1075,6 +1075,21 @@ static enum dram_rank skl_get_dimm_rank(u8 size, u32 rank)
 	return I915_DRAM_RANK_INVALID;
 }
 
+static bool
+skl_is_16gb_dimm(enum dram_rank rank, u8 size, u8 width)
+{
+	if (rank == I915_DRAM_RANK_SINGLE && width == 8 && size == 16)
+		return true;
+	else if (rank == I915_DRAM_RANK_DUAL && width == 8 && size == 32)
+		return true;
+	else if (rank == SKL_DRAM_RANK_SINGLE && width == 16 && size == 8)
+		return true;
+	else if (rank == SKL_DRAM_RANK_DUAL && width == 16 && size == 16)
+		return true;
+
+	return false;
+}
+
 static int
 skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 {
@@ -1112,6 +1127,11 @@ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
 	else
 		ch->rank = I915_DRAM_RANK_SINGLE;
 
+	ch->is_16gb_dimm = skl_is_16gb_dimm(ch->l_info.rank, ch->l_info.size,
+					    ch->l_info.width) ||
+			   skl_is_16gb_dimm(ch->s_info.rank, ch->s_info.size,
+					    ch->s_info.width);
+
 	DRM_DEBUG_KMS("(size:width:rank) L(%dGB:X%d:%s) S(%dGB:X%d:%s)\n",
 		      ch->l_info.size, ch->l_info.width,
 		      ch->l_info.rank ? "dual" : "single",
@@ -1144,6 +1164,8 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		return -EINVAL;
 	}
 
+	dram_info->valid_dimm = true;
+
 	/*
 	 * If any of the channel is single rank channel, worst case output
 	 * will be same as if single rank memory, so consider single rank
@@ -1159,6 +1181,10 @@ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
 		DRM_INFO("couldn't get memory rank information\n");
 		return -EINVAL;
 	}
+
+	if (ch0.is_16gb_dimm || ch1.is_16gb_dimm)
+		dram_info->is_16gb_dimm = true;
+
 	return 0;
 }
 
@@ -1271,6 +1297,7 @@ bxt_get_dram_info(struct drm_i915_private *dev_priv)
 		return -EINVAL;
 	}
 
+	dram_info->valid_dimm = true;
 	dram_info->valid = true;
 	return 0;
 }
@@ -1283,6 +1310,8 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	int ret;
 
 	dram_info->valid = false;
+	dram_info->valid_dimm = false;
+	dram_info->is_16gb_dimm = false;
 	dram_info->rank = I915_DRAM_RANK_INVALID;
 	dram_info->bandwidth_kbps = 0;
 	dram_info->num_channels = 0;
@@ -1306,9 +1335,9 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 		sprintf(bandwidth_str, "unknown");
 	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
 		      bandwidth_str, dram_info->num_channels);
-	DRM_DEBUG_KMS("DRAM rank: %s rank\n",
+	DRM_DEBUG_KMS("DRAM rank: %s rank 16GB-dimm:%s\n",
 		      (dram_info->rank == I915_DRAM_RANK_DUAL) ?
-		      "dual" : "single");
+		      "dual" : "single", yesno(dram_info->is_16gb_dimm));
 }
 
 /**

commit 5771caf885ae779ade0ea009ae5d5f363bb72a52
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Aug 24 15:02:22 2018 +0530

    drm/i915/skl+: Decode memory bandwidth and parameters
    
    This patch adds support to decode system memory bandwidth and other
    parameters for skylake and Gen9+ platforms, which will be used for
    arbitrated display memory bandwidth calculation in GEN9 based
    platforms and WM latency level-0 Work-around calculation on GEN9+.
    
    Changes Since V1:
     - s/memdev_info/dram_info
     - create a struct to hold channel info
    Changes Since V2:
     - rewrite code to adhere i915 coding style
     - not valid for GLK
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180824093225.12598-3-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 52befc1e0912..361dfcd44fe8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1063,6 +1063,132 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
+static enum dram_rank skl_get_dimm_rank(u8 size, u32 rank)
+{
+	if (size == 0)
+		return I915_DRAM_RANK_INVALID;
+	if (rank == SKL_DRAM_RANK_SINGLE)
+		return I915_DRAM_RANK_SINGLE;
+	else if (rank == SKL_DRAM_RANK_DUAL)
+		return I915_DRAM_RANK_DUAL;
+
+	return I915_DRAM_RANK_INVALID;
+}
+
+static int
+skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
+{
+	u32 tmp_l, tmp_s;
+	u32 s_val = val >> SKL_DRAM_S_SHIFT;
+
+	if (!val)
+		return -EINVAL;
+
+	tmp_l = val & SKL_DRAM_SIZE_MASK;
+	tmp_s = s_val & SKL_DRAM_SIZE_MASK;
+
+	if (tmp_l == 0 && tmp_s == 0)
+		return -EINVAL;
+
+	ch->l_info.size = tmp_l;
+	ch->s_info.size = tmp_s;
+
+	tmp_l = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
+	tmp_s = (s_val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
+	ch->l_info.width = (1 << tmp_l) * 8;
+	ch->s_info.width = (1 << tmp_s) * 8;
+
+	tmp_l = val & SKL_DRAM_RANK_MASK;
+	tmp_s = s_val & SKL_DRAM_RANK_MASK;
+	ch->l_info.rank = skl_get_dimm_rank(ch->l_info.size, tmp_l);
+	ch->s_info.rank = skl_get_dimm_rank(ch->s_info.size, tmp_s);
+
+	if (ch->l_info.rank == I915_DRAM_RANK_DUAL ||
+	    ch->s_info.rank == I915_DRAM_RANK_DUAL)
+		ch->rank = I915_DRAM_RANK_DUAL;
+	else if (ch->l_info.rank == I915_DRAM_RANK_SINGLE &&
+		 ch->s_info.rank == I915_DRAM_RANK_SINGLE)
+		ch->rank = I915_DRAM_RANK_DUAL;
+	else
+		ch->rank = I915_DRAM_RANK_SINGLE;
+
+	DRM_DEBUG_KMS("(size:width:rank) L(%dGB:X%d:%s) S(%dGB:X%d:%s)\n",
+		      ch->l_info.size, ch->l_info.width,
+		      ch->l_info.rank ? "dual" : "single",
+		      ch->s_info.size, ch->s_info.width,
+		      ch->s_info.rank ? "dual" : "single");
+
+	return 0;
+}
+
+static int
+skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
+{
+	struct dram_info *dram_info = &dev_priv->dram_info;
+	struct dram_channel_info ch0, ch1;
+	u32 val;
+	int ret;
+
+	val = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch0, val);
+	if (ret == 0)
+		dram_info->num_channels++;
+
+	val = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
+	ret = skl_dram_get_channel_info(&ch1, val);
+	if (ret == 0)
+		dram_info->num_channels++;
+
+	if (dram_info->num_channels == 0) {
+		DRM_INFO("Number of memory channels is zero\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * If any of the channel is single rank channel, worst case output
+	 * will be same as if single rank memory, so consider single rank
+	 * memory.
+	 */
+	if (ch0.rank == I915_DRAM_RANK_SINGLE ||
+	    ch1.rank == I915_DRAM_RANK_SINGLE)
+		dram_info->rank = I915_DRAM_RANK_SINGLE;
+	else
+		dram_info->rank = max(ch0.rank, ch1.rank);
+
+	if (dram_info->rank == I915_DRAM_RANK_INVALID) {
+		DRM_INFO("couldn't get memory rank information\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int
+skl_get_dram_info(struct drm_i915_private *dev_priv)
+{
+	struct dram_info *dram_info = &dev_priv->dram_info;
+	u32 mem_freq_khz, val;
+	int ret;
+
+	ret = skl_dram_get_channels_info(dev_priv);
+	if (ret)
+		return ret;
+
+	val = I915_READ(SKL_MC_BIOS_DATA_0_0_0_MCHBAR_PCU);
+	mem_freq_khz = DIV_ROUND_UP((val & SKL_REQ_DATA_MASK) *
+				    SKL_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
+
+	dram_info->bandwidth_kbps = dram_info->num_channels *
+							mem_freq_khz * 8;
+
+	if (dram_info->bandwidth_kbps == 0) {
+		DRM_INFO("Couldn't get system memory bandwidth\n");
+		return -EINVAL;
+	}
+
+	dram_info->valid = true;
+	return 0;
+}
+
 static int
 bxt_get_dram_info(struct drm_i915_private *dev_priv)
 {
@@ -1153,6 +1279,7 @@ static void
 intel_get_dram_info(struct drm_i915_private *dev_priv)
 {
 	struct dram_info *dram_info = &dev_priv->dram_info;
+	char bandwidth_str[32];
 	int ret;
 
 	dram_info->valid = false;
@@ -1160,15 +1287,25 @@ intel_get_dram_info(struct drm_i915_private *dev_priv)
 	dram_info->bandwidth_kbps = 0;
 	dram_info->num_channels = 0;
 
-	if (!IS_BROXTON(dev_priv))
+	if (INTEL_GEN(dev_priv) < 9 || IS_GEMINILAKE(dev_priv))
 		return;
 
-	ret = bxt_get_dram_info(dev_priv);
+	/* Need to calculate bandwidth only for Gen9 */
+	if (IS_BROXTON(dev_priv))
+		ret = bxt_get_dram_info(dev_priv);
+	else if (INTEL_GEN(dev_priv) == 9)
+		ret = skl_get_dram_info(dev_priv);
+	else
+		ret = skl_dram_get_channels_info(dev_priv);
 	if (ret)
 		return;
 
-	DRM_DEBUG_KMS("DRAM bandwidth:%d KBps, total-channels: %u\n",
-		      dram_info->bandwidth_kbps, dram_info->num_channels);
+	if (dram_info->bandwidth_kbps)
+		sprintf(bandwidth_str, "%d KBps", dram_info->bandwidth_kbps);
+	else
+		sprintf(bandwidth_str, "unknown");
+	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
+		      bandwidth_str, dram_info->num_channels);
 	DRM_DEBUG_KMS("DRAM rank: %s rank\n",
 		      (dram_info->rank == I915_DRAM_RANK_DUAL) ?
 		      "dual" : "single");

commit cbfa59d4b331046d89c795c8e809922f345d9bd7
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Aug 24 15:02:21 2018 +0530

    drm/i915/bxt: Decode memory bandwidth and parameters
    
    This patch adds support to decode system memory bandwidth and other
    parameters for broxton platform, which will be used for arbitrated
    display memory bandwidth calculation in GEN9 based platforms and
    WM latency level-0 Work-around calculation on GEN9+ platforms.
    
    Changes since V1:
     - s/memdev_info/dram_info
    Changes since V2:
     - Adhere to i915 coding style (Rodrigo)
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180824093225.12598-2-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5dd7fc582e6f..52befc1e0912 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1063,6 +1063,117 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	intel_gvt_sanitize_options(dev_priv);
 }
 
+static int
+bxt_get_dram_info(struct drm_i915_private *dev_priv)
+{
+	struct dram_info *dram_info = &dev_priv->dram_info;
+	u32 dram_channels;
+	u32 mem_freq_khz, val;
+	u8 num_active_channels;
+	int i;
+
+	val = I915_READ(BXT_P_CR_MC_BIOS_REQ_0_0_0);
+	mem_freq_khz = DIV_ROUND_UP((val & BXT_REQ_DATA_MASK) *
+				    BXT_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
+
+	dram_channels = val & BXT_DRAM_CHANNEL_ACTIVE_MASK;
+	num_active_channels = hweight32(dram_channels);
+
+	/* Each active bit represents 4-byte channel */
+	dram_info->bandwidth_kbps = (mem_freq_khz * num_active_channels * 4);
+
+	if (dram_info->bandwidth_kbps == 0) {
+		DRM_INFO("Couldn't get system memory bandwidth\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Now read each DUNIT8/9/10/11 to check the rank of each dimms.
+	 */
+	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
+		u8 size, width;
+		enum dram_rank rank;
+		u32 tmp;
+
+		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
+		if (val == 0xFFFFFFFF)
+			continue;
+
+		dram_info->num_channels++;
+		tmp = val & BXT_DRAM_RANK_MASK;
+
+		if (tmp == BXT_DRAM_RANK_SINGLE)
+			rank = I915_DRAM_RANK_SINGLE;
+		else if (tmp == BXT_DRAM_RANK_DUAL)
+			rank = I915_DRAM_RANK_DUAL;
+		else
+			rank = I915_DRAM_RANK_INVALID;
+
+		tmp = val & BXT_DRAM_SIZE_MASK;
+		if (tmp == BXT_DRAM_SIZE_4GB)
+			size = 4;
+		else if (tmp == BXT_DRAM_SIZE_6GB)
+			size = 6;
+		else if (tmp == BXT_DRAM_SIZE_8GB)
+			size = 8;
+		else if (tmp == BXT_DRAM_SIZE_12GB)
+			size = 12;
+		else if (tmp == BXT_DRAM_SIZE_16GB)
+			size = 16;
+		else
+			size = 0;
+
+		tmp = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
+		width = (1 << tmp) * 8;
+		DRM_DEBUG_KMS("dram size:%dGB width:X%d rank:%s\n", size,
+			      width, rank == I915_DRAM_RANK_SINGLE ? "single" :
+			      rank == I915_DRAM_RANK_DUAL ? "dual" : "unknown");
+
+		/*
+		 * If any of the channel is single rank channel,
+		 * worst case output will be same as if single rank
+		 * memory, so consider single rank memory.
+		 */
+		if (dram_info->rank == I915_DRAM_RANK_INVALID)
+			dram_info->rank = rank;
+		else if (rank == I915_DRAM_RANK_SINGLE)
+			dram_info->rank = I915_DRAM_RANK_SINGLE;
+	}
+
+	if (dram_info->rank == I915_DRAM_RANK_INVALID) {
+		DRM_INFO("couldn't get memory rank information\n");
+		return -EINVAL;
+	}
+
+	dram_info->valid = true;
+	return 0;
+}
+
+static void
+intel_get_dram_info(struct drm_i915_private *dev_priv)
+{
+	struct dram_info *dram_info = &dev_priv->dram_info;
+	int ret;
+
+	dram_info->valid = false;
+	dram_info->rank = I915_DRAM_RANK_INVALID;
+	dram_info->bandwidth_kbps = 0;
+	dram_info->num_channels = 0;
+
+	if (!IS_BROXTON(dev_priv))
+		return;
+
+	ret = bxt_get_dram_info(dev_priv);
+	if (ret)
+		return;
+
+	DRM_DEBUG_KMS("DRAM bandwidth:%d KBps, total-channels: %u\n",
+		      dram_info->bandwidth_kbps, dram_info->num_channels);
+	DRM_DEBUG_KMS("DRAM rank: %s rank\n",
+		      (dram_info->rank == I915_DRAM_RANK_DUAL) ?
+		      "dual" : "single");
+}
+
 /**
  * i915_driver_init_hw - setup state requiring device access
  * @dev_priv: device private
@@ -1180,6 +1291,12 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		goto err_msi;
 
 	intel_opregion_setup(dev_priv);
+	/*
+	 * Fill the dram structure to get the system raw bandwidth and
+	 * dram info. This will be used for memory latency calculation.
+	 */
+	intel_get_dram_info(dev_priv);
+
 
 	return 0;
 

commit 1feb64c49d7f2a46dc7b1e4c92c85ead2775395e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Sep 13 16:16:22 2018 +0300

    drm/i915: Clear DRIVER_ATOMIC on a per-device basis
    
    Currently we're clearing DRIVER_ATOMIC in driver.driver_features
    for older platforms. This will not work correctly should we ever
    have a system with and old and new GPU in it. While that is not
    possible currently let's make the code more correct and use
    the per-device driver_features instead.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180913131622.17690-2-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f8cfd16be534..61199defb470 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1336,10 +1336,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct drm_i915_private *dev_priv;
 	int ret;
 
-	/* Enable nuclear pageflip on ILK+ */
-	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
-		driver.driver_features &= ~DRIVER_ATOMIC;
-
 	ret = -ENOMEM;
 	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
 	if (dev_priv)
@@ -1352,6 +1348,10 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	dev_priv->drm.pdev = pdev;
 	dev_priv->drm.dev_private = dev_priv;
 
+	/* Disable nuclear pageflip by default on pre-ILK */
+	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
+		dev_priv->drm.driver_features &= ~DRIVER_ATOMIC;
+
 	ret = pci_enable_device(pdev);
 	if (ret)
 		goto out_fini;

commit 31962ca6a26087eea255c000ea9fa4ffbdad697b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 5 15:09:21 2018 +0100

    drm/i915: Move final cleanup of drm_i915_private to i915_driver_destroy
    
    Introduce a complementary function to i915_driver_create() to undo all
    that is created.
    
    Suggested-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905140921.17467-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1dddd2f4f929..5dd7fc582e6f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1355,6 +1355,17 @@ i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return i915;
 }
 
+static void i915_driver_destroy(struct drm_i915_private *i915)
+{
+	struct pci_dev *pdev = i915->drm.pdev;
+
+	drm_dev_fini(&i915->drm);
+	kfree(i915);
+
+	/* And make sure we never chase our dangling pointer from pci_dev */
+	pci_set_drvdata(pdev, NULL);
+}
+
 /**
  * i915_driver_load - setup chip and create an initial config
  * @pdev: PCI device
@@ -1436,9 +1447,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_disable_device(pdev);
 out_fini:
 	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
-	drm_dev_fini(&dev_priv->drm);
-	kfree(dev_priv);
-	pci_set_drvdata(pdev, NULL);
+	i915_driver_destroy(dev_priv);
 	return ret;
 }
 
@@ -1489,9 +1498,7 @@ static void i915_driver_release(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 
 	i915_driver_cleanup_early(dev_priv);
-	drm_dev_fini(&dev_priv->drm);
-
-	kfree(dev_priv);
+	i915_driver_destroy(dev_priv);
 }
 
 static int i915_driver_open(struct drm_device *dev, struct drm_file *file)

commit 55ac5a1614f99816ed367a9ded5f5d65321b522f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 5 15:09:20 2018 +0100

    drm/i915: Attach the pci match data to the device upon creation
    
    Attach our device_info to the our i915 private on creation so that it is
    always available for inspection.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905140921.17467-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77a4a01ddc08..1dddd2f4f929 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -870,7 +870,6 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 /**
  * i915_driver_init_early - setup state not requiring device access
  * @dev_priv: device private
- * @ent: the matching pci_device_id
  *
  * Initialize everything that is a "SW-only" state, that is state not
  * requiring accessing the device or exposing the driver via kernel internal
@@ -878,25 +877,13 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
  * system memory allocation, setting up device specific attributes and
  * function hooks not requiring accessing the device.
  */
-static int i915_driver_init_early(struct drm_i915_private *dev_priv,
-				  const struct pci_device_id *ent)
+static int i915_driver_init_early(struct drm_i915_private *dev_priv)
 {
-	const struct intel_device_info *match_info =
-		(struct intel_device_info *)ent->driver_data;
-	struct intel_device_info *device_info;
 	int ret = 0;
 
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	/* Setup the write-once "constant" device info */
-	device_info = mkwrite_device_info(dev_priv);
-	memcpy(device_info, match_info, sizeof(*device_info));
-	device_info->device_id = dev_priv->drm.pdev->device;
-
-	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
-		     sizeof(device_info->platform_mask) * BITS_PER_BYTE);
-	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);
 	mutex_init(&dev_priv->backlight_lock);
@@ -1335,6 +1322,39 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 		DRM_INFO("DRM_I915_DEBUG_RUNTIME_PM enabled\n");
 }
 
+static struct drm_i915_private *
+i915_driver_create(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	const struct intel_device_info *match_info =
+		(struct intel_device_info *)ent->driver_data;
+	struct intel_device_info *device_info;
+	struct drm_i915_private *i915;
+
+	i915 = kzalloc(sizeof(*i915), GFP_KERNEL);
+	if (!i915)
+		return NULL;
+
+	if (drm_dev_init(&i915->drm, &driver, &pdev->dev)) {
+		kfree(i915);
+		return NULL;
+	}
+
+	i915->drm.pdev = pdev;
+	i915->drm.dev_private = i915;
+	pci_set_drvdata(pdev, &i915->drm);
+
+	/* Setup the write-once "constant" device info */
+	device_info = mkwrite_device_info(i915);
+	memcpy(device_info, match_info, sizeof(*device_info));
+	device_info->device_id = pdev->device;
+
+	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
+		     sizeof(device_info->platform_mask) * BITS_PER_BYTE);
+	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
+
+	return i915;
+}
+
 /**
  * i915_driver_load - setup chip and create an initial config
  * @pdev: PCI device
@@ -1357,24 +1377,15 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
 		driver.driver_features &= ~DRIVER_ATOMIC;
 
-	ret = -ENOMEM;
-	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
-	if (dev_priv)
-		ret = drm_dev_init(&dev_priv->drm, &driver, &pdev->dev);
-	if (ret) {
-		DRM_DEV_ERROR(&pdev->dev, "allocation failed\n");
-		goto out_free;
-	}
-
-	dev_priv->drm.pdev = pdev;
-	dev_priv->drm.dev_private = dev_priv;
+	dev_priv = i915_driver_create(pdev, ent);
+	if (!dev_priv)
+		return -ENOMEM;
 
 	ret = pci_enable_device(pdev);
 	if (ret)
 		goto out_fini;
 
-	pci_set_drvdata(pdev, &dev_priv->drm);
-	ret = i915_driver_init_early(dev_priv, ent);
+	ret = i915_driver_init_early(dev_priv);
 	if (ret < 0)
 		goto out_pci_disable;
 
@@ -1426,7 +1437,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_fini:
 	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
 	drm_dev_fini(&dev_priv->drm);
-out_free:
 	kfree(dev_priv);
 	pci_set_drvdata(pdev, NULL);
 	return ret;

commit 6dfc4a8f134fe0fe4c77dd09906e7305ba7b3edc
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Aug 16 22:34:14 2018 +0300

    drm/i915: Verify power domains after enabling them
    
    After
    commit 2cd9a689e97b ("drm/i915: Refactor intel_display_set_init_power() logic")
    it makes more sense to check the power domain/well refcounts after
    enabling the power domains functionality. Before that it's guaranteed
    that most power wells (in the INIT domain) will have a reference held,
    so not an interesting state.
    
    While at it also add the check after the init_hw/fini_hw, disable and
    suspend/resume steps. Make the test optional on a Kconfig option since
    it may add substantial overhead: on VLV/CHV the corresponding PUNIT reg
    access for each power well may take up to 20ms.
    
    v2:
    - Add the state check to more spots. (Chris)
    
    v3:
    - During suspend check the state before deiniting display core.
      Afterwards DC states are disabled (and so the dc_off power well is
      enabled) even though we don't hold a reference on it.
    - Do the test conditionally based on a new Kconfig option. (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    [Add DRM_I915_DEBUG_RUNTIME_PM to welcome messages]
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180817145837.26592-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 35a012ffc03b..77a4a01ddc08 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1331,6 +1331,8 @@ static void i915_welcome_messages(struct drm_i915_private *dev_priv)
 		DRM_INFO("DRM_I915_DEBUG enabled\n");
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
 		DRM_INFO("DRM_I915_DEBUG_GEM enabled\n");
+	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM))
+		DRM_INFO("DRM_I915_DEBUG_RUNTIME_PM enabled\n");
 }
 
 /**

commit 2cd9a689e97b460489348aee89d72a812c3c1066
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Aug 16 15:37:57 2018 +0300

    drm/i915: Refactor intel_display_set_init_power() logic
    
    The device global init_power_on flag is somewhat arbitrary and makes
    debugging power refcounting problems difficult. Instead arrange things
    so that all display power domain get has a corresponding put call. After
    this change we have the following sequences:
    
    driver loading:
    intel_power_domains_init_hw();
    <other init steps>
    intel_power_domains_enable();
    
    driver unloading:
    intel_power_domains_disable();
    <other uninit steps>
    intel_power_domains_fini_hw();
    
    system suspend:
    intel_power_domains_disable();
    <other suspend steps>
    intel_power_domains_suspend();
    
    system resume:
    intel_power_domains_resume();
    <other resume steps>
    intel_power_domains_enable();
    
    at other times while the driver is loaded:
    intel_display_power_get();
    ...
    intel_display_power_put();
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180816123757.3286-2-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 021304e252eb..35a012ffc03b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1282,6 +1282,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	if (INTEL_INFO(dev_priv)->num_pipes)
 		drm_kms_helper_poll_init(dev);
 
+	intel_power_domains_enable(dev_priv);
 	intel_runtime_pm_enable(dev_priv);
 }
 
@@ -1292,6 +1293,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
 	intel_runtime_pm_disable(dev_priv);
+	intel_power_domains_disable(dev_priv);
 
 	intel_fbdev_unregister(dev_priv);
 	intel_audio_deinit(dev_priv);
@@ -1374,7 +1376,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (ret < 0)
 		goto out_pci_disable;
 
-	intel_runtime_pm_get(dev_priv);
+	disable_rpm_wakeref_asserts(dev_priv);
 
 	ret = i915_driver_init_mmio(dev_priv);
 	if (ret < 0)
@@ -1404,7 +1406,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	intel_init_ipc(dev_priv);
 
-	intel_runtime_pm_put(dev_priv);
+	enable_rpm_wakeref_asserts(dev_priv);
 
 	i915_welcome_messages(dev_priv);
 
@@ -1415,7 +1417,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 out_cleanup_mmio:
 	i915_driver_cleanup_mmio(dev_priv);
 out_runtime_pm_put:
-	intel_runtime_pm_put(dev_priv);
+	enable_rpm_wakeref_asserts(dev_priv);
 	i915_driver_cleanup_early(dev_priv);
 out_pci_disable:
 	pci_disable_device(pdev);
@@ -1433,7 +1435,7 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
+	disable_rpm_wakeref_asserts(dev_priv);
 
 	i915_driver_unregister(dev_priv);
 
@@ -1465,7 +1467,8 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_driver_cleanup_hw(dev_priv);
 	i915_driver_cleanup_mmio(dev_priv);
 
-	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
+	enable_rpm_wakeref_asserts(dev_priv);
+
 	WARN_ON(atomic_read(&dev_priv->runtime_pm.wakeref_count));
 }
 
@@ -1575,7 +1578,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
-	intel_display_set_init_power(dev_priv, true);
+	intel_power_domains_disable(dev_priv);
 
 	drm_kms_helper_poll_disable(dev);
 
@@ -1612,6 +1615,18 @@ static int i915_drm_suspend(struct drm_device *dev)
 	return 0;
 }
 
+static enum i915_drm_suspend_mode
+get_suspend_mode(struct drm_i915_private *dev_priv, bool hibernate)
+{
+	if (hibernate)
+		return I915_DRM_SUSPEND_HIBERNATE;
+
+	if (suspend_to_idle(dev_priv))
+		return I915_DRM_SUSPEND_IDLE;
+
+	return I915_DRM_SUSPEND_MEM;
+}
+
 static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
@@ -1622,21 +1637,10 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	i915_gem_suspend_late(dev_priv);
 
-	intel_display_set_init_power(dev_priv, false);
 	intel_uncore_suspend(dev_priv);
 
-	/*
-	 * In case of firmware assisted context save/restore don't manually
-	 * deinit the power domains. This also means the CSR/DMC firmware will
-	 * stay active, it will power down any HW resources as required and
-	 * also enable deeper system power states that would be blocked if the
-	 * firmware was inactive.
-	 */
-	if (IS_GEN9_LP(dev_priv) || hibernation || !suspend_to_idle(dev_priv) ||
-	    dev_priv->csr.dmc_payload == NULL) {
-		intel_power_domains_suspend(dev_priv);
-		dev_priv->power_domains_suspended = true;
-	}
+	intel_power_domains_suspend(dev_priv,
+				    get_suspend_mode(dev_priv, hibernation));
 
 	ret = 0;
 	if (IS_GEN9_LP(dev_priv))
@@ -1648,10 +1652,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
-		if (dev_priv->power_domains_suspended) {
-			intel_power_domains_init_hw(dev_priv, true);
-			dev_priv->power_domains_suspended = false;
-		}
+		intel_power_domains_resume(dev_priv);
 
 		goto out;
 	}
@@ -1768,6 +1769,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
+	intel_power_domains_enable(dev_priv);
+
 	enable_rpm_wakeref_asserts(dev_priv);
 
 	return 0;
@@ -1802,7 +1805,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	ret = pci_set_power_state(pdev, PCI_D0);
 	if (ret) {
 		DRM_ERROR("failed to set PCI D0 power state (%d)\n", ret);
-		goto out;
+		return ret;
 	}
 
 	/*
@@ -1818,10 +1821,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 * depend on the device enable refcount we can't anyway depend on them
 	 * disabling/enabling the device.
 	 */
-	if (pci_enable_device(pdev)) {
-		ret = -EIO;
-		goto out;
-	}
+	if (pci_enable_device(pdev))
+		return -EIO;
 
 	pci_set_master(pdev);
 
@@ -1844,18 +1845,12 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_sanitize(dev_priv);
 
-	if (dev_priv->power_domains_suspended)
-		intel_power_domains_init_hw(dev_priv, true);
-	else
-		intel_display_set_init_power(dev_priv, true);
+	intel_power_domains_resume(dev_priv);
 
 	intel_engines_sanitize(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 
-out:
-	dev_priv->power_domains_suspended = false;
-
 	return ret;
 }
 

commit 07d805721938a35e695d9f89218a4b02f6a4b2c4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 16 15:37:56 2018 +0300

    drm/i915: Introduce intel_runtime_pm_disable to pair intel_runtime_pm_enable
    
    Currently, we cancel the extra wakeref we have for !runtime-pm devices
    inside power_wells_fini_hw. However, this is not strictly paired with
    the acquisition of that wakeref in runtime_pm_enable (as the fini_hw may
    be called on errors paths before we even call runtime_pm_enable). Make
    the symmetry more explicit and include a check that we do release all of
    our rpm wakerefs.
    
    v2: Fixup transfer of ownership back to core whilst keeping our wakeref
    count balanced.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180816123757.3286-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 41111f2a9c39..021304e252eb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1281,6 +1281,8 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 */
 	if (INTEL_INFO(dev_priv)->num_pipes)
 		drm_kms_helper_poll_init(dev);
+
+	intel_runtime_pm_enable(dev_priv);
 }
 
 /**
@@ -1289,6 +1291,8 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
+	intel_runtime_pm_disable(dev_priv);
+
 	intel_fbdev_unregister(dev_priv);
 	intel_audio_deinit(dev_priv);
 
@@ -1366,16 +1370,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto out_fini;
 
 	pci_set_drvdata(pdev, &dev_priv->drm);
-	/*
-	 * Disable the system suspend direct complete optimization, which can
-	 * leave the device suspended skipping the driver's suspend handlers
-	 * if the device was already runtime suspended. This is needed due to
-	 * the difference in our runtime and system suspend sequence and
-	 * becaue the HDA driver may require us to enable the audio power
-	 * domain during system suspend.
-	 */
-	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NEVER_SKIP);
-
 	ret = i915_driver_init_early(dev_priv, ent);
 	if (ret < 0)
 		goto out_pci_disable;
@@ -1408,8 +1402,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	i915_driver_register(dev_priv);
 
-	intel_runtime_pm_enable(dev_priv);
-
 	intel_init_ipc(dev_priv);
 
 	intel_runtime_pm_put(dev_priv);
@@ -1441,13 +1433,13 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
+	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
+
 	i915_driver_unregister(dev_priv);
 
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 
-	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
-
 	drm_atomic_helper_shutdown(dev);
 
 	intel_gvt_cleanup(dev_priv);
@@ -1474,6 +1466,7 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_driver_cleanup_mmio(dev_priv);
 
 	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
+	WARN_ON(atomic_read(&dev_priv->runtime_pm.wakeref_count));
 }
 
 static void i915_driver_release(struct drm_device *dev)

commit a99b32a6fff7e482a267c72e565c8c410ce793d7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Aug 14 18:18:57 2018 +0100

    drm/i915: Clear stop-engine for a pardoned reset
    
    If we pardon a per-engine reset, we may leave the STOP_RING bit asserted
    in RING_MI_MODE resulting in the engine hanging. Unconditionally clear
    it on the per-engine exit path as we know that either we skipped the
    reset and so need the cancellation, or the reset was successful and the
    cancellation is a no-op, or there was an error and we will follow up
    with a full-reset or wedging (both of which will stop the engines again
    as required).
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=107188
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=106560
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180814171857.24673-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9dce55182c3a..41111f2a9c39 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2079,6 +2079,7 @@ int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
 		goto out;
 
 out:
+	intel_engine_cancel_stop_cs(engine);
 	i915_gem_reset_finish_engine(engine);
 	return ret;
 }

commit f28ec6f4ea483554aacc59e8eb4a7667ecaf58ad
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Aug 6 12:58:37 2018 +0300

    drm/i915: Constify power well descriptors
    
    It makes sense to keep unchanging data const. Extract such fields from
    the i915_power_well struct into a new i915_power_well_desc struct that
    we initialize during compile time. For the rest of the dynamic
    fields allocate an array of i915_power_well objects in i915 dev_priv,
    and link to each of these objects their corresponding
    i915_power_well_desc object.
    
    v2:
    - Fix checkpatch warnings about missing param name in fn declaration and
      lines over 80 chars. (Paulo)
    - Move check for unique IDs to __set_power_wells().
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    [Fixed checkpatch warn in __set_power_wells()]
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180806095843.13294-5-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6396318cf73c..9dce55182c3a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -924,7 +924,9 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_uc_init_early(dev_priv);
 	intel_pm_setup(dev_priv);
 	intel_init_dpio(dev_priv);
-	intel_power_domains_init(dev_priv);
+	ret = intel_power_domains_init(dev_priv);
+	if (ret < 0)
+		goto err_uc;
 	intel_irq_init(dev_priv);
 	intel_hangcheck_init(dev_priv);
 	intel_init_display_hooks(dev_priv);
@@ -936,6 +938,9 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	return 0;
 
+err_uc:
+	intel_uc_cleanup_early(dev_priv);
+	i915_gem_cleanup_early(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 err_engines:
@@ -950,6 +955,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
 	intel_irq_fini(dev_priv);
+	intel_power_domains_cleanup(dev_priv);
 	intel_uc_cleanup_early(dev_priv);
 	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);

commit 48a287ed9d624d8eae65e2dd1b12915b2b853644
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Aug 6 12:58:35 2018 +0300

    drm/i915: Rename intel_power_domains_fini() to intel_power_domains_fini_hw()
    
    intel_power_domains_fini() rolls back what was done in
    intel_power_domains_init_hw(), so rename and move it accordingly. This
    allows us adding a cleanup function later for intel_power_domains_init()
    in a cleaner way.
    
    No functional change.
    
    v2:
    - Fix checkpatch error adding missing param name to function
      declaration. (Paulo)
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180806095843.13294-3-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ed0169d49876..6396318cf73c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -712,7 +712,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	intel_teardown_gmbus(dev_priv);
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);
-	intel_power_domains_fini(dev_priv);
+	intel_power_domains_fini_hw(dev_priv);
 	vga_switcheroo_unregister_client(pdev);
 cleanup_vga_client:
 	vga_client_register(pdev, NULL, NULL, NULL);
@@ -1462,7 +1462,7 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_gem_fini(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 
-	intel_power_domains_fini(dev_priv);
+	intel_power_domains_fini_hw(dev_priv);
 
 	i915_driver_cleanup_hw(dev_priv);
 	i915_driver_cleanup_mmio(dev_priv);

commit a6476ebd4350d51146ef0492b4b06bc0d31e8827
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Aug 6 15:56:47 2018 +0100

    drm/i915: Stop dropping irq around resets
    
    A long time ago, we were afraid of handling interrupts and signaling
    waiters during a reset, worrying that the confusion in request handling
    would interfere with our attempts to process the reset in an orderly
    fashion. Since then, we have isolated our irq-driven request handling by
    virtue of the engine->timeline.lock and control of kthreads where
    required, eliminating the danger of concurrently processing interrupts.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180806145647.13131-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3857e7963fc5..ed0169d49876 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1918,7 +1918,6 @@ void i915_reset(struct drm_i915_private *i915,
 		dev_notice(i915->drm.dev, "Resetting chip for %s\n", reason);
 	error->reset_count++;
 
-	disable_irq(i915->drm.irq);
 	ret = i915_gem_reset_prepare(i915);
 	if (ret) {
 		dev_err(i915->drm.dev, "GPU recovery failed\n");
@@ -1980,8 +1979,6 @@ void i915_reset(struct drm_i915_private *i915,
 
 finish:
 	i915_gem_reset_finish(i915);
-	enable_irq(i915->drm.irq);
-
 wakeup:
 	clear_bit(I915_RESET_HANDOFF, &error->flags);
 	wake_up_bit(&error->flags, I915_RESET_HANDOFF);

commit 08e3e21a24d23db6a4adca90f7cb40d69e09d35c
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Fri Aug 3 16:24:43 2018 -0700

    drm/i915: kill resource streamer support
    
    After disabling resource streamer on ICL (due to it actually not
    existing there), I got feedback that there have been some experimental
    patches for mesa to use RS years ago, but nothing ever landed or shipped
    because there was no performance improvement.
    
    This removes it from kernel keeping the uapi defines around for
    compatibility.
    
    v2: - re-add the inadvertent removal of CTX_CTRL_INHIBIT_SYN_CTX_SWITCH
        - don't bother trying to document removed params on uapi header:
          applications should know that from the query.
          (from Chris)
    
    v3: - disable CTX_CTRL_RS_CTX_ENABLE istead of removing it
        - reword commit message after Daniele confirmed no performance
          regression on his machine
        - reword commit message to make clear RS is being removed due to
          never been used
    v4: - move I915_EXEC_RESOURCE_STREAMER to __I915_EXEC_ILLEGAL_FLAGS so
          the check on ioctl() is made much earlier by
          i915_gem_check_execbuffer() (suggested by Tvrtko)
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Acked-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180803232443.17193-1-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 64e0ea4bef67..3857e7963fc5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -373,7 +373,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 			value = 2;
 		break;
 	case I915_PARAM_HAS_RESOURCE_STREAMER:
-		value = HAS_RESOURCE_STREAMER(dev_priv);
+		value = 0;
 		break;
 	case I915_PARAM_HAS_POOLED_EU:
 		value = HAS_POOLED_EU(dev_priv);

commit c444ad790cc2b2bb6925a0b56716712a79624b4e
Author: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Date:   Fri Aug 3 19:41:50 2018 +0300

    drm/i915: Fix typo in i915_drm_resume()
    
    Trivial typo, s/loose/lose/, in i915_drm_resume.
    
    Signed-off-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180803164150.8185-1-gwan-gyeong.mun@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 18a45e7a3d7c..64e0ea4bef67 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1758,7 +1758,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	/*
 	 * ... but also need to make sure that hotplug processing
 	 * doesn't cause havoc. Like in the driver load code we don't
-	 * bother with the tiny race here where we might loose hotplug
+	 * bother with the tiny race here where we might lose hotplug
 	 * notifications.
 	 * */
 	intel_hpd_init(dev_priv);

commit c74a7469f97c0f40b46e82ee979f9fb1bb6e847c
Merge: 6f15a7de86c8 500775074f88
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Jul 23 09:13:12 2018 -0700

    Merge drm/drm-next into drm-intel-next-queued
    
    We need a backmerge to get DP_DPCD_REV_14 before we push other
    i915 changes to dinq that could break compilation.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

commit 900ccf30f9e112b508a61b228bf014e3bea14bc4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 20 11:19:10 2018 +0100

    drm/i915: Only force GGTT coherency w/a on required chipsets
    
    Not all chipsets have an internal buffer delaying the visibility of
    writes via the GGTT being visible by other physical paths, but we use a
    very heavy workaround for all. We only need to apply that workarounds to
    the chipsets we know suffer from the delay and the resulting coherency
    issue.
    
    Similarly, the same inconsistent coherency fouls up our ABI promise that
    a write into a mmap_gtt is immediately visible to others. Since the HW
    has made that a lie, let userspace know when that contract is broken.
    (Not that userspace would want to use mmap_gtt on those chipsets for
    other performance reasons...)
    
    Testcase: igt/drv_selftest/live_coherency
    Testcase: igt/gem_mmap_gtt/coherency
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100587
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Tomasz Lis <tomasz.lis@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180720101910.11153-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 343e79a44abd..23e9a86cbc2a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -441,6 +441,9 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 	case I915_PARAM_CS_TIMESTAMP_FREQUENCY:
 		value = 1000 * INTEL_INFO(dev_priv)->cs_timestamp_frequency_khz;
 		break;
+	case I915_PARAM_MMAP_GTT_COHERENT:
+		value = INTEL_INFO(dev_priv)->has_coherent_ggtt;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit ef8e0ff97ae8168ffe1558a5726a8b348c8228a3
Merge: 294f96ae8aa5 ef821e3f14e8
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jul 20 12:29:23 2018 +1000

    Merge tag 'drm-intel-next-2018-07-19' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    On GEM side:
    
    - GuC related fixes (Chris, Michal)
    - GTT read-only pages support (Jon, Chris)
    - More selftests fixes (Chris)
    - More GPU reset improvements (Chris)
    - Flush caches after GGTT writes (Chris)
    - Handle recursive shrinker for vma->last_active allocation (Chris)
    - Other execlists fixes (Chris)
    
    On Display side:
    
    - GLK HDMI fix (Clint)
    - Rework and cleanup around HPD pin (Ville)
    - Preparation work for Display Stream Compression support coming on ICL (Anusha)
    - Nuke LVDS lid notification (Ville)
    - Assume eDP is always connected (Ville)
    - Kill intel panel detection (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Fri 20 Jul 2018 01:51:45 AM AEST
    # gpg:                using RSA key FA625F640EEB13CA
    # gpg: Good signature from "Rodrigo Vivi <rodrigo.vivi@intel.com>"
    # gpg:                 aka "Rodrigo Vivi <rodrigo.vivi@gmail.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 6D20 7068 EEDD 6509 1C2C  E2A3 FA62 5F64 0EEB 13CA
    
    # Conflicts:
    #       drivers/gpu/drm/i915/intel_lrc.c
    Link: https://patchwork.freedesktop.org/patch/msgid/20180719171257.GA12199@intel.com

commit 05c72e77ccda89ff624108b1b59a0fc43843f343
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 17 20:42:14 2018 +0300

    drm/i915: Nuke the LVDS lid notifier
    
    We broke the LVDS notifier resume thing in (presumably) commit
    e2c8b8701e2d ("drm/i915: Use atomic helpers for suspend, v2.") as
    we no longer duplicate the current state in the LVDS notifier and
    thus we never resume it properly either.
    
    Instead of trying to fix it again let's just kill off the lid
    notifier entirely. None of the machines tested thus far have
    apparently needed it. Originally the lid notifier was added to
    work around cases where the VBIOS was clobbering some of the
    hardware state behind the driver's back, mostly on Thinkpads.
    We now have a few report of Thinkpads working just fine without
    the notifier. So maybe it was misdiagnosed originally, or
    something else has changed (ACPI video stuff perhaps?).
    
    If we do end up finding a machine where the VBIOS is still causing
    problems I would suggest that we first try setting various bits in
    the VBIOS scratch registers. There are several to choose from that
    may instruct the VBIOS to steer clear.
    
    With the notifier gone we'll also stop looking at the panel status
    in ->detect().
    
    v2: Nuke enum modeset_restore (Rodrigo)
    
    Cc: stable@vger.kernel.org
    Cc: Wolfgang Draxinger <wdraxinger.maillist@draxit.de>
    Cc: Vito Caputo <vcaputo@pengaru.com>
    Cc: kitsunyan <kitsunyan@airmail.cc>
    Cc: Joonas Saarinen <jza@saunalahti.fi>
    Tested-by: Vito Caputo <vcaputo@pengaru.com> # Thinkapd X61s
    Tested-by: kitsunyan <kitsunyan@airmail.cc> # ThinkPad X200
    Tested-by: Joonas Saarinen <jza@saunalahti.fi> # Fujitsu Siemens U9210
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=105902
    References: https://lists.freedesktop.org/archives/intel-gfx/2018-June/169315.html
    References: https://bugs.freedesktop.org/show_bug.cgi?id=21230
    Fixes: e2c8b8701e2d ("drm/i915: Use atomic helpers for suspend, v2.")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180717174216.22252-1-ville.syrjala@linux.intel.com
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 337b1aad5212..343e79a44abd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -900,7 +900,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	spin_lock_init(&dev_priv->uncore.lock);
 
 	mutex_init(&dev_priv->sb_lock);
-	mutex_init(&dev_priv->modeset_restore_lock);
 	mutex_init(&dev_priv->av_mutex);
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
@@ -1570,11 +1569,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	pci_power_t opregion_target_state;
 
-	/* ignore lid events during suspend */
-	mutex_lock(&dev_priv->modeset_restore_lock);
-	dev_priv->modeset_restore = MODESET_SUSPENDED;
-	mutex_unlock(&dev_priv->modeset_restore_lock);
-
 	disable_rpm_wakeref_asserts(dev_priv);
 
 	/* We do a lot of poking in a lot of registers, make sure they work
@@ -1770,10 +1764,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);
 
-	mutex_lock(&dev_priv->modeset_restore_lock);
-	dev_priv->modeset_restore = MODESET_DONE;
-	mutex_unlock(&dev_priv->modeset_restore_lock);
-
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
 	enable_rpm_wakeref_asserts(dev_priv);

commit 539c475dadc430bd0f1601902fcacc1e55ffe85a
Merge: 0c2fd59ae315 82edc7e8b8c0
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 19 05:46:24 2018 +1000

    Merge tag 'drm-intel-next-2018-07-09' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Higlights here goes to many PSR fixes and improvements; to the Ice lake work with
    power well support and begin of DSI support addition. Also there were many improvements
    on execlists and interrupts for minimal latency on command submission; and many fixes
    on selftests, mostly caught by our CI.
    
    General driver:
    - Clean-up on aux irq (Lucas)
    - Mark expected switch fall-through for dealing with static analysis tools (Gustavo)
    
    Gem:
    - Different fixes for GuC (Chris, Anusha, Michal)
    - Avoid self-relocation BIAS if no relocation (Chris)
    - Improve debugging cases in on EINVAL return and vma allocation (Chris)
    - Fixes and improvements on context destroying and freeing (Chris)
    - Wait for engines to idle before retiring (Chris)
    - Many improvements on execlists and interrupts for minimal latency on command submission (Chris)
    - Many fixes in selftests, specially on cases highlighted on CI (Chris)
    - Other fixes and improvements around GGTT (Chris)
    - Prevent background reaping of active objects (Chris)
    
    Display:
    - Parallel modeset cleanup to fix driver reset (Chris)
    - Get AUX power domain for DP main link (Imre)
    - Clean-up on PSR unused func pointers (Rodrigo)
    - Many PSR/PSR2 fixes and improvements (DK, Jose, Tarun)
    - Add a PSR1 live status (Vathsala)
    - Replace old drm_*_{un/reference} with put,get functions (Thomas)
    - FBC fixes (Maarten)
    - Abstract and document the usage of picking macros (Jani)
    - Remove unnecessary check for unsupported modifiers for NV12. (DK)
    - Interrupt fixes for display (Ville)
    - Clean up on sdvo code (Ville)
    - Clean up on current DSI code (Jani)
    - Remove support for legacy debugfs crc interface (Maarten)
    - Simplify get_encoder_power_domains (Imre)
    
    Icelake:
    - MG PLL fixes (Imre)
    - Add hw workaround for alpha blending (Vandita)
    - Add power well support (Imre)
    - Add Interrupt Support (Anusha)
    - Start to add support for DSI on Ice Lake (Madhav)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Tue 10 Jul 2018 08:41:37 AM AEST
    # gpg:                using RSA key FA625F640EEB13CA
    # gpg: Good signature from "Rodrigo Vivi <rodrigo.vivi@intel.com>"
    # gpg:                 aka "Rodrigo Vivi <rodrigo.vivi@gmail.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 6D20 7068 EEDD 6509 1C2C  E2A3 FA62 5F64 0EEB 13CA
    Link: https://patchwork.freedesktop.org/patch/msgid/20180710234349.GA16562@intel.com

commit 159b69bc0dcdb88ea5126a8f98e4caa31789326b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 16 09:03:31 2018 +0100

    drm/i915: Remove pci private pointer after destroying the device private
    
    On an aborted module load, we unwind and free our device private - but
    we left a dangling pointer to our privates inside the pci_device. After
    the attempted aborted unload, we may still get a call to i915_pci_remove()
    when the module is removed, potentially chasing stale data.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180716080332.32283-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cfa7583cf408..337b1aad5212 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1424,6 +1424,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	drm_dev_fini(&dev_priv->drm);
 out_free:
 	kfree(dev_priv);
+	pci_set_drvdata(pdev, NULL);
 	return ret;
 }
 

commit 1a4313d13b69318d11e3418b7193be6add511f69
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jul 5 19:43:52 2018 +0300

    drm/i915: Rewrite mst suspend/resume in terms of encoders
    
    Rather than looping over all the ports and picking the encoder based on
    the port, let's just loop over all the encoders instead. Gets rid of
    some irq_port[] usage, which is a bit of an eye sore.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180705164357.28512-4-ville.syrjala@linux.intel.com
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f059aa332323..cfa7583cf408 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1586,7 +1586,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_display_suspend(dev);
 
-	intel_dp_mst_suspend(dev);
+	intel_dp_mst_suspend(dev_priv);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 	intel_hpd_cancel_work(dev_priv);
@@ -1751,7 +1751,7 @@ static int i915_drm_resume(struct drm_device *dev)
 		dev_priv->display.hpd_irq_setup(dev_priv);
 	spin_unlock_irq(&dev_priv->irq_lock);
 
-	intel_dp_mst_resume(dev);
+	intel_dp_mst_resume(dev_priv);
 
 	intel_display_resume(dev);
 

commit 7ab87ede5078af1daccf26951096e16ac16e19cb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 10 15:38:21 2018 +0100

    drm/i915: Unwind HW init after GVT setup failure
    
    Following intel_gvt_init() failure, we missed unwinding our setup
    leaving pointers dangling past the module unload. For our example, the
    pm_qos:
    
    [  441.057615] top: 000000006b3baf1c, n: 0000000054d8ef33, p: 0000000097cdf1a2
                   prev: 0000000054d8ef33, n: 0000000097cdf1a2, p: 000000006b3baf1c
                   next: 0000000097cdf1a2, n: 000000006de8fc8b, p: 0000000081087253
    [  441.057627] WARNING: CPU: 4 PID: 9277 at lib/plist.c:42 plist_check_prev_next+0x2d/0x40
    [  441.057628] Modules linked in: i915(+) vgem snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core e1000e snd_pcm mei_me mei prime_numbers [last unloaded: i915]
    [  441.057652] CPU: 4 PID: 9277 Comm: drv_selftest Tainted: G     U            4.18.0-rc4-CI-CI_DRM_4464+ #1
    [  441.057653] Hardware name: System manufacturer System Product Name/Z170 PRO GAMING, BIOS 3402 04/26/2017
    [  441.057656] RIP: 0010:plist_check_prev_next+0x2d/0x40
    [  441.057657] Code: 08 48 39 f0 74 2b 49 89 f0 48 8b 4f 08 50 ff 32 52 48 89 fe 41 ff 70 08 48 8b 17 48 c7 c7 d8 ae 14 82 4d 8b 08 e8 63 0e 76 ff <0f> 0b 48 83 c4 20 c3 48 39 10 75 d0 f3 c3 0f 1f 44 00 00 41 54 55
    [  441.057717] RSP: 0018:ffffc900003a3a68 EFLAGS: 00010082
    [  441.057720] RAX: 0000000000000000 RBX: ffff8802193978c0 RCX: 0000000000000002
    [  441.057721] RDX: 0000000080000002 RSI: ffffffff820c65a4 RDI: 00000000ffffffff
    [  441.057722] RBP: ffff8802193978c0 R08: 0000000000000000 R09: 0000000000000001
    [  441.057724] R10: ffffc900003a3a70 R11: 0000000000000000 R12: ffffffff82243de0
    [  441.057725] R13: ffffffff82243de0 R14: ffff88021a6c78c0 R15: 0000000077359400
    [  441.057726] FS:  00007fc23a4a9980(0000) GS:ffff880236d00000(0000) knlGS:0000000000000000
    [  441.057728] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  441.057729] CR2: 0000563e4503d038 CR3: 0000000138f86005 CR4: 00000000003606e0
    [  441.057730] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  441.057731] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [  441.057732] Call Trace:
    [  441.057736]  plist_check_list+0x2e/0x40
    [  441.057738]  plist_add+0x23/0x130
    [  441.057743]  pm_qos_update_target+0x1bd/0x2f0
    [  441.057771]  i915_driver_load+0xec4/0x1060 [i915]
    [  441.057775]  ? trace_hardirqs_on_caller+0xe0/0x1b0
    [  441.057800]  i915_pci_probe+0x29/0x90 [i915]
    [  441.057804]  pci_device_probe+0xa1/0x130
    [  441.057807]  driver_probe_device+0x306/0x480
    [  441.057810]  __driver_attach+0xdb/0x100
    [  441.057812]  ? driver_probe_device+0x480/0x480
    [  441.057813]  ? driver_probe_device+0x480/0x480
    [  441.057816]  bus_for_each_dev+0x74/0xc0
    [  441.057819]  bus_add_driver+0x15f/0x250
    [  441.057821]  ? 0xffffffffa0696000
    [  441.057823]  driver_register+0x56/0xe0
    [  441.057825]  ? 0xffffffffa0696000
    [  441.057827]  do_one_initcall+0x58/0x370
    [  441.057830]  ? do_init_module+0x1d/0x1ea
    [  441.057832]  ? rcu_read_lock_sched_held+0x6f/0x80
    [  441.057834]  ? kmem_cache_alloc_trace+0x282/0x2e0
    [  441.057838]  do_init_module+0x56/0x1ea
    [  441.057841]  load_module+0x2435/0x2b20
    [  441.057852]  ? __se_sys_finit_module+0xd3/0xf0
    [  441.057854]  __se_sys_finit_module+0xd3/0xf0
    [  441.057861]  do_syscall_64+0x55/0x190
    [  441.057863]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  441.057865] RIP: 0033:0x7fc239d75839
    [  441.057866] Code: 00 f3 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 1f f6 2c 00 f7 d8 64 89 01 48
    [  441.057927] RSP: 002b:00007fffb7825d38 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [  441.057930] RAX: ffffffffffffffda RBX: 0000563e45035dd0 RCX: 00007fc239d75839
    [  441.057931] RDX: 0000000000000000 RSI: 0000563e4502f8a0 RDI: 0000000000000004
    [  441.057932] RBP: 0000563e4502f8a0 R08: 0000000000000004 R09: 0000000000000000
    [  441.057933] R10: 00007fffb7825ea0 R11: 0000000000000246 R12: 0000000000000000
    [  441.057934] R13: 0000563e4502f690 R14: 0000000000000000 R15: 000000000000003f
    [  441.057940] irq event stamp: 231338
    [  441.057943] hardirqs last  enabled at (231337): [<ffffffff8193e3fc>] _raw_spin_unlock_irqrestore+0x4c/0x60
    [  441.057944] hardirqs last disabled at (231338): [<ffffffff8193e26d>] _raw_spin_lock_irqsave+0xd/0x50
    [  441.057947] softirqs last  enabled at (231024): [<ffffffff81c0034f>] __do_softirq+0x34f/0x505
    [  441.057949] softirqs last disabled at (231005): [<ffffffff8108c7b9>] irq_exit+0xa9/0xc0
    [  441.057951] WARNING: CPU: 4 PID: 9277 at lib/plist.c:42 plist_check_prev_next+0x2d/0x40
    
    v2: Add a load failure point to intel_gvt_init() so that we always
    exercise this path in future.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=107129
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180710143821.1889-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f26cc721ee0f..f059aa332323 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1154,8 +1154,6 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_uncore_sanitize(dev_priv);
 
-	intel_opregion_setup(dev_priv);
-
 	i915_gem_load_init_fences(dev_priv);
 
 	/* On the 945G/GM, the chipset reports the MSI capability on the
@@ -1184,10 +1182,16 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	ret = intel_gvt_init(dev_priv);
 	if (ret)
-		goto err_ggtt;
+		goto err_msi;
+
+	intel_opregion_setup(dev_priv);
 
 	return 0;
 
+err_msi:
+	if (pdev->msi_enabled)
+		pci_disable_msi(pdev);
+	pm_qos_remove_request(&dev_priv->pm_qos);
 err_ggtt:
 	i915_ggtt_cleanup_hw(dev_priv);
 err_perf:

commit 73bad7ca87b65a91f61cf34b92a1febd689c01c1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 10 10:44:21 2018 +0100

    drm/i915: Cleanup modesetting on load-error path
    
    After handling a critical failure initialising GEM we need to unwind the
    modesetting setup.
    
    Testcase: igt/drv_module_reload/basic-reload-inject
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180710094421.16223-2-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c2b9a4a0ee49..f26cc721ee0f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -682,7 +682,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	ret = i915_gem_init(dev_priv);
 	if (ret)
-		goto cleanup_irq;
+		goto cleanup_modeset;
 
 	intel_setup_overlay(dev_priv);
 
@@ -702,6 +702,8 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 	i915_gem_fini(dev_priv);
+cleanup_modeset:
+	intel_modeset_cleanup(dev);
 cleanup_irq:
 	drm_irq_uninstall(dev);
 	intel_teardown_gmbus(dev_priv);

commit 8cff1f4a3ca58ab426f224b4bd6af61c1a9976ab
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 9 14:48:58 2018 +0100

    drm/i915: Remove function details from device error messages
    
    Error messages are intended to be addressed to the user; be clear,
    succinct, instructive and unambiguous. Adding the function name to
    that message does not add any information the user requires and in
    the process makes the message less clear.
    
    E.g.
    
    [  245.539711] i915 0000:00:02.0: [drm:i915_gem_init [i915]] Failed to initialize GPU, declaring it wedged!
    
    becomes
    
    [  245.539711] i915 0000:00:02.0: Failed to initialize GPU, declaring it wedged!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709134858.12446-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2959c88a37a5..c2b9a4a0ee49 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -104,8 +104,13 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	dev_printk(level, kdev, "[" DRM_NAME ":%ps] %pV",
-		   __builtin_return_address(0), &vaf);
+	if (is_error)
+		dev_printk(level, kdev, "%pV", &vaf);
+	else
+		dev_printk(level, kdev, "[" DRM_NAME ":%ps] %pV",
+			   __builtin_return_address(0), &vaf);
+
+	va_end(args);
 
 	if (is_error && !shown_bug_once) {
 		/*
@@ -117,8 +122,6 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 			dev_notice(kdev, "%s", FDO_BUG_MSG);
 		shown_bug_once = true;
 	}
-
-	va_end(args);
 }
 
 /* Map PCH device id to PCH type, or PCH_NONE if unknown. */

commit b4d4b0b7defbc226cc2237e08ced62c1c806e301
Merge: 3c8daa7db46d e1cacec9d50d
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 28 13:10:37 2018 +1000

    Merge tag 'drm-intel-next-2018-06-20' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Chris is doing many reworks that allow us to get full-ppgtt supported
    on all platforms back to HSW. As well many other fix and improvements,
    Including:
    - Use GEM suspend when aborting initialization (Chris)
    - Change i915_gem_fault to return vm_fault_t (Chris)
    - Expand VMA to Non gem object entities (Chris)
    - Improve logs for load failure, but quite logging on fault injection to avoid noise on CI (Chris)
    - Other page directory handling fixes and improvements for gen6 (Chris)
    - Other gtt clean-up removing redundancies and unused checks (Chris)
    - Reorder aliasing ppgtt fini (Chris)
    - Refactor of unsetting obg->mm.pages (Chris)
    - Apply batch location restrictions before pinning (Chris)
    - Ringbuffer fixes for context restore (Chris)
    - Execlist fixes on freeing error pointer on allocation error (Chris)
    - Make closing request flush mandatory (Chris)
    - Move GEM sanitize from resume_early to resume (Chris)
    - Improve debug dumps (Chris)
    - Silent compiler for selftest (Chris)
    - Other execlists changes to improve hangcheck and reset.
    - Many gtt page directory fixes and improvements (Chris)
    - Reorg context workarounds (Chris)
    - Avoid ERR_PTR dereference on selftest (Chris)
    
    Other GEM related work:
    - Stop trying to reset GPU if reset failed (Mika)
    - Add HW workaround for KBL to fix GPU reset (Mika)
    - Fix context ban and hang accounting for client (Mika)
    - Fixes on OA perf (Michel, Jani)
    - Refactor on GuC log mechanisms (Piotr)
    - Enable provoking vertex fix on Gen9 system (Kenneth)
    
    More ICL patches for Display enabling:
    - ICL - 10-bit support for HDMI (RK)
    - ICL - Start adding TBT PLL (Paulo)
    - ICL - DDI HDMK level selection (Manasi)
    - ICL - GMBUS GPIO pin mapping fix (Mahesh)
    - ICL - Adding DP_AUX_E support (James)
    - ICL - Display interrupts handling (DK)
    
    Other display fixes and improvements:
    - Fix sprite destination color keying on SKL+ (Ville)
    - Fixes and improvements on PCH detection, specially for non PCH systems (Jani)
    - Document PCH_NOP (Lucas)
    - Allow DBLSCAN user modes with eDP/LVDS/DSI (Ville)
    - Opregion and ACPI cleanup and organization (Jani)
    - Kill delays when activation psr (Rodrigo)
    - ...and a consequent fix of the psr activation flow (DK)
    - Fix HDMI infoframe setting (Imre)
    - Fix Display interrupts and modes on old gens (Ville)
    - Start switching to kernel unsigned int types (Jani)
    - Introduction to Amber Lake and Whiskey Lake platforms (Jose)
    - Audio clock fixes for HBR3 (RK)
    - Standardize i915_reg.h definitions according to our doc and checkpatch (Paulo)
    - Remove unused timespec_to_jiffies_timeout function (Arnd)
    - Increase the scope of PSR wake fix for other VBTs out there (Vathsala)
    - Improve debug msgs with prop name/id (Ville)
    - Other clean up on unecessary cursor size defines (Ville)
    - Enforce max hdisplay/hblank_start limits on HSW/BDW (Ville)
    - Make ELD pointers constant (Jani)
    - Fix for PSR VBT parse (Colin)
    - Add warn about unsupported CDCLK rates (Imre)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Thu 21 Jun 2018 07:12:10 AM AEST
    # gpg:                using RSA key FA625F640EEB13CA
    # gpg: Good signature from "Rodrigo Vivi <rodrigo.vivi@intel.com>"
    # gpg:                 aka "Rodrigo Vivi <rodrigo.vivi@gmail.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 6D20 7068 EEDD 6509 1C2C  E2A3 FA62 5F64 0EEB 13CA
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625165622.GA21761@intel.com

commit 3069290d9d6a9afa93661c299419089eea57164b
Merge: ce397d215ccd 14c3f8425080
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 22 11:34:41 2018 +1000

    Merge tag 'drm-intel-next-2018-06-06' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    - Ice Lake's display enabling patches (Jose, Mahesh, Dhinakaran, Paulo, Manasi, Anusha, Arkadiusz)
    - Ice Lake's workarounds (Oscar and Yunwei)
    - Ice Lake interrupt registers fixes (Oscar)
    - Context switch timeline fixes and improvements (Chris)
    - Spelling fixes (Colin)
    - GPU reset fixes and improvements (Chris)
      - Including fixes on execlist and preemption for a proper GPU reset (Chris)
    - Clean-up the port pipe select bits (Ville)
    - Other execlist improvements (Chris)
    - Remove unused enable_cmd_parser parameter (Chris)
    - Fix order of enabling pipe/transcoder/planes on HSW+ to avoid hang on ICL (Paulo)
    - Simplification and changes on intel_context (Chris)
    - Disable LVDS on Radiant P845 (Ondrej)
    - Improve HSW/BDW voltage swing handling (Ville)
    - Cleanup and renames on few parts of intel_dp code to make code clear and less confusing (Ville)
    - Move acpi lid notification code for fixing LVDS (Chris)
    - Speed up GPU idle detection (Chris)
    - Make intel_engine_dump irqsafe (Chris)
    - Fix GVT crash (Zhenyu)
    - Move GEM BO inside drm_framebuffer and use intel_fb_obj everywhere (Chris)
    - Revert edp's alternate fixed mode (Jani)
    - Protect tainted function pointer lookup (Chris)
      - And subsequent unsigned long size fix (Chris)
    - Allow page directory allocation to fail (Chris)
    - VBT's edp and lvds fix and clean-up (Ville)
    - Many other reorganizations and cleanups on DDI and DP code, as well on scaler and planes (Ville)
    - Selftest pin the mock kernel context (Chris)
    - Many PSR Fixes, clean-up and improvements (Dhinakaran)
    - PSR VBT fix (Vathsala)
    - Fix i915_scheduler and intel_context declaration (Tvrtko)
    - Improve PCH underruns detection on ILK-IVB (Ville)
    - Few s/drm_priv/i915 (Chris, Michal)
    - Notify opregion of the sanitized encoder state (Maarten)
    - Guc's event handling improvements and fixes on initialization failures (Michal)
    - Many gtt fixes and improvements (Chris)
    - Fixes and improvements for Suspend and Freeze safely (Chris)
    - i915_gem init and fini cleanup and fixes (Michal)
    - Remove obsolete switch_mm for gen8+ (Chris)
    - hw and context id fixes for GuC (Lionel)
    - Add new vGPU cap info bit VGT_CAPS_HUGE_GTT (Changbin)
    - Make context pin/unpin symmetric (Chris)
    - vma: Move the bind_count vs pin_count assertion to a helper (Chris)
    - Use available SZ_1M instead of 1 << 20 (Chris)
    - Trace and PMU fixes and improvements (Tvrtko)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180611162737.GA2378@intel.com

commit 8a29c778fa1a50a25a3e66cf9589888758858d24
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Wed May 23 11:04:35 2018 -0700

    drm/i915: remove check for aux irq
    
    This became dead code with commit 309bd8ed464f ("drm/i915: Reinstate
    GMBUS and AUX interrupts on gen4/g4x").
    
    v2: Move comment about HW behavior to where decision is made to enable
    MSI (Ville).
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180523180435.18042-1-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 33453d56c386..2959c88a37a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1165,6 +1165,12 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * get lost on g4x as well, and interrupt delivery seems to stay
 	 * properly dead afterwards. So we'll just disable them for all
 	 * pre-gen5 chipsets.
+	 *
+	 * dp aux and gmbus irq on gen4 seems to be able to generate legacy
+	 * interrupts even when in MSI mode. This results in spurious
+	 * interrupt warnings if the legacy irq no. is shared with another
+	 * device. The kernel then disables that interrupt source and so
+	 * prevents the other device from working properly.
 	 */
 	if (INTEL_GEN(dev_priv) >= 5) {
 		if (pci_enable_msi(pdev) < 0)

commit 4fdd5b4e9aba5fbbc6d3072a5a87fa1d3f3fc030
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Jun 16 21:25:34 2018 +0100

    drm/i915: Fix fallout of fake reset along resume
    
    commit b2209e62a450 ("drm/i915/execlists: Reset the CSB head tracking on
    reset/sanitization") and commit 1288786b18f7 ("drm/i915: Move GEM sanitize
    from resume_early to resume") show the conflicting requirements on the
    code. We must reset the GPU before trashing live state on a fast resume
    (hibernation debug, or error paths), but we must only reset our state
    tracking iff the GPU is reset (or power cycled). This is tricky if we
    are disabling GPU reset to simulate broken hardware; we reset our state
    tracking but the GPU is left intact and recovers from its stale state.
    
    v2: Again without the assertion for forcewake, no longer required since
    commit b3ee09a4de33 ("drm/i915/ringbuffer: Fix context restore upon reset")
    as the contexts are reset from the CS ensuring everything is powered up.
    
    Fixes: b2209e62a450 ("drm/i915/execlists: Reset the CSB head tracking on reset/sanitization")
    Fixes: 1288786b18f7 ("drm/i915: Move GEM sanitize from resume_early to resume")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180616202534.18767-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a9c8c66bb525..33453d56c386 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1841,6 +1841,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	else
 		intel_display_set_init_power(dev_priv, true);
 
+	intel_engines_sanitize(dev_priv);
+
 	enable_rpm_wakeref_asserts(dev_priv);
 
 out:

commit 1288786b18f7d979f1f9bcb0134ee5fbfcc8e3d1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 14 10:40:59 2018 +0100

    drm/i915: Move GEM sanitize from resume_early to resume
    
    This should be a no-op in terms of our control flow, we move the
    sanitization (GPU reset) from the bottom of the early resume phase to
    the top of the next. However, following hibernation debug, the power
    code skips the early resume phase, but as we are about to completely
    restore the GTT mappings, we first need to stop the GPU using them i.e.
    perform a GPU reset (i915_gem_sanitize()).
    
    Testcase: igt/gem_exec_suspend/basic-S4-devices
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180614094103.18025-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4cdd70de5ed0..a9c8c66bb525 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1698,6 +1698,8 @@ static int i915_drm_resume(struct drm_device *dev)
 	disable_rpm_wakeref_asserts(dev_priv);
 	intel_sanitize_gt_powersave(dev_priv);
 
+	i915_gem_sanitize(dev_priv);
+
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
@@ -1839,8 +1841,6 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	else
 		intel_display_set_init_power(dev_priv, true);
 
-	i915_gem_sanitize(dev_priv);
-
 	enable_rpm_wakeref_asserts(dev_priv);
 
 out:

commit 51c18bf7fdbe3c0546e86cb0fa5866fee07c5261
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Jun 9 12:10:58 2018 +0100

    drm/i915: Squash GEM load failure message (again)
    
    Due to a silent conflict (silent because we are trying to fix the CI
    test that is meant to exercising these failures!) between commit
    51e645b6652c ("drm/i915: Mark the GPU as wedged without error on fault
    injection") and commit 8571a05a9dd0 ("drm/i915: Use GEM suspend when
    aborting initialisation"), we failed to actually squash the error
    message after injecting the load failure.
    
    Rearrange the code to export i915_load_failure() for better logging of
    real errors (and quiet logging of injected errors).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180609111058.2660-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d258388605d6..4cdd70de5ed0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -73,6 +73,12 @@ bool __i915_inject_load_failure(const char *func, int line)
 
 	return false;
 }
+
+bool i915_error_injected(void)
+{
+	return i915_load_fail_count && !i915_modparams.inject_load_failure;
+}
+
 #endif
 
 #define FDO_BUG_URL "https://bugs.freedesktop.org/enter_bug.cgi?product=DRI"
@@ -115,20 +121,6 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	va_end(args);
 }
 
-static bool i915_error_injected(struct drm_i915_private *dev_priv)
-{
-#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
-	return i915_load_fail_count && !i915_modparams.inject_load_failure;
-#else
-	return false;
-#endif
-}
-
-#define i915_load_error(i915, fmt, ...)					 \
-	__i915_printk(i915,						 \
-		      i915_error_injected(i915) ? KERN_DEBUG : KERN_ERR, \
-		      fmt, ##__VA_ARGS__)
-
 /* Map PCH device id to PCH type, or PCH_NONE if unknown. */
 static enum intel_pch
 intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)

commit 07ba0a82536e4955682b3b9077957ae1421d94bf
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Jun 8 15:33:30 2018 +0300

    drm/i915: fix PCH_NOP setting for non-PCH platforms
    
    Setting PCH type to PCH_NOP before checking whether we actually have a
    PCH ends up returning true for HAS_PCH_SPLIT() on all non-PCH split
    platforms. Fix this by using PCH_NOP only for platforms that actually
    have a PCH.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180608123330.31003-6-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9aba419e5d8b..d258388605d6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -248,14 +248,6 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 {
 	struct pci_dev *pch = NULL;
 
-	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
-	 * (which really amounts to a PCH but no South Display).
-	 */
-	if (INTEL_INFO(dev_priv)->num_pipes == 0) {
-		dev_priv->pch_type = PCH_NOP;
-		return;
-	}
-
 	/*
 	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
 	 * make graphics device passthrough work easy for VMM, that only
@@ -295,6 +287,17 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			break;
 		}
 	}
+
+	/*
+	 * Use PCH_NOP (PCH but no South Display) for PCH platforms without
+	 * display.
+	 */
+	if (pch && INTEL_INFO(dev_priv)->num_pipes == 0) {
+		DRM_DEBUG_KMS("Display disabled, reverting to NOP PCH\n");
+		dev_priv->pch_type = PCH_NOP;
+		dev_priv->pch_id = 0;
+	}
+
 	if (!pch)
 		DRM_DEBUG_KMS("No PCH found.\n");
 

commit 85b17e6e4d3f288cc757ff5407b2ca6604673d74
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Jun 8 15:33:28 2018 +0300

    drm/i915: clean up virtual PCH special case handling
    
    Use intel_pch_type() also for mapping the no PCH case (PCH id 0) to
    PCH_NONE to simplify code.
    
    Also make sure that intel_pch_type() knows all the PCH ids returned by
    intel_virt_detect_pch(). Loudly fail if this isn't the case; this
    shouldn't happen anyway.
    
    Cc: Colin Xu <Colin.Xu@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Colin Xu <Colin.Xu@intel.com>
    Reviewed-by: Colin Xu <Colin.Xu@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180608123330.31003-4-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8f22ae8925fc..9aba419e5d8b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -284,13 +284,12 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 		} else if (intel_is_virt_pch(id, pch->subsystem_vendor,
 					 pch->subsystem_device)) {
 			id = intel_virt_detect_pch(dev_priv);
-			if (id) {
-				pch_type = intel_pch_type(dev_priv, id);
-				if (WARN_ON(pch_type == PCH_NONE))
-					pch_type = PCH_NOP;
-			} else {
-				pch_type = PCH_NONE;
-			}
+			pch_type = intel_pch_type(dev_priv, id);
+
+			/* Sanity check virtual PCH id */
+			if (WARN_ON(id && pch_type == PCH_NONE))
+				id = 0;
+
 			dev_priv->pch_type = pch_type;
 			dev_priv->pch_id = id;
 			break;

commit 78ef3faff9ea557e54b053234b6c9461d3ea183f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Jun 8 15:33:26 2018 +0300

    drm/i915: fix guest virtual PCH detection on non-PCH systems
    
    Virtualized non-PCH systems such as Broxton or Geminilake should use
    PCH_NONE to indicate no PCH rather than PCH_NOP. The latter is a
    specific case to indicate a PCH system without south display.
    
    Reported-by: Colin Xu <Colin.Xu@intel.com>
    Cc: Colin Xu <Colin.Xu@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Colin Xu <Colin.Xu@intel.com>
    Reviewed-by: Colin Xu <Colin.Xu@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180608123330.31003-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0a1b09bb658f..8f22ae8925fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -289,7 +289,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				if (WARN_ON(pch_type == PCH_NONE))
 					pch_type = PCH_NOP;
 			} else {
-				pch_type = PCH_NOP;
+				pch_type = PCH_NONE;
 			}
 			dev_priv->pch_type = pch_type;
 			dev_priv->pch_id = id;

commit cf68f0c3a07b092bca92e7b4f1b3893ab454bd38
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jun 6 15:41:53 2018 +0100

    drm/i915: Mark i915.inject_load_failure as being hit
    
    When we reach the magic value and do inject a fault into our module load,
    mark the module option as being hit. Since we fail from inside pci
    probe, the module load isn't actually aborted and the module (and
    parameters) are left lingering. igt can then inspect the parameter on its
    synchronous completion of modprobe to see if the fault injection was
    successful, and will keeping on injecting new faults until the module
    succeeds in loading having surpassed the number of fault points.
    
    v2: Reset to 0 after being hit;
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180606144153.4244-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83ce9c1ec170..0a1b09bb658f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -67,6 +67,7 @@ bool __i915_inject_load_failure(const char *func, int line)
 	if (++i915_load_fail_count == i915_modparams.inject_load_failure) {
 		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
 			 i915_modparams.inject_load_failure, func, line);
+		i915_modparams.inject_load_failure = 0;
 		return true;
 	}
 
@@ -117,16 +118,15 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 static bool i915_error_injected(struct drm_i915_private *dev_priv)
 {
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
-	return i915_modparams.inject_load_failure &&
-	       i915_load_fail_count == i915_modparams.inject_load_failure;
+	return i915_load_fail_count && !i915_modparams.inject_load_failure;
 #else
 	return false;
 #endif
 }
 
-#define i915_load_error(dev_priv, fmt, ...)				     \
-	__i915_printk(dev_priv,						     \
-		      i915_error_injected(dev_priv) ? KERN_DEBUG : KERN_ERR, \
+#define i915_load_error(i915, fmt, ...)					 \
+	__i915_printk(i915,						 \
+		      i915_error_injected(i915) ? KERN_DEBUG : KERN_ERR, \
 		      fmt, ##__VA_ARGS__)
 
 /* Map PCH device id to PCH type, or PCH_NONE if unknown. */

commit 8979187a8cfa1fd221a17a06a9ce76e72ae52a05
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Mon Jun 4 09:00:32 2018 +0000

    drm/i915: Move i915_gem_fini to i915_gem.c
    
    We should keep i915_gem_init/fini functions together for easier
    tracking of their symmetry.
    
    v2: rebased, pulled out from the series
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180604090032.20840-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 915758a65c96..83ce9c1ec170 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -636,28 +636,6 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 	.can_switch = i915_switcheroo_can_switch,
 };
 
-static void i915_gem_fini(struct drm_i915_private *dev_priv)
-{
-	i915_gem_suspend_late(dev_priv);
-
-	/* Flush any outstanding unpin_work. */
-	i915_gem_drain_workqueue(dev_priv);
-
-	mutex_lock(&dev_priv->drm.struct_mutex);
-	intel_uc_fini_hw(dev_priv);
-	intel_uc_fini(dev_priv);
-	i915_gem_cleanup_engines(dev_priv);
-	i915_gem_contexts_fini(dev_priv);
-	mutex_unlock(&dev_priv->drm.struct_mutex);
-
-	intel_uc_fini_misc(dev_priv);
-	i915_gem_cleanup_userptr(dev_priv);
-
-	i915_gem_drain_freed_objects(dev_priv);
-
-	WARN_ON(!list_empty(&dev_priv->contexts.list));
-}
-
 static int i915_load_modeset_init(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);

commit f17ca5010c34e99e4035f22437f8b83452584a26
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Mon May 21 17:25:43 2018 -0700

    drm/i915/icl: Add Icelake PCH detection
    
    This patch adds the support to detect PCH_ICP.
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Suggested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180522002558.29262-10-paulo.r.zanoni@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fe92665c8482..915758a65c96 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -233,6 +233,8 @@ intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 		id = INTEL_PCH_SPT_DEVICE_ID_TYPE;
 	else if (IS_COFFEELAKE(dev_priv) || IS_CANNONLAKE(dev_priv))
 		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;
+	else if (IS_ICELAKE(dev_priv))
+		id = INTEL_PCH_ICP_DEVICE_ID_TYPE;
 
 	if (id)
 		DRM_DEBUG_KMS("Assuming PCH ID %04x\n", id);

commit ec92ad00a393d07f7f6c1c9a0ff65141f2173050
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu May 31 09:22:46 2018 +0100

    drm/i915: Only sanitize GEM from late suspend
    
    During testing we encounter a conflict between SUSPEND_TEST_DEVICES and
    disabling reset (gem_eio/suspend). This results in the device continuing
    on without being reset, but since it has gone through HW sanitization to
    account for the suspend/resume cycle, we have to assume the device has
    been reset to its defaults. A simple way around this is to skip the
    sanitize phase for SUSPEND_TEST_DEVICES by moving it to suspend-late.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180531082246.9763-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fb39e40c0847..fe92665c8482 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -636,6 +636,8 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
+	i915_gem_suspend_late(dev_priv);
+
 	/* Flush any outstanding unpin_work. */
 	i915_gem_drain_workqueue(dev_priv);
 
@@ -1611,7 +1613,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
 	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
 
-	intel_uncore_suspend(dev_priv);
 	intel_opregion_unregister(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
@@ -1633,7 +1634,10 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
+	i915_gem_suspend_late(dev_priv);
+
 	intel_display_set_init_power(dev_priv, false);
+	intel_uncore_suspend(dev_priv);
 
 	/*
 	 * In case of firmware assisted context save/restore don't manually

commit 73b66f8731573a5fa74799dfabb4cdfe513b9241
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri May 25 10:26:29 2018 +0100

    drm/i915: Prepare GEM for suspend earlier
    
    In order to prepare the GPU for sleeping, we may want to submit commands
    to it. This is a complicated process that may even require some swapping
    in from shmemfs, if the GPU was in the wrong state. As such, we need to
    do this preparation step synchronously before the rest of the system has
    started to turn off (e.g. swapin fails if scsi is suspended).
    Fortunately, we are provided with a such a hook, pm_ops.prepare().
    
    v2: Compile cleanup
    v3: Fewer asserts, fewer problems?
    
    v4: Ville pointed out that in some circumstances (such as switching off
    the overlay) the display code may issue a GPU request. This is
    unexpected, and will result in us going to sleep with us believing the
    GPU is still awake (though all user work has been saved). Add a comment
    to remind our future selves of what trouble brews.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=106640
    Testcase: igt/drv_suspend after igt/gem_tiled_swapping
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180525092629.1456-1-chris@chris-wilson.co.uk
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2a96d082addf..fb39e40c0847 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1553,12 +1553,30 @@ static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 	return false;
 }
 
+static int i915_drm_prepare(struct drm_device *dev)
+{
+	struct drm_i915_private *i915 = to_i915(dev);
+	int err;
+
+	/*
+	 * NB intel_display_suspend() may issue new requests after we've
+	 * ostensibly marked the GPU as ready-to-sleep here. We need to
+	 * split out that work and pull it forward so that after point,
+	 * the GPU is not woken again.
+	 */
+	err = i915_gem_suspend(i915);
+	if (err)
+		dev_err(&i915->drm.pdev->dev,
+			"GEM idle failed, suspend/resume might fail\n");
+
+	return err;
+}
+
 static int i915_drm_suspend(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	pci_power_t opregion_target_state;
-	int error;
 
 	/* ignore lid events during suspend */
 	mutex_lock(&dev_priv->modeset_restore_lock);
@@ -1575,13 +1593,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	pci_save_state(pdev);
 
-	error = i915_gem_suspend(dev_priv);
-	if (error) {
-		dev_err(&pdev->dev,
-			"GEM idle failed, resume might fail\n");
-		goto out;
-	}
-
 	intel_display_suspend(dev);
 
 	intel_dp_mst_suspend(dev);
@@ -1609,10 +1620,9 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_csr_ucode_suspend(dev_priv);
 
-out:
 	enable_rpm_wakeref_asserts(dev_priv);
 
-	return error;
+	return 0;
 }
 
 static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
@@ -2081,6 +2091,22 @@ int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
 	return ret;
 }
 
+static int i915_pm_prepare(struct device *kdev)
+{
+	struct pci_dev *pdev = to_pci_dev(kdev);
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	if (!dev) {
+		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
+
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
+	return i915_drm_prepare(dev);
+}
+
 static int i915_pm_suspend(struct device *kdev)
 {
 	struct pci_dev *pdev = to_pci_dev(kdev);
@@ -2731,6 +2757,7 @@ const struct dev_pm_ops i915_pm_ops = {
 	 * S0ix (via system suspend) and S3 event handlers [PMSG_SUSPEND,
 	 * PMSG_RESUME]
 	 */
+	.prepare = i915_pm_prepare,
 	.suspend = i915_pm_suspend,
 	.suspend_late = i915_pm_suspend_late,
 	.resume_early = i915_pm_resume_early,

commit b8a71080ad288eb3fe42f101e64526cdd2823f93
Merge: 2045b22461c0 01f83786f9ab
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 16 07:10:13 2018 +1000

    Merge tag 'drm-intel-next-2018-05-14' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Last drm/i915 changes for v4.18:
    
    - NV12 enabling (Chandra, Maarten)
    - ICL workarounds (Oscar)
    - ICL basic DPLL enabling (Paulo)
    - GVT updates
    - DP link config refactoring (Jani)
    - Module parameter to override DMC firmware (Jani)
    - PSR updates (José, DK, Daniel, Ville)
    - ICL DP vswing programming (Manasi)
    - ICL DBuf slice updates (Mahesh)
    - Selftest fixes and updates (Chris, Matthew, Oscar)
    - Execlist fixes and updates (Chris)
    - Stolen memory first 4k fix (Hans de Goede)
    - wait_for fixes (Mika)
    - Tons of GEM improvements (Chris)
    - Plenty of other fixes and improvements (Everyone)
    - Crappy changelog (Me)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Mon 14 May 2018 11:04:24 PM AEST
    # gpg:                using RSA key D398079D26ABEE6F
    # gpg: Good signature from "Jani Nikula <jani.nikula@intel.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 1565 A65B 77B0 632E 1124  E59C D398 079D 26AB EE6F
    
    # Conflicts:
    #       drivers/gpu/drm/i915/intel_lrc.c
    #       drivers/gpu/drm/i915/intel_sprite.c
    Link: https://patchwork.freedesktop.org/patch/msgid/87k1s51bvw.fsf@intel.com

commit 94cc2fde365fb4484080ea6675bb1e0c933f8002
Merge: 900aa8ad2158 8eb008c80841
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri May 11 18:08:10 2018 +0200

    Merge remote-tracking branch 'drm/drm-next' into drm-misc-next
    
    drm-misc-next is still based on v4.16-rc7, and was getting a bit stale.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

commit 4e8507ba774f1fe5cd0c26a7cafc09afb8a6ba8e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun May 6 19:31:47 2018 +0100

    drm/i915: Don't request a bug report for unsafe module parameters
    
    Unsafe module parameters are just that, unsafe. If the user is foolish
    enough to try them and the kernel breaks, they get to keep both pieces.
    Don't ask them to file a bug report if they broke it themselves.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=106423
    Fixes: d15d7538c6d2 ("drm/i915: Tune down init error message due to failure injection")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180506183147.2690-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c2986849236..2a96d082addf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -101,7 +101,13 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 		   __builtin_return_address(0), &vaf);
 
 	if (is_error && !shown_bug_once) {
-		dev_notice(kdev, "%s", FDO_BUG_MSG);
+		/*
+		 * Ask the user to file a bug report for the error, except
+		 * if they may have caused the bug by fiddling with unsafe
+		 * module parameters.
+		 */
+		if (!test_taint(TAINT_USER))
+			dev_notice(kdev, "%s", FDO_BUG_MSG);
 		shown_bug_once = true;
 	}
 

commit 8eb008c80841e3410ef2c043093478ea36bb5ff1
Merge: 0ab390262c49 fadec6eefe23
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 4 10:31:10 2018 +1000

    Merge tag 'drm-intel-next-2018-04-13' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    First drm/i915 feature batch heading for v4.18:
    
    - drm-next backmerge to fix build (Rodrigo)
    - GPU documentation improvements (Kevin)
    - GuC and HuC refactoring, host/GuC communication, logging, fixes, and more
      (mostly Michal and Michał, also Jackie, Michel and Piotr)
    - PSR and PSR2 enabling and fixes (DK, José, Rodrigo and Chris)
    - Selftest updates (Chris, Daniele)
    - DPLL management refactoring (Lucas)
    - DP MST fixes (Lyude and DK)
    - Watermark refactoring and changes to support NV12 (Mahesh)
    - NV12 prep work (Chandra)
    - Icelake Combo PHY enablers (Manasi)
    - Perf OA refactoring and ICL enabling (Lionel)
    - ICL enabling (Oscar, Paulo, Nabendu, Mika, Kelvin, Michel)
    - Workarounds refactoring (Oscar)
    - HDCP fixes and improvements (Ramalingam, Radhakrishna)
    - Power management fixes (Imre)
    - Various display fixes (Maarten, Ville, Vidya, Jani, Gaurav)
    - debugfs for FIFO underrun clearing (Maarten)
    - Execlist improvements (Chris)
    - Reset improvements (Chris)
    - Plenty of things here and there I overlooked and/or didn't understand... (Everyone)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/87lgd2cze8.fsf@intel.com

commit 0cd54b039537767cc12c4d7b6a62a98d01d99403
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 20 08:51:57 2018 +0200

    drm/i915: Drop DRM_CONTROL_ALLOW
    
    Control nodes are no more!
    
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20180420065159.4531-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 07c07d55398b..154414832d86 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2816,10 +2816,10 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_GET_APERTURE, i915_gem_get_aperture_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(I915_GEM_MADVISE, i915_gem_madvise_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_OVERLAY_PUT_IMAGE, intel_overlay_put_image_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_OVERLAY_PUT_IMAGE, intel_overlay_put_image_ioctl, DRM_MASTER),
+	DRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER),
+	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER),
+	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER),
 	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_DESTROY, i915_gem_context_destroy_ioctl, DRM_RENDER_ALLOW),

commit e01569ab962145b2fb46f6240bf1f07ec3a6261a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Apr 9 10:49:05 2018 +0100

    drm/i915: Silence debugging DRM_ERROR for failing to suspend vlv powerwells
    
    If we try to suspend a wedged device following a GPU reset failure, we
    will also fail to turn off the rc6 powerwells (on vlv), leading to a
    *ERROR*. This is quite expected in this case, so the best we can do is
    shake our heads and reduce the *ERROR* to a debug so CI stops
    complaining.
    
    Testcase: igt/gem_eio/in-flight-suspend #vlv
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=105583
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180409094905.4516-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b7dbeba72dec..8c2986849236 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2468,10 +2468,13 @@ static void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 	/*
 	 * RC6 transitioning can be delayed up to 2 msec (see
 	 * valleyview_enable_rps), use 3 msec for safety.
+	 *
+	 * This can fail to turn off the rc6 if the GPU is stuck after a failed
+	 * reset and we are trying to force the machine to sleep.
 	 */
 	if (vlv_wait_for_pw_status(dev_priv, mask, val))
-		DRM_ERROR("timeout waiting for GT wells to go %s\n",
-			  onoff(wait_for_on));
+		DRM_DEBUG_DRIVER("timeout waiting for GT wells to go %s\n",
+				 onoff(wait_for_on));
 }
 
 static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)

commit 53f071e19d566e7d0a4eada1bd8313a4cdb660a4
Merge: 043477b088d2 0ab390262c49
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 2 12:20:32 2018 +0300

    Merge drm/drm-next into drm-intel-next-queued
    
    Need d224985a5e31 ("sched/wait, drivers/drm: Convert wait_on_atomic_t()
    usage to the new wait_var_event() API") in dinq to be able to fix
    https://bugs.freedesktop.org/show_bug.cgi?id=106085.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 867ab4b2fcc3f840e9cc378a812e07f850795e6f
Merge: 5ec83b22a2dd 221bda4b5f1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 22 17:14:29 2018 -0700

    Merge tag 'drm-fixes-for-v4.17-rc2' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm fixes from Dave Airlie:
     "Exynos, i915, vc4, amdgpu fixes.
    
      i915:
       - an oops fix
       - two race fixes
       - some gvt fixes
    
      amdgpu:
       - dark screen fix
       - clk/voltage fix
       - vega12 smu fix
    
      vc4:
       - memory leak fix
    
      exynos just drops some code"
    
    * tag 'drm-fixes-for-v4.17-rc2' of git://people.freedesktop.org/~airlied/linux: (23 commits)
      drm/amd/powerplay: header file interface to SMU update
      drm/amd/pp: Fix bug voltage can't be OD separately on VI
      drm/amd/display: Don't program bypass on linear regamma LUT
      drm/i915: Fix LSPCON TMDS output buffer enabling from low-power state
      drm/i915/audio: Fix audio detection issue on GLK
      drm/i915: Call i915_perf_fini() on init_hw error unwind
      drm/i915/bios: filter out invalid DDC pins from VBT child devices
      drm/i915/pmu: Inspect runtime PM state more carefully while estimating RC6
      drm/i915: Do no use kfree() to free a kmem_cache_alloc() return value
      drm/exynos: exynos_drm_fb -> drm_framebuffer
      drm/exynos: Move dma_addr out of exynos_drm_fb
      drm/exynos: Move GEM BOs to drm_framebuffer
      drm: Fix HDCP downstream dev count read
      drm/vc4: Fix memory leak during BO teardown
      drm/i915/execlists: Clear user-active flag on preemption completion
      drm/i915/gvt: Add drm_format_mod update
      drm/i915/gvt: Disable primary/sprite/cursor plane at virtual display initialization
      drm/i915/gvt: Delete redundant error message in fb_decode.c
      drm/i915/gvt: Cancel dma map when resetting ggtt entries
      drm/i915/gvt: Missed to cancel dma map for ggtt entries
      ...

commit 4a0559ed99189f259e92ed34f60dd51688f1bc40
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Apr 14 10:12:33 2018 +0100

    drm/i915: Call i915_perf_fini() on init_hw error unwind
    
    We have to cleanup after i915_perf_init(), even on the error path, as it
    passes a pointer into the module to the sysfs core. If we fail to
    unregister the sysctl table, we leave a dangling pointer which then may
    explode anytime later.
    
    Fixes: 9f9b2792b6d3 ("drm/i915/perf: reuse timestamp frequency from device info")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180414091233.32224-1-chris@chris-wilson.co.uk
    (cherry picked from commit 9f172f6fbd243759c808d97bd83c95e49325b2c9)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 07c07d55398b..be8555049c93 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1102,30 +1102,32 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	ret = i915_ggtt_probe_hw(dev_priv);
 	if (ret)
-		return ret;
+		goto err_perf;
 
-	/* WARNING: Apparently we must kick fbdev drivers before vgacon,
-	 * otherwise the vga fbdev driver falls over. */
+	/*
+	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
+	 * otherwise the vga fbdev driver falls over.
+	 */
 	ret = i915_kick_out_firmware_fb(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to remove conflicting framebuffer drivers\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	ret = i915_kick_out_vgacon(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to remove conflicting VGA console\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	ret = i915_ggtt_init_hw(dev_priv);
 	if (ret)
-		return ret;
+		goto err_ggtt;
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to enable GGTT\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	pci_set_master(pdev);
@@ -1136,7 +1138,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto out_ggtt;
+			goto err_ggtt;
 		}
 	}
 
@@ -1154,7 +1156,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto out_ggtt;
+			goto err_ggtt;
 		}
 	}
 
@@ -1187,13 +1189,14 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	ret = intel_gvt_init(dev_priv);
 	if (ret)
-		goto out_ggtt;
+		goto err_ggtt;
 
 	return 0;
 
-out_ggtt:
+err_ggtt:
 	i915_ggtt_cleanup_hw(dev_priv);
-
+err_perf:
+	i915_perf_fini(dev_priv);
 	return ret;
 }
 

commit 9f172f6fbd243759c808d97bd83c95e49325b2c9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Apr 14 10:12:33 2018 +0100

    drm/i915: Call i915_perf_fini() on init_hw error unwind
    
    We have to cleanup after i915_perf_init(), even on the error path, as it
    passes a pointer into the module to the sysfs core. If we fail to
    unregister the sysctl table, we leave a dangling pointer which then may
    explode anytime later.
    
    Fixes: 9f9b2792b6d3 ("drm/i915/perf: reuse timestamp frequency from device info")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180414091233.32224-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f770be18b2d7..840020681985 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1101,30 +1101,32 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	ret = i915_ggtt_probe_hw(dev_priv);
 	if (ret)
-		return ret;
+		goto err_perf;
 
-	/* WARNING: Apparently we must kick fbdev drivers before vgacon,
-	 * otherwise the vga fbdev driver falls over. */
+	/*
+	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
+	 * otherwise the vga fbdev driver falls over.
+	 */
 	ret = i915_kick_out_firmware_fb(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to remove conflicting framebuffer drivers\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	ret = i915_kick_out_vgacon(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to remove conflicting VGA console\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	ret = i915_ggtt_init_hw(dev_priv);
 	if (ret)
-		return ret;
+		goto err_ggtt;
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to enable GGTT\n");
-		goto out_ggtt;
+		goto err_ggtt;
 	}
 
 	pci_set_master(pdev);
@@ -1135,7 +1137,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto out_ggtt;
+			goto err_ggtt;
 		}
 	}
 
@@ -1153,7 +1155,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
-			goto out_ggtt;
+			goto err_ggtt;
 		}
 	}
 
@@ -1186,13 +1188,14 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	ret = intel_gvt_init(dev_priv);
 	if (ret)
-		goto out_ggtt;
+		goto err_ggtt;
 
 	return 0;
 
-out_ggtt:
+err_ggtt:
 	i915_ggtt_cleanup_hw(dev_priv);
-
+err_perf:
+	i915_perf_fini(dev_priv);
 	return ret;
 }
 

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit d0667e9ce52eb2d5d32db4f16976226e78f88784
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 6 23:03:54 2018 +0100

    drm/i915: Pass the set of guilty engines to i915_reset()
    
    Currently, we rely on inspecting the hangcheck state from within the
    i915_reset() routines to determine which engines were guilty of the
    hang. This is problematic for cases where we want to run
    i915_handle_error() and call i915_reset() independently of hangcheck.
    Instead of relying on the indirect parameter passing, turn it into an
    explicit parameter providing the set of stalled engines which then are
    treated as guilty until proven innocent.
    
    While we are removing the implicit stalled parameter, also make the
    reason into an explicit parameter to i915_reset(). We still need a
    back-channel for i915_handle_error() to hand over the task to the locked
    waiter, but let's keep that its own channel rather than incriminate
    another.
    
    This leaves stalled/seqno as being private to hangcheck, with no more
    nefarious snooping by reset, be it whole-device or per-engine. \o/
    
    The only real issue now is that this makes it crystal clear that we
    don't actually do any testing of hangcheck per se in
    drv_selftest/live_hangcheck, merely of resets!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180406220354.18911-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7ce229c6f424..f770be18b2d7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1866,6 +1866,8 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 /**
  * i915_reset - reset chip after a hang
  * @i915: #drm_i915_private to reset
+ * @stalled_mask: mask of the stalled engines with the guilty requests
+ * @reason: user error message for why we are resetting
  *
  * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
  * on failure.
@@ -1880,7 +1882,9 @@ static int i915_resume_switcheroo(struct drm_device *dev)
  *   - re-init interrupt state
  *   - re-init display
  */
-void i915_reset(struct drm_i915_private *i915)
+void i915_reset(struct drm_i915_private *i915,
+		unsigned int stalled_mask,
+		const char *reason)
 {
 	struct i915_gpu_error *error = &i915->gpu_error;
 	int ret;
@@ -1899,9 +1903,8 @@ void i915_reset(struct drm_i915_private *i915)
 	if (!i915_gem_unset_wedged(i915))
 		goto wakeup;
 
-	if (error->reason)
-		dev_notice(i915->drm.dev,
-			   "Resetting chip for %s\n", error->reason);
+	if (reason)
+		dev_notice(i915->drm.dev, "Resetting chip for %s\n", reason);
 	error->reset_count++;
 
 	disable_irq(i915->drm.irq);
@@ -1944,7 +1947,7 @@ void i915_reset(struct drm_i915_private *i915)
 		goto error;
 	}
 
-	i915_gem_reset(i915);
+	i915_gem_reset(i915, stalled_mask);
 	intel_overlay_reset(i915);
 
 	/*

commit bba0869b18e44ff2f713c98575ddad8c7c5e9b10
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 6 23:03:53 2018 +0100

    drm/i915: Treat i915_reset_engine() as guilty until proven innocent
    
    If we are resetting just one engine, we know it has stalled. So we can
    pass the stalled parameter directly to i915_gem_reset_engine(), which
    alleviates the necessity to poke at the generic engine->hangcheck.stalled
    magic variable, leaving that under control of hangcheck as its name
    implies. Other than simplifying by removing the indirect parameter along
    this path, this allows us to introduce new reset mechanisms that run
    independently of hangcheck.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180406220354.18911-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 684060ed8db6..7ce229c6f424 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2050,7 +2050,7 @@ int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
 	 * active request and can drop it, adjust head to skip the offending
 	 * request to resume executing remaining requests in the queue.
 	 */
-	i915_gem_reset_engine(engine, active_request);
+	i915_gem_reset_engine(engine, active_request, true);
 
 	/*
 	 * The engine and its registers (and workarounds in case of render)

commit 028666793a0291b63eb61bae7252345821326a1b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 30 14:18:01 2018 +0100

    drm/i915/selftests: Avoid repeatedly harming the same innocent context
    
    We don't handle resetting the kernel context very well, or presumably any
    context executing its breadcrumb commands in the ring as opposed to the
    batchbuffer and flush. If we trigger a device reset twice in quick
    succession while the kernel context is executing, we may end up skipping
    the breadcrumb.  This is really only a problem for the selftest as
    normally there is a large interlude between resets (hangcheck), or we
    focus on resetting just one engine and so avoid repeatedly resetting
    innocents.
    
    Something to try would be a preempt-to-idle to quiesce the engine before
    reset, so that innocent contexts would be spared the reset.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    CC: Michel Thierry <michel.thierry@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180330131801.18327-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d354627882e3..684060ed8db6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1886,6 +1886,8 @@ void i915_reset(struct drm_i915_private *i915)
 	int ret;
 	int i;
 
+	GEM_TRACE("flags=%lx\n", error->flags);
+
 	might_sleep();
 	lockdep_assert_held(&i915->drm.struct_mutex);
 	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
@@ -2016,6 +2018,7 @@ int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
 	struct i915_request *active_request;
 	int ret;
 
+	GEM_TRACE("%s flags=%lx\n", engine->name, error->flags);
 	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
 
 	active_request = i915_gem_reset_prepare_engine(engine);

commit 300efa9eea451bdcf3b5a1eb292222e06e85bb2c
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Mar 22 16:36:42 2018 +0200

    drm/i915: Fix hibernation with ACPI S0 target state
    
    After
    
    commit dd9f31c7a3887950cbd0d49eb9d43f7a1518a356
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Aug 16 17:46:07 2017 +0300
    
        drm/i915/gen9+: Set same power state before hibernation image
        save/restore
    
    during hibernation/suspend the power domain functionality got disabled,
    after which resume could leave it incorrectly disabled if the ACPI
    target state was S0 during suspend and i915 was not loaded by the loader
    kernel.
    
    This was caused by not considering if we resumed from hibernation as the
    condition for power domains reiniting.
    
    Fix this by simply tracking if we suspended power domains during system
    suspend and reinit power domains accordingly during resume. This will
    result in reiniting power domains always when resuming from hibernation,
    regardless of the platform and whether or not i915 is loaded by the
    loader kernel.
    
    The reason we didn't catch this earlier is that the enabled/disabled
    state of power domains during PMSG_FREEZE/PMSG_QUIESCE is platform
    and kernel config dependent: on my SKL the target state is S4
    during PMSG_FREEZE and (with the driver loaded in the loader kernel)
    S0 during PMSG_QUIESCE. On the reporter's machine it's S0 during
    PMSG_FREEZE but (contrary to this) power domains are not initialized
    during PMSG_QUIESCE since i915 is not loaded in the loader kernel, or
    it's loaded but without the DMC firmware being available.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=105196
    Reported-and-tested-by: amn-bas@hotmail.com
    Fixes: dd9f31c7a388 ("drm/i915/gen9+: Set same power state before hibernation image save/restore")
    Cc: amn-bas@hotmail.com
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180322143642.26883-1-imre.deak@intel.com
    (cherry picked from commit 0f90603c33bdf6575cfdc81edd53f3f13ba166fb)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d7c4de45644d..07c07d55398b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1611,15 +1611,12 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
-	bool fw_csr;
 	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
 	intel_display_set_init_power(dev_priv, false);
 
-	fw_csr = !IS_GEN9_LP(dev_priv) && !hibernation &&
-		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
 	 * deinit the power domains. This also means the CSR/DMC firmware will
@@ -1627,8 +1624,11 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	 * also enable deeper system power states that would be blocked if the
 	 * firmware was inactive.
 	 */
-	if (!fw_csr)
+	if (IS_GEN9_LP(dev_priv) || hibernation || !suspend_to_idle(dev_priv) ||
+	    dev_priv->csr.dmc_payload == NULL) {
 		intel_power_domains_suspend(dev_priv);
+		dev_priv->power_domains_suspended = true;
+	}
 
 	ret = 0;
 	if (IS_GEN9_LP(dev_priv))
@@ -1640,8 +1640,10 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
-		if (!fw_csr)
+		if (dev_priv->power_domains_suspended) {
 			intel_power_domains_init_hw(dev_priv, true);
+			dev_priv->power_domains_suspended = false;
+		}
 
 		goto out;
 	}
@@ -1662,8 +1664,6 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	if (!(hibernation && INTEL_GEN(dev_priv) < 6))
 		pci_set_power_state(pdev, PCI_D3hot);
 
-	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
-
 out:
 	enable_rpm_wakeref_asserts(dev_priv);
 
@@ -1830,8 +1830,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	intel_uncore_resume_early(dev_priv);
 
 	if (IS_GEN9_LP(dev_priv)) {
-		if (!dev_priv->suspended_to_idle)
-			gen9_sanitize_dc_state(dev_priv);
+		gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		hsw_disable_pc8(dev_priv);
@@ -1839,8 +1838,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_sanitize(dev_priv);
 
-	if (IS_GEN9_LP(dev_priv) ||
-	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
+	if (dev_priv->power_domains_suspended)
 		intel_power_domains_init_hw(dev_priv, true);
 	else
 		intel_display_set_init_power(dev_priv, true);
@@ -1850,7 +1848,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	enable_rpm_wakeref_asserts(dev_priv);
 
 out:
-	dev_priv->suspended_to_idle = false;
+	dev_priv->power_domains_suspended = false;
 
 	return ret;
 }

commit 0f90603c33bdf6575cfdc81edd53f3f13ba166fb
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Mar 22 16:36:42 2018 +0200

    drm/i915: Fix hibernation with ACPI S0 target state
    
    After
    
    commit dd9f31c7a3887950cbd0d49eb9d43f7a1518a356
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Aug 16 17:46:07 2017 +0300
    
        drm/i915/gen9+: Set same power state before hibernation image
        save/restore
    
    during hibernation/suspend the power domain functionality got disabled,
    after which resume could leave it incorrectly disabled if the ACPI
    target state was S0 during suspend and i915 was not loaded by the loader
    kernel.
    
    This was caused by not considering if we resumed from hibernation as the
    condition for power domains reiniting.
    
    Fix this by simply tracking if we suspended power domains during system
    suspend and reinit power domains accordingly during resume. This will
    result in reiniting power domains always when resuming from hibernation,
    regardless of the platform and whether or not i915 is loaded by the
    loader kernel.
    
    The reason we didn't catch this earlier is that the enabled/disabled
    state of power domains during PMSG_FREEZE/PMSG_QUIESCE is platform
    and kernel config dependent: on my SKL the target state is S4
    during PMSG_FREEZE and (with the driver loaded in the loader kernel)
    S0 during PMSG_QUIESCE. On the reporter's machine it's S0 during
    PMSG_FREEZE but (contrary to this) power domains are not initialized
    during PMSG_QUIESCE since i915 is not loaded in the loader kernel, or
    it's loaded but without the DMC firmware being available.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=105196
    Reported-and-tested-by: amn-bas@hotmail.com
    Fixes: dd9f31c7a388 ("drm/i915/gen9+: Set same power state before hibernation image save/restore")
    Cc: amn-bas@hotmail.com
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180322143642.26883-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index db223378d84b..d354627882e3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1607,15 +1607,12 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
-	bool fw_csr;
 	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
 	intel_display_set_init_power(dev_priv, false);
 
-	fw_csr = !IS_GEN9_LP(dev_priv) && !hibernation &&
-		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
 	 * deinit the power domains. This also means the CSR/DMC firmware will
@@ -1623,8 +1620,11 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	 * also enable deeper system power states that would be blocked if the
 	 * firmware was inactive.
 	 */
-	if (!fw_csr)
+	if (IS_GEN9_LP(dev_priv) || hibernation || !suspend_to_idle(dev_priv) ||
+	    dev_priv->csr.dmc_payload == NULL) {
 		intel_power_domains_suspend(dev_priv);
+		dev_priv->power_domains_suspended = true;
+	}
 
 	ret = 0;
 	if (IS_GEN9_LP(dev_priv))
@@ -1636,8 +1636,10 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
-		if (!fw_csr)
+		if (dev_priv->power_domains_suspended) {
 			intel_power_domains_init_hw(dev_priv, true);
+			dev_priv->power_domains_suspended = false;
+		}
 
 		goto out;
 	}
@@ -1658,8 +1660,6 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	if (!(hibernation && INTEL_GEN(dev_priv) < 6))
 		pci_set_power_state(pdev, PCI_D3hot);
 
-	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
-
 out:
 	enable_rpm_wakeref_asserts(dev_priv);
 
@@ -1826,8 +1826,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	intel_uncore_resume_early(dev_priv);
 
 	if (IS_GEN9_LP(dev_priv)) {
-		if (!dev_priv->suspended_to_idle)
-			gen9_sanitize_dc_state(dev_priv);
+		gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		hsw_disable_pc8(dev_priv);
@@ -1835,8 +1834,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_sanitize(dev_priv);
 
-	if (IS_GEN9_LP(dev_priv) ||
-	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
+	if (dev_priv->power_domains_suspended)
 		intel_power_domains_init_hw(dev_priv, true);
 	else
 		intel_display_set_init_power(dev_priv, true);
@@ -1846,7 +1844,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	enable_rpm_wakeref_asserts(dev_priv);
 
 out:
-	dev_priv->suspended_to_idle = false;
+	dev_priv->power_domains_suspended = false;
 
 	return ret;
 }

commit 8c650aefb82d559aa0e1b7c0c36346b906481106
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Mar 23 12:34:50 2018 +0000

    drm/i915/uc: Fetch uC firmware in init_early
    
    We were fetching uC firmwares in separate uc_init_fw step, while
    there is no reason why we can't fetch them during init_early.
    This will also simplify upcoming patches, as size of the firmware
    may be used for register initialization.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180323123451.59244-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2561974af79c..db223378d84b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -692,11 +692,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_irq;
 
-	intel_uc_init_fw(dev_priv);
-
 	ret = i915_gem_init(dev_priv);
 	if (ret)
-		goto cleanup_uc;
+		goto cleanup_irq;
 
 	intel_setup_overlay(dev_priv);
 
@@ -716,8 +714,6 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 	i915_gem_fini(dev_priv);
-cleanup_uc:
-	intel_uc_fini_fw(dev_priv);
 cleanup_irq:
 	drm_irq_uninstall(dev);
 	intel_teardown_gmbus(dev_priv);
@@ -962,6 +958,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
 	intel_irq_fini(dev_priv);
+	intel_uc_cleanup_early(dev_priv);
 	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 	i915_engines_cleanup(dev_priv);
@@ -1457,7 +1454,6 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_reset_error_state(dev_priv);
 
 	i915_gem_fini(dev_priv);
-	intel_uc_fini_fw(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 
 	intel_power_domains_fini(dev_priv);

commit a0de908d44fb67500b7c45bd8325f316496227db
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Mar 23 12:34:49 2018 +0000

    drm/i915: Reorder early initialization
    
    In upcoming patch, we want to perform more actions in early
    initialization of the uC. This reordering will help resolve
    new dependencies that will be introduced by future patch.
    
    v2: s/i915_gem_load_init/i915_gem_init_early (Chris)
    v3: s/i915_gem_load_cleanup/i915_gem_cleanup_early (Michal)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180323123451.59244-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a7d3275f45d2..2561974af79c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -919,17 +919,21 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
 
-	intel_wopcm_init_early(&dev_priv->wopcm);
-	intel_uc_init_early(dev_priv);
 	i915_memcpy_init_early(dev_priv);
 
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
 		goto err_engines;
 
+	ret = i915_gem_init_early(dev_priv);
+	if (ret < 0)
+		goto err_workqueues;
+
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
 
+	intel_wopcm_init_early(&dev_priv->wopcm);
+	intel_uc_init_early(dev_priv);
 	intel_pm_setup(dev_priv);
 	intel_init_dpio(dev_priv);
 	intel_power_domains_init(dev_priv);
@@ -938,18 +942,13 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);
-	ret = i915_gem_load_init(dev_priv);
-	if (ret < 0)
-		goto err_irq;
-
 	intel_display_crc_init(dev_priv);
 
 	intel_detect_preproduction_hw(dev_priv);
 
 	return 0;
 
-err_irq:
-	intel_irq_fini(dev_priv);
+err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 err_engines:
 	i915_engines_cleanup(dev_priv);
@@ -962,8 +961,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
  */
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
-	i915_gem_load_cleanup(dev_priv);
 	intel_irq_fini(dev_priv);
+	i915_gem_cleanup_early(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 	i915_engines_cleanup(dev_priv);
 }

commit fa265275910f9d2396f8656317196c830878bd40
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Wed Mar 14 20:04:29 2018 +0000

    drm/i915/huc: Check HuC status in dedicated function
    
    We try to keep all HuC related code in dedicated file.
    There is no need to peek HuC register directly during
    handling getparam ioctl.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180314200429.40132-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3f637ab89e51..a7d3275f45d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -377,9 +377,9 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 		value = INTEL_INFO(dev_priv)->sseu.min_eu_in_pool;
 		break;
 	case I915_PARAM_HUC_STATUS:
-		intel_runtime_pm_get(dev_priv);
-		value = I915_READ(HUC_STATUS2) & HUC_FW_VERIFIED;
-		intel_runtime_pm_put(dev_priv);
+		value = intel_huc_check_status(&dev_priv->huc);
+		if (value < 0)
+			return value;
 		break;
 	case I915_PARAM_MMAP_GTT_VERSION:
 		/* Though we've started our numbering from 1, and so class all

commit ce80075470f6328e487389262c95af092d421ffc
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Mar 20 10:04:49 2018 +0000

    drm/i915: Add control flags to i915_handle_error()
    
    Not all callers want the GPU error to handled in the same way, so expose
    a control parameter. In the first instance, some callers do not want the
    heavyweight error capture so add a bit to request the state to be
    captured and saved.
    
    v2: Pass msg down to i915_reset/i915_reset_engine so that we include the
    reason for the reset in the dev_notice(), superseding the earlier option
    to not print that notice.
    v3: Stash the reason inside the i915->gpu_error to handover to the direct
    reset from the blocking waiter.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180320100449.1360-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ba5f150a29c0..3f637ab89e51 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1873,7 +1873,6 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 /**
  * i915_reset - reset chip after a hang
  * @i915: #drm_i915_private to reset
- * @flags: Instructions
  *
  * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
  * on failure.
@@ -1888,7 +1887,7 @@ static int i915_resume_switcheroo(struct drm_device *dev)
  *   - re-init interrupt state
  *   - re-init display
  */
-void i915_reset(struct drm_i915_private *i915, unsigned int flags)
+void i915_reset(struct drm_i915_private *i915)
 {
 	struct i915_gpu_error *error = &i915->gpu_error;
 	int ret;
@@ -1905,8 +1904,9 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	if (!i915_gem_unset_wedged(i915))
 		goto wakeup;
 
-	if (!(flags & I915_RESET_QUIET))
-		dev_notice(i915->drm.dev, "Resetting chip after gpu hang\n");
+	if (error->reason)
+		dev_notice(i915->drm.dev,
+			   "Resetting chip for %s\n", error->reason);
 	error->reset_count++;
 
 	disable_irq(i915->drm.irq);
@@ -2007,7 +2007,7 @@ static inline int intel_gt_reset_engine(struct drm_i915_private *dev_priv,
 /**
  * i915_reset_engine - reset GPU engine to recover from a hang
  * @engine: engine to reset
- * @flags: options
+ * @msg: reason for GPU reset; or NULL for no dev_notice()
  *
  * Reset a specific GPU engine. Useful if a hang is detected.
  * Returns zero on successful reset or otherwise an error code.
@@ -2017,7 +2017,7 @@ static inline int intel_gt_reset_engine(struct drm_i915_private *dev_priv,
  *  - reset engine (which will force the engine to idle)
  *  - re-init/configure engine
  */
-int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
+int i915_reset_engine(struct intel_engine_cs *engine, const char *msg)
 {
 	struct i915_gpu_error *error = &engine->i915->gpu_error;
 	struct i915_request *active_request;
@@ -2032,10 +2032,9 @@ int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
 		goto out;
 	}
 
-	if (!(flags & I915_RESET_QUIET)) {
+	if (msg)
 		dev_notice(engine->i915->drm.dev,
-			   "Resetting %s after gpu hang\n", engine->name);
-	}
+			   "Resetting %s for %s\n", engine->name, msg);
 	error->reset_engine_count[engine->id]++;
 
 	if (!engine->i915->guc.execbuf_client)

commit 26376a7e74d2deff445a72a2cfbfef084c28e4bc
Author: Oscar Mateo <oscar.mateo@intel.com>
Date:   Fri Mar 16 14:14:49 2018 +0200

    drm/i915/icl: Check for fused-off VDBOX and VEBOX instances
    
    In Gen11, the Video Decode engines (aka VDBOX, aka VCS, aka BSD) and the
    Video Enhancement engines (aka VEBOX, aka VECS) could be fused off. Also,
    each VDBOX and VEBOX has its own power well, which only exist if the
    related engine exists in the HW.
    
    Unfortunately, we have a Catch-22 situation going on: we need the blitter
    forcewake to read the register with the fuse info, but we cannot initialize
    the forcewake domains without knowin about the engines present in the HW.
    We workaround this problem by allowing the initialization of all forcewake
    domains and then pruning the fused off ones, as per the fuse information.
    
    Bspec: 20680
    
    v2: We were shifting incorrectly for vebox disable (Vinay)
    
    v3: Assert mmio is ready and warn if we have attempted to initialize
        forcewake for fused-off engines (Paulo)
    
    v4:
      - Use INTEL_GEN in new code (Tvrtko)
      - Shorter local variable (Tvrtko, Michal)
      - Keep "if (!...) continue" style (Tvrtko)
      - No unnecessary BUG_ON (Tvrtko)
      - WARN_ON and cleanup if wrong mask (Tvrtko, Michal)
      - Use I915_READ_FW (Michal)
      - Use I915_MAX_VCS/VECS macros (Michal)
    
    v5: Rebased by Rodrigo fixing conflicts on top of:
        "drm/i915: Simplify intel_engines_init"
    
    v6: Fix v5. Remove info->num_rings. (by Oscar)
    
    v7: Rebase (Rodrigo).
    
    v8:
      - s/intel_device_info_fused_off_engines/
        intel_device_info_init_mmio (Chris)
      - Make vdbox_disable & vebox_disable local variables (Chris)
    
    v9:
      - Move function declaration to intel_device_info.h (Michal)
      - Missing indent in bit fields definitions (Michal)
      - When RC6 is enabled by BIOS, the fuse register cannot be read until
        the blitter powerwell is awake. Shuffle where the fuse is read, prune
        the forcewake domains after the fact and change the commit message
        accordingly (Vinay, Sagar, Chris).
    
    v10:
      - Improved commit message (Sagar)
      - New line in header file (Sagar)
      - Specify the message in fw_domain_reset applies to ICL+ (Sagar)
    
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Oscar Mateo <oscar.mateo@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180316121456.11577-1-mika.kuoppala@linux.intel.com
    [Mika: soothe checkpatch on commit msg]
    Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1021bf40e236..ba5f150a29c0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1033,6 +1033,10 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 	intel_uncore_init(dev_priv);
 
+	intel_device_info_init_mmio(dev_priv);
+
+	intel_uncore_prune(dev_priv);
+
 	intel_uc_init_mmio(dev_priv);
 
 	ret = intel_engines_init_mmio(dev_priv);

commit 4977a287b9e7c3dbe156bf28f8771b758060ee3e
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Mon Mar 19 10:53:40 2018 +0100

    drm/i915/guc: Split relay control and GuC log level
    
    Those two concepts are really separate. Since GuC is writing data into
    its own buffer and we even provide a way for userspace to read directly
    from it using i915_guc_log_dump debugfs, there's no real reason to tie
    log level with relay creation.
    Let's create a separate debugfs, giving userspace a way to create a
    relay on demand, when it wants to read a continuous log rather than a
    snapshot.
    
    v2: Don't touch guc_log_level on relay creation error, adjust locking
        after rebase, s/dev_priv/i915, pass guc to file->private_data (Sagar)
        Use struct_mutex rather than runtime.lock for set_log_level
    v3: Tidy ordering of definitions (Sagar)
    
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180319095348.9716-5-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3df5193487f3..1021bf40e236 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1239,9 +1239,6 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		i915_debugfs_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
 
-		/* Depends on debugfs having been initialized */
-		intel_uc_register(dev_priv);
-
 		/* Depends on sysfs having been initialized */
 		i915_perf_register(dev_priv);
 	} else
@@ -1299,7 +1296,6 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_pmu_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
-	intel_uc_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 
 	i915_gem_shrinker_unregister(dev_priv);

commit ac697ae8013a7c7301174c9c3b02a92fe418b7ea
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 15 15:10:15 2018 +0000

    drm/i915: Stop engines when declaring the machine wedged
    
    If we fail to reset the GPU, we declare the machine wedged. However, the
    GPU may well still be running in the background with an in-flight
    request. So despite our efforts in cleaning up the request queue and
    faking the breadcrumb in the HWSP, the GPU may eventually write the
    in-flght seqno there breaking all of our assumptions and throwing the
    driver into a deep turmoil, wedging beyond wedged.
    
    To avoid this we ideally want to reset the GPU. Since that has already
    failed, make sure the rings have the stop bit set instead. This is part
    of the normal GPU reset sequence, but that is actually disabled by
    igt/gem_eio to force the wedged state. If we assume the worst, we must
    poke at the bit again before we give up.
    
    v2: Move the intel_gpu_reset() from set-wedged in the reset error path
    into i915_gem_set_wedged() itself. Even if the reset fails (e.g. if it is
    disabled by gem_eio), it still tries to make sure the engines are
    stopped. For i915_gem_set_wedged() callers from outside of i915_reset(),
    this should make sure the GPU is disabled while the driver is marked as
    being wedged.
    
    Testcase: igt/gem_eio
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180315151015.22741-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f03555efc520..3df5193487f3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1995,7 +1995,6 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 error:
 	i915_gem_set_wedged(i915);
 	i915_retire_requests(i915);
-	intel_gpu_reset(i915, ALL_ENGINES);
 	goto finish;
 }
 

commit 6b0478fb722ae638ad747e17251e90bbf1b7969b
Author: Jackie Li <yaodong.li@intel.com>
Date:   Tue Mar 13 17:32:50 2018 -0700

    drm/i915: Implement dynamic GuC WOPCM offset and size calculation
    
    Hardware may have specific restrictions on GuC WOPCM offset and size. On
    Gen9, the value of the GuC WOPCM size register needs to be larger than the
    value of GuC WOPCM offset register + a Gen9 specific offset (144KB) for
    reserved GuC WOPCM. Fail to enforce such a restriction on GuC WOPCM size
    will lead to GuC firmware execution failures. On the other hand, with
    current static GuC WOPCM offset and size values (512KB for both offset and
    size), the GuC WOPCM size verification will fail on Gen9 even if it can be
    fixed by lowering the GuC WOPCM offset by calculating its value based on
    HuC firmware size (which is likely less than 200KB on Gen9), so that we can
    have a GuC WOPCM size value which is large enough to pass the GuC WOPCM
    size check.
    
    This patch updates the reserved GuC WOPCM size for RC6 context on Gen9 to
    24KB to strictly align with the Gen9 GuC WOPCM layout. It also adds support
    to verify the GuC WOPCM size aganist the Gen9 hardware restrictions. To
    meet all above requirements, let's provide dynamic partitioning of the
    WOPCM that will be based on platform specific HuC/GuC firmware sizes.
    
    v2:
     - Removed intel_wopcm_init (Ville/Sagar/Joonas)
     - Renamed and Moved the intel_wopcm_partition into intel_guc (Sagar)
     - Removed unnecessary function calls (Joonas)
     - Init GuC WOPCM partition as soon as firmware fetching is completed
    
    v3:
     - Fixed indentation issues (Chris)
     - Removed layering violation code (Chris/Michal)
     - Created separat files for GuC wopcm code  (Michal)
     - Used inline function to avoid code duplication (Michal)
    
    v4:
     - Preset the GuC WOPCM top during early GuC init (Chris)
     - Fail intel_uc_init_hw() as soon as GuC WOPCM partitioning failed
    
    v5:
     - Moved GuC DMA WOPCM register updating code into intel_wopcm.c
     - Took care of the locking status before writing to GuC DMA
       Write-Once registers. (Joonas)
    
    v6:
     - Made sure the GuC WOPCM size to be multiple of 4K (4K aligned)
    
    v8:
     - Updated comments and fixed naming issues (Sagar/Joonas)
     - Updated commit message to include more description about the hardware
       restriction on GuC WOPCM size (Sagar)
    
    v9:
     - Minor changes variable names and code comments (Sagar)
     - Added detailed GuC WOPCM layout drawing (Sagar/Michal)
     - Refined macro definitions to be reader friendly (Michal)
     - Removed redundent check to valid flag (Michal)
     - Unified first parameter for exported GuC WOPCM functions (Michal)
     - Refined the name and parameter list of hardware restriction checking
       functions (Michal)
    
    v10:
     - Used shorter function name for internal functions (Joonas)
     - Moved init-ealry function into c file (Joonas)
     - Consolidated and removed redundant size checks (Joonas/Michal)
     - Removed unnecessary unlikely() from code which is only called once
       during boot (Joonas)
     - More fixes to kernel-doc format and content (Michal)
     - Avoided the use of PAGE_MASK for 4K pages (Michal)
     - Added error log messages to error paths (Michal)
    
    v11:
     - Replaced intel_guc_wopcm with more generic intel_wopcm and attached
       intel_wopcm to drm_i915_private instead intel_guc (Michal)
     - dynamic calculation of GuC non-wopcm memory start (a.k.a WOPCM Top
       offset from GuC WOPCM base) (Michal)
     - Moved WOPCM marco definitions into .c source file (Michal)
     - Exported WOPCM layout diagram as kernel-doc (Michal)
    
    v12:
     - Updated naming, function kernel-doc to align with new changes (Michal)
    
    v13:
     - Updated the ordering of s-o-b/cc/r-b tags (Sagar)
     - Corrected one tense error in comment (Sagar)
     - Corrected typos and removed spurious comments (Joonas)
    
    Bspec: 12690
    
    Signed-off-by: Jackie Li <yaodong.li@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Sujaritha Sundaresan <sujaritha.sundaresan@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: John Spotswood <john.a.spotswood@intel.com>
    Cc: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com> (v8)
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com> (v9)
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com> (v11)
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com> (v12)
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1520987574-19351-2-git-send-email-yaodong.li@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0126b222ab7f..f03555efc520 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -919,6 +919,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
 
+	intel_wopcm_init_early(&dev_priv->wopcm);
 	intel_uc_init_early(dev_priv);
 	i915_memcpy_init_early(dev_priv);
 

commit 3c33fc7c1af9a3426eff9015e5bab08a21a5fa9d
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Mon Mar 12 13:03:06 2018 +0000

    drm/i915/uc: Sanitize uC options early
    
    We are sanitizing uC related modparams together with other driver
    modparams in intel_sanitize_options called from i915_driver_init_hw,
    but this is too late for us as we will want to use USES_GUC/USES_HUC
    macros at earlier stage. Since our sanitizing does not require any
    MMIO access, we can do it in intel_uc_init_early right after we resolve
    firmware names.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180312130308.22952-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 987c6770d1a6..0126b222ab7f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1074,8 +1074,6 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 					    i915_modparams.enable_ppgtt);
 	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915_modparams.enable_ppgtt);
 
-	intel_uc_sanitize_options(dev_priv);
-
 	intel_gvt_sanitize_options(dev_priv);
 }
 

commit 950724ba88521195b4aefd092c8a0337487be352
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Thu Mar 8 16:46:54 2018 +0100

    drm/i915/guc: Create common entry points for log register/unregister
    
    We have many functions responsible for allocating different parts of
    GuC log runtime called from multiple places. Let's stick with keeping
    everything in guc_log_register instead.
    
    v2: Use more generic intel_uc_register name, keep using "misc" suffix (Michał)
        s/dev_priv/i915 (Sagar)
        Make guc_log_relay_* static (sparse)
    
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180308154707.21716-2-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d7c4de45644d..987c6770d1a6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1238,9 +1238,11 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
 		i915_debugfs_register(dev_priv);
-		i915_guc_log_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
 
+		/* Depends on debugfs having been initialized */
+		intel_uc_register(dev_priv);
+
 		/* Depends on sysfs having been initialized */
 		i915_perf_register(dev_priv);
 	} else
@@ -1298,7 +1300,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_pmu_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
-	i915_guc_log_unregister(dev_priv);
+	intel_uc_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 
 	i915_gem_shrinker_unregister(dev_priv);

commit a446ae2c6e6555048301f2339cfd97b8eed6d0b7
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 6 12:28:56 2018 +0000

    drm/i915: add query uAPI
    
    There are a number of information that are readable from hardware
    registers and that we would like to make accessible to userspace. One
    particular example is the topology of the execution units (how are
    execution units grouped in subslices and slices and also which ones
    have been fused off for die recovery).
    
    At the moment the GET_PARAM ioctl covers some basic needs, but
    generally is only able to return a single value for each defined
    parameter. This is a bit problematic with topology descriptions which
    are array/maps of available units.
    
    This change introduces a new ioctl that can deal with requests to fill
    structures of potentially variable lengths. The user is expected fill
    a query with length fields set at 0 on the first call, the kernel then
    sets the length fields to the their expected values. A second call to
    the kernel with length fields at their expected values will trigger a
    copy of the data to the pointed memory locations.
    
    The scope of this uAPI is only to provide information to userspace,
    not to allow configuration of the device.
    
    v2: Simplify dispatcher code iteration (Tvrtko)
        Tweak uapi drm_i915_query_item structure (Tvrtko)
    
    v3: Rename pad fields into flags (Chris)
        Return error on flags field != 0 (Chris)
        Only copy length back to userspace in drm_i915_query_item (Chris)
    
    v4: Use array of functions instead of switch (Chris)
    
    v5: More comments in uapi (Tvrtko)
        Return query item errors in length field (All)
    
    v6: Tweak uapi comments style to match the coding style (Lionel)
    
    v7: Add i915_query.h (Joonas)
    
    v8: (Lionel) Change the behavior of the item iterator to report
        invalid queries into the query item rather than stopping the
        iteration. This enables userspace applications to query newer
        items on older kernels and only have failure on the items that are
        not supported.
    
    v9: Edit copyright headers (Joonas)
    
    v10: Typos & comments in uapi (Joonas)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180306122857.27317-6-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c594ff5e57d0..d7c4de45644d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,7 @@
 #include "i915_drv.h"
 #include "i915_trace.h"
 #include "i915_pmu.h"
+#include "i915_query.h"
 #include "i915_vgpu.h"
 #include "intel_drv.h"
 #include "intel_uc.h"
@@ -2832,6 +2833,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_PERF_OPEN, i915_perf_open_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_QUERY, i915_query_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 8cc7669355136f8952779e6f60053c1284d59c4d
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 6 12:28:52 2018 +0000

    drm/i915: store all subslice masks
    
    Up to now, subslice mask was assumed to be uniform across slices. But
    starting with Cannonlake, slices can be asymmetric (for example slice0
    has different number of subslices as slice1+). This change stores all
    subslices masks for all slices rather than having a single mask that
    applies to all slices.
    
    v2: Rework how we store total numbers in sseu_dev_info (Tvrtko)
        Fix CHV eu masks, was reading disabled as enabled (Tvrtko)
        Readability changes (Tvrtko)
        Add EU index helper (Tvrtko)
    
    v3: Turn ALIGN(v, 8) / 8 into DIV_ROUND_UP(v, BITS_PER_BYTE) (Tvrtko)
        Reuse sseu_eu_idx() for setting eu_mask on CHV (Tvrtko)
        Reformat debug prints for subslices (Tvrtko)
    
    v4: Change eu_mask helper into sseu_set_eus() (Tvrtko)
    
    v5: With Haswell reporting masks & counts, bump sseu_*_eus() functions
        to use u16 (Lionel)
    
    v6: Fix sseu_get_eus() for > 8 EUs per subslice (Lionel)
    
    v7: Change debugfs enabels for number of subslices per slice, will
        need a small igt/pm_sseu change (Lionel)
        Drop subslice_total field from sseu_dev_info, rely on
        sseu_subslice_total() to recompute the value instead (Lionel)
    
    v8: Remove unused function compute_subslice_total() (Lionel)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180306122857.27317-2-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d61b51c0bf0b..c594ff5e57d0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -428,7 +428,7 @@ static int i915_getparam_ioctl(struct drm_device *dev, void *data,
 			return -ENODEV;
 		break;
 	case I915_PARAM_SUBSLICE_MASK:
-		value = INTEL_INFO(dev_priv)->sseu.subslice_mask;
+		value = INTEL_INFO(dev_priv)->sseu.subslice_mask[0];
 		if (!value)
 			return -ENODEV;
 		break;

commit 7cfca4afd656f0aa6f136d8a1260d994abc96a0c
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Mar 2 11:15:49 2018 +0000

    drm/i915/uc: Introduce intel_uc_suspend|resume
    
    We want to use higher level 'uc' functions as the main entry points to
    the GuC/HuC code to hide some details and keep code layered.
    
    While here, move call to disable_guc_interrupts after sending suspend
    action to the GuC to allow it work also with CTB as comm mechanism.
    
    v2: update commit msg (Sagar)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180302111550.21328-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aaa861b51024..d61b51c0bf0b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2575,7 +2575,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 */
 	i915_gem_runtime_suspend(dev_priv);
 
-	intel_guc_suspend(dev_priv);
+	intel_uc_suspend(dev_priv);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
@@ -2597,7 +2597,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
-		intel_guc_resume(dev_priv);
+		intel_uc_resume(dev_priv);
 
 		i915_gem_init_swizzling(dev_priv);
 		i915_gem_restore_fences(dev_priv);
@@ -2683,7 +2683,7 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
-	intel_guc_resume(dev_priv);
+	intel_uc_resume(dev_priv);
 
 	/*
 	 * No point of rolling back things in case of an error, as the best

commit e61e0f51ba7974bb575cdc23220b573e5cd4ff2a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 21 09:56:36 2018 +0000

    drm/i915: Rename drm_i915_gem_request to i915_request
    
    We want to de-emphasize the link between the request (dependency,
    execution and fence tracking) from GEM and so rename the struct from
    drm_i915_gem_request to i915_request. That is we may implement the GEM
    user interface on top of requests, but they are an abstraction for
    tracking execution rather than an implementation detail of GEM. (Since
    they are not tied to HW, we keep the i915 prefix as opposed to intel.)
    
    In short, the spatch:
    @@
    
    @@
    - struct drm_i915_gem_request
    + struct i915_request
    
    A corollary to contracting the type name, we also harmonise on using
    'rq' shorthand for local variables where space if of the essence and
    repetition makes 'request' unwieldy. For globals and struct members,
    'request' is still much preferred for its clarity.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180221095636.6649-1-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d09f8e661fbd..aaa861b51024 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -808,7 +808,7 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 	/*
 	 * The i915 workqueue is primarily used for batched retirement of
 	 * requests (and thus managing bo) once the task has been completed
-	 * by the GPU. i915_gem_retire_requests() is called directly when we
+	 * by the GPU. i915_retire_requests() is called directly when we
 	 * need high-priority retirement, such as waiting for an explicit
 	 * bo.
 	 *
@@ -1992,7 +1992,7 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
 error:
 	i915_gem_set_wedged(i915);
-	i915_gem_retire_requests(i915);
+	i915_retire_requests(i915);
 	intel_gpu_reset(i915, ALL_ENGINES);
 	goto finish;
 }
@@ -2019,7 +2019,7 @@ static inline int intel_gt_reset_engine(struct drm_i915_private *dev_priv,
 int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
 {
 	struct i915_gpu_error *error = &engine->i915->gpu_error;
-	struct drm_i915_gem_request *active_request;
+	struct i915_request *active_request;
 	int ret;
 
 	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));

commit 57b29646bb4804732d654d85ca574ced263d7bc2
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Nov 27 11:57:46 2017 -0500

    drm/i915: Deprecate pci_get_bus_and_slot()
    
    pci_get_bus_and_slot() is restrictive such that it assumes domain=0 as
    where a PCI device is present. This restricts the device drivers to be
    reused for other domain numbers.
    
    Getting ready to remove pci_get_bus_and_slot() function in favor of
    pci_get_domain_bus_and_slot().
    
    Extract the domain number from drm_device and pass it into
    pci_get_domain_bus_and_slot() function.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 173d0095e3b2..ca17508fd28c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -434,7 +434,10 @@ static int i915_getparam(struct drm_device *dev, void *data,
 
 static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
-	dev_priv->bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+	int domain = pci_domain_nr(dev_priv->drm.pdev->bus);
+
+	dev_priv->bridge_dev =
+		pci_get_domain_bus_and_slot(domain, 0, PCI_DEVFN(0, 0));
 	if (!dev_priv->bridge_dev) {
 		DRM_ERROR("bridge device not found\n");
 		return -1;

commit c5cb21c17a169eee5d45f2706ba3b6c3a7288786
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 15 08:19:30 2018 +0000

    drm/i915: Store platform_mask inside the static device info
    
    Rather than deriving the platform_mask from the
    intel_device_static_info->platform at runtime, pre-fill it in the static
    data.
    
    v2: Undefine macros at end of their scope
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180215081930.11477-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 046c073aa4aa..d09f8e661fbd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -906,8 +906,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
 		     sizeof(device_info->platform_mask) * BITS_PER_BYTE);
-	device_info->platform_mask = BIT(device_info->platform);
-
 	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);

commit bc76298e68e791f878d76f9b7a911713c85b2843
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 15 08:19:28 2018 +0000

    drm/i915: Store gen_mask inside the static device info
    
    Rather than deriving the gen_mask from the static intel_device_info->gen
    at runtime, pre-fill it in the static data.
    
    v2: Undefine local macros at end of their scope.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180215081930.11477-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a9931b8ec0b3..046c073aa4aa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -909,8 +909,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	device_info->platform_mask = BIT(device_info->platform);
 
 	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
-	device_info->gen_mask = BIT(device_info->gen - 1);
-
 	spin_lock_init(&dev_priv->irq_lock);
 	spin_lock_init(&dev_priv->gpu_error.lock);
 	mutex_init(&dev_priv->backlight_lock);

commit 785f076b3ba781804f2b22b347b4431e3efb0ab3
Author: Hans de Goede <j.w.r.degoede@gmail.com>
Date:   Wed Feb 14 09:21:49 2018 +0100

    drm/i915: Add intel_bios_cleanup() function
    
    Add an intel_bios_cleanup() function to act as counterpart of
    intel_bios_init() and move the cleanup of vbt related resources there,
    putting it in the same file as the allocation.
    
    Changed in v2:
    -While touching the code anyways, remove the unnecessary:
     if (dev_priv->vbt.child_dev) done before kfree(dev_priv->vbt.child_dev)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180214082151.25015-1-hdegoede@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9380c9f69b0f..a9931b8ec0b3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1448,19 +1448,7 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_modeset_cleanup(dev);
 
-	/*
-	 * free the memory space allocated for the child device
-	 * config parsed from VBT
-	 */
-	if (dev_priv->vbt.child_dev && dev_priv->vbt.child_dev_num) {
-		kfree(dev_priv->vbt.child_dev);
-		dev_priv->vbt.child_dev = NULL;
-		dev_priv->vbt.child_dev_num = 0;
-	}
-	kfree(dev_priv->vbt.sdvo_lvds_vbt_mode);
-	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;
-	kfree(dev_priv->vbt.lfp_lvds_vbt_mode);
-	dev_priv->vbt.lfp_lvds_vbt_mode = NULL;
+	intel_bios_cleanup(dev_priv);
 
 	vga_switcheroo_unregister_client(pdev);
 	vga_client_register(pdev, NULL, NULL, NULL);

commit 40ace64b1ece1b8a29f86e6e2bc6fb91f7f0e537
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Feb 5 19:31:38 2018 +0200

    drm/i915: have virtual PCH detection return a PCH id
    
    Simplify intel_virt_detect_pch() by making it return a PCH id rather
    than returning the PCH type and setting PCH id for some PCHs. Map the
    PCH id to PCH type using the shared routine. This gives us sanity check
    on the supported combinations also in the virtualized setting.
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/197cf635261a1c628371ffaaee90e8647493af4d.1517851783.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 786486a53dce..9380c9f69b0f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -202,9 +202,10 @@ static bool intel_is_virt_pch(unsigned short id,
 		 sdevice == PCI_SUBDEVICE_ID_QEMU));
 }
 
-static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
+static unsigned short
+intel_virt_detect_pch(const struct drm_i915_private *dev_priv)
 {
-	enum intel_pch ret = PCH_NOP;
+	unsigned short id = 0;
 
 	/*
 	 * In a virtualized passthrough environment we can be in a
@@ -213,28 +214,25 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_GEN5(dev_priv)) {
-		ret = PCH_IBX;
-		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
-	} else if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv)) {
-		ret = PCH_CPT;
-		DRM_DEBUG_KMS("Assuming CougarPoint PCH\n");
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
-		ret = PCH_LPT;
-		if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
-			dev_priv->pch_id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
-		else
-			dev_priv->pch_id = INTEL_PCH_LPT_DEVICE_ID_TYPE;
-		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
-	} else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
-		ret = PCH_SPT;
-		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
-	} else if (IS_COFFEELAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
-		ret = PCH_CNP;
-		DRM_DEBUG_KMS("Assuming CannonPoint PCH\n");
-	}
+	if (IS_GEN5(dev_priv))
+		id = INTEL_PCH_IBX_DEVICE_ID_TYPE;
+	else if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv))
+		id = INTEL_PCH_CPT_DEVICE_ID_TYPE;
+	else if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
+		id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		id = INTEL_PCH_LPT_DEVICE_ID_TYPE;
+	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
+		id = INTEL_PCH_SPT_DEVICE_ID_TYPE;
+	else if (IS_COFFEELAKE(dev_priv) || IS_CANNONLAKE(dev_priv))
+		id = INTEL_PCH_CNP_DEVICE_ID_TYPE;
+
+	if (id)
+		DRM_DEBUG_KMS("Assuming PCH ID %04x\n", id);
+	else
+		DRM_DEBUG_KMS("Assuming no PCH\n");
 
-	return ret;
+	return id;
 }
 
 static void intel_detect_pch(struct drm_i915_private *dev_priv)
@@ -269,19 +267,25 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 
 		id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
 
-		dev_priv->pch_id = id;
-
 		pch_type = intel_pch_type(dev_priv, id);
 		if (pch_type != PCH_NONE) {
 			dev_priv->pch_type = pch_type;
+			dev_priv->pch_id = id;
+			break;
 		} else if (intel_is_virt_pch(id, pch->subsystem_vendor,
-					     pch->subsystem_device)) {
-			dev_priv->pch_type = intel_virt_detect_pch(dev_priv);
-		} else {
-			continue;
+					 pch->subsystem_device)) {
+			id = intel_virt_detect_pch(dev_priv);
+			if (id) {
+				pch_type = intel_pch_type(dev_priv, id);
+				if (WARN_ON(pch_type == PCH_NONE))
+					pch_type = PCH_NOP;
+			} else {
+				pch_type = PCH_NOP;
+			}
+			dev_priv->pch_type = pch_type;
+			dev_priv->pch_id = id;
+			break;
 		}
-
-		break;
 	}
 	if (!pch)
 		DRM_DEBUG_KMS("No PCH found.\n");

commit 435ad2c009429157cb65ce8a6221038235cc0501
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Feb 5 19:31:37 2018 +0200

    drm/i915: abstract virtual PCH id detection
    
    Make the code slightly more pleasant to look at. No functional changes.
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/38ee1ac06c6724e888679eb287af36c221bd399b.1517851783.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 066c3406bbc9..786486a53dce 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -192,6 +192,16 @@ intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
 	}
 }
 
+static bool intel_is_virt_pch(unsigned short id,
+			      unsigned short svendor, unsigned short sdevice)
+{
+	return (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
+		id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
+		(id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
+		 svendor == PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
+		 sdevice == PCI_SUBDEVICE_ID_QEMU));
+}
+
 static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 {
 	enum intel_pch ret = PCH_NOP;
@@ -264,13 +274,8 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 		pch_type = intel_pch_type(dev_priv, id);
 		if (pch_type != PCH_NONE) {
 			dev_priv->pch_type = pch_type;
-		} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
-			   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
-			   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
-			    pch->subsystem_vendor ==
-			    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
-			    pch->subsystem_device ==
-			    PCI_SUBDEVICE_ID_QEMU)) {
+		} else if (intel_is_virt_pch(id, pch->subsystem_vendor,
+					     pch->subsystem_device)) {
 			dev_priv->pch_type = intel_virt_detect_pch(dev_priv);
 		} else {
 			continue;

commit da6c10c23a904d8ada1a9bf94ee26422f4cd4be0
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Feb 5 19:31:36 2018 +0200

    drm/i915: abstract PCH type detection from PCH id
    
    Make the logic in intel_detect_pch() easier to follow, and make the PCH
    id to type mapping reusable. No functional changes.
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/3bd4ffcd284cdbd4e8dc77ab02d97ded422e0c21.1517851783.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7bfc74c1aeb8..066c3406bbc9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -122,6 +122,75 @@ static bool i915_error_injected(struct drm_i915_private *dev_priv)
 		      i915_error_injected(dev_priv) ? KERN_DEBUG : KERN_ERR, \
 		      fmt, ##__VA_ARGS__)
 
+/* Map PCH device id to PCH type, or PCH_NONE if unknown. */
+static enum intel_pch
+intel_pch_type(const struct drm_i915_private *dev_priv, unsigned short id)
+{
+	switch (id) {
+	case INTEL_PCH_IBX_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
+		WARN_ON(!IS_GEN5(dev_priv));
+		return PCH_IBX;
+	case INTEL_PCH_CPT_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+		WARN_ON(!IS_GEN6(dev_priv) && !IS_IVYBRIDGE(dev_priv));
+		return PCH_CPT;
+	case INTEL_PCH_PPT_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found PantherPoint PCH\n");
+		WARN_ON(!IS_GEN6(dev_priv) && !IS_IVYBRIDGE(dev_priv));
+		/* PantherPoint is CPT compatible */
+		return PCH_CPT;
+	case INTEL_PCH_LPT_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found LynxPoint PCH\n");
+		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
+		WARN_ON(IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv));
+		return PCH_LPT;
+	case INTEL_PCH_LPT_LP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
+		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
+		WARN_ON(!IS_HSW_ULT(dev_priv) && !IS_BDW_ULT(dev_priv));
+		return PCH_LPT;
+	case INTEL_PCH_WPT_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
+		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
+		WARN_ON(IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv));
+		/* WildcatPoint is LPT compatible */
+		return PCH_LPT;
+	case INTEL_PCH_WPT_LP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
+		WARN_ON(!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv));
+		WARN_ON(!IS_HSW_ULT(dev_priv) && !IS_BDW_ULT(dev_priv));
+		/* WildcatPoint is LPT compatible */
+		return PCH_LPT;
+	case INTEL_PCH_SPT_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
+		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv));
+		return PCH_SPT;
+	case INTEL_PCH_SPT_LP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
+		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv));
+		return PCH_SPT;
+	case INTEL_PCH_KBP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
+		WARN_ON(!IS_SKYLAKE(dev_priv) && !IS_KABYLAKE(dev_priv) &&
+			!IS_COFFEELAKE(dev_priv));
+		return PCH_KBP;
+	case INTEL_PCH_CNP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
+		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));
+		return PCH_CNP;
+	case INTEL_PCH_CNP_LP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
+		WARN_ON(!IS_CANNONLAKE(dev_priv) && !IS_COFFEELAKE(dev_priv));
+		return PCH_CNP;
+	case INTEL_PCH_ICP_DEVICE_ID_TYPE:
+		DRM_DEBUG_KMS("Found Ice Lake PCH\n");
+		WARN_ON(!IS_ICELAKE(dev_priv));
+		return PCH_ICP;
+	default:
+		return PCH_NONE;
+	}
+}
 
 static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 {
@@ -183,6 +252,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	 */
 	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
 		unsigned short id;
+		enum intel_pch pch_type;
 
 		if (pch->vendor != PCI_VENDOR_ID_INTEL)
 			continue;
@@ -191,81 +261,9 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 
 		dev_priv->pch_id = id;
 
-		if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_IBX;
-			DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-			WARN_ON(!IS_GEN5(dev_priv));
-		} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_CPT;
-			DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-			WARN_ON(!IS_GEN6(dev_priv) &&
-				!IS_IVYBRIDGE(dev_priv));
-		} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
-			/* PantherPoint is CPT compatible */
-			dev_priv->pch_type = PCH_CPT;
-			DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-			WARN_ON(!IS_GEN6(dev_priv) &&
-				!IS_IVYBRIDGE(dev_priv));
-		} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_LPT;
-			DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-			WARN_ON(!IS_HASWELL(dev_priv) &&
-				!IS_BROADWELL(dev_priv));
-			WARN_ON(IS_HSW_ULT(dev_priv) ||
-				IS_BDW_ULT(dev_priv));
-		} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_LPT;
-			DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-			WARN_ON(!IS_HASWELL(dev_priv) &&
-				!IS_BROADWELL(dev_priv));
-			WARN_ON(!IS_HSW_ULT(dev_priv) &&
-				!IS_BDW_ULT(dev_priv));
-		} else if (id == INTEL_PCH_WPT_DEVICE_ID_TYPE) {
-			/* WildcatPoint is LPT compatible */
-			dev_priv->pch_type = PCH_LPT;
-			DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
-			WARN_ON(!IS_HASWELL(dev_priv) &&
-				!IS_BROADWELL(dev_priv));
-			WARN_ON(IS_HSW_ULT(dev_priv) ||
-				IS_BDW_ULT(dev_priv));
-		} else if (id == INTEL_PCH_WPT_LP_DEVICE_ID_TYPE) {
-			/* WildcatPoint is LPT compatible */
-			dev_priv->pch_type = PCH_LPT;
-			DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
-			WARN_ON(!IS_HASWELL(dev_priv) &&
-				!IS_BROADWELL(dev_priv));
-			WARN_ON(!IS_HSW_ULT(dev_priv) &&
-				!IS_BDW_ULT(dev_priv));
-		} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_SPT;
-			DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-			WARN_ON(!IS_SKYLAKE(dev_priv) &&
-				!IS_KABYLAKE(dev_priv));
-		} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_SPT;
-			DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-			WARN_ON(!IS_SKYLAKE(dev_priv) &&
-				!IS_KABYLAKE(dev_priv));
-		} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_KBP;
-			DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
-			WARN_ON(!IS_SKYLAKE(dev_priv) &&
-				!IS_KABYLAKE(dev_priv) &&
-				!IS_COFFEELAKE(dev_priv));
-		} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_CNP;
-			DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
-			WARN_ON(!IS_CANNONLAKE(dev_priv) &&
-				!IS_COFFEELAKE(dev_priv));
-		} else if (id == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_CNP;
-			DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
-			WARN_ON(!IS_CANNONLAKE(dev_priv) &&
-				!IS_COFFEELAKE(dev_priv));
-		} else if (id == INTEL_PCH_ICP_DEVICE_ID_TYPE) {
-			dev_priv->pch_type = PCH_ICP;
-			DRM_DEBUG_KMS("Found Ice Lake PCH\n");
-			WARN_ON(!IS_ICELAKE(dev_priv));
+		pch_type = intel_pch_type(dev_priv, id);
+		if (pch_type != PCH_NONE) {
+			dev_priv->pch_type = pch_type;
 		} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
 			   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
 			   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&

commit ad5169070713cee0be9f533a8f39b2903b7833d8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 9 11:40:56 2018 +0000

    drm/i915: Move the final intel_gpu_reset() to after declaring wedged
    
    If we fail to reset the GPU (i915_reset()), we do one final
    intel_gpu_reset() attempt as we mark the device wedged. The idea here is
    even though the GPU has proven unreliable (and so we want to stop using
    it for the time being), we don't want it spinning away in the background
    whilst the driver idles so we try to reset it one more time. However, we
    want to dump the i915_gem_set_wedged() debugging info before we do, so
    that we can see the accurate state of the GPU when it failed.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180209114056.9957-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index daa9060bdfcb..7bfc74c1aeb8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1920,7 +1920,6 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	ret = i915_gem_reset_prepare(i915);
 	if (ret) {
 		dev_err(i915->drm.dev, "GPU recovery failed\n");
-		intel_gpu_reset(i915, ALL_ENGINES);
 		goto taint;
 	}
 
@@ -2003,6 +2002,7 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 error:
 	i915_gem_set_wedged(i915);
 	i915_gem_retire_requests(i915);
+	intel_gpu_reset(i915, ALL_ENGINES);
 	goto finish;
 }
 

commit 6a20fe7b17cd7ecd4b75dd82cfa6664780d6f923
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Feb 7 18:48:41 2018 +0200

    drm/i915: Give all ioctl functions an _ioctl suffix
    
    Most of our ioctl functions have an _ioctl suffix in the name. I like
    that idea since it makes it easy to figure out how the function is
    going to get called. Rename the handful of exceptions to follow the
    same pattern.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180207164841.19431-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cd57f946cf45..daa9060bdfcb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -286,8 +286,8 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	pci_dev_put(pch);
 }
 
-static int i915_getparam(struct drm_device *dev, void *data,
-			 struct drm_file *file_priv)
+static int i915_getparam_ioctl(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
@@ -2792,7 +2792,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_BATCHBUFFER, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_IRQ_EMIT, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_IRQ_WAIT, drm_noop, DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_SETPARAM, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_ALLOC, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_FREE, drm_noop, DRM_AUTH),
@@ -2804,8 +2804,8 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_VBLANK_SWAP, drm_noop, DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(I915_HWS_ADDR, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
-	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, i915_gem_execbuffer, DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, i915_gem_execbuffer_ioctl, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_PIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_UNPIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
@@ -2824,11 +2824,11 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_GET_TILING, i915_gem_get_tiling_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_GET_APERTURE, i915_gem_get_aperture_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id, 0),
+	DRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(I915_GEM_MADVISE, i915_gem_madvise_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_OVERLAY_PUT_IMAGE, intel_overlay_put_image_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER|DRM_CONTROL_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),

commit 34e07e42c55aeaa78e93b057a6664e2ecde3fadb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 8 10:54:48 2018 +0000

    drm/i915: Add missing kerneldoc for 'ent' in i915_driver_init_early
    
    drivers/gpu/drm/i915/i915_drv.c:891: warning: No description found for parameter 'ent'
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180208105449.29880-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 143b9d5438d2..cd57f946cf45 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -873,6 +873,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 /**
  * i915_driver_init_early - setup state not requiring device access
  * @dev_priv: device private
+ * @ent: the matching pci_device_id
  *
  * Initialize everything that is a "SW-only" state, that is state not
  * requiring accessing the device or exposing the driver via kernel internal

commit 3fed180812edebac7d04b94a69da33b4f8532907
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 7 21:05:43 2018 +0000

    drm/i915: Move the scheduler feature bits into the purview of the engines
    
    Rather than having the high level ioctl interface guess the underlying
    implementation details, having the implementation declare what
    capabilities it exports. We define an intel_driver_caps, similar to the
    intel_device_info, which instead of trying to describe the HW gives
    details on what the driver itself supports. This is then populated by
    the engine backend for the new scheduler capability field for use
    elsewhere.
    
    v2: Use caps.scheduler for validating CONTEXT_PARAM_SET_PRIORITY (Mika)
        One less assumption of engine[RCS] \o/
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tomasz Lis <tomasz.lis@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Tomasz Lis <tomasz.lis@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180207210544.26351-2-chris@chris-wilson.co.uk
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bb605e0b996c..143b9d5438d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -381,13 +381,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = i915_gem_mmap_gtt_version();
 		break;
 	case I915_PARAM_HAS_SCHEDULER:
-		value = 0;
-		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule) {
-			value |= I915_SCHEDULER_CAP_ENABLED;
-			value |= I915_SCHEDULER_CAP_PRIORITY;
-			if (HAS_LOGICAL_RING_PREEMPTION(dev_priv))
-				value |= I915_SCHEDULER_CAP_PREEMPTION;
-		}
+		value = dev_priv->caps.scheduler;
 		break;
 
 	case I915_PARAM_MMAP_VERSION:

commit 8177e1125235a40c1af110e37febf6bb1e7b3f81
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 7 11:15:45 2018 +0000

    drm/i915: Tidy up some error messages around reset failure
    
    On blb and pnv, we are seeing sporadic
    
      i915 0000:00:02.0: Resetting chip after gpu hang
      [drm:intel_gpu_reset [i915]] rcs0: timed out on STOP_RING
      [drm:i915_reset [i915]] *ERROR* Failed hw init on reset -5
    
    which notably lack the actual root cause of the error. Ostensibly it
    should be the init_ring_common() that failed, but it's error paths are
    covered by DRM_ERROR.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180207111545.17078-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e9f1daf258fe..bb605e0b996c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1957,7 +1957,8 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	 */
 	ret = i915_ggtt_enable_hw(i915);
 	if (ret) {
-		DRM_ERROR("Failed to re-enable GGTT following reset %d\n", ret);
+		DRM_ERROR("Failed to re-enable GGTT following reset (%d)\n",
+			  ret);
 		goto error;
 	}
 
@@ -1974,7 +1975,8 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	 */
 	ret = i915_gem_init_hw(i915);
 	if (ret) {
-		DRM_ERROR("Failed hw init on reset %d\n", ret);
+		DRM_ERROR("Failed to initialise HW following reset (%d)\n",
+			  ret);
 		goto error;
 	}
 

commit d67c0ac19f9a3d900fbdf84924cb4d3aea934310
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Feb 2 15:04:16 2018 +0200

    drm/i915: reduce indent in pch detection
    
    Save some horizontal space.
    
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180202130416.18233-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6e7e933fea32..e9f1daf258fe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -182,100 +182,103 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	 * of only checking the first one.
 	 */
 	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
-		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
-			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
-
-			dev_priv->pch_id = id;
-
-			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_IBX;
-				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-				WARN_ON(!IS_GEN5(dev_priv));
-			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_CPT;
-				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-				WARN_ON(!IS_GEN6(dev_priv) &&
-					!IS_IVYBRIDGE(dev_priv));
-			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
-				/* PantherPoint is CPT compatible */
-				dev_priv->pch_type = PCH_CPT;
-				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-				WARN_ON(!IS_GEN6(dev_priv) &&
-					!IS_IVYBRIDGE(dev_priv));
-			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-				WARN_ON(!IS_HASWELL(dev_priv) &&
-					!IS_BROADWELL(dev_priv));
-				WARN_ON(IS_HSW_ULT(dev_priv) ||
-					IS_BDW_ULT(dev_priv));
-			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev_priv) &&
-					!IS_BROADWELL(dev_priv));
-				WARN_ON(!IS_HSW_ULT(dev_priv) &&
-					!IS_BDW_ULT(dev_priv));
-			} else if (id == INTEL_PCH_WPT_DEVICE_ID_TYPE) {
-				/* WildcatPoint is LPT compatible */
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
-				WARN_ON(!IS_HASWELL(dev_priv) &&
-					!IS_BROADWELL(dev_priv));
-				WARN_ON(IS_HSW_ULT(dev_priv) ||
-					IS_BDW_ULT(dev_priv));
-			} else if (id == INTEL_PCH_WPT_LP_DEVICE_ID_TYPE) {
-				/* WildcatPoint is LPT compatible */
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev_priv) &&
-					!IS_BROADWELL(dev_priv));
-				WARN_ON(!IS_HSW_ULT(dev_priv) &&
-					!IS_BDW_ULT(dev_priv));
-			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_SPT;
-				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev_priv) &&
-					!IS_KABYLAKE(dev_priv));
-			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_SPT;
-				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev_priv) &&
-					!IS_KABYLAKE(dev_priv));
-			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_KBP;
-				DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
-				WARN_ON(!IS_SKYLAKE(dev_priv) &&
-					!IS_KABYLAKE(dev_priv) &&
-					!IS_COFFEELAKE(dev_priv));
-			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_CNP;
-				DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
-				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
-					!IS_COFFEELAKE(dev_priv));
-			} else if (id == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_CNP;
-				DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
-				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
-					!IS_COFFEELAKE(dev_priv));
-			} else if (id == INTEL_PCH_ICP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_ICP;
-				DRM_DEBUG_KMS("Found Ice Lake PCH\n");
-				WARN_ON(!IS_ICELAKE(dev_priv));
-			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
-				   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
-				   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
-				    pch->subsystem_vendor ==
-					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
-				    pch->subsystem_device ==
-					    PCI_SUBDEVICE_ID_QEMU)) {
-				dev_priv->pch_type =
-					intel_virt_detect_pch(dev_priv);
-			} else
-				continue;
-
-			break;
+		unsigned short id;
+
+		if (pch->vendor != PCI_VENDOR_ID_INTEL)
+			continue;
+
+		id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+
+		dev_priv->pch_id = id;
+
+		if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_IBX;
+			DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
+			WARN_ON(!IS_GEN5(dev_priv));
+		} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_CPT;
+			DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+			WARN_ON(!IS_GEN6(dev_priv) &&
+				!IS_IVYBRIDGE(dev_priv));
+		} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
+			/* PantherPoint is CPT compatible */
+			dev_priv->pch_type = PCH_CPT;
+			DRM_DEBUG_KMS("Found PantherPoint PCH\n");
+			WARN_ON(!IS_GEN6(dev_priv) &&
+				!IS_IVYBRIDGE(dev_priv));
+		} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_LPT;
+			DRM_DEBUG_KMS("Found LynxPoint PCH\n");
+			WARN_ON(!IS_HASWELL(dev_priv) &&
+				!IS_BROADWELL(dev_priv));
+			WARN_ON(IS_HSW_ULT(dev_priv) ||
+				IS_BDW_ULT(dev_priv));
+		} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_LPT;
+			DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
+			WARN_ON(!IS_HASWELL(dev_priv) &&
+				!IS_BROADWELL(dev_priv));
+			WARN_ON(!IS_HSW_ULT(dev_priv) &&
+				!IS_BDW_ULT(dev_priv));
+		} else if (id == INTEL_PCH_WPT_DEVICE_ID_TYPE) {
+			/* WildcatPoint is LPT compatible */
+			dev_priv->pch_type = PCH_LPT;
+			DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
+			WARN_ON(!IS_HASWELL(dev_priv) &&
+				!IS_BROADWELL(dev_priv));
+			WARN_ON(IS_HSW_ULT(dev_priv) ||
+				IS_BDW_ULT(dev_priv));
+		} else if (id == INTEL_PCH_WPT_LP_DEVICE_ID_TYPE) {
+			/* WildcatPoint is LPT compatible */
+			dev_priv->pch_type = PCH_LPT;
+			DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
+			WARN_ON(!IS_HASWELL(dev_priv) &&
+				!IS_BROADWELL(dev_priv));
+			WARN_ON(!IS_HSW_ULT(dev_priv) &&
+				!IS_BDW_ULT(dev_priv));
+		} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_SPT;
+			DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
+			WARN_ON(!IS_SKYLAKE(dev_priv) &&
+				!IS_KABYLAKE(dev_priv));
+		} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_SPT;
+			DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
+			WARN_ON(!IS_SKYLAKE(dev_priv) &&
+				!IS_KABYLAKE(dev_priv));
+		} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_KBP;
+			DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
+			WARN_ON(!IS_SKYLAKE(dev_priv) &&
+				!IS_KABYLAKE(dev_priv) &&
+				!IS_COFFEELAKE(dev_priv));
+		} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_CNP;
+			DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
+			WARN_ON(!IS_CANNONLAKE(dev_priv) &&
+				!IS_COFFEELAKE(dev_priv));
+		} else if (id == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_CNP;
+			DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
+			WARN_ON(!IS_CANNONLAKE(dev_priv) &&
+				!IS_COFFEELAKE(dev_priv));
+		} else if (id == INTEL_PCH_ICP_DEVICE_ID_TYPE) {
+			dev_priv->pch_type = PCH_ICP;
+			DRM_DEBUG_KMS("Found Ice Lake PCH\n");
+			WARN_ON(!IS_ICELAKE(dev_priv));
+		} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
+			   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
+			   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
+			    pch->subsystem_vendor ==
+			    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
+			    pch->subsystem_device ==
+			    PCI_SUBDEVICE_ID_QEMU)) {
+			dev_priv->pch_type = intel_virt_detect_pch(dev_priv);
+		} else {
+			continue;
 		}
+
+		break;
 	}
 	if (!pch)
 		DRM_DEBUG_KMS("No PCH found.\n");

commit fae919f07610c52ad93915b54c5baeb111c6ea0d
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Feb 1 17:32:48 2018 +0000

    drm/i915: Enable inject_load_failure only in DEBUG config
    
    We're using i915_inject_load_failure() to inject dummy
    faults during driver load, but since this is debug utility
    we shouldn't expose it in default config as it consumes
    both code and data.
    
    add/remove: 0/1 grow/shrink: 0/2 up/down: 0/-302 (-302)
    Function                                     old     new   delta
    __i915_inject_load_failure                    61       -     -61
    i915_gem_init                               1331    1268     -63
    i915_driver_load                            5923    5745    -178
    Total: Before=1177454, After=1177152, chg -0.03%
    
    add/remove: 0/1 grow/shrink: 0/0 up/down: 0/-4 (-4)
    Data                                         old     new   delta
    i915_load_fail_count                           4       -      -4
    Total: Before=56762, After=56758, chg -0.01%
    
    add/remove: 4/8 grow/shrink: 0/1 up/down: 245/-591 (-346)
    RO Data                                      old     new   delta
    __param_str_inject_load_failure               20       -     -20
    __UNIQUE_ID_inject_load_failuretype200        34       -     -34
    __param_inject_load_failure                   40       -     -40
    __func__                                    4998    4896    -102
    __UNIQUE_ID_inject_load_failure201           150       -    -150
    Total: Before=119095, After=118749, chg -0.29%
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180201173248.3912-1-michal.wajdeczko@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1ec12add34b2..6e7e933fea32 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -55,6 +55,7 @@
 
 static struct drm_driver driver;
 
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
 static unsigned int i915_load_fail_count;
 
 bool __i915_inject_load_failure(const char *func, int line)
@@ -70,6 +71,7 @@ bool __i915_inject_load_failure(const char *func, int line)
 
 	return false;
 }
+#endif
 
 #define FDO_BUG_URL "https://bugs.freedesktop.org/enter_bug.cgi?product=DRI"
 #define FDO_BUG_MSG "Please file a bug at " FDO_BUG_URL " against DRM/Intel " \
@@ -107,8 +109,12 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 
 static bool i915_error_injected(struct drm_i915_private *dev_priv)
 {
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
 	return i915_modparams.inject_load_failure &&
 	       i915_load_fail_count == i915_modparams.inject_load_failure;
+#else
+	return false;
+#endif
 }
 
 #define i915_load_error(dev_priv, fmt, ...)				     \

commit d13a8479f3584613b6aacbb793eae64578b8f69a
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jan 16 16:53:24 2018 +0100

    drm/i915: Always call to intel_display_set_init_power() in resume_early.
    
    intel_power_domains_init_hw() calls set_init_power, but when using
    runtime power management this call is skipped. This prevents hw readout
    from taking place.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=104172
    Link: https://patchwork.freedesktop.org/patch/msgid/20180116155324.75120-1-maarten.lankhorst@linux.intel.com
    Fixes: bc87229f323e ("drm/i915/skl: enable PC9/10 power states during suspend-to-idle")
    Cc: Nivedita Swaminathan <nivedita.swaminathan@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: <stable@vger.kernel.org> # v4.5+
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    (cherry picked from commit ac25dfed15d470d7f23dd817e965b54aa3f94a1e)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c8da9d20c33..173d0095e3b2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1842,6 +1842,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	if (IS_GEN9_LP(dev_priv) ||
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
+	else
+		intel_display_set_init_power(dev_priv, true);
 
 	i915_gem_sanitize(dev_priv);
 

commit 70deeaddc6e6c51bb5e2b088dd92bb5a0e5b8d8a
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Wed Jan 24 21:16:58 2018 +0530

    drm/i915/guc: Fix lockdep due to log relay channel handling under struct_mutex
    
    This patch fixes lockdep issue due to circular locking dependency of
    struct_mutex, i_mutex_key, mmap_sem, relay_channels_mutex.
    For GuC log relay channel we create debugfs file that requires i_mutex_key
    lock and we are doing that under struct_mutex. So we introduced newer
    dependency as:
        &dev->struct_mutex --> &sb->s_type->i_mutex_key#3 --> &mm->mmap_sem
    However, there is dependency from mmap_sem to struct_mutex. Hence we
    separate the relay create/destroy operation from under struct_mutex.
    Also added runtime check of relay buffer status.
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    
    ======================================================
    WARNING: possible circular locking dependency detected
    4.15.0-rc6-CI-Patchwork_7614+ #1 Not tainted
    ------------------------------------------------------
    debugfs_test/1388 is trying to acquire lock:
     (&dev->struct_mutex){+.+.}, at: [<00000000d5e1d915>] i915_mutex_lock_interruptible+0x47/0x130 [i915]
    
    but task is already holding lock:
     (&mm->mmap_sem){++++}, at: [<0000000029a9c131>] __do_page_fault+0x106/0x560
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #3 (&mm->mmap_sem){++++}:
           _copy_to_user+0x1e/0x70
           filldir+0x8c/0xf0
           dcache_readdir+0xeb/0x160
           iterate_dir+0xdc/0x140
           SyS_getdents+0xa0/0x130
           entry_SYSCALL_64_fastpath+0x1c/0x89
    
    -> #2 (&sb->s_type->i_mutex_key#3){++++}:
           start_creating+0x59/0x110
           __debugfs_create_file+0x2e/0xe0
           relay_create_buf_file+0x62/0x80
           relay_late_setup_files+0x84/0x250
           guc_log_late_setup+0x4f/0x110 [i915]
           i915_guc_log_register+0x32/0x40 [i915]
           i915_driver_load+0x7b6/0x1720 [i915]
           i915_pci_probe+0x2e/0x90 [i915]
           pci_device_probe+0x9c/0x120
           driver_probe_device+0x2a3/0x480
           __driver_attach+0xd9/0xe0
           bus_for_each_dev+0x57/0x90
           bus_add_driver+0x168/0x260
           driver_register+0x52/0xc0
           do_one_initcall+0x39/0x150
           do_init_module+0x56/0x1ef
           load_module+0x231c/0x2d70
           SyS_finit_module+0xa5/0xe0
           entry_SYSCALL_64_fastpath+0x1c/0x89
    
    -> #1 (relay_channels_mutex){+.+.}:
           relay_open+0x12c/0x2b0
           intel_guc_log_runtime_create+0xab/0x230 [i915]
           intel_guc_init+0x81/0x120 [i915]
           intel_uc_init+0x29/0xa0 [i915]
           i915_gem_init+0x182/0x530 [i915]
           i915_driver_load+0xaa9/0x1720 [i915]
           i915_pci_probe+0x2e/0x90 [i915]
           pci_device_probe+0x9c/0x120
           driver_probe_device+0x2a3/0x480
           __driver_attach+0xd9/0xe0
           bus_for_each_dev+0x57/0x90
           bus_add_driver+0x168/0x260
           driver_register+0x52/0xc0
           do_one_initcall+0x39/0x150
           do_init_module+0x56/0x1ef
           load_module+0x231c/0x2d70
           SyS_finit_module+0xa5/0xe0
           entry_SYSCALL_64_fastpath+0x1c/0x89
    
    -> #0 (&dev->struct_mutex){+.+.}:
           __mutex_lock+0x81/0x9b0
           i915_mutex_lock_interruptible+0x47/0x130 [i915]
           i915_gem_fault+0x201/0x790 [i915]
           __do_fault+0x15/0x70
           __handle_mm_fault+0x677/0xdc0
           handle_mm_fault+0x14f/0x2f0
           __do_page_fault+0x2d1/0x560
           page_fault+0x4c/0x60
    
    other info that might help us debug this:
    
    Chain exists of:
      &dev->struct_mutex --> &sb->s_type->i_mutex_key#3 --> &mm->mmap_sem
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&mm->mmap_sem);
                                   lock(&sb->s_type->i_mutex_key#3);
                                   lock(&mm->mmap_sem);
      lock(&dev->struct_mutex);
    
     *** DEADLOCK ***
    
    1 lock held by debugfs_test/1388:
     #0:  (&mm->mmap_sem){++++}, at: [<0000000029a9c131>] __do_page_fault+0x106/0x560
    
    stack backtrace:
    CPU: 2 PID: 1388 Comm: debugfs_test Not tainted 4.15.0-rc6-CI-Patchwork_7614+ #1
    Hardware name: To Be Filled By O.E.M. To Be Filled By O.E.M./J4205-ITX, BIOS P1.10 09/29/2016
    Call Trace:
     dump_stack+0x5f/0x86
     print_circular_bug.isra.18+0x1d0/0x2c0
     __lock_acquire+0x14ae/0x1b60
     ? lock_acquire+0xaf/0x200
     lock_acquire+0xaf/0x200
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     __mutex_lock+0x81/0x9b0
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? __pm_runtime_resume+0x4f/0x80
     i915_gem_fault+0x201/0x790 [i915]
     __do_fault+0x15/0x70
     ? _raw_spin_unlock+0x29/0x40
     __handle_mm_fault+0x677/0xdc0
     handle_mm_fault+0x14f/0x2f0
     __do_page_fault+0x2d1/0x560
     ? page_fault+0x36/0x60
     page_fault+0x4c/0x60
    
    v2: Added lock protection to guc->log.runtime.relay_chan (Chris)
        Fixed locking inside guc_flush_logs uncovered by new lockdep.
    
    v3: Locking guc_read_update_log_buffer entirely with relay_lock. (Chris)
        Prepared intel_guc_init_early. Moved relay_lock inside relay_create
        relay_destroy, relay_file_create, guc_read_update_log_buffer. (Michal)
        Removed struct_mutex lock around guc_log_flush and removed usage
        of guc_log_has_relay() from runtime_create path as it needs
        struct_mutex lock.
    
    v4: Handle NULL relay sub buffer pointer earlier in read_update_log_buffer
        (Chris). Fixed comment suffix **/. (Michal)
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=104693
    Testcase: igt/debugfs_test/read_all_entries # with enable_guc=1 and guc_log_level=1
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1516808821-3638-3-git-send-email-sagar.a.kamble@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 95e1c161a887..1ec12add34b2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -626,7 +626,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	i915_gem_contexts_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
-	intel_uc_fini_wq(dev_priv);
+	intel_uc_fini_misc(dev_priv);
 	i915_gem_cleanup_userptr(dev_priv);
 
 	i915_gem_drain_freed_objects(dev_priv);

commit 1ed21cb4142bccd23d988e2b47541c302f4d09fb
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Wed Jan 24 21:16:57 2018 +0530

    drm/i915/guc: Enable interrupts before resuming GuC during runtime resume
    
    GuC log streaming needs interrupts enabled prior to GuC resume but
    runtime pm interrupt setup was happening post GuC resume. Fix it.
    While at it, fix the unwinding of steps in the runtime suspend path.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=104695
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1516808821-3638-2-git-send-email-sagar.a.kamble@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1fbe37889d92..95e1c161a887 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2600,6 +2600,11 @@ static int intel_runtime_suspend(struct device *kdev)
 
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
+		intel_guc_resume(dev_priv);
+
+		i915_gem_init_swizzling(dev_priv);
+		i915_gem_restore_fences(dev_priv);
+
 		enable_rpm_wakeref_asserts(dev_priv);
 
 		return ret;
@@ -2665,8 +2670,6 @@ static int intel_runtime_resume(struct device *kdev)
 	if (intel_uncore_unclaimed_mmio(dev_priv))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
-	intel_guc_resume(dev_priv);
-
 	if (IS_GEN9_LP(dev_priv)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);
@@ -2681,6 +2684,10 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_uncore_runtime_resume(dev_priv);
 
+	intel_runtime_pm_enable_interrupts(dev_priv);
+
+	intel_guc_resume(dev_priv);
+
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
@@ -2688,8 +2695,6 @@ static int intel_runtime_resume(struct device *kdev)
 	i915_gem_init_swizzling(dev_priv);
 	i915_gem_restore_fences(dev_priv);
 
-	intel_runtime_pm_enable_interrupts(dev_priv);
-
 	/*
 	 * On VLV/CHV display interrupts are part of the display
 	 * power well, so hpd is reinitialized from there. For

commit 5c8ea01830b1e5a29b6a949e6b69eb606d335fa9
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Thu Jan 11 16:00:10 2018 -0200

    drm/i915/icp: Add the ID for ICL PCH - ICP
    
    Add the PCI ID for the ICL PCH - ICP.
    
    v2: rebased.
    v3: rebased.
    v4: fix ICP name.
    v5: fix the ID mask (Fei Li).
    v6 (from Paulo): bikesheds.
    
    Cc: Li, Fei <fei.li@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180111180010.24357-9-paulo.r.zanoni@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 173d0095e3b2..1fbe37889d92 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -252,6 +252,10 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
+			} else if (id == INTEL_PCH_ICP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_ICP;
+				DRM_DEBUG_KMS("Found Ice Lake PCH\n");
+				WARN_ON(!IS_ICELAKE(dev_priv));
 			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
 				   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
 				   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&

commit ac25dfed15d470d7f23dd817e965b54aa3f94a1e
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jan 16 16:53:24 2018 +0100

    drm/i915: Always call to intel_display_set_init_power() in resume_early.
    
    intel_power_domains_init_hw() calls set_init_power, but when using
    runtime power management this call is skipped. This prevents hw readout
    from taking place.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=104172
    Link: https://patchwork.freedesktop.org/patch/msgid/20180116155324.75120-1-maarten.lankhorst@linux.intel.com
    Fixes: bc87229f323e ("drm/i915/skl: enable PC9/10 power states during suspend-to-idle")
    Cc: Nivedita Swaminathan <nivedita.swaminathan@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: <stable@vger.kernel.org> # v4.5+
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c8da9d20c33..173d0095e3b2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1842,6 +1842,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	if (IS_GEN9_LP(dev_priv) ||
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
+	else
+		intel_display_set_init_power(dev_priv, true);
 
 	i915_gem_sanitize(dev_priv);
 

commit 27d558a1a0ab07bcf15b3ca7e816f9ed2f558e59
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Dec 21 21:57:35 2017 +0000

    drm/i915: Dump device info at once
    
    We are dumping device info separately for sw_only and runtime part
    but to simplify the code we can also do it from one place once
    we complete driver load.
    
    v2: use dedicated welcome function (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221185334.17396-8-michal.wajdeczko@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221215735.30314-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5bf4f589594a..6c8da9d20c33 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -931,12 +931,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_display_crc_init(dev_priv);
 
-	if (drm_debug & DRM_UT_DRIVER) {
-		struct drm_printer p = drm_debug_printer("i915 device info:");
-
-		intel_device_info_dump(&dev_priv->info, &p);
-	}
-
 	intel_detect_preproduction_hw(dev_priv);
 
 	return 0;
@@ -1089,11 +1083,6 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		return -ENODEV;
 
 	intel_device_info_runtime_init(mkwrite_device_info(dev_priv));
-	if (drm_debug & DRM_UT_DRIVER) {
-		struct drm_printer p = drm_debug_printer("i915 device info:");
-
-		intel_device_info_dump_runtime(&dev_priv->info, &p);
-	}
 
 	intel_sanitize_options(dev_priv);
 
@@ -1303,6 +1292,21 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_gem_shrinker_unregister(dev_priv);
 }
 
+static void i915_welcome_messages(struct drm_i915_private *dev_priv)
+{
+	if (drm_debug & DRM_UT_DRIVER) {
+		struct drm_printer p = drm_debug_printer("i915 device info:");
+
+		intel_device_info_dump(&dev_priv->info, &p);
+		intel_device_info_dump_runtime(&dev_priv->info, &p);
+	}
+
+	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
+		DRM_INFO("DRM_I915_DEBUG enabled\n");
+	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
+		DRM_INFO("DRM_I915_DEBUG_GEM enabled\n");
+}
+
 /**
  * i915_driver_load - setup chip and create an initial config
  * @pdev: PCI device
@@ -1388,13 +1392,10 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	intel_init_ipc(dev_priv);
 
-	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
-		DRM_INFO("DRM_I915_DEBUG enabled\n");
-	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
-		DRM_INFO("DRM_I915_DEBUG_GEM enabled\n");
-
 	intel_runtime_pm_put(dev_priv);
 
+	i915_welcome_messages(dev_priv);
+
 	return 0;
 
 out_cleanup_hw:

commit 5fbbe8d4e102352af0349f0d5fe9d567319e0877
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Dec 21 21:57:34 2017 +0000

    drm/i915: Add pretty printer for runtime part of intel_device_info
    
    During initialization of the runtime part of the intel_device_info
    we are dumping that part using DRM_DEBUG_DRIVER mechanism.
    As we already have pretty printer for const part of the info,
    make similar function for the runtime part and use it separately.
    
    v2: add runtime dump to debugfs (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221185334.17396-7-michal.wajdeczko@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221215735.30314-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 06eea8dab464..5bf4f589594a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1089,6 +1089,11 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		return -ENODEV;
 
 	intel_device_info_runtime_init(mkwrite_device_info(dev_priv));
+	if (drm_debug & DRM_UT_DRIVER) {
+		struct drm_printer p = drm_debug_printer("i915 device info:");
+
+		intel_device_info_dump_runtime(&dev_priv->info, &p);
+	}
 
 	intel_sanitize_options(dev_priv);
 

commit 6a7e51f35ae3920a6925f17e2d7cda5c869816ee
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Dec 21 21:57:33 2017 +0000

    drm/i915: Update intel_device_info_runtime_init() parameter
    
    As we try to follow object-verb pattern in our functions, update
    intel_device_info_runtime_init() parameter from dev_priv to info.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221185334.17396-6-michal.wajdeczko@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221215735.30314-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6f14986dcd11..06eea8dab464 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1088,7 +1088,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	intel_device_info_runtime_init(dev_priv);
+	intel_device_info_runtime_init(mkwrite_device_info(dev_priv));
 
 	intel_sanitize_options(dev_priv);
 

commit eb10ed9a9e1ecacafab5535c86b62061b39360e5
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Tue Dec 19 11:43:45 2017 +0000

    drm/i915: Convert intel_device_info_dump into pretty printer
    
    Convert intel_device_info_dump into pretty printer to be
    consistent with the rest of the driver code.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171219114346.26308-2-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 72bea281edb7..6f14986dcd11 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -931,7 +931,11 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_display_crc_init(dev_priv);
 
-	intel_device_info_dump(dev_priv);
+	if (drm_debug & DRM_UT_DRIVER) {
+		struct drm_printer p = drm_debug_printer("i915 device info:");
+
+		intel_device_info_dump(&dev_priv->info, &p);
+	}
 
 	intel_detect_preproduction_hw(dev_priv);
 

commit a31d73c3a7218539bc25fc298ac6cd5b66d96b86
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Dec 17 13:28:50 2017 +0000

    drm/i915: Re-enable GGTT earlier after GPU reset
    
    Inside i915_gem_reset(), we start touching the HW and so require the
    low-level HW to be re-enabled, in particular the PCI BARs.
    
    Fixes: 7b6da818d86f ("drm/i915: Restore the kernel context after a GPU reset on an idle engine")
    References: 0db8c9612091 ("drm/i915: Re-enable GTT following a device reset")
    Testcase: igt/drv_hangman #i915g/i915gm
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171217132852.30642-1-chris@chris-wilson.co.uk
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6d39fdf2b604..72bea281edb7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1924,9 +1924,6 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 		goto taint;
 	}
 
-	i915_gem_reset(i915);
-	intel_overlay_reset(i915);
-
 	/* Ok, now get things going again... */
 
 	/*
@@ -1939,6 +1936,9 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 		goto error;
 	}
 
+	i915_gem_reset(i915);
+	intel_overlay_reset(i915);
+
 	/*
 	 * Next we need to restore the context, but we don't use those
 	 * yet either...

commit f6ba181ada5572304c29cff44f04c15fa295f547
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Dec 16 00:22:06 2017 +0000

    drm/i915: Skip an engine reset if it recovered before our preparations
    
    At the beginning of a reset, we disable the submission method and find
    the stuck request. We expect to find a stuck request for we have
    declared the engine stalled. However, if we find no active request, the
    engine must have recovered from its stall before we could issue a reset,
    so let the engine continue on without a reset. If the engine is truly
    stuck, we will back soon enough with the next reset attempt.
    
    v2: Remove the stale debug message.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171216002206.31737-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca9f4b2862eb..6d39fdf2b604 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2011,19 +2011,19 @@ int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
 
 	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
 
+	active_request = i915_gem_reset_prepare_engine(engine);
+	if (IS_ERR_OR_NULL(active_request)) {
+		/* Either the previous reset failed, or we pardon the reset. */
+		ret = PTR_ERR(active_request);
+		goto out;
+	}
+
 	if (!(flags & I915_RESET_QUIET)) {
 		dev_notice(engine->i915->drm.dev,
 			   "Resetting %s after gpu hang\n", engine->name);
 	}
 	error->reset_engine_count[engine->id]++;
 
-	active_request = i915_gem_reset_prepare_engine(engine);
-	if (IS_ERR(active_request)) {
-		DRM_DEBUG_DRIVER("Previous reset failed, promote to full reset\n");
-		ret = PTR_ERR(active_request);
-		goto out;
-	}
-
 	if (!engine->i915->guc.execbuf_client)
 		ret = intel_gt_reset_engine(engine->i915, engine);
 	else

commit 61b5c1587dd82a8493d7838bb2f9289fd0903364
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Wed Dec 13 23:13:48 2017 +0100

    drm/i915/guc: Extract guc_init from guc_init_hw
    
    After GPU reset, GuC HW needs to be reinitialized (with FW reload).
    Unfortunately, we're doing some extra work there (mostly allocating stuff),
    work that can be moved to guc_init and called once at driver load time.
    
    As a side effect we're no longer hitting an assert in
    i915_ggtt_enable_guc on suspend/resume.
    
    v2: Do not duplicate disable_communication / reset_guc_interrupts
    v3: Add proper teardown after rebase
    
    References: 04f7b24eccdf ("drm/i915/guc: Assert that we switch between known ggtt->invalidate functions")
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171213221352.7173-3-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 285c8b238bff..ca9f4b2862eb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -617,6 +617,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 
 	mutex_lock(&dev_priv->drm.struct_mutex);
 	intel_uc_fini_hw(dev_priv);
+	intel_uc_fini(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_contexts_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);

commit 3176ff49bc3e56871ec9f338cac759dacd0135e1
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Wed Dec 13 23:13:47 2017 +0100

    drm/i915/guc: Move GuC workqueue allocations outside of the mutex
    
    This gets rid of the following lockdep splat:
    
    ======================================================
    WARNING: possible circular locking dependency detected
    4.15.0-rc2-CI-Patchwork_7428+ #1 Not tainted
    ------------------------------------------------------
    debugfs_test/1351 is trying to acquire lock:
     (&dev->struct_mutex){+.+.}, at: [<000000009d90d1a3>] i915_mutex_lock_interruptible+0x47/0x130 [i915]
    
    but task is already holding lock:
     (&mm->mmap_sem){++++}, at: [<000000005df01c1e>] __do_page_fault+0x106/0x560
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #6 (&mm->mmap_sem){++++}:
           __might_fault+0x63/0x90
           _copy_to_user+0x1e/0x70
           filldir+0x8c/0xf0
           dcache_readdir+0xeb/0x160
           iterate_dir+0xe6/0x150
           SyS_getdents+0xa0/0x130
           entry_SYSCALL_64_fastpath+0x1c/0x89
    
    -> #5 (&sb->s_type->i_mutex_key#5){++++}:
           lockref_get+0x9/0x20
    
    -> #4 ((completion)&req.done){+.+.}:
           wait_for_common+0x54/0x210
           devtmpfs_create_node+0x130/0x150
           device_add+0x5ad/0x5e0
           device_create_groups_vargs+0xd4/0xe0
           device_create+0x35/0x40
           msr_device_create+0x22/0x40
           cpuhp_invoke_callback+0xc5/0xbf0
           cpuhp_thread_fun+0x167/0x210
           smpboot_thread_fn+0x17f/0x270
           kthread+0x173/0x1b0
           ret_from_fork+0x24/0x30
    
    -> #3 (cpuhp_state-up){+.+.}:
           cpuhp_issue_call+0x132/0x1c0
           __cpuhp_setup_state_cpuslocked+0x12f/0x2a0
           __cpuhp_setup_state+0x3a/0x50
           page_writeback_init+0x3a/0x5c
           start_kernel+0x393/0x3e2
           secondary_startup_64+0xa5/0xb0
    
    -> #2 (cpuhp_state_mutex){+.+.}:
           __mutex_lock+0x81/0x9b0
           __cpuhp_setup_state_cpuslocked+0x4b/0x2a0
           __cpuhp_setup_state+0x3a/0x50
           page_alloc_init+0x1f/0x26
           start_kernel+0x139/0x3e2
           secondary_startup_64+0xa5/0xb0
    
    -> #1 (cpu_hotplug_lock.rw_sem){++++}:
           cpus_read_lock+0x34/0xa0
           apply_workqueue_attrs+0xd/0x40
           __alloc_workqueue_key+0x2c7/0x4e1
           intel_guc_submission_init+0x10c/0x650 [i915]
           intel_uc_init_hw+0x29e/0x460 [i915]
           i915_gem_init_hw+0xca/0x290 [i915]
           i915_gem_init+0x115/0x3a0 [i915]
           i915_driver_load+0x9a8/0x16c0 [i915]
           i915_pci_probe+0x2e/0x90 [i915]
           pci_device_probe+0x9c/0x120
           driver_probe_device+0x2a3/0x480
           __driver_attach+0xd9/0xe0
           bus_for_each_dev+0x57/0x90
           bus_add_driver+0x168/0x260
           driver_register+0x52/0xc0
           do_one_initcall+0x39/0x150
           do_init_module+0x56/0x1ef
           load_module+0x231c/0x2d70
           SyS_finit_module+0xa5/0xe0
           entry_SYSCALL_64_fastpath+0x1c/0x89
    
    -> #0 (&dev->struct_mutex){+.+.}:
           lock_acquire+0xaf/0x200
           __mutex_lock+0x81/0x9b0
           i915_mutex_lock_interruptible+0x47/0x130 [i915]
           i915_gem_fault+0x201/0x760 [i915]
           __do_fault+0x15/0x70
           __handle_mm_fault+0x85b/0xe40
           handle_mm_fault+0x14f/0x2f0
           __do_page_fault+0x2d1/0x560
           page_fault+0x22/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &dev->struct_mutex --> &sb->s_type->i_mutex_key#5 --> &mm->mmap_sem
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&mm->mmap_sem);
                                   lock(&sb->s_type->i_mutex_key#5);
                                   lock(&mm->mmap_sem);
      lock(&dev->struct_mutex);
    
     *** DEADLOCK ***
    
    1 lock held by debugfs_test/1351:
     #0:  (&mm->mmap_sem){++++}, at: [<000000005df01c1e>] __do_page_fault+0x106/0x560
    
    stack backtrace:
    CPU: 2 PID: 1351 Comm: debugfs_test Not tainted 4.15.0-rc2-CI-Patchwork_7428+ #1
    Hardware name:                  /NUC6i5SYB, BIOS SYSKLi35.86A.0057.2017.0119.1758 01/19/2017
    Call Trace:
     dump_stack+0x5f/0x86
     print_circular_bug+0x230/0x3b0
     check_prev_add+0x439/0x7b0
     ? lockdep_init_map_crosslock+0x20/0x20
     ? unwind_get_return_address+0x16/0x30
     ? __lock_acquire+0x1385/0x15a0
     __lock_acquire+0x1385/0x15a0
     lock_acquire+0xaf/0x200
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     __mutex_lock+0x81/0x9b0
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? i915_mutex_lock_interruptible+0x47/0x130 [i915]
     i915_mutex_lock_interruptible+0x47/0x130 [i915]
     ? __pm_runtime_resume+0x4f/0x80
     i915_gem_fault+0x201/0x760 [i915]
     __do_fault+0x15/0x70
     __handle_mm_fault+0x85b/0xe40
     handle_mm_fault+0x14f/0x2f0
     __do_page_fault+0x2d1/0x560
     page_fault+0x22/0x30
    RIP: 0033:0x7f98d6f49116
    RSP: 002b:00007ffd6ffc3278 EFLAGS: 00010283
    RAX: 00007f98d39a2bc0 RBX: 0000000000000000 RCX: 0000000000001680
    RDX: 0000000000001680 RSI: 00007ffd6ffc3400 RDI: 00007f98d39a2bc0
    RBP: 00007ffd6ffc33a0 R08: 0000000000000000 R09: 00000000000005a0
    R10: 000055e847c2a830 R11: 0000000000000002 R12: 0000000000000001
    R13: 000055e847c1d040 R14: 00007ffd6ffc3400 R15: 00007f98d6752ba0
    
    v2: Init preempt_work unconditionally (Chris)
    v3: Mention that we need the enable_guc=1 for lockdep splat (Chris)
    
    Testcase: igt/debugfs_test/read_all_entries # with i915.enable_guc=1
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171213221352.7173-2-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 721ccce1832f..285c8b238bff 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -621,6 +621,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	i915_gem_contexts_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
+	intel_uc_fini_wq(dev_priv);
 	i915_gem_cleanup_userptr(dev_priv);
 
 	i915_gem_drain_freed_objects(dev_priv);

commit 3ef98f50ca7cef5cc9b9bf89cd46830afbf4df68
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Dec 11 20:40:40 2017 +0000

    drm/i915: Print an error message for a reset failure on gen2
    
    Since on gen2, we do not universally have a GPU reset implementation, we
    fail i915_reset() at intel_has_gpu_reset(). However, this is also
    intentionally disabled for CI testing and so it only has a debug
    message. Promote that debug message to a user-facing error message that
    should explain why their machine became unusable following the GPU hang.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211204040.22858-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 54a8fca7e7b2..721ccce1832f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1903,7 +1903,10 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	}
 
 	if (!intel_has_gpu_reset(i915)) {
-		DRM_DEBUG_DRIVER("GPU reset disabled\n");
+		if (i915_modparams.reset)
+			dev_err(i915->drm.dev, "GPU reset not supported\n");
+		else
+			DRM_DEBUG_DRIVER("GPU reset disabled\n");
 		goto error;
 	}
 

commit 73ebd503034c1abe31137df02dd4493eb7a522d4
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Mon Dec 11 15:18:20 2017 +0000

    drm/i915: make mappable struct resource centric
    
    Now that we are using struct resource to track the stolen region, it is
    more convenient if we track the mappable region in a resource as well.
    
    v2: prefer iomap and gmadr naming scheme
        prefer DEFINE_RES_MEM
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171211151822.20953-8-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5b1fd5f1defb..54a8fca7e7b2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -726,7 +726,7 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 	if (!ap)
 		return -ENOMEM;
 
-	ap->ranges[0].base = ggtt->mappable_base;
+	ap->ranges[0].base = ggtt->gmadr.start;
 	ap->ranges[0].size = ggtt->mappable_end;
 
 	primary =

commit 6647852abc1fd74e9c5e0dcf404ea4cb9c929630
Merge: 3e72be177cf1 3f1f0b1c57dd
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Dec 8 10:15:30 2017 -0800

    Merge airlied/drm-next into drm-intel-next-queued
    
    Chris requested this backmerge for a reconciliation on
    drm_print.h between drm-misc-next and drm-intel-next-queued
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

commit 3f1f0b1c57dd617e9b0ded50efb8d6c011b85b20
Merge: 5c379b4f4fd0 d65efe7c9513
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Dec 8 08:39:14 2017 +1000

    Merge tag 'drm-intel-next-2017-12-01' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    [airlied: fix conflict in intel_dsi.c]
    
    drm-intel-next-2017-12-01:
    
    - Init clock gate fix (Ville)
    - Execlists event handling corrections (Chris, Michel)
    - Improvements on GPU Cache invalidation and context switch (Chris)
    - More perf OA changes (Lionel)
    - More selftests improvements and fixes (Chris, Matthew)
    - Clean-up on modules parameters (Chris)
    - Clean-up around old ringbuffer submission and hw semaphore on old platforms (Chris)
    - More Cannonlake stabilization effort (David, James)
    - Display planes clean-up and improvements (Ville)
    - New PMU interface for perf queries... (Tvrtko)
    - ... and other subsequent PMU changes and fixes (Tvrtko, Chris)
    - Remove success dmesg noise from rotation (Chris)
    - New DMC for Kabylake (Anusha)
    - Fixes around atomic commits (Daniel)
    - GuC updates and fixes (Sagar, Michal, Chris)
    - Couple gmbus/i2c fixes (Ville)
    - Use exponential backoff for all our wait_for() (Chris)
    - Fixes for i915/fbdev (Chris)
    - Backlight fixes (Arnd)
    - Updates on shrinker (Chris)
    - Make Hotplug enable more robuts (Chris)
    - Disable huge pages (TPH) on lack of a needed workaround (Joonas)
    - New GuC images for SKL, KBL, BXT (Sagar)
    - Add HW Workaround for Geminilake performance (Valtteri)
    - Fixes for PPS timings (Imre)
    - More IPS fixes (Maarten)
    - Many fixes for Display Port on gen2-gen4 (Ville)
    - Retry GPU reset making the recover from hang more robust (Chris)
    
    * tag 'drm-intel-next-2017-12-01' of git://anongit.freedesktop.org/drm/drm-intel: (101 commits)
      drm/i915: Update DRIVER_DATE to 20171201
      drm/i915/cnl: Mask previous DDI - PLL mapping
      drm/i915: Remove unsafe i915.enable_rc6
      drm/i915: Sleep and retry a GPU reset if at first we don't succeed
      drm/i915: Interlaced DP output doesn't work on VLV/CHV
      drm/i915: Pass crtc state to intel_pipe_{enable,disable}()
      drm/i915: Wait for pipe to start on i830 as well
      drm/i915: Fix vblank timestamp/frame counter jumps on gen2
      drm/i915: Fix deadlock in i830_disable_pipe()
      drm/i915: Fix has_audio readout for DDI A
      drm/i915: Don't add the "force audio" property to DP connectors that don't support audio
      drm/i915: Disable DP audio for g4x
      drm/i915/selftests: Wake the device before executing requests on the GPU
      drm/i915: Set fake_vma.size as well as fake_vma.node.size for capture
      drm/i915: Tidy up signed/unsigned comparison
      drm/i915: Enable IPS with only sprite plane visible too, v4.
      drm/i915: Make ips_enabled a property depending on whether IPS is enabled, v3.
      drm/i915: Avoid PPS HW/SW state mismatch due to rounding
      drm/i915: Skip switch-to-kernel-context on suspend when wedged
      drm/i915/glk: Apply WaProgramL3SqcReg1DefaultForPerf for GLK too
      ...

commit 107783d00a067cd3e2ebf4564b1b8c03915186e9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Dec 5 17:27:57 2017 +0000

    drm/i915: Taint (TAINT_WARN) the kernel if the GPU reset fails
    
    History tells us that if we cannot reset the GPU now, we never will. This
    then impacts everything that is run subsequently. On failing the reset,
    we mark the driver as wedged, trying to prevent further execution on the
    GPU, forcing userspace to fallback to using the CPU to update its
    framebuffers and let the user know what happened.
    
    We also want to go one step further and add a taint to the kernel so that
    any subsequent faults can be traced back to this failure. This is
    useful for CI, where if the GPU/driver fails we want to reboot and
    restart testing rather than continue on into oblivion. For everyone
    else, the warning taint is a testament to the system unreliability.
    
    TAINT_WARN is used anytime a WARN() is emitted, which is suitable for
    our purposes here as well; the driver/system may behave unexpectedly
    after the failure.
    
    v2: Also taint if the recovery fails (again history shows us that is
    typically fatal).
    v3: Use TAINT_WARN
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=103514
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171205172757.32609-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 962d7c7c799c..b2e210b77457 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1897,9 +1897,9 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	disable_irq(i915->drm.irq);
 	ret = i915_gem_reset_prepare(i915);
 	if (ret) {
-		DRM_ERROR("GPU recovery failed\n");
+		dev_err(i915->drm.dev, "GPU recovery failed\n");
 		intel_gpu_reset(i915, ALL_ENGINES);
-		goto error;
+		goto taint;
 	}
 
 	if (!intel_has_gpu_reset(i915)) {
@@ -1916,7 +1916,7 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	}
 	if (ret) {
 		dev_err(i915->drm.dev, "Failed to reset chip\n");
-		goto error;
+		goto taint;
 	}
 
 	i915_gem_reset(i915);
@@ -1959,6 +1959,20 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	wake_up_bit(&error->flags, I915_RESET_HANDOFF);
 	return;
 
+taint:
+	/*
+	 * History tells us that if we cannot reset the GPU now, we
+	 * never will. This then impacts everything that is run
+	 * subsequently. On failing the reset, we mark the driver
+	 * as wedged, preventing further execution on the GPU.
+	 * We also want to go one step further and add a taint to the
+	 * kernel so that any subsequent faults can be traced back to
+	 * this failure. This is important for CI, where if the
+	 * GPU/driver fails we would like to reboot and restart testing
+	 * rather than continue on into oblivion. For everyone else,
+	 * the system should still plod along, but they have been warned!
+	 */
+	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
 error:
 	i915_gem_set_wedged(i915);
 	i915_gem_retire_requests(i915);

commit ca797d29cd63e7b71b4eea29aff3b1cefd1ecb59
Merge: 2c1c55cb75a9 010d118c2061
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 4 09:40:35 2017 +1000

    Merge tag 'drm-intel-next-2017-11-17-1' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    More change sets for 4.16:
    
    - Many improvements for selftests and other igt tests (Chris)
    - Forcewake with PUNIT->PMIC bus fixes and robustness (Hans)
    - Define an engine class for uABI (Tvrtko)
    - Context switch fixes and improvements (Chris)
    - GT powersavings and power gating simplification and fixes (Chris)
    - Other general driver clean-ups (Chris, Lucas, Ville)
    - Removing old, useless and/or bad workarounds (Chris, Oscar, Radhakrishna)
    - IPS, pipe config, etc in preparation for another Fast Boot attempt (Maarten)
    - OA perf fixes and support to Coffee Lake and Cannonlake (Lionel)
    - Fixes around GPU fault registers (Michel)
    - GEM Proxy (Tina)
    - Refactor of Geminilake and Cannonlake plane color handling (James)
    - Generalize transcoder loop (Mika Kahola)
    - New HW Workaround for Cannonlake and Geminilake (Rodrigo)
    - Resume GuC before using GEM (Chris)
    - Stolen Memory handling improvements (Ville)
    - Initialize entry in PPAT for older compilers (Chris)
    - Other fixes and robustness improvements on execbuf (Chris)
    - Improve logs of GEM_BUG_ON (Mika Kuoppala)
    - Rework with massive rename of GuC functions and files (Sagar)
    - Don't sanitize frame start delay if pipe is off (Ville)
    - Cannonlake clock fixes (Rodrigo)
    - Cannonlake HDMI 2.0 support (Rodrigo)
    - Add a GuC doorbells selftest (Michel)
    - Add might_sleep() check to our wait_for() (Chris)
    
    Many GVT changes for 4.16:
    
    - CSB HWSP update support (Weinan)
    - GVT debug helpers, dyndbg and debugfs (Chuanxiao, Shuo)
    - full virtualized opregion (Xiaolin)
    - VM health check for sane fallback (Fred)
    - workload submission code refactor for future enabling (Zhi)
    - Updated repo URL in MAINTAINERS (Zhenyu)
    - other many misc fixes
    
    * tag 'drm-intel-next-2017-11-17-1' of git://anongit.freedesktop.org/drm/drm-intel: (260 commits)
      drm/i915: Update DRIVER_DATE to 20171117
      drm/i915: Add a policy note for removing workarounds
      drm/i915/selftests: Report ENOMEM clearly for an allocation failure
      Revert "drm/i915: Display WA #1133 WaFbcSkipSegments:cnl, glk"
      drm/i915: Calculate g4x intermediate watermarks correctly
      drm/i915: Calculate vlv/chv intermediate watermarks correctly, v3.
      drm/i915: Pass crtc_state to ips toggle functions, v2
      drm/i915: Pass idle crtc_state to intel_dp_sink_crc
      drm/i915: Enable FIFO underrun reporting after initial fastset, v4.
      drm/i915: Mark the userptr invalidate workqueue as WQ_MEM_RECLAIM
      drm/i915: Add might_sleep() check to wait_for()
      drm/i915/selftests: Add a GuC doorbells selftest
      drm/i915/cnl: Extend HDMI 2.0 support to CNL.
      drm/i915/cnl: Simplify dco_fraction calculation.
      drm/i915/cnl: Don't blindly replace qdiv.
      drm/i915/cnl: Fix wrpll math for higher freqs.
      drm/i915/cnl: Fix, simplify and unify wrpll variable sizes.
      drm/i915/cnl: Remove useless conversion.
      drm/i915/cnl: Remove spurious central_freq.
      drm/i915/selftests: exercise_ggtt may have nothing to do
      ...

commit fb6db0f5bf1d4d3a4af6242e287fa795221ec5b8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Dec 1 11:30:30 2017 +0000

    drm/i915: Remove unsafe i915.enable_rc6
    
    It has been many years since the last confirmed sighting (and fix) of an
    RC6 related bug (usually a system hang). Remove the parameter to stop
    users from setting dangerous values, as they often set it during triage
    and end up disabling the entire runtime pm instead (the option is not a
    fine scalpel!).
    
    Furthermore, it allows users to set known dangerous values which were
    intended for testing and not for production use. For testing, we can
    always patch in the required setting without having to expose ourselves
    to random abuse.
    
    v2: Fixup NEEDS_WaRsDisableCoarsePowerGating fumble, and document the
    lack of ilk support better.
    v3: Clear intel_info->rc6p if we don't support rc6 itself.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171201113030.18360-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43fbff48a133..962d7c7c799c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2527,7 +2527,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
-	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && intel_rc6_enabled())))
+	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && HAS_RC6(dev_priv))))
 		return -ENODEV;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))

commit f7096d40eea84d32eb1e3b0f2b4407167aae9a83
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Dec 1 12:20:11 2017 +0000

    drm/i915: Sleep and retry a GPU reset if at first we don't succeed
    
    As we declare the GPU wedged if the reset fails, such a failure is quite
    terminal. Before taking that drastic action, let's sleep first and try
    active, in the hope that the hardware has quietened down and is then
    able to reset. After a few such attempts, it is fair to say that the HW
    is truly wedged.
    
    v2: Always print the failure message now, we precheck whether resets are
    disabled.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=104007
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171201122011.16841-1-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1c419893e3a9..43fbff48a133 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1877,7 +1877,9 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 {
 	struct i915_gpu_error *error = &i915->gpu_error;
 	int ret;
+	int i;
 
+	might_sleep();
 	lockdep_assert_held(&i915->drm.struct_mutex);
 	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
 
@@ -1900,12 +1902,20 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 		goto error;
 	}
 
-	ret = intel_gpu_reset(i915, ALL_ENGINES);
+	if (!intel_has_gpu_reset(i915)) {
+		DRM_DEBUG_DRIVER("GPU reset disabled\n");
+		goto error;
+	}
+
+	for (i = 0; i < 3; i++) {
+		ret = intel_gpu_reset(i915, ALL_ENGINES);
+		if (ret == 0)
+			break;
+
+		msleep(100);
+	}
 	if (ret) {
-		if (ret != -ENODEV)
-			DRM_ERROR("Failed to reset chip: %i\n", ret);
-		else
-			DRM_DEBUG_DRIVER("GPU reset disabled\n");
+		dev_err(i915->drm.dev, "Failed to reset chip\n");
 		goto error;
 	}
 

commit 43f462f1c2e111d2882b48baeeff774ae42e7c56
Merge: 3c02a6d94665 c209101fc1c9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 28 10:01:15 2017 -0800

    Merge tag 'drm-for-v4.15-part2-fixes' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm fixes from Dave Airlie:
    
     - TTM regression fix for some virt gpus (bochs vga)
    
     - a few i915 stable fixes
    
     - one vc4 fix
    
     - one uapi fix
    
    * tag 'drm-for-v4.15-part2-fixes' of git://people.freedesktop.org/~airlied/linux:
      drm/ttm: don't attempt to use hugepages if dma32 requested (v2)
      drm/vblank: Pass crtc_id to page_flip_ioctl.
      drm/i915: Fix init_clock_gating for resume
      drm/i915: Mark the userptr invalidate workqueue as WQ_MEM_RECLAIM
      drm/i915: Clear breadcrumb node when cancelling signaling
      drm/i915/gvt: ensure -ve return value is handled correctly
      drm/i915: Re-register PMIC bus access notifier on runtime resume
      drm/i915: Fix false-positive assert_rpm_wakelock_held in i915_pmic_bus_access_notifier v2
      drm/edid: Don't send non-zero YQ in AVI infoframe for HDMI 1.x sinks
      drm/vc4: Account for interrupts in flight

commit 448aa9117cfa6591c4e18cb32a0329a66b9cd3b7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 28 11:01:47 2017 +0000

    drm/i915: Enable hotplug polling after registering the outputs
    
    Previously we would enable hotplug polling on the outputs immediately
    upon construction. This would allow a very early hotplug event to
    trigger before we had finishing setting up the driver to handle it.
    Instead, move the output polling to the last step of registration, after
    we have set up all handlers, including the fbdev configuration.
    
    v2: Symmetrically turnoff the hotplug helper in unregister after the
    fbdev is first synchronised then finalized. This stops a late hotplug
    event being processed after the interrupts are disabled.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com> #v1
    Link: https://patchwork.freedesktop.org/patch/msgid/20171128110147.28654-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9c519aa4f550..1c419893e3a9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -693,8 +693,6 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	/* Only enable hotplug handling once the fbdev is fully set up. */
 	intel_hpd_init(dev_priv);
 
-	drm_kms_helper_poll_init(dev);
-
 	return 0;
 
 cleanup_gem:
@@ -1255,6 +1253,13 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 * cannot run before the connectors are registered.
 	 */
 	intel_fbdev_initial_config_async(dev);
+
+	/*
+	 * We need to coordinate the hotplugs with the asynchronous fbdev
+	 * configuration, for which we use the fbdev->async_cookie.
+	 */
+	if (INTEL_INFO(dev_priv)->num_pipes)
+		drm_kms_helper_poll_init(dev);
 }
 
 /**
@@ -1266,6 +1271,13 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	intel_fbdev_unregister(dev_priv);
 	intel_audio_deinit(dev_priv);
 
+	/*
+	 * After flushing the fbdev (incl. a late async config which will
+	 * have delayed queuing of a hotplug event), then flush the hotplug
+	 * events.
+	 */
+	drm_kms_helper_poll_fini(&dev_priv->drm);
+
 	intel_gpu_ips_teardown();
 	acpi_video_unregister();
 	intel_opregion_unregister(dev_priv);

commit 848b365d5d1f0d41d07773c6a69149b2561f29de
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Nov 23 11:53:37 2017 +0000

    drm/i915: Rename shrinker init/cleanup to match driver initialisation phase
    
    Since the shrinker is registered and unregistered during
    i915_driver_register and i915_driver_unregister, respectively, rename
    the init/cleanup functions to match.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171123115338.10270-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0793a27e2b95..9c519aa4f550 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1215,7 +1215,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
 
-	i915_gem_shrinker_init(dev_priv);
+	i915_gem_shrinker_register(dev_priv);
 	i915_pmu_register(dev_priv);
 
 	/*
@@ -1277,7 +1277,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_guc_log_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 
-	i915_gem_shrinker_cleanup(dev_priv);
+	i915_gem_shrinker_unregister(dev_priv);
 }
 
 /**

commit b46a33e271ed81bd765c632b972c49d5b44729c7
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Nov 21 18:18:45 2017 +0000

    drm/i915/pmu: Expose a PMU interface for perf queries
    
    From: Chris Wilson <chris@chris-wilson.co.uk>
    From: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    From: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    
    The first goal is to be able to measure GPU (and invidual ring) busyness
    without having to poll registers from userspace. (Which not only incurs
    holding the forcewake lock indefinitely, perturbing the system, but also
    runs the risk of hanging the machine.) As an alternative we can use the
    perf event counter interface to sample the ring registers periodically
    and send those results to userspace.
    
    Functionality we are exporting to userspace is via the existing perf PMU
    API and can be exercised via the existing tools. For example:
    
      perf stat -a -e i915/rcs0-busy/ -I 1000
    
    Will print the render engine busynnes once per second. All the performance
    counters can be enumerated (perf list) and have their unit of measure
    correctly reported in sysfs.
    
    v1-v2 (Chris Wilson):
    
    v2: Use a common timer for the ring sampling.
    
    v3: (Tvrtko Ursulin)
     * Decouple uAPI from i915 engine ids.
     * Complete uAPI defines.
     * Refactor some code to helpers for clarity.
     * Skip sampling disabled engines.
     * Expose counters in sysfs.
     * Pass in fake regs to avoid null ptr deref in perf core.
     * Convert to class/instance uAPI.
     * Use shared driver code for rc6 residency, power and frequency.
    
    v4: (Dmitry Rogozhkin)
     * Register PMU with .task_ctx_nr=perf_invalid_context
     * Expose cpumask for the PMU with the single CPU in the mask
     * Properly support pmu->stop(): it should call pmu->read()
     * Properly support pmu->del(): it should call stop(event, PERF_EF_UPDATE)
     * Introduce refcounting of event subscriptions.
     * Make pmu.busy_stats a refcounter to avoid busy stats going away
       with some deleted event.
     * Expose cpumask for i915 PMU to avoid multiple events creation of
       the same type followed by counter aggregation by perf-stat.
     * Track CPUs getting online/offline to migrate perf context. If (likely)
       cpumask will initially set CPU0, CONFIG_BOOTPARAM_HOTPLUG_CPU0 will be
       needed to see effect of CPU status tracking.
     * End result is that only global events are supported and perf stat
       works correctly.
     * Deny perf driver level sampling - it is prohibited for uncore PMU.
    
    v5: (Tvrtko Ursulin)
    
     * Don't hardcode number of engine samplers.
     * Rewrite event ref-counting for correctness and simplicity.
     * Store initial counter value when starting already enabled events
       to correctly report values to all listeners.
     * Fix RC6 residency readout.
     * Comments, GPL header.
    
    v6:
     * Add missing entry to v4 changelog.
     * Fix accounting in CPU hotplug case by copying the approach from
       arch/x86/events/intel/cstate.c. (Dmitry Rogozhkin)
    
    v7:
     * Log failure message only on failure.
     * Remove CPU hotplug notification state on unregister.
    
    v8:
     * Fix error unwind on failed registration.
     * Checkpatch cleanup.
    
    v9:
     * Drop the energy metric, it is available via intel_rapl_perf.
       (Ville Syrjälä)
     * Use HAS_RC6(p). (Chris Wilson)
     * Handle unsupported non-engine events. (Dmitry Rogozhkin)
     * Rebase for intel_rc6_residency_ns needing caller managed
       runtime pm.
     * Drop HAS_RC6 checks from the read callback since creating those
       events will be rejected at init time already.
     * Add counter units to sysfs so perf stat output is nicer.
     * Cleanup the attribute tables for brevity and readability.
    
    v10:
     * Fixed queued accounting.
    
    v11:
     * Move intel_engine_lookup_user to intel_engine_cs.c
     * Commit update. (Joonas Lahtinen)
    
    v12:
     * More accurate sampling. (Chris Wilson)
     * Store and report frequency in MHz for better usability from
       perf stat.
     * Removed metrics: queued, interrupts, rc6 counters.
     * Sample engine busyness based on seqno difference only
       for less MMIO (and forcewake) on all platforms. (Chris Wilson)
    
    v13:
     * Comment spelling, use mul_u32_u32 to work around potential GCC
       issue and somne code alignment changes. (Chris Wilson)
    
    v14:
     * Rebase.
    
    v15:
     * Rebase for RPS refactoring.
    
    v16:
     * Use the dynamic slot in the CPU hotplug state machine so that we are
       free to setup our state as multi-instance. Previously we were re-using
       the CPUHP_AP_PERF_X86_UNCORE_ONLINE slot which is neither used as
       multi-instance, nor owned by our driver to start with.
     * Register the CPU hotplug handlers after the PMU, otherwise the callback
       will get called before the PMU is initialized which can end up in
       perf_pmu_migrate_context with an un-initialized base.
     * Added workaround for a probable bug in cpuhp core.
    
    v17:
     * Remove workaround for the cpuhp bug.
    
    v18:
     * Rebase for drm_i915_gem_engine_class getting upstream before us.
    
    v19:
     * Rebase. (trivial)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171121181852.16128-2-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8dbcb03b5f54..0793a27e2b95 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -48,6 +48,7 @@
 
 #include "i915_drv.h"
 #include "i915_trace.h"
+#include "i915_pmu.h"
 #include "i915_vgpu.h"
 #include "intel_drv.h"
 #include "intel_uc.h"
@@ -1215,6 +1216,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	struct drm_device *dev = &dev_priv->drm;
 
 	i915_gem_shrinker_init(dev_priv);
+	i915_pmu_register(dev_priv);
 
 	/*
 	 * Notify a valid surface after modesetting,
@@ -1269,6 +1271,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	intel_opregion_unregister(dev_priv);
 
 	i915_perf_unregister(dev_priv);
+	i915_pmu_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
 	i915_guc_log_unregister(dev_priv);

commit 3572f04c69ed4369da5d3c65d84fb18774aa60b6
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Nov 16 18:02:15 2017 +0200

    drm/i915: Fix init_clock_gating for resume
    
    Moving the init_clock_gating() call from intel_modeset_init_hw() to
    intel_modeset_gem_init() had an unintended effect of not applying
    some workarounds on resume. This, for example, cause some kind of
    corruption to appear at the top of my IVB Thinkpad X1 Carbon LVDS
    screen after hibernation. Fix the problem by explicitly calling
    init_clock_gating() from the resume path.
    
    I really hope this doesn't break something else again. At least
    the problems reported at https://bugs.freedesktop.org/show_bug.cgi?id=103549
    didn't make a comeback, even after a hibernate cycle.
    
    v2: Reorder the init_clock_gating vs. modeset_init_hw to match
        the display reset path (Rodrigo)
    
    Cc: stable@vger.kernel.org
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Fixes: 6ac43272768c ("drm/i915: Move init_clock_gating() back to where it was")
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171116160215.25715-1-ville.syrjala@linux.intel.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    (cherry picked from commit 675f7ff35bd256e65d3d0f52718d8babf5d1002a)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 34191028bbad..7d9b07df32fa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1714,6 +1714,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	intel_guc_resume(dev_priv);
 
 	intel_modeset_init_hw(dev);
+	intel_init_clock_gating(dev_priv);
 
 	spin_lock_irq(&dev_priv->irq_lock);
 	if (dev_priv->display.hpd_irq_setup)

commit 294cf1af8cf2eb0d1eced377fdfb9a2d3f0e8b42
Author: Hans de Goede <j.w.r.degoede@gmail.com>
Date:   Tue Nov 14 14:55:17 2017 +0100

    drm/i915: Re-register PMIC bus access notifier on runtime resume
    
    intel_uncore_suspend() unregisters the uncore code's PMIC bus access
    notifier and gets called on both normal and runtime suspend.
    
    intel_uncore_resume_early() re-registers the notifier, but only on
    normal resume. Add a new intel_uncore_runtime_resume() function which
    only re-registers the notifier and call that on runtime resume.
    
    Cc: stable@vger.kernel.org
    Reported-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114135518.15981-2-hdegoede@redhat.com
    (cherry picked from commit bedf4d79c3654921839b62246b0965ddb308b201)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3db5851756f0..34191028bbad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2618,6 +2618,8 @@ static int intel_runtime_resume(struct device *kdev)
 		ret = vlv_resume_prepare(dev_priv, true);
 	}
 
+	intel_uncore_runtime_resume(dev_priv);
+
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).

commit 93c6e966b4cd1c99d02b488e149df606f811587b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Nov 20 20:55:04 2017 +0000

    drm/i915: Remove i915.semaphores modparam
    
    Having disabled the broken semaphores on Sandybridge, there is no need
    for a modparam any more, so remove it in favour of a simple
    HAS_LEGACY_SEMAPHORES() guard.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171120205504.21892-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c608fd96771c..8dbcb03b5f54 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -321,7 +321,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = USES_PPGTT(dev_priv);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
-		value = i915_modparams.semaphores;
+		value = HAS_LEGACY_SEMAPHORES(dev_priv);
 		break;
 	case I915_PARAM_HAS_SECURE_BATCHES:
 		value = capable(CAP_SYS_ADMIN);
@@ -1063,11 +1063,6 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 					    i915_modparams.enable_ppgtt);
 	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915_modparams.enable_ppgtt);
 
-	i915_modparams.semaphores =
-		intel_sanitize_semaphores(dev_priv, i915_modparams.semaphores);
-	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n",
-			 yesno(i915_modparams.semaphores));
-
 	intel_uc_sanitize_options(dev_priv);
 
 	intel_gvt_sanitize_options(dev_priv);

commit fb5c551ad510e4a408c105670f89c725ebbfe6c8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Nov 20 20:55:00 2017 +0000

    drm/i915: Remove i915.enable_execlists module parameter
    
    Execlists and legacy ringbuffer submission are no longer feature
    comparable (execlists now offer greater functionality that should
    overcome their performance hit) and obsoletes the unsafe module
    parameter, i.e. comparing the two modes of execution is no longer
    useful, so remove the debug tool.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com> #i915_perf.c
    Link: https://patchwork.freedesktop.org/patch/msgid/20171120205504.21892-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2b4ced93011b..c608fd96771c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -371,9 +371,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule) {
 			value |= I915_SCHEDULER_CAP_ENABLED;
 			value |= I915_SCHEDULER_CAP_PRIORITY;
-
-			if (HAS_LOGICAL_RING_PREEMPTION(dev_priv) &&
-			    i915_modparams.enable_execlists)
+			if (HAS_LOGICAL_RING_PREEMPTION(dev_priv))
 				value |= I915_SCHEDULER_CAP_PREEMPTION;
 		}
 		break;
@@ -1054,10 +1052,6 @@ static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 
 static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 {
-	i915_modparams.enable_execlists =
-		intel_sanitize_enable_execlists(dev_priv,
-						i915_modparams.enable_execlists);
-
 	/*
 	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
 	 * user's requested state against the hardware/driver capabilities.  We

commit 9f9b2792b6d38fbc8028f31b41ebd38a3f28a401
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Fri Oct 27 15:59:31 2017 +0100

    drm/i915/perf: reuse timestamp frequency from device info
    
    Now that we have this stored in the device info, we can drop it from perf
    part of the driver.
    
    Note that this requires to init perf after we've computed the frequency,
    hence why we move i915_perf_init() from i915_driver_init_early() to after
    intel_device_info_runtime_init().
    
    v2: Use div_u64 (Chris)
    
    v3: Drop u64 divs by switching to kHz (Chris/Ville)
        Move i915_perf_fini to i915_driver_cleanup_hw (Matthew)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171113181902.12411-2-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 87452c5558d3..2b4ced93011b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -936,8 +936,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_detect_preproduction_hw(dev_priv);
 
-	i915_perf_init(dev_priv);
-
 	return 0;
 
 err_irq:
@@ -954,7 +952,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
  */
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
-	i915_perf_fini(dev_priv);
 	i915_gem_load_cleanup(dev_priv);
 	intel_irq_fini(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
@@ -1101,6 +1098,8 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_sanitize_options(dev_priv);
 
+	i915_perf_init(dev_priv);
+
 	ret = i915_ggtt_probe_hw(dev_priv);
 	if (ret)
 		return ret;
@@ -1206,6 +1205,8 @@ static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 {
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
+	i915_perf_fini(dev_priv);
+
 	if (pdev->msi_enabled)
 		pci_disable_msi(pdev);
 

commit 675f7ff35bd256e65d3d0f52718d8babf5d1002a
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Nov 16 18:02:15 2017 +0200

    drm/i915: Fix init_clock_gating for resume
    
    Moving the init_clock_gating() call from intel_modeset_init_hw() to
    intel_modeset_gem_init() had an unintended effect of not applying
    some workarounds on resume. This, for example, cause some kind of
    corruption to appear at the top of my IVB Thinkpad X1 Carbon LVDS
    screen after hibernation. Fix the problem by explicitly calling
    init_clock_gating() from the resume path.
    
    I really hope this doesn't break something else again. At least
    the problems reported at https://bugs.freedesktop.org/show_bug.cgi?id=103549
    didn't make a comeback, even after a hibernate cycle.
    
    v2: Reorder the init_clock_gating vs. modeset_init_hw to match
        the display reset path (Rodrigo)
    
    Cc: stable@vger.kernel.org
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Fixes: 6ac43272768c ("drm/i915: Move init_clock_gating() back to where it was")
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171116160215.25715-1-ville.syrjala@linux.intel.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8ea6ce7027d4..87452c5558d3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1714,6 +1714,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	i915_gem_resume(dev_priv);
 
 	intel_modeset_init_hw(dev);
+	intel_init_clock_gating(dev_priv);
 
 	spin_lock_irq(&dev_priv->irq_lock);
 	if (dev_priv->display.hpd_irq_setup)

commit 6a7a6a982a22091b9d67cb3ff33d7782494aa2f8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 17 10:26:35 2017 +0000

    drm/i915: Add a policy note for removing workarounds
    
    Rodrigo gave a persuasive argument for keeping workarounds: that they
    serve as a good guide for the bring up of the next generation. Not only
    do workarounds persist into the early revisions, they show where the
    workarounds were previously added to the code flow and sometimes the old
    workarounds have an explanation that give insight into their wider
    implications.
    
    Based on his suggestion, document the policy that we want to keep the
    workarounds from the current generation to guide the next. Older
    preproduction workarounds we still want to remove to keep the code
    clean.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171117102635.8689-1-chris@chris-wilson.co.uk
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3423d873123a..8ea6ce7027d4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -843,6 +843,11 @@ static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
  * We don't keep the workarounds for pre-production hardware, so we expect our
  * driver to fail on these machines in one way or another. A little warning on
  * dmesg may help both the user and the bug triagers.
+ *
+ * Our policy for removing pre-production workarounds is to keep the
+ * current gen workarounds as a guide to the bring-up of the next gen
+ * (workarounds have a habit of persisting!). Anything older than that
+ * should be removed along with the complications they introduce.
  */
 static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 {

commit e60e1ee60630cafef5e430c2ae364877e061d980
Merge: 5d352e69c60e f150891fd987
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 20:42:10 2017 -0800

    Merge tag 'drm-for-v4.15' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for v4.15.
    
      Core:
       - Atomic object lifetime fixes
       - Atomic iterator improvements
       - Sparse/smatch fixes
       - Legacy kms ioctls to be interruptible
       - EDID override improvements
       - fb/gem helper cleanups
       - Simple outreachy patches
       - Documentation improvements
       - Fix dma-buf rcu races
       - DRM mode object leasing for improving VR use cases.
       - vgaarb improvements for non-x86 platforms.
    
      New driver:
       - tve200: Faraday Technology TVE200 block.
    
         This "TV Encoder" encodes a ITU-T BT.656 stream and can be found in
         the StorLink SL3516 (later Cortina Systems CS3516) as well as the
         Grain Media GM8180.
    
      New bridges:
       - SiI9234 support
    
      New panels:
       - S6E63J0X03, OTM8009A, Seiko 43WVF1G, 7" rpi touch panel, Toshiba
         LT089AC19000, Innolux AT043TN24
    
      i915:
       - Remove Coffeelake from alpha support
       - Cannonlake workarounds
       - Infoframe refactoring for DisplayPort
       - VBT updates
       - DisplayPort vswing/emph/buffer translation refactoring
       - CCS fixes
       - Restore GPU clock boost on missed vblanks
       - Scatter list updates for userptr allocations
       - Gen9+ transition watermarks
       - Display IPC (Isochronous Priority Control)
       - Private PAT management
       - GVT: improved error handling and pci config sanitizing
       - Execlist refactoring
       - Transparent Huge Page support
       - User defined priorities support
       - HuC/GuC firmware refactoring
       - DP MST fixes
       - eDP power sequencing fixes
       - Use RCU instead of stop_machine
       - PSR state tracking support
       - Eviction fixes
       - BDW DP aux channel timeout fixes
       - LSPCON fixes
       - Cannonlake PLL fixes
    
      amdgpu:
       - Per VM BO support
       - Powerplay cleanups
       - CI powerplay support
       - PASID mgr for kfd
       - SR-IOV fixes
       - initial GPU reset for vega10
       - Prime mmap support
       - TTM updates
       - Clock query interface for Raven
       - Fence to handle ioctl
       - UVD encode ring support on Polaris
       - Transparent huge page DMA support
       - Compute LRU pipe tweaks
       - BO flag to allow buffers to opt out of implicit sync
       - CTX priority setting API
       - VRAM lost infrastructure plumbing
    
      qxl:
       - fix flicker since atomic rework
    
      amdkfd:
       - Further improvements from internal AMD tree
       - Usermode events
       - Drop radeon support
    
      nouveau:
       - Pascal temperature sensor support
       - Improved BAR2 handling
       - MMU rework to support Pascal MMU
    
      exynos:
       - Improved HDMI/mixer support
       - HDMI audio interface support
    
      tegra:
       - Prep work for tegra186
       - Cleanup/fixes
    
      msm:
       - Preemption support for a5xx
       - Display fixes for 8x96 (snapdragon 820)
       - Async cursor plane fixes
       - FW loading rework
       - GPU debugging improvements
    
      vc4:
       - Prep for DSI panels
       - fix T-format tiling scanout
       - New madvise ioctl
    
      Rockchip:
       - LVDS support
    
      omapdrm:
       - omap4 HDMI CEC support
    
      etnaviv:
       - GPU performance counters groundwork
    
      sun4i:
       - refactor driver load + TCON backend
       - HDMI improvements
       - A31 support
       - Misc fixes
    
      udl:
       - Probe/EDID read fixes.
    
      tilcdc:
       - Misc fixes.
    
      pl111:
       - Support more variants
    
      adv7511:
       - Improve EDID handling.
       - HDMI CEC support
    
      sii8620:
       - Add remote control support"
    
    * tag 'drm-for-v4.15' of git://people.freedesktop.org/~airlied/linux: (1480 commits)
      drm/rockchip: analogix_dp: Use mutex rather than spinlock
      drm/mode_object: fix documentation for object lookups.
      drm/i915: Reorder context-close to avoid calling i915_vma_close() under RCU
      drm/i915: Move init_clock_gating() back to where it was
      drm/i915: Prune the reservation shared fence array
      drm/i915: Idle the GPU before shinking everything
      drm/i915: Lock llist_del_first() vs llist_del_all()
      drm/i915: Calculate ironlake intermediate watermarks correctly, v2.
      drm/i915: Disable lazy PPGTT page table optimization for vGPU
      drm/i915/execlists: Remove the priority "optimisation"
      drm/i915: Filter out spurious execlists context-switch interrupts
      drm/amdgpu: use irq-safe lock for kiq->ring_lock
      drm/amdgpu: bypass lru touch for KIQ ring submission
      drm/amdgpu: Potential uninitialized variable in amdgpu_vm_update_directories()
      drm/amdgpu: potential uninitialized variable in amdgpu_vce_ring_parse_cs()
      drm/amd/powerplay: initialize a variable before using it
      drm/amd/powerplay: suppress KASAN out of bounds warning in vega10_populate_all_memory_levels
      drm/amd/amdgpu: fix evicted VRAM bo adjudgement condition
      drm/vblank: Tune drm_crtc_accurate_vblank_count() WARN down to a debug
      drm/rockchip: add CONFIG_OF dependency for lvds
      ...

commit 01c799c995bb8a87878b0d64edfd33014968da8e
Author: Hans de Goede <j.w.r.degoede@gmail.com>
Date:   Tue Nov 14 14:55:18 2017 +0100

    drm/i915: Call uncore_suspend before platform suspend handlers
    
    Quoting Ville: "the forcewake timer might still be active until the uncore
    suspend, and having active forcewakes while we've already told the GT wake
    stuff to stop acting normally doesn't seem quite right to me."
    
    Reported-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Suggested-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114135518.15981-3-hdegoede@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f4588add15db..3423d873123a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2526,6 +2526,8 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
+	intel_uncore_suspend(dev_priv);
+
 	ret = 0;
 	if (IS_GEN9_LP(dev_priv)) {
 		bxt_display_core_uninit(dev_priv);
@@ -2538,6 +2540,8 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
+		intel_uncore_runtime_resume(dev_priv);
+
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
 		enable_rpm_wakeref_asserts(dev_priv);
@@ -2545,8 +2549,6 @@ static int intel_runtime_suspend(struct device *kdev)
 		return ret;
 	}
 
-	intel_uncore_suspend(dev_priv);
-
 	enable_rpm_wakeref_asserts(dev_priv);
 	WARN_ON_ONCE(atomic_read(&dev_priv->runtime_pm.wakeref_count));
 

commit bedf4d79c3654921839b62246b0965ddb308b201
Author: Hans de Goede <j.w.r.degoede@gmail.com>
Date:   Tue Nov 14 14:55:17 2017 +0100

    drm/i915: Re-register PMIC bus access notifier on runtime resume
    
    intel_uncore_suspend() unregisters the uncore code's PMIC bus access
    notifier and gets called on both normal and runtime suspend.
    
    intel_uncore_resume_early() re-registers the notifier, but only on
    normal resume. Add a new intel_uncore_runtime_resume() function which
    only re-registers the notifier and call that on runtime resume.
    
    Cc: stable@vger.kernel.org
    Reported-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114135518.15981-2-hdegoede@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1ae7031eedaa..f4588add15db 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2621,6 +2621,8 @@ static int intel_runtime_resume(struct device *kdev)
 		ret = vlv_resume_prepare(dev_priv, true);
 	}
 
+	intel_uncore_runtime_resume(dev_priv);
+
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).

commit 7469c62cb6549cf72bfd4d63cb3fc5f34eb0b2d0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 14 13:03:00 2017 +0000

    drm/i915: Resume GuC before using GEM
    
    Resuming GEM presumes it can talk to hw, in particular to ensure the
    kernel context is loaded upon resume for powersaving. If the GuC is
    still asleep at this point, we upset the HW. Rearrange the resume such
    that we restore the original order of init-hw, resume-guc, use-gem.
    
    Fixes: 37cd33006d02 ("drm/i915: Remove redundant intel_autoenable_gt_powersave()")
    References: a1c419941453 ("drm/i915/guc: Add host2guc notification for suspend and resume")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Alex Dai <yu.dai@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114130300.25677-2-chris@chris-wilson.co.uk
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 171b86f37878..1ae7031eedaa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1708,8 +1708,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	i915_gem_resume(dev_priv);
 
-	intel_guc_resume(dev_priv);
-
 	intel_modeset_init_hw(dev);
 
 	spin_lock_irq(&dev_priv->irq_lock);

commit f577a03ba920df1a9163221d4823627999c59bfd
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Nov 13 23:34:53 2017 +0000

    drm/i915: fix 64bit divide
    
    ERROR: "__udivdi3" [drivers/gpu/drm/i915/i915.ko] undefined!
    ERROR: "__divdi3" [drivers/gpu/drm/i915/i915.ko] undefined!
    
    Store the frequency in kHz and drop 64bit divisions.
    
    v2: Use div64_u64 (Matthew)
    
    v3: store frequency in kHz to avoid 64bit divs (Chris/Ville)
    
    Fixes: dab9178333 ("drm/i915: expose command stream timestamp frequency to userspace")
    Reported-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171113233455.12085-3-lionel.g.landwerlin@intel.com
    Reviewed-by: Ewelina Musial <ewelina.musial@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 42813f4247e2..171b86f37878 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -420,7 +420,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 			return -ENODEV;
 		break;
 	case I915_PARAM_CS_TIMESTAMP_FREQUENCY:
-		value = INTEL_INFO(dev_priv)->cs_timestamp_frequency;
+		value = 1000 * INTEL_INFO(dev_priv)->cs_timestamp_frequency_khz;
 		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);

commit dab91783338bd3dd42638f89b5f7e34c57773207
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Fri Nov 10 19:08:44 2017 +0000

    drm/i915: expose command stream timestamp frequency to userspace
    
    We use to have this fixed per generation, but starting with CNL userspace
    cannot tell just off the PCI ID. Let's make this information available. This
    is particularly useful for performance monitoring where much of the
    normalization work is done using those timestamps (this include pipeline
    statistics in both GL & Vulkan as well as OA reports).
    
    v2: Use variables for 24MHz/19.2MHz values (Ewelina)
        Renamed function & coding style (Sagar)
    
    v3: Fix frequency read on Broadwell (Sagar)
        Fix missing divide by 4 on <= gen4 (Sagar)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Tested-by: Rafael Antognolli <rafael.antognolli@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110190845.32574-7-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9df7b5d59a94..42813f4247e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -419,6 +419,9 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		if (!value)
 			return -ENODEV;
 		break;
+	case I915_PARAM_CS_TIMESTAMP_FREQUENCY:
+		value = INTEL_INFO(dev_priv)->cs_timestamp_frequency;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit 37cd33006d02d84e08caedea2db48662c18e499e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Nov 12 11:27:38 2017 +0000

    drm/i915: Remove redundant intel_autoenable_gt_powersave()
    
    Now that we always execute a context switch upon module load, there is
    no need to queue a delayed task for doing so. The purpose of the delayed
    task is to enable GT powersaving, for which we need the HW state to be
    valid (i.e. having loaded a context and initialised basic state). We
    used to defer this operation as historically it was slow (due to slow
    register polling, fixed with commit 1758b90e38f5 ("drm/i915: Use a hybrid
    scheme for fast register waits")) but now we have a requirement to save
    the default HW state.
    
    v2: Load the kernel context (to provide the power context) upon resume.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171112112738.1463-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f8600cc96f2a..9df7b5d59a94 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1683,8 +1683,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_csr_ucode_resume(dev_priv);
 
-	i915_gem_resume(dev_priv);
-
 	i915_restore_state(dev_priv);
 	intel_pps_unlock_regs_wa(dev_priv);
 	intel_opregion_setup(dev_priv);
@@ -1705,12 +1703,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	drm_mode_config_reset(dev);
 
-	mutex_lock(&dev->struct_mutex);
-	if (i915_gem_init_hw(dev_priv)) {
-		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-		i915_gem_set_wedged(dev_priv);
-	}
-	mutex_unlock(&dev->struct_mutex);
+	i915_gem_resume(dev_priv);
 
 	intel_guc_resume(dev_priv);
 
@@ -1745,8 +1738,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
-	intel_autoenable_gt_powersave(dev_priv);
-
 	enable_rpm_wakeref_asserts(dev_priv);
 
 	return 0;

commit 9c52d1c816baa5b8c97485b20d95af29c98d26ee
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 10 23:24:47 2017 +0000

    drm/i915/selftests: Yet another forgotten mock_i915->mm initialiser
    
    Move all of the i915->mm initialisation to a private function that can
    be reused by the mock i915 device to save forgetting any more steps.
    
    For example,
    <7>[ 1542.046332] [IGT] drv_selftest: starting subtest mock_objects
    <4>[ 1542.123924] Setting dangerous option mock_selftests - tainting kernel
    <6>[ 1542.167941] i915: Performing mock selftests with st_random_seed=0x246f5ab5 st_timeout=1000
    <4>[ 1542.178012] INFO: trying to register non-static key.
    <4>[ 1542.178027] the code is fine but needs lockdep annotation.
    <4>[ 1542.178032] turning off the locking correctness validator.
    <4>[ 1542.178041] CPU: 3 PID: 6008 Comm: kworker/3:7 Tainted: G     U          4.14.0-rc8-CI-CI_DRM_3332+ #1
    <4>[ 1542.178049] Hardware name:                  /NUC6CAYB, BIOS AYAPLCEL.86A.0040.2017.0619.1722 06/19/2017
    <4>[ 1542.178144] Workqueue: events __i915_gem_free_work [i915]
    <4>[ 1542.178152] Call Trace:
    <4>[ 1542.178163]  dump_stack+0x68/0x9f
    <4>[ 1542.178170]  register_lock_class+0x3fd/0x580
    <4>[ 1542.178177]  ? unwind_next_frame+0x14/0x20
    <4>[ 1542.178184]  ? __save_stack_trace+0x73/0xd0
    <4>[ 1542.178191]  __lock_acquire+0xa4/0x1b00
    <4>[ 1542.178254]  ? __i915_gem_free_work+0x28/0xa0 [i915]
    <4>[ 1542.178261]  ? __lock_acquire+0x4ab/0x1b00
    <4>[ 1542.178268]  lock_acquire+0xb0/0x200
    <4>[ 1542.178273]  ? lock_acquire+0xb0/0x200
    <4>[ 1542.178336]  ? __i915_gem_free_work+0x28/0xa0 [i915]
    <4>[ 1542.178344]  _raw_spin_lock+0x32/0x50
    <4>[ 1542.178405]  ? __i915_gem_free_work+0x28/0xa0 [i915]
    <4>[ 1542.178468]  __i915_gem_free_work+0x28/0xa0 [i915]
    <4>[ 1542.178476]  process_one_work+0x221/0x650
    <4>[ 1542.178483]  worker_thread+0x4e/0x3c0
    <4>[ 1542.178489]  kthread+0x114/0x150
    <4>[ 1542.178494]  ? process_one_work+0x650/0x650
    <4>[ 1542.178499]  ? kthread_create_on_node+0x40/0x40
    <4>[ 1542.178506]  ret_from_fork+0x27/0x40
    
    v2: Fish out i915->mm.object_stat_lock which was being inited over in
    i915_drv.c (Matthew)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110232447.21618-1-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d97fe9c9439a..f8600cc96f2a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -894,7 +894,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->backlight_lock);
 	spin_lock_init(&dev_priv->uncore.lock);
 
-	spin_lock_init(&dev_priv->mm.object_stat_lock);
 	mutex_init(&dev_priv->sb_lock);
 	mutex_init(&dev_priv->modeset_restore_lock);
 	mutex_init(&dev_priv->av_mutex);

commit d2b4b97933f5adacfba42dc3b9200d0e21fbe2c4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 10 14:26:33 2017 +0000

    drm/i915: Record the default hw state after reset upon load
    
    Take a copy of the HW state after a reset upon module loading by
    executing a context switch from a blank context to the kernel context,
    thus saving the default hw state over the blank context image.
    We can then use the default hw state to initialise any future context,
    ensuring that each starts with the default view of hw state.
    
    v2: Unmap our default state from the GTT after stealing it from the
    context. This should stop us from accidentally overwriting it via the
    GTT (and frees up some precious GTT space).
    
    Testcase: igt/gem_ctx_isolation
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110142634.10551-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b440f2b90a5..d97fe9c9439a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -406,6 +406,9 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		 */
 		value = 1;
 		break;
+	case I915_PARAM_HAS_CONTEXT_ISOLATION:
+		value = intel_engines_has_context_isolation(dev_priv);
+		break;
 	case I915_PARAM_SLICE_MASK:
 		value = INTEL_INFO(dev_priv)->sseu.slice_mask;
 		if (!value)

commit d378a3efb819e6d1992127122d957337571b4594
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 10 14:26:31 2017 +0000

    drm/i915: Inline intel_modeset_gem_init()
    
    intel_modeset_gem_init() now only sets up the legacy overlay, so let's
    remove the function and call the setup directly during driver load. This
    should help us find a better point in the initialisation sequence for it
    later.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110142634.10551-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e7e9e061073b..1b440f2b90a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -676,7 +676,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_uc;
 
-	intel_modeset_gem_init(dev);
+	intel_setup_overlay(dev_priv);
 
 	if (INTEL_INFO(dev_priv)->num_pipes == 0)
 		return 0;

commit c2eac4d3a115e2f511844e7bcf73f4e877fbf5da
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:16:46 2017 +0200

    PCI / PM: Use the NEVER_SKIP driver flag
    
    Replace the PCI-specific flag PCI_DEV_FLAGS_NEEDS_RESUME with the
    PM core's DPM_FLAG_NEVER_SKIP one everywhere and drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9f45cfeae775..f124de3a0668 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1304,7 +1304,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 * becaue the HDA driver may require us to enable the audio power
 	 * domain during system suspend.
 	 */
-	pdev->dev_flags |= PCI_DEV_FLAGS_NEEDS_RESUME;
+	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NEVER_SKIP);
 
 	ret = i915_driver_init_early(dev_priv, ent);
 	if (ret < 0)

commit 6acbea89efbdc6aef56bc6f364d4d8b72a5fc145
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Tue Oct 31 15:53:09 2017 -0700

    drm/i915/guc: Add support for reset engine using GuC commands
    
    This patch adds per engine reset and recovery (TDR) support when GuC is
    used to submit workloads to GPU.
    
    In the case of i915 directly submission to ELSP, driver manages hang
    detection, recovery and resubmission. With GuC submission these tasks
    are shared between driver and GuC. i915 is still responsible for detecting
    a hang, and when it does it only requests GuC to reset that Engine. GuC
    internally manages acquiring forcewake and idling the engine before
    resetting it.
    
    Once the reset is successful, i915 takes over again and handles the
    resubmission. The scheduler in i915 knows which requests are pending so
    after resetting a engine, pending workloads/requests are resubmitted
    again.
    
    v2: s/i915_guc_request_engine_reset/i915_guc_reset_engine/ to match the
    non-guc function names.
    
    v3: Removed debug message about engine restarting from which request,
    since the new baseline do it regardless of submission mode. (Chris)
    
    v4: Rebase.
    
    v5: Do not pass unnecessary reporting flags to the fw (Jeff);
    tasklet_schedule(&execlists->irq_tasklet) handles the resubmit; rebase.
    
    v6: Rename the existing reset engine function and share a similar
    interface between guc and non-guc paths (Chris).
    
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171031225309.10888-1-michel.thierry@intel.com
    Reviewed-by: Jeff McGee <jeff.mcgee@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index af745749509c..e7e9e061073b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1950,6 +1950,12 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 	goto finish;
 }
 
+static inline int intel_gt_reset_engine(struct drm_i915_private *dev_priv,
+					struct intel_engine_cs *engine)
+{
+	return intel_gpu_reset(dev_priv, intel_engine_flag(engine));
+}
+
 /**
  * i915_reset_engine - reset GPU engine to recover from a hang
  * @engine: engine to reset
@@ -1984,10 +1990,14 @@ int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
 		goto out;
 	}
 
-	ret = intel_gpu_reset(engine->i915, intel_engine_flag(engine));
+	if (!engine->i915->guc.execbuf_client)
+		ret = intel_gt_reset_engine(engine->i915, engine);
+	else
+		ret = intel_guc_reset_engine(&engine->i915->guc, engine);
 	if (ret) {
 		/* If we fail here, we expect to fallback to a global reset */
-		DRM_DEBUG_DRIVER("Failed to reset %s, ret=%d\n",
+		DRM_DEBUG_DRIVER("%sFailed to reset %s, ret=%d\n",
+				 engine->i915->guc.execbuf_client ? "GuC " : "",
 				 engine->name, ret);
 		goto out;
 	}

commit c41937fd994a449b4e862826d7eb9f366f6d33e9
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Thu Oct 26 15:35:58 2017 +0200

    drm/i915/guc: Preemption! With GuC
    
    Pretty similar to what we have on execlists.
    We're reusing most of the GEM code, however, due to GuC quirks we need a
    couple of extra bits.
    Preemption is implemented as GuC action, and actions can be pretty slow.
    Because of that, we're using a mutex to serialize them. Since we're
    requesting preemption from the tasklet, the task of creating a workitem
    and wrapping it in GuC action is delegated to a worker.
    
    To distinguish that preemption has finished, we're using additional
    piece of HWSP, and since we're not getting context switch interrupts,
    we're also adding a user interrupt.
    
    The fact that our special preempt context has completed unfortunately
    doesn't mean that we're ready to submit new work. We also need to wait
    for GuC to finish its own processing.
    
    v2: Don't compile out the wait for GuC, handle workqueue flush on reset,
    no need for ordered workqueue, put on a reviewer hat when looking at my own
    patches (Chris)
    Move struct work around in intel_guc, move user interruput outside of
    conditional (Michał)
    Keep ring around rather than chase though intel_context
    
    v3: Extract WA for flushing ggtt writes to a helper (Chris)
    Keep work_struct in intel_guc rather than engine (Michał)
    Use ordered workqueue for inject_preempt worker to avoid GuC quirks.
    
    v4: Drop now unused INTEL_GUC_PREEMPT_OPTION_IMMEDIATE (Daniele)
    Drop stray newlines, use container_of for intel_guc in worker,
    check for presence of workqueue when flushing it, rather than
    enable_guc_submission modparam, reorder preempt postprocessing (Chris)
    
    v5: Make wq NULL after destroying it
    
    v6: Swap struct guc_preempt_work members (Michał)
    
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171026133558.19580-1-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7b871802ae36..af745749509c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -373,8 +373,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 			value |= I915_SCHEDULER_CAP_PRIORITY;
 
 			if (HAS_LOGICAL_RING_PREEMPTION(dev_priv) &&
-			    i915_modparams.enable_execlists &&
-			    !i915_modparams.enable_guc_submission)
+			    i915_modparams.enable_execlists)
 				value |= I915_SCHEDULER_CAP_PREEMPTION;
 		}
 		break;

commit a4598d17551ab5ce5c9fd2ac7a7803e89b63260e
Author: Michał Winiarski <michal.winiarski@intel.com>
Date:   Wed Oct 25 22:00:18 2017 +0200

    drm/i915: Rename helpers used for unwinding, use macro for can_preempt
    
    We would also like to make use of execlist_cancel_port_requests and
    unwind_incomplete_requests in GuC preemption backend.
    Let's rename the functions to use the correct prefixes, so that we can
    simply add the declarations in the following patch.
    Similar thing for applies for can_preempt, except we're introducing
    HAS_LOGICAL_RING_PREEMPTION macro instad, converting other users that
    were previously touching device info directly.
    
    v2: s/intel_engine/execlists and pass execlists to unwind (Chris)
    v3: use locked version for exporting, drop const qual (Chris)
    
    Signed-off-by: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171025200020.16636-11-michal.winiarski@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3db5851756f0..7b871802ae36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -372,7 +372,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 			value |= I915_SCHEDULER_CAP_ENABLED;
 			value |= I915_SCHEDULER_CAP_PRIORITY;
 
-			if (INTEL_INFO(dev_priv)->has_logical_ring_preemption &&
+			if (HAS_LOGICAL_RING_PREEMPTION(dev_priv) &&
 			    i915_modparams.enable_execlists &&
 			    !i915_modparams.enable_guc_submission)
 				value |= I915_SCHEDULER_CAP_PREEMPTION;

commit 7c781423379d8215f2cc4940700bde0b9f93fed0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 11 15:18:57 2017 +0100

    drm/i915/userptr: Drop struct_mutex before cleanup
    
    Purely to silence lockdep, as we know that no bo can exist at this time
    and so the inversion is impossible. Nevertheless, lockdep currently
    warns on unload:
    
    [  137.522565] WARNING: possible circular locking dependency detected
    [  137.522568] 4.14.0-rc4-CI-CI_DRM_3209+ #1 Tainted: G     U
    [  137.522570] ------------------------------------------------------
    [  137.522572] drv_module_relo/1532 is trying to acquire lock:
    [  137.522574]  ("i915-userptr-acquire"){+.+.}, at: [<ffffffff8109a831>] flush_workqueue+0x91/0x540
    [  137.522581]
                   but task is already holding lock:
    [  137.522583]  (&dev->struct_mutex){+.+.}, at: [<ffffffffa014fb3f>] i915_gem_fini+0x3f/0xc0 [i915]
    [  137.522605]
                   which lock already depends on the new lock.
    
    [  137.522608]
                   the existing dependency chain (in reverse order) is:
    [  137.522611]
                   -> #3 (&dev->struct_mutex){+.+.}:
    [  137.522615]        __lock_acquire+0x1420/0x15e0
    [  137.522618]        lock_acquire+0xb0/0x200
    [  137.522621]        __mutex_lock+0x86/0x9b0
    [  137.522623]        mutex_lock_interruptible_nested+0x1b/0x20
    [  137.522640]        i915_mutex_lock_interruptible+0x51/0x130 [i915]
    [  137.522657]        i915_gem_fault+0x20b/0x720 [i915]
    [  137.522660]        __do_fault+0x1e/0x80
    [  137.522662]        __handle_mm_fault+0xa08/0xed0
    [  137.522664]        handle_mm_fault+0x156/0x300
    [  137.522666]        __do_page_fault+0x2c5/0x570
    [  137.522668]        do_page_fault+0x28/0x250
    [  137.522671]        page_fault+0x22/0x30
    [  137.522672]
                   -> #2 (&mm->mmap_sem){++++}:
    [  137.522677]        __lock_acquire+0x1420/0x15e0
    [  137.522679]        lock_acquire+0xb0/0x200
    [  137.522682]        down_read+0x3e/0x70
    [  137.522699]        __i915_gem_userptr_get_pages_worker+0x141/0x240 [i915]
    [  137.522701]        process_one_work+0x233/0x660
    [  137.522704]        worker_thread+0x4e/0x3b0
    [  137.522706]        kthread+0x152/0x190
    [  137.522708]        ret_from_fork+0x27/0x40
    [  137.522710]
                   -> #1 ((&work->work)){+.+.}:
    [  137.522714]        __lock_acquire+0x1420/0x15e0
    [  137.522717]        lock_acquire+0xb0/0x200
    [  137.522719]        process_one_work+0x206/0x660
    [  137.522721]        worker_thread+0x4e/0x3b0
    [  137.522723]        kthread+0x152/0x190
    [  137.522725]        ret_from_fork+0x27/0x40
    [  137.522727]
                   -> #0 ("i915-userptr-acquire"){+.+.}:
    [  137.522731]        check_prev_add+0x430/0x840
    [  137.522733]        __lock_acquire+0x1420/0x15e0
    [  137.522735]        lock_acquire+0xb0/0x200
    [  137.522738]        flush_workqueue+0xb4/0x540
    [  137.522740]        drain_workqueue+0xd4/0x1b0
    [  137.522742]        destroy_workqueue+0x1c/0x200
    [  137.522758]        i915_gem_cleanup_userptr+0x15/0x20 [i915]
    [  137.522770]        i915_gem_fini+0x5f/0xc0 [i915]
    [  137.522782]        i915_driver_unload+0x122/0x180 [i915]
    [  137.522794]        i915_pci_remove+0x19/0x30 [i915]
    [  137.522797]        pci_device_remove+0x39/0xb0
    [  137.522800]        device_release_driver_internal+0x15d/0x220
    [  137.522803]        driver_detach+0x40/0x80
    [  137.522805]        bus_remove_driver+0x58/0xd0
    [  137.522807]        driver_unregister+0x2c/0x40
    [  137.522809]        pci_unregister_driver+0x36/0xb0
    [  137.522828]        i915_exit+0x1a/0x8b [i915]
    [  137.522831]        SyS_delete_module+0x18c/0x1e0
    [  137.522834]        entry_SYSCALL_64_fastpath+0x1c/0xb1
    [  137.522835]
                   other info that might help us debug this:
    
    [  137.522838] Chain exists of:
                     "i915-userptr-acquire" --> &mm->mmap_sem --> &dev->struct_mutex
    
    [  137.522844]  Possible unsafe locking scenario:
    
    [  137.522846]        CPU0                    CPU1
    [  137.522848]        ----                    ----
    [  137.522850]   lock(&dev->struct_mutex);
    [  137.522852]                                lock(&mm->mmap_sem);
    [  137.522854]                                lock(&dev->struct_mutex);
    [  137.522857]   lock("i915-userptr-acquire");
    [  137.522859]
                    *** DEADLOCK ***
    
    [  137.522862] 3 locks held by drv_module_relo/1532:
    [  137.522864]  #0:  (&dev->mutex){....}, at: [<ffffffff8161d47b>] device_release_driver_internal+0x2b/0x220
    [  137.522869]  #1:  (&dev->mutex){....}, at: [<ffffffff8161d489>] device_release_driver_internal+0x39/0x220
    [  137.522873]  #2:  (&dev->struct_mutex){+.+.}, at: [<ffffffffa014fb3f>] i915_gem_fini+0x3f/0xc0 [i915]
    [  137.522888]
                   stack backtrace:
    [  137.522891] CPU: 0 PID: 1532 Comm: drv_module_relo Tainted: G     U          4.14.0-rc4-CI-CI_DRM_3209+ #1
    [  137.522894] Hardware name:                  /NUC7i5BNB, BIOS BNKBL357.86A.0048.2017.0704.1415 07/04/2017
    [  137.522897] Call Trace:
    [  137.522900]  dump_stack+0x68/0x9f
    [  137.522902]  print_circular_bug+0x235/0x3c0
    [  137.522905]  ? lockdep_init_map_crosslock+0x20/0x20
    [  137.522908]  check_prev_add+0x430/0x840
    [  137.522919]  ? i915_gem_fini+0x5f/0xc0 [i915]
    [  137.522922]  ? __kernel_text_address+0x12/0x40
    [  137.522925]  ? __save_stack_trace+0x66/0xd0
    [  137.522928]  __lock_acquire+0x1420/0x15e0
    [  137.522930]  ? __lock_acquire+0x1420/0x15e0
    [  137.522933]  ? lockdep_init_map_crosslock+0x20/0x20
    [  137.522936]  ? __this_cpu_preempt_check+0x13/0x20
    [  137.522938]  lock_acquire+0xb0/0x200
    [  137.522940]  ? flush_workqueue+0x91/0x540
    [  137.522943]  flush_workqueue+0xb4/0x540
    [  137.522945]  ? flush_workqueue+0x91/0x540
    [  137.522948]  ? __mutex_unlock_slowpath+0x43/0x2c0
    [  137.522951]  ? trace_hardirqs_on_caller+0xe3/0x1b0
    [  137.522954]  drain_workqueue+0xd4/0x1b0
    [  137.522956]  ? drain_workqueue+0xd4/0x1b0
    [  137.522958]  destroy_workqueue+0x1c/0x200
    [  137.522975]  i915_gem_cleanup_userptr+0x15/0x20 [i915]
    [  137.522987]  i915_gem_fini+0x5f/0xc0 [i915]
    [  137.523000]  i915_driver_unload+0x122/0x180 [i915]
    [  137.523015]  i915_pci_remove+0x19/0x30 [i915]
    [  137.523018]  pci_device_remove+0x39/0xb0
    [  137.523021]  device_release_driver_internal+0x15d/0x220
    [  137.523023]  driver_detach+0x40/0x80
    [  137.523026]  bus_remove_driver+0x58/0xd0
    [  137.523028]  driver_unregister+0x2c/0x40
    [  137.523030]  pci_unregister_driver+0x36/0xb0
    [  137.523049]  i915_exit+0x1a/0x8b [i915]
    [  137.523052]  SyS_delete_module+0x18c/0x1e0
    [  137.523055]  entry_SYSCALL_64_fastpath+0x1c/0xb1
    [  137.523057] RIP: 0033:0x7f7bd0609287
    [  137.523059] RSP: 002b:00007ffef694bc18 EFLAGS: 00000246 ORIG_RAX: 00000000000000b0
    [  137.523062] RAX: ffffffffffffffda RBX: ffffffff81493f33 RCX: 00007f7bd0609287
    [  137.523065] RDX: 0000000000000001 RSI: 0000000000000800 RDI: 0000564f999f9fc8
    [  137.523067] RBP: ffffc90005c4ff88 R08: 0000000000000000 R09: 0000000000000080
    [  137.523069] R10: 00007f7bd20ef8c0 R11: 0000000000000246 R12: 0000000000000000
    [  137.523072] R13: 00007ffef694be00 R14: 0000000000000000 R15: 0000000000000000
    [  137.523075]  ? __this_cpu_preempt_check+0x13/0x20
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171011141857.14161-1-chris@chris-wilson.co.uk
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f1e651703764..3db5851756f0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -615,9 +615,10 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_contexts_fini(dev_priv);
-	i915_gem_cleanup_userptr(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
+	i915_gem_cleanup_userptr(dev_priv);
+
 	i915_gem_drain_freed_objects(dev_priv);
 
 	WARN_ON(!list_empty(&dev_priv->contexts.list));

commit 37d933fc1728e998d929d0ff5113dcb14ce31293
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Tue Oct 10 22:30:10 2017 +0100

    drm/i915: Introduce separate status variable for RC6 and LLC ring frequency setup
    
    Defined new struct intel_rc6 to hold RC6 specific state and
    intel_ring_pstate to hold ring specific state.
    
    v2: s/intel_ring_pstate/intel_llc_pstate. Removed checks from
    autoenable_* functions. (Chris)
    
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Radoslaw Szwichtenberg <radoslaw.szwichtenberg@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1507360055-19948-13-git-send-email-sagar.a.kamble@intel.com
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171010213010.7415-12-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f3ac1f45e154..f1e651703764 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2502,7 +2502,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
-	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rps.enabled && intel_rc6_enabled())))
+	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rc6.enabled && intel_rc6_enabled())))
 		return -ENODEV;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))

commit 771decb0b4d75b5cc1d7ddfbdf512bd8768d2793
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Tue Oct 10 22:30:07 2017 +0100

    drm/i915: Rename intel_enable_rc6 to intel_rc6_enabled
    
    This function gives the status of RC6, whether disabled or if
    enabled then which state. intel_enable_rc6 will be used for
    enabling RC6 in the next patch.
    
    v2: Rebase.
    
    v3: Rebase.
    
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Radoslaw Szwichtenberg <radoslaw.szwichtenberg@intel.com> #1
    Reviewed-by: Ewelina Musial <ewelina.musial@intel.com> #1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1507360055-19948-10-git-send-email-sagar.a.kamble@intel.com
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171010213010.7415-9-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9b8a19149154..f3ac1f45e154 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2502,7 +2502,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
-	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rps.enabled && intel_enable_rc6())))
+	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rps.enabled && intel_rc6_enabled())))
 		return -ENODEV;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))

commit 562d9bae08a10335368bf54ea5cc7e4f6185bccc
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Tue Oct 10 22:30:06 2017 +0100

    drm/i915: Name structure in dev_priv that contains RPS/RC6 state as "gt_pm"
    
    Prepared substructure rps for RPS related state. autoenable_work is
    used for RC6 too hence it is defined outside rps structure. As we do
    this lot many functions are refactored to use intel_rps *rps to access
    rps related members. Hence renamed intel_rps_client pointer variables
    to rps_client in various functions.
    
    v2: Rebase.
    
    v3: s/pm/gt_pm (Chris)
    Refactored access to rps structure by declaring struct intel_rps * in
    many functions.
    
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Radoslaw Szwichtenberg <radoslaw.szwichtenberg@intel.com> #1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1507360055-19948-9-git-send-email-sagar.a.kamble@intel.com
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171010213010.7415-8-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9ebbb08dcf2d..9b8a19149154 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2502,7 +2502,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
-	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6())))
+	if (WARN_ON_ONCE(!(dev_priv->gt_pm.rps.enabled && intel_enable_rc6())))
 		return -ENODEV;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))

commit ad1443f0f3dd1b2434af897af8b8f942e47cf8c3
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Tue Oct 10 22:30:04 2017 +0100

    drm/i915: Name i915_runtime_pm structure in dev_priv as "runtime_pm"
    
    We were using dev_priv->pm for runtime power management related state.
    This patch renames it to "runtime_pm" which looks more apt.
    
    v2: s/rpm/runtime_pm (Chris)
    
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Radoslaw Szwichtenberg <radoslaw.szwichtenberg@intel.com> #1
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/1507360055-19948-7-git-send-email-sagar.a.kamble@intel.com
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171010213010.7415-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 66fc156b294a..9ebbb08dcf2d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2544,12 +2544,12 @@ static int intel_runtime_suspend(struct device *kdev)
 	intel_uncore_suspend(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
-	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
+	WARN_ON_ONCE(atomic_read(&dev_priv->runtime_pm.wakeref_count));
 
 	if (intel_uncore_arm_unclaimed_mmio_detection(dev_priv))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");
 
-	dev_priv->pm.suspended = true;
+	dev_priv->runtime_pm.suspended = true;
 
 	/*
 	 * FIXME: We really should find a document that references the arguments
@@ -2595,11 +2595,11 @@ static int intel_runtime_resume(struct device *kdev)
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
-	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
+	WARN_ON_ONCE(atomic_read(&dev_priv->runtime_pm.wakeref_count));
 	disable_rpm_wakeref_asserts(dev_priv);
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
-	dev_priv->pm.suspended = false;
+	dev_priv->runtime_pm.suspended = false;
 	if (intel_uncore_unclaimed_mmio(dev_priv))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 

commit ac14fbd460d0ec16e7750e40dcd8199b0ff83d0a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 3 21:34:53 2017 +0100

    drm/i915/scheduler: Support user-defined priorities
    
    Use a priority stored in the context as the initial value when
    submitting a request. This allows us to change the default priority on a
    per-context basis, allowing different contexts to be favoured with GPU
    time at the expense of lower importance work. The user can adjust the
    context's priority via I915_CONTEXT_PARAM_PRIORITY, with more positive
    values being higher priority (they will be serviced earlier, after their
    dependencies have been resolved). Any prerequisite work for an execbuf
    will have its priority raised to match the new request as required.
    
    Normal users can specify any value in the range of -1023 to 0 [default],
    i.e. they can reduce the priority of their workloads (and temporarily
    boost it back to normal if so desired).
    
    Privileged users can specify any value in the range of -1023 to 1023,
    [default is 0], i.e. they can raise their priority above all overs and
    so potentially starve the system.
    
    Note that the existing schedulers are not fair, nor load balancing, the
    execution is strictly by priority on a first-come, first-served basis,
    and the driver may choose to boost some requests above the range
    available to users.
    
    This priority was originally based around nice(2), but evolved to allow
    clients to adjust their priority within a small range, and allow for a
    privileged high priority range.
    
    For example, this can be used to implement EGL_IMG_context_priority
    https://www.khronos.org/registry/egl/extensions/IMG/EGL_IMG_context_priority.txt
    
            EGL_CONTEXT_PRIORITY_LEVEL_IMG determines the priority level of
            the context to be created. This attribute is a hint, as an
            implementation may not support multiple contexts at some
            priority levels and system policy may limit access to high
            priority contexts to appropriate system privilege level. The
            default value for EGL_CONTEXT_PRIORITY_LEVEL_IMG is
            EGL_CONTEXT_PRIORITY_MEDIUM_IMG."
    
    so we can map
    
            PRIORITY_HIGH -> 1023 [privileged, will failback to 0]
            PRIORITY_MED -> 0 [default]
            PRIORITY_LOW -> -1023
    
    They also map onto the priorities used by VkQueue (and a VkQueue is
    essentially a timeline, our i915_gem_context under full-ppgtt).
    
    v2: s/CAP_SYS_ADMIN/CAP_SYS_NICE/
    v3: Report min/max user priorities as defines in the uapi, and rebase
    internal priorities on the exposed values.
    
    Testcase: igt/gem_exec_schedule
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171003203453.15692-9-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7614880edad8..66fc156b294a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -370,6 +370,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = 0;
 		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule) {
 			value |= I915_SCHEDULER_CAP_ENABLED;
+			value |= I915_SCHEDULER_CAP_PRIORITY;
 
 			if (INTEL_INFO(dev_priv)->has_logical_ring_preemption &&
 			    i915_modparams.enable_execlists &&

commit beecec9017901849352cfd2886981fe462f9fed0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 3 21:34:52 2017 +0100

    drm/i915/execlists: Preemption!
    
    When we write to ELSP, it triggers a context preemption at the earliest
    arbitration point (3DPRIMITIVE, some PIPECONTROLs, a few other
    operations and the explicit MI_ARB_CHECK). If this is to the same
    context, it triggers a LITE_RESTORE where the RING_TAIL is merely
    updated (used currently to chain requests from the same context
    together, avoiding bubbles). However, if it is to a different context, a
    full context-switch is performed and it will start to execute the new
    context saving the image of the old for later execution.
    
    Previously we avoided preemption by only submitting a new context when
    the old was idle. But now we wish embrace it, and if the new request has
    a higher priority than the currently executing request, we write to the
    ELSP regardless, thus triggering preemption, but we tell the GPU to
    switch to our special preemption context (not the target). In the
    context-switch interrupt handler, we know that the previous contexts
    have finished execution and so can unwind all the incomplete requests
    and compute the new highest priority request to execute.
    
    It would be feasible to avoid the switch-to-idle intermediate by
    programming the ELSP with the target context. The difficulty is in
    tracking which request that should be whilst maintaining the dependency
    change, the error comes in with coalesced requests. As we only track the
    most recent request and its priority, we may run into the issue of being
    tricked in preempting a high priority request that was followed by a
    low priority request from the same context (e.g. for PI); worse still
    that earlier request may be our own dependency and the order then broken
    by preemption. By injecting the switch-to-idle and then recomputing the
    priority queue, we avoid the issue with tracking in-flight coalesced
    requests. Having tried the preempt-to-busy approach, and failed to find
    a way around the coalesced priority issue, Michal's original proposal to
    inject an idle context (based on handling GuC preemption) succeeds.
    
    The current heuristic for deciding when to preempt are only if the new
    request is of higher priority, and has the privileged priority of
    greater than 0. Note that the scheduler remains unfair!
    
    v2: Disable for gen8 (bdw/bsw) as we need additional w/a for GPGPU.
    Since, the feature is now conditional and not always available when we
    have a scheduler, make it known via the HAS_SCHEDULER GETPARAM (now a
    capability mask).
    v3: Stylistic tweaks.
    v4: Appease Joonas with a snippet of kerneldoc, only to fuel to fire of
    the preempt vs preempting debate.
    
    Suggested-by: Michal Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ben Widawsky <benjamin.widawsky@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171003203453.15692-8-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 006332805702..7614880edad8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -368,9 +368,16 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		break;
 	case I915_PARAM_HAS_SCHEDULER:
 		value = 0;
-		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule)
+		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule) {
 			value |= I915_SCHEDULER_CAP_ENABLED;
+
+			if (INTEL_INFO(dev_priv)->has_logical_ring_preemption &&
+			    i915_modparams.enable_execlists &&
+			    !i915_modparams.enable_guc_submission)
+				value |= I915_SCHEDULER_CAP_PREEMPTION;
+		}
 		break;
+
 	case I915_PARAM_MMAP_VERSION:
 		/* Remember to bump this if the version changes! */
 	case I915_PARAM_HAS_GEM:

commit bf64e0b00e1ff30449cc68e7bc7498adb6faa343
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 3 21:34:51 2017 +0100

    drm/i915: Expand I915_PARAM_HAS_SCHEDULER into a capability bitmask
    
    In the next few patches, we wish to enable different features for the
    scheduler, some which may subtlety change ABI (e.g. allow requests to be
    reordered under different circumstances). So we need to make sure
    userspace is cognizant of the changes (if they care), by which we employ
    the usual method of a GETPARAM. We already have an
    I915_PARAM_HAS_SCHEDULER (which notes the existing ability to reorder
    requests to avoid bubbles), and now we wish to extend that to be a
    bitmask to describe the different capabilities implemented.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171003203453.15692-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 74a456fe487f..006332805702 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -367,8 +367,9 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = i915_gem_mmap_gtt_version();
 		break;
 	case I915_PARAM_HAS_SCHEDULER:
-		value = dev_priv->engine[RCS] &&
-			dev_priv->engine[RCS]->schedule;
+		value = 0;
+		if (dev_priv->engine[RCS] && dev_priv->engine[RCS]->schedule)
+			value |= I915_SCHEDULER_CAP_ENABLED;
 		break;
 	case I915_PARAM_MMAP_VERSION:
 		/* Remember to bump this if the version changes! */

commit 1fc556fa346948c337d1b04d809443f65e77e04f
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Wed Oct 4 15:33:24 2017 +0000

    drm/i915/uc: Create intel_uc_init_mmio
    
    This patch adds new function intel_uc_init_mmio which will initialize
    MMIO access related variables prior to uc load/init.
    
    v2: Removed unnecessary export of guc_send_init_regs. Created
    intel_uc_init_mmio that currently wraps guc_init_send_regs. (Michal)
    
    v3 (Michal): add kerneldoc (Joonas)
    
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171004153327.32608-4-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5cc24344c266..74a456fe487f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1007,6 +1007,8 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 	intel_uncore_init(dev_priv);
 
+	intel_uc_init_mmio(dev_priv);
+
 	ret = intel_engines_init_mmio(dev_priv);
 	if (ret)
 		goto err_uncore;

commit dd9f31c7a3887950cbd0d49eb9d43f7a1518a356
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Aug 16 17:46:07 2017 +0300

    drm/i915/gen9+: Set same power state before hibernation image save/restore
    
    Atm, on GEN9 big core platforms before saving the hibernation image we
    uninitialize the display, disabling power wells manually, while before
    restoring the image we keep things powered (letting HW/DMC power down
    things as needed). The state mismatch will trigger the following error:
    
    DC state mismatch (0x0 -> 0x2)
    
    While the restore handler knows how to initialize the display from an
    unknown state (due to a different loader kernel or not having i915
    loaded in the loader kernel) we should still use the same state for
    consistency before image saving and restoring. Do this by uniniting the
    display before restoring the image too.
    
    Bugzilla: https://bugs.freedesktop.org/attachment.cgi?id=133376
    Reported-and-tested-by: Wang Wendy <wendy.wang@intel.com>
    Reported-and-tested-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Wang Wendy <wendy.wang@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170816144607.9935-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 59ac9199b35d..5cc24344c266 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1580,7 +1580,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	intel_display_set_init_power(dev_priv, false);
 
-	fw_csr = !IS_GEN9_LP(dev_priv) &&
+	fw_csr = !IS_GEN9_LP(dev_priv) && !hibernation &&
 		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
@@ -2070,11 +2070,14 @@ static int i915_pm_resume(struct device *kdev)
 /* freeze: before creating the hibernation_image */
 static int i915_pm_freeze(struct device *kdev)
 {
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 	int ret;
 
-	ret = i915_pm_suspend(kdev);
-	if (ret)
-		return ret;
+	if (dev->switch_power_state != DRM_SWITCH_POWER_OFF) {
+		ret = i915_drm_suspend(dev);
+		if (ret)
+			return ret;
+	}
 
 	ret = i915_gem_freeze(kdev_to_i915(kdev));
 	if (ret)
@@ -2085,11 +2088,14 @@ static int i915_pm_freeze(struct device *kdev)
 
 static int i915_pm_freeze_late(struct device *kdev)
 {
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 	int ret;
 
-	ret = i915_pm_suspend_late(kdev);
-	if (ret)
-		return ret;
+	if (dev->switch_power_state != DRM_SWITCH_POWER_OFF) {
+		ret = i915_drm_suspend_late(dev, true);
+		if (ret)
+			return ret;
+	}
 
 	ret = i915_gem_freeze_late(kdev_to_i915(kdev));
 	if (ret)

commit ae7617f0ef1820be033eef93859a6bb6174a843f
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Sep 27 17:41:38 2017 +0100

    drm/i915: Allow optimized platform checks
    
    If we store the platform as a bitmask, and convert the
    IS_PLATFORM macro to use it, we allow the compiler to
    merge the IS_PLATFORM(a) || IS_PLATFORM(b) || ... checks
    into a single conditional.
    
    As a secondary benefit this saves almost 1k of text:
    
        text           data     bss     dec     hex filename
    -1460254          60014    3656 1523924  1740d4 drivers/gpu/drm/i915/i915.ko
    +1459260          60026    3656 1522942  173cfe drivers/gpu/drm/i915/i915.ko
    
    v2: Removed the infamous -1.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170927164138.15474-1-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7056bb299dc6..59ac9199b35d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -870,6 +870,10 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	memcpy(device_info, match_info, sizeof(*device_info));
 	device_info->device_id = dev_priv->drm.pdev->device;
 
+	BUILD_BUG_ON(INTEL_MAX_PLATFORMS >
+		     sizeof(device_info->platform_mask) * BITS_PER_BYTE);
+	device_info->platform_mask = BIT(device_info->platform);
+
 	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
 	device_info->gen_mask = BIT(device_info->gen - 1);
 

commit 4f044a88a86adb4c8cc6cb1a7303bb9c61ea2caa
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Tue Sep 19 19:38:44 2017 +0000

    drm/i915: Rename global i915 to i915_modparams
    
    Our global struct with params is named exactly the same way
    as new preferred name for the drm_i915_private function parameter.
    To avoid such name reuse lets use different name for the global.
    
    v5: pure rename
    v6: fix
    
    Credits-to: Coccinelle
    
    @@
    identifier n;
    @@
    (
    -       i915.n
    +       i915_modparams.n
    )
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Ville Syrjala <ville.syrjala@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170919193846.38060-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5c111ea96e80..7056bb299dc6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -58,12 +58,12 @@ static unsigned int i915_load_fail_count;
 
 bool __i915_inject_load_failure(const char *func, int line)
 {
-	if (i915_load_fail_count >= i915.inject_load_failure)
+	if (i915_load_fail_count >= i915_modparams.inject_load_failure)
 		return false;
 
-	if (++i915_load_fail_count == i915.inject_load_failure) {
+	if (++i915_load_fail_count == i915_modparams.inject_load_failure) {
 		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
-			 i915.inject_load_failure, func, line);
+			 i915_modparams.inject_load_failure, func, line);
 		return true;
 	}
 
@@ -106,8 +106,8 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 
 static bool i915_error_injected(struct drm_i915_private *dev_priv)
 {
-	return i915.inject_load_failure &&
-	       i915_load_fail_count == i915.inject_load_failure;
+	return i915_modparams.inject_load_failure &&
+	       i915_load_fail_count == i915_modparams.inject_load_failure;
 }
 
 #define i915_load_error(dev_priv, fmt, ...)				     \
@@ -321,7 +321,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = USES_PPGTT(dev_priv);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
-		value = i915.semaphores;
+		value = i915_modparams.semaphores;
 		break;
 	case I915_PARAM_HAS_SECURE_BATCHES:
 		value = capable(CAP_SYS_ADMIN);
@@ -340,7 +340,8 @@ static int i915_getparam(struct drm_device *dev, void *data,
 			return -ENODEV;
 		break;
 	case I915_PARAM_HAS_GPU_RESET:
-		value = i915.enable_hangcheck && intel_has_gpu_reset(dev_priv);
+		value = i915_modparams.enable_hangcheck &&
+			intel_has_gpu_reset(dev_priv);
 		if (value && intel_has_reset_engine(dev_priv))
 			value = 2;
 		break;
@@ -1031,9 +1032,9 @@ static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 
 static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 {
-	i915.enable_execlists =
+	i915_modparams.enable_execlists =
 		intel_sanitize_enable_execlists(dev_priv,
-						i915.enable_execlists);
+						i915_modparams.enable_execlists);
 
 	/*
 	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
@@ -1041,12 +1042,15 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	 * do this now so that we can print out any log messages once rather
 	 * than every time we check intel_enable_ppgtt().
 	 */
-	i915.enable_ppgtt =
-		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
-	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
+	i915_modparams.enable_ppgtt =
+		intel_sanitize_enable_ppgtt(dev_priv,
+					    i915_modparams.enable_ppgtt);
+	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915_modparams.enable_ppgtt);
 
-	i915.semaphores = intel_sanitize_semaphores(dev_priv, i915.semaphores);
-	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n", yesno(i915.semaphores));
+	i915_modparams.semaphores =
+		intel_sanitize_semaphores(dev_priv, i915_modparams.semaphores);
+	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n",
+			 yesno(i915_modparams.semaphores));
 
 	intel_uc_sanitize_options(dev_priv);
 
@@ -1277,7 +1281,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int ret;
 
 	/* Enable nuclear pageflip on ILK+ */
-	if (!i915.nuclear_pageflip && match_info->gen < 5)
+	if (!i915_modparams.nuclear_pageflip && match_info->gen < 5)
 		driver.driver_features &= ~DRIVER_ATOMIC;
 
 	ret = -ENOMEM;

commit 2503a0fef214ddadfdf5844d62453591de35586f
Author: Kumar, Mahesh <mahesh1.kumar@intel.com>
Date:   Thu Aug 17 19:15:28 2017 +0530

    drm/i915/bxt+: Enable IPC support
    
    This patch adds IPC support. This patch also enables IPC in all supported
    platforms based on has_ipc flag.
    IPC (Isochronous Priority Control) is the hardware feature, which
    dynamically controls the memory read priority of Display.
    
    When IPC is enabled, plane read requests are sent at high priority until
    filling above the transition watermark, then the requests are sent at
    lower priority until dropping below the level 0 watermark.
    The lower priority requests allow other memory clients to have better
    memory access. When IPC is disabled, all plane read requests are sent at
    high priority.
    
    Changes since V1:
     - Remove commandline parameter to disable ipc
     - Address Paulo's comments
    Changes since V2:
     - Address review comments
     - Set ipc_enabled flag
    Changes since V3:
     - move ipc_enabled flag assignment inside intel_ipc_enable function
    Changes since V4:
     - Re-enable IPC after suspend/resume
    Changes since V5:
     - Enable IPC for all gen >=9 except SKL
    Changes since V6:
     - fix commit msg
     - after resume program IPC based on SW state.
    Changes since V7:
     - Modify IPC support check based on HAS_IPC macro (suggested by Chris)
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170817134529.2839-8-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff70fc45ba7c..5c111ea96e80 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1341,7 +1341,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	intel_runtime_pm_enable(dev_priv);
 
-	dev_priv->ipc_enabled = false;
+	intel_init_ipc(dev_priv);
 
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
 		DRM_INFO("DRM_I915_DEBUG enabled\n");
@@ -2609,6 +2609,8 @@ static int intel_runtime_resume(struct device *kdev)
 	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_init(dev_priv);
 
+	intel_enable_ipc(dev_priv);
+
 	enable_rpm_wakeref_asserts(dev_priv);
 
 	if (ret)

commit bcd7726f7d4f3c7d9c7e6d0a833520c61dd9eb21
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 6 12:14:05 2017 +0100

    drm/i915: Re-enable GTT following a device reset
    
    Ville Syrjälä spotted that PGETBL_CTL was losing its enable bit upon a
    reset. That was causing the display to show garbage on his 945gm. On my
    i915gm the effect was far more severe; re-enabling the display following
    the reset without PGETBL_CTL being enabled lead to an immediate hard
    hang.
    
    We do have a routine to re-enable PGETBL_CTL which is applicable to
    gen2-4, although on gen4 it is documented that a graphics reset doesn't
    alter the register (no such wording is given for gen3) and should be safe
    to call to punch back in the enable bit. However, that leaves the question
    of whether we need to completely re-initialise the register and the
    rest of the GSM. For g33/pnv/gen4+, where we do have a configurable
    page table, its contents do seem to be kept, and so we should be able to
    recover without having to reinitialise the GTT from scratch (as prior to
    g33, that register is configured by the BIOS and we leave alone except
    for the enable bit).
    
    This appears to have been broken by commit 5fbd0418eef2 ("drm/i915:
    Re-enable GGTT earlier during resume on pre-gen6 platforms"), which
    moved the intel_enable_gtt() from i915_gem_init_hw() (also used by
    reset) to add it earlier during hw init and resume, missing the reset
    path.
    
    v2: Find the culprit, rearrange ggtt_enable to be before gem_init_hw to
    match init/resume
    
    Reported-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Fixes: 5fbd0418eef2 ("drm/i915: Re-enable GGTT earlier during resume on pre-gen6 platforms")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101852
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170906111405.27110-1-chris@chris-wilson.co.uk
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    (cherry picked from commit 0db8c961209153498fe7e279b8f0d3deb81808f0)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43100229613c..9f45cfeae775 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1891,9 +1891,15 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 
 	/*
 	 * Everything depends on having the GTT running, so we need to start
-	 * there.  Fortunately we don't need to do this unless we reset the
-	 * chip at a PCI level.
-	 *
+	 * there.
+	 */
+	ret = i915_ggtt_enable_hw(i915);
+	if (ret) {
+		DRM_ERROR("Failed to re-enable GGTT following reset %d\n", ret);
+		goto error;
+	}
+
+	/*
 	 * Next we need to restore the context, but we don't use those
 	 * yet either...
 	 *

commit 0db8c961209153498fe7e279b8f0d3deb81808f0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 6 12:14:05 2017 +0100

    drm/i915: Re-enable GTT following a device reset
    
    Ville Syrjälä spotted that PGETBL_CTL was losing its enable bit upon a
    reset. That was causing the display to show garbage on his 945gm. On my
    i915gm the effect was far more severe; re-enabling the display following
    the reset without PGETBL_CTL being enabled lead to an immediate hard
    hang.
    
    We do have a routine to re-enable PGETBL_CTL which is applicable to
    gen2-4, although on gen4 it is documented that a graphics reset doesn't
    alter the register (no such wording is given for gen3) and should be safe
    to call to punch back in the enable bit. However, that leaves the question
    of whether we need to completely re-initialise the register and the
    rest of the GSM. For g33/pnv/gen4+, where we do have a configurable
    page table, its contents do seem to be kept, and so we should be able to
    recover without having to reinitialise the GTT from scratch (as prior to
    g33, that register is configured by the BIOS and we leave alone except
    for the enable bit).
    
    This appears to have been broken by commit 5fbd0418eef2 ("drm/i915:
    Re-enable GGTT earlier during resume on pre-gen6 platforms"), which
    moved the intel_enable_gtt() from i915_gem_init_hw() (also used by
    reset) to add it earlier during hw init and resume, missing the reset
    path.
    
    v2: Find the culprit, rearrange ggtt_enable to be before gem_init_hw to
    match init/resume
    
    Reported-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Fixes: 5fbd0418eef2 ("drm/i915: Re-enable GGTT earlier during resume on pre-gen6 platforms")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101852
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170906111405.27110-1-chris@chris-wilson.co.uk
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f10a078e3a55..ff70fc45ba7c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1892,9 +1892,15 @@ void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 
 	/*
 	 * Everything depends on having the GTT running, so we need to start
-	 * there.  Fortunately we don't need to do this unless we reset the
-	 * chip at a PCI level.
-	 *
+	 * there.
+	 */
+	ret = i915_ggtt_enable_hw(i915);
+	if (ret) {
+		DRM_ERROR("Failed to re-enable GGTT following reset %d\n", ret);
+		goto error;
+	}
+
+	/*
 	 * Next we need to restore the context, but we don't use those
 	 * yet either...
 	 *

commit eb371933cf4d3495d0899880b2e0e252ce9db517
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Aug 21 16:50:56 2017 -0700

    drm/i915/cfl: Coffee Lake works on Kaby Lake PCH.
    
    Coffee Lake CPU on Kaby Lake PCH is possible.
    It does exist, and it does work.
    
    The only missed case was this warning here noticed
    by Wendy who could get one system with this configuration
    and reported the issue for us:
    
    Hardware Configuration
    Board ID KBL S DDR4 UDIMM EV CRB
    Processor    Intel® Processor code named Coffee Lake S, (6+2), 6 cores 12 threads, GT2, A0 (Internal) (QNJ4)
    
    [ 3.220585] WARNING: CPU: 10 PID: 206 at drivers/gpu/drm/i915/i915_drv.c:340 i915_driver_load+0x1210/0x1660 [i915]
    [ 3.221312] Modules linked in: hid_generic usbhid i915 i2c_algo_bit drm_kms_helper e1000e syscopyarea sysfillrect sysimgblt nvme fb_sys_fops ptp ahci i2c_hid drm pps_core nvme_core libahci wmi hid video
    [ 3.222050] CPU: 10 PID: 206 Comm: systemd-udevd Not tainted 4.13.0-rc5-intel-next+ #1
    [ 3.222706] Hardware name: Intel Corporation Kabylake Client platform/KBL S DDR4 UDIMM EV CRB, BIOS KBLSE2R1.R00.X089.P00.1705051000 05/05/2017
    
    Cc: Wendy Wang <wendy.wang@intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170821235056.9015-1-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43100229613c..f10a078e3a55 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -239,7 +239,8 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
-					!IS_KABYLAKE(dev_priv));
+					!IS_KABYLAKE(dev_priv) &&
+					!IS_COFFEELAKE(dev_priv));
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");

commit cf6e7bac6357f0ccca51fcb5eb325e724f6b4c95
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Tue Aug 15 15:57:33 2017 +0100

    drm/i915: Add support for drm syncobjs
    
    This commit adds support for waiting on or signaling DRM syncobjs as
    part of execbuf.  It does so by hijacking the currently unused cliprects
    pointer to instead point to an array of i915_gem_exec_fence structs
    which containe a DRM syncobj and a flags parameter which specifies
    whether to wait on it or to signal it.  This implementation
    theoretically allows for both flags to be set in which case it waits on
    the dma_fence that was in the syncobj and then immediately replaces it
    with the dma_fence from the current execbuf.
    
    v2:
     - Rebase on new syncobj API
    v3:
     - Pull everything out into helpers
     - Do all allocation in gem_execbuffer2
     - Pack the flags in the bottom 2 bits of the drm_syncobj*
    v4:
     - Prevent a potential race on syncobj->fence
    
    Testcase: igt/gem_exec_fence/syncobj*
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/1499289202-25441-1-git-send-email-jason.ekstrand@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170815145733.4562-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 25de4a95526b..43100229613c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -388,6 +388,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_FENCE:
 	case I915_PARAM_HAS_EXEC_CAPTURE:
 	case I915_PARAM_HAS_EXEC_BATCH_FIRST:
+	case I915_PARAM_HAS_EXEC_FENCE_ARRAY:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from
@@ -2739,7 +2740,7 @@ static struct drm_driver driver = {
 	 */
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
-	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC,
+	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_SYNCOBJ,
 	.release = i915_driver_release,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,

commit 148b1e115eae37c9f3705691b4c45aa4cc0fa71d
Merge: 3ec0af7f223b 09ef2378dc42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Aug 10 18:12:01 2017 +0200

    Merge airlied/drm-next into drm-intel-next-queued
    
    Ben Widawsky/Daniel Stone need the extended modifier support from
    drm-misc to be able to merge CCS support for i915.ko
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 5a7e6a3fa1bf02c426a45c52cf9c27050753768f
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Sun Aug 6 17:41:00 2017 +0200

    drm/i915: Use the drm_driver.dumb_destroy default
    
    drm_gem_dumb_destroy() is the drm_driver.dumb_destroy default,
    so no need to set it.
    
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1502034068-51384-12-git-send-email-noralf@tronnes.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d310d8245dca..4c96a7214482 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2755,7 +2755,6 @@ static struct drm_driver driver = {
 
 	.dumb_create = i915_gem_dumb_create,
 	.dumb_map_offset = i915_gem_mmap_gtt,
-	.dumb_destroy = drm_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
 	.num_ioctls = ARRAY_SIZE(i915_ioctls),
 	.fops = &i915_driver_fops,

commit 23247d715d3cf679cac24d1c4de2d76774a2a495
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Jul 31 11:52:20 2017 -0700

    drm/i915: Fix PCH names for KBP and CNP.
    
    No functional change.
    
    KBP was based on SPT and spec wasn't clear about the full name.
    There was the initial point of the "Point" confusion.
    
    Later the split with Coffee Lake and Cannon Lake both using CNP
    and also some uncertainty from the specs we had at that time
    made us to propagated the mistake along.
    
    So, let's fix this now and avoid propagating these wrong
    "points".
    
    Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170731185220.758-1-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cc25115c2db7..ba15844cbafc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -237,17 +237,17 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_KBP;
-				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
+				DRM_DEBUG_KMS("Found Kaby Lake PCH (KBP)\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
-				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
+				DRM_DEBUG_KMS("Found Cannon Lake PCH (CNP)\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
 			} else if (id == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
-				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
+				DRM_DEBUG_KMS("Found Cannon Lake LP PCH (CNP-LP)\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
 			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||

commit f89823c212246d0671cc51e69894a3df1a743aee
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Thu Aug 3 18:05:50 2017 +0100

    drm/i915/perf: Implement I915_PERF_ADD/REMOVE_CONFIG interface
    
    The motivation behind this new interface is expose at runtime the
    creation of new OA configs which can be used as part of the i915 perf
    open interface. This will enable the kernel to learn new configs which
    may be experimental, or otherwise not part of the core set currently
    available through the i915 perf interface.
    
    v2: Drop DRM_ERROR for userspace errors (Matthew)
        Add padding to userspace structure (Matthew)
        s/guid/uuid/ (Matthew)
    
    v3: Use u32 instead of int to iterate through registers (Matthew)
    
    v4: Lock access to dynamic config list (Lionel)
    
    v5: by Matthew:
        Fix uninitialized error values
        Fix incorrect unwiding when opening perf stream
        Use kmalloc_array() to store register
        Use uuid_is_valid() to valid config uuids
        Declare ioctls as write only
        Check padding members are set to 0
        by Lionel:
        Return ENOENT rather than EINVAL when trying to remove non
        existing config
    
    v6: by Chris:
        Use ref counts for OA configs
        Store UUID in drm_i915_perf_oa_config rather then using pointer
        Shuffle fields of drm_i915_perf_oa_config to avoid padding
    
    v7: by Chris
        Rename uapi pointers fields to end with '_ptr'
    
    v8: by Andrzej, Marek, Sebastian
        Update register whitelisting
        by Lionel
        Add more register names for documentation
        Allow configuration programming in non-paranoid mode
        Add support for value filter for a couple of registers already
        programmed in other part of the kernel
    
    v9: Documentation fix (Lionel)
        Allow writing WAIT_FOR_RC6_EXIT only on Gen8+ (Andrzej)
    
    v10: Perform read access_ok() on register pointers (Lionel)
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
    Reviewed-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170803165812.2373-2-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 214555e813f1..cc25115c2db7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2729,6 +2729,8 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERF_OPEN, i915_perf_open_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_PERF_ADD_CONFIG, i915_perf_add_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_PERF_REMOVE_CONFIG, i915_perf_remove_config_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 535275d3238f3a302b6b7812b3af6ab5989a06e2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 21 13:32:37 2017 +0100

    drm/i915: Squelch reset messages during selftests
    
    During our selftests, we try reseting the GPU tens of thousands of
    times, flooding the dmesg with our reset spam drowning out any potential
    warnings. Add an option to i915_reset()/i915_reset_engine() to specify a
    quiet reset for selftesting.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170721123238.16428-19-chris@chris-wilson.co.uk
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ac8215c0e36..214555e813f1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1831,7 +1831,8 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 
 /**
  * i915_reset - reset chip after a hang
- * @dev_priv: device private to reset
+ * @i915: #drm_i915_private to reset
+ * @flags: Instructions
  *
  * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
  * on failure.
@@ -1846,34 +1847,34 @@ static int i915_resume_switcheroo(struct drm_device *dev)
  *   - re-init interrupt state
  *   - re-init display
  */
-void i915_reset(struct drm_i915_private *dev_priv)
+void i915_reset(struct drm_i915_private *i915, unsigned int flags)
 {
-	struct i915_gpu_error *error = &dev_priv->gpu_error;
+	struct i915_gpu_error *error = &i915->gpu_error;
 	int ret;
 
-	lockdep_assert_held(&dev_priv->drm.struct_mutex);
+	lockdep_assert_held(&i915->drm.struct_mutex);
 	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
 
 	if (!test_bit(I915_RESET_HANDOFF, &error->flags))
 		return;
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
-	if (!i915_gem_unset_wedged(dev_priv))
+	if (!i915_gem_unset_wedged(i915))
 		goto wakeup;
 
-	dev_notice(dev_priv->drm.dev,
-		   "Resetting chip after gpu hang\n");
+	if (!(flags & I915_RESET_QUIET))
+		dev_notice(i915->drm.dev, "Resetting chip after gpu hang\n");
 	error->reset_count++;
 
-	disable_irq(dev_priv->drm.irq);
-	ret = i915_gem_reset_prepare(dev_priv);
+	disable_irq(i915->drm.irq);
+	ret = i915_gem_reset_prepare(i915);
 	if (ret) {
 		DRM_ERROR("GPU recovery failed\n");
-		intel_gpu_reset(dev_priv, ALL_ENGINES);
+		intel_gpu_reset(i915, ALL_ENGINES);
 		goto error;
 	}
 
-	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
+	ret = intel_gpu_reset(i915, ALL_ENGINES);
 	if (ret) {
 		if (ret != -ENODEV)
 			DRM_ERROR("Failed to reset chip: %i\n", ret);
@@ -1882,8 +1883,8 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset(dev_priv);
-	intel_overlay_reset(dev_priv);
+	i915_gem_reset(i915);
+	intel_overlay_reset(i915);
 
 	/* Ok, now get things going again... */
 
@@ -1899,17 +1900,17 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	 * was running at the time of the reset (i.e. we weren't VT
 	 * switched away).
 	 */
-	ret = i915_gem_init_hw(dev_priv);
+	ret = i915_gem_init_hw(i915);
 	if (ret) {
 		DRM_ERROR("Failed hw init on reset %d\n", ret);
 		goto error;
 	}
 
-	i915_queue_hangcheck(dev_priv);
+	i915_queue_hangcheck(i915);
 
 finish:
-	i915_gem_reset_finish(dev_priv);
-	enable_irq(dev_priv->drm.irq);
+	i915_gem_reset_finish(i915);
+	enable_irq(i915->drm.irq);
 
 wakeup:
 	clear_bit(I915_RESET_HANDOFF, &error->flags);
@@ -1917,14 +1918,15 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	return;
 
 error:
-	i915_gem_set_wedged(dev_priv);
-	i915_gem_retire_requests(dev_priv);
+	i915_gem_set_wedged(i915);
+	i915_gem_retire_requests(i915);
 	goto finish;
 }
 
 /**
  * i915_reset_engine - reset GPU engine to recover from a hang
  * @engine: engine to reset
+ * @flags: options
  *
  * Reset a specific GPU engine. Useful if a hang is detected.
  * Returns zero on successful reset or otherwise an error code.
@@ -1934,7 +1936,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
  *  - reset engine (which will force the engine to idle)
  *  - re-init/configure engine
  */
-int i915_reset_engine(struct intel_engine_cs *engine)
+int i915_reset_engine(struct intel_engine_cs *engine, unsigned int flags)
 {
 	struct i915_gpu_error *error = &engine->i915->gpu_error;
 	struct drm_i915_gem_request *active_request;
@@ -1942,8 +1944,10 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 
 	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
 
-	dev_notice(engine->i915->drm.dev,
-		   "Resetting %s after gpu hang\n", engine->name);
+	if (!(flags & I915_RESET_QUIET)) {
+		dev_notice(engine->i915->drm.dev,
+			   "Resetting %s after gpu hang\n", engine->name);
+	}
 	error->reset_engine_count[engine->id]++;
 
 	active_request = i915_gem_reset_prepare_engine(engine);

commit 7367612fe1eae573d86fc273a29af0797bfb918f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 21 13:32:31 2017 +0100

    drm/i915: Emit a user level message when resetting the GPU (or engine)
    
    Although a banned context will be told to -EIO off if they try to submit
    more requests, we have a discrepancy between whole device resets and
    per-engine resets where we report the GPU reset but not the engine
    resets. This leaves a bit of mystery as to why the context was banned,
    and also reduces awareness overall of when a GPU (engine) reset occurs
    with its possible side-effects.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170721123238.16428-13-chris@chris-wilson.co.uk
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6753fc861dbb..3ac8215c0e36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1861,9 +1861,10 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	if (!i915_gem_unset_wedged(dev_priv))
 		goto wakeup;
 
+	dev_notice(dev_priv->drm.dev,
+		   "Resetting chip after gpu hang\n");
 	error->reset_count++;
 
-	pr_notice("drm/i915: Resetting chip after gpu hang\n");
 	disable_irq(dev_priv->drm.irq);
 	ret = i915_gem_reset_prepare(dev_priv);
 	if (ret) {
@@ -1941,7 +1942,9 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 
 	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
 
-	DRM_DEBUG_DRIVER("resetting %s\n", engine->name);
+	dev_notice(engine->i915->drm.dev,
+		   "Resetting %s after gpu hang\n", engine->name);
+	error->reset_engine_count[engine->id]++;
 
 	active_request = i915_gem_reset_prepare_engine(engine);
 	if (IS_ERR(active_request)) {
@@ -1974,7 +1977,6 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 	if (ret)
 		goto out;
 
-	error->reset_engine_count[engine->id]++;
 out:
 	i915_gem_reset_finish_engine(engine);
 	return ret;

commit 0364cd19d61caad7292cc4e87f5001595b6c7642
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 21 13:32:21 2017 +0100

    drm/i915: Serialize per-engine resets against new requests
    
    We rely on disabling the execlists (by stopping the tasklet) to prevent
    new requests from submitting to the engine ELSP before we are ready.
    However, we re-enable the engine before we call init_hw which gives
    userspace the opportunity to subit a new request which is then
    overwritten by init_hw -- but not before the HW may have started
    executing. The subsequent out-of-order CSB is detected by our sanity
    checks in intel_lrc_irq_handler().
    
    Fixes: a1ef70e14453 ("drm/i915: Add support for per engine reset recovery")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170721123238.16428-3-chris@chris-wilson.co.uk
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 853d6741d3a5..6753fc861dbb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1951,6 +1951,12 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 	}
 
 	ret = intel_gpu_reset(engine->i915, intel_engine_flag(engine));
+	if (ret) {
+		/* If we fail here, we expect to fallback to a global reset */
+		DRM_DEBUG_DRIVER("Failed to reset %s, ret=%d\n",
+				 engine->name, ret);
+		goto out;
+	}
 
 	/*
 	 * The request that caused the hang is stuck on elsp, we know the
@@ -1959,15 +1965,6 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 	 */
 	i915_gem_reset_engine(engine, active_request);
 
-	i915_gem_reset_finish_engine(engine);
-
-	if (ret) {
-		/* If we fail here, we expect to fallback to a global reset */
-		DRM_DEBUG_DRIVER("Failed to reset %s, ret=%d\n",
-				 engine->name, ret);
-		goto out;
-	}
-
 	/*
 	 * The engine and its registers (and workarounds in case of render)
 	 * have been reset to their default values. Follow the init_ring
@@ -1979,6 +1976,7 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 
 	error->reset_engine_count[engine->id]++;
 out:
+	i915_gem_reset_finish_engine(engine);
 	return ret;
 }
 

commit b4f3e1631f5e8fcfb1da84cbd5d3ec581480954a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 21 13:32:20 2017 +0100

    drm/i915: Reset context image on engines after triggering the reset
    
    We try to fixup the context image after the reset to ensure that there
    are no more pending writes from the hw that may conflict and to fixup
    any that were in flight.
    
    Fixes: a1ef70e14453 ("drm/i915: Add support for per engine reset recovery")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170721123238.16428-2-chris@chris-wilson.co.uk
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6b583dc2eb1f..853d6741d3a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1950,6 +1950,8 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 		goto out;
 	}
 
+	ret = intel_gpu_reset(engine->i915, intel_engine_flag(engine));
+
 	/*
 	 * The request that caused the hang is stuck on elsp, we know the
 	 * active request and can drop it, adjust head to skip the offending
@@ -1957,9 +1959,6 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 	 */
 	i915_gem_reset_engine(engine, active_request);
 
-	/* Finally, reset just this engine. */
-	ret = intel_gpu_reset(engine->i915, intel_engine_flag(engine));
-
 	i915_gem_reset_finish_engine(engine);
 
 	if (ret) {

commit 64282ea2d2a90437c0739ce016b80a1dec16507e
Merge: d2939424ff89 e6742e1021a5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 27 09:33:49 2017 +0200

    Merge airlied/drm-next into drm-intel-next-queued
    
    Resync with upstream to avoid git getting too badly confused. Also, we
    have a conflict with the drm_vblank_cleanup removal, which cannot be
    resolved by simply taking our side. Bake that in properly.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit af055598542670c8533a58582813b1419949cae0
Merge: 9f15a4ab19ab 2d62c799f8ff
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jul 26 13:23:10 2017 +0200

    Merge airlied/drm-next into drm-misc-next
    
    I need this to be able to apply the deferred fbdev setup patches, I
    need the relevant prep work that landed through the drm-intel tree.
    
    Also squash in conflict fixup from Laurent Pinchart.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 8b5d27b911d741054c65fb57f0d794a283308577
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 20 19:57:53 2017 +0200

    drm/i915: Remove intel_flip_work infrastructure
    
    This gets rid of all the interactions between the legacy flip code and
    the modeset code. Yay!
    
    This highlights an ommission in the atomic paths, where we fail to
    apply a boost to the pending rendering when we miss the target vblank.
    But the existing code is still dead and can be removed.
    
    v2: Note that the boosting doesn't work in atomic (Chris).
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170720175754.30751-7-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f406aec8a499..5a21a6fcc90d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -876,7 +876,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	spin_lock_init(&dev_priv->uncore.lock);
 
 	spin_lock_init(&dev_priv->mm.object_stat_lock);
-	spin_lock_init(&dev_priv->mmio_flip_lock);
 	mutex_init(&dev_priv->sb_lock);
 	mutex_init(&dev_priv->modeset_restore_lock);
 	mutex_init(&dev_priv->av_mutex);

commit 99c539bef5385099585335897185a014a8dfe1bf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Jul 15 00:46:56 2017 +0200

    drm/i915: unregister interfaces first in unload
    
    We first need to make sure no one else can get at us anymore,
    before we can proceed to tear down all the datastructures.
    
    Just a small step towards eventually the perfect unload code ...
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170714224656.6431-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ffeb3a3bed58..f406aec8a499 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1375,6 +1375,8 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
+	i915_driver_unregister(dev_priv);
+
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 
@@ -1384,8 +1386,6 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_gvt_cleanup(dev_priv);
 
-	i915_driver_unregister(dev_priv);
-
 	drm_vblank_cleanup(dev);
 
 	intel_modeset_cleanup(dev);

commit 4f256d8219f230cb11b49343931dc0b2fa8bd149
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Jul 15 00:46:55 2017 +0200

    drm/i915: Fix fbdev unload sequence
    
    First thing we need to do is unregister the fbdev instance, but we
    can't just go ahead and kfree it. That must wait until the hotplug and
    polling work are stopped, since they can race with the with the
    teardown. That means we need to split up the fbdev teardown into the
    unregister part and the cleanup part.
    
    I originally suspected that this was broken in one of the unload
    shuffles, but on closer inspection the oldest sequence I've dug out
    also gets this wrong. Just not quite so badly.
    
    I've run drv_module_reload a few hundred times and it's rock solid
    compared to insta-death beforehand. This bug seems to have been
    uncovered by
    
    commit 88be58be886f1215cc73dc8c273c985eecd7385c
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Jul 6 15:00:19 2017 +0200
    
        drm/i915/fbdev: Always forward hotplug events
    
    But the effect of that seems to only be to increase the race window
    enough to make it blow up easier. I'm not exactly clear on what's
    going on there ...
    
    v2: Fix whitespace and use fetch_and_zero (Chris).
    
    Testcase: igt/drv_module_reload
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101791
    Cc: martin.peres@free.fr
    Cc: chris@chris-wilson.co.uk
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170714224656.6431-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 799dd3890cd9..ffeb3a3bed58 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1241,6 +1241,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
+	intel_fbdev_unregister(dev_priv);
 	intel_audio_deinit(dev_priv);
 
 	intel_gpu_ips_teardown();
@@ -1374,8 +1375,6 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	intel_fbdev_fini(dev);
-
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 

commit 3b19f16a556446c144a1f921444931b0cf9447ab
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 18 14:41:24 2017 +0100

    drm/i915: Drain the device workqueue on unload
    
    Workers on the i915->wq may rearm themselves so for completeness we need
    to replace our flush_workqueue() with a call to drain_workqueue() before
    unloading the device.
    
    v2: Reinforce the drain_workqueue with an preceding rcu_barrier() as a
    few of the tasks that need to be drained may first be armed by RCU.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=101627
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170718134124.14832-1-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6f750efe9c3d..799dd3890cd9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -596,7 +596,8 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
-	flush_workqueue(dev_priv->wq);
+	/* Flush any outstanding unpin_work. */
+	i915_gem_drain_workqueue(dev_priv);
 
 	mutex_lock(&dev_priv->drm.struct_mutex);
 	intel_uc_fini_hw(dev_priv);
@@ -1413,9 +1414,6 @@ void i915_driver_unload(struct drm_device *dev)
 	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 	i915_reset_error_state(dev_priv);
 
-	/* Flush any outstanding unpin_work. */
-	drain_workqueue(dev_priv->wq);
-
 	i915_gem_fini(dev_priv);
 	intel_uc_fini_fw(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);

commit 817aef5d86f124e94bfc871ecd6fb2afa4f55417
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Thu Jun 15 11:11:45 2017 +0800

    drm/i915: Setting pch_id for HSW/BDW in virtual environment
    
    In a IGD passthrough environment, the real ISA bridge may doesn't exist.
    then pch_id couldn't be correctly gotten from ISA bridge, but pch_id is
    used to identify LPT_H and LPT_LP. Currently i915 treat all LPT pch as
    LPT_H,then errors occur when i915 runs on LPT_LP machines with igd
    passthrough.
    
    This patch set pch_id for HSW/BDW according to IGD type and isn't fully
    correct. But it solves such issue on HSW/BDW ult/ulx machines.
    QA CI system is blocked by this issue for a long time, it's better that
    we could merge it to unblock QA CI system.
    
    We know the root cause is in device model of virtual passthrough, and
    will resolve it in the future with several parts cooperation in kernel,
    qemu and xen.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99938
    
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1497496305-5364-1-git-send-email-xiong.y.zhang@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a6bef9ee8703..6f750efe9c3d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -135,6 +135,10 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 		DRM_DEBUG_KMS("Assuming CougarPoint PCH\n");
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		ret = PCH_LPT;
+		if (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))
+			dev_priv->pch_id = INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
+		else
+			dev_priv->pch_id = INTEL_PCH_LPT_DEVICE_ID_TYPE;
 		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
 	} else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
 		ret = PCH_SPT;

commit b740e76936c14354a9c5676a3eed839ea8472c41
Merge: 7141fd3e5ba9 6d61e70ccc21
Author: Sean Paul <seanpaul@chromium.org>
Date:   Tue Jun 27 09:18:17 2017 -0400

    Merge remote-tracking branch 'airlied/drm-next' into drm-misc-next
    
    Required for Daniel's drm_vblank_cleanup cleanup

commit e38c2da01f76cca82b59ca612529b81df82a7cc7
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jun 26 23:30:51 2017 +0300

    drm/i915: Disable MSI for all pre-gen5
    
    We have pretty clear evidence that MSIs are getting lost on g4x and
    somehow the interrupt logic doesn't seem to recover from that state
    even if we try hard to clear the IIR.
    
    Disabling IER around the normal IIR clearing in the irq handler isn't
    sufficient to avoid this, so the problem really seems to be further
    up the interrupt chain. This should guarantee that there's always
    an edge if any IIR bits are set after the interrupt handler is done,
    which should normally guarantee that the CPU interrupt is generated.
    That approach seems to work perfectly on VLV/CHV, but apparently
    not on g4x.
    
    MSI is documented to be broken on 965gm at least. The chipset spec
    says MSI is defeatured because interrupts can be delayed or lost,
    which fits well with what we're seeing on g4x. Previously we've
    already disabled GMBUS interrupts on g4x because somehow GMBUS
    manages to raise legacy interrupts even when MSI is enabled.
    
    Since there's such widespread MSI breakahge all over in the pre-gen5
    land let's just give up on MSI on these platforms.
    
    Seqno reporting might be negatively affected by this since the legcy
    interrupts aren't guaranteed to be ordered with the seqno writes,
    whereas MSI interrupts may be? But an occasioanlly missed seqno
    seems like a small price to pay for generally working interrupts.
    
    Cc: stable@vger.kernel.org
    Cc: Diego Viola <diego.viola@gmail.com>
    Tested-by: Diego Viola <diego.viola@gmail.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101261
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170626203051.28480-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43e925933688..a6bef9ee8703 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1141,10 +1141,12 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * and the registers being closely associated.
 	 *
 	 * According to chipset errata, on the 965GM, MSI interrupts may
-	 * be lost or delayed, but we use them anyways to avoid
-	 * stuck interrupts on some machines.
+	 * be lost or delayed, and was defeatured. MSI interrupts seem to
+	 * get lost on g4x as well, and interrupt delivery seems to stay
+	 * properly dead afterwards. So we'll just disable them for all
+	 * pre-gen5 chipsets.
 	 */
-	if (!IS_I945G(dev_priv) && !IS_I945GM(dev_priv)) {
+	if (INTEL_GEN(dev_priv) >= 5) {
 		if (pci_enable_msi(pdev) < 0)
 			DRM_DEBUG_DRIVER("can't enable MSI");
 	}

commit baf54385af7856eab151edb0822dc95e7f5c8b14
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 21 10:28:41 2017 +0200

    drm/i915: Drop drm_vblank_cleanup
    
    On the load error path we can't have pending vblank interrupts, and on
    unload we already call drm_atomic_helper_shutdown beforehand! So all
    good to nuke it.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170621082850.13224-5-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6033355d9469..8d583a2fbf46 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1264,7 +1264,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	ret = i915_load_modeset_init(&dev_priv->drm);
 	if (ret < 0)
-		goto out_cleanup_vblank;
+		goto out_cleanup_hw;
 
 	i915_driver_register(dev_priv);
 
@@ -1285,8 +1285,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	return 0;
 
-out_cleanup_vblank:
-	drm_vblank_cleanup(&dev_priv->drm);
 out_cleanup_hw:
 	i915_driver_cleanup_hw(dev_priv);
 out_cleanup_mmio:
@@ -1322,8 +1320,6 @@ void i915_driver_unload(struct drm_device *dev)
 
 	i915_driver_unregister(dev_priv);
 
-	drm_vblank_cleanup(dev);
-
 	intel_modeset_cleanup(dev);
 
 	/*

commit 36703e79a982c8ce5a8e43833291f2719e92d0d1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 22 11:56:25 2017 +0100

    drm/i915: Break modeset deadlocks on reset
    
    Trying to do a modeset from within a reset is fraught with danger. We
    can fall into a cyclic deadlock where the modeset is waiting on a
    previous modeset that is waiting on a request, and since the GPU hung
    that request completion is waiting on the reset. As modesetting doesn't
    allow its locks to be broken and restarted, or for its *own* reset
    mechanism to take over the display, we have to do something very
    evil instead. If we detect that we are stuck waiting to prepare the
    display reset (by using a very simple timeout), resort to cancelling all
    in-flight requests and throwing the user data into /dev/null, which is
    marginally better than the driver locking up and keeping that data to
    itself.
    
    This is not a fix; this is just a workaround that unbreaks machines
    until we can resolve the deadlock in a way that doesn't lose data!
    
    v2: Move the retirement from set-wegded to the i915_reset() error path,
    after which we no longer any delayed worker cleanup for
    i915_handle_error()
    v3: C abuse for syntactic sugar
    v4: Cover all waits with the timeout to catch more driver breakage
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=99093
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170622105625.16952-1-chris@chris-wilson.co.uk
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 370429e2071f..43e925933688 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1919,6 +1919,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 
 error:
 	i915_gem_set_wedged(dev_priv);
+	i915_gem_retire_requests(dev_priv);
 	goto finish;
 }
 

commit c5e855d07834d67f30fab07e7d7316b090b8073f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Jun 21 20:49:44 2017 +0300

    drm/i915: Always use 9 bits of the LPC bridge device ID for PCH detection
    
    Make the code less confusiong by always using the top 9 bits of the
    LPC bridge device ID to detect the PCH type. We need to add a bit of
    new code for WPT, and we need to adjust the KBP ID as well. All the
    other pre-CNP IDs are fine as is.
    
    The virtualization cases I think are fine. These P2X and P3X IDs
    actually just look like the old PIIX4 and PIIX3 IDs to me. Not sure
    why they're not called PIIX3/4 though. The qemu one has a comment
    saying the full ID is 0x2918 which is fine with 9 bits.
    
    v2: Keep the CNP ID as 0xa300 (DK)
    
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170621174944.23306-1-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 80a6d4d13e6f..370429e2071f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -173,29 +173,25 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
 		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
 			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
-			unsigned short id_ext = pch->device &
-				INTEL_PCH_DEVICE_ID_MASK_EXT;
+
+			dev_priv->pch_id = id;
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_IBX;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
 				WARN_ON(!IS_GEN5(dev_priv));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 				WARN_ON(!IS_GEN6(dev_priv) &&
 					!IS_IVYBRIDGE(dev_priv));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
 				WARN_ON(!IS_GEN6(dev_priv) &&
 					!IS_IVYBRIDGE(dev_priv));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev_priv) &&
@@ -203,39 +199,49 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				WARN_ON(IS_HSW_ULT(dev_priv) ||
 					IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev_priv) &&
 					!IS_BROADWELL(dev_priv));
 				WARN_ON(!IS_HSW_ULT(dev_priv) &&
 					!IS_BDW_ULT(dev_priv));
+			} else if (id == INTEL_PCH_WPT_DEVICE_ID_TYPE) {
+				/* WildcatPoint is LPT compatible */
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found WildcatPoint PCH\n");
+				WARN_ON(!IS_HASWELL(dev_priv) &&
+					!IS_BROADWELL(dev_priv));
+				WARN_ON(IS_HSW_ULT(dev_priv) ||
+					IS_BDW_ULT(dev_priv));
+			} else if (id == INTEL_PCH_WPT_LP_DEVICE_ID_TYPE) {
+				/* WildcatPoint is LPT compatible */
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found WildcatPoint LP PCH\n");
+				WARN_ON(!IS_HASWELL(dev_priv) &&
+					!IS_BROADWELL(dev_priv));
+				WARN_ON(!IS_HSW_ULT(dev_priv) &&
+					!IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
-			} else if (id_ext == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id_ext;
+			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
-			} else if (id_ext == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_id = id_ext;
+			} else if (id == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
@@ -247,7 +253,6 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
 				    pch->subsystem_device ==
 					    PCI_SUBDEVICE_ID_QEMU)) {
-				dev_priv->pch_id = id;
 				dev_priv->pch_type =
 					intel_virt_detect_pch(dev_priv);
 			} else

commit d4cdbf0334c01ac2fa29238bd7b87142ea0f5740
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jun 20 16:03:09 2017 +0300

    drm/i915: Clean up some expressions
    
    Write the '!(SNB||IVB)' checks in the CPT/PPT detections
    as '!SNB && !IVB' to make it less messy looking, and clear out
    some useless parens the from the virtualization PCH detection case.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620130310.13245-5-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7ef113d062f5..80a6d4d13e6f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -185,15 +185,15 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev_priv) ||
-					IS_IVYBRIDGE(dev_priv)));
+				WARN_ON(!IS_GEN6(dev_priv) &&
+					!IS_IVYBRIDGE(dev_priv));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev_priv) ||
-					IS_IVYBRIDGE(dev_priv)));
+				WARN_ON(!IS_GEN6(dev_priv) &&
+					!IS_IVYBRIDGE(dev_priv));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_LPT;
@@ -240,9 +240,9 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
-			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
-				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
-				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
+			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE ||
+				   id == INTEL_PCH_P3X_DEVICE_ID_TYPE ||
+				   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE &&
 				    pch->subsystem_vendor ==
 					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
 				    pch->subsystem_device ==

commit aa0321300651df92dad7925a1da7fcaaf2f78c57
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jun 20 16:03:07 2017 +0300

    drm/i915: s/Couar/Cougar/
    
    Fix a typo in the PCH type debug message.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620130310.13245-3-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d35a114c46ed..7ef113d062f5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -132,7 +132,7 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
 	} else if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv)) {
 		ret = PCH_CPT;
-		DRM_DEBUG_KMS("Assuming CouarPoint PCH\n");
+		DRM_DEBUG_KMS("Assuming CougarPoint PCH\n");
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		ret = PCH_LPT;
 		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");

commit 702c8f8e5daba24777b29899fb9576fe64a924ea
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Tue Jun 20 10:57:48 2017 +0100

    drm/i915: Add engine reset count to error state
    
    Driver maintains count of how many times a given engine is reset, useful to
    capture this in error state also. It gives an idea of how engine is coping
    up with the workloads it is executing before this error state.
    
    A follow-up patch will provide this information in debugfs.
    
    v2: s/engine_reset/reset_engine/ (Chris)
        Define count as unsigned int (Tvrtko)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170615201828.23144-7-michel.thierry@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620095751.13127-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2ecac000e5da..d35a114c46ed 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1971,7 +1971,10 @@ int i915_reset_engine(struct intel_engine_cs *engine)
 	 * process to program RING_MODE, HWSP and re-enable submission.
 	 */
 	ret = engine->init_hw(engine);
+	if (ret)
+		goto out;
 
+	error->reset_engine_count[engine->id]++;
 out:
 	return ret;
 }

commit a1ef70e144534777965426393dcaa1721e908e83
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Tue Jun 20 10:57:47 2017 +0100

    drm/i915: Add support for per engine reset recovery
    
    This change implements support for per-engine reset as an initial, less
    intrusive hang recovery option to be attempted before falling back to the
    legacy full GPU reset recovery mode if necessary. This is only supported
    from Gen8 onwards.
    
    Hangchecker determines which engines are hung and invokes error handler to
    recover from it. Error handler schedules recovery for each of those engines
    that are hung. The recovery procedure is as follows,
     - identifies the request that caused the hang and it is dropped
     - force engine to idle: this is done by issuing a reset request
     - reset the engine
     - re-init the engine to resume submissions.
    
    If engine reset fails then we fall back to heavy weight full gpu reset
    which resets all engines and reinitiazes complete state of HW and SW.
    
    v2: Rebase.
    v3: s/*engine_reset*/*reset_engine*/; freeze engine and irqs before
    calling i915_gem_reset_engine (Chris).
    v4: Rebase, modify i915_gem_reset_prepare to use a ring mask and
    reuse the function for reset_engine.
    v5: intel_reset_engine_start/cancel instead of request/unrequest_reset.
    v6: Clean up reset_engine function to not require mutex, i.e. no need to call
    revoke/restore_fences and _retire_requests (Chris).
    v7: Remove leftovers from v5, i.e. no need to disable irq, hold
    forcewake or wakeup the handoff bit (Chris).
    v8: engine_retire_requests should be (and it was) static; explain that
    we have to re-init the engine after reset, which is why the init_hw call
    is needed; check reset-in-progress flag (Chris).
    v9: Rebase, include code to pass the active request to gem_reset_engine
    (as it is already done in full reset). Remove unnecessary
    intel_reset_engine_start/cancel, these are executed as part of the
    reset.
    v10: Rebase, use the right I915_RESET_ENGINE flag.
    v11: Fixup to call reset_finish_engine even on error.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Signed-off-by: Tomas Elf <tomas.elf@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170615201828.23144-6-michel.thierry@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620095751.13127-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e5b31e29382c..2ecac000e5da 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1923,11 +1923,57 @@ void i915_reset(struct drm_i915_private *dev_priv)
  *
  * Reset a specific GPU engine. Useful if a hang is detected.
  * Returns zero on successful reset or otherwise an error code.
+ *
+ * Procedure is:
+ *  - identifies the request that caused the hang and it is dropped
+ *  - reset engine (which will force the engine to idle)
+ *  - re-init/configure engine
  */
 int i915_reset_engine(struct intel_engine_cs *engine)
 {
-	/* FIXME: replace me with engine reset sequence */
-	return -ENODEV;
+	struct i915_gpu_error *error = &engine->i915->gpu_error;
+	struct drm_i915_gem_request *active_request;
+	int ret;
+
+	GEM_BUG_ON(!test_bit(I915_RESET_ENGINE + engine->id, &error->flags));
+
+	DRM_DEBUG_DRIVER("resetting %s\n", engine->name);
+
+	active_request = i915_gem_reset_prepare_engine(engine);
+	if (IS_ERR(active_request)) {
+		DRM_DEBUG_DRIVER("Previous reset failed, promote to full reset\n");
+		ret = PTR_ERR(active_request);
+		goto out;
+	}
+
+	/*
+	 * The request that caused the hang is stuck on elsp, we know the
+	 * active request and can drop it, adjust head to skip the offending
+	 * request to resume executing remaining requests in the queue.
+	 */
+	i915_gem_reset_engine(engine, active_request);
+
+	/* Finally, reset just this engine. */
+	ret = intel_gpu_reset(engine->i915, intel_engine_flag(engine));
+
+	i915_gem_reset_finish_engine(engine);
+
+	if (ret) {
+		/* If we fail here, we expect to fallback to a global reset */
+		DRM_DEBUG_DRIVER("Failed to reset %s, ret=%d\n",
+				 engine->name, ret);
+		goto out;
+	}
+
+	/*
+	 * The engine and its registers (and workarounds in case of render)
+	 * have been reset to their default values. Follow the init_ring
+	 * process to program RING_MODE, HWSP and re-enable submission.
+	 */
+	ret = engine->init_hw(engine);
+
+out:
+	return ret;
 }
 
 static int i915_pm_suspend(struct device *kdev)

commit 142bc7d99bcfd17a9bc66b46eb1b5d1b93364549
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Tue Jun 20 10:57:46 2017 +0100

    drm/i915: Modify error handler for per engine hang recovery
    
    This is a preparatory patch which modifies error handler to do per engine
    hang recovery. The actual patch which implements this sequence follows
    later in the series. The aim is to prepare existing recovery function to
    adapt to this new function where applicable (which fails at this point
    because core implementation is lacking) and continue recovery using legacy
    full gpu reset.
    
    A helper function is also added to query the availability of engine
    reset. A subsequent patch will add the capability to query which type
    of reset is present (engine -> full -> no-reset) via the get-param
    ioctl.
    
    It has been decided that the error events that are used to notify user of
    reset will only be sent in case if full chip reset. In case of just
    single (or multiple) engine resets, userspace won't be notified by these
    events.
    
    Note that this implementation of engine reset is for i915 directly
    submitting to the ELSP, where the driver manages the hang detection,
    recovery and resubmission. With GuC submission these tasks are shared
    between driver and firmware; i915 will still responsible for detecting a
    hang, and when it does it will have to request GuC to reset that Engine and
    remind the firmware about the outstanding submissions. This will be
    added in different patch.
    
    v2: rebase, advertise engine reset availability in platform definition,
    add note about GuC submission.
    v3: s/*engine_reset*/*reset_engine*/. (Chris)
    Handle reset as 2 level resets, by first going to engine only and fall
    backing to full/chip reset as needed, i.e. reset_engine will need the
    struct_mutex.
    v4: Pass the engine mask to i915_reset. (Chris)
    v5: Rebase, update selftests.
    v6: Rebase, prepare for mutex-less reset engine.
    v7: Pass reset_engine mask as a function parameter, and iterate over the
    engine mask for reset_engine. (Chris)
    v8: Use i915.reset >=2 in has_reset_engine; remove redundant reset
    logging; add a reset-engine-in-progress flag to prevent concurrent
    resets, and avoid dual purposing of reset-backoff. (Chris)
    v9: Support reset of different engines in parallel (Chris)
    v10: Handle reset-engine flag locking better (Chris)
    v11: Squash in reporting of per-engine-reset availability.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Signed-off-by: Ian Lister <ian.lister@intel.com>
    Signed-off-by: Tomas Elf <tomas.elf@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170615201828.23144-4-michel.thierry@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620095751.13127-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fe3d46ee4ddc..e5b31e29382c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -331,6 +331,8 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		break;
 	case I915_PARAM_HAS_GPU_RESET:
 		value = i915.enable_hangcheck && intel_has_gpu_reset(dev_priv);
+		if (value && intel_has_reset_engine(dev_priv))
+			value = 2;
 		break;
 	case I915_PARAM_HAS_RESOURCE_STREAMER:
 		value = HAS_RESOURCE_STREAMER(dev_priv);
@@ -1915,6 +1917,19 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	goto finish;
 }
 
+/**
+ * i915_reset_engine - reset GPU engine to recover from a hang
+ * @engine: engine to reset
+ *
+ * Reset a specific GPU engine. Useful if a hang is detected.
+ * Returns zero on successful reset or otherwise an error code.
+ */
+int i915_reset_engine(struct intel_engine_cs *engine)
+{
+	/* FIXME: replace me with engine reset sequence */
+	return -ENODEV;
+}
+
 static int i915_pm_suspend(struct device *kdev)
 {
 	struct pci_dev *pdev = to_pci_dev(kdev);

commit 5f09a9c8ab6b16eefbcf81635330d68481af1edc
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jun 20 12:05:46 2017 +0100

    drm/i915: Allow contexts to be unreferenced locklessly
    
    If we move the actual cleanup of the context to a worker, we can allow
    the final free to be called from any context and avoid undue latency in
    the caller.
    
    v2: Negotiate handling the delayed contexts free by flushing the
    workqueue before calling i915_gem_context_fini() and performing the final
    free of the kernel context directly
    v3: Flush deferred frees before new context allocations
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620110547.15947-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 36585b6e3718..fe3d46ee4ddc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -585,6 +585,8 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
+	flush_workqueue(dev_priv->wq);
+
 	mutex_lock(&dev_priv->drm.struct_mutex);
 	intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);

commit 829a0af29f70612f505302cc785a1ddd2bac148b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jun 20 12:05:45 2017 +0100

    drm/i915: Group all the global context information together
    
    Create a substruct to hold all the global context state under
    drm_i915_private.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620110547.15947-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ee2325b180e7..36585b6e3718 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -588,13 +588,13 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	mutex_lock(&dev_priv->drm.struct_mutex);
 	intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
-	i915_gem_context_fini(dev_priv);
+	i915_gem_contexts_fini(dev_priv);
 	i915_gem_cleanup_userptr(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
 	i915_gem_drain_freed_objects(dev_priv);
 
-	WARN_ON(!list_empty(&dev_priv->context_list));
+	WARN_ON(!list_empty(&dev_priv->contexts.list));
 }
 
 static int i915_load_modeset_init(struct drm_device *dev)
@@ -1425,9 +1425,10 @@ static void i915_driver_release(struct drm_device *dev)
 
 static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
 {
+	struct drm_i915_private *i915 = to_i915(dev);
 	int ret;
 
-	ret = i915_gem_open(dev, file);
+	ret = i915_gem_open(i915, file);
 	if (ret)
 		return ret;
 
@@ -1457,7 +1458,7 @@ static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 	struct drm_i915_file_private *file_priv = file->driver_priv;
 
 	mutex_lock(&dev->struct_mutex);
-	i915_gem_context_close(dev, file);
+	i915_gem_context_close(file);
 	i915_gem_release(dev, file);
 	mutex_unlock(&dev->struct_mutex);
 

commit 5c484cee7ef9c4fd29fa0ba09640d55960977145
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:39 2017 +0200

    drm: Remove drm_driver->set_busid hook
    
    The only special-case is pci devices, and we can easily handle this in
    the core. Do so and drop a pile of boilerplate from drivers.
    
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-5-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3036d4835b0f..6033355d9469 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2622,7 +2622,6 @@ static struct drm_driver driver = {
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
 	.postclose = i915_driver_postclose,
-	.set_busid = drm_pci_set_busid,
 
 	.gem_close_object = i915_gem_close_object,
 	.gem_free_object_unlocked = i915_gem_free_object,

commit 28e0f4eef6cb3413a8eb943cd9e366793bfa7e87
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri Jun 16 12:36:14 2017 -0700

    drm/i915: Store 9 bits of PCI Device ID for platforms with a LP PCH
    
    Although we use 9 bits of Device ID for identifying PCH, only 8 bits are
    stored in dev_priv->pch_id. This makes HAS_PCH_CNP_LP() and
    HAS_PCH_SPT_LP() incorrect. Fix this by storing all the 9 bits for the
    platforms with LP PCH.
    
    v2: Drop PCH_LPT_LP change (Imre)
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Fixes: commit ec7e0bb35f8d ("drm/i915/cnp: Add PCI ID for Cannonpoint LP PCH")
    Reported-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1497641774-29104-1-git-send-email-dhinakaran.pandiyan@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3c2af70034cf..ee2325b180e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -176,24 +176,26 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			unsigned short id_ext = pch->device &
 				INTEL_PCH_DEVICE_ID_MASK_EXT;
 
-			dev_priv->pch_id = id;
-
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_IBX;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
 				WARN_ON(!IS_GEN5(dev_priv));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev_priv) ||
 					IS_IVYBRIDGE(dev_priv)));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev_priv) ||
 					IS_IVYBRIDGE(dev_priv)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev_priv) &&
@@ -201,6 +203,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				WARN_ON(IS_HSW_ULT(dev_priv) ||
 					IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev_priv) &&
@@ -208,26 +211,31 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				WARN_ON(!IS_HSW_ULT(dev_priv) &&
 					!IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id_ext == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id_ext;
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
 					!IS_COFFEELAKE(dev_priv));
 			} else if (id_ext == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_id = id_ext;
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
 				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
@@ -239,6 +247,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
 				    pch->subsystem_device ==
 					    PCI_SUBDEVICE_ID_QEMU)) {
+				dev_priv->pch_id = id;
 				dev_priv->pch_type =
 					intel_virt_detect_pch(dev_priv);
 			} else

commit 1a71cf2fa646799d4397a49b223549d8617fece0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 16 15:05:23 2017 +0100

    drm/i915: Allow execbuffer to use the first object as the batch
    
    Currently, the last object in the execlist is the always the batch.
    However, when building the batch buffer we often know the batch object
    first and if we can use the first slot in the execlist we can emit
    relocation instructions relative to it immediately and avoid a separate
    pass to adjust the relocations to point to the last execlist slot.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e33a2ed9244c..3c2af70034cf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -367,6 +367,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_ASYNC:
 	case I915_PARAM_HAS_EXEC_FENCE:
 	case I915_PARAM_HAS_EXEC_CAPTURE:
+	case I915_PARAM_HAS_EXEC_BATCH_FIRST:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from

commit 8a2421bd0d9abb3a599969d88e1910a2a101eccc
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 16 15:05:22 2017 +0100

    drm/i915: Wait upon userptr get-user-pages within execbuffer
    
    This simply hides the EAGAIN caused by userptr when userspace causes
    resource contention. However, it is quite beneficial with highly
    contended userptr users as we avoid repeating the setup costs and
    kernel-user context switches.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a534412a5551..e33a2ed9244c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -579,6 +579,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_context_fini(dev_priv);
+	i915_gem_cleanup_userptr(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
 	i915_gem_drain_freed_objects(dev_priv);

commit f532023381df49ac00cb2d1e70df607cf534720d
Author: Robert Bragg <robert@sixbynine.org>
Date:   Tue Jun 13 12:23:00 2017 +0100

    drm/i915: expose _SUBSLICE_MASK GETPARM
    
    Assuming a uniform mask across all slices, this enables userspace to
    determine the specific sub slices can be enabled. This information is
    required, for example, to be able to analyse some OA counter reports
    where the counter configuration depends on the HW sub slice
    configuration.
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d503612a7fc1..a534412a5551 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -379,6 +379,11 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		if (!value)
 			return -ENODEV;
 		break;
+	case I915_PARAM_SUBSLICE_MASK:
+		value = INTEL_INFO(dev_priv)->sseu.subslice_mask;
+		if (!value)
+			return -ENODEV;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit 7fed555c02f754af44f8963890b5ef8e30e97391
Author: Robert Bragg <robert@sixbynine.org>
Date:   Tue Jun 13 12:22:59 2017 +0100

    drm/i915: expose _SLICE_MASK GETPARM
    
    Enables userspace to determine the maximum number of slices that can
    be enabled on the device and also know what specific slices can be
    enabled. This information is required, for example, to be able to
    analyse some OA counter reports where the counter configuration
    depends on the HW slice configuration.
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1f802de7b94b..d503612a7fc1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -374,6 +374,11 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		 */
 		value = 1;
 		break;
+	case I915_PARAM_SLICE_MASK:
+		value = INTEL_INFO(dev_priv)->sseu.slice_mask;
+		if (!value)
+			return -ENODEV;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit 809378196bb449fe30d0ca15a990965fc553f9f5
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Thu Jun 8 08:49:59 2017 -0700

    drm/i915/cfl: Coffee Lake uses CNP PCH.
    
    So let's force it on the virtual detection.
    
    Also it is still the only silicon for now on this PCH,
    so WARN otherwise.
    
    v2: Rebased on top of Cannonlake and added the missed
        debug message as pointed by DK.
    
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1496937000-8450-2-git-send-email-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7a925c51477f..1f802de7b94b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -139,8 +139,9 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 	} else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
 		ret = PCH_SPT;
 		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
-	} else if (IS_CANNONLAKE(dev_priv)) {
+	} else if (IS_COFFEELAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
 		ret = PCH_CNP;
+		DRM_DEBUG_KMS("Assuming CannonPoint PCH\n");
 	}
 
 	return ret;
@@ -224,11 +225,13 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
-				WARN_ON(!IS_CANNONLAKE(dev_priv));
+				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
+					!IS_COFFEELAKE(dev_priv));
 			} else if (id_ext == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
-				WARN_ON(!IS_CANNONLAKE(dev_priv));
+				WARN_ON(!IS_CANNONLAKE(dev_priv) &&
+					!IS_COFFEELAKE(dev_priv));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit acf1dba661e908e923320b4226bad4d8fc23c6f5
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Jun 6 13:30:31 2017 -0700

    drm/i915/cnl: Cannonlake uses CNP PCH.
    
    Avoid warning when CNP is detected with CNL.
    
    Also let's force it on the virtual detection.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1496781040-20888-2-git-send-email-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6ca99dea7cf0..7a925c51477f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -139,6 +139,8 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 	} else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
 		ret = PCH_SPT;
 		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
+	} else if (IS_CANNONLAKE(dev_priv)) {
+		ret = PCH_CNP;
 	}
 
 	return ret;
@@ -222,9 +224,11 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
+				WARN_ON(!IS_CANNONLAKE(dev_priv));
 			} else if (id_ext == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
+				WARN_ON(!IS_CANNONLAKE(dev_priv));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit 4ba459a224fd8e85b241d15481d63aaa3b306d4e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jun 1 21:30:43 2017 +0300

    drm/i915: Remove dead code from runtime resume handler
    
    Remove the SNB PCH refclock init call from the runtime resume handler.
    I don't think it was actually needed even when we had SNB runtime PM,
    and if definitely isn't needed ever since SNB runtime PM was nuked in
    commit d4c5636e7447 ("drm/i915: Remove runtime PM for SNB").
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170601183043.28543-1-ville.syrjala@linux.intel.com
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 90b646c51759..6ca99dea7cf0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2470,9 +2470,6 @@ static int intel_runtime_resume(struct device *kdev)
 
 	intel_guc_resume(dev_priv);
 
-	if (IS_GEN6(dev_priv))
-		intel_init_pch_refclk(dev_priv);
-
 	if (IS_GEN9_LP(dev_priv)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);

commit ec7e0bb35f8d339b51b440b5fc525618784f11f4
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri Jun 2 13:06:40 2017 -0700

    drm/i915/cnp: Add PCI ID for Cannonpoint LP PCH
    
    The first two bytes of PCI ID for CNP_LP PCH are the same as that of
    SPT_LP. We should really be looking at the first 9 bits instead of the
    first 8 to identify platforms, although this seems to have not caused any
    problems on earlier platforms. Introduce a 9 bit extended mask for SPT and
    CNP while not touching the code for any of the other platforms.
    
    v2: (Rodrigo) Make platform agnostic and fix commit message.
    
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1496434004-29812-2-git-send-email-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9e4c13ed795d..90b646c51759 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -170,6 +170,9 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
 		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
 			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+			unsigned short id_ext = pch->device &
+				INTEL_PCH_DEVICE_ID_MASK_EXT;
+
 			dev_priv->pch_id = id;
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
@@ -206,7 +209,7 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
-			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
+			} else if (id_ext == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
@@ -219,6 +222,9 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CNP;
 				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
+			} else if (id_ext == INTEL_PCH_CNP_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_CNP;
+				DRM_DEBUG_KMS("Found CannonPoint LP PCH\n");
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit 7b22b8c402c8ee26dd4dc1474887a2a91961e766
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Jun 2 13:06:39 2017 -0700

    drm/i915/cnp: Introduce Cannonpoint PCH.
    
    Most of south engine display that is in PCH is still the
    same as SPT and KBP, except for this key differences:
    
    - Backlight: Backlight programming changed in CNP PCH.
    - Panel Power: Sligh programming changed in CNP PCH.
    - GMBUS and GPIO: The pin mapping has changed in CNP PCH.
    
    All of these changes follow more the BXT style.
    
    v2: Update definition to use dev_priv isntead of dev (Tvrtko).
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1496434004-29812-1-git-send-email-rodrigo.vivi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2fdfaf135ea9..9e4c13ed795d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -216,6 +216,9 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev_priv) &&
 					!IS_KABYLAKE(dev_priv));
+			} else if (id == INTEL_PCH_CNP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_CNP;
+				DRM_DEBUG_KMS("Found CannonPoint PCH\n");
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit adfdf85d795f4d4f487b61ee0b169d64c6e19081
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v4.10.x: 4d071c3 - PCI/PM: Add needs_resume flag
    Cc: <stable@vger.kernel.org> # v4.10.x
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3536f1a7f5da..2fdfaf135ea9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1242,6 +1242,15 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto out_fini;
 
 	pci_set_drvdata(pdev, &dev_priv->drm);
+	/*
+	 * Disable the system suspend direct complete optimization, which can
+	 * leave the device suspended skipping the driver's suspend handlers
+	 * if the device was already runtime suspended. This is needed due to
+	 * the difference in our runtime and system suspend sequence and
+	 * becaue the HDA driver may require us to enable the audio power
+	 * domain during system suspend.
+	 */
+	pdev->dev_flags |= PCI_DEV_FLAGS_NEEDS_RESUME;
 
 	ret = i915_driver_init_early(dev_priv, ent);
 	if (ret < 0)

commit 67b7f33eeeaa6368289c6d25b283432e02dcc1c1
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Sat May 27 17:44:17 2017 +0800

    drm/i915/gvt: Add gvt options sanitize function
    
    The intel_gvt_sanitize_options will sanitize the GVT related
    options before doing initialize the GVT.
    
    Suggested-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7b8c72776f46..3536f1a7f5da 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -997,6 +997,8 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n", yesno(i915.semaphores));
 
 	intel_uc_sanitize_options(dev_priv);
+
+	intel_gvt_sanitize_options(dev_priv);
 }
 
 /**

commit 6bdba81979b2c3c8fed0be62ca31c32c3129d85f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 17 15:15:57 2017 +0200

    Revert "drm/i915: Restore lost "Initialized i915" welcome message"
    
    This reverts commit bc5ca47c0af4f949ba889e666b7da65569e36093.
    
    Gabriel put this back into generic code with
    
    commit 75f6dfe3e652e1adef8cc1b073c89f3e22103a8f
    Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Date:   Wed Dec 28 12:32:11 2016 -0200
    
        drm: Deduplicate driver initialization message
    
    but somehow he missed Chris' patch to add the message meanwhile.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101025
    Fixes: 75f6dfe3e652 ("drm: Deduplicate driver initialization message")
    Cc: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: <stable@vger.kernel.org> # v4.11+
    Reviewed-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170517131557.7836-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 452c26505018..7b8c72776f46 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1277,10 +1277,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	dev_priv->ipc_enabled = false;
 
-	/* Everything is in place, we can now relax! */
-	DRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",
-		 driver.name, driver.major, driver.minor, driver.patchlevel,
-		 driver.date, pci_name(pdev), dev_priv->drm.primary->index);
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
 		DRM_INFO("DRM_I915_DEBUG enabled\n");
 	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))

commit cefcff8f93c3306bfd331a2eaa363263196fdf73
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Apr 28 10:58:39 2017 +0300

    drm/i915: Do not leak dev_priv->l3_parity.remap_info[]
    
    Add intel_irq_fini() for placing the deinitialization code,
    starting with freeing dev_priv->l3_parity.remap_info[].
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493366319-18515-1-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2d3c426465d3..452c26505018 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -852,7 +852,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_audio_hooks(dev_priv);
 	ret = i915_gem_load_init(dev_priv);
 	if (ret < 0)
-		goto err_workqueues;
+		goto err_irq;
 
 	intel_display_crc_init(dev_priv);
 
@@ -864,7 +864,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	return 0;
 
-err_workqueues:
+err_irq:
+	intel_irq_fini(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 err_engines:
 	i915_engines_cleanup(dev_priv);
@@ -879,6 +880,7 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
 	i915_perf_fini(dev_priv);
 	i915_gem_load_cleanup(dev_priv);
+	intel_irq_fini(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 	i915_engines_cleanup(dev_priv);
 }

commit 73ba2d5c2bd4ecfec8fe37f20e962889b8a4c972
Merge: 53cecf1b0e30 88326ef05b26
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Apr 29 05:50:27 2017 +1000

    Merge tag 'drm-intel-next-fixes-2017-04-27' of git://anongit.freedesktop.org/git/drm-intel into drm-next
    
    drm/i915 and gvt fixes for drm-next/v4.12
    
    * tag 'drm-intel-next-fixes-2017-04-27' of git://anongit.freedesktop.org/git/drm-intel:
      drm/i915: Confirm the request is still active before adding it to the await
      drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
      drm/i915/selftests: Allocate inode/file dynamically
      drm/i915: Fix system hang with EI UP masked on Haswell
      drm/i915: checking for NULL instead of IS_ERR() in mock selftests
      drm/i915: Perform link quality check unconditionally during long pulse
      drm/i915: Fix use after free in lpe_audio_platdev_destroy()
      drm/i915: Use the right mapping_gfp_mask for final shmem allocation
      drm/i915: Make legacy cursor updates more unsynced
      drm/i915: Apply a cond_resched() to the saturated signaler
      drm/i915: Park the signaler before sleeping
      drm/i915/gvt: fix a bounds check in ring_id_to_context_switch_event()
      drm/i915/gvt: Fix PTE write flush for taking runtime pm properly
      drm/i915/gvt: remove some debug messages in scheduler timer handler
      drm/i915/gvt: add mmio init for virtual display
      drm/i915/gvt: use directly assignment for structure copying
      drm/i915/gvt: remove redundant ring id check which cause significant CPU misprediction
      drm/i915/gvt: remove redundant platform check for mocs load/restore
      drm/i915/gvt: Align render mmio list to cacheline
      drm/i915/gvt: cleanup some too chatty scheduler message

commit 63ffbcdadcf2b5dde2cd6db6715fc94e77cd43b6
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Apr 28 10:53:36 2017 +0300

    drm/i915: Sanitize engine context sizes
    
    Pre-calculate engine context size based on engine class and device
    generation and store it in the engine instance.
    
    v2:
    - Squash and get rid of hw_context_size (Chris)
    
    v3:
    - Move after MMIO init for probing on Gen7 and 8 (Chris)
    - Retained rounding (Tvrtko)
    v4:
    - Rebase for deferred legacy context allocation
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: intel-gvt-dev@lists.freedesktop.org
    Acked-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c7d68e789642..2d3c426465d3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -835,10 +835,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_uc_init_early(dev_priv);
 	i915_memcpy_init_early(dev_priv);
 
-	ret = intel_engines_init_early(dev_priv);
-	if (ret)
-		return ret;
-
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
 		goto err_engines;
@@ -948,14 +944,21 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 
 	ret = i915_mmio_setup(dev_priv);
 	if (ret < 0)
-		goto put_bridge;
+		goto err_bridge;
 
 	intel_uncore_init(dev_priv);
+
+	ret = intel_engines_init_mmio(dev_priv);
+	if (ret)
+		goto err_uncore;
+
 	i915_gem_init_mmio(dev_priv);
 
 	return 0;
 
-put_bridge:
+err_uncore:
+	intel_uncore_fini(dev_priv);
+err_bridge:
 	pci_dev_put(dev_priv->bridge_dev);
 
 	return ret;

commit 96dabe99cae8a1b5fc645f213eeac928541d3899
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 21 14:58:15 2017 +0100

    drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
    
    The busy-spin, as the first stage of intel_wait_for_register(), is
    currently under suspicion for causing:
    
    [   62.034926] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [   62.034928] Modules linked in: i2c_dev i915 intel_gtt drm_kms_helper prime_numbers
    [   62.034932] CPU: 1 PID: 183 Comm: kworker/1:2 Not tainted 4.11.0-rc7+ #471
    [   62.034933] Hardware name:                  /        , BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [   62.034934] Workqueue: pm pm_runtime_work
    [   62.034936] task: ffff880275a04ec0 task.stack: ffffc900002d8000
    [   62.034936] RIP: 0010:__intel_wait_for_register_fw+0x77/0x1a0 [i915]
    [   62.034937] RSP: 0018:ffffc900002dbc38 EFLAGS: 00000082
    [   62.034939] RAX: ffffc90003530094 RBX: 0000000000130094 RCX: 0000000000000001
    [   62.034940] RDX: 00000000000000a1 RSI: ffff88027fd15e58 RDI: 0000000000000000
    [   62.034941] RBP: ffffc900002dbc78 R08: 0000000000000002 R09: 0000000000000000
    [   62.034942] R10: ffffc900002dbc18 R11: ffff880276429dd0 R12: ffff8802707c0000
    [   62.034943] R13: 00000000000000a0 R14: 0000000000000000 R15: 00000000fffefc10
    [   62.034945] FS:  0000000000000000(0000) GS:ffff88027fd00000(0000) knlGS:0000000000000000
    [   62.034945] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   62.034947] CR2: 00007ffd3cd98ff8 CR3: 0000000274c19000 CR4: 00000000001006e0
    [   62.034947] Call Trace:
    [   62.034948]  intel_wait_for_register+0x77/0x140 [i915]
    [   62.034949]  vlv_suspend_complete+0x23/0x5b0 [i915]
    [   62.034950]  intel_runtime_suspend+0x16c/0x2a0 [i915]
    [   62.034950]  pci_pm_runtime_suspend+0x50/0x180
    [   62.034951]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034952]  __rpm_callback+0xc5/0x210
    [   62.034953]  rpm_callback+0x1f/0x80
    [   62.034953]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034954]  rpm_suspend+0x118/0x580
    [   62.034955]  pm_runtime_work+0x64/0x90
    [   62.034956]  process_one_work+0x1bb/0x3e0
    [   62.034956]  worker_thread+0x46/0x4f0
    [   62.034957]  ? __schedule+0x18b/0x610
    [   62.034958]  kthread+0xff/0x140
    [   62.034958]  ? process_one_work+0x3e0/0x3e0
    [   62.034959]  ? kthread_create_on_node+
    
    and related hard lockups in CI for byt and bsw.
    
    Note this effectively reverts commits 41ce405e6894 and b27366958869
    ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    
    v2: Convert bool allow into a u32 mask for clarity and repeat the
    comment on vlv rc6 timing to justify the 3ms timeout used for the wait (Ville)
    
    Fixes: 41ce405e6894 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Fixes: b27366958869 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100718
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170421135815.11897-1-chris@chris-wilson.co.uk
    Tested-by: Tomi Sarvela <tomi.p.sarvela@intel.com>
    (cherry picked from commit 3dd14c04d77d7d702de5aa7157df4cc9417329f3)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c616b4e755bc..1aa26d5f1779 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2177,6 +2177,20 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
 }
 
+static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
+				  u32 mask, u32 val)
+{
+	/* The HW does not like us polling for PW_STATUS frequently, so
+	 * use the sleeping loop rather than risk the busy spin within
+	 * intel_wait_for_register().
+	 *
+	 * Transitioning between RC6 states should be at most 2ms (see
+	 * valleyview_enable_rps) so use a 3ms timeout.
+	 */
+	return wait_for((I915_READ_NOTRACE(VLV_GTLC_PW_STATUS) & mask) == val,
+			3);
+}
+
 int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 {
 	u32 val;
@@ -2205,8 +2219,9 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 
 static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 {
+	u32 mask;
 	u32 val;
-	int err = 0;
+	int err;
 
 	val = I915_READ(VLV_GTLC_WAKE_CTRL);
 	val &= ~VLV_GTLC_ALLOWWAKEREQ;
@@ -2215,45 +2230,32 @@ static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
 	POSTING_READ(VLV_GTLC_WAKE_CTRL);
 
-	err = intel_wait_for_register(dev_priv,
-				      VLV_GTLC_PW_STATUS,
-				      VLV_GTLC_ALLOWWAKEACK,
-				      allow,
-				      1);
+	mask = VLV_GTLC_ALLOWWAKEACK;
+	val = allow ? mask : 0;
+
+	err = vlv_wait_for_pw_status(dev_priv, mask, val);
 	if (err)
 		DRM_ERROR("timeout disabling GT waking\n");
 
 	return err;
 }
 
-static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
-				 bool wait_for_on)
+static void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
+				  bool wait_for_on)
 {
 	u32 mask;
 	u32 val;
-	int err;
 
 	mask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;
 	val = wait_for_on ? mask : 0;
-	if ((I915_READ(VLV_GTLC_PW_STATUS) & mask) == val)
-		return 0;
-
-	DRM_DEBUG_KMS("waiting for GT wells to go %s (%08x)\n",
-		      onoff(wait_for_on),
-		      I915_READ(VLV_GTLC_PW_STATUS));
 
 	/*
 	 * RC6 transitioning can be delayed up to 2 msec (see
 	 * valleyview_enable_rps), use 3 msec for safety.
 	 */
-	err = intel_wait_for_register(dev_priv,
-				      VLV_GTLC_PW_STATUS, mask, val,
-				      3);
-	if (err)
+	if (vlv_wait_for_pw_status(dev_priv, mask, val))
 		DRM_ERROR("timeout waiting for GT wells to go %s\n",
 			  onoff(wait_for_on));
-
-	return err;
 }
 
 static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
@@ -2274,7 +2276,7 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	 * Bspec defines the following GT well on flags as debug only, so
 	 * don't treat them as hard failures.
 	 */
-	(void)vlv_wait_for_gt_wells(dev_priv, false);
+	vlv_wait_for_gt_wells(dev_priv, false);
 
 	mask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;
 	WARN_ON((I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);

commit 3dd14c04d77d7d702de5aa7157df4cc9417329f3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 21 14:58:15 2017 +0100

    drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
    
    The busy-spin, as the first stage of intel_wait_for_register(), is
    currently under suspicion for causing:
    
    [   62.034926] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [   62.034928] Modules linked in: i2c_dev i915 intel_gtt drm_kms_helper prime_numbers
    [   62.034932] CPU: 1 PID: 183 Comm: kworker/1:2 Not tainted 4.11.0-rc7+ #471
    [   62.034933] Hardware name:                  /        , BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [   62.034934] Workqueue: pm pm_runtime_work
    [   62.034936] task: ffff880275a04ec0 task.stack: ffffc900002d8000
    [   62.034936] RIP: 0010:__intel_wait_for_register_fw+0x77/0x1a0 [i915]
    [   62.034937] RSP: 0018:ffffc900002dbc38 EFLAGS: 00000082
    [   62.034939] RAX: ffffc90003530094 RBX: 0000000000130094 RCX: 0000000000000001
    [   62.034940] RDX: 00000000000000a1 RSI: ffff88027fd15e58 RDI: 0000000000000000
    [   62.034941] RBP: ffffc900002dbc78 R08: 0000000000000002 R09: 0000000000000000
    [   62.034942] R10: ffffc900002dbc18 R11: ffff880276429dd0 R12: ffff8802707c0000
    [   62.034943] R13: 00000000000000a0 R14: 0000000000000000 R15: 00000000fffefc10
    [   62.034945] FS:  0000000000000000(0000) GS:ffff88027fd00000(0000) knlGS:0000000000000000
    [   62.034945] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   62.034947] CR2: 00007ffd3cd98ff8 CR3: 0000000274c19000 CR4: 00000000001006e0
    [   62.034947] Call Trace:
    [   62.034948]  intel_wait_for_register+0x77/0x140 [i915]
    [   62.034949]  vlv_suspend_complete+0x23/0x5b0 [i915]
    [   62.034950]  intel_runtime_suspend+0x16c/0x2a0 [i915]
    [   62.034950]  pci_pm_runtime_suspend+0x50/0x180
    [   62.034951]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034952]  __rpm_callback+0xc5/0x210
    [   62.034953]  rpm_callback+0x1f/0x80
    [   62.034953]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034954]  rpm_suspend+0x118/0x580
    [   62.034955]  pm_runtime_work+0x64/0x90
    [   62.034956]  process_one_work+0x1bb/0x3e0
    [   62.034956]  worker_thread+0x46/0x4f0
    [   62.034957]  ? __schedule+0x18b/0x610
    [   62.034958]  kthread+0xff/0x140
    [   62.034958]  ? process_one_work+0x3e0/0x3e0
    [   62.034959]  ? kthread_create_on_node+
    
    and related hard lockups in CI for byt and bsw.
    
    Note this effectively reverts commits 41ce405e6894 and b27366958869
    ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    
    v2: Convert bool allow into a u32 mask for clarity and repeat the
    comment on vlv rc6 timing to justify the 3ms timeout used for the wait (Ville)
    
    Fixes: 41ce405e6894 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Fixes: b27366958869 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100718
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170421135815.11897-1-chris@chris-wilson.co.uk
    Tested-by: Tomi Sarvela <tomi.p.sarvela@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cc7393e65e99..c7d68e789642 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2175,6 +2175,20 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
 }
 
+static int vlv_wait_for_pw_status(struct drm_i915_private *dev_priv,
+				  u32 mask, u32 val)
+{
+	/* The HW does not like us polling for PW_STATUS frequently, so
+	 * use the sleeping loop rather than risk the busy spin within
+	 * intel_wait_for_register().
+	 *
+	 * Transitioning between RC6 states should be at most 2ms (see
+	 * valleyview_enable_rps) so use a 3ms timeout.
+	 */
+	return wait_for((I915_READ_NOTRACE(VLV_GTLC_PW_STATUS) & mask) == val,
+			3);
+}
+
 int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 {
 	u32 val;
@@ -2203,8 +2217,9 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 
 static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 {
+	u32 mask;
 	u32 val;
-	int err = 0;
+	int err;
 
 	val = I915_READ(VLV_GTLC_WAKE_CTRL);
 	val &= ~VLV_GTLC_ALLOWWAKEREQ;
@@ -2213,45 +2228,32 @@ static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
 	POSTING_READ(VLV_GTLC_WAKE_CTRL);
 
-	err = intel_wait_for_register(dev_priv,
-				      VLV_GTLC_PW_STATUS,
-				      VLV_GTLC_ALLOWWAKEACK,
-				      allow,
-				      1);
+	mask = VLV_GTLC_ALLOWWAKEACK;
+	val = allow ? mask : 0;
+
+	err = vlv_wait_for_pw_status(dev_priv, mask, val);
 	if (err)
 		DRM_ERROR("timeout disabling GT waking\n");
 
 	return err;
 }
 
-static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
-				 bool wait_for_on)
+static void vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
+				  bool wait_for_on)
 {
 	u32 mask;
 	u32 val;
-	int err;
 
 	mask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;
 	val = wait_for_on ? mask : 0;
-	if ((I915_READ(VLV_GTLC_PW_STATUS) & mask) == val)
-		return 0;
-
-	DRM_DEBUG_KMS("waiting for GT wells to go %s (%08x)\n",
-		      onoff(wait_for_on),
-		      I915_READ(VLV_GTLC_PW_STATUS));
 
 	/*
 	 * RC6 transitioning can be delayed up to 2 msec (see
 	 * valleyview_enable_rps), use 3 msec for safety.
 	 */
-	err = intel_wait_for_register(dev_priv,
-				      VLV_GTLC_PW_STATUS, mask, val,
-				      3);
-	if (err)
+	if (vlv_wait_for_pw_status(dev_priv, mask, val))
 		DRM_ERROR("timeout waiting for GT wells to go %s\n",
 			  onoff(wait_for_on));
-
-	return err;
 }
 
 static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
@@ -2272,7 +2274,7 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	 * Bspec defines the following GT well on flags as debug only, so
 	 * don't treat them as hard failures.
 	 */
-	(void)vlv_wait_for_gt_wells(dev_priv, false);
+	vlv_wait_for_gt_wells(dev_priv, false);
 
 	mask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;
 	WARN_ON((I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);

commit 856ee92e8602bd86d34388ac08381c5cb3918756
Merge: a6a5c983b35e 4f7d029b9bf0
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 19 11:07:14 2017 +1000

    Merge tag 'v4.11-rc7' into drm-next
    
    Backmerge Linux 4.11-rc7 from Linus tree, to fix some
    conflicts that were causing problems with the rerere cache
    in drm-tip.

commit b0fd47adc6233e4c198a97e1ddb05accd31eeacb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Apr 15 10:39:02 2017 +0100

    drm/i915: Copy user requested buffers into the error state
    
    Introduce a new execobject.flag (EXEC_OBJECT_CAPTURE) that userspace may
    use to indicate that it wants the contents of this buffer preserved in
    the error state (/sys/class/drm/cardN/error) following a GPU hang
    involving this batch.
    
    Use this at your discretion, the contents of the error state. although
    compressed, are allocated with GFP_ATOMIC (i.e. limited) and kept for all
    eternity (until the error state is destroyed).
    
    Based on an earlier patch by Ben Widawsky <ben@bwidawsk.net>
    Testcase: igt/gem_exec_capture
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ben Widawsky <ben@bwidawsk.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170415093902.22581-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bd85e3826b72..cc7393e65e99 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -350,6 +350,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_SOFTPIN:
 	case I915_PARAM_HAS_EXEC_ASYNC:
 	case I915_PARAM_HAS_EXEC_FENCE:
+	case I915_PARAM_HAS_EXEC_CAPTURE:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from

commit ebf3f19abbfd041a0e79a523e4dd1f6f6797b783
Merge: a8e9a419c337 d455937ed1cf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 12 10:07:43 2017 +0200

    Merge airlied/drm-next into drm-intel-next-queued
    
    Maarten needs both the new connector->atomic_check hook and the
    connection_mutex locking changes in the probe helpers to be able to
    start merging the connector property conversion to atomic.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 63987bfebd8869e00b34e2bdd12e59d71909bec0
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Wed Apr 5 15:51:50 2017 +0530

    drm/i915: Suspend GuC prior to GPU Reset during GEM suspend
    
    i915 is currently doing a full GPU reset at the end of
    i915_gem_suspend() followed by GuC suspend in i915_drm_suspend(). This
    GPU reset clobbers the GuC, causing the suspend request to then fail,
    leaving the GuC in an undefined state. We need to tell the GuC to
    suspend before we do the direct intel_gpu_reset().
    
    v2: Commit message update. (Chris, Daniele)
    
    Fixes: 1c777c5d1dcd ("drm/i915/hsw: Fix GPU hang during resume from S3-devices state")
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1491387710-20553-1-git-send-email-sagar.a.kamble@intel.com
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit fd08923384385400101c71ac0d21d37d6b23b00d)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1c75402a59c1..5c089b3c2a7e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1434,8 +1434,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 		goto out;
 	}
 
-	intel_guc_suspend(dev_priv);
-
 	intel_display_suspend(dev);
 
 	intel_dp_mst_suspend(dev);

commit 2b2fc72aa51ba20f047d4825f8ea3e0d9306d8fb
Merge: cdf5316bdb7a ba515d3407dc
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 11 07:28:01 2017 +1000

    Merge tag 'drm-intel-testing-2017-04-03' of git://anongit.freedesktop.org/git/drm-intel into drm-next
    
    Last 4.12 feature pile:
    
    GVT updates:
    - Add mdev attribute group for per-vgpu info
    - Time slice based vGPU scheduling QoS support (Gao Ping)
    - Initial KBL support for E3 server (Han Xu)
    - other misc.
    
    i915:
    - lots and lots of small fixes and improvements all over
    - refactor fw_domain code (Chris Wilson)
    - improve guc code (Oscar Mateo)
    - refactor cursor/sprite code, precompute more for less overhead in
      the critical path (Ville)
    - refactor guc/huc fw loading code a bit (Michal Wajdeczko)
    
    * tag 'drm-intel-testing-2017-04-03' of git://anongit.freedesktop.org/git/drm-intel: (121 commits)
      drm/i915: Update DRIVER_DATE to 20170403
      drm/i915: Clear gt.active_requests before checking idle status
      drm/i915/uc: Drop use of MISSING_CASE on trivial enums
      drm/i915: make a few DDI functions static
      drm/i915: Combine reset_all_global_seqno() loops into one
      drm/i915: Remove redudant wait for each engine to idle from seqno wrap
      drm/i915: Wait for all engines to be idle as part of i915_gem_wait_for_idle()
      drm/i915: Move retire-requests into i915_gem_wait_for_idle()
      drm/i915/uc: Move fw path check to fetch_uc_fw()
      drm/i915/huc: Remove unused intel_huc_fini()
      drm/i915/uc: Add intel_uc_fw_fini()
      drm/i915/uc: Add intel_uc_fw_type_repr()
      drm/i915/uc: Move intel_uc_fw_status_repr() to intel_uc.h
      drivers: gpu: drm: i915L intel_lpe_audio: Fix kerneldoc comments
      drm/i915: Suppress busy status for engines if wedged
      drm/i915: Do request retirement before marking engines as wedged
      drm/i915: Drop verbose and archaic "ring" from our internal engine names
      drm/i915: Use a dummy timeline name for a signaled fence
      drm/i915: Ironlake do_idle_maps w/a may be called w/o struct_mutex
      drm/i915/guc: Take enable_guc_loading check out of GEM core code
      ...

commit fd08923384385400101c71ac0d21d37d6b23b00d
Author: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Date:   Wed Apr 5 15:51:50 2017 +0530

    drm/i915: Suspend GuC prior to GPU Reset during GEM suspend
    
    i915 is currently doing a full GPU reset at the end of
    i915_gem_suspend() followed by GuC suspend in i915_drm_suspend(). This
    GPU reset clobbers the GuC, causing the suspend request to then fail,
    leaving the GuC in an undefined state. We need to tell the GuC to
    suspend before we do the direct intel_gpu_reset().
    
    v2: Commit message update. (Chris, Daniele)
    
    Fixes: 1c777c5d1dcd ("drm/i915/hsw: Fix GPU hang during resume from S3-devices state")
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1491387710-20553-1-git-send-email-sagar.a.kamble@intel.com
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0595600fb775..94c61aa975d8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1486,8 +1486,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 		goto out;
 	}
 
-	intel_guc_suspend(dev_priv);
-
 	intel_display_suspend(dev);
 
 	intel_dp_mst_suspend(dev);

commit ff4c3b76eefe3c9c52326250c6701149d0985fb6
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Mar 3 17:19:28 2017 +0200

    drm/i915: Enable atomic on VLV/CHV
    
    VLV/CHV watermarks are now able to handle the radiation, so
    mark these platforms as ready for atomic.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Suggested-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170303151928.23053-5-ville.syrjala@linux.intel.com
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0b3811673199..0595600fb775 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1213,9 +1213,8 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct drm_i915_private *dev_priv;
 	int ret;
 
-	/* Enable nuclear pageflip on ILK+, except vlv/chv */
-	if (!i915.nuclear_pageflip &&
-	    (match_info->gen < 5 || match_info->has_gmch_display))
+	/* Enable nuclear pageflip on ILK+ */
+	if (!i915.nuclear_pageflip && match_info->gen < 5)
 		driver.driver_features &= ~DRIVER_ATOMIC;
 
 	ret = -ENOMEM;

commit b8991403ea0f3e5b59e08e37a7ac0af8ef4264e3
Author: Oscar Mateo <oscar.mateo@intel.com>
Date:   Tue Mar 28 09:53:47 2017 -0700

    drm/i915/guc: Take enable_guc_loading check out of GEM core code
    
    The should happen as soon as possible, but always within the logic that
    depends on it (and not interrupting the top-level driver control flow).
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Oscar Mateo <oscar.mateo@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1490720027-23234-1-git-send-email-oscar.mateo@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6d9944a00b7d..0b3811673199 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -549,8 +549,7 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
 	mutex_lock(&dev_priv->drm.struct_mutex);
-	if (i915.enable_guc_loading)
-		intel_uc_fini_hw(dev_priv);
+	intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_context_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);

commit 18dddadc78c91a91b546acc48506c24f5f840c4f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 21 17:41:49 2017 +0100

    drm/atomic: Introduce drm_atomic_helper_shutdown
    
    The trouble here is that it does multiple atomic commits under one
    drm_modeset_lock_all, which breaks the behind-the-scenes acquire
    context magic that function pulls off. It's much better to have one
    overall atomic commit. That we still have multiple atomic commits
    prevents us from adding some pretty useful debug checks to the atomic
    machinery.
    
    Hence it is really a bad idea to call the legacy
    drm_crtc_force_disable_all() function. There's 2 atomic drivers using
    this still, nouveau and tinydrm. To fix this, introduce a new
    drm_atomic_helper_shutdown() by extracting the code from i915.
    
    While at it improve kernel-doc and catch future offenders by
    sprinkling a WARN_ON into the legacy function. We should probably move
    those into the legacy modeset helpers, too ...
    
    v2: Make it compile on arm drivers too (Noralf).
    
    v3: Correct kerneldoc to point at _disable_all().
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Noralf Trønnes <noralf@tronnes.org>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170321164149.31531-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 03d9e45694c9..98b17070a123 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1307,8 +1307,6 @@ void i915_driver_unload(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
-	struct drm_modeset_acquire_ctx ctx;
-	int ret;
 
 	intel_fbdev_fini(dev);
 
@@ -1317,23 +1315,7 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
 
-	drm_modeset_acquire_init(&ctx, 0);
-	while (1) {
-		ret = drm_modeset_lock_all_ctx(dev, &ctx);
-		if (!ret)
-			ret = drm_atomic_helper_disable_all(dev, &ctx);
-
-		if (ret != -EDEADLK)
-			break;
-
-		drm_modeset_backoff(&ctx);
-	}
-
-	if (ret)
-		DRM_ERROR("Disabling all crtc's during unload failed with %i\n", ret);
-
-	drm_modeset_drop_locks(&ctx);
-	drm_modeset_acquire_fini(&ctx);
+	drm_atomic_helper_shutdown(dev);
 
 	intel_gvt_cleanup(dev_priv);
 

commit 3950bf3dbff1010e3309416f9fe2acbea03156d5
Author: Oscar Mateo <oscar.mateo@intel.com>
Date:   Wed Mar 22 10:39:46 2017 -0700

    drm/i915/guc: Add onion teardown to the GuC setup
    
    Starting with intel_guc_loader, down to intel_guc_submission
    and finally to intel_guc_log.
    
    v2:
      - Null execbuf client outside guc_client_free (Daniele)
      - Assert if things try to get allocated twice (Daniele/Joonas)
      - Null guc->log.buf_addr when destroyed (Daniele)
      - Newline between returning success and error labels (Joonas)
      - Remove some unnecessary comments (Joonas)
      - Keep guc_log_create_extras naming convention (Joonas)
      - Helper function guc_log_has_extras (Joonas)
      - No need for separate relay_channel create/destroy. It's just another extra.
      - No need to nullify guc->log.flush_wq when destroyed (Joonas)
      - Hoist the check for has_extras out of guc_log_create_extras (Joonas)
      - Try to do i915_guc_log_register/unregister calls (kind of) symmetric (Daniele)
      - Make sure initel_guc_fini is not called before init is ever called (Daniele)
    
    v3:
      - Remove unnecessary parenthesis (Joonas)
      - Check for logs enabled on debugfs registration
      - Rebase on top of Tvrtko's "Fix request re-submission after reset"
    
    v4:
      - Rebased
      - Comment around enabling/disabling interrupts inside GuC logging (Joonas)
    
    Signed-off-by: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 03d9e45694c9..6d9944a00b7d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -549,6 +549,8 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
 	mutex_lock(&dev_priv->drm.struct_mutex);
+	if (i915.enable_guc_loading)
+		intel_uc_fini_hw(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_context_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
@@ -609,7 +611,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	ret = i915_gem_init(dev_priv);
 	if (ret)
-		goto cleanup_irq;
+		goto cleanup_uc;
 
 	intel_modeset_gem_init(dev);
 
@@ -631,9 +633,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 	i915_gem_fini(dev_priv);
+cleanup_uc:
+	intel_uc_fini_fw(dev_priv);
 cleanup_irq:
-	intel_guc_fini(dev_priv);
-	intel_huc_fini(dev_priv);
 	drm_irq_uninstall(dev);
 	intel_teardown_gmbus(dev_priv);
 cleanup_csr:
@@ -1369,9 +1371,8 @@ void i915_driver_unload(struct drm_device *dev)
 	/* Flush any outstanding unpin_work. */
 	drain_workqueue(dev_priv->wq);
 
-	intel_guc_fini(dev_priv);
-	intel_huc_fini(dev_priv);
 	i915_gem_fini(dev_priv);
+	intel_uc_fini_fw(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 
 	intel_power_domains_fini(dev_priv);

commit 2e8f9d322948406fb3aa0b27bda4d40a34e57123
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 16 17:13:04 2017 +0000

    drm/i915: Restore engine->submit_request before unwedging
    
    When we wedge the device, we override engine->submit_request with a nop
    to ensure that all in-flight requests are marked in error. However, igt
    would like to unwedge the device to test -EIO handling. This requires us
    to flush those in-flight requests and restore the original
    engine->submit_request.
    
    v2: Use a vfunc to unify enabling request submission to engines
    v3: Split new vfunc to a separate patch.
    v4: Make the wait interruptible -- the third party fences we wait upon
    may be indefinitely broken, so allow the reset to be aborted.
    
    Fixes: 821ed7df6e2a ("drm/i915: Update reset path to fix incomplete requests")
    Testcase: igt/gem_eio
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com> #v3
    Link: http://patchwork.freedesktop.org/patch/msgid/20170316171305.12972-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index be3c81221d11..03d9e45694c9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1821,7 +1821,9 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		return;
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
-	__clear_bit(I915_WEDGED, &error->flags);
+	if (!i915_gem_unset_wedged(dev_priv))
+		goto wakeup;
+
 	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
@@ -1867,17 +1869,18 @@ void i915_reset(struct drm_i915_private *dev_priv)
 
 	i915_queue_hangcheck(dev_priv);
 
-wakeup:
+finish:
 	i915_gem_reset_finish(dev_priv);
 	enable_irq(dev_priv->drm.irq);
 
+wakeup:
 	clear_bit(I915_RESET_HANDOFF, &error->flags);
 	wake_up_bit(&error->flags, I915_RESET_HANDOFF);
 	return;
 
 error:
 	i915_gem_set_wedged(dev_priv);
-	goto wakeup;
+	goto finish;
 }
 
 static int i915_pm_suspend(struct device *kdev)

commit 8c185ecaf4ee6966144c3897afdda557c5849bb0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 16 17:13:02 2017 +0000

    drm/i915: Split I915_RESET_IN_PROGRESS into two flags
    
    I915_RESET_IN_PROGRESS is being used for both signaling the requirement
    to i915_mutex_lock_interruptible() to avoid taking the struct_mutex and
    to instruct a waiter (already holding the struct_mutex) to perform the
    reset. To allow for a little more coordination, split these two meaning
    into a couple of distinct flags. I915_RESET_BACKOFF tells
    i915_mutex_lock_interruptible() not to acquire the mutex and
    I915_RESET_HANDOFF tells the waiter to call i915_reset().
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Michel Thierry <michel.thierry@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170316171305.12972-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9164167cd147..be3c81221d11 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1815,8 +1815,9 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	int ret;
 
 	lockdep_assert_held(&dev_priv->drm.struct_mutex);
+	GEM_BUG_ON(!test_bit(I915_RESET_BACKOFF, &error->flags));
 
-	if (!test_and_clear_bit(I915_RESET_IN_PROGRESS, &error->flags))
+	if (!test_bit(I915_RESET_HANDOFF, &error->flags))
 		return;
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
@@ -1869,7 +1870,9 @@ void i915_reset(struct drm_i915_private *dev_priv)
 wakeup:
 	i915_gem_reset_finish(dev_priv);
 	enable_irq(dev_priv->drm.irq);
-	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
+
+	clear_bit(I915_RESET_HANDOFF, &error->flags);
+	wake_up_bit(&error->flags, I915_RESET_HANDOFF);
 	return;
 
 error:

commit d2be9f2f41a8e361def96f8ca3eebf2db1c280a5
Author: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
Date:   Tue Mar 14 15:28:10 2017 +0100

    drm/i915/guc: Extract param logic form guc_init_fw()
    
    Let intel_guc_init_fw() focus on determining and fetching the correct
    firmware.
    
    This patch introduces intel_uc_sanitize_options() that is called from
    intel_sanitize_options().
    
    Then, if we have GuC, we can call intel_guc_init_fw() conditionally
    and we do not have to do the internal checks.
    
    v2: fix comment, notify when nuking GuC explicitly enabled (M. Wajdeczko)
    v3: fix comment again, change the nuke message (M. Wajdeczko)
    v4: update title to reflect new function name + rebase
    v5: text && remove 2 uneccessary checks (M. Wajdeczko)
    
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8a456ec52019..9164167cd147 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -988,6 +988,8 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 
 	i915.semaphores = intel_sanitize_semaphores(dev_priv, i915.semaphores);
 	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n", yesno(i915.semaphores));
+
+	intel_uc_sanitize_options(dev_priv);
 }
 
 /**

commit 29ad6a30de84f25f5ec8ac13c5d97b2fcc4bf605
Author: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
Date:   Tue Mar 14 15:28:09 2017 +0100

    drm/i915/uc: Introduce intel_uc_init_fw()
    
    Instead of calling intel_guc_init() and intel_huc_init() one by one this
    patch introduces intel_uc_init_fw() function that calls them both.
    
    Called functions are renamed accordingly.
    
    Trying to have subject_verb_object ordering and more descriptive names,
    the intel_huc_init() and intel_guc_init() functions are renamed.
    
    For guc_init():
     * `intel_guc` is the subject, so those functions now take intel_guc
       structure, instead of the dev_priv
     * init is the verb
     * fw is the object which better describes the function's role
    
    huc_init() change follows the same reasoning.
    
    v2: settle on intel_uc_fetch_fw name (M. Wajdeczko)
    v3: yet another rename - intel_uc_init_fw (J. Lahtinen)
    v4: non-trivial rebase
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 95fb7d391788..8a456ec52019 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -605,8 +605,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_irq;
 
-	intel_huc_init(dev_priv);
-	intel_guc_init(dev_priv);
+	intel_uc_init_fw(dev_priv);
 
 	ret = i915_gem_init(dev_priv);
 	if (ret)

commit 7d2ec88149926b7ad875b9f95595e763e43d6105
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:45 2017 +0100

    drm/i915: Merge pre/postclose hooks
    
    There's really not a reason afaics that we can't just clean up
    everything at the end, in the terminal postclose hook: Since this is
    closing a file descriptor we know no one else can have a reference or
    a thread doing something with that drm_file except the close code.
    Ordering shouldn't matter, as long as we don't kfree before we clean
    stuff up.
    
    In the past this was more relevant when drivers still had to track and
    clean up pending drm events, but that's all done by the core now.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-13-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e312b61ba6bb..95fb7d391788 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1420,17 +1420,14 @@ static void i915_driver_lastclose(struct drm_device *dev)
 	vga_switcheroo_process_delayed_switch();
 }
 
-static void i915_driver_preclose(struct drm_device *dev, struct drm_file *file)
+static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 {
+	struct drm_i915_file_private *file_priv = file->driver_priv;
+
 	mutex_lock(&dev->struct_mutex);
 	i915_gem_context_close(dev, file);
 	i915_gem_release(dev, file);
 	mutex_unlock(&dev->struct_mutex);
-}
-
-static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
-{
-	struct drm_i915_file_private *file_priv = file->driver_priv;
 
 	kfree(file_priv);
 }
@@ -2635,7 +2632,6 @@ static struct drm_driver driver = {
 	.release = i915_driver_release,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
-	.preclose = i915_driver_preclose,
 	.postclose = i915_driver_postclose,
 	.set_busid = drm_pci_set_busid,
 

commit 1b2e5ea0b7061be3ffdcd85918c2f428edace4ba
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Feb 12 17:19:59 2017 +0000

    drm/i915: Always call i915_gem_reset_finish() following i915_gem_reset_prepare()
    
    As i915_gem_reset_finish() undoes the steps from
    i915_gem_reset_prepare() to leave the system in a fully-working state,
    e.g. to be able to free the breadcrumb signal threads, make sure that we
    always call it even on the error path.
    
    Fixes: da9a796f5475 ("drm/i915: Split GEM resetting into 3 phases")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170212172002.23072-2-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    (cherry picked from commit 8d613c539c74fa9055f88f4116196d7c820bd98f)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6cd78bb2064d..1c75402a59c1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1809,10 +1809,10 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset_finish(dev_priv);
 	i915_queue_hangcheck(dev_priv);
 
 wakeup:
+	i915_gem_reset_finish(dev_priv);
 	enable_irq(dev_priv->drm.irq);
 	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
 	return;

commit 0f5418e564ac6452b9086295646e602a9addc4bf
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Mon Mar 13 17:04:33 2017 +0000

    drm/i915: Drop support for I915_EXEC_CONSTANTS_* execbuf parameters.
    
    This patch makes the I915_PARAM_HAS_EXEC_CONSTANTS getparam return 0
    (indicating the optional feature is not supported), and makes execbuf
    always return -EINVAL if the flags are used.
    
    Apparently, no userspace ever shipped which used this optional feature:
    I checked the git history of Mesa, xf86-video-intel, libva, and Beignet,
    and there were zero commits showing a use of these flags.  Kernel commit
    72bfa19c8deb4 apparently introduced the feature prematurely.  According
    to Chris, the intention was to use this in cairo-drm, but "the use was
    broken for gen6", so I don't think it ever happened.
    
    'relative_constants_mode' has always been tracked per-device, but this
    has actually been wrong ever since hardware contexts were introduced, as
    the INSTPM register is saved (and automatically restored) as part of the
    render ring context. The software per-device value could therefore get
    out of sync with the hardware per-context value.  This meant that using
    them is actually unsafe: a client which tried to use them could damage
    the state of other clients, causing the GPU to interpret their BO
    offsets as absolute pointers, leading to bogus memory reads.
    
    These flags were also never ported to execlist mode, making them no-ops
    on Gen9+ (which requires execlists), and Gen8 in the default mode.
    
    On Gen8+, userspace can write these registers directly, achieving the
    same effect.  On Gen6-7.5, it likely makes sense to extend the command
    parser to support them.  I don't think anyone wants this on Gen4-5.
    
    Based on a patch by Dave Gordon.
    
    v3: Return -ENODEV for the getparam, as this is what we do for other
        obsolete features.  Suggested by Chris Wilson.
    
    Cc: stable@vger.kernel.org
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=92448
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170215093446.21291-1-kenneth@whitecape.org
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170313170433.26843-1-chris@chris-wilson.co.uk
    (cherry picked from commit ef0f411f51475f4eebf9fc1b19a85be698af19ff)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2093d203665d..6cd78bb2064d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -248,6 +248,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_IRQ_ACTIVE:
 	case I915_PARAM_ALLOW_BATCHBUFFER:
 	case I915_PARAM_LAST_DISPATCH:
+	case I915_PARAM_HAS_EXEC_CONSTANTS:
 		/* Reject all old ums/dri params. */
 		return -ENODEV;
 	case I915_PARAM_CHIPSET_ID:
@@ -274,9 +275,6 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_BSD2:
 		value = !!dev_priv->engine[VCS2];
 		break;
-	case I915_PARAM_HAS_EXEC_CONSTANTS:
-		value = INTEL_GEN(dev_priv) >= 4;
-		break;
 	case I915_PARAM_HAS_LLC:
 		value = HAS_LLC(dev_priv);
 		break;

commit da9a796f5475b4d3a339083af719982b7ab4a12b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 13 16:59:57 2017 +0000

    drm/i915: Split GEM resetting into 3 phases
    
    Currently we do a reset prepare/finish around the call to reset the GPU,
    but it looks like we need a later stage after the hw has been
    reinitialised to allow GEM to restart itself. Start by splitting the 2
    GEM phases into 3:
    
      prepare - before the reset, check if GEM recovered, then stop GEM
    
      reset - after the reset, update GEM bookkeeping
    
      finish - after the re-initialisation following the reset, restart GEM
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170208143033.11651-2-chris@chris-wilson.co.uk
    Link: http://patchwork.freedesktop.org/patch/msgid/20170313165958.13970-1-chris@chris-wilson.co.uk
    (cherry picked from commit d80270931314a88d79d9bd5e0a5df93c12196375)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e703556eba99..2093d203665d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1788,7 +1788,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset_finish(dev_priv);
+	i915_gem_reset(dev_priv);
 	intel_overlay_reset(dev_priv);
 
 	/* Ok, now get things going again... */
@@ -1811,6 +1811,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	i915_gem_reset_finish(dev_priv);
 	i915_queue_hangcheck(dev_priv);
 
 wakeup:

commit 44e921d4a19846e39fa818afa9d2d22c3117210a
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Mar 9 17:44:34 2017 +0200

    drm/i915: Optimize VLV/CHV display FIFO updates
    
    Use I915_{READ,WRITE}_FW() for updating the DSPARB registers on
    VLV/CHV. This is less expesive as we can grab the uncore.lock across
    the entire sequence of reads and writes instead of each register
    access grabbing it.
    
    This also allows us to eliminate the dsparb lock entirely as the
    uncore.lock now effectively protects the contents of the DSPARB
    registers.
    
    v2: Add a note that interrupts are already disabled (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170309154434.29303-6-ville.syrjala@linux.intel.com
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1af54717fa81..e312b61ba6bb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -825,7 +825,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	spin_lock_init(&dev_priv->mm.object_stat_lock);
 	spin_lock_init(&dev_priv->mmio_flip_lock);
-	spin_lock_init(&dev_priv->wm.dsparb_lock);
 	mutex_init(&dev_priv->sb_lock);
 	mutex_init(&dev_priv->modeset_restore_lock);
 	mutex_init(&dev_priv->av_mutex);

commit 665788572c6410b7efadc2e3009c5d830b6d8ef9
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Mar 10 15:27:57 2017 +0200

    drm/i915/vbt: don't propagate errors from intel_bios_init()
    
    We don't use the error return for anything other than reporting and
    logging that there is no VBT. We can pull the logging in the function,
    and remove the error status return. Moreover, if we needed the
    information for something later on, we'd probably be better off storing
    the bit in dev_priv, and using it where it's needed, instead of using
    the error return.
    
    While at it, improve the comments.
    
    Cc: Manasi Navare <manasi.d.navare@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/438ebbb0d5f0d321c625065b9cc78532a1dab24f.1489152288.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b1e9027a4f80..1af54717fa81 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -567,9 +567,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	ret = intel_bios_init(dev_priv);
-	if (ret)
-		DRM_INFO("failed to find VBIOS tables\n");
+	intel_bios_init(dev_priv);
 
 	/* If we have > 1 VGA cards, then we need to arbitrate access
 	 * to the common VGA resources.

commit f103560cf7c2abc10283dd0ba9889f3de5b7ac7e
Merge: 1f3b1fd386e6 264ec1a8221c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 13 09:26:06 2017 +0100

    Merge tag 'topic/designware-baytrail-2017-03-02' of git://anongit.freedesktop.org/git/drm-intel into drm-intel-next-queued
    
    Baytrail PMIC vs. PMU race fixes from Hans de Goede
    
    This time the right version (v4), with the compile fix.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 2e16101780e9cc8c4c68566db002e7513a1530eb
Merge: b558dfd56a5c 505b681539a7
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 8 12:41:47 2017 +1000

    Merge tag 'drm-intel-next-2017-03-06' of git://anongit.freedesktop.org/git/drm-intel into drm-next
    
    4 weeks worth of stuff since I was traveling&lazy:
    
    - lspcon improvements (Imre)
    - proper atomic state for cdclk handling (Ville)
    - gpu reset improvements (Chris)
    - lots and lots of polish around fences, requests, waiting and
      everything related all over (both gem and modeset code), from Chris
    - atomic by default on gen5+ minus byt/bsw (Maarten did the patch to
      flip the default, really this is a massive joint team effort)
    - moar power domains, now 64bit (Ander)
    - big pile of in-kernel unit tests for various gem subsystems (Chris),
      including simple mock objects for i915 device and and the ggtt
      manager.
    - i915_gpu_info in debugfs, for taking a snapshot of the current gpu
      state. Same thing as i915_error_state, but useful if the kernel didn't
      notice something is stick. From Chris.
    - bxt dsi fixes (Umar Shankar)
    - bxt w/a updates (Jani)
    - no more struct_mutex for gem object unreference (Chris)
    - some execlist refactoring (Tvrtko)
    - color manager support for glk (Ander)
    - improve the power-well sync code to better take over from the
      firmware (Imre)
    - gem tracepoint polish (Tvrtko)
    - lots of glk fixes all around (Ander)
    - ctx switch improvements (Chris)
    - glk dsi support&fixes (Deepak M)
    - dsi fixes for vlv and clanups, lots of them (Hans de Goede)
    - switch to i915.ko types in lots of our internal modeset code (Ander)
    - byt/bsw atomic wm update code, yay (Ville)
    
    * tag 'drm-intel-next-2017-03-06' of git://anongit.freedesktop.org/git/drm-intel: (432 commits)
      drm/i915: Update DRIVER_DATE to 20170306
      drm/i915: Don't use enums for hardware engine id
      drm/i915: Split breadcrumbs spinlock into two
      drm/i915: Refactor wakeup of the next breadcrumb waiter
      drm/i915: Take reference for signaling the request from hardirq
      drm/i915: Add FIFO underrun tracepoints
      drm/i915: Add cxsr toggle tracepoint
      drm/i915: Add VLV/CHV watermark/FIFO programming tracepoints
      drm/i915: Add plane update/disable tracepoints
      drm/i915: Kill level 0 wm hack for VLV/CHV
      drm/i915: Workaround VLV/CHV sprite1->sprite0 enable underrun
      drm/i915: Sanitize VLV/CHV watermarks properly
      drm/i915: Only use update_wm_{pre,post} for pre-ilk platforms
      drm/i915: Nuke crtc->wm.cxsr_allowed
      drm/i915: Compute proper intermediate wms for vlv/cvh
      drm/i915: Skip useless watermark/FIFO related work on VLV/CHV when not needed
      drm/i915: Compute vlv/chv wms the atomic way
      drm/i915: Compute VLV/CHV FIFO sizes based on the PM2 watermarks
      drm/i915: Plop vlv/chv fifo sizes into crtc state
      drm/i915: Plop vlv wm state into crtc_state
      ...

commit b558dfd56a5c1f915327967ecfe1181cf2a7a494
Merge: c1ae3cfa0e89 ca39b449f6d0
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 7 13:59:53 2017 +1000

    Merge tag 'drm-misc-next-2017-03-06' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    First slice of drm-misc-next for 4.12:
    
    Core/subsystem-wide:
    - link status core patch from Manasi, for signalling link train fail
      to userspace. I also had the i915 patch in here, but that had a
      small buglet in our CI, so reverted.
    - more debugfs_remove removal from Noralf, almost there now (Noralf
      said he'll try to follow up with the stragglers).
    - drm todo moved into kerneldoc, for better visibility (see
      Documentation/gpu/todo.rst), lots of starter tasks in there.
    - devm_ of helpers + use it in sti (from Ben Gaignard, acked by Rob
      Herring)
    - extended framebuffer fbdev support (for fbdev flipping), and vblank
      wait ioctl fbdev support (Maxime Ripard)
    - misc small things all over, as usual
    - add vblank callbacks to drm_crtc_funcs, plus make lots of good use
      of this to simplify drivers (Shawn Guo)
    - new atomic iterator macros to unconfuse old vs. new state
    
    Small drivers:
    - vc4 improvements from Eric
    - vc4 kerneldocs (Eric)!
    - tons of improvements for dw-mipi-dsi in rockchip from John Keeping
      and Chris Zhong.
    - MAINTAINERS entries for drivers managed in drm-misc. It's not yet
      official, still an experiment, but definitely not complete fail and
      better to avoid confusion. We kinda screwed that up with drm-misc a
      bit when we started committers last year.
    - qxl atomic conversion (Gabriel Krisman)
    - bunch of virtual driver polish (qxl, virgl, ...)
    - misc tiny patches all over
    
    This is the first time we've done the same merge-window blackout for
    drm-misc as we've done for drm-intel for ages, hence why we have a
    _lot_ of stuff queued already. But it's still only half of drm-intel
    (room to grow!), and the drivers in drm-misc experiment seems to work
    at least insofar as that you also get lots of driver updates here
    alredy.
    
    * tag 'drm-misc-next-2017-03-06' of git://anongit.freedesktop.org/git/drm-misc: (141 commits)
      drm/vc4: Fix OOPSes from trying to cache a partially constructed BO.
      drm/vc4: Fulfill user BO creation requests from the kernel BO cache.
      Revert "drm/i915: Implement Link Rate fallback on Link training failure"
      drm/fb-helper: implement ioctl FBIO_WAITFORVSYNC
      drm: Update drm_fbdev_cma_init documentation
      drm/rockchip/dsi: add dw-mipi power domain support
      drm/rockchip/dsi: fix insufficient bandwidth of some panel
      dt-bindings: add power domain node for dw-mipi-rockchip
      drm/rockchip/dsi: remove mode_valid function
      drm/rockchip/dsi: dw-mipi: correct the coding style
      drm/rockchip/dsi: dw-mipi: support RK3399 mipi dsi
      dt-bindings: add rk3399 support for dw-mipi-rockchip
      drm/rockchip: dw-mipi-dsi: add reset control
      drm/rockchip: dw-mipi-dsi: support non-burst modes
      drm/rockchip: dw-mipi-dsi: defer probe if panel is not loaded
      drm/rockchip: vop: test for P{H,V}SYNC
      drm/rockchip: dw-mipi-dsi: use positive check for N{H, V}SYNC
      drm/rockchip: dw-mipi-dsi: use specific poll helper
      drm/rockchip: dw-mipi-dsi: improve PLL configuration
      drm/rockchip: dw-mipi-dsi: properly configure PHY timing
      ...

commit 68f60946c1b6d1504af8994f4a419769217e4f23
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Feb 10 11:28:01 2017 +0100

    drm/i915: Add intel_uncore_suspend / resume functions
    
    Rename intel_uncore_early_sanitize to intel_uncore_resume, dropping the
    (always true) restore_forcewake argument and add a new intel_uncore_resume
    function to replace the intel_uncore_forcewake_reset(dev_priv, false)
    calls done from the suspend / runtime_suspend functions and make
    intel_uncore_forcewake_reset private.
    
    This is a preparation patch for adding PMIC bus access notifier support.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=155241
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: tagorereddy <tagore.chandan@gmail.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170210102802.20898-12-hdegoede@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f6017f2cfb86..58eb308fca41 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1456,7 +1456,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
 	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
 
-	intel_uncore_forcewake_reset(dev_priv, false);
+	intel_uncore_suspend(dev_priv);
 	intel_opregion_unregister(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
@@ -1701,7 +1701,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
 			  ret);
 
-	intel_uncore_early_sanitize(dev_priv, true);
+	intel_uncore_resume_early(dev_priv);
 
 	if (IS_GEN9_LP(dev_priv)) {
 		if (!dev_priv->suspended_to_idle)
@@ -2343,7 +2343,7 @@ static int intel_runtime_suspend(struct device *kdev)
 		return ret;
 	}
 
-	intel_uncore_forcewake_reset(dev_priv, false);
+	intel_uncore_suspend(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));

commit b05eeb0f47a3f9f2530f1c46b11dacfa0ca71876
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Thu Jan 26 23:56:21 2017 +0100

    drm/i915: Remove i915_debugfs_unregister()
    
    drm_debugfs_cleanup() now removes all minor->debugfs_list entries
    automatically, so no need to do this explicitly. Additionally it
    uses debugfs_remove_recursive() to clean up the debugfs files,
    so no need for adding fake drm_info_node entries.
    
    Cc: daniel.vetter@intel.com
    Cc: jani.nikula@linux.intel.com
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170126225621.12314-20-noralf@tronnes.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f6017f2cfb86..8cdafef8eac9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1167,7 +1167,6 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 
 	i915_teardown_sysfs(dev_priv);
 	i915_guc_log_unregister(dev_priv);
-	i915_debugfs_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 
 	i915_gem_shrinker_cleanup(dev_priv);

commit c771633daf951439ef1875b0da52b56e5696d19f
Merge: 62b695662a24 64a577196d66
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Feb 27 09:30:11 2017 +0100

    Merge airlied/drm-next into drm-misc-next
    
    Backmerge the main pull request to sync up with all the newly landed
    drivers. Otherwise we'll have chaos even before 4.12 started in
    earnest.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit ef0f411f51475f4eebf9fc1b19a85be698af19ff
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Wed Feb 15 01:34:46 2017 -0800

    drm/i915: Drop support for I915_EXEC_CONSTANTS_* execbuf parameters.
    
    This patch makes the I915_PARAM_HAS_EXEC_CONSTANTS getparam return 0
    (indicating the optional feature is not supported), and makes execbuf
    always return -EINVAL if the flags are used.
    
    Apparently, no userspace ever shipped which used this optional feature:
    I checked the git history of Mesa, xf86-video-intel, libva, and Beignet,
    and there were zero commits showing a use of these flags.  Kernel commit
    72bfa19c8deb4 apparently introduced the feature prematurely.  According
    to Chris, the intention was to use this in cairo-drm, but "the use was
    broken for gen6", so I don't think it ever happened.
    
    'relative_constants_mode' has always been tracked per-device, but this
    has actually been wrong ever since hardware contexts were introduced, as
    the INSTPM register is saved (and automatically restored) as part of the
    render ring context. The software per-device value could therefore get
    out of sync with the hardware per-context value.  This meant that using
    them is actually unsafe: a client which tried to use them could damage
    the state of other clients, causing the GPU to interpret their BO
    offsets as absolute pointers, leading to bogus memory reads.
    
    These flags were also never ported to execlist mode, making them no-ops
    on Gen9+ (which requires execlists), and Gen8 in the default mode.
    
    On Gen8+, userspace can write these registers directly, achieving the
    same effect.  On Gen6-7.5, it likely makes sense to extend the command
    parser to support them.  I don't think anyone wants this on Gen4-5.
    
    Based on a patch by Dave Gordon.
    
    v3: Return -ENODEV for the getparam, as this is what we do for other
        obsolete features.  Suggested by Chris Wilson.
    
    Cc: stable@vger.kernel.org
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=92448
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170215093446.21291-1-kenneth@whitecape.org
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 747cd5dfb910..51241dec3f83 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -249,6 +249,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_IRQ_ACTIVE:
 	case I915_PARAM_ALLOW_BATCHBUFFER:
 	case I915_PARAM_LAST_DISPATCH:
+	case I915_PARAM_HAS_EXEC_CONSTANTS:
 		/* Reject all old ums/dri params. */
 		return -ENODEV;
 	case I915_PARAM_CHIPSET_ID:
@@ -275,9 +276,6 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_BSD2:
 		value = !!dev_priv->engine[VCS2];
 		break;
-	case I915_PARAM_HAS_EXEC_CONSTANTS:
-		value = INTEL_GEN(dev_priv) >= 4;
-		break;
 	case I915_PARAM_HAS_LLC:
 		value = HAS_LLC(dev_priv);
 		break;

commit ef96152e6a36e0510387cb174178b7982c1ae879
Merge: d5500a074741 64a577196d66
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 18:58:18 2017 -0800

    Merge tag 'drm-for-v4.11-less-shouty' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for v4.11.
    
      Nothing too major, the tinydrm and mmu-less support should make
      writing smaller drivers easier for some of the simpler platforms, and
      there are a bunch of documentation updates.
    
      Intel grew displayport MST audio support which is hopefully useful to
      people, and FBC is on by default for GEN9+ (so people know where to
      look for regressions). AMDGPU has a lot of fixes that would like new
      firmware files installed for some GPUs.
    
      Other than that it's pretty scattered all over.
    
      I may have a follow up pull request as I know BenH has a bunch of AST
      rework and fixes and I'd like to get those in once they've been tested
      by AST, and I've got at least one pull request I'm just trying to get
      the author to fix up.
    
      Core:
       - drm_mm reworked
       - Connector list locking and iterators
       - Documentation updates
       - Format handling rework
       - MMU-less support for fbdev helpers
       - drm_crtc_from_index helper
       - Core CRC API
       - Remove drm_framebuffer_unregister_private
       - Debugfs cleanup
       - EDID/Infoframe fixes
       - Release callback
       - Tinydrm support (smaller drivers for simple hw)
    
      panel:
       - Add support for some new simple panels
    
      i915:
       - FBC by default for gen9+
       - Shared dpll cleanups and docs
       - GEN8 powerdomain cleanup
       - DMC support on GLK
       - DP MST audio support
       - HuC loading support
       - GVT init ordering fixes
       - GVT IOMMU workaround fix
    
      amdgpu/radeon:
       - Power/clockgating improvements
       - Preliminary SR-IOV support
       - TTM buffer priority and eviction fixes
       - SI DPM quirks removed due to firmware fixes
       - Powerplay improvements
       - VCE/UVD powergating fixes
       - Cleanup SI GFX code to match CI/VI
       - Support for > 2 displays on 3/5 crtc asics
       - SI headless fixes
    
      nouveau:
       - Rework securre boot code in prep for GP10x secure boot
       - Channel recovery improvements
       - Initial power budget code
       - MMU rework preperation
    
      vmwgfx:
       - Bunch of fixes and cleanups
    
      exynos:
       - Runtime PM support for MIC driver
       - Cleanups to use atomic helpers
       - UHD Support for TM2/TM2E boards
       - Trigger mode fix for Rinato board
    
      etnaviv:
       - Shader performance fix
       - Command stream validator fixes
       - Command buffer suballocator
    
      rockchip:
       - CDN DisplayPort support
       - IOMMU support for arm64 platform
    
      imx-drm:
       - Fix i.MX5 TV encoder probing
       - Remove lower fb size limits
    
      msm:
       - Support for HW cursor on MDP5 devices
       - DSI encoder cleanup
       - GPU DT bindings cleanup
    
      sti:
       - stih410 cleanups
       - Create fbdev at binding
       - HQVDP fixes
       - Remove stih416 chip functionality
       - DVI/HDMI mode selection fixes
       - FPS statistic reporting
    
      omapdrm:
       - IRQ code cleanup
    
      dwi-hdmi bridge:
       - Cleanups and fixes
    
      adv-bridge:
       - Updates for nexus
    
      sii8520 bridge:
       - Add interlace mode support
       - Rework HDMI and lots of fixes
    
      qxl:
       - probing/teardown cleanups
    
      ZTE drm:
       - HDMI audio via SPDIF interface
       - Video Layer overlay plane support
       - Add TV encoder output device
    
      atmel-hlcdc:
       - Rework fbdev creation logic
    
      tegra:
       - OF node fix
    
      fsl-dcu:
       - Minor fixes
    
      mali-dp:
       - Assorted fixes
    
      sunxi:
       - Minor fix"
    
    [ This was the "fixed" pull, that still had build warnings due to people
      not even having build tested the result. I'm not a happy camper
    
      I've fixed the things I noticed up in this merge.      - Linus ]
    
    * tag 'drm-for-v4.11-less-shouty' of git://people.freedesktop.org/~airlied/linux: (1177 commits)
      lib/Kconfig: make PRIME_NUMBERS not user selectable
      drm/tinydrm: helpers: Properly fix backlight dependency
      drm/tinydrm: mipi-dbi: Fix field width specifier warning
      drm/tinydrm: mipi-dbi: Silence: ‘cmd’ may be used uninitialized
      drm/sti: fix build warnings in sti_drv.c and sti_vtg.c files
      drm/amd/powerplay: fix PSI feature on Polars12
      drm/amdgpu: refuse to reserve io mem for split VRAM buffers
      drm/ttm: fix use-after-free races in vm fault handling
      drm/tinydrm: Add support for Multi-Inno MI0283QT display
      dt-bindings: Add Multi-Inno MI0283QT binding
      dt-bindings: display/panel: Add common rotation property
      of: Add vendor prefix for Multi-Inno
      drm/tinydrm: Add MIPI DBI support
      drm/tinydrm: Add helper functions
      drm: Add DRM support for tiny LCD displays
      drm/amd/amdgpu: post card if there is real hw resetting performed
      drm/nouveau/tmr: provide backtrace when a timeout is hit
      drm/nouveau/pci/g92: Fix rearm
      drm/nouveau/drm/therm/fan: add a fallback if no fan control is specified in the vbios
      drm/nouveau/hwmon: expose power_max and power_crit
      ..

commit 28cbc335d272f293c4368abd4ac2e17e36805b79
Merge: 1ec5c1867af0 7086b7b3d101
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 08:50:22 2017 -0800

    Merge tag 'sound-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "Here is the update of sound bits for 4.11: again at this time, no big
      changes in ALSA and ASoC core but only cosmetic changes like
      consitifaction.
    
      Meanwhile, quite a lot of developments are seen in a few driver side.
    
      ALSA Core:
       - Clean up, consitification of some ops
    
      HD-audio:
       - A slight behavior change of single_cmd option
       - Quirks for AmigaOne X1000, Samsung Ativ Book 8, Dell AiO, ALC221
         HP, and fixes for Lewisburg controller
       - Realtek ALC299, ALC1220 codecs
    
      Others:
       - USB-audio: Tascam US-16x08 DSP mixer quirk
       - Intel HDMI LPE audio support for Baytrail / Cherrytrail; this
         contains some updates in drm/i915 for the new platform binding
    
      ASoC:
       - Lots of updates in Intel drivers, mostly for DisplayPort and HDMI
         on Skylake and onwards, as well as more Baytrail / Cherrytrail
         boards support
       - Channel mapping support for HDMI
       - Support for AllWinner A31 and A33, Everest Semiconductor ES8328,
         Nuvoton NAU8540.
    
    * tag 'sound-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (323 commits)
      ALSA: usb-audio: Tidy up mixer_us16x08.c
      ALSA: usb-audio: Fix memory leak and corruption in mixer_us16x08.c
      ALSA: usb-audio: purge needless variable length array
      ALSA: x86: hdmi: select CONFIG_SND_PCM
      ALSA: x86: Don't enable runtime PM as default
      ALSA: x86: Use runtime PM autosuspend
      ALSA: usb-audio: localize function without external linkage
      ALSA: usb-audio: localize one-referrer variable
      ALSA: usb-audio: Tascam US-16x08 DSP mixer quirk
      ALSA: emu10k1: constify snd_emux_operators structure
      ASoC: sun4i-spdif: drop unnessary snd_soc_unregister_component()
      ASoC: Intel: bxt: Add jack port initialize in bxt_rt298 machine
      ASoC: nau8825: automatic BCLK and LRC divde in master mode
      ASoC: hdac_hdmi: Add device id for Geminilake
      ASoC: Intel: Skylake: Add Geminlake IDs
      ASoC: rt298: Add DMI match for Geminilake reference platform
      ASoC: Intel: Skylake: Check device type to get endpoint configuration
      ASoC: Intel: bxt: Add jack port initialize in da7219_max98357a machine
      ASoC: Intel: Skylake: Add jack port initialize in nau88l25_ssm4567 machine
      ASoC: Intel: Skylake: Add jack port initialize in nau88l25_max98357a machine
      ...

commit 94000cc32988a0674923309d35ab9c2405c4b39b
Merge: a5eb76d9c892 7089db84e356
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 23 12:10:12 2017 +1000

    Merge tag 'v4.10-rc8' into drm-next
    
    Linux 4.10-rc8
    
    Backmerge Linus rc8 to fix some conflicts, but also
    to avoid pulling it in via a fixes pull from someone.

commit 784f2f1a9da22b0ab00c1b364ee2c10573f5c248
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Mon Feb 20 10:46:57 2017 +0000

    drm/i915: Fix typo in semaphore debug message
    
    Pronounces less rude when fixed.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170220104657.5237-1-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c992d406ae74..747cd5dfb910 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -999,7 +999,7 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
 
 	i915.semaphores = intel_sanitize_semaphores(dev_priv, i915.semaphores);
-	DRM_DEBUG_DRIVER("use GPU sempahores? %s\n", yesno(i915.semaphores));
+	DRM_DEBUG_DRIVER("use GPU semaphores? %s\n", yesno(i915.semaphores));
 }
 
 /**

commit 3582ad1361644ba0f937cf6aa59d5c9ead6763ca
Author: sagar.a.kamble@intel.com <sagar.a.kamble@intel.com>
Date:   Fri Feb 3 13:58:33 2017 +0530

    drm/i915: Do RPM Wake during GuC/HuC status read
    
    HUC_STATUS, GUC_STATUS, SOFT_SCRATCH registers are read in debugfs
    and getparam ioctl. This patch covers those accesses by RPM get/put.
    
    v2: Covering access in i915_getparam(I915_PARAM_HUC_STATUS) (ChrisW)
    
    Cc: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Cc: Fiedorowicz, Lukasz <lukasz.fiedorowicz@intel.com>
    Signed-off-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486110513-12130-1-git-send-email-sagar.a.kamble@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 50de00921cc9..c992d406ae74 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -319,10 +319,9 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = INTEL_INFO(dev_priv)->sseu.min_eu_in_pool;
 		break;
 	case I915_PARAM_HUC_STATUS:
-		/* The register is already force-woken. We dont need
-		 * any rpm here
-		 */
+		intel_runtime_pm_get(dev_priv);
 		value = I915_READ(HUC_STATUS2) & HUC_FW_VERIFIED;
+		intel_runtime_pm_put(dev_priv);
 		break;
 	case I915_PARAM_MMAP_GTT_VERSION:
 		/* Though we've started our numbering from 1, and so class all

commit 5a4c6f1b1b2d91c5252cedf1c7b68a894c3f117e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Feb 14 16:46:11 2017 +0000

    drm/i915: The return of i915_gpu_info to debugfs
    
    Once upon a time before we had automated GPU state capture upon hangs,
    we had intel_gpu_dump. Now we come almost full circle and reinstate that
    view of the current GPU queues and registers by using the error capture
    facility to snapshot the GPU state when debugfs/.../i915_gpu_info is
    opened - which should provided useful debugging to both the error
    capture routines (without having to cause a hang and avoid the error
    state being eaten by igt) and generally.
    
    v2: Rename drm_i915_error_state to i915_gpu_state to alleviate some name
    collisions between the error state dump and inspecting the gpu state.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170214164611.11381-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index efb1f64f0e41..50de00921cc9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1370,7 +1370,7 @@ void i915_driver_unload(struct drm_device *dev)
 
 	/* Free error state after interrupts are fully disabled. */
 	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
-	i915_destroy_error_state(dev_priv);
+	i915_reset_error_state(dev_priv);
 
 	/* Flush any outstanding unpin_work. */
 	drain_workqueue(dev_priv->wq);

commit 66d9cb5d805af70229ffe6f961bf06adc511f469
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 13 17:15:17 2017 +0000

    drm/i915: Mock the GEM device for self-testing
    
    A simulacrum of drm_i915_private to let us pretend interactions with the
    device.
    
    v2: Tidy init error paths
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170213171558.20942-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ac1b3582ca55..efb1f64f0e41 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2668,3 +2668,7 @@ static struct drm_driver driver = {
 	.minor = DRIVER_MINOR,
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
+
+#if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
+#include "selftests/mock_drm.c"
+#endif

commit 8d613c539c74fa9055f88f4116196d7c820bd98f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Feb 12 17:19:59 2017 +0000

    drm/i915: Always call i915_gem_reset_finish() following i915_gem_reset_prepare()
    
    As i915_gem_reset_finish() undoes the steps from
    i915_gem_reset_prepare() to leave the system in a fully-working state,
    e.g. to be able to free the breadcrumb signal threads, make sure that we
    always call it even on the error path.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170212172002.23072-2-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 221f1c56fd9c..ac1b3582ca55 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1873,10 +1873,10 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset_finish(dev_priv);
 	i915_queue_hangcheck(dev_priv);
 
 wakeup:
+	i915_gem_reset_finish(dev_priv);
 	enable_irq(dev_priv->drm.irq);
 	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
 	return;

commit cad3688ff00656face6c78a1028fd02288b4a960
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 10 16:35:21 2017 +0000

    drm/i915: Split device release from unload
    
    We may need to keep our memory management alive after we have unloaded
    the physical pci device. For example, if we have exported an object via
    dmabuf, that will keep the device around but the pci device may be
    removed before the dmabuf itself is released, use of the pci hardware
    will be revoked, but the memory and object management needs to persist
    for the dmabuf.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170210163523.17533-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2394de1b19df..221f1c56fd9c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1231,8 +1231,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 		ret = drm_dev_init(&dev_priv->drm, &driver, &pdev->dev);
 	if (ret) {
 		DRM_DEV_ERROR(&pdev->dev, "allocation failed\n");
-		kfree(dev_priv);
-		return ret;
+		goto out_free;
 	}
 
 	dev_priv->drm.pdev = pdev;
@@ -1240,7 +1239,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	ret = pci_enable_device(pdev);
 	if (ret)
-		goto out_free_priv;
+		goto out_fini;
 
 	pci_set_drvdata(pdev, &dev_priv->drm);
 
@@ -1304,9 +1303,11 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	i915_driver_cleanup_early(dev_priv);
 out_pci_disable:
 	pci_disable_device(pdev);
-out_free_priv:
+out_fini:
 	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
-	drm_dev_unref(&dev_priv->drm);
+	drm_dev_fini(&dev_priv->drm);
+out_free:
+	kfree(dev_priv);
 	return ret;
 }
 
@@ -1385,8 +1386,16 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_driver_cleanup_mmio(dev_priv);
 
 	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
+}
+
+static void i915_driver_release(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
 
 	i915_driver_cleanup_early(dev_priv);
+	drm_dev_fini(&dev_priv->drm);
+
+	kfree(dev_priv);
 }
 
 static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
@@ -2630,6 +2639,7 @@ static struct drm_driver driver = {
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC,
+	.release = i915_driver_release,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,

commit 317eaa95081bfa081a5bf147e175b4e007e5a105
Author: Lyude <lyude@redhat.com>
Date:   Fri Feb 3 21:18:25 2017 -0500

    drm/i915/debugfs: Add i915_hpd_storm_ctl
    
    This adds a file in i915's debugfs directory that allows userspace to
    manually control HPD storm detection. This is mainly for hotplugging
    tests, where we might want to test HPD storm functionality or disable
    storm detection to speed up hotplugging tests without breaking anything.
    
    Changes since v1:
    - Make HPD storm interval configurable
    - Misc code cleanup
    
    Signed-off-by: Lyude <lyude@redhat.com>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Tomeu Vizoso <tomeu@tomeuvizoso.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a17dde86dc8c..2394de1b19df 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -827,6 +827,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	spin_lock_init(&dev_priv->gpu_error.lock);
 	mutex_init(&dev_priv->backlight_lock);
 	spin_lock_init(&dev_priv->uncore.lock);
+
 	spin_lock_init(&dev_priv->mm.object_stat_lock);
 	spin_lock_init(&dev_priv->mmio_flip_lock);
 	spin_lock_init(&dev_priv->wm.dsparb_lock);

commit 8d2b47dde8a097e6fef2ebb5042cbb267cc75adf
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Feb 2 08:41:42 2017 +0100

    drm/i915: Enable atomic support by default on supported platforms.
    
    i915 is pretty much feature complete. Support for atomic i915-specific
    connector properties is still missing; those properties can (for now)
    only be set through the legacy ioctl.
    
    ILK style watermarks and gen9+ watermarks are handled atomically,
    and nonblocking modesets work. FBC has also been made to work with
    atomic.
    
    gen4x- and vlv/chv watermarks still need to be fixed, so disable atomic
    by default there for now.
    
    Flip the switch!!
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Lyude <cpaul@redhat.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486021302-24910-1-git-send-email-maarten.lankhorst@linux.intel.com
    [mlankhorst: Fix checkpatch warning about extra space in match_info]
    Acked-by: Daniel Stone <daniel@fooishbar.org>
    Reviewed-by: Lyude <lyude@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d48c02a7933f..a17dde86dc8c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1214,11 +1214,15 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
  */
 int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
+	const struct intel_device_info *match_info =
+		(struct intel_device_info *)ent->driver_data;
 	struct drm_i915_private *dev_priv;
 	int ret;
 
-	if (i915.nuclear_pageflip)
-		driver.driver_features |= DRIVER_ATOMIC;
+	/* Enable nuclear pageflip on ILK+, except vlv/chv */
+	if (!i915.nuclear_pageflip &&
+	    (match_info->gen < 5 || match_info->has_gmch_display))
+		driver.driver_features &= ~DRIVER_ATOMIC;
 
 	ret = -ENOMEM;
 	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
@@ -2624,7 +2628,7 @@ static struct drm_driver driver = {
 	 */
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
-	    DRIVER_RENDER | DRIVER_MODESET,
+	    DRIVER_RENDER | DRIVER_MODESET | DRIVER_ATOMIC,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,

commit d80270931314a88d79d9bd5e0a5df93c12196375
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 8 14:30:32 2017 +0000

    drm/i915: Split GEM resetting into 3 phases
    
    Currently we do a reset prepare/finish around the call to reset the GPU,
    but it looks like we need a later stage after the hw has been
    reinitialised to allow GEM to restart itself. Start by splitting the 2
    GEM phases into 3:
    
      prepare - before the reset, check if GEM recovered, then stop GEM
    
      reset - after the reset, update GEM bookkeeping
    
      finish - after the re-initialisation following the reset, restart GEM
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170208143033.11651-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 78191e00a00c..d48c02a7933f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1836,7 +1836,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset_finish(dev_priv);
+	i915_gem_reset(dev_priv);
 	intel_overlay_reset(dev_priv);
 
 	/* Ok, now get things going again... */
@@ -1859,6 +1859,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	i915_gem_reset_finish(dev_priv);
 	i915_queue_hangcheck(dev_priv);
 
 wakeup:

commit 83bf6d55c132d5c4f773e5a04149c05f4aa0c2ad
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 3 12:57:17 2017 +0000

    drm/i915: Remove overzealous fence warn on runtime suspend
    
    The goal of the WARN was to catch when we are still actively using the
    fence as we go into the runtime suspend. However, the reg->pin_count is
    too coarse as it does not distinguish between exclusive ownership of the
    fence register from activity.
    
    I've not improved on the WARN, nor have we captured this WARN in an
    exact igt, but it is showing up regularly in the wild:
    
    [ 1915.935332] WARNING: CPU: 1 PID: 10861 at drivers/gpu/drm/i915/i915_gem.c:2022 i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.935383] WARN_ON(reg->pin_count)[ 1915.935399] Modules linked in:
     snd_hda_intel i915 drm_kms_helper vgem netconsole scsi_transport_iscsi fuse vfat fat x86_pkg_temp_thermal coretemp intel_cstate intel_uncore snd_hda_codec_hdmi snd_hda_codec_generic snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mei_me mei serio_raw intel_rapl_perf intel_pch_thermal soundcore wmi acpi_pad i2c_algo_bit syscopyarea sysfillrect sysimgblt fb_sys_fops drm r8169 mii video [last unloaded: drm_kms_helper]
    [ 1915.935785] CPU: 1 PID: 10861 Comm: kworker/1:0 Tainted: G     U  W       4.9.0-rc5+ #170
    [ 1915.935799] Hardware name: LENOVO 80MX/Lenovo E31-80, BIOS DCCN34WW(V2.03) 12/01/2015
    [ 1915.935822] Workqueue: pm pm_runtime_work
    [ 1915.935845]  ffffc900044fbbf0 ffffffffac3220bc ffffc900044fbc40 0000000000000000
    [ 1915.935890]  ffffc900044fbc30 ffffffffac059bcb 000007e6044fbc60 ffff8801626e3198
    [ 1915.935937]  ffff8801626e0000 0000000000000002 ffffffffc05e5d4e 0000000000000000
    [ 1915.935985] Call Trace:
    [ 1915.936013]  [<ffffffffac3220bc>] dump_stack+0x4f/0x73
    [ 1915.936038]  [<ffffffffac059bcb>] __warn+0xcb/0xf0
    [ 1915.936060]  [<ffffffffac059c4f>] warn_slowpath_fmt+0x5f/0x80
    [ 1915.936158]  [<ffffffffc052d916>] i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.936251]  [<ffffffffc04f1c74>] intel_runtime_suspend+0x64/0x280 [i915]
    [ 1915.936277]  [<ffffffffac0926f1>] ? dequeue_entity+0x241/0xbc0
    [ 1915.936298]  [<ffffffffac36bb85>] pci_pm_runtime_suspend+0x55/0x180
    [ 1915.936317]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936339]  [<ffffffffac4514e2>] __rpm_callback+0x32/0x70
    [ 1915.936356]  [<ffffffffac451544>] rpm_callback+0x24/0x80
    [ 1915.936375]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936392]  [<ffffffffac45222d>] rpm_suspend+0x12d/0x680
    [ 1915.936415]  [<ffffffffac69f6d7>] ? _raw_spin_unlock_irq+0x17/0x30
    [ 1915.936435]  [<ffffffffac0810b8>] ? finish_task_switch+0x88/0x220
    [ 1915.936455]  [<ffffffffac4534bf>] pm_runtime_work+0x6f/0xb0
    [ 1915.936477]  [<ffffffffac074353>] process_one_work+0x1f3/0x4d0
    [ 1915.936501]  [<ffffffffac074678>] worker_thread+0x48/0x4e0
    [ 1915.936523]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936542]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936559]  [<ffffffffac07a2c9>] kthread+0xd9/0xf0
    [ 1915.936580]  [<ffffffffac07a1f0>] ? kthread_park+0x60/0x60
    [ 1915.936600]  [<ffffffffac69fe62>] ret_from_fork+0x22/0x30
    
    In the case the register is pinned, it should be present and we will
    need to invalidate them to be restored upon resume as we cannot expect
    the owner of the pin to call get_fence prior to use after resume.
    
    Fixes: 7c108fd8feac ("drm/i915: Move fence cancellation to runtime suspend")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98804
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Imre Deak <imre.deak@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: <drm-intel-fixes@lists.freedesktop.org> # v4.10-rc1+
    Link: http://patchwork.freedesktop.org/patch/msgid/20170203125717.8431-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    (cherry picked from commit e0ec3ec698851a6c97a12d696407b3ff77700c23)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8d6309865fa5..728ca3ea74d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2428,6 +2428,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	i915_gem_init_swizzling(dev_priv);
+	i915_gem_restore_fences(dev_priv);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 

commit 853277481178fdf14d1a4e9e6ac7174d6046176f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Feb 1 15:46:09 2017 +0200

    drm/i915: don't warn about Skylake CPU - KabyPoint PCH combo
    
    Apparently there are machines out there with Skylake CPU and KabyPoint
    PCH. Judging from our driver code, there doesn't seem to be any code
    paths that would do anything different between SunrisePoint and
    KabyPoint PCHs, so it would seem okay to accept the combo without
    warnings.
    
    Fixes: 22dea0be50b2 ("drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.")
    References: https://lists.freedesktop.org/archives/intel-gfx/2017-February/118611.html
    Reported-by: Rainer Koenig <Rainer.Koenig@ts.fujitsu.com>
    Cc: Rainer Koenig <Rainer.Koenig@ts.fujitsu.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: <stable@vger.kernel.org> # v4.8+
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1485956769-26015-1-git-send-email-jani.nikula@intel.com
    (cherry picked from commit 3aac4acb89710fe782c9e78e7b1febf76e112c6c)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b2c4a0b8a627..8d6309865fa5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -213,7 +213,8 @@ static void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
-				WARN_ON(!IS_KABYLAKE(dev_priv));
+				WARN_ON(!IS_SKYLAKE(dev_priv) &&
+					!IS_KABYLAKE(dev_priv));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit e0ec3ec698851a6c97a12d696407b3ff77700c23
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 3 12:57:17 2017 +0000

    drm/i915: Remove overzealous fence warn on runtime suspend
    
    The goal of the WARN was to catch when we are still actively using the
    fence as we go into the runtime suspend. However, the reg->pin_count is
    too coarse as it does not distinguish between exclusive ownership of the
    fence register from activity.
    
    I've not improved on the WARN, nor have we captured this WARN in an
    exact igt, but it is showing up regularly in the wild:
    
    [ 1915.935332] WARNING: CPU: 1 PID: 10861 at drivers/gpu/drm/i915/i915_gem.c:2022 i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.935383] WARN_ON(reg->pin_count)[ 1915.935399] Modules linked in:
     snd_hda_intel i915 drm_kms_helper vgem netconsole scsi_transport_iscsi fuse vfat fat x86_pkg_temp_thermal coretemp intel_cstate intel_uncore snd_hda_codec_hdmi snd_hda_codec_generic snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mei_me mei serio_raw intel_rapl_perf intel_pch_thermal soundcore wmi acpi_pad i2c_algo_bit syscopyarea sysfillrect sysimgblt fb_sys_fops drm r8169 mii video [last unloaded: drm_kms_helper]
    [ 1915.935785] CPU: 1 PID: 10861 Comm: kworker/1:0 Tainted: G     U  W       4.9.0-rc5+ #170
    [ 1915.935799] Hardware name: LENOVO 80MX/Lenovo E31-80, BIOS DCCN34WW(V2.03) 12/01/2015
    [ 1915.935822] Workqueue: pm pm_runtime_work
    [ 1915.935845]  ffffc900044fbbf0 ffffffffac3220bc ffffc900044fbc40 0000000000000000
    [ 1915.935890]  ffffc900044fbc30 ffffffffac059bcb 000007e6044fbc60 ffff8801626e3198
    [ 1915.935937]  ffff8801626e0000 0000000000000002 ffffffffc05e5d4e 0000000000000000
    [ 1915.935985] Call Trace:
    [ 1915.936013]  [<ffffffffac3220bc>] dump_stack+0x4f/0x73
    [ 1915.936038]  [<ffffffffac059bcb>] __warn+0xcb/0xf0
    [ 1915.936060]  [<ffffffffac059c4f>] warn_slowpath_fmt+0x5f/0x80
    [ 1915.936158]  [<ffffffffc052d916>] i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.936251]  [<ffffffffc04f1c74>] intel_runtime_suspend+0x64/0x280 [i915]
    [ 1915.936277]  [<ffffffffac0926f1>] ? dequeue_entity+0x241/0xbc0
    [ 1915.936298]  [<ffffffffac36bb85>] pci_pm_runtime_suspend+0x55/0x180
    [ 1915.936317]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936339]  [<ffffffffac4514e2>] __rpm_callback+0x32/0x70
    [ 1915.936356]  [<ffffffffac451544>] rpm_callback+0x24/0x80
    [ 1915.936375]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936392]  [<ffffffffac45222d>] rpm_suspend+0x12d/0x680
    [ 1915.936415]  [<ffffffffac69f6d7>] ? _raw_spin_unlock_irq+0x17/0x30
    [ 1915.936435]  [<ffffffffac0810b8>] ? finish_task_switch+0x88/0x220
    [ 1915.936455]  [<ffffffffac4534bf>] pm_runtime_work+0x6f/0xb0
    [ 1915.936477]  [<ffffffffac074353>] process_one_work+0x1f3/0x4d0
    [ 1915.936501]  [<ffffffffac074678>] worker_thread+0x48/0x4e0
    [ 1915.936523]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936542]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936559]  [<ffffffffac07a2c9>] kthread+0xd9/0xf0
    [ 1915.936580]  [<ffffffffac07a1f0>] ? kthread_park+0x60/0x60
    [ 1915.936600]  [<ffffffffac69fe62>] ret_from_fork+0x22/0x30
    
    In the case the register is pinned, it should be present and we will
    need to invalidate them to be restored upon resume as we cannot expect
    the owner of the pin to call get_fence prior to use after resume.
    
    Fixes: 7c108fd8feac ("drm/i915: Move fence cancellation to runtime suspend")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98804
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Imre Deak <imre.deak@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: <drm-intel-fixes@lists.freedesktop.org> # v4.10-rc1+
    Link: http://patchwork.freedesktop.org/patch/msgid/20170203125717.8431-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 276676b2bbc8..78191e00a00c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2475,6 +2475,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	i915_gem_init_swizzling(dev_priv);
+	i915_gem_restore_fences(dev_priv);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 

commit 26f837e8e1ec9748b55be3af6d7f54b9ad5a43b1
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Fri Jan 13 10:46:09 2017 +0800

    drm/i915: make intel_gvt_init() later instead of too early
    
    Previously intel_gvt_init() was called very early even before
    MMIO initialization which had several drawbacks:
    - Have to handle MMIO access for initial MMIO state dump if golden
      state firmware is not available
    - Hypervisor detection should depend on pvinfo only instead of detecting
      hypervisor status.
    - Don't know hw resource size e.g aperture, ggtt size to determine
      for vGPU type, etc.
    
    This trys to move intel_gvt_init() call late after required info
    has already been initialized for GVT host.
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4ae69ebe166e..1dfc0b204a72 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -824,10 +824,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	if (ret < 0)
 		return ret;
 
-	ret = intel_gvt_init(dev_priv);
-	if (ret < 0)
-		goto err_workqueues;
-
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
 
@@ -841,7 +837,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_audio_hooks(dev_priv);
 	ret = i915_gem_load_init(dev_priv);
 	if (ret < 0)
-		goto err_gvt;
+		goto err_workqueues;
 
 	intel_display_crc_init(dev_priv);
 
@@ -853,8 +849,6 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	return 0;
 
-err_gvt:
-	intel_gvt_cleanup(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 	return ret;
@@ -1077,6 +1071,10 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 			DRM_DEBUG_DRIVER("can't enable MSI");
 	}
 
+	ret = intel_gvt_init(dev_priv);
+	if (ret)
+		goto out_ggtt;
+
 	return 0;
 
 out_ggtt:
@@ -1290,6 +1288,8 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
 
+	intel_gvt_cleanup(dev_priv);
+
 	i915_driver_unregister(dev_priv);
 
 	drm_vblank_cleanup(dev);

commit 1e94320ffee29424ef70cdbb7f5601216382b7e6
Merge: e1b239f371c0 f3d83317a69e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 7 09:38:44 2017 +0100

    Merge branch 'for-linus' into for-next

commit 3aac4acb89710fe782c9e78e7b1febf76e112c6c
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Feb 1 15:46:09 2017 +0200

    drm/i915: don't warn about Skylake CPU - KabyPoint PCH combo
    
    Apparently there are machines out there with Skylake CPU and KabyPoint
    PCH. Judging from our driver code, there doesn't seem to be any code
    paths that would do anything different between SunrisePoint and
    KabyPoint PCHs, so it would seem okay to accept the combo without
    warnings.
    
    Fixes: 22dea0be50b2 ("drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.")
    References: https://lists.freedesktop.org/archives/intel-gfx/2017-February/118611.html
    Reported-by: Rainer Koenig <Rainer.Koenig@ts.fujitsu.com>
    Cc: Rainer Koenig <Rainer.Koenig@ts.fujitsu.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: <stable@vger.kernel.org> # v4.8+
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1485956769-26015-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0667f480df97..276676b2bbc8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -214,7 +214,8 @@ static void intel_detect_pch(struct drm_i915_private *dev_priv)
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
-				WARN_ON(!IS_KABYLAKE(dev_priv));
+				WARN_ON(!IS_SKYLAKE(dev_priv) &&
+					!IS_KABYLAKE(dev_priv));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit a667fb402c1e856209bf9e77ba41fc1cf356b867
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Dec 15 15:29:44 2016 +0100

    drm/i915: Disable all crtcs during driver unload, v2.
    
    We may keep the crtc's enabled when userspace unsets all framebuffers but
    keeps the crtc active. This exposes a WARN in fbc_global disable, and
    a lot of bugs in our hardware readout code. Solve this by disabling
    all crtc's for now.
    
    Changes since v1:
    - Use lock_all_ctx instead of lock_all.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481812185-19098-4-git-send-email-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0e99cb22362c..0667f480df97 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -43,6 +43,7 @@
 
 #include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
 #include <drm/i915_drm.h>
 
 #include "i915_drv.h"
@@ -1307,6 +1308,8 @@ void i915_driver_unload(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
+	struct drm_modeset_acquire_ctx ctx;
+	int ret;
 
 	intel_fbdev_fini(dev);
 
@@ -1315,6 +1318,24 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
 
+	drm_modeset_acquire_init(&ctx, 0);
+	while (1) {
+		ret = drm_modeset_lock_all_ctx(dev, &ctx);
+		if (!ret)
+			ret = drm_atomic_helper_disable_all(dev, &ctx);
+
+		if (ret != -EDEADLK)
+			break;
+
+		drm_modeset_backoff(&ctx);
+	}
+
+	if (ret)
+		DRM_ERROR("Disabling all crtc's during unload failed with %i\n", ret);
+
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+
 	i915_driver_unregister(dev_priv);
 
 	drm_vblank_cleanup(dev);

commit 0102ba1fd8af8c2719436eaadc743f940ab525c2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 30 10:44:58 2017 +0000

    drm/i915: Add early BXT sdv to the list of preproduction machines
    
    Extend intel_detect_preproduction_hw() to include BXT A and B steppings.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: "Zanoni, Paulo R" <paulo.r.zanoni@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170130104458.2653-3-chris@chris-wilson.co.uk
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0f5dbd434991..0e99cb22362c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -783,6 +783,7 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 
 	pre |= IS_HSW_EARLY_SDV(dev_priv);
 	pre |= IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0);
+	pre |= IS_BXT_REVID(dev_priv, 0, BXT_REVID_B_LAST);
 
 	if (pre) {
 		DRM_ERROR("This is a pre-production stepping. "

commit 7c5ff4a2c588c89d00ab0e0dd61f44942233d63d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 30 10:44:57 2017 +0000

    drm/i915: Mark the kernel as tainted if we fail the preproduction check
    
    Preproduction sdv are not supported beyond the release of production
    hardware, and continued use is ill-advised. Mark the kernel as tainted
    to reinforce the error.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: "Zanoni, Paulo R" <paulo.r.zanoni@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170130104458.2653-2-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b960aa929070..0f5dbd434991 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -784,9 +784,11 @@ static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 	pre |= IS_HSW_EARLY_SDV(dev_priv);
 	pre |= IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0);
 
-	if (pre)
+	if (pre) {
 		DRM_ERROR("This is a pre-production stepping. "
 			  "It may not be fully functional.\n");
+		add_taint(TAINT_MACHINE_CHECK, LOCKDEP_STILL_OK);
+	}
 }
 
 /**

commit 248a124d6fc0fde44b8fafc695ca4a2c24eb0856
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 30 10:44:56 2017 +0000

    drm/i915: Make intel_detect_preproduction_hw easier to extend
    
    As we add new generations, we should keep detecting new pre-production
    system development platforms that were temporarily enabled to facilitate
    initial development and now superseded by production systems. To make
    it easier to add more platforms, split the if into a series of logical
    operations.
    
    v2: s/sdv/pre/ - not all system development vehicles are for
    preproduction usage.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: "Zanoni, Paulo R" <paulo.r.zanoni@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170130104458.2653-1-chris@chris-wilson.co.uk
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3aa5bf58cf32..b960aa929070 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -779,8 +779,12 @@ static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
  */
 static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
 {
-	if (IS_HSW_EARLY_SDV(dev_priv) ||
-	    IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0))
+	bool pre = false;
+
+	pre |= IS_HSW_EARLY_SDV(dev_priv);
+	pre |= IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0);
+
+	if (pre)
 		DRM_ERROR("This is a pre-production stepping. "
 			  "It may not be fully functional.\n");
 }

commit fec0445caa273209d2809760ac7c63e743d6f512
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 27 09:40:08 2017 +0000

    drm/i915: Support explicit fencing for execbuf
    
    Now that the user can opt-out of implicit fencing, we need to give them
    back control over the fencing. We employ sync_file to wrap our
    drm_i915_gem_request and provide an fd that userspace can merge with
    other sync_file fds and pass back to the kernel to wait upon before
    future execution.
    
    Testcase: igt/gem_exec_fence
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Chad Versace <chadversary@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127094008.27489-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c9c2037fadf..3aa5bf58cf32 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -350,6 +350,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
 	case I915_PARAM_HAS_EXEC_SOFTPIN:
 	case I915_PARAM_HAS_EXEC_ASYNC:
+	case I915_PARAM_HAS_EXEC_FENCE:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from
@@ -2550,7 +2551,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_HWS_ADDR, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, i915_gem_execbuffer, DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2, i915_gem_execbuffer2, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2_WR, i915_gem_execbuffer2, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_PIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_UNPIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),

commit 77ae9957897df86e627089688265e0db029dd0df
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 27 09:40:07 2017 +0000

    drm/i915: Enable userspace to opt-out of implicit fencing
    
    Userspace is faced with a dilemma. The kernel requires implicit fencing
    to manage resource usage (we always must wait for the GPU to finish
    before releasing its PTE) and for third parties. However, userspace may
    wish to avoid this serialisation if it is either using explicit fencing
    between parties and wants more fine-grained access to buffers (e.g. it
    may partition the buffer between uses and track fences on ranges rather
    than the implicit fences tracking the whole object). It follows that
    userspace needs a mechanism to avoid the kernel's serialisation on its
    implicit fences before execbuf execution.
    
    The next question is whether this is an object, execbuf or context flag.
    Hybrid users (such as using explicit EGL_ANDROID_native_sync fencing on
    shared winsys buffers, but implicit fencing on internal surfaces)
    require a per-object level flag. Given that this flag need to be only
    set once for the lifetime of the object, this reduces the convenience of
    having an execbuf or context level flag (and avoids having multiple
    pieces of uABI controlling the same feature).
    
    Incorrect use of this flag will result in rendering corruption and GPU
    hangs - but will not result in use-after-free or similar resource
    tracking issues.
    
    Serious caveat: write ordering is not strictly correct after setting
    this flag on a render target on multiple engines. This affects all
    subsequent GEM operations (execbuf, set-domain, pread) and shared
    dma-buf operations. A fix is possible - but costly (both in terms of
    further ABI changes and runtime overhead).
    
    Testcase: igt/gem_exec_async
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Chad Versace <chadversary@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127094008.27489-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 507a6f69426f..6c9c2037fadf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -349,6 +349,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
 	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
 	case I915_PARAM_HAS_EXEC_SOFTPIN:
+	case I915_PARAM_HAS_EXEC_ASYNC:
 		/* For the time being all of these are always true;
 		 * if some supported hardware does not have one of these
 		 * features this value needs to be provided from

commit eef57324d926f0d8c7a40069e7d26e0cb0651b47
Author: Jerome Anand <jerome.anand@intel.com>
Date:   Wed Jan 25 04:27:49 2017 +0530

    drm/i915: setup bridge for HDMI LPE audio driver
    
    Enable support for HDMI LPE audio mode on Baytrail and
    Cherrytrail when HDaudio controller is not detected
    
    Setup minimum required resources during i915_driver_load:
    1. Create a platform device to share MMIO/IRQ resources
    2. Make the platform device child of i915 device for runtime PM.
    3. Create IRQ chip to forward HDMI LPE audio irqs.
    
    HDMI LPE audio driver (a standalone sound driver) probes the
    LPE audio device and creates a new sound card.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Jerome Anand <jerome.anand@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 445fec9c2841..9b8d81fa0441 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1138,7 +1138,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	if (IS_GEN5(dev_priv))
 		intel_gpu_ips_init(dev_priv);
 
-	i915_audio_component_init(dev_priv);
+	intel_audio_init(dev_priv);
 
 	/*
 	 * Some ports require correctly set-up hpd registers for detection to
@@ -1156,7 +1156,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 {
-	i915_audio_component_cleanup(dev_priv);
+	intel_audio_deinit(dev_priv);
 
 	intel_gpu_ips_teardown();
 	acpi_video_unregister();

commit 21d6e0bde50713922a6520ef84e5fd245b05d468
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Fri Jan 20 16:28:43 2017 +0200

    drm/i915: Don't init hpd polling for vlv and chv from runtime_suspend()
    
    An error in the condition for avoiding the call to intel_hpd_poll_init()
    for valleyview and cherryview from intel_runtime_suspend() caused it to
    be called unconditionally. Fix it.
    
    Fixes: 19625e85c6ec ("drm/i915: Enable polling when we don't have hpd")
    Cc: stable@vger.kernel.org
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Lyude <cpaul@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: <stable@vger.kernel.org> # v4.9+
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484922525-6131-2-git-send-email-ander.conselvan.de.oliveira@intel.com
    (cherry picked from commit 04313b00b79405f86d815100f85c47a2ee5b8ca0)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 445fec9c2841..b2c4a0b8a627 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2378,7 +2378,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	assert_forcewakes_inactive(dev_priv);
 
-	if (!IS_VALLEYVIEW(dev_priv) || !IS_CHERRYVIEW(dev_priv))
+	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_poll_init(dev_priv);
 
 	DRM_DEBUG_KMS("Device suspended\n");

commit 241455172b8683f65a325490baf2d8dd683b3832
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 24 11:01:35 2017 +0000

    drm/i915: Reset the gpu on takeover
    
    The GPU may be in an unknown state following resume and module load. The
    previous occupant may have left contexts loaded, or other dangerous
    state, which can cause an immediate GPU hang for us. The only save
    course of action is to reset the GPU prior to using it - similarly to
    how we reset the GPU prior to unload (before a second user may be
    affected by our leftover state).
    
    We need to reset the GPU very early in our load/resume sequence so that
    any stale HW pointers are revoked prior to any resource allocations we
    make (that may conflict).
    
    A reset should only be a couple of milliseconds on a slow device, a cost
    we should easily be able to absorb into our initialisation times.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170124110135.6418-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f8d1ffeccc69..507a6f69426f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -950,6 +950,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 		goto put_bridge;
 
 	intel_uncore_init(dev_priv);
+	i915_gem_init_mmio(dev_priv);
 
 	return 0;
 
@@ -1731,6 +1732,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
 
+	i915_gem_sanitize(dev_priv);
+
 	enable_rpm_wakeref_asserts(dev_priv);
 
 out:

commit bb8f0f5abdd7845175962a3fb99a5681290f9566
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 24 11:01:34 2017 +0000

    drm/i915: Split intel_engine allocation and initialisation
    
    In order to reset the GPU early on in the module load sequence, we need
    to allocate the basic engine structs (to populate the mmio offsets etc).
    Currently, the engine initialisation allocates both the base struct and
    also allocate auxiliary objects, which depend upon state setup quite
    late in the load sequence. We split off the allocation callback for
    later and allow ourselves to allocate the engine structs themselves
    early.
    
    v2: Different paint for the unwind following error.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170124110135.6418-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca168b22ee26..f8d1ffeccc69 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -755,6 +755,15 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 	return -ENOMEM;
 }
 
+static void i915_engines_cleanup(struct drm_i915_private *i915)
+{
+	struct intel_engine_cs *engine;
+	enum intel_engine_id id;
+
+	for_each_engine(engine, i915, id)
+		kfree(engine);
+}
+
 static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
 {
 	destroy_workqueue(dev_priv->hotplug.dp_wq);
@@ -817,12 +826,15 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->pps_mutex);
 
 	intel_uc_init_early(dev_priv);
-
 	i915_memcpy_init_early(dev_priv);
 
+	ret = intel_engines_init_early(dev_priv);
+	if (ret)
+		return ret;
+
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
-		return ret;
+		goto err_engines;
 
 	ret = intel_gvt_init(dev_priv);
 	if (ret < 0)
@@ -857,6 +869,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_gvt_cleanup(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
+err_engines:
+	i915_engines_cleanup(dev_priv);
 	return ret;
 }
 
@@ -869,6 +883,7 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 	i915_perf_fini(dev_priv);
 	i915_gem_load_cleanup(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
+	i915_engines_cleanup(dev_priv);
 }
 
 static int i915_mmio_setup(struct drm_i915_private *dev_priv)

commit 04313b00b79405f86d815100f85c47a2ee5b8ca0
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Fri Jan 20 16:28:43 2017 +0200

    drm/i915: Don't init hpd polling for vlv and chv from runtime_suspend()
    
    An error in the condition for avoiding the call to intel_hpd_poll_init()
    for valleyview and cherryview from intel_runtime_suspend() caused it to
    be called unconditionally. Fix it.
    
    Fixes: 19625e85c6ec ("drm/i915: Enable polling when we don't have hpd")
    Cc: stable@vger.kernel.org
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Lyude <cpaul@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: <stable@vger.kernel.org> # v4.9+
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484922525-6131-2-git-send-email-ander.conselvan.de.oliveira@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4ae69ebe166e..ca168b22ee26 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2377,7 +2377,7 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	assert_forcewakes_inactive(dev_priv);
 
-	if (!IS_VALLEYVIEW(dev_priv) || !IS_CHERRYVIEW(dev_priv))
+	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_poll_init(dev_priv);
 
 	DRM_DEBUG_KMS("Device suspended\n");

commit 5464cd657632502c61c64775dffef1cc7ebd4839
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Wed Jan 18 08:05:58 2017 -0800

    drm/i915/get_params: Add HuC status to getparams
    
    This patch will allow for getparams to return the status of the HuC.
    As the HuC has to be validated by the GuC this patch uses the validated
    status to show when the HuC is loaded and ready for use. You cannot use
    the loaded status as with the GuC as the HuC is verified after it is
    loaded and is not usable until it is verified.
    
    v2: removed the forewakes as the registers are already force-woken.
         (T.Ursulin)
    v3: rebased on top of drm-tip. Removed any reference to intel_huc.h
    v4: rebased. Rename I915_PARAM_HAS_HUC to I915_PARAM_HUC_STATUS.
    Remove intel_is_huc_valid() since it is used only in one place.
    Put the case of I915_PARAM_HAS_HUC() in the right place.
    v5: rebased. Add a comment to specify that I915_READ(reg)
    does not read garbage value. The register HUC_STATUS2 is force
    woken and no rpm is needed.
    
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484755558-1234-6-git-send-email-anusha.srivatsa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d1197aa68af5..4ae69ebe166e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,7 @@
 #include "i915_trace.h"
 #include "i915_vgpu.h"
 #include "intel_drv.h"
+#include "intel_uc.h"
 
 static struct drm_driver driver;
 
@@ -315,6 +316,12 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_MIN_EU_IN_POOL:
 		value = INTEL_INFO(dev_priv)->sseu.min_eu_in_pool;
 		break;
+	case I915_PARAM_HUC_STATUS:
+		/* The register is already force-woken. We dont need
+		 * any rpm here
+		 */
+		value = I915_READ(HUC_STATUS2) & HUC_FW_VERIFIED;
+		break;
 	case I915_PARAM_MMAP_GTT_VERSION:
 		/* Though we've started our numbering from 1, and so class all
 		 * earlier versions as 0, in effect their value is undefined as

commit bd132858e9f9ad1c03a7d4982deaac7f0c0a4f0d
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Wed Jan 18 08:05:53 2017 -0800

    drm/i915/huc: Add HuC fw loading support
    
    The HuC loading process is similar to GuC. The intel_uc_fw_fetch()
    is used for both cases.
    
    HuC loading needs to be before GuC loading. The WOPCM setting must
    be done early before loading any of them.
    
    v2: rebased on-top of drm-intel-nightly.
        removed if(HAS_GUC()) before the guc call. (D.Gordon)
        update huc_version number of format.
    v3: rebased to drm-intel-nightly, changed the file name format to
        match the one in the huc package.
        Changed dev->dev_private to to_i915()
    v4: moved function back to where it was.
        change wait_for_atomic to wait_for.
    v5: rebased. Changed the year in the copyright message to reflect
    the right year.Correct the comments,remove the unwanted WARN message,
    replace drm_gem_object_unreference() with i915_gem_object_put().Make the
    prototypes in intel_huc.h non-extern.
    v6: rebased. Update the file construction done by HuC. It is similar to
    GuC.Adopted the approach used in-
    https://patchwork.freedesktop.org/patch/104355/ <Tvrtko Ursulin>
    v7: Change dev to dev_priv in macro definition.
    Corrected comments.
    v8: rebased on top of drm-tip. Updated functions intel_huc_load(),
    intel_huc_init() and intel_uc_fw_fetch() to accept dev_priv instead of
    dev. Moved contents of intel_huc.h to intel_uc.h.
    v9: change SKL_FW_ to SKL_HUC_FW_. Add intel_ prefix to guc_wopcm_size().
    Remove unwanted checks in intel_uc.h. Rename huc_fw in struct intel_huc to
    simply fw to avoid redundency.
    v10: rebased. Correct comments. Make intel_huc_fini() accept dev_priv
    instead of dev like intel_huc_init() and intel_huc_load().Move definition
    to i915_guc_reg.h from intel_uc.h. Clean DMA_CTRL bits after HuC DMA
    transfer in huc_ucode_xfer() instead of guc_ucode_xfer(). Add suitable
    WARNs to give extra info.
    v11: rebased. Add proper bias for HuC and make sure there are
    asserts on failure by using guc_ggtt_offset_vma(). Introduce
    intel_huc.c and remove intel_huc_loader.c since it has functions that
    do more than just loading.Correct year in copyright.
    v12: remove invalidates that are not required anymore.
    
    Cc: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Tested-by: Xiang Haihao <haihao.xiang@intel.com>
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Alex Dai <yu.dai@intel.com>
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484755558-1234-1-git-send-email-anusha.srivatsa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 348dec482502..d1197aa68af5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -599,6 +599,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_irq;
 
+	intel_huc_init(dev_priv);
 	intel_guc_init(dev_priv);
 
 	ret = i915_gem_init(dev_priv);
@@ -627,6 +628,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	i915_gem_fini(dev_priv);
 cleanup_irq:
 	intel_guc_fini(dev_priv);
+	intel_huc_fini(dev_priv);
 	drm_irq_uninstall(dev);
 	intel_teardown_gmbus(dev_priv);
 cleanup_csr:
@@ -1314,6 +1316,7 @@ void i915_driver_unload(struct drm_device *dev)
 	drain_workqueue(dev_priv->wq);
 
 	intel_guc_fini(dev_priv);
+	intel_huc_fini(dev_priv);
 	i915_gem_fini(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 

commit 0e178aef8f13ff11dc9dec82c2cd849981cb1ad1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 17 17:59:06 2017 +0200

    drm/i915: Detect a failed GPU reset+recovery
    
    If we can't recover the GPU after the reset, mark it as wedged to cancel
    the outstanding tasks and to prevent new users from trying to use the
    broken GPU.
    
    v2: Check the same ring is hung again before declaring the reset broken.
    v3: use engine_stalled (Mika)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484668747-9120-6-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fbad2b64b890..348dec482502 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1761,7 +1761,12 @@ void i915_reset(struct drm_i915_private *dev_priv)
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
 	disable_irq(dev_priv->drm.irq);
-	i915_gem_reset_prepare(dev_priv);
+	ret = i915_gem_reset_prepare(dev_priv);
+	if (ret) {
+		DRM_ERROR("GPU recovery failed\n");
+		intel_gpu_reset(dev_priv, ALL_ENGINES);
+		goto error;
+	}
 
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
 	if (ret) {

commit 4c9655436522eaf4ba35572851150ccb71f3866e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 17 17:59:01 2017 +0200

    drm/i915: Move engine reset preparation to i915_gem_reset_prepare()
    
    Now that we have prepare/finish routines for the GEM reset, move the
    disabling of the engine->irq_tasklet into them to reduce repetition. The
    device irq enable/disable is split out to ensure it is run first and
    last always (even if the GPU reset fails).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484668747-9120-1-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 350ee06c8d05..fbad2b64b890 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1728,22 +1728,6 @@ static int i915_resume_switcheroo(struct drm_device *dev)
 	return i915_drm_resume(dev);
 }
 
-static void disable_engines_irq(struct drm_i915_private *dev_priv)
-{
-	struct intel_engine_cs *engine;
-	enum intel_engine_id id;
-
-	/* Ensure irq handler finishes, and not run again. */
-	disable_irq(dev_priv->drm.irq);
-	for_each_engine(engine, dev_priv, id)
-		tasklet_kill(&engine->irq_tasklet);
-}
-
-static void enable_engines_irq(struct drm_i915_private *dev_priv)
-{
-	enable_irq(dev_priv->drm.irq);
-}
-
 /**
  * i915_reset - reset chip after a hang
  * @dev_priv: device private to reset
@@ -1776,12 +1760,10 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
+	disable_irq(dev_priv->drm.irq);
 	i915_gem_reset_prepare(dev_priv);
 
-	disable_engines_irq(dev_priv);
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
-	enable_engines_irq(dev_priv);
-
 	if (ret) {
 		if (ret != -ENODEV)
 			DRM_ERROR("Failed to reset chip: %i\n", ret);
@@ -1816,6 +1798,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	i915_queue_hangcheck(dev_priv);
 
 wakeup:
+	enable_irq(dev_priv->drm.irq);
 	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
 	return;
 

commit f9cda04867804e232987a2bc8832ee109907ed6f
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Jan 13 17:41:57 2017 +0000

    drm/i915/guc: Move GuC log related functions into dedicated file
    
    Functions supporting GuC logging capabilities were spread across
    many files, with unnecessary exposures and mixed with unrelated
    code. Dedicate file will make maintenance of all GuC functions
    easier as more functions are coming to support GuC submissions.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170113174157.104492-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4e5ea5898e06..350ee06c8d05 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1114,7 +1114,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
 		i915_debugfs_register(dev_priv);
-		i915_guc_register(dev_priv);
+		i915_guc_log_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
 
 		/* Depends on sysfs having been initialized */
@@ -1158,7 +1158,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	i915_perf_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
-	i915_guc_unregister(dev_priv);
+	i915_guc_log_unregister(dev_priv);
 	i915_debugfs_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 

commit df2105749a8a0b7f7da8b2fb0b9cee1b3008586b
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Wed Jan 11 20:18:09 2017 -0800

    drm/i915: Update i915_reset parameter for kerneldoc
    
    Since commit c033666a94b57 ("drm/i915: Store a i915 backpointer from
    engine, and use it") i915_reset receives dev_priv, but the kerneldoc
    was not updated.
    
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170112041817.1102-3-michel.thierry@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aefab9a1a68e..4e5ea5898e06 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1746,7 +1746,7 @@ static void enable_engines_irq(struct drm_i915_private *dev_priv)
 
 /**
  * i915_reset - reset chip after a hang
- * @dev: drm device to reset
+ * @dev_priv: device private to reset
  *
  * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
  * on failure.

commit 111dbcab3d5baf5ef7a377471dbd10c23484f11d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 10 12:10:44 2017 +0000

    drm/i915: Include ioctl in set-tiling and get-tiling function names
    
    Make it clear that these functions are the user entry points for
    the tiling/fence registers.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170110121045.27144-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8001fd1165e0..aefab9a1a68e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2549,8 +2549,8 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP_GTT, i915_gem_mmap_gtt_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SET_DOMAIN, i915_gem_set_domain_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_SW_FINISH, i915_gem_sw_finish_ioctl, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(I915_GEM_GET_TILING, i915_gem_get_tiling, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_GET_TILING, i915_gem_get_tiling_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_GET_APERTURE, i915_gem_get_aperture_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id, 0),
 	DRM_IOCTL_DEF_DRV(I915_GEM_MADVISE, i915_gem_madvise_ioctl, DRM_RENDER_ALLOW),

commit b9fd799e408f992060cb3e03150479661eb7a14d
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Dec 16 17:42:25 2016 +0200

    drm/i915/glk: Add missing bits to allow runtime pm suspend on GLK.
    
    Besides having the DMC firmware in place and loaded let's
    handle runtime suspend and dc9 as we do for Broxton.
    
    Cc: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481902946-18593-2-git-send-email-ander.conselvan.de.oliveira@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4d22b4b479b8..8001fd1165e0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1471,7 +1471,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	intel_display_set_init_power(dev_priv, false);
 
-	fw_csr = !IS_BROXTON(dev_priv) &&
+	fw_csr = !IS_GEN9_LP(dev_priv) &&
 		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
@@ -1484,7 +1484,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 		intel_power_domains_suspend(dev_priv);
 
 	ret = 0;
-	if (IS_BROXTON(dev_priv))
+	if (IS_GEN9_LP(dev_priv))
 		bxt_enable_dc9(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_enable_pc8(dev_priv);
@@ -1692,7 +1692,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_early_sanitize(dev_priv, true);
 
-	if (IS_BROXTON(dev_priv)) {
+	if (IS_GEN9_LP(dev_priv)) {
 		if (!dev_priv->suspended_to_idle)
 			gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
@@ -1702,7 +1702,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_sanitize(dev_priv);
 
-	if (IS_BROXTON(dev_priv) ||
+	if (IS_GEN9_LP(dev_priv) ||
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
 
@@ -2326,7 +2326,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
 	ret = 0;
-	if (IS_BROXTON(dev_priv)) {
+	if (IS_GEN9_LP(dev_priv)) {
 		bxt_display_core_uninit(dev_priv);
 		bxt_enable_dc9(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
@@ -2411,7 +2411,7 @@ static int intel_runtime_resume(struct device *kdev)
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev_priv);
 
-	if (IS_BROXTON(dev_priv)) {
+	if (IS_GEN9_LP(dev_priv)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);
 		if (dev_priv->csr.dmc_payload &&

commit b1ed35d9179bc42c5ac7b86548cfae589be17b3e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jan 4 14:51:10 2017 +0000

    drm/i915: Revoke fenced GTT mmapings across GPU reset
    
    The fence registers are clobbered by a GPU reset. If there is concurrent
    user access to a fenced region via a GTT mmaping, the access will not be
    fenced during the reset (until we restore the fences afterwards). In order
    to prevent invalid access during the reset, before we clobber the fences
    first we must invalidate the GTT mmapings. Access to the mmap will then
    be forced to fault in the page, and in handling the fault, i915_gem_fault()
    will take the struct_mutex and wait upon the reset to complete.
    
    v2: Fix up commentary.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99274
    Testcase: igt/gem_mmap_gtt/hang
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170104145110.1486-1-chris@chris-wilson.co.uk
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2c020eafada6..4d22b4b479b8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1776,6 +1776,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
+	i915_gem_reset_prepare(dev_priv);
 
 	disable_engines_irq(dev_priv);
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
@@ -1789,7 +1790,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	i915_gem_reset(dev_priv);
+	i915_gem_reset_finish(dev_priv);
 	intel_overlay_reset(dev_priv);
 
 	/* Ok, now get things going again... */

commit bdeb978506a7cf59ee75ed61a7b6a3506d03a1e4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Dec 23 14:57:56 2016 +0000

    drm/i915: Repeat flush of idle work during suspend
    
    The idle work handler is self-arming - if it detects that it needs to
    run again it will queue itself from its work handler. Take greater care
    when trying to drain the idle work, and double check that it is flushed.
    
    The free worker has a similar issue where it is armed by an RCU task
    which may be running concurrently with us.
    
    This should hopefully help with the sporadic WARN_ON(dev_priv->gt.awake)
    from i915_gem_suspend.
    
    v2: Reuse drain_freed_objects.
    v3: Don't try to flush the freed objects from the shrinker, as it may be
    underneath the struct_mutex already.
    v4: do while and comment upon the excess rcu_barrier in drain_freed_objects
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161223145804.6605-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6428588518aa..2c020eafada6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -545,8 +545,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	i915_gem_context_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
-	rcu_barrier();
-	flush_work(&dev_priv->mm.free_work);
+	i915_gem_drain_freed_objects(dev_priv);
 
 	WARN_ON(!list_empty(&dev_priv->context_list));
 }

commit 87a6752c43f28363b0fd330874dec20249292d2f
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Dec 6 19:04:13 2016 +0000

    drm/i915: Use DRM_DEV_ERROR in i915_driver_load
    
    Now that it is available we don't have to open code a similar
    error message ourselves.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481051053-29783-1-git-send-email-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d2cc28f6953d..6428588518aa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1190,8 +1190,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (dev_priv)
 		ret = drm_dev_init(&dev_priv->drm, &driver, &pdev->dev);
 	if (ret) {
-		dev_printk(KERN_ERR, &pdev->dev,
-			   "[" DRM_NAME ":%s] allocation failed\n", __func__);
+		DRM_DEV_ERROR(&pdev->dev, "allocation failed\n");
 		kfree(dev_priv);
 		return ret;
 	}

commit a3a8986cb22aafd83681b7e783ca6d4963712989
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Thu Dec 1 21:19:34 2016 +0530

    drm/i915/bxt: IPC WA for Broxton
    
    Display Workarounds #1135
    If IPC is enabled in BXT, display underruns are observed.
    WA: The Line Time programmed in the WM_LINETIME register should be
    half of the actual calculated Line Time.
    
    Programmed Line Time = 1/2*Calculated Line Time
    
    Changes since V1:
     - Add Workaround number in commit & code
    Changes since V2 (from Paulo):
     - Bikeshed white space and make the WA tag look like the others
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161201154940.24446-3-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5fe27e42d81b..d2cc28f6953d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1239,6 +1239,8 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	intel_runtime_pm_enable(dev_priv);
 
+	dev_priv->ipc_enabled = false;
+
 	/* Everything is in place, we can now relax! */
 	DRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",
 		 driver.name, driver.major, driver.minor, driver.patchlevel,

commit 467a14d935c6d95b94e4197bf63e264eab4c5d06
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Dec 5 16:13:28 2016 +0200

    drm/i915: Protect DSPARB registers with a spinlock
    
    Each DSPARB register can house bits for two separate pipes, hence
    we must protect the registers during reprogramming so that parallel
    FIFO reconfigurations happening simultaneosly on multiple pipes won't
    corrupt each others values.
    
    We'll use a new spinlock for this instead of the wm_mutex since we'll
    have to move the DSPARB programming to happen from the vblank evade
    critical section, and we can't use mutexes in there.
    
    v2: Document why we use a spinlock instead of a mutex (Maarten)
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1480947208-18468-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1a7ac2eefe97..5fe27e42d81b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -801,6 +801,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	spin_lock_init(&dev_priv->uncore.lock);
 	spin_lock_init(&dev_priv->mm.object_stat_lock);
 	spin_lock_init(&dev_priv->mmio_flip_lock);
+	spin_lock_init(&dev_priv->wm.dsparb_lock);
 	mutex_init(&dev_priv->sb_lock);
 	mutex_init(&dev_priv->modeset_restore_lock);
 	mutex_init(&dev_priv->av_mutex);

commit c0f86832e3fd0d125f22bf26040d24837d0412db
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Dec 7 12:13:04 2016 +0200

    drm/i915: rename BROADWATER and CRESTLINE to I965G and I965GM, respectively
    
    Add more consistency to our naming. Pineview remains the outlier. Keep
    using code names for gen5+.
    
    v2: rebased
    
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481105584-23033-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ae583c79c19f..1a7ac2eefe97 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1033,7 +1033,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * behaviour if any general state is accessed within a page above 4GB,
 	 * which also needs to be handled carefully.
 	 */
-	if (IS_BROADWATER(dev_priv) || IS_CRESTLINE(dev_priv)) {
+	if (IS_I965G(dev_priv) || IS_I965GM(dev_priv)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 
 		if (ret) {

commit a9a251c2aea5aaeb004eac4e6c2b86383347ce9f
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Fri Dec 2 10:24:11 2016 +0000

    drm/i915: make i915_suspend_switcheroo static
    
    Looks like this was missed when unexporting, so let's keep sparse happy.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Fixes: 7f26cb88014a ("drm/i915: Unexport VGA switcheroo functions")
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161202102411.19831-1-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ace9be8f6ff9..ae583c79c19f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1522,7 +1522,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	return ret;
 }
 
-int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
+static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 {
 	int error;
 

commit 192aa18142b28fdcb63b12984e02466ced382a54
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:45 2016 +0000

    drm/i915: Make intel_pm_setup take dev_priv
    
    Function actually wants dev_priv so give it to it.
    
    v2: Commit message. (Joonas Lahtinen)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1480601805-14391-2-git-send-email-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bd8994d02813..ace9be8f6ff9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -822,7 +822,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	/* This must be called before any calls to HAS_PCH_* */
 	intel_detect_pch(dev_priv);
 
-	intel_pm_setup(&dev_priv->drm);
+	intel_pm_setup(dev_priv);
 	intel_init_dpio(dev_priv);
 	intel_power_domains_init(dev_priv);
 	intel_irq_init(dev_priv);

commit af6dc7425b359519cdc9399b19029a037827dd21
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:44 2016 +0000

    drm/i915: Make i915_save/restore_state and intel_i2c_reset take dev_priv
    
    dev_priv is more appropriate since it is used much more in these.
    
    v2: Commit message and keep the local pdev variable. (Joonas Lahtinen)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 809315cad316..bd8994d02813 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1439,7 +1439,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	i915_gem_suspend_gtt_mappings(dev_priv);
 
-	i915_save_state(dev);
+	i915_save_state(dev_priv);
 
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
 	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
@@ -1562,7 +1562,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	i915_gem_resume(dev_priv);
 
-	i915_restore_state(dev);
+	i915_restore_state(dev_priv);
 	intel_pps_unlock_regs_wa(dev_priv);
 	intel_opregion_setup(dev_priv);
 

commit 12ff05e750dff5ae098e8b2803363d9707214735
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:43 2016 +0000

    drm/i915: Make i915_destroy_error_state take dev_priv
    
    Since it does not need dev at all.
    
    Also change the stored pointer in struct i915_error_state_file_priv
    to i915.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fee0b46a04bc..809315cad316 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1307,7 +1307,7 @@ void i915_driver_unload(struct drm_device *dev)
 
 	/* Free error state after interrupts are fully disabled. */
 	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
-	i915_destroy_error_state(dev);
+	i915_destroy_error_state(dev_priv);
 
 	/* Flush any outstanding unpin_work. */
 	drain_workqueue(dev_priv->wq);

commit 401964465f04f3c01dd7ddfe6b5149bc33eaa509
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:42 2016 +0000

    drm/i915: Make gmbus setup take dev_priv
    
    Simplify the code by passing the right argument in.
    
    v2: Commit message. (Joonas Lahtinen)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 362c8baef640..fee0b46a04bc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -592,7 +592,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_csr;
 
-	intel_setup_gmbus(dev);
+	intel_setup_gmbus(dev_priv);
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
@@ -629,7 +629,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 cleanup_irq:
 	intel_guc_fini(dev_priv);
 	drm_irq_uninstall(dev);
-	intel_teardown_gmbus(dev);
+	intel_teardown_gmbus(dev_priv);
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);
 	intel_power_domains_fini(dev_priv);

commit 7f26cb88014a748d03ecc0dcb6a5876f311b823d
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:41 2016 +0000

    drm/i915: Unexport VGA switcheroo functions
    
    They are only used in i915_drv.c so a forward declaration is enough.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1312cd5e4465..362c8baef640 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -497,6 +497,9 @@ static unsigned int i915_vga_set_decode(void *cookie, bool state)
 		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 }
 
+static int i915_resume_switcheroo(struct drm_device *dev);
+static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state);
+
 static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
 {
 	struct drm_device *dev = pci_get_drvdata(pdev);
@@ -1710,7 +1713,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-int i915_resume_switcheroo(struct drm_device *dev)
+static int i915_resume_switcheroo(struct drm_device *dev)
 {
 	int ret;
 

commit da5f53bf3c3ad5ffcb88b2892a9c02ece2ad140f
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:40 2016 +0000

    drm/i915: dev_priv cleanup in bridge/bar/mmio init code
    
    dev_priv is more appropriate for these so converting saves
    some lines of source.
    
    v2: Commit message and keep the pdev local variable. (Joonas Lahtinen)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 383bf1ac1bdd..1312cd5e4465 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -142,9 +142,8 @@ static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-static void intel_detect_pch(struct drm_device *dev)
+static void intel_detect_pch(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pch = NULL;
 
 	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
@@ -361,10 +360,8 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	return 0;
 }
 
-static int i915_get_bridge_dev(struct drm_device *dev)
+static int i915_get_bridge_dev(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
-
 	dev_priv->bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
 	if (!dev_priv->bridge_dev) {
 		DRM_ERROR("bridge device not found\n");
@@ -375,9 +372,8 @@ static int i915_get_bridge_dev(struct drm_device *dev)
 
 /* Allocate space for the MCH regs if needed, return nonzero on error */
 static int
-intel_alloc_mchbar_resource(struct drm_device *dev)
+intel_alloc_mchbar_resource(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	int reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp_lo, temp_hi = 0;
 	u64 mchbar_addr;
@@ -421,9 +417,8 @@ intel_alloc_mchbar_resource(struct drm_device *dev)
 
 /* Setup MCHBAR if possible, return true if we should disable it again */
 static void
-intel_setup_mchbar(struct drm_device *dev)
+intel_setup_mchbar(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	int mchbar_reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp;
 	bool enabled;
@@ -445,7 +440,7 @@ intel_setup_mchbar(struct drm_device *dev)
 	if (enabled)
 		return;
 
-	if (intel_alloc_mchbar_resource(dev))
+	if (intel_alloc_mchbar_resource(dev_priv))
 		return;
 
 	dev_priv->mchbar_need_disable = true;
@@ -461,9 +456,8 @@ intel_setup_mchbar(struct drm_device *dev)
 }
 
 static void
-intel_teardown_mchbar(struct drm_device *dev)
+intel_teardown_mchbar(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	int mchbar_reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 
 	if (dev_priv->mchbar_need_disable) {
@@ -493,9 +487,9 @@ intel_teardown_mchbar(struct drm_device *dev)
 /* true = enable decode, false = disable decoder */
 static unsigned int i915_vga_set_decode(void *cookie, bool state)
 {
-	struct drm_device *dev = cookie;
+	struct drm_i915_private *dev_priv = cookie;
 
-	intel_modeset_vga_set_state(to_i915(dev), state);
+	intel_modeset_vga_set_state(dev_priv, state);
 	if (state)
 		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
 		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
@@ -574,7 +568,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	 * then we do not take part in VGA arbitration and the
 	 * vga_client_register() fails with -ENODEV.
 	 */
-	ret = vga_client_register(pdev, dev, NULL, i915_vga_set_decode);
+	ret = vga_client_register(pdev, dev_priv, NULL, i915_vga_set_decode);
 	if (ret && ret != -ENODEV)
 		goto out;
 
@@ -823,7 +817,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 		goto err_workqueues;
 
 	/* This must be called before any calls to HAS_PCH_* */
-	intel_detect_pch(&dev_priv->drm);
+	intel_detect_pch(dev_priv);
 
 	intel_pm_setup(&dev_priv->drm);
 	intel_init_dpio(dev_priv);
@@ -865,9 +859,8 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 	i915_workqueues_cleanup(dev_priv);
 }
 
-static int i915_mmio_setup(struct drm_device *dev)
+static int i915_mmio_setup(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int mmio_bar;
 	int mmio_size;
@@ -893,17 +886,16 @@ static int i915_mmio_setup(struct drm_device *dev)
 	}
 
 	/* Try to make sure MCHBAR is enabled before poking at it */
-	intel_setup_mchbar(dev);
+	intel_setup_mchbar(dev_priv);
 
 	return 0;
 }
 
-static void i915_mmio_cleanup(struct drm_device *dev)
+static void i915_mmio_cleanup(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	intel_teardown_mchbar(dev);
+	intel_teardown_mchbar(dev_priv);
 	pci_iounmap(pdev, dev_priv->regs);
 }
 
@@ -918,16 +910,15 @@ static void i915_mmio_cleanup(struct drm_device *dev)
  */
 static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = &dev_priv->drm;
 	int ret;
 
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	if (i915_get_bridge_dev(dev))
+	if (i915_get_bridge_dev(dev_priv))
 		return -EIO;
 
-	ret = i915_mmio_setup(dev);
+	ret = i915_mmio_setup(dev_priv);
 	if (ret < 0)
 		goto put_bridge;
 
@@ -947,10 +938,8 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = &dev_priv->drm;
-
 	intel_uncore_fini(dev_priv);
-	i915_mmio_cleanup(dev);
+	i915_mmio_cleanup(dev_priv);
 	pci_dev_put(dev_priv->bridge_dev);
 }
 

commit cb15d9f8c30c868f6117d96b6fa58129785026f6
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:39 2016 +0000

    drm/i915: More GEM init dev_priv cleanup
    
    Simplifies the code to pass the right parameter in.
    
    v2: Commit message. (Joonas Lahtinen)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a7f85bdf8d66..383bf1ac1bdd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -544,8 +544,8 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
 	mutex_lock(&dev_priv->drm.struct_mutex);
-	i915_gem_cleanup_engines(&dev_priv->drm);
-	i915_gem_context_fini(&dev_priv->drm);
+	i915_gem_cleanup_engines(dev_priv);
+	i915_gem_context_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
 	rcu_barrier();
@@ -833,7 +833,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);
-	ret = i915_gem_load_init(&dev_priv->drm);
+	ret = i915_gem_load_init(dev_priv);
 	if (ret < 0)
 		goto err_gvt;
 
@@ -861,7 +861,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
 	i915_perf_fini(dev_priv);
-	i915_gem_load_cleanup(&dev_priv->drm);
+	i915_gem_load_cleanup(dev_priv);
 	i915_workqueues_cleanup(dev_priv);
 }
 

commit bf9e8429ab9747f584e692bad52a7a9f1787a4da
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Dec 1 14:16:38 2016 +0000

    drm/i915: Make various init functions take dev_priv
    
    Like GEM init, GUC init, MOCS init and context creation.
    
    Enables them to lose dev_priv locals.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 89af78eb5c32..a7f85bdf8d66 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,9 +603,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (ret)
 		goto cleanup_irq;
 
-	intel_guc_init(dev);
+	intel_guc_init(dev_priv);
 
-	ret = i915_gem_init(dev);
+	ret = i915_gem_init(dev_priv);
 	if (ret)
 		goto cleanup_irq;
 
@@ -626,11 +626,11 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	return 0;
 
 cleanup_gem:
-	if (i915_gem_suspend(dev))
+	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 	i915_gem_fini(dev_priv);
 cleanup_irq:
-	intel_guc_fini(dev);
+	intel_guc_fini(dev_priv);
 	drm_irq_uninstall(dev);
 	intel_teardown_gmbus(dev);
 cleanup_csr:
@@ -1283,7 +1283,7 @@ void i915_driver_unload(struct drm_device *dev)
 
 	intel_fbdev_fini(dev);
 
-	if (i915_gem_suspend(dev))
+	if (i915_gem_suspend(dev_priv))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
@@ -1320,7 +1320,7 @@ void i915_driver_unload(struct drm_device *dev)
 	/* Flush any outstanding unpin_work. */
 	drain_workqueue(dev_priv->wq);
 
-	intel_guc_fini(dev);
+	intel_guc_fini(dev_priv);
 	i915_gem_fini(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 
@@ -1425,14 +1425,14 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	pci_save_state(pdev);
 
-	error = i915_gem_suspend(dev);
+	error = i915_gem_suspend(dev_priv);
 	if (error) {
 		dev_err(&pdev->dev,
 			"GEM idle failed, resume might fail\n");
 		goto out;
 	}
 
-	intel_guc_suspend(dev);
+	intel_guc_suspend(dev_priv);
 
 	intel_display_suspend(dev);
 
@@ -1568,7 +1568,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_csr_ucode_resume(dev_priv);
 
-	i915_gem_resume(dev);
+	i915_gem_resume(dev_priv);
 
 	i915_restore_state(dev);
 	intel_pps_unlock_regs_wa(dev_priv);
@@ -1591,13 +1591,13 @@ static int i915_drm_resume(struct drm_device *dev)
 	drm_mode_config_reset(dev);
 
 	mutex_lock(&dev->struct_mutex);
-	if (i915_gem_init_hw(dev)) {
+	if (i915_gem_init_hw(dev_priv)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
 		i915_gem_set_wedged(dev_priv);
 	}
 	mutex_unlock(&dev->struct_mutex);
 
-	intel_guc_resume(dev);
+	intel_guc_resume(dev_priv);
 
 	intel_modeset_init_hw(dev);
 
@@ -1770,11 +1770,10 @@ static void enable_engines_irq(struct drm_i915_private *dev_priv)
  */
 void i915_reset(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = &dev_priv->drm;
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
 	int ret;
 
-	lockdep_assert_held(&dev->struct_mutex);
+	lockdep_assert_held(&dev_priv->drm.struct_mutex);
 
 	if (!test_and_clear_bit(I915_RESET_IN_PROGRESS, &error->flags))
 		return;
@@ -1814,7 +1813,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	 * was running at the time of the reset (i.e. we weren't VT
 	 * switched away).
 	 */
-	ret = i915_gem_init_hw(dev);
+	ret = i915_gem_init_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("Failed hw init on reset %d\n", ret);
 		goto error;
@@ -2328,7 +2327,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 */
 	i915_gem_runtime_suspend(dev_priv);
 
-	intel_guc_suspend(dev);
+	intel_guc_suspend(dev_priv);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
@@ -2413,7 +2412,7 @@ static int intel_runtime_resume(struct device *kdev)
 	if (intel_uncore_unclaimed_mmio(dev_priv))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
-	intel_guc_resume(dev);
+	intel_guc_resume(dev_priv);
 
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev_priv);

commit 908764f6d0bd1ba496cb8da33b9b98297ed27351
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Nov 29 21:40:29 2016 +0200

    drm/i915/lspcon: Enable AUX interrupts for resume time initialization
    
    For LSPCON initialization during system resume we need AUX
    functionality, but we call the corresponding encoder reset hook with all
    interrupts disabled. Without interrupts we'll do a poll-wait for AUX
    transfer completions, which adds a significant delay if the transfers
    timeout/need to be retried for some reason.
    
    Fix this by enabling interrupts before calling the reset hooks. Note
    that while this will enable AUX interrupts it will keep HPD interrupts
    disabled, in a similar way to the init time output setup code.
    
    This issue existed since LSPCON support was added.
    
    v2:
    - Rebased on drm-tip.
    
    Cc: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1480448429-27739-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dc80c8ff54e3..89af78eb5c32 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1575,18 +1575,21 @@ static int i915_drm_resume(struct drm_device *dev)
 	intel_opregion_setup(dev_priv);
 
 	intel_init_pch_refclk(dev_priv);
-	drm_mode_config_reset(dev);
 
 	/*
 	 * Interrupts have to be enabled before any batches are run. If not the
 	 * GPU will hang. i915_gem_init_hw() will initiate batches to
 	 * update/restore the context.
 	 *
+	 * drm_mode_config_reset() needs AUX interrupts.
+	 *
 	 * Modeset enabling in intel_modeset_init_hw() also needs working
 	 * interrupts.
 	 */
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
+	drm_mode_config_reset(dev);
+
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");

commit d4881a48a85ccb8b100fb7cd4f4791f35b0a3f49
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 30 12:01:31 2016 +0100

    drm/i915: Remove dummy i915_kick_out_firmware_fb
    
    Since
    
    commit 44adece57e2604cec8527a499b48e4d584ab53b8
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Aug 10 18:52:34 2016 +0200
    
        drm/fb-helper: Add a dummy remove_conflicting_framebuffers
    
    the drm helpers take care of this for us.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161130110131.25668-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8dac298461c0..dc80c8ff54e3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -643,7 +643,6 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	return ret;
 }
 
-#if IS_ENABLED(CONFIG_FB)
 static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 {
 	struct apertures_struct *ap;
@@ -668,12 +667,6 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 
 	return ret;
 }
-#else
-static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
-{
-	return 0;
-}
-#endif
 
 #if !defined(CONFIG_VGA_CONSOLE)
 static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)

commit 413e8fdb6ae7ef074cb0393adada2658217ec48d
Author: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
Date:   Fri Nov 25 18:59:36 2016 +0100

    drm/i915/guc: Init send_mutex in intel_uc_init_early()
    
    send_mutex is used to serialise communication with GuC via
    intel_guc_send().
    
    Since functions that utilize it are no longer limited to submission,
    initialization should be handled as a part of general setup.
    
    v2: move initialization to *_early()
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1480096777-12573-5-git-send-email-arkadiusz.hiler@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0fba4bb5655e..8dac298461c0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -817,6 +817,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
 
+	intel_uc_init_early(dev_priv);
+
 	i915_memcpy_init_early(dev_priv);
 
 	ret = i915_workqueues_init(dev_priv);

commit c39055b072f8b1c403aa7967e8efbb1a1a59b348
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Wed Nov 23 16:21:44 2016 +0200

    drm/i915: Pass dev_priv to intel_setup_outputs()
    
    Pass dev_priv to intel_setup_outputs() and functions called by it, since
    those are all intel i915 specific functions. Also, in the majority of
    the functions dev_priv is used more often than dev. In the rare cases
    where there are a few calls back into drm core, a local dev variable was
    added.
    
    v2: Don't convert dev to &dev_priv->drm in intel_dsi_init. (Ville)
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479910904-11005-1-git-send-email-ander.conselvan.de.oliveira@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b893e67b4897..0fba4bb5655e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1579,7 +1579,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	intel_pps_unlock_regs_wa(dev_priv);
 	intel_opregion_setup(dev_priv);
 
-	intel_init_pch_refclk(dev);
+	intel_init_pch_refclk(dev_priv);
 	drm_mode_config_reset(dev);
 
 	/*
@@ -2418,7 +2418,7 @@ static int intel_runtime_resume(struct device *kdev)
 	intel_guc_resume(dev);
 
 	if (IS_GEN6(dev_priv))
-		intel_init_pch_refclk(dev);
+		intel_init_pch_refclk(dev_priv);
 
 	if (IS_BROXTON(dev_priv)) {
 		bxt_disable_dc9(dev_priv);

commit c2a126a46d4c843e9e56b7cad6a14b3791ffab47
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 22 14:41:19 2016 +0000

    drm/i915: Disable hangcheck when wedged
    
    If the gpu reset fails and the machine is terminally wedged, further
    hangchecks achieve nothing but noise. Disable them, with a corollary
    that we re-enable hangchecking after a successful GPU reset in case the
    user is artificially bringing the machine back to life through the debug
    interface.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161122144121.7379-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff13503eae08..b893e67b4897 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1822,6 +1822,8 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	i915_queue_hangcheck(dev_priv);
+
 wakeup:
 	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
 	return;

commit 442b8c06fc7230772a663a00feeb5ebc61652d6d
Author: Robert Bragg <robert@sixbynine.org>
Date:   Mon Nov 7 19:49:53 2016 +0000

    drm/i915: advertise available metrics via sysfs
    
    Each metric set is given a sysfs entry like:
    
    /sys/class/drm/card0/metrics/<guid>/id
    
    This allows userspace to enumerate the specific sets that are available
    for the current system. The 'id' file contains an unsigned integer that
    can be used to open the associated metric set via
    DRM_IOCTL_I915_PERF_OPEN. The <guid> is a globally unique ID for a
    specific OA unit register configuration that can be reliably used by
    userspace as a key to lookup corresponding counter meta data and
    normalization equations.
    
    The guid registry is currently maintained as part of gputop along with
    the XML metric set descriptions and code generation scripts, ref:
    
     https://github.com/rib/gputop
     > gputop-data/guids.xml
     > scripts/update-guids.py
     > gputop-data/oa-*.xml
     > scripts/i915-perf-kernelgen.py
    
     $ make -C gputop-data -f Makefile.xml SYSFS=1 WHITELIST=RenderBasic
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Sourab Gupta <sourab.gupta@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161107194957.3385-8-robert@sixbynine.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 94a9fb0f7b39..ff13503eae08 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1129,6 +1129,9 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 		i915_debugfs_register(dev_priv);
 		i915_guc_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
+
+		/* Depends on sysfs having been initialized */
+		i915_perf_register(dev_priv);
 	} else
 		DRM_ERROR("Failed to register driver for userspace access!\n");
 
@@ -1165,6 +1168,8 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	acpi_video_unregister();
 	intel_opregion_unregister(dev_priv);
 
+	i915_perf_unregister(dev_priv);
+
 	i915_teardown_sysfs(dev_priv);
 	i915_guc_unregister(dev_priv);
 	i915_debugfs_unregister(dev_priv);

commit eec688e1420da584afb36ffa5f0cad75f53cf286
Author: Robert Bragg <robert@sixbynine.org>
Date:   Mon Nov 7 19:49:47 2016 +0000

    drm/i915: Add i915 perf infrastructure
    
    Adds base i915 perf infrastructure for Gen performance metrics.
    
    This adds a DRM_IOCTL_I915_PERF_OPEN ioctl that takes an array of uint64
    properties to configure a stream of metrics and returns a new fd usable
    with standard VFS system calls including read() to read typed and sized
    records; ioctl() to enable or disable capture and poll() to wait for
    data.
    
    A stream is opened something like:
    
      uint64_t properties[] = {
          /* Single context sampling */
          DRM_I915_PERF_PROP_CTX_HANDLE,        ctx_handle,
    
          /* Include OA reports in samples */
          DRM_I915_PERF_PROP_SAMPLE_OA,         true,
    
          /* OA unit configuration */
          DRM_I915_PERF_PROP_OA_METRICS_SET,    metrics_set_id,
          DRM_I915_PERF_PROP_OA_FORMAT,         report_format,
          DRM_I915_PERF_PROP_OA_EXPONENT,       period_exponent,
       };
       struct drm_i915_perf_open_param parm = {
          .flags = I915_PERF_FLAG_FD_CLOEXEC |
                   I915_PERF_FLAG_FD_NONBLOCK |
                   I915_PERF_FLAG_DISABLED,
          .properties_ptr = (uint64_t)properties,
          .num_properties = sizeof(properties) / 16,
       };
       int fd = drmIoctl(drm_fd, DRM_IOCTL_I915_PERF_OPEN, &param);
    
    Records read all start with a common { type, size } header with
    DRM_I915_PERF_RECORD_SAMPLE being of most interest. Sample records
    contain an extensible number of fields and it's the
    DRM_I915_PERF_PROP_SAMPLE_xyz properties given when opening that
    determine what's included in every sample.
    
    No specific streams are supported yet so any attempt to open a stream
    will return an error.
    
    v2:
        use i915_gem_context_get() - Chris Wilson
    v3:
        update read() interface to avoid passing state struct - Chris Wilson
        fix some rebase fallout, with i915-perf init/deinit
    v4:
        s/DRM_IORW/DRM_IOW/ - Emil Velikov
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Sourab Gupta <sourab.gupta@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161107194957.3385-2-robert@sixbynine.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 445fec9c2841..94a9fb0f7b39 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -848,6 +848,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_detect_preproduction_hw(dev_priv);
 
+	i915_perf_init(dev_priv);
+
 	return 0;
 
 err_gvt:
@@ -863,6 +865,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
  */
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
+	i915_perf_fini(dev_priv);
 	i915_gem_load_cleanup(&dev_priv->drm);
 	i915_workqueues_cleanup(dev_priv);
 }
@@ -2565,6 +2568,7 @@ static const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_USERPTR, i915_gem_userptr_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_PERF_OPEN, i915_perf_open_ioctl, DRM_RENDER_ALLOW),
 };
 
 static struct drm_driver driver = {

commit 6315b5d33a8ff6e0bf3d083524ffaa4e33d5981b
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Nov 16 12:32:42 2016 +0000

    drm/i915: dev_priv cleanup in intel_display.c
    
    v2: Rebase.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ce34e7ab44ab..445fec9c2841 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -495,7 +495,7 @@ static unsigned int i915_vga_set_decode(void *cookie, bool state)
 {
 	struct drm_device *dev = cookie;
 
-	intel_modeset_vga_set_state(dev, state);
+	intel_modeset_vga_set_state(to_i915(dev), state);
 	if (state)
 		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
 		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;

commit 275a991c038aaa1c1ba09e96b7add46e4712daff
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Nov 16 08:55:34 2016 +0000

    drm/i915: dev_priv cleanup in i915_gem_gtt.c
    
    Started with removing INTEL_INFO(dev) and cascaded into a quite
    big trickle of function prototype changes. Still, I think it is
    for the better.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 74f545a50eac..ce34e7ab44ab 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1442,7 +1442,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_suspend_hw(dev_priv);
 
-	i915_gem_suspend_gtt_mappings(dev);
+	i915_gem_suspend_gtt_mappings(dev_priv);
 
 	i915_save_state(dev);
 

commit c6be607abcf70cdfd4379dd43e7f66d8815542b7
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Nov 16 08:55:31 2016 +0000

    drm/i915: dev_priv and a small cascade of cleanups in i915_gem.c
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4f0e56d3b441..74f545a50eac 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2426,7 +2426,7 @@ static int intel_runtime_resume(struct device *kdev)
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
-	i915_gem_init_swizzling(dev);
+	i915_gem_init_swizzling(dev_priv);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 

commit 3975797f3e72bd115c6ba80210c5fe65ebd9e14e
Merge: 78424c927cf1 b7c0e47d9824
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 17 14:32:57 2016 +0100

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next-queued
    
    Tvrtko needs
    
    commit b3c11ac267d461d3d597967164ff7278a919a39f
    Author: Eric Engestrom <eric@engestrom.ch>
    Date:   Sat Nov 12 01:12:56 2016 +0000
    
        drm: move allocation out of drm_get_format_name()
    
    to be able to apply his patches without conflicts.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 0de9136dbbc9f6882bb375270eaddf1b999081bf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Nov 14 20:41:01 2016 +0000

    drm/i915/scheduler: Signal the arrival of a new request
    
    The start of the scheduler, add a hook into request submission for the
    scheduler to see the arrival of new requests and prepare its runqueues.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114204105.29171-6-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 847794d387d6..874fe857a345 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -323,6 +323,10 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		 */
 		value = i915_gem_mmap_gtt_version();
 		break;
+	case I915_PARAM_HAS_SCHEDULER:
+		value = dev_priv->engine[RCS] &&
+			dev_priv->engine[RCS]->schedule;
+		break;
 	case I915_PARAM_MMAP_VERSION:
 		/* Remember to bump this if the version changes! */
 	case I915_PARAM_HAS_GEM:

commit d2ad3ae4ecf5825a57bb8b1adf4eca2e25adcf63
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Nov 10 15:36:34 2016 +0200

    drm/i915: Update i915_driver_load kerneldoc
    
    Update i915_driver_load kerneldoc to match code.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478784994-2494-2-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 22a90b95158d..847794d387d6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1168,8 +1168,8 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 
 /**
  * i915_driver_load - setup chip and create an initial config
- * @dev: DRM device
- * @flags: startup flags
+ * @pdev: PCI device
+ * @ent: matching PCI ID entry
  *
  * The driver load routine has to do several things:
  *   - drive output discovery via intel_modeset_init()

commit 514e1d64801a6bc5c4bfe6a2fe29849813290b1d
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Nov 4 14:42:48 2016 +0000

    drm/i915: Convert i915_drv.c to INTEL_GEN
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478270568-7902-2-git-send-email-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b849ee18c1fc..22a90b95158d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -374,12 +374,12 @@ static int
 intel_alloc_mchbar_resource(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
-	int reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+	int reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp_lo, temp_hi = 0;
 	u64 mchbar_addr;
 	int ret;
 
-	if (INTEL_INFO(dev)->gen >= 4)
+	if (INTEL_GEN(dev_priv) >= 4)
 		pci_read_config_dword(dev_priv->bridge_dev, reg + 4, &temp_hi);
 	pci_read_config_dword(dev_priv->bridge_dev, reg, &temp_lo);
 	mchbar_addr = ((u64)temp_hi << 32) | temp_lo;
@@ -406,7 +406,7 @@ intel_alloc_mchbar_resource(struct drm_device *dev)
 		return ret;
 	}
 
-	if (INTEL_INFO(dev)->gen >= 4)
+	if (INTEL_GEN(dev_priv) >= 4)
 		pci_write_config_dword(dev_priv->bridge_dev, reg + 4,
 				       upper_32_bits(dev_priv->mch_res.start));
 
@@ -420,7 +420,7 @@ static void
 intel_setup_mchbar(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
-	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+	int mchbar_reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp;
 	bool enabled;
 
@@ -460,7 +460,7 @@ static void
 intel_teardown_mchbar(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
-	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+	int mchbar_reg = INTEL_GEN(dev_priv) >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 
 	if (dev_priv->mchbar_need_disable) {
 		if (IS_I915G(dev_priv) || IS_I915GM(dev_priv)) {
@@ -879,7 +879,7 @@ static int i915_mmio_setup(struct drm_device *dev)
 	 * the register BAR remains the same size for all the earlier
 	 * generations up to Ironlake.
 	 */
-	if (INTEL_INFO(dev)->gen < 5)
+	if (INTEL_GEN(dev_priv) < 5)
 		mmio_size = 512 * 1024;
 	else
 		mmio_size = 2 * 1024 * 1024;
@@ -1512,7 +1512,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	 * Fujitsu FSC S7110
 	 * Acer Aspire 1830T
 	 */
-	if (!(hibernation && INTEL_INFO(dev_priv)->gen < 6))
+	if (!(hibernation && INTEL_GEN(dev_priv) < 6))
 		pci_set_power_state(pdev, PCI_D3hot);
 
 	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);

commit b7f05d4ae0a66ec0494dd0f9a7f2114cbe6fd2ea
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Nov 9 11:30:45 2016 +0000

    drm/i915: Pass dev_priv to INTEL_INFO everywhere apart from the gen use
    
    After this patch only conversion of INTEL_INFO(p)->gen to
    INTEL_GEN(dev_priv) remains before the __I915__ macro can
    be removed.
    
    v2: Tidy vlv_compute_wm. (David Weinehall)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b72c24ff39c3..b849ee18c1fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -150,7 +150,7 @@ static void intel_detect_pch(struct drm_device *dev)
 	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
 	 * (which really amounts to a PCH but no South Display).
 	 */
-	if (INTEL_INFO(dev)->num_pipes == 0) {
+	if (INTEL_INFO(dev_priv)->num_pipes == 0) {
 		dev_priv->pch_type = PCH_NOP;
 		return;
 	}
@@ -607,7 +607,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	intel_modeset_gem_init(dev);
 
-	if (INTEL_INFO(dev)->num_pipes == 0)
+	if (INTEL_INFO(dev_priv)->num_pipes == 0)
 		return 0;
 
 	ret = intel_fbdev_init(dev);

commit 3e91168a6a76f7e21c44f04ebf953589ca59f03c
Merge: db8feb6979e9 4b514e10157a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Nov 11 09:28:44 2016 +1000

    Merge tag 'topic/drm-misc-2016-11-10' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - better atomic state debugging from Rob
    - fence prep from gustavo
    - sumits flushed out his backlog of pending dma-buf/fence patches from
      various people
    - drm_mm leak debugging plus trying to appease Kconfig (Chris)
    - a few misc things all over
    
    * tag 'topic/drm-misc-2016-11-10' of git://anongit.freedesktop.org/drm-intel: (35 commits)
      drm: Make DRM_DEBUG_MM depend on STACKTRACE_SUPPORT
      drm/i915: Restrict DRM_DEBUG_MM automatic selection
      drm: Restrict stackdepot usage to builtin drm.ko
      drm/msm: module param to dump state on error irq
      drm/msm/mdp5: add atomic_print_state support
      drm/atomic: add debugfs file to dump out atomic state
      drm/atomic: add new drm_debug bit to dump atomic state
      drm: add helpers to go from plane state to drm_rect
      drm: add helper for printing to log or seq_file
      drm: helper macros to print composite types
      reservation: revert "wait only with non-zero timeout specified (v3)" v2
      drm/ttm: fix ttm_bo_wait
      dma-buf/fence: revert "don't wait when specified timeout is zero" (v2)
      dma-buf/fence: make timeout handling in fence_default_wait consistent (v2)
      drm/amdgpu: add the interface of waiting multiple fences (v4)
      dma-buf: return index of the first signaled fence (v2)
      MAINTAINERS: update Sync File Framework files
      dma-buf/sw_sync: put fence reference from the fence creation
      dma-buf/sw_sync: mark sync_timeline_create() static
      drm: Add stackdepot include for DRM_DEBUG_MM
      ...

commit e0b70061404f64f592d6d082a63c504b66d65c6e
Author: Lyude <lyude@redhat.com>
Date:   Tue Nov 1 21:06:30 2016 -0400

    drm/i915: Reinit polling before hpd when resuming
    
    Now that we don't run the connector reprobing from i915_drm_resume(), we
    need to make it so we don't have to wait for reprobing to finish so that
    we actually speed things up. In order to do this, we need to make sure
    that i915_drm_resume() doesn't get blocked by i915_hpd_poll_init_work()
    while trying to acquire the mode_config lock that
    drm_kms_helper_poll_enable() needs to acquire.
    
    The easiest way to do this is to just enable polling before hpd. This
    shouldn't break anything since at that point we have everything else we
    need for polling enabled.
    
    As well, this should result in a rather significant improvement in how
    quickly we can resume the system.
    
    Signed-off-by: Lyude <lyude@redhat.com>
    Tested-by: David Weinehall <david.weinehall@linux.intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Testcase: analyze_suspend.py -config config/suspend-callgraph.cfg -filter i915

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0e45665efd7f..b72c24ff39c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1600,6 +1600,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_display_resume(dev);
 
+	drm_kms_helper_poll_enable(dev);
+
 	/*
 	 * ... but also need to make sure that hotplug processing
 	 * doesn't cause havoc. Like in the driver load code we don't
@@ -1619,7 +1621,6 @@ static int i915_drm_resume(struct drm_device *dev)
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
 	intel_autoenable_gt_powersave(dev_priv);
-	drm_kms_helper_poll_enable(dev);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 

commit f97f193613dc7b723fa1b7e187da0ba585a7f2de
Author: Lyude <lyude@redhat.com>
Date:   Tue Nov 1 17:31:32 2016 -0400

    drm/i915: Remove redundant reprobe in i915_drm_resume
    
    Weine's investigation on benchmarking the suspend/resume process pointed
    out a lot of the time in suspend/resume is being spent reprobing. While
    the reprobing process is a lengthy one for good reason, we don't need to
    hold up the entire suspend/resume process while we wait for it to
    finish. Luckily as it turns out, we already trigger a full connector
    reprobe in i915_hpd_poll_init_work(), so we can just ditch reprobing in
    i915_drm_resume() entirely.
    
    This won't lead to less time spent resuming just yet since now the
    bottleneck will be waiting for the mode_config lock in
    drm_kms_helper_poll_enable(), since that will be held as long as
    i915_hpd_poll_init_work() is reprobing all of the connectors. But we'll
    address that in the next patch.
    
    Signed-off-by: Lyude <lyude@redhat.com>
    Tested-by: David Weinehall <david.weinehall@linux.intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Testcase: analyze_suspend.py -config config/suspend-callgraph.cfg -filter i915

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9e5a547a67ab..0e45665efd7f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1607,8 +1607,6 @@ static int i915_drm_resume(struct drm_device *dev)
 	 * notifications.
 	 * */
 	intel_hpd_init(dev_priv);
-	/* Config may have changed between suspend and resume */
-	drm_helper_hpd_irq_event(dev);
 
 	intel_opregion_register(dev_priv);
 

commit 55edf41b699bcb31dcf45082d99e91b7e217206e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Nov 1 17:40:44 2016 +0200

    drm: define drm_compat_ioctl NULL on CONFIG_COMPAT=n and reduce #ifdefs
    
    If we define drm_compat_ioctl NULL on CONFIG_COMPAT=n, we don't have to
    check for the config everywhere.
    
    Reviewed-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478014844-27454-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 912d5348e3e7..cf583d4e3a9f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2509,9 +2509,7 @@ static const struct file_operations i915_driver_fops = {
 	.mmap = drm_gem_mmap,
 	.poll = drm_poll,
 	.read = drm_read,
-#ifdef CONFIG_COMPAT
 	.compat_ioctl = i915_compat_ioctl,
-#endif
 	.llseek = noop_llseek,
 };
 

commit 3ac168a70b2417c602fb86d48cb0cd12102890e1
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Tue Nov 1 18:43:03 2016 +0200

    drm/i915: Move hangcheck code out from i915_irq.c
    
    Create new file for hangcheck specific code, intel_hangcheck.c,
    and move all related code in it.
    
    v2: s/intel_engine_hangcheck/intel_engine (Chris)
    
    No functional changes.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478018583-5816-1-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 48f4d210baf6..9e5a547a67ab 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -830,6 +830,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_dpio(dev_priv);
 	intel_power_domains_init(dev_priv);
 	intel_irq_init(dev_priv);
+	intel_hangcheck_init(dev_priv);
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);

commit 712bf36449ef6eb7a130153db9cb13fe897dc2e4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Oct 31 22:37:23 2016 +0200

    drm/i915: Pass dev_priv to intel_suspend_hw()
    
    Unify our approach to things by passing around dev_priv instead of dev.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1477946245-14134-25-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f83dde9e36d1..48f4d210baf6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1435,7 +1435,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_suspend_encoders(dev_priv);
 
-	intel_suspend_hw(dev);
+	intel_suspend_hw(dev_priv);
 
 	i915_gem_suspend_gtt_mappings(dev);
 

commit 46f16e631aa2001cd4a4899b4797d4f0b847ad10
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Oct 31 22:37:22 2016 +0200

    drm/i915: Pass dev_priv to init_clock_gating
    
    Unify our approach to things by passing around dev_priv instead of dev.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1477946245-14134-24-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77ca07f7f94e..f83dde9e36d1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2264,7 +2264,6 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 				bool rpm_resume)
 {
-	struct drm_device *dev = &dev_priv->drm;
 	int err;
 	int ret;
 
@@ -2289,7 +2288,7 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 	vlv_check_no_gt_access(dev_priv);
 
 	if (rpm_resume)
-		intel_init_clock_gating(dev);
+		intel_init_clock_gating(dev_priv);
 
 	return ret;
 }

commit a26e52392191f51605af9017058cf5e43334cd5b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Oct 31 22:37:19 2016 +0200

    drm/i915: Pass dev_priv to IS_BROADWATER/IS_CRESTLINE
    
    Unify our approach to things by passing around dev_priv instead of dev.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1477946245-14134-21-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3b9bfd2cf0c0..77ca07f7f94e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -981,7 +981,6 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 {
 	struct pci_dev *pdev = dev_priv->drm.pdev;
-	struct drm_device *dev = &dev_priv->drm;
 	int ret;
 
 	if (i915_inject_load_failure())
@@ -1039,7 +1038,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * behaviour if any general state is accessed within a page above 4GB,
 	 * which also needs to be handled carefully.
 	 */
-	if (IS_BROADWATER(dev) || IS_CRESTLINE(dev)) {
+	if (IS_BROADWATER(dev_priv) || IS_CRESTLINE(dev_priv)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 
 		if (ret) {

commit 7d5d59e527b43d4efb00467234efbd2a0d5e5a86
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 1 08:48:41 2016 +0000

    drm/i915: Use the full hammer when shutting down the rcu tasks
    
    To flush all call_rcu() tasks (here from i915_gem_free_object()) we need
    to call rcu_barrier() (not synchronize_rcu()). If we don't then we may
    still have objects being freed as we continue to teardown the driver -
    in particular, the recently released rings may race with the memory
    manager shutdown resulting in sporadic:
    
    [  142.217186] WARNING: CPU: 7 PID: 6185 at drivers/gpu/drm/drm_mm.c:932 drm_mm_takedown+0x2e/0x40
    [  142.217187] Memory manager not clean during takedown.
    [  142.217187] Modules linked in: i915(-) x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel lpc_ich snd_hda_codec_realtek snd_hda_codec_generic mei_me mei snd_hda_codec_hdmi snd_hda_codec snd_hwdep snd_hda_core snd_pcm e1000e ptp pps_core [last unloaded: snd_hda_intel]
    [  142.217199] CPU: 7 PID: 6185 Comm: rmmod Not tainted 4.9.0-rc2-CI-Trybot_242+ #1
    [  142.217199] Hardware name: LENOVO 10AGS00601/SHARKBAY, BIOS FBKT34AUS 04/24/2013
    [  142.217200]  ffffc90002ecfce0 ffffffff8142dd65 ffffc90002ecfd30 0000000000000000
    [  142.217202]  ffffc90002ecfd20 ffffffff8107e4e6 000003a40778c2a8 ffff880401355c48
    [  142.217204]  ffff88040778c2a8 ffffffffa040f3c0 ffffffffa040f4a0 00005621fbf8b1f0
    [  142.217206] Call Trace:
    [  142.217209]  [<ffffffff8142dd65>] dump_stack+0x67/0x92
    [  142.217211]  [<ffffffff8107e4e6>] __warn+0xc6/0xe0
    [  142.217213]  [<ffffffff8107e54a>] warn_slowpath_fmt+0x4a/0x50
    [  142.217214]  [<ffffffff81559e3e>] drm_mm_takedown+0x2e/0x40
    [  142.217236]  [<ffffffffa035c02a>] i915_gem_cleanup_stolen+0x1a/0x20 [i915]
    [  142.217246]  [<ffffffffa034c581>] i915_ggtt_cleanup_hw+0x31/0xb0 [i915]
    [  142.217253]  [<ffffffffa0310311>] i915_driver_cleanup_hw+0x31/0x40 [i915]
    [  142.217260]  [<ffffffffa0312001>] i915_driver_unload+0x141/0x1a0 [i915]
    [  142.217268]  [<ffffffffa031c2c4>] i915_pci_remove+0x14/0x20 [i915]
    [  142.217269]  [<ffffffff8147d214>] pci_device_remove+0x34/0xb0
    [  142.217271]  [<ffffffff8157b14c>] __device_release_driver+0x9c/0x150
    [  142.217272]  [<ffffffff8157bcc6>] driver_detach+0xb6/0xc0
    [  142.217273]  [<ffffffff8157abe3>] bus_remove_driver+0x53/0xd0
    [  142.217274]  [<ffffffff8157c787>] driver_unregister+0x27/0x50
    [  142.217276]  [<ffffffff8147c265>] pci_unregister_driver+0x25/0x70
    [  142.217287]  [<ffffffffa03d764c>] i915_exit+0x1a/0x71 [i915]
    [  142.217289]  [<ffffffff811136b3>] SyS_delete_module+0x193/0x1e0
    [  142.217291]  [<ffffffff818174ae>] entry_SYSCALL_64_fastpath+0x1c/0xb1
    [  142.217292] ---[ end trace 6fd164859c154772 ]---
    [  142.217505] [drm:show_leaks] *ERROR* node [6b6b6b6b6b6b6b6b + 6b6b6b6b6b6b6b6b]: inserted at
                    [<ffffffff81559ff3>] save_stack.isra.1+0x53/0xa0
                    [<ffffffff8155a98d>] drm_mm_insert_node_in_range_generic+0x2ad/0x360
                    [<ffffffffa035bf23>] i915_gem_stolen_insert_node_in_range+0x93/0xe0 [i915]
                    [<ffffffffa035c855>] i915_gem_object_create_stolen+0x75/0xb0 [i915]
                    [<ffffffffa036a51a>] intel_engine_create_ring+0x9a/0x140 [i915]
                    [<ffffffffa036a921>] intel_init_ring_buffer+0xf1/0x440 [i915]
                    [<ffffffffa036be1b>] intel_init_render_ring_buffer+0xab/0x1b0 [i915]
                    [<ffffffffa0363d08>] intel_engines_init+0xc8/0x210 [i915]
                    [<ffffffffa0355d7c>] i915_gem_init+0xac/0xf0 [i915]
                    [<ffffffffa0311454>] i915_driver_load+0x9c4/0x1430 [i915]
                    [<ffffffffa031c2f8>] i915_pci_probe+0x28/0x40 [i915]
                    [<ffffffff8147d315>] pci_device_probe+0x85/0xf0
                    [<ffffffff8157b7ff>] driver_probe_device+0x21f/0x430
                    [<ffffffff8157baee>] __driver_attach+0xde/0xe0
    
    In particular note that the node was being poisoned as we inspected the
    list, a  clear indication that the object is being freed as we make the
    assertion.
    
    v2: Don't loop, just assert that we do all the work required as that
    will be better at detecting further errors.
    
    Fixes: fbbd37b36fa5 ("drm/i915: Move object release to a freelist + worker")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161101084843.3961-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6a99544c98d3..3b9bfd2cf0c0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -544,7 +544,7 @@ static void i915_gem_fini(struct drm_i915_private *dev_priv)
 	i915_gem_context_fini(&dev_priv->drm);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
 
-	synchronize_rcu();
+	rcu_barrier();
 	flush_work(&dev_priv->mm.free_work);
 
 	WARN_ON(!list_empty(&dev_priv->context_list));

commit b079bd17e301708da044b4ea114f44c4aa47160c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Oct 25 18:58:02 2016 +0300

    drm/i915: Bail if plane/crtc init fails
    
    Due to the plane->index not getting readjusted in drm_plane_cleanup(),
    we can't continue initialization of some plane/crtc init fails.
    Well, we sort of could I suppose if we left all initialized planes on
    the list, but that would expose those planes to userspace as well.
    
    But for crtcs the situation is even worse since we assume that
    pipe==crtc index occasionally, so we can't really deal with a partially
    initialize set of crtcs.
    
    So seems safest to just abort the entire thing if anything goes wrong.
    All the failure paths here are kmalloc()s anyway, so it seems unlikely
    we'd get very far if these start failing.
    
    v2: Add (enum plane) case to silence gcc
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1477411083-19255-4-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 839ce2ae38fa..6a99544c98d3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -595,7 +595,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	/* Important: The output setup functions called by modeset_init need
 	 * working irqs for e.g. gmbus and dp aux transfers. */
-	intel_modeset_init(dev);
+	ret = intel_modeset_init(dev);
+	if (ret)
+		goto cleanup_irq;
 
 	intel_guc_init(dev);
 

commit 73cb97010d4fdd2a29f00cac14d206c7641c23d2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 28 13:58:46 2016 +0100

    drm/i915: Combine seqno + tracking into a global timeline struct
    
    Our timelines are more than just a seqno. They also provide an ordered
    list of requests to be executed. Due to the restriction of handling
    individual address spaces, we are limited to a timeline per address
    space but we use a fence context per engine within.
    
    Our first step to introducing independent timelines per context (i.e. to
    allow each context to have a queue of requests to execute that have a
    defined set of dependencies on other requests) is to provide a timeline
    abstraction for the global execution queue.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161028125858.23563-23-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 91cd7b296c0f..839ce2ae38fa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -831,7 +831,9 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_display_hooks(dev_priv);
 	intel_init_clock_gating_hooks(dev_priv);
 	intel_init_audio_hooks(dev_priv);
-	i915_gem_load_init(&dev_priv->drm);
+	ret = i915_gem_load_init(&dev_priv->drm);
+	if (ret < 0)
+		goto err_gvt;
 
 	intel_display_crc_init(dev_priv);
 
@@ -841,6 +843,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	return 0;
 
+err_gvt:
+	intel_gvt_cleanup(dev_priv);
 err_workqueues:
 	i915_workqueues_cleanup(dev_priv);
 	return ret;

commit f0cd518206e1a47e57bc251e1faba9d38eadcc59
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 28 13:58:43 2016 +0100

    drm/i915: Use lockless object free
    
    Having moved the locked phase of freeing an object to a separate worker,
    we can now declare to the core that we only need the unlocked variant of
    driver->gem_free_object, and can use the simple unreference internally.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161028125858.23563-20-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b308f7173b6d..91cd7b296c0f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2575,7 +2575,7 @@ static struct drm_driver driver = {
 	.set_busid = drm_pci_set_busid,
 
 	.gem_close_object = i915_gem_close_object,
-	.gem_free_object = i915_gem_free_object,
+	.gem_free_object_unlocked = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
 
 	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,

commit fbbd37b36fa5e16a03aca07a922192d3db28588d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 28 13:58:42 2016 +0100

    drm/i915: Move object release to a freelist + worker
    
    We want to hide the latency of releasing objects and their backing
    storage from the submission, so we move the actual free to a worker.
    This allows us to switch to struct_mutex freeing of the object in the
    next patch.
    
    Furthermore, if we know that the object we are dereferencing remains valid
    for the duration of our access, we can forgo the usual synchronisation
    barriers and atomic reference counting. To ensure this we defer freeing
    an object til after an RCU grace period, such that any lookup of the
    object within an RCU read critical section will remain valid until
    after we exit that critical section. We also employ this delay for
    rate-limiting the serialisation on reallocation - we have to slow down
    object creation in order to prevent resource starvation (in particular,
    files).
    
    v2: Return early in i915_gem_tiling() ioctl to skip over superfluous
    work on error.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161028125858.23563-19-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index af3559d34328..b308f7173b6d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -537,14 +537,17 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 	.can_switch = i915_switcheroo_can_switch,
 };
 
-static void i915_gem_fini(struct drm_device *dev)
+static void i915_gem_fini(struct drm_i915_private *dev_priv)
 {
-	mutex_lock(&dev->struct_mutex);
-	i915_gem_cleanup_engines(dev);
-	i915_gem_context_fini(dev);
-	mutex_unlock(&dev->struct_mutex);
+	mutex_lock(&dev_priv->drm.struct_mutex);
+	i915_gem_cleanup_engines(&dev_priv->drm);
+	i915_gem_context_fini(&dev_priv->drm);
+	mutex_unlock(&dev_priv->drm.struct_mutex);
+
+	synchronize_rcu();
+	flush_work(&dev_priv->mm.free_work);
 
-	WARN_ON(!list_empty(&to_i915(dev)->context_list));
+	WARN_ON(!list_empty(&dev_priv->context_list));
 }
 
 static int i915_load_modeset_init(struct drm_device *dev)
@@ -619,7 +622,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 cleanup_gem:
 	if (i915_gem_suspend(dev))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
-	i915_gem_fini(dev);
+	i915_gem_fini(dev_priv);
 cleanup_irq:
 	intel_guc_fini(dev);
 	drm_irq_uninstall(dev);
@@ -1305,7 +1308,7 @@ void i915_driver_unload(struct drm_device *dev)
 	drain_workqueue(dev_priv->wq);
 
 	intel_guc_fini(dev);
-	i915_gem_fini(dev);
+	i915_gem_fini(dev_priv);
 	intel_fbc_cleanup_cfb(dev_priv);
 
 	intel_power_domains_fini(dev_priv);

commit f824083559af27d92db938733dba54617824d702
Author: Akash Goel <akash.goel@intel.com>
Date:   Wed Oct 12 21:54:34 2016 +0530

    drm/i915: Add a relay backed debugfs interface for capturing GuC logs
    
    Added a new debugfs interface '/sys/kernel/debug/dri/guc_log' for the
    User to capture GuC firmware logs. Availed relay framework to implement
    the interface, where Driver will have to just use a relay API to store
    snapshots of the GuC log buffer in the buffer managed by relay.
    The snapshot will be taken when GuC firmware sends a log buffer flush
    interrupt and up to four snapshots could be stored in the relay buffer.
    The relay buffer will be operated in a mode where it will overwrite the
    data not yet collected by User.
    Besides mmap method, through which User can directly access the relay
    buffer contents, relay also supports the 'poll' method. Through the 'poll'
    call on log file, User can come to know whenever a new snapshot of the
    log buffer is taken by Driver, so can run in tandem with the Driver and
    capture the logs in a sustained/streaming manner, without any loss of data.
    
    v2: Defer the creation of relay channel & associated debugfs file, as
        debugfs setup is now done at the end of i915 Driver load. (Chris)
    
    v3:
    - Switch to no-overwrite mode for relay.
    - Fix the relay sub buffer switching sequence.
    
    v4:
    - Update i915 Kconfig to select RELAY config. (TvrtKo)
    - Log a message when there is no sub buffer available to capture
      the GuC log buffer. (Tvrtko)
    - Increase the number of relay sub buffers to 8 from 4, to have
      sufficient buffering for boot time logs
    
    v5:
    - Fix the alignment, indentation issues and some minor cleanup. (Tvrtko)
    - Update the comment to elaborate on why a relay channel has to be
      associated with the debugfs file. (Tvrtko)
    
    v6:
    - Move the write to 'is_global' after the NULL check on parent directory
      dentry pointer. (Tvrtko)
    
    v7: Add a BUG_ON to validate relay buffer allocation size. (Chris)
    
    Testcase: igt/tools/intel_guc_logger
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Sourab Gupta <sourab.gupta@intel.com>
    Signed-off-by: Akash Goel <akash.goel@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 99e4e044e958..af3559d34328 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1111,6 +1111,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
 		i915_debugfs_register(dev_priv);
+		i915_guc_register(dev_priv);
 		i915_setup_sysfs(dev_priv);
 	} else
 		DRM_ERROR("Failed to register driver for userspace access!\n");
@@ -1149,6 +1150,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	intel_opregion_unregister(dev_priv);
 
 	i915_teardown_sysfs(dev_priv);
+	i915_guc_unregister(dev_priv);
 	i915_debugfs_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 

commit 7c108fd8feac9a4f380c22444ff8527e8d25bc75
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Oct 24 13:42:18 2016 +0100

    drm/i915: Move fence cancellation to runtime suspend
    
    At the moment, we have dependency on the RPM as a barrier itself in both
    i915_gem_release_all_mmaps() and i915_gem_restore_fences().
    i915_gem_restore_fences() is also called along !runtime pm paths, but we
    can move the markup of lost fences alongside releasing the mmaps into a
    common i915_gem_runtime_suspend(). This has the advantage of locating
    all the tricky barrier dependencies into one location.
    
    v2: Just mark the fence as invalid (fence->dirty) so that upon waking we
    will be sure to clear the fence after use, or restore it to the correct
    value before use. This makes sure that if the fence is left intact
    across the sleep, we do not leave it pointing to a region of GTT for the
    next unsuspecting user.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Imre Deak <imre.deak@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161024124218.18252-5-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 885d33f341f3..99e4e044e958 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2278,10 +2278,8 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 
 	vlv_check_no_gt_access(dev_priv);
 
-	if (rpm_resume) {
+	if (rpm_resume)
 		intel_init_clock_gating(dev);
-		i915_gem_restore_fences(dev);
-	}
 
 	return ret;
 }
@@ -2307,7 +2305,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	 * We are safe here against re-faults, since the fault handler takes
 	 * an RPM reference.
 	 */
-	i915_gem_release_all_mmaps(dev_priv);
+	i915_gem_runtime_suspend(dev_priv);
 
 	intel_guc_suspend(dev);
 

commit 9c870d03674f11b49ef4f48b04d709ffa7cf1390
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Oct 24 13:42:15 2016 +0100

    drm/i915: Use RPM as the barrier for controlling user mmap access
    
    We can remove the false coupling between RPM and struct mutex by the
    observation that we can use the RPM wakeref as the barrier around user
    mmap access. That is as we tear down the user's PTE atomically from
    within rpm suspend and then to fault in new PTE requires the rpm
    wakeref, means that no user access is possible through those PTE without
    RPM being awake. Having made that observation, we can then remove the
    presumption of having to take rpm outside of struct_mutex and so allow
    fine grained acquisition of a wakeref around hw access rather than
    having to remember to acquire the wakeref early on.
    
    v2: Rejig placement of the new intel_runtime_pm_get() to be as tight
    as possible around the GTT pread/pwrite.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161024124218.18252-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 912d5348e3e7..885d33f341f3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2301,24 +2301,6 @@ static int intel_runtime_suspend(struct device *kdev)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
-	/*
-	 * We could deadlock here in case another thread holding struct_mutex
-	 * calls RPM suspend concurrently, since the RPM suspend will wait
-	 * first for this RPM suspend to finish. In this case the concurrent
-	 * RPM resume will be followed by its RPM suspend counterpart. Still
-	 * for consistency return -EAGAIN, which will reschedule this suspend.
-	 */
-	if (!mutex_trylock(&dev->struct_mutex)) {
-		DRM_DEBUG_KMS("device lock contention, deffering suspend\n");
-		/*
-		 * Bump the expiration timestamp, otherwise the suspend won't
-		 * be rescheduled.
-		 */
-		pm_runtime_mark_last_busy(kdev);
-
-		return -EAGAIN;
-	}
-
 	disable_rpm_wakeref_asserts(dev_priv);
 
 	/*
@@ -2326,7 +2308,6 @@ static int intel_runtime_suspend(struct device *kdev)
 	 * an RPM reference.
 	 */
 	i915_gem_release_all_mmaps(dev_priv);
-	mutex_unlock(&dev->struct_mutex);
 
 	intel_guc_suspend(dev);
 

commit 0525a062df00ff728919a752d2204b943cf76bd4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 14 14:27:07 2016 +0100

    drm/i915: Emit telltales for extra levels of debug upon initialisation
    
    After printing our welcome message to the user, also include
    supplementary details on what debugging is enabled (useful for us to
    sanity check what extra safeguards are on for any random kernel).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161014132707.29039-1-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1fddc2ccada2..912d5348e3e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1232,6 +1232,10 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	DRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",
 		 driver.name, driver.major, driver.minor, driver.patchlevel,
 		 driver.date, pci_name(pdev), dev_priv->drm.primary->index);
+	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG))
+		DRM_INFO("DRM_I915_DEBUG enabled\n");
+	if (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))
+		DRM_INFO("DRM_I915_DEBUG_GEM enabled\n");
 
 	intel_runtime_pm_put(dev_priv);
 

commit 4c494a5769cd0de92638b25960ba0158c36088a6
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 13 14:34:06 2016 +0300

    drm/i915: Fix mismatched INIT power domain disabling during suspend
    
    Currently the display INIT power domain disabling/enabling happens in a
    mismatched way in the suspend/resume_early hooks respectively. This can
    leave display power wells incorrectly disabled in the resume hook if the
    suspend sequence is aborted for some reason resulting in the
    suspend/resume hooks getting called but the suspend_late/resume_early
    hooks being skipped. In particular this change fixes "Unclaimed read
    from register 0x1e1204" on BYT/BSW triggered from i915_drm_resume()->
    intel_pps_unlock_regs_wa() when suspending with /sys/power/pm_test set
    to devices.
    
    Fixes: 85e90679335f ("drm/i915: disable power wells on suspend")
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: David Weinehall <david.weinehall@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476358446-11621-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 69ff489fb683..1fddc2ccada2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1437,8 +1437,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	dev_priv->suspend_count++;
 
-	intel_display_set_init_power(dev_priv, false);
-
 	intel_csr_ucode_suspend(dev_priv);
 
 out:
@@ -1456,6 +1454,8 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
+	intel_display_set_init_power(dev_priv, false);
+
 	fw_csr = !IS_BROXTON(dev_priv) &&
 		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*

commit 5db9401983ac7bf9ddc45de54c53ccfa31d21774
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:03:10 2016 +0100

    drm/i915: Make IS_GEN macros only take dev_priv
    
    Saves 1416 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476352990-2504-1-git-send-email-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b4cfaa0e0e1..69ff489fb683 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -174,7 +174,7 @@ static void intel_detect_pch(struct drm_device *dev)
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_IBX;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-				WARN_ON(!IS_GEN5(dev));
+				WARN_ON(!IS_GEN5(dev_priv));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
@@ -860,7 +860,7 @@ static int i915_mmio_setup(struct drm_device *dev)
 	int mmio_bar;
 	int mmio_size;
 
-	mmio_bar = IS_GEN2(dev) ? 1 : 0;
+	mmio_bar = IS_GEN2(dev_priv) ? 1 : 0;
 	/*
 	 * Before gen4, the registers and the GTT are behind different BARs.
 	 * However, from gen4 onwards, the registers and the GTT are shared
@@ -1013,7 +1013,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	pci_set_master(pdev);
 
 	/* overlay on gen2 is broken and can't address above 1G */
-	if (IS_GEN2(dev)) {
+	if (IS_GEN2(dev_priv)) {
 		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");

commit 920a14b2459701196e42a47c7bc1559582e79ab9
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Oct 14 10:13:44 2016 +0100

    drm/i915: Make IS_CHERRYVIEW only take dev_priv
    
    Saves 864 bytes of .rodata strings and ~100 of .text.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    v3: Rebase.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 64e31cd25dea..1b4cfaa0e0e1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -424,7 +424,7 @@ intel_setup_mchbar(struct drm_device *dev)
 	u32 temp;
 	bool enabled;
 
-	if (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev))
+	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		return;
 
 	dev_priv->mchbar_need_disable = false;

commit e2d214ae2b343abbdc073a800fed924bdd124cfe
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:03:04 2016 +0100

    drm/i915: Make IS_BROXTON only take dev_priv
    
    Saves 1392 bytes of .rodata strings.
    
    Also change a few function/macro prototypes in i915_gem_gtt.c
    from dev to dev_priv where it made more sense to do so.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    v3: Mention function prototype changes. (David Weinehall)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5dd56d9ea905..64e31cd25dea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2414,7 +2414,7 @@ static int intel_runtime_resume(struct device *kdev)
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev);
 
-	if (IS_BROXTON(dev)) {
+	if (IS_BROXTON(dev_priv)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);
 		if (dev_priv->csr.dmc_payload &&

commit 0853723b8956acc9690ace7ab6ea1f50bb997b52
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:03:02 2016 +0100

    drm/i915: Make IS_KABYLAKE only take dev_priv
    
    Saves 1320 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ef7bed81c6a0..5dd56d9ea905 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -203,17 +203,17 @@ static void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev) &&
-					!IS_KABYLAKE(dev));
+				WARN_ON(!IS_SKYLAKE(dev_priv) &&
+					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev) &&
-					!IS_KABYLAKE(dev));
+				WARN_ON(!IS_SKYLAKE(dev_priv) &&
+					!IS_KABYLAKE(dev_priv));
 			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_KBP;
 				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
-				WARN_ON(!IS_KABYLAKE(dev));
+				WARN_ON(!IS_KABYLAKE(dev_priv));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit 8652744b647e267f7a6902263c424a7dc29d6648
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:03:00 2016 +0100

    drm/i915: Make IS_BROADWELL only take dev_priv
    
    Saves 1808 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b1142aaf50ec..ef7bed81c6a0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -189,13 +189,15 @@ static void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(!IS_HASWELL(dev_priv) &&
+					!IS_BROADWELL(dev_priv));
 				WARN_ON(IS_HSW_ULT(dev_priv) ||
 					IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(!IS_HASWELL(dev_priv) &&
+					!IS_BROADWELL(dev_priv));
 				WARN_ON(!IS_HSW_ULT(dev_priv) &&
 					!IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {

commit fd6b8f43c9e9a3adc384423a1d3dfeefd38655ea
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Oct 14 10:13:06 2016 +0100

    drm/i915: Make IS_IVYBRIDGE only take dev_priv
    
    Saves 848 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    v3: Rebase.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bb14e9521c5e..b1142aaf50ec 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -114,7 +114,7 @@ static bool i915_error_injected(struct drm_i915_private *dev_priv)
 		      fmt, ##__VA_ARGS__)
 
 
-static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
+static enum intel_pch intel_virt_detect_pch(struct drm_i915_private *dev_priv)
 {
 	enum intel_pch ret = PCH_NOP;
 
@@ -125,16 +125,16 @@ static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
 	 * make an educated guess as to which PCH is really there.
 	 */
 
-	if (IS_GEN5(dev)) {
+	if (IS_GEN5(dev_priv)) {
 		ret = PCH_IBX;
 		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
-	} else if (IS_GEN6(dev) || IS_IVYBRIDGE(dev)) {
+	} else if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv)) {
 		ret = PCH_CPT;
 		DRM_DEBUG_KMS("Assuming CouarPoint PCH\n");
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		ret = PCH_LPT;
 		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
-	} else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {
+	} else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
 		ret = PCH_SPT;
 		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
 	}
@@ -178,12 +178,14 @@ static void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
+				WARN_ON(!(IS_GEN6(dev_priv) ||
+					IS_IVYBRIDGE(dev_priv)));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
+				WARN_ON(!(IS_GEN6(dev_priv) ||
+					IS_IVYBRIDGE(dev_priv)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
@@ -217,7 +219,8 @@ static void intel_detect_pch(struct drm_device *dev)
 					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
 				    pch->subsystem_device ==
 					    PCI_SUBDEVICE_ID_QEMU)) {
-				dev_priv->pch_type = intel_virt_detect_pch(dev);
+				dev_priv->pch_type =
+					intel_virt_detect_pch(dev_priv);
 			} else
 				continue;
 

commit 50a0bc90541689b9b834bf93d9ba815e05423a18
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:02:58 2016 +0100

    drm/i915: Make INTEL_DEVID only take dev_priv
    
    Saves 4472 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8183743ef422..bb14e9521c5e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -188,12 +188,14 @@ static void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
-				WARN_ON(IS_HSW_ULT(dev) || IS_BDW_ULT(dev));
+				WARN_ON(IS_HSW_ULT(dev_priv) ||
+					IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
-				WARN_ON(!IS_HSW_ULT(dev) && !IS_BDW_ULT(dev));
+				WARN_ON(!IS_HSW_ULT(dev_priv) &&
+					!IS_BDW_ULT(dev_priv));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
@@ -422,7 +424,7 @@ intel_setup_mchbar(struct drm_device *dev)
 
 	dev_priv->mchbar_need_disable = false;
 
-	if (IS_I915G(dev) || IS_I915GM(dev)) {
+	if (IS_I915G(dev_priv) || IS_I915GM(dev_priv)) {
 		pci_read_config_dword(dev_priv->bridge_dev, DEVEN, &temp);
 		enabled = !!(temp & DEVEN_MCHBAR_EN);
 	} else {
@@ -440,7 +442,7 @@ intel_setup_mchbar(struct drm_device *dev)
 	dev_priv->mchbar_need_disable = true;
 
 	/* Space is allocated or reserved, so enable it. */
-	if (IS_I915G(dev) || IS_I915GM(dev)) {
+	if (IS_I915G(dev_priv) || IS_I915GM(dev_priv)) {
 		pci_write_config_dword(dev_priv->bridge_dev, DEVEN,
 				       temp | DEVEN_MCHBAR_EN);
 	} else {
@@ -456,7 +458,7 @@ intel_teardown_mchbar(struct drm_device *dev)
 	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 
 	if (dev_priv->mchbar_need_disable) {
-		if (IS_I915G(dev) || IS_I915GM(dev)) {
+		if (IS_I915G(dev_priv) || IS_I915GM(dev_priv)) {
 			u32 deven_val;
 
 			pci_read_config_dword(dev_priv->bridge_dev, DEVEN,
@@ -1053,7 +1055,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * be lost or delayed, but we use them anyways to avoid
 	 * stuck interrupts on some machines.
 	 */
-	if (!IS_I945G(dev) && !IS_I945GM(dev)) {
+	if (!IS_I945G(dev_priv) && !IS_I945GM(dev_priv)) {
 		if (pci_enable_msi(pdev) < 0)
 			DRM_DEBUG_DRIVER("can't enable MSI");
 	}

commit 6772ffe0235937414e6ab2de0f44adb1cb794408
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Oct 13 11:02:55 2016 +0100

    drm/i915: Make HAS_RUNTIME_PM only take dev_priv
    
    Saves 960 bytes of .rodata strings.
    
    v2: Add parantheses around dev_priv. (Ville Syrjala)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c3d4761dfa0..8183743ef422 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2285,7 +2285,7 @@ static int intel_runtime_suspend(struct device *kdev)
 	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6())))
 		return -ENODEV;
 
-	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
+	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
 	DRM_DEBUG_KMS("Suspending device\n");
@@ -2389,7 +2389,7 @@ static int intel_runtime_resume(struct device *kdev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret = 0;
 
-	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
+	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev_priv)))
 		return -ENODEV;
 
 	DRM_DEBUG_KMS("Resuming device\n");

commit 3b3f1650b1ca46a4225e0bf72804779b161e27b6
Author: Akash Goel <akash.goel@intel.com>
Date:   Thu Oct 13 22:44:48 2016 +0530

    drm/i915: Allocate intel_engine_cs structure only for the enabled engines
    
    With the possibility of addition of many more number of rings in future,
    the drm_i915_private structure could bloat as an array, of type
    intel_engine_cs, is embedded inside it.
            struct intel_engine_cs engine[I915_NUM_ENGINES];
    Though this is still fine as generally there is only a single instance of
    drm_i915_private structure used, but not all of the possible rings would be
    enabled or active on most of the platforms. Some memory can be saved by
    allocating intel_engine_cs structure only for the enabled/active engines.
    Currently the engine/ring ID is kept static and dev_priv->engine[] is simply
    indexed using the enums defined in intel_engine_id.
    To save memory and continue using the static engine/ring IDs, 'engine' is
    defined as an array of pointers.
            struct intel_engine_cs *engine[I915_NUM_ENGINES];
    dev_priv->engine[engine_ID] will be NULL for disabled engine instances.
    
    There is a text size reduction of 928 bytes, from 1028200 to 1027272, for
    i915.o file (but for i915.ko file text size remain same as 1193131 bytes).
    
    v2:
    - Remove the engine iterator field added in drm_i915_private structure,
      instead pass a local iterator variable to the for_each_engine**
      macros. (Chris)
    - Do away with intel_engine_initialized() and instead directly use the
      NULL pointer check on engine pointer. (Chris)
    
    v3:
    - Remove for_each_engine_id() macro, as the updated macro for_each_engine()
      can be used in place of it. (Chris)
    - Protect the access to Render engine Fault register with a NULL check, as
      engine specific init is done later in Driver load sequence.
    
    v4:
    - Use !!dev_priv->engine[VCS] style for the engine check in getparam. (Chris)
    - Kill the superfluous init_engine_lists().
    
    v5:
    - Cleanup the intel_engines_init() & intel_engines_setup(), with respect to
      allocation of intel_engine_cs structure. (Chris)
    
    v6:
    - Rebase.
    
    v7:
    - Optimize the for_each_engine_masked() macro. (Chris)
    - Change the type of 'iter' local variable to enum intel_engine_id. (Chris)
    - Rebase.
    
    v8: Rebase.
    
    v9: Rebase.
    
    v10:
    - For index calculation use engine ID instead of pointer based arithmetic in
      intel_engine_sync_index() as engine pointers are not contiguous now (Chris)
    - For appropriateness, rename local enum variable 'iter' to 'id'. (Joonas)
    - Use for_each_engine macro for cleanup in intel_engines_init() and remove
      check for NULL engine pointer in cleanup() routines. (Joonas)
    
    v11: Rebase.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Akash Goel <akash.goel@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476378888-7372-1-git-send-email-akash.goel@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e9b3bfcb347a..8c3d4761dfa0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -255,16 +255,16 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = dev_priv->overlay ? 1 : 0;
 		break;
 	case I915_PARAM_HAS_BSD:
-		value = intel_engine_initialized(&dev_priv->engine[VCS]);
+		value = !!dev_priv->engine[VCS];
 		break;
 	case I915_PARAM_HAS_BLT:
-		value = intel_engine_initialized(&dev_priv->engine[BCS]);
+		value = !!dev_priv->engine[BCS];
 		break;
 	case I915_PARAM_HAS_VEBOX:
-		value = intel_engine_initialized(&dev_priv->engine[VECS]);
+		value = !!dev_priv->engine[VECS];
 		break;
 	case I915_PARAM_HAS_BSD2:
-		value = intel_engine_initialized(&dev_priv->engine[VCS2]);
+		value = !!dev_priv->engine[VCS2];
 		break;
 	case I915_PARAM_HAS_EXEC_CONSTANTS:
 		value = INTEL_GEN(dev_priv) >= 4;
@@ -1707,10 +1707,11 @@ int i915_resume_switcheroo(struct drm_device *dev)
 static void disable_engines_irq(struct drm_i915_private *dev_priv)
 {
 	struct intel_engine_cs *engine;
+	enum intel_engine_id id;
 
 	/* Ensure irq handler finishes, and not run again. */
 	disable_irq(dev_priv->drm.irq);
-	for_each_engine(engine, dev_priv)
+	for_each_engine(engine, dev_priv, id)
 		tasklet_kill(&engine->irq_tasklet);
 }
 

commit 1c777c5d1dcdf8fa0223fcff35fb387b5bb9517a
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Oct 12 17:46:37 2016 +0300

    drm/i915/hsw: Fix GPU hang during resume from S3-devices state
    
    Currently resuming on HSW from S3 pm_test/devices state leads to an
    unrecoverable GPU hang. Resetting the GPU during suspend fixes this. For
    a full S3 cycle this change only means the reset happens earlier (before
    reaching S3). For S4 the reset will happen now both during the freeze
    and quiesce phases, which is a benefit since it will guarantee that the
    GPU is idle before creating and loading the hibernation image.
    
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476283597-580-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 89d322215c84..e9b3bfcb347a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -532,32 +532,6 @@ static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 
 static void i915_gem_fini(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = to_i915(dev);
-
-	/*
-	 * Neither the BIOS, ourselves or any other kernel
-	 * expects the system to be in execlists mode on startup,
-	 * so we need to reset the GPU back to legacy mode. And the only
-	 * known way to disable logical contexts is through a GPU reset.
-	 *
-	 * So in order to leave the system in a known default configuration,
-	 * always reset the GPU upon unload. Afterwards we then clean up the
-	 * GEM state tracking, flushing off the requests and leaving the
-	 * system in a known idle state.
-	 *
-	 * Note that is of the upmost importance that the GPU is idle and
-	 * all stray writes are flushed *before* we dismantle the backing
-	 * storage for the pinned objects.
-	 *
-	 * However, since we are uncertain that reseting the GPU on older
-	 * machines is a good idea, we don't - just in case it leaves the
-	 * machine in an unusable condition.
-	 */
-	if (HAS_HW_CONTEXTS(dev)) {
-		int reset = intel_gpu_reset(dev_priv, ALL_ENGINES);
-		WARN_ON(reset && reset != -ENODEV);
-	}
-
 	mutex_lock(&dev->struct_mutex);
 	i915_gem_cleanup_engines(dev);
 	i915_gem_context_fini(dev);
@@ -636,6 +610,8 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	return 0;
 
 cleanup_gem:
+	if (i915_gem_suspend(dev))
+		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 	i915_gem_fini(dev);
 cleanup_irq:
 	intel_guc_fini(dev);

commit 9e60ab0387817c6a9440f448aff7c8514b32d31b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 4 21:11:28 2016 +0100

    drm/i915: Disable irqs across GPU reset
    
    Whilst we reset the GPU, we want to prevent execlists from submitting
    new work (which it does via an interrupt handler). To achieve this we
    disable the irq (and drain the irq tasklet) around the reset. When we
    enable it again afters, the interrupt queue should be empty and we can
    reinitialise from a known state without fear of the tasklet running
    concurrently.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161004201132.21801-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9c1543240e27..89d322215c84 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1728,6 +1728,21 @@ int i915_resume_switcheroo(struct drm_device *dev)
 	return i915_drm_resume(dev);
 }
 
+static void disable_engines_irq(struct drm_i915_private *dev_priv)
+{
+	struct intel_engine_cs *engine;
+
+	/* Ensure irq handler finishes, and not run again. */
+	disable_irq(dev_priv->drm.irq);
+	for_each_engine(engine, dev_priv)
+		tasklet_kill(&engine->irq_tasklet);
+}
+
+static void enable_engines_irq(struct drm_i915_private *dev_priv)
+{
+	enable_irq(dev_priv->drm.irq);
+}
+
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -1761,7 +1776,11 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
+
+	disable_engines_irq(dev_priv);
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
+	enable_engines_irq(dev_priv);
+
 	if (ret) {
 		if (ret != -ENODEV)
 			DRM_ERROR("Failed to reset chip: %i\n", ret);

commit 4fc7e845f3e2c4c928bf792e43c69af969999a2c
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Sep 26 15:07:52 2016 +0300

    drm/i915/skl: tell the user about pre-production hardware
    
    We just removed the implementation for all the pre-production
    workarounds, so now tell the user that we expect his machine to not
    work properly. Also convert this to DRM_ERROR so we can more easily
    spot these problems in bug reports and CI/QA runs.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474891672-23414-2-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bfb2efd8d4d4..9c1543240e27 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -771,6 +771,19 @@ static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
 	destroy_workqueue(dev_priv->wq);
 }
 
+/*
+ * We don't keep the workarounds for pre-production hardware, so we expect our
+ * driver to fail on these machines in one way or another. A little warning on
+ * dmesg may help both the user and the bug triagers.
+ */
+static void intel_detect_preproduction_hw(struct drm_i915_private *dev_priv)
+{
+	if (IS_HSW_EARLY_SDV(dev_priv) ||
+	    IS_SKL_REVID(dev_priv, 0, SKL_REVID_F0))
+		DRM_ERROR("This is a pre-production stepping. "
+			  "It may not be fully functional.\n");
+}
+
 /**
  * i915_driver_init_early - setup state not requiring device access
  * @dev_priv: device private
@@ -838,13 +851,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_device_info_dump(dev_priv);
 
-	/* Not all pre-production machines fall into this category, only the
-	 * very first ones. Almost everything should work, except for maybe
-	 * suspend/resume. And we don't implement workarounds that affect only
-	 * pre-production machines. */
-	if (IS_HSW_EARLY_SDV(dev_priv))
-		DRM_INFO("This is an early pre-production Haswell machine. "
-			 "It may not be fully functional.\n");
+	intel_detect_preproduction_hw(dev_priv);
 
 	return 0;
 

commit 6a800eabba34945c2986d70114b41d564bad52a8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 21 14:51:07 2016 +0100

    drm/i915: Only shrink the unbound objects during freeze
    
    At the point of creating the hibernation image, the runtime power manage
    core is disabled - and using the rpm functions triggers a warn.
    i915_gem_shrink_all() tries to unbind objects, which requires device
    access and so tries to how an rpm reference triggering a warning:
    
    [   44.235420] ------------[ cut here ]------------
    [   44.235424] WARNING: CPU: 2 PID: 2199 at drivers/gpu/drm/i915/intel_runtime_pm.c:2688 intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235426] WARN_ON_ONCE(ret < 0)
    [   44.235445] Modules linked in: ctr ccm arc4 rt2800usb rt2x00usb rt2800lib rt2x00lib crc_ccitt mac80211 cmac cfg80211 btusb rfcomm bnep btrtl btbcm btintel bluetooth dcdbas x86_pkg_temp_thermal intel_powerclamp coretemp snd_hda_codec_realtek crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_generic aesni_intel snd_hda_codec_hdmi aes_x86_64 lrw gf128mul snd_hda_intel glue_helper ablk_helper cryptd snd_hda_codec hid_multitouch joydev snd_hda_core binfmt_misc i2c_hid serio_raw snd_pcm acpi_pad snd_timer snd i2c_designware_platform 8250_dw nls_iso8859_1 i2c_designware_core lpc_ich mfd_core soundcore usbhid hid psmouse ahci libahci
    [   44.235447] CPU: 2 PID: 2199 Comm: kworker/u8:8 Not tainted 4.8.0-rc5+ #130
    [   44.235447] Hardware name: Dell Inc. XPS 13 9343/0310JH, BIOS A07 11/11/2015
    [   44.235450] Workqueue: events_unbound async_run_entry_fn
    [   44.235453]  0000000000000000 ffff8801b2f7fb98 ffffffff81306c2f ffff8801b2f7fbe8
    [   44.235454]  0000000000000000 ffff8801b2f7fbd8 ffffffff81056c01 00000a801f50ecc0
    [   44.235456]  ffff88020ce50000 ffff88020ce59b60 ffffffff81a60b5c ffffffff81414840
    [   44.235456] Call Trace:
    [   44.235459]  [<ffffffff81306c2f>] dump_stack+0x4d/0x6e
    [   44.235461]  [<ffffffff81056c01>] __warn+0xd1/0xf0
    [   44.235464]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235465]  [<ffffffff81056c6f>] warn_slowpath_fmt+0x4f/0x60
    [   44.235468]  [<ffffffff814e73ce>] ? pm_runtime_get_if_in_use+0x6e/0xa0
    [   44.235469]  [<ffffffff81433526>] intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235471]  [<ffffffff81458a26>] i915_gem_shrink+0x306/0x360
    [   44.235473]  [<ffffffff81343fd4>] ? pci_platform_power_transition+0x24/0x90
    [   44.235475]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235476]  [<ffffffff81458dfb>] i915_gem_shrink_all+0x1b/0x30
    [   44.235478]  [<ffffffff814560b3>] i915_gem_freeze_late+0x33/0x90
    [   44.235479]  [<ffffffff81414877>] i915_pm_freeze_late+0x37/0x40
    [   44.235481]  [<ffffffff814e9b8e>] dpm_run_callback+0x4e/0x130
    [   44.235483]  [<ffffffff814ea5db>] __device_suspend_late+0xdb/0x1f0
    [   44.235484]  [<ffffffff814ea70f>] async_suspend_late+0x1f/0xa0
    [   44.235486]  [<ffffffff81077557>] async_run_entry_fn+0x37/0x150
    [   44.235488]  [<ffffffff8106f518>] process_one_work+0x148/0x3f0
    [   44.235490]  [<ffffffff8106f8eb>] worker_thread+0x12b/0x490
    [   44.235491]  [<ffffffff8106f7c0>] ? process_one_work+0x3f0/0x3f0
    [   44.235492]  [<ffffffff81074d09>] kthread+0xc9/0xe0
    [   44.235495]  [<ffffffff816e257f>] ret_from_fork+0x1f/0x40
    [   44.235496]  [<ffffffff81074c40>] ? kthread_park+0x60/0x60
    [   44.235497] ---[ end trace e438706b97c7f132 ]---
    
    Alternatively, to actually shrink everything we have to do so slightly
    earlier in the hibernation process.
    
    To keep lockdep silent, we need to take struct_mutex for the shrinker
    even though we know that we are the only user during the freeze.
    
    Fixes: 7aab2d534e35 ("drm/i915: Shrink objects prior to hibernation")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160921135108.29574-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8ae5853ea3c6..bfb2efd8d4d4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1863,7 +1863,17 @@ static int i915_pm_resume(struct device *kdev)
 /* freeze: before creating the hibernation_image */
 static int i915_pm_freeze(struct device *kdev)
 {
-	return i915_pm_suspend(kdev);
+	int ret;
+
+	ret = i915_pm_suspend(kdev);
+	if (ret)
+		return ret;
+
+	ret = i915_gem_freeze(kdev_to_i915(kdev));
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static int i915_pm_freeze_late(struct device *kdev)

commit f2a91d1a6f5960c08f1ca60bd076f4dc020c50c6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 21 14:51:06 2016 +0100

    drm/i915: Restore current RPS state after reset
    
    Following commit 821ed7df6e2a ("drm/i915: Update reset path to fix
    incomplete requests") we no longer mark the context as lost on reset as
    we keep the requests (and contexts) alive. However, RPS remains reset
    and we need to restore the current state to match the in-flight
    requests.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=97824
    Fixes: 821ed7df6e2a ("drm/i915: Update reset path to fix incomplete requests")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Arun Siluvery <arun.siluvery@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160921135108.29574-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7f4e8adec8a8..8ae5853ea3c6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1786,15 +1786,6 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	/*
-	 * rps/rc6 re-init is necessary to restore state lost after the
-	 * reset and the re-install of gt irqs. Skip for ironlake per
-	 * previous concerns that it doesn't respond well to some forms
-	 * of re-init after reset.
-	 */
-	intel_sanitize_gt_powersave(dev_priv);
-	intel_autoenable_gt_powersave(dev_priv);
-
 wakeup:
 	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
 	return;

commit 821ed7df6e2a1dbae243caebcfe21a0a4329fca0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 9 14:11:53 2016 +0100

    drm/i915: Update reset path to fix incomplete requests
    
    Update reset path in preparation for engine reset which requires
    identification of incomplete requests and associated context and fixing
    their state so that engine can resume correctly after reset.
    
    The request that caused the hang will be skipped and head is reset to the
    start of breadcrumb. This allows us to resume from where we left-off.
    Since this request didn't complete normally we also need to cleanup elsp
    queue manually. This is vital if we employ nonblocking request
    submission where we may have a web of dependencies upon the hung request
    and so advancing the seqno manually is no longer trivial.
    
    ABI: gem_reset_stats / DRM_IOCTL_I915_GET_RESET_STATS
    
    We change the way we count pending batches. Only the active context
    involved in the reset is marked as either innocent or guilty, and not
    mark the entire world as pending. By inspection this only affects
    igt/gem_reset_stats (which assumes implementation details) and not
    piglit.
    
    ARB_robustness gives this guide on how we expect the user of this
    interface to behave:
    
     * Provide a mechanism for an OpenGL application to learn about
       graphics resets that affect the context.  When a graphics reset
       occurs, the OpenGL context becomes unusable and the application
       must create a new context to continue operation. Detecting a
       graphics reset happens through an inexpensive query.
    
    And with regards to the actual meaning of the reset values:
    
       Certain events can result in a reset of the GL context. Such a reset
       causes all context state to be lost. Recovery from such events
       requires recreation of all objects in the affected context. The
       current status of the graphics reset state is returned by
    
            enum GetGraphicsResetStatusARB();
    
       The symbolic constant returned indicates if the GL context has been
       in a reset state at any point since the last call to
       GetGraphicsResetStatusARB. NO_ERROR indicates that the GL context
       has not been in a reset state since the last call.
       GUILTY_CONTEXT_RESET_ARB indicates that a reset has been detected
       that is attributable to the current GL context.
       INNOCENT_CONTEXT_RESET_ARB indicates a reset has been detected that
       is not attributable to the current GL context.
       UNKNOWN_CONTEXT_RESET_ARB indicates a detected graphics reset whose
       cause is unknown.
    
    The language here is explicit in that we must mark up the guilty batch,
    but is loose enough for us to relax the innocent (i.e. pending)
    accounting as only the active batches are involved with the reset.
    
    In the future, we are looking towards single engine resetting (with
    minimal locking), where it seems inappropriate to mark the entire world
    as innocent since the reset occurred on a different engine. Reducing the
    information available means we only have to encounter the pain once, and
    also reduces the information leaking from one context to another.
    
    v2: Legacy ringbuffer submission required a reset following hibernation,
    or else we restore stale values to the RING_HEAD and walked over
    stolen garbage.
    
    v3: GuC requires replaying the requests after a reset.
    
    v4: Restore engine IRQ after reset (so waiters will be woken!)
        Rearm hangcheck if resetting with a waiter.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160909131201.16673-13-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f2614b2f59f7..7f4e8adec8a8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -559,7 +559,6 @@ static void i915_gem_fini(struct drm_device *dev)
 	}
 
 	mutex_lock(&dev->struct_mutex);
-	i915_gem_reset(dev);
 	i915_gem_cleanup_engines(dev);
 	i915_gem_context_fini(dev);
 	mutex_unlock(&dev->struct_mutex);
@@ -1579,7 +1578,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-		set_bit(I915_WEDGED, &dev_priv->gpu_error.flags);
+		i915_gem_set_wedged(dev_priv);
 	}
 	mutex_unlock(&dev->struct_mutex);
 
@@ -1755,9 +1754,6 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
-
-	i915_gem_reset(dev);
-
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
 	if (ret) {
 		if (ret != -ENODEV)
@@ -1767,6 +1763,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	i915_gem_reset(dev_priv);
 	intel_overlay_reset(dev_priv);
 
 	/* Ok, now get things going again... */
@@ -1803,7 +1800,7 @@ void i915_reset(struct drm_i915_private *dev_priv)
 	return;
 
 error:
-	set_bit(I915_WEDGED, &error->flags);
+	i915_gem_set_wedged(dev_priv);
 	goto wakeup;
 }
 

commit 780f262a703a683bc56bbb860b25286a6f501d61
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 9 14:11:52 2016 +0100

    drm/i915: Replace wait-on-mutex with wait-on-bit in reset worker
    
    Since we have a cooperative mode now with a direct reset, we can avoid
    the contention on struct_mutex and instead try then sleep on the
    I915_RESET_IN_PROGRESS bit. If the mutex is held and that bit is
    cleared, all is fine. Otherwise, we sleep for a bit and try again. In
    the worst case we sleep for an extra second waiting for the mutex to be
    released (no one touching the GPU is allowed the struct_mutex whilst the
    I915_RESET_IN_PROGRESS bit is set). But when we have a direct reset,
    this allows us to clean up the reset worker faster.
    
    v2: Remember to call wake_up_bit() after changing (for the faster wakeup
    as promised)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160909131201.16673-12-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff4173e6e298..f2614b2f59f7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1726,8 +1726,8 @@ int i915_resume_switcheroo(struct drm_device *dev)
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
  *
- * Reset the chip.  Useful if a hang is detected. Returns zero on successful
- * reset or otherwise an error code.
+ * Reset the chip.  Useful if a hang is detected. Marks the device as wedged
+ * on failure.
  *
  * Caller must hold the struct_mutex.
  *
@@ -1739,7 +1739,7 @@ int i915_resume_switcheroo(struct drm_device *dev)
  *   - re-init interrupt state
  *   - re-init display
  */
-int i915_reset(struct drm_i915_private *dev_priv)
+void i915_reset(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
@@ -1748,7 +1748,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	lockdep_assert_held(&dev->struct_mutex);
 
 	if (!test_and_clear_bit(I915_RESET_IN_PROGRESS, &error->flags))
-		return test_bit(I915_WEDGED, &error->flags) ? -EIO : 0;
+		return;
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
 	__clear_bit(I915_WEDGED, &error->flags);
@@ -1798,11 +1798,13 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	intel_sanitize_gt_powersave(dev_priv);
 	intel_autoenable_gt_powersave(dev_priv);
 
-	return 0;
+wakeup:
+	wake_up_bit(&error->flags, I915_RESET_IN_PROGRESS);
+	return;
 
 error:
 	set_bit(I915_WEDGED, &error->flags);
-	return ret;
+	goto wakeup;
 }
 
 static int i915_pm_suspend(struct device *kdev)

commit 221fe7994554cc3985fc5d761ed7e44dcae0fa52
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 9 14:11:51 2016 +0100

    drm/i915: Perform a direct reset of the GPU from the waiter
    
    If a waiter is holding the struct_mutex, then the reset worker cannot
    reset the GPU until the waiter returns. We do not want to return -EAGAIN
    form i915_wait_request as that breaks delicate operations like
    i915_vma_unbind() which often cannot be restarted easily, and returning
    -EIO is just as useless (and has in the past proven dangerous). The
    remaining WARN_ON(i915_wait_request) serve as a valuable reminder that
    handling errors from an indefinite wait are tricky.
    
    We can keep the current semantic that knowing after a reset is complete,
    so is the request, by performing the reset ourselves if we hold the
    mutex.
    
    uevent emission is still handled by the reset worker, so it may appear
    slightly out of order with respect to the actual reset (and concurrent
    use of the device).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160909131201.16673-11-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 47a676d859db..ff4173e6e298 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1729,6 +1729,8 @@ int i915_resume_switcheroo(struct drm_device *dev)
  * Reset the chip.  Useful if a hang is detected. Returns zero on successful
  * reset or otherwise an error code.
  *
+ * Caller must hold the struct_mutex.
+ *
  * Procedure is fairly simple:
  *   - reset the chip using the reset reg
  *   - re-init context state
@@ -1743,7 +1745,10 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
 	int ret;
 
-	mutex_lock(&dev->struct_mutex);
+	lockdep_assert_held(&dev->struct_mutex);
+
+	if (!test_and_clear_bit(I915_RESET_IN_PROGRESS, &error->flags))
+		return test_bit(I915_WEDGED, &error->flags) ? -EIO : 0;
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
 	__clear_bit(I915_WEDGED, &error->flags);
@@ -1784,9 +1789,6 @@ int i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
-	clear_bit(I915_RESET_IN_PROGRESS, &error->flags);
-	mutex_unlock(&dev->struct_mutex);
-
 	/*
 	 * rps/rc6 re-init is necessary to restore state lost after the
 	 * reset and the re-install of gt irqs. Skip for ironlake per
@@ -1800,7 +1802,6 @@ int i915_reset(struct drm_i915_private *dev_priv)
 
 error:
 	set_bit(I915_WEDGED, &error->flags);
-	mutex_unlock(&dev->struct_mutex);
 	return ret;
 }
 

commit 8af29b0c78ed11a3dd2a544f9df30be988d9de29
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 9 14:11:47 2016 +0100

    drm/i915: Separate out reset flags from the reset counter
    
    In preparation for introducing a per-engine reset, we can first separate
    the mixing of the reset state from the global reset counter.
    
    The loss of atomicity in updating the reset state poses a small problem
    for handling the waiters. For requests, this is solved by advancing the
    seqno so that a waiter waking up after the reset knows the request is
    complete. For pending flips, we still rely on the increment of the
    global reset epoch (as well as the reset-in-progress flag) to signify
    when the hardware was reset.
    
    The advantage, now that we do not inspect the reset state during reset
    itself i.e. we no longer emit requests during reset, is that we can use
    the atomic updates of the state flags to ensure that only one reset
    worker is active.
    
    v2: Mika spotted that I transformed the i915_gem_wait_for_error() wakeup
    into a waiter wakeup.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Arun Siluvery <arun.siluvery@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470414607-32453-6-git-send-email-arun.siluvery@linux.intel.com
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160909131201.16673-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 02c34d6996ea..47a676d859db 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1579,7 +1579,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-		atomic_or(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
+		set_bit(I915_WEDGED, &dev_priv->gpu_error.flags);
 	}
 	mutex_unlock(&dev->struct_mutex);
 
@@ -1741,20 +1741,13 @@ int i915_reset(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
-	unsigned reset_counter;
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
-	atomic_andnot(I915_WEDGED, &error->reset_counter);
-
-	/* Clear the reset-in-progress flag and increment the reset epoch. */
-	reset_counter = atomic_inc_return(&error->reset_counter);
-	if (WARN_ON(__i915_reset_in_progress(reset_counter))) {
-		ret = -EIO;
-		goto error;
-	}
+	__clear_bit(I915_WEDGED, &error->flags);
+	error->reset_count++;
 
 	pr_notice("drm/i915: Resetting chip after gpu hang\n");
 
@@ -1791,6 +1784,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	clear_bit(I915_RESET_IN_PROGRESS, &error->flags);
 	mutex_unlock(&dev->struct_mutex);
 
 	/*
@@ -1805,7 +1799,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	return 0;
 
 error:
-	atomic_or(I915_WEDGED, &error->reset_counter);
+	set_bit(I915_WEDGED, &error->flags);
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
 }

commit 57ec171eae21ee0a2848ade1cb7f8f12a31b0731
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Aug 31 19:13:05 2016 +0300

    drm/i915: sseu: Convert subslice count fields to subslice mask
    
    In an upcoming patch we'll need the actual mask of subslices in addition
    to their count, so convert the subslice_per_slice field to a mask.
    Also we can easily calculate subslice_total from the other fields, so
    instead of storing a cached version of this, add a helper to calculate
    it.
    
    v2:
    - Use hweight8() on u8 typed vars instead of hweight32(). (Ben)
    
    Reviewed-by: Robert Bragg <robert@sixbynine.org> (v1)
    Reviewed-by: Ben Widawsky <benjamin.widawsky@intel.com> (v1)
    Tested-by: Ben Widawsky <benjamin.widawsky@intel.com> (v1)
    Signed-off-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5e22105b728f..02c34d6996ea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -288,7 +288,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = INTEL_INFO(dev_priv)->sseu.subslice_total;
+		value = sseu_subslice_total(&INTEL_INFO(dev_priv)->sseu);
 		if (!value)
 			return -ENODEV;
 		break;

commit 43b6799814ca1f29ba35a712c59cbef293573d53
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Aug 31 19:13:02 2016 +0300

    drm/i915: sseu: Use sseu_dev_info in device info
    
    Move all slice/subslice/eu related properties to the sseu_dev_info
    struct.
    
    No functional change.
    
    v2:
    - s/info/sseu/ based on the new struct name. (Ben)
    
    Reviewed-by: Robert Bragg <robert@sixbynine.org> (v1)
    Reviewed-by: Ben Widawsky <benjamin.widawsky@intel.com> (v1)
    Tested-by: Ben Widawsky <benjamin.widawsky@intel.com> (v1)
    Signed-off-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 24543079af95..5e22105b728f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -288,12 +288,12 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = INTEL_INFO(dev_priv)->subslice_total;
+		value = INTEL_INFO(dev_priv)->sseu.subslice_total;
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_EU_TOTAL:
-		value = INTEL_INFO(dev_priv)->eu_total;
+		value = INTEL_INFO(dev_priv)->sseu.eu_total;
 		if (!value)
 			return -ENODEV;
 		break;
@@ -307,7 +307,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = HAS_POOLED_EU(dev_priv);
 		break;
 	case I915_PARAM_MIN_EU_IN_POOL:
-		value = INTEL_INFO(dev_priv)->min_eu_in_pool;
+		value = INTEL_INFO(dev_priv)->sseu.min_eu_in_pool;
 		break;
 	case I915_PARAM_MMAP_GTT_VERSION:
 		/* Though we've started our numbering from 1, and so class all

commit 16162470023627776d503795d08aa5a797ce40a2
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Fri Sep 2 13:46:17 2016 +0300

    drm/i915: Cleanup i915_param()
    
    Rather than having a separate case for each value where we just return
    a hardcoded value = 1, we lump them all together and rely on the awesome
    case-fallthrough feature of C.
    
    Fix all feature macros to pass dev_priv instead of dev while at it,
    and use INTEL_GEN() instead of INTEL_INFO()->gen.
    
    Signed-off-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160902104617.29089-1-david.weinehall@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 47fe07283d88..24543079af95 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -248,22 +248,12 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_REVISION:
 		value = pdev->revision;
 		break;
-	case I915_PARAM_HAS_GEM:
-		value = 1;
-		break;
 	case I915_PARAM_NUM_FENCES_AVAIL:
 		value = dev_priv->num_fence_regs;
 		break;
 	case I915_PARAM_HAS_OVERLAY:
 		value = dev_priv->overlay ? 1 : 0;
 		break;
-	case I915_PARAM_HAS_PAGEFLIPPING:
-		value = 1;
-		break;
-	case I915_PARAM_HAS_EXECBUF2:
-		/* depends on GEM */
-		value = 1;
-		break;
 	case I915_PARAM_HAS_BSD:
 		value = intel_engine_initialized(&dev_priv->engine[VCS]);
 		break;
@@ -276,67 +266,34 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_BSD2:
 		value = intel_engine_initialized(&dev_priv->engine[VCS2]);
 		break;
-	case I915_PARAM_HAS_RELAXED_FENCING:
-		value = 1;
-		break;
-	case I915_PARAM_HAS_COHERENT_RINGS:
-		value = 1;
-		break;
 	case I915_PARAM_HAS_EXEC_CONSTANTS:
-		value = INTEL_INFO(dev)->gen >= 4;
-		break;
-	case I915_PARAM_HAS_RELAXED_DELTA:
-		value = 1;
-		break;
-	case I915_PARAM_HAS_GEN7_SOL_RESET:
-		value = 1;
+		value = INTEL_GEN(dev_priv) >= 4;
 		break;
 	case I915_PARAM_HAS_LLC:
-		value = HAS_LLC(dev);
+		value = HAS_LLC(dev_priv);
 		break;
 	case I915_PARAM_HAS_WT:
-		value = HAS_WT(dev);
+		value = HAS_WT(dev_priv);
 		break;
 	case I915_PARAM_HAS_ALIASING_PPGTT:
-		value = USES_PPGTT(dev);
-		break;
-	case I915_PARAM_HAS_WAIT_TIMEOUT:
-		value = 1;
+		value = USES_PPGTT(dev_priv);
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
 		value = i915.semaphores;
 		break;
-	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
-		value = 1;
-		break;
 	case I915_PARAM_HAS_SECURE_BATCHES:
 		value = capable(CAP_SYS_ADMIN);
 		break;
-	case I915_PARAM_HAS_PINNED_BATCHES:
-		value = 1;
-		break;
-	case I915_PARAM_HAS_EXEC_NO_RELOC:
-		value = 1;
-		break;
-	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
-		value = 1;
-		break;
 	case I915_PARAM_CMD_PARSER_VERSION:
 		value = i915_cmd_parser_get_version(dev_priv);
 		break;
-	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
-		value = 1;
-		break;
-	case I915_PARAM_MMAP_VERSION:
-		value = 1;
-		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
-		value = INTEL_INFO(dev)->subslice_total;
+		value = INTEL_INFO(dev_priv)->subslice_total;
 		if (!value)
 			return -ENODEV;
 		break;
 	case I915_PARAM_EU_TOTAL:
-		value = INTEL_INFO(dev)->eu_total;
+		value = INTEL_INFO(dev_priv)->eu_total;
 		if (!value)
 			return -ENODEV;
 		break;
@@ -344,16 +301,13 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = i915.enable_hangcheck && intel_has_gpu_reset(dev_priv);
 		break;
 	case I915_PARAM_HAS_RESOURCE_STREAMER:
-		value = HAS_RESOURCE_STREAMER(dev);
-		break;
-	case I915_PARAM_HAS_EXEC_SOFTPIN:
-		value = 1;
+		value = HAS_RESOURCE_STREAMER(dev_priv);
 		break;
 	case I915_PARAM_HAS_POOLED_EU:
-		value = HAS_POOLED_EU(dev);
+		value = HAS_POOLED_EU(dev_priv);
 		break;
 	case I915_PARAM_MIN_EU_IN_POOL:
-		value = INTEL_INFO(dev)->min_eu_in_pool;
+		value = INTEL_INFO(dev_priv)->min_eu_in_pool;
 		break;
 	case I915_PARAM_MMAP_GTT_VERSION:
 		/* Though we've started our numbering from 1, and so class all
@@ -362,6 +316,29 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		 */
 		value = i915_gem_mmap_gtt_version();
 		break;
+	case I915_PARAM_MMAP_VERSION:
+		/* Remember to bump this if the version changes! */
+	case I915_PARAM_HAS_GEM:
+	case I915_PARAM_HAS_PAGEFLIPPING:
+	case I915_PARAM_HAS_EXECBUF2: /* depends on GEM */
+	case I915_PARAM_HAS_RELAXED_FENCING:
+	case I915_PARAM_HAS_COHERENT_RINGS:
+	case I915_PARAM_HAS_RELAXED_DELTA:
+	case I915_PARAM_HAS_GEN7_SOL_RESET:
+	case I915_PARAM_HAS_WAIT_TIMEOUT:
+	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
+	case I915_PARAM_HAS_PINNED_BATCHES:
+	case I915_PARAM_HAS_EXEC_NO_RELOC:
+	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
+	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
+	case I915_PARAM_HAS_EXEC_SOFTPIN:
+		/* For the time being all of these are always true;
+		 * if some supported hardware does not have one of these
+		 * features this value needs to be provided from
+		 * INTEL_INFO(), a feature macro, or similar.
+		 */
+		value = 1;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit 4cc6907501ed2393a70ad92a30e00dc54c536e50
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 25 19:05:19 2016 +0100

    drm/i915: Add I915_PARAM_MMAP_GTT_VERSION to advertise unlimited mmaps
    
    Now that we have working partial VMA and faulting support for all
    objects, including fence support, advertise to userspace that it can
    take advantage of unlimited GGTT mmaps.
    
    v2: Make room in the kerneldoc for a more detailed explanation of the
    limitations of the GTT mmap interface.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160825180519.11341-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1d2230f7b749..47fe07283d88 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -355,6 +355,13 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_MIN_EU_IN_POOL:
 		value = INTEL_INFO(dev)->min_eu_in_pool;
 		break;
+	case I915_PARAM_MMAP_GTT_VERSION:
+		/* Though we've started our numbering from 1, and so class all
+		 * earlier versions as 0, in effect their value is undefined as
+		 * the ioctl will report EINVAL for the unknown param!
+		 */
+		value = i915_gem_mmap_gtt_version();
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit bc5ca47c0af4f949ba889e666b7da65569e36093
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 25 08:23:14 2016 +0100

    drm/i915: Restore lost "Initialized i915" welcome message
    
    A side effect of removing the midlayer from driver loading was the loss
    of a useful message announcing to userspace that i915 had successfully
    started, e.g.:
    
            [drm] Initialized i915 1.6.0 20160425 for 0000:00:02.0 on minor 0
    
    Reported-by: Timo Aaltonen <tjaalton@ubuntu.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Fixes: 8f460e2c78f2 ("drm/i915: Demidlayer driver loading")
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: drm-intel-fixes@lists.freedesktop.org
    Link: http://patchwork.freedesktop.org/patch/msgid/20160825072314.17402-1-chris@chris-wilson.co.uk
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fc9273215286..1d2230f7b749 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1255,6 +1255,11 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	intel_runtime_pm_enable(dev_priv);
 
+	/* Everything is in place, we can now relax! */
+	DRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",
+		 driver.name, driver.major, driver.minor, driver.patchlevel,
+		 driver.date, pci_name(pdev), dev_priv->drm.primary->index);
+
 	intel_runtime_pm_put(dev_priv);
 
 	return 0;

commit abc80abde5bd5962a4ec4e126ab7867c0b5fd195
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 24 10:27:01 2016 +0100

    drm/i915: Force RC6 restore after system resume and reset
    
    In order for the RC6 autoenable worker to take any action, RC6 first
    must be disabled. Upon resume or reset, the sw state may be stale and so
    we require a forced restore.
    
    Fixes: b7137e0cf1e5 ("drm/i915: Defer enabling rc6 til after we submit...")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160824092701.19178-1-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5a7c0c2e57d8..fc9273215286 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1560,6 +1560,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
+	intel_sanitize_gt_powersave(dev_priv);
 
 	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
@@ -1809,6 +1810,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	 * previous concerns that it doesn't respond well to some forms
 	 * of re-init after reset.
 	 */
+	intel_sanitize_gt_powersave(dev_priv);
 	intel_autoenable_gt_powersave(dev_priv);
 
 	return 0;

commit 36cdd0138b7f51f204df871c548b65ea2d59522d
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Mon Aug 22 13:59:31 2016 +0300

    drm/i915: debugfs spring cleaning
    
    Just like with sysfs, we do some major overhaul.
    
    Pass dev_priv instead of dev to all feature macros (IS_, HAS_,
    INTEL_, etc.). This has the side effect that a bunch of functions
    now get dev_priv passed instead of dev.
    
    All calls to INTEL_INFO()->gen have been replaced with
    INTEL_GEN().
    
    We want access to to_i915(node->minor->dev) in a lot of places,
    so add the node_to_i915() helper to accommodate for this.
    
    Finally, we have quite a few cases where we get a void * pointer,
    and need to cast it to drm_device *, only to run to_i915() on it.
    Add cast_to_i915() to do this.
    
    v2: Don't introduce extra dev (Chris)
    
    v3: Make pipe_crc_info have a pointer to drm_i915_private instead of
        drm_device. This saves a bit of space, since we never use
        drm_device anywhere in these functions.
    
        Also some minor fixup that I missed in the previous version.
    
    v4: Changed the code a bit so that dev_priv is passed directly
        to various functions, thus removing the need for the
        cast_to_i915() helper. Also did some additional cleanup.
    
    v5: Additional cleanup of newly introduced changes.
    
    v6: Rebase again because of conflict.
    
    Signed-off-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160822105931.pcbe2lpsgzckzboa@boom
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d22a1d8fe5b7..5a7c0c2e57d8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -851,7 +851,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	intel_init_audio_hooks(dev_priv);
 	i915_gem_load_init(&dev_priv->drm);
 
-	intel_display_crc_init(&dev_priv->drm);
+	intel_display_crc_init(dev_priv);
 
 	intel_device_info_dump(dev_priv);
 

commit 52a05c302bcfe571aa4896118e3d22feb51ab1c7
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Mon Aug 22 13:32:44 2016 +0300

    drm/i915: pdev cleanup
    
    In an effort to simplify things for a future push of dev_priv instead
    of dev wherever possible, always take pdev via dev_priv where
    feasible, eliminating the direct access from dev. Right now this
    only eliminates a few cases of dev, but it also obviates that we pass
    dev into a lot of functions where dev_priv would be the more obvious
    choice.
    
    v2: Fixed one more place missing in the previous patch set
    
    Signed-off-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160822103245.24069-5-david.weinehall@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c316034aeda3..d22a1d8fe5b7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -232,6 +232,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	drm_i915_getparam_t *param = data;
 	int value;
 
@@ -242,10 +243,10 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		/* Reject all old ums/dri params. */
 		return -ENODEV;
 	case I915_PARAM_CHIPSET_ID:
-		value = dev->pdev->device;
+		value = pdev->device;
 		break;
 	case I915_PARAM_REVISION:
-		value = dev->pdev->revision;
+		value = pdev->revision;
 		break;
 	case I915_PARAM_HAS_GEM:
 		value = 1;
@@ -516,7 +517,7 @@ static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_
 		pr_info("switched on\n");
 		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 		/* i915 resume handler doesn't set to D0 */
-		pci_set_power_state(dev->pdev, PCI_D0);
+		pci_set_power_state(pdev, PCI_D0);
 		i915_resume_switcheroo(dev);
 		dev->switch_power_state = DRM_SWITCH_POWER_ON;
 	} else {
@@ -585,6 +586,7 @@ static void i915_gem_fini(struct drm_device *dev)
 static int i915_load_modeset_init(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
 	if (i915_inject_load_failure())
@@ -601,13 +603,13 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	 * then we do not take part in VGA arbitration and the
 	 * vga_client_register() fails with -ENODEV.
 	 */
-	ret = vga_client_register(dev->pdev, dev, NULL, i915_vga_set_decode);
+	ret = vga_client_register(pdev, dev, NULL, i915_vga_set_decode);
 	if (ret && ret != -ENODEV)
 		goto out;
 
 	intel_register_dsm_handler();
 
-	ret = vga_switcheroo_register_client(dev->pdev, &i915_switcheroo_ops, false);
+	ret = vga_switcheroo_register_client(pdev, &i915_switcheroo_ops, false);
 	if (ret)
 		goto cleanup_vga_client;
 
@@ -659,9 +661,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 cleanup_csr:
 	intel_csr_ucode_fini(dev_priv);
 	intel_power_domains_fini(dev_priv);
-	vga_switcheroo_unregister_client(dev->pdev);
+	vga_switcheroo_unregister_client(pdev);
 cleanup_vga_client:
-	vga_client_register(dev->pdev, NULL, NULL, NULL);
+	vga_client_register(pdev, NULL, NULL, NULL);
 out:
 	return ret;
 }
@@ -881,6 +883,7 @@ static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 static int i915_mmio_setup(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int mmio_bar;
 	int mmio_size;
 
@@ -897,7 +900,7 @@ static int i915_mmio_setup(struct drm_device *dev)
 		mmio_size = 512 * 1024;
 	else
 		mmio_size = 2 * 1024 * 1024;
-	dev_priv->regs = pci_iomap(dev->pdev, mmio_bar, mmio_size);
+	dev_priv->regs = pci_iomap(pdev, mmio_bar, mmio_size);
 	if (dev_priv->regs == NULL) {
 		DRM_ERROR("failed to map registers\n");
 
@@ -913,9 +916,10 @@ static int i915_mmio_setup(struct drm_device *dev)
 static void i915_mmio_cleanup(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 
 	intel_teardown_mchbar(dev);
-	pci_iounmap(dev->pdev, dev_priv->regs);
+	pci_iounmap(pdev, dev_priv->regs);
 }
 
 /**
@@ -994,6 +998,7 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
  */
 static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 {
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	struct drm_device *dev = &dev_priv->drm;
 	int ret;
 
@@ -1032,11 +1037,11 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		goto out_ggtt;
 	}
 
-	pci_set_master(dev->pdev);
+	pci_set_master(pdev);
 
 	/* overlay on gen2 is broken and can't address above 1G */
 	if (IS_GEN2(dev)) {
-		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(30));
+		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(30));
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
 
@@ -1053,7 +1058,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * which also needs to be handled carefully.
 	 */
 	if (IS_BROADWATER(dev) || IS_CRESTLINE(dev)) {
-		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(32));
+		ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 
 		if (ret) {
 			DRM_ERROR("failed to set DMA mask\n");
@@ -1083,7 +1088,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	 * stuck interrupts on some machines.
 	 */
 	if (!IS_I945G(dev) && !IS_I945GM(dev)) {
-		if (pci_enable_msi(dev->pdev) < 0)
+		if (pci_enable_msi(pdev) < 0)
 			DRM_DEBUG_DRIVER("can't enable MSI");
 	}
 
@@ -1101,10 +1106,10 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = &dev_priv->drm;
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	if (dev->pdev->msi_enabled)
-		pci_disable_msi(dev->pdev);
+	if (pdev->msi_enabled)
+		pci_disable_msi(pdev);
 
 	pm_qos_remove_request(&dev_priv->pm_qos);
 	i915_ggtt_cleanup_hw(dev_priv);
@@ -1274,6 +1279,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 void i915_driver_unload(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 
 	intel_fbdev_fini(dev);
 
@@ -1302,8 +1308,8 @@ void i915_driver_unload(struct drm_device *dev)
 	kfree(dev_priv->vbt.lfp_lvds_vbt_mode);
 	dev_priv->vbt.lfp_lvds_vbt_mode = NULL;
 
-	vga_switcheroo_unregister_client(dev->pdev);
-	vga_client_register(dev->pdev, NULL, NULL, NULL);
+	vga_switcheroo_unregister_client(pdev);
+	vga_client_register(pdev, NULL, NULL, NULL);
 
 	intel_csr_ucode_fini(dev_priv);
 
@@ -1400,6 +1406,7 @@ static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 static int i915_drm_suspend(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	pci_power_t opregion_target_state;
 	int error;
 
@@ -1416,11 +1423,11 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	drm_kms_helper_poll_disable(dev);
 
-	pci_save_state(dev->pdev);
+	pci_save_state(pdev);
 
 	error = i915_gem_suspend(dev);
 	if (error) {
-		dev_err(&dev->pdev->dev,
+		dev_err(&pdev->dev,
 			"GEM idle failed, resume might fail\n");
 		goto out;
 	}
@@ -1465,6 +1472,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	bool fw_csr;
 	int ret;
 
@@ -1498,7 +1506,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 		goto out;
 	}
 
-	pci_disable_device(dev->pdev);
+	pci_disable_device(pdev);
 	/*
 	 * During hibernation on some platforms the BIOS may try to access
 	 * the device even though it's already in D3 and hang the machine. So
@@ -1512,7 +1520,7 @@ static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 	 * Acer Aspire 1830T
 	 */
 	if (!(hibernation && INTEL_INFO(dev_priv)->gen < 6))
-		pci_set_power_state(dev->pdev, PCI_D3hot);
+		pci_set_power_state(pdev, PCI_D3hot);
 
 	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
 
@@ -1629,6 +1637,7 @@ static int i915_drm_resume(struct drm_device *dev)
 static int i915_drm_resume_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	int ret;
 
 	/*
@@ -1651,7 +1660,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 * the device powered we can also remove the following set power state
 	 * call.
 	 */
-	ret = pci_set_power_state(dev->pdev, PCI_D0);
+	ret = pci_set_power_state(pdev, PCI_D0);
 	if (ret) {
 		DRM_ERROR("failed to set PCI D0 power state (%d)\n", ret);
 		goto out;
@@ -1670,12 +1679,12 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 * depend on the device enable refcount we can't anyway depend on them
 	 * disabling/enabling the device.
 	 */
-	if (pci_enable_device(dev->pdev)) {
+	if (pci_enable_device(pdev)) {
 		ret = -EIO;
 		goto out;
 	}
 
-	pci_set_master(dev->pdev);
+	pci_set_master(pdev);
 
 	disable_rpm_wakeref_asserts(dev_priv);
 

commit 694c2828459e1d048b79c42dd8decbafb099707d
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Mon Aug 22 13:32:43 2016 +0300

    drm/i915: i915_sysfs.c cleanup
    
    Various cleanup for i915_sysfs.c; we now use dev_priv whenever
    possible. The kdev_to_drm_minor() helper function has been
    replaced by one that converts from struct device *
    to struct drm_i915_private *.
    
    We already have a seemingly identical helper (kdev_to_i915())
    in i915_drv.h. But that one cannot be used here.
    Unlike the version in i915_drv.h, this helper
    reaches i915 through drm_minor.
    
    v2: Rename kdev_to_i915_dm() to kdev_minor_to_i915() (Chris)
    
    Signed-off-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160822103245.24069-4-david.weinehall@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 53f9535fb81e..c316034aeda3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1133,7 +1133,7 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	/* Reveal our presence to userspace */
 	if (drm_dev_register(dev, 0) == 0) {
 		i915_debugfs_register(dev_priv);
-		i915_setup_sysfs(dev);
+		i915_setup_sysfs(dev_priv);
 	} else
 		DRM_ERROR("Failed to register driver for userspace access!\n");
 
@@ -1170,7 +1170,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	acpi_video_unregister();
 	intel_opregion_unregister(dev_priv);
 
-	i915_teardown_sysfs(&dev_priv->drm);
+	i915_teardown_sysfs(dev_priv);
 	i915_debugfs_unregister(dev_priv);
 	drm_dev_unregister(&dev_priv->drm);
 

commit c49d13ee13f709852cc05f9035df89e9ffa26108
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Mon Aug 22 13:32:42 2016 +0300

    drm/i915: consistent struct device naming
    
    We currently have a mix of struct device *device, struct device *kdev,
    and struct device *dev (the latter forcing us to refer to
    struct drm_device as something else than the normal dev).
    
    To simplify things, always use kdev when referring to struct device.
    
    v2: Replace the dev_to_drm_minor() macro with the inline function
        kdev_to_drm_minor().
    
    Signed-off-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160822103245.24069-3-david.weinehall@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 13ae340ef1f3..53f9535fb81e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -77,7 +77,7 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	      const char *fmt, ...)
 {
 	static bool shown_bug_once;
-	struct device *dev = dev_priv->drm.dev;
+	struct device *kdev = dev_priv->drm.dev;
 	bool is_error = level[1] <= KERN_ERR[1];
 	bool is_debug = level[1] == KERN_DEBUG[1];
 	struct va_format vaf;
@@ -91,11 +91,11 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	dev_printk(level, dev, "[" DRM_NAME ":%ps] %pV",
+	dev_printk(level, kdev, "[" DRM_NAME ":%ps] %pV",
 		   __builtin_return_address(0), &vaf);
 
 	if (is_error && !shown_bug_once) {
-		dev_notice(dev, "%s", FDO_BUG_MSG);
+		dev_notice(kdev, "%s", FDO_BUG_MSG);
 		shown_bug_once = true;
 	}
 
@@ -1462,9 +1462,9 @@ static int i915_drm_suspend(struct drm_device *dev)
 	return error;
 }
 
-static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
+static int i915_drm_suspend_late(struct drm_device *dev, bool hibernation)
 {
-	struct drm_i915_private *dev_priv = to_i915(drm_dev);
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	bool fw_csr;
 	int ret;
 
@@ -1498,7 +1498,7 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 		goto out;
 	}
 
-	pci_disable_device(drm_dev->pdev);
+	pci_disable_device(dev->pdev);
 	/*
 	 * During hibernation on some platforms the BIOS may try to access
 	 * the device even though it's already in D3 and hang the machine. So
@@ -1512,7 +1512,7 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	 * Acer Aspire 1830T
 	 */
 	if (!(hibernation && INTEL_INFO(dev_priv)->gen < 6))
-		pci_set_power_state(drm_dev->pdev, PCI_D3hot);
+		pci_set_power_state(dev->pdev, PCI_D3hot);
 
 	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
 
@@ -1810,25 +1810,25 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-static int i915_pm_suspend(struct device *dev)
+static int i915_pm_suspend(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct pci_dev *pdev = to_pci_dev(kdev);
+	struct drm_device *dev = pci_get_drvdata(pdev);
 
-	if (!drm_dev) {
-		dev_err(dev, "DRM not initialized, aborting suspend.\n");
+	if (!dev) {
+		dev_err(kdev, "DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
 	}
 
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend(drm_dev);
+	return i915_drm_suspend(dev);
 }
 
-static int i915_pm_suspend_late(struct device *dev)
+static int i915_pm_suspend_late(struct device *kdev)
 {
-	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 
 	/*
 	 * We have a suspend ordering issue with the snd-hda driver also
@@ -1839,57 +1839,57 @@ static int i915_pm_suspend_late(struct device *dev)
 	 * FIXME: This should be solved with a special hdmi sink device or
 	 * similar so that power domains can be employed.
 	 */
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend_late(drm_dev, false);
+	return i915_drm_suspend_late(dev, false);
 }
 
-static int i915_pm_poweroff_late(struct device *dev)
+static int i915_pm_poweroff_late(struct device *kdev)
 {
-	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend_late(drm_dev, true);
+	return i915_drm_suspend_late(dev, true);
 }
 
-static int i915_pm_resume_early(struct device *dev)
+static int i915_pm_resume_early(struct device *kdev)
 {
-	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_resume_early(drm_dev);
+	return i915_drm_resume_early(dev);
 }
 
-static int i915_pm_resume(struct device *dev)
+static int i915_pm_resume(struct device *kdev)
 {
-	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
+	struct drm_device *dev = &kdev_to_i915(kdev)->drm;
 
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_resume(drm_dev);
+	return i915_drm_resume(dev);
 }
 
 /* freeze: before creating the hibernation_image */
-static int i915_pm_freeze(struct device *dev)
+static int i915_pm_freeze(struct device *kdev)
 {
-	return i915_pm_suspend(dev);
+	return i915_pm_suspend(kdev);
 }
 
-static int i915_pm_freeze_late(struct device *dev)
+static int i915_pm_freeze_late(struct device *kdev)
 {
 	int ret;
 
-	ret = i915_pm_suspend_late(dev);
+	ret = i915_pm_suspend_late(kdev);
 	if (ret)
 		return ret;
 
-	ret = i915_gem_freeze_late(dev_to_i915(dev));
+	ret = i915_gem_freeze_late(kdev_to_i915(kdev));
 	if (ret)
 		return ret;
 
@@ -1897,25 +1897,25 @@ static int i915_pm_freeze_late(struct device *dev)
 }
 
 /* thaw: called after creating the hibernation image, but before turning off. */
-static int i915_pm_thaw_early(struct device *dev)
+static int i915_pm_thaw_early(struct device *kdev)
 {
-	return i915_pm_resume_early(dev);
+	return i915_pm_resume_early(kdev);
 }
 
-static int i915_pm_thaw(struct device *dev)
+static int i915_pm_thaw(struct device *kdev)
 {
-	return i915_pm_resume(dev);
+	return i915_pm_resume(kdev);
 }
 
 /* restore: called after loading the hibernation image. */
-static int i915_pm_restore_early(struct device *dev)
+static int i915_pm_restore_early(struct device *kdev)
 {
-	return i915_pm_resume_early(dev);
+	return i915_pm_resume_early(kdev);
 }
 
-static int i915_pm_restore(struct device *dev)
+static int i915_pm_restore(struct device *kdev)
 {
-	return i915_pm_resume(dev);
+	return i915_pm_resume(kdev);
 }
 
 /*
@@ -2277,9 +2277,9 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 	return ret;
 }
 
-static int intel_runtime_suspend(struct device *device)
+static int intel_runtime_suspend(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(device);
+	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
@@ -2305,7 +2305,7 @@ static int intel_runtime_suspend(struct device *device)
 		 * Bump the expiration timestamp, otherwise the suspend won't
 		 * be rescheduled.
 		 */
-		pm_runtime_mark_last_busy(device);
+		pm_runtime_mark_last_busy(kdev);
 
 		return -EAGAIN;
 	}
@@ -2384,9 +2384,9 @@ static int intel_runtime_suspend(struct device *device)
 	return 0;
 }
 
-static int intel_runtime_resume(struct device *device)
+static int intel_runtime_resume(struct device *kdev)
 {
-	struct pci_dev *pdev = to_pci_dev(device);
+	struct pci_dev *pdev = to_pci_dev(kdev);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret = 0;

commit cc9263874b42bf98209dce0afe698b550648e770
Merge: 02bef8f98d26 fc93ff608b15
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 15 10:41:47 2016 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next-queued
    
    Backmerge because too many conflicts, and also we need to get at the
    latest struct fence patches from Gustavo. Requested by Chris Wilson.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit fc93ff608b15ae32cde3006b7af860b59cac20ec
Merge: f8725ad1da51 c5b7e97b27db
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 15 16:53:57 2016 +1000

    Merge tag 'drm-intel-next-2016-08-08' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - refactor ddi buffer programming a bit (Ville)
    - large-scale renaming to untangle naming in the gem code (Chris)
    - rework vma/active tracking for accurately reaping idle mappings of shared
      objects (Chris)
    - misc dp sst/mst probing corner case fixes (Ville)
    - tons of cleanup&tunings all around in gem
    - lockless (rcu-protected) request lookup, plus use it everywhere for
      non(b)locking waits (Chris)
    - pipe crc debugfs fixes (Rodrigo)
    - random fixes all over
    
    * tag 'drm-intel-next-2016-08-08' of git://anongit.freedesktop.org/drm-intel: (222 commits)
      drm/i915: Update DRIVER_DATE to 20160808
      drm/i915: fix aliasing_ppgtt leak
      drm/i915: Update comment before i915_spin_request
      drm/i915: Use drm official vblank_no_hw_counter callback.
      drm/i915: Fix copy_to_user usage for pipe_crc
      Revert "drm/i915: Track active streams also for DP SST"
      drm/i915: fix WaInsertDummyPushConstPs
      drm/i915: Assert that the request hasn't been retired
      drm/i915: Repack fence tiling mode and stride into a single integer
      drm/i915: Document and reject invalid tiling modes
      drm/i915: Remove locking for get_tiling
      drm/i915: Remove pinned check from madvise ioctl
      drm/i915: Reduce locking inside swfinish ioctl
      drm/i915: Remove (struct_mutex) locking for busy-ioctl
      drm/i915: Remove (struct_mutex) locking for wait-ioctl
      drm/i915: Do a nonblocking wait first in pread/pwrite
      drm/i915: Remove unused no-shrinker-steal
      drm/i915: Tidy generation of the GTT mmap offset
      drm/i915/shrinker: Wait before acquiring struct_mutex under oom
      drm/i915: Simplify do_idling() (Ironlake vt-d w/a)
      ...

commit 0b1de5d58e1972a88cfa5d1ea709a7b16934783a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 12 12:39:59 2016 +0100

    drm/i915: Use SSE4.1 movntdqa to accelerate reads from WC memory
    
    This patch provides the infrastructure for performing a 16-byte aligned
    read from WC memory using non-temporal instructions introduced with sse4.1.
    Using movntdqa we can bypass the CPU caches and read directly from memory
    and ignoring the page attributes set on the CPU PTE i.e. negating the
    impact of an otherwise UC access. Copying using movntdqa from WC is almost
    as fast as reading from WB memory, modulo the possibility of both hitting
    the CPU cache or leaving the data in the CPU cache for the next consumer.
    (The CPU cache itself my be flushed for the region of the movntdqa and on
    later access the movntdqa reads from a separate internal buffer for the
    cacheline.) The write back to the memory is however cached.
    
    This will be used in later patches to accelerate accessing WC memory.
    
    v2: Report whether the accelerated copy is successful/possible.
    v3: Function alignment override was only necessary when using the
    function target("sse4.1") - which is not necessary for emitting movntdqa
    from __asm__.
    v4: Improve notes on CPU cache behaviour vs non-temporal stores.
    v5: Fix byte offsets for unrolled moves.
    v6: Find all remaining typos of "movntqda", use kernel_fpu_begin.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Akash Goel <akash.goel@intel.com>
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471001999-17787-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0fcd1c0f67bb..9b9ea8d3ecdc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -827,6 +827,8 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	mutex_init(&dev_priv->wm.wm_mutex);
 	mutex_init(&dev_priv->pps_mutex);
 
+	i915_memcpy_init_early(dev_priv);
+
 	ret = i915_workqueues_init(dev_priv);
 	if (ret < 0)
 		return ret;

commit 44adece57e2604cec8527a499b48e4d584ab53b8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 10 18:52:34 2016 +0200

    drm/fb-helper: Add a dummy remove_conflicting_framebuffers
    
    Lots of drivers don't properly compile without this when CONFIG_FB=n.
    It's kinda a hack, but since CONFIG_FB doesn't stub any fucntions when
    it's disabled I think it makes sense to add it to drm_fb_helper.h.
    
    Long term we probably need to rethink all the logic to unload firmware
    framebuffer drivers, at least if we want to be able to move away from
    CONFIG_FB and fbcon.
    
    v2: Unfortunately just stubbing out remove_conflicting_framebuffers in
    drm_fb_helper.h upset gcc about static vs. non-static declarations, so
    a new wrapper it needs to be. Means more churn :(
    
    Cc: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Cc: Noralf Trønnes <noralf@tronnes.org>
    Cc: tomi.valkeinen@ti.com
    Cc: dh.herrmann@gmail.com
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470847958-28465-2-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 95ddd56b89f0..40cd16cf9772 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -706,7 +706,7 @@ static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 	primary =
 		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
 
-	ret = remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
+	ret = drm_fb_helper_remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
 
 	kfree(ap);
 

commit 8090ba8c216ff75c32ecb85c41adf3c5126d8a92
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Aug 10 14:07:33 2016 +0300

    drm/i915: Apply the PPS register unlock workaround more consistently
    
    Atm, we apply this workaround somewhat inconsistently at the following
    points: driver loading, LVDS init, eDP PPS init, system resume. As this
    workaround also affects registers other than PPS (timing, PLL) a more
    consistent way is to apply it early after the PPS HW context is known to
    be lost: driver loading, system resume and on VLV/CHV/BXT when turning
    on power domains.
    
    This is needed by the next patch that removes saving/restoring of the
    PP_CONTROL register.
    
    This also removes the incorrect programming of the workaround on HSW+
    PCH platforms which don't have the register locking mechanism.
    
    v2: (Ville)
    - Don't apply the workaround on BXT.
    - Simplify platform checks using HAS_DDI().
    v3:
    - Move the call of intel_pps_unlock_regs_wa() to the more
      logical vlv_display_power_well_init() (also fixing CHV) (Ville).
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470827254-21954-5-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8cfc264ec9f6..0fcd1c0f67bb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1560,6 +1560,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	i915_gem_resume(dev);
 
 	i915_restore_state(dev);
+	intel_pps_unlock_regs_wa(dev_priv);
 	intel_opregion_setup(dev_priv);
 
 	intel_init_pch_refclk(dev);

commit b1f788c6acb2f34622dd5f4c3d5210c6e3945e78
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 4 07:52:45 2016 +0100

    drm/i915: Release vma when the handle is closed
    
    In order to prevent a leak of the vma on shared objects, we need to
    hook into the object_close callback to destroy the vma on the object for
    this file. However, if we destroyed that vma immediately we may cause
    unexpected application stalls as we try to unbind a busy vma - hence we
    defer the unbind to when we retire the vma.
    
    v2: Keep vma allocated until closed. This is useful for a later
    optimisation, but it is required now in order to handle potential
    recursion of i915_vma_unbind() by retiring itself.
    v3: Comments are important.
    
    Testcase: igt/gem_ppggtt/flink-and-close-vma-leak
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470293567-10811-26-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 50c564089fa8..8cfc264ec9f6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2578,6 +2578,7 @@ static struct drm_driver driver = {
 	.postclose = i915_driver_postclose,
 	.set_busid = drm_pci_set_busid,
 
+	.gem_close_object = i915_gem_close_object,
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
 

commit f6b9d5cabd582bcae8db92eac0c3a138370e4167
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 4 07:52:23 2016 +0100

    drm/i915: Split early global GTT initialisation
    
    Initialising the global GTT is tricky as we wish to use the drm_mm range
    manager during the modesetting initialisation (to capture stolen
    allocations from the BIOS) before we actually enable GEM. To overcome
    this, we currently setup the drm_mm first and then carefully rebind
    them.
    
    v2: Fixup after rebasing
    v3: GGTT initialisation needs to be split around kicking out conflicts
    v4: Restore an old UMS BUG_ON(mappable > total) as a DRM_ERROR plus
    fixup of probe results.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470293567-10811-4-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ed52f61d8560..50c564089fa8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -993,8 +993,6 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
-	struct i915_ggtt *ggtt = &dev_priv->ggtt;
-	uint32_t aperture_size;
 	int ret;
 
 	if (i915_inject_load_failure())
@@ -1044,7 +1042,6 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		}
 	}
 
-
 	/* 965GM sometimes incorrectly writes to hardware status page (HWS)
 	 * using 32bit addressing, overwriting memory if HWS is located
 	 * above 4GB.
@@ -1063,19 +1060,6 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		}
 	}
 
-	aperture_size = ggtt->mappable_end;
-
-	ggtt->mappable =
-		io_mapping_create_wc(ggtt->mappable_base,
-				     aperture_size);
-	if (!ggtt->mappable) {
-		ret = -EIO;
-		goto out_ggtt;
-	}
-
-	ggtt->mtrr = arch_phys_wc_add(ggtt->mappable_base,
-					      aperture_size);
-
 	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
 			   PM_QOS_DEFAULT_VALUE);
 
@@ -1116,14 +1100,11 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = &dev_priv->drm;
-	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 
 	if (dev->pdev->msi_enabled)
 		pci_disable_msi(dev->pdev);
 
 	pm_qos_remove_request(&dev_priv->pm_qos);
-	arch_phys_wc_del(ggtt->mtrr);
-	io_mapping_free(ggtt->mappable);
 	i915_ggtt_cleanup_hw(dev_priv);
 }
 

commit 97d6d7ab68e0b1f7268a5a69187c86305d65762f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 4 07:52:22 2016 +0100

    drm/i915: Update GGTT initialisation functions to take drm_i915_private
    
    Since these are internal functions they operate on drm_i915_private and
    not the drm_device being passed in. So pass in the drm_i915_private
    instead, and remove one layer of dancing. No space wins here, just
    conforming to the norm in function parameters.
    
    v2: Include all the probe functions
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470293567-10811-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8996c2a6cd07..ed52f61d8560 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1004,7 +1004,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_sanitize_options(dev_priv);
 
-	ret = i915_ggtt_probe_hw(dev);
+	ret = i915_ggtt_probe_hw(dev_priv);
 	if (ret)
 		return ret;
 
@@ -1022,11 +1022,11 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		goto out_ggtt;
 	}
 
-	ret = i915_ggtt_init_hw(dev);
+	ret = i915_ggtt_init_hw(dev_priv);
 	if (ret)
 		return ret;
 
-	ret = i915_ggtt_enable_hw(dev);
+	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret) {
 		DRM_ERROR("failed to enable GGTT\n");
 		goto out_ggtt;
@@ -1104,7 +1104,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	return 0;
 
 out_ggtt:
-	i915_ggtt_cleanup_hw(dev);
+	i915_ggtt_cleanup_hw(dev_priv);
 
 	return ret;
 }
@@ -1124,7 +1124,7 @@ static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 	pm_qos_remove_request(&dev_priv->pm_qos);
 	arch_phys_wc_del(ggtt->mtrr);
 	io_mapping_free(ggtt->mappable);
-	i915_ggtt_cleanup_hw(dev);
+	i915_ggtt_cleanup_hw(dev_priv);
 }
 
 /**
@@ -1570,7 +1570,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
-	ret = i915_ggtt_enable_hw(dev);
+	ret = i915_ggtt_enable_hw(dev_priv);
 	if (ret)
 		DRM_ERROR("failed to re-enable GGTT\n");
 

commit 0088e522ddcb2cb5763ad85f9db2c2b473843d8d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 4 07:52:21 2016 +0100

    drm/i915: Split GGTT initialisation between probing and setup
    
    In order to handle conflicting drivers (i.e. vgacon) having a different
    setup of hardware, we have to remove those other drivers before we try
    to setup our own mappings. This requires us to split GGTT initialisation
    between probing for the hardware location (part of the PCI BAR) and
    later establishing the kernel resources for it.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470293567-10811-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83afdd0597b5..8996c2a6cd07 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1004,16 +1004,10 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 
 	intel_sanitize_options(dev_priv);
 
-	ret = i915_ggtt_init_hw(dev);
+	ret = i915_ggtt_probe_hw(dev);
 	if (ret)
 		return ret;
 
-	ret = i915_ggtt_enable_hw(dev);
-	if (ret) {
-		DRM_ERROR("failed to enable GGTT\n");
-		goto out_ggtt;
-	}
-
 	/* WARNING: Apparently we must kick fbdev drivers before vgacon,
 	 * otherwise the vga fbdev driver falls over. */
 	ret = i915_kick_out_firmware_fb(dev_priv);
@@ -1028,6 +1022,16 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 		goto out_ggtt;
 	}
 
+	ret = i915_ggtt_init_hw(dev);
+	if (ret)
+		return ret;
+
+	ret = i915_ggtt_enable_hw(dev);
+	if (ret) {
+		DRM_ERROR("failed to enable GGTT\n");
+		goto out_ggtt;
+	}
+
 	pci_set_master(dev->pdev);
 
 	/* overlay on gen2 is broken and can't address above 1G */

commit 54b4f68f184c4b8409c113148758baf37d51351b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 21 21:16:19 2016 +0100

    Revert "drm/i915: Enable RC6 immediately"
    
    This reverts commit b12e0ee2080c ("drm/i915: Enable RC6 immediately"),
    as it was never meant to be sent anywhere other than the bug report for
    experimentation.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469132179-4052-1-git-send-email-chris@chris-wilson.co.uk
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 84e4018b18a7..83afdd0597b5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1630,6 +1630,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
+	intel_autoenable_gt_powersave(dev_priv);
 	drm_kms_helper_poll_enable(dev);
 
 	enable_rpm_wakeref_asserts(dev_priv);
@@ -1811,8 +1812,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	 * previous concerns that it doesn't respond well to some forms
 	 * of re-init after reset.
 	 */
-	if (INTEL_GEN(dev_priv) > 5)
-		intel_enable_gt_powersave(dev_priv);
+	intel_autoenable_gt_powersave(dev_priv);
 
 	return 0;
 
@@ -2440,7 +2440,6 @@ static int intel_runtime_resume(struct device *device)
 	i915_gem_init_swizzling(dev);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
-	intel_enable_gt_powersave(dev_priv);
 
 	/*
 	 * On VLV/CHV display interrupts are part of the display

commit b12e0ee2080c093a08243726f0f3c57fddf954a5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 21 18:28:30 2016 +0100

    drm/i915: Enable RC6 immediately
    
    Now that PCU communication is reasonably fast, we do not need to defer
    RC6 initialisation to a workqueue.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=97017
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83afdd0597b5..84e4018b18a7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1630,7 +1630,6 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
-	intel_autoenable_gt_powersave(dev_priv);
 	drm_kms_helper_poll_enable(dev);
 
 	enable_rpm_wakeref_asserts(dev_priv);
@@ -1812,7 +1811,8 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	 * previous concerns that it doesn't respond well to some forms
 	 * of re-init after reset.
 	 */
-	intel_autoenable_gt_powersave(dev_priv);
+	if (INTEL_GEN(dev_priv) > 5)
+		intel_enable_gt_powersave(dev_priv);
 
 	return 0;
 
@@ -2440,6 +2440,7 @@ static int intel_runtime_resume(struct device *device)
 	i915_gem_init_swizzling(dev);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
+	intel_enable_gt_powersave(dev_priv);
 
 	/*
 	 * On VLV/CHV display interrupts are part of the display

commit 39df91905df3ba2d3a8e1270a30845970c9e2001
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jul 20 13:31:57 2016 +0100

    drm/i915: Convert i915_semaphores_is_enabled over to early sanitize
    
    Rather than recomputing whether semaphores are enabled, we can do that
    computation once during early initialisation as the i915.semaphores
    module parameter is now read-only.
    
    s/i915_semaphores_is_enabled/i915.semaphores/
    
    v2: Add the state to the debug dmesg as well
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469005202-9659-10-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469017917-15134-9-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c5b7b8e0678a..83afdd0597b5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -228,27 +228,6 @@ static void intel_detect_pch(struct drm_device *dev)
 	pci_dev_put(pch);
 }
 
-bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
-{
-	if (INTEL_GEN(dev_priv) < 6)
-		return false;
-
-	if (i915.semaphores >= 0)
-		return i915.semaphores;
-
-	/* TODO: make semaphores and Execlists play nicely together */
-	if (i915.enable_execlists)
-		return false;
-
-#ifdef CONFIG_INTEL_IOMMU
-	/* Enable semaphores on SNB when IO remapping is off */
-	if (IS_GEN6(dev_priv) && intel_iommu_gfx_mapped)
-		return false;
-#endif
-
-	return true;
-}
-
 static int i915_getparam(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
 {
@@ -324,7 +303,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		value = 1;
 		break;
 	case I915_PARAM_HAS_SEMAPHORES:
-		value = i915_semaphore_is_enabled(dev_priv);
+		value = i915.semaphores;
 		break;
 	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
 		value = 1;
@@ -999,6 +978,9 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
 	i915.enable_ppgtt =
 		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
 	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
+
+	i915.semaphores = intel_sanitize_semaphores(dev_priv, i915.semaphores);
+	DRM_DEBUG_DRIVER("use GPU sempahores? %s\n", yesno(i915.semaphores));
 }
 
 /**

commit 84c8e0963da434d37355079b568465cd121af295
Author: Lyude <cpaul@redhat.com>
Date:   Tue Jun 21 17:03:44 2016 -0400

    drm/i915: Enable polling when we don't have hpd
    
    Unfortunately, there's two situations where we lose hpd right now:
    - Runtime suspend
    - When we've shut off all of the power wells on Valleyview/Cherryview
    
    While it would be nice if this didn't cause issues, this has the
    ability to get us in some awkward states where a user won't be able to
    get their display to turn on. For instance; if we boot a Valleyview
    system without any monitors connected, it won't need any of it's power
    wells and thus shut them off. Since this causes us to lose HPD, this
    means that unless the user knows how to ssh into their machine and do a
    manual reprobe for monitors, none of the monitors they connect after
    booting will actually work.
    
    Eventually we should come up with a better fix then having to enable
    polling for this, since this makes rpm a lot less useful, but for now
    the infrastructure in i915 just isn't there yet to get hpd in these
    situations.
    
    Changes since v1:
     - Add comment explaining the addition of the if
       (!mode_config->poll_running) in intel_hpd_init()
     - Remove unneeded if (!dev->mode_config.poll_enabled) in
       i915_hpd_poll_init_work()
     - Call to drm_helper_hpd_irq_event() after we disable polling
     - Add cancel_work_sync() call to intel_hpd_cancel_work()
    
    Changes since v2:
     - Apparently dev->mode_config.poll_running doesn't actually reflect
       whether or not a poll is currently in progress, and is actually used
       for dynamic module paramter enabling/disabling. So now we instead
       keep track of our own poll_running variable in dev_priv->hotplug
     - Clean i915_hpd_poll_init_work() a little bit
    
    Changes since v3:
     - Remove the now-redundant connector loop in intel_hpd_init(), just
       rely on intel_hpd_poll_enable() for setting connector->polled
       correctly on each connector
     - Get rid of poll_running
     - Don't assign enabled in i915_hpd_poll_init_work before we actually
       lock dev->mode_config.mutex
     - Wrap enabled assignment in i915_hpd_poll_init_work() in READ_ONCE()
       for doc purposes
     - Do the same for dev_priv->hotplug.poll_enabled with WRITE_ONCE in
       intel_hpd_poll_enable()
     - Add some comments about racing not mattering in intel_hpd_poll_enable
    
    Changes since v4:
     - Rename intel_hpd_poll_enable() to intel_hpd_poll_init()
     - Drop the bool argument from intel_hpd_poll_init()
     - Remove redundant calls to intel_hpd_poll_init()
     - Rename poll_enable_work to poll_init_work
     - Add some kerneldoc for intel_hpd_poll_init()
     - Cross-reference intel_hpd_poll_init() in intel_hpd_init()
     - Just copy the loop from intel_hpd_init() in intel_hpd_poll_init()
    
    Changes since v5:
     - Minor kerneldoc nitpicks
    
    Cc: stable@vger.kernel.org
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Lyude <cpaul@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    (cherry picked from commit 19625e85c6ec56038368aa72c44f5f55b221f0fc)

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b9a811750ca8..95ddd56b89f0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2413,6 +2413,9 @@ static int intel_runtime_suspend(struct device *device)
 
 	assert_forcewakes_inactive(dev_priv);
 
+	if (!IS_VALLEYVIEW(dev_priv) || !IS_CHERRYVIEW(dev_priv))
+		intel_hpd_poll_init(dev_priv);
+
 	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;
 }

commit 5ab57c7020697942ea15f45ad14c69cecb164329
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 15 14:56:20 2016 +0100

    drm/i915: Flush logical context image out to memory upon suspend
    
    Before suspend, and especially before building the hibernation image, we
    need to context image to be coherent in memory. To do this we require
    that we perform a context switch to a disposable context (i.e. the
    dev_priv->kernel_context) - when that switch is complete, all other
    context images will be complete. This leaves the kernel_context image as
    incomplete, but fortunately that is disposable and we can do a quick
    fixup of the logical state after resuming.
    
    v2: Share the nearly identical code to switch to the kernel context with
    eviction.
    v3: Explain why we need the switch and reset.
    
    Testcase: igt/gem_exec_suspend # bsw
    References: https://bugs.freedesktop.org/show_bug.cgi?id=96526
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468590980-6186-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 15440123e38d..c5b7b8e0678a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1590,9 +1590,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_csr_ucode_resume(dev_priv);
 
-	mutex_lock(&dev->struct_mutex);
-	i915_gem_restore_gtt_mappings(dev);
-	mutex_unlock(&dev->struct_mutex);
+	i915_gem_resume(dev);
 
 	i915_restore_state(dev);
 	intel_opregion_setup(dev_priv);

commit 19625e85c6ec56038368aa72c44f5f55b221f0fc
Author: Lyude <cpaul@redhat.com>
Date:   Tue Jun 21 17:03:44 2016 -0400

    drm/i915: Enable polling when we don't have hpd
    
    Unfortunately, there's two situations where we lose hpd right now:
    - Runtime suspend
    - When we've shut off all of the power wells on Valleyview/Cherryview
    
    While it would be nice if this didn't cause issues, this has the
    ability to get us in some awkward states where a user won't be able to
    get their display to turn on. For instance; if we boot a Valleyview
    system without any monitors connected, it won't need any of it's power
    wells and thus shut them off. Since this causes us to lose HPD, this
    means that unless the user knows how to ssh into their machine and do a
    manual reprobe for monitors, none of the monitors they connect after
    booting will actually work.
    
    Eventually we should come up with a better fix then having to enable
    polling for this, since this makes rpm a lot less useful, but for now
    the infrastructure in i915 just isn't there yet to get hpd in these
    situations.
    
    Changes since v1:
     - Add comment explaining the addition of the if
       (!mode_config->poll_running) in intel_hpd_init()
     - Remove unneeded if (!dev->mode_config.poll_enabled) in
       i915_hpd_poll_init_work()
     - Call to drm_helper_hpd_irq_event() after we disable polling
     - Add cancel_work_sync() call to intel_hpd_cancel_work()
    
    Changes since v2:
     - Apparently dev->mode_config.poll_running doesn't actually reflect
       whether or not a poll is currently in progress, and is actually used
       for dynamic module paramter enabling/disabling. So now we instead
       keep track of our own poll_running variable in dev_priv->hotplug
     - Clean i915_hpd_poll_init_work() a little bit
    
    Changes since v3:
     - Remove the now-redundant connector loop in intel_hpd_init(), just
       rely on intel_hpd_poll_enable() for setting connector->polled
       correctly on each connector
     - Get rid of poll_running
     - Don't assign enabled in i915_hpd_poll_init_work before we actually
       lock dev->mode_config.mutex
     - Wrap enabled assignment in i915_hpd_poll_init_work() in READ_ONCE()
       for doc purposes
     - Do the same for dev_priv->hotplug.poll_enabled with WRITE_ONCE in
       intel_hpd_poll_enable()
     - Add some comments about racing not mattering in intel_hpd_poll_enable
    
    Changes since v4:
     - Rename intel_hpd_poll_enable() to intel_hpd_poll_init()
     - Drop the bool argument from intel_hpd_poll_init()
     - Remove redundant calls to intel_hpd_poll_init()
     - Rename poll_enable_work to poll_init_work
     - Add some kerneldoc for intel_hpd_poll_init()
     - Cross-reference intel_hpd_poll_init() in intel_hpd_init()
     - Just copy the loop from intel_hpd_init() in intel_hpd_poll_init()
    
    Changes since v5:
     - Minor kerneldoc nitpicks
    
    Cc: stable@vger.kernel.org
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Lyude <cpaul@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c6cc01faaa36..15440123e38d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2409,6 +2409,9 @@ static int intel_runtime_suspend(struct device *device)
 
 	assert_forcewakes_inactive(dev_priv);
 
+	if (!IS_VALLEYVIEW(dev_priv) || !IS_CHERRYVIEW(dev_priv))
+		intel_hpd_poll_init(dev_priv);
+
 	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;
 }

commit b7137e0cf1e55b5b0cb88fbd85425a1bc0d24c3a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jul 13 09:10:37 2016 +0100

    drm/i915: Defer enabling rc6 til after we submit the first batch/context
    
    Some hardware requires a valid render context before it can initiate
    rc6 power gating of the GPU; the default state of the GPU is not
    sufficient and may lead to undefined behaviour. The first execution of
    any batch will load the "golden render state", at which point it is safe
    to enable rc6. As we do not forcibly load the kernel context at resume,
    we have to hook into the batch submission to be sure that the render
    state is setup before enabling rc6.
    
    However, since we don't enable powersaving until that first batch, we
    queued a delayed task in order to guarantee that the batch is indeed
    submitted.
    
    v2: Rearrange intel_disable_gt_powersave() to match.
    v3: Apply user specified cur_freq (or idle_freq if not set).
    v4: Give in, and supply a delayed work to autoenable rc6
    v5: Mika suggested a couple of better names for delayed_resume_work
    v6: Rebalance rpm_put around the autoenable task
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468397438-21226-7-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b9a811750ca8..c6cc01faaa36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1343,7 +1343,7 @@ void i915_driver_unload(struct drm_device *dev)
 	i915_destroy_error_state(dev);
 
 	/* Flush any outstanding unpin_work. */
-	flush_workqueue(dev_priv->wq);
+	drain_workqueue(dev_priv->wq);
 
 	intel_guc_fini(dev);
 	i915_gem_fini(dev);
@@ -1458,8 +1458,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_guc_suspend(dev);
 
-	intel_suspend_gt_powersave(dev_priv);
-
 	intel_display_suspend(dev);
 
 	intel_dp_mst_suspend(dev);
@@ -1652,6 +1650,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
+	intel_autoenable_gt_powersave(dev_priv);
 	drm_kms_helper_poll_enable(dev);
 
 	enable_rpm_wakeref_asserts(dev_priv);
@@ -1778,8 +1777,6 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	unsigned reset_counter;
 	int ret;
 
-	intel_reset_gt_powersave(dev_priv);
-
 	mutex_lock(&dev->struct_mutex);
 
 	/* Clear any previous failed attempts at recovery. Time to try again. */
@@ -1835,8 +1832,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	 * previous concerns that it doesn't respond well to some forms
 	 * of re-init after reset.
 	 */
-	if (INTEL_INFO(dev)->gen > 5)
-		intel_enable_gt_powersave(dev_priv);
+	intel_autoenable_gt_powersave(dev_priv);
 
 	return 0;
 
@@ -2459,7 +2455,6 @@ static int intel_runtime_resume(struct device *device)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	i915_gem_init_swizzling(dev);
-	gen6_update_ring_freq(dev_priv);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 

commit 22dea0be50b2eb0bafd3c82e1fb080113e0c889e
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Fri Jul 1 17:07:12 2016 -0700

    drm/i915: Introduce Kabypoint PCH for Kabylake H/DT.
    
    Some Kabylake SKUs are going to use Kabypoint PCH.
    It is mainly for Halo and DT ones.
    
    >From our specs it doesn't seem that KBP brings
    any change on the display south engine. So let's consider
    this as a continuation of SunrisePoint, i.e., SPT+.
    
    Since it is easy to get confused by a letter change:
    KBL = Kabylake - CPU/GPU codename.
    KBP = Kabypoint - PCH codename.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=96826
    Link: http://patchwork.freedesktop.org/patch/msgid/1467418032-15167-1-git-send-email-rodrigo.vivi@intel.com
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 694edac2c703..b9a811750ca8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -204,6 +204,10 @@ static void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev) &&
 					!IS_KABYLAKE(dev));
+			} else if (id == INTEL_PCH_KBP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_KBP;
+				DRM_DEBUG_KMS("Found KabyPoint PCH\n");
+				WARN_ON(!IS_KABYLAKE(dev));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&

commit 91c8a326a192117219d5b9b980244c3662e35404
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 5 10:40:23 2016 +0100

    drm/i915: Convert dev_priv->dev backpointers to dev_priv->drm
    
    Since drm_i915_private is now a subclass of drm_device we do not need to
    chase the drm_i915_private->dev backpointer and can instead simply
    access drm_i915_private->drm directly.
    
       text    data     bss     dec     hex filename
    1068757    4565     416 1073738  10624a drivers/gpu/drm/i915/i915.ko
    1066949    4565     416 1071930  105b3a drivers/gpu/drm/i915/i915.ko
    
    Created by the coccinelle script:
    @@
    struct drm_i915_private *d;
    identifier i;
    @@
    (
    - d->dev->i
    + d->drm.i
    |
    - d->dev
    + &d->drm
    )
    
    and for good measure the dev_priv->dev backpointer was removed entirely.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467711623-2905-4-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 595029bc55a3..694edac2c703 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -687,7 +687,7 @@ static int i915_load_modeset_init(struct drm_device *dev)
 static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
 {
 	struct apertures_struct *ap;
-	struct pci_dev *pdev = dev_priv->dev->pdev;
+	struct pci_dev *pdev = dev_priv->drm.pdev;
 	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 	bool primary;
 	int ret;
@@ -889,7 +889,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
  */
 static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
 {
-	i915_gem_load_cleanup(dev_priv->dev);
+	i915_gem_load_cleanup(&dev_priv->drm);
 	i915_workqueues_cleanup(dev_priv);
 }
 
@@ -944,7 +944,7 @@ static void i915_mmio_cleanup(struct drm_device *dev)
  */
 static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	int ret;
 
 	if (i915_inject_load_failure())
@@ -973,7 +973,7 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 
 	intel_uncore_fini(dev_priv);
 	i915_mmio_cleanup(dev);
@@ -1006,7 +1006,7 @@ static void intel_sanitize_options(struct drm_i915_private *dev_priv)
  */
 static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 	uint32_t aperture_size;
 	int ret;
@@ -1125,7 +1125,7 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 
 	if (dev->pdev->msi_enabled)
@@ -1146,7 +1146,7 @@ static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
  */
 static void i915_driver_register(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 
 	i915_gem_shrinker_init(dev_priv);
 
@@ -1197,9 +1197,9 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
 	acpi_video_unregister();
 	intel_opregion_unregister(dev_priv);
 
-	i915_teardown_sysfs(dev_priv->dev);
+	i915_teardown_sysfs(&dev_priv->drm);
 	i915_debugfs_unregister(dev_priv);
-	drm_dev_unregister(dev_priv->dev);
+	drm_dev_unregister(&dev_priv->drm);
 
 	i915_gem_shrinker_cleanup(dev_priv);
 }
@@ -1236,7 +1236,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	dev_priv->drm.pdev = pdev;
 	dev_priv->drm.dev_private = dev_priv;
-	dev_priv->dev = &dev_priv->drm;
 
 	ret = pci_enable_device(pdev);
 	if (ret)
@@ -1264,13 +1263,13 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 * to the role/effect of the given init step.
 	 */
 	if (INTEL_INFO(dev_priv)->num_pipes) {
-		ret = drm_vblank_init(dev_priv->dev,
+		ret = drm_vblank_init(&dev_priv->drm,
 				      INTEL_INFO(dev_priv)->num_pipes);
 		if (ret)
 			goto out_cleanup_hw;
 	}
 
-	ret = i915_load_modeset_init(dev_priv->dev);
+	ret = i915_load_modeset_init(&dev_priv->drm);
 	if (ret < 0)
 		goto out_cleanup_vblank;
 
@@ -1283,7 +1282,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return 0;
 
 out_cleanup_vblank:
-	drm_vblank_cleanup(dev_priv->dev);
+	drm_vblank_cleanup(&dev_priv->drm);
 out_cleanup_hw:
 	i915_driver_cleanup_hw(dev_priv);
 out_cleanup_mmio:
@@ -1402,7 +1401,7 @@ static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
 
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	struct intel_encoder *encoder;
 
 	drm_modeset_lock_all(dev);
@@ -1770,7 +1769,7 @@ int i915_resume_switcheroo(struct drm_device *dev)
  */
 int i915_reset(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
 	unsigned reset_counter;
 	int ret;
@@ -1861,7 +1860,7 @@ static int i915_pm_suspend(struct device *dev)
 
 static int i915_pm_suspend_late(struct device *dev)
 {
-	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
+	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
 
 	/*
 	 * We have a suspend ordering issue with the snd-hda driver also
@@ -1880,7 +1879,7 @@ static int i915_pm_suspend_late(struct device *dev)
 
 static int i915_pm_poweroff_late(struct device *dev)
 {
-	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
+	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
@@ -1890,7 +1889,7 @@ static int i915_pm_poweroff_late(struct device *dev)
 
 static int i915_pm_resume_early(struct device *dev)
 {
-	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
+	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
@@ -1900,7 +1899,7 @@ static int i915_pm_resume_early(struct device *dev)
 
 static int i915_pm_resume(struct device *dev)
 {
-	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
+	struct drm_device *drm_dev = &dev_to_i915(dev)->drm;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
@@ -2278,7 +2277,7 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 				bool rpm_resume)
 {
-	struct drm_device *dev = dev_priv->dev;
+	struct drm_device *dev = &dev_priv->drm;
 	int err;
 	int ret;
 

commit ded8b07d4c2827811215d92be4c97426ce7f1999
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 5 10:40:22 2016 +0100

    drm/i915: Remove impossible tests for dev->dev_private
    
    If we have a drm_device, we have a drm_i915_private (since they are the
    same).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467711623-2905-3-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fa72b73cb180..595029bc55a3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1556,7 +1556,7 @@ int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 {
 	int error;
 
-	if (!dev || !dev->dev_private) {
+	if (!dev) {
 		DRM_ERROR("dev: %p\n", dev);
 		DRM_ERROR("DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
@@ -1848,7 +1848,7 @@ static int i915_pm_suspend(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
-	if (!drm_dev || !drm_dev->dev_private) {
+	if (!drm_dev) {
 		dev_err(dev, "DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
 	}

commit fb93942033dfe7b4b87bba516f9b551da0bac970
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 5 10:40:21 2016 +0100

    drm/i915: Remove use of dev_priv->dev backpointer in __i915_printk()
    
    As we can just directly use drm_dev->drm.dev, we do not need the
    drm_dev->dev backpointer anymore and can also loose the warning about
    order of __i915_printk() and our initialisation (which is now always
    safe).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467711623-2905-2-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 87295f6e5520..fa72b73cb180 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -77,7 +77,7 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 	      const char *fmt, ...)
 {
 	static bool shown_bug_once;
-	struct device *dev = dev_priv->dev->dev;
+	struct device *dev = dev_priv->drm.dev;
 	bool is_error = level[1] <= KERN_ERR[1];
 	bool is_debug = level[1] == KERN_DEBUG[1];
 	struct va_format vaf;
@@ -1234,7 +1234,6 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return ret;
 	}
 
-	/* Must be set before calling __i915_printk */
 	dev_priv->drm.pdev = pdev;
 	dev_priv->drm.dev_private = dev_priv;
 	dev_priv->dev = &dev_priv->drm;

commit 94b4f3ba483ace6dd4a3f881e19cc18bdbafa6ef
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jul 5 10:40:20 2016 +0100

    drm/i915: Split out runtime configuration of device info to its own file
    
    Let's reclaim a few hundred lines from i915_drv.c by splitting out the
    runtime configuration of the "constant" dev_priv->info.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467711623-2905-1-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 695001ffd547..87295f6e5520 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -748,394 +748,6 @@ static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
 }
 #endif
 
-static void i915_dump_device_info(struct drm_i915_private *dev_priv)
-{
-	const struct intel_device_info *info = &dev_priv->info;
-
-#define PRINT_S(name) "%s"
-#define SEP_EMPTY
-#define PRINT_FLAG(name) info->name ? #name "," : ""
-#define SEP_COMMA ,
-	DRM_DEBUG_DRIVER("i915 device info: gen=%i, pciid=0x%04x rev=0x%02x flags="
-			 DEV_INFO_FOR_EACH_FLAG(PRINT_S, SEP_EMPTY),
-			 info->gen,
-			 dev_priv->dev->pdev->device,
-			 dev_priv->dev->pdev->revision,
-			 DEV_INFO_FOR_EACH_FLAG(PRINT_FLAG, SEP_COMMA));
-#undef PRINT_S
-#undef SEP_EMPTY
-#undef PRINT_FLAG
-#undef SEP_COMMA
-}
-
-static void cherryview_sseu_info_init(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_device_info *info;
-	u32 fuse, eu_dis;
-
-	info = (struct intel_device_info *)&dev_priv->info;
-	fuse = I915_READ(CHV_FUSE_GT);
-
-	info->slice_total = 1;
-
-	if (!(fuse & CHV_FGT_DISABLE_SS0)) {
-		info->subslice_per_slice++;
-		eu_dis = fuse & (CHV_FGT_EU_DIS_SS0_R0_MASK |
-				 CHV_FGT_EU_DIS_SS0_R1_MASK);
-		info->eu_total += 8 - hweight32(eu_dis);
-	}
-
-	if (!(fuse & CHV_FGT_DISABLE_SS1)) {
-		info->subslice_per_slice++;
-		eu_dis = fuse & (CHV_FGT_EU_DIS_SS1_R0_MASK |
-				 CHV_FGT_EU_DIS_SS1_R1_MASK);
-		info->eu_total += 8 - hweight32(eu_dis);
-	}
-
-	info->subslice_total = info->subslice_per_slice;
-	/*
-	 * CHV expected to always have a uniform distribution of EU
-	 * across subslices.
-	*/
-	info->eu_per_subslice = info->subslice_total ?
-				info->eu_total / info->subslice_total :
-				0;
-	/*
-	 * CHV supports subslice power gating on devices with more than
-	 * one subslice, and supports EU power gating on devices with
-	 * more than one EU pair per subslice.
-	*/
-	info->has_slice_pg = 0;
-	info->has_subslice_pg = (info->subslice_total > 1);
-	info->has_eu_pg = (info->eu_per_subslice > 2);
-}
-
-static void gen9_sseu_info_init(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_device_info *info;
-	int s_max = 3, ss_max = 4, eu_max = 8;
-	int s, ss;
-	u32 fuse2, s_enable, ss_disable, eu_disable;
-	u8 eu_mask = 0xff;
-
-	info = (struct intel_device_info *)&dev_priv->info;
-	fuse2 = I915_READ(GEN8_FUSE2);
-	s_enable = (fuse2 & GEN8_F2_S_ENA_MASK) >>
-		   GEN8_F2_S_ENA_SHIFT;
-	ss_disable = (fuse2 & GEN9_F2_SS_DIS_MASK) >>
-		     GEN9_F2_SS_DIS_SHIFT;
-
-	info->slice_total = hweight32(s_enable);
-	/*
-	 * The subslice disable field is global, i.e. it applies
-	 * to each of the enabled slices.
-	*/
-	info->subslice_per_slice = ss_max - hweight32(ss_disable);
-	info->subslice_total = info->slice_total *
-			       info->subslice_per_slice;
-
-	/*
-	 * Iterate through enabled slices and subslices to
-	 * count the total enabled EU.
-	*/
-	for (s = 0; s < s_max; s++) {
-		if (!(s_enable & (0x1 << s)))
-			/* skip disabled slice */
-			continue;
-
-		eu_disable = I915_READ(GEN9_EU_DISABLE(s));
-		for (ss = 0; ss < ss_max; ss++) {
-			int eu_per_ss;
-
-			if (ss_disable & (0x1 << ss))
-				/* skip disabled subslice */
-				continue;
-
-			eu_per_ss = eu_max - hweight8((eu_disable >> (ss*8)) &
-						      eu_mask);
-
-			/*
-			 * Record which subslice(s) has(have) 7 EUs. we
-			 * can tune the hash used to spread work among
-			 * subslices if they are unbalanced.
-			 */
-			if (eu_per_ss == 7)
-				info->subslice_7eu[s] |= 1 << ss;
-
-			info->eu_total += eu_per_ss;
-		}
-	}
-
-	/*
-	 * SKL is expected to always have a uniform distribution
-	 * of EU across subslices with the exception that any one
-	 * EU in any one subslice may be fused off for die
-	 * recovery. BXT is expected to be perfectly uniform in EU
-	 * distribution.
-	*/
-	info->eu_per_subslice = info->subslice_total ?
-				DIV_ROUND_UP(info->eu_total,
-					     info->subslice_total) : 0;
-	/*
-	 * SKL supports slice power gating on devices with more than
-	 * one slice, and supports EU power gating on devices with
-	 * more than one EU pair per subslice. BXT supports subslice
-	 * power gating on devices with more than one subslice, and
-	 * supports EU power gating on devices with more than one EU
-	 * pair per subslice.
-	*/
-	info->has_slice_pg = ((IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) &&
-			       (info->slice_total > 1));
-	info->has_subslice_pg = (IS_BROXTON(dev) && (info->subslice_total > 1));
-	info->has_eu_pg = (info->eu_per_subslice > 2);
-
-	if (IS_BROXTON(dev)) {
-#define IS_SS_DISABLED(_ss_disable, ss)    (_ss_disable & (0x1 << ss))
-		/*
-		 * There is a HW issue in 2x6 fused down parts that requires
-		 * Pooled EU to be enabled as a WA. The pool configuration
-		 * changes depending upon which subslice is fused down. This
-		 * doesn't affect if the device has all 3 subslices enabled.
-		 */
-		/* WaEnablePooledEuFor2x6:bxt */
-		info->has_pooled_eu = ((info->subslice_per_slice == 3) ||
-				       (info->subslice_per_slice == 2 &&
-					INTEL_REVID(dev) < BXT_REVID_C0));
-
-		info->min_eu_in_pool = 0;
-		if (info->has_pooled_eu) {
-			if (IS_SS_DISABLED(ss_disable, 0) ||
-			    IS_SS_DISABLED(ss_disable, 2))
-				info->min_eu_in_pool = 3;
-			else if (IS_SS_DISABLED(ss_disable, 1))
-				info->min_eu_in_pool = 6;
-			else
-				info->min_eu_in_pool = 9;
-		}
-#undef IS_SS_DISABLED
-	}
-}
-
-static void broadwell_sseu_info_init(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_device_info *info;
-	const int s_max = 3, ss_max = 3, eu_max = 8;
-	int s, ss;
-	u32 fuse2, eu_disable[s_max], s_enable, ss_disable;
-
-	fuse2 = I915_READ(GEN8_FUSE2);
-	s_enable = (fuse2 & GEN8_F2_S_ENA_MASK) >> GEN8_F2_S_ENA_SHIFT;
-	ss_disable = (fuse2 & GEN8_F2_SS_DIS_MASK) >> GEN8_F2_SS_DIS_SHIFT;
-
-	eu_disable[0] = I915_READ(GEN8_EU_DISABLE0) & GEN8_EU_DIS0_S0_MASK;
-	eu_disable[1] = (I915_READ(GEN8_EU_DISABLE0) >> GEN8_EU_DIS0_S1_SHIFT) |
-			((I915_READ(GEN8_EU_DISABLE1) & GEN8_EU_DIS1_S1_MASK) <<
-			 (32 - GEN8_EU_DIS0_S1_SHIFT));
-	eu_disable[2] = (I915_READ(GEN8_EU_DISABLE1) >> GEN8_EU_DIS1_S2_SHIFT) |
-			((I915_READ(GEN8_EU_DISABLE2) & GEN8_EU_DIS2_S2_MASK) <<
-			 (32 - GEN8_EU_DIS1_S2_SHIFT));
-
-
-	info = (struct intel_device_info *)&dev_priv->info;
-	info->slice_total = hweight32(s_enable);
-
-	/*
-	 * The subslice disable field is global, i.e. it applies
-	 * to each of the enabled slices.
-	 */
-	info->subslice_per_slice = ss_max - hweight32(ss_disable);
-	info->subslice_total = info->slice_total * info->subslice_per_slice;
-
-	/*
-	 * Iterate through enabled slices and subslices to
-	 * count the total enabled EU.
-	 */
-	for (s = 0; s < s_max; s++) {
-		if (!(s_enable & (0x1 << s)))
-			/* skip disabled slice */
-			continue;
-
-		for (ss = 0; ss < ss_max; ss++) {
-			u32 n_disabled;
-
-			if (ss_disable & (0x1 << ss))
-				/* skip disabled subslice */
-				continue;
-
-			n_disabled = hweight8(eu_disable[s] >> (ss * eu_max));
-
-			/*
-			 * Record which subslices have 7 EUs.
-			 */
-			if (eu_max - n_disabled == 7)
-				info->subslice_7eu[s] |= 1 << ss;
-
-			info->eu_total += eu_max - n_disabled;
-		}
-	}
-
-	/*
-	 * BDW is expected to always have a uniform distribution of EU across
-	 * subslices with the exception that any one EU in any one subslice may
-	 * be fused off for die recovery.
-	 */
-	info->eu_per_subslice = info->subslice_total ?
-		DIV_ROUND_UP(info->eu_total, info->subslice_total) : 0;
-
-	/*
-	 * BDW supports slice power gating on devices with more than
-	 * one slice.
-	 */
-	info->has_slice_pg = (info->slice_total > 1);
-	info->has_subslice_pg = 0;
-	info->has_eu_pg = 0;
-}
-
-/*
- * Determine various intel_device_info fields at runtime.
- *
- * Use it when either:
- *   - it's judged too laborious to fill n static structures with the limit
- *     when a simple if statement does the job,
- *   - run-time checks (eg read fuse/strap registers) are needed.
- *
- * This function needs to be called:
- *   - after the MMIO has been setup as we are reading registers,
- *   - after the PCH has been detected,
- *   - before the first usage of the fields it can tweak.
- */
-static void intel_device_info_runtime_init(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_device_info *info;
-	enum pipe pipe;
-
-	info = (struct intel_device_info *)&dev_priv->info;
-
-	/*
-	 * Skylake and Broxton currently don't expose the topmost plane as its
-	 * use is exclusive with the legacy cursor and we only want to expose
-	 * one of those, not both. Until we can safely expose the topmost plane
-	 * as a DRM_PLANE_TYPE_CURSOR with all the features exposed/supported,
-	 * we don't expose the topmost plane at all to prevent ABI breakage
-	 * down the line.
-	 */
-	if (IS_BROXTON(dev)) {
-		info->num_sprites[PIPE_A] = 2;
-		info->num_sprites[PIPE_B] = 2;
-		info->num_sprites[PIPE_C] = 1;
-	} else if (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev))
-		for_each_pipe(dev_priv, pipe)
-			info->num_sprites[pipe] = 2;
-	else
-		for_each_pipe(dev_priv, pipe)
-			info->num_sprites[pipe] = 1;
-
-	if (i915.disable_display) {
-		DRM_INFO("Display disabled (module parameter)\n");
-		info->num_pipes = 0;
-	} else if (info->num_pipes > 0 &&
-		   (IS_GEN7(dev_priv) || IS_GEN8(dev_priv)) &&
-		   HAS_PCH_SPLIT(dev)) {
-		u32 fuse_strap = I915_READ(FUSE_STRAP);
-		u32 sfuse_strap = I915_READ(SFUSE_STRAP);
-
-		/*
-		 * SFUSE_STRAP is supposed to have a bit signalling the display
-		 * is fused off. Unfortunately it seems that, at least in
-		 * certain cases, fused off display means that PCH display
-		 * reads don't land anywhere. In that case, we read 0s.
-		 *
-		 * On CPT/PPT, we can detect this case as SFUSE_STRAP_FUSE_LOCK
-		 * should be set when taking over after the firmware.
-		 */
-		if (fuse_strap & ILK_INTERNAL_DISPLAY_DISABLE ||
-		    sfuse_strap & SFUSE_STRAP_DISPLAY_DISABLED ||
-		    (dev_priv->pch_type == PCH_CPT &&
-		     !(sfuse_strap & SFUSE_STRAP_FUSE_LOCK))) {
-			DRM_INFO("Display fused off, disabling\n");
-			info->num_pipes = 0;
-		} else if (fuse_strap & IVB_PIPE_C_DISABLE) {
-			DRM_INFO("PipeC fused off\n");
-			info->num_pipes -= 1;
-		}
-	} else if (info->num_pipes > 0 && IS_GEN9(dev_priv)) {
-		u32 dfsm = I915_READ(SKL_DFSM);
-		u8 disabled_mask = 0;
-		bool invalid;
-		int num_bits;
-
-		if (dfsm & SKL_DFSM_PIPE_A_DISABLE)
-			disabled_mask |= BIT(PIPE_A);
-		if (dfsm & SKL_DFSM_PIPE_B_DISABLE)
-			disabled_mask |= BIT(PIPE_B);
-		if (dfsm & SKL_DFSM_PIPE_C_DISABLE)
-			disabled_mask |= BIT(PIPE_C);
-
-		num_bits = hweight8(disabled_mask);
-
-		switch (disabled_mask) {
-		case BIT(PIPE_A):
-		case BIT(PIPE_B):
-		case BIT(PIPE_A) | BIT(PIPE_B):
-		case BIT(PIPE_A) | BIT(PIPE_C):
-			invalid = true;
-			break;
-		default:
-			invalid = false;
-		}
-
-		if (num_bits > info->num_pipes || invalid)
-			DRM_ERROR("invalid pipe fuse configuration: 0x%x\n",
-				  disabled_mask);
-		else
-			info->num_pipes -= num_bits;
-	}
-
-	/* Initialize slice/subslice/EU info */
-	if (IS_CHERRYVIEW(dev))
-		cherryview_sseu_info_init(dev);
-	else if (IS_BROADWELL(dev))
-		broadwell_sseu_info_init(dev);
-	else if (INTEL_INFO(dev)->gen >= 9)
-		gen9_sseu_info_init(dev);
-
-	info->has_snoop = !info->has_llc;
-
-	/* Snooping is broken on BXT A stepping. */
-	if (IS_BXT_REVID(dev, 0, BXT_REVID_A1))
-		info->has_snoop = false;
-
-	DRM_DEBUG_DRIVER("slice total: %u\n", info->slice_total);
-	DRM_DEBUG_DRIVER("subslice total: %u\n", info->subslice_total);
-	DRM_DEBUG_DRIVER("subslice per slice: %u\n", info->subslice_per_slice);
-	DRM_DEBUG_DRIVER("EU total: %u\n", info->eu_total);
-	DRM_DEBUG_DRIVER("EU per subslice: %u\n", info->eu_per_subslice);
-	DRM_DEBUG_DRIVER("has slice power gating: %s\n",
-			 info->has_slice_pg ? "y" : "n");
-	DRM_DEBUG_DRIVER("has subslice power gating: %s\n",
-			 info->has_subslice_pg ? "y" : "n");
-	DRM_DEBUG_DRIVER("has EU power gating: %s\n",
-			 info->has_eu_pg ? "y" : "n");
-
-	i915.enable_execlists =
-		intel_sanitize_enable_execlists(dev_priv,
-					       	i915.enable_execlists);
-
-	/*
-	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
-	 * user's requested state against the hardware/driver capabilities.  We
-	 * do this now so that we can print out any log messages once rather
-	 * than every time we check intel_enable_ppgtt().
-	 */
-	i915.enable_ppgtt =
-		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
-	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
-}
-
 static void intel_init_dpio(struct drm_i915_private *dev_priv)
 {
 	/*
@@ -1213,7 +825,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 		return -ENODEV;
 
 	/* Setup the write-once "constant" device info */
-	device_info = (struct intel_device_info *)&dev_priv->info;
+	device_info = mkwrite_device_info(dev_priv);
 	memcpy(device_info, match_info, sizeof(*device_info));
 	device_info->device_id = dev_priv->drm.pdev->device;
 
@@ -1254,7 +866,7 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 
 	intel_display_crc_init(&dev_priv->drm);
 
-	i915_dump_device_info(dev_priv);
+	intel_device_info_dump(dev_priv);
 
 	/* Not all pre-production machines fall into this category, only the
 	 * very first ones. Almost everything should work, except for maybe
@@ -1368,6 +980,23 @@ static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
 	pci_dev_put(dev_priv->bridge_dev);
 }
 
+static void intel_sanitize_options(struct drm_i915_private *dev_priv)
+{
+	i915.enable_execlists =
+		intel_sanitize_enable_execlists(dev_priv,
+						i915.enable_execlists);
+
+	/*
+	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
+	 * user's requested state against the hardware/driver capabilities.  We
+	 * do this now so that we can print out any log messages once rather
+	 * than every time we check intel_enable_ppgtt().
+	 */
+	i915.enable_ppgtt =
+		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
+	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
+}
+
 /**
  * i915_driver_init_hw - setup state requiring device access
  * @dev_priv: device private
@@ -1385,7 +1014,9 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	if (i915_inject_load_failure())
 		return -ENODEV;
 
-	intel_device_info_runtime_init(dev);
+	intel_device_info_runtime_init(dev_priv);
+
+	intel_sanitize_options(dev_priv);
 
 	ret = i915_ggtt_init_hw(dev);
 	if (ret)

commit fac5e23e3c385fde41aab4a23bc50c8c15ad4d00
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 4 11:34:36 2016 +0100

    drm/i915: Mass convert dev->dev_private to to_i915(dev)
    
    Since we now subclass struct drm_device, we can save pointer dances by
    noting the equivalence of struct drm_device and struct drm_i915_private,
    i.e. by using to_i915().
    
       text    data     bss     dec     hex filename
    1073824    4562     416 1078802  107612 drivers/gpu/drm/i915/i915.ko
    1068976    4562     416 1073954  106322 drivers/gpu/drm/i915/i915.ko
    
    Created by the coccinelle script:
    
    @@
    expression E;
    identifier p;
    @@
    - struct drm_i915_private *p = E->dev_private;
    + struct drm_i915_private *p = to_i915(E);
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Dave Gordon <david.s.gordon@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467628477-25379-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7b9b6f90ca69..695001ffd547 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -144,7 +144,7 @@ static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
 
 static void intel_detect_pch(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pch = NULL;
 
 	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
@@ -248,7 +248,7 @@ bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
 static int i915_getparam(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	drm_i915_getparam_t *param = data;
 	int value;
 
@@ -384,7 +384,7 @@ static int i915_getparam(struct drm_device *dev, void *data,
 
 static int i915_get_bridge_dev(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 
 	dev_priv->bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
 	if (!dev_priv->bridge_dev) {
@@ -398,7 +398,7 @@ static int i915_get_bridge_dev(struct drm_device *dev)
 static int
 intel_alloc_mchbar_resource(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp_lo, temp_hi = 0;
 	u64 mchbar_addr;
@@ -444,7 +444,7 @@ intel_alloc_mchbar_resource(struct drm_device *dev)
 static void
 intel_setup_mchbar(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 	u32 temp;
 	bool enabled;
@@ -484,7 +484,7 @@ intel_setup_mchbar(struct drm_device *dev)
 static void
 intel_teardown_mchbar(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
 
 	if (dev_priv->mchbar_need_disable) {
@@ -601,7 +601,7 @@ static void i915_gem_fini(struct drm_device *dev)
 
 static int i915_load_modeset_init(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
 	if (i915_inject_load_failure())
@@ -1671,7 +1671,7 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 void i915_driver_unload(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 
 	intel_fbdev_fini(dev);
 
@@ -1797,7 +1797,7 @@ static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 
 static int i915_drm_suspend(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	pci_power_t opregion_target_state;
 	int error;
 
@@ -1864,7 +1864,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 {
-	struct drm_i915_private *dev_priv = drm_dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(drm_dev);
 	bool fw_csr;
 	int ret;
 
@@ -1948,7 +1948,7 @@ int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 
 static int i915_drm_resume(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
@@ -2028,7 +2028,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 static int i915_drm_resume_early(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
 	/*
@@ -2684,7 +2684,7 @@ static int intel_runtime_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret;
 
 	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6())))
@@ -2788,7 +2788,7 @@ static int intel_runtime_resume(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(dev);
 	int ret = 0;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))

commit 7b4d3a16dd97be0ebc793ea046b9af9d5c9b1b1a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 4 08:08:37 2016 +0100

    drm/i915: Remove stop-rings debugfs interface
    
    Now that we have (near) universal GPU recovery code, we can inject a
    real hang from userspace and not need any fakery. Not only does this
    mean that the testing is far more realistic, but we can simplify the
    kernel in the process.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467616119-4093-7-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 40521a3e8b8f..7b9b6f90ca69 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2159,24 +2159,11 @@ int i915_reset(struct drm_i915_private *dev_priv)
 		goto error;
 	}
 
+	pr_notice("drm/i915: Resetting chip after gpu hang\n");
+
 	i915_gem_reset(dev);
 
 	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
-
-	/* Also reset the gpu hangman. */
-	if (error->stop_rings != 0) {
-		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
-		error->stop_rings = 0;
-		if (ret == -ENODEV) {
-			DRM_INFO("Reset not implemented, but ignoring "
-				 "error for simulated gpu hangs\n");
-			ret = 0;
-		}
-	}
-
-	if (i915_stop_ring_allow_warn(dev_priv))
-		pr_notice("drm/i915: Resetting chip after gpu hang\n");
-
 	if (ret) {
 		if (ret != -ENODEV)
 			DRM_ERROR("Failed to reset chip: %i\n", ret);

commit c33d247d0e31df48ada35d71d1dc7830a4bb4314
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 4 08:08:36 2016 +0100

    drm/i915: Flush the RPS bottom-half when the GPU idles
    
    Make sure that the RPS bottom-half is flushed before we set the idle
    frequency when we decide the GPU is idle. This should prevent any races
    with the bottom-half and setting the idle frequency, and ensures that
    the bottom-half is bounded by the GPU's rpm reference taken for when it
    is active (i.e. between gen6_rps_busy() and gen6_rps_idle()).
    
    v2: Avoid recursively using the i915->wq - RPS does not touch the
    struct_mutex so has no place being on the ordered i915->wq.
    v3: Enable/disable interrupts for RPS busy/idle in order to prevent
    further HW access from RPS outside of the wakeref.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    References: https://bugs.freedesktop.org/show_bug.cgi?id=89728
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467616119-4093-6-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2b6494b19869..40521a3e8b8f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2737,7 +2737,6 @@ static int intel_runtime_suspend(struct device *device)
 
 	intel_guc_suspend(dev);
 
-	intel_suspend_gt_powersave(dev_priv);
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
 	ret = 0;
@@ -2852,8 +2851,6 @@ static int intel_runtime_resume(struct device *device)
 	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_init(dev_priv);
 
-	intel_enable_gt_powersave(dev_priv);
-
 	enable_rpm_wakeref_asserts(dev_priv);
 
 	if (ret)

commit 67d97da34917fb0b21af4c0942a6e03b4b10c094
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 4 08:08:31 2016 +0100

    drm/i915: Only start retire worker when idle
    
    The retire worker is a low frequency task that makes sure we retire
    outstanding requests if userspace is being lax. We only need to start it
    once as it remains active until the GPU is idle, so do a cheap test
    before the more expensive queue_work(). A consequence of this is that we
    need correct locking in the worker to make the hot path of request
    submission cheap. To keep the symmetry and keep hangcheck strictly bound
    by the GPU's wakelock, we move the cancel_sync(hangcheck) to the idle
    worker before dropping the wakelock.
    
    v2: Guard against RCU fouling the breadcrumbs bottom-half whilst we kick
    the waiter.
    v3: Remove the wakeref assertion squelching (now we hold a wakeref for
    the hangcheck, any rpm error there is genuine).
    v4: To prevent excess work when retiring requests, we split the busy
    flag into two, a boolean to denote whether we hold the wakeref and a
    bitmask of active engines.
    v5: Reorder cancelling hangcheck upon idling to avoid a race where we
    might cancel a hangcheck after being preempted by a new task
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    References: https://bugs.freedesktop.org/show_bug.cgi?id=88437
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467616119-4093-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6fa9c0338b1b..2b6494b19869 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2735,8 +2735,6 @@ static int intel_runtime_suspend(struct device *device)
 	i915_gem_release_all_mmaps(dev_priv);
 	mutex_unlock(&dev->struct_mutex);
 
-	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
-
 	intel_guc_suspend(dev);
 
 	intel_suspend_gt_powersave(dev_priv);

commit 338d0eeaa9a7699744642720bf5adcdd5400f0a2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Jul 2 15:35:58 2016 +0100

    drm/i915: Fix random indent in i915_drm_resume()
    
    smatch complains:
    
            drivers/gpu/drm/i915/i915_drv.c:1616 i915_drm_resume() warn:
            inconsistent indenting
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467470166-31717-1-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c9abf912249f..6fa9c0338b1b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1982,7 +1982,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-			atomic_or(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
+		atomic_or(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
 	}
 	mutex_unlock(&dev->struct_mutex);
 

commit 7774002586703aac3952f332bdf14759865171ef
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 1 17:23:12 2016 +0100

    drm/i915: Remove the dedicated hangcheck workqueue
    
    The queue only ever contains at most one item and has no special flags.
    It is just a very simple wrapper around the system-wq - a complication
    with no benefits.
    
    v2: Use the system_long_wq as we may wish to capture the error state
    after detecting the hang - which may take a bit of time.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467390209-3576-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8a2674013aef..c9abf912249f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1175,15 +1175,8 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 	if (dev_priv->hotplug.dp_wq == NULL)
 		goto out_free_wq;
 
-	dev_priv->gpu_error.hangcheck_wq =
-		alloc_ordered_workqueue("i915-hangcheck", 0);
-	if (dev_priv->gpu_error.hangcheck_wq == NULL)
-		goto out_free_dp_wq;
-
 	return 0;
 
-out_free_dp_wq:
-	destroy_workqueue(dev_priv->hotplug.dp_wq);
 out_free_wq:
 	destroy_workqueue(dev_priv->wq);
 out_err:
@@ -1194,7 +1187,6 @@ static int i915_workqueues_init(struct drm_i915_private *dev_priv)
 
 static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
 {
-	destroy_workqueue(dev_priv->gpu_error.hangcheck_wq);
 	destroy_workqueue(dev_priv->hotplug.dp_wq);
 	destroy_workqueue(dev_priv->wq);
 }

commit 37f501afed23fa1126017255495d5be5e97c9d6d
Author: arun.siluvery@linux.intel.com <arun.siluvery@linux.intel.com>
Date:   Fri Jul 1 11:43:02 2016 +0100

    drm/i915/bxt: Export pooled eu info to userspace
    
    Pooled EU is a bxt only feature and kernel changes are already merged. This
    feature is not yet exposed to userspace as the support was not yet
    available. Beignet team expressed interest and added patches to use this.
    
    Since we now have a user and patches to use them, expose them from the
    kernel side as well.
    
    v2: fix compile error
    
    [1] https://lists.freedesktop.org/archives/beignet/2016-June/007698.html
    [2] https://lists.freedesktop.org/archives/beignet/2016-June/007699.html
    
    Cc: Winiarski, Michal <michal.winiarski@intel.com>
    Cc: Zou, Nanhai <nanhai.zou@intel.com>
    Cc: Yang, Rong R <rong.r.yang@intel.com>
    Cc: Tim Gore <tim.gore@intel.com>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467369782-25992-1-git-send-email-arun.siluvery@linux.intel.com
    Acked-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c580e24095b0..8a2674013aef 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -365,6 +365,12 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_SOFTPIN:
 		value = 1;
 		break;
+	case I915_PARAM_HAS_POOLED_EU:
+		value = HAS_POOLED_EU(dev);
+		break;
+	case I915_PARAM_MIN_EU_IN_POOL:
+		value = INTEL_INFO(dev)->min_eu_in_pool;
+		break;
 	default:
 		DRM_DEBUG("Unknown parameter %d\n", param->param);
 		return -EINVAL;

commit 41ce405e689491658cb68dfca620dc199130c5f6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 30 15:32:48 2016 +0100

    drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()
    
    By using the out-of-line intel_wait_for_register() not only do we can
    efficiency from using the hybrid wait_for() contained within, but we
    avoid code bloat from the numerous inlined loops, in total (all patches):
    
       text    data     bss     dec     hex filename
    1078551    4557     416 1083524  108884 drivers/gpu/drm/i915/i915.ko
    1070775    4557     416 1075748  106a24 drivers/gpu/drm/i915/i915.ko
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467297225-21379-5-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fb5758f4f9d3..c580e24095b0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2588,8 +2588,7 @@ static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 
 	mask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;
 	val = wait_for_on ? mask : 0;
-#define COND ((I915_READ(VLV_GTLC_PW_STATUS) & mask) == val)
-	if (COND)
+	if ((I915_READ(VLV_GTLC_PW_STATUS) & mask) == val)
 		return 0;
 
 	DRM_DEBUG_KMS("waiting for GT wells to go %s (%08x)\n",
@@ -2600,13 +2599,14 @@ static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 	 * RC6 transitioning can be delayed up to 2 msec (see
 	 * valleyview_enable_rps), use 3 msec for safety.
 	 */
-	err = wait_for(COND, 3);
+	err = intel_wait_for_register(dev_priv,
+				      VLV_GTLC_PW_STATUS, mask, val,
+				      3);
 	if (err)
 		DRM_ERROR("timeout waiting for GT wells to go %s\n",
 			  onoff(wait_for_on));
 
 	return err;
-#undef COND
 }
 
 static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)

commit b2736695886931ede25de3d21726dea7b2e8e9f2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 30 15:32:47 2016 +0100

    drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()
    
    By using the out-of-line intel_wait_for_register() not only do we can
    efficiency from using the hybrid wait_for() contained within, but we
    avoid code bloat from the numerous inlined loops, in total (all patches):
    
       text    data     bss     dec     hex filename
    1078551    4557     416 1083524  108884 drivers/gpu/drm/i915/i915.ko
    1070775    4557     416 1075748  106a24 drivers/gpu/drm/i915/i915.ko
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467297225-21379-4-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 51eb1cd86957..fb5758f4f9d3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2568,13 +2568,15 @@ static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
 	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
 	POSTING_READ(VLV_GTLC_WAKE_CTRL);
 
-#define COND (!!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEACK) == \
-	      allow)
-	err = wait_for(COND, 1);
+	err = intel_wait_for_register(dev_priv,
+				      VLV_GTLC_PW_STATUS,
+				      VLV_GTLC_ALLOWWAKEACK,
+				      allow,
+				      1);
 	if (err)
 		DRM_ERROR("timeout disabling GT waking\n");
+
 	return err;
-#undef COND
 }
 
 static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,

commit c6ddc5f3d05dfc7bbb2a5f1e477aed98510a71bb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 30 15:32:46 2016 +0100

    drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()
    
    By using the out-of-line intel_wait_for_register() not only do we can
    efficiency from using the hybrid wait_for() contained within, but we
    avoid code bloat from the numerous inlined loops, in total (all patches):
    
       text    data     bss     dec     hex filename
    1078551    4557     416 1083524  108884 drivers/gpu/drm/i915/i915.ko
    1070775    4557     416 1075748  106a24 drivers/gpu/drm/i915/i915.ko
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467297225-21379-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b98afbd33235..51eb1cd86957 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -2535,8 +2535,6 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	u32 val;
 	int err;
 
-#define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
-
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
 	val &= ~VLV_GFX_CLK_FORCE_ON_BIT;
 	if (force_on)
@@ -2546,13 +2544,16 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	if (!force_on)
 		return 0;
 
-	err = wait_for(COND, 20);
+	err = intel_wait_for_register(dev_priv,
+				      VLV_GTLC_SURVIVABILITY_REG,
+				      VLV_GFX_CLK_STATUS_BIT,
+				      VLV_GFX_CLK_STATUS_BIT,
+				      20);
 	if (err)
 		DRM_ERROR("timeout waiting for GFX clock force-on (%08x)\n",
 			  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
 
 	return err;
-#undef COND
 }
 
 static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)

commit a09d0ba1745b607070a937083ecf9ec616178768
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:27 2016 +0100

    drm/i915: Move module init/exit to i915_pci.c
    
    The module init/exit routines are a wrapper around the PCI device
    init/exit, so move them across.
    
    Note that in order to avoid exporting the driver struct, instead of
    manipulating driver.features inside i915_init we instead opt to simply
    exit if i915.modeset is disabled.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-15-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7d011a686bc9..b98afbd33235 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -28,7 +28,6 @@
  */
 
 #include <linux/acpi.h>
-#include <linux/console.h>
 #include <linux/device.h>
 #include <linux/oom.h>
 #include <linux/module.h>
@@ -1592,6 +1591,9 @@ int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct drm_i915_private *dev_priv;
 	int ret;
 
+	if (i915.nuclear_pageflip)
+		driver.driver_features |= DRIVER_ATOMIC;
+
 	ret = -ENOMEM;
 	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
 	if (dev_priv)
@@ -3018,50 +3020,3 @@ static struct drm_driver driver = {
 	.minor = DRIVER_MINOR,
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
-
-static int __init i915_init(void)
-{
-	extern struct pci_driver i915_pci_driver;
-
-	/*
-	 * Enable KMS by default, unless explicitly overriden by
-	 * either the i915.modeset prarameter or by the
-	 * vga_text_mode_force boot option.
-	 */
-
-	if (i915.modeset == 0)
-		driver.driver_features &= ~DRIVER_MODESET;
-
-	if (vgacon_text_force() && i915.modeset == -1)
-		driver.driver_features &= ~DRIVER_MODESET;
-
-	if (!(driver.driver_features & DRIVER_MODESET)) {
-		/* Silently fail loading to not upset userspace. */
-		DRM_DEBUG_DRIVER("KMS disabled.\n");
-		return 0;
-	}
-
-	if (i915.nuclear_pageflip)
-		driver.driver_features |= DRIVER_ATOMIC;
-
-	return drm_pci_init(&driver, &i915_pci_driver);
-}
-
-static void __exit i915_exit(void)
-{
-	extern struct pci_driver i915_pci_driver;
-
-	if (!(driver.driver_features & DRIVER_MODESET))
-		return; /* Never loaded a driver. */
-
-	drm_pci_exit(&driver, &i915_pci_driver);
-}
-
-module_init(i915_init);
-module_exit(i915_exit);
-
-MODULE_AUTHOR("Tungsten Graphics, Inc.");
-MODULE_AUTHOR("Intel Corporation");
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL and additional rights");

commit 42f5551d276921d4de8bd45765494b2dc63eb39c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:26 2016 +0100

    drm/i915: Split out the PCI driver interface to i915_pci.c
    
    To reclaim a bit of space from i915_drv.c, we can move the routines that
    just hook us into the PCI device tree into i915_pci.c
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-14-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 50d1a71aeddc..7d011a686bc9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -53,387 +53,6 @@
 
 static struct drm_driver driver;
 
-#define GEN_DEFAULT_PIPEOFFSETS \
-	.pipe_offsets = { PIPE_A_OFFSET, PIPE_B_OFFSET, \
-			  PIPE_C_OFFSET, PIPE_EDP_OFFSET }, \
-	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
-			   TRANSCODER_C_OFFSET, TRANSCODER_EDP_OFFSET }, \
-	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET }
-
-#define GEN_CHV_PIPEOFFSETS \
-	.pipe_offsets = { PIPE_A_OFFSET, PIPE_B_OFFSET, \
-			  CHV_PIPE_C_OFFSET }, \
-	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
-			   CHV_TRANSCODER_C_OFFSET, }, \
-	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET, \
-			     CHV_PALETTE_C_OFFSET }
-
-#define CURSOR_OFFSETS \
-	.cursor_offsets = { CURSOR_A_OFFSET, CURSOR_B_OFFSET, CHV_CURSOR_C_OFFSET }
-
-#define IVB_CURSOR_OFFSETS \
-	.cursor_offsets = { CURSOR_A_OFFSET, IVB_CURSOR_B_OFFSET, IVB_CURSOR_C_OFFSET }
-
-#define BDW_COLORS \
-	.color = { .degamma_lut_size = 512, .gamma_lut_size = 512 }
-#define CHV_COLORS \
-	.color = { .degamma_lut_size = 65, .gamma_lut_size = 257 }
-
-static const struct intel_device_info intel_i830_info = {
-	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_845g_info = {
-	.gen = 2, .num_pipes = 1,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_i85x_info = {
-	.gen = 2, .is_i85x = 1, .is_mobile = 1, .num_pipes = 2,
-	.cursor_needs_physical = 1,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_i865g_info = {
-	.gen = 2, .num_pipes = 1,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_i915g_info = {
-	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1, .num_pipes = 2,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-static const struct intel_device_info intel_i915gm_info = {
-	.gen = 3, .is_mobile = 1, .num_pipes = 2,
-	.cursor_needs_physical = 1,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.supports_tv = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-static const struct intel_device_info intel_i945g_info = {
-	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1, .num_pipes = 2,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-static const struct intel_device_info intel_i945gm_info = {
-	.gen = 3, .is_i945gm = 1, .is_mobile = 1, .num_pipes = 2,
-	.has_hotplug = 1, .cursor_needs_physical = 1,
-	.has_overlay = 1, .overlay_needs_physical = 1,
-	.supports_tv = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_i965g_info = {
-	.gen = 4, .is_broadwater = 1, .num_pipes = 2,
-	.has_hotplug = 1,
-	.has_overlay = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_i965gm_info = {
-	.gen = 4, .is_crestline = 1, .num_pipes = 2,
-	.is_mobile = 1, .has_fbc = 1, .has_hotplug = 1,
-	.has_overlay = 1,
-	.supports_tv = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_g33_info = {
-	.gen = 3, .is_g33 = 1, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_overlay = 1,
-	.ring_mask = RENDER_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_g45_info = {
-	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1, .num_pipes = 2,
-	.has_pipe_cxsr = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_gm45_info = {
-	.gen = 4, .is_g4x = 1, .num_pipes = 2,
-	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1,
-	.has_pipe_cxsr = 1, .has_hotplug = 1,
-	.supports_tv = 1,
-	.ring_mask = RENDER_RING | BSD_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_pineview_info = {
-	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_overlay = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_ironlake_d_info = {
-	.gen = 5, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_ironlake_m_info = {
-	.gen = 5, .is_mobile = 1, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING | BSD_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_sandybridge_d_info = {
-	.gen = 6, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
-	.has_llc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-static const struct intel_device_info intel_sandybridge_m_info = {
-	.gen = 6, .is_mobile = 1, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
-	.has_llc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-};
-
-#define GEN7_FEATURES  \
-	.gen = 7, .num_pipes = 3, \
-	.need_gfx_hws = 1, .has_hotplug = 1, \
-	.has_fbc = 1, \
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
-	.has_llc = 1, \
-	GEN_DEFAULT_PIPEOFFSETS, \
-	IVB_CURSOR_OFFSETS
-
-static const struct intel_device_info intel_ivybridge_d_info = {
-	GEN7_FEATURES,
-	.is_ivybridge = 1,
-};
-
-static const struct intel_device_info intel_ivybridge_m_info = {
-	GEN7_FEATURES,
-	.is_ivybridge = 1,
-	.is_mobile = 1,
-};
-
-static const struct intel_device_info intel_ivybridge_q_info = {
-	GEN7_FEATURES,
-	.is_ivybridge = 1,
-	.num_pipes = 0, /* legal, last one wins */
-};
-
-#define VLV_FEATURES  \
-	.gen = 7, .num_pipes = 2, \
-	.need_gfx_hws = 1, .has_hotplug = 1, \
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
-	.display_mmio_offset = VLV_DISPLAY_BASE, \
-	GEN_DEFAULT_PIPEOFFSETS, \
-	CURSOR_OFFSETS
-
-static const struct intel_device_info intel_valleyview_m_info = {
-	VLV_FEATURES,
-	.is_valleyview = 1,
-	.is_mobile = 1,
-};
-
-static const struct intel_device_info intel_valleyview_d_info = {
-	VLV_FEATURES,
-	.is_valleyview = 1,
-};
-
-#define HSW_FEATURES  \
-	GEN7_FEATURES, \
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING, \
-	.has_ddi = 1, \
-	.has_fpga_dbg = 1
-
-static const struct intel_device_info intel_haswell_d_info = {
-	HSW_FEATURES,
-	.is_haswell = 1,
-};
-
-static const struct intel_device_info intel_haswell_m_info = {
-	HSW_FEATURES,
-	.is_haswell = 1,
-	.is_mobile = 1,
-};
-
-#define BDW_FEATURES \
-	HSW_FEATURES, \
-	BDW_COLORS
-
-static const struct intel_device_info intel_broadwell_d_info = {
-	BDW_FEATURES,
-	.gen = 8,
-	.is_broadwell = 1,
-};
-
-static const struct intel_device_info intel_broadwell_m_info = {
-	BDW_FEATURES,
-	.gen = 8, .is_mobile = 1,
-	.is_broadwell = 1,
-};
-
-static const struct intel_device_info intel_broadwell_gt3d_info = {
-	BDW_FEATURES,
-	.gen = 8,
-	.is_broadwell = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
-
-static const struct intel_device_info intel_broadwell_gt3m_info = {
-	BDW_FEATURES,
-	.gen = 8, .is_mobile = 1,
-	.is_broadwell = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
-
-static const struct intel_device_info intel_cherryview_info = {
-	.gen = 8, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.is_cherryview = 1,
-	.display_mmio_offset = VLV_DISPLAY_BASE,
-	GEN_CHV_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-	CHV_COLORS,
-};
-
-static const struct intel_device_info intel_skylake_info = {
-	BDW_FEATURES,
-	.is_skylake = 1,
-	.gen = 9,
-};
-
-static const struct intel_device_info intel_skylake_gt3_info = {
-	BDW_FEATURES,
-	.is_skylake = 1,
-	.gen = 9,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
-
-static const struct intel_device_info intel_broxton_info = {
-	.is_preliminary = 1,
-	.is_broxton = 1,
-	.gen = 9,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.num_pipes = 3,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	.has_pooled_eu = 0,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
-	BDW_COLORS,
-};
-
-static const struct intel_device_info intel_kabylake_info = {
-	BDW_FEATURES,
-	.is_kabylake = 1,
-	.gen = 9,
-};
-
-static const struct intel_device_info intel_kabylake_gt3_info = {
-	BDW_FEATURES,
-	.is_kabylake = 1,
-	.gen = 9,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
-
-/*
- * Make sure any device matches here are from most specific to most
- * general.  For example, since the Quanta match is based on the subsystem
- * and subvendor IDs, we need it to come before the more general IVB
- * PCI ID matches, otherwise we'll use the wrong info struct above.
- */
-static const struct pci_device_id pciidlist[] = {
-	INTEL_I830_IDS(&intel_i830_info),
-	INTEL_I845G_IDS(&intel_845g_info),
-	INTEL_I85X_IDS(&intel_i85x_info),
-	INTEL_I865G_IDS(&intel_i865g_info),
-	INTEL_I915G_IDS(&intel_i915g_info),
-	INTEL_I915GM_IDS(&intel_i915gm_info),
-	INTEL_I945G_IDS(&intel_i945g_info),
-	INTEL_I945GM_IDS(&intel_i945gm_info),
-	INTEL_I965G_IDS(&intel_i965g_info),
-	INTEL_G33_IDS(&intel_g33_info),
-	INTEL_I965GM_IDS(&intel_i965gm_info),
-	INTEL_GM45_IDS(&intel_gm45_info),
-	INTEL_G45_IDS(&intel_g45_info),
-	INTEL_PINEVIEW_IDS(&intel_pineview_info),
-	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),
-	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),
-	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),
-	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),
-	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */
-	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),
-	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),
-	INTEL_HSW_D_IDS(&intel_haswell_d_info),
-	INTEL_HSW_M_IDS(&intel_haswell_m_info),
-	INTEL_VLV_M_IDS(&intel_valleyview_m_info),
-	INTEL_VLV_D_IDS(&intel_valleyview_d_info),
-	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),
-	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),
-	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),
-	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info),
-	INTEL_CHV_IDS(&intel_cherryview_info),
-	INTEL_SKL_GT1_IDS(&intel_skylake_info),
-	INTEL_SKL_GT2_IDS(&intel_skylake_info),
-	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
-	INTEL_SKL_GT4_IDS(&intel_skylake_gt3_info),
-	INTEL_BXT_IDS(&intel_broxton_info),
-	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
-	INTEL_KBL_GT2_IDS(&intel_kabylake_info),
-	INTEL_KBL_GT3_IDS(&intel_kabylake_gt3_info),
-	INTEL_KBL_GT4_IDS(&intel_kabylake_gt3_info),
-	{0, 0, 0}
-};
-MODULE_DEVICE_TABLE(pci, pciidlist);
-
 static unsigned int i915_load_fail_count;
 
 bool __i915_inject_load_failure(const char *func, int line)
@@ -1968,8 +1587,7 @@ static void i915_driver_unregister(struct drm_i915_private *dev_priv)
  *   - allocate initial config memory
  *   - setup the DRM framebuffer with the allocated memory
  */
-static int i915_driver_load(struct pci_dev *pdev,
-			    const struct pci_device_id *ent)
+int i915_driver_load(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct drm_i915_private *dev_priv;
 	int ret;
@@ -2051,18 +1669,14 @@ static int i915_driver_load(struct pci_dev *pdev,
 	return ret;
 }
 
-static int i915_driver_unload(struct drm_device *dev)
+void i915_driver_unload(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret;
 
 	intel_fbdev_fini(dev);
 
-	ret = i915_gem_suspend(dev);
-	if (ret) {
-		DRM_ERROR("failed to idle hardware: %d\n", ret);
-		return ret;
-	}
+	if (i915_gem_suspend(dev))
+		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
 
@@ -2110,8 +1724,6 @@ static int i915_driver_unload(struct drm_device *dev)
 	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
 
 	i915_driver_cleanup_early(dev_priv);
-
-	return 0;
 }
 
 static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
@@ -2614,40 +2226,6 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
-{
-	struct intel_device_info *intel_info =
-		(struct intel_device_info *) ent->driver_data;
-
-	if (IS_PRELIMINARY_HW(intel_info) && !i915.preliminary_hw_support) {
-		DRM_INFO("This hardware requires preliminary hardware support.\n"
-			 "See CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT, and/or modparam preliminary_hw_support\n");
-		return -ENODEV;
-	}
-
-	/* Only bind to function 0 of the device. Early generations
-	 * used function 1 as a placeholder for multi-head. This causes
-	 * us confusion instead, especially on the systems where both
-	 * functions have the same PCI-ID!
-	 */
-	if (PCI_FUNC(pdev->devfn))
-		return -ENODEV;
-
-	if (vga_switcheroo_client_probe_defer(pdev))
-		return -EPROBE_DEFER;
-
-	return i915_driver_load(pdev, ent);
-}
-
-static void
-i915_pci_remove(struct pci_dev *pdev)
-{
-	struct drm_device *dev = pci_get_drvdata(pdev);
-
-	i915_driver_unload(dev);
-	drm_dev_unref(dev);
-}
-
 static int i915_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -3285,7 +2863,7 @@ static int intel_runtime_resume(struct device *device)
 	return ret;
 }
 
-static const struct dev_pm_ops i915_pm_ops = {
+const struct dev_pm_ops i915_pm_ops = {
 	/*
 	 * S0ix (via system suspend) and S3 event handlers [PMSG_SUSPEND,
 	 * PMSG_RESUME]
@@ -3441,16 +3019,10 @@ static struct drm_driver driver = {
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
 
-static struct pci_driver i915_pci_driver = {
-	.name = DRIVER_NAME,
-	.id_table = pciidlist,
-	.probe = i915_pci_probe,
-	.remove = i915_pci_remove,
-	.driver.pm = &i915_pm_ops,
-};
-
 static int __init i915_init(void)
 {
+	extern struct pci_driver i915_pci_driver;
+
 	/*
 	 * Enable KMS by default, unless explicitly overriden by
 	 * either the i915.modeset prarameter or by the
@@ -3477,6 +3049,8 @@ static int __init i915_init(void)
 
 static void __exit i915_exit(void)
 {
+	extern struct pci_driver i915_pci_driver;
+
 	if (!(driver.driver_features & DRIVER_MODESET))
 		return; /* Never loaded a driver. */
 

commit c2dac8680ee49b0dc870b3d7b23c5102d3e49eb9
Author: Frank Binns <frank.binns@imgtec.com>
Date:   Fri Jun 24 14:00:25 2016 +0100

    drm/i915: Fix misleading driver debug message
    
    Stop claiming that UMS support is disabled when it's not actually
    supported anymore.
    
    Signed-off-by: Frank Binns <frank.binns@imgtec.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466763836-27772-1-git-send-email-frank.binns@imgtec.com
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-13-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index afa3e99fd48a..50d1a71aeddc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -3465,7 +3465,7 @@ static int __init i915_init(void)
 
 	if (!(driver.driver_features & DRIVER_MODESET)) {
 		/* Silently fail loading to not upset userspace. */
-		DRM_DEBUG_DRIVER("KMS and UMS disabled.\n");
+		DRM_DEBUG_DRIVER("KMS disabled.\n");
 		return 0;
 	}
 

commit dda330099afc10160d1ae1f74838f8452169dbbd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:23 2016 +0100

    drm/i915: Remove user controllable DRM_ERROR for i915_getparam()
    
    The GETPARAM ioctl writes to a user supplied address. If that address is
    invalid, it is the user's error and not the driver's, so quietly report
    EFAULT and don't blame ourselves with a DRM_ERROR.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-11-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e2375361a34d..afa3e99fd48a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -752,10 +752,8 @@ static int i915_getparam(struct drm_device *dev, void *data,
 		return -EINVAL;
 	}
 
-	if (copy_to_user(param->value, &value, sizeof(int))) {
-		DRM_ERROR("copy_to_user failed\n");
+	if (put_user(value, param->value))
 		return -EFAULT;
-	}
 
 	return 0;
 }

commit 0673ad472b9849ad6dbd83d5e3a3a63aba5db740
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:22 2016 +0100

    drm/i915: Merge i915_dma.c into i915_drv.c
    
    i915_dma.c used to contain the DRI1/UMS horror show, but now all that
    remains are the out-of-place driver level interfaces (such as
    allocating, initialising and registering the driver). These should be in
    i915_drv.c alongside similar routines for suspend/resume.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-10-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9ddae6add9e0..e2375361a34d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -27,19 +27,29 @@
  *
  */
 
-#include <linux/device.h>
 #include <linux/acpi.h>
-#include <drm/drmP.h>
-#include <drm/i915_drm.h>
-#include "i915_drv.h"
-#include "i915_trace.h"
-#include "intel_drv.h"
-
 #include <linux/console.h>
+#include <linux/device.h>
+#include <linux/oom.h>
 #include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
 #include <linux/pm_runtime.h>
+#include <linux/pnp.h>
+#include <linux/slab.h>
+#include <linux/vgaarb.h>
 #include <linux/vga_switcheroo.h>
+#include <linux/vt.h>
+#include <acpi/video.h>
+
+#include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/i915_drm.h>
+
+#include "i915_drv.h"
+#include "i915_trace.h"
+#include "i915_vgpu.h"
+#include "intel_drv.h"
 
 static struct drm_driver driver;
 
@@ -321,239 +331,1833 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 };
 
-static const struct intel_device_info intel_cherryview_info = {
-	.gen = 8, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.is_cherryview = 1,
-	.display_mmio_offset = VLV_DISPLAY_BASE,
-	GEN_CHV_PIPEOFFSETS,
-	CURSOR_OFFSETS,
-	CHV_COLORS,
-};
+static const struct intel_device_info intel_cherryview_info = {
+	.gen = 8, .num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.is_cherryview = 1,
+	.display_mmio_offset = VLV_DISPLAY_BASE,
+	GEN_CHV_PIPEOFFSETS,
+	CURSOR_OFFSETS,
+	CHV_COLORS,
+};
+
+static const struct intel_device_info intel_skylake_info = {
+	BDW_FEATURES,
+	.is_skylake = 1,
+	.gen = 9,
+};
+
+static const struct intel_device_info intel_skylake_gt3_info = {
+	BDW_FEATURES,
+	.is_skylake = 1,
+	.gen = 9,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
+};
+
+static const struct intel_device_info intel_broxton_info = {
+	.is_preliminary = 1,
+	.is_broxton = 1,
+	.gen = 9,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.num_pipes = 3,
+	.has_ddi = 1,
+	.has_fpga_dbg = 1,
+	.has_fbc = 1,
+	.has_pooled_eu = 0,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+	BDW_COLORS,
+};
+
+static const struct intel_device_info intel_kabylake_info = {
+	BDW_FEATURES,
+	.is_kabylake = 1,
+	.gen = 9,
+};
+
+static const struct intel_device_info intel_kabylake_gt3_info = {
+	BDW_FEATURES,
+	.is_kabylake = 1,
+	.gen = 9,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
+};
+
+/*
+ * Make sure any device matches here are from most specific to most
+ * general.  For example, since the Quanta match is based on the subsystem
+ * and subvendor IDs, we need it to come before the more general IVB
+ * PCI ID matches, otherwise we'll use the wrong info struct above.
+ */
+static const struct pci_device_id pciidlist[] = {
+	INTEL_I830_IDS(&intel_i830_info),
+	INTEL_I845G_IDS(&intel_845g_info),
+	INTEL_I85X_IDS(&intel_i85x_info),
+	INTEL_I865G_IDS(&intel_i865g_info),
+	INTEL_I915G_IDS(&intel_i915g_info),
+	INTEL_I915GM_IDS(&intel_i915gm_info),
+	INTEL_I945G_IDS(&intel_i945g_info),
+	INTEL_I945GM_IDS(&intel_i945gm_info),
+	INTEL_I965G_IDS(&intel_i965g_info),
+	INTEL_G33_IDS(&intel_g33_info),
+	INTEL_I965GM_IDS(&intel_i965gm_info),
+	INTEL_GM45_IDS(&intel_gm45_info),
+	INTEL_G45_IDS(&intel_g45_info),
+	INTEL_PINEVIEW_IDS(&intel_pineview_info),
+	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),
+	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),
+	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),
+	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),
+	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */
+	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),
+	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),
+	INTEL_HSW_D_IDS(&intel_haswell_d_info),
+	INTEL_HSW_M_IDS(&intel_haswell_m_info),
+	INTEL_VLV_M_IDS(&intel_valleyview_m_info),
+	INTEL_VLV_D_IDS(&intel_valleyview_d_info),
+	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),
+	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),
+	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),
+	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info),
+	INTEL_CHV_IDS(&intel_cherryview_info),
+	INTEL_SKL_GT1_IDS(&intel_skylake_info),
+	INTEL_SKL_GT2_IDS(&intel_skylake_info),
+	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
+	INTEL_SKL_GT4_IDS(&intel_skylake_gt3_info),
+	INTEL_BXT_IDS(&intel_broxton_info),
+	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
+	INTEL_KBL_GT2_IDS(&intel_kabylake_info),
+	INTEL_KBL_GT3_IDS(&intel_kabylake_gt3_info),
+	INTEL_KBL_GT4_IDS(&intel_kabylake_gt3_info),
+	{0, 0, 0}
+};
+MODULE_DEVICE_TABLE(pci, pciidlist);
+
+static unsigned int i915_load_fail_count;
+
+bool __i915_inject_load_failure(const char *func, int line)
+{
+	if (i915_load_fail_count >= i915.inject_load_failure)
+		return false;
+
+	if (++i915_load_fail_count == i915.inject_load_failure) {
+		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
+			 i915.inject_load_failure, func, line);
+		return true;
+	}
+
+	return false;
+}
+
+#define FDO_BUG_URL "https://bugs.freedesktop.org/enter_bug.cgi?product=DRI"
+#define FDO_BUG_MSG "Please file a bug at " FDO_BUG_URL " against DRM/Intel " \
+		    "providing the dmesg log by booting with drm.debug=0xf"
+
+void
+__i915_printk(struct drm_i915_private *dev_priv, const char *level,
+	      const char *fmt, ...)
+{
+	static bool shown_bug_once;
+	struct device *dev = dev_priv->dev->dev;
+	bool is_error = level[1] <= KERN_ERR[1];
+	bool is_debug = level[1] == KERN_DEBUG[1];
+	struct va_format vaf;
+	va_list args;
+
+	if (is_debug && !(drm_debug & DRM_UT_DRIVER))
+		return;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	dev_printk(level, dev, "[" DRM_NAME ":%ps] %pV",
+		   __builtin_return_address(0), &vaf);
+
+	if (is_error && !shown_bug_once) {
+		dev_notice(dev, "%s", FDO_BUG_MSG);
+		shown_bug_once = true;
+	}
+
+	va_end(args);
+}
+
+static bool i915_error_injected(struct drm_i915_private *dev_priv)
+{
+	return i915.inject_load_failure &&
+	       i915_load_fail_count == i915.inject_load_failure;
+}
+
+#define i915_load_error(dev_priv, fmt, ...)				     \
+	__i915_printk(dev_priv,						     \
+		      i915_error_injected(dev_priv) ? KERN_DEBUG : KERN_ERR, \
+		      fmt, ##__VA_ARGS__)
+
+
+static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
+{
+	enum intel_pch ret = PCH_NOP;
+
+	/*
+	 * In a virtualized passthrough environment we can be in a
+	 * setup where the ISA bridge is not able to be passed through.
+	 * In this case, a south bridge can be emulated and we have to
+	 * make an educated guess as to which PCH is really there.
+	 */
+
+	if (IS_GEN5(dev)) {
+		ret = PCH_IBX;
+		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
+	} else if (IS_GEN6(dev) || IS_IVYBRIDGE(dev)) {
+		ret = PCH_CPT;
+		DRM_DEBUG_KMS("Assuming CouarPoint PCH\n");
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = PCH_LPT;
+		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
+	} else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {
+		ret = PCH_SPT;
+		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
+	}
+
+	return ret;
+}
+
+static void intel_detect_pch(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct pci_dev *pch = NULL;
+
+	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
+	 * (which really amounts to a PCH but no South Display).
+	 */
+	if (INTEL_INFO(dev)->num_pipes == 0) {
+		dev_priv->pch_type = PCH_NOP;
+		return;
+	}
+
+	/*
+	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
+	 * make graphics device passthrough work easy for VMM, that only
+	 * need to expose ISA bridge to let driver know the real hardware
+	 * underneath. This is a requirement from virtualization team.
+	 *
+	 * In some virtualized environments (e.g. XEN), there is irrelevant
+	 * ISA bridge in the system. To work reliably, we should scan trhough
+	 * all the ISA bridge devices and check for the first match, instead
+	 * of only checking the first one.
+	 */
+	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
+		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
+			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+			dev_priv->pch_id = id;
+
+			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_IBX;
+				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
+				WARN_ON(!IS_GEN5(dev));
+			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_CPT;
+				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
+			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
+				/* PantherPoint is CPT compatible */
+				dev_priv->pch_type = PCH_CPT;
+				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
+				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
+			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
+				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(IS_HSW_ULT(dev) || IS_BDW_ULT(dev));
+			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
+				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(!IS_HSW_ULT(dev) && !IS_BDW_ULT(dev));
+			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_SPT;
+				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
+				WARN_ON(!IS_SKYLAKE(dev) &&
+					!IS_KABYLAKE(dev));
+			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_SPT;
+				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
+				WARN_ON(!IS_SKYLAKE(dev) &&
+					!IS_KABYLAKE(dev));
+			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
+				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
+				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
+				    pch->subsystem_vendor ==
+					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
+				    pch->subsystem_device ==
+					    PCI_SUBDEVICE_ID_QEMU)) {
+				dev_priv->pch_type = intel_virt_detect_pch(dev);
+			} else
+				continue;
+
+			break;
+		}
+	}
+	if (!pch)
+		DRM_DEBUG_KMS("No PCH found.\n");
+
+	pci_dev_put(pch);
+}
+
+bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
+{
+	if (INTEL_GEN(dev_priv) < 6)
+		return false;
+
+	if (i915.semaphores >= 0)
+		return i915.semaphores;
+
+	/* TODO: make semaphores and Execlists play nicely together */
+	if (i915.enable_execlists)
+		return false;
+
+#ifdef CONFIG_INTEL_IOMMU
+	/* Enable semaphores on SNB when IO remapping is off */
+	if (IS_GEN6(dev_priv) && intel_iommu_gfx_mapped)
+		return false;
+#endif
+
+	return true;
+}
+
+static int i915_getparam(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	drm_i915_getparam_t *param = data;
+	int value;
+
+	switch (param->param) {
+	case I915_PARAM_IRQ_ACTIVE:
+	case I915_PARAM_ALLOW_BATCHBUFFER:
+	case I915_PARAM_LAST_DISPATCH:
+		/* Reject all old ums/dri params. */
+		return -ENODEV;
+	case I915_PARAM_CHIPSET_ID:
+		value = dev->pdev->device;
+		break;
+	case I915_PARAM_REVISION:
+		value = dev->pdev->revision;
+		break;
+	case I915_PARAM_HAS_GEM:
+		value = 1;
+		break;
+	case I915_PARAM_NUM_FENCES_AVAIL:
+		value = dev_priv->num_fence_regs;
+		break;
+	case I915_PARAM_HAS_OVERLAY:
+		value = dev_priv->overlay ? 1 : 0;
+		break;
+	case I915_PARAM_HAS_PAGEFLIPPING:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_EXECBUF2:
+		/* depends on GEM */
+		value = 1;
+		break;
+	case I915_PARAM_HAS_BSD:
+		value = intel_engine_initialized(&dev_priv->engine[VCS]);
+		break;
+	case I915_PARAM_HAS_BLT:
+		value = intel_engine_initialized(&dev_priv->engine[BCS]);
+		break;
+	case I915_PARAM_HAS_VEBOX:
+		value = intel_engine_initialized(&dev_priv->engine[VECS]);
+		break;
+	case I915_PARAM_HAS_BSD2:
+		value = intel_engine_initialized(&dev_priv->engine[VCS2]);
+		break;
+	case I915_PARAM_HAS_RELAXED_FENCING:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_COHERENT_RINGS:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_EXEC_CONSTANTS:
+		value = INTEL_INFO(dev)->gen >= 4;
+		break;
+	case I915_PARAM_HAS_RELAXED_DELTA:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_GEN7_SOL_RESET:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_LLC:
+		value = HAS_LLC(dev);
+		break;
+	case I915_PARAM_HAS_WT:
+		value = HAS_WT(dev);
+		break;
+	case I915_PARAM_HAS_ALIASING_PPGTT:
+		value = USES_PPGTT(dev);
+		break;
+	case I915_PARAM_HAS_WAIT_TIMEOUT:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_SEMAPHORES:
+		value = i915_semaphore_is_enabled(dev_priv);
+		break;
+	case I915_PARAM_HAS_PRIME_VMAP_FLUSH:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_SECURE_BATCHES:
+		value = capable(CAP_SYS_ADMIN);
+		break;
+	case I915_PARAM_HAS_PINNED_BATCHES:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_EXEC_NO_RELOC:
+		value = 1;
+		break;
+	case I915_PARAM_HAS_EXEC_HANDLE_LUT:
+		value = 1;
+		break;
+	case I915_PARAM_CMD_PARSER_VERSION:
+		value = i915_cmd_parser_get_version(dev_priv);
+		break;
+	case I915_PARAM_HAS_COHERENT_PHYS_GTT:
+		value = 1;
+		break;
+	case I915_PARAM_MMAP_VERSION:
+		value = 1;
+		break;
+	case I915_PARAM_SUBSLICE_TOTAL:
+		value = INTEL_INFO(dev)->subslice_total;
+		if (!value)
+			return -ENODEV;
+		break;
+	case I915_PARAM_EU_TOTAL:
+		value = INTEL_INFO(dev)->eu_total;
+		if (!value)
+			return -ENODEV;
+		break;
+	case I915_PARAM_HAS_GPU_RESET:
+		value = i915.enable_hangcheck && intel_has_gpu_reset(dev_priv);
+		break;
+	case I915_PARAM_HAS_RESOURCE_STREAMER:
+		value = HAS_RESOURCE_STREAMER(dev);
+		break;
+	case I915_PARAM_HAS_EXEC_SOFTPIN:
+		value = 1;
+		break;
+	default:
+		DRM_DEBUG("Unknown parameter %d\n", param->param);
+		return -EINVAL;
+	}
+
+	if (copy_to_user(param->value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user failed\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int i915_get_bridge_dev(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	dev_priv->bridge_dev = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+	if (!dev_priv->bridge_dev) {
+		DRM_ERROR("bridge device not found\n");
+		return -1;
+	}
+	return 0;
+}
+
+/* Allocate space for the MCH regs if needed, return nonzero on error */
+static int
+intel_alloc_mchbar_resource(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+	u32 temp_lo, temp_hi = 0;
+	u64 mchbar_addr;
+	int ret;
+
+	if (INTEL_INFO(dev)->gen >= 4)
+		pci_read_config_dword(dev_priv->bridge_dev, reg + 4, &temp_hi);
+	pci_read_config_dword(dev_priv->bridge_dev, reg, &temp_lo);
+	mchbar_addr = ((u64)temp_hi << 32) | temp_lo;
+
+	/* If ACPI doesn't have it, assume we need to allocate it ourselves */
+#ifdef CONFIG_PNP
+	if (mchbar_addr &&
+	    pnp_range_reserved(mchbar_addr, mchbar_addr + MCHBAR_SIZE))
+		return 0;
+#endif
+
+	/* Get some space for it */
+	dev_priv->mch_res.name = "i915 MCHBAR";
+	dev_priv->mch_res.flags = IORESOURCE_MEM;
+	ret = pci_bus_alloc_resource(dev_priv->bridge_dev->bus,
+				     &dev_priv->mch_res,
+				     MCHBAR_SIZE, MCHBAR_SIZE,
+				     PCIBIOS_MIN_MEM,
+				     0, pcibios_align_resource,
+				     dev_priv->bridge_dev);
+	if (ret) {
+		DRM_DEBUG_DRIVER("failed bus alloc: %d\n", ret);
+		dev_priv->mch_res.start = 0;
+		return ret;
+	}
+
+	if (INTEL_INFO(dev)->gen >= 4)
+		pci_write_config_dword(dev_priv->bridge_dev, reg + 4,
+				       upper_32_bits(dev_priv->mch_res.start));
+
+	pci_write_config_dword(dev_priv->bridge_dev, reg,
+			       lower_32_bits(dev_priv->mch_res.start));
+	return 0;
+}
+
+/* Setup MCHBAR if possible, return true if we should disable it again */
+static void
+intel_setup_mchbar(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+	u32 temp;
+	bool enabled;
+
+	if (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev))
+		return;
+
+	dev_priv->mchbar_need_disable = false;
+
+	if (IS_I915G(dev) || IS_I915GM(dev)) {
+		pci_read_config_dword(dev_priv->bridge_dev, DEVEN, &temp);
+		enabled = !!(temp & DEVEN_MCHBAR_EN);
+	} else {
+		pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, &temp);
+		enabled = temp & 1;
+	}
+
+	/* If it's already enabled, don't have to do anything */
+	if (enabled)
+		return;
+
+	if (intel_alloc_mchbar_resource(dev))
+		return;
+
+	dev_priv->mchbar_need_disable = true;
+
+	/* Space is allocated or reserved, so enable it. */
+	if (IS_I915G(dev) || IS_I915GM(dev)) {
+		pci_write_config_dword(dev_priv->bridge_dev, DEVEN,
+				       temp | DEVEN_MCHBAR_EN);
+	} else {
+		pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg, &temp);
+		pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg, temp | 1);
+	}
+}
+
+static void
+intel_teardown_mchbar(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int mchbar_reg = INTEL_INFO(dev)->gen >= 4 ? MCHBAR_I965 : MCHBAR_I915;
+
+	if (dev_priv->mchbar_need_disable) {
+		if (IS_I915G(dev) || IS_I915GM(dev)) {
+			u32 deven_val;
+
+			pci_read_config_dword(dev_priv->bridge_dev, DEVEN,
+					      &deven_val);
+			deven_val &= ~DEVEN_MCHBAR_EN;
+			pci_write_config_dword(dev_priv->bridge_dev, DEVEN,
+					       deven_val);
+		} else {
+			u32 mchbar_val;
+
+			pci_read_config_dword(dev_priv->bridge_dev, mchbar_reg,
+					      &mchbar_val);
+			mchbar_val &= ~1;
+			pci_write_config_dword(dev_priv->bridge_dev, mchbar_reg,
+					       mchbar_val);
+		}
+	}
+
+	if (dev_priv->mch_res.start)
+		release_resource(&dev_priv->mch_res);
+}
+
+/* true = enable decode, false = disable decoder */
+static unsigned int i915_vga_set_decode(void *cookie, bool state)
+{
+	struct drm_device *dev = cookie;
+
+	intel_modeset_vga_set_state(dev, state);
+	if (state)
+		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
+		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
+	else
+		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
+}
+
+static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
+
+	if (state == VGA_SWITCHEROO_ON) {
+		pr_info("switched on\n");
+		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
+		/* i915 resume handler doesn't set to D0 */
+		pci_set_power_state(dev->pdev, PCI_D0);
+		i915_resume_switcheroo(dev);
+		dev->switch_power_state = DRM_SWITCH_POWER_ON;
+	} else {
+		pr_info("switched off\n");
+		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
+		i915_suspend_switcheroo(dev, pmm);
+		dev->switch_power_state = DRM_SWITCH_POWER_OFF;
+	}
+}
+
+static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	/*
+	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
+	 * locking inversion with the driver load path. And the access here is
+	 * completely racy anyway. So don't bother with locking for now.
+	 */
+	return dev->open_count == 0;
+}
+
+static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
+	.set_gpu_state = i915_switcheroo_set_state,
+	.reprobe = NULL,
+	.can_switch = i915_switcheroo_can_switch,
+};
+
+static void i915_gem_fini(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	/*
+	 * Neither the BIOS, ourselves or any other kernel
+	 * expects the system to be in execlists mode on startup,
+	 * so we need to reset the GPU back to legacy mode. And the only
+	 * known way to disable logical contexts is through a GPU reset.
+	 *
+	 * So in order to leave the system in a known default configuration,
+	 * always reset the GPU upon unload. Afterwards we then clean up the
+	 * GEM state tracking, flushing off the requests and leaving the
+	 * system in a known idle state.
+	 *
+	 * Note that is of the upmost importance that the GPU is idle and
+	 * all stray writes are flushed *before* we dismantle the backing
+	 * storage for the pinned objects.
+	 *
+	 * However, since we are uncertain that reseting the GPU on older
+	 * machines is a good idea, we don't - just in case it leaves the
+	 * machine in an unusable condition.
+	 */
+	if (HAS_HW_CONTEXTS(dev)) {
+		int reset = intel_gpu_reset(dev_priv, ALL_ENGINES);
+		WARN_ON(reset && reset != -ENODEV);
+	}
+
+	mutex_lock(&dev->struct_mutex);
+	i915_gem_reset(dev);
+	i915_gem_cleanup_engines(dev);
+	i915_gem_context_fini(dev);
+	mutex_unlock(&dev->struct_mutex);
+
+	WARN_ON(!list_empty(&to_i915(dev)->context_list));
+}
+
+static int i915_load_modeset_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
+	ret = intel_bios_init(dev_priv);
+	if (ret)
+		DRM_INFO("failed to find VBIOS tables\n");
+
+	/* If we have > 1 VGA cards, then we need to arbitrate access
+	 * to the common VGA resources.
+	 *
+	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
+	 * then we do not take part in VGA arbitration and the
+	 * vga_client_register() fails with -ENODEV.
+	 */
+	ret = vga_client_register(dev->pdev, dev, NULL, i915_vga_set_decode);
+	if (ret && ret != -ENODEV)
+		goto out;
+
+	intel_register_dsm_handler();
+
+	ret = vga_switcheroo_register_client(dev->pdev, &i915_switcheroo_ops, false);
+	if (ret)
+		goto cleanup_vga_client;
+
+	/* must happen before intel_power_domains_init_hw() on VLV/CHV */
+	intel_update_rawclk(dev_priv);
+
+	intel_power_domains_init_hw(dev_priv, false);
+
+	intel_csr_ucode_init(dev_priv);
+
+	ret = intel_irq_install(dev_priv);
+	if (ret)
+		goto cleanup_csr;
+
+	intel_setup_gmbus(dev);
+
+	/* Important: The output setup functions called by modeset_init need
+	 * working irqs for e.g. gmbus and dp aux transfers. */
+	intel_modeset_init(dev);
+
+	intel_guc_init(dev);
+
+	ret = i915_gem_init(dev);
+	if (ret)
+		goto cleanup_irq;
+
+	intel_modeset_gem_init(dev);
+
+	if (INTEL_INFO(dev)->num_pipes == 0)
+		return 0;
+
+	ret = intel_fbdev_init(dev);
+	if (ret)
+		goto cleanup_gem;
+
+	/* Only enable hotplug handling once the fbdev is fully set up. */
+	intel_hpd_init(dev_priv);
+
+	drm_kms_helper_poll_init(dev);
+
+	return 0;
+
+cleanup_gem:
+	i915_gem_fini(dev);
+cleanup_irq:
+	intel_guc_fini(dev);
+	drm_irq_uninstall(dev);
+	intel_teardown_gmbus(dev);
+cleanup_csr:
+	intel_csr_ucode_fini(dev_priv);
+	intel_power_domains_fini(dev_priv);
+	vga_switcheroo_unregister_client(dev->pdev);
+cleanup_vga_client:
+	vga_client_register(dev->pdev, NULL, NULL, NULL);
+out:
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_FB)
+static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
+{
+	struct apertures_struct *ap;
+	struct pci_dev *pdev = dev_priv->dev->pdev;
+	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+	bool primary;
+	int ret;
+
+	ap = alloc_apertures(1);
+	if (!ap)
+		return -ENOMEM;
+
+	ap->ranges[0].base = ggtt->mappable_base;
+	ap->ranges[0].size = ggtt->mappable_end;
+
+	primary =
+		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
+
+	ret = remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
+
+	kfree(ap);
+
+	return ret;
+}
+#else
+static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
+{
+	return 0;
+}
+#endif
+
+#if !defined(CONFIG_VGA_CONSOLE)
+static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
+{
+	return 0;
+}
+#elif !defined(CONFIG_DUMMY_CONSOLE)
+static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
+{
+	return -ENODEV;
+}
+#else
+static int i915_kick_out_vgacon(struct drm_i915_private *dev_priv)
+{
+	int ret = 0;
+
+	DRM_INFO("Replacing VGA console driver\n");
+
+	console_lock();
+	if (con_is_bound(&vga_con))
+		ret = do_take_over_console(&dummy_con, 0, MAX_NR_CONSOLES - 1, 1);
+	if (ret == 0) {
+		ret = do_unregister_con_driver(&vga_con);
+
+		/* Ignore "already unregistered". */
+		if (ret == -ENODEV)
+			ret = 0;
+	}
+	console_unlock();
+
+	return ret;
+}
+#endif
+
+static void i915_dump_device_info(struct drm_i915_private *dev_priv)
+{
+	const struct intel_device_info *info = &dev_priv->info;
+
+#define PRINT_S(name) "%s"
+#define SEP_EMPTY
+#define PRINT_FLAG(name) info->name ? #name "," : ""
+#define SEP_COMMA ,
+	DRM_DEBUG_DRIVER("i915 device info: gen=%i, pciid=0x%04x rev=0x%02x flags="
+			 DEV_INFO_FOR_EACH_FLAG(PRINT_S, SEP_EMPTY),
+			 info->gen,
+			 dev_priv->dev->pdev->device,
+			 dev_priv->dev->pdev->revision,
+			 DEV_INFO_FOR_EACH_FLAG(PRINT_FLAG, SEP_COMMA));
+#undef PRINT_S
+#undef SEP_EMPTY
+#undef PRINT_FLAG
+#undef SEP_COMMA
+}
+
+static void cherryview_sseu_info_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct intel_device_info *info;
+	u32 fuse, eu_dis;
+
+	info = (struct intel_device_info *)&dev_priv->info;
+	fuse = I915_READ(CHV_FUSE_GT);
+
+	info->slice_total = 1;
+
+	if (!(fuse & CHV_FGT_DISABLE_SS0)) {
+		info->subslice_per_slice++;
+		eu_dis = fuse & (CHV_FGT_EU_DIS_SS0_R0_MASK |
+				 CHV_FGT_EU_DIS_SS0_R1_MASK);
+		info->eu_total += 8 - hweight32(eu_dis);
+	}
+
+	if (!(fuse & CHV_FGT_DISABLE_SS1)) {
+		info->subslice_per_slice++;
+		eu_dis = fuse & (CHV_FGT_EU_DIS_SS1_R0_MASK |
+				 CHV_FGT_EU_DIS_SS1_R1_MASK);
+		info->eu_total += 8 - hweight32(eu_dis);
+	}
+
+	info->subslice_total = info->subslice_per_slice;
+	/*
+	 * CHV expected to always have a uniform distribution of EU
+	 * across subslices.
+	*/
+	info->eu_per_subslice = info->subslice_total ?
+				info->eu_total / info->subslice_total :
+				0;
+	/*
+	 * CHV supports subslice power gating on devices with more than
+	 * one subslice, and supports EU power gating on devices with
+	 * more than one EU pair per subslice.
+	*/
+	info->has_slice_pg = 0;
+	info->has_subslice_pg = (info->subslice_total > 1);
+	info->has_eu_pg = (info->eu_per_subslice > 2);
+}
+
+static void gen9_sseu_info_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct intel_device_info *info;
+	int s_max = 3, ss_max = 4, eu_max = 8;
+	int s, ss;
+	u32 fuse2, s_enable, ss_disable, eu_disable;
+	u8 eu_mask = 0xff;
+
+	info = (struct intel_device_info *)&dev_priv->info;
+	fuse2 = I915_READ(GEN8_FUSE2);
+	s_enable = (fuse2 & GEN8_F2_S_ENA_MASK) >>
+		   GEN8_F2_S_ENA_SHIFT;
+	ss_disable = (fuse2 & GEN9_F2_SS_DIS_MASK) >>
+		     GEN9_F2_SS_DIS_SHIFT;
+
+	info->slice_total = hweight32(s_enable);
+	/*
+	 * The subslice disable field is global, i.e. it applies
+	 * to each of the enabled slices.
+	*/
+	info->subslice_per_slice = ss_max - hweight32(ss_disable);
+	info->subslice_total = info->slice_total *
+			       info->subslice_per_slice;
+
+	/*
+	 * Iterate through enabled slices and subslices to
+	 * count the total enabled EU.
+	*/
+	for (s = 0; s < s_max; s++) {
+		if (!(s_enable & (0x1 << s)))
+			/* skip disabled slice */
+			continue;
+
+		eu_disable = I915_READ(GEN9_EU_DISABLE(s));
+		for (ss = 0; ss < ss_max; ss++) {
+			int eu_per_ss;
+
+			if (ss_disable & (0x1 << ss))
+				/* skip disabled subslice */
+				continue;
+
+			eu_per_ss = eu_max - hweight8((eu_disable >> (ss*8)) &
+						      eu_mask);
+
+			/*
+			 * Record which subslice(s) has(have) 7 EUs. we
+			 * can tune the hash used to spread work among
+			 * subslices if they are unbalanced.
+			 */
+			if (eu_per_ss == 7)
+				info->subslice_7eu[s] |= 1 << ss;
+
+			info->eu_total += eu_per_ss;
+		}
+	}
+
+	/*
+	 * SKL is expected to always have a uniform distribution
+	 * of EU across subslices with the exception that any one
+	 * EU in any one subslice may be fused off for die
+	 * recovery. BXT is expected to be perfectly uniform in EU
+	 * distribution.
+	*/
+	info->eu_per_subslice = info->subslice_total ?
+				DIV_ROUND_UP(info->eu_total,
+					     info->subslice_total) : 0;
+	/*
+	 * SKL supports slice power gating on devices with more than
+	 * one slice, and supports EU power gating on devices with
+	 * more than one EU pair per subslice. BXT supports subslice
+	 * power gating on devices with more than one subslice, and
+	 * supports EU power gating on devices with more than one EU
+	 * pair per subslice.
+	*/
+	info->has_slice_pg = ((IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) &&
+			       (info->slice_total > 1));
+	info->has_subslice_pg = (IS_BROXTON(dev) && (info->subslice_total > 1));
+	info->has_eu_pg = (info->eu_per_subslice > 2);
+
+	if (IS_BROXTON(dev)) {
+#define IS_SS_DISABLED(_ss_disable, ss)    (_ss_disable & (0x1 << ss))
+		/*
+		 * There is a HW issue in 2x6 fused down parts that requires
+		 * Pooled EU to be enabled as a WA. The pool configuration
+		 * changes depending upon which subslice is fused down. This
+		 * doesn't affect if the device has all 3 subslices enabled.
+		 */
+		/* WaEnablePooledEuFor2x6:bxt */
+		info->has_pooled_eu = ((info->subslice_per_slice == 3) ||
+				       (info->subslice_per_slice == 2 &&
+					INTEL_REVID(dev) < BXT_REVID_C0));
+
+		info->min_eu_in_pool = 0;
+		if (info->has_pooled_eu) {
+			if (IS_SS_DISABLED(ss_disable, 0) ||
+			    IS_SS_DISABLED(ss_disable, 2))
+				info->min_eu_in_pool = 3;
+			else if (IS_SS_DISABLED(ss_disable, 1))
+				info->min_eu_in_pool = 6;
+			else
+				info->min_eu_in_pool = 9;
+		}
+#undef IS_SS_DISABLED
+	}
+}
+
+static void broadwell_sseu_info_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct intel_device_info *info;
+	const int s_max = 3, ss_max = 3, eu_max = 8;
+	int s, ss;
+	u32 fuse2, eu_disable[s_max], s_enable, ss_disable;
+
+	fuse2 = I915_READ(GEN8_FUSE2);
+	s_enable = (fuse2 & GEN8_F2_S_ENA_MASK) >> GEN8_F2_S_ENA_SHIFT;
+	ss_disable = (fuse2 & GEN8_F2_SS_DIS_MASK) >> GEN8_F2_SS_DIS_SHIFT;
+
+	eu_disable[0] = I915_READ(GEN8_EU_DISABLE0) & GEN8_EU_DIS0_S0_MASK;
+	eu_disable[1] = (I915_READ(GEN8_EU_DISABLE0) >> GEN8_EU_DIS0_S1_SHIFT) |
+			((I915_READ(GEN8_EU_DISABLE1) & GEN8_EU_DIS1_S1_MASK) <<
+			 (32 - GEN8_EU_DIS0_S1_SHIFT));
+	eu_disable[2] = (I915_READ(GEN8_EU_DISABLE1) >> GEN8_EU_DIS1_S2_SHIFT) |
+			((I915_READ(GEN8_EU_DISABLE2) & GEN8_EU_DIS2_S2_MASK) <<
+			 (32 - GEN8_EU_DIS1_S2_SHIFT));
+
+
+	info = (struct intel_device_info *)&dev_priv->info;
+	info->slice_total = hweight32(s_enable);
+
+	/*
+	 * The subslice disable field is global, i.e. it applies
+	 * to each of the enabled slices.
+	 */
+	info->subslice_per_slice = ss_max - hweight32(ss_disable);
+	info->subslice_total = info->slice_total * info->subslice_per_slice;
+
+	/*
+	 * Iterate through enabled slices and subslices to
+	 * count the total enabled EU.
+	 */
+	for (s = 0; s < s_max; s++) {
+		if (!(s_enable & (0x1 << s)))
+			/* skip disabled slice */
+			continue;
+
+		for (ss = 0; ss < ss_max; ss++) {
+			u32 n_disabled;
+
+			if (ss_disable & (0x1 << ss))
+				/* skip disabled subslice */
+				continue;
+
+			n_disabled = hweight8(eu_disable[s] >> (ss * eu_max));
+
+			/*
+			 * Record which subslices have 7 EUs.
+			 */
+			if (eu_max - n_disabled == 7)
+				info->subslice_7eu[s] |= 1 << ss;
+
+			info->eu_total += eu_max - n_disabled;
+		}
+	}
+
+	/*
+	 * BDW is expected to always have a uniform distribution of EU across
+	 * subslices with the exception that any one EU in any one subslice may
+	 * be fused off for die recovery.
+	 */
+	info->eu_per_subslice = info->subslice_total ?
+		DIV_ROUND_UP(info->eu_total, info->subslice_total) : 0;
+
+	/*
+	 * BDW supports slice power gating on devices with more than
+	 * one slice.
+	 */
+	info->has_slice_pg = (info->slice_total > 1);
+	info->has_subslice_pg = 0;
+	info->has_eu_pg = 0;
+}
+
+/*
+ * Determine various intel_device_info fields at runtime.
+ *
+ * Use it when either:
+ *   - it's judged too laborious to fill n static structures with the limit
+ *     when a simple if statement does the job,
+ *   - run-time checks (eg read fuse/strap registers) are needed.
+ *
+ * This function needs to be called:
+ *   - after the MMIO has been setup as we are reading registers,
+ *   - after the PCH has been detected,
+ *   - before the first usage of the fields it can tweak.
+ */
+static void intel_device_info_runtime_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct intel_device_info *info;
+	enum pipe pipe;
+
+	info = (struct intel_device_info *)&dev_priv->info;
+
+	/*
+	 * Skylake and Broxton currently don't expose the topmost plane as its
+	 * use is exclusive with the legacy cursor and we only want to expose
+	 * one of those, not both. Until we can safely expose the topmost plane
+	 * as a DRM_PLANE_TYPE_CURSOR with all the features exposed/supported,
+	 * we don't expose the topmost plane at all to prevent ABI breakage
+	 * down the line.
+	 */
+	if (IS_BROXTON(dev)) {
+		info->num_sprites[PIPE_A] = 2;
+		info->num_sprites[PIPE_B] = 2;
+		info->num_sprites[PIPE_C] = 1;
+	} else if (IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev))
+		for_each_pipe(dev_priv, pipe)
+			info->num_sprites[pipe] = 2;
+	else
+		for_each_pipe(dev_priv, pipe)
+			info->num_sprites[pipe] = 1;
+
+	if (i915.disable_display) {
+		DRM_INFO("Display disabled (module parameter)\n");
+		info->num_pipes = 0;
+	} else if (info->num_pipes > 0 &&
+		   (IS_GEN7(dev_priv) || IS_GEN8(dev_priv)) &&
+		   HAS_PCH_SPLIT(dev)) {
+		u32 fuse_strap = I915_READ(FUSE_STRAP);
+		u32 sfuse_strap = I915_READ(SFUSE_STRAP);
+
+		/*
+		 * SFUSE_STRAP is supposed to have a bit signalling the display
+		 * is fused off. Unfortunately it seems that, at least in
+		 * certain cases, fused off display means that PCH display
+		 * reads don't land anywhere. In that case, we read 0s.
+		 *
+		 * On CPT/PPT, we can detect this case as SFUSE_STRAP_FUSE_LOCK
+		 * should be set when taking over after the firmware.
+		 */
+		if (fuse_strap & ILK_INTERNAL_DISPLAY_DISABLE ||
+		    sfuse_strap & SFUSE_STRAP_DISPLAY_DISABLED ||
+		    (dev_priv->pch_type == PCH_CPT &&
+		     !(sfuse_strap & SFUSE_STRAP_FUSE_LOCK))) {
+			DRM_INFO("Display fused off, disabling\n");
+			info->num_pipes = 0;
+		} else if (fuse_strap & IVB_PIPE_C_DISABLE) {
+			DRM_INFO("PipeC fused off\n");
+			info->num_pipes -= 1;
+		}
+	} else if (info->num_pipes > 0 && IS_GEN9(dev_priv)) {
+		u32 dfsm = I915_READ(SKL_DFSM);
+		u8 disabled_mask = 0;
+		bool invalid;
+		int num_bits;
+
+		if (dfsm & SKL_DFSM_PIPE_A_DISABLE)
+			disabled_mask |= BIT(PIPE_A);
+		if (dfsm & SKL_DFSM_PIPE_B_DISABLE)
+			disabled_mask |= BIT(PIPE_B);
+		if (dfsm & SKL_DFSM_PIPE_C_DISABLE)
+			disabled_mask |= BIT(PIPE_C);
+
+		num_bits = hweight8(disabled_mask);
+
+		switch (disabled_mask) {
+		case BIT(PIPE_A):
+		case BIT(PIPE_B):
+		case BIT(PIPE_A) | BIT(PIPE_B):
+		case BIT(PIPE_A) | BIT(PIPE_C):
+			invalid = true;
+			break;
+		default:
+			invalid = false;
+		}
+
+		if (num_bits > info->num_pipes || invalid)
+			DRM_ERROR("invalid pipe fuse configuration: 0x%x\n",
+				  disabled_mask);
+		else
+			info->num_pipes -= num_bits;
+	}
+
+	/* Initialize slice/subslice/EU info */
+	if (IS_CHERRYVIEW(dev))
+		cherryview_sseu_info_init(dev);
+	else if (IS_BROADWELL(dev))
+		broadwell_sseu_info_init(dev);
+	else if (INTEL_INFO(dev)->gen >= 9)
+		gen9_sseu_info_init(dev);
+
+	info->has_snoop = !info->has_llc;
+
+	/* Snooping is broken on BXT A stepping. */
+	if (IS_BXT_REVID(dev, 0, BXT_REVID_A1))
+		info->has_snoop = false;
+
+	DRM_DEBUG_DRIVER("slice total: %u\n", info->slice_total);
+	DRM_DEBUG_DRIVER("subslice total: %u\n", info->subslice_total);
+	DRM_DEBUG_DRIVER("subslice per slice: %u\n", info->subslice_per_slice);
+	DRM_DEBUG_DRIVER("EU total: %u\n", info->eu_total);
+	DRM_DEBUG_DRIVER("EU per subslice: %u\n", info->eu_per_subslice);
+	DRM_DEBUG_DRIVER("has slice power gating: %s\n",
+			 info->has_slice_pg ? "y" : "n");
+	DRM_DEBUG_DRIVER("has subslice power gating: %s\n",
+			 info->has_subslice_pg ? "y" : "n");
+	DRM_DEBUG_DRIVER("has EU power gating: %s\n",
+			 info->has_eu_pg ? "y" : "n");
+
+	i915.enable_execlists =
+		intel_sanitize_enable_execlists(dev_priv,
+					       	i915.enable_execlists);
+
+	/*
+	 * i915.enable_ppgtt is read-only, so do an early pass to validate the
+	 * user's requested state against the hardware/driver capabilities.  We
+	 * do this now so that we can print out any log messages once rather
+	 * than every time we check intel_enable_ppgtt().
+	 */
+	i915.enable_ppgtt =
+		intel_sanitize_enable_ppgtt(dev_priv, i915.enable_ppgtt);
+	DRM_DEBUG_DRIVER("ppgtt mode: %i\n", i915.enable_ppgtt);
+}
+
+static void intel_init_dpio(struct drm_i915_private *dev_priv)
+{
+	/*
+	 * IOSF_PORT_DPIO is used for VLV x2 PHY (DP/HDMI B and C),
+	 * CHV x1 PHY (DP/HDMI D)
+	 * IOSF_PORT_DPIO_2 is used for CHV x2 PHY (DP/HDMI B and C)
+	 */
+	if (IS_CHERRYVIEW(dev_priv)) {
+		DPIO_PHY_IOSF_PORT(DPIO_PHY0) = IOSF_PORT_DPIO_2;
+		DPIO_PHY_IOSF_PORT(DPIO_PHY1) = IOSF_PORT_DPIO;
+	} else if (IS_VALLEYVIEW(dev_priv)) {
+		DPIO_PHY_IOSF_PORT(DPIO_PHY0) = IOSF_PORT_DPIO;
+	}
+}
+
+static int i915_workqueues_init(struct drm_i915_private *dev_priv)
+{
+	/*
+	 * The i915 workqueue is primarily used for batched retirement of
+	 * requests (and thus managing bo) once the task has been completed
+	 * by the GPU. i915_gem_retire_requests() is called directly when we
+	 * need high-priority retirement, such as waiting for an explicit
+	 * bo.
+	 *
+	 * It is also used for periodic low-priority events, such as
+	 * idle-timers and recording error state.
+	 *
+	 * All tasks on the workqueue are expected to acquire the dev mutex
+	 * so there is no point in running more than one instance of the
+	 * workqueue at any time.  Use an ordered one.
+	 */
+	dev_priv->wq = alloc_ordered_workqueue("i915", 0);
+	if (dev_priv->wq == NULL)
+		goto out_err;
+
+	dev_priv->hotplug.dp_wq = alloc_ordered_workqueue("i915-dp", 0);
+	if (dev_priv->hotplug.dp_wq == NULL)
+		goto out_free_wq;
+
+	dev_priv->gpu_error.hangcheck_wq =
+		alloc_ordered_workqueue("i915-hangcheck", 0);
+	if (dev_priv->gpu_error.hangcheck_wq == NULL)
+		goto out_free_dp_wq;
+
+	return 0;
+
+out_free_dp_wq:
+	destroy_workqueue(dev_priv->hotplug.dp_wq);
+out_free_wq:
+	destroy_workqueue(dev_priv->wq);
+out_err:
+	DRM_ERROR("Failed to allocate workqueues.\n");
+
+	return -ENOMEM;
+}
+
+static void i915_workqueues_cleanup(struct drm_i915_private *dev_priv)
+{
+	destroy_workqueue(dev_priv->gpu_error.hangcheck_wq);
+	destroy_workqueue(dev_priv->hotplug.dp_wq);
+	destroy_workqueue(dev_priv->wq);
+}
+
+/**
+ * i915_driver_init_early - setup state not requiring device access
+ * @dev_priv: device private
+ *
+ * Initialize everything that is a "SW-only" state, that is state not
+ * requiring accessing the device or exposing the driver via kernel internal
+ * or userspace interfaces. Example steps belonging here: lock initialization,
+ * system memory allocation, setting up device specific attributes and
+ * function hooks not requiring accessing the device.
+ */
+static int i915_driver_init_early(struct drm_i915_private *dev_priv,
+				  const struct pci_device_id *ent)
+{
+	const struct intel_device_info *match_info =
+		(struct intel_device_info *)ent->driver_data;
+	struct intel_device_info *device_info;
+	int ret = 0;
+
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
+	/* Setup the write-once "constant" device info */
+	device_info = (struct intel_device_info *)&dev_priv->info;
+	memcpy(device_info, match_info, sizeof(*device_info));
+	device_info->device_id = dev_priv->drm.pdev->device;
+
+	BUG_ON(device_info->gen > sizeof(device_info->gen_mask) * BITS_PER_BYTE);
+	device_info->gen_mask = BIT(device_info->gen - 1);
+
+	spin_lock_init(&dev_priv->irq_lock);
+	spin_lock_init(&dev_priv->gpu_error.lock);
+	mutex_init(&dev_priv->backlight_lock);
+	spin_lock_init(&dev_priv->uncore.lock);
+	spin_lock_init(&dev_priv->mm.object_stat_lock);
+	spin_lock_init(&dev_priv->mmio_flip_lock);
+	mutex_init(&dev_priv->sb_lock);
+	mutex_init(&dev_priv->modeset_restore_lock);
+	mutex_init(&dev_priv->av_mutex);
+	mutex_init(&dev_priv->wm.wm_mutex);
+	mutex_init(&dev_priv->pps_mutex);
+
+	ret = i915_workqueues_init(dev_priv);
+	if (ret < 0)
+		return ret;
+
+	ret = intel_gvt_init(dev_priv);
+	if (ret < 0)
+		goto err_workqueues;
+
+	/* This must be called before any calls to HAS_PCH_* */
+	intel_detect_pch(&dev_priv->drm);
+
+	intel_pm_setup(&dev_priv->drm);
+	intel_init_dpio(dev_priv);
+	intel_power_domains_init(dev_priv);
+	intel_irq_init(dev_priv);
+	intel_init_display_hooks(dev_priv);
+	intel_init_clock_gating_hooks(dev_priv);
+	intel_init_audio_hooks(dev_priv);
+	i915_gem_load_init(&dev_priv->drm);
+
+	intel_display_crc_init(&dev_priv->drm);
+
+	i915_dump_device_info(dev_priv);
+
+	/* Not all pre-production machines fall into this category, only the
+	 * very first ones. Almost everything should work, except for maybe
+	 * suspend/resume. And we don't implement workarounds that affect only
+	 * pre-production machines. */
+	if (IS_HSW_EARLY_SDV(dev_priv))
+		DRM_INFO("This is an early pre-production Haswell machine. "
+			 "It may not be fully functional.\n");
+
+	return 0;
+
+err_workqueues:
+	i915_workqueues_cleanup(dev_priv);
+	return ret;
+}
+
+/**
+ * i915_driver_cleanup_early - cleanup the setup done in i915_driver_init_early()
+ * @dev_priv: device private
+ */
+static void i915_driver_cleanup_early(struct drm_i915_private *dev_priv)
+{
+	i915_gem_load_cleanup(dev_priv->dev);
+	i915_workqueues_cleanup(dev_priv);
+}
+
+static int i915_mmio_setup(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+	int mmio_bar;
+	int mmio_size;
+
+	mmio_bar = IS_GEN2(dev) ? 1 : 0;
+	/*
+	 * Before gen4, the registers and the GTT are behind different BARs.
+	 * However, from gen4 onwards, the registers and the GTT are shared
+	 * in the same BAR, so we want to restrict this ioremap from
+	 * clobbering the GTT which we want ioremap_wc instead. Fortunately,
+	 * the register BAR remains the same size for all the earlier
+	 * generations up to Ironlake.
+	 */
+	if (INTEL_INFO(dev)->gen < 5)
+		mmio_size = 512 * 1024;
+	else
+		mmio_size = 2 * 1024 * 1024;
+	dev_priv->regs = pci_iomap(dev->pdev, mmio_bar, mmio_size);
+	if (dev_priv->regs == NULL) {
+		DRM_ERROR("failed to map registers\n");
+
+		return -EIO;
+	}
+
+	/* Try to make sure MCHBAR is enabled before poking at it */
+	intel_setup_mchbar(dev);
+
+	return 0;
+}
+
+static void i915_mmio_cleanup(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	intel_teardown_mchbar(dev);
+	pci_iounmap(dev->pdev, dev_priv->regs);
+}
+
+/**
+ * i915_driver_init_mmio - setup device MMIO
+ * @dev_priv: device private
+ *
+ * Setup minimal device state necessary for MMIO accesses later in the
+ * initialization sequence. The setup here should avoid any other device-wide
+ * side effects or exposing the driver via kernel internal or user space
+ * interfaces.
+ */
+static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	int ret;
+
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
+	if (i915_get_bridge_dev(dev))
+		return -EIO;
+
+	ret = i915_mmio_setup(dev);
+	if (ret < 0)
+		goto put_bridge;
+
+	intel_uncore_init(dev_priv);
+
+	return 0;
+
+put_bridge:
+	pci_dev_put(dev_priv->bridge_dev);
+
+	return ret;
+}
+
+/**
+ * i915_driver_cleanup_mmio - cleanup the setup done in i915_driver_init_mmio()
+ * @dev_priv: device private
+ */
+static void i915_driver_cleanup_mmio(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	intel_uncore_fini(dev_priv);
+	i915_mmio_cleanup(dev);
+	pci_dev_put(dev_priv->bridge_dev);
+}
+
+/**
+ * i915_driver_init_hw - setup state requiring device access
+ * @dev_priv: device private
+ *
+ * Setup state that requires accessing the device, but doesn't require
+ * exposing the driver via kernel internal or userspace interfaces.
+ */
+static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+	uint32_t aperture_size;
+	int ret;
+
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
+	intel_device_info_runtime_init(dev);
+
+	ret = i915_ggtt_init_hw(dev);
+	if (ret)
+		return ret;
+
+	ret = i915_ggtt_enable_hw(dev);
+	if (ret) {
+		DRM_ERROR("failed to enable GGTT\n");
+		goto out_ggtt;
+	}
+
+	/* WARNING: Apparently we must kick fbdev drivers before vgacon,
+	 * otherwise the vga fbdev driver falls over. */
+	ret = i915_kick_out_firmware_fb(dev_priv);
+	if (ret) {
+		DRM_ERROR("failed to remove conflicting framebuffer drivers\n");
+		goto out_ggtt;
+	}
+
+	ret = i915_kick_out_vgacon(dev_priv);
+	if (ret) {
+		DRM_ERROR("failed to remove conflicting VGA console\n");
+		goto out_ggtt;
+	}
+
+	pci_set_master(dev->pdev);
+
+	/* overlay on gen2 is broken and can't address above 1G */
+	if (IS_GEN2(dev)) {
+		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(30));
+		if (ret) {
+			DRM_ERROR("failed to set DMA mask\n");
+
+			goto out_ggtt;
+		}
+	}
+
+
+	/* 965GM sometimes incorrectly writes to hardware status page (HWS)
+	 * using 32bit addressing, overwriting memory if HWS is located
+	 * above 4GB.
+	 *
+	 * The documentation also mentions an issue with undefined
+	 * behaviour if any general state is accessed within a page above 4GB,
+	 * which also needs to be handled carefully.
+	 */
+	if (IS_BROADWATER(dev) || IS_CRESTLINE(dev)) {
+		ret = dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(32));
+
+		if (ret) {
+			DRM_ERROR("failed to set DMA mask\n");
+
+			goto out_ggtt;
+		}
+	}
+
+	aperture_size = ggtt->mappable_end;
+
+	ggtt->mappable =
+		io_mapping_create_wc(ggtt->mappable_base,
+				     aperture_size);
+	if (!ggtt->mappable) {
+		ret = -EIO;
+		goto out_ggtt;
+	}
+
+	ggtt->mtrr = arch_phys_wc_add(ggtt->mappable_base,
+					      aperture_size);
+
+	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_DEFAULT_VALUE);
+
+	intel_uncore_sanitize(dev_priv);
+
+	intel_opregion_setup(dev_priv);
+
+	i915_gem_load_init_fences(dev_priv);
+
+	/* On the 945G/GM, the chipset reports the MSI capability on the
+	 * integrated graphics even though the support isn't actually there
+	 * according to the published specs.  It doesn't appear to function
+	 * correctly in testing on 945G.
+	 * This may be a side effect of MSI having been made available for PEG
+	 * and the registers being closely associated.
+	 *
+	 * According to chipset errata, on the 965GM, MSI interrupts may
+	 * be lost or delayed, but we use them anyways to avoid
+	 * stuck interrupts on some machines.
+	 */
+	if (!IS_I945G(dev) && !IS_I945GM(dev)) {
+		if (pci_enable_msi(dev->pdev) < 0)
+			DRM_DEBUG_DRIVER("can't enable MSI");
+	}
+
+	return 0;
+
+out_ggtt:
+	i915_ggtt_cleanup_hw(dev);
+
+	return ret;
+}
+
+/**
+ * i915_driver_cleanup_hw - cleanup the setup done in i915_driver_init_hw()
+ * @dev_priv: device private
+ */
+static void i915_driver_cleanup_hw(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+
+	if (dev->pdev->msi_enabled)
+		pci_disable_msi(dev->pdev);
+
+	pm_qos_remove_request(&dev_priv->pm_qos);
+	arch_phys_wc_del(ggtt->mtrr);
+	io_mapping_free(ggtt->mappable);
+	i915_ggtt_cleanup_hw(dev);
+}
+
+/**
+ * i915_driver_register - register the driver with the rest of the system
+ * @dev_priv: device private
+ *
+ * Perform any steps necessary to make the driver available via kernel
+ * internal or userspace interfaces.
+ */
+static void i915_driver_register(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	i915_gem_shrinker_init(dev_priv);
+
+	/*
+	 * Notify a valid surface after modesetting,
+	 * when running inside a VM.
+	 */
+	if (intel_vgpu_active(dev_priv))
+		I915_WRITE(vgtif_reg(display_ready), VGT_DRV_DISPLAY_READY);
+
+	/* Reveal our presence to userspace */
+	if (drm_dev_register(dev, 0) == 0) {
+		i915_debugfs_register(dev_priv);
+		i915_setup_sysfs(dev);
+	} else
+		DRM_ERROR("Failed to register driver for userspace access!\n");
+
+	if (INTEL_INFO(dev_priv)->num_pipes) {
+		/* Must be done after probing outputs */
+		intel_opregion_register(dev_priv);
+		acpi_video_register();
+	}
+
+	if (IS_GEN5(dev_priv))
+		intel_gpu_ips_init(dev_priv);
+
+	i915_audio_component_init(dev_priv);
+
+	/*
+	 * Some ports require correctly set-up hpd registers for detection to
+	 * work properly (leading to ghost connected connector status), e.g. VGA
+	 * on gm45.  Hence we can only set up the initial fbdev config after hpd
+	 * irqs are fully enabled. We do it last so that the async config
+	 * cannot run before the connectors are registered.
+	 */
+	intel_fbdev_initial_config_async(dev);
+}
+
+/**
+ * i915_driver_unregister - cleanup the registration done in i915_driver_regiser()
+ * @dev_priv: device private
+ */
+static void i915_driver_unregister(struct drm_i915_private *dev_priv)
+{
+	i915_audio_component_cleanup(dev_priv);
+
+	intel_gpu_ips_teardown();
+	acpi_video_unregister();
+	intel_opregion_unregister(dev_priv);
+
+	i915_teardown_sysfs(dev_priv->dev);
+	i915_debugfs_unregister(dev_priv);
+	drm_dev_unregister(dev_priv->dev);
+
+	i915_gem_shrinker_cleanup(dev_priv);
+}
+
+/**
+ * i915_driver_load - setup chip and create an initial config
+ * @dev: DRM device
+ * @flags: startup flags
+ *
+ * The driver load routine has to do several things:
+ *   - drive output discovery via intel_modeset_init()
+ *   - initialize the memory manager
+ *   - allocate initial config memory
+ *   - setup the DRM framebuffer with the allocated memory
+ */
+static int i915_driver_load(struct pci_dev *pdev,
+			    const struct pci_device_id *ent)
+{
+	struct drm_i915_private *dev_priv;
+	int ret;
 
-static const struct intel_device_info intel_skylake_info = {
-	BDW_FEATURES,
-	.is_skylake = 1,
-	.gen = 9,
-};
+	ret = -ENOMEM;
+	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
+	if (dev_priv)
+		ret = drm_dev_init(&dev_priv->drm, &driver, &pdev->dev);
+	if (ret) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "[" DRM_NAME ":%s] allocation failed\n", __func__);
+		kfree(dev_priv);
+		return ret;
+	}
 
-static const struct intel_device_info intel_skylake_gt3_info = {
-	BDW_FEATURES,
-	.is_skylake = 1,
-	.gen = 9,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
+	/* Must be set before calling __i915_printk */
+	dev_priv->drm.pdev = pdev;
+	dev_priv->drm.dev_private = dev_priv;
+	dev_priv->dev = &dev_priv->drm;
 
-static const struct intel_device_info intel_broxton_info = {
-	.is_preliminary = 1,
-	.is_broxton = 1,
-	.gen = 9,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.num_pipes = 3,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	.has_pooled_eu = 0,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
-	BDW_COLORS,
-};
+	ret = pci_enable_device(pdev);
+	if (ret)
+		goto out_free_priv;
 
-static const struct intel_device_info intel_kabylake_info = {
-	BDW_FEATURES,
-	.is_kabylake = 1,
-	.gen = 9,
-};
+	pci_set_drvdata(pdev, &dev_priv->drm);
 
-static const struct intel_device_info intel_kabylake_gt3_info = {
-	BDW_FEATURES,
-	.is_kabylake = 1,
-	.gen = 9,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-};
+	ret = i915_driver_init_early(dev_priv, ent);
+	if (ret < 0)
+		goto out_pci_disable;
 
-/*
- * Make sure any device matches here are from most specific to most
- * general.  For example, since the Quanta match is based on the subsystem
- * and subvendor IDs, we need it to come before the more general IVB
- * PCI ID matches, otherwise we'll use the wrong info struct above.
- */
-static const struct pci_device_id pciidlist[] = {
-	INTEL_I830_IDS(&intel_i830_info),
-	INTEL_I845G_IDS(&intel_845g_info),
-	INTEL_I85X_IDS(&intel_i85x_info),
-	INTEL_I865G_IDS(&intel_i865g_info),
-	INTEL_I915G_IDS(&intel_i915g_info),
-	INTEL_I915GM_IDS(&intel_i915gm_info),
-	INTEL_I945G_IDS(&intel_i945g_info),
-	INTEL_I945GM_IDS(&intel_i945gm_info),
-	INTEL_I965G_IDS(&intel_i965g_info),
-	INTEL_G33_IDS(&intel_g33_info),
-	INTEL_I965GM_IDS(&intel_i965gm_info),
-	INTEL_GM45_IDS(&intel_gm45_info),
-	INTEL_G45_IDS(&intel_g45_info),
-	INTEL_PINEVIEW_IDS(&intel_pineview_info),
-	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),
-	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),
-	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),
-	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),
-	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */
-	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),
-	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),
-	INTEL_HSW_D_IDS(&intel_haswell_d_info),
-	INTEL_HSW_M_IDS(&intel_haswell_m_info),
-	INTEL_VLV_M_IDS(&intel_valleyview_m_info),
-	INTEL_VLV_D_IDS(&intel_valleyview_d_info),
-	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),
-	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),
-	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),
-	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info),
-	INTEL_CHV_IDS(&intel_cherryview_info),
-	INTEL_SKL_GT1_IDS(&intel_skylake_info),
-	INTEL_SKL_GT2_IDS(&intel_skylake_info),
-	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
-	INTEL_SKL_GT4_IDS(&intel_skylake_gt3_info),
-	INTEL_BXT_IDS(&intel_broxton_info),
-	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
-	INTEL_KBL_GT2_IDS(&intel_kabylake_info),
-	INTEL_KBL_GT3_IDS(&intel_kabylake_gt3_info),
-	INTEL_KBL_GT4_IDS(&intel_kabylake_gt3_info),
-	{0, 0, 0}
-};
+	intel_runtime_pm_get(dev_priv);
 
-MODULE_DEVICE_TABLE(pci, pciidlist);
+	ret = i915_driver_init_mmio(dev_priv);
+	if (ret < 0)
+		goto out_runtime_pm_put;
 
-static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
-{
-	enum intel_pch ret = PCH_NOP;
+	ret = i915_driver_init_hw(dev_priv);
+	if (ret < 0)
+		goto out_cleanup_mmio;
 
 	/*
-	 * In a virtualized passthrough environment we can be in a
-	 * setup where the ISA bridge is not able to be passed through.
-	 * In this case, a south bridge can be emulated and we have to
-	 * make an educated guess as to which PCH is really there.
+	 * TODO: move the vblank init and parts of modeset init steps into one
+	 * of the i915_driver_init_/i915_driver_register functions according
+	 * to the role/effect of the given init step.
 	 */
-
-	if (IS_GEN5(dev)) {
-		ret = PCH_IBX;
-		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
-	} else if (IS_GEN6(dev) || IS_IVYBRIDGE(dev)) {
-		ret = PCH_CPT;
-		DRM_DEBUG_KMS("Assuming CouarPoint PCH\n");
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
-		ret = PCH_LPT;
-		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
-	} else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {
-		ret = PCH_SPT;
-		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
+	if (INTEL_INFO(dev_priv)->num_pipes) {
+		ret = drm_vblank_init(dev_priv->dev,
+				      INTEL_INFO(dev_priv)->num_pipes);
+		if (ret)
+			goto out_cleanup_hw;
 	}
 
+	ret = i915_load_modeset_init(dev_priv->dev);
+	if (ret < 0)
+		goto out_cleanup_vblank;
+
+	i915_driver_register(dev_priv);
+
+	intel_runtime_pm_enable(dev_priv);
+
+	intel_runtime_pm_put(dev_priv);
+
+	return 0;
+
+out_cleanup_vblank:
+	drm_vblank_cleanup(dev_priv->dev);
+out_cleanup_hw:
+	i915_driver_cleanup_hw(dev_priv);
+out_cleanup_mmio:
+	i915_driver_cleanup_mmio(dev_priv);
+out_runtime_pm_put:
+	intel_runtime_pm_put(dev_priv);
+	i915_driver_cleanup_early(dev_priv);
+out_pci_disable:
+	pci_disable_device(pdev);
+out_free_priv:
+	i915_load_error(dev_priv, "Device initialization failed (%d)\n", ret);
+	drm_dev_unref(&dev_priv->drm);
 	return ret;
 }
 
-void intel_detect_pch(struct drm_device *dev)
+static int i915_driver_unload(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct pci_dev *pch = NULL;
+	int ret;
 
-	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
-	 * (which really amounts to a PCH but no South Display).
-	 */
-	if (INTEL_INFO(dev)->num_pipes == 0) {
-		dev_priv->pch_type = PCH_NOP;
-		return;
+	intel_fbdev_fini(dev);
+
+	ret = i915_gem_suspend(dev);
+	if (ret) {
+		DRM_ERROR("failed to idle hardware: %d\n", ret);
+		return ret;
 	}
 
+	intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
+
+	i915_driver_unregister(dev_priv);
+
+	drm_vblank_cleanup(dev);
+
+	intel_modeset_cleanup(dev);
+
 	/*
-	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
-	 * make graphics device passthrough work easy for VMM, that only
-	 * need to expose ISA bridge to let driver know the real hardware
-	 * underneath. This is a requirement from virtualization team.
-	 *
-	 * In some virtualized environments (e.g. XEN), there is irrelevant
-	 * ISA bridge in the system. To work reliably, we should scan trhough
-	 * all the ISA bridge devices and check for the first match, instead
-	 * of only checking the first one.
+	 * free the memory space allocated for the child device
+	 * config parsed from VBT
 	 */
-	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
-		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
-			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
-			dev_priv->pch_id = id;
+	if (dev_priv->vbt.child_dev && dev_priv->vbt.child_dev_num) {
+		kfree(dev_priv->vbt.child_dev);
+		dev_priv->vbt.child_dev = NULL;
+		dev_priv->vbt.child_dev_num = 0;
+	}
+	kfree(dev_priv->vbt.sdvo_lvds_vbt_mode);
+	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;
+	kfree(dev_priv->vbt.lfp_lvds_vbt_mode);
+	dev_priv->vbt.lfp_lvds_vbt_mode = NULL;
 
-			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_IBX;
-				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
-				WARN_ON(!IS_GEN5(dev));
-			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_CPT;
-				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
-			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
-				/* PantherPoint is CPT compatible */
-				dev_priv->pch_type = PCH_CPT;
-				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
-				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
-			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
-				WARN_ON(IS_HSW_ULT(dev) || IS_BDW_ULT(dev));
-			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
-				WARN_ON(!IS_HSW_ULT(dev) && !IS_BDW_ULT(dev));
-			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_SPT;
-				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev) &&
-					!IS_KABYLAKE(dev));
-			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_SPT;
-				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev) &&
-					!IS_KABYLAKE(dev));
-			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
-				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
-				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
-				    pch->subsystem_vendor ==
-					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
-				    pch->subsystem_device ==
-					    PCI_SUBDEVICE_ID_QEMU)) {
-				dev_priv->pch_type = intel_virt_detect_pch(dev);
-			} else
-				continue;
+	vga_switcheroo_unregister_client(dev->pdev);
+	vga_client_register(dev->pdev, NULL, NULL, NULL);
 
-			break;
-		}
-	}
-	if (!pch)
-		DRM_DEBUG_KMS("No PCH found.\n");
+	intel_csr_ucode_fini(dev_priv);
 
-	pci_dev_put(pch);
+	/* Free error state after interrupts are fully disabled. */
+	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
+	i915_destroy_error_state(dev);
+
+	/* Flush any outstanding unpin_work. */
+	flush_workqueue(dev_priv->wq);
+
+	intel_guc_fini(dev);
+	i915_gem_fini(dev);
+	intel_fbc_cleanup_cfb(dev_priv);
+
+	intel_power_domains_fini(dev_priv);
+
+	i915_driver_cleanup_hw(dev_priv);
+	i915_driver_cleanup_mmio(dev_priv);
+
+	intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
+
+	i915_driver_cleanup_early(dev_priv);
+
+	return 0;
 }
 
-bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
+static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
 {
-	if (INTEL_GEN(dev_priv) < 6)
-		return false;
+	int ret;
 
-	if (i915.semaphores >= 0)
-		return i915.semaphores;
+	ret = i915_gem_open(dev, file);
+	if (ret)
+		return ret;
 
-	/* TODO: make semaphores and Execlists play nicely together */
-	if (i915.enable_execlists)
-		return false;
+	return 0;
+}
 
-#ifdef CONFIG_INTEL_IOMMU
-	/* Enable semaphores on SNB when IO remapping is off */
-	if (IS_GEN6(dev_priv) && intel_iommu_gfx_mapped)
-		return false;
-#endif
+/**
+ * i915_driver_lastclose - clean up after all DRM clients have exited
+ * @dev: DRM device
+ *
+ * Take care of cleaning up after all DRM clients have exited.  In the
+ * mode setting case, we want to restore the kernel's initial mode (just
+ * in case the last client left us in a bad state).
+ *
+ * Additionally, in the non-mode setting case, we'll tear down the GTT
+ * and DMA structures, since the kernel won't be using them, and clea
+ * up any GEM state.
+ */
+static void i915_driver_lastclose(struct drm_device *dev)
+{
+	intel_fbdev_restore_mode(dev);
+	vga_switcheroo_process_delayed_switch();
+}
 
-	return true;
+static void i915_driver_preclose(struct drm_device *dev, struct drm_file *file)
+{
+	mutex_lock(&dev->struct_mutex);
+	i915_gem_context_close(dev, file);
+	i915_gem_release(dev, file);
+	mutex_unlock(&dev->struct_mutex);
+}
+
+static void i915_driver_postclose(struct drm_device *dev, struct drm_file *file)
+{
+	struct drm_i915_file_private *file_priv = file->driver_priv;
+
+	kfree(file_priv);
 }
 
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
@@ -1034,7 +2638,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (vga_switcheroo_client_probe_defer(pdev))
 		return -EPROBE_DEFER;
 
-	return i915_driver_load(pdev, ent, &driver);
+	return i915_driver_load(pdev, ent);
 }
 
 static void
@@ -1742,6 +3346,68 @@ static const struct file_operations i915_driver_fops = {
 	.llseek = noop_llseek,
 };
 
+static int
+i915_gem_reject_pin_ioctl(struct drm_device *dev, void *data,
+			  struct drm_file *file)
+{
+	return -ENODEV;
+}
+
+static const struct drm_ioctl_desc i915_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(I915_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_FLUSH, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_FLIP, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_BATCHBUFFER, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_IRQ_EMIT, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_IRQ_WAIT, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_GETPARAM, i915_getparam, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_SETPARAM, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_ALLOC, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_FREE, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_INIT_HEAP, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_CMDBUFFER, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_DESTROY_HEAP,  drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_SET_VBLANK_PIPE,  drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GET_VBLANK_PIPE,  drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_VBLANK_SWAP, drm_noop, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_HWS_ADDR, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_INIT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER, i915_gem_execbuffer, DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(I915_GEM_EXECBUFFER2, i915_gem_execbuffer2, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_PIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_UNPIN, i915_gem_reject_pin_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_BUSY, i915_gem_busy_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_SET_CACHING, i915_gem_set_caching_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_GET_CACHING, i915_gem_get_caching_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_THROTTLE, i915_gem_throttle_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_ENTERVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_LEAVEVT, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CREATE, i915_gem_create_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_PREAD, i915_gem_pread_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_PWRITE, i915_gem_pwrite_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP, i915_gem_mmap_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_MMAP_GTT, i915_gem_mmap_gtt_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_SET_DOMAIN, i915_gem_set_domain_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_SW_FINISH, i915_gem_sw_finish_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_SET_TILING, i915_gem_set_tiling, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_GET_TILING, i915_gem_get_tiling, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_GET_APERTURE, i915_gem_get_aperture_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GET_PIPE_FROM_CRTC_ID, intel_get_pipe_from_crtc_id, 0),
+	DRM_IOCTL_DEF_DRV(I915_GEM_MADVISE, i915_gem_madvise_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_OVERLAY_PUT_IMAGE, intel_overlay_put_image_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_OVERLAY_ATTRS, intel_overlay_attrs_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_SET_SPRITE_COLORKEY, intel_sprite_set_colorkey, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GET_SPRITE_COLORKEY, drm_noop, DRM_MASTER|DRM_CONTROL_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_WAIT, i915_gem_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_CREATE, i915_gem_context_create_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_DESTROY, i915_gem_context_destroy_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_REG_READ, i915_reg_read_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GET_RESET_STATS, i915_gem_context_reset_stats_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_USERPTR, i915_gem_userptr_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),
+};
+
 static struct drm_driver driver = {
 	/* Don't use MTRRs here; the Xserver or userspace app should
 	 * deal with them for Intel hardware.
@@ -1767,6 +3433,7 @@ static struct drm_driver driver = {
 	.dumb_map_offset = i915_gem_mmap_gtt,
 	.dumb_destroy = drm_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
+	.num_ioctls = ARRAY_SIZE(i915_ioctls),
 	.fops = &i915_driver_fops,
 	.name = DRIVER_NAME,
 	.desc = DRIVER_DESC,
@@ -1786,8 +3453,6 @@ static struct pci_driver i915_pci_driver = {
 
 static int __init i915_init(void)
 {
-	driver.num_ioctls = i915_max_ioctl;
-
 	/*
 	 * Enable KMS by default, unless explicitly overriden by
 	 * either the i915.modeset prarameter or by the

commit 3e783bac8ade7dd66f97cb748582035356a210ba
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:19 2016 +0100

    drm/i915: Demidlayer driver unloading
    
    To complete the transition to manual control of load/unload, we need to
    take over unloading from i915_pci_remove(). This allows us to correctly
    order our unregister vs shutdown phases, which currently are inverted
    due to the midlayer.
    
    However, the unload sequence is still invalid as we shutdown the driver
    with the last reference. Ideally, all we want to do is remove the
    userspace access on device removal, deferring the cleanup to the
    drm_dev_release() - breaking the reference cycles is then left as an
    exercise for the reader.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-7-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1a335e1a8b62..9ddae6add9e0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1042,7 +1042,8 @@ i915_pci_remove(struct pci_dev *pdev)
 {
 	struct drm_device *dev = pci_get_drvdata(pdev);
 
-	drm_put_dev(dev);
+	i915_driver_unload(dev);
+	drm_dev_unref(dev);
 }
 
 static int i915_pm_suspend(struct device *dev)
@@ -1748,7 +1749,6 @@ static struct drm_driver driver = {
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER | DRIVER_MODESET,
-	.unload = i915_driver_unload,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,

commit 8f460e2c78f211f71c274001facb36b03af2ebc6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:18 2016 +0100

    drm/i915: Demidlayer driver loading
    
    Take control over allocating, loading and registering the driver from the
    DRM midlayer by performing it manually from i915_pci_probe. This allows
    us to carefully control the order of when we setup the hardware vs when
    it becomes visible to third parties (including userspace). The current
    ordering makes the driver visible to userspace first (in order to
    coordinate with removed DRI1 userspace), but that ordering incurs risk.
    The risk increases as we strive for more asynchronous loading.
    
    One side effect of controlling the allocation is that we can allocate
    both the drm_device + drm_i915_private in one block, the next step
    towards subclassing.
    
    Unload is still left as before, a mix of midlayer and driver.
    
    v2: After drm_dev_init(), we should call drm_dev_unref() so that we call
    drm_dev_release() and free everything from drm_dev_init().
    v3: Fixup missed error code for failing to allocate dev_priv
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-6-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ea09bd83a5a..1a335e1a8b62 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1034,7 +1034,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (vga_switcheroo_client_probe_defer(pdev))
 		return -EPROBE_DEFER;
 
-	return drm_get_pci_dev(pdev, ent, &driver);
+	return i915_driver_load(pdev, ent, &driver);
 }
 
 static void
@@ -1748,7 +1748,6 @@ static struct drm_driver driver = {
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER | DRIVER_MODESET,
-	.load = i915_driver_load,
 	.unload = i915_driver_unload,
 	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,

commit 1dac891c1c95a8528f3558b481fbb9a45d653619
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 14:00:17 2016 +0100

    drm/i915: Register debugfs interface last
    
    Currently debugfs files are created before the driver is even loads.
    This gives the opportunity for userspace to open that interface and poke
    around before the backing data structures are initialised - with the
    possibility of oopsing or worse.
    
    Move the creation of the debugfs files to our registration phase, where
    we announce our presence to the world when we are ready, i.e the
    sequence changes from
    
            drm_dev_register()
             -> drm_minor_register()
              -> drm_debugfs_init()
               -> i915_debugfs_init()
             -> i915_driver_load()
    
    to
    
            drm_dev_register()
             -> drm_minor_register()
              -> drm_debugfs_init()
             -> i915_driver_load()
              -> i915_debugfs_register()
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466773227-7994-5-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3eb47fbcea73..3ea09bd83a5a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1756,10 +1756,6 @@ static struct drm_driver driver = {
 	.postclose = i915_driver_postclose,
 	.set_busid = drm_pci_set_busid,
 
-#if defined(CONFIG_DEBUG_FS)
-	.debugfs_init = i915_debugfs_init,
-	.debugfs_cleanup = i915_debugfs_cleanup,
-#endif
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
 

commit e015dd69b2cf8d639308ad1cb4cd204a24e918fe
Author: arun.siluvery@linux.intel.com <arun.siluvery@linux.intel.com>
Date:   Fri Jun 3 11:14:51 2016 +0100

    drm/i915/bxt: Add WaEnablePooledEuFor2x6
    
    Pooled EU is enabled by default for BXT but for fused down 2x6 parts it is
    advised to turn it off. But there is another HW issue in these parts (fused
    down 2x6 parts) before C0 that requires Pooled EU to be enabled as a
    workaround. In this case the pool configuration changes depending upon
    which subslice is disabled. This doesn't affect if the device has all 3
    subslices enabled.
    
    Userspace need to know min no. of eus in a pool as it varies based on which
    subslice is disabled, this is not yet exported because userspace support is
    not available yet. Once the support is available this needs to be exported
    using getparam ioctls.
    
    v2: s/subslice_total/subslice_per_slice as it is a more logical field (Mika)
    
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Winiarski, Michal <michal.winiarski@intel.com>
    Cc: Zou, Nanhai <nanhai.zou@intel.com>
    Cc: Yang, Rong R <rong.r.yang@intel.com>
    Cc: Tim Gore <tim.gore@intel.com>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 60a6416ac26e..3eb47fbcea73 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -355,7 +355,7 @@ static const struct intel_device_info intel_broxton_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.has_fbc = 1,
-	.has_pooled_eu = 1,
+	.has_pooled_eu = 0,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
 	BDW_COLORS,

commit 33e141ed1cf74cd8ef26e5f175e43e378157a649
Author: arun.siluvery@linux.intel.com <arun.siluvery@linux.intel.com>
Date:   Fri Jun 3 06:34:33 2016 +0100

    drm/i915:bxt: Enable Pooled EU support
    
    This mode allows to assign EUs to pools which can process work collectively.
    The command to enable this mode should be issued as part of context initialization.
    
    The pooled mode is global, once enabled it has to stay the same across all
    contexts until HW reset hence this is sent in auxiliary golden context batch.
    Thanks to Mika for the preliminary review and comments.
    
    v2: explain why this is enabled in golden context, use feature flag while
    enabling the support (Chris)
    
    v3: Include only kernel support as userspace support is not available yet.
    
    User space clients need to know when the pooled EU feature is present
    and enabled on the hardware so that they can adapt work submissions.
    Create a new device info flag for this purpose.
    
    Set has_pooled_eu to true in the Broxton static device info - Broxton
    supports the feature in hardware and the driver will enable it by
    default.
    
    We need to add getparam ioctls to enable userspace to query availability of
    this feature and to retrieve min. no of eus in a pool but we will expose
    them once userspace support is available. Opensource users for this feature
    are mesa, libva and beignet.
    
    Beignet team is currently working on adding userspace support.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v2)
    Cc: Winiarski, Michal <michal.winiarski@intel.com>
    Cc: Zou, Nanhai <nanhai.zou@intel.com>
    Cc: Yang, Rong R <rong.r.yang@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Armin Reese <armin.c.reese@intel.com>
    Cc: Tim Gore <tim.gore@intel.com>
    Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7985370dff2a..60a6416ac26e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -355,6 +355,7 @@ static const struct intel_device_info intel_broxton_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.has_fbc = 1,
+	.has_pooled_eu = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
 	BDW_COLORS,

commit 94bb489c89c4ca7dc36bfbe50e77f26d8458e347
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Mon Jun 13 14:38:56 2016 +0200

    drm/i915: use #defines for qemu subsystem ids
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465821536-21312-1-git-send-email-kraxel@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 872c60608dbd..7985370dff2a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -517,8 +517,10 @@ void intel_detect_pch(struct drm_device *dev)
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
 				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
-				    pch->subsystem_vendor == 0x1af4 &&
-				    pch->subsystem_device == 0x1100)) {
+				    pch->subsystem_vendor ==
+					    PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&
+				    pch->subsystem_device ==
+					    PCI_SUBDEVICE_ID_QEMU)) {
 				dev_priv->pch_type = intel_virt_detect_pch(dev);
 			} else
 				continue;

commit 5599617ec0719dba3b1f85a4abca2a6c93368ae3
Merge: 8d19d7d9dbc2 66fd7a66e8b9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 09:54:12 2016 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next-queued
    
    Git got absolutely destroyed with all our cherry-picking from
    drm-intel-next-queued to various branches. It ended up inserting
    intel_crtc_page_flip 2x even in intel_display.c.
    
    Backmerge to get back to sanity.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 66fd7a66e8b9e11e49f46ea77910f935c4dee5c3
Merge: 65439b68bb10 e42aeef1237b
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 2 07:58:36 2016 +1000

    Merge branch 'drm-intel-next' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2016-05-22:
    - cmd-parser support for direct reg->reg loads (Ken Graunke)
    - better handle DP++ smart dongles (Ville)
    - bxt guc fw loading support (Nick Hoathe)
    - remove a bunch of struct typedefs from dpll code (Ander)
    - tons of small work all over to avoid casting between drm_device and the i915
      dev struct (Tvrtko&Chris)
    - untangle request retiring from other operations, also fixes reset stat corner
      cases (Chris)
    - skl atomic watermark support from Matt Roper, yay!
    - various wm handling bugfixes from Ville
    - big pile of cdclck rework for bxt/skl (Ville)
    - CABC (Content Adaptive Brigthness Control) for dsi panels (Jani&Deepak M)
    - nonblocking atomic commits for plane-only updates (Maarten Lankhorst)
    - bunch of PSR fixes&improvements
    - untangle our map/pin/sg_iter code a bit (Dave Gordon)
    drm-intel-next-2016-05-08:
    - refactor stolen quirks to share code between early quirks and i915 (Joonas)
    - refactor gem BO/vma funcstion (Tvrtko&Dave)
    - backlight over DPCD support (Yetunde Abedisi)
    - more dsi panel sequence support (Jani)
    - lots of refactoring around handling iomaps, vma, ring access and related
      topics culmulating in removing the duplicated request tracking in the execlist
      code (Chris & Tvrtko) includes a small patch for core iomapping code
    - hw state readout for bxt dsi (Ramalingam C)
    - cdclk cleanups (Ville)
    - dedupe chv pll code a bit (Ander)
    - enable semaphores on gen8+ for legacy submission, to be able to have a direct
      comparison against execlist on the same platform (Chris) Not meant to be used
      for anything else but performance tuning
    - lvds border bit hw state checker fix (Jani)
    - rpm vs. shrinker/oom-notifier fixes (Praveen Paneri)
    - l3 tuning (Imre)
    - revert mst dp audio, it's totally non-functional and crash-y (Lyude)
    - first official dmc for kbl (Rodrigo)
    - and tons of small things all over as usual
    
    * 'drm-intel-next' of git://anongit.freedesktop.org/drm-intel: (194 commits)
      drm/i915: Revert async unpin and nonblocking atomic commit
      drm/i915: Update DRIVER_DATE to 20160522
      drm/i915: Inline sg_next() for the optimised SGL iterator
      drm/i915: Introduce & use new lightweight SGL iterators
      drm/i915: optimise i915_gem_object_map() for small objects
      drm/i915: refactor i915_gem_object_pin_map()
      drm/i915/psr: Implement PSR2 w/a for gen9
      drm/i915/psr: Use ->get_aux_send_ctl functions
      drm/i915/psr: Order DP aux transactions correctly
      drm/i915/psr: Make idle_frames sensible again
      drm/i915/psr: Try to program link training times correctly
      drm/i915/userptr: Convert to drm_i915_private
      drm/i915: Allow nonblocking update of pageflips.
      drm/i915: Check for unpin correctness.
      Reapply "drm/i915: Avoid stalling on pending flips for legacy cursor updates"
      drm/i915: Make unpin async.
      drm/i915: Prepare connectors for nonblocking checks.
      drm/i915: Pass atomic states to fbc update functions.
      drm/i915: Remove reset_counter from intel_crtc.
      drm/i915: Remove queue_flip pointer.
      ...

commit 65439b68bb10afd877af05463bbff5d25200fd06
Merge: 1a695a905c18 b82caafcf230
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 2 07:50:23 2016 +1000

    Merge tag 'topic/drm-misc-2016-06-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Frist -misc pull for 4.8, with pretty much just random all over plus a few
    more lockless gem BO patches acked/reviewed by driver maintainers.
    
    I'm starting a bit earlier this time around because there's a few invasive
    patch series to land (nonblocking atomic prep work, fence prep work,
    rst/sphinx kerneldoc finally happening) and I need a baseline with all the
    branches merged.
    
    * tag 'topic/drm-misc-2016-06-01' of git://anongit.freedesktop.org/drm-intel: (21 commits)
      drm/vc4: Use lockless gem BO free callback
      drm/vc4: Use drm_gem_object_unreference_unlocked
      drm: Initialize a linear gamma table by default
      drm/vgem: Use lockless gem BO free callback
      drm/qxl: Don't set a gamma table size
      drm/msm: Nuke dummy gamma_set/get functions
      drm/cirrus: Drop redundnant gamma size check
      drm/fb-helper: Remove dead code in setcolreg
      drm/mediatek: Use lockless gem BO free callback
      drm/hisilicon: Use lockless gem BO free callback
      drm/hlcd: Use lockless gem BO free callback
      vga_switcheroo: Support deferred probing of audio clients
      vga_switcheroo: Add helper for deferred probing
      virtio-gpu: fix output lookup
      drm/doc: Unify KMS Locking docs
      drm/atomic-helper: Do not call ->mode_fixup for CRTC which will be disabled
      Fix annoyingly awkward typo in drm_edid_load.c
      drm/doc: Drop vblank_disable_allow wording
      drm: use seqlock for vblank time/count
      drm/mm: avoid possible null pointer dereference
      ...

commit b00e5334ab1bb2e41187fb964a1a2304871fb4ff
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue May 31 11:13:27 2016 +0200

    vga_switcheroo: Add helper for deferred probing
    
    So far we've got one condition when DRM drivers need to defer probing
    on a dual GPU system and it's coded separately into each of the relevant
    drivers. As suggested by Daniel Vetter, deduplicate that code in the
    drivers and move it to a new vga_switcheroo helper. This yields better
    encapsulation of concepts and lets us add further checks in a central
    place. (The existing check pertains to pre-retina MacBook Pros and an
    additional check is expected to be needed for retinas.)
    
    One might be tempted to check deferred probing conditions in
    vga_switcheroo_register_client(), but this is usually called fairly late
    during driver load. The GPU is fully brought up and ready for switching
    at that point. On boot the ->probe hook is potentially called dozens of
    times until it finally succeeds, and each time we'd repeat bringup and
    teardown of the GPU, lengthening boot time considerably and cluttering
    logfiles. A separate helper is therefore needed which can be called
    right at the beginning of the ->probe hook.
    
    Note that amdgpu currently does not call this helper as the AMD GPUs
    built into MacBook Pros are only supported by radeon so far.
    
    v2: This helper could eventually be used by audio clients as well,
        so rephrase kerneldoc to refer to "client" instead of "GPU"
        and move the single existing check in an if block specific
        to PCI_CLASS_DISPLAY_VGA devices. Move documentation on
        that check from kerneldoc to a comment. (Daniel Vetter)
    
    v3: Mandate in kerneldoc that registration of client shall only
        happen after calling this helper. (Daniel Vetter)
    
    v4: Rebase on 412c8f7de011 ("drm/radeon: Return -EPROBE_DEFER when
        amdkfd not loaded")
    
    v5: Some Optimus GPUs use PCI_CLASS_DISPLAY_3D, make sure those are
        matched as well. (Emil Velikov)
    
    v6: The if-condition referring to PCI_BASE_CLASS_DISPLAY may be
        considered a functional change. Move to a separate commit to
        keep this a pure refactoring change. (Emil Velikov, Jani Nikula)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/575885fd440c2b13c3f19ddf44360cfbbff35f50.1464685538.git.lukas@wunner.de

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d37c0a671eed..20d58987381d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -35,11 +35,9 @@
 #include "i915_trace.h"
 #include "intel_drv.h"
 
-#include <linux/apple-gmux.h>
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
-#include <linux/vgaarb.h>
 #include <linux/vga_switcheroo.h>
 #include <drm/drm_crtc_helper.h>
 
@@ -1025,13 +1023,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
-	/*
-	 * apple-gmux is needed on dual GPU MacBook Pro
-	 * to probe the panel if we're the inactive GPU.
-	 */
-	if (IS_ENABLED(CONFIG_VGA_ARB) && IS_ENABLED(CONFIG_VGA_SWITCHEROO) &&
-	    apple_gmux_present() && pdev != vga_default_device() &&
-	    !vga_switcheroo_handler_flags())
+	if (vga_switcheroo_client_probe_defer(pdev))
 		return -EPROBE_DEFER;
 
 	return drm_get_pci_dev(pdev, ent, &driver);

commit 7fa1d27b638db86516d7b3d8dc1a3576c72ee423
Merge: 79b3c7164c18 157d2c7fad08
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 27 16:08:38 2016 +1000

    Merge tag 'drm-intel-next-fixes-2016-05-25' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    I see the main drm pull got merged, here's the first batch of fixes for
    4.7 already. Fixes all around, a large portion cc: stable stuff.
    
    [airlied: the DP++ stuff is a regression fix].
    * tag 'drm-intel-next-fixes-2016-05-25' of git://anongit.freedesktop.org/drm-intel:
      drm/i915: Stop automatically retiring requests after a GPU hang
      drm/i915: Unify intel_ring_begin()
      drm/i915: Ignore stale wm register values on resume on ilk-bdw (v2)
      drm/i915/psr: Try to program link training times correctly
      drm/i915/bxt: Adjusting the error in horizontal timings retrieval
      drm/i915: Don't leave old junk in ilk active watermarks on readout
      drm/i915: s/DPPL/DPLL/ for SKL DPLLs
      drm/i915: Fix gen8 semaphores id for legacy mode
      drm/i915: Set crtc_state->lane_count for HDMI
      drm/i915/BXT: Retrieving the horizontal timing for DSI
      drm/i915: Protect gen7 irq_seqno_barrier with uncore lock
      drm/i915: Re-enable GGTT earlier during resume on pre-gen6 platforms
      drm/i915: Determine DP++ type 1 DVI adaptor presence based on VBT
      drm/i915: Enable/disable TMDS output buffers in DP++ adaptor as needed
      drm/i915: Respect DP++ adaptor TMDS clock limit
      drm: Add helper for DP++ adaptors

commit 03d92e4779b82e03f3fbf6631156eb0727fc75d4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon May 23 15:08:10 2016 +0100

    drm/i915/opregion: Rename init/fini functions to register/unregister
    
    Current intel_opregion_init is called during the driver registration
    phase and intel_opregion_fini from the unregistration phase. Rename the
    functions so that this is clear from their names. The phases tell us
    what we expect the existing hw state to be, e.g. whether interrupts are
    still enabled etc.
    
    It should be noted that the opregion init/fini routines are asymmetric
    and this is carried across into their new names. Indeed, their new names
    make it even clearer that perhaps all is not well in the opregion
    suspend/resume sequence (as well in the module unload).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464012490-30961-2-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Jani Nikula <jani.nikula@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7627bbec8e37..943d7b222fd4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -631,7 +631,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
 
 	intel_uncore_forcewake_reset(dev_priv, false);
-	intel_opregion_fini(dev_priv);
+	intel_opregion_unregister(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
 
@@ -794,7 +794,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	/* Config may have changed between suspend and resume */
 	drm_helper_hpd_irq_event(dev);
 
-	intel_opregion_init(dev_priv);
+	intel_opregion_register(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);
 

commit 6f9f4b7a2cf7c5047f4d31bb00b0a48fb0a674e3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon May 23 15:08:09 2016 +0100

    drm/i915/opregion: Convert to using native drm_i915_private
    
    Prefer passing struct drm_i915_private to internal interfaces as this
    saves us having to dance between drm_device and our native struct. The
    savings hare are small (only 70 bytes of unrequired dancing), but
    progressive!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464012490-30961-1-git-send-email-chris@chris-wilson.co.uk
    Reviewed-by: Jani Nikula <jani.nikula@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dba03c026151..7627bbec8e37 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -628,10 +628,10 @@ static int i915_drm_suspend(struct drm_device *dev)
 	i915_save_state(dev);
 
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
-	intel_opregion_notify_adapter(dev, opregion_target_state);
+	intel_opregion_notify_adapter(dev_priv, opregion_target_state);
 
 	intel_uncore_forcewake_reset(dev_priv, false);
-	intel_opregion_fini(dev);
+	intel_opregion_fini(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
 
@@ -749,7 +749,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	mutex_unlock(&dev->struct_mutex);
 
 	i915_restore_state(dev);
-	intel_opregion_setup(dev);
+	intel_opregion_setup(dev_priv);
 
 	intel_init_pch_refclk(dev);
 	drm_mode_config_reset(dev);
@@ -794,7 +794,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	/* Config may have changed between suspend and resume */
 	drm_helper_hpd_irq_event(dev);
 
-	intel_opregion_init(dev);
+	intel_opregion_init(dev_priv);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);
 
@@ -802,7 +802,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	dev_priv->modeset_restore = MODESET_DONE;
 	mutex_unlock(&dev_priv->modeset_restore_lock);
 
-	intel_opregion_notify_adapter(dev, PCI_D0);
+	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 
 	drm_kms_helper_poll_enable(dev);
 
@@ -1596,14 +1596,14 @@ static int intel_runtime_suspend(struct device *device)
 	 * FIXME: We really should find a document that references the arguments
 	 * used below!
 	 */
-	if (IS_BROADWELL(dev)) {
+	if (IS_BROADWELL(dev_priv)) {
 		/*
 		 * On Broadwell, if we use PCI_D1 the PCH DDI ports will stop
 		 * being detected, and the call we do at intel_runtime_resume()
 		 * won't be able to restore them. Since PCI_D3hot matches the
 		 * actual specification and appears to be working, use it.
 		 */
-		intel_opregion_notify_adapter(dev, PCI_D3hot);
+		intel_opregion_notify_adapter(dev_priv, PCI_D3hot);
 	} else {
 		/*
 		 * current versions of firmware which depend on this opregion
@@ -1612,7 +1612,7 @@ static int intel_runtime_suspend(struct device *device)
 		 * to distinguish it from notifications that might be sent via
 		 * the suspend path.
 		 */
-		intel_opregion_notify_adapter(dev, PCI_D1);
+		intel_opregion_notify_adapter(dev_priv, PCI_D1);
 	}
 
 	assert_forcewakes_inactive(dev_priv);
@@ -1636,7 +1636,7 @@ static int intel_runtime_resume(struct device *device)
 	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
 	disable_rpm_wakeref_asserts(dev_priv);
 
-	intel_opregion_notify_adapter(dev, PCI_D0);
+	intel_opregion_notify_adapter(dev_priv, PCI_D0);
 	dev_priv->pm.suspended = false;
 	if (intel_uncore_unclaimed_mmio(dev_priv))
 		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");

commit 5fbd0418eef283269f2cc1b90b63d88f20c887bf
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 6 21:35:55 2016 +0300

    drm/i915: Re-enable GGTT earlier during resume on pre-gen6 platforms
    
    Move the intel_enable_gtt() call to happen before we touch the GTT
    during resume. Right now it's done way too late. Before
    commit ebb7c78d358b ("agp/intel-gtt: Only register fake agp driver for gen1")
    it was actually done earlier on account of also getting called from
    the resume hook of the fake agp driver. With the fake agp driver
    no longer getting registered we must move the call up.
    
    The symptoms I've seen on my 830 machine include lowmem corruption,
    other kinds of memory corruption, and straight up hung machine during
    or just after resume. Not really sure what causes the memory corruption,
    but so far I've not seen any with this fix.
    
    I think we shouldn't really need to call this during init, but we have
    been doing that so I've decided to keep the call. However moving that
    call earlier could be prudent as well. Doing it right after the
    intel-gtt probe seems appropriate.
    
    Also tested this on 946gz,elk,ilk and all seemed quite happy with
    this change.
    
    v2: Reorder init_hw vs. enable_hw functions (Chris)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: drm-intel-fixes@lists.freedesktop.org
    Fixes: ebb7c78d358b ("agp/intel-gtt: Only register fake agp driver for gen1")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462559755-353-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit ac840ae53573d9f435c88c131f6707a79aecb466)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7a0e4d6c71e2..dd36760f7da6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -734,9 +734,14 @@ int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
+	ret = i915_ggtt_enable_hw(dev);
+	if (ret)
+		DRM_ERROR("failed to re-enable GGTT\n");
+
 	intel_csr_ucode_resume(dev_priv);
 
 	mutex_lock(&dev->struct_mutex);

commit 9a652cc01e589e10e2aa341074ea240c9838102b
Merge: e8fcdf1e65c7 99ee87295017
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 17 12:15:49 2016 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next-queued
    
    Backmerge request by Jani to get at
    
    commit 249c4f538b1aae55d41699f8bafc6cb762a7f48f
    Author: Deepak M <m.deepak@intel.com>
    Date:   Wed Mar 30 17:03:39 2016 +0300
    
        drm: Add new DCS commands in the enum list
    
    Some simple conflicts in intel_dp.c.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 461fb99c15a705274cf4a8042362f254ceb1529d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat May 14 07:26:33 2016 +0100

    drm/i915: Update domain tracking for GEM objects on hibernation
    
    When creating the hibernation image, the CPU will read the pages of all
    objects and thus conflict with our domain tracking. We need to update
    our domain tracking to accurately reflect the state on restoration.
    
    v2: Perform the domain tracking inside freeze, before the image is
    written, rather than upon restoration.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: David Weinehall <david.weinehall@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1463207195-22076-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 816cacddbe88..7210642e29ad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1123,7 +1123,17 @@ static int i915_pm_freeze(struct device *dev)
 
 static int i915_pm_freeze_late(struct device *dev)
 {
-	return i915_pm_suspend_late(dev);
+	int ret;
+
+	ret = i915_pm_suspend_late(dev);
+	if (ret)
+		return ret;
+
+	ret = i915_gem_freeze_late(dev_to_i915(dev));
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 /* thaw: called after creating the hibernation image, but before turning off. */

commit 1f19ac2a0b1ad8e2a9c382efa7416b014c988949
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat May 14 07:26:32 2016 +0100

    drm/i915: Add distinct stubs for PM hibernation phases
    
    Currently for handling the extra hibernation phases we just call the
    equivalent suspend/resume phases. In the next couple of patches, I wish
    to specialise the hibernation phases to reduce the amount of work
    required for handling GEM objects.
    
    v2: There are more! Don't forget the freeze phases.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: David Weinehall <david.weinehall@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1463207195-22076-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 198f79369003..816cacddbe88 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1115,6 +1115,39 @@ static int i915_pm_resume(struct device *dev)
 	return i915_drm_resume(drm_dev);
 }
 
+/* freeze: before creating the hibernation_image */
+static int i915_pm_freeze(struct device *dev)
+{
+	return i915_pm_suspend(dev);
+}
+
+static int i915_pm_freeze_late(struct device *dev)
+{
+	return i915_pm_suspend_late(dev);
+}
+
+/* thaw: called after creating the hibernation image, but before turning off. */
+static int i915_pm_thaw_early(struct device *dev)
+{
+	return i915_pm_resume_early(dev);
+}
+
+static int i915_pm_thaw(struct device *dev)
+{
+	return i915_pm_resume(dev);
+}
+
+/* restore: called after loading the hibernation image. */
+static int i915_pm_restore_early(struct device *dev)
+{
+	return i915_pm_resume_early(dev);
+}
+
+static int i915_pm_restore(struct device *dev)
+{
+	return i915_pm_resume(dev);
+}
+
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1669,14 +1702,14 @@ static const struct dev_pm_ops i915_pm_ops = {
 	 * @restore, @restore_early : called after rebooting and restoring the
 	 *                            hibernation image [PMSG_RESTORE]
 	 */
-	.freeze = i915_pm_suspend,
-	.freeze_late = i915_pm_suspend_late,
-	.thaw_early = i915_pm_resume_early,
-	.thaw = i915_pm_resume,
+	.freeze = i915_pm_freeze,
+	.freeze_late = i915_pm_freeze_late,
+	.thaw_early = i915_pm_thaw_early,
+	.thaw = i915_pm_thaw,
 	.poweroff = i915_pm_suspend,
 	.poweroff_late = i915_pm_poweroff_late,
-	.restore_early = i915_pm_resume_early,
-	.restore = i915_pm_resume,
+	.restore_early = i915_pm_restore_early,
+	.restore = i915_pm_restore,
 
 	/* S0ix (via runtime suspend) event handlers */
 	.runtime_suspend = intel_runtime_suspend,

commit ab0d24ac38e34c03a6ced9b9c458a07ab3d431ea
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue May 10 10:57:05 2016 +0100

    drm/i915: Promote IS_BROADWELL to a simple macro
    
    If we allow it a dedicated flag in dev_priv we enable the
    compiler to nicely optimize conditions like IS_HASSWELL ||
    IS_BROADWELL.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a676c6dbc0e7..198f79369003 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -300,22 +300,26 @@ static const struct intel_device_info intel_haswell_m_info = {
 static const struct intel_device_info intel_broadwell_d_info = {
 	BDW_FEATURES,
 	.gen = 8,
+	.is_broadwell = 1,
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
 	BDW_FEATURES,
 	.gen = 8, .is_mobile = 1,
+	.is_broadwell = 1,
 };
 
 static const struct intel_device_info intel_broadwell_gt3d_info = {
 	BDW_FEATURES,
 	.gen = 8,
+	.is_broadwell = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 };
 
 static const struct intel_device_info intel_broadwell_gt3m_info = {
 	BDW_FEATURES,
 	.gen = 8, .is_mobile = 1,
+	.is_broadwell = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 };
 

commit dc97997a21fe1708fc93021baa4ba90db7a3b57f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 10 14:10:04 2016 +0100

    drm/i915: Use drm_i915_private as the native pointer for intel_uncore.c
    
    Pass drm_i915_private to the uncore init/fini routines and their
    subservients as it is their native type.
    
       text    data     bss     dec     hex filename
    6309978 3578778  696320 10585076         a183f4 vmlinux
    6309530 3578778  696320 10584628         a18234 vmlinux
    
    a modest 400 bytes of saving, but 60 lines of code deleted!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462885804-26750-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a4cae74d86d8..a676c6dbc0e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -606,7 +606,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_guc_suspend(dev);
 
-	intel_suspend_gt_powersave(dev);
+	intel_suspend_gt_powersave(dev_priv);
 
 	intel_display_suspend(dev);
 
@@ -626,7 +626,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
 	intel_opregion_notify_adapter(dev, opregion_target_state);
 
-	intel_uncore_forcewake_reset(dev, false);
+	intel_uncore_forcewake_reset(dev_priv, false);
 	intel_opregion_fini(dev);
 
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
@@ -866,9 +866,9 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
 			  ret);
 
-	intel_uncore_early_sanitize(dev, true);
+	intel_uncore_early_sanitize(dev_priv, true);
 
-	if (IS_BROXTON(dev)) {
+	if (IS_BROXTON(dev_priv)) {
 		if (!dev_priv->suspended_to_idle)
 			gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
@@ -876,7 +876,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		hsw_disable_pc8(dev_priv);
 	}
 
-	intel_uncore_sanitize(dev);
+	intel_uncore_sanitize(dev_priv);
 
 	if (IS_BROXTON(dev_priv) ||
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
@@ -926,7 +926,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	unsigned reset_counter;
 	int ret;
 
-	intel_reset_gt_powersave(dev);
+	intel_reset_gt_powersave(dev_priv);
 
 	mutex_lock(&dev->struct_mutex);
 
@@ -942,7 +942,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 
 	i915_gem_reset(dev);
 
-	ret = intel_gpu_reset(dev, ALL_ENGINES);
+	ret = intel_gpu_reset(dev_priv, ALL_ENGINES);
 
 	/* Also reset the gpu hangman. */
 	if (error->stop_rings != 0) {
@@ -997,7 +997,7 @@ int i915_reset(struct drm_i915_private *dev_priv)
 	 * of re-init after reset.
 	 */
 	if (INTEL_INFO(dev)->gen > 5)
-		intel_enable_gt_powersave(dev);
+		intel_enable_gt_powersave(dev_priv);
 
 	return 0;
 
@@ -1474,7 +1474,7 @@ static int intel_runtime_suspend(struct device *device)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
-	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6(dev))))
+	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6())))
 		return -ENODEV;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
@@ -1513,7 +1513,7 @@ static int intel_runtime_suspend(struct device *device)
 
 	intel_guc_suspend(dev);
 
-	intel_suspend_gt_powersave(dev);
+	intel_suspend_gt_powersave(dev_priv);
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
 	ret = 0;
@@ -1535,7 +1535,7 @@ static int intel_runtime_suspend(struct device *device)
 		return ret;
 	}
 
-	intel_uncore_forcewake_reset(dev, false);
+	intel_uncore_forcewake_reset(dev_priv, false);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
@@ -1616,7 +1616,7 @@ static int intel_runtime_resume(struct device *device)
 	 * we can do is to hope that things will still work (and disable RPM).
 	 */
 	i915_gem_init_swizzling(dev);
-	gen6_update_ring_freq(dev);
+	gen6_update_ring_freq(dev_priv);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
 
@@ -1628,7 +1628,7 @@ static int intel_runtime_resume(struct device *device)
 	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_init(dev_priv);
 
-	intel_enable_gt_powersave(dev);
+	intel_enable_gt_powersave(dev_priv);
 
 	enable_rpm_wakeref_asserts(dev_priv);
 

commit ac840ae53573d9f435c88c131f6707a79aecb466
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 6 21:35:55 2016 +0300

    drm/i915: Re-enable GGTT earlier during resume on pre-gen6 platforms
    
    Move the intel_enable_gtt() call to happen before we touch the GTT
    during resume. Right now it's done way too late. Before
    commit ebb7c78d358b ("agp/intel-gtt: Only register fake agp driver for gen1")
    it was actually done earlier on account of also getting called from
    the resume hook of the fake agp driver. With the fake agp driver
    no longer getting registered we must move the call up.
    
    The symptoms I've seen on my 830 machine include lowmem corruption,
    other kinds of memory corruption, and straight up hung machine during
    or just after resume. Not really sure what causes the memory corruption,
    but so far I've not seen any with this fix.
    
    I think we shouldn't really need to call this during init, but we have
    been doing that so I've decided to keep the call. However moving that
    call earlier could be prudent as well. Doing it right after the
    intel-gtt probe seems appropriate.
    
    Also tested this on 946gz,elk,ilk and all seemed quite happy with
    this change.
    
    v2: Reorder init_hw vs. enable_hw functions (Chris)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: drm-intel-fixes@lists.freedesktop.org
    Fixes: ebb7c78d358b ("agp/intel-gtt: Only register fake agp driver for gen1")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462559755-353-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a116730c39aa..a4cae74d86d8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -730,9 +730,14 @@ int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
+	ret = i915_ggtt_enable_hw(dev);
+	if (ret)
+		DRM_ERROR("failed to re-enable GGTT\n");
+
 	intel_csr_ucode_resume(dev_priv);
 
 	mutex_lock(&dev->struct_mutex);

commit c033666a94b576185c4b5055f20536e13fada960
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri May 6 15:40:21 2016 +0100

    drm/i915: Store a i915 backpointer from engine, and use it
    
       text    data     bss     dec     hex filename
    6309351 3578714  696320 10584385         a18141 vmlinux
    6308391 3578714  696320 10583425         a17d81 vmlinux
    
    Almost 1KiB of code reduction.
    
    v2: More s/INTEL_INFO()->gen/INTEL_GEN()/ and IS_GENx() conversions
    
       text    data     bss     dec     hex filename
    6304579 3578778  696320 10579677         a16edd vmlinux
    6303427 3578778  696320 10578525         a16a5d vmlinux
    
    Now over 1KiB!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462545621-30125-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca9bea6ce552..a116730c39aa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -530,9 +530,9 @@ void intel_detect_pch(struct drm_device *dev)
 	pci_dev_put(pch);
 }
 
-bool i915_semaphore_is_enabled(struct drm_device *dev)
+bool i915_semaphore_is_enabled(struct drm_i915_private *dev_priv)
 {
-	if (INTEL_INFO(dev)->gen < 6)
+	if (INTEL_GEN(dev_priv) < 6)
 		return false;
 
 	if (i915.semaphores >= 0)
@@ -544,7 +544,7 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
-	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)
+	if (IS_GEN6(dev_priv) && intel_iommu_gfx_mapped)
 		return false;
 #endif
 
@@ -914,9 +914,9 @@ int i915_resume_switcheroo(struct drm_device *dev)
  *   - re-init interrupt state
  *   - re-init display
  */
-int i915_reset(struct drm_device *dev)
+int i915_reset(struct drm_i915_private *dev_priv)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_device *dev = dev_priv->dev;
 	struct i915_gpu_error *error = &dev_priv->gpu_error;
 	unsigned reset_counter;
 	int ret;

commit 91d14251bb3bf01d7a6e8abe898dc0f1889ebf22
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri May 6 14:48:28 2016 +0100

    drm/i915: Small display interrupt handlers tidy
    
    I have noticed some of our interrupt handlers use both dev and
    dev_priv while they could get away with only dev_priv in the
    huge majority of cases.
    
    Tidying that up had a cascading effect on changing functions
    prototypes, so relatively big churn factor, but I think it is
    for the better.
    
    For example even where changes cascade out of i915_irq.c, for
    functions prefixed with intel_, genX_ or <plat>_, it makes more
    sense to take dev_priv directly anyway.
    
    This allows us to eliminate local variables and intermixed usage
    of dev and dev_priv where only one is good enough.
    
    End result is shrinkage of both source and the resulting binary.
    
    i915.ko:
    
     - .text         000b0899
     + .text         000b0619
    
    Or if we look at the Gen8 display irq chain:
    
     -00000000000006ad t gen8_irq_handler
     +0000000000000663 t gen8_irq_handler
       -0000000000000028 T intel_opregion_asle_intr
       +0000000000000024 T intel_opregion_asle_intr
       -000000000000008c t ilk_hpd_irq_handler
       +000000000000007f t ilk_hpd_irq_handler
       -0000000000000116 T intel_check_page_flip
       +0000000000000112 T intel_check_page_flip
       -000000000000011a T intel_prepare_page_flip
       +0000000000000119 T intel_prepare_page_flip
       -0000000000000014 T intel_finish_page_flip_plane
       +0000000000000013 T intel_finish_page_flip_plane
       -0000000000000053 t hsw_pipe_crc_irq_handler
       +000000000000004c t hsw_pipe_crc_irq_handler
       -000000000000022e t cpt_irq_handler
       +0000000000000213 t cpt_irq_handler
    
    So small shrinkage but it is all fast paths so doesn't harm.
    
    Situation is similar in other interrupt handlers as well.
    
    v2: Tidy intel_queue_rps_boost_for_request as well. (Chris Wilson)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 58c48892fa82..ca9bea6ce552 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -768,7 +768,7 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	spin_lock_irq(&dev_priv->irq_lock);
 	if (dev_priv->display.hpd_irq_setup)
-		dev_priv->display.hpd_irq_setup(dev);
+		dev_priv->display.hpd_irq_setup(dev_priv);
 	spin_unlock_irq(&dev_priv->irq_lock);
 
 	intel_dp_mst_resume(dev);

commit fffb675106aef326bbd837612ad74c31ab060b93
Merge: b89359bdf0f1 5b4fd5b1111b
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 4 17:25:30 2016 +1000

    Merge tag 'drm-intel-next-2016-04-25' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - more userptr cornercase fixes from Chris
    - clean up and tune forcewake handling (Tvrtko)
    - more underrun fixes from Ville, mostly for ilk to appeas CI
    - fix unclaimed register warnings on vlv/chv and enable the debug code to catch
      them by default (Ville)
    - skl gpu hang fixes for gt3/4 (Mika Kuoppala)
    - edram improvements for gen9+ (Mika again)
    - clean up gpu reset corner cases (Chris)
    - fix ctx/ring machine deaths on snb/ilk (Chris)
    - MOCS programming for all engines (Peter Antoine)
    - robustify/clean up vlv/chv irq handler (Ville)
    - split gen8+ irq handlers into ack/handle phase (Ville)
    - tons of bxt rpm fixes (mostly around firmware interactions), from Imre
    - hook up panel fitting for dsi panels (Ville)
    - more runtime PM fixes all over from Imre
    - shrinker polish (Chris)
    - more guc fixes from Alex Dai and Dave Gordon
    - tons of bugfixes and small polish all over (but with a big focus on bxt)
    
    * tag 'drm-intel-next-2016-04-25' of git://anongit.freedesktop.org/drm-intel: (142 commits)
      drm/i915: Update DRIVER_DATE to 20160425
      drm/i915/bxt: Explicitly clear the Turbo control register
      drm/i915: Correct the i915_frequency_info debugfs output
      drm/i915: Macros to convert PM time interval values to microseconds
      drm/i915: Make RPS EI/thresholds multiple of 25 on SNB-BDW
      drm/i915: Fake HDMI live status
      drm/i915/bxt: Force reprogramming a PHY with invalid HW state
      drm/i915/bxt: Wait for PHY1 GRC done if PHY0 was already enabled
      drm/i915/bxt: Use PHY0 GRC value for HW state verification
      drm/i915: use dev_priv directly in gen8_ppgtt_notify_vgt
      drm/i915/bxt: Enable DC5 during runtime resume
      drm/i915/bxt: Sanitize DC state tracking during system resume
      drm/i915/bxt: Don't uninit/init display core twice during system suspend/resume
      drm/i915: Inline intel_suspend_complete
      drm/i915/kbl: Don't WARN for expected secondary MISC IO power well request
      drm/i915: Fix eDP low vswing for Broadwell
      drm/i915: check for ERR_PTR from i915_gem_object_pin_map()
      drm/i915/guc: local optimisations and updating comments
      drm/i915/guc: drop cached copy of 'wq_head'
      drm/i915/guc: keep GuC doorbell & process descriptor mapped in kernel
      ...

commit c14005a80fd2bcd71dea353bb4d4ef79ac08e47a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 29 12:20:22 2016 +0100

    drm/i915: Enable semaphores for legacy submission on gen8
    
    We have sufficient evidence from igt to support that semaphores are in
    a working state. Enabling semaphores now for legacy provides a better
    comparison of execlists against legacy ring submission.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461928823-10298-6-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7a0e4d6c71e2..58c48892fa82 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -542,10 +542,6 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (i915.enable_execlists)
 		return false;
 
-	/* Until we get further testing... */
-	if (IS_GEN8(dev))
-		return false;
-
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
 	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)

commit f62c79b33ff150da40fcdfc8cd48d0dd77f62902
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 20 20:27:57 2016 +0300

    drm/i915/bxt: Enable DC5 during runtime resume
    
    Right after runtime resume we know that we can re-enable DC5, since we
    just disabled DC9 and power well 2 is disabled. So enable DC5 explicitly
    instead of delaying this until the next time we disable power well 2.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461173277-16090-5-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a0f8913a76f8..7a0e4d6c71e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1601,6 +1601,9 @@ static int intel_runtime_resume(struct device *device)
 	if (IS_BROXTON(dev)) {
 		bxt_disable_dc9(dev_priv);
 		bxt_display_core_init(dev_priv, true);
+		if (dev_priv->csr.dmc_payload &&
+		    (dev_priv->csr.allowed_dc_mask & DC_STATE_EN_UPTO_DC5))
+			gen9_enable_dc5(dev_priv);
 	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		hsw_disable_pc8(dev_priv);
 	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {

commit da2f41d107e57074814ad44f4cea2b7befe3b7c4
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 20 20:27:56 2016 +0300

    drm/i915/bxt: Sanitize DC state tracking during system resume
    
    After suspend-to-ram or -disk we don't know what power state the display
    HW will be, DC0 or DC9 are both possible states, so reset the software
    DC state tracking in these cases. This gets rid of 'DC state mismatch'
    error messages during resuming from ram or disk where we expected to be
    in DC9 (as set by the suspend handler) but we are in DC0.
    
    v2:
    - Remove extra WS in gen9_sanitize_dc_state() (Bob)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461173277-16090-4-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2d0efd312b82..a0f8913a76f8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -867,10 +867,13 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_early_sanitize(dev, true);
 
-	if (IS_BROXTON(dev))
+	if (IS_BROXTON(dev)) {
+		if (!dev_priv->suspended_to_idle)
+			gen9_sanitize_dc_state(dev_priv);
 		bxt_disable_dc9(dev_priv);
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		hsw_disable_pc8(dev_priv);
+	}
 
 	intel_uncore_sanitize(dev);
 

commit b8aea3d1f408445f7683b47de09a8c6209c36409
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 20 20:27:55 2016 +0300

    drm/i915/bxt: Don't uninit/init display core twice during system suspend/resume
    
    Atm, we run the BSpec display core uninit/init sequences twice during
    system suspend/resume. While this shouldn't cause any problem, it's
    redundant, so get rid of the duplicate call.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461173277-16090-3-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 191287394543..2d0efd312b82 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -668,10 +668,9 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 		intel_power_domains_suspend(dev_priv);
 
 	ret = 0;
-	if (IS_BROXTON(dev_priv)) {
-		bxt_display_core_uninit(dev_priv);
+	if (IS_BROXTON(dev_priv))
 		bxt_enable_dc9(dev_priv);
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_enable_pc8(dev_priv);
 	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_suspend_complete(dev_priv);
@@ -868,10 +867,9 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_early_sanitize(dev, true);
 
-	if (IS_BROXTON(dev)) {
+	if (IS_BROXTON(dev))
 		bxt_disable_dc9(dev_priv);
-		bxt_display_core_init(dev_priv, true);
-	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 
 	intel_uncore_sanitize(dev);

commit 507e126e0700a71939935636a4d581a9323c5ec1
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 20 20:27:54 2016 +0300

    drm/i915: Inline intel_suspend_complete
    
    Initially we thought that the platform specific suspend/resume sequences
    can be shared between the runtime and system suspend/resume handlers.
    This turned out to be not true, we have quite a few differences on most
    of the platforms. This was realized already earlier by Paulo who
    inlined the platform specific resume_prepare handlers. We have the
    same problem with the corresponding suspend_complete handlers, there are
    platform differences that make it unfeasible to share the code between
    the runtime and system suspend paths. Also now we call functions that
    need to be paired like hsw_enable_pc8()/hsw_disable_pc8() from different
    levels of the call stack, which is confusing. Fix this by inlining the
    suspend_complete handlers too.
    
    This is also needed by the next patch that removes a redundant
    uninit/init call during system suspend/resume on BXT.
    
    No functional change.
    
    CC: Paulo Zanoni <przanoni@gmail.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
    [s/uninline/inline in the commit message]
    Link: http://patchwork.freedesktop.org/patch/msgid/1461173277-16090-2-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b449f96d2c1..191287394543 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -567,10 +567,9 @@ static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 	drm_modeset_unlock_all(dev);
 }
 
-static int intel_suspend_complete(struct drm_i915_private *dev_priv);
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 			      bool rpm_resume);
-static int bxt_resume_prepare(struct drm_i915_private *dev_priv);
+static int vlv_suspend_complete(struct drm_i915_private *dev_priv);
 
 static bool suspend_to_idle(struct drm_i915_private *dev_priv)
 {
@@ -668,7 +667,14 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	if (!fw_csr)
 		intel_power_domains_suspend(dev_priv);
 
-	ret = intel_suspend_complete(dev_priv);
+	ret = 0;
+	if (IS_BROXTON(dev_priv)) {
+		bxt_display_core_uninit(dev_priv);
+		bxt_enable_dc9(dev_priv);
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		hsw_enable_pc8(dev_priv);
+	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
+		ret = vlv_suspend_complete(dev_priv);
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
@@ -862,9 +868,10 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_early_sanitize(dev, true);
 
-	if (IS_BROXTON(dev))
-		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+	if (IS_BROXTON(dev)) {
+		bxt_disable_dc9(dev_priv);
+		bxt_display_core_init(dev_priv, true);
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 
 	intel_uncore_sanitize(dev);
@@ -1102,29 +1109,6 @@ static int i915_pm_resume(struct device *dev)
 	return i915_drm_resume(drm_dev);
 }
 
-static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
-{
-	hsw_enable_pc8(dev_priv);
-
-	return 0;
-}
-
-static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
-{
-	bxt_display_core_uninit(dev_priv);
-	bxt_enable_dc9(dev_priv);
-
-	return 0;
-}
-
-static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
-{
-	bxt_disable_dc9(dev_priv);
-	bxt_display_core_init(dev_priv, true);
-
-	return 0;
-}
-
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1530,7 +1514,16 @@ static int intel_runtime_suspend(struct device *device)
 	intel_suspend_gt_powersave(dev);
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
-	ret = intel_suspend_complete(dev_priv);
+	ret = 0;
+	if (IS_BROXTON(dev_priv)) {
+		bxt_display_core_uninit(dev_priv);
+		bxt_enable_dc9(dev_priv);
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
+		hsw_enable_pc8(dev_priv);
+	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
+		ret = vlv_suspend_complete(dev_priv);
+	}
+
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
 		intel_runtime_pm_enable_interrupts(dev_priv);
@@ -1604,12 +1597,14 @@ static int intel_runtime_resume(struct device *device)
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev);
 
-	if (IS_BROXTON(dev))
-		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+	if (IS_BROXTON(dev)) {
+		bxt_disable_dc9(dev_priv);
+		bxt_display_core_init(dev_priv, true);
+	} else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {
 		hsw_disable_pc8(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
+	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
 		ret = vlv_resume_prepare(dev_priv, true);
+	}
 
 	/*
 	 * No point of rolling back things in case of an error, as the best
@@ -1640,26 +1635,6 @@ static int intel_runtime_resume(struct device *device)
 	return ret;
 }
 
-/*
- * This function implements common functionality of runtime and system
- * suspend sequence.
- */
-static int intel_suspend_complete(struct drm_i915_private *dev_priv)
-{
-	int ret;
-
-	if (IS_BROXTON(dev_priv))
-		ret = bxt_suspend_complete(dev_priv);
-	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
-		ret = hsw_suspend_complete(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
-		ret = vlv_suspend_complete(dev_priv);
-	else
-		ret = 0;
-
-	return ret;
-}
-
 static const struct dev_pm_ops i915_pm_ops = {
 	/*
 	 * S0ix (via system suspend) and S3 event handlers [PMSG_SUSPEND,

commit 605b28c8598651d33cb63f40ac6759259d9c216d
Merge: 49047962ecf0 ba3150ac3876
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 22 09:03:31 2016 +1000

    Merge tag 'drm-intel-next-2016-04-11' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - make modeset hw state checker atomic aware (Maarten)
    - close races in gpu stuck detection/seqno reading (Chris)
    - tons&tons of small improvements from Chris Wilson all over the gem code
    - more dsi/bxt work from Ramalingam&Jani
    - macro polish from Joonas
    - guc fw loading fixes (Arun&Dave)
    - vmap notifier (acked by Andrew) + i915 support by Chris Wilson
    - create bottom half for execlist irq processing (Chris Wilson)
    - vlv/chv pll cleanup (Ville)
    - rework DP detection, especially sink detection (Shubhangi Shrivastava)
    - make color manager support fully atomic (Maarten)
    - avoid livelock on chv in execlist irq handler (Chris)
    
    * tag 'drm-intel-next-2016-04-11' of git://anongit.freedesktop.org/drm-intel: (82 commits)
      drm/i915: Update DRIVER_DATE to 20160411
      drm/i915: Avoid allocating a vmap arena for a single page
      drm,i915: Introduce drm_malloc_gfp()
      drm/i915/shrinker: Restrict vmap purge to objects with vmaps
      drm/i915: Refactor duplicate object vmap functions
      drm/i915: Consolidate common error handling in intel_pin_and_map_ringbuffer_obj
      drm/i915/dmabuf: Tighten struct_mutex for unmap_dma_buf
      drm/i915: implement WaClearTdlStateAckDirtyBits
      drm/i915/bxt: Reversed polarity of PORT_PLL_REF_SEL bit
      drm/i915: Rename hw state checker to hw state verifier.
      drm/i915: Move modeset state verifier calls.
      drm/i915: Make modeset state verifier take crtc as argument.
      drm/i915: Replace manual barrier() with READ_ONCE() in HWS accessor
      drm/i915: Use simplest form for flushing the single cacheline in the HWS
      drm/i915: Harden detection of missed interrupts
      drm/i915: Separate out the seqno-barrier from engine->get_seqno
      drm/i915: Remove forcewake dance from seqno/irq barrier on legacy gen6+
      drm/i915: Fixup the free space logic in ring_prepare
      drm/i915: Simplify check for idleness in hangcheck
      drm/i915: Apply a mb between emitting the request and hangcheck
      ...

commit f74ed08d55a059a20dc1e513edc51c18dfaf2add
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 18 14:48:21 2016 +0300

    drm/i915/gen9: Fix runtime PM refcounting in case DMC firmware isn't loaded
    
    While we disable runtime PM and with that display power well support if
    the DMC firmware isn't loaded, we still want to disable power wells
    during system suspend and driver unload. So drop/reacquire the
    corresponding power refcount during suspend/resume and driver unloading.
    This also means we have to check if DMC is not loaded and skip enabling
    DC states in the power well code.
    
    v2:
    - Reuse intel_csr_ucode_suspend() in intel_csr_ucode_fini() instead of
      opencoding the former. (Chris)
    - Add docbook comment to the public resume and suspend functions.
    
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460980101-14713-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 735df5595b34..1b449f96d2c1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -640,8 +640,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_display_set_init_power(dev_priv, false);
 
-	if (HAS_CSR(dev_priv))
-		flush_work(&dev_priv->csr.work);
+	intel_csr_ucode_suspend(dev_priv);
 
 out:
 	enable_rpm_wakeref_asserts(dev_priv);
@@ -733,6 +732,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
+	intel_csr_ucode_resume(dev_priv);
+
 	mutex_lock(&dev->struct_mutex);
 	i915_gem_restore_gtt_mappings(dev);
 	mutex_unlock(&dev->struct_mutex);

commit 44410cd0bfb26bde9288da34c190cc9267d42a20
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 18 14:45:54 2016 +0300

    drm/i915: Fix system resume if PCI device remained enabled
    
    During system resume we depended on pci_enable_device() also putting the
    device into PCI D0 state. This won't work if the PCI device was already
    enabled but still in D3 state. This is because pci_enable_device() is
    refcounted and will not change the HW state if called with a non-zero
    refcount. Leaving the device in D3 will make all subsequent device
    accesses fail.
    
    This didn't cause a problem most of the time, since we resumed with an
    enable refcount of 0. But it fails at least after module reload because
    after that we also happen to leak a PCI device enable reference: During
    probing we call drm_get_pci_dev() which will enable the PCI device, but
    during device removal drm_put_dev() won't disable it. This is a bug of
    its own in DRM core, but without much harm as it only leaves the PCI
    device enabled. Fixing it is also a bit more involved, due to DRM
    mid-layering and because it affects non-i915 drivers too. The fix in
    this patch is valid regardless of the problem in DRM core.
    
    v2:
    - Add a code comment about the relation of this fix to the freeze/thaw
      vs. the suspend/resume phases. (Ville)
    - Add a code comment about the inconsistent ordering of set power state
      and device enable calls. (Chris)
    
    CC: Ville Syrjälä <ville.syrjala@linux.intel.com>
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    CC: stable@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460979954-14503-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 219b70774b01..735df5595b34 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -803,7 +803,7 @@ static int i915_drm_resume(struct drm_device *dev)
 static int i915_drm_resume_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret = 0;
+	int ret;
 
 	/*
 	 * We have a resume ordering issue with the snd-hda driver also
@@ -814,6 +814,36 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 * FIXME: This should be solved with a special hdmi sink device or
 	 * similar so that power domains can be employed.
 	 */
+
+	/*
+	 * Note that we need to set the power state explicitly, since we
+	 * powered off the device during freeze and the PCI core won't power
+	 * it back up for us during thaw. Powering off the device during
+	 * freeze is not a hard requirement though, and during the
+	 * suspend/resume phases the PCI core makes sure we get here with the
+	 * device powered on. So in case we change our freeze logic and keep
+	 * the device powered we can also remove the following set power state
+	 * call.
+	 */
+	ret = pci_set_power_state(dev->pdev, PCI_D0);
+	if (ret) {
+		DRM_ERROR("failed to set PCI D0 power state (%d)\n", ret);
+		goto out;
+	}
+
+	/*
+	 * Note that pci_enable_device() first enables any parent bridge
+	 * device and only then sets the power state for this device. The
+	 * bridge enabling is a nop though, since bridge devices are resumed
+	 * first. The order of enabling power and enabling the device is
+	 * imposed by the PCI core as described above, so here we preserve the
+	 * same order for the freeze/thaw phases.
+	 *
+	 * TODO: eventually we should remove pci_disable_device() /
+	 * pci_enable_enable_device() from suspend/resume. Due to how they
+	 * depend on the device enable refcount we can't anyway depend on them
+	 * disabling/enabling the device.
+	 */
 	if (pci_enable_device(dev->pdev)) {
 		ret = -EIO;
 		goto out;

commit 6e35e8ab6f7058cf5a53b30bf0085e0eaf61b4f7
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 18 10:04:19 2016 +0300

    drm/i915: Fix error path in i915_drm_resume_early
    
    If system resume fails, this may lead to a runtime PM wake reference
    underflow used for runtime PM state checking.
    
    Fixes: 1f814daca43a ("drm/i915: add support for checking if we hold an RPM reference")
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460963062-13211-2-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b7c7d7773654..219b70774b01 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -842,11 +842,11 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
 
+	enable_rpm_wakeref_asserts(dev_priv);
+
 out:
 	dev_priv->suspended_to_idle = false;
 
-	enable_rpm_wakeref_asserts(dev_priv);
-
 	return ret;
 }
 

commit d7d7c9ee699a0b85de0023433cdbd8f965e1ac08
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Apr 1 16:02:42 2016 +0300

    drm/i915/bxt: Don't toggle power well 1 on-demand
    
    Power well 1 is managed by the DMC firmware so don't toggle it on-demand
    from the driver. This means we need to follow the BSpec display
    initialization sequence during driver loading and resuming (both system
    and runtime) and enable power well 1 only once there. Afterwards DMC
    will toggle power well 1 whenever entering/exiting DC5.
    
    For this to work we also need to do away getting the PLL power domain,
    since that just kept runtime PM disabled for good.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459515767-29228-12-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0d442b2a0d13..b7c7d7773654 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1080,10 +1080,7 @@ static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 
 static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	/* TODO: when DC5 support is added disable DC5 here. */
-
-	broxton_ddi_phy_uninit(dev_priv);
-	broxton_uninit_cdclk(dev_priv);
+	bxt_display_core_uninit(dev_priv);
 	bxt_enable_dc9(dev_priv);
 
 	return 0;
@@ -1091,16 +1088,8 @@ static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
 
 static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 {
-	/* TODO: when CSR FW support is added make sure the FW is loaded */
-
 	bxt_disable_dc9(dev_priv);
-
-	/*
-	 * TODO: when DC5 support is added enable DC5 here if the CSR FW
-	 * is available.
-	 */
-	broxton_init_cdclk(dev_priv);
-	broxton_ddi_phy_init(dev_priv);
+	bxt_display_core_init(dev_priv, true);
 
 	return 0;
 }

commit c6c4696fa52323b873e794b3efa88acc7378a78d
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Apr 1 16:02:40 2016 +0300

    drm/i915/bxt: Pass drm_i915_private to DDI PHY, CDCLK helpers
    
    For internal APIs passing dev_priv is preferred to reduce indirections,
    so convert over a few DDI PHY, CDCLK helpers.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: David Weinehall <david.weinehall@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459515767-29228-10-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ef0e0dbf2e35..0d442b2a0d13 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1080,12 +1080,10 @@ static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 
 static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
-
 	/* TODO: when DC5 support is added disable DC5 here. */
 
-	broxton_ddi_phy_uninit(dev);
-	broxton_uninit_cdclk(dev);
+	broxton_ddi_phy_uninit(dev_priv);
+	broxton_uninit_cdclk(dev_priv);
 	bxt_enable_dc9(dev_priv);
 
 	return 0;
@@ -1093,8 +1091,6 @@ static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
 
 static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
-
 	/* TODO: when CSR FW support is added make sure the FW is loaded */
 
 	bxt_disable_dc9(dev_priv);
@@ -1103,8 +1099,8 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 	 * TODO: when DC5 support is added enable DC5 here if the CSR FW
 	 * is available.
 	 */
-	broxton_init_cdclk(dev);
-	broxton_ddi_phy_init(dev);
+	broxton_init_cdclk(dev_priv);
+	broxton_ddi_phy_init(dev_priv);
 
 	return 0;
 }

commit a7c8125f464ce798fe0962e0fd837802e7bf28cc
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Apr 1 16:02:38 2016 +0300

    drm/i915/bxt: Suspend power domains during suspend-to-idle
    
    On SKL/KBL suspend-to-idle (aka freeze/s0ix) is performed with DMC
    firmware assistance where the target display power state is DC6. On
    Broxton on the other hand we don't use the firmware for this, but rely
    instead on a manual DC9 flow. For this we have to uninitialize the
    display following the BSpec display uninit sequence, just as during
    S3/S4, so make sure we follow this sequence.
    
    CC: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459515767-29228-8-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index adc33927e838..ef0e0dbf2e35 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -657,7 +657,8 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 
 	disable_rpm_wakeref_asserts(dev_priv);
 
-	fw_csr = suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
+	fw_csr = !IS_BROXTON(dev_priv) &&
+		suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
 	 * deinit the power domains. This also means the CSR/DMC firmware will
@@ -837,7 +838,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_sanitize(dev);
 
-	if (!(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
+	if (IS_BROXTON(dev_priv) ||
+	    !(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
 		intel_power_domains_init_hw(dev_priv, true);
 
 out:

commit 804e59a8300b6943cad60f5032f954bd9c4e87e2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 13 17:35:09 2016 +0100

    drm/i915: Suppress error message when GPU resets are disabled
    
    If we do not have lowlevel support for reseting the GPU, or if the user
    has explicitly disabled reseting the device, the failure is expected.
    Since it is an expected failure, we should be using a lower priority
    message than *ERROR*, perhaps NOTICE. In the absence of DRM_NOTICE, just
    emit the expected failure as a DEBUG message.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460565315-7748-10-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 633d0ddace6a..adc33927e838 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -917,7 +917,10 @@ int i915_reset(struct drm_device *dev)
 		pr_notice("drm/i915: Resetting chip after gpu hang\n");
 
 	if (ret) {
-		DRM_ERROR("Failed to reset chip: %i\n", ret);
+		if (ret != -ENODEV)
+			DRM_ERROR("Failed to reset chip: %i\n", ret);
+		else
+			DRM_DEBUG_DRIVER("GPU reset disabled\n");
 		goto error;
 	}
 

commit d98c52cf4fa2bb7116a89f1132fc773b1cfa6436
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 13 17:35:05 2016 +0100

    drm/i915: Tighten reset_counter for reset status
    
    In the reset_counter, we use two bits to track a GPU hang and reset. The
    low bit is a "reset-in-progress" flag that we set to signal when we need
    to break waiters in order for the recovery task to grab the mutex. As
    soon as the recovery task has the mutex, we can clear that flag (which
    we do by incrementing the reset_counter thereby incrementing the gobal
    reset epoch). By clearing that flag when the recovery task holds the
    struct_mutex, we can forgo a second flag that simply tells GEM to ignore
    the "reset-in-progress" flag.
    
    The second flag we store in the reset_counter is whether the
    reset failed and we consider the GPU terminally wedged. Whilst this flag
    is set, all access to the GPU (at least through GEM rather than direct mmio
    access) is verboten.
    
    PS: Fun is in store, as in the future we want to move from a global
    reset epoch to a per-engine reset engine with request recovery.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460565315-7748-6-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1dca3442c545..633d0ddace6a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -880,23 +880,32 @@ int i915_resume_switcheroo(struct drm_device *dev)
 int i915_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	bool simulated;
+	struct i915_gpu_error *error = &dev_priv->gpu_error;
+	unsigned reset_counter;
 	int ret;
 
 	intel_reset_gt_powersave(dev);
 
 	mutex_lock(&dev->struct_mutex);
 
-	i915_gem_reset(dev);
+	/* Clear any previous failed attempts at recovery. Time to try again. */
+	atomic_andnot(I915_WEDGED, &error->reset_counter);
 
-	simulated = dev_priv->gpu_error.stop_rings != 0;
+	/* Clear the reset-in-progress flag and increment the reset epoch. */
+	reset_counter = atomic_inc_return(&error->reset_counter);
+	if (WARN_ON(__i915_reset_in_progress(reset_counter))) {
+		ret = -EIO;
+		goto error;
+	}
+
+	i915_gem_reset(dev);
 
 	ret = intel_gpu_reset(dev, ALL_ENGINES);
 
 	/* Also reset the gpu hangman. */
-	if (simulated) {
+	if (error->stop_rings != 0) {
 		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
-		dev_priv->gpu_error.stop_rings = 0;
+		error->stop_rings = 0;
 		if (ret == -ENODEV) {
 			DRM_INFO("Reset not implemented, but ignoring "
 				 "error for simulated gpu hangs\n");
@@ -909,8 +918,7 @@ int i915_reset(struct drm_device *dev)
 
 	if (ret) {
 		DRM_ERROR("Failed to reset chip: %i\n", ret);
-		mutex_unlock(&dev->struct_mutex);
-		return ret;
+		goto error;
 	}
 
 	intel_overlay_reset(dev_priv);
@@ -929,20 +937,14 @@ int i915_reset(struct drm_device *dev)
 	 * was running at the time of the reset (i.e. we weren't VT
 	 * switched away).
 	 */
-
-	/* Used to prevent gem_check_wedged returning -EAGAIN during gpu reset */
-	dev_priv->gpu_error.reload_in_reset = true;
-
 	ret = i915_gem_init_hw(dev);
-
-	dev_priv->gpu_error.reload_in_reset = false;
-
-	mutex_unlock(&dev->struct_mutex);
 	if (ret) {
 		DRM_ERROR("Failed hw init on reset %d\n", ret);
-		return ret;
+		goto error;
 	}
 
+	mutex_unlock(&dev->struct_mutex);
+
 	/*
 	 * rps/rc6 re-init is necessary to restore state lost after the
 	 * reset and the re-install of gt irqs. Skip for ironlake per
@@ -953,6 +955,11 @@ int i915_reset(struct drm_device *dev)
 		intel_enable_gt_powersave(dev);
 
 	return 0;
+
+error:
+	atomic_or(I915_WEDGED, &error->reset_counter);
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
 }
 
 static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)

commit 2d1fe0734087f0d3adb77e2489843126e313387c
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 7 11:08:05 2016 +0300

    drm/i915: Do not use {HAS_*, IS_*, INTEL_INFO}(dev_priv->dev)
    
    dev_priv is what the macro works hard to extract, pass it directly.
    
    > sed 's/\([A-Z].*(dev_priv\)->dev)/\1)/g'
    
    v2:
    - Include all wrapper macros too (Chris)
    
    v3:
    - Include sed cmdline (Chris)
    
    v4:
    - Break long line
    - Rebase
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460016485-8089-1-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 79b63cb4ddcf..1dca3442c545 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1400,7 +1400,7 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	if (err)
 		goto err2;
 
-	if (!IS_CHERRYVIEW(dev_priv->dev))
+	if (!IS_CHERRYVIEW(dev_priv))
 		vlv_save_gunit_s0ix_state(dev_priv);
 
 	err = vlv_force_gfx_clock(dev_priv, false);
@@ -1432,7 +1432,7 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 	 */
 	ret = vlv_force_gfx_clock(dev_priv, true);
 
-	if (!IS_CHERRYVIEW(dev_priv->dev))
+	if (!IS_CHERRYVIEW(dev_priv))
 		vlv_restore_gunit_s0ix_state(dev_priv);
 
 	err = vlv_allow_gt_wake(dev_priv, true);

commit 85bd5ac371c844f66918dda8c83145a26a55f9f2
Merge: e7c8e54440bc 68d4aee9d1f2
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 6 09:40:07 2016 +1000

    Merge tag 'drm-intel-next-2016-03-30' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - VBT code refactor for a clean split between parsing&using of firmware
      information (Jani)
    - untangle the pll computation code, and splitting up the monster
      i9xx_crtc_compute_clocks (Ander)
    - dsi support for bxt (Jani, Shashank Sharma and others)
    - color manager (i.e. de-gamma, color conversion matrix & gamma support) from
      Lionel Landwerlin
    - Vulkan hsw support in the command parser (Jordan Justen)
    - large-scale renaming of intel_engine_cs variables/parameters to avoid the epic
      ring vs. engine confusion introduced in gen8 (Tvrtko Ursulin)
    - few atomic patches from Maarten&Matt, big one is two-stage wm programming on ilk-bdw
    - refactor driver load and add infrastructure to inject load failures for
      testing, from Imre
    - various small things all over
    
    * tag 'drm-intel-next-2016-03-30' of git://anongit.freedesktop.org/drm-intel: (179 commits)
      drm/i915: Update DRIVER_DATE to 20160330
      drm/i915: Call intel_dp_mst_resume() before resuming displays
      drm/i915: Fix races on fbdev
      drm/i915: remove unused dev_priv->render_reclock_avail
      drm/i915: move sdvo mappings to vbt data
      drm/i915: move edp low vswing config to vbt data
      drm/i915: use a substruct in vbt data for edp
      drm/i915: replace for_each_engine()
      drm/i915: introduce for_each_engine_id()
      drm/i915/bxt: Fix DSI HW state readout
      drm/i915: Remove vblank wait from hsw_enable_ips, v2.
      drm/i915: Tidy aliasing_gtt_bind_vma()
      drm/i915: Split PNV version of crtc_compute_clock()
      drm/i915: Split g4x_crtc_compute_clock()
      drm/i915: Split i8xx_crtc_compute_clock()
      drm/i915: Split CHV and VLV specific crtc_compute_clock() hooks
      drm/i915: Merge ironlake_compute_clocks() and ironlake_crtc_compute_clock()
      drm/i915: Move fp divisor calculation into ironlake_compute_dpll()
      drm/i915: Pass crtc_state->dpll directly to ->find_dpll()
      drm/i915: Simplify ironlake_crtc_compute_clock() CPU eDP case
      ...

commit e7c8e54440bcae3f883ca8801f6558fe29bf0198
Merge: 9735a22799b9 249c4f538b1a
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 6 09:39:01 2016 +1000

    Merge tag 'topic/drm-misc-2016-04-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    * tag 'topic/drm-misc-2016-04-01' of git://anongit.freedesktop.org/drm-intel:
      drm: Add new DCS commands in the enum list
      drm: Make uapi headers C89 pendantic compliant
      drm/atomic: export drm_atomic_helper_wait_for_fences()
      drm: Untangle __KERNEL__ guards
      drm: Move DRM_MODE_OBJECT_* to uapi headers
      drm: align #include directives with libdrm in uapi headers
      drm: Make drm.h uapi header safe for C++
      vgacon: dummy implementation for vgacon_text_force
      drm/sysfs: Nuke TV/DVI property files
      drm/ttm: Remove TTM_HAS_AGP
      drm: bridge/dw-hdmi: Remove pre_enable/post_disable dummy funcs
      Revert "drm: Don't pass negative delta to ktime_sub_ns()"
      drm/atmel: Fixup drm_connector_/unplug/unregister/_all
      drm: Rename drm_connector_unplug_all() to drm_connector_unregister_all()
      drm: bridge: Make (pre/post) enable/disable callbacks optional

commit 9c7417022ded5700a4b1a11da59951ebf080e4e0
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Wed Mar 30 07:58:01 2016 -0700

    drm/i915/kbl: Remove preliminary_hw_support protection from KBL.
    
    We now have KBL machines running in our CI systems and with no
    blocking issues that could cause a full hangs or blank screens.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459349881-951-1-git-send-email-rodrigo.vivi@intel.com
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f73b4f7b2d39..79b63cb4ddcf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -360,14 +360,12 @@ static const struct intel_device_info intel_broxton_info = {
 
 static const struct intel_device_info intel_kabylake_info = {
 	BDW_FEATURES,
-	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,
 };
 
 static const struct intel_device_info intel_kabylake_gt3_info = {
 	BDW_FEATURES,
-	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,

commit 44debe7a123cc760fc90ccbe253210798c917fa7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 11:26:35 2016 +0200

    vgacon: dummy implementation for vgacon_text_force
    
    This allows us to ditch a ton of ugly #ifdefs from a bunch of drm modeset
    drivers.
    
    v2: Make the dummy function actually return a sane value, spotted by
    Ville.
    
    v3: Because the patch is still in limbo there's no more drivers to
    convert, noticed by Emil.
    
    v4: Rebase once more, because hooray. I'll just go ahead an apply this
    one later on to drm-misc.
    
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44912ecebc1a..8a62690e6513 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1750,10 +1750,8 @@ static int __init i915_init(void)
 	if (i915.modeset == 0)
 		driver.driver_features &= ~DRIVER_MODESET;
 
-#ifdef CONFIG_VGA_CONSOLE
 	if (vgacon_text_force() && i915.modeset == -1)
 		driver.driver_features &= ~DRIVER_MODESET;
-#endif
 
 	if (!(driver.driver_features & DRIVER_MODESET)) {
 		/* Silently fail loading to not upset userspace. */

commit a16b7658f4e0d4aec9bc3e75a5f0cc3f7a3a0422
Author: Lyude <cpaul@redhat.com>
Date:   Fri Mar 11 10:57:01 2016 -0500

    drm/i915: Call intel_dp_mst_resume() before resuming displays
    
    Since we need MST devices ready before we try to resume displays,
    calling this after intel_display_resume() can result in some issues with
    various laptop docks where the monitor won't turn back on after
    suspending the system.
    
    This order was originally changed in
    
            commit e7d6f7d70829 ("drm/i915: resume MST after reading back hw state")
    
    In order to fix some unclaimed register errors, however the actual cause
    of those has since been fixed.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Lyude <cpaul@redhat.com>
    [danvet: Resolve conflicts with locking changes.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 20f8dbe7b21c..f73b4f7b2d39 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -770,10 +770,10 @@ static int i915_drm_resume(struct drm_device *dev)
 		dev_priv->display.hpd_irq_setup(dev);
 	spin_unlock_irq(&dev_priv->irq_lock);
 
-	intel_display_resume(dev);
-
 	intel_dp_mst_resume(dev);
 
+	intel_display_resume(dev);
+
 	/*
 	 * ... but also need to make sure that hotplug processing
 	 * doesn't cause havoc. Like in the driver load code we don't

commit 29dc3739e50da3576ddf89d9ea2704640676135d
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Wed Mar 16 10:57:17 2016 +0000

    drm/i915: Implement color management on chv
    
    Patch based on a previous series by Shashank Sharma.
    
    v2: Update contributors
    
    v3: Refactor degamma/gamma LUTs load into a single function
    
    v4: Remove unused variable
    
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Kumar, Kiran S <kiran.s.kumar@intel.com>
    Signed-off-by: Kausal Malladi <kausalmalladi@gmail.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458125837-2576-5-git-send-email-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f118a938dcaf..20f8dbe7b21c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -68,6 +68,8 @@ static struct drm_driver driver;
 
 #define BDW_COLORS \
 	.color = { .degamma_lut_size = 512, .gamma_lut_size = 512 }
+#define CHV_COLORS \
+	.color = { .degamma_lut_size = 65, .gamma_lut_size = 257 }
 
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
@@ -325,6 +327,7 @@ static const struct intel_device_info intel_cherryview_info = {
 	.display_mmio_offset = VLV_DISPLAY_BASE,
 	GEN_CHV_PIPEOFFSETS,
 	CURSOR_OFFSETS,
+	CHV_COLORS,
 };
 
 static const struct intel_device_info intel_skylake_info = {

commit 82cf435b3134a5f892971b721b34e4c5d249363d
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Wed Mar 16 10:57:16 2016 +0000

    drm/i915: Implement color management on bdw/skl/bxt/kbl
    
    Patch based on a previous series by Shashank Sharma.
    
    v2: Do not read GAMMA_MODE register to figure what mode we're in
    
    v3: Program PREC_PAL_GC_MAX to clamp pixel values > 1.0
    
        Add documentation on how the Broadcast RGB property is affected by CTM
    
    v4: Update contributors
    
    v5: Refactor degamma/gamma LUTs load into a single function
    
    v6: Fix missing intel_crtc variable (bisect issue)
    
    v7: Fix & simplify limited range matrix multiplication (Matt Roper's
        comment)
    
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Kumar, Kiran S <kiran.s.kumar@intel.com>
    Signed-off-by: Kausal Malladi <kausalmalladi@gmail.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Acknowledged-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458125837-2576-4-git-send-email-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2a076b005af9..f118a938dcaf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -66,6 +66,9 @@ static struct drm_driver driver;
 #define IVB_CURSOR_OFFSETS \
 	.cursor_offsets = { CURSOR_A_OFFSET, IVB_CURSOR_B_OFFSET, IVB_CURSOR_C_OFFSET }
 
+#define BDW_COLORS \
+	.color = { .degamma_lut_size = 512, .gamma_lut_size = 512 }
+
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
@@ -288,24 +291,28 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.is_mobile = 1,
 };
 
+#define BDW_FEATURES \
+	HSW_FEATURES, \
+	BDW_COLORS
+
 static const struct intel_device_info intel_broadwell_d_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.gen = 8,
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.gen = 8, .is_mobile = 1,
 };
 
 static const struct intel_device_info intel_broadwell_gt3d_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.gen = 8,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 };
 
 static const struct intel_device_info intel_broadwell_gt3m_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.gen = 8, .is_mobile = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 };
@@ -321,13 +328,13 @@ static const struct intel_device_info intel_cherryview_info = {
 };
 
 static const struct intel_device_info intel_skylake_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.is_skylake = 1,
 	.gen = 9,
 };
 
 static const struct intel_device_info intel_skylake_gt3_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.is_skylake = 1,
 	.gen = 9,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
@@ -345,17 +352,18 @@ static const struct intel_device_info intel_broxton_info = {
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
+	BDW_COLORS,
 };
 
 static const struct intel_device_info intel_kabylake_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,
 };
 
 static const struct intel_device_info intel_kabylake_gt3_info = {
-	HSW_FEATURES,
+	BDW_FEATURES,
 	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,

commit 1844a66b98800b3cfd92aea4e801641304ac07d7
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Mar 16 13:31:30 2016 -0700

    drm/i915: add another virtual PCH bridge for passthrough support
    
    Some configs use the P2X type but some use a P3X type PCH, so add that
    to the detect_pch function so things work correctly.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Allen Kay <allen.m.kay@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458160290-16710-1-git-send-email-jbarnes@virtuousgeek.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3648b73b48da..2a076b005af9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -504,6 +504,7 @@ void intel_detect_pch(struct drm_device *dev)
 				WARN_ON(!IS_SKYLAKE(dev) &&
 					!IS_KABYLAKE(dev));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
+				   (id == INTEL_PCH_P3X_DEVICE_ID_TYPE) ||
 				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
 				    pch->subsystem_vendor == 0x1af4 &&
 				    pch->subsystem_device == 0x1100)) {

commit ee4b6faf96a990d2acc30084f4edf015ca21b9c4
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Wed Mar 16 17:54:00 2016 +0200

    drm/i915: Modify reset func to handle per engine resets
    
    In full gpu reset we prime all engines and reset domains corresponding to
    each engine. Per engine reset is just a special case of this process
    wherein only a single engine is reset. This change is aimed to modify
    relevant functions to achieve this. There are some other steps we carry out
    in case of engine reset which are addressed in later patches.
    
    Reset func now accepts a mask of all engines that need to be reset. Where
    per engine resets are supported, error handler populates the mask
    accordingly otherwise all engines are specified.
    
    v2: ALL_ENGINES mask fixup, better for_each_ring_masked (Chris)
    v3: Whitespace fixes (Chris)
    v4: Rebase due to s/ring/engine
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458143640-20563-1-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 20e82008b8b6..3648b73b48da 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -881,7 +881,7 @@ int i915_reset(struct drm_device *dev)
 
 	simulated = dev_priv->gpu_error.stop_rings != 0;
 
-	ret = intel_gpu_reset(dev);
+	ret = intel_gpu_reset(dev, ALL_ENGINES);
 
 	/* Also reset the gpu hangman. */
 	if (simulated) {

commit e2c8b8701e2d0cb5b89fa3b5c8acae9dc4f76259
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Feb 16 10:06:14 2016 +0100

    drm/i915: Use atomic helpers for suspend, v2.
    
    Instead of duplicating the functionality now that we no longer need
    to preserve dpll state we can move to using the upstream suspend helper.
    
    Changes since v1:
    - Call hw readout with all mutexes held.
    - Rework intel_display_suspend to only assign modeset_restore_state
      on success.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/56C2E686.5060803@linux.intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44912ecebc1a..20e82008b8b6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,13 +603,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_suspend_gt_powersave(dev);
 
-	/*
-	 * Disable CRTCs directly since we want to preserve sw state
-	 * for _thaw. Also, power gate the CRTC power wells.
-	 */
-	drm_modeset_lock_all(dev);
 	intel_display_suspend(dev);
-	drm_modeset_unlock_all(dev);
 
 	intel_dp_mst_suspend(dev);
 
@@ -764,9 +758,7 @@ static int i915_drm_resume(struct drm_device *dev)
 		dev_priv->display.hpd_irq_setup(dev);
 	spin_unlock_irq(&dev_priv->irq_lock);
 
-	drm_modeset_lock_all(dev);
 	intel_display_resume(dev);
-	drm_modeset_unlock_all(dev);
 
 	intel_dp_mst_resume(dev);
 

commit 704ab614ec1201138032003c03113a81526638ab
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Jan 11 20:09:20 2016 +0100

    drm/i915: Defer probe if gmux is present but its driver isn't
    
    gmux is a microcontroller built into dual GPU MacBook Pros.
    On pre-retina MBPs, if we're the inactive GPU, we need apple-gmux
    to temporarily switch DDC so that we can probe the panel's EDID.
    
    The checks for CONFIG_VGA_ARB and CONFIG_VGA_SWITCHEROO are necessary
    because if either of them is disabled but gmux is present, the driver
    would never load, even if we're the active GPU. (vga_default_device()
    would evaluate to NULL and vga_switcheroo_handler_flags() would
    evaluate to 0.)
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=88861
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=61115
    Tested-by: Lukas Wunner <lukas@wunner.de>
        [MBP  9,1 2012  intel IVB + nvidia GK107  pre-retina  15"]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/f56ee6a0600a3e1bb5bed4d0db4ed9ade7445c47.1452525860.git.lukas@wunner.de

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 11d8414edbbe..44912ecebc1a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -35,9 +35,12 @@
 #include "i915_trace.h"
 #include "intel_drv.h"
 
+#include <linux/apple-gmux.h>
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/vgaarb.h>
+#include <linux/vga_switcheroo.h>
 #include <drm/drm_crtc_helper.h>
 
 static struct drm_driver driver;
@@ -969,6 +972,15 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
+	/*
+	 * apple-gmux is needed on dual GPU MacBook Pro
+	 * to probe the panel if we're the inactive GPU.
+	 */
+	if (IS_ENABLED(CONFIG_VGA_ARB) && IS_ENABLED(CONFIG_VGA_SWITCHEROO) &&
+	    apple_gmux_present() && pdev != vga_default_device() &&
+	    !vga_switcheroo_handler_flags())
+		return -EPROBE_DEFER;
+
 	return drm_get_pci_dev(pdev, ent, &driver);
 }
 

commit b039d6d02500ba8fe22e545b55b4961c1ef0f32d
Merge: 388f7b1d6e8c 947eaebc318d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Feb 9 10:27:41 2016 +1000

    Merge tag 'drm-intel-next-2016-01-24' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - support for v3 vbt dsi blocks (Jani)
    - improve mmio debug checks (Mika Kuoppala)
    - reorg the ddi port translation table entries and related code (Ville)
    - reorg gen8 interrupt handling for future platforms (Tvrtko)
    - refactor tile width/height computations for framebuffers (Ville)
    - kerneldoc integration for intel_pm.c (Jani)
    - move default context from engines to device-global dev_priv (Dave Gordon)
    - make seqno/irq ordering coherent with execlist (Chris)
    - decouple internal engine number from UABI (Chris&Tvrtko)
    - tons of small fixes all over, as usual
    
    * tag 'drm-intel-next-2016-01-24' of git://anongit.freedesktop.org/drm-intel: (148 commits)
      drm/i915: Update DRIVER_DATE to 20160124
      drm/i915: Seal busy-ioctl uABI and prevent leaking of internal ids
      drm/i915: Decouple execbuf uAPI from internal implementation
      drm/i915: Use ordered seqno write interrupt generation on gen8+ execlists
      drm/i915: Limit the auto arming of mmio debugs on vlv/chv
      drm/i915: Tune down "GT register while GT waking disabled" message
      drm/i915: tidy up a few leftovers
      drm/i915: abolish separate per-ring default_context pointers
      drm/i915: simplify allocation of driver-internal requests
      drm/i915: Fix NULL plane->fb oops on SKL
      drm/i915: Do not put big intel_crtc_state on the stack
      Revert "drm/i915: Add two-stage ILK-style watermark programming (v10)"
      drm/i915: add DOC: headline to RC6 kernel-doc
      drm/i915: turn some bogus kernel-doc comments to normal comments
      drm/i915/sdvo: revert bogus kernel-doc comments to normal comments
      drm/i915/gen9: Correct max save/restore register count during gpu reset with GuC
      drm/i915: Demote user facing DMC firmware load failure message
      drm/i915: use hlist_for_each_entry
      drm/i915: skl_update_scaler() wants a rotation bitmask instead of bit number
      drm/i915: Don't reject primary plane windowing with color keying enabled on SKL+
      ...

commit f2e305108faba0c85eb4ba4066599decb675117e
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Mon Jan 25 12:02:28 2016 +0100

    drm/i915: refine qemu south bridge detection
    
    The test for the qemu q35 south bridge added by commit
    "39bfcd52 drm/i915: more virtual south bridge detection"
    also matches on real hardware.  Having the check for
    virtual systems last in the list is not enough to avoid
    that ...
    
    Refine the check by additionally verifying the pci
    subsystem id to see whenever it *really* is qemu.
    
    [ v2: fix subvendor tyops ]
    
    Reported-and-tested-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Tested-by: Bruno Wolff III <bruno@wolff.to>
    Cc: drm-intel-fixes@lists.freedesktop.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453719748-10944-1-git-send-email-kraxel@redhat.com
    (cherry picked from commit 1e859111c128265f8d62b39ff322e42b1ddb5a20)

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ac616d7363b..f357058c74d9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -501,7 +501,9 @@ void intel_detect_pch(struct drm_device *dev)
 				WARN_ON(!IS_SKYLAKE(dev) &&
 					!IS_KABYLAKE(dev));
 			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
-				   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE)) {
+				   ((id == INTEL_PCH_QEMU_DEVICE_ID_TYPE) &&
+				    pch->subsystem_vendor == 0x1af4 &&
+				    pch->subsystem_device == 0x1100)) {
 				dev_priv->pch_type = intel_virt_detect_pch(dev);
 			} else
 				continue;

commit 6fa283b07e708913aa5fb38a3a20ba7adc05ba56
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jan 19 21:00:56 2016 +0100

    drm/i915: Tune down "GT register while GT waking disabled" message
    
    We've had this since forever, and's randomly reporting issues and as
    such causing piles&piles of CI noise. Mika is working on proper debug
    infrastructure for this, and on fixing this properly.
    
    Meanwhile make CI more useful for everyone else.
    
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=93121
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453233656-12955-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 975af3568521..706b8eabfaf4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1356,7 +1356,7 @@ static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
 	if (!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEERR))
 		return;
 
-	DRM_ERROR("GT register access while GT waking disabled\n");
+	DRM_DEBUG_DRIVER("GT register access while GT waking disabled\n");
 	I915_WRITE(VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);
 }
 

commit 87ad321287ae99a8932af1a19ac99849284a62bd
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jan 14 12:53:34 2016 +0200

    drm/i915: add onoff utility function
    
    Add a common function to return "on" or "off" string based on the
    argument, and drop the local versions of it.
    
    This is the onoff version of
    
    commit 42a8ca4cb4a48ddbf40e8edb291425e76bcdc230
    Author: Jani Nikula <jani.nikula@intel.com>
    Date:   Thu Aug 27 16:23:30 2015 +0300
    
        drm/i915: add yesno utility function
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452768814-29787-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f17a2b0c2493..975af3568521 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1335,8 +1335,8 @@ static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 		return 0;
 
 	DRM_DEBUG_KMS("waiting for GT wells to go %s (%08x)\n",
-			wait_for_on ? "on" : "off",
-			I915_READ(VLV_GTLC_PW_STATUS));
+		      onoff(wait_for_on),
+		      I915_READ(VLV_GTLC_PW_STATUS));
 
 	/*
 	 * RC6 transitioning can be delayed up to 2 msec (see
@@ -1345,7 +1345,7 @@ static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
 	err = wait_for(COND, 3);
 	if (err)
 		DRM_ERROR("timeout waiting for GT wells to go %s\n",
-			  wait_for_on ? "on" : "off");
+			  onoff(wait_for_on));
 
 	return err;
 #undef COND

commit 6a7e4f99897f31708ff9ea01875d9ff112bebe90
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 8 19:59:44 2015 +0200

    drm/i915: Kill intel_prepare_ddi()
    
    Move the ddi buffer translation programming to occur from the encoder
    .pre_enable() hook, for just the ddi port we are enabling. Previously
    we used to reprogram the translations for all ddi ports during
    init and during power well enabling.
    
    v2: s/intel_prepare_ddi_buffers/intel_prepare_ddi_buffer/ (Daniel)
        Resolve conflicts due to  dev_priv->atomic_cdclk_freq
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9de993d5fed2..f17a2b0c2493 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1077,7 +1077,6 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 	 */
 	broxton_init_cdclk(dev);
 	broxton_ddi_phy_init(dev);
-	intel_prepare_ddi(dev);
 
 	return 0;
 }

commit bc3b9346cd47148db8601fb425a4949902c475ec
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Fri Jan 8 15:51:20 2016 +0200

    drm/i915: Arm the unclaimed mmio debugs on suspend path
    
    If we go into suspend with unclaimed access detected,
    it would be nice to catch that access on a next suspend path.
    So instead of just notifying about it, arm the unclaimed
    mmio checks on suspend side.
    
    We want to keep the asymmetry on resume, as if it was
    on resume path, it was not driver that is responsible so
    no point in arming mmio debugs.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452261080-6979-2-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 288fec7691dc..9de993d5fed2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1502,7 +1502,7 @@ static int intel_runtime_suspend(struct device *device)
 	enable_rpm_wakeref_asserts(dev_priv);
 	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
 
-	if (intel_uncore_unclaimed_mmio(dev_priv))
+	if (intel_uncore_arm_unclaimed_mmio_detection(dev_priv))
 		DRM_ERROR("Unclaimed access detected prior to suspending\n");
 
 	dev_priv->pm.suspended = true;

commit 55ec45c2ced1a4b1e7cd2e7e306101f328958760
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Tue Dec 15 16:25:08 2015 +0200

    drm/i915: Detect and clear unclaimed access on resume
    
    If something, the usual suspect being bios, access hw
    behind our back, don't let it slide into situation where
    normal register access will detect this and spit out
    a warn on into dmesg. On some bdw bioses this happens
    during igt/bat run always and as there is not much we can
    do about it, its better just to detect and flush this
    explicitly on resume and only print a debug message.
    
    v2: use DRM_DEBUG_DRIVER (Chris)
    v3: s/access/mmio, s/prior/prior to, s/dev/dev_priv
    
    Testcase: igt/pm_rpm/basic-rte
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <przanoni@gmail.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    [Mika: fixed merge conflict]
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450189512-30360-3-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ac616d7363b..288fec7691dc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1501,6 +1501,10 @@ static int intel_runtime_suspend(struct device *device)
 
 	enable_rpm_wakeref_asserts(dev_priv);
 	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
+
+	if (intel_uncore_unclaimed_mmio(dev_priv))
+		DRM_ERROR("Unclaimed access detected prior to suspending\n");
+
 	dev_priv->pm.suspended = true;
 
 	/*
@@ -1549,6 +1553,8 @@ static int intel_runtime_resume(struct device *device)
 
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
+	if (intel_uncore_unclaimed_mmio(dev_priv))
+		DRM_DEBUG_DRIVER("Unclaimed access during suspend, bios?\n");
 
 	intel_guc_resume(dev);
 

commit 1f814daca43a2d99248fd754eacfb8ba12449235
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Dec 16 02:52:19 2015 +0200

    drm/i915: add support for checking if we hold an RPM reference
    
    Atm, we assert that the device is not suspended until the point when the
    device is truly put to a suspended state. This is fine, but we can catch
    more problems if we check that RPM refcount is non-zero. After that one
    drops to zero we shouldn't access the device any more, even if the actual
    device suspend may be delayed. Change assert_rpm_wakelock_held()
    accordingly to check for a non-zero RPM refcount in addition to the
    current device-not-suspended check.
    
    For the new asserts to work we need to annotate every place explicitly in
    the code where we expect that the device is powered. The places where we
    only assume this, but may not hold an RPM reference:
    - driver load
      We assume the device to be powered until we enable RPM. Make this
      explicit by taking an RPM reference around the load function.
    - system and runtime sudpend/resume handlers
      These handlers are called when the RPM reference becomes 0 and know the
      exact point after which the device can get powered off. Disable the
      RPM-reference-held check for their duration.
    - the IRQ, hangcheck and RPS work handlers
      These handlers are flushed in the system/runtime suspend handler
      before the device is powered off, so it's guaranteed that they won't
      run while the device is powered off even though they don't hold any
      RPM reference. Disable the RPM-reference-held check for their duration.
    
    In all these cases we still check that the device is not suspended.
    These explicit annotations also have the positive side effect of
    documenting our assumptions better.
    
    This caught additional WARNs from the atomic modeset path, those should
    be fixed separately.
    
    v2:
    - remove the redundant HAS_RUNTIME_PM check (moved to patch 1) (Ville)
    v3:
    - use a new dedicated RPM wakelock refcount to also catch cases where
      our own RPM get/put functions were not called (Chris)
    - assert also that the new RPM wakelock refcount is 0 in the RPM
      suspend handler (Chris)
    - change the assert error message to be more meaningful (Chris)
    - prevent false assert errors and check that the RPM wakelock is 0 in
      the RPM resume handler too
    - prevent false assert errors in the hangcheck work too
    - add a device not suspended assert check to the hangcheck work
    v4:
    - rename disable/enable_rpm_asserts to disable/enable_rpm_wakeref_asserts
      and wakelock_count to wakeref_count
    - disable the wakeref asserts in the IRQ handlers and RPS work too
    - update/clarify commit message
    v5:
    - mark places we plan to change to use proper RPM refcounting with
      separate DISABLE/ENABLE_RPM_WAKEREF_ASSERTS aliases (Chris)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450227139-13471-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44ad3085695f..3ac616d7363b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -577,6 +577,8 @@ static int i915_drm_suspend(struct drm_device *dev)
 	dev_priv->modeset_restore = MODESET_SUSPENDED;
 	mutex_unlock(&dev_priv->modeset_restore_lock);
 
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
 	intel_display_set_init_power(dev_priv, true);
@@ -589,7 +591,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	if (error) {
 		dev_err(&dev->pdev->dev,
 			"GEM idle failed, resume might fail\n");
-		return error;
+		goto out;
 	}
 
 	intel_guc_suspend(dev);
@@ -632,7 +634,10 @@ static int i915_drm_suspend(struct drm_device *dev)
 	if (HAS_CSR(dev_priv))
 		flush_work(&dev_priv->csr.work);
 
-	return 0;
+out:
+	enable_rpm_wakeref_asserts(dev_priv);
+
+	return error;
 }
 
 static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
@@ -641,6 +646,8 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	bool fw_csr;
 	int ret;
 
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	fw_csr = suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
 	/*
 	 * In case of firmware assisted context save/restore don't manually
@@ -659,7 +666,7 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 		if (!fw_csr)
 			intel_power_domains_init_hw(dev_priv, true);
 
-		return ret;
+		goto out;
 	}
 
 	pci_disable_device(drm_dev->pdev);
@@ -680,7 +687,10 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 
 	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
 
-	return 0;
+out:
+	enable_rpm_wakeref_asserts(dev_priv);
+
+	return ret;
 }
 
 int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
@@ -711,6 +721,8 @@ static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	mutex_lock(&dev->struct_mutex);
 	i915_gem_restore_gtt_mappings(dev);
 	mutex_unlock(&dev->struct_mutex);
@@ -775,6 +787,8 @@ static int i915_drm_resume(struct drm_device *dev)
 
 	drm_kms_helper_poll_enable(dev);
 
+	enable_rpm_wakeref_asserts(dev_priv);
+
 	return 0;
 }
 
@@ -799,6 +813,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
@@ -820,6 +836,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 out:
 	dev_priv->suspended_to_idle = false;
 
+	enable_rpm_wakeref_asserts(dev_priv);
+
 	return ret;
 }
 
@@ -1452,6 +1470,9 @@ static int intel_runtime_suspend(struct device *device)
 
 		return -EAGAIN;
 	}
+
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	/*
 	 * We are safe here against re-faults, since the fault handler takes
 	 * an RPM reference.
@@ -1471,10 +1492,15 @@ static int intel_runtime_suspend(struct device *device)
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
 		intel_runtime_pm_enable_interrupts(dev_priv);
 
+		enable_rpm_wakeref_asserts(dev_priv);
+
 		return ret;
 	}
 
 	intel_uncore_forcewake_reset(dev, false);
+
+	enable_rpm_wakeref_asserts(dev_priv);
+	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
 	dev_priv->pm.suspended = true;
 
 	/*
@@ -1518,6 +1544,9 @@ static int intel_runtime_resume(struct device *device)
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
+	WARN_ON_ONCE(atomic_read(&dev_priv->pm.wakeref_count));
+	disable_rpm_wakeref_asserts(dev_priv);
+
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
@@ -1552,6 +1581,8 @@ static int intel_runtime_resume(struct device *device)
 
 	intel_enable_gt_powersave(dev);
 
+	enable_rpm_wakeref_asserts(dev_priv);
+
 	if (ret)
 		DRM_ERROR("Runtime resume failed, disabling it (%d)\n", ret);
 	else

commit 19c8054c4d82932d9f6bbf8d650aae4a1399a64d
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Dec 16 12:48:16 2015 +0200

    drm/i915: prefer for_each_intel_* macros for iteration
    
    Use the for_each_intel_* macros for iterating intel_encoder,
    intel_connector, and intel_crtc. No functional changes.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450262896-5325-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8ddfcce92cf1..44ad3085695f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -543,15 +543,12 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
-	struct drm_encoder *encoder;
+	struct intel_encoder *encoder;
 
 	drm_modeset_lock_all(dev);
-	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
-		struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
-
-		if (intel_encoder->suspend)
-			intel_encoder->suspend(intel_encoder);
-	}
+	for_each_intel_encoder(dev, encoder)
+		if (encoder->suspend)
+			encoder->suspend(encoder);
 	drm_modeset_unlock_all(dev);
 }
 

commit 666a45379e2c29bc16e60648e5ad8f6f8b7fa6ce
Author: Wayne Boyer <wayne.boyer@intel.com>
Date:   Wed Dec 9 12:29:35 2015 -0800

    drm/i915: Separate cherryview from valleyview
    
    The cherryview device shares many characteristics with the valleyview
    device.  When support was added to the driver for cherryview, the
    corresponding device info structure included .is_valleyview = 1.
    This is not correct and leads to some confusion.
    
    This patch changes .is_valleyview to .is_cherryview in the cherryview
    device info structure and simplifies the IS_CHERRYVIEW macro.
    Then where appropriate, instances of IS_VALLEYVIEW are replaced with
    IS_VALLEYVIEW || IS_CHERRYVIEW or equivalent.
    
    v2: Use IS_VALLEYVIEW || IS_CHERRYVIEW instead of defining a new macro.
        Also add followup patches to fix issues discovered during the first
        review. (Ville)
    v3: Fix some style issues and one gen check. Remove CRT related changes
        as CRT is not supported on CHV. (Imre, Ville)
    v4: Make a few more optimizations. (Ville)
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Wayne Boyer <wayne.boyer@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449692975-14803-1-git-send-email-wayne.boyer@intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 81862d5246d6..8ddfcce92cf1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -311,7 +311,7 @@ static const struct intel_device_info intel_cherryview_info = {
 	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.is_valleyview = 1,
+	.is_cherryview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
 	GEN_CHV_PIPEOFFSETS,
 	CURSOR_OFFSETS,
@@ -802,7 +802,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	if (IS_VALLEYVIEW(dev_priv))
+	if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
 		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
@@ -1533,7 +1533,7 @@ static int intel_runtime_resume(struct device *device)
 		ret = bxt_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv))
+	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, true);
 
 	/*
@@ -1550,7 +1550,7 @@ static int intel_runtime_resume(struct device *device)
 	 * power well, so hpd is reinitialized from there. For
 	 * everyone else do it here.
 	 */
-	if (!IS_VALLEYVIEW(dev_priv))
+	if (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
 		intel_hpd_init(dev_priv);
 
 	intel_enable_gt_powersave(dev);
@@ -1575,7 +1575,7 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 		ret = bxt_suspend_complete(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		ret = hsw_suspend_complete(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv))
+	else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))
 		ret = vlv_suspend_complete(dev_priv);
 	else
 		ret = 0;

commit 825f272895b9ec9151399b4102739c899b0b6392
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Wed Dec 9 15:56:13 2015 +0200

    drm/i915: Cancel hangcheck before GPU is suspended
    
    In order to avoid accessing GPU registers while GPU is suspended cancel
    the hangcheck work before calling intel_suspend_complete which actually
    puts the GPU to suspend. Otherwise hangcheck might do MMIO reads to a
    suspended GPU.
    
    Placement before intel_guc_suspend is imitated from i915_drm_suspend
    which cancels the work at i915_gem_suspend, to keep the functions
    similar.
    
    On VLV systems, namely BYT, this was causing an error during runtime
    suspend cycle:
    
    [drm:vlv_check_no_gt_access [i915]] *ERROR* GT register access while GT waking disabled
    
    Testcase: igt/pm_rpm/basic-rte
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=93121
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449669373-8588-1-git-send-email-joonas.lahtinen@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e6935f1cb689..81862d5246d6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1462,6 +1462,8 @@ static int intel_runtime_suspend(struct device *device)
 	i915_gem_release_all_mmaps(dev_priv);
 	mutex_unlock(&dev->struct_mutex);
 
+	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
+
 	intel_guc_suspend(dev);
 
 	intel_suspend_gt_powersave(dev);
@@ -1475,7 +1477,6 @@ static int intel_runtime_suspend(struct device *device)
 		return ret;
 	}
 
-	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 	intel_uncore_forcewake_reset(dev, false);
 	dev_priv->pm.suspended = true;
 

commit 15620206ae87ba9643ffa6f5ddb5471be7192006
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Fri Nov 6 14:11:16 2015 +0200

    drm/i915/skl: Add SKL GT4 PCI IDs
    
    Add Skylake Intel Graphics GT4 PCI IDs
    
    v2: Rebase
    
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446811876-303-1-git-send-email-mika.kuoppala@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 46ac66484dc7..e6935f1cb689 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -399,6 +399,7 @@ static const struct pci_device_id pciidlist[] = {
 	INTEL_SKL_GT1_IDS(&intel_skylake_info),
 	INTEL_SKL_GT2_IDS(&intel_skylake_info),
 	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
+	INTEL_SKL_GT4_IDS(&intel_skylake_gt3_info),
 	INTEL_BXT_IDS(&intel_broxton_info),
 	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
 	INTEL_KBL_GT2_IDS(&intel_kabylake_info),

commit a9287dbc26569ec187b8bca0093e0ffe28abe843
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 16:15:55 2015 +0100

    drm/i915: Restore skl_gt3 device info
    
    This was broken in
    
    commit 6a8beeffed3b2d33151150e3a03696e697f16d46
    Author: Wayne Boyer <wayne.boyer@intel.com>
    Date:   Wed Dec 2 13:28:14 2015 -0800
    
        drm/i915: Clean up device info structure definitions
    
    and I didn't spot this while reviewing. We really need that CI farm up
    asap!
    
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Wayne Boyer <wayne.boyer@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d2d7e2461fa6..46ac66484dc7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -324,6 +324,7 @@ static const struct intel_device_info intel_skylake_info = {
 };
 
 static const struct intel_device_info intel_skylake_gt3_info = {
+	HSW_FEATURES,
 	.is_skylake = 1,
 	.gen = 9,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,

commit 6a8beeffed3b2d33151150e3a03696e697f16d46
Author: Wayne Boyer <wayne.boyer@intel.com>
Date:   Wed Dec 2 13:28:14 2015 -0800

    drm/i915: Clean up device info structure definitions
    
    Beginning with gen7, newer devices repetitively redefine values
    for the device info structure members.  This patch simplifies the
    structure definitions by grouping member value definitions into the
    existing GEN7_FEATURES #define and into the new GEN7_LP_FEATURES
    and HSW_FEATURES #defines.
    
    Specifically, GEN_DEFAULT_PIPEOFFSETS and IVB_CURSOR_OFFSETS are
    added to GEN7_FEATURES and subsequent IVB definitions are simplified.
    
    VLV_FEATURES is defined to differentiate and simplify the
    gen7 low power (LP) devices.
    
    HSW_FEATURES is defined and used to simplify all HSW+ devices
    except for LP.
    
    v2: Use VLV_FEATURES for the gen7 low power devices. (Jani)
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Wayne Boyer <wayne.boyer@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449091694-7681-1-git-send-email-wayne.boyer@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 90faa8e03fca..d2d7e2461fa6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -228,121 +228,83 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1, \
 	.has_fbc = 1, \
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
-	.has_llc = 1
+	.has_llc = 1, \
+	GEN_DEFAULT_PIPEOFFSETS, \
+	IVB_CURSOR_OFFSETS
 
 static const struct intel_device_info intel_ivybridge_d_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.is_mobile = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_q_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.num_pipes = 0, /* legal, last one wins */
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
+#define VLV_FEATURES  \
+	.gen = 7, .num_pipes = 2, \
+	.need_gfx_hws = 1, .has_hotplug = 1, \
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
+	.display_mmio_offset = VLV_DISPLAY_BASE, \
+	GEN_DEFAULT_PIPEOFFSETS, \
+	CURSOR_OFFSETS
+
 static const struct intel_device_info intel_valleyview_m_info = {
-	GEN7_FEATURES,
-	.is_mobile = 1,
-	.num_pipes = 2,
+	VLV_FEATURES,
 	.is_valleyview = 1,
-	.display_mmio_offset = VLV_DISPLAY_BASE,
-	.has_fbc = 0, /* legal, last one wins */
-	.has_llc = 0, /* legal, last one wins */
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
+	.is_mobile = 1,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
-	GEN7_FEATURES,
-	.num_pipes = 2,
+	VLV_FEATURES,
 	.is_valleyview = 1,
-	.display_mmio_offset = VLV_DISPLAY_BASE,
-	.has_fbc = 0, /* legal, last one wins */
-	.has_llc = 0, /* legal, last one wins */
-	GEN_DEFAULT_PIPEOFFSETS,
-	CURSOR_OFFSETS,
 };
 
+#define HSW_FEATURES  \
+	GEN7_FEATURES, \
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING, \
+	.has_ddi = 1, \
+	.has_fpga_dbg = 1
+
 static const struct intel_device_info intel_haswell_d_info = {
-	GEN7_FEATURES,
+	HSW_FEATURES,
 	.is_haswell = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
-	GEN7_FEATURES,
+	HSW_FEATURES,
 	.is_haswell = 1,
 	.is_mobile = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_d_info = {
-	.gen = 8, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
+	HSW_FEATURES,
+	.gen = 8,
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
-	.gen = 8, .is_mobile = 1, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
+	HSW_FEATURES,
+	.gen = 8, .is_mobile = 1,
 };
 
 static const struct intel_device_info intel_broadwell_gt3d_info = {
-	.gen = 8, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
+	HSW_FEATURES,
+	.gen = 8,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_gt3m_info = {
-	.gen = 8, .is_mobile = 1, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
+	HSW_FEATURES,
+	.gen = 8, .is_mobile = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_cherryview_info = {
@@ -356,29 +318,15 @@ static const struct intel_device_info intel_cherryview_info = {
 };
 
 static const struct intel_device_info intel_skylake_info = {
+	HSW_FEATURES,
 	.is_skylake = 1,
-	.gen = 9, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
+	.gen = 9,
 };
 
 static const struct intel_device_info intel_skylake_gt3_info = {
 	.is_skylake = 1,
-	.gen = 9, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
+	.gen = 9,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broxton_info = {
@@ -396,33 +344,18 @@ static const struct intel_device_info intel_broxton_info = {
 };
 
 static const struct intel_device_info intel_kabylake_info = {
+	HSW_FEATURES,
 	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,
-	.num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_kabylake_gt3_info = {
+	HSW_FEATURES,
 	.is_preliminary = 1,
 	.is_kabylake = 1,
 	.gen = 9,
-	.num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
-	.has_llc = 1,
-	.has_ddi = 1,
-	.has_fpga_dbg = 1,
-	.has_fbc = 1,
-	GEN_DEFAULT_PIPEOFFSETS,
-	IVB_CURSOR_OFFSETS,
 };
 
 /*

commit 39bfcd5235e07e95ad3e70eab8e0b85db181de9e
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Thu Nov 26 12:03:51 2015 +0100

    drm/i915: more virtual south bridge detection
    
    Commit "30c964a drm/i915: Detect virtual south bridge" detects and
    handles the southbridge emulated by vmware esx.  Add the ich9 south
    bridge emulated by 'qemu -M q35'.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 649e20aaa3ff..90faa8e03fca 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -565,7 +565,8 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev) &&
 					!IS_KABYLAKE(dev));
-			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE) {
+			} else if ((id == INTEL_PCH_P2X_DEVICE_ID_TYPE) ||
+				   (id == INTEL_PCH_QEMU_DEVICE_ID_TYPE)) {
 				dev_priv->pch_type = intel_virt_detect_pch(dev);
 			} else
 				continue;

commit bc87229f323e6b5ee9ac57817463fb2ff65e6811
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Nov 18 17:32:30 2015 +0200

    drm/i915/skl: enable PC9/10 power states during suspend-to-idle
    
    During suspend-to-idle we need to keep the DMC firmware active and DC6
    enabled, since otherwise we won't reach deep system power states like
    PC9/10. The lead for this came from Nivedita who noticed that the
    kernel's turbostat tool didn't report any PC9/10 residency change
    across an 'echo freeze > /sys/power/state'.
    
    Reported-by: Nivedita Swaminathan <nivedita.swaminathan@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447860750-18110-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6344dfb72177..649e20aaa3ff 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -624,6 +624,14 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 			      bool rpm_resume);
 static int bxt_resume_prepare(struct drm_i915_private *dev_priv);
 
+static bool suspend_to_idle(struct drm_i915_private *dev_priv)
+{
+#if IS_ENABLED(CONFIG_ACPI_SLEEP)
+	if (acpi_target_system_state() < ACPI_STATE_S3)
+		return true;
+#endif
+	return false;
+}
 
 static int i915_drm_suspend(struct drm_device *dev)
 {
@@ -676,11 +684,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	i915_save_state(dev);
 
-	opregion_target_state = PCI_D3cold;
-#if IS_ENABLED(CONFIG_ACPI_SLEEP)
-	if (acpi_target_system_state() < ACPI_STATE_S3)
-		opregion_target_state = PCI_D1;
-#endif
+	opregion_target_state = suspend_to_idle(dev_priv) ? PCI_D1 : PCI_D3cold;
 	intel_opregion_notify_adapter(dev, opregion_target_state);
 
 	intel_uncore_forcewake_reset(dev, false);
@@ -701,15 +705,26 @@ static int i915_drm_suspend(struct drm_device *dev)
 static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = drm_dev->dev_private;
+	bool fw_csr;
 	int ret;
 
-	intel_power_domains_suspend(dev_priv);
+	fw_csr = suspend_to_idle(dev_priv) && dev_priv->csr.dmc_payload;
+	/*
+	 * In case of firmware assisted context save/restore don't manually
+	 * deinit the power domains. This also means the CSR/DMC firmware will
+	 * stay active, it will power down any HW resources as required and
+	 * also enable deeper system power states that would be blocked if the
+	 * firmware was inactive.
+	 */
+	if (!fw_csr)
+		intel_power_domains_suspend(dev_priv);
 
 	ret = intel_suspend_complete(dev_priv);
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
-		intel_power_domains_init_hw(dev_priv, true);
+		if (!fw_csr)
+			intel_power_domains_init_hw(dev_priv, true);
 
 		return ret;
 	}
@@ -730,6 +745,8 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	if (!(hibernation && INTEL_INFO(dev_priv)->gen < 6))
 		pci_set_power_state(drm_dev->pdev, PCI_D3hot);
 
+	dev_priv->suspended_to_idle = suspend_to_idle(dev_priv);
+
 	return 0;
 }
 
@@ -842,8 +859,10 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	 * FIXME: This should be solved with a special hdmi sink device or
 	 * similar so that power domains can be employed.
 	 */
-	if (pci_enable_device(dev->pdev))
-		return -EIO;
+	if (pci_enable_device(dev->pdev)) {
+		ret = -EIO;
+		goto out;
+	}
 
 	pci_set_master(dev->pdev);
 
@@ -861,7 +880,12 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		hsw_disable_pc8(dev_priv);
 
 	intel_uncore_sanitize(dev);
-	intel_power_domains_init_hw(dev_priv, true);
+
+	if (!(dev_priv->suspended_to_idle && dev_priv->csr.dmc_payload))
+		intel_power_domains_init_hw(dev_priv, true);
+
+out:
+	dev_priv->suspended_to_idle = false;
 
 	return ret;
 }

commit a03bc7cd633760ae0312327b6e30ec8fe962a798
Author: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
Date:   Mon Nov 9 16:48:27 2015 +0100

    drm/i915/skl: Remove unused suspend and resume callbacks
    
    Signed-off-by: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447084107-8521-13-git-send-email-patrik.jakobsson@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5c0ce29acda2..6344dfb72177 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -622,7 +622,6 @@ static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 static int intel_suspend_complete(struct drm_i915_private *dev_priv);
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 			      bool rpm_resume);
-static int skl_resume_prepare(struct drm_i915_private *dev_priv);
 static int bxt_resume_prepare(struct drm_i915_private *dev_priv);
 
 
@@ -858,8 +857,6 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
-		ret = skl_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 
@@ -1071,11 +1068,6 @@ static int i915_pm_resume(struct device *dev)
 	return i915_drm_resume(drm_dev);
 }
 
-static int skl_suspend_complete(struct drm_i915_private *dev_priv)
-{
-	return 0;
-}
-
 static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
@@ -1115,11 +1107,6 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
-static int skl_resume_prepare(struct drm_i915_private *dev_priv)
-{
-	return 0;
-}
-
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1583,8 +1570,6 @@ static int intel_runtime_resume(struct device *device)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev))
-		ret = skl_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 	else if (IS_VALLEYVIEW(dev_priv))
@@ -1627,8 +1612,6 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 
 	if (IS_BROXTON(dev_priv))
 		ret = bxt_suspend_complete(dev_priv);
-	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
-		ret = skl_suspend_complete(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		ret = hsw_suspend_complete(dev_priv);
 	else if (IS_VALLEYVIEW(dev_priv))

commit 9f836f9016ad5320e0c9230419d2102cf15a28aa
Author: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
Date:   Mon Nov 16 16:20:01 2015 +0100

    drm/i915/gen9: Turn DC handling into a power well
    
    Handle DC off as a power well where enabling the power well will prevent
    the DMC to enter selected DC states (required around modesets and Aux
    A). Disabling the power well will allow DC states again. For now the
    highest DC state is DC6 for Skylake and DC5 for Broxton but will be
    configurable for Skylake in a later patch.
    
    v2: Check both DC5 and DC6 bits in power well enabled function (Ville)
    v3:
    - Remove unneeded DC_OFF case in skl_set_power_well() (Imre)
    - Add PW2 dependency to DC_OFF (Imre)
    v4: Put DC_OFF before PW2 in BXT power well array
    
    Signed-off-by: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    [fixed line over 80 and parenthesis alignment checkpatch warns (imre)]
    Link: http://patchwork.freedesktop.org/patch/msgid/1447687201-24759-1-git-send-email-patrik.jakobsson@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8ea1896e3e83..5c0ce29acda2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1073,9 +1073,6 @@ static int i915_pm_resume(struct device *dev)
 
 static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	if (dev_priv->csr.dmc_payload)
-		skl_enable_dc6(dev_priv);
-
 	return 0;
 }
 
@@ -1120,9 +1117,6 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 
 static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 {
-	if (dev_priv->csr.dmc_payload)
-		skl_disable_dc6(dev_priv);
-
 	return 0;
 }
 

commit 73dfc227ff5c8e005120daefc19b8521b1adc203
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Nov 17 17:33:53 2015 +0200

    drm/i915/skl: init/uninit display core as part of the HW power domain state
    
    We need to initialize the display core part early, before initializing
    the rest of the display power state. This is also described in the bspec
    termed "Display initialization sequence". Atm we run this sequence
    during driver loading after power domain HW state initialization which
    is too late and during runtime suspend/resume which is unneeded and can
    interere with DMC functionality which handles HW resources toggled
    by this init/uninit sequence automatically. The init sequence must be
    run as the first step of HW power state initialization and during
    system resume. The uninit sequence must be run during system suspend.
    
    To address the above move the init sequence to the initial HW power
    state setup and the uninit sequence to a new power domains suspend
    function called during system suspend.
    
    As part of the init sequence we also have to reprogram the DMC firmware
    as it's lost across a system suspend/resume cycle.
    
    After this change CD clock initialization during driver loading will
    happen only later after other dependent HW/SW parts are initialized,
    while during system resume it will get initialized as the last step of
    the init sequence. This distinction can be removed by some refactoring
    of platform independent parts. I left this refactoring out from this
    series since I didn't want to change non-SKL parts. This is a TODO for
    later.
    
    v2:
    - fix error path in i915_drm_suspend_late()
    - don't try to re-program the DMC firmware if it failed to load
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Patrik Jakobsson <patrik.jakobsson@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447774433-20834-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 858d58cfbbd1..8ea1896e3e83 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -704,10 +704,13 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	struct drm_i915_private *dev_priv = drm_dev->dev_private;
 	int ret;
 
+	intel_power_domains_suspend(dev_priv);
+
 	ret = intel_suspend_complete(dev_priv);
 
 	if (ret) {
 		DRM_ERROR("Suspend complete failed: %d\n", ret);
+		intel_power_domains_init_hw(dev_priv, true);
 
 		return ret;
 	}
@@ -861,7 +864,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 		hsw_disable_pc8(dev_priv);
 
 	intel_uncore_sanitize(dev);
-	intel_power_domains_init_hw(dev_priv);
+	intel_power_domains_init_hw(dev_priv, true);
 
 	return ret;
 }
@@ -1070,8 +1073,6 @@ static int i915_pm_resume(struct device *dev)
 
 static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	skl_uninit_cdclk(dev_priv);
-
 	if (dev_priv->csr.dmc_payload)
 		skl_enable_dc6(dev_priv);
 
@@ -1122,9 +1123,6 @@ static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 	if (dev_priv->csr.dmc_payload)
 		skl_disable_dc6(dev_priv);
 
-	skl_init_cdclk(dev_priv);
-	intel_csr_load_program(dev_priv);
-
 	return 0;
 }
 

commit f514c2d8428584431fc0a3b64a4c3c7b8df3e3ae
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Oct 28 23:59:06 2015 +0200

    drm/i915/gen9: flush DMC fw loading work during system suspend
    
    Currently during system s/r we enable/disable DC6, so before we do so
    make sure that the firmware loading is complete.
    
    Note that whether we need to enable DC6 for S3/S4 is still open.  At
    least the firmware program is lost during S3 and we need to reprogram it
    after resuming. Until this is clarified we keep the current behavior and
    enable/disable DC6.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Animesh Manna <animesh.manna@intel.com>
    Tested-by: Daniel Stone <daniels@collabora.com> # SKL
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446069547-24760-13-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 37319b081b8d..858d58cfbbd1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -693,6 +693,9 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	intel_display_set_init_power(dev_priv, false);
 
+	if (HAS_CSR(dev_priv))
+		flush_work(&dev_priv->csr.work);
+
 	return 0;
 }
 

commit 15e72c1fc118731970ab1a94fb894039b8abfff4
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Wed Oct 28 23:59:05 2015 +0200

    drm/i915/gen9: Use flush_work to synchronize with dmc loader
    
    During driver unload to ensure we dont have any pending task,
    flush_work added to complete firmware loading task.
    
    v1: Initial version.
    
    v2: As per review comments from Daniel,
    Removed flush_work from skl_set_power_well. As we have taken
    power well refernece and rpm count during firmware loading
    by using display_power_domain_get/put - this will always
    ensure rpm will be blocked if firmware is not loaded.
    
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Tested-by: Daniel Stone <daniels@collabora.com> # SKL
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446069547-24760-12-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d678b15f7467..37319b081b8d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1067,8 +1067,6 @@ static int i915_pm_resume(struct device *dev)
 
 static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	/* Enabling DC6 is not a hard requirement to enter runtime D3 */
-
 	skl_uninit_cdclk(dev_priv);
 
 	if (dev_priv->csr.dmc_payload)

commit f4448375467d9443a1e74e0552212121b6394332
Author: Daniel Vetter <daniel.vetter@intel.com>
Date:   Wed Oct 28 23:59:02 2015 +0200

    drm/i915/gen9: Use dev_priv in csr functions
    
    As all csr firmware related opertion are not using any
    any data structures of drm framework level, so better to
    use dev_priv instead of dev. it's a new style! :)
    
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Tested-by: Daniel Stone <daniels@collabora.com> # SKL
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446069547-24760-9-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c605fd40d6c3..d678b15f7467 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1118,13 +1118,11 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 
 static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
-
 	if (dev_priv->csr.dmc_payload)
 		skl_disable_dc6(dev_priv);
 
 	skl_init_cdclk(dev_priv);
-	intel_csr_load_program(dev);
+	intel_csr_load_program(dev_priv);
 
 	return 0;
 }

commit c729ed88af7b5266325d324672c4fdf8debd70a9
Author: Daniel Vetter <daniel.vetter@intel.com>
Date:   Wed Oct 28 23:59:00 2015 +0200

    drm/i915/gen9: Simplify csr loading failure printing.
    
    If we really want to we can be more verbose here, but we really don't
    need an entire function for this.
    
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Tested-by: Daniel Stone <daniels@collabora.com> # SKL
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446069547-24760-7-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aa34fcb0bdc2..c605fd40d6c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -604,26 +604,6 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return true;
 }
 
-void i915_firmware_load_error_print(const char *fw_path, int err)
-{
-	DRM_ERROR("failed to load firmware %s (%d)\n", fw_path, err);
-
-	/*
-	 * If the reason is not known assume -ENOENT since that's the most
-	 * usual failure mode.
-	 */
-	if (!err)
-		err = -ENOENT;
-
-	if (!(IS_BUILTIN(CONFIG_DRM_I915) && err == -ENOENT))
-		return;
-
-	DRM_ERROR(
-	  "The driver is built-in, so to load the firmware you need to\n"
-	  "include it either in the kernel (see CONFIG_EXTRA_FIRMWARE) or\n"
-	  "in your initrd/initramfs image.\n");
-}
-
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;

commit 414b7999b8bef3d79c563d8305b1df18da701634
Author: Daniel Vetter <daniel.vetter@intel.com>
Date:   Thu Nov 12 17:10:37 2015 +0200

    drm/i915/gen9: Remove csr.state, csr_lock and related code.
    
    This removes two anti-patterns:
    - Locking shouldn't be used to synchronize with async work (of any
      form, whether callbacks, workers or other threads). This is what the
      mutex_lock/unlock seems to have been for in intel_csr_load_program.
      Instead ordering should be ensured with the generic
      wait_for_completion()/complete(). Or more specific functions
      provided by the core kernel like e.g.
      flush_work()/cancel_work_sync() in the case of synchronizing with a
      work item.
    
    - Don't invent own completion like the following code did with the
      (already removed) wait_for(csr_load_status_get()) pattern - it's
      really hard to get these right when you want them to be _really_
      correct (and be fast) in all cases. Furthermore it's easier to read
      code using the well-known primitives than new ones using
      non-standard names.
    
    Before enabling/disabling DC6 check if the firmware is loaded
    successfully. This is guaranteed during runtime s/r, since otherwise we
    don't enable RPM, but not during system s/r.
    
    Note that it's still unclear whether we need to enable/disable DC6
    during system s/r, until that's clarified, keep the current behavior and
    enable/disable DC6.
    
    Also after this patch there is a race during system s/r where the
    firmware may not be loaded yet, that's addressed in an upcoming patch.
    
    v2-v3:
    - unchanged
    v4:
    - rebased on latest drm-intel-nightly
    
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    [imre: added code and note about checking if the firmware loaded ok,
     before enabling/disabling it]
    Reviewed-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Tested-by: Daniel Stone <daniels@collabora.com> # SKL
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447341037-2623-1-git-send-email-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9f552094b41b..aa34fcb0bdc2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1087,18 +1087,11 @@ static int i915_pm_resume(struct device *dev)
 
 static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	enum csr_state state;
 	/* Enabling DC6 is not a hard requirement to enter runtime D3 */
 
 	skl_uninit_cdclk(dev_priv);
 
-	/* TODO: wait for a completion event or
-	 * similar here instead of busy
-	 * waiting using wait_for function.
-	 */
-	wait_for((state = intel_csr_load_status_get(dev_priv)) !=
-			FW_UNINITIALIZED, 1000);
-	if (state == FW_LOADED)
+	if (dev_priv->csr.dmc_payload)
 		skl_enable_dc6(dev_priv);
 
 	return 0;
@@ -1147,7 +1140,7 @@ static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
-	if (intel_csr_load_status_get(dev_priv) == FW_LOADED)
+	if (dev_priv->csr.dmc_payload)
 		skl_disable_dc6(dev_priv);
 
 	skl_init_cdclk(dev_priv);

commit 8b10c0cf21ec84618d4bf02c73c0543500ece68d
Author: Deepak S <deepak.s@intel.com>
Date:   Wed Oct 28 12:21:12 2015 -0700

    drm/i915/kbl: Add Kabylake GT4 PCI ID
    
    v2: (Rodrigo) Rebase after commit 3cb27f38f
        ("drm/i915: remove an extra level of indirection in PCI ID list")
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Deepak S <deepak.s@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446060072-19489-1-git-send-email-rodrigo.vivi@intel.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f020daadc16d..9f552094b41b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -469,6 +469,7 @@ static const struct pci_device_id pciidlist[] = {
 	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
 	INTEL_KBL_GT2_IDS(&intel_kabylake_info),
 	INTEL_KBL_GT3_IDS(&intel_kabylake_gt3_info),
+	INTEL_KBL_GT4_IDS(&intel_kabylake_gt3_info),
 	{0, 0, 0}
 };
 

commit d97044b661d0d56b2a2ae9b2b95ab0b359b417dc
Author: Deepak S <deepak.s@intel.com>
Date:   Wed Oct 28 12:19:51 2015 -0700

    drm/i915/kbl: Add Kabylake PCI ID
    
    v2: separate out device info into different GT (Damien)
    v3: Add is_kabylake to the KBL gt3 structuer (Damien)
        Sort the platforms in older -> newer order (Damien)
    
    v4: Split platform definition since is_skylake=1 on
        kabylake structure was Nacked. (Rodrigo)
    
    v5: (Rodrigo) Rebase after commit 3cb27f38f
    ("drm/i915: remove an extra level of indirection in PCI ID list")
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Deepak S <deepak.s@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446059991-17033-1-git-send-email-rodrigo.vivi@intel.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7b29aeeae29e..f020daadc16d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -466,6 +466,9 @@ static const struct pci_device_id pciidlist[] = {
 	INTEL_SKL_GT2_IDS(&intel_skylake_info),
 	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
 	INTEL_BXT_IDS(&intel_broxton_info),
+	INTEL_KBL_GT1_IDS(&intel_kabylake_info),
+	INTEL_KBL_GT2_IDS(&intel_kabylake_info),
+	INTEL_KBL_GT3_IDS(&intel_kabylake_gt3_info),
 	{0, 0, 0}
 };
 

commit ef11bdb3e00a3f0b30018b0f5d74b9da1566ecb7
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Wed Oct 28 04:16:45 2015 -0700

    drm/i915/kbl: Introduce Kabylake platform defition.
    
    Kabylake is a Intel® Processor containing Intel® HD Graphics
    following Skylake.
    
    It is Gen9p5, so it inherits everything from Skylake.
    
    Let's start by adding the platform separated from Skylake
    but reusing most of all features, functions etc. Later we
    rebase the PCI-ID patch without is_skylake=1
    so we don't replace what original Author did there.
    
    Few IS_SKYLAKEs if statements are not being covered by this patch
    on purpose:
       - Workarounds: Kabylake is derivated from Skylake H0 so no
                      W/As apply here.
       - GuC: A following patch removes Kabylake support with an
              explanation: No firmware available yet.
       - DMC/CSR: Done in a separated patch since we need to be carefull
                  and load the version for revision 7 since
                  Kabylake is Skylake H0.
    
    v2: relative cleaner commit message and added the missed
        IS_KABYLAKE to intel_i2c.c as pointed out by Jani.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 64b3fa83e39e..7b29aeeae29e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -395,6 +395,36 @@ static const struct intel_device_info intel_broxton_info = {
 	IVB_CURSOR_OFFSETS,
 };
 
+static const struct intel_device_info intel_kabylake_info = {
+	.is_preliminary = 1,
+	.is_kabylake = 1,
+	.gen = 9,
+	.num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	.has_fpga_dbg = 1,
+	.has_fbc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+};
+
+static const struct intel_device_info intel_kabylake_gt3_info = {
+	.is_preliminary = 1,
+	.is_kabylake = 1,
+	.gen = 9,
+	.num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	.has_fpga_dbg = 1,
+	.has_fbc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -461,7 +491,7 @@ static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		ret = PCH_LPT;
 		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
-	} else if (IS_SKYLAKE(dev)) {
+	} else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {
 		ret = PCH_SPT;
 		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
 	}
@@ -524,11 +554,13 @@ void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev));
+				WARN_ON(!IS_SKYLAKE(dev) &&
+					!IS_KABYLAKE(dev));
 			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
-				WARN_ON(!IS_SKYLAKE(dev));
+				WARN_ON(!IS_SKYLAKE(dev) &&
+					!IS_KABYLAKE(dev));
 			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = intel_virt_detect_pch(dev);
 			} else
@@ -836,7 +868,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_SKYLAKE(dev_priv))
+	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
 		ret = skl_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
@@ -1583,7 +1615,7 @@ static int intel_runtime_resume(struct device *device)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_resume_prepare(dev_priv);
-	else if (IS_SKYLAKE(dev))
+	else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev))
 		ret = skl_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
@@ -1627,7 +1659,7 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 
 	if (IS_BROXTON(dev_priv))
 		ret = bxt_suspend_complete(dev_priv);
-	else if (IS_SKYLAKE(dev_priv))
+	else if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
 		ret = skl_suspend_complete(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		ret = hsw_suspend_complete(dev_priv);

commit 7526ac195c77d5f95731b73c634aa31f13382013
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Oct 27 10:14:54 2015 -0700

    drm/i915: Define IS_BROXTON properly.
    
    Kabylake will also be defined as gen9 and !is_skylake.
    So we need start by creating a proper Broxton
    definition, otherwise we will break broxton with the
    introduction of Kabylake.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445966099-1640-2-git-send-email-rodrigo.vivi@intel.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 121c5394fa51..64b3fa83e39e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -383,6 +383,7 @@ static const struct intel_device_info intel_skylake_gt3_info = {
 
 static const struct intel_device_info intel_broxton_info = {
 	.is_preliminary = 1,
+	.is_broxton = 1,
 	.gen = 9,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,

commit 3cb27f38f2075964bedc5cafb6b25518809180be
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Oct 28 19:33:09 2015 +0200

    drm/i915: remove an extra level of indirection in PCI ID list
    
    Add the PCI IDs directly in the pciidlist array instead of defining an
    extra macro. The minor benefit from this is neater diffs when adding to
    the end of the list.
    
    v2: drop the "aka" comment (Ville)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446053589-21283-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b1f1dec05274..121c5394fa51 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -400,44 +400,41 @@ static const struct intel_device_info intel_broxton_info = {
  * and subvendor IDs, we need it to come before the more general IVB
  * PCI ID matches, otherwise we'll use the wrong info struct above.
  */
-#define INTEL_PCI_IDS \
-	INTEL_I830_IDS(&intel_i830_info),	\
-	INTEL_I845G_IDS(&intel_845g_info),	\
-	INTEL_I85X_IDS(&intel_i85x_info),	\
-	INTEL_I865G_IDS(&intel_i865g_info),	\
-	INTEL_I915G_IDS(&intel_i915g_info),	\
-	INTEL_I915GM_IDS(&intel_i915gm_info),	\
-	INTEL_I945G_IDS(&intel_i945g_info),	\
-	INTEL_I945GM_IDS(&intel_i945gm_info),	\
-	INTEL_I965G_IDS(&intel_i965g_info),	\
-	INTEL_G33_IDS(&intel_g33_info),		\
-	INTEL_I965GM_IDS(&intel_i965gm_info),	\
-	INTEL_GM45_IDS(&intel_gm45_info), 	\
-	INTEL_G45_IDS(&intel_g45_info), 	\
-	INTEL_PINEVIEW_IDS(&intel_pineview_info),	\
-	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),	\
-	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),	\
-	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),	\
-	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),	\
-	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */ \
-	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),	\
-	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),	\
-	INTEL_HSW_D_IDS(&intel_haswell_d_info), \
-	INTEL_HSW_M_IDS(&intel_haswell_m_info), \
-	INTEL_VLV_M_IDS(&intel_valleyview_m_info),	\
-	INTEL_VLV_D_IDS(&intel_valleyview_d_info),	\
-	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),	\
-	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),	\
-	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),	\
-	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info), \
-	INTEL_CHV_IDS(&intel_cherryview_info),	\
-	INTEL_SKL_GT1_IDS(&intel_skylake_info),	\
-	INTEL_SKL_GT2_IDS(&intel_skylake_info),	\
-	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),	\
-	INTEL_BXT_IDS(&intel_broxton_info)
-
-static const struct pci_device_id pciidlist[] = {		/* aka */
-	INTEL_PCI_IDS,
+static const struct pci_device_id pciidlist[] = {
+	INTEL_I830_IDS(&intel_i830_info),
+	INTEL_I845G_IDS(&intel_845g_info),
+	INTEL_I85X_IDS(&intel_i85x_info),
+	INTEL_I865G_IDS(&intel_i865g_info),
+	INTEL_I915G_IDS(&intel_i915g_info),
+	INTEL_I915GM_IDS(&intel_i915gm_info),
+	INTEL_I945G_IDS(&intel_i945g_info),
+	INTEL_I945GM_IDS(&intel_i945gm_info),
+	INTEL_I965G_IDS(&intel_i965g_info),
+	INTEL_G33_IDS(&intel_g33_info),
+	INTEL_I965GM_IDS(&intel_i965gm_info),
+	INTEL_GM45_IDS(&intel_gm45_info),
+	INTEL_G45_IDS(&intel_g45_info),
+	INTEL_PINEVIEW_IDS(&intel_pineview_info),
+	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),
+	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),
+	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),
+	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),
+	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */
+	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),
+	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),
+	INTEL_HSW_D_IDS(&intel_haswell_d_info),
+	INTEL_HSW_M_IDS(&intel_haswell_m_info),
+	INTEL_VLV_M_IDS(&intel_valleyview_m_info),
+	INTEL_VLV_D_IDS(&intel_valleyview_d_info),
+	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),
+	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),
+	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),
+	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info),
+	INTEL_CHV_IDS(&intel_cherryview_info),
+	INTEL_SKL_GT1_IDS(&intel_skylake_info),
+	INTEL_SKL_GT2_IDS(&intel_skylake_info),
+	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),
+	INTEL_BXT_IDS(&intel_broxton_info),
 	{0, 0, 0}
 };
 

commit 0a9d2bed5557e7d870761eede982f2d9d08f87f4
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Tue Sep 29 11:01:59 2015 +0530

    drm/i915/skl: Making DC6 entry is the last call in suspend flow.
    
    Mmio register access after dc6/dc5 entry is not allowed when
    DC6 power states are enabled according to bspec (bspec-id 0527),
    so enabling dc6 as the last call in suspend flow.
    
    Addtional note from Imre:
    
    Currently we keep DC6 enabled during modesets and DPAUX transfers, which
    is not allowed according to the specification. This can lead at least to
    PLL locking failures, DPAUX timeouts and prevent deeper package power
    states (PC9/10). Fix this for now by enabling DC6 only when we know the
    above events (modeset, DPAUX) can't happen.
    
    This a temporary solution as some issues are still unsolved as described
    in [1] and [2], we'll address those as a follow-up.
    
    [1]
    http://lists.freedesktop.org/archives/intel-gfx/2015-October/077669.html
    [2]
    http://lists.freedesktop.org/archives/intel-gfx/2015-October/077787.html
    
    v1: Initial version.
    
    v2: Based on review comment from Daniel,
    - created a seperate patch for csr uninitialization set call.
    
    v3: Rebased on top of latest code.
    
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Vathsala Nagaraju <vathsala.nagaraju@intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 760e0ce4aa26..b1f1dec05274 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1053,10 +1053,20 @@ static int i915_pm_resume(struct device *dev)
 
 static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
+	enum csr_state state;
 	/* Enabling DC6 is not a hard requirement to enter runtime D3 */
 
 	skl_uninit_cdclk(dev_priv);
 
+	/* TODO: wait for a completion event or
+	 * similar here instead of busy
+	 * waiting using wait_for function.
+	 */
+	wait_for((state = intel_csr_load_status_get(dev_priv)) !=
+			FW_UNINITIALIZED, 1000);
+	if (state == FW_LOADED)
+		skl_enable_dc6(dev_priv);
+
 	return 0;
 }
 
@@ -1103,6 +1113,9 @@ static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
+	if (intel_csr_load_status_get(dev_priv) == FW_LOADED)
+		skl_disable_dc6(dev_priv);
+
 	skl_init_cdclk(dev_priv);
 	intel_csr_load_program(dev);
 

commit a1c4199414539d7eea34e416fb64fb5178221381
Author: Alex Dai <yu.dai@intel.com>
Date:   Wed Sep 30 09:46:37 2015 -0700

    drm/i915/guc: Add host2guc notification for suspend and resume
    
    Add host2guc interface to notify GuC power state changes when
    enter or resume from power saving state.
    
    v3: Move intel_guc_suspend to i915_drm_suspend for consistency.
    
    v2: Add GuC suspend/resume to runtime suspend/resume too
    
    v1: Change to a more flexible way when fill host to GuC scratch
    data in order to remove hard coding.
    
    Signed-off-by: Alex Dai <yu.dai@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1cb6b82e17d4..760e0ce4aa26 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -638,6 +638,8 @@ static int i915_drm_suspend(struct drm_device *dev)
 		return error;
 	}
 
+	intel_guc_suspend(dev);
+
 	intel_suspend_gt_powersave(dev);
 
 	/*
@@ -767,6 +769,8 @@ static int i915_drm_resume(struct drm_device *dev)
 	}
 	mutex_unlock(&dev->struct_mutex);
 
+	intel_guc_resume(dev);
+
 	intel_modeset_init_hw(dev);
 
 	spin_lock_irq(&dev_priv->irq_lock);
@@ -1500,6 +1504,8 @@ static int intel_runtime_suspend(struct device *device)
 	i915_gem_release_all_mmaps(dev_priv);
 	mutex_unlock(&dev->struct_mutex);
 
+	intel_guc_suspend(dev);
+
 	intel_suspend_gt_powersave(dev);
 	intel_runtime_pm_disable_interrupts(dev_priv);
 
@@ -1559,6 +1565,8 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
+	intel_guc_resume(dev);
+
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev);
 

commit c268444a2cecabc0ab567ca275662d80fa0ac813
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Wed Aug 26 01:36:06 2015 +0530

    drm/i915/skl Remove the call for csr uninitialization from suspend path
    
    This patch remove the function call to set the firmware
    loading status as uninitialized during suspend.
    
    Dmc firmware will restore the firmware in normal suspend. In previous
    patch added a check to directly read the hardware status and load
    the firmware if got reset during resume from suspend-hibernation.
    
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Vathsala Nagaraju <vathsala.nagaraju@intel.com>
    Reviewed-by: A.Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b31485a8bd39..1cb6b82e17d4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1051,12 +1051,6 @@ static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	/* Enabling DC6 is not a hard requirement to enter runtime D3 */
 
-	/*
-	 * This is to ensure that CSR isn't identified as loaded before
-	 * CSR-loading program is called during runtime-resume.
-	 */
-	intel_csr_load_status_set(dev_priv, FW_UNINITIALIZED);
-
 	skl_uninit_cdclk(dev_priv);
 
 	return 0;

commit 30c964a6cb7bbade28eabcbc3fce4b01be8f1a39
Author: Robert Beckett <robert.beckett@intel.com>
Date:   Fri Aug 28 13:10:22 2015 +0100

    drm/i915: Detect virtual south bridge
    
    Virtualized systems often use a virtual P2X4 south bridge.
    Detect this in intel_detect_pch and make a best guess as to which PCH
    we should be using.
    
    This was seen on vmware esxi hypervisor. When passing the graphics device
    through to a guest, it can not pass through the PCH. Instead it simulates
    a P2X4 southbridge.
    
    Signed-off-by: Robert Beckett <robert.beckett@intel.com>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e6d7a69ec1bf..b31485a8bd39 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -443,6 +443,34 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 
 MODULE_DEVICE_TABLE(pci, pciidlist);
 
+static enum intel_pch intel_virt_detect_pch(struct drm_device *dev)
+{
+	enum intel_pch ret = PCH_NOP;
+
+	/*
+	 * In a virtualized passthrough environment we can be in a
+	 * setup where the ISA bridge is not able to be passed through.
+	 * In this case, a south bridge can be emulated and we have to
+	 * make an educated guess as to which PCH is really there.
+	 */
+
+	if (IS_GEN5(dev)) {
+		ret = PCH_IBX;
+		DRM_DEBUG_KMS("Assuming Ibex Peak PCH\n");
+	} else if (IS_GEN6(dev) || IS_IVYBRIDGE(dev)) {
+		ret = PCH_CPT;
+		DRM_DEBUG_KMS("Assuming CouarPoint PCH\n");
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = PCH_LPT;
+		DRM_DEBUG_KMS("Assuming LynxPoint PCH\n");
+	} else if (IS_SKYLAKE(dev)) {
+		ret = PCH_SPT;
+		DRM_DEBUG_KMS("Assuming SunrisePoint PCH\n");
+	}
+
+	return ret;
+}
+
 void intel_detect_pch(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -503,6 +531,8 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev));
+			} else if (id == INTEL_PCH_P2X_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = intel_virt_detect_pch(dev);
 			} else
 				continue;
 

commit 44cc6c08da0b6c8321c6740bbb6a0c6feb45b2c2
Merge: 40a4a5727f21 2d4df13c0f9e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 30 08:47:41 2015 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    Backmerge to catch up with 4.3. slightly more involved conflict in the
    irq code, but nothing beyond adjacent changes.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 22dfe79fd9c3951017bd68cad1d3257631307dde
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Sep 18 20:03:16 2015 +0300

    drm/i915: Parametrize GEN7_GT_SCRATCH and GEN7_LRA_LIMITS
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bdec64ca6f13..947bd4385292 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1120,7 +1120,7 @@ static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	s->gfx_pend_tlb1	= I915_READ(GEN7_GFX_PEND_TLB1);
 
 	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
-		s->lra_limits[i] = I915_READ(GEN7_LRA_LIMITS_BASE + i * 4);
+		s->lra_limits[i] = I915_READ(GEN7_LRA_LIMITS(i));
 
 	s->media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
 	s->gfx_max_req_count	= I915_READ(GEN7_GFX_MAX_REQ_COUNT);
@@ -1164,7 +1164,7 @@ static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	s->pm_ier		= I915_READ(GEN6_PMIER);
 
 	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
-		s->gt_scratch[i] = I915_READ(GEN7_GT_SCRATCH_BASE + i * 4);
+		s->gt_scratch[i] = I915_READ(GEN7_GT_SCRATCH(i));
 
 	/* GT SA CZ domain, 0x100000-0x138124 */
 	s->tilectl		= I915_READ(TILECTL);
@@ -1202,7 +1202,7 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	I915_WRITE(GEN7_GFX_PEND_TLB1,	s->gfx_pend_tlb1);
 
 	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
-		I915_WRITE(GEN7_LRA_LIMITS_BASE + i * 4, s->lra_limits[i]);
+		I915_WRITE(GEN7_LRA_LIMITS(i), s->lra_limits[i]);
 
 	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->media_max_req_count);
 	I915_WRITE(GEN7_GFX_MAX_REQ_COUNT, s->gfx_max_req_count);
@@ -1246,7 +1246,7 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	I915_WRITE(GEN6_PMIER,		s->pm_ier);
 
 	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
-		I915_WRITE(GEN7_GT_SCRATCH_BASE + i * 4, s->gt_scratch[i]);
+		I915_WRITE(GEN7_GT_SCRATCH(i), s->gt_scratch[i]);
 
 	/* GT SA CZ domain, 0x100000-0x138124 */
 	I915_WRITE(TILECTL,			s->tilectl);

commit f377ea88b862bf7151be96d276f4cb740f8e1c41
Merge: 51e771c0d25b 73bf1b7be7aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 4 15:49:32 2015 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main pull request for the drm for 4.3.  Nouveau is
      probably the biggest amount of changes in here, since it missed 4.2.
      Highlights below, along with the usual bunch of fixes.
    
      All stuff outside drm should have applicable acks.
    
      Highlights:
    
       - new drivers:
            freescale dcu kms driver
    
       - core:
            more atomic fixes
            disable some dri1 interfaces on kms drivers
            drop fb panic handling, this was just getting more broken, as more locking was required.
            new core fbdev Kconfig support - instead of each driver enable/disabling it
            struct_mutex cleanups
    
       - panel:
            more new panels
            cleanup Kconfig
    
       - i915:
            Skylake support enabled by default
            legacy modesetting using atomic infrastructure
            Skylake fixes
            GEN9 workarounds
    
       - amdgpu:
            Fiji support
            CGS support for amdgpu
            Initial GPU scheduler - off by default
            Lots of bug fixes and optimisations.
    
       - radeon:
            DP fixes
            misc fixes
    
       - amdkfd:
            Add Carrizo support for amdkfd using amdgpu.
    
       - nouveau:
            long pending cleanup to complete driver,
            fully bisectable which makes it larger,
            perfmon work
            more reclocking improvements
            maxwell displayport fixes
    
       - vmwgfx:
            new DX device support, supports OpenGL 3.3
            screen targets support
    
       - mgag200:
            G200eW support
            G200e new revision support
    
       - msm:
            dragonboard 410c support, msm8x94 support, msm8x74v1 support
            yuv format support
            dma plane support
            mdp5 rotation
            initial hdcp
    
       - sti:
            atomic support
    
       - exynos:
            lots of cleanups
            atomic modesetting/pageflipping support
            render node support
    
       - tegra:
            tegra210 support (dc, dsi, dp/hdmi)
            dpms with atomic modesetting support
    
       - atmel:
            support for 3 more atmel SoCs
            new input formats, PRIME support.
    
       - dwhdmi:
            preparing to add audio support
    
       - rockchip:
            yuv plane support"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (1369 commits)
      drm/amdgpu: rename gmc_v8_0_init_compute_vmid
      drm/amdgpu: fix vce3 instance handling
      drm/amdgpu: remove ib test for the second VCE Ring
      drm/amdgpu: properly enable VM fault interrupts
      drm/amdgpu: fix warning in scheduler
      drm/amdgpu: fix buffer placement under memory pressure
      drm/amdgpu/cz: fix cz_dpm_update_low_memory_pstate logic
      drm/amdgpu: fix typo in dce11 watermark setup
      drm/amdgpu: fix typo in dce10 watermark setup
      drm/amdgpu: use top down allocation for non-CPU accessible vram
      drm/amdgpu: be explicit about cpu vram access for driver BOs (v2)
      drm/amdgpu: set MEC doorbell range for Fiji
      drm/amdgpu: implement burst NOP for SDMA
      drm/amdgpu: add insert_nop ring func and default implementation
      drm/amdgpu: add amdgpu_get_sdma_instance helper function
      drm/amdgpu: add AMDGPU_MAX_SDMA_INSTANCES
      drm/amdgpu: add burst_nop flag for sdma
      drm/amdgpu: add count field for the SDMA NOP packet v2
      drm/amdgpu: use PT for VM sync on unmap
      drm/amdgpu: make wait_event uninterruptible in push_job
      ...

commit 08d8a232aa5e145f995a98ac7f3de55e2fe6832b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Aug 27 23:56:08 2015 +0300

    drm/i915: Reinitialize HPD after runtime D3
    
    Runtime suspends disabled all interrupts, so in order to get them back
    fully we need to also do the HPD irq setup on runtime resume. Except
    on VLV/CHV where the display interrupt initialization is part of the
    display power well powerup.
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4737d15de5f0..bdec64ca6f13 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1555,6 +1555,15 @@ static int intel_runtime_resume(struct device *device)
 	gen6_update_ring_freq(dev);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
+
+	/*
+	 * On VLV/CHV display interrupts are part of the display
+	 * power well, so hpd is reinitialized from there. For
+	 * everyone else do it here.
+	 */
+	if (!IS_VALLEYVIEW(dev_priv))
+		intel_hpd_init(dev_priv);
+
 	intel_enable_gt_powersave(dev);
 
 	if (ret)

commit e93c28f39375558409329a02a767d5cadfcc4a31
Merge: 85a62bf9d8ef 6fa2d197936b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 2 14:33:42 2015 +0200

    Merge tag 'drm-intel-next-fixes-2015-09-02' into drm-intel-next-queued
    
    Backmerge -fixes since there's more DDI-E related cleanups on top of
    the pile of -fixes for skl that just landed for 4.3.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i914/intel_dp.c
            drivers/gpu/drm/i915/intel_lrc.c
    
    Conflicts are all fairly harmless adjacent line stuff.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 1751fcf9f92ebfd230260230956535b19b4ec675
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Aug 27 15:15:15 2015 +0200

    drm/i915: Fix module initialisation, v2.
    
    The driver doesn't support UMS any more, so set DRIVER_MODESET by default,
    remove the legacy s/r callbacks, and rename the s/r functions to make it more clear
    they're only in use by switcheroo now.
    
    Also remove an obsolete comment about atomic. Normal updates are supported only
    async updates aren't yet.
    
    v2: Don't unconditionally set DRIVER_ATOMIC, we're not yet there.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ce3bd0c713b9..4646fe1a0499 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -679,7 +679,7 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 	return 0;
 }
 
-int i915_suspend_legacy(struct drm_device *dev, pm_message_t state)
+int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state)
 {
 	int error;
 
@@ -812,7 +812,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-int i915_resume_legacy(struct drm_device *dev)
+int i915_resume_switcheroo(struct drm_device *dev)
 {
 	int ret;
 
@@ -1649,7 +1649,7 @@ static struct drm_driver driver = {
 	 */
 	.driver_features =
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
-	    DRIVER_RENDER,
+	    DRIVER_RENDER | DRIVER_MODESET,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,
 	.open = i915_driver_open,
@@ -1658,10 +1658,6 @@ static struct drm_driver driver = {
 	.postclose = i915_driver_postclose,
 	.set_busid = drm_pci_set_busid,
 
-	/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
-	.suspend = i915_suspend_legacy,
-	.resume = i915_resume_legacy,
-
 #if defined(CONFIG_DEBUG_FS)
 	.debugfs_init = i915_debugfs_init,
 	.debugfs_cleanup = i915_debugfs_cleanup,
@@ -1704,7 +1700,6 @@ static int __init i915_init(void)
 	 * either the i915.modeset prarameter or by the
 	 * vga_text_mode_force boot option.
 	 */
-	driver.driver_features |= DRIVER_MODESET;
 
 	if (i915.modeset == 0)
 		driver.driver_features &= ~DRIVER_MODESET;
@@ -1715,17 +1710,11 @@ static int __init i915_init(void)
 #endif
 
 	if (!(driver.driver_features & DRIVER_MODESET)) {
-		driver.get_vblank_timestamp = NULL;
 		/* Silently fail loading to not upset userspace. */
 		DRM_DEBUG_DRIVER("KMS and UMS disabled.\n");
 		return 0;
 	}
 
-	/*
-	 * FIXME: Note that we're lying to the DRM core here so that we can get access
-	 * to the atomic ioctl and the atomic properties.  Only plane operations on
-	 * a single CRTC will actually work.
-	 */
 	if (i915.nuclear_pageflip)
 		driver.driver_features |= DRIVER_ATOMIC;
 

commit 54875571bbfde00fc63741715c531cbb5246c3b2
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Jun 30 17:06:47 2015 +0300

    drm/i915: apply the PCI_D0/D3 hibernation workaround everywhere on pre GEN6
    
    commit da2bc1b9db3351addd293e5b82757efe1f77ed1d
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Thu Oct 23 19:23:26 2014 +0300
    
        drm/i915: add poweroff_late handler
    
    introduced a regression on old platforms during hibernation. A workaround was
    added in
    
    commit ab3be73fa7b43f4c3648ce29b5fd649ea54d3adb
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Mon Mar 2 13:04:41 2015 +0200
    
        drm/i915: gen4: work around hang during hibernation
    
    using an explicit blacklist for the GENs/BIOS vendors where the issue was
    reported. Later there we had reports of the same failure on platforms not on
    this list.
    
    To my best knowledge the correct thing to do is still to put the device to PCI
    D3 state during hibernation, see [1] and [2] for the reasons. This also aligns
    with our future plans to unify more the runtime and system suspend/resume
    paths. Since an exact blacklist seems to be impractical (multiple GENs and
    BIOS vendors are affected) apply the workaround on everything pre GEN6.
    
    [1] http://lists.freedesktop.org/archives/intel-gfx/2015-February/060710.html
    [2] https://lkml.org/lkml/2015/6/22/274
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=95061
    Reported-by: Ilya Tumaykin <itumaykin@gmail.com>
    Reported-by: Dirk Griesbach <spamthis@freenet.de>
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Reported-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Tested-by: Mikko Rapeli <mikko.rapeli@iki.fi>
    Reported-by: Paul Bolle <pebolle@tiscali.nl>
    CC: stable@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1d887459e37f..8edcec8ae592 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -662,15 +662,18 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 
 	pci_disable_device(drm_dev->pdev);
 	/*
-	 * During hibernation on some GEN4 platforms the BIOS may try to access
+	 * During hibernation on some platforms the BIOS may try to access
 	 * the device even though it's already in D3 and hang the machine. So
 	 * leave the device in D0 on those platforms and hope the BIOS will
-	 * power down the device properly. Platforms where this was seen:
-	 * Lenovo Thinkpad X301, X61s
+	 * power down the device properly. The issue was seen on multiple old
+	 * GENs with different BIOS vendors, so having an explicit blacklist
+	 * is inpractical; apply the workaround on everything pre GEN6. The
+	 * platforms where the issue was seen:
+	 * Lenovo Thinkpad X301, X61s, X60, T60, X41
+	 * Fujitsu FSC S7110
+	 * Acer Aspire 1830T
 	 */
-	if (!(hibernation &&
-	      drm_dev->pdev->subsystem_vendor == PCI_VENDOR_ID_LENOVO &&
-	      INTEL_INFO(dev_priv)->gen == 4))
+	if (!(hibernation && INTEL_INFO(dev_priv)->gen < 6))
 		pci_set_power_state(drm_dev->pdev, PCI_D3hot);
 
 	return 0;

commit c5b852f33e7844f4664794a3b3c738d07b09ce0a
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Aug 26 09:29:56 2015 +0200

    Partially revert "drm/i915: Use full atomic modeset."
    
    This partially reverts commit 74c090b1bdc57b1c9f1361908cca5a3d8a80fb08.
    
    The DRIVER_ATOMIC cap cannot yet be exported because i915 lacks async
    support.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6e03e115ea1f..ce3bd0c713b9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1726,7 +1726,7 @@ static int __init i915_init(void)
 	 * to the atomic ioctl and the atomic properties.  Only plane operations on
 	 * a single CRTC will actually work.
 	 */
-	if (driver.driver_features & DRIVER_MODESET)
+	if (i915.nuclear_pageflip)
 		driver.driver_features |= DRIVER_ATOMIC;
 
 	return drm_pci_init(&driver, &i915_pci_driver);

commit 6c908bf43df417b10917c3a463d3bd413eb476fd
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Aug 25 19:03:41 2015 -0300

    drm/i915: gen 9 can check for unclaimed registers too
    
    Dear git bisect user,
    
    Even though this is the patch that introduced the WARN() you're
    bisecting, please notice that it's very likely that the problem you're
    facing was already present before this commit. In other words: this
    commit adds code to detect errors and give WARN()s about them, but the
    errors were already there.
    
    In order to continue your debug, please use the i915.mmio_debug
    option, check the backtraces and try to discover which read or write
    operation is causing the error message. Then check if this is
    happening because the register does not exist or because its power
    well is down when the operation is being done.
    
    On my SKL machine, if I use i915.mmio_debug=999, this patch triggers
    42 WARNs just by booting. I didn't investigate them yet. Normal users
    are only going to get a single WARN due to the default i915.mmio_debug
    setting.
    
    Thank you for your comprehension,
    Paulo
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1d887459e37f..6e03e115ea1f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -362,6 +362,7 @@ static const struct intel_device_info intel_skylake_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
@@ -374,6 +375,7 @@ static const struct intel_device_info intel_skylake_gt3_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
@@ -386,6 +388,7 @@ static const struct intel_device_info intel_broxton_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.num_pipes = 3,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,

commit d37ae19a6c21bc358f69e1dca410743c98347fe2
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Thu Jul 30 18:20:29 2015 -0300

    drm/i915/skl: send opregion_nofify_adapter(PCI_D1) instead of PCI_D3
    
    I was told that the "repurposed D1 definition" is still valid for SKL.
    It is BDW that is special due to its hotplug bug, so let's
    special-case BDW instead of HSW.
    
    Cc: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 151263b433e6..1d887459e37f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1489,7 +1489,15 @@ static int intel_runtime_suspend(struct device *device)
 	 * FIXME: We really should find a document that references the arguments
 	 * used below!
 	 */
-	if (IS_HASWELL(dev)) {
+	if (IS_BROADWELL(dev)) {
+		/*
+		 * On Broadwell, if we use PCI_D1 the PCH DDI ports will stop
+		 * being detected, and the call we do at intel_runtime_resume()
+		 * won't be able to restore them. Since PCI_D3hot matches the
+		 * actual specification and appears to be working, use it.
+		 */
+		intel_opregion_notify_adapter(dev, PCI_D3hot);
+	} else {
 		/*
 		 * current versions of firmware which depend on this opregion
 		 * notification have repurposed the D1 definition to mean
@@ -1498,16 +1506,6 @@ static int intel_runtime_suspend(struct device *device)
 		 * the suspend path.
 		 */
 		intel_opregion_notify_adapter(dev, PCI_D1);
-	} else {
-		/*
-		 * On Broadwell, if we use PCI_D1 the PCH DDI ports will stop
-		 * being detected, and the call we do at intel_runtime_resume()
-		 * won't be able to restore them. Since PCI_D3hot matches the
-		 * actual specification and appears to be working, use it. Let's
-		 * assume the other non-Haswell platforms will stay the same as
-		 * Broadwell.
-		 */
-		intel_opregion_notify_adapter(dev, PCI_D3hot);
 	}
 
 	assert_forcewakes_inactive(dev_priv);

commit 3b9a02e844948fc14cb32a06bc00e0e61bde3577
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 27 11:47:38 2015 +0200

    drm/i915: Fake AGP is dead
    
    Remove the leftovers, yay!
    
    AGP for i915 kms died long ago with
    
    commit 3bb6ce66866310f50d461b9eff949c1ce95560ce
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Nov 13 22:14:16 2013 +0100
    
        drm/i915: Kill legeacy AGP for gen3 kms
    
    and with ums now gone to there's really no users any more.
    
    Note that device_is_agp is only called when DRIVER_USE_AGP is set and
    since we've unconditionally cleared that since a while there are
    really no users left for i915_driver_device_is_agp.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0d6775a3e88c..151263b433e6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -935,8 +935,6 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
-	driver.driver_features &= ~(DRIVER_USE_AGP);
-
 	return drm_get_pci_dev(pdev, ent, &driver);
 }
 
@@ -1649,7 +1647,6 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_USE_AGP |
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER,
 	.load = i915_driver_load,
@@ -1664,7 +1661,6 @@ static struct drm_driver driver = {
 	.suspend = i915_suspend_legacy,
 	.resume = i915_resume_legacy,
 
-	.device_is_agp = i915_driver_device_is_agp,
 #if defined(CONFIG_DEBUG_FS)
 	.debugfs_init = i915_debugfs_init,
 	.debugfs_cleanup = i915_debugfs_cleanup,

commit 805de8f43c20ba8b479bb598b543fa86b20067f6
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Apr 24 01:12:32 2015 +0200

    atomic: Replace atomic_{set,clear}_mask() usage
    
    Replace the deprecated atomic_{set,clear}_mask() usage with the now
    ubiquous atomic_{or,andnot}() functions.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 884b4f9b81c4..8917c98ff121 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -748,7 +748,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-		atomic_set_mask(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
+			atomic_or(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
 	}
 	mutex_unlock(&dev->struct_mutex);
 

commit 4b0c8bb016e7f36e2d6ec230f9177f88def690d5
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Thu Jul 16 17:08:09 2015 +0100

    drm/i915/skl: Drop the preliminary_hw_support flag
    
    Time to light a candle and remove the preliminary_hw_support flag.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f13ed1ef6641..0d6775a3e88c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -356,7 +356,6 @@ static const struct intel_device_info intel_cherryview_info = {
 };
 
 static const struct intel_device_info intel_skylake_info = {
-	.is_preliminary = 1,
 	.is_skylake = 1,
 	.gen = 9, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
@@ -369,7 +368,6 @@ static const struct intel_device_info intel_skylake_info = {
 };
 
 static const struct intel_device_info intel_skylake_gt3_info = {
-	.is_preliminary = 1,
 	.is_skylake = 1,
 	.gen = 9, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,

commit 74c090b1bdc57b1c9f1361908cca5a3d8a80fb08
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jul 13 16:30:30 2015 +0200

    drm/i915: Use full atomic modeset.
    
    Huzzah! \o/
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index db48aee7f140..f13ed1ef6641 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1731,7 +1731,7 @@ static int __init i915_init(void)
 	 * to the atomic ioctl and the atomic properties.  Only plane operations on
 	 * a single CRTC will actually work.
 	 */
-	if (i915.nuclear_pageflip)
+	if (driver.driver_features & DRIVER_MODESET)
 		driver.driver_features |= DRIVER_ATOMIC;
 
 	return drm_pci_init(&driver, &i915_pci_driver);

commit 043e9bda6b7bf6ff83576c65a40becc5054e827d
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jul 13 16:30:25 2015 +0200

    drm/i915: Convert resume to atomic.
    
    Instead of all the ad-hoc updating, duplicate the old state first
    before reading out the hw state, then restore it.
    
    intel_display_resume is a new function that duplicates the sw state,
    then reads out the hw state, and commits the old state.
    
    intel_display_setup_hw_state now only reads out the atomic state.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=90396
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e44dc0d6656f..db48aee7f140 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -741,7 +741,7 @@ static int i915_drm_resume(struct drm_device *dev)
 	spin_unlock_irq(&dev_priv->irq_lock);
 
 	drm_modeset_lock_all(dev);
-	intel_modeset_setup_hw_state(dev, true);
+	intel_display_resume(dev);
 	drm_modeset_unlock_all(dev);
 
 	intel_dp_mst_resume(dev);

commit b1330fbb870467bbb90adb2e8868672af4ca88c7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 18 11:42:08 2015 +0100

    drm/i915: Report an error when i915.reset prevents a reset
    
    If the user disables the GPU reset using the i915.reset parameter and
    one occurs, report that we failed to reset the GPU. If we return early,
    as we currently do, then we leave all state intact (with a hung GPU)
    and clients block forever waiting for their requests to complete.
    
    Testcase: igt/gem_eio
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    [danvet: Mark i915.reset as an unsafe modoption, as discussed with
    Chris.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b12a8218e35e..e44dc0d6656f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -846,9 +846,6 @@ int i915_reset(struct drm_device *dev)
 	bool simulated;
 	int ret;
 
-	if (!i915.reset)
-		return 0;
-
 	intel_reset_gt_powersave(dev);
 
 	mutex_lock(&dev->struct_mutex);

commit bf13af56252b2b4f50eb6fc8638e8cb9e84ff475
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jun 23 13:57:47 2015 +0200

    drm/i915: Fix up KMS Kconfig removal patch
    
    The module pciid list got lost, but somehow most distros seem to
    force-load drm drivers early and no one noticed for a while.
    
    Bug introduced in
    
    commit fd930478fb797e4cbaa799d9ddd970e9a1fa1b4a
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Fri Jun 19 20:27:27 2015 +0100
    
        drm/i915: Remove KMS Kconfig option
    
    Reported-by: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Damien Lespiau <damien.lespiau@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c69f19271e27..b12a8218e35e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -440,9 +440,7 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	{0, 0, 0}
 };
 
-#if defined(CONFIG_DRM_I915_KMS)
 MODULE_DEVICE_TABLE(pci, pciidlist);
-#endif
 
 void intel_detect_pch(struct drm_device *dev)
 {

commit fd930478fb797e4cbaa799d9ddd970e9a1fa1b4a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 19 20:27:27 2015 +0100

    drm/i915: Remove KMS Kconfig option
    
    Since we only support modesetting by default (disabling modesetting on
    the command line prevents i915.ko from loading), having a parameter to
    disable modesstting by default is superfluous, i.e. saying
    CONFIG_DRM_I915_KMS=n is equivalent to CONFIG_DRM_I915=n.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Veter <daniel.vetter@ffwll.ch>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0ec57bad454f..c69f19271e27 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1710,20 +1710,14 @@ static int __init i915_init(void)
 	driver.num_ioctls = i915_max_ioctl;
 
 	/*
-	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless
-	 * explicitly disabled with the module pararmeter.
-	 *
-	 * Otherwise, just follow the parameter (defaulting to off).
-	 *
-	 * Allow optional vga_text_mode_force boot option to override
-	 * the default behavior.
+	 * Enable KMS by default, unless explicitly overriden by
+	 * either the i915.modeset prarameter or by the
+	 * vga_text_mode_force boot option.
 	 */
-#if defined(CONFIG_DRM_I915_KMS)
-	if (i915.modeset != 0)
-		driver.driver_features |= DRIVER_MODESET;
-#endif
-	if (i915.modeset == 1)
-		driver.driver_features |= DRIVER_MODESET;
+	driver.driver_features |= DRIVER_MODESET;
+
+	if (i915.modeset == 0)
+		driver.driver_features &= ~DRIVER_MODESET;
 
 #ifdef CONFIG_VGA_CONSOLE
 	if (vgacon_text_force() && i915.modeset == -1)

commit 77913b39addfaa836929815515ff55cea1142b66
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jun 18 13:06:16 2015 +0300

    drm/i915: move generic hotplug code into new intel_hotplug.c file
    
    We have enough generic hotplug functions sprinkled all over i915_irq.c
    to warrant moving them to a file of their own. This should further
    underline the distinction between generic code in the new file and
    platform specific hotplug and irq code that remains in i915_irq.c.
    
    Add new intel_hpd_init_work to keep work functions static, and rename
    get_port_from_pin to intel_hpd_pin_to_port while increasing its
    visibility, but keep everything else the same.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 78ef0bb53c36..0ec57bad454f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -541,21 +541,6 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return true;
 }
 
-void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
-{
-	spin_lock_irq(&dev_priv->irq_lock);
-
-	dev_priv->hotplug.long_port_mask = 0;
-	dev_priv->hotplug.short_port_mask = 0;
-	dev_priv->hotplug.event_bits = 0;
-
-	spin_unlock_irq(&dev_priv->irq_lock);
-
-	cancel_work_sync(&dev_priv->hotplug.dig_port_work);
-	cancel_work_sync(&dev_priv->hotplug.hotplug_work);
-	cancel_delayed_work_sync(&dev_priv->hotplug.reenable_work);
-}
-
 void i915_firmware_load_error_print(const char *fw_path, int err)
 {
 	DRM_ERROR("failed to load firmware %s (%d)\n", fw_path, err);

commit 9716c691ce06b043d3e75c8ff93704cb40c52265
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Jun 10 10:24:19 2015 +0200

    Revert "drm/i915: Make intel_display_suspend atomic, v2."
    
    This reverts commit 490f400db5d886fc28566af69b02f6497f31be4b.
    
    We're not ready yet to make it atomic, we calculate some state in
    advance, but without atomic plane support atomic the hw readout will
    fail.
    
    It's required to revert this commit to revert the atomic hw
    state readout patch.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=90868
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=90861
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d3632c56fdf7..78ef0bb53c36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -634,9 +634,6 @@ static int i915_drm_suspend(struct drm_device *dev)
 	intel_display_suspend(dev);
 	drm_modeset_unlock_all(dev);
 
-	/* suspending displays will unsets init power */
-	intel_display_set_init_power(dev_priv, true);
-
 	intel_dp_mst_suspend(dev);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);

commit 06ea0b0897db906c5616f660a34b54d92f7d09cf
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jun 1 12:50:05 2015 +0200

    drm/i915: Make intel_display_suspend atomic, v2.
    
    Calculate all state using a normal transition, but afterwards fudge
    crtc->state->active back to its old value. This should still allow
    state restore in setup_hw_state to work properly.
    
    Calling intel_set_mode will cause intel_display_set_init_power to be
    called, make sure init_power gets set again afterwards.
    
    Changes since v1:
    - Fix to compile with v2 of the patch that adds intel_display_suspend.
    - Add intel_display_set_init_power.
    - Set return value to int to allow error checking.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 78ef0bb53c36..d3632c56fdf7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -634,6 +634,9 @@ static int i915_drm_suspend(struct drm_device *dev)
 	intel_display_suspend(dev);
 	drm_modeset_unlock_all(dev);
 
+	/* suspending displays will unsets init power */
+	intel_display_set_init_power(dev_priv, true);
+
 	intel_dp_mst_suspend(dev);
 
 	intel_runtime_pm_disable_interrupts(dev_priv);

commit 6b72d486245265676df9866734bca1b39252e480
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jun 1 12:49:47 2015 +0200

    drm/i915: add intel_display_suspend, v2
    
    This is a function used to disable all crtc's. This makes it clearer
    to distinguish between when mode needs to be preserved and when
    it can be trashed.
    
    Changes since v1:
    - Copy power changes from intel_crtc_control.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a051a0241883..78ef0bb53c36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -601,7 +601,6 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv);
 static int i915_drm_suspend(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct drm_crtc *crtc;
 	pci_power_t opregion_target_state;
 	int error;
 
@@ -632,8 +631,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	 * for _thaw. Also, power gate the CRTC power wells.
 	 */
 	drm_modeset_lock_all(dev);
-	for_each_crtc(dev, crtc)
-		intel_crtc_control(crtc, false);
+	intel_display_suspend(dev);
 	drm_modeset_unlock_all(dev);
 
 	intel_dp_mst_suspend(dev);

commit 5fcece80ecdac932a0acb71e3a239c39dd4af20f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 27 15:03:42 2015 +0300

    drm/i915: group all hotplug related fields into a new struct in dev_priv
    
    There are plenty of hotplug related fields in struct drm_i915_private
    scattered all around. Group them under one hotplug struct. Clean up
    naming while at it. No functional changes.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 884b4f9b81c4..a051a0241883 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -545,15 +545,15 @@ void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
 {
 	spin_lock_irq(&dev_priv->irq_lock);
 
-	dev_priv->long_hpd_port_mask = 0;
-	dev_priv->short_hpd_port_mask = 0;
-	dev_priv->hpd_event_bits = 0;
+	dev_priv->hotplug.long_port_mask = 0;
+	dev_priv->hotplug.short_port_mask = 0;
+	dev_priv->hotplug.event_bits = 0;
 
 	spin_unlock_irq(&dev_priv->irq_lock);
 
-	cancel_work_sync(&dev_priv->dig_port_work);
-	cancel_work_sync(&dev_priv->hotplug_work);
-	cancel_delayed_work_sync(&dev_priv->hotplug_reenable_work);
+	cancel_work_sync(&dev_priv->hotplug.dig_port_work);
+	cancel_work_sync(&dev_priv->hotplug.hotplug_work);
+	cancel_delayed_work_sync(&dev_priv->hotplug.reenable_work);
 }
 
 void i915_firmware_load_error_print(const char *fw_path, int err)

commit 5d96d8afcfbb1500272756747e0bfcdbebf3b070
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Thu May 21 16:37:48 2015 +0100

    drm/i915/skl: Deinit/init the display at suspend/resume
    
    We need to re-init the display hardware when going out of suspend. This
    includes:
    
      - Hooking the PCH to the reset logic
      - Restoring CDCDLK
      - Enabling the DDB power
    
    Among those, only the CDCDLK one is a bit tricky. There's some
    complexity in that:
    
      - DPLL0 (which is the source for CDCLK) has two VCOs, each with a set
        of supported frequencies. As eDP also uses DPLL0 for its link rate,
        once DPLL0 is on, we restrict the possible eDP link rates the chosen
        VCO.
      - CDCLK also limits the bandwidth available to push pixels.
    
    So, as a first step, this commit restore what the BIOS set, until I can
    do more testing.
    
    In case that's of interest for the reviewer, I've unit tested the
    function that derives the decimal frequency field:
    
      #include <stdio.h>
      #include <stdint.h>
      #include <assert.h>
    
      #define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
    
      static const struct dpll_freq {
              unsigned int freq;
              unsigned int decimal;
      } freqs[] = {
              { .freq = 308570, .decimal = 0b01001100111},
              { .freq = 337500, .decimal = 0b01010100001},
              { .freq = 432000, .decimal = 0b01101011110},
              { .freq = 450000, .decimal = 0b01110000010},
              { .freq = 540000, .decimal = 0b10000110110},
              { .freq = 617140, .decimal = 0b10011010000},
              { .freq = 675000, .decimal = 0b10101000100},
      };
    
      static void intbits(unsigned int v)
      {
              int i;
    
              for(i = 10; i >= 0; i--)
                      putchar('0' + ((v >> i) & 1));
      }
    
      static unsigned int freq_decimal(unsigned int freq /* in kHz */)
      {
              return (freq - 1000) / 500;
      }
    
      static void test_freq(const struct dpll_freq *entry)
      {
              unsigned int decimal = freq_decimal(entry->freq);
    
              printf("freq: %d, expected: ", entry->freq);
              intbits(entry->decimal);
              printf(", got: ");
              intbits(decimal);
              putchar('\n');
    
              assert(decimal == entry->decimal);
      }
    
      int main(int argc, char **argv)
      {
              int i;
    
              for (i = 0; i < ARRAY_SIZE(freqs); i++)
                      test_freq(&freqs[i]);
    
              return 0;
      }
    
    v2:
      - Rebase on top of -nightly
      - Use (freq - 1000) / 500 for the decimal frequency (Ville)
      - Fix setting the enable bit of HSW_NDE_RSTWRN_OPT (Ville)
      - Rename skl_display_{resume,suspend} to skl_{init,uninit}_cdclk to
        be consistent with the BXT code (Ville)
      - Store boot CDCLK in ddi_pll_init (Ville)
      - Merge dev_priv's skl_boot_cdclk into cdclk_freq
      - Use LCPLL_PLL_LOCK instead of (1 << 30) (Ville)
      - Replace various '0' by SKL_DPLL0 to be a bit more explicit that
        we're programming DPLL0
      - Busy poll the PCU before doing the frequency change. It takes about
        3/4 cycles, each separated by 10us, to get the ACK from the CPU
        (Ville)
    
    v3:
      - Restore dev_priv->skl_boot_cdclk, leaving unification with
        dev_priv->cdclk_freq for a later patch (Daniel, Ville)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 93191c1fd18e..884b4f9b81c4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1047,6 +1047,8 @@ static int skl_suspend_complete(struct drm_i915_private *dev_priv)
 	 */
 	intel_csr_load_status_set(dev_priv, FW_UNINITIALIZED);
 
+	skl_uninit_cdclk(dev_priv);
+
 	return 0;
 }
 
@@ -1093,6 +1095,7 @@ static int skl_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
+	skl_init_cdclk(dev_priv);
 	intel_csr_load_program(dev);
 
 	return 0;

commit 16e44e3e93c429b44a1441049ce89208fd3e0d28
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed May 20 14:45:16 2015 +0100

    drm/i915: Kill the dev variable in intel_suspend_complete()
    
    The macros we use there are the magic ones that can take either dev or
    dev_priv. We'd like to move as much as possible towards dev_priv though.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 442dd6c3d8d2..93191c1fd18e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1590,16 +1590,15 @@ static int intel_runtime_resume(struct device *device)
  */
 static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
-	if (IS_BROXTON(dev))
+	if (IS_BROXTON(dev_priv))
 		ret = bxt_suspend_complete(dev_priv);
-	else if (IS_SKYLAKE(dev))
+	else if (IS_SKYLAKE(dev_priv))
 		ret = skl_suspend_complete(dev_priv);
-	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		ret = hsw_suspend_complete(dev_priv);
-	else if (IS_VALLEYVIEW(dev))
+	else if (IS_VALLEYVIEW(dev_priv))
 		ret = vlv_suspend_complete(dev_priv);
 	else
 		ret = 0;

commit ff0b187f92f61503c8af67d3dc5e6e91fbe2f9cc
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed May 20 14:45:15 2015 +0100

    drm/i915: Add a space after ', ' and don't capitalize mid-sentence
    
    Couldn't let it go!
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77f981822c67..442dd6c3d8d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -812,7 +812,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	if (IS_VALLEYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
-		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
+		DRM_ERROR("Resume prepare failed: %d, continuing anyway\n",
+			  ret);
 
 	intel_uncore_early_sanitize(dev, true);
 

commit a9a6b73a1c1191ef9e1339c61231144dd2cb1f2b
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed May 20 14:45:14 2015 +0100

    drm/i915/bxt: Also add bxt_resume_prepare() to the S3/S4 path
    
    Currently bxt_resume_prepare() is only used in the runtime-resume path.
    Add it to the full S3/S4 path as well.
    
    v2: Rebase on top of the vlv_resume_prepare() shuffling around
    
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com> (v1)
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5cc57f2ec192..77f981822c67 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -595,6 +595,7 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv);
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 			      bool rpm_resume);
 static int skl_resume_prepare(struct drm_i915_private *dev_priv);
+static int bxt_resume_prepare(struct drm_i915_private *dev_priv);
 
 
 static int i915_drm_suspend(struct drm_device *dev)
@@ -815,10 +816,12 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	intel_uncore_early_sanitize(dev, true);
 
-	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
-		hsw_disable_pc8(dev_priv);
+	if (IS_BROXTON(dev))
+		ret = bxt_resume_prepare(dev_priv);
 	else if (IS_SKYLAKE(dev_priv))
 		ret = skl_resume_prepare(dev_priv);
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		hsw_disable_pc8(dev_priv);
 
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);

commit c965d99557fd48e8c57d793ec22458e508cbf676
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon May 18 19:53:48 2015 +0100

    drm/i915: Fix 'suspedn' typo
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 51149fb75e96..5cc57f2ec192 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -989,7 +989,7 @@ static int i915_pm_suspend_late(struct device *dev)
 	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
 
 	/*
-	 * We have a suspedn ordering issue with the snd-hda driver also
+	 * We have a suspend ordering issue with the snd-hda driver also
 	 * requiring our device to be power up. Due to the lack of a
 	 * parent/child relationship we currently solve this with an late
 	 * suspend hook.

commit bdcddf95e82b1c4e370fc1196b1f4f50f775dab4
Merge: 91d9f9856f91 e26081808eda
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 20 16:23:53 2015 +1000

    Backmerge v4.1-rc4 into into drm-next
    
    We picked up a silent conflict in amdkfd with drm-fixes and drm-next,
    backmerge v4.1-rc5 and fix the conflicts
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    Conflicts:
            drivers/gpu/drm/drm_irq.c

commit 364aece01a2dd748fc36a1e8bf52ef639b0857bd
Author: Peter Antoine <peter.antoine@intel.com>
Date:   Mon May 11 08:50:45 2015 +0100

    drm/i915: Avoid GPU hang when coming out of s3 or s4
    
    This patch fixes a timing issue that causes a GPU hang when the system
    comes out of power saving.
    
    During pm_resume, We are submitting batchbuffers before enabling
    Interrupts this is causing us to miss the context switch interrupt,
    and in consequence intel_execlists_handle_ctx_events is not triggered.
    
    This patch is based on a patch from Deepak S <deepak.s@intel.com>
    from another platform.
    
    The patch fixes an issue introduced by:
      commit e7778be1eab918274f79603d7c17b3ec8be77386
      drm/i915: Fix startup failure in LRC mode after recent init changes
    
    The above patch added a call to init_context() to fix an issue introduced
    by a previous patch. But, it then opened up a small timing window for the
    batches being added by the init_context (basically setting up the context)
    to complete before the interrupts have been turned on, thus hanging the
    GPU.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=89600
    Cc: stable@vger.kernel.org # 4.0+
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [Jani: fixed typo in subject, massaged the comments a bit]
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c302ffb5a168..a19d2c71e205 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -699,6 +699,16 @@ static int i915_drm_resume(struct drm_device *dev)
 	intel_init_pch_refclk(dev);
 	drm_mode_config_reset(dev);
 
+	/*
+	 * Interrupts have to be enabled before any batches are run. If not the
+	 * GPU will hang. i915_gem_init_hw() will initiate batches to
+	 * update/restore the context.
+	 *
+	 * Modeset enabling in intel_modeset_init_hw() also needs working
+	 * interrupts.
+	 */
+	intel_runtime_pm_enable_interrupts(dev_priv);
+
 	mutex_lock(&dev->struct_mutex);
 	if (i915_gem_init_hw(dev)) {
 		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
@@ -706,9 +716,6 @@ static int i915_drm_resume(struct drm_device *dev)
 	}
 	mutex_unlock(&dev->struct_mutex);
 
-	/* We need working interrupts for modeset enabling ... */
-	intel_runtime_pm_enable_interrupts(dev_priv);
-
 	intel_modeset_init_hw(dev);
 
 	spin_lock_irq(&dev_priv->irq_lock);

commit ac935a8b6db00079e2de65cadf4c735ed8f0175b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Apr 1 14:22:58 2015 -0700

    drm/i915/vlv: remove wait for previous GFX clk disable request
    
    Looks like it was introduced in:
    
    commit 650ad970a39f8b6164fe8613edc150f585315289
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Fri Apr 18 16:35:02 2014 +0300
    
        drm/i915: vlv: factor out vlv_force_gfx_clock and check for pending force-of
    
    but I'm not sure why.  It has caused problems for us in the past (see
    85250ddff7a6 "drm/i915/chv: Remove Wait for a previous gfx force-off"
    and 8d4eee9cd7a1 "drm/i915: vlv: increase timeout when forcing on the
    GFX clock") and doesn't seem to be required, so let's just drop it.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=89611
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Tested-by: Darren Hart <dvhart@linux.intel.com>
    Reviewed-by: Deepak S <deepak.s@linux.intel.com>
    Cc: stable@vger.kernel.org # c9c52e24194a: drm/i915/chv: Remove Wait ...
    Cc: stable@vger.kernel.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    [danvet: Repick this commit from
    5df0582bf036bb5f9a8ad8db5884fe13a55347d1 becuase Dave Airlie lost it
    in his merge commit e1dee1973c74a0408b108d88c57a15be8a2d6d84.]
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 334bcc1badaa..6bb6c47db49f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1286,21 +1286,7 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	u32 val;
 	int err;
 
-	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
-	/* Wait for a previous force-off to settle */
-	if (force_on && !IS_CHERRYVIEW(dev_priv->dev)) {
-		/* WARN_ON only for the Valleyview */
-		WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
-
-		err = wait_for(!COND, 20);
-		if (err) {
-			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",
-				  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
-			return err;
-		}
-	}
 
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
 	val &= ~VLV_GFX_CLK_FORCE_ON_BIT;

commit f75a1985137f272dff1a361b763a76fb8f68c3b9
Author: Suketu Shah <suketu.j.shah@intel.com>
Date:   Thu Apr 16 14:22:11 2015 +0530

    drm/i915/skl: Add DC6 Trigger sequence.
    
    Add triggers for DC6 as per details provided in skl_enable_dc6
    and skl_disable_dc6 implementations.
    
    Also Call POSTING_READ for every write to a register to ensure
    it is written to immediately
    
    v1: Remove POSTING_READ and intel_prepare_ddi calls as they've been added in previous patches.
    
    v2:
    1] Remove check for backlight disabled as it should be the case by that time.
    2] Mark DC5 as disabled when enabling DC6.
    3] Return from DC5-disabling function early if DC5 is already be disabled which can happen
       due to DC6-enabling earlier.
    3] Ensure CSR firmware is loaded after resume from DC6 as corresponding memory contents won't
       be retained after runtime-suspend.
    4] Ensure that CSR isn't identified as loaded before CSR-loading program is called during
       runtime-resume.
    
    v3: Rebase to latest
    Modified as per review comments from Imre and after discussion with Art:
    1] DC6 should be preferably enabled when PG2 is disabled by SW as the check for PG1 being
       disabled is taken of by HW to enter DC6, and disabled when PG2 is enabled respectively.
       This helps save more power, especially in the case when display is disabled but GT is
       enabled. Accordingly, replacing DC5 trigger sequence with DC6 for SKL.
    2] DC6 could be enabled from intel_runtime_suspend() function, if DC5 is already enabled.
    3] Move CSR-load-status setting code from intel_runtime_suspend function to a new function.
    
    v4:
    1] Enable/disable DC6 only when toggling the power-well using a newly defined macro ENABLE_DC6.
    
    v5:
    1] Load CSR on system resume too as firmware may be lost on system suspend preventing
       enabling DC5, DC6.
    2] DDI buffers shouldn't be programmed during driver-load/resume as it's already done
       during modeset initialization then and also that the encoder list is still uninitialized by
       then. Therefore, call intel_prepare_ddi function right after disabling DC6 but outside
       skl_disable_dc6 function and not during driver-load/resume.
    
    v6:
    1] Rebase to latest.
    2] Move SKL_ENABLE_DC6 macro definition from intel_display.c to intel_runtime_pm.c.
    
    v7:
    1) Refactored the code for removing the warning got from checkpatch.
    2) After adding dmc ver 1.0 support rebased on top of nightly. (Animesh)
    
    v8:
    - Reverted the changes done in v7.
    - Removed the condition check in skl_prepare_resune(). (Animesh)
    
    Issue: VIZ-2819
    Signed-off-by: A.Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Suketu Shah <suketu.j.shah@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b743bb17e288..334bcc1badaa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -594,6 +594,8 @@ static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 static int intel_suspend_complete(struct drm_i915_private *dev_priv);
 static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 			      bool rpm_resume);
+static int skl_resume_prepare(struct drm_i915_private *dev_priv);
+
 
 static int i915_drm_suspend(struct drm_device *dev)
 {
@@ -808,6 +810,8 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
+	else if (IS_SKYLAKE(dev_priv))
+		ret = skl_resume_prepare(dev_priv);
 
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);
@@ -1022,6 +1026,19 @@ static int i915_pm_resume(struct device *dev)
 	return i915_drm_resume(drm_dev);
 }
 
+static int skl_suspend_complete(struct drm_i915_private *dev_priv)
+{
+	/* Enabling DC6 is not a hard requirement to enter runtime D3 */
+
+	/*
+	 * This is to ensure that CSR isn't identified as loaded before
+	 * CSR-loading program is called during runtime-resume.
+	 */
+	intel_csr_load_status_set(dev_priv, FW_UNINITIALIZED);
+
+	return 0;
+}
+
 static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
@@ -1061,6 +1078,15 @@ static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
+static int skl_resume_prepare(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	intel_csr_load_program(dev);
+
+	return 0;
+}
+
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1536,6 +1562,8 @@ static int intel_runtime_resume(struct device *device)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_resume_prepare(dev_priv);
+	else if (IS_SKYLAKE(dev))
+		ret = skl_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 	else if (IS_VALLEYVIEW(dev_priv))
@@ -1570,6 +1598,8 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 
 	if (IS_BROXTON(dev))
 		ret = bxt_suspend_complete(dev_priv);
+	else if (IS_SKYLAKE(dev))
+		ret = skl_suspend_complete(dev_priv);
 	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		ret = hsw_suspend_complete(dev_priv);
 	else if (IS_VALLEYVIEW(dev))

commit eb805623d8b161342ed9c9caf366f0a295041a6d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon May 4 14:58:44 2015 +0200

    drm/i915/skl: Add support to load SKL CSR firmware.
    
    Display Context Save and Restore support is needed for
    various SKL Display C states like DC5, DC6.
    
    This implementation is added based on first version of DMC CSR program
    that we received from h/w team.
    
    Here we are using request_firmware based design.
    Finally this firmware should end up in linux-firmware tree.
    
    For SKL platform its mandatory to ensure that we load this
    csr program before enabling DC states like DC5/DC6.
    
    As CSR program gets reset on various conditions, we should ensure
    to load it during boot and in future change to be added to load
    this system resume sequence too.
    
    v1: Initial relese as RFC patch
    
    v2: Design change as per Daniel, Damien and Shobit's review comments
    request firmware method followed.
    
    v3: Some optimization and functional changes.
    Pulled register defines into drivers/gpu/drm/i915/i915_reg.h
    Used kmemdup to allocate and duplicate firmware content.
    Ensured to free allocated buffer.
    
    v4: Modified as per review comments from Satheesh and Daniel
    Removed temporary buffer.
    Optimized number of writes by replacing I915_WRITE with I915_WRITE64.
    
    v5:
    Modified as per review comemnts from Damien.
    - Changed name for functions and firmware.
    - Introduced HAS_CSR.
    - Reverted back previous change and used csr_buf with u8 size.
    - Using cpu_to_be64 for endianness change.
    
    Modified as per review comments from Imre.
    - Modified registers and macro names to be a bit closer to bspec terminology
    and the existing register naming in the driver.
    - Early return for non SKL platforms in intel_load_csr_program function.
    - Added locking around CSR program load function as it may be called
    concurrently during system/runtime resume.
    - Releasing the fw before loading the program for consistency
    - Handled error path during f/w load.
    
    v6: Modified as per review comments from Imre.
    - Corrected out_freecsr sequence.
    
    v7: Modified as per review comments from Imre.
    Fail loading fw if fw->size%8!=0.
    
    v8: Rebase to latest.
    
    v9: Rebase on top of -nightly (Damien)
    
    v10: Enabled support for dmc firmware ver 1.0.
    According to ver 1.0 in a single binary package all the firmware's that are
    required for different stepping's of the product will be stored. The package
    contains the css header, followed by the package header and the actual dmc
    firmwares. Package header contains the firmware/stepping mapping table and
    the corresponding firmware offsets to the individual binaries, within the
    package. Each individual program binary contains the header and the payload
    sections whose size is specified in the header section. This changes are done
    to extract the specific firmaware from the package. (Animesh)
    
    v11: Modified as per review comemnts from Imre.
    - Added code comment from bpec for header structure elements.
    - Added __packed to avoid structure padding.
    - Added helper functions for stepping and substepping info.
    - Added code comment for CSR_MAX_FW_SIZE.
    - Disabled BXT firmware loading, will be enabled with dmc 1.0 support.
    - Changed skl_stepping_info based on bspec, earlier used from config DB.
    - Removed duplicate call of cpu_to_be* from intel_csr_load_program function.
    - Used cpu_to_be32 instead of cpu_to_be64 as firmware binary in dword aligned.
    - Added sanity check for header length.
    - Added sanity check for mmio address got from firmware binary.
    - kmalloc done separately for dmc header and dmc firmware. (Animesh)
    
    v12: Modified as per review comemnts from Imre.
    - Corrected the typo error in skl stepping info structure.
    - Added out-of-bound access for skl_stepping_info.
    - Sanity check for mmio address modified.
    - Sanity check added for stepping and substeppig.
    - Modified the intel_dmc_info structure, cache only the required header info. (Animesh)
    
    v13: clarify firmware load error message.
    The reason for a firmware loading failure can be obscure if the driver
    is built-in. Provide an explanation to the user about the likely reason for
    the failure and how to resolve it. (Imre)
    
    v14: Suggested by Jani.
    - fix s/I915/CONFIG_DRM_I915/ typo
    - add fw_path to the firmware object instead of using a static ptr (Jani)
    
    v15:
    1) Changed the firmware name as dmc_gen9.bin, everytime for a new firmware version a symbolic link
    with same name will help not to build kernel again.
    2) Changes done as per review comments from Imre.
    - Error check removed for intel_csr_ucode_init.
    - Moved csr-specific data structure to intel_csr.h and optimization done on structure definition.
    - fw->data used directly for parsing the header info & memory allocation
    only done separately for payload. (Animesh)
    
    v16:
    - No need for out_regs label in i915_driver_load(), so removed it.
    - Changed the firmware name as skl_dmc_ver1.bin, followed naming convention <platform>_dmc_<api-version>.bin (Animesh)
    
    Issue: VIZ-2569
    Signed-off-by: A.Sunil Kamath <sunil.kamath@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6e9ab2fb1647..b743bb17e288 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -556,6 +556,26 @@ void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
 	cancel_delayed_work_sync(&dev_priv->hotplug_reenable_work);
 }
 
+void i915_firmware_load_error_print(const char *fw_path, int err)
+{
+	DRM_ERROR("failed to load firmware %s (%d)\n", fw_path, err);
+
+	/*
+	 * If the reason is not known assume -ENOENT since that's the most
+	 * usual failure mode.
+	 */
+	if (!err)
+		err = -ENOENT;
+
+	if (!(IS_BUILTIN(CONFIG_DRM_I915) && err == -ENOENT))
+		return;
+
+	DRM_ERROR(
+	  "The driver is built-in, so to load the firmware you need to\n"
+	  "include it either in the kernel (see CONFIG_EXTRA_FIRMWARE) or\n"
+	  "in your initrd/initramfs image.\n");
+}
+
 static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;

commit e1dee1973c74a0408b108d88c57a15be8a2d6d84
Merge: c0fe07aa50be 93a96c6f049d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 8 20:51:06 2015 +1000

    Merge tag 'drm-intel-next-2015-04-23-fixed' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2015-04-23:
    - dither support for ns2501 dvo (Thomas Richter)
    - some polish for the gtt code and fixes to finally enable the cmd parser on hsw
    - first pile of bxt stage 1 enabling (too many different people to list ...)
    - more psr fixes from Rodrigo
    - skl rotation support from Chandra
    - more atomic work from Ander and Matt
    - pile of cleanups and micro-ops for execlist from Chris
    drm-intel-next-2015-04-10:
    - cdclk handling cleanup and fixes from Ville
    - more prep patches for olr removal from John Harrison
    - gmbus pin naming rework from Jani (prep for bxt)
    - remove ->new_config from Ander (more atomic conversion work)
    - rps (boost) tuning and unification with byt/bsw from Chris
    - cmd parser batch bool tuning from Chris
    - gen8 dynamic pte allocation (Michel Thierry, based on work from Ben Widawsky)
    - execlist tuning (not yet all of it) from Chris
    - add drm_plane_from_index (Chandra)
    - various small things all over
    
    * tag 'drm-intel-next-2015-04-23-fixed' of git://anongit.freedesktop.org/drm-intel: (204 commits)
      drm/i915/gtt: Allocate va range only if vma is not bound
      drm/i915: Enable cmd parser to do secure batch promotion for aliasing ppgtt
      drm/i915: fix intel_prepare_ddi
      drm/i915: factor out ddi_get_encoder_port
      drm/i915/hdmi: check port in ibx_infoframe_enabled
      drm/i915/hdmi: fix vlv infoframe port check
      drm/i915: Silence compiler warning in dvo
      drm/i915: Update DRIVER_DATE to 20150423
      drm/i915: Enable dithering on NatSemi DVO2501 for Fujitsu S6010
      rm/i915: Move i915_get_ggtt_vma_pages into ggtt_bind_vma
      drm/i915: Don't try to outsmart gcc in i915_gem_gtt.c
      drm/i915: Unduplicate i915_ggtt_unbind/bind_vma
      drm/i915: Move ppgtt_bind/unbind around
      drm/i915: move i915_gem_restore_gtt_mappings around
      drm/i915: Fix up the vma aliasing ppgtt binding
      drm/i915: Remove misleading comment around bind_to_vm
      drm/i915: Don't use atomics for pg_dirty_rings
      drm/i915: Don't look at pg_dirty_rings for aliasing ppgtt
      drm/i915/skl: Support Y tiling in MMIO flips
      drm/i915: Fixup kerneldoc for struct intel_context
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit 59fd7e4b0b0769638b5162e56c28bbb027a118d3
Merge: c8b3fd0ce313 b5f1c97f9444
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Apr 27 10:35:15 2015 +1000

    Merge tag 'drm-intel-next-fixes-2015-04-25' of git://anongit.freedesktop.org/drm-intel into drm-fixes
    
    three fixes for i915.
    
    * tag 'drm-intel-next-fixes-2015-04-25' of git://anongit.freedesktop.org/drm-intel:
      drm/i915: vlv: fix save/restore of GFX_MAX_REQ_COUNT reg
      drm/i915: Workaround to avoid lite restore with HEAD==TAIL
      drm/i915: cope with large i2c transfers

commit b5f1c97f944482e98e6e39208af356630389d1ea
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 15 16:52:30 2015 -0700

    drm/i915: vlv: fix save/restore of GFX_MAX_REQ_COUNT reg
    
    Due this typo we don't save/restore the GFX_MAX_REQ_COUNT register across
    suspend/resume, so fix this.
    
    This was introduced in
    
    commit ddeea5b0c36f3665446518c609be91f9336ef674
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Mon May 5 15:19:56 2014 +0300
    
        drm/i915: vlv: add runtime PM support
    
    I noticed this only by reading the code. To my knowledge it shouldn't
    cause any real problems at the moment, since the power well backing this
    register remains on across a runtime s/r. This may change once
    system-wide s0ix functionality is enabled in the kernel.
    
    v2:
    - resend after a missing git add -u :/
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Tested-By: PRC QA PRTS (Patch Regression Test System Contact: shuang.he@intel.com)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82f8be4b6745..9cc953e9b867 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1038,7 +1038,7 @@ static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 		s->lra_limits[i] = I915_READ(GEN7_LRA_LIMITS_BASE + i * 4);
 
 	s->media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
-	s->gfx_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
+	s->gfx_max_req_count	= I915_READ(GEN7_GFX_MAX_REQ_COUNT);
 
 	s->render_hwsp		= I915_READ(RENDER_HWS_PGA_GEN7);
 	s->ecochk		= I915_READ(GAM_ECOCHK);
@@ -1119,7 +1119,7 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 		I915_WRITE(GEN7_LRA_LIMITS_BASE + i * 4, s->lra_limits[i]);
 
 	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->media_max_req_count);
-	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->gfx_max_req_count);
+	I915_WRITE(GEN7_GFX_MAX_REQ_COUNT, s->gfx_max_req_count);
 
 	I915_WRITE(RENDER_HWS_PGA_GEN7,	s->render_hwsp);
 	I915_WRITE(GAM_ECOCHK,		s->ecochk);

commit 2c33ce009ca2389dbf0535d0672214d09738e35e
Merge: cec32a470106 09d51602cf84
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Apr 20 11:32:26 2015 +1000

    Merge Linus master into drm-next
    
    The merge is clean, but the arm build fails afterwards,
    due to API changes in the regulator tree.
    
    I've included the patch into the merge to fix the build.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 31335cec02604cba72deee44bb18cb82790ef2aa
Author: Suketu Shah <suketu.j.shah@intel.com>
Date:   Mon Nov 24 13:37:45 2014 +0530

    drm/i915/bxt: Add DC9 Trigger sequence
    
    Add triggers for DC9 as per details provided in bxt_enable_dc9
    and bxt_disable_dc9 implementations.
    
    v1:
    - Add SKL check in gen9_disable_dc5 as it is possible for DC5
      to remain disabled only for SKL.
    - Add additional checks for whether DC5 is already disabled during
      DC5-disabling only for BXT.
    
    v2:
    - rebase to latest.
    - Load CSR during DC9 disabling in the beginning before DC9 is
      disabled.
    - Make gen9_disable_dc5 function non-static as it's being called by
      functions in i915_drv.c.
    - Enable DC9-related functionality using a macro.
    
    v3: (imre)
    - remove BXT_ENABLE_DC9, we want DC9 always, and it's only valid on BXT
    - remove DC5 disabling and CSR FW loaded check, these are nop atm
    - squash in Vandana's "Do ddi_phy_init always" patch
    
    v4:
    - add TODO to re-enable DC5 during resume if CSR FW is available (sagar)
    
    Signed-off-by: Suketu Shah <suketu.j.shah@intel.com>
    Signed-off-by: A.Sunil Kamath <sunil.kamath@intel.com> (v2)
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c1a3cdb5189b..ad77131cdcff 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1009,6 +1009,38 @@ static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
+static int bxt_suspend_complete(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	/* TODO: when DC5 support is added disable DC5 here. */
+
+	broxton_ddi_phy_uninit(dev);
+	broxton_uninit_cdclk(dev);
+	bxt_enable_dc9(dev_priv);
+
+	return 0;
+}
+
+static int bxt_resume_prepare(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	/* TODO: when CSR FW support is added make sure the FW is loaded */
+
+	bxt_disable_dc9(dev_priv);
+
+	/*
+	 * TODO: when DC5 support is added enable DC5 here if the CSR FW
+	 * is available.
+	 */
+	broxton_init_cdclk(dev);
+	broxton_ddi_phy_init(dev);
+	intel_prepare_ddi(dev);
+
+	return 0;
+}
+
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1479,6 +1511,9 @@ static int intel_runtime_resume(struct device *device)
 
 	if (IS_GEN6(dev_priv))
 		intel_init_pch_refclk(dev);
+
+	if (IS_BROXTON(dev))
+		ret = bxt_resume_prepare(dev_priv);
 	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
 		hsw_disable_pc8(dev_priv);
 	else if (IS_VALLEYVIEW(dev_priv))
@@ -1511,7 +1546,9 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
-	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
+	if (IS_BROXTON(dev))
+		ret = bxt_suspend_complete(dev_priv);
+	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		ret = hsw_suspend_complete(dev_priv);
 	else if (IS_VALLEYVIEW(dev))
 		ret = vlv_suspend_complete(dev_priv);

commit c5fe557ddec423afa13410fc5927bb90a7c96765
Merge: 30154650b8b5 c776eb2edfce
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 14 14:00:56 2015 +0200

    Merge branch 'topic/bxt-stage1' into drm-intel-next-queued
    
    Separate topic branch for bxt didn't work out since we needed to
    refactor the gmbus code a bit to make it look decent. So backmerge.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit ce89db2eabb0979e823aed38d5f5b22512d06392
Author: Daisy Sun <daisy.sun@intel.com>
Date:   Tue Mar 17 11:39:28 2015 +0200

    drm/i915/bxt: BXT FBC enablement
    
    Enable FBC feature on Broxton
    
    Issue: VIZ-3784
    Signed-off-by: Daisy Sun <daisy.sun@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4d5078550e0b..48434cb6898d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -388,6 +388,7 @@ static const struct intel_device_info intel_broxton_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.num_pipes = 3,
 	.has_ddi = 1,
+	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
 };

commit 1347f5b46a270db1991625f9f57af91e23a4b512
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Tue Mar 17 11:39:27 2015 +0200

    drm/i915/bxt: Add BXT PCI ids
    
    v2: Switch to info->ring_mask and add VEBOX support.
    v3: Fold in update from Damien.
    v4: Add GEN_DEFAULT_PIPEOFFSETS and IVB_CURSOR_OFFSETS
    v5: set no-LLC (imre)
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com> (v1,v4)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch> (v4)
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82f8be4b6745..4d5078550e0b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -381,6 +381,17 @@ static const struct intel_device_info intel_skylake_gt3_info = {
 	IVB_CURSOR_OFFSETS,
 };
 
+static const struct intel_device_info intel_broxton_info = {
+	.is_preliminary = 1,
+	.gen = 9,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.num_pipes = 3,
+	.has_ddi = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -420,7 +431,8 @@ static const struct intel_device_info intel_skylake_gt3_info = {
 	INTEL_CHV_IDS(&intel_cherryview_info),	\
 	INTEL_SKL_GT1_IDS(&intel_skylake_info),	\
 	INTEL_SKL_GT2_IDS(&intel_skylake_info),	\
-	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info)	\
+	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info),	\
+	INTEL_BXT_IDS(&intel_broxton_info)
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit 5df0582bf036bb5f9a8ad8db5884fe13a55347d1
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Apr 1 14:22:58 2015 -0700

    drm/i915/vlv: remove wait for previous GFX clk disable request
    
    Looks like it was introduced in:
    
    commit 650ad970a39f8b6164fe8613edc150f585315289
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Fri Apr 18 16:35:02 2014 +0300
    
        drm/i915: vlv: factor out vlv_force_gfx_clock and check for pending force-of
    
    but I'm not sure why.  It has caused problems for us in the past (see
    85250ddff7a6 "drm/i915/chv: Remove Wait for a previous gfx force-off"
    and 8d4eee9cd7a1 "drm/i915: vlv: increase timeout when forcing on the
    GFX clock") and doesn't seem to be required, so let's just drop it.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=89611
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Tested-by: Darren Hart <dvhart@linux.intel.com>
    Reviewed-by: Deepak S <deepak.s@linux.intel.com>
    Cc: stable@vger.kernel.org # c9c52e24194a: drm/i915/chv: Remove Wait ...
    Cc: stable@vger.kernel.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3fa3eae0ee06..5c66b568bb81 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1199,21 +1199,7 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	u32 val;
 	int err;
 
-	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
-	/* Wait for a previous force-off to settle */
-	if (force_on && !IS_CHERRYVIEW(dev_priv->dev)) {
-		/* WARN_ON only for the Valleyview */
-		WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
-
-		err = wait_for(!COND, 20);
-		if (err) {
-			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",
-				  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
-			return err;
-		}
-	}
 
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
 	val &= ~VLV_GFX_CLK_FORCE_ON_BIT;

commit c9c52e24194a741f9fca96e7aa965f0fa36af504
Author: Deepak S <deepak.s@linux.intel.com>
Date:   Sat Mar 28 15:23:34 2015 +0530

    drm/i915/chv: Remove Wait for a previous gfx force-off
    
    On CHV, PUNIT team confirmed that 'VLV_GFX_CLK_STATUS_BIT' is not a
    sticky bit and it will always be set. So ignore Check for previous
    Gfx force off during suspend and allow the force clk as part S0ix
    Sequence
    
    Signed-off-by: Deepak S <deepak.s@linux.intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a8e6b7cbdf30..3fa3eae0ee06 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1200,11 +1200,13 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	int err;
 
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-	WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
 
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
 	/* Wait for a previous force-off to settle */
-	if (force_on) {
+	if (force_on && !IS_CHERRYVIEW(dev_priv->dev)) {
+		/* WARN_ON only for the Valleyview */
+		WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
+
 		err = wait_for(!COND, 20);
 		if (err) {
 			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",

commit 9c25210fd30991e68f93e2ec0857de2d967b5766
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Apr 1 14:22:57 2015 -0700

    drm/i915/vlv: save/restore the power context base reg
    
    Some BIOSes (e.g. the one on the Minnowboard) don't save/restore this
    reg.  If it's unlocked, we can just restore the previous value, and if
    it's locked (in case the BIOS re-programmed it for us) the write will be
    ignored and we'll still have "did it move" sanity check in the PM code to
    warn us if something is still amiss.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=89611
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Tested-by: Darren Hart <dvhart@linux.intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Deepak S <deepak.s@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cc6ea53d2b81..a8e6b7cbdf30 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1095,6 +1095,7 @@ static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
 	s->gu_ctl0		= I915_READ(VLV_GU_CTL0);
 	s->gu_ctl1		= I915_READ(VLV_GU_CTL1);
+	s->pcbr			= I915_READ(VLV_PCBR);
 	s->clock_gate_dis2	= I915_READ(VLV_GUNIT_CLOCK_GATE2);
 
 	/*
@@ -1189,6 +1190,7 @@ static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
 	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
 	I915_WRITE(VLV_GU_CTL0,			s->gu_ctl0);
 	I915_WRITE(VLV_GU_CTL1,			s->gu_ctl1);
+	I915_WRITE(VLV_PCBR,			s->pcbr);
 	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
 }
 

commit 85250ddff7a603dfe0ec0503a9e6395f79424f61
Author: Deepak S <deepak.s@linux.intel.com>
Date:   Sat Mar 28 15:23:34 2015 +0530

    drm/i915/chv: Remove Wait for a previous gfx force-off
    
    On CHV, PUNIT team confirmed that 'VLV_GFX_CLK_STATUS_BIT' is not a
    sticky bit and it will always be set. So ignore Check for previous
    Gfx force off during suspend and allow the force clk as part S0ix
    Sequence
    
    Signed-off-by: Deepak S <deepak.s@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82f8be4b6745..182d6a742778 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1194,11 +1194,13 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	int err;
 
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
-	WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
 
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
 	/* Wait for a previous force-off to settle */
-	if (force_on) {
+	if (force_on && !IS_CHERRYVIEW(dev_priv->dev)) {
+		/* WARN_ON only for the Valleyview */
+		WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
+
 		err = wait_for(!COND, 20);
 		if (err) {
 			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",

commit 7a8785f7eea5f1a35f10d2fbdee7df1febb850de
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 11 22:52:28 2015 +0200

    drm/i915: Remove the preliminary_hw_support shackles from CHV
    
    CHV should be in a good enough shape now, so let's drop the
    .is_preliminary flag.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 15f58d02acda..82f8be4b6745 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -346,7 +346,6 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 };
 
 static const struct intel_device_info intel_cherryview_info = {
-	.is_preliminary = 1,
 	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,

commit 9393943be66abb3131d06f43dbd94538733e1aa6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Feb 23 12:03:28 2015 +0100

    drm/i915: Remove irq-related FIXME in reset code
    
    With the two-step reset counter increments which braket the actual
    reset code and the subsequent wake-up we're guaranteeing that all the
    lockless waiters _will_ be woken up. And since we unconditionally bail
    out of waits with -EAGAIN (or -EIO) in that case there is not risk of
    lost interrupt enabling bits when the lockless wait code races against
    a gpu reset.
    
    Let's remove this FIXME as resolved then.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0001642c38b4..15f58d02acda 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -881,12 +881,6 @@ int i915_reset(struct drm_device *dev)
 		return ret;
 	}
 
-	/*
-	 * FIXME: This races pretty badly against concurrent holders of
-	 * ring interrupts. This is possible since we've started to drop
-	 * dev->struct_mutex in select places when waiting for the gpu.
-	 */
-
 	/*
 	 * rps/rc6 re-init is necessary to restore state lost after the
 	 * reset and the re-install of gt irqs. Skip for ironlake per

commit a8c6ecb3be7029881f7c95e5e201a629094a4e1a
Merge: 8dd0eb356671 9eccca084320
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 9 19:58:30 2015 +1000

    Merge tag 'v4.0-rc3' into drm-next
    
    Linux 4.0-rc3 backmerge to fix two i915 conflicts, and get
    some mainline bug fixes needed for my testing box
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/i915/intel_display.c

commit 8dd0eb3566711d81bfbe2b4421b33f0dd723cec4
Merge: d136dfeec84b f89fe1ffe698
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 9 19:41:15 2015 +1000

    Merge tag 'drm-intel-next-2015-02-27' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - Y tiling support for scanout from Tvrtko&Damien
    - Remove more UMS support
    - some small prep patches for OLR removal from John Harrison
    - first few patches for dynamic pagetable allocation from Ben Widawsky, rebased
      by tons of other people
    - DRRS support patches (Sonika&Vandana)
    - fbc patches from Paulo
    - make sure our vblank callbacks aren't called when the pipes are off
    - various patches all over
    
    * tag 'drm-intel-next-2015-02-27' of git://anongit.freedesktop.org/drm-intel: (61 commits)
      drm/i915: Update DRIVER_DATE to 20150227
      drm/i915: Clarify obj->map_and_fenceable
      drm/i915/skl: Allow Y (and Yf) frame buffer creation
      drm/i915/skl: Update watermarks for Y tiling
      drm/i915/skl: Updated watermark programming
      drm/i915/skl: Adjust get_plane_config() to support Yb/Yf tiling
      drm/i915/skl: Teach pin_and_fence_fb_obj() about Y tiling constraints
      drm/i915/skl: Adjust intel_fb_align_height() for Yb/Yf tiling
      drm/i915/skl: Allow scanning out Y and Yf fbs
      drm/i915/skl: Add new displayable tiling formats
      drm/i915: Remove DRIVER_MODESET checks from modeset code
      drm/i915: Remove regfile code&data for UMS suspend/resume
      drm/i915: Remove DRIVER_MODESET checks from gem code
      drm/i915: Remove DRIVER_MODESET checks in the gpu reset code
      drm/i915: Remove DRIVER_MODESET checks from suspend/resume code
      drm/i915: Remove DRIVER_MODESET checks in load/unload/close code
      drm/i915: fix a printk format
      drm/i915: Add media rc6 residency file to sysfs
      drm/i915: Add missing description to parameter in alloc_pt_range
      drm/i915: Removed the read of RP_STATE_CAP from sysfs/debugfs functions
      ...

commit 7547af91868f0ea940abc25460accc4025c5ce0a
Merge: 87dc8b6cbdd9 d4495cbaa586
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 5 09:41:09 2015 +1000

    Merge tag 'drm-intel-next-2015-02-14' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - use the atomic helpers for plane_upate/disable hooks (Matt Roper)
    - refactor the initial plane config code (Damien)
    - ppgtt prep patches for dynamic pagetable alloc (Ben Widawsky, reworked and
      rebased by a lot of other people)
    - framebuffer modifier support from Tvrtko Ursulin, drm core code from Rob Clark
    - piles of workaround patches for skl from Damien and Nick Hoath
    - vGPU support for xengt on the client side (Yu Zhang)
    - and the usual smaller things all over
    
    * tag 'drm-intel-next-2015-02-14' of git://anongit.freedesktop.org/drm-intel: (88 commits)
      drm/i915: Update DRIVER_DATE to 20150214
      drm/i915: Remove references to previously removed UMS config option
      drm/i915/skl: Use a LRI for WaDisableDgMirrorFixInHalfSliceChicken5
      drm/i915/skl: Fix always true comparison in a revision id check
      drm/i915/skl: Implement WaEnableLbsSlaRetryTimerDecrement
      drm/i915/skl: Implement WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken
      drm/i915: Add process identifier to requests
      drm/i915/skl: Implement WaBarrierPerformanceFixDisable
      drm/i915/skl: Implement WaCcsTlbPrefetchDisable:skl
      drm/i915/skl: Implement WaDisableChickenBitTSGBarrierAckForFFSliceCS
      drm/i915/skl: Implement WaDisableHDCInvalidation
      drm/i915/skl: Implement WaDisableLSQCROPERFforOCL
      drm/i915/skl: Implement WaDisablePartialResolveInVc
      drm/i915/skl: Introduce a SKL specific init_workarounds()
      drm/i915/skl: Document that we implement WaRsClearFWBitsAtReset
      drm/i915/skl: Implement WaSetGAPSunitClckGateDisable
      drm/i915/skl: Make the init clock gating function skylake specific
      drm/i915/skl: Provide a gen9 specific init_render_ring()
      drm/i915/skl: Document the WM read latency W/A with its name
      drm/i915/skl: Also detect eDRAM on SKL
      ...

commit ab3be73fa7b43f4c3648ce29b5fd649ea54d3adb
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Mar 2 13:04:41 2015 +0200

    drm/i915: gen4: work around hang during hibernation
    
    Bjørn reported that his machine hang during hibernation and eventually
    bisected the problem to the following commit:
    
    commit da2bc1b9db3351addd293e5b82757efe1f77ed1d
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Thu Oct 23 19:23:26 2014 +0300
    
        drm/i915: add poweroff_late handler
    
    The problem seems to be that after the kernel puts the device into D3
    the BIOS still tries to access it, or otherwise assumes that it's in D0.
    This is clearly bogus, since ACPI mandates that devices are put into D3
    by the OSPM if they are not wake-up sources. In the future we want to
    unify more of the driver's runtime and system suspend paths, for example
    by skipping all the system suspend/hibernation hooks if the device is
    runtime suspended already. Accordingly for all other platforms the goal
    is still to properly power down the device during hibernation.
    
    v2:
    - Another GEN4 Lenovo laptop had the same issue, while platforms from
      other vendors (including mobile and desktop, GEN4 and non-GEN4) seem
      to work fine. Based on this apply the workaround on all GEN4 Lenovo
      platforms.
    - add code comment about failing platforms (Ville)
    
    Reference: http://lists.freedesktop.org/archives/intel-gfx/2015-February/060633.html
    Reported-and-bisected-by: Bjørn Mork <bjorn@mork.no>
    Cc: stable@vger.kernel.org # v3.19
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8039cec71fc2..cc6ea53d2b81 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -622,7 +622,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	return 0;
 }
 
-static int i915_drm_suspend_late(struct drm_device *drm_dev)
+static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)
 {
 	struct drm_i915_private *dev_priv = drm_dev->dev_private;
 	int ret;
@@ -636,7 +636,17 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev)
 	}
 
 	pci_disable_device(drm_dev->pdev);
-	pci_set_power_state(drm_dev->pdev, PCI_D3hot);
+	/*
+	 * During hibernation on some GEN4 platforms the BIOS may try to access
+	 * the device even though it's already in D3 and hang the machine. So
+	 * leave the device in D0 on those platforms and hope the BIOS will
+	 * power down the device properly. Platforms where this was seen:
+	 * Lenovo Thinkpad X301, X61s
+	 */
+	if (!(hibernation &&
+	      drm_dev->pdev->subsystem_vendor == PCI_VENDOR_ID_LENOVO &&
+	      INTEL_INFO(dev_priv)->gen == 4))
+		pci_set_power_state(drm_dev->pdev, PCI_D3hot);
 
 	return 0;
 }
@@ -662,7 +672,7 @@ int i915_suspend_legacy(struct drm_device *dev, pm_message_t state)
 	if (error)
 		return error;
 
-	return i915_drm_suspend_late(dev);
+	return i915_drm_suspend_late(dev, false);
 }
 
 static int i915_drm_resume(struct drm_device *dev)
@@ -950,7 +960,17 @@ static int i915_pm_suspend_late(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_suspend_late(drm_dev);
+	return i915_drm_suspend_late(drm_dev, false);
+}
+
+static int i915_pm_poweroff_late(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
+
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
+	return i915_drm_suspend_late(drm_dev, true);
 }
 
 static int i915_pm_resume_early(struct device *dev)
@@ -1520,7 +1540,7 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.thaw_early = i915_pm_resume_early,
 	.thaw = i915_pm_resume,
 	.poweroff = i915_pm_suspend,
-	.poweroff_late = i915_pm_suspend_late,
+	.poweroff_late = i915_pm_poweroff_late,
 	.restore_early = i915_pm_resume_early,
 	.restore = i915_pm_resume,
 

commit 33d30a9c5e34cead70e053b7470e94d0b8a3ab79
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Feb 23 12:03:27 2015 +0100

    drm/i915: Remove DRIVER_MODESET checks in the gpu reset code
    
    Again, good riddance to UMS!
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c1a5377caff0..cc6c51107047 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -863,38 +863,35 @@ int i915_reset(struct drm_device *dev)
 	 * was running at the time of the reset (i.e. we weren't VT
 	 * switched away).
 	 */
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		/* Used to prevent gem_check_wedged returning -EAGAIN during gpu reset */
-		dev_priv->gpu_error.reload_in_reset = true;
 
-		ret = i915_gem_init_hw(dev);
+	/* Used to prevent gem_check_wedged returning -EAGAIN during gpu reset */
+	dev_priv->gpu_error.reload_in_reset = true;
 
-		dev_priv->gpu_error.reload_in_reset = false;
+	ret = i915_gem_init_hw(dev);
 
-		mutex_unlock(&dev->struct_mutex);
-		if (ret) {
-			DRM_ERROR("Failed hw init on reset %d\n", ret);
-			return ret;
-		}
-
-		/*
-		 * FIXME: This races pretty badly against concurrent holders of
-		 * ring interrupts. This is possible since we've started to drop
-		 * dev->struct_mutex in select places when waiting for the gpu.
-		 */
+	dev_priv->gpu_error.reload_in_reset = false;
 
-		/*
-		 * rps/rc6 re-init is necessary to restore state lost after the
-		 * reset and the re-install of gt irqs. Skip for ironlake per
-		 * previous concerns that it doesn't respond well to some forms
-		 * of re-init after reset.
-		 */
-		if (INTEL_INFO(dev)->gen > 5)
-			intel_enable_gt_powersave(dev);
-	} else {
-		mutex_unlock(&dev->struct_mutex);
+	mutex_unlock(&dev->struct_mutex);
+	if (ret) {
+		DRM_ERROR("Failed hw init on reset %d\n", ret);
+		return ret;
 	}
 
+	/*
+	 * FIXME: This races pretty badly against concurrent holders of
+	 * ring interrupts. This is possible since we've started to drop
+	 * dev->struct_mutex in select places when waiting for the gpu.
+	 */
+
+	/*
+	 * rps/rc6 re-init is necessary to restore state lost after the
+	 * reset and the re-install of gt irqs. Skip for ironlake per
+	 * previous concerns that it doesn't respond well to some forms
+	 * of re-init after reset.
+	 */
+	if (INTEL_INFO(dev)->gen > 5)
+		intel_enable_gt_powersave(dev);
+
 	return 0;
 }
 

commit d581893853fa8c68d49c033ed256c85d7df53ecd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Feb 23 12:03:26 2015 +0100

    drm/i915: Remove DRIVER_MODESET checks from suspend/resume code
    
    UMS is dead, yay!
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ba6862f5b6b2..c1a5377caff0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -574,6 +574,7 @@ static int i915_drm_suspend(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_crtc *crtc;
 	pci_power_t opregion_target_state;
+	int error;
 
 	/* ignore lid events during suspend */
 	mutex_lock(&dev_priv->modeset_restore_lock);
@@ -588,37 +589,32 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 	pci_save_state(dev->pdev);
 
-	/* If KMS is active, we do the leavevt stuff here */
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		int error;
-
-		error = i915_gem_suspend(dev);
-		if (error) {
-			dev_err(&dev->pdev->dev,
-				"GEM idle failed, resume might fail\n");
-			return error;
-		}
+	error = i915_gem_suspend(dev);
+	if (error) {
+		dev_err(&dev->pdev->dev,
+			"GEM idle failed, resume might fail\n");
+		return error;
+	}
 
-		intel_suspend_gt_powersave(dev);
+	intel_suspend_gt_powersave(dev);
 
-		/*
-		 * Disable CRTCs directly since we want to preserve sw state
-		 * for _thaw. Also, power gate the CRTC power wells.
-		 */
-		drm_modeset_lock_all(dev);
-		for_each_crtc(dev, crtc)
-			intel_crtc_control(crtc, false);
-		drm_modeset_unlock_all(dev);
+	/*
+	 * Disable CRTCs directly since we want to preserve sw state
+	 * for _thaw. Also, power gate the CRTC power wells.
+	 */
+	drm_modeset_lock_all(dev);
+	for_each_crtc(dev, crtc)
+		intel_crtc_control(crtc, false);
+	drm_modeset_unlock_all(dev);
 
-		intel_dp_mst_suspend(dev);
+	intel_dp_mst_suspend(dev);
 
-		intel_runtime_pm_disable_interrupts(dev_priv);
-		intel_hpd_cancel_work(dev_priv);
+	intel_runtime_pm_disable_interrupts(dev_priv);
+	intel_hpd_cancel_work(dev_priv);
 
-		intel_suspend_encoders(dev_priv);
+	intel_suspend_encoders(dev_priv);
 
-		intel_suspend_hw(dev);
-	}
+	intel_suspend_hw(dev);
 
 	i915_gem_suspend_gtt_mappings(dev);
 
@@ -690,53 +686,48 @@ static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		mutex_lock(&dev->struct_mutex);
-		i915_gem_restore_gtt_mappings(dev);
-		mutex_unlock(&dev->struct_mutex);
-	}
+	mutex_lock(&dev->struct_mutex);
+	i915_gem_restore_gtt_mappings(dev);
+	mutex_unlock(&dev->struct_mutex);
 
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
-	/* KMS EnterVT equivalent */
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		intel_init_pch_refclk(dev);
-		drm_mode_config_reset(dev);
+	intel_init_pch_refclk(dev);
+	drm_mode_config_reset(dev);
 
-		mutex_lock(&dev->struct_mutex);
-		if (i915_gem_init_hw(dev)) {
-			DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
-			atomic_set_mask(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
-		}
-		mutex_unlock(&dev->struct_mutex);
+	mutex_lock(&dev->struct_mutex);
+	if (i915_gem_init_hw(dev)) {
+		DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
+		atomic_set_mask(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
+	}
+	mutex_unlock(&dev->struct_mutex);
 
-		/* We need working interrupts for modeset enabling ... */
-		intel_runtime_pm_enable_interrupts(dev_priv);
+	/* We need working interrupts for modeset enabling ... */
+	intel_runtime_pm_enable_interrupts(dev_priv);
 
-		intel_modeset_init_hw(dev);
+	intel_modeset_init_hw(dev);
 
-		spin_lock_irq(&dev_priv->irq_lock);
-		if (dev_priv->display.hpd_irq_setup)
-			dev_priv->display.hpd_irq_setup(dev);
-		spin_unlock_irq(&dev_priv->irq_lock);
+	spin_lock_irq(&dev_priv->irq_lock);
+	if (dev_priv->display.hpd_irq_setup)
+		dev_priv->display.hpd_irq_setup(dev);
+	spin_unlock_irq(&dev_priv->irq_lock);
 
-		drm_modeset_lock_all(dev);
-		intel_modeset_setup_hw_state(dev, true);
-		drm_modeset_unlock_all(dev);
+	drm_modeset_lock_all(dev);
+	intel_modeset_setup_hw_state(dev, true);
+	drm_modeset_unlock_all(dev);
 
-		intel_dp_mst_resume(dev);
+	intel_dp_mst_resume(dev);
 
-		/*
-		 * ... but also need to make sure that hotplug processing
-		 * doesn't cause havoc. Like in the driver load code we don't
-		 * bother with the tiny race here where we might loose hotplug
-		 * notifications.
-		 * */
-		intel_hpd_init(dev_priv);
-		/* Config may have changed between suspend and resume */
-		drm_helper_hpd_irq_event(dev);
-	}
+	/*
+	 * ... but also need to make sure that hotplug processing
+	 * doesn't cause havoc. Like in the driver load code we don't
+	 * bother with the tiny race here where we might loose hotplug
+	 * notifications.
+	 * */
+	intel_hpd_init(dev_priv);
+	/* Config may have changed between suspend and resume */
+	drm_helper_hpd_irq_event(dev);
 
 	intel_opregion_init(dev);
 

commit 796e1c55717e9a6ff5c81b12289ffa1ffd919b6f
Merge: 8c334ce8f0fe 45ee2dbc65cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 16 15:48:00 2015 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull, it has a shared branch with some alsa
      crossover but everything should be acked by relevant people.
    
      New drivers:
         - ATMEL HLCDC driver
         - designware HDMI core support (used in multiple SoCs).
    
      core:
         - lots more atomic modesetting work, properties and atomic ioctl
           (hidden under option)
         - bridge rework allows support for Samsung exynos chromebooks to
           work finally.
         - some more panels supported
    
      i915:
         - atomic plane update support
         - DSI uses shared DSI infrastructure
         - Skylake basic support is all merged now
         - component framework used for i915/snd-hda interactions
         - write-combine cpu memory mappings
         - engine init code refactored
         - full ppgtt enabled where execlists are enabled.
         - cherryview rps/gpu turbo and pipe CRC support.
    
      radeon:
         - indirect draw support for evergreen/cayman
         - SMC and manual fan control for SI/CI
         - Displayport audio support
    
      amdkfd:
         - SDMA usermode queue support
         - replace suballocator usage with more suitable one
         - rework for allowing interfacing to more than radeon
    
      nouveau:
         - major renaming in prep for later splitting work
         - merge arm platform driver into nouveau
         - GK20A reclocking support
    
      msm:
         - conversion to atomic modesetting
         - YUV support for mdp4/5
         - eDP support
         - hw cursor for mdp5
    
      tegra:
         - conversion to atomic modesetting
         - better suspend/resume support for child devices
    
      rcar-du:
         - interlaced support
    
      imx:
         - move to using dw_hdmi shared support
         - mode_fixup support
    
      sti:
         - DVO support
         - HDMI infoframe support
    
      exynos:
         - refactoring and cleanup, removed lots of internal unnecessary
           abstraction
         - exynos7 DECON display controller support
    
      Along with the usual bunch of fixes, cleanups etc"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (724 commits)
      drm/radeon: fix voltage setup on hawaii
      drm/radeon/dp: Set EDP_CONFIGURATION_SET for bridge chips if necessary
      drm/radeon: only enable kv/kb dpm interrupts once v3
      drm/radeon: workaround for CP HW bug on CIK
      drm/radeon: Don't try to enable write-combining without PAT
      drm/radeon: use 0-255 rather than 0-100 for pwm fan range
      drm/i915: Clamp efficient frequency to valid range
      drm/i915: Really ignore long HPD pulses on eDP
      drm/exynos: Add DECON driver
      drm/i915: Correct the base value while updating LP_OUTPUT_HOLD in MIPI_PORT_CTRL
      drm/i915: Insert a command barrier on BLT/BSD cache flushes
      drm/i915: Drop vblank wait from intel_dp_link_down
      drm/exynos: fix NULL pointer reference
      drm/exynos: remove exynos_plane_dpms
      drm/exynos: remove mode property of exynos crtc
      drm/exynos: Remove exynos_plane_dpms() call with no effect
      drm/i915: Squelch overzealous uncore reset WARN_ON
      drm/i915: Take runtime pm reference on hangcheck_info
      drm/i915: Correct the IOSF Dev_FN field for IOSF transfers
      drm/exynos: fix DMA_ATTR_NO_KERNEL_MAPPING usage
      ...

commit cd5956c9136d80ca09faacf9622dc68426bec98c
Author: Andreas Ruprecht <rupran@einserver.de>
Date:   Fri Feb 6 11:16:47 2015 +0100

    drm/i915: Remove references to previously removed UMS config option
    
    Commit 03dae59c72ffffd8 ("drm/i915: Ditch UMS config option") removed
    CONFIG_DRM_I915_UMS from the Kconfig file, but i915_drv.c still
    references this option in two #ifndef statements.
    
    As an undefined config option will always be 'false', we can drop
    the #ifndefs alltogether and adapt the printed error message.
    
    This inconsistency was found with the undertaker tool.
    
    Signed-off-by: Andreas Ruprecht <rupran@einserver.de>
    [danvet: Undo logging change as requested by Jani.]
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 84a303152c91..ba6862f5b6b2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1651,11 +1651,9 @@ static int __init i915_init(void)
 
 	if (!(driver.driver_features & DRIVER_MODESET)) {
 		driver.get_vblank_timestamp = NULL;
-#ifndef CONFIG_DRM_I915_UMS
 		/* Silently fail loading to not upset userspace. */
 		DRM_DEBUG_DRIVER("KMS and UMS disabled.\n");
 		return 0;
-#endif
 	}
 
 	/*
@@ -1671,10 +1669,8 @@ static int __init i915_init(void)
 
 static void __exit i915_exit(void)
 {
-#ifndef CONFIG_DRM_I915_UMS
 	if (!(driver.driver_features & DRIVER_MODESET))
 		return; /* Never loaded a driver. */
-#endif
 
 	drm_pci_exit(&driver, &i915_pci_driver);
 }

commit 719388e146c34f065c275258e007a39b694aa68f
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Feb 4 13:22:27 2015 +0000

    drm/i915/skl: Declare that GT3 has a second VCS
    
    v2: leave intel_skylake_info alone (Rodrigo, Daniel)
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5f50e7033ef7..84a303152c91 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -369,6 +369,19 @@ static const struct intel_device_info intel_skylake_info = {
 	IVB_CURSOR_OFFSETS,
 };
 
+static const struct intel_device_info intel_skylake_gt3_info = {
+	.is_preliminary = 1,
+	.is_skylake = 1,
+	.gen = 9, .num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	.has_fbc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -406,7 +419,9 @@ static const struct intel_device_info intel_skylake_info = {
 	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),	\
 	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info), \
 	INTEL_CHV_IDS(&intel_cherryview_info),	\
-	INTEL_SKL_IDS(&intel_skylake_info)
+	INTEL_SKL_GT1_IDS(&intel_skylake_info),	\
+	INTEL_SKL_GT2_IDS(&intel_skylake_info),	\
+	INTEL_SKL_GT3_IDS(&intel_skylake_gt3_info)	\
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit 3fe9cf390f6dc84f76b112b0a660967a84f9a81b
Merge: 6ccd93bdb989 830953c0724b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 3 17:57:16 2015 +0100

    Merge branch 'topic/snd-device' into for-next

commit 737b1506037788f1e01b2a4c5795d4180b2e2e00
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 26 18:03:03 2015 +0200

    drm/i915: Convert hangcheck from a timer into a delayed work item
    
    When run as a timer, i915_hangcheck_elapsed() must adhere to all the
    rules of running in a softirq context. This is advantageous to us as we
    want to minimise the risk that a driver bug will prevent us from
    detecting a hung GPU. However, that is irrelevant if the driver bug
    prevents us from resetting and recovering. Still it is prudent not to
    rely on mutexes inside the checker, but given the coarseness of
    dev->struct_mutex doing so is extremely hard.
    
    Give in and run from a work queue, i.e. outside of softirq.
    
    v2: Use own workqueue to avoid deadlocks (Daniel)
        Cleanup commit msg and add comment to i915_queue_hangcheck() (Chris)
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Daniel Vetter <dnaiel.vetter@ffwll.chm>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    [danvet: Remove accidental kerneldoc comment starter, to appease the 0
    day builder.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9da4e60bdc7a..5f50e7033ef7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1402,7 +1402,7 @@ static int intel_runtime_suspend(struct device *device)
 		return ret;
 	}
 
-	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
+	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 	intel_uncore_forcewake_reset(dev, false);
 	dev_priv->pm.suspended = true;
 

commit b2e7723b09eb059584943febf47d637b2b8ca73f
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Thu Jan 22 16:53:12 2015 -0800

    drm/i915: Add i915.nuclear_pageflip command line param to force atomic (v4)
    
    We don't have full atomic modeset support yet, but the "nuclear
    pageflip" subset of functionality (i.e., plane operations only) should
    be ready.  Allow the user to force atomic on for debug purposes, or for
    fixed-purpose embedded devices that will only use atomic for plane
    updates.
    
    The term 'nuclear' is used here instead of 'atomic' to make it clear
    that this doesn't allow full atomic modeset support, just a (very
    useful) subset of the atomic functionality.
    
    We'll drop the kernel parameter and unconditionally enable atomic in a
    future patch once all of the necessary pieces are in.
    
    v2:
     - Use module_param_named_unsafe() (Daniel)
     - Simplify comment on DRIVER_ATOMIC guard (Daniel)
    
    v3:
     - Make the parameter "nuclear_pageflip" rather than just "nuclear"
       for clarity. (Ander)
    
    v4:
     - Make the internal variable "nuclear_pageflip" as well as the
       command-line option. (Ander)
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6484229dd10d..9da4e60bdc7a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1643,6 +1643,14 @@ static int __init i915_init(void)
 #endif
 	}
 
+	/*
+	 * FIXME: Note that we're lying to the DRM core here so that we can get access
+	 * to the atomic ioctl and the atomic properties.  Only plane operations on
+	 * a single CRTC will actually work.
+	 */
+	if (i915.nuclear_pageflip)
+		driver.driver_features |= DRIVER_ATOMIC;
+
 	return drm_pci_init(&driver, &i915_pci_driver);
 }
 

commit 59bad947180ddc22665e8b2b5f8f9ef65e8aab7f
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Fri Jan 16 11:34:40 2015 +0200

    drm/i915: Rename the forcewake get/put functions
    
    We have multiple forcewake domains now on recent gens. Change the
    function naming to reflect this.
    
    v2: More verbose names (Chris)
    v3: Rebase
    v4: Rebase
    v5: Add documentation for forcewake_get/put
    
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Deepak S <deepak.s@linux.intel.com> (v2)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 55a3fef075ae..6484229dd10d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1431,7 +1431,7 @@ static int intel_runtime_suspend(struct device *device)
 		intel_opregion_notify_adapter(dev, PCI_D3hot);
 	}
 
-	assert_force_wake_inactive(dev_priv);
+	assert_forcewakes_inactive(dev_priv);
 
 	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;

commit dc9fb09cae5b1355c1a9d8102e40b97b34332f31
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 16 11:34:34 2015 +0200

    drm/i915: Rebalance runtime pm vs forcewake
    
    Calling intel_runtime_pm_put() is illegal from a soft-irq context, so
    revert the crude hack
    
    commit aa0b3b5bb8768c1a6a6788869d9c7015eae7e80c
    Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Date:   Tue Apr 1 14:55:07 2014 -0300
    
        drm/i915: don't schedule force_wake_timer at gen6_read
    
    and apply the single line corrective instead.
    
    v2: assert forcewake is off after the forcewake_reset (Paulo)
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=80913
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Deepak S <deepak.s@linux.intel.com> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 308774f42079..55a3fef075ae 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1365,8 +1365,6 @@ static int intel_runtime_suspend(struct device *device)
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
 		return -ENODEV;
 
-	assert_force_wake_inactive(dev_priv);
-
 	DRM_DEBUG_KMS("Suspending device\n");
 
 	/*
@@ -1405,6 +1403,7 @@ static int intel_runtime_suspend(struct device *device)
 	}
 
 	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
+	intel_uncore_forcewake_reset(dev, false);
 	dev_priv->pm.suspended = true;
 
 	/*
@@ -1432,6 +1431,8 @@ static int intel_runtime_suspend(struct device *device)
 		intel_opregion_notify_adapter(dev, PCI_D3hot);
 	}
 
+	assert_force_wake_inactive(dev_priv);
+
 	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;
 }

commit a35cc9d0c0118fb18f7c5dd7a44adb454868a679
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Wed Jan 21 10:33:53 2015 -0800

    drm/i915: Fix and clean BDW PCH identification
    
    It seems in the past we have BDW with PCH not been propperly identified
    and we force it to be LPT and we were warning !IS_HASWELL on propper identification.
    
    Now that products are out there we are receiveing logs with this incorrect WARN.
    And also according to local tests on all production BDW here ULT or HALO we don't
    need this force anymore. So let's clean this block for real.
    
    v2: Fix LPT_LP WARNs to avoid wrong warns on BDW_ULT (By Jani).
    
    Reference: https://bugs.freedesktop.org/attachment.cgi?id=110972
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Xion Zhang <xiong.y.zhang@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 574057cd1d09..7643300828c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -462,19 +462,13 @@ void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
-				WARN_ON(!IS_HASWELL(dev));
-				WARN_ON(IS_HSW_ULT(dev));
-			} else if (IS_BROADWELL(dev)) {
-				dev_priv->pch_type = PCH_LPT;
-				dev_priv->pch_id =
-					INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
-				DRM_DEBUG_KMS("This is Broadwell, assuming "
-					      "LynxPoint LP PCH\n");
+				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(IS_HSW_ULT(dev) || IS_BDW_ULT(dev));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev));
-				WARN_ON(!IS_HSW_ULT(dev));
+				WARN_ON(!IS_HASWELL(dev) && !IS_BROADWELL(dev));
+				WARN_ON(!IS_HSW_ULT(dev) && !IS_BDW_ULT(dev));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");

commit 0a87a2db485a1456b7427914969c0e8195a1bbda
Merge: 7226572d8ed4 fcf3aac5fc30
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jan 12 23:07:46 2015 +0100

    Merge tag 'topic/i915-hda-componentized-2015-01-12' into drm-intel-next-queued
    
    Conflicts:
            drivers/gpu/drm/i915/intel_runtime_pm.c
    
    Separate branch so that Takashi can also pull just this refactoring
    into sound-next.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 888d0d421663313739a8bf93459c6ba61fd4b121
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Jan 8 17:54:13 2015 +0200

    drm/i915: add dev_to_i915 helper
    
    This will be needed by later patches, so factor it out.
    
    No functional change.
    
    v2:
    - s/dev_to_i915_priv/dev_to_i915/ (Jani)
    - don't use the helper in i915_pm_suspend (Chris)
    - simplify the helper (Chris)
    v3:
    - remove redundant upcasting in the helper (Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 574057cd1d09..cbbd23f78518 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -940,8 +940,7 @@ static int i915_pm_suspend(struct device *dev)
 
 static int i915_pm_suspend_late(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
 
 	/*
 	 * We have a suspedn ordering issue with the snd-hda driver also
@@ -960,8 +959,7 @@ static int i915_pm_suspend_late(struct device *dev)
 
 static int i915_pm_resume_early(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
@@ -971,8 +969,7 @@ static int i915_pm_resume_early(struct device *dev)
 
 static int i915_pm_resume(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct drm_device *drm_dev = dev_to_i915(dev)->dev;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;

commit da6b51d007da17fd394405055e2f0109ec5f05f4
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Dec 24 13:11:17 2014 +1000

    Revert "drm/gem: Warn on illegal use of the dumb buffer interface v2"
    
    This reverts commit 355a70183848f21198e9f6296bd646df3478a26d.
    
    This had some bad side effects under normal operation, and should
    have been dropped earlier.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fc8cfddbf232..574057cd1d09 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1586,7 +1586,7 @@ static struct drm_driver driver = {
 	.gem_prime_import = i915_gem_prime_import,
 
 	.dumb_create = i915_gem_dumb_create,
-	.dumb_map_offset = i915_gem_dumb_map_offset,
+	.dumb_map_offset = i915_gem_mmap_gtt,
 	.dumb_destroy = drm_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
 	.fops = &i915_driver_fops,

commit 98711167ce9e734dc0e41e158debb7f4c1269917
Author: Deepak S <deepak.s@linux.intel.com>
Date:   Fri Dec 12 14:18:16 2014 +0530

    drm/i915: Skip gunit save/restore for cherryview
    
    With cherryview onwards, Gunit hardware itself save and restore all the
    Gunit registers. Skipping the "vlv_save_gunit_s0ix_state" &
    "vlv_restore_gunit_s0ix_state" for cherryview in S3/S0ix sequence.
    
    Signed-off-by: Deepak S <deepak.s@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 71be3c930a0e..95bc829184eb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1298,7 +1298,9 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	err = vlv_allow_gt_wake(dev_priv, false);
 	if (err)
 		goto err2;
-	vlv_save_gunit_s0ix_state(dev_priv);
+
+	if (!IS_CHERRYVIEW(dev_priv->dev))
+		vlv_save_gunit_s0ix_state(dev_priv);
 
 	err = vlv_force_gfx_clock(dev_priv, false);
 	if (err)
@@ -1329,7 +1331,8 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
 	 */
 	ret = vlv_force_gfx_clock(dev_priv, true);
 
-	vlv_restore_gunit_s0ix_state(dev_priv);
+	if (!IS_CHERRYVIEW(dev_priv->dev))
+		vlv_restore_gunit_s0ix_state(dev_priv);
 
 	err = vlv_allow_gt_wake(dev_priv, true);
 	if (!ret)

commit dbea3cea69508e9d548ed4a6be13de35492e5d15
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Dec 15 18:59:28 2014 +0200

    drm/i915: sanitize RPS resetting during GPU reset
    
    Atm, we don't disable RPS interrupts and related work items before
    resetting the GPU. This may interfere with the following GPU
    initialization and cause RPS interrupts to show up in PM_IIR too early
    before calling gen6_enable_rps_interrupts() (triggering a WARN there).
    
    Solve this by disabling RPS interrupts and flushing any related work
    items before resetting the GPU.
    
    v2:
    - split out the common parts of the gt suspend and the new gt reset
      functions (Paulo)
    v3:
    - remove the check for UMS, it's a NOP nowadays (Daniel)
    
    Reported-by: He, Shuang <shuang.he@intel.com>
    Testcase: igt/gem_reset_stats/ban-render
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=86644
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f990ab4c3efb..fc8cfddbf232 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -811,6 +811,8 @@ int i915_reset(struct drm_device *dev)
 	if (!i915.reset)
 		return 0;
 
+	intel_reset_gt_powersave(dev);
+
 	mutex_lock(&dev->struct_mutex);
 
 	i915_gem_reset(dev);
@@ -880,7 +882,7 @@ int i915_reset(struct drm_device *dev)
 		 * of re-init after reset.
 		 */
 		if (INTEL_INFO(dev)->gen > 5)
-			intel_reset_gt_powersave(dev);
+			intel_enable_gt_powersave(dev);
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}

commit e7d6f7d708290da1b7c92f533444b042c79412e0
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 8 13:23:37 2014 +1000

    drm/i915: resume MST after reading back hw state
    
    Otherwise the MST resume paths can hit DPMS paths
    which hit state checker paths, which hit WARN_ON,
    because the state checker is inconsistent with the
    hw.
    
    This fixes a bunch of WARN_ON's on resume after
    undocking.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1e9c136a874c..f990ab4c3efb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -706,11 +706,12 @@ static int i915_drm_resume(struct drm_device *dev)
 			dev_priv->display.hpd_irq_setup(dev);
 		spin_unlock_irq(&dev_priv->irq_lock);
 
-		intel_dp_mst_resume(dev);
 		drm_modeset_lock_all(dev);
 		intel_modeset_setup_hw_state(dev, true);
 		drm_modeset_unlock_all(dev);
 
+		intel_dp_mst_resume(dev);
+
 		/*
 		 * ... but also need to make sure that hotplug processing
 		 * doesn't cause havoc. Like in the driver load code we don't

commit 1362b7764088d49cedf87cd9d0b6ac2f16306dbf
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 26 17:07:29 2014 +0200

    drm/i915: Deal with video overlay on GPU reset
    
    Clear the video overlay state on GPU reset. Any pending overlay request
    in the ring has been nuked, and the display itself gets reset. So we
    pretty much lose all state here. Adjust the software state to match so
    that the next "putimage" will restore things to working order.
    
    v2: Ass a locking check into intel_overlay_release_old_vid() (Daniel)
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: s/0/NULL/ to appease sparse, reported by 0-day tester.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1e9c136a874c..71be3c930a0e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -838,6 +838,8 @@ int i915_reset(struct drm_device *dev)
 		return ret;
 	}
 
+	intel_overlay_reset(dev_priv);
+
 	/* Ok, now get things going again... */
 
 	/*

commit 7514747d27632f2d71dd2f1e6abd6e0451dcbf3f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Nov 24 18:28:11 2014 +0200

    drm/i915: Grab modeset locks for GPU rest on pre-ctg
    
    On gen4 and earlier the GPU reset also resets the display, so we should
    protect against concurrent modeset operations. Grab all the modeset locks
    around the entire GPU reset dance, remebering first ti dislogde any
    pending page flip to make sure we don't deadlock. Any pageflip coming
    in between these two steps should fail anyway due to reset_in_progress,
    so this should be safe.
    
    This fixes a lot of failed asserts in the modeset code when there's a
    modeset racing with the reset. Naturally the asserts aren't happy when
    the expected state has disappeared.
    
    v2: Drop UMS checks, complete pending flips after the reset (Daniel)
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5066fd105512..1e9c136a874c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -880,25 +880,6 @@ int i915_reset(struct drm_device *dev)
 		 */
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
-
-
-		if (IS_GEN3(dev) || (IS_GEN4(dev) && !IS_G4X(dev))) {
-			intel_runtime_pm_disable_interrupts(dev_priv);
-			intel_runtime_pm_enable_interrupts(dev_priv);
-
-			intel_modeset_init_hw(dev);
-
-			spin_lock_irq(&dev_priv->irq_lock);
-			if (dev_priv->display.hpd_irq_setup)
-				dev_priv->display.hpd_irq_setup(dev);
-			spin_unlock_irq(&dev_priv->irq_lock);
-
-			drm_modeset_lock_all(dev);
-			intel_modeset_setup_hw_state(dev, true);
-			drm_modeset_unlock_all(dev);
-
-			intel_hpd_init(dev_priv);
-		}
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}

commit 408d4b9e1f0159583e81e093b3e7fe12a9b1072f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 21 21:54:28 2014 +0200

    drm/i915: Implement GPU reset for g33
    
    g33 seems to sit somewhere between the 915/945/965 style and the
    g4x style. The bits look like g4x, but we still need to do a full
    reset including display.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 44abd7b0051d..5066fd105512 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -881,8 +881,8 @@ int i915_reset(struct drm_device *dev)
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
 
-		if ((IS_GEN3(dev) && !IS_G33(dev)) ||
-		    (IS_GEN4(dev) && !IS_G4X(dev))) {
+
+		if (IS_GEN3(dev) || (IS_GEN4(dev) && !IS_G4X(dev))) {
 			intel_runtime_pm_disable_interrupts(dev_priv);
 			intel_runtime_pm_enable_interrupts(dev_priv);
 

commit 59ea90543f57a40827d7d1e528d657b8cc7161b1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 21 21:54:27 2014 +0200

    drm/i915: Implement GPU reset for 915/945
    
    915/945 have the same reset registers as 965, so share the code.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 68e42392f59c..44abd7b0051d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -881,7 +881,8 @@ int i915_reset(struct drm_device *dev)
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
 
-		if (IS_GEN4(dev) && !IS_G4X(dev)) {
+		if ((IS_GEN3(dev) && !IS_G33(dev)) ||
+		    (IS_GEN4(dev) && !IS_G4X(dev))) {
 			intel_runtime_pm_disable_interrupts(dev_priv);
 			intel_runtime_pm_enable_interrupts(dev_priv);
 

commit ca83b9361bf70d5d4171ba54a598a8c8f981f091
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 21 21:54:26 2014 +0200

    drm/i915: Restore the display config after a GPU reset on gen4
    
    On pre-ctg GPU reset also resets the display hardware. Force a mode
    restore after the GPU reset, and also re-init clock gating.
    
    v2: Use intel_modeset_init_hw() instead of intel_init_clock_gating()
        in case more relevant stuff gets added there at some point
        Restore interrupts after the reset as well
    
    Tested-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1e9c136a874c..68e42392f59c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -880,6 +880,24 @@ int i915_reset(struct drm_device *dev)
 		 */
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
+
+		if (IS_GEN4(dev) && !IS_G4X(dev)) {
+			intel_runtime_pm_disable_interrupts(dev_priv);
+			intel_runtime_pm_enable_interrupts(dev_priv);
+
+			intel_modeset_init_hw(dev);
+
+			spin_lock_irq(&dev_priv->irq_lock);
+			if (dev_priv->display.hpd_irq_setup)
+				dev_priv->display.hpd_irq_setup(dev);
+			spin_unlock_irq(&dev_priv->irq_lock);
+
+			drm_modeset_lock_all(dev);
+			intel_modeset_setup_hw_state(dev, true);
+			drm_modeset_unlock_all(dev);
+
+			intel_hpd_init(dev_priv);
+		}
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}

commit 26045b53c96f23b75a48544349c3d936e8402418
Merge: 1a92b7a241dc 064ca1d250b1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Dec 3 08:25:59 2014 +1000

    Merge tag 'drm-intel-next-2014-11-21-fixed' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2014-11-21:
    - infoframe tracking (for fastboot) from Jesse
    - start of the dri1/ums support removal
    - vlv forcewake timeout fixes (Imre)
    - bunch of patches to polish the rps code (Imre) and improve it on bdw (Tom
      O'Rourke)
    - on-demand pinning for execlist contexts
    - vlv/chv backlight improvements (Ville)
    - gen8+ render ctx w/a work from various people
    - skl edp programming (Satheeshakrishna et al.)
    - psr docbook (Rodrigo)
    - piles of little fixes and improvements all over, as usual
    
    * tag 'drm-intel-next-2014-11-21-fixed' of git://anongit.freedesktop.org/drm-intel: (117 commits)
      drm/i915: Don't pin LRC in GGTT when dumping in debugfs
      drm/i915: Update DRIVER_DATE to 20141121
      drm/i915/g4x: fix g4x infoframe readout
      drm/i915: Only call mod_timer() if not already pending
      drm/i915: Don't rely upon encoder->type for infoframe hw state readout
      drm/i915: remove the IRQs enabled WARN from intel_disable_gt_powersave
      drm/i915: Use ggtt error obj capture helper for gen8 semaphores
      drm/i915: vlv: increase timeout when setting idle GPU freq
      drm/i915: vlv: fix cdclk setting during modeset while suspended
      drm/i915: Dump hdmi pipe_config state
      drm/i915: Gen9 shadowed registers
      drm/i915/skl: Gen9 multi-engine forcewake
      drm/i915: Read power well status before other registers for drpc info
      drm/i915: Pin tiled objects for L-shaped configs
      drm/i915: Update ring freq for full gpu freq range
      drm/i915: change initial rps frequency for gen8
      drm/i915: Keep min freq above floor on HSW/BDW
      drm/i915: Use efficient frequency for HSW/BDW
      drm/i915: Can i915_gem_init_ioctl
      drm/i915: Sanitize ->lastclose
      ...

commit 355a70183848f21198e9f6296bd646df3478a26d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Nov 20 09:56:25 2014 +0100

    drm/gem: Warn on illegal use of the dumb buffer interface v2
    
    It happens on occasion that developers of generic user-space applications
    abuse the dumb buffer API to get hold of drm buffers that they can both
    mmap() and use for GPU acceleration, using the assumptions that dumb buffers
    and buffers available for GPU are
    a) The same type and can be aribtrarily type-casted.
    b) fully coherent.
    
    This patch makes the most widely used drivers warn nicely when that happens,
    the next step will be to fail.
    
    v2: Move drmP.h changes to drm_gem.h. Fix Radeon dumb mmap breakage.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2404b2baa01e..c743908b0a7e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1593,7 +1593,7 @@ static struct drm_driver driver = {
 	.gem_prime_import = i915_gem_prime_import,
 
 	.dumb_create = i915_gem_dumb_create,
-	.dumb_map_offset = i915_gem_mmap_gtt,
+	.dumb_map_offset = i915_gem_dumb_map_offset,
 	.dumb_destroy = drm_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
 	.fops = &i915_driver_fops,

commit 87255483070c1e5a37b39cdda4d1e98fa3a13516
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 19 20:36:48 2014 +0100

    drm/i915: Ditch dev_priv->ums.mm_suspend
    
    Again just complicates gem init functions and makes a general mess out
    of everything.
    
    Good riddance!
    
    v2: In my enthusiasm to start removing dri1/ums crud I went overboard a
    bit and killed parts of hangcheck. Resurrect it.
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c9f248acbd69..1df407941700 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -852,10 +852,7 @@ int i915_reset(struct drm_device *dev)
 	 * was running at the time of the reset (i.e. we weren't VT
 	 * switched away).
 	 */
-	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
-			!dev_priv->ums.mm_suspended) {
-		dev_priv->ums.mm_suspended = 0;
-
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		/* Used to prevent gem_check_wedged returning -EAGAIN during gpu reset */
 		dev_priv->gpu_error.reload_in_reset = true;
 

commit 5c6c600354adac5f95fd41b178b084ac0182e14c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Sep 6 10:28:27 2014 +0100

    drm/i915: Remove DRI1 ring accessors and API
    
    With the deprecation of UMS, and by association DRI1, we have a tough
    choice when updating the ring access routines. We either rewrite the
    DRI1 routines blindly without testing (so likely to be broken) or take
    the liberty of declaring them no longer supported and remove them
    entirely. This takes the latter approach.
    
    v2: Also remove the DRI1 sarea updates
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    [danvet: Fix rebase conflicts.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 19558d61b032..c9f248acbd69 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1573,8 +1573,6 @@ static struct drm_driver driver = {
 	.resume = i915_resume_legacy,
 
 	.device_is_agp = i915_driver_device_is_agp,
-	.master_create = i915_master_create,
-	.master_destroy = i915_master_destroy,
 #if defined(CONFIG_DEBUG_FS)
 	.debugfs_init = i915_debugfs_init,
 	.debugfs_cleanup = i915_debugfs_cleanup,

commit 2eb5252e2fffc52745a672152c7df597f4041045
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Nov 19 15:30:05 2014 +0200

    drm/i915: disable rps irqs earlier during suspend/unload
    
    After the previous patch RPS disabling doesn't depend any more on the
    first level interrupts being disabled, so we can move it everywhere
    earlier. Doing so let's us think about the uninitialization steps
    afterwards independently of any asynchronous RPS events that can happen
    atm. It also makes the system/runtime suspend time RPS disabling more
    uniform. Finally this gets rid of the WARN in
    intel_suspend_gt_powersave(), which we can hit if a final RPS work runs
    after we disabled the first level interrupts.
    
    Testcase: igt/pm_rpm
    Reference: https://bugs.freedesktop.org/show_bug.cgi?id=82939
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 122ea9549110..19558d61b032 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -584,6 +584,8 @@ static int i915_drm_suspend(struct drm_device *dev)
 			return error;
 		}
 
+		intel_suspend_gt_powersave(dev);
+
 		/*
 		 * Disable CRTCs directly since we want to preserve sw state
 		 * for _thaw. Also, power gate the CRTC power wells.
@@ -595,15 +597,11 @@ static int i915_drm_suspend(struct drm_device *dev)
 
 		intel_dp_mst_suspend(dev);
 
-		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
-
 		intel_runtime_pm_disable_interrupts(dev_priv);
 		intel_hpd_cancel_work(dev_priv);
 
 		intel_suspend_encoders(dev_priv);
 
-		intel_suspend_gt_powersave(dev);
-
 		intel_suspend_hw(dev);
 	}
 
@@ -1393,9 +1391,8 @@ static int intel_runtime_suspend(struct device *device)
 	i915_gem_release_all_mmaps(dev_priv);
 	mutex_unlock(&dev->struct_mutex);
 
-	flush_delayed_work(&dev_priv->rps.delayed_resume_work);
-	intel_runtime_pm_disable_interrupts(dev_priv);
 	intel_suspend_gt_powersave(dev);
+	intel_runtime_pm_disable_interrupts(dev_priv);
 
 	ret = intel_suspend_complete(dev_priv);
 	if (ret) {

commit 5ea13be5badca78a11921b864db380274279c8b9
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Nov 12 14:48:52 2014 +0200

    drm/i915: remove the unnecessary block around display.hpd_irq_setup
    
    The block was added for spin_lock_irqsave flags, but since the locking
    was converted to spin_lock_irq variant, the block is no longer needed.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2404b2baa01e..122ea9549110 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -703,12 +703,10 @@ static int i915_drm_resume(struct drm_device *dev)
 
 		intel_modeset_init_hw(dev);
 
-		{
-			spin_lock_irq(&dev_priv->irq_lock);
-			if (dev_priv->display.hpd_irq_setup)
-				dev_priv->display.hpd_irq_setup(dev);
-			spin_unlock_irq(&dev_priv->irq_lock);
-		}
+		spin_lock_irq(&dev_priv->irq_lock);
+		if (dev_priv->display.hpd_irq_setup)
+			dev_priv->display.hpd_irq_setup(dev);
+		spin_unlock_irq(&dev_priv->irq_lock);
 
 		intel_dp_mst_resume(dev);
 		drm_modeset_lock_all(dev);

commit fac6adb06a530ead523a60c975bae633e44335ca
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Thu Oct 30 15:59:31 2014 -0200

    drm/i915: fix RPS on runtime suspend
    
    With this patch, the RPS sequence for runtime suspend/resume is
    exactly like the sequence for S3 suspend/resume:
     - flush_delayed_work(&dev_priv->rps.delayed_resume_work)
     - intel_runtime_pm_disable_interrupts()
     - intel_suspend_gt_powersave()
       (suspended)
     - intel_runtime_pm_enable_interrupts()
     - intel_enable_gt_powersave()
    
    With this, we get rid of WARNs that are currently intermittently
    triggered by the system-suspend-execbuf subtest of runtime PM. Notice
    that these WARNs could also be triggered in other ways that involved
    doing lots of RPM suspend/resume cycles just after a system S3 resume.
    
    Testcase: igt/pm_rpm/system-suspend-execbuf
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reference: https://bugs.freedesktop.org/show_bug.cgi?id=82939
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0c7cf480e854..2404b2baa01e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1395,13 +1395,9 @@ static int intel_runtime_suspend(struct device *device)
 	i915_gem_release_all_mmaps(dev_priv);
 	mutex_unlock(&dev->struct_mutex);
 
-	/*
-	 * rps.work can't be rearmed here, since we get here only after making
-	 * sure the GPU is idle and the RPS freq is set to the minimum. See
-	 * intel_mark_idle().
-	 */
-	cancel_work_sync(&dev_priv->rps.work);
+	flush_delayed_work(&dev_priv->rps.delayed_resume_work);
 	intel_runtime_pm_disable_interrupts(dev_priv);
+	intel_suspend_gt_powersave(dev);
 
 	ret = intel_suspend_complete(dev_priv);
 	if (ret) {
@@ -1473,7 +1469,7 @@ static int intel_runtime_resume(struct device *device)
 	gen6_update_ring_freq(dev);
 
 	intel_runtime_pm_enable_interrupts(dev_priv);
-	intel_reset_gt_powersave(dev);
+	intel_enable_gt_powersave(dev);
 
 	if (ret)
 		DRM_ERROR("Runtime resume failed, disabling it (%d)\n", ret);

commit efee833a2d0a69dfa2c4ec28377b00803a0f9a60
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Oct 27 17:54:33 2014 -0200

    drm/i915: run hsw_disable_pc8() later on resume
    
    We want to run intel_uncore_early_sanitize() before we touch any
    registers, because on BDW, when we resume, the FPGA_DBG_RM_NOCLAIM bit
    is set, so we need to clear it - through intel_uncore_early_sanitize()
    - before we do anything else. With the current code, we don't clear
    the bit before our first register access, so we print a WARN
    complaining about an unclaimed register error.
    
    v1: Was called "drm/i915: run intel_uncore_early_sanitize earlier on
    resume"
    v2: Was called "drm/i915: run intel_uncore_early_sanitize earlier on
    resume on non-VLV"
    v3: This one, on top of the intel_resume_prepare() rework.
    v4: Rebase.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 33b6fc49dda7..0c7cf480e854 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -760,14 +760,16 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
-		hsw_disable_pc8(dev_priv);
-	else if (IS_VALLEYVIEW(dev_priv))
+	if (IS_VALLEYVIEW(dev_priv))
 		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
 		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
 
 	intel_uncore_early_sanitize(dev, true);
+
+	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		hsw_disable_pc8(dev_priv);
+
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);
 

commit 1a5df187172a92ffdf8dc89988154d512d66a896
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Oct 27 17:54:32 2014 -0200

    drm/i915: kill intel_resume_prepare()
    
    Because, really, the abstraction is not working for us. It is nice for
    VLV, but doesn't add anything useful on SNB/HSW/BDW. We want to change
    this code due to a recently-discovered bug, but we can't seem to find
    a nice solution that repects the current abstraction. So let's kill
    intel_resume_prepare() and its friends, and add an equivalent
    implementation to both its callers.
    
    Also, look at the diffstat!
    
    v2: - Rebase.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 035ec94ca3c7..33b6fc49dda7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -551,8 +551,8 @@ static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
 }
 
 static int intel_suspend_complete(struct drm_i915_private *dev_priv);
-static int intel_resume_prepare(struct drm_i915_private *dev_priv,
-				bool rpm_resume);
+static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
+			      bool rpm_resume);
 
 static int i915_drm_suspend(struct drm_device *dev)
 {
@@ -744,7 +744,7 @@ static int i915_drm_resume(struct drm_device *dev)
 static int i915_drm_resume_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret;
+	int ret = 0;
 
 	/*
 	 * We have a resume ordering issue with the snd-hda driver also
@@ -760,7 +760,10 @@ static int i915_drm_resume_early(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	ret = intel_resume_prepare(dev_priv, false);
+	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		hsw_disable_pc8(dev_priv);
+	else if (IS_VALLEYVIEW(dev_priv))
+		ret = vlv_resume_prepare(dev_priv, false);
 	if (ret)
 		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
 
@@ -986,25 +989,6 @@ static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
-static int snb_resume_prepare(struct drm_i915_private *dev_priv,
-				bool rpm_resume)
-{
-	struct drm_device *dev = dev_priv->dev;
-
-	if (rpm_resume)
-		intel_init_pch_refclk(dev);
-
-	return 0;
-}
-
-static int hsw_resume_prepare(struct drm_i915_private *dev_priv,
-				bool rpm_resume)
-{
-	hsw_disable_pc8(dev_priv);
-
-	return 0;
-}
-
 /*
  * Save all Gunit registers that may be lost after a D3 and a subsequent
  * S0i[R123] transition. The list of registers needing a save/restore is
@@ -1462,7 +1446,7 @@ static int intel_runtime_resume(struct device *device)
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret;
+	int ret = 0;
 
 	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
 		return -ENODEV;
@@ -1472,7 +1456,13 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	ret = intel_resume_prepare(dev_priv, true);
+	if (IS_GEN6(dev_priv))
+		intel_init_pch_refclk(dev);
+	else if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+		hsw_disable_pc8(dev_priv);
+	else if (IS_VALLEYVIEW(dev_priv))
+		ret = vlv_resume_prepare(dev_priv, true);
+
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
@@ -1510,29 +1500,6 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-/*
- * This function implements common functionality of runtime and system
- * resume sequence. Variable rpm_resume used for implementing different
- * code paths.
- */
-static int intel_resume_prepare(struct drm_i915_private *dev_priv,
-				bool rpm_resume)
-{
-	struct drm_device *dev = dev_priv->dev;
-	int ret;
-
-	if (IS_GEN6(dev))
-		ret = snb_resume_prepare(dev_priv, rpm_resume);
-	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
-		ret = hsw_resume_prepare(dev_priv, rpm_resume);
-	else if (IS_VALLEYVIEW(dev))
-		ret = vlv_resume_prepare(dev_priv, rpm_resume);
-	else
-		ret = 0;
-
-	return ret;
-}
-
 static const struct dev_pm_ops i915_pm_ops = {
 	/*
 	 * S0ix (via system suspend) and S3 event handlers [PMSG_SUSPEND,

commit 5545dbbfb3bb7a5ab5ced991e08d1c312326e843
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:28 2014 +0300

    drm/i915: add comments on what stage a given PM handler is called
    
    This will hopefully make it easier to navigate the code without the need
    to consult the full PM documentation.
    
    v2:
    - add a comment that the freeze handler is also called after rebooting
    - add a comment that the thaw handler is also called to recover from
      errors (Ville)
    - add the PM event names (PMSG_THAW etc.) for reference (Ville)
    - add comments that s0ix can be handled both via system and runtime
      suspend (Ville)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bce58d395b28..035ec94ca3c7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1534,10 +1534,30 @@ static int intel_resume_prepare(struct drm_i915_private *dev_priv,
 }
 
 static const struct dev_pm_ops i915_pm_ops = {
+	/*
+	 * S0ix (via system suspend) and S3 event handlers [PMSG_SUSPEND,
+	 * PMSG_RESUME]
+	 */
 	.suspend = i915_pm_suspend,
 	.suspend_late = i915_pm_suspend_late,
 	.resume_early = i915_pm_resume_early,
 	.resume = i915_pm_resume,
+
+	/*
+	 * S4 event handlers
+	 * @freeze, @freeze_late    : called (1) before creating the
+	 *                            hibernation image [PMSG_FREEZE] and
+	 *                            (2) after rebooting, before restoring
+	 *                            the image [PMSG_QUIESCE]
+	 * @thaw, @thaw_early       : called (1) after creating the hibernation
+	 *                            image, before writing it [PMSG_THAW]
+	 *                            and (2) after failing to create or
+	 *                            restore the image [PMSG_RECOVER]
+	 * @poweroff, @poweroff_late: called after writing the hibernation
+	 *                            image, before rebooting [PMSG_HIBERNATE]
+	 * @restore, @restore_early : called after rebooting and restoring the
+	 *                            hibernation image [PMSG_RESTORE]
+	 */
 	.freeze = i915_pm_suspend,
 	.freeze_late = i915_pm_suspend_late,
 	.thaw_early = i915_pm_resume_early,
@@ -1546,6 +1566,8 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.poweroff_late = i915_pm_suspend_late,
 	.restore_early = i915_pm_resume_early,
 	.restore = i915_pm_resume,
+
+	/* S0ix (via runtime suspend) event handlers */
 	.runtime_suspend = intel_runtime_suspend,
 	.runtime_resume = intel_runtime_resume,
 };

commit fc49b3da0e1f20484ac069982e2dcbf1a53f60af
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:27 2014 +0300

    drm/i915: unify switcheroo and legacy suspend/resume handlers
    
    By now we handle switcheroo and legacy suspend/resume the same way, so
    no need to keep separate functions for them.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 808f6591317a..bce58d395b28 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -649,7 +649,7 @@ static int i915_drm_suspend_late(struct drm_device *drm_dev)
 	return 0;
 }
 
-int i915_suspend(struct drm_device *dev, pm_message_t state)
+int i915_suspend_legacy(struct drm_device *dev, pm_message_t state)
 {
 	int error;
 
@@ -771,7 +771,7 @@ static int i915_drm_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-static int i915_resume_legacy(struct drm_device *dev)
+int i915_resume_legacy(struct drm_device *dev)
 {
 	int ret;
 
@@ -785,11 +785,6 @@ static int i915_resume_legacy(struct drm_device *dev)
 	return i915_drm_resume(dev);
 }
 
-int i915_resume(struct drm_device *dev)
-{
-	return i915_resume_legacy(dev);
-}
-
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -1592,7 +1587,7 @@ static struct drm_driver driver = {
 	.set_busid = drm_pci_set_busid,
 
 	/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
-	.suspend = i915_suspend,
+	.suspend = i915_suspend_legacy,
 	.resume = i915_resume_legacy,
 
 	.device_is_agp = i915_driver_device_is_agp,

commit da2bc1b9db3351addd293e5b82757efe1f77ed1d
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:26 2014 +0300

    drm/i915: add poweroff_late handler
    
    The suspend_late handler saves some registers and powers off the device,
    so it doesn't have a big overhead. Calling it at S4 poweroff_late time
    makes the power off handling identical to the S3 suspend and S4 freeze
    handling, so do this for consistency.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8b2b34cc6552..808f6591317a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1548,6 +1548,7 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.thaw_early = i915_pm_resume_early,
 	.thaw = i915_pm_resume,
 	.poweroff = i915_pm_suspend,
+	.poweroff_late = i915_pm_suspend_late,
 	.restore_early = i915_pm_resume_early,
 	.restore = i915_pm_resume,
 	.runtime_suspend = intel_runtime_suspend,

commit 5e365c391aeffe8b53d6952c28a68bd5fc856390
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:25 2014 +0300

    drm/i915: sanitize suspend/resume helper function names
    
    By now the S4 freeze/thaw and S3 suspend/resume events are handled the
    same way, so we can rename the freeze/thaw internal helpers to
    suspend/resume accordingly to make clearer what the helpers do. Also
    rename i915_resume_early to i915_drm_resume_early aligning it with the
    rest of the helper names.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2190d0f61018..8b2b34cc6552 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -554,7 +554,7 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv);
 static int intel_resume_prepare(struct drm_i915_private *dev_priv,
 				bool rpm_resume);
 
-static int i915_drm_freeze(struct drm_device *dev)
+static int i915_drm_suspend(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_crtc *crtc;
@@ -666,14 +666,14 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	error = i915_drm_freeze(dev);
+	error = i915_drm_suspend(dev);
 	if (error)
 		return error;
 
 	return i915_drm_suspend_late(dev);
 }
 
-static int __i915_drm_thaw(struct drm_device *dev)
+static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
@@ -741,7 +741,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 	return 0;
 }
 
-static int i915_resume_early(struct drm_device *dev)
+static int i915_drm_resume_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
@@ -771,11 +771,6 @@ static int i915_resume_early(struct drm_device *dev)
 	return ret;
 }
 
-static int i915_drm_resume(struct drm_device *dev)
-{
-	return __i915_drm_thaw(dev);
-}
-
 static int i915_resume_legacy(struct drm_device *dev)
 {
 	int ret;
@@ -783,7 +778,7 @@ static int i915_resume_legacy(struct drm_device *dev)
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	ret = i915_resume_early(dev);
+	ret = i915_drm_resume_early(dev);
 	if (ret)
 		return ret;
 
@@ -944,7 +939,7 @@ static int i915_pm_suspend(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_freeze(drm_dev);
+	return i915_drm_suspend(drm_dev);
 }
 
 static int i915_pm_suspend_late(struct device *dev)
@@ -975,7 +970,7 @@ static int i915_pm_resume_early(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_resume_early(drm_dev);
+	return i915_drm_resume_early(drm_dev);
 }
 
 static int i915_pm_resume(struct device *dev)

commit 36d61e6751d16fa80a4355b9708ff24ab7536f89
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:24 2014 +0300

    drm/i915: unify S3 and S4 suspend/resume handlers
    
    The S3 and S4 events are now handled the same way internally, there is no
    need to keep separate wrapper functions around them. Simply reuse the
    suspend/resume versions everywhere.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index be4cb1d4f3e9..2190d0f61018 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -673,22 +673,6 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	return i915_drm_suspend_late(dev);
 }
 
-static int i915_drm_thaw_early(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret;
-
-	ret = intel_resume_prepare(dev_priv, false);
-	if (ret)
-		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
-
-	intel_uncore_early_sanitize(dev, true);
-	intel_uncore_sanitize(dev);
-	intel_power_domains_init_hw(dev_priv);
-
-	return ret;
-}
-
 static int __i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -757,13 +741,11 @@ static int __i915_drm_thaw(struct drm_device *dev)
 	return 0;
 }
 
-static int i915_drm_thaw(struct drm_device *dev)
-{
-	return __i915_drm_thaw(dev);
-}
-
 static int i915_resume_early(struct drm_device *dev)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
+
 	/*
 	 * We have a resume ordering issue with the snd-hda driver also
 	 * requiring our device to be power up. Due to the lack of a
@@ -778,7 +760,15 @@ static int i915_resume_early(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	return i915_drm_thaw_early(dev);
+	ret = intel_resume_prepare(dev_priv, false);
+	if (ret)
+		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
+
+	intel_uncore_early_sanitize(dev, true);
+	intel_uncore_sanitize(dev);
+	intel_power_domains_init_hw(dev_priv);
+
+	return ret;
 }
 
 static int i915_drm_resume(struct drm_device *dev)
@@ -999,66 +989,6 @@ static int i915_pm_resume(struct device *dev)
 	return i915_drm_resume(drm_dev);
 }
 
-static int i915_pm_freeze(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-
-	if (!drm_dev || !drm_dev->dev_private) {
-		dev_err(dev, "DRM not initialized, aborting suspend.\n");
-		return -ENODEV;
-	}
-
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
-	return i915_drm_freeze(drm_dev);
-}
-
-static int i915_pm_freeze_late(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
-	return i915_drm_suspend_late(drm_dev);
-}
-
-static int i915_pm_thaw_early(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
-	return i915_resume_early(drm_dev);
-}
-
-static int i915_pm_thaw(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
-	return i915_drm_thaw(drm_dev);
-}
-
-static int i915_pm_poweroff(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-
-	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
-	return i915_drm_freeze(drm_dev);
-}
-
 static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
@@ -1618,11 +1548,11 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.suspend_late = i915_pm_suspend_late,
 	.resume_early = i915_pm_resume_early,
 	.resume = i915_pm_resume,
-	.freeze = i915_pm_freeze,
-	.freeze_late = i915_pm_freeze_late,
-	.thaw_early = i915_pm_thaw_early,
-	.thaw = i915_pm_thaw,
-	.poweroff = i915_pm_poweroff,
+	.freeze = i915_pm_suspend,
+	.freeze_late = i915_pm_suspend_late,
+	.thaw_early = i915_pm_resume_early,
+	.thaw = i915_pm_resume,
+	.poweroff = i915_pm_suspend,
 	.restore_early = i915_pm_resume_early,
 	.restore = i915_pm_resume,
 	.runtime_suspend = intel_runtime_suspend,

commit f2476ae65e6159b41168bc41c630e9fbb1d72dde
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:23 2014 +0300

    drm/i915: disable/re-enable PCI device around S4 freeze/thaw
    
    We already disable everything during S4 freeze, except the PCI device
    itself. There is no reason why we couldn't disable that too and doing
    so allows us to unify these handlers in the next patch with the
    corresponding S3 suspend/resume handlers.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4524c615f0a7..be4cb1d4f3e9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1019,12 +1019,11 @@ static int i915_pm_freeze_late(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-	struct drm_i915_private *dev_priv = drm_dev->dev_private;
 
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return intel_suspend_complete(dev_priv);
+	return i915_drm_suspend_late(drm_dev);
 }
 
 static int i915_pm_thaw_early(struct device *dev)
@@ -1035,7 +1034,7 @@ static int i915_pm_thaw_early(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	return i915_drm_thaw_early(drm_dev);
+	return i915_resume_early(drm_dev);
 }
 
 static int i915_pm_thaw(struct device *dev)

commit ee6f280e7895c838d90e8ef19ba737c8003ae85d
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:22 2014 +0300

    drm/i915: enable output polling during S4 thaw
    
    To avoid processing hotplug events we disable connector polling for the
    duration of S3 suspend. We also disable it for S4 freeze, and keep it
    disabled after S4 thaw. This won't prevent though hotplug processing,
    since we re-enable interrupts anyway. There is also no need to prevent
    it at that time, since we reinitialize everything during thaw, so the
    device is in a consistent state. So to simplify things enable polling
    during thaw, which will allow us to handle S4 thaw the same way as S3
    resume in an upcoming patch.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d0f721fb25ad..4524c615f0a7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -752,6 +752,8 @@ static int __i915_drm_thaw(struct drm_device *dev)
 
 	intel_opregion_notify_adapter(dev, PCI_D0);
 
+	drm_kms_helper_poll_enable(dev);
+
 	return 0;
 }
 
@@ -781,14 +783,7 @@ static int i915_resume_early(struct drm_device *dev)
 
 static int i915_drm_resume(struct drm_device *dev)
 {
-	int ret;
-
-	ret = __i915_drm_thaw(dev);
-	if (ret)
-		return ret;
-
-	drm_kms_helper_poll_enable(dev);
-	return 0;
+	return __i915_drm_thaw(dev);
 }
 
 static int i915_resume_legacy(struct drm_device *dev)

commit ed49388384b19ed37567053de7b4087ba990813e
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:21 2014 +0300

    drm/i915: check for GT faults in all resume handlers and driver load time
    
    Checking for GT faults is not specific in any way to S4 thaw, so do it
    also during S3 resume, S4 restore and driver load time. This allows us to
    unify the Sx handlers in an upcoming patch.
    
    v2:
    - move the check to intel_uncore_early_sanitize(), so we check at driver
      load time too (Chris)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9c934bec3ef1..d0f721fb25ad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -757,9 +757,6 @@ static int __i915_drm_thaw(struct drm_device *dev)
 
 static int i915_drm_thaw(struct drm_device *dev)
 {
-	if (drm_core_check_feature(dev, DRIVER_MODESET))
-		i915_check_and_clear_faults(dev);
-
 	return __i915_drm_thaw(dev);
 }
 

commit f4a12ead50580c17c3641ac1a453e68b5a5195dd
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:20 2014 +0300

    drm/i915: remove unused restore_gtt_mappings optimization during suspend
    
    The logic to skip restoring GTT mappings was added to speed up
    suspend/resume, but not on old GENs where not restoring them caused
    problems. The check for old GENs is based on the existence of OpRegion,
    but this doesn't work since opregion is initialized only after
    the check. So we end up always restoring the mappings.
    
    On my BYT - which has OpRegion - skipping restoring the mappings during
    suspend doesn't work, I get a GPU hang after resume. Also the logic of
    when to allow the optimization during S4 is reversed: we should allow it
    during S4 thaw but not during S4 restore, but atm we have it the other
    way around in the code.
    
    Since correctness wins over optimal code and since the optimization
    wasn't used anyway I decided not to try to fix it at this point, but
    just remove it. This allows us to unify the S3 and S4 handlers in the
    following patches.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 69936322f87d..9c934bec3ef1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -689,12 +689,11 @@ static int i915_drm_thaw_early(struct drm_device *dev)
 	return ret;
 }
 
-static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
+static int __i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
-	    restore_gtt_mappings) {
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
 		i915_gem_restore_gtt_mappings(dev);
 		mutex_unlock(&dev->struct_mutex);
@@ -761,7 +760,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 	if (drm_core_check_feature(dev, DRIVER_MODESET))
 		i915_check_and_clear_faults(dev);
 
-	return __i915_drm_thaw(dev, true);
+	return __i915_drm_thaw(dev);
 }
 
 static int i915_resume_early(struct drm_device *dev)
@@ -785,15 +784,9 @@ static int i915_resume_early(struct drm_device *dev)
 
 static int i915_drm_resume(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
-	/*
-	 * Platforms with opregion should have sane BIOS, older ones (gen3 and
-	 * earlier) need to restore the GTT mappings since the BIOS might clear
-	 * all our scratch PTEs.
-	 */
-	ret = __i915_drm_thaw(dev, !dev_priv->opregion.header);
+	ret = __i915_drm_thaw(dev);
 	if (ret)
 		return ret;
 

commit 097dd83763bfe8e8643957c0b90819742fb01cd9
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:19 2014 +0300

    drm/i915: fix S4 suspend while switcheroo state is off
    
    If the device is suspended already through the switcheroo interface we
    shouldn't suspend it again or resume it after suspend. We have the
    corresponding check for S3 suspend already, add it for all the other
    S3 and S4 handlers. Also move the check from i915_resume_early() to
    i915_resume_legacy(), so that it's done in the high level handler for
    all PM events.
    
    v2:
    - fix the resume path too, we don't need to special case there
      DRM_SWITCH_POWER_OFF with the device being enabled (in which case we'd
      have to disable the device), since that never happens (Ville)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 203bd820d5f7..69936322f87d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -766,9 +766,6 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 static int i915_resume_early(struct drm_device *dev)
 {
-	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
-		return 0;
-
 	/*
 	 * We have a resume ordering issue with the snd-hda driver also
 	 * requiring our device to be power up. Due to the lack of a
@@ -808,6 +805,9 @@ static int i915_resume_legacy(struct drm_device *dev)
 {
 	int ret;
 
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	ret = i915_resume_early(dev);
 	if (ret)
 		return ret;
@@ -997,6 +997,9 @@ static int i915_pm_resume_early(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_resume_early(drm_dev);
 }
 
@@ -1005,6 +1008,9 @@ static int i915_pm_resume(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_drm_resume(drm_dev);
 }
 
@@ -1018,6 +1024,9 @@ static int i915_pm_freeze(struct device *dev)
 		return -ENODEV;
 	}
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_drm_freeze(drm_dev);
 }
 
@@ -1027,6 +1036,9 @@ static int i915_pm_freeze_late(struct device *dev)
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = drm_dev->dev_private;
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return intel_suspend_complete(dev_priv);
 }
 
@@ -1035,6 +1047,9 @@ static int i915_pm_thaw_early(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_drm_thaw_early(drm_dev);
 }
 
@@ -1043,6 +1058,9 @@ static int i915_pm_thaw(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_drm_thaw(drm_dev);
 }
 
@@ -1051,6 +1069,9 @@ static int i915_pm_poweroff(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	return i915_drm_freeze(drm_dev);
 }
 

commit 5a17514ed924201f1465e4a2f5209bdb192d8dff
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:18 2014 +0300

    drm/i915: vlv: fix switcheroo/legacy suspend/resume
    
    During switcheroo/legacy suspend we don't call the suspend_late handler
    but when resuming afterwards we call resume_early. This happened to work
    so far, since suspend_late only disabled the PCI device. This changed in
    
    commit 016970beb05da6285c2f3ed2bee1c676cb75972e
    Author: Sagar Kamble <sagar.a.kamble@intel.com>
    Date:   Wed Aug 13 23:07:06 2014 +0530
    
        drm/i915: Sharing platform specific sequence between runtime and system susp
    
    after which we also saved/restored the VLV Gunit HW state in
    suspend_late/resume_early. So now since we don't save the state during
    suspend a following resume will restore a corrupted state.
    
    Fix this by calling the suspend_late handler during both switcheroo and
    legacy suspend.
    
    CC: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 524c3dfed380..203bd820d5f7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -670,11 +670,7 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (error)
 		return error;
 
-	/* Shut down the device */
-	pci_disable_device(dev->pdev);
-	pci_set_power_state(dev->pdev, PCI_D3hot);
-
-	return 0;
+	return i915_drm_suspend_late(dev);
 }
 
 static int i915_drm_thaw_early(struct drm_device *dev)
@@ -790,7 +786,7 @@ static int i915_resume_early(struct drm_device *dev)
 	return i915_drm_thaw_early(dev);
 }
 
-int i915_resume(struct drm_device *dev)
+static int i915_drm_resume(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
@@ -816,7 +812,12 @@ static int i915_resume_legacy(struct drm_device *dev)
 	if (ret)
 		return ret;
 
-	return i915_resume(dev);
+	return i915_drm_resume(dev);
+}
+
+int i915_resume(struct drm_device *dev)
+{
+	return i915_resume_legacy(dev);
 }
 
 /**
@@ -1004,7 +1005,7 @@ static int i915_pm_resume(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 
-	return i915_resume(drm_dev);
+	return i915_drm_resume(drm_dev);
 }
 
 static int i915_pm_freeze(struct device *dev)

commit 50a0072f3829d36767f3359649d224f18f7987f7
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:17 2014 +0300

    drm/i915: propagate error from legacy resume handler
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 56c75706055c..524c3dfed380 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -810,10 +810,13 @@ int i915_resume(struct drm_device *dev)
 
 static int i915_resume_legacy(struct drm_device *dev)
 {
-	i915_resume_early(dev);
-	i915_resume(dev);
+	int ret;
 
-	return 0;
+	ret = i915_resume_early(dev);
+	if (ret)
+		return ret;
+
+	return i915_resume(dev);
 }
 
 /**

commit f2888fabfbbccc0acb4d21713b91d557edc1e64f
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:16 2014 +0300

    drm/i915: unify legacy S3 suspend and S4 freeze handlers
    
    i915_suspend() is called from the DRM legacy S3 suspend/S4 freeze paths
    and the switcheroo suspend path. For switcheroo we only ever need to
    perform a full suspend (PM_EVENT_SUSPEND) and for the DRM legacy path
    we can handle the S4 freeze (PM_EVENT_FREEZE) the same way as S3
    suspend. The only difference atm between suspend and freeze is that
    during freeze we don't disable the PCI device, but there is no reason
    why we can't do so. So unify the two cases to reduce complexity.
    
    Note that for the DRM legacy case the thaw event is not handled, so
    we disable the display before creating the hibernation image and it
    won't get re-enabled until reboot. We could fix this leaving the
    display enabled for the image creation/writing (if we care enough
    about UMS), but this can be done as a follow-up.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 753d44a10f12..56c75706055c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -670,11 +670,9 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (error)
 		return error;
 
-	if (state.event == PM_EVENT_SUSPEND) {
-		/* Shut down the device */
-		pci_disable_device(dev->pdev);
-		pci_set_power_state(dev->pdev, PCI_D3hot);
-	}
+	/* Shut down the device */
+	pci_disable_device(dev->pdev);
+	pci_set_power_state(dev->pdev, PCI_D3hot);
 
 	return 0;
 }

commit c3c09c9522f806bd12d0c85dfdb8d2b8578d0da1
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Oct 23 19:23:15 2014 +0300

    drm/i915: factor out i915_drm_suspend_late
    
    This is needed by an upcoming patch fixing the switcheroo/legacy suspend
    paths.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ffd672ef245c..753d44a10f12 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -630,6 +630,25 @@ static int i915_drm_freeze(struct drm_device *dev)
 	return 0;
 }
 
+static int i915_drm_suspend_late(struct drm_device *drm_dev)
+{
+	struct drm_i915_private *dev_priv = drm_dev->dev_private;
+	int ret;
+
+	ret = intel_suspend_complete(dev_priv);
+
+	if (ret) {
+		DRM_ERROR("Suspend complete failed: %d\n", ret);
+
+		return ret;
+	}
+
+	pci_disable_device(drm_dev->pdev);
+	pci_set_power_state(drm_dev->pdev, PCI_D3hot);
+
+	return 0;
+}
+
 int i915_suspend(struct drm_device *dev, pm_message_t state)
 {
 	int error;
@@ -955,8 +974,6 @@ static int i915_pm_suspend_late(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-	struct drm_i915_private *dev_priv = drm_dev->dev_private;
-	int ret;
 
 	/*
 	 * We have a suspedn ordering issue with the snd-hda driver also
@@ -970,16 +987,7 @@ static int i915_pm_suspend_late(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	ret = intel_suspend_complete(dev_priv);
-
-	if (ret)
-		DRM_ERROR("Suspend complete failed: %d\n", ret);
-	else {
-		pci_disable_device(pdev);
-		pci_set_power_state(pdev, PCI_D3hot);
-	}
-
-	return ret;
+	return i915_drm_suspend_late(drm_dev);
 }
 
 static int i915_pm_resume_early(struct device *dev)

commit 163f53a2611c98a9f8e25cbda30ce8ce268b92de
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Sep 10 18:16:54 2014 +0300

    drm/i915: vlv: fix gunit HW state corruption during S4 suspend
    
    During S4 freeze we don't call intel_suspend_complete(), which would
    save the gunit HW state, but during S4 thaw/restore events we call
    intel_resume_prepare() which restores it, thus ending up in a corrupted
    HW state.
    
    Fix this by calling intel_suspend_complete() from the corresponding
    freeze_late event handler.
    
    The issue was introduced in
    commit 016970beb05da6285c2f3ed2bee1c676cb75972e
    Author: Sagar Kamble <sagar.a.kamble@intel.com>
    Date:   Wed Aug 13 23:07:06 2014 +0530
    
    CC: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f7bc3e980d8e..ffd672ef245c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1011,6 +1011,15 @@ static int i915_pm_freeze(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
+static int i915_pm_freeze_late(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *dev_priv = drm_dev->dev_private;
+
+	return intel_suspend_complete(dev_priv);
+}
+
 static int i915_pm_thaw_early(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -1595,6 +1604,7 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.resume_early = i915_pm_resume_early,
 	.resume = i915_pm_resume,
 	.freeze = i915_pm_freeze,
+	.freeze_late = i915_pm_freeze_late,
 	.thaw_early = i915_pm_thaw_early,
 	.thaw = i915_pm_thaw,
 	.poweroff = i915_pm_poweroff,

commit 0b14cbd2f58199a024acbe2994bb27533c97d756
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Sep 10 18:16:55 2014 +0300

    drm/i915: remove dead code from legacy suspend handler
    
    The legacy DRM suspend logic (effective in UMS) doesn't handle any S4 thaw
    events so we don't need to care about it either. Only S3 suspend and S4
    freeze events are handled. Leave an assert behind to be sure.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a05a1d083e95..f7bc3e980d8e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -640,9 +640,9 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 		return -ENODEV;
 	}
 
-	if (state.event == PM_EVENT_PRETHAW)
-		return 0;
-
+	if (WARN_ON_ONCE(state.event != PM_EVENT_SUSPEND &&
+			 state.event != PM_EVENT_FREEZE))
+		return -EINVAL;
 
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;

commit fa4dca2cce89ce8dc95f6dde58b3791feadc4283
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Oct 1 20:04:17 2014 +0100

    drm/i915/skl: Don't check for ULT/ULX when detecting the PCH
    
    IS_ULT() wasn't taking into account SKL so we had a warn with SPT-LP.
    
    We don't realy need those checks here, and as we don't need to introduce
    IS_SKL_ULT/ULX() at the moment, let's just drop them.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 02cee518c113..a05a1d083e95 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -479,12 +479,10 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev));
-				WARN_ON(IS_ULT(dev));
 			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
 				WARN_ON(!IS_SKYLAKE(dev));
-				WARN_ON(!IS_ULT(dev));
 			} else
 				continue;
 

commit bcef6d5aa5746e6d3955f2dbc8e00d58d2c8adbd
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Oct 1 20:04:13 2014 +0100

    drm/i915: Use IS_HSW_ULT() in a HSW specific code path
    
    No need to add the BDW pci ULT/ULX checks inside a if (IS_HASWELL(dev))
    code path.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bd7978cb094f..02cee518c113 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -463,7 +463,7 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
-				WARN_ON(IS_ULT(dev));
+				WARN_ON(IS_HSW_ULT(dev));
 			} else if (IS_BROADWELL(dev)) {
 				dev_priv->pch_type = PCH_LPT;
 				dev_priv->pch_id =
@@ -474,7 +474,7 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_LPT;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
-				WARN_ON(!IS_ULT(dev));
+				WARN_ON(!IS_HSW_ULT(dev));
 			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_SPT;
 				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");

commit b963291cf9af882b2f30693fa8459afbdb0ed288
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 30 10:56:44 2014 +0200

    drm/i915: Use dev_priv instead of dev in irq setup functions
    
    It's the new world order!
    
    Not going full monty on these here and rolling this out throughout the
    subsequent call chains since this is just for the kerneldoc. Later on
    we can go more crazy, especially once we've embedded drm_device
    correctly.
    
    v2: Also frob the runtime_pm functions ...
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 66489fa5ce43..bd7978cb094f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -599,7 +599,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
 
-		intel_runtime_pm_disable_interrupts(dev);
+		intel_runtime_pm_disable_interrupts(dev_priv);
 		intel_hpd_cancel_work(dev_priv);
 
 		intel_suspend_encoders(dev_priv);
@@ -705,7 +705,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 
 		/* We need working interrupts for modeset enabling ... */
-		intel_runtime_pm_restore_interrupts(dev);
+		intel_runtime_pm_enable_interrupts(dev_priv);
 
 		intel_modeset_init_hw(dev);
 
@@ -727,7 +727,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		 * bother with the tiny race here where we might loose hotplug
 		 * notifications.
 		 * */
-		intel_hpd_init(dev);
+		intel_hpd_init(dev_priv);
 		/* Config may have changed between suspend and resume */
 		drm_helper_hpd_irq_event(dev);
 	}
@@ -1473,12 +1473,12 @@ static int intel_runtime_suspend(struct device *device)
 	 * intel_mark_idle().
 	 */
 	cancel_work_sync(&dev_priv->rps.work);
-	intel_runtime_pm_disable_interrupts(dev);
+	intel_runtime_pm_disable_interrupts(dev_priv);
 
 	ret = intel_suspend_complete(dev_priv);
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
-		intel_runtime_pm_restore_interrupts(dev);
+		intel_runtime_pm_enable_interrupts(dev_priv);
 
 		return ret;
 	}
@@ -1538,7 +1538,7 @@ static int intel_runtime_resume(struct device *device)
 	i915_gem_init_swizzling(dev);
 	gen6_update_ring_freq(dev);
 
-	intel_runtime_pm_restore_interrupts(dev);
+	intel_runtime_pm_enable_interrupts(dev_priv);
 	intel_reset_gt_powersave(dev);
 
 	if (ret)

commit d8f2716a1a46bed27ce210e74c7fec3855595200
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 1 01:02:04 2014 +0200

    drm/i915: Reinstate error level message for non-simulated gpu hangs
    
    This seems to have been accidentally lost in
    
    commit be62acb4cce1389a28296852737e3917d9cc5b25
    Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Date:   Fri Aug 30 16:19:28 2013 +0300
    
        drm/i915: ban badly behaving contexts
    
    Without this real gpu hangs only log output at info level, which gets
    filtered away by piglit's testrunner.
    
    v2: Tune down to notice level. Note that we need to add drm/i915 so
    that at least the automatic igt dmesg filtering still picks it up.
    
    v3: git add and lack of coffee don't mix well.
    
    v4: Message is in between hw and sw reset, so switch verb to
    continuous form.
    
    v5: Use i915_stop_rings_allow_warn for consistency. For Chris' case of
    injecting lots of hangs I guess we need to revamp this all anyway when
    merging. For now this should plug the regression for piglit testing
    mesa.
    
    v6: Make it compile (Mika).
    
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Kenneth Graunke <kenneth@whitecape.org>
    Reported-by: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ea93ff151a74..66489fa5ce43 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -844,6 +844,9 @@ int i915_reset(struct drm_device *dev)
 		}
 	}
 
+	if (i915_stop_ring_allow_warn(dev_priv))
+		pr_notice("drm/i915: Resetting chip after gpu hang\n");
+
 	if (ret) {
 		DRM_ERROR("Failed to reset chip: %i\n", ret);
 		mutex_unlock(&dev->struct_mutex);

commit 970104fac6ca0cfdfbaa1a23c70c06a71208e2ac
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 30 10:56:37 2014 +0200

    drm/i915: Remove intel_modeset_suspend_hw
    
    Another layer of indirection for just an lpt-only w/a is a bit
    excessive. Reduce it.
    
    This was added in
    
    commit 7d708ee40a6b9ca1112a322e554c887df105b025
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Apr 17 14:04:50 2013 +0300
    
        drm/i915: HSW: allow PCH clock gating for suspend
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6948877c881c..ea93ff151a74 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -606,7 +606,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 		intel_suspend_gt_powersave(dev);
 
-		intel_modeset_suspend_hw(dev);
+		intel_suspend_hw(dev);
 	}
 
 	i915_gem_suspend_gtt_mappings(dev);

commit 955e36d0b4d3e29c9c8a865d166a42718aed302e
Merge: ce31d9f4fc05 c83155a60443
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 30 22:36:57 2014 +0200

    Merge branch 'topic/skl-stage1' into drm-intel-next-queued
    
    SKL stage 1 patches still need polish so will likely miss the 3.18
    merge window. We've decided to postpone to 3.19 so let's pull this in
    to make patch merging and conflict handling easier.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit e7e7ea20297afae464bb7da69a2e4c67d1d2b354
Author: Satheeshakrishna M <satheeshakrishna.m@intel.com>
Date:   Wed Apr 9 11:08:57 2014 +0530

    drm/i915/skl: Sunrise Point PCH detection
    
    This patch implements detection of SPT and SPT-LP PCH devices.
    
    v2: Added HAS_PCH_SPT macro
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Satheeshakrishna M <satheeshakrishna.m@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7088bdea11c7..51fbb3459e50 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -475,6 +475,16 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
+			} else if (id == INTEL_PCH_SPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_SPT;
+				DRM_DEBUG_KMS("Found SunrisePoint PCH\n");
+				WARN_ON(!IS_SKYLAKE(dev));
+				WARN_ON(IS_ULT(dev));
+			} else if (id == INTEL_PCH_SPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_SPT;
+				DRM_DEBUG_KMS("Found SunrisePoint LP PCH\n");
+				WARN_ON(!IS_SKYLAKE(dev));
+				WARN_ON(!IS_ULT(dev));
 			} else
 				continue;
 

commit 043efb1111694981c99613b8f944d6eabfb93273
Author: Daisy Sun <daisy.sun@intel.com>
Date:   Wed Apr 23 17:13:09 2014 -0700

    drm/i915/skl: SKL FBC enablement
    
    Enable FBC feature on Skylake
    
    Issue: VIZ-3788
    Reviewed-by: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Daisy Sun <daisy.sun@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a1ba1557154c..7088bdea11c7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -364,6 +364,7 @@ static const struct intel_device_info intel_skylake_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
 };

commit 7201c0b3a4de18ec80c9f508549a7de6631541b3
Author: Satheeshakrishna M <satheeshakrishna.m@intel.com>
Date:   Wed Apr 2 11:24:50 2014 +0530

    drm/i915/skl: Add an IS_SKYLAKE macro
    
    Adding new macro IS_SKYLAKE for skylake specific implementation.
    
    Reviewed-by: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Satheeshakrishna M <satheeshakrishna.m@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bec58e86bd49..a1ba1557154c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -358,6 +358,7 @@ static const struct intel_device_info intel_cherryview_info = {
 
 static const struct intel_device_info intel_skylake_info = {
 	.is_preliminary = 1,
+	.is_skylake = 1,
 	.gen = 9, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,

commit 72bbf0af0c76cbefe9cecbd2ed670b7555e03625
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Feb 13 15:27:37 2013 +0000

    drm/i915/skl: Add the Skylake PCI ids
    
    v2: Squash in 2nd patch from Damien for more ids (Daniel)
    v3: info->has*ring -> info->ring_mask conversion. Also add VEBOX support.
    v4: Fold in update from Damien
    v5: Rebase and add GEN_DEFAULT_PIPEOFFSETS
    v6: Add more PCI ID (Vandana)
    v7: Rebase and add IVB_CURSOR_OFFSETS
    v8: Renamed the macro from _PCI_IDS to _IDS for consistency
    
    Reviewed-by: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Vandana Kannan <vandana.kannan@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3870c7359a16..bec58e86bd49 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -356,6 +356,17 @@ static const struct intel_device_info intel_cherryview_info = {
 	CURSOR_OFFSETS,
 };
 
+static const struct intel_device_info intel_skylake_info = {
+	.is_preliminary = 1,
+	.gen = 9, .num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -392,7 +403,8 @@ static const struct intel_device_info intel_cherryview_info = {
 	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),	\
 	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),	\
 	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info), \
-	INTEL_CHV_IDS(&intel_cherryview_info)
+	INTEL_CHV_IDS(&intel_cherryview_info),	\
+	INTEL_SKL_IDS(&intel_skylake_info)
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit 133217869ea7f328acedab2ed2ec1ad41b6390bd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Sep 15 14:55:29 2014 +0200

    drm/i915: Clarify irq_lock locking, special cases
    
    Grab bag for all the special cases:
    - i9xx_check_fifo_underruns is only called from crtc_enable hooks,
      i.e. process context.
    - i915_enable_asle_pipestat is only called from interrupt postinstall
      hooks. So again process context.
    - gen8_irq_power_well_post_enable is called from the runtime pm code,
      which again means process context.
    - The open-coded hpd_irq_setup loop in _thaw is also running in process
      context.
    
    So for all of them the plain _irq variant is sufficient.
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b8bd0080603e..8ce1b13ad97e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -686,11 +686,10 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		intel_modeset_init_hw(dev);
 
 		{
-			unsigned long irqflags;
-			spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
+			spin_lock_irq(&dev_priv->irq_lock);
 			if (dev_priv->display.hpd_irq_setup)
 				dev_priv->display.hpd_irq_setup(dev);
-			spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
+			spin_unlock_irq(&dev_priv->irq_lock);
 		}
 
 		intel_dp_mst_resume(dev);

commit 2363d8c97f87738dba7af7d2103f4f26b3bf5916
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Sep 8 18:28:20 2014 +0200

    drm/i915: Restore resume irq ordering comment
    
    This was lost in
    
    commit e11aa362308f5de467ce355a2a2471321b15a35c
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Wed Jun 18 09:52:55 2014 -0700
    
        drm/i915: use runtime irq suspend/resume in freeze/thaw
    
    which makes the second part of this commen a bit nonsense. Both were
    originally added in
    
    commit 15239099d7a7a9ecdc1ccb5b187ae4cda5488ff9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Mar 5 09:50:58 2013 +0100
    
        drm/i915: enable irqs earlier when resuming
    
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 055d5e7fbf12..b8bd0080603e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -680,6 +680,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		}
 		mutex_unlock(&dev->struct_mutex);
 
+		/* We need working interrupts for modeset enabling ... */
 		intel_runtime_pm_restore_interrupts(dev);
 
 		intel_modeset_init_hw(dev);

commit a1e470d421f68d69bf35c1ed316a861625010eab
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Sep 8 18:17:18 2014 +0200

    drm/i915: Don't reinit hpd interrupts after gpu reset
    
    Somehow I've overlooked this when simplifying the irq reinit
    scheme on gen4.5+ in
    
    commit 78ad455fd229c6f6cc2f390ccbe0d8f1a62d55a9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu May 22 22:18:21 2014 +0200
    
        drm/i915: Improve irq handling after gpu resets
    
    Since display interrups in general survive a gpu reset on those
    platforms there's also no need to reinit the hotplug settings.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3870c7359a16..055d5e7fbf12 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -871,8 +871,6 @@ int i915_reset(struct drm_device *dev)
 		 */
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
-
-		intel_hpd_init(dev);
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}

commit 40d201af0b9e6196a210b97d3b2493b1156564f6
Merge: 29a7d1795a03 a12624959ad4
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Sep 16 16:02:09 2014 +1000

    Merge tag 'drm-intel-next-2014-09-05' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - final bits (again) for the rotation support (Sonika Jindal)
    - support bl_power in the intel backlight (Jani)
    - vdd handling improvements from Ville
    - i830M fixes from Ville
    - piles of prep work all over to make skl enabling just plug in (Damien, Sonika)
    - rename DP training defines to reflect latest edp standards, this touches all
      drm drivers supporting DP (Sonika Jindal)
    - cache edids during single detect cycle to avoid re-reading it for e.g. audio,
      from Chris
    - move w/a for registers which are stored in the hw context to the context init
      code (Arun&Damien)
    - edp panel power sequencer fixes, helps chv a lot (Ville)
    - piles of other chv fixes all over
    - much more paranoid pageflip handling with stall detection and better recovery
      from Chris
    - small things all over, as usual
    
    * tag 'drm-intel-next-2014-09-05' of git://anongit.freedesktop.org/drm-intel: (114 commits)
      drm/i915: Update DRIVER_DATE to 20140905
      drm/i915: Decouple the stuck pageflip on modeset
      drm/i915: Check for a stalled page flip after each vblank
      drm/i915: Introduce a for_each_plane() macro
      drm/i915: Rewrite ABS_DIFF() in a safer manner
      drm/i915: Add comments explaining the vdd on/off functions
      drm/i915: Move DP port disable to post_disable for pch platforms
      drm/i915: Enable DP port earlier
      drm/i915: Turn on panel power before doing aux transfers
      drm/i915: Be more careful when picking the initial power sequencer pipe
      drm/i915: Reset power sequencer pipe tracking when disp2d is off
      drm/i915: Track which port is using which pipe's power sequencer
      drm/i915: Fix edp vdd locking
      drm/i915: Reset the HEAD pointer for the ring after writing START
      drm/i915: Fix unsafe vma iteration in i915_drop_caches
      drm/i915: init sprites with univeral plane init function
      drm/i915: Check of !HAS_PCH_SPLIT() in PCH transcoder funcs
      drm/i915: Use HAS_GMCH_DISPLAY un underrun reporting code
      drm/i915: Use IS_BROADWELL() instead of IS_GEN8() in forcewake code
      drm/i915: Don't call gen8_fbc_sw_flush() on chv
      ...

commit 915b4d11b8b9e7b84ba4a4645b6cc7fbc0c071cf
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 29 12:12:43 2014 +0200

    drm: add driver->set_busid() callback
    
    One step closer to dropping all the drm_bus_* code:
    Add a driver->set_busid() callback and make all drivers use the generic
    helpers. Nouveau is the only driver that uses two different bus-types with
    the same drm_driver. This is totally broken if both buses are available on
    the same machine (unlikely, but lets be safe). Therefore, we create two
    different drivers for each platform during module_init() and set the
    set_busid() callback respectively.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff4db249cc72..cdd95956811d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1593,6 +1593,7 @@ static struct drm_driver driver = {
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,
 	.postclose = i915_driver_postclose,
+	.set_busid = drm_pci_set_busid,
 
 	/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
 	.suspend = i915_suspend,

commit 1eab9234cbfdd72fe29a68f3da8002e2c74c0c36
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Aug 27 11:30:21 2014 +0100

    drm/i915: Add "Intel Corporation" as module author
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e72a713432bc..8ff375538b5d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1707,6 +1707,7 @@ module_init(i915_init);
 module_exit(i915_exit);
 
 MODULE_AUTHOR("Tungsten Graphics, Inc.");
+MODULE_AUTHOR("Intel Corporation");
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");

commit 0a6d16318939f3dbd9f5f91709c4e72c585d8554
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Aug 27 11:30:20 2014 +0100

    drm/i915: Don't use a define when it's clearer to just put the value
    
    Instead of going through hoops, just put the driver author directly as
    DRM_AUTHOR() argument. This will also make it consistent when we add
    Intel to the list.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d02398720237..e72a713432bc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1706,6 +1706,7 @@ static void __exit i915_exit(void)
 module_init(i915_init);
 module_exit(i915_exit);
 
-MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_AUTHOR("Tungsten Graphics, Inc.");
+
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");

commit c8a0bd42df69fe76646b45dea04c7cf4995fa6a3
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Thu Aug 21 17:09:38 2014 -0300

    drm/i915: send PCI_D3hot adapter opregion message on BDW RPM suspend
    
    On BDW we're seeing a problem that after we runtime resume, the
    outputs connected to DDI C are not detected: they don't appear in the
    SDEISR register and GMBUS transactions don't work. They stop working
    at the moment we call intel_opregion_notify_adapter() during runtime
    suspend, but they don't go back to work when we call the same function
    during runtime resume. They only work after we do a modeset and call
    intel_opregion_notify_encoder(), but this point is already too late.
    
    While debugging, I tried to pass PCI_D3hot which is the value that
    matches the spec, and it seems to have solved the problem. I couldn't
    find any explanation of why this solves the problem, but there's also
    no documented explanation - besides our code and git log - of why
    Haswell should use PCI_D1, so keep this for now in order to keep BDW
    runtime PM working.
    
    Also add a comment to point the fact that there's no spec documenting
    all the weirdness involved here.
    
    Cc: kristen.c.accardi@intel.com
    Testcase: igt/pm_rpm/drm-resources-equal
    Testcase: igt/pm_rpm/i2c
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 683be99117c6..d02398720237 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1462,13 +1462,29 @@ static int intel_runtime_suspend(struct device *device)
 	dev_priv->pm.suspended = true;
 
 	/*
-	 * current versions of firmware which depend on this opregion
-	 * notification have repurposed the D1 definition to mean
-	 * "runtime suspended" vs. what you would normally expect (D3)
-	 * to distinguish it from notifications that might be sent
-	 * via the suspend path.
+	 * FIXME: We really should find a document that references the arguments
+	 * used below!
 	 */
-	intel_opregion_notify_adapter(dev, PCI_D1);
+	if (IS_HASWELL(dev)) {
+		/*
+		 * current versions of firmware which depend on this opregion
+		 * notification have repurposed the D1 definition to mean
+		 * "runtime suspended" vs. what you would normally expect (D3)
+		 * to distinguish it from notifications that might be sent via
+		 * the suspend path.
+		 */
+		intel_opregion_notify_adapter(dev, PCI_D1);
+	} else {
+		/*
+		 * On Broadwell, if we use PCI_D1 the PCH DDI ports will stop
+		 * being detected, and the call we do at intel_runtime_resume()
+		 * won't be able to restore them. Since PCI_D3hot matches the
+		 * actual specification and appears to be working, use it. Let's
+		 * assume the other non-Haswell platforms will stay the same as
+		 * Broadwell.
+		 */
+		intel_opregion_notify_adapter(dev, PCI_D3hot);
+	}
 
 	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;

commit 6689c167ae14c312972e89be1121e933e4de0001
Author: McAulay, Alistair <alistair.mcaulay@intel.com>
Date:   Fri Aug 15 18:51:35 2014 +0100

    drm/i915: Rework GPU reset sequence to match driver load & thaw
    
    This patch is to address Daniels concerns over different code during reset:
    
    http://lists.freedesktop.org/archives/intel-gfx/2014-June/047758.html
    
    "The reason for aiming as hard as possible to use the exact same code for
    driver load, gpu reset and runtime pm/system resume is that we've simply
    seen too many bugs due to slight variations and unintended omissions."
    
    Tested using igt drv_hangman.
    
    V2: Cleaner way of preventing check_wedge returning -EAGAIN
    V3: Clean the last_context during reset, to ensure do_switch() does the MI_SET_CONTEXT. As per review.
    Signed-off-by: McAulay, Alistair <alistair.mcaulay@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    [danvet: Rebase over ctx->ppgtt rework and extend the comment in
    check_wedge a bit.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff4db249cc72..683be99117c6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -844,7 +844,13 @@ int i915_reset(struct drm_device *dev)
 			!dev_priv->ums.mm_suspended) {
 		dev_priv->ums.mm_suspended = 0;
 
+		/* Used to prevent gem_check_wedged returning -EAGAIN during gpu reset */
+		dev_priv->gpu_error.reload_in_reset = true;
+
 		ret = i915_gem_init_hw(dev);
+
+		dev_priv->gpu_error.reload_in_reset = false;
+
 		mutex_unlock(&dev->struct_mutex);
 		if (ret) {
 			DRM_ERROR("Failed hw init on reset %d\n", ret);

commit a18b29f0c6bd17703b5eb88c3b2184a26d173135
Merge: 04cd214516d8 604effb782a8
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Sep 3 08:30:48 2014 +1000

    Merge tag 'drm-intel-next-2014-09-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2014-08-22:
    - basic code for execlist, which is the fancy new cmd submission on gen8. Still
      disabled by default (Ben, Oscar Mateo, Thomas Daniel et al)
    - remove the useless usage of console_lock for I915_FBDEV=n (Chris)
    - clean up relations between ctx and ppgtt
    - clean up ppgtt lifetime handling (Michel Thierry)
    - various cursor code improvements from Ville
    - execbuffer code cleanups and secure batch fixes (Chris)
    - prep work for dev -> dev_priv transition (Chris)
    - some of the prep patches for the seqno -> request object transition (Chris)
    - various small improvements all over
    
    * tag 'drm-intel-next-2014-09-01' of git://anongit.freedesktop.org/drm-intel: (86 commits)
      drm/i915: fix suspend/resume for GENs w/o runtime PM support
      drm/i915: Update DRIVER_DATE to 20140822
      drm: fix plane rotation when restoring fbdev configuration
      drm/i915/bdw: Disable execlists by default
      drm/i915/bdw: Enable Logical Ring Contexts (hence, Execlists)
      drm/i915/bdw: Document Logical Rings, LR contexts and Execlists
      drm/i915/bdw: Print context state in debugfs
      drm/i915/bdw: Display context backing obj & ringbuffer info in debugfs
      drm/i915/bdw: Display execlists info in debugfs
      drm/i915/bdw: Disable semaphores for Execlists
      drm/i915/bdw: Make sure gpu reset still works with Execlists
      drm/i915/bdw: Don't write PDP in the legacy way when using LRCs
      drm/i915: Track cursor changes as frontbuffer tracking flushes
      drm/i915/bdw: Help out the ctx switch interrupt handler
      drm/i915/bdw: Avoid non-lite-restore preemptions
      drm/i915/bdw: Handle context switch events
      drm/i915/bdw: Two-stage execlist submit process
      drm/i915/bdw: Write the tail pointer, LRC style
      drm/i915/bdw: Implement context switching (somewhat)
      drm/i915/bdw: Emission of requests with logical rings
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit 604effb782a8a4d9a20c8af16bcbf86d742db119
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Aug 26 13:26:56 2014 +0300

    drm/i915: fix suspend/resume for GENs w/o runtime PM support
    
    Before sharing common parts between the system and runtime s/r
    handlers we WARNed if the runtime s/r handlers were called on GENs that
    didn't support RPM. But this WARN is not correct if the same handler is
    called from the system s/r path, since that can happen on any platform.
    This also broke system s/r on old platforms.
    
    The issue was introduced in
    
    commit 016970beb05da6285c2f3ed2bee1c676cb75972e
    Author: Sagar Kamble <sagar.a.kamble@intel.com>
    Date:   Wed Aug 13 23:07:06 2014 +0530
    
    v2:
    - remove the WARN and depend on the HAS_RUNTIME_PM check in
      rutime_suspend/resume instead (Daniel)
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=82751
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 117f5c16df74..0f7a522682a5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1373,7 +1373,9 @@ static int intel_runtime_suspend(struct device *device)
 	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6(dev))))
 		return -ENODEV;
 
-	WARN_ON(!HAS_RUNTIME_PM(dev));
+	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
+		return -ENODEV;
+
 	assert_force_wake_inactive(dev_priv);
 
 	DRM_DEBUG_KMS("Suspending device\n");
@@ -1441,7 +1443,8 @@ static int intel_runtime_resume(struct device *device)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
-	WARN_ON(!HAS_RUNTIME_PM(dev));
+	if (WARN_ON_ONCE(!HAS_RUNTIME_PM(dev)))
+		return -ENODEV;
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
@@ -1476,16 +1479,12 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
-	if (IS_GEN6(dev)) {
-		ret = 0;
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		ret = hsw_suspend_complete(dev_priv);
-	} else if (IS_VALLEYVIEW(dev)) {
+	else if (IS_VALLEYVIEW(dev))
 		ret = vlv_suspend_complete(dev_priv);
-	} else {
-		ret = -ENODEV;
-		WARN_ON(1);
-	}
+	else
+		ret = 0;
 
 	return ret;
 }
@@ -1501,16 +1500,14 @@ static int intel_resume_prepare(struct drm_i915_private *dev_priv,
 	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
-	if (IS_GEN6(dev)) {
+	if (IS_GEN6(dev))
 		ret = snb_resume_prepare(dev_priv, rpm_resume);
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		ret = hsw_resume_prepare(dev_priv, rpm_resume);
-	} else if (IS_VALLEYVIEW(dev)) {
+	else if (IS_VALLEYVIEW(dev))
 		ret = vlv_resume_prepare(dev_priv, rpm_resume);
-	} else {
-		WARN_ON(1);
-		ret = -ENODEV;
-	}
+	else
+		ret = 0;
 
 	return ret;
 }

commit 71386ef9008817feebd863e46d8711ebe9e7cbbb
Author: Oscar Mateo <oscar.mateo@intel.com>
Date:   Thu Jul 24 17:04:44 2014 +0100

    drm/i915/bdw: Disable semaphores for Execlists
    
    Up until recently, semaphores weren't enabled in BDW so we didn't care
    about them. But then Rodrigo came and enabled them:
    
       commit 521e62e49a42661a4ee0102644517dbe2f100a23
       Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
    
          drm/i915: Enable semaphores on BDW
    
    So now we have to explicitly disable them for Execlists until both
    features play nicely.
    
    Signed-off-by: Oscar Mateo <oscar.mateo@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2f112853c36f..117f5c16df74 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -481,6 +481,10 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (i915.semaphores >= 0)
 		return i915.semaphores;
 
+	/* TODO: make semaphores and Execlists play nicely together */
+	if (i915.enable_execlists)
+		return false;
+
 	/* Until we get further testing... */
 	if (IS_GEN8(dev))
 		return false;

commit 07f9cd0b3870e306ddc5abcc3af2d748c9bd378c
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Aug 18 14:42:45 2014 +0300

    drm/i915: make sure VDD is turned off during system suspend
    
    Atm we may leave eDP VDD enabled during system suspend after the CRTCs
    are disabled through an HPD->DPCD read event. So disable VDD during
    suspend at a point when no HPDs can occur.
    
    Note that runtime suspend doesn't have the same problem, since there the
    RPM ref held by VDD provides already the needed serialization.
    
    v2:
    - add note to commit message about the runtime suspend path (Ville)
    - use edp_panel_vdd_off_sync(), so we can keep the WARN in
      edp_panel_vdd_off() (Ville)
    v3:
    - rebased on -fixes (for_each_intel_encoder()->list_for_each_entry())
      (Imre)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> (v2)
    Cc: stable@vger.kernel.org (3.16+)
    [Jani: fix sparse warning reported by Fengguang Wu]
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3f9c8f6b2418..e27cdbe9d524 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -509,6 +509,21 @@ void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
 	cancel_delayed_work_sync(&dev_priv->hotplug_reenable_work);
 }
 
+static void intel_suspend_encoders(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	struct drm_encoder *encoder;
+
+	drm_modeset_lock_all(dev);
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
+
+		if (intel_encoder->suspend)
+			intel_encoder->suspend(intel_encoder);
+	}
+	drm_modeset_unlock_all(dev);
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -555,6 +570,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 		intel_runtime_pm_disable_interrupts(dev);
 		intel_hpd_cancel_work(dev_priv);
 
+		intel_suspend_encoders(dev_priv);
+
 		intel_suspend_gt_powersave(dev);
 
 		intel_modeset_suspend_hw(dev);

commit 1d0d343abb70922adebebc1cfcef6622f4c7edec
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Aug 18 14:42:44 2014 +0300

    drm/i915: cancel hotplug and dig_port work during suspend and unload
    
    Make sure these work handlers don't run after we system suspend or
    unload the driver. Note that we don't cancel the handlers during runtime
    suspend. That could lead to a lockup, since we take a runtime PM ref
    from the handlers themselves. Fortunaltely canceling there is not needed
    since the RPM ref itself provides for the needed serialization.
    
    v2:
    - fix the order of canceling dig_port_work wrt. hotplug_work (Ville)
    - zero out {long,short}_hpd_port_mask and hpd_event_bits for speed
      (Ville)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: stable@vger.kernel.org (3.16+)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec96f9a9724c..3f9c8f6b2418 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -494,6 +494,21 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return true;
 }
 
+void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)
+{
+	spin_lock_irq(&dev_priv->irq_lock);
+
+	dev_priv->long_hpd_port_mask = 0;
+	dev_priv->short_hpd_port_mask = 0;
+	dev_priv->hpd_event_bits = 0;
+
+	spin_unlock_irq(&dev_priv->irq_lock);
+
+	cancel_work_sync(&dev_priv->dig_port_work);
+	cancel_work_sync(&dev_priv->hotplug_work);
+	cancel_delayed_work_sync(&dev_priv->hotplug_reenable_work);
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -538,6 +553,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
 
 		intel_runtime_pm_disable_interrupts(dev);
+		intel_hpd_cancel_work(dev_priv);
 
 		intel_suspend_gt_powersave(dev);
 

commit 016970beb05da6285c2f3ed2bee1c676cb75972e
Author: Sagar Kamble <sagar.a.kamble@intel.com>
Date:   Wed Aug 13 23:07:06 2014 +0530

    drm/i915: Sharing platform specific sequence between runtime and system suspend/ resume paths
    
    On VLV, post S0i3 during i915_drm_thaw following issue is observed during ring
    initialization.
    
    [ 335.604039] [drm:stop_ring] ERROR render ring :timed out trying to stop ring
    [ 336.607340] [drm:stop_ring] ERROR render ring :timed out trying to stop ring
    [ 336.607345] [drm:init_ring_common] ERROR failed to set render ring head to zero ctl 00000000 head 00000000 tail 00000000 start 00000000
    [ 337.610645] [drm:stop_ring] ERROR bsd ring :timed out trying to stop ring
    [ 338.613952] [drm:stop_ring] ERROR bsd ring :timed out trying to stop ring
    [ 338.613956] [drm:init_ring_common] ERROR failed to set bsd ring head to zero ctl 00000000 head 00000000 tail 00000000 start 00000000
    [ 339.617256] [drm:stop_ring] ERROR render ring :timed out trying to stop ring
    [ 339.617258] -----------[ cut here ]-----------
    [ 339.617267] WARNING: CPU: 0 PID: 6 at drivers/gpu/drm/i915/intel_ringbuffer.c:1666 intel_cleanup_ring+0xe6/0xf0()
    [ 339.617396] --[ end trace 5ef5ed1a3c92e2a6 ]--
    [ 339.617428] [drm:__i915_drm_thaw] ERROR failed to re-initialize GPU, declaring wedged!
    
    This is happening since wake is not enabled and Gunit registers are not restored.
    For this system suspend/resume paths need to follow save/restore and additional
    platform specific setup in suspend_complete and resume_prepare.
    
    suspend_complete is shared unconditionaly for VLV, HSW, BDW. resume_prepare for
    HSW and BDW has pc8 disabling which is needed during thaw_early so sharing
    uncondtionally. For VLV and SNB runtime resume specific sequence exists.
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Goel, Akash <akash.goel@intel.com>
    Signed-off-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b06e975dba39..2f112853c36f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -496,7 +496,8 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 
 
 static int intel_suspend_complete(struct drm_i915_private *dev_priv);
-static int intel_resume_prepare(struct drm_i915_private *dev_priv);
+static int intel_resume_prepare(struct drm_i915_private *dev_priv,
+				bool rpm_resume);
 
 static int i915_drm_freeze(struct drm_device *dev)
 {
@@ -604,15 +605,17 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
 
-	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
-		hsw_disable_pc8(dev_priv);
+	ret = intel_resume_prepare(dev_priv, false);
+	if (ret)
+		DRM_ERROR("Resume prepare failed: %d,Continuing resume\n", ret);
 
 	intel_uncore_early_sanitize(dev, true);
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);
 
-	return 0;
+	return ret;
 }
 
 static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
@@ -888,6 +891,7 @@ static int i915_pm_suspend_late(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = drm_dev->dev_private;
+	int ret;
 
 	/*
 	 * We have a suspedn ordering issue with the snd-hda driver also
@@ -901,13 +905,16 @@ static int i915_pm_suspend_late(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	if (IS_HASWELL(drm_dev) || IS_BROADWELL(drm_dev))
-		hsw_enable_pc8(dev_priv);
+	ret = intel_suspend_complete(dev_priv);
 
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, PCI_D3hot);
+	if (ret)
+		DRM_ERROR("Suspend complete failed: %d\n", ret);
+	else {
+		pci_disable_device(pdev);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
 
-	return 0;
+	return ret;
 }
 
 static int i915_pm_resume_early(struct device *dev)
@@ -970,16 +977,19 @@ static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
-static int snb_resume_prepare(struct drm_i915_private *dev_priv)
+static int snb_resume_prepare(struct drm_i915_private *dev_priv,
+				bool rpm_resume)
 {
 	struct drm_device *dev = dev_priv->dev;
 
-	intel_init_pch_refclk(dev);
+	if (rpm_resume)
+		intel_init_pch_refclk(dev);
 
 	return 0;
 }
 
-static int hsw_resume_prepare(struct drm_i915_private *dev_priv)
+static int hsw_resume_prepare(struct drm_i915_private *dev_priv,
+				bool rpm_resume)
 {
 	hsw_disable_pc8(dev_priv);
 
@@ -1315,7 +1325,8 @@ static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 	return err;
 }
 
-static int vlv_resume_prepare(struct drm_i915_private *dev_priv)
+static int vlv_resume_prepare(struct drm_i915_private *dev_priv,
+				bool rpm_resume)
 {
 	struct drm_device *dev = dev_priv->dev;
 	int err;
@@ -1340,8 +1351,10 @@ static int vlv_resume_prepare(struct drm_i915_private *dev_priv)
 
 	vlv_check_no_gt_access(dev_priv);
 
-	intel_init_clock_gating(dev);
-	i915_gem_restore_fences(dev);
+	if (rpm_resume) {
+		intel_init_clock_gating(dev);
+		i915_gem_restore_fences(dev);
+	}
 
 	return ret;
 }
@@ -1431,7 +1444,7 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	ret = intel_resume_prepare(dev_priv);
+	ret = intel_resume_prepare(dev_priv, true);
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
@@ -1450,6 +1463,10 @@ static int intel_runtime_resume(struct device *device)
 	return ret;
 }
 
+/*
+ * This function implements common functionality of runtime and system
+ * suspend sequence.
+ */
 static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
@@ -1469,17 +1486,23 @@ static int intel_suspend_complete(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-static int intel_resume_prepare(struct drm_i915_private *dev_priv)
+/*
+ * This function implements common functionality of runtime and system
+ * resume sequence. Variable rpm_resume used for implementing different
+ * code paths.
+ */
+static int intel_resume_prepare(struct drm_i915_private *dev_priv,
+				bool rpm_resume)
 {
 	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
 	if (IS_GEN6(dev)) {
-		ret = snb_resume_prepare(dev_priv);
+		ret = snb_resume_prepare(dev_priv, rpm_resume);
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
-		ret = hsw_resume_prepare(dev_priv);
+		ret = hsw_resume_prepare(dev_priv, rpm_resume);
 	} else if (IS_VALLEYVIEW(dev)) {
-		ret = vlv_resume_prepare(dev_priv);
+		ret = vlv_resume_prepare(dev_priv, rpm_resume);
 	} else {
 		WARN_ON(1);
 		ret = -ENODEV;

commit ebc3282409ae4d1e90c2f9608665cc4d8fbf7e73
Author: Sagar Kamble <sagar.a.kamble@intel.com>
Date:   Wed Aug 13 23:07:05 2014 +0530

    drm/i915: Created common handler for platform specific suspend/resume
    
    With this change, intel_runtime_suspend and intel_runtime_resume functions
    become completely platform agnostic. Platform specific suspend/resume
    changes are moved to intel_suspend_complete and intel_resume_prepare.
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Goel, Akash <akash.goel@intel.com>
    Signed-off-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 01de97776d81..b06e975dba39 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -494,6 +494,10 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return true;
 }
 
+
+static int intel_suspend_complete(struct drm_i915_private *dev_priv);
+static int intel_resume_prepare(struct drm_i915_private *dev_priv);
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -959,14 +963,14 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
-static int hsw_runtime_suspend(struct drm_i915_private *dev_priv)
+static int hsw_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
 
 	return 0;
 }
 
-static int snb_runtime_resume(struct drm_i915_private *dev_priv)
+static int snb_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
@@ -975,7 +979,7 @@ static int snb_runtime_resume(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
-static int hsw_runtime_resume(struct drm_i915_private *dev_priv)
+static int hsw_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	hsw_disable_pc8(dev_priv);
 
@@ -1271,7 +1275,7 @@ static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
 	I915_WRITE(VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);
 }
 
-static int vlv_runtime_suspend(struct drm_i915_private *dev_priv)
+static int vlv_suspend_complete(struct drm_i915_private *dev_priv)
 {
 	u32 mask;
 	int err;
@@ -1311,7 +1315,7 @@ static int vlv_runtime_suspend(struct drm_i915_private *dev_priv)
 	return err;
 }
 
-static int vlv_runtime_resume(struct drm_i915_private *dev_priv)
+static int vlv_resume_prepare(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 	int err;
@@ -1389,17 +1393,7 @@ static int intel_runtime_suspend(struct device *device)
 	cancel_work_sync(&dev_priv->rps.work);
 	intel_runtime_pm_disable_interrupts(dev);
 
-	if (IS_GEN6(dev)) {
-		ret = 0;
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
-		ret = hsw_runtime_suspend(dev_priv);
-	} else if (IS_VALLEYVIEW(dev)) {
-		ret = vlv_runtime_suspend(dev_priv);
-	} else {
-		ret = -ENODEV;
-		WARN_ON(1);
-	}
-
+	ret = intel_suspend_complete(dev_priv);
 	if (ret) {
 		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
 		intel_runtime_pm_restore_interrupts(dev);
@@ -1437,17 +1431,7 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	if (IS_GEN6(dev)) {
-		ret = snb_runtime_resume(dev_priv);
-	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
-		ret = hsw_runtime_resume(dev_priv);
-	} else if (IS_VALLEYVIEW(dev)) {
-		ret = vlv_runtime_resume(dev_priv);
-	} else {
-		WARN_ON(1);
-		ret = -ENODEV;
-	}
-
+	ret = intel_resume_prepare(dev_priv);
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
@@ -1466,6 +1450,44 @@ static int intel_runtime_resume(struct device *device)
 	return ret;
 }
 
+static int intel_suspend_complete(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	int ret;
+
+	if (IS_GEN6(dev)) {
+		ret = 0;
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = hsw_suspend_complete(dev_priv);
+	} else if (IS_VALLEYVIEW(dev)) {
+		ret = vlv_suspend_complete(dev_priv);
+	} else {
+		ret = -ENODEV;
+		WARN_ON(1);
+	}
+
+	return ret;
+}
+
+static int intel_resume_prepare(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	int ret;
+
+	if (IS_GEN6(dev)) {
+		ret = snb_resume_prepare(dev_priv);
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = hsw_resume_prepare(dev_priv);
+	} else if (IS_VALLEYVIEW(dev)) {
+		ret = vlv_resume_prepare(dev_priv);
+	} else {
+		WARN_ON(1);
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
 static const struct dev_pm_ops i915_pm_ops = {
 	.suspend = i915_pm_suspend,
 	.suspend_late = i915_pm_suspend_late,

commit 82e3b8c130f046b7dd1e7898c10e40edb52fee6d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 13 13:09:46 2014 +0100

    drm/i915: Localise the fbdev console lock frobbing
    
    Rather than take and release the console_lock() around a non-existent
    DRM_I915_FBDEV, move the lock acquisation into the callee where it will
    be compiled out by the config option entirely. This includes moving the
    deferred fb_set_suspend() dance and encapsulating it entirely within
    intel_fbdev.c.
    
    v2: Use an integral work item so that we can explicitly flush the work
    upon suspend/unload.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    [danvet: Add the flush_work in fbdev_fini per the mailing list
    discussion. And s/BUG_ON/WARN_ON/ because.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec96f9a9724c..01de97776d81 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -558,9 +558,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	intel_uncore_forcewake_reset(dev, false);
 	intel_opregion_fini(dev);
 
-	console_lock();
-	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED);
-	console_unlock();
+	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED, true);
 
 	dev_priv->suspend_count++;
 
@@ -599,18 +597,6 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	return 0;
 }
 
-void intel_console_resume(struct work_struct *work)
-{
-	struct drm_i915_private *dev_priv =
-		container_of(work, struct drm_i915_private,
-			     console_resume_work);
-	struct drm_device *dev = dev_priv->dev;
-
-	console_lock();
-	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING);
-	console_unlock();
-}
-
 static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -681,17 +667,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 
 	intel_opregion_init(dev);
 
-	/*
-	 * The console lock can be pretty contented on resume due
-	 * to all the printk activity.  Try to keep it out of the hot
-	 * path of resume if possible.
-	 */
-	if (console_trylock()) {
-		intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING);
-		console_unlock();
-	} else {
-		schedule_work(&dev_priv->console_resume_work);
-	}
+	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING, false);
 
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_DONE;

commit be71eabebaf9f142612d34d42292b454e984dcb5
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Aug 4 11:15:19 2014 -0700

    Revert "drm/i915: Enable semaphores on BDW"
    
    This reverts commit 521e62e49a42661a4ee0102644517dbe2f100a23.
    
    Although POST_SYNC brought a bit of stability to Semaphores on BDW
    it didn't solved all issues and some hungs can still occour when
    semaphores are enabled on BDW. Also some sloweness can be found on some
    igt tests, althoguth it apparently doesn't affect real workloads.
    
    Besides that, no real performance gain was found on our tests with different
    and even multiple workloads.
    
    Let's disable it again for now. At least until we are sure it is safe
    to re-enable it.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c4b25ce8bb0..ec96f9a9724c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -481,6 +481,10 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (i915.semaphores >= 0)
 		return i915.semaphores;
 
+	/* Until we get further testing... */
+	if (IS_GEN8(dev))
+		return false;
+
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
 	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)

commit 4dac3edfe68e5e1b3c2216b84ba160572420fa40
Merge: 487777673e35 e05444be705b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 29 20:49:36 2014 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    Pull in drm-next with Dave's DP MST support so that I can merge some
    conflicting patches which also touch the driver load sequencing around
    interrupt handling.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 09b64267c1f72f2670fcde9f11e5453ce365ca23
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jul 23 14:25:24 2014 +1000

    drm/i915: don't suspend gt until after we disable irqs and display (v2)
    
    When I moved the irq disable down to after display disable,
    I didn't realise the gt suspend also required irqs off, so move it
    down as well.
    
    Fixes WARNs seen at suspend/resume time.
    
    v2: moved the rps flush down as well.
    
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a361bb9bc243..2a83833207b1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -516,11 +516,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 			return error;
 		}
 
-		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
-
-
-		intel_suspend_gt_powersave(dev);
-
 		/*
 		 * Disable CRTCs directly since we want to preserve sw state
 		 * for _thaw.
@@ -532,8 +527,13 @@ static int i915_drm_freeze(struct drm_device *dev)
 		drm_modeset_unlock_all(dev);
 
 		intel_dp_mst_suspend(dev);
+
+		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
+
 		intel_runtime_pm_disable_interrupts(dev);
 
+		intel_suspend_gt_powersave(dev);
+
 		intel_modeset_suspend_hw(dev);
 	}
 

commit 66bc2cab191816d931f4d660d2f162130dd202b2
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Wed Jul 16 17:49:30 2014 -0300

    drm/i915: BDW can also detect unclaimed registers
    
    By the time I wrote this patch, it allowed me to catch some problems.
    But due to patch reordering - in order to prevent fake "regression"
    reports - this patch may be merged after the fixes of the problems
    identified by this patch.
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index de7d9a73eb2b..387279602fd9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -303,6 +303,7 @@ static const struct intel_device_info intel_broadwell_d_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
@@ -314,6 +315,7 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
@@ -325,6 +327,7 @@ static const struct intel_device_info intel_broadwell_gt3d_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,
@@ -336,6 +339,7 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 	IVB_CURSOR_OFFSETS,

commit b04c5bd6fda54703e56f29569e4bca489d6c5a5c
Author: Borun Fu <borun.fu@intel.com>
Date:   Sat Jul 12 10:02:27 2014 +0530

    drm/i915: Power gating display wells during i915_pm_suspend
    
    On VLV, after i915_pm_suspend display power wells are staying
    power ungated. So, after initiating mem sleep "echo mem > /sys/power/state"
    Display is staing D0 State. There might be better way/place to power gate
    these wells. Also, we need to make sure that if wells are power gated due to
    DPMS OFF sequence, they need not be turned off by i915_pm_suspend again.
    
    v2: Extracted helper for intel_crtc_disable and power gating CRTC power wells.
    [Daniel]
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Change-Id: I34c80da66aa24c423a5576c68aa1f3a8d0f43848
    Signed-off-by: Borun Fu <borun.fu@intel.com>
    Signed-off-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 23139aaa9431..de7d9a73eb2b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -525,12 +525,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 		/*
 		 * Disable CRTCs directly since we want to preserve sw state
-		 * for _thaw.
+		 * for _thaw. Also, power gate the CRTC power wells.
 		 */
 		drm_modeset_lock_all(dev);
-		for_each_crtc(dev, crtc) {
-			dev_priv->display.crtc_disable(crtc);
-		}
+		for_each_crtc(dev, crtc)
+			intel_crtc_control(crtc, false);
 		drm_modeset_unlock_all(dev);
 
 		intel_modeset_suspend_hw(dev);

commit 0e32b39ceed665bfa4a77a4bc307b6652b991632
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 2 14:02:48 2014 +1000

    drm/i915: add DP 1.2 MST support (v0.7)
    
    This adds DP 1.2 MST support on Haswell systems.
    
    Notes:
    a) this reworks irq handling for DP MST ports, so that we can
    avoid the mode config locking in the current hpd handlers, as
    we need to process up/down msgs at a better time.
    
    Changes since v0.1:
    use PORT_PCH_HOTPLUG to detect short vs long pulses
    add a workqueue to deal with digital events as they can get blocked on the
    main workqueue beyong mode_config mutex
    fix a bunch of modeset checker warnings
    acks irqs in the driver
    cleanup the MST encoders
    
    Changes since v0.2:
    check irq status again in work handler
    move around bring up and tear down to fix DPMS on/off
    use path properties.
    
    Changes since v0.3:
    updates for mst apis
    more state checker fixes
    irq handling improvements
    fbcon handling support
    improved reference counting of link - fixes redocking.
    
    Changes since v0.4:
    handle gpu reset hpd reinit without oopsing
    check link status on HPD irqs
    fix suspend/resume
    
    Changes since v0.5:
    use proper functions to get max link/lane counts
    fix another checker backtrace - due to connectors disappearing.
    set output type in more places fro, unknown->displayport
    don't talk to devices if no HPD asserted
    check mst on short irqs only
    check link status properly
    rebase onto prepping irq changes.
    drop unsued force_act
    
    Changes since v0.6:
    cleanup unused struct entry.
    
    [airlied: fix some sparse warnings].
    
    Reviewed-by: Todd Previte <tprevite@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 83cb43a24768..a361bb9bc243 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -518,7 +518,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
 
-		intel_runtime_pm_disable_interrupts(dev);
 
 		intel_suspend_gt_powersave(dev);
 
@@ -532,6 +531,9 @@ static int i915_drm_freeze(struct drm_device *dev)
 		}
 		drm_modeset_unlock_all(dev);
 
+		intel_dp_mst_suspend(dev);
+		intel_runtime_pm_disable_interrupts(dev);
+
 		intel_modeset_suspend_hw(dev);
 	}
 
@@ -646,6 +648,15 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 
 		intel_modeset_init_hw(dev);
 
+		{
+			unsigned long irqflags;
+			spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
+			if (dev_priv->display.hpd_irq_setup)
+				dev_priv->display.hpd_irq_setup(dev);
+			spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
+		}
+
+		intel_dp_mst_resume(dev);
 		drm_modeset_lock_all(dev);
 		intel_modeset_setup_hw_state(dev, true);
 		drm_modeset_unlock_all(dev);

commit c51f71679042a5f388d9580ffbede14c897f1e86
Merge: b957f457fbce 7b3c29f6fd37
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Jul 19 16:43:41 2014 +1000

    Merge tag 'drm-intel-next-2014-07-11' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - fbc improvements when stolen memory is tight (Ben)
    - cdclk handling improvements for vlv/chv (Ville)
    - proper fix for stuck primary planes on gmch platforms with cxsr (Imre&Ebgert
      Eich)
    - gen8 hw semaphore support (Ben)
    - more execlist prep work from Oscar Mateo
    - locking fixes for primary planes (Matt Roper)
    - code rework to support runtime pm for dpms on hsw/bdw (Paulo, Imre & me), but
      not yet enabled because some fixes from Paulo haven't made the cut
    - more gpu boost tuning from Chris
    - as usual piles of little things all over
    
    * tag 'drm-intel-next-2014-07-11' of git://anongit.freedesktop.org/drm-intel: (93 commits)
      drm/i915: Make the RPS interrupt generation mask handle the vlv wa
      drm/i915: Move RPS evaluation interval counters to i915->rps
      drm/i915: Don't cast a pointer to void* unnecessarily
      drm/i915: don't read LVDS regs at compute_config time
      drm/i915: check the power domains in intel_lvds_get_hw_state()
      drm/i915: check the power domains in ironlake_get_pipe_config()
      drm/i915: don't skip shared DPLL assertion on LPT
      drm/i915: Only touch WRPLL hw state in enable/disable hooks
      drm/i915: Switch to common shared dpll framework for WRPLLs
      drm/i915: ->enable hook for WRPLLs
      drm/i915: ->disable hook for WRPLLs
      drm/i915: State readout support for WRPLLs
      drm/i915: add POWER_DOMAIN_PLLS
      drm/i915: Document that the pll->mode_set hook is optional
      drm/i915: Basic shared dpll support for WRPLLs
      drm/i915: Precompute static ddi_pll_sel values in encoders
      drm/i915: BDW also has special-purpose DP DDI clocks
      drm/i915: State readout and cross-checking for ddi_pll_sel
      drm/i915: Move ddi_pll_sel into the pipe config
      drm/i915: Add a debugfs file for the shared dpll state
      ...

commit ca5a1b9ba0fb5291b555a23b76dbe5f6c30bfd7a
Merge: c7dbc6c9ae5c 34882298b93e
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jul 9 10:38:42 2014 +1000

    Merge tag 'drm-intel-next-2014-06-20' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - Accurate frontbuffer tracking and frontbuffer rendering invalidate, flush and
      flip events. This is prep work for proper PSR support and should also be
      useful for DRRS&fbc.
    - Runtime suspend hardware on system suspend to support the new SOix sleep
      states, from Jesse.
    - PSR updates for broadwell (Rodrigo)
    - Universal plane support for cursors (Matt Roper), including core drm patches.
    - Prefault gtt mappings (Chris)
    - baytrail write-enable pte bit support (Akash Goel)
    - mmio based flips (Sourab Gupta) instead of blitter ring flips
    - interrupt handling race fixes (Oscar Mateo)
    
    And old, not yet merged features from the previous round:
    - rps/turbo support for chv (Deepak)
    - some other straggling chv patches (Ville)
    - proper universal plane conversion for the primary plane (Matt Roper)
    - ppgtt on vlv from Jesse
    - pile of cleanups, little fixes for insane corner cases and improved debug
      support all over
    
    * tag 'drm-intel-next-2014-06-20' of git://anongit.freedesktop.org/drm-intel: (99 commits)
      drm/i915: Update DRIVER_DATE to 20140620
      drivers/i915: Fix unnoticed failure of init_ring_common()
      drm/i915: Track frontbuffer invalidation/flushing
      drm/i915: Use new frontbuffer bits to increase pll clock
      drm/i915: don't take runtime PM reference around freeze/thaw
      drm/i915: use runtime irq suspend/resume in freeze/thaw
      drm/i915: Properly track domain of the fbcon fb
      drm/i915: Print obj->frontbuffer_bits in debugfs output
      drm/i915: Introduce accurate frontbuffer tracking
      drm/i915: Drop schedule_back from psr_exit
      drm/i915: Ditch intel_edp_psr_update
      drm/i915: Drop unecessary complexity from psr_inactivate
      drm/i915: Remove ctx->last_ring
      drm/i915/chv: Ack interrupts before handling them (CHV)
      drm/i915/bdw: Ack interrupts before handling them (GEN8)
      drm/i915/vlv: Ack interrupts before handling them (VLV)
      drm/i915: Ack interrupts before handling them (GEN5 - GEN7)
      drm/i915: Don't BUG_ON in i915_gem_obj_offset
      drm/i915: Grab dev->struct_mutex in i915_gem_pageflip_info
      drm/i915: Add some L3 registers to the parser whitelist
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit 95fa2eeecfe82788b47366abf7c3a773cc187663
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Jun 23 15:46:02 2014 +0300

    drm/i915: make system freeze support depend on CONFIG_ACPI_SLEEP
    
    To achieve further power savings during system freeze (aka connected
    standby, or s0ix) we have to send a PCI_D1 opregion notification. As
    the information about the state we're entering (system freeze,
    suspend to ram or suspend to disk) is only available through the ACPI
    subsystem, make this support depend on the relevant kconfig option.
    Things will still work if this option isn't set, albeit with less than
    optimial power saving.
    
    This also fixes a compile breakage when the option is not set introduced
    in
    
    commit e5747e3adcd67ae27105003ec99fb58cba180105
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Thu Jun 12 08:35:47 2014 -0700
    
        drm/i915: send proper opregion notifications on suspend/resume
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bc1962362ffb..23139aaa9431 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -540,10 +540,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	i915_save_state(dev);
 
-	if (acpi_target_system_state() >= ACPI_STATE_S3)
-		opregion_target_state = PCI_D3cold;
-	else
+	opregion_target_state = PCI_D3cold;
+#if IS_ENABLED(CONFIG_ACPI_SLEEP)
+	if (acpi_target_system_state() < ACPI_STATE_S3)
 		opregion_target_state = PCI_D1;
+#endif
 	intel_opregion_notify_adapter(dev, opregion_target_state);
 
 	intel_uncore_forcewake_reset(dev, false);

commit 50c3dc970a09b3b60422a58934cc27a413288bab
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 27 17:19:22 2014 +0200

    drm/fb-helper: Fix hpd vs. initial config races
    
    Some drivers need to be able to have a perfect race-free fbcon setup.
    Current drivers only enable hotplug processing after the call to
    drm_fb_helper_initial_config which leaves a tiny but important race.
    
    This race is especially noticable on embedded platforms where the
    driver itself enables the voltage for the hdmi output, since only then
    will monitors (after a bit of delay, as usual) respond by asserting
    the hpd pin.
    
    Most of the infrastructure is already there with the split-out
    drm_fb_helper_init. And drm_fb_helper_initial_config already has all
    the required locking to handle concurrent hpd events since
    
    commit 53f1904bced78d7c00f5d874c662ec3ac85d0f9f
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Mar 20 14:26:35 2014 +0100
    
        drm/fb-helper: improve drm_fb_helper_initial_config locking
    
    The only missing bit is making drm_fb_helper_hotplug_event save
    against concurrent calls of drm_fb_helper_initial_config. The only
    unprotected bit is the check for fb_helper->fb.
    
    With that drivers can first initialize the fb helper, then enabel
    hotplug processing and then set up the initial config all in a
    completely race-free manner. Update kerneldoc and convert i915 as a
    proof of concept.
    
    Feature requested by Thierry since his tegra driver atm reliably boots
    slowly enough to misses the hotplug event for an external hdmi screen,
    but also reliably boots to quickly for the hpd pin to be asserted when
    the fb helper calls into the hdmi ->detect function.
    
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 651e65e051c0..d935ab3718e1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -527,7 +527,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 		}
 
 		drm_irq_uninstall(dev);
-		dev_priv->enable_hotplug_processing = false;
 
 		intel_disable_gt_powersave(dev);
 
@@ -655,7 +654,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		 * notifications.
 		 * */
 		intel_hpd_init(dev);
-		dev_priv->enable_hotplug_processing = true;
 		/* Config may have changed between suspend and resume */
 		drm_helper_hpd_irq_event(dev);
 	}

commit 521e62e49a42661a4ee0102644517dbe2f100a23
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Jun 30 09:53:44 2014 -0700

    drm/i915: Enable semaphores on BDW
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8a0cb0cc39ad..bc1962362ffb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -477,10 +477,6 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (i915.semaphores >= 0)
 		return i915.semaphores;
 
-	/* Until we get further testing... */
-	if (IS_GEN8(dev))
-		return false;
-
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
 	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)

commit 84a2ab8ec76b4fa47f490a01c8186e4b4d757bfe
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Jun 27 18:51:51 2014 -0300

    drm/i915: flush delayed_resume_work when suspending
    
    It is possible that, by the time we run i915_drm_freeze(),
    delayed_resume_work was already queued but did not run yet. If it
    still didn't run after intel_runtime_pm_disable_interrupts(), by the
    time it runs it will try to change the interrupt registers with the
    interrupts already disabled, which will trigger a WARN. We can
    reliably reproduce this with the pm_rpm system-suspend test case.
    
    In order to avoid the problem, we have to flush the work before
    disabling the interrupts. We could also cancel the work instead of
    flushing it, but that would require us to put a runtime PM reference -
    and any other resource we may need in the future - in case the work
    was already queued, so I believe flushing the work is more
    future-proof, although less efficient. But I can also change this part
    if someone requests.
    
    Another thing I tried was to move the intel_suspend_gt_powersave()
    call to before intel_runtime_pm_disable_interrupts(), but since that
    function needs to be called after the interrupts are already disabled,
    due to dev_priv->rps.work, this strategy didn't work.
    
    Testcase: igt/pm_rpm/system-suspend
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=80517
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6eb45ac7a7d5..8a0cb0cc39ad 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -520,6 +520,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 			return error;
 		}
 
+		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
+
 		intel_runtime_pm_disable_interrupts(dev);
 		dev_priv->enable_hotplug_processing = false;
 

commit 395a5abbd97d7d76a7a26da52f33daebe279b3b3
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jun 18 09:52:56 2014 -0700

    drm/i915: don't take runtime PM reference around freeze/thaw
    
    We should be taking the right power well refs these days, so this
    shouldn't be necessary.  It also gets in the way of re-using these
    routines for S0iX states, as those need all the power saving features
    enabled.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index be9774148426..6eb45ac7a7d5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -496,8 +496,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 	struct drm_crtc *crtc;
 	pci_power_t opregion_target_state;
 
-	intel_runtime_pm_get(dev_priv);
-
 	/* ignore lid events during suspend */
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_SUSPENDED;
@@ -686,7 +684,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 
 	intel_opregion_notify_adapter(dev, PCI_D0);
 
-	intel_runtime_pm_put(dev_priv);
 	return 0;
 }
 

commit e11aa362308f5de467ce355a2a2471321b15a35c
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jun 18 09:52:55 2014 -0700

    drm/i915: use runtime irq suspend/resume in freeze/thaw
    
    We don't need to uninstall the full handler, simply disabling interrupts
    ought to be enough.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7ae4e2a20493..be9774148426 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -522,7 +522,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 			return error;
 		}
 
-		drm_irq_uninstall(dev);
+		intel_runtime_pm_disable_interrupts(dev);
 		dev_priv->enable_hotplug_processing = false;
 
 		intel_suspend_gt_powersave(dev);
@@ -646,8 +646,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		}
 		mutex_unlock(&dev->struct_mutex);
 
-		/* We need working interrupts for modeset enabling ... */
-		drm_irq_install(dev, dev->pdev->irq);
+		intel_runtime_pm_restore_interrupts(dev);
 
 		intel_modeset_init_hw(dev);
 

commit 5d0cf3d6e07957502dae8602e2f96eb6790ddc13
Merge: 27b6c122512c 8abdc17941c7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 18 11:44:05 2014 +0200

    Merge branch 'topic/soix' into drm-intel-next-queued
    
    Jesse's SOix work required some patches from acpi-next, so pull it in
    through a topic barnch.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c
            drivers/gpu/drm/i915/intel_pm.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 10018603a481e4c1067e825e449f2e19dd737095
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Jun 6 12:59:39 2014 +0300

    drm/i915: preserve user forcewake over system suspend/resume
    
    Atm, the forcewake refcount will be incorrectly set to zero during
    system suspend if there is any reference held via the
    i915_forcewake_user debugfs entry.
    
    Fix this by simply not zeroing the sw counters during suspend and
    restoring the original state using them. Note that the only other
    places where we zeroed the counters were driver load and unload time,
    where it was redundant anyway.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=78059
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 615b62f0541d..5a08c86cb1ab 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -600,7 +600,7 @@ static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	intel_uncore_early_sanitize(dev);
+	intel_uncore_early_sanitize(dev, true);
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);
 

commit 8abdc17941c71b37311bb93876ac83dce58160c8
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Thu Jun 12 08:35:48 2014 -0700

    drm/i915: make sure PC8 is enabled on suspend and disabled on resume v4
    
    This matches the runtime suspend paths and allows the system to enter
    the lowest power mode at freeze time.
    
    v2: move disable_pc8 call to thaw_early (Imre)
        move enable_pc8 to freeze_late (Imre/Jesse)
    v3: drop spurious hunk from _freeze now that we have freeze_late (Jesse)
    v4: move back to suspend_late (Imre was right)
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43b804357bcf..3536bfe537dd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -616,6 +616,9 @@ static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
+		hsw_disable_pc8(dev_priv);
+
 	intel_uncore_early_sanitize(dev);
 	intel_uncore_sanitize(dev);
 	intel_power_domains_init_hw(dev_priv);
@@ -899,6 +902,7 @@ static int i915_pm_suspend_late(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *dev_priv = drm_dev->dev_private;
 
 	/*
 	 * We have a suspedn ordering issue with the snd-hda driver also
@@ -912,6 +916,9 @@ static int i915_pm_suspend_late(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
+	if (IS_HASWELL(drm_dev) || IS_BROADWELL(drm_dev))
+		hsw_enable_pc8(dev_priv);
+
 	pci_disable_device(pdev);
 	pci_set_power_state(pdev, PCI_D3hot);
 

commit e5747e3adcd67ae27105003ec99fb58cba180105
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Jun 12 08:35:47 2014 -0700

    drm/i915: send proper opregion notifications on suspend/resume
    
    This indicates to the firmware that it can power down various other
    components or bring them back up, depending on the target system state.
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 704dfe36c2ed..43b804357bcf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -28,6 +28,7 @@
  */
 
 #include <linux/device.h>
+#include <linux/acpi.h>
 #include <drm/drmP.h>
 #include <drm/i915_drm.h>
 #include "i915_drv.h"
@@ -499,6 +500,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_crtc *crtc;
+	pci_power_t opregion_target_state;
 
 	intel_runtime_pm_get(dev_priv);
 
@@ -548,6 +550,12 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	i915_save_state(dev);
 
+	if (acpi_target_system_state() >= ACPI_STATE_S3)
+		opregion_target_state = PCI_D3cold;
+	else
+		opregion_target_state = PCI_D1;
+	intel_opregion_notify_adapter(dev, opregion_target_state);
+
 	intel_uncore_forcewake_reset(dev, false);
 	intel_opregion_fini(dev);
 
@@ -680,6 +688,8 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 	dev_priv->modeset_restore = MODESET_DONE;
 	mutex_unlock(&dev_priv->modeset_restore_lock);
 
+	intel_opregion_notify_adapter(dev, PCI_D0);
+
 	intel_runtime_pm_put(dev_priv);
 	return 0;
 }

commit 156c7ca08185886329113f20249446af4fb07f60
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Jun 12 08:35:45 2014 -0700

    drm/i915: leave rc6 enabled at suspend time v4
    
    This allows the system to enter the lowest power mode during system freeze.
    
    v2: delete force wake timer at suspend (Imre)
    v3: add GT work suspend function (Imre)
    v4: use uncore forcewake reset (Daniel)
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 458b778cd495..704dfe36c2ed 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -529,7 +529,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 		drm_irq_uninstall(dev);
 		dev_priv->enable_hotplug_processing = false;
 
-		intel_disable_gt_powersave(dev);
+		intel_suspend_gt_powersave(dev);
 
 		/*
 		 * Disable CRTCs directly since we want to preserve sw state
@@ -548,8 +548,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	i915_save_state(dev);
 
+	intel_uncore_forcewake_reset(dev, false);
 	intel_opregion_fini(dev);
-	intel_uncore_fini(dev);
 
 	console_lock();
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED);

commit 85e90679335f56d162f4a0ff525573818e17ce44
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Thu Jun 12 08:35:44 2014 -0700

    drm/i915: disable power wells on suspend
    
    We want to make sure everything is disabled and at its lowest power when
    freezing.
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 651e65e051c0..458b778cd495 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -557,6 +557,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	dev_priv->suspend_count++;
 
+	intel_display_set_init_power(dev_priv, false);
+
 	return 0;
 }
 

commit 2d401b175f9026d839d3ad1cf444802c986c32bc
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 9 13:29:08 2014 +0300

    drm/i915: Don't use pipe_offset stuff for DPLL registers
    
    These are just single registers so wasting space for the pipe offsets
    seems a bit pointless. So just use the _PIPE3() macro instead.
    
    Also rewrite the _PIPE3() macro to be more obvious, and protect the
    arguments properly.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    [danvet: Frob conflict.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 651e65e051c0..615b62f0541d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -46,8 +46,6 @@ static struct drm_driver driver;
 			  PIPE_C_OFFSET, PIPE_EDP_OFFSET }, \
 	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
 			   TRANSCODER_C_OFFSET, TRANSCODER_EDP_OFFSET }, \
-	.dpll_offsets = { DPLL_A_OFFSET, DPLL_B_OFFSET }, \
-	.dpll_md_offsets = { DPLL_A_MD_OFFSET, DPLL_B_MD_OFFSET }, \
 	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET }
 
 #define GEN_CHV_PIPEOFFSETS \
@@ -55,10 +53,6 @@ static struct drm_driver driver;
 			  CHV_PIPE_C_OFFSET }, \
 	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
 			   CHV_TRANSCODER_C_OFFSET, }, \
-	.dpll_offsets = { DPLL_A_OFFSET, DPLL_B_OFFSET, \
-			  CHV_DPLL_C_OFFSET }, \
-	.dpll_md_offsets = { DPLL_A_MD_OFFSET, DPLL_B_MD_OFFSET, \
-			     CHV_DPLL_C_MD_OFFSET }, \
 	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET, \
 			     CHV_PALETTE_C_OFFSET }
 

commit 15d24aa5602fb87c7b1358cfabcfeb9b26db290f
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Wed Jun 4 17:09:30 2014 -0700

    drm/i915: BDW: Adding missing cursor offsets.
    
    BDW uses IVB cursor offsets.
    
    Whithout this patch it is not possible to use multiple outputs with cursor
    on BDW.
    The cursor gets completely crazy because update position uses the wrong
    cursor register for the second pipe.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=79621
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fa7138215b56..651e65e051c0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -321,6 +321,7 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	.has_ddi = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_gt3d_info = {
@@ -331,6 +332,7 @@ static const struct intel_device_info intel_broadwell_gt3d_info = {
 	.has_ddi = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_gt3m_info = {

commit c9cd7b65db50175a5f1ff64bbad6d5affdad6aba
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Jun 2 16:58:30 2014 +0300

    drm/i915: tell the user if both KMS and UMS are disabled
    
    If both KMS is disabled (by i915.modeset=0 or nomodeset parameters) and
    UMS is disabled (by CONFIG_DRM_I915_UMS=n, the default), the user might
    not be aware his setup is not supported. Inform the users (and, by
    extension, the poor i915 developers having to read their dmesgs in bug
    reports) why their graphics experience might be lacking.
    
    A similar message was added on the UMS path in
    commit e147accbd19f55489dabdcc4dc3551cc3e3f2553
    Author: Jani Nikula <jani.nikula@intel.com>
    Date:   Thu Oct 10 15:25:37 2013 +0300
    
        drm/i915: tell the user KMS is required for gen6+
    
    but it won't be reached if CONFIG_DRM_I915_UMS=n since
    commit b30324adaf8d2e5950a602bde63030d15a61826f
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Nov 13 22:11:25 2013 +0100
    
        drm/i915: Deprecated UMS support
    
    v2: Use DRM_DEBUG_DRIVER.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 481d2a14cdc6..fa7138215b56 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1583,6 +1583,7 @@ static int __init i915_init(void)
 		driver.get_vblank_timestamp = NULL;
 #ifndef CONFIG_DRM_I915_UMS
 		/* Silently fail loading to not upset userspace. */
+		DRM_DEBUG_DRIVER("KMS and UMS disabled.\n");
 		return 0;
 #endif
 	}

commit 78ad455fd229c6f6cc2f390ccbe0d8f1a62d55a9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 22 22:18:21 2014 +0200

    drm/i915: Improve irq handling after gpu resets
    
    Currently we do a full re-init of all interrupts after a gpu hang.
    Which is pretty bad since we don't restore the interrupts we've
    enabled at runtime correctly. Even with that addressed it's rather
    horribly race.
    
    But on g4x and later we only reset the gt and not the entire gpu.
    Which means we only need to reset the GT interrupt bits. Which has the
    nice benefit that vblank waits, pipe CRC interrupts and everything
    else display related just keeps on working.
    
    The downside is that gt interrupt handling (i.e. ring->get/put_irq) is
    still racy. But as long as the gpu hang reliably wakes all waters and
    we have a short time where the refcount drops to 0 we'll recover. So
    not that bad really.
    
    v2: Ville noticed that GTIMR and PMIMR don't get cleared, only the
    subordinate per-ring registers. So let's rip out all the interrupt dancing.
    The FIXME comment is still required though since the ring irq handling
    happens at the per-ring interrupt mask registers, too.
    
    Testcase: igt/kms_flip/vblank-vs-hang
    Testcase: igt/kms_pipe_crc_basic/hang-*
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5b5b82c3f570..481d2a14cdc6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -811,17 +811,17 @@ int i915_reset(struct drm_device *dev)
 		}
 
 		/*
-		 * FIXME: This is horribly race against concurrent pageflip and
-		 * vblank wait ioctls since they can observe dev->irqs_disabled
-		 * being false when they shouldn't be able to.
+		 * FIXME: This races pretty badly against concurrent holders of
+		 * ring interrupts. This is possible since we've started to drop
+		 * dev->struct_mutex in select places when waiting for the gpu.
 		 */
-		drm_irq_uninstall(dev);
-		drm_irq_install(dev, dev->pdev->irq);
 
-		/* rps/rc6 re-init is necessary to restore state lost after the
-		 * reset and the re-install of drm irq. Skip for ironlake per
+		/*
+		 * rps/rc6 re-init is necessary to restore state lost after the
+		 * reset and the re-install of gt irqs. Skip for ironlake per
 		 * previous concerns that it doesn't respond well to some forms
-		 * of re-init after reset. */
+		 * of re-init after reset.
+		 */
 		if (INTEL_INFO(dev)->gen > 5)
 			intel_reset_gt_powersave(dev);
 

commit 6e9f798d91c526982cca0026cd451e8fdbf18aaf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 29 23:54:47 2014 +0200

    drm: Split connection_mutex out of mode_config.mutex (v3)
    
    After the split-out of crtc locks from the big mode_config.mutex
    there's still two major areas it protects:
    - Various connector probe states, like connector->status, EDID
      properties, probed mode lists and similar information.
    - The links from connector->encoder and encoder->crtc and other
      modeset-relevant connector state (e.g. properties which control the
      panel fitter).
    
    The later is used by modeset operations. But they don't really care
    about the former since it's allowed to e.g. enable a disconnected VGA
    output or with a mode not in the probed list.
    
    Thus far this hasn't been a problem, but for the atomic modeset
    conversion Rob Clark needs to convert all modeset relevant locks into
    w/w locks. This is required because the order of acquisition is
    determined by how userspace supplies the atomic modeset data. This has
    run into troubles in the detect path since the i915 load detect code
    needs _both_ protections offered by the mode_config.mutex: It updates
    probe state and it needs to change the modeset configuration to enable
    the temporary load detect pipe.
    
    The big deal here is that for the probe/detect users of this lock a
    plain mutex fits best, but for atomic modesets we really want a w/w
    mutex. To fix this lets split out a new connection_mutex lock for the
    modeset relevant parts.
    
    For simplicity I've decided to only add one additional lock for all
    connector/encoder links and modeset configuration states. We have
    piles of different modeset objects in addition to those (like bridges
    or panels), so adding per-object locks would be much more effort.
    
    Also, we're guaranteed (at least for now) to do a full modeset if we
    need to acquire this lock. Which means that fine-grained locking is
    fairly irrelevant compared to the amount of time the full modeset will
    take.
    
    I've done a full audit, and there's just a few things that justify
    special focus:
    - Locking in drm_sysfs.c is almost completely absent. We should
      sprinkle mode_config.connection_mutex over this file a bit, but
      since it already lacks mode_config.mutex this patch wont make the
      situation any worse. This is material for a follow-up patch.
    
    - omap has a omap_framebuffer_flush function which walks the
      connector->encoder->crtc links and is called from many contexts.
      Some look like they don't acquire mode_config.mutex, so this is
      already racy. Again fixing this is material for a separate patch.
    
    - The radeon hot_plug function to retrain DP links looks at
      connector->dpms. Currently this happens without any locking, so is
      already racy. I think radeon_hotplug_work_func should gain
      mutex_lock/unlock calls for the mode_config.connection_mutex.
    
    - Same applies to i915's intel_dp_hot_plug. But again, this is already
      racy.
    
    - i915 load_detect code needs to acquire this lock. Which means the
      w/w dance due to Rob's work will be nicely contained to _just_ this
      function.
    
    I've added fixme comments everywhere where it looks suspicious but in
    the sysfs code. After a quick irc discussion with Dave Airlie it
    sounds like the lack of locking in there is due to sysfs cleanup fun
    at module unload.
    
    v1: original (only compile tested)
    
    v2: missing mutex_init(), etc (from Rob Clark)
    
    v3: i915 needs more care in the conversion:
    - Protect the edp pp logic with the connection_mutex.
    - Use connection_mutex in the backlight code due to
      get_pipe_from_connector.
    - Use drm_modeset_lock_all in suspend/resume paths.
    - Update lock checks in the overlay code.
    
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4619c9e51907..5b5b82c3f570 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -533,13 +533,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 		 * Disable CRTCs directly since we want to preserve sw state
 		 * for _thaw.
 		 */
-		mutex_lock(&dev->mode_config.mutex);
+		drm_modeset_lock_all(dev);
 		for_each_crtc(dev, crtc) {
-			mutex_lock(&crtc->mutex);
 			dev_priv->display.crtc_disable(crtc);
-			mutex_unlock(&crtc->mutex);
 		}
-		mutex_unlock(&dev->mode_config.mutex);
+		drm_modeset_unlock_all(dev);
 
 		intel_modeset_suspend_hw(dev);
 	}

commit fe5b1886a78d92e0e4681e449725714e947dfc58
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon May 12 18:35:05 2014 +0300

    drm/i915: disable GT power saving early during system suspend
    
    Atm, we disable GT power saving during the end of the suspend sequence
    in i915_save_state(). Doing the disabling at that point seems arbitrary.
    One reason to disable it early though is to have a quiescent HW state
    before we do anything else (for example save registers). So move the
    disabling earlier, which also takes care canceling of the deferred RPS
    enabling work done by intel_disable_gt_powersave().
    
    Note that after the move we'll call intel_disable_gt_powersave() only
    in case modeset is enabled, but that's anyway the only case where we
    have it enabled in the first place.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Robert Beckett <robert.beckett@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index acb93fad4df7..4619c9e51907 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -524,10 +524,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 			return error;
 		}
 
-		cancel_delayed_work_sync(&dev_priv->rps.delayed_resume_work);
-
 		drm_irq_uninstall(dev);
 		dev_priv->enable_hotplug_processing = false;
+
+		intel_disable_gt_powersave(dev);
+
 		/*
 		 * Disable CRTCs directly since we want to preserve sw state
 		 * for _thaw.

commit d6102977643de5be2d7dc022fcd2c75ffff59a1b
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed May 7 19:57:49 2014 +0300

    drm/i915: remove user GTT mappings early during runtime suspend
    
    Currently user space can access GEM buffers mapped to GTT through
    existing mappings concurrently while the platform specific suspend
    handlers are running. Since these handlers may change the HW state in a
    way that would break such accesses, remove the mappings before calling
    the handlers. Spotted by Ville.
    
    Also Chris pointed out that the lists that i915_gem_release_all_mmaps()
    walks through need dev->struct_mutex, so take this lock. There is a
    potential deadlock against a concurrent RPM resume, resolve this by
    aborting and rescheduling the suspend (Daniel).
    
    v2:
    - take struct_mutex around i915_gem_release_all_mmaps() (Chris, Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Robert Beckett <robert.beckett@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c83c83b74bf4..acb93fad4df7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -36,6 +36,7 @@
 
 #include <linux/console.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <drm/drm_crtc_helper.h>
 
 static struct drm_driver driver;
@@ -1355,6 +1356,30 @@ static int intel_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	/*
+	 * We could deadlock here in case another thread holding struct_mutex
+	 * calls RPM suspend concurrently, since the RPM suspend will wait
+	 * first for this RPM suspend to finish. In this case the concurrent
+	 * RPM resume will be followed by its RPM suspend counterpart. Still
+	 * for consistency return -EAGAIN, which will reschedule this suspend.
+	 */
+	if (!mutex_trylock(&dev->struct_mutex)) {
+		DRM_DEBUG_KMS("device lock contention, deffering suspend\n");
+		/*
+		 * Bump the expiration timestamp, otherwise the suspend won't
+		 * be rescheduled.
+		 */
+		pm_runtime_mark_last_busy(device);
+
+		return -EAGAIN;
+	}
+	/*
+	 * We are safe here against re-faults, since the fault handler takes
+	 * an RPM reference.
+	 */
+	i915_gem_release_all_mmaps(dev_priv);
+	mutex_unlock(&dev->struct_mutex);
+
 	/*
 	 * rps.work can't be rearmed here, since we get here only after making
 	 * sure the GPU is idle and the RPS freq is set to the minimum. See
@@ -1381,8 +1406,6 @@ static int intel_runtime_suspend(struct device *device)
 		return ret;
 	}
 
-	i915_gem_release_all_mmaps(dev_priv);
-
 	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
 	dev_priv->pm.suspended = true;
 

commit f7ef3fa77fa85b3a8a15b464efd56d0314a3231c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu May 22 09:44:40 2014 +0100

    drm/i915: Hold CRTC lock whilst freezing the planes
    
    Daniel keeps on ramping up the warning level of the DRM and our display
    core to make it complain whenever the locking rules are not followed.
    This caught
    
    commit 24576d23976746cb52e7700c4cadbf4bc1bc3472
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Tue Mar 26 09:25:45 2013 -0700
    
        drm/i915: enable VT switchless resume v3
    
    introducing an unlocked access to the CRTC whilst disabling it for
    suspend.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=78114
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d9e06e751523..c83c83b74bf4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -532,8 +532,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 		 * for _thaw.
 		 */
 		mutex_lock(&dev->mode_config.mutex);
-		for_each_crtc(dev, crtc)
+		for_each_crtc(dev, crtc) {
+			mutex_lock(&crtc->mutex);
 			dev_priv->display.crtc_disable(crtc);
+			mutex_unlock(&crtc->mutex);
+		}
 		mutex_unlock(&dev->mode_config.mutex);
 
 		intel_modeset_suspend_hw(dev);

commit 1ff74cf15a376a98d5c7c5b6dcb9aebd9734acdd
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue May 20 15:25:33 2014 -0700

    drm/i915: drop encoder hot_plug calls at resume
    
    We really just want to go detect displays again and fire off a hotplug
    event if things have changed, not go through full hotplug processing.
    
    Requested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 009d677a2385..d9e06e751523 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -597,24 +597,6 @@ void intel_console_resume(struct work_struct *work)
 	console_unlock();
 }
 
-static void intel_resume_hotplug(struct drm_device *dev)
-{
-	struct drm_mode_config *mode_config = &dev->mode_config;
-	struct intel_encoder *encoder;
-
-	mutex_lock(&mode_config->mutex);
-	DRM_DEBUG_KMS("running encoder hotplug functions\n");
-
-	list_for_each_entry(encoder, &mode_config->encoder_list, base.head)
-		if (encoder->hot_plug)
-			encoder->hot_plug(encoder);
-
-	mutex_unlock(&mode_config->mutex);
-
-	/* Just fire off a uevent and let userspace tell us what to do */
-	drm_helper_hpd_irq_event(dev);
-}
-
 static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -670,7 +652,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		intel_hpd_init(dev);
 		dev_priv->enable_hotplug_processing = true;
 		/* Config may have changed between suspend and resume */
-		intel_resume_hotplug(dev);
+		drm_helper_hpd_irq_event(dev);
 	}
 
 	intel_opregion_init(dev);

commit 07fddb14c0fb7d6ed4e8269c69e8f028f4782349
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 9 13:28:54 2014 +0300

    drm/i915/chv: Bump num_pipes to 3
    
    CHV has three pipes so let's expose them all.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6920127d734a..009d677a2385 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -345,7 +345,7 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 
 static const struct intel_device_info intel_cherryview_info = {
 	.is_preliminary = 1,
-	.gen = 8, .num_pipes = 2,
+	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.is_valleyview = 1,

commit 5efb3e2838536832c9b6872512e6b6daf592cee9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 9 13:28:53 2014 +0300

    drm/i915/chv: Add cursor pipe offsets
    
    Unsurprisingly the cursor C regiters are also at a weird offset on CHV.
    Add more pipe offsets to handle them.
    
    This also gets rid of most of the differences between the i9xx vs. ivb
    cursor code. We can unify the remaining code as well, but I'll leave
    that for another patch.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4636799c7b67..6920127d734a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,11 +61,18 @@ static struct drm_driver driver;
 	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET, \
 			     CHV_PALETTE_C_OFFSET }
 
+#define CURSOR_OFFSETS \
+	.cursor_offsets = { CURSOR_A_OFFSET, CURSOR_B_OFFSET, CHV_CURSOR_C_OFFSET }
+
+#define IVB_CURSOR_OFFSETS \
+	.cursor_offsets = { CURSOR_A_OFFSET, IVB_CURSOR_B_OFFSET, IVB_CURSOR_C_OFFSET }
+
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_845g_info = {
@@ -73,6 +80,7 @@ static const struct intel_device_info intel_845g_info = {
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_i85x_info = {
@@ -82,6 +90,7 @@ static const struct intel_device_info intel_i85x_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_i865g_info = {
@@ -89,6 +98,7 @@ static const struct intel_device_info intel_i865g_info = {
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_i915g_info = {
@@ -96,6 +106,7 @@ static const struct intel_device_info intel_i915g_info = {
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 static const struct intel_device_info intel_i915gm_info = {
 	.gen = 3, .is_mobile = 1, .num_pipes = 2,
@@ -105,12 +116,14 @@ static const struct intel_device_info intel_i915gm_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 static const struct intel_device_info intel_i945g_info = {
 	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 static const struct intel_device_info intel_i945gm_info = {
 	.gen = 3, .is_i945gm = 1, .is_mobile = 1, .num_pipes = 2,
@@ -120,6 +133,7 @@ static const struct intel_device_info intel_i945gm_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_i965g_info = {
@@ -128,6 +142,7 @@ static const struct intel_device_info intel_i965g_info = {
 	.has_overlay = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
@@ -137,6 +152,7 @@ static const struct intel_device_info intel_i965gm_info = {
 	.supports_tv = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_g33_info = {
@@ -145,6 +161,7 @@ static const struct intel_device_info intel_g33_info = {
 	.has_overlay = 1,
 	.ring_mask = RENDER_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_g45_info = {
@@ -152,6 +169,7 @@ static const struct intel_device_info intel_g45_info = {
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_gm45_info = {
@@ -161,6 +179,7 @@ static const struct intel_device_info intel_gm45_info = {
 	.supports_tv = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_pineview_info = {
@@ -168,6 +187,7 @@ static const struct intel_device_info intel_pineview_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
@@ -175,6 +195,7 @@ static const struct intel_device_info intel_ironlake_d_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
@@ -183,6 +204,7 @@ static const struct intel_device_info intel_ironlake_m_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
@@ -192,6 +214,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -201,6 +224,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 #define GEN7_FEATURES  \
@@ -214,6 +238,7 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
@@ -221,6 +246,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.is_ivybridge = 1,
 	.is_mobile = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_q_info = {
@@ -228,6 +254,7 @@ static const struct intel_device_info intel_ivybridge_q_info = {
 	.is_ivybridge = 1,
 	.num_pipes = 0, /* legal, last one wins */
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {
@@ -239,6 +266,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
@@ -249,6 +277,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
 	GEN_DEFAULT_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_haswell_d_info = {
@@ -258,6 +287,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.has_fpga_dbg = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -268,6 +298,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_fpga_dbg = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_d_info = {
@@ -278,6 +309,7 @@ static const struct intel_device_info intel_broadwell_d_info = {
 	.has_ddi = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
@@ -308,6 +340,7 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 	.has_ddi = 1,
 	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
+	IVB_CURSOR_OFFSETS,
 };
 
 static const struct intel_device_info intel_cherryview_info = {
@@ -318,6 +351,7 @@ static const struct intel_device_info intel_cherryview_info = {
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
 	GEN_CHV_PIPEOFFSETS,
+	CURSOR_OFFSETS,
 };
 
 /*

commit 84fd4f4e18885fc6b4a00f222040f24727b52514
Author: Rafael Barbalho <rafael.barbalho@intel.com>
Date:   Mon Apr 28 14:00:42 2014 +0300

    drm/i915/chv: Add CHV display support
    
    Add support for the third pipe in cherrview
    
    v2: Don't use spaces for indentation (Jani)
        Wrap long lines
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Rafael Barbalho <rafael.barbalho@intel.com>
    [vsyrjala: slightly massaged the patch]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b948c7110be8..4636799c7b67 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,17 @@ static struct drm_driver driver;
 	.dpll_md_offsets = { DPLL_A_MD_OFFSET, DPLL_B_MD_OFFSET }, \
 	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET }
 
+#define GEN_CHV_PIPEOFFSETS \
+	.pipe_offsets = { PIPE_A_OFFSET, PIPE_B_OFFSET, \
+			  CHV_PIPE_C_OFFSET }, \
+	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
+			   CHV_TRANSCODER_C_OFFSET, }, \
+	.dpll_offsets = { DPLL_A_OFFSET, DPLL_B_OFFSET, \
+			  CHV_DPLL_C_OFFSET }, \
+	.dpll_md_offsets = { DPLL_A_MD_OFFSET, DPLL_B_MD_OFFSET, \
+			     CHV_DPLL_C_MD_OFFSET }, \
+	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET, \
+			     CHV_PALETTE_C_OFFSET }
 
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
@@ -306,6 +317,7 @@ static const struct intel_device_info intel_cherryview_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	GEN_CHV_PIPEOFFSETS,
 };
 
 /*

commit 70e1e0ec02dfe93650fb2c70824dc81e3eb5b2cc
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Tue May 13 23:32:24 2014 +0100

    drm/i915: Use for_each_crtc() when iterating through the CRTCs
    
    Patch done using the following semantic patch (thanks Daniel for the
    help!)
    
      @@
      iterator name list_for_each_entry;
      iterator name for_each_crtc;
      struct drm_crtc * crtc;
      struct drm_device * dev;
      @@
      -list_for_each_entry(crtc,&dev->mode_config.crtc_list, head) {
      +for_each_crtc(dev,crtc) {
            ...
      }
    
    Followed by a couple of fixups by hand (that spatch doesn't match the
    cases where list_for_each_entry() is not followed by a set of '{', '}',
    but I couldn't figure out a way to leave the '{' out of the iterator
    match).
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6868bc0eabd3..b948c7110be8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -486,7 +486,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 		 * for _thaw.
 		 */
 		mutex_lock(&dev->mode_config.mutex);
-		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
+		for_each_crtc(dev, crtc)
 			dev_priv->display.crtc_disable(crtc);
 		mutex_unlock(&dev->mode_config.mutex);
 

commit 7d87a7f709650bde4d7d63117f25ee1c095da5dd
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 9 18:19:04 2014 +0300

    srm/i915/chv: Add Cherryview PCI IDs
    
    v2: Update to also fill in the new num_pipes field.
    
    v3: Rebase on top of the pciid extraction.
    
    v4: Switch from info->has*ring to info->ring mask. Also add VEBOX support whiel
    at it.
    
    v5: s/CHV_PCI_IDS/CHV_IDS/, and drop the trailing '\'
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4024e16ae63d..6868bc0eabd3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -299,6 +299,15 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 	GEN_DEFAULT_PIPEOFFSETS,
 };
 
+static const struct intel_device_info intel_cherryview_info = {
+	.is_preliminary = 1,
+	.gen = 8, .num_pipes = 2,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.is_valleyview = 1,
+	.display_mmio_offset = VLV_DISPLAY_BASE,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -334,7 +343,8 @@ static const struct intel_device_info intel_broadwell_gt3m_info = {
 	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),	\
 	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),	\
 	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),	\
-	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info)
+	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info), \
+	INTEL_CHV_IDS(&intel_cherryview_info)
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit ddeea5b0c36f3665446518c609be91f9336ef674
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon May 5 15:19:56 2014 +0300

    drm/i915: vlv: add runtime PM support
    
    Add runtime PM support for VLV, but leave it disabled. The next patch
    enables it.
    
    The suspend/resume sequence used is based on [1] and [2]. In practice we
    depend on the GT RC6 mechanism to save the HW context depending on the
    render and media power wells. By the time we run the runtime suspend
    callback the display side is also off and the HW context for that is
    managed by the display power domain framework.
    
    Besides the above there are Gunit registers that depend on a system-wide
    power well. This power well goes off once the device enters any of the
    S0i[R123] states. To handle this scenario, save/restore these Gunit
    registers. Note that this is not the complete register set dictated by
    [2], to remove some overhead, registers that are known not to be used are
    ignored. Also some registers are fully setup by initialization functions
    called during resume, these are not saved either. The list of registers
    can be further reduced, see the TODO note in the code.
    
    [1] VLV_gfx_clocking_PM_reset_y12w21d3 / "Driver D3 entry/exit"
    [2] VLV2_S0IXRegs
    
    v2:
    - unchanged
    v3:
    - fix s/GEN6_PMIIR/GEN6_PMIMR/ typo when saving/restoring registers
      (Ville)
    v4:
    - rebased on the previous patch fixing GEN register prefixes
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [ rebased (according to v4) ]
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a1ebbb02dfa9..4024e16ae63d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -939,6 +939,198 @@ static int hsw_runtime_resume(struct drm_i915_private *dev_priv)
 	return 0;
 }
 
+/*
+ * Save all Gunit registers that may be lost after a D3 and a subsequent
+ * S0i[R123] transition. The list of registers needing a save/restore is
+ * defined in the VLV2_S0IXRegs document. This documents marks all Gunit
+ * registers in the following way:
+ * - Driver: saved/restored by the driver
+ * - Punit : saved/restored by the Punit firmware
+ * - No, w/o marking: no need to save/restore, since the register is R/O or
+ *                    used internally by the HW in a way that doesn't depend
+ *                    keeping the content across a suspend/resume.
+ * - Debug : used for debugging
+ *
+ * We save/restore all registers marked with 'Driver', with the following
+ * exceptions:
+ * - Registers out of use, including also registers marked with 'Debug'.
+ *   These have no effect on the driver's operation, so we don't save/restore
+ *   them to reduce the overhead.
+ * - Registers that are fully setup by an initialization function called from
+ *   the resume path. For example many clock gating and RPS/RC6 registers.
+ * - Registers that provide the right functionality with their reset defaults.
+ *
+ * TODO: Except for registers that based on the above 3 criteria can be safely
+ * ignored, we save/restore all others, practically treating the HW context as
+ * a black-box for the driver. Further investigation is needed to reduce the
+ * saved/restored registers even further, by following the same 3 criteria.
+ */
+static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)
+{
+	struct vlv_s0ix_state *s = &dev_priv->vlv_s0ix_state;
+	int i;
+
+	/* GAM 0x4000-0x4770 */
+	s->wr_watermark		= I915_READ(GEN7_WR_WATERMARK);
+	s->gfx_prio_ctrl	= I915_READ(GEN7_GFX_PRIO_CTRL);
+	s->arb_mode		= I915_READ(ARB_MODE);
+	s->gfx_pend_tlb0	= I915_READ(GEN7_GFX_PEND_TLB0);
+	s->gfx_pend_tlb1	= I915_READ(GEN7_GFX_PEND_TLB1);
+
+	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
+		s->lra_limits[i] = I915_READ(GEN7_LRA_LIMITS_BASE + i * 4);
+
+	s->media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
+	s->gfx_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
+
+	s->render_hwsp		= I915_READ(RENDER_HWS_PGA_GEN7);
+	s->ecochk		= I915_READ(GAM_ECOCHK);
+	s->bsd_hwsp		= I915_READ(BSD_HWS_PGA_GEN7);
+	s->blt_hwsp		= I915_READ(BLT_HWS_PGA_GEN7);
+
+	s->tlb_rd_addr		= I915_READ(GEN7_TLB_RD_ADDR);
+
+	/* MBC 0x9024-0x91D0, 0x8500 */
+	s->g3dctl		= I915_READ(VLV_G3DCTL);
+	s->gsckgctl		= I915_READ(VLV_GSCKGCTL);
+	s->mbctl		= I915_READ(GEN6_MBCTL);
+
+	/* GCP 0x9400-0x9424, 0x8100-0x810C */
+	s->ucgctl1		= I915_READ(GEN6_UCGCTL1);
+	s->ucgctl3		= I915_READ(GEN6_UCGCTL3);
+	s->rcgctl1		= I915_READ(GEN6_RCGCTL1);
+	s->rcgctl2		= I915_READ(GEN6_RCGCTL2);
+	s->rstctl		= I915_READ(GEN6_RSTCTL);
+	s->misccpctl		= I915_READ(GEN7_MISCCPCTL);
+
+	/* GPM 0xA000-0xAA84, 0x8000-0x80FC */
+	s->gfxpause		= I915_READ(GEN6_GFXPAUSE);
+	s->rpdeuhwtc		= I915_READ(GEN6_RPDEUHWTC);
+	s->rpdeuc		= I915_READ(GEN6_RPDEUC);
+	s->ecobus		= I915_READ(ECOBUS);
+	s->pwrdwnupctl		= I915_READ(VLV_PWRDWNUPCTL);
+	s->rp_down_timeout	= I915_READ(GEN6_RP_DOWN_TIMEOUT);
+	s->rp_deucsw		= I915_READ(GEN6_RPDEUCSW);
+	s->rcubmabdtmr		= I915_READ(GEN6_RCUBMABDTMR);
+	s->rcedata		= I915_READ(VLV_RCEDATA);
+	s->spare2gh		= I915_READ(VLV_SPAREG2H);
+
+	/* Display CZ domain, 0x4400C-0x4402C, 0x4F000-0x4F11F */
+	s->gt_imr		= I915_READ(GTIMR);
+	s->gt_ier		= I915_READ(GTIER);
+	s->pm_imr		= I915_READ(GEN6_PMIMR);
+	s->pm_ier		= I915_READ(GEN6_PMIER);
+
+	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
+		s->gt_scratch[i] = I915_READ(GEN7_GT_SCRATCH_BASE + i * 4);
+
+	/* GT SA CZ domain, 0x100000-0x138124 */
+	s->tilectl		= I915_READ(TILECTL);
+	s->gt_fifoctl		= I915_READ(GTFIFOCTL);
+	s->gtlc_wake_ctrl	= I915_READ(VLV_GTLC_WAKE_CTRL);
+	s->gtlc_survive		= I915_READ(VLV_GTLC_SURVIVABILITY_REG);
+	s->pmwgicz		= I915_READ(VLV_PMWGICZ);
+
+	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
+	s->gu_ctl0		= I915_READ(VLV_GU_CTL0);
+	s->gu_ctl1		= I915_READ(VLV_GU_CTL1);
+	s->clock_gate_dis2	= I915_READ(VLV_GUNIT_CLOCK_GATE2);
+
+	/*
+	 * Not saving any of:
+	 * DFT,		0x9800-0x9EC0
+	 * SARB,	0xB000-0xB1FC
+	 * GAC,		0x5208-0x524C, 0x14000-0x14C000
+	 * PCI CFG
+	 */
+}
+
+static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)
+{
+	struct vlv_s0ix_state *s = &dev_priv->vlv_s0ix_state;
+	u32 val;
+	int i;
+
+	/* GAM 0x4000-0x4770 */
+	I915_WRITE(GEN7_WR_WATERMARK,	s->wr_watermark);
+	I915_WRITE(GEN7_GFX_PRIO_CTRL,	s->gfx_prio_ctrl);
+	I915_WRITE(ARB_MODE,		s->arb_mode | (0xffff << 16));
+	I915_WRITE(GEN7_GFX_PEND_TLB0,	s->gfx_pend_tlb0);
+	I915_WRITE(GEN7_GFX_PEND_TLB1,	s->gfx_pend_tlb1);
+
+	for (i = 0; i < ARRAY_SIZE(s->lra_limits); i++)
+		I915_WRITE(GEN7_LRA_LIMITS_BASE + i * 4, s->lra_limits[i]);
+
+	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->media_max_req_count);
+	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s->gfx_max_req_count);
+
+	I915_WRITE(RENDER_HWS_PGA_GEN7,	s->render_hwsp);
+	I915_WRITE(GAM_ECOCHK,		s->ecochk);
+	I915_WRITE(BSD_HWS_PGA_GEN7,	s->bsd_hwsp);
+	I915_WRITE(BLT_HWS_PGA_GEN7,	s->blt_hwsp);
+
+	I915_WRITE(GEN7_TLB_RD_ADDR,	s->tlb_rd_addr);
+
+	/* MBC 0x9024-0x91D0, 0x8500 */
+	I915_WRITE(VLV_G3DCTL,		s->g3dctl);
+	I915_WRITE(VLV_GSCKGCTL,	s->gsckgctl);
+	I915_WRITE(GEN6_MBCTL,		s->mbctl);
+
+	/* GCP 0x9400-0x9424, 0x8100-0x810C */
+	I915_WRITE(GEN6_UCGCTL1,	s->ucgctl1);
+	I915_WRITE(GEN6_UCGCTL3,	s->ucgctl3);
+	I915_WRITE(GEN6_RCGCTL1,	s->rcgctl1);
+	I915_WRITE(GEN6_RCGCTL2,	s->rcgctl2);
+	I915_WRITE(GEN6_RSTCTL,		s->rstctl);
+	I915_WRITE(GEN7_MISCCPCTL,	s->misccpctl);
+
+	/* GPM 0xA000-0xAA84, 0x8000-0x80FC */
+	I915_WRITE(GEN6_GFXPAUSE,	s->gfxpause);
+	I915_WRITE(GEN6_RPDEUHWTC,	s->rpdeuhwtc);
+	I915_WRITE(GEN6_RPDEUC,		s->rpdeuc);
+	I915_WRITE(ECOBUS,		s->ecobus);
+	I915_WRITE(VLV_PWRDWNUPCTL,	s->pwrdwnupctl);
+	I915_WRITE(GEN6_RP_DOWN_TIMEOUT,s->rp_down_timeout);
+	I915_WRITE(GEN6_RPDEUCSW,	s->rp_deucsw);
+	I915_WRITE(GEN6_RCUBMABDTMR,	s->rcubmabdtmr);
+	I915_WRITE(VLV_RCEDATA,		s->rcedata);
+	I915_WRITE(VLV_SPAREG2H,	s->spare2gh);
+
+	/* Display CZ domain, 0x4400C-0x4402C, 0x4F000-0x4F11F */
+	I915_WRITE(GTIMR,		s->gt_imr);
+	I915_WRITE(GTIER,		s->gt_ier);
+	I915_WRITE(GEN6_PMIMR,		s->pm_imr);
+	I915_WRITE(GEN6_PMIER,		s->pm_ier);
+
+	for (i = 0; i < ARRAY_SIZE(s->gt_scratch); i++)
+		I915_WRITE(GEN7_GT_SCRATCH_BASE + i * 4, s->gt_scratch[i]);
+
+	/* GT SA CZ domain, 0x100000-0x138124 */
+	I915_WRITE(TILECTL,			s->tilectl);
+	I915_WRITE(GTFIFOCTL,			s->gt_fifoctl);
+	/*
+	 * Preserve the GT allow wake and GFX force clock bit, they are not
+	 * be restored, as they are used to control the s0ix suspend/resume
+	 * sequence by the caller.
+	 */
+	val = I915_READ(VLV_GTLC_WAKE_CTRL);
+	val &= VLV_GTLC_ALLOWWAKEREQ;
+	val |= s->gtlc_wake_ctrl & ~VLV_GTLC_ALLOWWAKEREQ;
+	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
+
+	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
+	val &= VLV_GFX_CLK_FORCE_ON_BIT;
+	val |= s->gtlc_survive & ~VLV_GFX_CLK_FORCE_ON_BIT;
+	I915_WRITE(VLV_GTLC_SURVIVABILITY_REG, val);
+
+	I915_WRITE(VLV_PMWGICZ,			s->pmwgicz);
+
+	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
+	I915_WRITE(VLV_GU_CTL0,			s->gu_ctl0);
+	I915_WRITE(VLV_GU_CTL1,			s->gu_ctl1);
+	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s->clock_gate_dis2);
+}
+
 int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 {
 	u32 val;
@@ -976,6 +1168,137 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 #undef COND
 }
 
+static int vlv_allow_gt_wake(struct drm_i915_private *dev_priv, bool allow)
+{
+	u32 val;
+	int err = 0;
+
+	val = I915_READ(VLV_GTLC_WAKE_CTRL);
+	val &= ~VLV_GTLC_ALLOWWAKEREQ;
+	if (allow)
+		val |= VLV_GTLC_ALLOWWAKEREQ;
+	I915_WRITE(VLV_GTLC_WAKE_CTRL, val);
+	POSTING_READ(VLV_GTLC_WAKE_CTRL);
+
+#define COND (!!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEACK) == \
+	      allow)
+	err = wait_for(COND, 1);
+	if (err)
+		DRM_ERROR("timeout disabling GT waking\n");
+	return err;
+#undef COND
+}
+
+static int vlv_wait_for_gt_wells(struct drm_i915_private *dev_priv,
+				 bool wait_for_on)
+{
+	u32 mask;
+	u32 val;
+	int err;
+
+	mask = VLV_GTLC_PW_MEDIA_STATUS_MASK | VLV_GTLC_PW_RENDER_STATUS_MASK;
+	val = wait_for_on ? mask : 0;
+#define COND ((I915_READ(VLV_GTLC_PW_STATUS) & mask) == val)
+	if (COND)
+		return 0;
+
+	DRM_DEBUG_KMS("waiting for GT wells to go %s (%08x)\n",
+			wait_for_on ? "on" : "off",
+			I915_READ(VLV_GTLC_PW_STATUS));
+
+	/*
+	 * RC6 transitioning can be delayed up to 2 msec (see
+	 * valleyview_enable_rps), use 3 msec for safety.
+	 */
+	err = wait_for(COND, 3);
+	if (err)
+		DRM_ERROR("timeout waiting for GT wells to go %s\n",
+			  wait_for_on ? "on" : "off");
+
+	return err;
+#undef COND
+}
+
+static void vlv_check_no_gt_access(struct drm_i915_private *dev_priv)
+{
+	if (!(I915_READ(VLV_GTLC_PW_STATUS) & VLV_GTLC_ALLOWWAKEERR))
+		return;
+
+	DRM_ERROR("GT register access while GT waking disabled\n");
+	I915_WRITE(VLV_GTLC_PW_STATUS, VLV_GTLC_ALLOWWAKEERR);
+}
+
+static int vlv_runtime_suspend(struct drm_i915_private *dev_priv)
+{
+	u32 mask;
+	int err;
+
+	/*
+	 * Bspec defines the following GT well on flags as debug only, so
+	 * don't treat them as hard failures.
+	 */
+	(void)vlv_wait_for_gt_wells(dev_priv, false);
+
+	mask = VLV_GTLC_RENDER_CTX_EXISTS | VLV_GTLC_MEDIA_CTX_EXISTS;
+	WARN_ON((I915_READ(VLV_GTLC_WAKE_CTRL) & mask) != mask);
+
+	vlv_check_no_gt_access(dev_priv);
+
+	err = vlv_force_gfx_clock(dev_priv, true);
+	if (err)
+		goto err1;
+
+	err = vlv_allow_gt_wake(dev_priv, false);
+	if (err)
+		goto err2;
+	vlv_save_gunit_s0ix_state(dev_priv);
+
+	err = vlv_force_gfx_clock(dev_priv, false);
+	if (err)
+		goto err2;
+
+	return 0;
+
+err2:
+	/* For safety always re-enable waking and disable gfx clock forcing */
+	vlv_allow_gt_wake(dev_priv, true);
+err1:
+	vlv_force_gfx_clock(dev_priv, false);
+
+	return err;
+}
+
+static int vlv_runtime_resume(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	int err;
+	int ret;
+
+	/*
+	 * If any of the steps fail just try to continue, that's the best we
+	 * can do at this point. Return the first error code (which will also
+	 * leave RPM permanently disabled).
+	 */
+	ret = vlv_force_gfx_clock(dev_priv, true);
+
+	vlv_restore_gunit_s0ix_state(dev_priv);
+
+	err = vlv_allow_gt_wake(dev_priv, true);
+	if (!ret)
+		ret = err;
+
+	err = vlv_force_gfx_clock(dev_priv, false);
+	if (!ret)
+		ret = err;
+
+	vlv_check_no_gt_access(dev_priv);
+
+	intel_init_clock_gating(dev);
+	i915_gem_restore_fences(dev);
+
+	return ret;
+}
+
 static int intel_runtime_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
@@ -1003,6 +1326,8 @@ static int intel_runtime_suspend(struct device *device)
 		ret = 0;
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		ret = hsw_runtime_suspend(dev_priv);
+	} else if (IS_VALLEYVIEW(dev)) {
+		ret = vlv_runtime_suspend(dev_priv);
 	} else {
 		ret = -ENODEV;
 		WARN_ON(1);
@@ -1051,6 +1376,8 @@ static int intel_runtime_resume(struct device *device)
 		ret = snb_runtime_resume(dev_priv);
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		ret = hsw_runtime_resume(dev_priv);
+	} else if (IS_VALLEYVIEW(dev)) {
+		ret = vlv_runtime_resume(dev_priv);
 	} else {
 		WARN_ON(1);
 		ret = -ENODEV;

commit 0ab9cfeb5df7dac60174589134c3894105458ffc
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Apr 15 16:39:45 2014 +0300

    drm/i915: propagate the error code from runtime PM callbacks
    
    Atm, none of the RPM callbacks can fail, but the next patch adding
    RPM support for VLV changes this, so prepare for it.
    
    In case one of these callbacks return error RPM will get permanently
    disabled until the error is explicitly cleared. In the future we could
    add support for re-enabling it, for example after resetting the HW, but
    for now - hopefully - we can live with the simpler solution.
    
    v2:
    - propagate the error from the resume callbacks too (Paulo)
    v3:
    - fix rebase fail typo around IS_GEN6() check in intel_runtime_suspend()
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 208e185c16a9..a1ebbb02dfa9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -916,21 +916,27 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
-static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
+static int hsw_runtime_suspend(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
+
+	return 0;
 }
 
-static void snb_runtime_resume(struct drm_i915_private *dev_priv)
+static int snb_runtime_resume(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
 	intel_init_pch_refclk(dev);
+
+	return 0;
 }
 
-static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
+static int hsw_runtime_resume(struct drm_i915_private *dev_priv)
 {
 	hsw_disable_pc8(dev_priv);
+
+	return 0;
 }
 
 int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
@@ -975,6 +981,7 @@ static int intel_runtime_suspend(struct device *device)
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
 
 	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6(dev))))
 		return -ENODEV;
@@ -992,12 +999,21 @@ static int intel_runtime_suspend(struct device *device)
 	cancel_work_sync(&dev_priv->rps.work);
 	intel_runtime_pm_disable_interrupts(dev);
 
-	if (IS_GEN6(dev))
-		;
-	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
-		hsw_runtime_suspend(dev_priv);
-	else
+	if (IS_GEN6(dev)) {
+		ret = 0;
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = hsw_runtime_suspend(dev_priv);
+	} else {
+		ret = -ENODEV;
 		WARN_ON(1);
+	}
+
+	if (ret) {
+		DRM_ERROR("Runtime suspend failed, disabling it (%d)\n", ret);
+		intel_runtime_pm_restore_interrupts(dev);
+
+		return ret;
+	}
 
 	i915_gem_release_all_mmaps(dev_priv);
 
@@ -1022,6 +1038,7 @@ static int intel_runtime_resume(struct device *device)
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
 
 	WARN_ON(!HAS_RUNTIME_PM(dev));
 
@@ -1030,21 +1047,31 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	if (IS_GEN6(dev))
-		snb_runtime_resume(dev_priv);
-	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
-		hsw_runtime_resume(dev_priv);
-	else
+	if (IS_GEN6(dev)) {
+		ret = snb_runtime_resume(dev_priv);
+	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+		ret = hsw_runtime_resume(dev_priv);
+	} else {
 		WARN_ON(1);
+		ret = -ENODEV;
+	}
 
+	/*
+	 * No point of rolling back things in case of an error, as the best
+	 * we can do is to hope that things will still work (and disable RPM).
+	 */
 	i915_gem_init_swizzling(dev);
 	gen6_update_ring_freq(dev);
 
 	intel_runtime_pm_restore_interrupts(dev);
 	intel_reset_gt_powersave(dev);
 
-	DRM_DEBUG_KMS("Device resumed\n");
-	return 0;
+	if (ret)
+		DRM_ERROR("Runtime resume failed, disabling it (%d)\n", ret);
+	else
+		DRM_DEBUG_KMS("Device resumed\n");
+
+	return ret;
 }
 
 static const struct dev_pm_ops i915_pm_ops = {

commit 8d4eee9cd7a170342dc6fbc2ee19ae77031a8cd5
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:43 2014 +0300

    drm/i915: vlv: increase timeout when forcing on the GFX clock
    
    I've seen latencies up to 15msec, so increase the timeout to 20msec.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9f3e977d1877..208e185c16a9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -944,7 +944,7 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
 	/* Wait for a previous force-off to settle */
 	if (force_on) {
-		err = wait_for(!COND, 5);
+		err = wait_for(!COND, 20);
 		if (err) {
 			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",
 				  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
@@ -961,7 +961,7 @@ int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
 	if (!force_on)
 		return 0;
 
-	err = wait_for(COND, 5);
+	err = wait_for(COND, 20);
 	if (err)
 		DRM_ERROR("timeout waiting for GFX clock force-on (%08x)\n",
 			  I915_READ(VLV_GTLC_SURVIVABILITY_REG));

commit 650ad970a39f8b6164fe8613edc150f585315289
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Apr 18 16:35:02 2014 +0300

    drm/i915: vlv: factor out vlv_force_gfx_clock and check for pending force-off
    
    This will be needed by the VLV runtime PM helpers too, so factor it out.
    
    Also add a safety check for the case where the previous force-off is
    still pending, since I'm not sure if Punit can handle a new setting
    while the previous one hasn't settled yet.
    
    v2:
    - unchanged
    v3:
    - add a note to the commit message about the safety check (Ville)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e3c9c44e4bc4..9f3e977d1877 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -933,6 +933,43 @@ static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
 	hsw_disable_pc8(dev_priv);
 }
 
+int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)
+{
+	u32 val;
+	int err;
+
+	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
+	WARN_ON(!!(val & VLV_GFX_CLK_FORCE_ON_BIT) == force_on);
+
+#define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) & VLV_GFX_CLK_STATUS_BIT)
+	/* Wait for a previous force-off to settle */
+	if (force_on) {
+		err = wait_for(!COND, 5);
+		if (err) {
+			DRM_ERROR("timeout waiting for GFX clock force-off (%08x)\n",
+				  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
+			return err;
+		}
+	}
+
+	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
+	val &= ~VLV_GFX_CLK_FORCE_ON_BIT;
+	if (force_on)
+		val |= VLV_GFX_CLK_FORCE_ON_BIT;
+	I915_WRITE(VLV_GTLC_SURVIVABILITY_REG, val);
+
+	if (!force_on)
+		return 0;
+
+	err = wait_for(COND, 5);
+	if (err)
+		DRM_ERROR("timeout waiting for GFX clock force-on (%08x)\n",
+			  I915_READ(VLV_GTLC_SURVIVABILITY_REG));
+
+	return err;
+#undef COND
+}
+
 static int intel_runtime_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);

commit 9486db611ca69ea67b6f4285fbb8afeb34585571
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Apr 22 20:21:07 2014 +0300

    drm/i915: reinit GT power save during resume
    
    During runtime suspend there can be a last pending rps.work, so make
    sure it's canceled. Note that in the runtime suspend callback we can't
    get any RPS interrupts since it's called only after the GPU goes idle
    and we set the minimum RPS frequency. The next possibility for an RPS
    interrupt is only after getting an RPM ref (for example because of a new
    GPU command) and calling the RPM resume callback.
    
    v2:
    - patch introduced in v2 of the patchset
    v3:
    - Change the order of canceling the rps.work and disabling interrupts to
      avoid the race between interrupt disabling and the the rps.work. Race
      spotted by Ville.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 114598d7f52e..e3c9c44e4bc4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -947,6 +947,12 @@ static int intel_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	/*
+	 * rps.work can't be rearmed here, since we get here only after making
+	 * sure the GPU is idle and the RPS freq is set to the minimum. See
+	 * intel_mark_idle().
+	 */
+	cancel_work_sync(&dev_priv->rps.work);
 	intel_runtime_pm_disable_interrupts(dev);
 
 	if (IS_GEN6(dev))
@@ -998,6 +1004,7 @@ static int intel_runtime_resume(struct device *device)
 	gen6_update_ring_freq(dev);
 
 	intel_runtime_pm_restore_interrupts(dev);
+	intel_reset_gt_powersave(dev);
 
 	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;

commit 92b806d3684f2c7009554aaf587531a6a861af39
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:39 2014 +0300

    drm/i915: make runtime PM swizzling/ring_freq init platform independent
    
    We need to re-init sizzling on all platforms so move it to the
    platform independent runtime resume callback. The ring frequency reinit
    is also needed everywhere except on VLV, but gen6_update_ring_freq()
    will be a noop on VLV, so we can move this function too to platform
    independent code.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c26000d9bb8..114598d7f52e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -926,8 +926,6 @@ static void snb_runtime_resume(struct drm_i915_private *dev_priv)
 	struct drm_device *dev = dev_priv->dev;
 
 	intel_init_pch_refclk(dev);
-	i915_gem_init_swizzling(dev);
-	gen6_update_ring_freq(dev);
 }
 
 static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
@@ -996,6 +994,9 @@ static int intel_runtime_resume(struct device *device)
 	else
 		WARN_ON(1);
 
+	i915_gem_init_swizzling(dev);
+	gen6_update_ring_freq(dev);
+
 	intel_runtime_pm_restore_interrupts(dev);
 
 	DRM_DEBUG_KMS("Device resumed\n");

commit c2bc2fc541b60f3afc263685af0e358b6bcac5a0
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Apr 18 16:16:23 2014 +0300

    drm/i915: factor out gen6_update_ring_freq
    
    This is needed by the next patch moving the call out from platform
    specific RPM callbacks to platform independent code.
    
    No functional change.
    
    v2:
    - patch introduce in v2 of the patchset
    v3:
    - simplify platform check condition (Ville)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ff02b0cf38ce..8c26000d9bb8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -927,9 +927,7 @@ static void snb_runtime_resume(struct drm_i915_private *dev_priv)
 
 	intel_init_pch_refclk(dev);
 	i915_gem_init_swizzling(dev);
-	mutex_lock(&dev_priv->rps.hw_lock);
 	gen6_update_ring_freq(dev);
-	mutex_unlock(&dev_priv->rps.hw_lock);
 }
 
 static void hsw_runtime_resume(struct drm_i915_private *dev_priv)

commit b5478bcd5f04c3eef934f506a98c8849bb410cd9
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:37 2014 +0300

    drm/i915: make runtime PM interrupt enable/disable platform independent
    
    We need to disable the interrupts for all platforms, so make the helpers
    for this platform independent and call them from them platform
    independent runtime suspend/resume callbacks.
    
    On HSW/BDW this will move interrupt disabling/re-enabling at the
    beginning/end of runtime suspend/resume respectively, but I don't see
    any reason why this would cause a problem there. In any case this seems
    to be the correct thing to do even on those platforms.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2d4fc9161cae..ff02b0cf38ce 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -916,13 +916,6 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
-static void snb_runtime_suspend(struct drm_i915_private *dev_priv)
-{
-	struct drm_device *dev = dev_priv->dev;
-
-	intel_runtime_pm_disable_interrupts(dev);
-}
-
 static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
 {
 	hsw_enable_pc8(dev_priv);
@@ -932,7 +925,6 @@ static void snb_runtime_resume(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
 
-	intel_runtime_pm_restore_interrupts(dev);
 	intel_init_pch_refclk(dev);
 	i915_gem_init_swizzling(dev);
 	mutex_lock(&dev_priv->rps.hw_lock);
@@ -959,8 +951,10 @@ static int intel_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	intel_runtime_pm_disable_interrupts(dev);
+
 	if (IS_GEN6(dev))
-		snb_runtime_suspend(dev_priv);
+		;
 	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		hsw_runtime_suspend(dev_priv);
 	else
@@ -1004,6 +998,8 @@ static int intel_runtime_resume(struct device *device)
 	else
 		WARN_ON(1);
 
+	intel_runtime_pm_restore_interrupts(dev);
+
 	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;
 }

commit aeab0b5af7df88284d101abf8d121f0e913b81ff
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:36 2014 +0300

    drm/i915: disable runtime PM if RC6 is disabled
    
    On VLV we depend on RC6 to save the GT render and media HW context
    before going to the D3 state via RPM, so as a preparation for the
    VLV RPM support (added in an upcoming patch) disable RPM if RC6 is
    disabled.
    
    There is probably a similar dependency on other platforms too, so for
    safety require RC6 for those too. For these platforms (SNB, HSW, BDW)
    this is then a possible fix.
    
    v2:
    - require RC6 for all RPM platforms, not just for VLV (Paulo, Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b8c9896520af..2d4fc9161cae 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -951,7 +951,7 @@ static int intel_runtime_suspend(struct device *device)
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	if (WARN_ON_ONCE(!dev_priv->rps.enabled))
+	if (WARN_ON_ONCE(!(dev_priv->rps.enabled && intel_enable_rc6(dev))))
 		return -ENODEV;
 
 	WARN_ON(!HAS_RUNTIME_PM(dev));

commit c6df39b5ea6342323a42edfbeeca0a28c643d7ae
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:29 2014 +0300

    drm/i915: get a runtime PM ref for the deferred GT powersave enabling
    
    At least on VLV but probably on other platforms too we depend on RC6
    being enabled for RPM, so disable RPM until the delayed RC6 enabling
    completes.
    
    v2:
    - explain the reason for the _noresume version of RPM get (Daniel)
    - use the simpler 'if (schedule_work()) rpm_get();' instead of
      'if (!cancel_work_sync()) rpm_get(); schedule_work();'
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5cbd79e369c4..b8c9896520af 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -782,7 +782,7 @@ int i915_reset(struct drm_device *dev)
 		 * previous concerns that it doesn't respond well to some forms
 		 * of re-init after reset. */
 		if (INTEL_INFO(dev)->gen > 5)
-			intel_enable_gt_powersave(dev);
+			intel_reset_gt_powersave(dev);
 
 		intel_hpd_init(dev);
 	} else {
@@ -951,6 +951,9 @@ static int intel_runtime_suspend(struct device *device)
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	if (WARN_ON_ONCE(!dev_priv->rps.enabled))
+		return -ENODEV;
+
 	WARN_ON(!HAS_RUNTIME_PM(dev));
 	assert_force_wake_inactive(dev_priv);
 

commit dc1d0136a48d7ad858b5158413def90b9d818503
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Apr 14 20:24:28 2014 +0300

    drm/i915: move getting struct_mutex lower in the callstack during GPU reset
    
    Getting struct_mutex around the whole intel_enable_gt_powersave()
    function is not necessary, since it's only needed for the ILK path
    therein.
    
    This will make intel_enable_gt_powersave() useable on the RPM resume
    path for >=GEN6 (added in an upcoming patch to reset the RPS state
    during RPM resume), where we can't (and need not) get this mutex.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 743cddec9a18..5cbd79e369c4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -781,11 +781,8 @@ int i915_reset(struct drm_device *dev)
 		 * reset and the re-install of drm irq. Skip for ironlake per
 		 * previous concerns that it doesn't respond well to some forms
 		 * of re-init after reset. */
-		if (INTEL_INFO(dev)->gen > 5) {
-			mutex_lock(&dev->struct_mutex);
+		if (INTEL_INFO(dev)->gen > 5)
 			intel_enable_gt_powersave(dev);
-			mutex_unlock(&dev->struct_mutex);
-		}
 
 		intel_hpd_init(dev);
 	} else {

commit 845f74a701541662bf7d4880a0f4d492b28f2d18
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Thu Apr 17 10:37:37 2014 +0800

    drm/i915:Initialize the second BSD ring on BDW GT3 machine
    
    Based on the hardware spec, the BDW GT3 machine has two independent
    BSD ring that can be used to dispatch the video commands.
    So just initialize it.
    
    V3->V4: Follow Imre's comment to do some minor updates. For example:
    more comments are added to describe the semaphore between ring.
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    [danvet: Fix up checkpatch error.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9f47aab7915f..743cddec9a18 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -282,7 +282,7 @@ static const struct intel_device_info intel_broadwell_m_info = {
 static const struct intel_device_info intel_broadwell_gt3d_info = {
 	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
 	.has_fbc = 1,
@@ -292,7 +292,7 @@ static const struct intel_device_info intel_broadwell_gt3d_info = {
 static const struct intel_device_info intel_broadwell_gt3m_info = {
 	.gen = 8, .is_mobile = 1, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
-	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING | BSD2_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
 	.has_fbc = 1,

commit fd3c269f8ff940cc0fbb3b7f7e84c0572f6f759a
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Thu Apr 17 10:37:35 2014 +0800

    drm/i915: Split the BDW device definition to prepare for dual BSD rings on BDW GT3
    
    Based on the hardware spec, the BDW GT3 has the different configuration
    with the BDW GT1/GT2. So split the BDW device info definition.
    This is to do the preparation for adding the Dual BSD rings on BDW GT3 machine.
    
    V1->V2: Follow Daniel's comment to pay attention to the stolen check for BDW
    in kernel/early-quirks.c
    
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f2ca3e929cd7..9f47aab7915f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -279,6 +279,26 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	GEN_DEFAULT_PIPEOFFSETS,
 };
 
+static const struct intel_device_info intel_broadwell_gt3d_info = {
+	.gen = 8, .num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	.has_fbc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+};
+
+static const struct intel_device_info intel_broadwell_gt3m_info = {
+	.gen = 8, .is_mobile = 1, .num_pipes = 3,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+	.has_fbc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -311,8 +331,10 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	INTEL_HSW_M_IDS(&intel_haswell_m_info), \
 	INTEL_VLV_M_IDS(&intel_valleyview_m_info),	\
 	INTEL_VLV_D_IDS(&intel_valleyview_d_info),	\
-	INTEL_BDW_M_IDS(&intel_broadwell_m_info),	\
-	INTEL_BDW_D_IDS(&intel_broadwell_d_info)
+	INTEL_BDW_GT12M_IDS(&intel_broadwell_m_info),	\
+	INTEL_BDW_GT12D_IDS(&intel_broadwell_d_info),	\
+	INTEL_BDW_GT3M_IDS(&intel_broadwell_gt3m_info),	\
+	INTEL_BDW_GT3D_IDS(&intel_broadwell_gt3d_info)
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit 074c6adaf4e7d1423d373bd5d1afc20b683cb4d0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 9 09:19:43 2014 +0100

    drm/i915: Mark device as wedged if we fail to resume
    
    During module load, if we fail to initialise the rings, we abort the
    load reporting EIO. However during resume, even though we report EIO as
    we fail to reinitialize the ringbuffers, the resume continues and the
    device is restored - albeit in a non-functional state. As we cannot
    execute any commands on the GPU, it is effectively wedged, mark it so.
    
    As we now preserve the ringbuffers across resume, this should prevent
    UXA from falling into the trap of repeatedly sending invalid
    batchbuffers and dropping all further rendering into /dev/null.
    
    Reported-and-tested-by: Jiri Kosina <jkosina@suse.cz>
    References: https://bugs.freedesktop.org/show_bug.cgi?id=76554
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Oscar Mateo <oscar.mateo@intel.com>
    [danvet: Drop unused error, spotted by Oscar.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 254b3236200b..f2ca3e929cd7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -551,7 +551,6 @@ static int i915_drm_thaw_early(struct drm_device *dev)
 static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int error = 0;
 
 	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
 	    restore_gtt_mappings) {
@@ -569,8 +568,10 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		drm_mode_config_reset(dev);
 
 		mutex_lock(&dev->struct_mutex);
-
-		error = i915_gem_init_hw(dev);
+		if (i915_gem_init_hw(dev)) {
+			DRM_ERROR("failed to re-initialize GPU, declaring wedged!\n");
+			atomic_set_mask(I915_WEDGED, &dev_priv->gpu_error.reset_counter);
+		}
 		mutex_unlock(&dev->struct_mutex);
 
 		/* We need working interrupts for modeset enabling ... */
@@ -613,7 +614,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 	mutex_unlock(&dev_priv->modeset_restore_lock);
 
 	intel_runtime_pm_put(dev_priv);
-	return error;
+	return 0;
 }
 
 static int i915_drm_thaw(struct drm_device *dev)

commit 444c9a08bf787e8236e132fab7eceeb2f065aa4c
Merge: 7e9ab4081e64 3c8413951cbd
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 1 09:32:21 2014 +1000

    Merge branch 'drm-init-cleanup' of git://people.freedesktop.org/~danvet/drm into drm-next
    
    Next pull request, this time more of the drm de-midlayering work. The big
    thing is that his patch series here removes everything from drm_bus except
    the set_busid callback. Thierry has a few more patches on top of this to
    make that one optional to.
    
    With that we can ditch all the non-pci drm_bus implementations, which
    Thierry has already done for the fake tegra host1x drm_bus.
    
    Reviewed by Thierry, Laurent and David and now also survived some testing
    on my intel boxes to make sure the irq fumble is fixed correctly ;-) The
    last minute rebase was just to add the r-b tags from Thierry for the 2
    patches I've redone.
    
    * 'drm-init-cleanup' of git://people.freedesktop.org/~danvet/drm:
      drm/<drivers>: don't set driver->dev_priv_size to 0
      drm: Remove dev->kdriver
      drm: remove drm_bus->get_name
      drm: rip out dev->devname
      drm: inline drm_pci_set_unique
      drm: remove bus->get_irq implementations
      drm: pass the irq explicitly to drm_irq_install
      drm/irq: Look up the pci irq directly in the drm_control ioctl
      drm/irq: track the irq installed in drm_irq_install in dev->irq
      drm: rename dev->count_lock to dev->buf_lock
      drm: Rip out totally bogus vga_switcheroo->can_switch locking
      drm: kill drm_bus->bus_type
      drm: remove drm_dev_to_irq from drivers
      drm/irq: remove cargo-culted locking from irq_install/uninstall
      drm/irq: drm_control is a legacy ioctl, so pci devices only
      drm/pci: fold in irq_by_busid support
      drm/irq: simplify irq checks in drm_wait_vblank

commit bb0f1b5c1695b4399cfd2359c114ae63edbb3ad8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Nov 3 21:09:27 2013 +0100

    drm: pass the irq explicitly to drm_irq_install
    
    Unfortunately this requires a drm-wide change, and I didn't see a sane
    way around that. Luckily it's fairly simple, we just need to inline
    the respective get_irq implementation from either drm_pci.c or
    drm_platform.c.
    
    With that we can now also remove drm_dev_to_irq from drm_irq.c.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 87ce105910f2..6124b491a19e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -574,7 +574,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 
 		/* We need working interrupts for modeset enabling ... */
-		drm_irq_install(dev);
+		drm_irq_install(dev, dev->pdev->irq);
 
 		intel_modeset_init_hw(dev);
 
@@ -752,7 +752,7 @@ int i915_reset(struct drm_device *dev)
 		 * being false when they shouldn't be able to.
 		 */
 		drm_irq_uninstall(dev);
-		drm_irq_install(dev);
+		drm_irq_install(dev, dev->pdev->irq);
 
 		/* rps/rc6 re-init is necessary to restore state lost after the
 		 * reset and the re-install of drm irq. Skip for ironlake per

commit e090c53b21e97864a25ada5c8437d9776978a050
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Nov 3 20:27:05 2013 +0100

    drm/irq: remove cargo-culted locking from irq_install/uninstall
    
    The dev->struct_mutex locking in drm_irq.c only protects
    dev->irq_enabled. Which isn't really much at all and only prevents
    especially nasty ums userspace from concurrently installing the
    interrupt handling a few times. Or at least trying.
    
    There are tons of unlocked readers of dev->irqs_enabled in the vblank
    wait code (and by extension also in the pageflip code since that uses
    the same vblank timestamp engine).
    
    Real modesetting drivers should ensure that nothing can go haywire
    with a sane setup teardown sequence. So we only really need this for
    the drm_control ioctl, everywhere else this will just paper over
    nastiness.
    
    Note that drm/i915 is a bit specially due to the gem+ums combination.
    So there we also need to properly protect the entervt and leavevt
    ioctls. But it's definitely saner to do everything in one go than to
    drop the lock in-between.
    
    Finally there's the gpu reset code in drm/i915. That one's just race
    (concurrent userspace calls to for vblank waits of pageflips could
    spuriously fail). So wrap it up in with a nice comment since fixing
    this is more involved.
    
    v2: Rebase and fix commit message (Thierry)
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82f4d1f47d3b..87ce105910f2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -746,6 +746,11 @@ int i915_reset(struct drm_device *dev)
 			return ret;
 		}
 
+		/*
+		 * FIXME: This is horribly race against concurrent pageflip and
+		 * vblank wait ioctls since they can observe dev->irqs_disabled
+		 * being false when they shouldn't be able to.
+		 */
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);
 

commit 8cbf3202098f191f8b0a0606b2df0af047f21fe5
Merge: 04feced98a43 c39b06951f1d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 9 14:33:47 2014 +0200

    Merge remote-tracking branch 'airlied/drm-next' into HEAD
    
    Backmerge drm-next after the big s/crtc->fb/crtc->primary->fb/
    cocinelle patch to avoid endless amounts of conflict hilarity in my
    -next queue for 3.16.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 76c4b250080fff6e4befaa3619942422fd0ea380
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Apr 1 19:55:22 2014 +0300

    drm/i915: move power domain init earlier during system resume
    
    During resume the intel hda audio driver depends on the i915 driver
    reinitializing the audio power domain. Since the order of calling the
    i915 resume handler wrt. that of the audio driver is not guaranteed,
    move the power domain reinitialization step to the resume_early
    handler. This is guaranteed to run before the resume handler of any
    other driver.
    
    The power domain initialization in turn requires us to enable the i915
    pci device first, so move that part earlier too.
    
    Accordingly disabling of the i915 pci device should happen after the
    audio suspend handler ran. So move the disabling later from the i915
    resume handler to the resume_late handler.
    
    v2:
    - move intel_uncore_sanitize/early_sanitize earlier too, so they don't
      get reordered wrt. intel_power_domains_init_hw()
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=76152
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Cc: stable@vger.kernel.org
    [danvet: Add cc: stable and loud comments that this is just a hack.]
    [danvet: Fix "Should it be static?" sparse warning reported by Wu
    Fengguang's kbuilder.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 11f77a8e4c4d..82f4d1f47d3b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -537,14 +537,21 @@ static void intel_resume_hotplug(struct drm_device *dev)
 	drm_helper_hpd_irq_event(dev);
 }
 
-static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
+static int i915_drm_thaw_early(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int error = 0;
 
 	intel_uncore_early_sanitize(dev);
-
 	intel_uncore_sanitize(dev);
+	intel_power_domains_init_hw(dev_priv);
+
+	return 0;
+}
+
+static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int error = 0;
 
 	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
 	    restore_gtt_mappings) {
@@ -553,8 +560,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 	}
 
-	intel_power_domains_init_hw(dev_priv);
-
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
@@ -619,19 +624,33 @@ static int i915_drm_thaw(struct drm_device *dev)
 	return __i915_drm_thaw(dev, true);
 }
 
-int i915_resume(struct drm_device *dev)
+static int i915_resume_early(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret;
-
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
+	/*
+	 * We have a resume ordering issue with the snd-hda driver also
+	 * requiring our device to be power up. Due to the lack of a
+	 * parent/child relationship we currently solve this with an early
+	 * resume hook.
+	 *
+	 * FIXME: This should be solved with a special hdmi sink device or
+	 * similar so that power domains can be employed.
+	 */
 	if (pci_enable_device(dev->pdev))
 		return -EIO;
 
 	pci_set_master(dev->pdev);
 
+	return i915_drm_thaw_early(dev);
+}
+
+int i915_resume(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
+
 	/*
 	 * Platforms with opregion should have sane BIOS, older ones (gen3 and
 	 * earlier) need to restore the GTT mappings since the BIOS might clear
@@ -645,6 +664,14 @@ int i915_resume(struct drm_device *dev)
 	return 0;
 }
 
+static int i915_resume_legacy(struct drm_device *dev)
+{
+	i915_resume_early(dev);
+	i915_resume(dev);
+
+	return 0;
+}
+
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -776,7 +803,6 @@ static int i915_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-	int error;
 
 	if (!drm_dev || !drm_dev->dev_private) {
 		dev_err(dev, "DRM not initialized, aborting suspend.\n");
@@ -786,9 +812,25 @@ static int i915_pm_suspend(struct device *dev)
 	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
-	error = i915_drm_freeze(drm_dev);
-	if (error)
-		return error;
+	return i915_drm_freeze(drm_dev);
+}
+
+static int i915_pm_suspend_late(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	/*
+	 * We have a suspedn ordering issue with the snd-hda driver also
+	 * requiring our device to be power up. Due to the lack of a
+	 * parent/child relationship we currently solve this with an late
+	 * suspend hook.
+	 *
+	 * FIXME: This should be solved with a special hdmi sink device or
+	 * similar so that power domains can be employed.
+	 */
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
 
 	pci_disable_device(pdev);
 	pci_set_power_state(pdev, PCI_D3hot);
@@ -796,6 +838,14 @@ static int i915_pm_suspend(struct device *dev)
 	return 0;
 }
 
+static int i915_pm_resume_early(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	return i915_resume_early(drm_dev);
+}
+
 static int i915_pm_resume(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -817,6 +867,14 @@ static int i915_pm_freeze(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
+static int i915_pm_thaw_early(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	return i915_drm_thaw_early(drm_dev);
+}
+
 static int i915_pm_thaw(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -887,10 +945,14 @@ static int i915_runtime_resume(struct device *device)
 
 static const struct dev_pm_ops i915_pm_ops = {
 	.suspend = i915_pm_suspend,
+	.suspend_late = i915_pm_suspend_late,
+	.resume_early = i915_pm_resume_early,
 	.resume = i915_pm_resume,
 	.freeze = i915_pm_freeze,
+	.thaw_early = i915_pm_thaw_early,
 	.thaw = i915_pm_thaw,
 	.poweroff = i915_pm_poweroff,
+	.restore_early = i915_pm_resume_early,
 	.restore = i915_pm_resume,
 	.runtime_suspend = i915_runtime_suspend,
 	.runtime_resume = i915_runtime_resume,
@@ -933,7 +995,7 @@ static struct drm_driver driver = {
 
 	/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
 	.suspend = i915_suspend,
-	.resume = i915_resume,
+	.resume = i915_resume_legacy,
 
 	.device_is_agp = i915_driver_device_is_agp,
 	.master_create = i915_master_create,

commit 6157d3c83ac1a1815192464c540283e1bb2a321c
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:12:37 2014 -0300

    drm/i915: add BDW runtime PM support
    
    This sould be enough.
    
    v2: BDW should also run hsw_runtime_resume (Ben).
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4b6c99dfe678..a01faea0401c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -875,8 +875,10 @@ static int intel_runtime_suspend(struct device *device)
 
 	if (IS_GEN6(dev))
 		snb_runtime_suspend(dev_priv);
-	else if (IS_HASWELL(dev))
+	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		hsw_runtime_suspend(dev_priv);
+	else
+		WARN_ON(1);
 
 	i915_gem_release_all_mmaps(dev_priv);
 
@@ -911,8 +913,10 @@ static int intel_runtime_resume(struct device *device)
 
 	if (IS_GEN6(dev))
 		snb_runtime_resume(dev_priv);
-	else if (IS_HASWELL(dev))
+	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		hsw_runtime_resume(dev_priv);
+	else
+		WARN_ON(1);
 
 	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;

commit 414de7a02025b2ff4f972cf3240d0471ebd36692
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:12:35 2014 -0300

    drm/i915: remove HAS_PC8 check
    
    Now that PC8 is part of runtime PM, the check is useless.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1c53fd378785..4b6c99dfe678 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -842,10 +842,7 @@ static void snb_runtime_suspend(struct drm_i915_private *dev_priv)
 
 static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
-
-	if (HAS_PC8(dev))
-		hsw_enable_pc8(dev_priv);
+	hsw_enable_pc8(dev_priv);
 }
 
 static void snb_runtime_resume(struct drm_i915_private *dev_priv)
@@ -862,10 +859,7 @@ static void snb_runtime_resume(struct drm_i915_private *dev_priv)
 
 static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
 {
-	struct drm_device *dev = dev_priv->dev;
-
-	if (HAS_PC8(dev))
-		hsw_disable_pc8(dev_priv);
+	hsw_disable_pc8(dev_priv);
 }
 
 static int intel_runtime_suspend(struct device *device)

commit 9a952a0d42ff089945ea3f5b3f690e45218d073f
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:12:34 2014 -0300

    drm/i915: add SNB runtime PM support
    
    Just because I have a SNB machine and I can easily test it.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b3600cbb81cf..1c53fd378785 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -833,6 +833,13 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
+static void snb_runtime_suspend(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	intel_runtime_pm_disable_interrupts(dev);
+}
+
 static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
@@ -841,6 +848,18 @@ static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
 		hsw_enable_pc8(dev_priv);
 }
 
+static void snb_runtime_resume(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	intel_runtime_pm_restore_interrupts(dev);
+	intel_init_pch_refclk(dev);
+	i915_gem_init_swizzling(dev);
+	mutex_lock(&dev_priv->rps.hw_lock);
+	gen6_update_ring_freq(dev);
+	mutex_unlock(&dev_priv->rps.hw_lock);
+}
+
 static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv->dev;
@@ -860,7 +879,9 @@ static int intel_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
-	if (IS_HASWELL(dev))
+	if (IS_GEN6(dev))
+		snb_runtime_suspend(dev_priv);
+	else if (IS_HASWELL(dev))
 		hsw_runtime_suspend(dev_priv);
 
 	i915_gem_release_all_mmaps(dev_priv);
@@ -894,7 +915,9 @@ static int intel_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	if (IS_HASWELL(dev))
+	if (IS_GEN6(dev))
+		snb_runtime_resume(dev_priv);
+	else if (IS_HASWELL(dev))
 		hsw_runtime_resume(dev_priv);
 
 	DRM_DEBUG_KMS("Device resumed\n");

commit 97bea20794f600ae9248bef296e3b62d12087a1e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:12:33 2014 -0300

    drm/i915: add gen-specific runtime suspend/resume functions
    
    We're adding runtime suspend support to more platforms, so organize
    the code in a way that all a new platform needs to do is to add its
    own gen-specific functions. Also rename the i915_ functions to intel_
    to make it clear that it's the top level one, not something that just
    runs on i915 platforms.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 11f77a8e4c4d..b3600cbb81cf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -833,7 +833,23 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
-static int i915_runtime_suspend(struct device *device)
+static void hsw_runtime_suspend(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	if (HAS_PC8(dev))
+		hsw_enable_pc8(dev_priv);
+}
+
+static void hsw_runtime_resume(struct drm_i915_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	if (HAS_PC8(dev))
+		hsw_disable_pc8(dev_priv);
+}
+
+static int intel_runtime_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
@@ -844,8 +860,8 @@ static int i915_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
-	if (HAS_PC8(dev))
-		hsw_enable_pc8(dev_priv);
+	if (IS_HASWELL(dev))
+		hsw_runtime_suspend(dev_priv);
 
 	i915_gem_release_all_mmaps(dev_priv);
 
@@ -865,7 +881,7 @@ static int i915_runtime_suspend(struct device *device)
 	return 0;
 }
 
-static int i915_runtime_resume(struct device *device)
+static int intel_runtime_resume(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
 	struct drm_device *dev = pci_get_drvdata(pdev);
@@ -878,8 +894,8 @@ static int i915_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
-	if (HAS_PC8(dev))
-		hsw_disable_pc8(dev_priv);
+	if (IS_HASWELL(dev))
+		hsw_runtime_resume(dev_priv);
 
 	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;
@@ -892,8 +908,8 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.thaw = i915_pm_thaw,
 	.poweroff = i915_pm_poweroff,
 	.restore = i915_pm_resume,
-	.runtime_suspend = i915_runtime_suspend,
-	.runtime_resume = i915_runtime_resume,
+	.runtime_suspend = intel_runtime_suspend,
+	.runtime_resume = intel_runtime_resume,
 };
 
 static const struct vm_operations_struct i915_gem_vm_ops = {

commit 50227e1cae118562b8b6230e31bca84870cad27e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Mar 31 14:27:21 2014 +0300

    drm/i915: prefer struct drm_i915_private to drm_i915_private_t
    
    Remove the rest of the references to drm_i915_private_t. No functional
    changes.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    [danvet: Drop hunk in i915_cmd_parser.c]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fa5d0ed76378..11f77a8e4c4d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -662,7 +662,7 @@ int i915_resume(struct drm_device *dev)
  */
 int i915_reset(struct drm_device *dev)
 {
-	drm_i915_private_t *dev_priv = dev->dev_private;
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	bool simulated;
 	int ret;
 

commit a14cb6fc851d09bdb2c95f26d81842d5b4fa7164
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:08:17 2014 -0300

    drm/i915: rename __hsw_do_{en, dis}able_pc8
    
    After we removed all the intermediate abstractions, we can rename
    these functions to just hsw_{en,dis}able_pc8.
    
    v2: - Rebase.
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9aa01bfcd068..fa5d0ed76378 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -845,7 +845,7 @@ static int i915_runtime_suspend(struct device *device)
 	DRM_DEBUG_KMS("Suspending device\n");
 
 	if (HAS_PC8(dev))
-		__hsw_do_enable_pc8(dev_priv);
+		hsw_enable_pc8(dev_priv);
 
 	i915_gem_release_all_mmaps(dev_priv);
 
@@ -879,7 +879,7 @@ static int i915_runtime_resume(struct device *device)
 	dev_priv->pm.suspended = false;
 
 	if (HAS_PC8(dev))
-		__hsw_do_disable_pc8(dev_priv);
+		hsw_disable_pc8(dev_priv);
 
 	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;

commit db8384f2e07bfa8cc607914dfa0b3cee81f59839
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:08:11 2014 -0300

    drm/i915: don't get/put PC8 reference on freeze/thaw
    
    We already get runtime PM references, and PC8 is now part of runtime
    PM, so this is enough.
    
    v2: - Rebase.
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3526f8e57914..9aa01bfcd068 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -428,7 +428,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
-	hsw_disable_package_c8(dev_priv);
 	intel_display_set_init_power(dev_priv, true);
 
 	drm_kms_helper_poll_disable(dev);
@@ -604,10 +603,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		schedule_work(&dev_priv->console_resume_work);
 	}
 
-	/* Undo what we did at i915_drm_freeze so the refcount goes back to the
-	 * expected level. */
-	hsw_enable_package_c8(dev_priv);
-
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_DONE;
 	mutex_unlock(&dev_priv->modeset_restore_lock);

commit a8a8bd547e6323c56295e1c5a03e30e765d42325
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 7 20:08:05 2014 -0300

    drm/i915: make PC8 be part of runtime PM suspend/resume
    
    Currently, when our driver becomes idle for i915.pc8_timeout (default:
    5s) we enable PC8, so we save some power, but not everything we can.
    Then, while PC8 is enabled, if we stay idle for more
    autosuspend_delay_ms (default: 10s) we'll enter runtime PM and put the
    graphics device in D3 state, saving even more power. The two features
    are separate things with increasing levels of power savings, but if we
    disable PC8 we'll never get into D3.
    
    While from the modularity point of view it would be nice to keep these
    features as separate, we have reasons to merge them:
     - We are not aware of anybody wanting a "PC8 without D3" environment.
     - If we keep both features as separate, we'll have to to test both
       PC8 and PC8+D3 code paths. We're already having a major pain to
       make QA do automated testing of just one thing, testing both paths
       will cost even more.
     - Only Haswell+ supports PC8, so if we want to add runtime PM support
       to, for example, IVB, we'll have to copy some code from the PC8
       feature to runtime PM, so merging both features as a single thing
       will make it easier for enabling runtime PM on other platforms.
    
    This patch only does the very basic steps required to have PC8 and
    runtime PM merged on a single feature: the next patches will take care
    of cleaning up everything.
    
    v2: - Rebase.
    v3: - Rebase.
        - Fully remove the deprecated i915 params since Daniel doesn't
          consider them as part of the ABI.
    v4: - Rebase.
        - Fix typo in the commit message.
    v5: - Rebase, again.
        - Add a huge comment explaining the different forcewake usage
          (Chris, Daniel).
        - Use open-coded forcewake functions (Daniel).
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5a0d34c47885..3526f8e57914 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -849,6 +849,9 @@ static int i915_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	if (HAS_PC8(dev))
+		__hsw_do_enable_pc8(dev_priv);
+
 	i915_gem_release_all_mmaps(dev_priv);
 
 	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
@@ -863,6 +866,7 @@ static int i915_runtime_suspend(struct device *device)
 	 */
 	intel_opregion_notify_adapter(dev, PCI_D1);
 
+	DRM_DEBUG_KMS("Device suspended\n");
 	return 0;
 }
 
@@ -879,6 +883,10 @@ static int i915_runtime_resume(struct device *device)
 	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
+	if (HAS_PC8(dev))
+		__hsw_do_disable_pc8(dev_priv);
+
+	DRM_DEBUG_KMS("Device resumed\n");
 	return 0;
 }
 

commit 28d85cd367a3f5b4d891ebe9aaaa88a5c73a3a96
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 13 11:05:02 2014 +0000

    drm/i915: Reset forcewake before suspend
    
    Now that we regularly defer the forcewake dance to a timer func, it is
    likely to fire after we disable the device during suspend. This
    generates an oops as we detect inconsistency in the hardware state. So
    before suspend, we want to complete the outstanding dance and generally
    sanitize the registers before handing back to the BIOS.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 658fe24961eb..5a0d34c47885 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -467,6 +467,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	i915_save_state(dev);
 
 	intel_opregion_fini(dev);
+	intel_uncore_fini(dev);
 
 	console_lock();
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED);

commit e8e6e6012d68c4967e8f26fdd39ac95c247d4789
Merge: bc079e8b1684 fa389e220254
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 10 21:43:46 2014 +0100

    Merge tag 'v3.14-rc6' into drm-intel-next-queued
    
    Linux 3.14-rc6
    
    I need the hdmi/dvi-dual link fixes in 3.14 to avoid ugly conflicts
    when merging Ville's new hdmi cloning support into my -next tree
    
    Conflicts:
            drivers/gpu/drm/i915/Makefile
            drivers/gpu/drm/i915/intel_dp.c
    
    Makefile cleanup conflicts with an acpi build fix, intel_dp.c is
    trivial.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit c923facd535b97972b5bb7d3df4fcafd61a63a5e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Mar 5 14:17:28 2014 +0200

    drm/i915: don't flood the logs about bdw semaphores
    
    BDW is no longer flagged as preliminary hw, but without
    i915.preliminary_hw_support module param set the logs are filled with
    WARNs about it.
    
    Just make semaphores off the BDW per-chip default for now.
    
    CC: Ben Widawsky <ben@bwidawsk.net>
    Reported-by: Sebastien Dufour <sebastien.dufour@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a50292c0423f..6ac91fcdb4f8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -403,15 +403,13 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (INTEL_INFO(dev)->gen < 6)
 		return false;
 
-	/* Until we get further testing... */
-	if (IS_GEN8(dev)) {
-		WARN_ON(!i915.preliminary_hw_support);
-		return false;
-	}
-
 	if (i915.semaphores >= 0)
 		return i915.semaphores;
 
+	/* Until we get further testing... */
+	if (IS_GEN8(dev))
+		return false;
+
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
 	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)

commit 62d5d69b49b6fea9905e36e67cc6c4fc5a17d75f
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Tue Feb 25 17:11:28 2014 +0200

    drm/i915: Add suspend count to error state
    
    For example if we get bug reports with similar error states and
    suspend count is always 1, that might lead the Sherlocks to
    right general direction.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 70a4c9bb7b80..a50292c0423f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -479,6 +479,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED);
 	console_unlock();
 
+	dev_priv->suspend_count++;
+
 	return 0;
 }
 

commit e998c40fed02c258404d11dcf66409c390e3ef9a
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Feb 21 13:52:26 2014 -0300

    drm/i915: assert force wake is disabled when we runtime suspend
    
    Just to be sure...
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 17c4466087a4..70a4c9bb7b80 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -849,6 +849,7 @@ static int i915_runtime_suspend(struct device *device)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	WARN_ON(!HAS_RUNTIME_PM(dev));
+	assert_force_wake_inactive(dev_priv);
 
 	DRM_DEBUG_KMS("Suspending device\n");
 

commit 8f94d24b7b3191fc8a6cf16c9d815410f5e09ae3
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Thu Feb 20 16:01:20 2014 -0800

    drm/i915/bdw: Add FBC support
    
    This got lost when we shuffled around our internal branch and
    GEN7_FEATURES macro. There were no HW changes to support FBC, so we just
    need to set the flag.
    
    v2: Don't allow FBC for any pipe but A on platforms with DDI. (Paulo)
    
    Cc: Daisy Sun <daisy.sun@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c4abe877fe33..17c4466087a4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -265,6 +265,7 @@ static const struct intel_device_info intel_broadwell_d_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 };
 
@@ -274,6 +275,7 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	.has_fbc = 1,
 	GEN_DEFAULT_PIPEOFFSETS,
 };
 

commit da7e29bd5b6dfab9b64eeffa7816fdcf00048d14
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Feb 18 00:02:02 2014 +0200

    drm/i915: use drm_i915_private everywhere in the power domain api
    
    The power domains framework is internal to the i915 driver, so pass
    drm_i915_private instead of drm_device to its functions.
    
    Also remove a dangling intel_set_power_well() declaration.
    
    No functional change.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2d05d7ce4c29..c4abe877fe33 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -434,7 +434,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
 	hsw_disable_package_c8(dev_priv);
-	intel_display_set_init_power(dev, true);
+	intel_display_set_init_power(dev_priv, true);
 
 	drm_kms_helper_poll_disable(dev);
 
@@ -556,7 +556,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 	}
 
-	intel_power_domains_init_hw(dev);
+	intel_power_domains_init_hw(dev_priv);
 
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);

commit bcdb72ac7c00d2b56359fc82bcc8fe50454717d5
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Feb 14 20:23:54 2014 +0200

    drm/i915: fix pch pci device enumeration
    
    pci_get_class(class, from) drops the refcount for 'from', so the
    extra pci_dev_put we do on it will result in a use after free bug
    starting with the WARN below.
    
    Regression introduced in
    
    commit 6a9c4b35e6696a63805b6da5e4889c6986e9ee1b
    Author: Rui Guo <firemeteor@users.sourceforge.net>
    Date:   Wed Jun 19 21:10:23 2013 +0800
    
        drm/i915: Fix PCH detect with multiple ISA bridges in VM
    
    [  164.338460] WARNING: CPU: 1 PID: 2094 at include/linux/kref.h:47 klist_next+0xae/0x110()
    [  164.347731] CPU: 1 PID: 2094 Comm: modprobe Tainted: G           O 3.13.0-imre+ #354
    [  164.356468] Hardware name: Intel Corp. VALLEYVIEW B0 PLATFORM/NOTEBOOK, BIOS BYTICRB1.X64.0062.R70.1310112051 10/11/2013
    [  164.368796] Call Trace:
    [  164.371609]  [<ffffffff816a32a6>] dump_stack+0x4e/0x7a
    [  164.377447]  [<ffffffff8104f75d>] warn_slowpath_common+0x7d/0xa0
    [  164.384238]  [<ffffffff8104f83a>] warn_slowpath_null+0x1a/0x20
    [  164.390851]  [<ffffffff8169aeae>] klist_next+0xae/0x110
    [  164.396777]  [<ffffffff8130a110>] ? pci_do_find_bus+0x70/0x70
    [  164.403286]  [<ffffffff813cb4a9>] bus_find_device+0x89/0xc0
    [  164.409719]  [<ffffffff8130a373>] pci_get_dev_by_id+0x63/0xa0
    [  164.416238]  [<ffffffff8130a4e4>] pci_get_class+0x44/0x50
    [  164.422433]  [<ffffffffa034821f>] intel_dsm_detect+0x16f/0x1f0 [i915]
    [  164.429801]  [<ffffffffa03482ae>] intel_register_dsm_handler+0xe/0x10 [i915]
    [  164.437831]  [<ffffffffa02d30fe>] i915_driver_load+0xafe/0xf30 [i915]
    [  164.445126]  [<ffffffff8158a150>] ? intel_alloc_coherent+0x110/0x110
    [  164.452340]  [<ffffffffa0148c07>] drm_dev_register+0xc7/0x150 [drm]
    [  164.459462]  [<ffffffffa014b23f>] drm_get_pci_dev+0x11f/0x1f0 [drm]
    [  164.466554]  [<ffffffff816abb81>] ? _raw_spin_unlock_irqrestore+0x51/0x70
    [  164.474287]  [<ffffffffa02cf7a6>] i915_pci_probe+0x56/0x60 [i915]
    [  164.481185]  [<ffffffff8130a028>] pci_device_probe+0x78/0xf0
    [  164.487603]  [<ffffffff813cd495>] driver_probe_device+0x155/0x350
    [  164.494505]  [<ffffffff813cd74e>] __driver_attach+0x6e/0xa0
    [  164.500826]  [<ffffffff813cd6e0>] ? __device_attach+0x50/0x50
    [  164.507333]  [<ffffffff813cb2be>] bus_for_each_dev+0x6e/0xc0
    [  164.513752]  [<ffffffff813ccefe>] driver_attach+0x1e/0x20
    [  164.519870]  [<ffffffff813cc958>] bus_add_driver+0x138/0x260
    [  164.526289]  [<ffffffffa0188000>] ? 0xffffffffa0187fff
    [  164.532116]  [<ffffffff813cde78>] driver_register+0x98/0xe0
    [  164.538558]  [<ffffffffa0188000>] ? 0xffffffffa0187fff
    [  164.544389]  [<ffffffff813087b0>] __pci_register_driver+0x60/0x70
    [  164.551336]  [<ffffffffa014b37d>] drm_pci_init+0x6d/0x120 [drm]
    [  164.558040]  [<ffffffffa0188000>] ? 0xffffffffa0187fff
    [  164.563928]  [<ffffffffa018806a>] i915_init+0x6a/0x6c [i915]
    [  164.570363]  [<ffffffff810002da>] do_one_initcall+0xaa/0x160
    [  164.576783]  [<ffffffff8103b140>] ? set_memory_nx+0x40/0x50
    [  164.583100]  [<ffffffff810ce7f5>] load_module+0x1fb5/0x2550
    [  164.589410]  [<ffffffff810caab0>] ? store_uevent+0x40/0x40
    [  164.595628]  [<ffffffff810cee7d>] SyS_init_module+0xed/0x100
    [  164.602048]  [<ffffffff816b3c52>] system_call_fastpath+0x16/0x1b
    
    v2: simplify the loop further (Chris)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reported-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=65652
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=74161
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 04f1f02c4019..ec7bb0fc71bc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -403,7 +403,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 void intel_detect_pch(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct pci_dev *pch;
+	struct pci_dev *pch = NULL;
 
 	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
 	 * (which really amounts to a PCH but no South Display).
@@ -424,12 +424,9 @@ void intel_detect_pch(struct drm_device *dev)
 	 * all the ISA bridge devices and check for the first match, instead
 	 * of only checking the first one.
 	 */
-	pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL);
-	while (pch) {
-		struct pci_dev *curr = pch;
+	while ((pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, pch))) {
 		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
-			unsigned short id;
-			id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+			unsigned short id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
 			dev_priv->pch_id = id;
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
@@ -461,18 +458,16 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
-			} else {
-				goto check_next;
-			}
-			pci_dev_put(pch);
+			} else
+				continue;
+
 			break;
 		}
-check_next:
-		pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, curr);
-		pci_dev_put(curr);
 	}
 	if (!pch)
-		DRM_DEBUG_KMS("No PCH found?\n");
+		DRM_DEBUG_KMS("No PCH found.\n");
+
+	pci_dev_put(pch);
 }
 
 bool i915_semaphore_is_enabled(struct drm_device *dev)

commit dd0a1aa19bd3d7203e58157b84cea78bbac605ac
Author: Jeff McGee <jeff.mcgee@intel.com>
Date:   Tue Feb 4 11:32:31 2014 -0600

    drm/i915: Restore rps/rc6 on reset
    
    A check of rps/rc6 state after i915_reset determined that the ring
    MAX_IDLE registers were returned to their hardware defaults and that
    the GEN6_PMIMR register was set to mask all interrupts. This change
    restores those values to their pre-reset states by re-initializing
    rps/rc6 in i915_reset. A full re-initialization was opted for versus
    a targeted set of restore operations for simplicity and maintain-
    ability. Note that the re-initialization is not done for Ironlake,
    due to a past comment that it causes problems.
    
    Also updated the rps initialization sequence to preserve existing
    min/max values in the case of a re-init. We assume the values were
    validated upon being set and do not do further range checking. The
    debugfs interface for changing min/max was updated with range
    checking to ensure this condition (already present in sysfs
    interface).
    
    v2: fix rps logging to output hw_max and hw_min, not rps.max_delay
        and rps.min_delay which don't strictly represent hardware limits.
        Add igt testcase to signed-off-by section.
    
    Testcase: igt/pm_rps/reset
    Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 05072cf5a008..2d05d7ce4c29 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -728,6 +728,17 @@ int i915_reset(struct drm_device *dev)
 
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);
+
+		/* rps/rc6 re-init is necessary to restore state lost after the
+		 * reset and the re-install of drm irq. Skip for ironlake per
+		 * previous concerns that it doesn't respond well to some forms
+		 * of re-init after reset. */
+		if (INTEL_INFO(dev)->gen > 5) {
+			mutex_lock(&dev->struct_mutex);
+			intel_enable_gt_powersave(dev);
+			mutex_unlock(&dev->struct_mutex);
+		}
+
 		intel_hpd_init(dev);
 	} else {
 		mutex_unlock(&dev->struct_mutex);

commit a57c774ab2b849b9f53ec01308186355aa4227e5
Author: Antti Koskipaa <antti.koskipaa@linux.intel.com>
Date:   Tue Feb 4 14:22:24 2014 +0200

    drm/i915: Reorganize display pipe register accesses
    
    RFCv2: Reorganize array indexing so that full offsets can be used as
    is. It makes grepping for registers in i915_reg.h much easier. Also
    move offset arrays to intel_device_info.
    
    v1: Fixed offsets for VLV, proper eDP handling
    
    v2: Fixed BCLRPAT, PIPESRC, PIPECONF and DSP* macros.
    
    v3: Added EDP pipe comment, removed redundant offset arrays for
        MSA_MISC and DDI_FUNC_CTL.
    
    v4: Rename patch and report object size increase.
    
    v5: Change location of commas, add PIPE_EDP into enum pipe
    
    v6: Insert PIPE_EDP_OFFSET into pipe offset array
    
    v7: Set I915_MAX_PIPES back to 3, change more registers accessors
        to use the new macros, get rid of _PIPE_INC and add dev_priv
        as a parameter where required by the new macros.
    
    Upcoming hardware will not have the various display pipe register
    ranges evenly spaced in memory. Change register address calculations
    into array lookups.
    
    Tested on SNB, VLV, IVB, Gen2 and HSW w/eDP.
    
    I left the UMS cruft untouched.
    
    Size differences:
       text    data     bss     dec     hex filename
     596431    4634      56  601121   92c21 i915.ko (new)
     593199    4634      56  597889   91f81 i915.ko (old)
    
    Signed-off-by: Antti Koskipaa <antti.koskipaa@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a071748d301a..05072cf5a008 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -40,16 +40,28 @@
 
 static struct drm_driver driver;
 
+#define GEN_DEFAULT_PIPEOFFSETS \
+	.pipe_offsets = { PIPE_A_OFFSET, PIPE_B_OFFSET, \
+			  PIPE_C_OFFSET, PIPE_EDP_OFFSET }, \
+	.trans_offsets = { TRANSCODER_A_OFFSET, TRANSCODER_B_OFFSET, \
+			   TRANSCODER_C_OFFSET, TRANSCODER_EDP_OFFSET }, \
+	.dpll_offsets = { DPLL_A_OFFSET, DPLL_B_OFFSET }, \
+	.dpll_md_offsets = { DPLL_A_MD_OFFSET, DPLL_B_MD_OFFSET }, \
+	.palette_offsets = { PALETTE_A_OFFSET, PALETTE_B_OFFSET }
+
+
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_845g_info = {
 	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_i85x_info = {
@@ -58,18 +70,21 @@ static const struct intel_device_info intel_i85x_info = {
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_i865g_info = {
 	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_i915g_info = {
 	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 static const struct intel_device_info intel_i915gm_info = {
 	.gen = 3, .is_mobile = 1, .num_pipes = 2,
@@ -78,11 +93,13 @@ static const struct intel_device_info intel_i915gm_info = {
 	.supports_tv = 1,
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 static const struct intel_device_info intel_i945g_info = {
 	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 static const struct intel_device_info intel_i945gm_info = {
 	.gen = 3, .is_i945gm = 1, .is_mobile = 1, .num_pipes = 2,
@@ -91,6 +108,7 @@ static const struct intel_device_info intel_i945gm_info = {
 	.supports_tv = 1,
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_i965g_info = {
@@ -98,6 +116,7 @@ static const struct intel_device_info intel_i965g_info = {
 	.has_hotplug = 1,
 	.has_overlay = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
@@ -106,6 +125,7 @@ static const struct intel_device_info intel_i965gm_info = {
 	.has_overlay = 1,
 	.supports_tv = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_g33_info = {
@@ -113,12 +133,14 @@ static const struct intel_device_info intel_g33_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 	.ring_mask = RENDER_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_g45_info = {
 	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1, .num_pipes = 2,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_gm45_info = {
@@ -127,18 +149,21 @@ static const struct intel_device_info intel_gm45_info = {
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.supports_tv = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_pineview_info = {
 	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
@@ -146,6 +171,7 @@ static const struct intel_device_info intel_ironlake_m_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
@@ -154,6 +180,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -162,6 +189,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 #define GEN7_FEATURES  \
@@ -174,18 +202,21 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 static const struct intel_device_info intel_ivybridge_d_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.is_mobile = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_ivybridge_q_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.num_pipes = 0, /* legal, last one wins */
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {
@@ -196,6 +227,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.display_mmio_offset = VLV_DISPLAY_BASE,
 	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
@@ -205,6 +237,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.display_mmio_offset = VLV_DISPLAY_BASE,
 	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_haswell_d_info = {
@@ -213,6 +246,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -222,6 +256,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_d_info = {
@@ -230,6 +265,7 @@ static const struct intel_device_info intel_broadwell_d_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
@@ -238,6 +274,7 @@ static const struct intel_device_info intel_broadwell_m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
 	.has_ddi = 1,
+	GEN_DEFAULT_PIPEOFFSETS,
 };
 
 /*

commit d330a9530c97b8ee4704fdd7f228712029438ea9
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jan 21 11:24:25 2014 +0200

    drm/i915: move module parameters into a struct, in a new file
    
    With 20+ module parameters, I think referring to them via a struct
    improves clarity over just having a bunch of globals. While at it, move
    the parameter initialization and definitions into a new file
    i915_params.c to reduce clutter in i915_drv.c.
    
    Apart from the ill-named i915_enable_rc6, i915_enable_fbc and
    i915_enable_ppgtt parameters, for which we lose the "i915_" prefix
    internally, the module parameters now look the same both on the kernel
    command line and in code. For example, "i915.modeset".
    
    The downsides of the change are losing static on a couple of variables
    and not having the initialization and module_param_named() right next to
    each other. On the other hand, all module parameters are now defined in
    one place at i915_params.c. Plus you can do this to find all module
    parameter references:
    
    $ git grep "i915\." -- drivers/gpu/drm/i915
    
    v2:
    - move the definitions into a new file
    - s/i915_params/i915/
    - make i915_try_reset i915.reset, for consistency
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82c46050ebee..a071748d301a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -38,120 +38,6 @@
 #include <linux/module.h>
 #include <drm/drm_crtc_helper.h>
 
-static int i915_modeset __read_mostly = -1;
-module_param_named(modeset, i915_modeset, int, 0400);
-MODULE_PARM_DESC(modeset,
-		"Use kernel modesetting [KMS] (0=DRM_I915_KMS from .config, "
-		"1=on, -1=force vga console preference [default])");
-
-int i915_panel_ignore_lid __read_mostly = 1;
-module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
-MODULE_PARM_DESC(panel_ignore_lid,
-		"Override lid status (0=autodetect, 1=autodetect disabled [default], "
-		"-1=force lid closed, -2=force lid open)");
-
-unsigned int i915_powersave __read_mostly = 1;
-module_param_named(powersave, i915_powersave, int, 0600);
-MODULE_PARM_DESC(powersave,
-		"Enable powersavings, fbc, downclocking, etc. (default: true)");
-
-int i915_semaphores __read_mostly = -1;
-module_param_named(semaphores, i915_semaphores, int, 0400);
-MODULE_PARM_DESC(semaphores,
-		"Use semaphores for inter-ring sync (default: -1 (use per-chip defaults))");
-
-int i915_enable_rc6 __read_mostly = -1;
-module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0400);
-MODULE_PARM_DESC(i915_enable_rc6,
-		"Enable power-saving render C-state 6. "
-		"Different stages can be selected via bitmask values "
-		"(0 = disable; 1 = enable rc6; 2 = enable deep rc6; 4 = enable deepest rc6). "
-		"For example, 3 would enable rc6 and deep rc6, and 7 would enable everything. "
-		"default: -1 (use per-chip default)");
-
-int i915_enable_fbc __read_mostly = -1;
-module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
-MODULE_PARM_DESC(i915_enable_fbc,
-		"Enable frame buffer compression for power savings "
-		"(default: -1 (use per-chip default))");
-
-unsigned int i915_lvds_downclock __read_mostly = 0;
-module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
-MODULE_PARM_DESC(lvds_downclock,
-		"Use panel (LVDS/eDP) downclocking for power savings "
-		"(default: false)");
-
-int i915_lvds_channel_mode __read_mostly;
-module_param_named(lvds_channel_mode, i915_lvds_channel_mode, int, 0600);
-MODULE_PARM_DESC(lvds_channel_mode,
-		 "Specify LVDS channel mode "
-		 "(0=probe BIOS [default], 1=single-channel, 2=dual-channel)");
-
-int i915_panel_use_ssc __read_mostly = -1;
-module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
-MODULE_PARM_DESC(lvds_use_ssc,
-		"Use Spread Spectrum Clock with panels [LVDS/eDP] "
-		"(default: auto from VBT)");
-
-int i915_vbt_sdvo_panel_type __read_mostly = -1;
-module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
-MODULE_PARM_DESC(vbt_sdvo_panel_type,
-		"Override/Ignore selection of SDVO panel mode in the VBT "
-		"(-2=ignore, -1=auto [default], index in VBT BIOS table)");
-
-static bool i915_try_reset __read_mostly = true;
-module_param_named(reset, i915_try_reset, bool, 0600);
-MODULE_PARM_DESC(reset, "Attempt GPU resets (default: true)");
-
-bool i915_enable_hangcheck __read_mostly = true;
-module_param_named(enable_hangcheck, i915_enable_hangcheck, bool, 0644);
-MODULE_PARM_DESC(enable_hangcheck,
-		"Periodically check GPU activity for detecting hangs. "
-		"WARNING: Disabling this can cause system wide hangs. "
-		"(default: true)");
-
-int i915_enable_ppgtt __read_mostly = -1;
-module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0400);
-MODULE_PARM_DESC(i915_enable_ppgtt,
-		"Override PPGTT usage. "
-		"(-1=auto [default], 0=disabled, 1=aliasing, 2=full)");
-
-int i915_enable_psr __read_mostly = 0;
-module_param_named(enable_psr, i915_enable_psr, int, 0600);
-MODULE_PARM_DESC(enable_psr, "Enable PSR (default: false)");
-
-unsigned int i915_preliminary_hw_support __read_mostly = IS_ENABLED(CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT);
-module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 0600);
-MODULE_PARM_DESC(preliminary_hw_support,
-		"Enable preliminary hardware support.");
-
-int i915_disable_power_well __read_mostly = 1;
-module_param_named(disable_power_well, i915_disable_power_well, int, 0600);
-MODULE_PARM_DESC(disable_power_well,
-		 "Disable the power well when possible (default: true)");
-
-int i915_enable_ips __read_mostly = 1;
-module_param_named(enable_ips, i915_enable_ips, int, 0600);
-MODULE_PARM_DESC(enable_ips, "Enable IPS (default: true)");
-
-bool i915_fastboot __read_mostly = 0;
-module_param_named(fastboot, i915_fastboot, bool, 0600);
-MODULE_PARM_DESC(fastboot, "Try to skip unnecessary mode sets at boot time "
-		 "(default: false)");
-
-int i915_enable_pc8 __read_mostly = 1;
-module_param_named(enable_pc8, i915_enable_pc8, int, 0600);
-MODULE_PARM_DESC(enable_pc8, "Enable support for low power package C states (PC8+) (default: true)");
-
-int i915_pc8_timeout __read_mostly = 5000;
-module_param_named(pc8_timeout, i915_pc8_timeout, int, 0600);
-MODULE_PARM_DESC(pc8_timeout, "Number of msecs of idleness required to enter PC8+ (default: 5000)");
-
-bool i915_prefault_disable __read_mostly;
-module_param_named(prefault_disable, i915_prefault_disable, bool, 0600);
-MODULE_PARM_DESC(prefault_disable,
-		"Disable page prefaulting for pread/pwrite/reloc (default:false). For developers only.");
-
 static struct drm_driver driver;
 
 static const struct intel_device_info intel_i830_info = {
@@ -480,12 +366,12 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 
 	/* Until we get further testing... */
 	if (IS_GEN8(dev)) {
-		WARN_ON(!i915_preliminary_hw_support);
+		WARN_ON(!i915.preliminary_hw_support);
 		return false;
 	}
 
-	if (i915_semaphores >= 0)
-		return i915_semaphores;
+	if (i915.semaphores >= 0)
+		return i915.semaphores;
 
 #ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
@@ -750,7 +636,7 @@ int i915_reset(struct drm_device *dev)
 	bool simulated;
 	int ret;
 
-	if (!i915_try_reset)
+	if (!i915.reset)
 		return 0;
 
 	mutex_lock(&dev->struct_mutex);
@@ -818,7 +704,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;
 
-	if (IS_PRELIMINARY_HW(intel_info) && !i915_preliminary_hw_support) {
+	if (IS_PRELIMINARY_HW(intel_info) && !i915.preliminary_hw_support) {
 		DRM_INFO("This hardware requires preliminary hardware support.\n"
 			 "See CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT, and/or modparam preliminary_hw_support\n");
 		return -ENODEV;
@@ -1049,14 +935,14 @@ static int __init i915_init(void)
 	 * the default behavior.
 	 */
 #if defined(CONFIG_DRM_I915_KMS)
-	if (i915_modeset != 0)
+	if (i915.modeset != 0)
 		driver.driver_features |= DRIVER_MODESET;
 #endif
-	if (i915_modeset == 1)
+	if (i915.modeset == 1)
 		driver.driver_features |= DRIVER_MODESET;
 
 #ifdef CONFIG_VGA_CONSOLE
-	if (vgacon_text_force() && i915_modeset == -1)
+	if (vgacon_text_force() && i915.modeset == -1)
 		driver.driver_features &= ~DRIVER_MODESET;
 #endif
 

commit 0e5539b923e3cfb79512b61f6f6137f865160804
Merge: fc2c807b7a2b f72d21eddfa9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Jan 25 21:14:57 2014 +0100

    Merge branch 'topic/ppgtt' into drm-intel-next-queued
    
    Because whatever.*
    
    * This should contain a fairly long list of issues and still
    unresolved resgressions, but I didn't really get a vote.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 6aec02f1965bba7317ee335ffe770112d64d205b
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jan 21 11:24:24 2014 +0200

    drm/i915: drop the i915.fbpercrtc module parameter
    
    It's unused, and nowadays specifying unknown parameters no longer
    prevents modules from being loaded.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 56e5ebbf322f..c46e0a1fb68e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -44,9 +44,6 @@ MODULE_PARM_DESC(modeset,
 		"Use kernel modesetting [KMS] (0=DRM_I915_KMS from .config, "
 		"1=on, -1=force vga console preference [default])");
 
-unsigned int i915_fbpercrtc __always_unused = 0;
-module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
-
 int i915_panel_ignore_lid __read_mostly = 1;
 module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
 MODULE_PARM_DESC(panel_ignore_lid,

commit 754970ee1a4b0a3ba0536ae1d22825a1cfb4c11b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 16 22:28:44 2014 +0100

    drm/i915: Shuffle modeset reset handling around
    
    Currently we're doing the reset handling a bit late, and we're doing
    it both in the driver load code and on resume. This makes it unusable
    for e.g. resetting the panel power sequence state like Paulo wants to.
    
    Instead of adding yet another single-use callback shuffle things
    around:
    - Output handling code is responsible to reset/init all state on its
      own at driver load time.
    - We call the reset functions much earlier, before we start using any
      of the modeset code.
    
    Compared to Paulo's new ->resume callback the only difference in
    placement is that ->reset is still called without dev->struct_mutex
    held. Which is imo a feature.
    
    v2: Rebase on top of the now merge dinq.
    
    Cc: Paulo Zanoni <przanoni@gmail.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 04f1f02c4019..56e5ebbf322f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -643,6 +643,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		intel_init_pch_refclk(dev);
+		drm_mode_config_reset(dev);
 
 		mutex_lock(&dev->struct_mutex);
 
@@ -655,7 +656,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		intel_modeset_init_hw(dev);
 
 		drm_modeset_lock_all(dev);
-		drm_mode_config_reset(dev);
 		intel_modeset_setup_hw_state(dev, true);
 		drm_modeset_unlock_all(dev);
 

commit 1fb2362b43371f35b98a55e615d990f96d8ac966
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Tue Jan 14 15:36:15 2014 -0800

    i915: send D1 opregion notification
    
    The opregion notification for runtime suspend is currently D1, not D3.
    
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca11cc854e78..04f1f02c4019 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -922,7 +922,15 @@ static int i915_runtime_suspend(struct device *device)
 
 	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
 	dev_priv->pm.suspended = true;
-	intel_opregion_notify_adapter(dev, PCI_D3cold);
+
+	/*
+	 * current versions of firmware which depend on this opregion
+	 * notification have repurposed the D1 definition to mean
+	 * "runtime suspended" vs. what you would normally expect (D3)
+	 * to distinguish it from notifications that might be sent
+	 * via the suspend path.
+	 */
+	intel_opregion_notify_adapter(dev, PCI_D1);
 
 	return 0;
 }

commit babb1903511f147b7c9ef3c06f13b036cac31997
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Jan 14 11:04:16 2014 -0800

    drm/i915/bdw: remove preliminary_hw_support flag from BDW
    
    It ought to work ok in 3.14.  We have some fun stuff coming after that,
    but all the basics are in place now and seem relatively stable.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c99f571f1e84..ca11cc854e78 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -341,7 +341,6 @@ static const struct intel_device_info intel_haswell_m_info = {
 };
 
 static const struct intel_device_info intel_broadwell_d_info = {
-	.is_preliminary = 1,
 	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
@@ -350,7 +349,6 @@ static const struct intel_device_info intel_broadwell_d_info = {
 };
 
 static const struct intel_device_info intel_broadwell_m_info = {
-	.is_preliminary = 1,
 	.gen = 8, .is_mobile = 1, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,

commit fae0ce15c29ecc19ec192566f61ccbffe4f25ed0
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Tue Dec 17 15:06:42 2013 -0800

    drm/i915: Make semaphore modparam RO
    
    A couple patches in the upcoming rework of semaphores will break if
    semaphores are toggled by the user at various times. Since the code
    cleanups there seem to be an overall win, and toggling semaphores at
    runtime is not a terribly useful thing to do, simply make the module
    parameter read-only.
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 43245b3fd2a2..c99f571f1e84 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -59,7 +59,7 @@ MODULE_PARM_DESC(powersave,
 		"Enable powersavings, fbc, downclocking, etc. (default: true)");
 
 int i915_semaphores __read_mostly = -1;
-module_param_named(semaphores, i915_semaphores, int, 0600);
+module_param_named(semaphores, i915_semaphores, int, 0400);
 MODULE_PARM_DESC(semaphores,
 		"Use semaphores for inter-ring sync (default: -1 (use per-chip defaults))");
 

commit cfd72a4c2089aa3938f37281a34d6eb3306d5fd8
Merge: 9354eafd893f 0d9d349d8788
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jan 20 10:21:54 2014 +1000

    Merge branch 'drm-intel-next' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    drm-intel-next-2014-01-10:
    - final bits for runtime D3 on Haswell from Paul (now enabled fully)
    - parse the backlight modulation freq information in the VBT from Jani
      (but not yet used)
    - more watermark improvements from Ville for ilk-ivb and bdw
    - bugfixes for fastboot from Jesse
    - watermark fix for i830M (but not yet everything)
    - vlv vga hotplug w/a (Imre)
    - piles of other small improvements, cleanups and fixes all over
    
    Note that the pull request includes a backmerge of the last drm-fixes
    pulled into Linus' tree - things where getting a bit too messy. So the
    shortlog also contains a bunch of patches from Linus tree. Please yell if
    you want me to frob it for you a bit.
    
    * 'drm-intel-next' of git://people.freedesktop.org/~danvet/drm-intel: (609 commits)
      drm/i915/bdw: make sure south port interrupts are enabled properly v2
      drm/i915: Include more information in disabled hotplug interrupt warning
      drm/i915: Only complain about a rogue hotplug IRQ after disabling
      drm/i915: Only WARN about a stuck hotplug irq ONCE
      drm/i915: s/hotplugt_status_gen4/hotplug_status_g4x/

commit 0d9d349d8788d30f3fc3bb39279c370f94d9dbec
Merge: cba1c0737713 145830dfb005
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 16 22:06:30 2014 +0100

    Merge commit origin/master into drm-intel-next
    
    Conflicts are getting out of hand, and now we have to shuffle even
    more in -next which was also shuffled in -fixes (the call for
    drm_mode_config_reset needs to move yet again).
    
    So do a proper backmerge. I wanted to wait with this for the 3.13
    relaese, but alas let's just do this now.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_reg.h
            drivers/gpu/drm/i915/intel_ddi.c
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_pm.c
    
    Besides the conflict around the forcewake get/put (where we chaged the
    called function in -fixes and added a new parameter in -next) code all
    the current conflicts are of the adjacent lines changed type.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 859ae233cd0ee76b6143f948ba1cb6b0b4c342f8
Merge: 785e15ecefbf ab57fff1302c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 23 10:46:07 2013 +1000

    Merge tag 'drm-intel-next-2013-12-13' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    - fbc1 improvements from Ville (pre-gm45).
    - vlv forcewake improvements from Deepak S.
    - Some corner-cases fixes from Mika for the context hang stat code.
    - pc8 improvements and prep work for runtime D3 from Paulo, almost ready for
      primetime.
    - gen2 dpll fixes from Ville.
    - DSI improvements from Shobhit Kumar.
    - A few smaller fixes and improvements all over.
    
    [airlied: intel_ddi.c conflict fixed up]
    
    * tag 'drm-intel-next-2013-12-13' of git://people.freedesktop.org/~danvet/drm-intel: (61 commits)
      drm/i915/bdw: Implement ff workarounds
      drm/i915/bdw: Force all Data Cache Data Port access to be Non-Coherent
      drm/i915/bdw: Don't use forcewake needlessly
      drm/i915: Clear out old GT FIFO errors in intel_uncore_early_sanitize()
      drm/i915: dont call irq_put when irq test is on
      drm/i915: Rework the FBC interval/stall stuff a bit
      drm/i915: Enable FBC for all mobile gen2 and gen3 platforms
      drm/i915: FBC_CONTROL2 is gen4 only
      drm/i915: Gen2 FBC1 CFB pitch wants 32B units
      drm/i915: split intel_ddi_pll_mode_set in 2 pieces
      drm/i915: Fix timeout with missed interrupts in __wait_seqno
      drm/i915: touch VGA MSR after we enable the power well
      drm/i915: extract hsw_power_well_post_{enable, disable}
      drm/i915: remove i915_disable_vga_mem declaration
      drm/i915: Parametrize the dphy and other spec specific parameters
      drm/i915: Remove redundant DSI PLL enabling
      drm/i915: Reorganize the DSI enable/disable sequence
      drm/i915: Try harder to get best m, n, p values with minimal error
      drm/i915: Compute dsi_clk from pixel clock
      drm/i915: Use FLISDSI interface for band gap reset
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/intel_ddi.c

commit 7e0d96bc03c140cb8183955ad6f0290caa731e64
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Dec 6 14:11:26 2013 -0800

    drm/i915: Use multiple VMs -- the point of no return
    
    As with processes which run on the CPU, the goal of multiple VMs is to
    provide process isolation. Specific to GEN, there is also the ability to
    map more objects per process (2GB each instead of 2Gb-2k total).
    
    For the most part, all the pipes have been laid, and all we need to do
    is remove asserts and actually start changing address spaces with the
    context switch. Since prior to this we've converted the setting of the
    page tables to a streamed version, this is quite easy.
    
    One important thing to point out (since it'd been hotly contested) is
    that with this patch, every context created will have it's own address
    space (provided the HW can do it).
    
    v2: Disable BDW on rebase
    
    NOTE: I tried to make this commit as small as possible. I needed one
    place where I could "turn everything on" and that is here. It could be
    split into finer commits, but I didn't really see much point.
    
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 65b5c83df3bb..6cdaa78f3a63 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -116,7 +116,8 @@ MODULE_PARM_DESC(enable_hangcheck,
 int i915_enable_ppgtt __read_mostly = -1;
 module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0400);
 MODULE_PARM_DESC(i915_enable_ppgtt,
-		"Enable PPGTT (default: true)");
+		"Override PPGTT usage. "
+		"(-1=auto [default], 0=disabled, 1=aliasing, 2=full)");
 
 int i915_enable_psr __read_mostly = 0;
 module_param_named(enable_psr, i915_enable_psr, int, 0600);

commit 3d7f0f9dcca6b40dd347bbf3508c642002e0a561
Merge: 4fe9adbc3609 6c719faca2ac
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 18 16:23:37 2013 +0100

    Merge commit drm-intel-fixes into topic/ppgtt
    
    I need the tricky do_switch fix before I can merge the final piece of
    the ppgtt enabling puzzle. Otherwise the conflict will be a real pain
    to resolve since the do_switch hunk from -fixes must be placed at the
    exact right place within a hunk in the next patch.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_gem_context.c
            drivers/gpu/drm/i915/i915_gem_execbuffer.c
            drivers/gpu/drm/i915/intel_display.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 24986ee06929a8de3a5b4722ccadf0b85c175264
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 11:34:33 2013 +0100

    drm: kill DRIVER_REQUIRE_AGP
    
    Only the two intel drivers need this and they can easily check for
    working agp support in their driver ->load callbacks.
    
    This is the only reason why agp initialization could fail, so allows
    us to rip out a bit of error handling code in the next patch.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0ec0fb32a103..e570ad7a9dfe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -828,7 +828,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
-	driver.driver_features &= ~(DRIVER_USE_AGP | DRIVER_REQUIRE_AGP);
+	driver.driver_features &= ~(DRIVER_USE_AGP);
 
 	return drm_get_pci_dev(pdev, ent, &driver);
 }
@@ -936,7 +936,7 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP |
+	    DRIVER_USE_AGP |
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
 	    DRIVER_RENDER,
 	.load = i915_driver_load,

commit da32cc90cbc865c6b49bdc2e0d81b2df3972e5ec
Merge: 319e2e3f63c3 be46ffd48ba3
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Dec 18 10:39:56 2013 +1000

    Merge tag 'drm-intel-next-2013-11-29' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    - some more ppgtt prep patches from Ben
    - a few fbc fixes from Ville
    - power well rework from Imre
    - vlv forcewake improvements from Deepak S, Ville and Jesse
    - a few smaller things all over
    
    [airlied: fixup forwcewake conflict]
    * tag 'drm-intel-next-2013-11-29' of git://people.freedesktop.org/~danvet/drm-intel: (97 commits)
      drm/i915: Fix port name in vlv_wait_port_ready() timeout warning
      drm/i915: Return a drm_mode_status enum in the mode_valid vfuncs
      drm/i915: add intel_display_power_enabled_sw() for use in atomic ctx
      drm/i915: drop DRM_ERROR in intel_fbdev init
      drm/i915/vlv: use parallel context restore when coming out of RC6
      drm/i915/vlv: use a lower RC6 timeout on VLV
      drm/i915/sdvo: Fix up debug output to not split lines
      drm/i915: make sparse happy for the new vlv mmio read function
      drm/i915: drop the right force-wake engine in the vlv mmio funcs
      drm/i915: Fix GT wake FIFO free entries for VLV
      drm/i915: Report all GTFIFODBG errors
      drm/i915: Enabling DebugFS for valleyview forcewake counts
      drm/i915/vlv: Valleyview support for forcewake Individual power wells.
      drm/i915: Add power well arguments to force wake routines.
      drm/i915: Do not attempt to re-enable an unconnected primary plane
      drm/i915: add a debugfs entry for power domain info
      drm/i915: add a default always-on power well
      drm/i915: don't do BDW/HSW specific powerdomains init on other platforms
      drm/i915: protect HSW power well check with IS_HASWELL in redisable_vga
      drm/i915: use IS_HASWELL/BROADWELL instead of HAS_POWER_WELL
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c

commit a08acaf2f6c278f7b3c090d9d7c6cbbe4f02f003
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 17 09:56:53 2013 +0100

    drm/i915: Use symbolic names for booleans in i915_semaphore_is_enabled
    
    Noticed while reviewing a patch and couldn't resist the OCD.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aea909b2f22e..31ffe39d2b79 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -480,12 +480,12 @@ void intel_detect_pch(struct drm_device *dev)
 bool i915_semaphore_is_enabled(struct drm_device *dev)
 {
 	if (INTEL_INFO(dev)->gen < 6)
-		return 0;
+		return false;
 
 	/* Until we get further testing... */
 	if (IS_GEN8(dev)) {
 		WARN_ON(!i915_preliminary_hw_support);
-		return 0;
+		return false;
 	}
 
 	if (i915_semaphores >= 0)
@@ -497,7 +497,7 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 		return false;
 #endif
 
-	return 1;
+	return true;
 }
 
 static int i915_drm_freeze(struct drm_device *dev)

commit 48018a57a8f5900e7e53ffaa0adeb784095accfb
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Dec 13 15:22:31 2013 -0200

    drm/i915: release the GTT mmaps when going into D3
    
    So we'll get a fault when someone tries to access the mmap, then we'll
    wake up from D3.
    
    v2: - Rebase
    v3: - Use gtt active/inactive
    
    Testcase: igt/pm_pc8/gem-mmap-gtt
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    [danvet: Add comment + WARN as discussed with Paulo on irc.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index df634a42cc0c..aea909b2f22e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -917,6 +917,8 @@ static int i915_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	i915_gem_release_all_mmaps(dev_priv);
+
 	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
 	dev_priv->pm.suspended = true;
 	intel_opregion_notify_adapter(dev, PCI_D3cold);

commit 16a3d6ef9f9db6b0e54e6bb756a6b6165166cf44
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Dec 13 15:22:30 2013 -0200

    drm/i915: cancel the hangcheck before runtime suspend
    
    The hangcheck function requires the hardware to be working, and if
    we're suspending we're going to put the HW in D3 state.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c2c9a93861ae..df634a42cc0c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -917,6 +917,7 @@ static int i915_runtime_suspend(struct device *device)
 
 	DRM_DEBUG_KMS("Suspending device\n");
 
+	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
 	dev_priv->pm.suspended = true;
 	intel_opregion_notify_adapter(dev, PCI_D3cold);
 

commit fd70d52acc7abef6402e21e3e11950773af3d769
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Nov 28 17:30:02 2013 +0200

    drm/i915: Enable FBC for all mobile gen2 and gen3 platforms
    
    All mobile gen2 and gen3 chipsets should have FBC1, and the code
    should now handle them all. So just set has_fbc=true for all such
    chipsets.
    
    Note that fbc is still disabled by default for now.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2137a33d5bb2..c2c9a93861ae 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -172,6 +172,7 @@ static const struct intel_device_info intel_i85x_info = {
 	.gen = 2, .is_i85x = 1, .is_mobile = 1, .num_pipes = 2,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 };
 
@@ -191,6 +192,7 @@ static const struct intel_device_info intel_i915gm_info = {
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
+	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 };
 static const struct intel_device_info intel_i945g_info = {
@@ -203,6 +205,7 @@ static const struct intel_device_info intel_i945gm_info = {
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
+	.has_fbc = 1,
 	.ring_mask = RENDER_RING,
 };
 

commit cd2e9e908a86c44c83026acd95520a2761f0d64c
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Dec 6 20:34:21 2013 -0200

    drm/i915: do adapter power state notification at runtime PM
    
    Now that we are actually setting the device to the D3 state, we should
    issue the notification.
    
    The opregion spec says we should send the message before the adapter
    is about to be placed in a lower power state, and after the adapter is
    placed in a higher power state.
    
    Jani originally wrote a similar patch for PC8, but then we discovered
    that we were not really changing the PCI D states when
    enabling/disabling PC8, so we had to postpone his patch.
    
    v2: - Improve commit message, explaining the expected state.
    
    v3: - Rebase.
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Credits-to: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com> (v2)
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7d2136170293..2137a33d5bb2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -915,6 +915,7 @@ static int i915_runtime_suspend(struct device *device)
 	DRM_DEBUG_KMS("Suspending device\n");
 
 	dev_priv->pm.suspended = true;
+	intel_opregion_notify_adapter(dev, PCI_D3cold);
 
 	return 0;
 }
@@ -929,6 +930,7 @@ static int i915_runtime_resume(struct device *device)
 
 	DRM_DEBUG_KMS("Resuming device\n");
 
+	intel_opregion_notify_adapter(dev, PCI_D0);
 	dev_priv->pm.suspended = false;
 
 	return 0;

commit 8a1874559f222efcae0c0c41b180f6e1af6b9d2e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Dec 6 20:32:13 2013 -0200

    drm/i915: add initial Runtime PM functions
    
    This patch adds the initial infrastructure to allow a Runtime PM
    implementation that sets the device to its D3 state. The patch just
    adds the necessary callbacks and the initial infrastructure.
    
    We still don't have any platform that actually uses this
    infrastructure, we still don't call get/put in all the places we need
    to, and we don't have any function to save/restore the state of the
    registers. This is not a problem since no platform uses the code added
    by this patch. We have a few people simultaneously working on runtime
    PM, so this initial code could help everybody make their plans.
    
    V2: - Move some functions to intel_pm.c
        - Remove useless pm_runtime_allow() call at init
        - Remove useless pm_runtime_mark_last_busy() call at get
        - Use pm_runtime_get_sync() instead of 2 calls
        - Add a WARN to check if we're really awake
    
    V3: - Rebase.
    
    V4: - Don't need to call pci_{save,restore}_state and
          pci_set_power_sate, since they're already called by the PCI
          layer
        - Remove wrong pm_runtime_enable() call at init_runtime_pm
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 13076db65eb9..7d2136170293 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -502,6 +502,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_crtc *crtc;
 
+	intel_runtime_pm_get(dev_priv);
+
 	/* ignore lid events during suspend */
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_SUSPENDED;
@@ -686,6 +688,8 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_DONE;
 	mutex_unlock(&dev_priv->modeset_restore_lock);
+
+	intel_runtime_pm_put(dev_priv);
 	return error;
 }
 
@@ -900,6 +904,36 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
+static int i915_runtime_suspend(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	WARN_ON(!HAS_RUNTIME_PM(dev));
+
+	DRM_DEBUG_KMS("Suspending device\n");
+
+	dev_priv->pm.suspended = true;
+
+	return 0;
+}
+
+static int i915_runtime_resume(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	WARN_ON(!HAS_RUNTIME_PM(dev));
+
+	DRM_DEBUG_KMS("Resuming device\n");
+
+	dev_priv->pm.suspended = false;
+
+	return 0;
+}
+
 static const struct dev_pm_ops i915_pm_ops = {
 	.suspend = i915_pm_suspend,
 	.resume = i915_pm_resume,
@@ -907,6 +941,8 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.thaw = i915_pm_thaw,
 	.poweroff = i915_pm_poweroff,
 	.restore = i915_pm_resume,
+	.runtime_suspend = i915_runtime_suspend,
+	.runtime_resume = i915_runtime_resume,
 };
 
 static const struct vm_operations_struct i915_gem_vm_ops = {

commit edd5b13313551d6b04acfb90d3db58ed3cf3c814
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Dec 2 17:39:09 2013 +0000

    drm/i915: Do not clobber config status after a forced restore of hw state
    
    We call intel_modeset_setup_hw_state() along two paths, driver
    load/resume and after a lid event notification. During initialisation of
    the driver, it is imperative that we reset the config state. This
    correctly sets up the initial connector statuses and prepares the
    hardware for a thorough probing. However, during a lid event, we only
    want to undo the damage caused by the bios by resetting our last known
    mode. In this cirumstance, we do not want to clobber our desired state.
    
    In order to try and keep sanity between the config state and our own
    tracking, do the drm_mode_config_reset() first along the load/resume
    paths before reading out the hw state and apply any definite known
    corrections.
    
    v2: "As discussed on irc I don't think we should force the connector
    state to anything here: Imo connector->status should reflect what we
    believe to be the true output connection state, whereas connector->encoder
    reflects whether this connector is wired up to a pipe. And since we no
    longer reject modeset on disconnected connectors and never nuked the pipe
    if the connector gets disconnected there's no reason for that - such policy
    is userspace's job.
    
    This regression has been introduced in
    
    commit 2e9388923e83bc4e2726f170a984621f1d582e77
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Oct 11 20:08:24 2012 +0200
    
        drm/i915/crt: explicitly set up HOTPLUG_BITS on resume"
    so sayeth Daniel.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org (v3.8 and later)
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2e367a1c6a64..5b7b7e06cb3a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -651,6 +651,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		intel_modeset_init_hw(dev);
 
 		drm_modeset_lock_all(dev);
+		drm_mode_config_reset(dev);
 		intel_modeset_setup_hw_state(dev, true);
 		drm_modeset_unlock_all(dev);
 

commit 7c063c725987406d743cc7de7625ff224fab75de
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Nov 26 09:13:41 2013 -0800

    drm/i915: take mode config lock around crtc disable at suspend
    
    This is just a theoretical issue, but we need to do this to prevent the
    WARN in pipe_from_connector at suspend time.
    
    This regression has been introduce in
    
    commit 7bd688cd66db93f6430f6e2b3145ee5686daa315
    Author: Jani Nikula <jani.nikula@intel.com>
    Date:   Fri Nov 8 16:48:56 2013 +0200
    
        drm/i915: handle backlight through chip specific functions
    
    https://bugs.freedesktop.org/show_bug.cgi?id=71978
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 989be12cdd6e..2e367a1c6a64 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -534,8 +534,10 @@ static int i915_drm_freeze(struct drm_device *dev)
 		 * Disable CRTCs directly since we want to preserve sw state
 		 * for _thaw.
 		 */
+		mutex_lock(&dev->mode_config.mutex);
 		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
 			dev_priv->display.crtc_disable(crtc);
+		mutex_unlock(&dev->mode_config.mutex);
 
 		intel_modeset_suspend_hw(dev);
 	}

commit ad52546e4336661c21b5ae927d8a9349e4a930cd
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Mon Nov 25 09:54:36 2013 -0800

    drm/i915: Disallow dynamic ppgtt param modification
    
    This would have never worked.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 804a139901a2..13076db65eb9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -114,7 +114,7 @@ MODULE_PARM_DESC(enable_hangcheck,
 		"(default: true)");
 
 int i915_enable_ppgtt __read_mostly = -1;
-module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0600);
+module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0400);
 MODULE_PARM_DESC(i915_enable_ppgtt,
 		"Enable PPGTT (default: true)");
 

commit b33ecdd1cdeb90ca07dd28d648558e87c8680443
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Nov 15 17:16:33 2013 +0100

    drm/i915: Fix module unloading with DRM_I915_UMS=n
    
    Oops, makes testing early boot failures in i915.ko a bit more pain, so
    let's fix it.
    
    v2: We already have a bit of static storage to track this (Chris).
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 583adcbef5e4..804a139901a2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1022,6 +1022,11 @@ static int __init i915_init(void)
 
 static void __exit i915_exit(void)
 {
+#ifndef CONFIG_DRM_I915_UMS
+	if (!(driver.driver_features & DRIVER_MODESET))
+		return; /* Never loaded a driver. */
+#endif
+
 	drm_pci_exit(&driver, &i915_pci_driver);
 }
 

commit cbaef0f173c7c8bb14976f3928e5876efec444e2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 6 23:02:24 2013 +0200

    drm/i915: Set has_fbc=true for all SNB+, except VLV
    
    At least since SNB (perhaps even earlier) even the desktop parts
    should have FBC.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c2e00ed23195..583adcbef5e4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -264,6 +264,7 @@ static const struct intel_device_info intel_ironlake_m_info = {
 static const struct intel_device_info intel_sandybridge_d_info = {
 	.gen = 6, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
 };
@@ -279,6 +280,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 #define GEN7_FEATURES  \
 	.gen = 7, .num_pipes = 3, \
 	.need_gfx_hws = 1, .has_hotplug = 1, \
+	.has_fbc = 1, \
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
 	.has_llc = 1
 
@@ -291,7 +293,6 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.is_mobile = 1,
-	.has_fbc = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_q_info = {
@@ -306,6 +307,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
 };
 
@@ -314,6 +316,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_fbc = 0, /* legal, last one wins */
 	.has_llc = 0, /* legal, last one wins */
 };
 
@@ -331,7 +334,6 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.is_mobile = 1,
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
-	.has_fbc = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 };
 

commit c09cd6e9691ec6fce8cb90b65929cad389d39c84
Merge: 7eb1c496f7ac 96ab4c70396e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Nov 15 10:02:39 2013 +0100

    Merge branch 'backlight-rework' into drm-intel-next-queued
    
    Pull in Jani's backlight rework branch. This was merged through a
    separate branch to be able to sort out the Broadwell conflicts
    properly before pulling it into the main development branch.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit b30324adaf8d2e5950a602bde63030d15a61826f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 13 22:11:25 2013 +0100

    drm/i915: Deprecated UMS support
    
    It's been 5 years since kms support was merged and roughly 4 years
    since UMS support was ripped out from userspace drivers.
    
    Thus far it's not been a big burden to keep the ums paths alive, and
    we've made some good progress in better separating it from the kms
    code by sprinkling DRIVER_MODESET checks all over the place.
    
    But now that the drm demidlayering is within reach this changes. I
    want to make the driver loading code more robust using devres.c and
    other cool tricks. But that doesn't work with ums due to the
    shadow-attach trick. Which means we either
    a) need to split out a complete ums codebase like radeon has
    b) kill it for good.
    
    The 2nd option is obviously much less work than the first, so I think
    it's time to test the waters and see how many people out there still
    use ums.
    
    I've decided that silently failing to initialize the driver (and not
    e.g. failing to load the module) is the right thing. That way we
    should only get reports from users that actually care about some ums
    features (like accelerated gl or support for secondary outputs).
    Everyone else will just fall back to the vesa X driver.
    
    For developers there's a small info level dmesg output.
    
    The plan is to drop this Kconfig option after 3.16 (so gives us 2 full
    releases) and then start killing code for real 2-3 releases
    afterwards. That should be more than enough time for users to pipe up.
    
    Of course if anyone does we need to revisit this plan and maybe go
    with option a) above.
    
    Also enable the KMS support by default in Kconfig and polish the help
    texts a bit.
    
    v2: Add the missing hunk of actual code changes. Oops. (Ville)
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b16a6eca795f..92ad319164d7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -975,8 +975,13 @@ static int __init i915_init(void)
 		driver.driver_features &= ~DRIVER_MODESET;
 #endif
 
-	if (!(driver.driver_features & DRIVER_MODESET))
+	if (!(driver.driver_features & DRIVER_MODESET)) {
 		driver.get_vblank_timestamp = NULL;
+#ifndef CONFIG_DRM_I915_UMS
+		/* Silently fail loading to not upset userspace. */
+		return 0;
+#endif
+	}
 
 	return drm_pci_init(&driver, &i915_pci_driver);
 }

commit 3bb6ce66866310f50d461b9eff949c1ce95560ce
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 13 22:14:16 2013 +0100

    drm/i915: Kill legeacy AGP for gen3 kms
    
    Thus far we've tried to carefully work around the fact that old
    userspace relied on the AGP-backed legacy buffer mapping ioctls for a
    bit too long. But it's really horribly, and now some new users for it
    started to show up again:
    
    http://www.mail-archive.com/mesa-dev@lists.freedesktop.org/msg45547.html
    
    This uses drmAgpSize to figure out the GTT size, which is both the
    wrong thing to inquire and also might force us to keep this crap
    around for another few years.
    
    So I want to stop this particular zombie from raising ever again. Now
    it's only been 4 years since XvMC was fixed for gen3, so a bit early
    by the usual rules. But since Linus explicitly said that an ABI
    breakage only counts if someone actually observes it I want to tempt
    fate an accelarate the demise of AGP.
    
    We probably need to wait 2-3 kernel releases with this shipping until
    we go on a killing spree code-wise.
    
    v2: Remove intel_agp_enabled since it's unused (Ville).
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a19940f5ef06..b16a6eca795f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -155,11 +155,6 @@ MODULE_PARM_DESC(prefault_disable,
 		"Disable page prefaulting for pread/pwrite/reloc (default:false). For developers only.");
 
 static struct drm_driver driver;
-#if IS_ENABLED(CONFIG_AGP_INTEL)
-extern int intel_agp_enabled;
-#else
-static int intel_agp_enabled = 1;
-#endif
 
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
@@ -797,17 +792,7 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
-	/* We've managed to ship a kms-enabled ddx that shipped with an XvMC
-	 * implementation for gen3 (and only gen3) that used legacy drm maps
-	 * (gasp!) to share buffers between X and the client. Hence we need to
-	 * keep around the fake agp stuff for gen3, even when kms is enabled. */
-	if (intel_info->gen != 3) {
-		driver.driver_features &=
-			~(DRIVER_USE_AGP | DRIVER_REQUIRE_AGP);
-	} else if (!intel_agp_enabled) {
-		DRM_ERROR("drm/i915 can't work without intel_agp module!\n");
-		return -ENODEV;
-	}
+	driver.driver_features &= ~(DRIVER_USE_AGP | DRIVER_REQUIRE_AGP);
 
 	return drm_get_pci_dev(pdev, ent, &driver);
 }

commit ea8eea73ac62fab878912a74df7fb586586238e7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 11 09:35:17 2013 +0100

    drm/i915: Make AGP=n work even on gen3
    
    Most platforms din't hit this condition, but if we want to allow
    building without agp we should also make this allowed on gen3.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c3e9485f38fe..a19940f5ef06 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -158,7 +158,7 @@ static struct drm_driver driver;
 #if IS_ENABLED(CONFIG_AGP_INTEL)
 extern int intel_agp_enabled;
 #else
-static int intel_agp_enabled;
+static int intel_agp_enabled = 1;
 #endif
 
 static const struct intel_device_info intel_i830_info = {

commit f2d91a2c556479713abbefec237cad4bc1d54b0d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 7 09:48:57 2013 +0100

    drm/i915: tune reset dmesg output a bit
    
    We don't want any ERROR for simulated gpu hangs, otoh printing the
    error code when the reset failed for real should be interesting.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=71333
    lu hua <huax.lu@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 38a344694e35..c3e9485f38fe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -731,14 +731,14 @@ int i915_reset(struct drm_device *dev)
 		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
 		dev_priv->gpu_error.stop_rings = 0;
 		if (ret == -ENODEV) {
-			DRM_ERROR("Reset not implemented, but ignoring "
-				  "error for simulated gpu hangs\n");
+			DRM_INFO("Reset not implemented, but ignoring "
+				 "error for simulated gpu hangs\n");
 			ret = 0;
 		}
 	}
 
 	if (ret) {
-		DRM_ERROR("Failed to reset chip.\n");
+		DRM_ERROR("Failed to reset chip: %i\n", ret);
 		mutex_unlock(&dev->struct_mutex);
 		return ret;
 	}

commit 00fe639a56b40930bf27eabeef9a826344d8f4c4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 5 14:00:08 2013 +0200

    drm/i915: Make AGP support optional
    
    We only depend on the intel-gtt module for GTT frobbign on older gens.
    The intel_agp module is optional, except for UMS and some old XvMC
    userland on gen3. So make AGP support optional. As before, we will
    fail the i915 init for UMS and gen3 KMS the same as before if
    intel_agp isn't around.
    
    intel-gtt.c is left with a somewhat ugly ifdef mess, but I'm going
    to save that for a later cleaning.
    
    At least my gen2 still works with the patch and CONFIG_AGP=n.
    
    v2: Make i915 depend on X86 and PCI, and intel-gtt depend on PCI
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 65447572b129..38a344694e35 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -155,7 +155,11 @@ MODULE_PARM_DESC(prefault_disable,
 		"Disable page prefaulting for pread/pwrite/reloc (default:false). For developers only.");
 
 static struct drm_driver driver;
+#if IS_ENABLED(CONFIG_AGP_INTEL)
 extern int intel_agp_enabled;
+#else
+static int intel_agp_enabled;
+#endif
 
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,

commit e76e063486355d2ac42b1c6fffc5fb7166d24389
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Thu Nov 7 21:40:41 2013 -0800

    drm/i915/bdw: Add BDW PCH check first
    
    Early platforms use the same PCH as HSW, and to avoid triggering the
    !ULT, and !HSW warnings, simply put it first in the search.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bbea429ec4b5..989be12cdd6e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -448,17 +448,17 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(IS_ULT(dev));
-			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
-				dev_priv->pch_type = PCH_LPT;
-				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
-				WARN_ON(!IS_HASWELL(dev));
-				WARN_ON(!IS_ULT(dev));
 			} else if (IS_BROADWELL(dev)) {
 				dev_priv->pch_type = PCH_LPT;
 				dev_priv->pch_id =
 					INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
 				DRM_DEBUG_KMS("This is Broadwell, assuming "
 					      "LynxPoint LP PCH\n");
+			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
+				WARN_ON(!IS_HASWELL(dev));
+				WARN_ON(!IS_ULT(dev));
 			} else {
 				goto check_next;
 			}

commit e64c4a1b8a1fbf56cbeed794816e6587719fab5c
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Nov 4 19:45:44 2013 -0800

    drm/i915/bdw: Disable semaphores
    
    We've done insufficient testing on them thus far, so keep them disabled
    until we do test.
    
    v2: Use WARN when not enabling preliminary HW support as this should
    only be disabled for that case.
    
    v3: Rip out the now useless (and really noisy) DRM_INFO output.
    
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Jesse Barnes <jbarnes@virtuosugeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a78e7798ec6b..bbea429ec4b5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -478,6 +478,12 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (INTEL_INFO(dev)->gen < 6)
 		return 0;
 
+	/* Until we get further testing... */
+	if (IS_GEN8(dev)) {
+		WARN_ON(!i915_preliminary_hw_support);
+		return 0;
+	}
+
 	if (i915_semaphores >= 0)
 		return i915_semaphores;
 

commit 018f52c9c3c40b5ba22586b6ced6c3f5339848d6
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Sat Nov 2 21:07:35 2013 -0700

    drm/i915/bdw: pretend we have LPT LP on Broadwell
    
    The platforms we currently have all have LPT LP on them. As such, we
    have no way to identify the new WPT PCH that will ship with Broadwell.
    
    NOTE: For all purposes relevant to the driver that this point, LPT and
    WPT are equivalent. Therefore there should be no need to actually change
    this for some time.
    
    v2: Don't assign dev_priv->num_pch_pll any more.
    
    v3: Rebase on top of the PCH detection changes for virtualized
    enviroments.
    
    v4: Wrote commit message
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch> (v3)
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c0ab5d460692..a78e7798ec6b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -453,6 +453,12 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
+			} else if (IS_BROADWELL(dev)) {
+				dev_priv->pch_type = PCH_LPT;
+				dev_priv->pch_id =
+					INTEL_PCH_LPT_LP_DEVICE_ID_TYPE;
+				DRM_DEBUG_KMS("This is Broadwell, assuming "
+					      "LynxPoint LP PCH\n");
 			} else {
 				goto check_next;
 			}

commit 4b30553d89c1477f86ef4207fe61a1effdcdacd3
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Sat Nov 2 21:07:32 2013 -0700

    drm/i915/bdw: Broadwell has 3 pipes
    
    v2: Rebase (Paulo Zanoni)
    
    v3: Rebase on top of num_pipes having moved to intel_device_info.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com> (v1)
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com> (v2)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 70799febb8ba..c0ab5d460692 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -338,7 +338,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 
 static const struct intel_device_info intel_broadwell_d_info = {
 	.is_preliminary = 1,
-	.gen = 8,
+	.gen = 8, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,
@@ -347,7 +347,7 @@ static const struct intel_device_info intel_broadwell_d_info = {
 
 static const struct intel_device_info intel_broadwell_m_info = {
 	.is_preliminary = 1,
-	.gen = 8, .is_mobile = 1,
+	.gen = 8, .is_mobile = 1, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 	.has_llc = 1,

commit 4d4dead67a4ab1d5de393f15ed5e4e2aa63d3bcf
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Sun Nov 3 16:47:33 2013 -0800

    drm/i915/bdw: Add device IDs
    
    v2: Squash in "drm/i915/bdw: Add BDW to the HAS_DDI check" as
    suggested by Damien.
    
    v3: Squash in VEBOX enabling from  Zhao Yakui <yakui.zhao@intel.com>
    
    v4: Rebase on top of Jesse's patch to extract all pci ids to
    include/drm/i915_pciids.h.
    
    v4: Replace Halo by its marketing moniker Iris. Requested by Ben.
    
    v5: Switch from info->has*ring to info->ring_mask.
    
    v6: Add 0x16X2 variant (which is newer than this patch)
    Rename to use new naming scheme (Chris)
    Remove Simulator PCI ids. These snuck in during rebase (Chris)
    
    v7: Fix poor sed job from v6
    Make the desktop variants use the desktop macro (Rebase error). Notice
    that this makes no functional difference - it's just confusing.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a0804fa1e306..70799febb8ba 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -336,6 +336,24 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 };
 
+static const struct intel_device_info intel_broadwell_d_info = {
+	.is_preliminary = 1,
+	.gen = 8,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+};
+
+static const struct intel_device_info intel_broadwell_m_info = {
+	.is_preliminary = 1,
+	.gen = 8, .is_mobile = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
+	.has_llc = 1,
+	.has_ddi = 1,
+};
+
 /*
  * Make sure any device matches here are from most specific to most
  * general.  For example, since the Quanta match is based on the subsystem
@@ -367,7 +385,9 @@ static const struct intel_device_info intel_haswell_m_info = {
 	INTEL_HSW_D_IDS(&intel_haswell_d_info), \
 	INTEL_HSW_M_IDS(&intel_haswell_m_info), \
 	INTEL_VLV_M_IDS(&intel_valleyview_m_info),	\
-	INTEL_VLV_D_IDS(&intel_valleyview_d_info)
+	INTEL_VLV_D_IDS(&intel_valleyview_d_info),	\
+	INTEL_BDW_M_IDS(&intel_broadwell_m_info),	\
+	INTEL_BDW_D_IDS(&intel_broadwell_d_info)
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_PCI_IDS,

commit 8245be31391974dc756a21cf2f2e25c7f53637c5
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Wed Nov 6 13:56:29 2013 -0200

    drm/i915: Require HW contexts (when possible)
    
    v2: Fixed the botched locking on init_hw failure in i915_reset (Ville)
    Call cleanup_ringbuffer on failed context create in init_hw (Ville)
    
    v3: Add dev argument ti clean_ringbuffer
    
    Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a0804fa1e306..65447572b129 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -755,12 +755,9 @@ int i915_reset(struct drm_device *dev)
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
 			!dev_priv->ums.mm_suspended) {
-		bool hw_contexts_disabled = dev_priv->hw_contexts_disabled;
 		dev_priv->ums.mm_suspended = 0;
 
 		ret = i915_gem_init_hw(dev);
-		if (!hw_contexts_disabled && dev_priv->hw_contexts_disabled)
-			DRM_ERROR("HW contexts didn't survive reset\n");
 		mutex_unlock(&dev->struct_mutex);
 		if (ret) {
 			DRM_ERROR("Failed hw init on reset %d\n", ret);

commit 7f16e5c1416070dc590dd333a2d677700046a4ab
Merge: 9d1cb9147dbe 5e01dc7b26d9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 4 16:28:47 2013 +0100

    Merge tag 'v3.12' into drm-intel-next
    
    I want to merge in the new Broadwell support as a late hw enabling
    pull request. But since the internal branch was based upon our
    drm-intel-nightly integration branch I need to resolve all the
    oustanding conflicts in drm/i915 with a backmerge to make the 60+
    patches apply properly.
    
    We'll propably have some fun because Linus will come up with a
    slightly different merge solution.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/i915_drv.c
            drivers/gpu/drm/i915/intel_crt.c
            drivers/gpu/drm/i915/intel_ddi.c
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
            drivers/gpu/drm/i915/intel_drv.h
    
    All rather simple adjacent lines changed or partial backports from
    -next to -fixes, with the exception of the thaw code in i915_dma.c.
    That one needed a bit of shuffling to restore the intent.
    
    Oh and the massive header file reordering in intel_drv.h is a bit
    trouble. But not much.
    
    v2: Also don't forget the fixup for the silent conflict that results
    in compile fail ...
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit ddb642fb0566758ace34384538720db0e24bcd4c
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Oct 28 17:20:35 2013 +0200

    drm/i915: rename i915_init_power_well to init_power_domains_init
    
    Similarly rename the other related functions in the power domain
    interface.
    
    Higher level driver code calling these functions knows only about power
    domains, not the underlying power wells which may be different on
    different platforms. Also these functions really init/cleanup/resume
    power domains and only through that all related power wells, so rename
    them accordingly.
    
    Note that I left i915_{request,release}_power_well as is, since that
    really changes the state only of a single power well (and is HSW
    specific). It should also get a better name once we make it more
    generic by controlling things through a new audio power domain.
    
    v4:
    - use intel prefix instead of i915 everywhere (Paulo)
    - use a $prefix_$block_$action format (Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b764f7b7eb6b..1041644030b7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -595,7 +595,7 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 	}
 
-	intel_init_power_well(dev);
+	intel_power_domains_init_hw(dev);
 
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);

commit baa707073b6f5374a917f86f4a681149cd39dc64
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Oct 25 17:36:48 2013 +0300

    drm/i915: use power get/put instead of set for power on after init
    
    Currently we make sure that all power domains are enabled during driver
    init and turn off unneded ones only after the first modeset. Similarly
    during suspend we enable all power domains, which will remain on through
    the following resume until the first modeset.
    
    This logic is supported by intel_set_power_well() in the power domain
    framework. It would be nice to simplify the API, so that we only have
    get/put functions and make it more explicit on the higher level how this
    "power well on during init" logic works. This will make it also easier
    if in the future we want to shorten the time the power wells are on.
    
    For this add a new device private flag tracking whether we have the
    power wells on because of init/suspend and use only
    intel_display_power_get()/put(). As nothing else uses
    intel_set_power_well() we can remove it.
    
    This also fixes
    
    commit 6efdf354ddb186c6604d1692075421e8d2c740e9
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Oct 16 17:25:52 2013 +0300
    
        drm/i915: enable only the needed power domains during modeset
    
    where removing intel_set_power_well() resulted in not releasing the
    reference on the power well that was taken during init and thus leaving
    the power well on all the time. Regression reported by Paulo.
    
    v2:
    - move the init_power_on flag to the power_domains struct (Daniel)
    
    v3:
    - add note about this being a regression fix too (Paulo)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1060a96d2184..b764f7b7eb6b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -477,7 +477,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	/* We do a lot of poking in a lot of registers, make sure they work
 	 * properly. */
 	hsw_disable_package_c8(dev_priv);
-	intel_set_power_well(dev, true);
+	intel_display_set_init_power(dev, true);
 
 	drm_kms_helper_poll_disable(dev);
 

commit 828c79087cec61eaf4c76bb32c222fbe35ac3930
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Wed Oct 16 09:21:30 2013 -0700

    drm/i915: Disable GGTT PTEs on GEN6+ suspend
    
    Once the machine gets to a certain point in the suspend process, we
    expect the GPU to be idle. If it is not, we might corrupt memory.
    Empirically (with an early version of this patch) we have seen this is
    not the case. We cannot currently explain why the latent GPU writes
    occur.
    
    In the technical sense, this patch is a workaround in that we have an
    issue we can't explain, and the patch indirectly solves the issue.
    However, it's really better than a workaround because we understand why
    it works, and it really should be a safe thing to do in all cases.
    
    The noticeable effect other than the debug messages would be an increase
    in the suspend time. I have not measure how expensive it actually is.
    
    I think it would be good to spend further time to root cause why we're
    seeing these latent writes, but it shouldn't preclude preventing the
    fallout.
    
    NOTE: It should be safe (and makes some sense IMO) to also keep the
    VALID bit unset on resume when we clear_range(). I've opted not to do
    this as properly clearing those bits at some later point would be extra
    work.
    
    v2: Fix bugzilla link
    
    Bugzilla: http://bugs.freedesktop.org/show_bug.cgi?id=65496
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=59321
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Tested-By: Todd Previte <tprevite@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 69d8ed5416c3..2ad27880cd04 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -505,6 +505,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 		intel_modeset_suspend_hw(dev);
 	}
 
+	i915_gem_suspend_gtt_mappings(dev);
+
 	i915_save_state(dev);
 
 	intel_opregion_fini(dev);
@@ -648,7 +650,8 @@ static int i915_drm_thaw(struct drm_device *dev)
 		mutex_lock(&dev->struct_mutex);
 		i915_gem_restore_gtt_mappings(dev);
 		mutex_unlock(&dev->struct_mutex);
-	}
+	} else if (drm_core_check_feature(dev, DRIVER_MODESET))
+		i915_check_and_clear_faults(dev);
 
 	__i915_drm_thaw(dev);
 

commit 45c5f2022c798b2938d4c0d1c14795787f610ccd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 16 11:50:01 2013 +0100

    drm/i915: Disable all GEM timers and work on unload
    
    We have two once very similar functions, i915_gpu_idle() and
    i915_gem_idle(). The former is used as the lower level operation to
    flush work on the GPU, whereas the latter is the high level interface to
    flush the GEM bookkeeping in addition to flushing the GPU. As such
    i915_gem_idle() also clears out the request and activity lists and
    cancels the delayed work. This is what we need for unloading the driver,
    unfortunately we called i915_gpu_idle() instead.
    
    In the process, make sure that when cancelling the delayed work and
    timer, which is synchronous, that we do not hold any locks to prevent a
    deadlock if the work item is already waiting upon the mutex. This
    requires us to push the mutex down from the caller to i915_gem_idle().
    
    v2: s/i915_gem_idle/i915_gem_suspend/
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70334
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: xunx.fang@intel.com
    [danvet: Only set ums.suspended for !kms as discussed earlier. Chris
    noticed that this slipped through.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e9dfadca2d71..1060a96d2184 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -487,9 +487,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		int error;
 
-		mutex_lock(&dev->struct_mutex);
-		error = i915_gem_idle(dev);
-		mutex_unlock(&dev->struct_mutex);
+		error = i915_gem_suspend(dev);
 		if (error) {
 			dev_err(&dev->pdev->dev,
 				"GEM idle failed, resume might fail\n");

commit 73ae478cdf6ab886b107f39269cbbf6d33ad2abe
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Tue Oct 15 10:02:57 2013 -0700

    drm/i915: Replace has_bsd/blt/vebox with a mask
    
    I've sent this patch several times for various reasons. It essentially
    cleans up a lot of code where we need to do something per ring, and want
    to query whether or not the ring exists on that hardware.
    
    It has various uses coming up, but for now it shouldn't be too
    offensive.
    
    v2: Big conflict resolution on Damien's DEV_INFO_FOR_EACH stuff
    
    v3: Resolved vebox addition
    
    v4: Rebased after months of disuse. Also made failed ringbuffer init
    cleaner.
    
    v5: Remove the init cleaner from v4. There is a better way to do it.
    (Chris)
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index db84e242306d..e9dfadca2d71 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -160,49 +160,58 @@ extern int intel_agp_enabled;
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_845g_info = {
 	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_i85x_info = {
 	.gen = 2, .is_i85x = 1, .is_mobile = 1, .num_pipes = 2,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_i865g_info = {
 	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_i915g_info = {
 	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 static const struct intel_device_info intel_i915gm_info = {
 	.gen = 3, .is_mobile = 1, .num_pipes = 2,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
+	.ring_mask = RENDER_RING,
 };
 static const struct intel_device_info intel_i945g_info = {
 	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.ring_mask = RENDER_RING,
 };
 static const struct intel_device_info intel_i945gm_info = {
 	.gen = 3, .is_i945gm = 1, .is_mobile = 1, .num_pipes = 2,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_i965g_info = {
 	.gen = 4, .is_broadwater = 1, .num_pipes = 2,
 	.has_hotplug = 1,
 	.has_overlay = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
@@ -210,18 +219,20 @@ static const struct intel_device_info intel_i965gm_info = {
 	.is_mobile = 1, .has_fbc = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 	.supports_tv = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_g33_info = {
 	.gen = 3, .is_g33 = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
+	.ring_mask = RENDER_RING,
 };
 
 static const struct intel_device_info intel_g45_info = {
 	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1, .num_pipes = 2,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING,
 };
 
 static const struct intel_device_info intel_gm45_info = {
@@ -229,7 +240,7 @@ static const struct intel_device_info intel_gm45_info = {
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.supports_tv = 1,
-	.has_bsd_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING,
 };
 
 static const struct intel_device_info intel_pineview_info = {
@@ -241,21 +252,20 @@ static const struct intel_device_info intel_pineview_info = {
 static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
-	.has_bsd_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
 	.gen = 6, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
 };
 
@@ -263,16 +273,14 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.gen = 6, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING,
 	.has_llc = 1,
 };
 
 #define GEN7_FEATURES  \
 	.gen = 7, .num_pipes = 3, \
 	.need_gfx_hws = 1, .has_hotplug = 1, \
-	.has_bsd_ring = 1, \
-	.has_blt_ring = 1, \
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING, \
 	.has_llc = 1
 
 static const struct intel_device_info intel_ivybridge_d_info = {
@@ -315,7 +323,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.is_haswell = 1,
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
-	.has_vebox_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -325,7 +333,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.has_fbc = 1,
-	.has_vebox_ring = 1,
+	.ring_mask = RENDER_RING | BSD_RING | BLT_RING | VEBOX_RING,
 };
 
 /*

commit 3d57e5bd1284f44e325f3a52d966259ed42f9e05
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Oct 14 10:01:36 2013 -0700

    drm/i915: Do a fuller init after reset
    
    I had this lying around from he original PPGTT series, and thought we
    might try to get it in by itself.
    
    It's convenient to just call i915_gem_init_hw at reset because we'll be
    adding new things to that function, and having just one function to call
    instead of reimplementing it in two places is nice.
    
    In order to accommodate we cleanup ringbuffers in order to bring them
    back up cleanly. Optionally, we could also teardown/re initialize the
    default context but this was causing some problems on reset which I
    wasn't able to fully debug, and is unnecessary with the previous context
    init/enable split.
    
    This essentially reverts:
    commit 8e88a2bd5987178d16d53686197404e149e996d9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Jun 19 18:40:00 2012 +0200
    
        drm/i915: don't call modeset_init_hw in i915_reset
    
    It seems to work for me on ILK now. Perhaps it's due to:
    commit 8a5c2ae753c588bcb2a4e38d1c6a39865dbf1ff3
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Thu Mar 28 13:57:19 2013 -0700
    
        drm/i915: fix ILK GPU reset for render
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 59649c060986..db84e242306d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -744,30 +744,17 @@ int i915_reset(struct drm_device *dev)
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
 			!dev_priv->ums.mm_suspended) {
-		struct intel_ring_buffer *ring;
-		int i;
-
+		bool hw_contexts_disabled = dev_priv->hw_contexts_disabled;
 		dev_priv->ums.mm_suspended = 0;
 
-		i915_gem_init_swizzling(dev);
-
-		for_each_ring(ring, dev_priv, i)
-			ring->init(ring);
-
-		i915_gem_context_init(dev);
-		if (dev_priv->mm.aliasing_ppgtt) {
-			ret = dev_priv->mm.aliasing_ppgtt->enable(dev);
-			if (ret)
-				i915_gem_cleanup_aliasing_ppgtt(dev);
-		}
-
-		/*
-		 * It would make sense to re-init all the other hw state, at
-		 * least the rps/rc6/emon init done within modeset_init_hw. For
-		 * some unknown reason, this blows up my ilk, so don't.
-		 */
-
+		ret = i915_gem_init_hw(dev);
+		if (!hw_contexts_disabled && dev_priv->hw_contexts_disabled)
+			DRM_ERROR("HW contexts didn't survive reset\n");
 		mutex_unlock(&dev->struct_mutex);
+		if (ret) {
+			DRM_ERROR("Failed hw init on reset %d\n", ret);
+			return ret;
+		}
 
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);

commit ab484f8fd62c97fc52dbb380d8b7cf3ff77b1e70
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Sat Oct 5 17:57:11 2013 -0700

    drm/i915: Remove gen specific checks in MMIO
    
    Now that MMIO has been split up into gen specific functions it is
    obvious when HAS_FPGA_DBG_UNCLAIMED, HAS_FORCE_WAKE are needed. As such,
    we can remove this extraneous condition.
    
    As a result of this, as well as previously existing function pointers
    for forcewake, we no longer need the has_force_wake member in the device
    specific data structure.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 96f230497cbe..59649c060986 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -257,7 +257,6 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -267,7 +266,6 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_force_wake = 1,
 };
 
 #define GEN7_FEATURES  \
@@ -275,8 +273,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1, \
 	.has_bsd_ring = 1, \
 	.has_blt_ring = 1, \
-	.has_llc = 1, \
-	.has_force_wake = 1
+	.has_llc = 1
 
 static const struct intel_device_info intel_ivybridge_d_info = {
 	GEN7_FEATURES,

commit 967ad7f1489da7babbe0746f81c283458ecd3f84
Merge: d7bf63f2465b 6aba5b6cf098
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 10 12:44:43 2013 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    The conflict in intel_drv.h tripped me up a bit since a patch in dinq
    moves all the functions around, but another one in drm-next removes a
    single function. So I'ev figured backing this into a backmerge would
    be good.
    
    i915_dma.c is just adjacent lines changed, nothing nefarious there.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/intel_drv.h
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 16eb5f4379b2097438a224381be3b4d9e56ac979
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Wed Oct 2 10:15:18 2013 +0200

    drm: kill ->gem_init_object() and friends
    
    All drivers embed gem-objects into their own buffer objects. There is no
    reason to keep drm_gem_object_alloc(), gem->driver_private and
    ->gem_init_object() anymore.
    
    New drivers are highly encouraged to do the same. There is no benefit in
    allocating gem-objects separately.
    
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Ben Skeggs <skeggsb@gmail.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6f385e1e9ed6..5f424899009b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -938,7 +938,6 @@ static struct drm_driver driver = {
 	.debugfs_init = i915_debugfs_init,
 	.debugfs_cleanup = i915_debugfs_cleanup,
 #endif
-	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
 

commit 492ab6697c9ff40be43591c8254cbb5b9753b1dc
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Oct 1 12:12:33 2013 +0300

    drm/i915: fix typo s/PatherPoint/PantherPoint/
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8ebb0d12e912..0fc96586acf3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -416,7 +416,7 @@ void intel_detect_pch(struct drm_device *dev)
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
-				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
+				DRM_DEBUG_KMS("Found PantherPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;

commit c9f7fbf9ed05eb92d63a2f4afbd76020572a0dbd
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 16 17:38:36 2013 +0300

    drm/i915: Call intel_uncore_early_sanitize() during resume
    
    Call intel_uncore_early_sanitize() first thing during resume to prevent
    stale BIOS leftovers from being reported as unclaimed register access.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 827c274a8f20..8ebb0d12e912 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -581,6 +581,8 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
+	intel_uncore_early_sanitize(dev);
+
 	intel_uncore_sanitize(dev);
 
 	if (drm_core_check_feature(dev, DRIVER_MODESET) &&

commit ebdcefc6eb209b5197d2f0f73bcc9b0396fdf53e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 16 17:38:35 2013 +0300

    drm/i915: Move power well resume earlier
    
    i915_restore_state() -> i915_restore_display() will attempt to
    re-disable VGA during resume. So the power well needs to be powered on
    before that.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6f385e1e9ed6..827c274a8f20 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -590,6 +590,8 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		mutex_unlock(&dev->struct_mutex);
 	}
 
+	intel_init_power_well(dev);
+
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
@@ -605,8 +607,6 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		/* We need working interrupts for modeset enabling ... */
 		drm_irq_install(dev);
 
-		intel_init_power_well(dev);
-
 		intel_modeset_init_hw(dev);
 
 		drm_modeset_lock_all(dev);

commit d6317290bfd8673d1cf3b6f8a12c72b3297eac36
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 16 17:38:31 2013 +0300

    drm/i915: Pull intel_init_power_well() out of intel_modeset_init_hw()
    
    The init and resume codepaths want to handel the power well in slightly
    different ways, so pull the power well init out from
    intel_modeset_init_hw() which gets called in both cases.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 75e7550064f4..6f385e1e9ed6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -605,6 +605,8 @@ static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 		/* We need working interrupts for modeset enabling ... */
 		drm_irq_install(dev);
 
+		intel_init_power_well(dev);
+
 		intel_modeset_init_hw(dev);
 
 		drm_modeset_lock_all(dev);

commit 9d49c0ef40890064ca552230c2e3ae0e1fb3b617
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Thu Sep 12 18:06:43 2013 -0300

    drm/i915: move more code to __i915_drm_thaw
    
    Both callers had code to sanitize the uncore and restore the GTT
    mappings just before calling __i915_drm_thaw, so Chris suggested I
    should unify the code.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec690ca40af7..75e7550064f4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -576,11 +576,20 @@ static void intel_resume_hotplug(struct drm_device *dev)
 	drm_helper_hpd_irq_event(dev);
 }
 
-static int __i915_drm_thaw(struct drm_device *dev)
+static int __i915_drm_thaw(struct drm_device *dev, bool restore_gtt_mappings)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
+	intel_uncore_sanitize(dev);
+
+	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
+	    restore_gtt_mappings) {
+		mutex_lock(&dev->struct_mutex);
+		i915_gem_restore_gtt_mappings(dev);
+		mutex_unlock(&dev->struct_mutex);
+	}
+
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
@@ -640,19 +649,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 
 static int i915_drm_thaw(struct drm_device *dev)
 {
-	int error = 0;
-
-	intel_uncore_sanitize(dev);
-
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		mutex_lock(&dev->struct_mutex);
-		i915_gem_restore_gtt_mappings(dev);
-		mutex_unlock(&dev->struct_mutex);
-	}
-
-	__i915_drm_thaw(dev);
-
-	return error;
+	return __i915_drm_thaw(dev, true);
 }
 
 int i915_resume(struct drm_device *dev)
@@ -668,20 +665,12 @@ int i915_resume(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	intel_uncore_sanitize(dev);
-
 	/*
 	 * Platforms with opregion should have sane BIOS, older ones (gen3 and
-	 * earlier) need this since the BIOS might clear all our scratch PTEs.
+	 * earlier) need to restore the GTT mappings since the BIOS might clear
+	 * all our scratch PTEs.
 	 */
-	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
-	    !dev_priv->opregion.header) {
-		mutex_lock(&dev->struct_mutex);
-		i915_gem_restore_gtt_mappings(dev);
-		mutex_unlock(&dev->struct_mutex);
-	}
-
-	ret = __i915_drm_thaw(dev);
+	ret = __i915_drm_thaw(dev, !dev_priv->opregion.header);
 	if (ret)
 		return ret;
 

commit be62acb4cce1389a28296852737e3917d9cc5b25
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Fri Aug 30 16:19:28 2013 +0300

    drm/i915: ban badly behaving contexts
    
    Now when we have mechanism in place to track which context
    was guilty of hanging the gpu, it is possible to punish
    for bad behaviour.
    
    If context has recently submitted a faulty batchbuffers guilty of
    gpu hang and submits another batch which hangs gpu in quick
    succession, ban it permanently. If ctx is banned, no more
    batchbuffers will be queued for execution.
    
    There is no need for global wedge machinery anymore and
    it would be unwise to wedge the whole gpu if we have multiple
    hanging batches queued for execution. Instead just ban
    the guilty ones and carry on.
    
    v2: Store guilty ban status bool in gpu_error instead of pointers
        that might become danling before hang is declared.
    
    v3: Use return value for banned status instead of stashing state
        into gpu_error (Chris Wilson)
    
    v4: - rebase on top of fixed hang stats api
        - add define for ban period
        - rename commit and improve commit msg
    
    v5: - rely context banning instead of wedging the gpu
        - beautification and fix for ban calculation (Chris)
    
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 72e2be7a6c80..ec690ca40af7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -719,24 +719,19 @@ int i915_reset(struct drm_device *dev)
 
 	simulated = dev_priv->gpu_error.stop_rings != 0;
 
-	if (!simulated && get_seconds() - dev_priv->gpu_error.last_reset < 5) {
-		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
-		ret = -ENODEV;
-	} else {
-		ret = intel_gpu_reset(dev);
-
-		/* Also reset the gpu hangman. */
-		if (simulated) {
-			DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
-			dev_priv->gpu_error.stop_rings = 0;
-			if (ret == -ENODEV) {
-				DRM_ERROR("Reset not implemented, but ignoring "
-					  "error for simulated gpu hangs\n");
-				ret = 0;
-			}
-		} else
-			dev_priv->gpu_error.last_reset = get_seconds();
+	ret = intel_gpu_reset(dev);
+
+	/* Also reset the gpu hangman. */
+	if (simulated) {
+		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
+		dev_priv->gpu_error.stop_rings = 0;
+		if (ret == -ENODEV) {
+			DRM_ERROR("Reset not implemented, but ignoring "
+				  "error for simulated gpu hangs\n");
+			ret = 0;
+		}
 	}
+
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");
 		mutex_unlock(&dev->struct_mutex);

commit b833d68599b38187c2b55d750f496aa87d9020bc
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Fri Aug 23 16:00:07 2013 -0700

    drm/i915: Restore the preliminary HW check.
    
    We still maintain code internally that cares about preliminary support.
    Leaving the check here doesn't hurt anyone, and should keep things more
    in line.
    
    This time around, stick the info in the intel_info structure, and also
    change the error from DRM_ERROR->DRM_INFO.
    
    This is a partial revert of:
    commit 590e4df8c82e6c2707ae12ba6672ab6fb9cd4b89
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Wed May 8 10:45:15 2013 -0700
    
        drm/i915: VLV support is no longer preliminary
    
    Daniel, I'll provide the fix ups for internal too if/when you merge
    this (if you want).
    
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 69d8ed5416c3..72e2be7a6c80 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -799,6 +799,12 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;
 
+	if (IS_PRELIMINARY_HW(intel_info) && !i915_preliminary_hw_support) {
+		DRM_INFO("This hardware requires preliminary hardware support.\n"
+			 "See CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT, and/or modparam preliminary_hw_support\n");
+		return -ENODEV;
+	}
+
 	/* Only bind to function 0 of the device. Early generations
 	 * used function 1 as a placeholder for multi-head. This causes
 	 * us confusion instead, especially on the systems where both

commit a0a1807544fe59b42d3760ee912ea4c6741298f5
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jul 26 13:32:51 2013 -0700

    drm/i915: split PCI IDs out into i915_drm.h v4
    
    For use by userspace (at some point in the future) and other kernel code.
    
    v2: move PCI IDs to uabi (Chris)
        move PCI IDs to drm/ (Dave)
    v3: fixup Quanta detection - needs to come first (Daniel)
    v4: fix up PCI match structure init for easier use by userspace (Chris)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ccb28ead3501..69d8ed5416c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -157,25 +157,6 @@ MODULE_PARM_DESC(prefault_disable,
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 
-#define INTEL_VGA_DEVICE(id, info) {		\
-	.class = PCI_BASE_CLASS_DISPLAY << 16,	\
-	.class_mask = 0xff0000,			\
-	.vendor = 0x8086,			\
-	.device = id,				\
-	.subvendor = PCI_ANY_ID,		\
-	.subdevice = PCI_ANY_ID,		\
-	.driver_data = (unsigned long) info }
-
-#define INTEL_QUANTA_VGA_DEVICE(info) {		\
-	.class = PCI_BASE_CLASS_DISPLAY << 16,	\
-	.class_mask = 0xff0000,			\
-	.vendor = 0x8086,			\
-	.device = 0x16a,			\
-	.subvendor = 0x152d,			\
-	.subdevice = 0x8990,			\
-	.driver_data = (unsigned long) info }
-
-
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
@@ -350,118 +331,41 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_vebox_ring = 1,
 };
 
+/*
+ * Make sure any device matches here are from most specific to most
+ * general.  For example, since the Quanta match is based on the subsystem
+ * and subvendor IDs, we need it to come before the more general IVB
+ * PCI ID matches, otherwise we'll use the wrong info struct above.
+ */
+#define INTEL_PCI_IDS \
+	INTEL_I830_IDS(&intel_i830_info),	\
+	INTEL_I845G_IDS(&intel_845g_info),	\
+	INTEL_I85X_IDS(&intel_i85x_info),	\
+	INTEL_I865G_IDS(&intel_i865g_info),	\
+	INTEL_I915G_IDS(&intel_i915g_info),	\
+	INTEL_I915GM_IDS(&intel_i915gm_info),	\
+	INTEL_I945G_IDS(&intel_i945g_info),	\
+	INTEL_I945GM_IDS(&intel_i945gm_info),	\
+	INTEL_I965G_IDS(&intel_i965g_info),	\
+	INTEL_G33_IDS(&intel_g33_info),		\
+	INTEL_I965GM_IDS(&intel_i965gm_info),	\
+	INTEL_GM45_IDS(&intel_gm45_info), 	\
+	INTEL_G45_IDS(&intel_g45_info), 	\
+	INTEL_PINEVIEW_IDS(&intel_pineview_info),	\
+	INTEL_IRONLAKE_D_IDS(&intel_ironlake_d_info),	\
+	INTEL_IRONLAKE_M_IDS(&intel_ironlake_m_info),	\
+	INTEL_SNB_D_IDS(&intel_sandybridge_d_info),	\
+	INTEL_SNB_M_IDS(&intel_sandybridge_m_info),	\
+	INTEL_IVB_Q_IDS(&intel_ivybridge_q_info), /* must be first IVB */ \
+	INTEL_IVB_M_IDS(&intel_ivybridge_m_info),	\
+	INTEL_IVB_D_IDS(&intel_ivybridge_d_info),	\
+	INTEL_HSW_D_IDS(&intel_haswell_d_info), \
+	INTEL_HSW_M_IDS(&intel_haswell_m_info), \
+	INTEL_VLV_M_IDS(&intel_valleyview_m_info),	\
+	INTEL_VLV_D_IDS(&intel_valleyview_d_info)
+
 static const struct pci_device_id pciidlist[] = {		/* aka */
-	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),		/* I830_M */
-	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),		/* 845_G */
-	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),		/* I855_GM */
-	INTEL_VGA_DEVICE(0x358e, &intel_i85x_info),
-	INTEL_VGA_DEVICE(0x2572, &intel_i865g_info),		/* I865_G */
-	INTEL_VGA_DEVICE(0x2582, &intel_i915g_info),		/* I915_G */
-	INTEL_VGA_DEVICE(0x258a, &intel_i915g_info),		/* E7221_G */
-	INTEL_VGA_DEVICE(0x2592, &intel_i915gm_info),		/* I915_GM */
-	INTEL_VGA_DEVICE(0x2772, &intel_i945g_info),		/* I945_G */
-	INTEL_VGA_DEVICE(0x27a2, &intel_i945gm_info),		/* I945_GM */
-	INTEL_VGA_DEVICE(0x27ae, &intel_i945gm_info),		/* I945_GME */
-	INTEL_VGA_DEVICE(0x2972, &intel_i965g_info),		/* I946_GZ */
-	INTEL_VGA_DEVICE(0x2982, &intel_i965g_info),		/* G35_G */
-	INTEL_VGA_DEVICE(0x2992, &intel_i965g_info),		/* I965_Q */
-	INTEL_VGA_DEVICE(0x29a2, &intel_i965g_info),		/* I965_G */
-	INTEL_VGA_DEVICE(0x29b2, &intel_g33_info),		/* Q35_G */
-	INTEL_VGA_DEVICE(0x29c2, &intel_g33_info),		/* G33_G */
-	INTEL_VGA_DEVICE(0x29d2, &intel_g33_info),		/* Q33_G */
-	INTEL_VGA_DEVICE(0x2a02, &intel_i965gm_info),		/* I965_GM */
-	INTEL_VGA_DEVICE(0x2a12, &intel_i965gm_info),		/* I965_GME */
-	INTEL_VGA_DEVICE(0x2a42, &intel_gm45_info),		/* GM45_G */
-	INTEL_VGA_DEVICE(0x2e02, &intel_g45_info),		/* IGD_E_G */
-	INTEL_VGA_DEVICE(0x2e12, &intel_g45_info),		/* Q45_G */
-	INTEL_VGA_DEVICE(0x2e22, &intel_g45_info),		/* G45_G */
-	INTEL_VGA_DEVICE(0x2e32, &intel_g45_info),		/* G41_G */
-	INTEL_VGA_DEVICE(0x2e42, &intel_g45_info),		/* B43_G */
-	INTEL_VGA_DEVICE(0x2e92, &intel_g45_info),		/* B43_G.1 */
-	INTEL_VGA_DEVICE(0xa001, &intel_pineview_info),
-	INTEL_VGA_DEVICE(0xa011, &intel_pineview_info),
-	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),
-	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
-	INTEL_VGA_DEVICE(0x0102, &intel_sandybridge_d_info),
-	INTEL_VGA_DEVICE(0x0112, &intel_sandybridge_d_info),
-	INTEL_VGA_DEVICE(0x0122, &intel_sandybridge_d_info),
-	INTEL_VGA_DEVICE(0x0106, &intel_sandybridge_m_info),
-	INTEL_VGA_DEVICE(0x0116, &intel_sandybridge_m_info),
-	INTEL_VGA_DEVICE(0x0126, &intel_sandybridge_m_info),
-	INTEL_VGA_DEVICE(0x010A, &intel_sandybridge_d_info),
-	INTEL_VGA_DEVICE(0x0156, &intel_ivybridge_m_info), /* GT1 mobile */
-	INTEL_VGA_DEVICE(0x0166, &intel_ivybridge_m_info), /* GT2 mobile */
-	INTEL_VGA_DEVICE(0x0152, &intel_ivybridge_d_info), /* GT1 desktop */
-	INTEL_VGA_DEVICE(0x0162, &intel_ivybridge_d_info), /* GT2 desktop */
-	INTEL_VGA_DEVICE(0x015a, &intel_ivybridge_d_info), /* GT1 server */
-	INTEL_QUANTA_VGA_DEVICE(&intel_ivybridge_q_info), /* Quanta transcode */
-	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
-	INTEL_VGA_DEVICE(0x0402, &intel_haswell_d_info), /* GT1 desktop */
-	INTEL_VGA_DEVICE(0x0412, &intel_haswell_d_info), /* GT2 desktop */
-	INTEL_VGA_DEVICE(0x0422, &intel_haswell_d_info), /* GT3 desktop */
-	INTEL_VGA_DEVICE(0x040a, &intel_haswell_d_info), /* GT1 server */
-	INTEL_VGA_DEVICE(0x041a, &intel_haswell_d_info), /* GT2 server */
-	INTEL_VGA_DEVICE(0x042a, &intel_haswell_d_info), /* GT3 server */
-	INTEL_VGA_DEVICE(0x0406, &intel_haswell_m_info), /* GT1 mobile */
-	INTEL_VGA_DEVICE(0x0416, &intel_haswell_m_info), /* GT2 mobile */
-	INTEL_VGA_DEVICE(0x0426, &intel_haswell_m_info), /* GT2 mobile */
-	INTEL_VGA_DEVICE(0x040B, &intel_haswell_d_info), /* GT1 reserved */
-	INTEL_VGA_DEVICE(0x041B, &intel_haswell_d_info), /* GT2 reserved */
-	INTEL_VGA_DEVICE(0x042B, &intel_haswell_d_info), /* GT3 reserved */
-	INTEL_VGA_DEVICE(0x040E, &intel_haswell_d_info), /* GT1 reserved */
-	INTEL_VGA_DEVICE(0x041E, &intel_haswell_d_info), /* GT2 reserved */
-	INTEL_VGA_DEVICE(0x042E, &intel_haswell_d_info), /* GT3 reserved */
-	INTEL_VGA_DEVICE(0x0C02, &intel_haswell_d_info), /* SDV GT1 desktop */
-	INTEL_VGA_DEVICE(0x0C12, &intel_haswell_d_info), /* SDV GT2 desktop */
-	INTEL_VGA_DEVICE(0x0C22, &intel_haswell_d_info), /* SDV GT3 desktop */
-	INTEL_VGA_DEVICE(0x0C0A, &intel_haswell_d_info), /* SDV GT1 server */
-	INTEL_VGA_DEVICE(0x0C1A, &intel_haswell_d_info), /* SDV GT2 server */
-	INTEL_VGA_DEVICE(0x0C2A, &intel_haswell_d_info), /* SDV GT3 server */
-	INTEL_VGA_DEVICE(0x0C06, &intel_haswell_m_info), /* SDV GT1 mobile */
-	INTEL_VGA_DEVICE(0x0C16, &intel_haswell_m_info), /* SDV GT2 mobile */
-	INTEL_VGA_DEVICE(0x0C26, &intel_haswell_m_info), /* SDV GT3 mobile */
-	INTEL_VGA_DEVICE(0x0C0B, &intel_haswell_d_info), /* SDV GT1 reserved */
-	INTEL_VGA_DEVICE(0x0C1B, &intel_haswell_d_info), /* SDV GT2 reserved */
-	INTEL_VGA_DEVICE(0x0C2B, &intel_haswell_d_info), /* SDV GT3 reserved */
-	INTEL_VGA_DEVICE(0x0C0E, &intel_haswell_d_info), /* SDV GT1 reserved */
-	INTEL_VGA_DEVICE(0x0C1E, &intel_haswell_d_info), /* SDV GT2 reserved */
-	INTEL_VGA_DEVICE(0x0C2E, &intel_haswell_d_info), /* SDV GT3 reserved */
-	INTEL_VGA_DEVICE(0x0A02, &intel_haswell_d_info), /* ULT GT1 desktop */
-	INTEL_VGA_DEVICE(0x0A12, &intel_haswell_d_info), /* ULT GT2 desktop */
-	INTEL_VGA_DEVICE(0x0A22, &intel_haswell_d_info), /* ULT GT3 desktop */
-	INTEL_VGA_DEVICE(0x0A0A, &intel_haswell_d_info), /* ULT GT1 server */
-	INTEL_VGA_DEVICE(0x0A1A, &intel_haswell_d_info), /* ULT GT2 server */
-	INTEL_VGA_DEVICE(0x0A2A, &intel_haswell_d_info), /* ULT GT3 server */
-	INTEL_VGA_DEVICE(0x0A06, &intel_haswell_m_info), /* ULT GT1 mobile */
-	INTEL_VGA_DEVICE(0x0A16, &intel_haswell_m_info), /* ULT GT2 mobile */
-	INTEL_VGA_DEVICE(0x0A26, &intel_haswell_m_info), /* ULT GT3 mobile */
-	INTEL_VGA_DEVICE(0x0A0B, &intel_haswell_d_info), /* ULT GT1 reserved */
-	INTEL_VGA_DEVICE(0x0A1B, &intel_haswell_d_info), /* ULT GT2 reserved */
-	INTEL_VGA_DEVICE(0x0A2B, &intel_haswell_d_info), /* ULT GT3 reserved */
-	INTEL_VGA_DEVICE(0x0A0E, &intel_haswell_m_info), /* ULT GT1 reserved */
-	INTEL_VGA_DEVICE(0x0A1E, &intel_haswell_m_info), /* ULT GT2 reserved */
-	INTEL_VGA_DEVICE(0x0A2E, &intel_haswell_m_info), /* ULT GT3 reserved */
-	INTEL_VGA_DEVICE(0x0D02, &intel_haswell_d_info), /* CRW GT1 desktop */
-	INTEL_VGA_DEVICE(0x0D12, &intel_haswell_d_info), /* CRW GT2 desktop */
-	INTEL_VGA_DEVICE(0x0D22, &intel_haswell_d_info), /* CRW GT3 desktop */
-	INTEL_VGA_DEVICE(0x0D0A, &intel_haswell_d_info), /* CRW GT1 server */
-	INTEL_VGA_DEVICE(0x0D1A, &intel_haswell_d_info), /* CRW GT2 server */
-	INTEL_VGA_DEVICE(0x0D2A, &intel_haswell_d_info), /* CRW GT3 server */
-	INTEL_VGA_DEVICE(0x0D06, &intel_haswell_m_info), /* CRW GT1 mobile */
-	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT2 mobile */
-	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT3 mobile */
-	INTEL_VGA_DEVICE(0x0D0B, &intel_haswell_d_info), /* CRW GT1 reserved */
-	INTEL_VGA_DEVICE(0x0D1B, &intel_haswell_d_info), /* CRW GT2 reserved */
-	INTEL_VGA_DEVICE(0x0D2B, &intel_haswell_d_info), /* CRW GT3 reserved */
-	INTEL_VGA_DEVICE(0x0D0E, &intel_haswell_d_info), /* CRW GT1 reserved */
-	INTEL_VGA_DEVICE(0x0D1E, &intel_haswell_d_info), /* CRW GT2 reserved */
-	INTEL_VGA_DEVICE(0x0D2E, &intel_haswell_d_info), /* CRW GT3 reserved */
-	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
-	INTEL_VGA_DEVICE(0x0f31, &intel_valleyview_m_info),
-	INTEL_VGA_DEVICE(0x0f32, &intel_valleyview_m_info),
-	INTEL_VGA_DEVICE(0x0f33, &intel_valleyview_m_info),
-	INTEL_VGA_DEVICE(0x0157, &intel_valleyview_m_info),
-	INTEL_VGA_DEVICE(0x0155, &intel_valleyview_d_info),
+	INTEL_PCI_IDS,
 	{0, 0, 0}
 };
 

commit 10ba50129ab0bdbc0ee712e50913d1c8db88c5f0
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Sun Aug 25 18:29:01 2013 +0200

    drm/i915: Support render nodes
    
    Enable support for drm render nodes for i915 by flagging the ioctls that
    are safe and just needed for rendering.
    
    v2: mark reg_read, set_caching and get_caching (ickle, danvet)
    
    Signed-off-by: Kristian Høgsberg <krh@bitplanet.net>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 735dd5625e9e..ccb28ead3501 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1022,7 +1022,8 @@ static struct drm_driver driver = {
 	 */
 	.driver_features =
 	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP |
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME,
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME |
+	    DRIVER_RENDER,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,
 	.open = i915_driver_open,

commit efa27f9cec09518c9b574e3ab4a0a41717237429
Merge: 62f2104f3fc1 fb1ae911f4e5
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 30 09:47:41 2013 +1000

    Merge tag 'drm-intel-next-2013-08-23' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Need to get my stuff out the door ;-) Highlights:
    - pc8+ support from Paulo
    - more vma patches from Ben.
    - Kconfig option to enable preliminary support by default (Josh
      Triplett)
    - Optimized cpu cache flush handling and support for write-through caching
      of display planes on Iris (Chris)
    - rc6 tuning from Stéphane Marchesin for more stability
    - VECS seqno wrap/semaphores fix (Ben)
    - a pile of smaller cleanups and improvements all over
    
    Note that I've ditched Ben's execbuf vma conversion for 3.12 since not yet
    ready. But there's still other vma conversion stuff in here.
    
    * tag 'drm-intel-next-2013-08-23' of git://people.freedesktop.org/~danvet/drm-intel: (62 commits)
      drm/i915: Print seqnos as unsigned in debugfs
      drm/i915: Fix context size calculation on SNB/IVB/VLV
      drm/i915: Use POSTING_READ in lcpll code
      drm/i915: enable Package C8+ by default
      drm/i915: add i915.pc8_timeout function
      drm/i915: add i915_pc8_status debugfs file
      drm/i915: allow package C8+ states on Haswell (disabled)
      drm/i915: fix SDEIMR assertion when disabling LCPLL
      drm/i915: grab force_wake when restoring LCPLL
      drm/i915: drop WaMbcDriverBootEnable workaround
      drm/i915: Cleaning up the relocate entry function
      drm/i915: merge HSW and SNB PM irq handlers
      drm/i915: fix how we mask PMIMR when adding work to the queue
      drm/i915: don't queue PM events we won't process
      drm/i915: don't disable/reenable IVB error interrupts when not needed
      drm/i915: add dev_priv->pm_irq_mask
      drm/i915: don't update GEN6_PMIMR when it's not needed
      drm/i915: wrap GEN6_PMIMR changes
      drm/i915: wrap GTIMR changes
      drm/i915: add the FCLK case to intel_ddi_get_cdclk_freq
      ...

commit e27e9708c45879f16fb824a2da94cd65e150a0c8
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Aug 19 13:18:12 2013 -0300

    drm/i915: enable Package C8+ by default
    
    This should be working, so enable it by default. Also easy to revert.
    
    v2: Rebase, s/allow/enable/.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6dc00a190669..beb295634a49 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -141,9 +141,9 @@ module_param_named(fastboot, i915_fastboot, bool, 0600);
 MODULE_PARM_DESC(fastboot, "Try to skip unnecessary mode sets at boot time "
 		 "(default: false)");
 
-int i915_enable_pc8 __read_mostly = 0;
+int i915_enable_pc8 __read_mostly = 1;
 module_param_named(enable_pc8, i915_enable_pc8, int, 0600);
-MODULE_PARM_DESC(enable_pc8, "Enable support for low power package C states (PC8+) (default: false)");
+MODULE_PARM_DESC(enable_pc8, "Enable support for low power package C states (PC8+) (default: true)");
 
 int i915_pc8_timeout __read_mostly = 5000;
 module_param_named(pc8_timeout, i915_pc8_timeout, int, 0600);

commit 900587453219f6090a1e28db1bb790aa64820131
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Aug 19 13:18:11 2013 -0300

    drm/i915: add i915.pc8_timeout function
    
    We currently only enter PC8+ after all its required conditions are
    met, there's no rendering, and we stay like that for at least 5
    seconds.
    
    I chose "5 seconds" because this value is conservative and won't make
    us enter/leave PC8+ thousands of times after the screen is off: some
    desktop environments have applications that wake up and do rendering
    every 1-3 seconds, even when the screen is off and the machine is
    completely idle.
    
    But when I was testing my PC8+ patches I set the default value to
    100ms so I could use the bad-behaving desktop environments to
    stress-test my patches. I also thought it would be a good idea to ask
    our power management team to test different values, but I'm pretty
    sure they would ask me for an easy way to change the timeout. So to
    help these 2 cases I decided to create an option that would make it
    easier to change the default value. I also expect people making
    specific products that use our driver could try to find the perfect
    timeout for them.
    
    Anyway, fixing the bad-behaving applications will always lead to
    better power savings than just changing the timeout value: you need to
    stop waking the Kernel, not quickly put it back to sleep again after
    you wake it for nothing. Bad sleep leads to bad mood!
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 84d48b82e3f1..6dc00a190669 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -145,6 +145,10 @@ int i915_enable_pc8 __read_mostly = 0;
 module_param_named(enable_pc8, i915_enable_pc8, int, 0600);
 MODULE_PARM_DESC(enable_pc8, "Enable support for low power package C states (PC8+) (default: false)");
 
+int i915_pc8_timeout __read_mostly = 5000;
+module_param_named(pc8_timeout, i915_pc8_timeout, int, 0600);
+MODULE_PARM_DESC(pc8_timeout, "Number of msecs of idleness required to enter PC8+ (default: 5000)");
+
 bool i915_prefault_disable __read_mostly;
 module_param_named(prefault_disable, i915_prefault_disable, bool, 0600);
 MODULE_PARM_DESC(prefault_disable,

commit c67a470b1db781c54be07a87217cff35a91f564e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Aug 19 13:18:09 2013 -0300

    drm/i915: allow package C8+ states on Haswell (disabled)
    
    This patch allows PC8+ states on Haswell. These states can only be
    reached when all the display outputs are disabled, and they allow some
    more power savings.
    
    The fact that the graphics device is allowing PC8+ doesn't mean that
    the machine will actually enter PC8+: all the other devices also need
    to allow PC8+.
    
    For now this option is disabled by default. You need i915.allow_pc8=1
    if you want it.
    
    This patch adds a big comment inside i915_drv.h explaining how it
    works and how it tracks things. Read it.
    
    v2: (this is not really v2, many previous versions were already sent,
         but they had different names)
        - Use the new functions to enable/disable GTIMR and GEN6_PMIMR
        - Rename almost all variables and functions to names suggested by
          Chris
        - More WARNs on the IRQ handling code
        - Also disable PC8 when there's GPU work to do (thanks to Ben for
          the help on this), so apps can run caster
        - Enable PC8 on a delayed work function that is delayed for 5
          seconds. This makes sure we only enable PC8+ if we're really
          idle
        - Make sure we're not in PC8+ when suspending
    v3: - WARN if IRQs are disabled on __wait_seqno
        - Replace some DRM_ERRORs with WARNs
        - Fix calls to restore GT and PM interrupts
        - Use intel_mark_busy instead of intel_ring_advance to disable PC8
    v4: - Use the force_wake, Luke!
    v5: - Remove the "IIR is not zero" WARNs
        - Move the force_wake chunk to its own patch
        - Only restore what's missing from RC6, not everything
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fd9fb2c25691..84d48b82e3f1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -141,6 +141,10 @@ module_param_named(fastboot, i915_fastboot, bool, 0600);
 MODULE_PARM_DESC(fastboot, "Try to skip unnecessary mode sets at boot time "
 		 "(default: false)");
 
+int i915_enable_pc8 __read_mostly = 0;
+module_param_named(enable_pc8, i915_enable_pc8, int, 0600);
+MODULE_PARM_DESC(enable_pc8, "Enable support for low power package C states (PC8+) (default: false)");
+
 bool i915_prefault_disable __read_mostly;
 module_param_named(prefault_disable, i915_prefault_disable, bool, 0600);
 MODULE_PARM_DESC(prefault_disable,
@@ -557,6 +561,9 @@ static int i915_drm_freeze(struct drm_device *dev)
 	dev_priv->modeset_restore = MODESET_SUSPENDED;
 	mutex_unlock(&dev_priv->modeset_restore_lock);
 
+	/* We do a lot of poking in a lot of registers, make sure they work
+	 * properly. */
+	hsw_disable_package_c8(dev_priv);
 	intel_set_power_well(dev, true);
 
 	drm_kms_helper_poll_disable(dev);
@@ -713,6 +720,10 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		schedule_work(&dev_priv->console_resume_work);
 	}
 
+	/* Undo what we did at i915_drm_freeze so the refcount goes back to the
+	 * expected level. */
+	hsw_enable_package_c8(dev_priv);
+
 	mutex_lock(&dev_priv->modeset_restore_lock);
 	dev_priv->modeset_restore = MODESET_DONE;
 	mutex_unlock(&dev_priv->modeset_restore_lock);

commit 99486b8e6140da7721c932e708a6c17dc1dd970a
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Tue Aug 13 16:23:17 2013 -0700

    i915: Add a Kconfig option to turn on i915.preliminary_hw_support by default
    
    When building kernels for a preliminary hardware target, having to add a
    kernel command-line option can prove inconvenient.  Add a Kconfig option
    that changes the default of this option to 1.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    [danvet: Pimp the Kconfig help text a bit as suggested by Damien in
    his 2nd review.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 01d63a0435fb..fd9fb2c25691 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -122,10 +122,10 @@ int i915_enable_psr __read_mostly = 0;
 module_param_named(enable_psr, i915_enable_psr, int, 0600);
 MODULE_PARM_DESC(enable_psr, "Enable PSR (default: false)");
 
-unsigned int i915_preliminary_hw_support __read_mostly = 0;
+unsigned int i915_preliminary_hw_support __read_mostly = IS_ENABLED(CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT);
 module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 0600);
 MODULE_PARM_DESC(preliminary_hw_support,
-		"Enable preliminary hardware support. (default: false)");
+		"Enable preliminary hardware support.");
 
 int i915_disable_power_well __read_mostly = 1;
 module_param_named(disable_power_well, i915_disable_power_well, int, 0600);

commit 281856477cdaba70032af502ee7192fe7aa54f69
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Aug 8 15:41:27 2013 +0200

    drm: rip out drm_core_has_MTRR checks
    
    The new arch_phys_wc_add/del functions do the right thing both with
    and without MTRR support in the kernel. So we can drop these
    additional checks.
    
    David Herrmann suggest to also kill the DRIVER_USE_MTRR flag since
    it's now unused, which spurred me to do a bit a better audit of the
    affected drivers. David helped a lot in that. Quoting our mail
    discussion:
    
    On Wed, Jul 10, 2013 at 5:41 PM, David Herrmann <dh.herrmann@gmail.com> wrote:
    > On Wed, Jul 10, 2013 at 5:22 PM, Daniel Vetter <daniel.vetter@ffwll.ch> wrote:
    >> On Wed, Jul 10, 2013 at 3:51 PM, David Herrmann <dh.herrmann@gmail.com> wrote:
    >>>> -#if __OS_HAS_MTRR
    >>>> -static inline int drm_core_has_MTRR(struct drm_device *dev)
    >>>> -{
    >>>> -       return drm_core_check_feature(dev, DRIVER_USE_MTRR);
    >>>> -}
    >>>> -#else
    >>>> -#define drm_core_has_MTRR(dev) (0)
    >>>> -#endif
    >>>> -
    >>>
    >>> That was the last user of DRIVER_USE_MTRR (apart from drivers setting
    >>> it in .driver_features). Any reason to keep it around?
    >>
    >> Yeah, I guess we could rip things out. Which will also force me to
    >> properly audit drivers for the eventual behaviour change this could
    >> entail (in case there's an x86 driver which did not ask for an mtrr,
    >> but iirc there isn't).
    >
    > david@david-mb ~/dev/kernel/linux $ for i in drivers/gpu/drm/* ; do if
    > test -d "$i" ; then if ! grep -q USE_MTRR -r $i ; then echo $i ; fi ;
    > fi ; done
    > drivers/gpu/drm/exynos
    > drivers/gpu/drm/gma500
    > drivers/gpu/drm/i2c
    > drivers/gpu/drm/nouveau
    > drivers/gpu/drm/omapdrm
    > drivers/gpu/drm/qxl
    > drivers/gpu/drm/rcar-du
    > drivers/gpu/drm/shmobile
    > drivers/gpu/drm/tilcdc
    > drivers/gpu/drm/ttm
    > drivers/gpu/drm/udl
    > drivers/gpu/drm/vmwgfx
    > david@david-mb ~/dev/kernel/linux $
    >
    > So for x86 gma500,nouveau,qxl,udl,vmwgfx don't set DRIVER_USE_MTRR.
    > But I cannot tell whether they break if we call arch_phys_wc_add/del,
    > anyway. At least nouveau seemed to work here, but it doesn't use AGP
    > or drm_bufs, I guess.
    
    Cool, thanks a lot for stitching together the list of drivers to look
    at. So for real KMS drivers it's the drives responsibility to add an
    mtrr if it needs one. nouvea, radeon, mgag200, i915 and vmwgfx do that
    already. Somehow the savage driver also ends up doing that, I have no
    idea why.
    
    Note that gma500 as a pure KMS driver doesn't need MTRR setup since
    the platforms that it supports all support PAT. So no MTRRs needed to
    get wc iomappings.
    
    The mtrr support in the drm core is all for legacy mappings of garts,
    framebuffers and registers. All legacy drivers set the USE_MTRR flag,
    so we're good there.
    
    All in all I think we can really just ditch this
    
    /endquote
    
    v2: Also kill DRIVER_USE_MTRR as suggested by David Herrmann
    
    v3: Rebase on top of David Herrmann's agp setup/cleanup changes.
    
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9411a745adaf..eec47bd00353 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1006,7 +1006,7 @@ static struct drm_driver driver = {
 	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
-	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP |
 	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,

commit b0e898ac555e96e7863a5ee95d70f3625f1db5e2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Aug 8 15:41:23 2013 +0200

    drm: remove FASYNC support
    
    So I've stumbled over drm_fasync and wondered what it does. Digging
    that up is quite a story.
    
    First I've had to read up on what this does and ended up being rather
    bewildered why peopled loved signals so much back in the days that
    they've created SIGIO just for that ...
    
    Then I wondered how this ever works, and what that strange "No-op."
    comment right above it should mean. After all calling the core fasync
    helper is pretty obviously not a noop. After reading through the
    kernels FASYNC implementation I've noticed that signals are only sent
    out to the processes attached with FASYNC by calling kill_fasync.
    
    No merged drm driver has ever done that.
    
    After more digging I've found out that the only driver that ever used
    this is the so called GAMMA driver. I've frankly never heard of such a
    gpu brand ever before. Now FASYNC seems to not have been the only bad
    thing with that driver, since Dave Airlie removed it from the drm
    driver with prejudice:
    
    commit 1430163b4bbf7b00367ea1066c1c5fe85dbeefed
    Author: Dave Airlie <airlied@linux.ie>
    Date:   Sun Aug 29 12:04:35 2004 +0000
    
        Drop GAMMA DRM from a great height ...
    
    Long story short, the drm fasync support seems to be doing absolutely
    nothing. And the only user of it was never merged into the upstream
    kernel. And we don't need any fops->fasync callback since the fcntl
    implementation in the kernel already implements the noop case
    correctly.
    
    So stop this particular cargo-cult and rip it all out.
    
    v2: Kill drm_fasync assignments in rcar (newly added) and imx drivers
    (somehow I've missed that one in staging). Also drop the reference in
    the drm DocBook. ARM compile-fail reported by Rob Clark.
    
    v3: Move the removal of dev->buf_asnyc assignment in drm_setup to this
    patch here.
    
    v4: Actually git add ... tsk.
    
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 13457e3e9cad..9411a745adaf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -994,7 +994,6 @@ static const struct file_operations i915_driver_fops = {
 	.unlocked_ioctl = drm_ioctl,
 	.mmap = drm_gem_mmap,
 	.poll = drm_poll,
-	.fasync = drm_fasync,
 	.read = drm_read,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = i915_compat_ioctl,

commit 32c913e4369ce7bd1d16a9b6983f7b8975c13f5a
Merge: abf190351b49 cd234b0bfd5a
Author: Dave Airlie <airlied@gmail.com>
Date:   Wed Aug 7 18:09:03 2013 +1000

    Merge tag 'drm-intel-next-2013-07-26-fixed' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Neat that QA (and Ben) keeps on humming along while I'm on vacation, so
    you already get the next feature pull request:
    - proper eLLC support for HSW from Ben
    - more interrupt refactoring
    - add w/a tags where we implement them already (Damien)
    - hangcheck fixes (Chris) + hangcheck stats (Mika)
    - flesh out the new vm structs for ppgtt and ggtt (Ben)
    - PSR for Haswell, still disabled by default (Rodrigo et al.)
    - pc8+ refclock sequence code from Paulo
    - more interrupt refactoring from Paulo, unifying ilk/snb with the ivb/hsw
      interrupt code
    - full solution for the Haswell concurrent reg access issues (Chris)
    - fix racy object accounting, used by some new leak tests
    - fix sync polarity settings on ch7xxx dvo encoder
    - random bits&pieces, little fixes and better debug output all over
    
    [airlied: fix conflict with drm_mm cleanups]
    
    * tag 'drm-intel-next-2013-07-26-fixed' of git://people.freedesktop.org/~danvet/drm-intel: (289 commits)
      drm/i915: Do not dereference NULL crtc or fb until after checking
      drm/i915: fix pnv display core clock readout out
      drm/i915: Replace open-coded offset_in_page()
      drm/i915: Retry DP aux_ch communications with a different clock after failure
      drm/i915: Add messages useful for HPD storm detection debugging (v2)
      drm/i915: dvo_ch7xxx: fix vsync polarity setting
      drm/i915: fix the racy object accounting
      drm/i915: Convert the register access tracepoint to be conditional
      drm/i915: Squash gen lookup through multiple indirections inside GT access
      drm/i915: Use the common register access functions for NOTRACE variants
      drm/i915: Use a private interface for register access within GT
      drm/i915: Colocate all GT access routines in the same file
      drm/i915: fix reference counting in i915_gem_create
      drm/i915: Use Graphics Base of Stolen Memory on all gen3+
      drm/i915: disable stolen mem for OVERLAY_NEEDS_PHYSICAL
      drm/i915: add functions to disable and restore LCPLL
      drm/i915: disable CLKOUT_DP when it's not needed
      drm/i915: extend lpt_enable_clkout_dp
      drm/i915: fix up error cleanup in i915_gem_object_bind_to_gtt
      drm/i915: Add some debug breadcrumbs to connector detection
      ...

commit 43387b37fa2d0f368142b8fa8c9440da92e5381b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 16 09:12:04 2013 +0200

    drm/gem: create drm_gem_dumb_destroy
    
    All the gem based kms drivers really want the same function to
    destroy a dumb framebuffer backing storage object.
    
    So give it to them and roll it out in all drivers.
    
    This still leaves the option open for kms drivers which don't use GEM
    for backing storage, but it does decently simplify matters for gem
    drivers.
    
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Intel Graphics Development <intel-gfx@lists.freedesktop.org>
    Cc: Ben Skeggs <skeggsb@gmail.com>
    Reviwed-by: Rob Clark <robdclark@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b07362f2675e..cca12db6dbb7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1163,7 +1163,7 @@ static struct drm_driver driver = {
 
 	.dumb_create = i915_gem_dumb_create,
 	.dumb_map_offset = i915_gem_mmap_gtt,
-	.dumb_destroy = i915_gem_dumb_destroy,
+	.dumb_destroy = drm_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
 	.fops = &i915_driver_fops,
 	.name = DRIVER_NAME,

commit 907b28c56ea40629aa6595ddfa414ec2fc7da41c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 19 20:36:52 2013 +0100

    drm/i915: Colocate all GT access routines in the same file
    
    Currently, the register access code is split between i915_drv.c and
    intel_pm.c. It only bares a superficial resemblance to the reset of the
    powermanagement code, so move it all into its own file. This is to ease
    further patches to enforce serialised register access.
    
    v2: Scan for random abuse of I915_WRITE_NOTRACE
    v3: Take the opportunity to rename the GT functions as uncore. Uncore is
    the term used by the hardware design (and bspec) for all functions
    outside of the GPU (and CPU) cores in what is also known as the System
    Agent.
    v4: Rebase onto SNB rc6 fixes
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    [danvet: Wrestle patch into applying and inline
    intel_uncore_early_sanitize (plus move the old comment to the new
    function). Also keep the _santize postfix for intel_uncore_sanitize.]
    [danvet: Squash in fixup spotted by Chris on irc: We need to call
    intel_pm_init before intel_uncore_sanitize since the later will call
    cancel_work on the delayed rps setup work the former initializes.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5849b0a91b4e..01d63a0435fb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -723,7 +723,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 {
 	int error = 0;
 
-	intel_gt_sanitize(dev);
+	intel_uncore_sanitize(dev);
 
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
@@ -749,7 +749,7 @@ int i915_resume(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	intel_gt_sanitize(dev);
+	intel_uncore_sanitize(dev);
 
 	/*
 	 * Platforms with opregion should have sane BIOS, older ones (gen3 and
@@ -770,140 +770,6 @@ int i915_resume(struct drm_device *dev)
 	return 0;
 }
 
-static int i8xx_do_reset(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
-	if (IS_I85X(dev))
-		return -ENODEV;
-
-	I915_WRITE(D_STATE, I915_READ(D_STATE) | DSTATE_GFX_RESET_I830);
-	POSTING_READ(D_STATE);
-
-	if (IS_I830(dev) || IS_845G(dev)) {
-		I915_WRITE(DEBUG_RESET_I830,
-			   DEBUG_RESET_DISPLAY |
-			   DEBUG_RESET_RENDER |
-			   DEBUG_RESET_FULL);
-		POSTING_READ(DEBUG_RESET_I830);
-		msleep(1);
-
-		I915_WRITE(DEBUG_RESET_I830, 0);
-		POSTING_READ(DEBUG_RESET_I830);
-	}
-
-	msleep(1);
-
-	I915_WRITE(D_STATE, I915_READ(D_STATE) & ~DSTATE_GFX_RESET_I830);
-	POSTING_READ(D_STATE);
-
-	return 0;
-}
-
-static int i965_reset_complete(struct drm_device *dev)
-{
-	u8 gdrst;
-	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
-	return (gdrst & GRDOM_RESET_ENABLE) == 0;
-}
-
-static int i965_do_reset(struct drm_device *dev)
-{
-	int ret;
-
-	/*
-	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
-	 * well as the reset bit (GR/bit 0).  Setting the GR bit
-	 * triggers the reset; when done, the hardware will clear it.
-	 */
-	pci_write_config_byte(dev->pdev, I965_GDRST,
-			      GRDOM_RENDER | GRDOM_RESET_ENABLE);
-	ret =  wait_for(i965_reset_complete(dev), 500);
-	if (ret)
-		return ret;
-
-	/* We can't reset render&media without also resetting display ... */
-	pci_write_config_byte(dev->pdev, I965_GDRST,
-			      GRDOM_MEDIA | GRDOM_RESET_ENABLE);
-
-	ret =  wait_for(i965_reset_complete(dev), 500);
-	if (ret)
-		return ret;
-
-	pci_write_config_byte(dev->pdev, I965_GDRST, 0);
-
-	return 0;
-}
-
-static int ironlake_do_reset(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	u32 gdrst;
-	int ret;
-
-	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
-	gdrst &= ~GRDOM_MASK;
-	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
-		   gdrst | GRDOM_RENDER | GRDOM_RESET_ENABLE);
-	ret = wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
-	if (ret)
-		return ret;
-
-	/* We can't reset render&media without also resetting display ... */
-	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
-	gdrst &= ~GRDOM_MASK;
-	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
-		   gdrst | GRDOM_MEDIA | GRDOM_RESET_ENABLE);
-	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
-}
-
-static int gen6_do_reset(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int	ret;
-	unsigned long irqflags;
-
-	/* Hold gt_lock across reset to prevent any register access
-	 * with forcewake not set correctly
-	 */
-	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
-
-	/* Reset the chip */
-
-	/* GEN6_GDRST is not in the gt power well, no need to check
-	 * for fifo space for the write or forcewake the chip for
-	 * the read
-	 */
-	I915_WRITE_NOTRACE(GEN6_GDRST, GEN6_GRDOM_FULL);
-
-	/* Spin waiting for the device to ack the reset request */
-	ret = wait_for((I915_READ_NOTRACE(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
-
-	/* If reset with a user forcewake, try to restore, otherwise turn it off */
-	if (dev_priv->forcewake_count)
-		dev_priv->gt.force_wake_get(dev_priv);
-	else
-		dev_priv->gt.force_wake_put(dev_priv);
-
-	/* Restore fifo count */
-	dev_priv->gt_fifo_count = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
-
-	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
-	return ret;
-}
-
-int intel_gpu_reset(struct drm_device *dev)
-{
-	switch (INTEL_INFO(dev)->gen) {
-	case 7:
-	case 6: return gen6_do_reset(dev);
-	case 5: return ironlake_do_reset(dev);
-	case 4: return i965_do_reset(dev);
-	case 2: return i8xx_do_reset(dev);
-	default: return -ENODEV;
-	}
-}
-
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -1233,136 +1099,3 @@ module_exit(i915_exit);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
-
-/* We give fast paths for the really cool registers */
-#define NEEDS_FORCE_WAKE(dev_priv, reg) \
-	((HAS_FORCE_WAKE((dev_priv)->dev)) && \
-	 ((reg) < 0x40000) &&            \
-	 ((reg) != FORCEWAKE))
-static void
-ilk_dummy_write(struct drm_i915_private *dev_priv)
-{
-	/* WaIssueDummyWriteToWakeupFromRC6:ilk Issue a dummy write to wake up
-	 * the chip from rc6 before touching it for real. MI_MODE is masked,
-	 * hence harmless to write 0 into. */
-	I915_WRITE_NOTRACE(MI_MODE, 0);
-}
-
-static void
-hsw_unclaimed_reg_clear(struct drm_i915_private *dev_priv, u32 reg)
-{
-	if (HAS_FPGA_DBG_UNCLAIMED(dev_priv->dev) &&
-	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
-		DRM_ERROR("Unknown unclaimed register before writing to %x\n",
-			  reg);
-		I915_WRITE_NOTRACE(FPGA_DBG, FPGA_DBG_RM_NOCLAIM);
-	}
-}
-
-static void
-hsw_unclaimed_reg_check(struct drm_i915_private *dev_priv, u32 reg)
-{
-	if (HAS_FPGA_DBG_UNCLAIMED(dev_priv->dev) &&
-	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
-		DRM_ERROR("Unclaimed write to %x\n", reg);
-		I915_WRITE_NOTRACE(FPGA_DBG, FPGA_DBG_RM_NOCLAIM);
-	}
-}
-
-#define __i915_read(x, y) \
-u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
-	unsigned long irqflags; \
-	u##x val = 0; \
-	spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
-	if (IS_GEN5(dev_priv->dev)) \
-		ilk_dummy_write(dev_priv); \
-	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
-		if (dev_priv->forcewake_count == 0) \
-			dev_priv->gt.force_wake_get(dev_priv); \
-		val = read##y(dev_priv->regs + reg); \
-		if (dev_priv->forcewake_count == 0) \
-			dev_priv->gt.force_wake_put(dev_priv); \
-	} else { \
-		val = read##y(dev_priv->regs + reg); \
-	} \
-	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
-	trace_i915_reg_rw(false, reg, val, sizeof(val)); \
-	return val; \
-}
-
-__i915_read(8, b)
-__i915_read(16, w)
-__i915_read(32, l)
-__i915_read(64, q)
-#undef __i915_read
-
-#define __i915_write(x, y) \
-void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
-	unsigned long irqflags; \
-	u32 __fifo_ret = 0; \
-	trace_i915_reg_rw(true, reg, val, sizeof(val)); \
-	spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
-	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
-		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \
-	} \
-	if (IS_GEN5(dev_priv->dev)) \
-		ilk_dummy_write(dev_priv); \
-	hsw_unclaimed_reg_clear(dev_priv, reg); \
-	write##y(val, dev_priv->regs + reg); \
-	if (unlikely(__fifo_ret)) { \
-		gen6_gt_check_fifodbg(dev_priv); \
-	} \
-	hsw_unclaimed_reg_check(dev_priv, reg); \
-	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
-}
-__i915_write(8, b)
-__i915_write(16, w)
-__i915_write(32, l)
-__i915_write(64, q)
-#undef __i915_write
-
-static const struct register_whitelist {
-	uint64_t offset;
-	uint32_t size;
-	uint32_t gen_bitmask; /* support gens, 0x10 for 4, 0x30 for 4 and 5, etc. */
-} whitelist[] = {
-	{ RING_TIMESTAMP(RENDER_RING_BASE), 8, 0xF0 },
-};
-
-int i915_reg_read_ioctl(struct drm_device *dev,
-			void *data, struct drm_file *file)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct drm_i915_reg_read *reg = data;
-	struct register_whitelist const *entry = whitelist;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(whitelist); i++, entry++) {
-		if (entry->offset == reg->offset &&
-		    (1 << INTEL_INFO(dev)->gen & entry->gen_bitmask))
-			break;
-	}
-
-	if (i == ARRAY_SIZE(whitelist))
-		return -EINVAL;
-
-	switch (entry->size) {
-	case 8:
-		reg->val = I915_READ64(reg->offset);
-		break;
-	case 4:
-		reg->val = I915_READ(reg->offset);
-		break;
-	case 2:
-		reg->val = I915_READ16(reg->offset);
-		break;
-	case 1:
-		reg->val = I915_READ8(reg->offset);
-		break;
-	default:
-		WARN_ON(1);
-		return -EINVAL;
-	}
-
-	return 0;
-}

commit cb54b53adae70701bdd77d848cea4b9b39b61cf9
Merge: d861e3387650 549f3a1218ba
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 25 09:41:59 2013 +0200

    Merge commit 'Merge branch 'drm-fixes' of git://people.freedesktop.org/~airlied/linux'
    
    This backmerges Linus' merge commit of the latest drm-fixes pull:
    
    commit 549f3a1218ba18fcde11ef0e22b07e6365645788
    Merge: 42577ca 058ca4a
    Author: Linus Torvalds <torvalds@linux-foundation.org>
    Date:   Tue Jul 23 15:47:08 2013 -0700
    
        Merge branch 'drm-fixes' of git://people.freedesktop.org/~airlied/linux
    
    We've accrued a few too many conflicts, but the real reason is that I
    want to merge the 100% solution for Haswell concurrent registers
    writes into drm-intel-next. But that depends upon the 90% bandaid
    merged into -fixes:
    
    commit a7cd1b8fea2f341b626b255d9898a5ca5fabbf0a
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Fri Jul 19 20:36:51 2013 +0100
    
        drm/i915: Serialize almost all register access
    
    Also, we can roll up on accrued conflicts.
    
    Usually I'd backmerge a tagged -rc, but I want to get this done before
    heading off to vacations next week ;-)
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/i915_gem.c
    
    v2: For added hilarity we have a init sequence conflict around the
    gt_lock, so need to move that one, too. Spotted by Jani Nikula.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 181d1b9e31c668259d3798c521672afb8edd355c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Jul 21 13:16:24 2013 +0200

    drm/i915: fix up gt init sequence fallout
    
    The regression fix for gen6+ rps fallout
    
    commit 7dcd2677ea912573d9ed4bcd629b0023b2d11505
    Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Date:   Wed Jul 17 10:22:58 2013 +0400
    
        drm/i915: fix long-standing SNB regression in power consumption after resume
    
    unintentionally also changed the init sequence ordering between
    gt_init and gt_reset - we need to reset BIOS damage like leftover
    forcewake references before we run our own code. Otherwise we can get
    nasty dmesg noise like
    
    [drm:__gen6_gt_force_wake_mt_get] *ERROR* Timed out waiting for forcewake old ack to clear.
    
    again. Since _reset suggests that we first need to have stuff
    initialized (which isn't the case here) call it sanitze instead.
    
    While at it also block out the rps disable introduced by the above
    commit on ilk: We don't have any knowledge of ilk rps being broken in
    similar ways. And the disable functions uses the default hw state
    which is only read out when we're enabling rps. So essentially we've
    been writing random grabage into that register.
    
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: stable@vger.kernel.org
    Tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6ddc5677ea2f..45b3c030f483 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -706,7 +706,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 {
 	int error = 0;
 
-	intel_gt_reset(dev);
+	intel_gt_sanitize(dev);
 
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
@@ -732,7 +732,7 @@ int i915_resume(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	intel_gt_reset(dev);
+	intel_gt_sanitize(dev);
 
 	/*
 	 * Platforms with opregion should have sane BIOS, older ones (gen3 and

commit a7cd1b8fea2f341b626b255d9898a5ca5fabbf0a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 19 20:36:51 2013 +0100

    drm/i915: Serialize almost all register access
    
    In theory, the different register blocks were meant to be only ever
    touched when holding either the struct_mutex, mode_config.lock or even a
    specific localised lock. This does not seem to be the case, and the
    hardware reacts extremely badly if we attempt to concurrently access two
    registers within the same cacheline.
    
    The HSD suggests that we only need to do this workaround for display
    range registers. However, upon review we need to serialize the multiple
    stages in our register write functions - if only for preemption
    protection.
    
    Irrespective of the hardware requirements, the current io functions are
    a little too loose with respect to the combination of pre- and
    post-condition testing that we do in conjunction with the actual io. As
    a result, we may be pre-empted and generate both false-postive and
    false-negative errors.
    
    Note well that this is a "90%" solution, there remains a few direct
    users of ioread/iowrite which will be fixed up in the next few patches.
    Since they are more invasive and that this simple change will prevent
    almost all lockups on Haswell, we kept this patch simple to facilitate
    backporting to stable.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=63914
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f4af1ca0fb62..6ddc5677ea2f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1253,21 +1253,21 @@ hsw_unclaimed_reg_check(struct drm_i915_private *dev_priv, u32 reg)
 
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
+	unsigned long irqflags; \
 	u##x val = 0; \
+	spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
 	if (IS_GEN5(dev_priv->dev)) \
 		ilk_dummy_write(dev_priv); \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
-		unsigned long irqflags; \
-		spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
 		if (dev_priv->forcewake_count == 0) \
 			dev_priv->gt.force_wake_get(dev_priv); \
 		val = read##y(dev_priv->regs + reg); \
 		if (dev_priv->forcewake_count == 0) \
 			dev_priv->gt.force_wake_put(dev_priv); \
-		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
 	} else { \
 		val = read##y(dev_priv->regs + reg); \
 	} \
+	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
 	trace_i915_reg_rw(false, reg, val, sizeof(val)); \
 	return val; \
 }
@@ -1280,8 +1280,10 @@ __i915_read(64, q)
 
 #define __i915_write(x, y) \
 void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
+	unsigned long irqflags; \
 	u32 __fifo_ret = 0; \
 	trace_i915_reg_rw(true, reg, val, sizeof(val)); \
+	spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
 		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \
 	} \
@@ -1293,6 +1295,7 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 		gen6_gt_check_fifodbg(dev_priv); \
 	} \
 	hsw_unclaimed_reg_check(dev_priv, reg); \
+	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
 }
 __i915_write(8, b)
 __i915_write(16, w)

commit 0b74b508f78cea96d0d1b47e72cc0ec7959cdc68
Author: Xiong Zhang <xiong.y.zhang@intel.com>
Date:   Fri Jul 19 13:51:24 2013 +0800

    drm/i915: add prefault_disable module option
    
    prefault is stll enabled by default which prevent most of pwrite/pread/reloc
    from running slow path, in order to verify these slow pathes, prefault need
    to be disabled.
    
    Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
    [danvet: Make checkpatch happy and bikeshed the module option help
    text a bit.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b178a7ca1294..c34086ad8181 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -141,6 +141,11 @@ module_param_named(fastboot, i915_fastboot, bool, 0600);
 MODULE_PARM_DESC(fastboot, "Try to skip unnecessary mode sets at boot time "
 		 "(default: false)");
 
+bool i915_prefault_disable __read_mostly;
+module_param_named(prefault_disable, i915_prefault_disable, bool, 0600);
+MODULE_PARM_DESC(prefault_disable,
+		"Disable page prefaulting for pread/pwrite/reloc (default:false). For developers only.");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 

commit e13af9a8340685cfe25d0c9f708da7121e0f51dd
Merge: ee114b97e67b 50b44a449ff1
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jul 19 11:56:14 2013 +1000

    Merge tag 'drm-intel-next-2013-07-12' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
     Highlights:
    - follow-up refactoring after the shared dpll rework that landed in 3.11
    - oddball prep cleanups from Ben for ppgtt
    - encoder->get_config state tracking infrastructure from Jesse
    - used by the experimental fastboot support from Jesse (disabled by
      default)
    - make the error state file official and add it to our sysfs interface
      (Mika)
    - drm_mm prep changes from Ben, prepares to embedd the drm_mm_node (which
      will be used by the vma rework later on)
    - interrupt handling rework, follow up cleanups to the VECS enabling, hpd
      storm handling and fifo underrun reporting.
    - Big pile of smaller cleanups, code improvements and related stuff.
    
    * tag 'drm-intel-next-2013-07-12' of git://people.freedesktop.org/~danvet/drm-intel: (72 commits)
      drm/i915: clear DPLL reg when disabling i9xx dplls
      drm/i915: Fix up cpt pixel multiplier enable sequence
      drm/i915: clean up vlv ->pre_pll_enable and pll enable sequence
      drm/i915: move error state to own compilation unit
      drm/i915: Don't attempt to read an unitialized stack value
      drm/i915: Use for_each_pipe() when possible
      drm/i915: don't enable PM_VEBOX_CS_ERROR_INTERRUPT
      drm/i915: unify ring irq refcounts (again)
      drm/i915: kill dev_priv->rps.lock
      drm/i915: queue work outside spinlock in hsw_pm_irq_handler
      drm/i915: streamline hsw_pm_irq_handler
      drm/i915: irq handlers don't need interrupt-safe spinlocks
      drm/i915: kill lpt pch transcoder->crtc mapping code for fifo underruns
      drm/i915: improve GEN7_ERR_INT clearing for fifo underrun reporting
      drm/i915: improve SERR_INT clearing for fifo underrun reporting
      drm/i915: extract ibx_display_interrupt_update
      drm/i915: remove unused members from drm_i915_private
      drm/i915: don't frob mm.suspended when not using ums
      drm/i915: Fix VLV DP RBR/HDMI/DAC PLL LPF coefficients
      drm/i915: WARN if the bios reserved range is bigger than stolen size
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_gem.c

commit 105b7c11f036f734988990541674a93e54cf4ec1
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Thu Jul 11 18:45:02 2013 -0300

    drm/intel: add enable_psr module option and disable psr by default
    
    v2: prefer seq_puts to seq_printf detected by Paulo Zanoni.
    v3: PSR is disabled by default. Without userspace ready it
        will cause regression for kde and xdm users
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Reviewed-by: Shobhit Kumar <shobhit.kumar@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0485f435eeea..b178a7ca1294 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -118,6 +118,10 @@ module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0600);
 MODULE_PARM_DESC(i915_enable_ppgtt,
 		"Enable PPGTT (default: true)");
 
+int i915_enable_psr __read_mostly = 0;
+module_param_named(enable_psr, i915_enable_psr, int, 0600);
+MODULE_PARM_DESC(enable_psr, "Enable PSR (default: false)");
+
 unsigned int i915_preliminary_hw_support __read_mostly = 0;
 module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 0600);
 MODULE_PARM_DESC(preliminary_hw_support,

commit db1b76ca6a79c774074ae87bee7afc0825a478f5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 9 16:51:37 2013 +0200

    drm/i915: don't frob mm.suspended when not using ums
    
    In kernel modeset driver mode we're in full control of the chip,
    always. So there's no need at all to set mm.suspended in
    i915_gem_idle. Hence move that out into the leavevt ioctl. Since
    i915_gem_idle doesn't suspend gem any more we can also drop the
    re-enabling for KMS in the thaw function.
    
    Also clean up the handling of mm.suspend at driver load by coalescing
    all the assignments.
    
    Stumbled over while reading through our resume code for unrelated
    reasons.
    
    v2: Shovel mm.suspended into the (newly created) ums dungeon as
    suggested by Chris Wilson. The plan is that once we've completely
    stopped relying on the register save/restore code we could shovel even
    that in there.
    
    v3: Improve the locking for the entervt/leavevt ioctls a bit by moving
    the dev->struct_mutex locking outside of i915_gem_idle. Also don't
    clear dev_priv->ums.mm_suspended for the kms case, we allocate it with
    kzalloc. Both suggested by Chris Wilson.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v2)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ed9262c42b7b..0485f435eeea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -556,7 +556,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	/* If KMS is active, we do the leavevt stuff here */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		int error = i915_gem_idle(dev);
+		int error;
+
+		mutex_lock(&dev->struct_mutex);
+		error = i915_gem_idle(dev);
+		mutex_unlock(&dev->struct_mutex);
 		if (error) {
 			dev_err(&dev->pdev->dev,
 				"GEM idle failed, resume might fail\n");
@@ -661,7 +665,6 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		intel_init_pch_refclk(dev);
 
 		mutex_lock(&dev->struct_mutex);
-		dev_priv->mm.suspended = 0;
 
 		error = i915_gem_init_hw(dev);
 		mutex_unlock(&dev->struct_mutex);
@@ -961,11 +964,11 @@ int i915_reset(struct drm_device *dev)
 	 * switched away).
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
-			!dev_priv->mm.suspended) {
+			!dev_priv->ums.mm_suspended) {
 		struct intel_ring_buffer *ring;
 		int i;
 
-		dev_priv->mm.suspended = 0;
+		dev_priv->ums.mm_suspended = 0;
 
 		i915_gem_init_swizzling(dev);
 

commit 36c0cc616e518bfc2b685bed7fb3243d1242eca4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 9 14:44:26 2013 +0200

    drm/i915: clean up media reset on gm45
    
    Originally I've thought that this fixes up the reset issues on my
    gm45, but that was just a red herring due to b0rked testing.
    
    Still I much prefer writing the right values (all other fields are
    reserved) instead of potentially dragging gunk around. Hence also
    clear the register to 0 after a reset.
    
    Note that Cspec is a bit confused and doesn't explicitly say that all
    the other bits in this register are "reserved, mbz" like usually.
    Instead they're marked as "r/o, default value = 0" which semantically
    amounts to the same thing.
    
    v2: Stop claiming this fixes anything and return 0 if successful
    instead of stack garbage.
    
    v3: Pimp the commit message to explain exactly why I think the docs
    allow us to ditch the rmw cycle, spurred by a discussion with Chris.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 33cb97388fc9..ed9262c42b7b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -798,28 +798,29 @@ static int i965_reset_complete(struct drm_device *dev)
 static int i965_do_reset(struct drm_device *dev)
 {
 	int ret;
-	u8 gdrst;
 
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit
 	 * triggers the reset; when done, the hardware will clear it.
 	 */
-	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
 	pci_write_config_byte(dev->pdev, I965_GDRST,
-			      gdrst | GRDOM_RENDER |
-			      GRDOM_RESET_ENABLE);
+			      GRDOM_RENDER | GRDOM_RESET_ENABLE);
 	ret =  wait_for(i965_reset_complete(dev), 500);
 	if (ret)
 		return ret;
 
 	/* We can't reset render&media without also resetting display ... */
-	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
 	pci_write_config_byte(dev->pdev, I965_GDRST,
-			      gdrst | GRDOM_MEDIA |
-			      GRDOM_RESET_ENABLE);
+			      GRDOM_MEDIA | GRDOM_RESET_ENABLE);
 
-	return wait_for(i965_reset_complete(dev), 500);
+	ret =  wait_for(i965_reset_complete(dev), 500);
+	if (ret)
+		return ret;
+
+	pci_write_config_byte(dev->pdev, I965_GDRST, 0);
+
+	return 0;
 }
 
 static int ironlake_do_reset(struct drm_device *dev)

commit bf51d5e2cda5d36d98e4b46ac7fca9461e512c41
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Wed Jul 3 17:12:13 2013 -0300

    drm/i915: switch disable_power_well default value to 1
    
    Now that the audio driver is using our power well API, everything
    should be working correctly, so let's give it a try.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 062cbda1bf4a..f4af1ca0fb62 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -123,10 +123,10 @@ module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 060
 MODULE_PARM_DESC(preliminary_hw_support,
 		"Enable preliminary hardware support. (default: false)");
 
-int i915_disable_power_well __read_mostly = 0;
+int i915_disable_power_well __read_mostly = 1;
 module_param_named(disable_power_well, i915_disable_power_well, int, 0600);
 MODULE_PARM_DESC(disable_power_well,
-		 "Disable the power well when possible (default: false)");
+		 "Disable the power well when possible (default: true)");
 
 int i915_enable_ips __read_mostly = 1;
 module_param_named(enable_ips, i915_enable_ips, int, 0600);

commit 2385bdf0787aef45ee1847b8508a417433da7e14
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jun 26 01:38:15 2013 +0300

    drm/i915: add fastboot param for fast & loose mode setting
    
    Handling all the state properly for fastboot is still not yet done by
    far, but we need some way to be able to test what we currently have.
    So hide the not-yet-quite-complete stuff behind a module option.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: Add a real commit message.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 062cbda1bf4a..33cb97388fc9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -132,6 +132,11 @@ int i915_enable_ips __read_mostly = 1;
 module_param_named(enable_ips, i915_enable_ips, int, 0600);
 MODULE_PARM_DESC(enable_ips, "Enable IPS (default: true)");
 
+bool i915_fastboot __read_mostly = 0;
+module_param_named(fastboot, i915_fastboot, bool, 0600);
+MODULE_PARM_DESC(fastboot, "Try to skip unnecessary mode sets at boot time "
+		 "(default: false)");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 

commit 6a9c4b35e6696a63805b6da5e4889c6986e9ee1b
Author: Rui Guo <firemeteor@users.sourceforge.net>
Date:   Wed Jun 19 21:10:23 2013 +0800

    drm/i915: Fix PCH detect with multiple ISA bridges in VM
    
    In some virtualized environments (e.g. XEN), there is irrelevant ISA bridge in
    the system. To work reliably, we should scan trhough all the ISA bridge
    devices and check for the first match, instead of only checking the first one.
    
    Signed-off-by: Rui Guo <firemeteor@users.sourceforge.net>
    [danvet: Fixup conflict with the num_pch_pll removal. And add
    subsystem header to the commit message headline.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index deaa32e8113b..062cbda1bf4a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -465,9 +465,15 @@ void intel_detect_pch(struct drm_device *dev)
 	 * make graphics device passthrough work easy for VMM, that only
 	 * need to expose ISA bridge to let driver know the real hardware
 	 * underneath. This is a requirement from virtualization team.
+	 *
+	 * In some virtualized environments (e.g. XEN), there is irrelevant
+	 * ISA bridge in the system. To work reliably, we should scan trhough
+	 * all the ISA bridge devices and check for the first match, instead
+	 * of only checking the first one.
 	 */
 	pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL);
-	if (pch) {
+	while (pch) {
+		struct pci_dev *curr = pch;
 		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
 			unsigned short id;
 			id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
@@ -496,10 +502,18 @@ void intel_detect_pch(struct drm_device *dev)
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
+			} else {
+				goto check_next;
 			}
+			pci_dev_put(pch);
+			break;
 		}
-		pci_dev_put(pch);
+check_next:
+		pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, curr);
+		pci_dev_put(curr);
 	}
+	if (!pch)
+		DRM_DEBUG_KMS("No PCH found?\n");
 }
 
 bool i915_semaphore_is_enabled(struct drm_device *dev)

commit 28419261b09aa3a5118647b1ed93809ca97c5354
Merge: 4a009085978d 854c94a7854a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 28 09:50:34 2013 +1000

    Merge tag 'drm-intel-next-2013-06-18' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Last 3.11 feature pull. I have a few odds bits and pieces and fixes in my
    queue, I'll sort them out later on to see what's for 3.11-fixes and what's
    for 3.12. But nothing to hold this here up imo.
    
    Highlights:
    - more hangcheck work from Mika and Chris to prepare for arb robustness
    - trickle feed fixes from Ville
    - first parts of the shared pch pll rework, with some basic hw state
      readout and cross-checking (this shuts up the confused pch pll refcount
      WARN that Linus just recently forwarded)
    - Haswell audio power well support from Wang Xingchao (alsa bits acked by
      Takashi)
    - some cleanups and asserts sprinkling around the plane/gamma enabling
      sequence from Ville
    - more gtt refactoring from Ben
    - clear up the adjusted->mode vs. pixel clock vs. port clock confusion
    - 30bpp support, this time for real hopefully
    
    * tag 'drm-intel-next-2013-06-18' of git://people.freedesktop.org/~danvet/drm-intel: (97 commits)
      drm/i915: remove a superflous semi-colon
      drm/i915: Kill useless "Enable panel fitter" comments
      drm/i915: Remove extra "ring" from error message
      drm/i915: simplify the reduced clock handling for pch plls
      drm/i915: stop killing pfit on i9xx
      drm/i915: explicitly set up PIPECONF (and gamma table) on haswell
      drm/i915: set up PIPECONF explicitly for i9xx/vlv platforms
      drm/i915: set up PIPECONF explicitly on ilk-ivb
      drm/i915: find guilty batch buffer on ring resets
      drm/i915: store ring hangcheck action
      drm/i915: add batch bo to i915_add_request()
      drm/i915: change i915_add_request to macro
      drm/i915: add i915_gem_context_get_hang_stats()
      drm/i915: add struct i915_ctx_hang_stats
      drm/i915: Try harder to disable trickle feed on VLV
      drm/i915: fix up pch pll enabling for pixel multipliers
      drm/i915: hw state readout and cross-checking for shared dplls
      drm/i915: WARN on lack of shared dpll
      drm/i915: split up intel_modeset_check_state
      drm/i915: extract readout_hw_state from setup_hw_state
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_fb.c
            drivers/gpu/drm/i915/intel_sdvo.c

commit e6dfcc5303d5d31cb36e36405acd766c8ed2c923
Merge: 9bc3cd5673d8 92d44621ad2d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jun 11 08:38:56 2013 +1000

    Merge tag 'drm-intel-next-2013-06-01' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    Another round of drm-intel-next for 3.11. Highlights:
    - Haswell IPS support (Paulo Zanoni)
    - VECS support on Haswell (Ben Widawsky, Xiang Haihao, ...)
    - Haswell watermark fixes (Paulo Zanoni)
    - "Make the gun bigger again" multithread fence fix from Chris.
    - i915_error_state finnally no longer fails with -ENOMEM! Big thanks to
      Mika for tackling this.
    - vlv sideband locking fixes from Jani
    - Hangcheck prep work for arb_robustness support (Mika&Chris)
    - edp vs cpu port confusion clean-up from Imre
    - pile of smaller fixes and cleanups all over.
    
    * tag 'drm-intel-next-2013-06-01' of git://people.freedesktop.org/~danvet/drm-intel: (70 commits)
      drm/i915: add i915_ips_status debugfs entry
      drm/i915: add enable_ips module option
      drm/i915: implement IPS feature
      drm/i915: fix up the edp power well check
      drm/i915: add I915_PARAM_HAS_VEBOX to i915_getparam
      drm/i915: add I915_EXEC_VEBOX to i915_gem_do_execbuffer()
      drm/i915: add VEBOX into debugfs
      drm/i915: Enable vebox interrupts
      drm/i915: vebox interrupt get/put
      drm/i915: consolidate interrupt naming scheme
      drm/i915: Convert irq_refounct to struct
      drm/i915: make PM interrupt writes non-destructive
      drm/i915: Add PM regs to pre/post install
      drm/i915: Create an ivybridge_irq_preinstall
      drm/i915: Create a more generic pm handler for hsw+
      drm/i915: add support for 5/6 data buffer partitioning on Haswell
      drm/i915: properly set HSW WM_LP watermarks
      drm/i915: properly set HSW WM_PIPE registers
      drm/i915: fix pch_nop support
      drm/i915: Vebox ringbuffer init
      ...

commit 7c74ade1de5b5311e7c886de27aa54e3285bd220
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 5 13:34:11 2013 +0200

    drm/i915: consolidate ->num_shared_dplls assignement
    
    In the future this won't be just for pch plls, so move it into the
    shared dpll init code.
    
    v2: Bikeshed the uncessary {} away while applying to appease
    checkpatch.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b0a4e6834c1d..c3e4f2915e5b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -433,7 +433,6 @@ void intel_detect_pch(struct drm_device *dev)
 	 */
 	if (INTEL_INFO(dev)->num_pipes == 0) {
 		dev_priv->pch_type = PCH_NOP;
-		dev_priv->num_shared_dpll = 0;
 		return;
 	}
 
@@ -452,34 +451,28 @@ void intel_detect_pch(struct drm_device *dev)
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_IBX;
-				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
 				WARN_ON(!IS_GEN5(dev));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
-				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
-				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
-				dev_priv->num_shared_dpll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(IS_ULT(dev));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
-				dev_priv->num_shared_dpll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
 			}
-			BUG_ON(dev_priv->num_shared_dpll > I915_NUM_PLLS);
 		}
 		pci_dev_put(pch);
 	}

commit e72f9fbf99c4277b2ccfd4d55d66aa6caf922f42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 5 13:34:06 2013 +0200

    drm/i915: s/pch_pll/shared_dpll/
    
    For fastboot we need some support to read out the sharing state of
    plls, at least for platforms where they can be shared (or freely
    assigned at least). Now for ivb we already have pretty extensive
    infrastructure for tracking pch plls, and it took us an aweful lot of
    tries to get that remotely right. Note that hsw could also share plls,
    but even now they're already freely assignable. So we need this on
    more than just ivb.
    
    So on top of the usual fastboot fun pll sharing seems to be an
    additional step up in fragility. Hence a common infrastructure for all
    shared/freely assignable display plls seems to be in order.
    
    The plan is to have a bit of dpll hw state readout code, which can be
    used individually, but also to fill in the pipe config. The hw state
    cross check code will then use that information to make sure that
    after every modeset every pipe still is connected to a pll which still
    has the correct configuration - a lot of the pch pll sharing bugs
    where due to incorrect sharing.
    
    We start this endeavour with a simple s/pch_pll/shared_dpll/ rename
    job.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 381c9dd4ab60..b0a4e6834c1d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -433,7 +433,7 @@ void intel_detect_pch(struct drm_device *dev)
 	 */
 	if (INTEL_INFO(dev)->num_pipes == 0) {
 		dev_priv->pch_type = PCH_NOP;
-		dev_priv->num_pch_pll = 0;
+		dev_priv->num_shared_dpll = 0;
 		return;
 	}
 
@@ -452,34 +452,34 @@ void intel_detect_pch(struct drm_device *dev)
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_IBX;
-				dev_priv->num_pch_pll = 2;
+				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
 				WARN_ON(!IS_GEN5(dev));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
-				dev_priv->num_pch_pll = 2;
+				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
-				dev_priv->num_pch_pll = 2;
+				dev_priv->num_shared_dpll = 2;
 				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
 				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
-				dev_priv->num_pch_pll = 0;
+				dev_priv->num_shared_dpll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(IS_ULT(dev));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
-				dev_priv->num_pch_pll = 0;
+				dev_priv->num_shared_dpll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
 				WARN_ON(!IS_ULT(dev));
 			}
-			BUG_ON(dev_priv->num_pch_pll > I915_NUM_PLLS);
+			BUG_ON(dev_priv->num_shared_dpll > I915_NUM_PLLS);
 		}
 		pci_dev_put(pch);
 	}

commit b6f3eff7130bbdb3d3ca5b7bbff2384b362606b4
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Jun 10 15:48:09 2013 +0100

    drm/i915: Use FBINFO_STATE defines instead of 0 and 1
    
    This makes, arguably, the condition on state easier to read.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b23cd63b9fda..381c9dd4ab60 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -546,7 +546,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	intel_opregion_fini(dev);
 
 	console_lock();
-	intel_fbdev_set_suspend(dev, 1);
+	intel_fbdev_set_suspend(dev, FBINFO_STATE_SUSPENDED);
 	console_unlock();
 
 	return 0;
@@ -590,7 +590,7 @@ void intel_console_resume(struct work_struct *work)
 	struct drm_device *dev = dev_priv->dev;
 
 	console_lock();
-	intel_fbdev_set_suspend(dev, 0);
+	intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING);
 	console_unlock();
 }
 
@@ -659,7 +659,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 	 * path of resume if possible.
 	 */
 	if (console_trylock()) {
-		intel_fbdev_set_suspend(dev, 0);
+		intel_fbdev_set_suspend(dev, FBINFO_STATE_RUNNING);
 		console_unlock();
 	} else {
 		schedule_work(&dev_priv->console_resume_work);

commit 3c4ca58c12a3bf71433425df534dfbb85d8a5dc5
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri May 31 16:33:23 2013 -0300

    drm/i915: add enable_ips module option
    
    IPS is still enabled by default. Feature requested by the power
    management team.
    
    This should also help testing the feature on some early pre-production
    hardware where there were relationship problems between IPS and PSR.
    
    v2: Rebase on top of the newest IPS implementation.
    v3: Check i915_enable_ips at compute_config, not supports_ips, so the
        kernel parameter will be ignored at haswell_get_pipe_config.
    
    Requested-by: Kristen Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a4e8f16a38e8..b23cd63b9fda 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -128,6 +128,10 @@ module_param_named(disable_power_well, i915_disable_power_well, int, 0600);
 MODULE_PARM_DESC(disable_power_well,
 		 "Disable the power well when possible (default: false)");
 
+int i915_enable_ips __read_mostly = 1;
+module_param_named(enable_ips, i915_enable_ips, int, 0600);
+MODULE_PARM_DESC(enable_ips, "Enable IPS (default: true)");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 

commit f72a1183b31cd1bebf926f904c1f025a90d153a1
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Tue May 28 19:22:22 2013 -0700

    drm/i915: add HAS_VEBOX
    
    The flag will be useful to help share code between IVB, and HSW as the
    programming is similar in many places with this as one of the major
    differences.
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    [Commit message + small fix by]
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index af224501b4ec..a4e8f16a38e8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -311,6 +311,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.is_haswell = 1,
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
+	.has_vebox_ring = 1,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -320,6 +321,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
 	.has_fbc = 1,
+	.has_vebox_ring = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit 2e7c8ee7a6bf3440478120f14cbf597d416f88b2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 28 10:38:44 2013 +0100

    drm/i915: Avoid promoting a simulated hang to 'wedged'
    
    It appears that a beneficial side-effect of Mika's more accurate hangman
    work is to speed up hang detection and execution. This exposes a bug in
    the reset code that then treats repeated simulated hangs as an
    indication that the machine is wedged. Jiggle the code around so that we
    only do the simulation processing from the hangcheck and avoid confusing
    it with a real hang.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=65060
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a1a936fd34e0..af224501b4ec 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -839,37 +839,14 @@ static int gen6_do_reset(struct drm_device *dev)
 
 int intel_gpu_reset(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret = -ENODEV;
-
 	switch (INTEL_INFO(dev)->gen) {
 	case 7:
-	case 6:
-		ret = gen6_do_reset(dev);
-		break;
-	case 5:
-		ret = ironlake_do_reset(dev);
-		break;
-	case 4:
-		ret = i965_do_reset(dev);
-		break;
-	case 2:
-		ret = i8xx_do_reset(dev);
-		break;
-	}
-
-	/* Also reset the gpu hangman. */
-	if (dev_priv->gpu_error.stop_rings) {
-		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
-		dev_priv->gpu_error.stop_rings = 0;
-		if (ret == -ENODEV) {
-			DRM_ERROR("Reset not implemented, but ignoring "
-				  "error for simulated gpu hangs\n");
-			ret = 0;
-		}
+	case 6: return gen6_do_reset(dev);
+	case 5: return ironlake_do_reset(dev);
+	case 4: return i965_do_reset(dev);
+	case 2: return i8xx_do_reset(dev);
+	default: return -ENODEV;
 	}
-
-	return ret;
 }
 
 /**
@@ -890,6 +867,7 @@ int intel_gpu_reset(struct drm_device *dev)
 int i915_reset(struct drm_device *dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
+	bool simulated;
 	int ret;
 
 	if (!i915_try_reset)
@@ -899,13 +877,26 @@ int i915_reset(struct drm_device *dev)
 
 	i915_gem_reset(dev);
 
-	ret = -ENODEV;
-	if (get_seconds() - dev_priv->gpu_error.last_reset < 5)
+	simulated = dev_priv->gpu_error.stop_rings != 0;
+
+	if (!simulated && get_seconds() - dev_priv->gpu_error.last_reset < 5) {
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
-	else
+		ret = -ENODEV;
+	} else {
 		ret = intel_gpu_reset(dev);
 
-	dev_priv->gpu_error.last_reset = get_seconds();
+		/* Also reset the gpu hangman. */
+		if (simulated) {
+			DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
+			dev_priv->gpu_error.stop_rings = 0;
+			if (ret == -ENODEV) {
+				DRM_ERROR("Reset not implemented, but ignoring "
+					  "error for simulated gpu hangs\n");
+				ret = 0;
+			}
+		} else
+			dev_priv->gpu_error.last_reset = get_seconds();
+	}
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");
 		mutex_unlock(&dev->struct_mutex);

commit e81f3d81e282a156b47c1c2c09a1976e34073060
Merge: 970fa986fadb e1b73cba13a0
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 31 12:56:05 2013 +1000

    Merge tag 'drm-intel-next-2013-05-20-merged' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    Highlights (copy-pasted from my testing cycle mails):
    - fbc support for Haswell (Rodrigo)
    - streamlined workaround comments, including an igt tool to grep for
      them (Damien)
    - sdvo and TV out cleanups, including a fixup for sdvo multifunction devices
    - refactor our eDP mess a bit (Imre)
    - don't register the hdmi connector on haswell when desktop eDP is present
    - vlv support is no longer preliminary!
    - more vlv fixes from Jesse for stolen and dpll handling
    - more flexible power well checking infrastructure from Paulo
    - a few gtt patches from Ben
    - a bit of OCD cleanups for transcoder #defines and an assorted pile
      of smaller things.
    - fixes for the gmch modeset sequence
    - a bit of OCD around plane/pipe usage (Ville)
    - vlv turbo support (Jesse)
    - tons of vlv modeset fixes (Jesse et al.)
    - vlv pte write fixes (Kenneth Graunke)
    - hpd filtering to avoid costly probes on unaffected outputs (Egbert Eich)
    - intel dev_info cleanups and refactorings (Damien)
    - vlv rc6 support (Jesse)
    - random pile of fixes around non-24bpp modes handling
    - asle/opregion cleanups and locking fixes (Jani)
    - dp dpll refactoring
    - improvements for reduced_clock computation on g4x/ilk+
    - pfit state refactored to use pipe_config (Jesse)
    - lots more computed modeset state moved to pipe_config, including readout
      and cross-check support
    - fdi auto-dithering for ivb B/C links, using the neat pipe_config
      improvements
    - drm_rect helpers plus sprite clipping fixes (Ville)
    - hw context refcounting (Mika + Ben)
    
    * tag 'drm-intel-next-2013-05-20-merged' of git://people.freedesktop.org/~danvet/drm-intel: (155 commits)
      drm/i915: add support for dvo Chrontel 7010B
      drm/i915: Use pipe config state to control gmch pfit enable/disable
      drm/i915: Use pipe_config state to disable ilk+ pfit
      drm/i915: panel fitter hw state readout&check support
      drm/i915: implement WADPOClockGatingDisable for LPT
      drm/i915: Add missing platform tags to FBC workaround comments
      drm/i915: rip out an unused lvds_reg variable
      drm/i915: Compute WR PLL dividers dynamically
      drm/i915: HSW FBC WaFbcDisableDpfcClockGating
      drm/i915: HSW FBC WaFbcAsynchFlipDisableFbcQueue
      drm/i915: Enable FBC at Haswell.
      drm/i915: IVB FBC WaFbcDisableDpfcClockGating
      drm/i915: IVB FBC WaFbcAsynchFlipDisableFbcQueue
      drm/i915: Add support for FBC on Ivybridge.
      drm/i915: Organize VBT stuff inside drm_i915_private
      drm/i915: make SDVO TV-out work for multifunction devices
      drm/i915: rip out now unused is_foo tracking from crtc code
      drm/i915: rip out TV-out lore ...
      drm/i915: drop TVclock special casing on ilk+
      drm/i915: move sdvo TV clock computation to intel_sdvo.c
      ...

commit 1c98b4871cca4b7ce07e19f92f934d47cf7210b0
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Mon May 13 18:12:25 2013 -0300

    drm/i915: Adding more reserved PCI IDs for Haswell.
    
    At DDX commit Chris mentioned the tendency we have of finding out more
    PCI IDs only when users report. So Let's add all new reserved Haswell IDs.
    
    This patch also fix GT3 names. I'no not sending in separated patche because
    names are only in few comments and not in variable names.
    
    v2: Fix some mobile ids (by Paulo)
    
    References: http://bugs.freedesktop.org/show_bug.cgi?id=63701
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9ebe895c17d6..a2e4953b8e8d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -364,40 +364,64 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
 	INTEL_VGA_DEVICE(0x0402, &intel_haswell_d_info), /* GT1 desktop */
 	INTEL_VGA_DEVICE(0x0412, &intel_haswell_d_info), /* GT2 desktop */
-	INTEL_VGA_DEVICE(0x0422, &intel_haswell_d_info), /* GT2 desktop */
+	INTEL_VGA_DEVICE(0x0422, &intel_haswell_d_info), /* GT3 desktop */
 	INTEL_VGA_DEVICE(0x040a, &intel_haswell_d_info), /* GT1 server */
 	INTEL_VGA_DEVICE(0x041a, &intel_haswell_d_info), /* GT2 server */
-	INTEL_VGA_DEVICE(0x042a, &intel_haswell_d_info), /* GT2 server */
+	INTEL_VGA_DEVICE(0x042a, &intel_haswell_d_info), /* GT3 server */
 	INTEL_VGA_DEVICE(0x0406, &intel_haswell_m_info), /* GT1 mobile */
 	INTEL_VGA_DEVICE(0x0416, &intel_haswell_m_info), /* GT2 mobile */
 	INTEL_VGA_DEVICE(0x0426, &intel_haswell_m_info), /* GT2 mobile */
+	INTEL_VGA_DEVICE(0x040B, &intel_haswell_d_info), /* GT1 reserved */
+	INTEL_VGA_DEVICE(0x041B, &intel_haswell_d_info), /* GT2 reserved */
+	INTEL_VGA_DEVICE(0x042B, &intel_haswell_d_info), /* GT3 reserved */
+	INTEL_VGA_DEVICE(0x040E, &intel_haswell_d_info), /* GT1 reserved */
+	INTEL_VGA_DEVICE(0x041E, &intel_haswell_d_info), /* GT2 reserved */
+	INTEL_VGA_DEVICE(0x042E, &intel_haswell_d_info), /* GT3 reserved */
 	INTEL_VGA_DEVICE(0x0C02, &intel_haswell_d_info), /* SDV GT1 desktop */
 	INTEL_VGA_DEVICE(0x0C12, &intel_haswell_d_info), /* SDV GT2 desktop */
-	INTEL_VGA_DEVICE(0x0C22, &intel_haswell_d_info), /* SDV GT2 desktop */
+	INTEL_VGA_DEVICE(0x0C22, &intel_haswell_d_info), /* SDV GT3 desktop */
 	INTEL_VGA_DEVICE(0x0C0A, &intel_haswell_d_info), /* SDV GT1 server */
 	INTEL_VGA_DEVICE(0x0C1A, &intel_haswell_d_info), /* SDV GT2 server */
-	INTEL_VGA_DEVICE(0x0C2A, &intel_haswell_d_info), /* SDV GT2 server */
+	INTEL_VGA_DEVICE(0x0C2A, &intel_haswell_d_info), /* SDV GT3 server */
 	INTEL_VGA_DEVICE(0x0C06, &intel_haswell_m_info), /* SDV GT1 mobile */
 	INTEL_VGA_DEVICE(0x0C16, &intel_haswell_m_info), /* SDV GT2 mobile */
-	INTEL_VGA_DEVICE(0x0C26, &intel_haswell_m_info), /* SDV GT2 mobile */
+	INTEL_VGA_DEVICE(0x0C26, &intel_haswell_m_info), /* SDV GT3 mobile */
+	INTEL_VGA_DEVICE(0x0C0B, &intel_haswell_d_info), /* SDV GT1 reserved */
+	INTEL_VGA_DEVICE(0x0C1B, &intel_haswell_d_info), /* SDV GT2 reserved */
+	INTEL_VGA_DEVICE(0x0C2B, &intel_haswell_d_info), /* SDV GT3 reserved */
+	INTEL_VGA_DEVICE(0x0C0E, &intel_haswell_d_info), /* SDV GT1 reserved */
+	INTEL_VGA_DEVICE(0x0C1E, &intel_haswell_d_info), /* SDV GT2 reserved */
+	INTEL_VGA_DEVICE(0x0C2E, &intel_haswell_d_info), /* SDV GT3 reserved */
 	INTEL_VGA_DEVICE(0x0A02, &intel_haswell_d_info), /* ULT GT1 desktop */
 	INTEL_VGA_DEVICE(0x0A12, &intel_haswell_d_info), /* ULT GT2 desktop */
-	INTEL_VGA_DEVICE(0x0A22, &intel_haswell_d_info), /* ULT GT2 desktop */
+	INTEL_VGA_DEVICE(0x0A22, &intel_haswell_d_info), /* ULT GT3 desktop */
 	INTEL_VGA_DEVICE(0x0A0A, &intel_haswell_d_info), /* ULT GT1 server */
 	INTEL_VGA_DEVICE(0x0A1A, &intel_haswell_d_info), /* ULT GT2 server */
-	INTEL_VGA_DEVICE(0x0A2A, &intel_haswell_d_info), /* ULT GT2 server */
+	INTEL_VGA_DEVICE(0x0A2A, &intel_haswell_d_info), /* ULT GT3 server */
 	INTEL_VGA_DEVICE(0x0A06, &intel_haswell_m_info), /* ULT GT1 mobile */
 	INTEL_VGA_DEVICE(0x0A16, &intel_haswell_m_info), /* ULT GT2 mobile */
-	INTEL_VGA_DEVICE(0x0A26, &intel_haswell_m_info), /* ULT GT2 mobile */
+	INTEL_VGA_DEVICE(0x0A26, &intel_haswell_m_info), /* ULT GT3 mobile */
+	INTEL_VGA_DEVICE(0x0A0B, &intel_haswell_d_info), /* ULT GT1 reserved */
+	INTEL_VGA_DEVICE(0x0A1B, &intel_haswell_d_info), /* ULT GT2 reserved */
+	INTEL_VGA_DEVICE(0x0A2B, &intel_haswell_d_info), /* ULT GT3 reserved */
+	INTEL_VGA_DEVICE(0x0A0E, &intel_haswell_m_info), /* ULT GT1 reserved */
+	INTEL_VGA_DEVICE(0x0A1E, &intel_haswell_m_info), /* ULT GT2 reserved */
+	INTEL_VGA_DEVICE(0x0A2E, &intel_haswell_m_info), /* ULT GT3 reserved */
 	INTEL_VGA_DEVICE(0x0D02, &intel_haswell_d_info), /* CRW GT1 desktop */
 	INTEL_VGA_DEVICE(0x0D12, &intel_haswell_d_info), /* CRW GT2 desktop */
-	INTEL_VGA_DEVICE(0x0D22, &intel_haswell_d_info), /* CRW GT2 desktop */
+	INTEL_VGA_DEVICE(0x0D22, &intel_haswell_d_info), /* CRW GT3 desktop */
 	INTEL_VGA_DEVICE(0x0D0A, &intel_haswell_d_info), /* CRW GT1 server */
 	INTEL_VGA_DEVICE(0x0D1A, &intel_haswell_d_info), /* CRW GT2 server */
-	INTEL_VGA_DEVICE(0x0D2A, &intel_haswell_d_info), /* CRW GT2 server */
+	INTEL_VGA_DEVICE(0x0D2A, &intel_haswell_d_info), /* CRW GT3 server */
 	INTEL_VGA_DEVICE(0x0D06, &intel_haswell_m_info), /* CRW GT1 mobile */
 	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT2 mobile */
-	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT2 mobile */
+	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT3 mobile */
+	INTEL_VGA_DEVICE(0x0D0B, &intel_haswell_d_info), /* CRW GT1 reserved */
+	INTEL_VGA_DEVICE(0x0D1B, &intel_haswell_d_info), /* CRW GT2 reserved */
+	INTEL_VGA_DEVICE(0x0D2B, &intel_haswell_d_info), /* CRW GT3 reserved */
+	INTEL_VGA_DEVICE(0x0D0E, &intel_haswell_d_info), /* CRW GT1 reserved */
+	INTEL_VGA_DEVICE(0x0D1E, &intel_haswell_d_info), /* CRW GT2 reserved */
+	INTEL_VGA_DEVICE(0x0D2E, &intel_haswell_d_info), /* CRW GT3 reserved */
 	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0f31, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0f32, &intel_valleyview_m_info),

commit 891348b2bf08d8946e0621bec49802897b28c1c4
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Mon May 6 19:37:36 2013 -0300

    drm/i915: Enable FBC at Haswell.
    
    This patch introduce Frame Buffer Compression (FBC) support for HSW.
    FBC is tied to primary plane A in HSW.
    
    v2: Ville pointed out docs say FBC must be disabled before disabling
        the plane on HSW.
    v3: Really enabling it by default at HSW.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cd84f774aace..a1a936fd34e0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -319,6 +319,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.is_mobile = 1,
 	.has_ddi = 1,
 	.has_fpga_dbg = 1,
+	.has_fbc = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit abe959c7e06f62f064432a2aa00c199f1f672c81
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Mon May 6 19:37:33 2013 -0300

    drm/i915: Add support for FBC on Ivybridge.
    
    This patch introduce Frame Buffer Compression (FBC) support for IVB,
    without enabling it by default.
    It adds a new function gen7_enable_fbc to avoid getting
    ironlake_enable_fbc messed with many IS_IVYBRIDGE checks.
    
    v2: Fixes from Ville.
            *  Fix Plane. FBC is tied to primary plane A in HSW
            *  Fix DPFC initial write to avoid let trash on the register.
    v3: Checking for bad plane on intel_update_fbc() as Chris suggested.
    v4: Ville pointed out that according to BSpec FBC_CTL bits 0:3 must be 0.
    v5: Up to v4 this work was entirely focused on Haswell. However Ville
        noticed I could reuse the FBC work done for HSW and get FBC for free
        at Ivybridge. So it makes more sense enable FBC for IVB first.
        FBC for HSW comming on next patches. We are just not enabling it by
        default on IVB.
    v6: Fix confused commit name (by Matt Turner).
    v7: Remove gtt_offset shift since it is page aligned byte offset (by Ville).
    
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3cb27fa842ee..cd84f774aace 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -280,6 +280,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	GEN7_FEATURES,
 	.is_ivybridge = 1,
 	.is_mobile = 1,
+	.has_fbc = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_q_info = {

commit 590e4df8c82e6c2707ae12ba6672ab6fb9cd4b89
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed May 8 10:45:15 2013 -0700

    drm/i915: VLV support is no longer preliminary
    
    Works pretty well actually.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 707a56ec389d..3cb27fa842ee 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -966,12 +966,6 @@ static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;
 
-	if (intel_info->is_valleyview)
-		if(!i915_preliminary_hw_support) {
-			DRM_ERROR("Preliminary hardware support disabled\n");
-			return -ENODEV;
-		}
-
 	/* Only bind to function 0 of the device. Early generations
 	 * used function 1 as a placeholder for multi-head. This causes
 	 * us confusion instead, especially on the systems where both

commit 7d708ee40a6b9ca1112a322e554c887df105b025
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Apr 17 14:04:50 2013 +0300

    drm/i915: HSW: allow PCH clock gating for suspend
    
    For the device to enter D3 we should enable PCH clock gating.
    
    v2:
    - use HAS_PCH_LPT instead of IS_HASWELL (Ville, Paolo)
    - rename lpt_allow_clock_gating to lpt_suspend_hw (Paolo)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 40b57871a0bf..707a56ec389d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -529,6 +529,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 		 */
 		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
 			dev_priv->display.crtc_disable(crtc);
+
+		intel_modeset_suspend_hw(dev);
 	}
 
 	i915_save_state(dev);

commit ecdb4eb71b8f76db2bf58c86af907e7b8ee056b0
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Fri May 3 18:48:10 2013 +0100

    drm/i915: Add platform information to implemented workarounds
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 624cdfcc1ba3..40b57871a0bf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1198,9 +1198,9 @@ MODULE_LICENSE("GPL and additional rights");
 static void
 ilk_dummy_write(struct drm_i915_private *dev_priv)
 {
-	/* WaIssueDummyWriteToWakeupFromRC6: Issue a dummy write to wake up the
-	 * chip from rc6 before touching it for real. MI_MODE is masked, hence
-	 * harmless to write 0 into. */
+	/* WaIssueDummyWriteToWakeupFromRC6:ilk Issue a dummy write to wake up
+	 * the chip from rc6 before touching it for real. MI_MODE is masked,
+	 * hence harmless to write 0 into. */
 	I915_WRITE_NOTRACE(MI_MODE, 0);
 }
 

commit 30568c45d9fc4ee0bb9e1da90e185692fcd67e38
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Apr 22 18:40:41 2013 +0100

    drm/i915: Turn HAS_FPGA_DBG_UNCLAIMED into a device_info flag
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 896b90430ba9..624cdfcc1ba3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -309,6 +309,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	GEN7_FEATURES,
 	.is_haswell = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -316,6 +317,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.is_haswell = 1,
 	.is_mobile = 1,
 	.has_ddi = 1,
+	.has_fpga_dbg = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit e76ebff887e9cc4a8448a0fc6abbb1925291f38b
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Apr 22 18:40:40 2013 +0100

    drm/i915: Introduce HAS_FPGA_DBG_UNCLAIMED()
    
    Let's introduce one more of those orthogonal feature macros. This should
    hopefully make the code more readable and make things easier for new platform
    enabling.
    
    This time, HAS_FPGA_DBG_UNCLAIMED() is true for platforms that have bit
    31 of FPGA_DBG able to signal unclaimed writes.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 564d4c65e25b..896b90430ba9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1205,7 +1205,7 @@ ilk_dummy_write(struct drm_i915_private *dev_priv)
 static void
 hsw_unclaimed_reg_clear(struct drm_i915_private *dev_priv, u32 reg)
 {
-	if (IS_HASWELL(dev_priv->dev) &&
+	if (HAS_FPGA_DBG_UNCLAIMED(dev_priv->dev) &&
 	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
 		DRM_ERROR("Unknown unclaimed register before writing to %x\n",
 			  reg);
@@ -1216,7 +1216,7 @@ hsw_unclaimed_reg_clear(struct drm_i915_private *dev_priv, u32 reg)
 static void
 hsw_unclaimed_reg_check(struct drm_i915_private *dev_priv, u32 reg)
 {
-	if (IS_HASWELL(dev_priv->dev) &&
+	if (HAS_FPGA_DBG_UNCLAIMED(dev_priv->dev) &&
 	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
 		DRM_ERROR("Unclaimed write to %x\n", reg);
 		I915_WRITE_NOTRACE(FPGA_DBG, FPGA_DBG_RM_NOCLAIM);

commit dd93be584099b157039c43c7b48eac56223ac94d
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Apr 22 18:40:39 2013 +0100

    drm/i915: Turn HAS_DDI() into a device_info flag
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9ebe895c17d6..564d4c65e25b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -308,12 +308,14 @@ static const struct intel_device_info intel_valleyview_d_info = {
 static const struct intel_device_info intel_haswell_d_info = {
 	GEN7_FEATURES,
 	.is_haswell = 1,
+	.has_ddi = 1,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
 	GEN7_FEATURES,
 	.is_haswell = 1,
 	.is_mobile = 1,
+	.has_ddi = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit 08e1413d95b50b19259fe2e425885030f93c7b85
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Apr 12 18:16:54 2013 -0300

    drm/i915: WARN when LPT-LP is not paired with ULT CPU
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c413aab6eb74..9ebe895c17d6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -459,11 +459,13 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->num_pch_pll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
+				WARN_ON(IS_ULT(dev));
 			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				dev_priv->num_pch_pll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
+				WARN_ON(!IS_ULT(dev));
 			}
 			BUG_ON(dev_priv->num_pch_pll > I915_NUM_PLLS);
 		}

commit 30ccd9644e021ae95e0f039d70b7d5ea8d9d8f3b
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Apr 15 21:48:03 2013 -0700

    drm/i915: VLV doesn't have LLC
    
    Caused by me with v2 of
    
    commit 219f4fdbed5570f1d2e8da0af1c298dd3622060e
    Author: Ben Widawsky <ben@bwidawsk.net>
    Date:   Fri Mar 15 11:17:54 2013 -0700
    
        drm/i915: Introduce GEN7_FEATURES for device info
    
    I don't have a VLV to test it with, Jesse, Ken, can one of you test?
    
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bddb9a50ea76..c413aab6eb74 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -294,6 +294,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_llc = 0, /* legal, last one wins */
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
@@ -301,6 +302,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_llc = 0, /* legal, last one wins */
 };
 
 static const struct intel_device_info intel_haswell_d_info = {

commit b7c36d25461ae41e6562a2f70cb3423bcf8af2d2
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Mon Apr 8 18:43:56 2013 -0700

    drm/i915: Allow PPGTT enable to fail
    
    I'm really not happy that we have to support this, but this will be the
    simplest way to handle cases where PPGTT init can fail, which I promise
    will be coming in the future.
    
    v2: Resolve conflicts due to patch series reordering.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 70d10de73bbd..bddb9a50ea76 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -927,8 +927,11 @@ int i915_reset(struct drm_device *dev)
 			ring->init(ring);
 
 		i915_gem_context_init(dev);
-		if (dev_priv->mm.aliasing_ppgtt)
-			dev_priv->mm.aliasing_ppgtt->enable(dev);
+		if (dev_priv->mm.aliasing_ppgtt) {
+			ret = dev_priv->mm.aliasing_ppgtt->enable(dev);
+			if (ret)
+				i915_gem_cleanup_aliasing_ppgtt(dev);
+		}
 
 		/*
 		 * It would make sense to re-init all the other hw state, at

commit 6197349bdeb97ee6f533990617c51c67ac233f79
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Mon Apr 8 18:43:54 2013 -0700

    drm/i915: Abstract PPGTT enabling
    
    Since we've already set up a nice vtable to abstract other PPGTT
    functions, also abstract the actual register programming to enable
    things.
    
    This function will probably need to change a bit as we implement real
    processes.
    
    v2: Resolve conflicts due to patch series reordering.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bd92e7d47653..70d10de73bbd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -927,7 +927,8 @@ int i915_reset(struct drm_device *dev)
 			ring->init(ring);
 
 		i915_gem_context_init(dev);
-		i915_gem_init_ppgtt(dev);
+		if (dev_priv->mm.aliasing_ppgtt)
+			dev_priv->mm.aliasing_ppgtt->enable(dev);
 
 		/*
 		 * It would make sense to re-init all the other hw state, at

commit 999bcdea3206ea8a402c010f78060cd3da4f812c
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Apr 5 13:12:45 2013 -0700

    drm/i915: Add a pipeless ivybridge configuration
    
    FIXME: This is based on some HW being used for a demo. We should
    probably wait until we have confirmation on the IDs before upstreaming
    this patch.
    
    v2: Use GEN7_FEATURES (Chris)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 88d78e39bf6d..bd92e7d47653 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -140,6 +140,16 @@ extern int intel_agp_enabled;
 	.subdevice = PCI_ANY_ID,		\
 	.driver_data = (unsigned long) info }
 
+#define INTEL_QUANTA_VGA_DEVICE(info) {		\
+	.class = PCI_BASE_CLASS_DISPLAY << 16,	\
+	.class_mask = 0xff0000,			\
+	.vendor = 0x8086,			\
+	.device = 0x16a,			\
+	.subvendor = 0x152d,			\
+	.subdevice = 0x8990,			\
+	.driver_data = (unsigned long) info }
+
+
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
@@ -272,6 +282,12 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.is_mobile = 1,
 };
 
+static const struct intel_device_info intel_ivybridge_q_info = {
+	GEN7_FEATURES,
+	.is_ivybridge = 1,
+	.num_pipes = 0, /* legal, last one wins */
+};
+
 static const struct intel_device_info intel_valleyview_m_info = {
 	GEN7_FEATURES,
 	.is_mobile = 1,
@@ -342,6 +358,7 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0152, &intel_ivybridge_d_info), /* GT1 desktop */
 	INTEL_VGA_DEVICE(0x0162, &intel_ivybridge_d_info), /* GT2 desktop */
 	INTEL_VGA_DEVICE(0x015a, &intel_ivybridge_d_info), /* GT1 server */
+	INTEL_QUANTA_VGA_DEVICE(&intel_ivybridge_q_info), /* Quanta transcode */
 	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
 	INTEL_VGA_DEVICE(0x0402, &intel_haswell_d_info), /* GT1 desktop */
 	INTEL_VGA_DEVICE(0x0412, &intel_haswell_d_info), /* GT2 desktop */

commit ce1bb329795c3efc4bfd8846ee4ef1798536307a
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Apr 5 13:12:44 2013 -0700

    drm/i915: Set PCH_NOP
    
    Set up PCH_NOP when we match a certain platform.
    
    v2: Just do a num_pipes check + comment instead of trying to check the
    platform (Daniel)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3b4b9c09a20b..88d78e39bf6d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -397,6 +397,15 @@ void intel_detect_pch(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct pci_dev *pch;
 
+	/* In all current cases, num_pipes is equivalent to the PCH_NOP setting
+	 * (which really amounts to a PCH but no South Display).
+	 */
+	if (INTEL_INFO(dev)->num_pipes == 0) {
+		dev_priv->pch_type = PCH_NOP;
+		dev_priv->num_pch_pll = 0;
+		return;
+	}
+
 	/*
 	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
 	 * make graphics device passthrough work easy for VMM, that only

commit bae3699182027525d92b97d904578a533264b242
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Apr 6 16:07:21 2013 +0200

    drm/i915: info level for simulated gpu hang dmesg notice
    
    Otherwise running igt will fill your dmesg with hang notices and it's
    hard to judge from a quick look whether they're expected or not.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a5b8aa9b319f..3b4b9c09a20b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -822,7 +822,7 @@ int intel_gpu_reset(struct drm_device *dev)
 
 	/* Also reset the gpu hangman. */
 	if (dev_priv->gpu_error.stop_rings) {
-		DRM_DEBUG("Simulated gpu hang, resetting stop_rings\n");
+		DRM_INFO("Simulated gpu hang, resetting stop_rings\n");
 		dev_priv->gpu_error.stop_rings = 0;
 		if (ret == -ENODEV) {
 			DRM_ERROR("Reset not implemented, but ignoring "

commit ecb135a1a1953d2895d149e78926be479fdc6f2c
Merge: bd6946e87a98 07961ac7c0ee
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 3 11:25:32 2013 +0200

    Merge tag 'v3.9-rc5' into drm-intel-next-queued
    
    Backmerge Linux 3.9-rc5 since I want to merge a few dp clock cleanups
    for -next, but they will conflict all over the place with
    
    commit 9d1a455b0ca1c2c956b4d9ab212864a8695270f1
    Author: Takashi Iwai <tiwai@suse.de>
    Date:   Mon Mar 18 11:25:36 2013 +0100
    
        drm/i915: Use the fixed pixel clock for eDP in intel_dp_set_m_n()
    
    from -fixes.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_dp.c: Simply adjacent lines changed.
            drivers/gpu/drm/i915/intel_panel.c: A field rename in -next
            conflicts with a bugfix in -fixes. Take the version from
            -fixes and apply the rename.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 8a5c2ae753c588bcb2a4e38d1c6a39865dbf1ff3
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Mar 28 13:57:19 2013 -0700

    drm/i915: fix ILK GPU reset for render
    
    Earlier code would leave both bits set, so any reset after the first
    would only reset media.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0cfc778aa759..1c53438cea47 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -744,6 +744,7 @@ static int ironlake_do_reset(struct drm_device *dev)
 	int ret;
 
 	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
+	gdrst &= ~GRDOM_MASK;
 	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
 		   gdrst | GRDOM_RENDER | GRDOM_RESET_ENABLE);
 	ret = wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
@@ -752,6 +753,7 @@ static int ironlake_do_reset(struct drm_device *dev)
 
 	/* We can't reset render&media without also resetting display ... */
 	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
+	gdrst &= ~GRDOM_MASK;
 	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
 		   gdrst | GRDOM_MEDIA | GRDOM_RESET_ENABLE);
 	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);

commit bb60b9695ced58768ba05b2d88fb4ee815df18f4
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Mar 26 09:25:46 2013 -0700

    drm/i915: emit a hotplug event on resume
    
    This will poke userspace into probing for configuration changes that may
    have occurred across suspend/resume.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bf57e1cc88b1..0cfc778aa759 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -545,6 +545,24 @@ void intel_console_resume(struct work_struct *work)
 	console_unlock();
 }
 
+static void intel_resume_hotplug(struct drm_device *dev)
+{
+	struct drm_mode_config *mode_config = &dev->mode_config;
+	struct intel_encoder *encoder;
+
+	mutex_lock(&mode_config->mutex);
+	DRM_DEBUG_KMS("running encoder hotplug functions\n");
+
+	list_for_each_entry(encoder, &mode_config->encoder_list, base.head)
+		if (encoder->hot_plug)
+			encoder->hot_plug(encoder);
+
+	mutex_unlock(&mode_config->mutex);
+
+	/* Just fire off a uevent and let userspace tell us what to do */
+	drm_helper_hpd_irq_event(dev);
+}
+
 static int __i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -580,6 +598,8 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		 * */
 		intel_hpd_init(dev);
 		dev_priv->enable_hotplug_processing = true;
+		/* Config may have changed between suspend and resume */
+		intel_resume_hotplug(dev);
 	}
 
 	intel_opregion_init(dev);

commit 24576d23976746cb52e7700c4cadbf4bc1bc3472
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Mar 26 09:25:45 2013 -0700

    drm/i915: enable VT switchless resume v3
    
    With the other bits in place, we can do this safely.
    
    v2: disable backlight on suspend to prevent premature enablement on resume
    v3: disable CRTCs on suspend to allow RTD3 (Kristen)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c4b13c0ee77..bf57e1cc88b1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -458,6 +458,7 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_crtc *crtc;
 
 	/* ignore lid events during suspend */
 	mutex_lock(&dev_priv->modeset_restore_lock);
@@ -481,10 +482,14 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 		cancel_delayed_work_sync(&dev_priv->rps.delayed_resume_work);
 
-		intel_modeset_disable(dev);
-
 		drm_irq_uninstall(dev);
 		dev_priv->enable_hotplug_processing = false;
+		/*
+		 * Disable CRTCs directly since we want to preserve sw state
+		 * for _thaw.
+		 */
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
+			dev_priv->display.crtc_disable(crtc);
 	}
 
 	i915_save_state(dev);
@@ -562,7 +567,10 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		drm_irq_install(dev);
 
 		intel_modeset_init_hw(dev);
-		intel_modeset_setup_hw_state(dev, false);
+
+		drm_modeset_lock_all(dev);
+		intel_modeset_setup_hw_state(dev, true);
+		drm_modeset_unlock_all(dev);
 
 		/*
 		 * ... but also need to make sure that hotplug processing

commit 2124b72e6283c4e84a55e71077fee91793f4c801
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Mar 22 14:07:23 2013 -0300

    drm/i915: don't disable the power well yet
    
    We're still not 100% ready to disable the power well, so don't disable
    it for now. When we disable it we break the audio driver (because some
    of the audio registers are on the power well) and machines with eDP on
    port D (because it doesn't use TRANSCODER_EDP).
    
    Also, instead of just reverting the code, add a Kernel option to let
    us disable it if we want. This will allow us to keep developing and
    testing the feature while it's not enabled.
    
    This fixes problems caused by the following commit:
      commit d6dd9eb1d96d2b7345fe4664066c2b7ed86da898
      Author: Daniel Vetter <daniel.vetter@ffwll.ch>
      Date:   Tue Jan 29 16:35:20 2013 -0200
           drm/i915: dynamic Haswell display power well support
    
    References: http://www.mail-archive.com/intel-gfx@lists.freedesktop.org/msg18788.html
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Mengdong Lin <mengdong.lin@intel.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0a8eceb75902..e9b57893db2b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -125,6 +125,11 @@ MODULE_PARM_DESC(preliminary_hw_support,
 		"Enable Haswell and ValleyView Support. "
 		"(default: false)");
 
+int i915_disable_power_well __read_mostly = 0;
+module_param_named(disable_power_well, i915_disable_power_well, int, 0600);
+MODULE_PARM_DESC(disable_power_well,
+		 "Disable the power well when possible (default: false)");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 

commit 219f4fdbed5570f1d2e8da0af1c298dd3622060e
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Mar 15 11:17:54 2013 -0700

    drm/i915: Introduce GEN7_FEATURES for device info
    
    Recommended by Chris.
    
    v2: Make it GEN7_FEATURES, and use it for vlv and hsw also (Ben)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 788ae5bd1bfe..6c4b13c0ee77 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -248,63 +248,49 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_force_wake = 1,
 };
 
+#define GEN7_FEATURES  \
+	.gen = 7, .num_pipes = 3, \
+	.need_gfx_hws = 1, .has_hotplug = 1, \
+	.has_bsd_ring = 1, \
+	.has_blt_ring = 1, \
+	.has_llc = 1, \
+	.has_force_wake = 1
+
 static const struct intel_device_info intel_ivybridge_d_info = {
-	.is_ivybridge = 1, .gen = 7, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
-	.has_llc = 1,
-	.has_force_wake = 1,
+	GEN7_FEATURES,
+	.is_ivybridge = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
-	.is_ivybridge = 1, .gen = 7, .is_mobile = 1, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 0,	/* FBC is not enabled on Ivybridge mobile yet */
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
-	.has_llc = 1,
-	.has_force_wake = 1,
+	GEN7_FEATURES,
+	.is_ivybridge = 1,
+	.is_mobile = 1,
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {
-	.gen = 7, .is_mobile = 1, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 0,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
+	GEN7_FEATURES,
+	.is_mobile = 1,
+	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
-	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
-	.gen = 7, .num_pipes = 2,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 0,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
+	GEN7_FEATURES,
+	.num_pipes = 2,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
-	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_haswell_d_info = {
-	.is_haswell = 1, .gen = 7, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
-	.has_llc = 1,
-	.has_force_wake = 1,
+	GEN7_FEATURES,
+	.is_haswell = 1,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
-	.is_haswell = 1, .gen = 7, .is_mobile = 1, .num_pipes = 3,
-	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_bsd_ring = 1,
-	.has_blt_ring = 1,
-	.has_llc = 1,
-	.has_force_wake = 1,
+	GEN7_FEATURES,
+	.is_haswell = 1,
+	.is_mobile = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit 7eb552aeae058a88eece91b902dd51fde45b1f41
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Wed Mar 13 14:05:41 2013 -0700

    drm/i915: Move num_pipes to intel info
    
    Requested by Daniel.
    
    v2: Fix incorrect num_pipe settings. (Chris)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2e4b4a3a77d2..788ae5bd1bfe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -136,74 +136,74 @@ extern int intel_agp_enabled;
 	.driver_data = (unsigned long) info }
 
 static const struct intel_device_info intel_i830_info = {
-	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1,
+	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_845g_info = {
-	.gen = 2,
+	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i85x_info = {
-	.gen = 2, .is_i85x = 1, .is_mobile = 1,
+	.gen = 2, .is_i85x = 1, .is_mobile = 1, .num_pipes = 2,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i865g_info = {
-	.gen = 2,
+	.gen = 2, .num_pipes = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i915g_info = {
-	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1,
+	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i915gm_info = {
-	.gen = 3, .is_mobile = 1,
+	.gen = 3, .is_mobile = 1, .num_pipes = 2,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
 };
 static const struct intel_device_info intel_i945g_info = {
-	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1,
+	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1, .num_pipes = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945gm_info = {
-	.gen = 3, .is_i945gm = 1, .is_mobile = 1,
+	.gen = 3, .is_i945gm = 1, .is_mobile = 1, .num_pipes = 2,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 	.supports_tv = 1,
 };
 
 static const struct intel_device_info intel_i965g_info = {
-	.gen = 4, .is_broadwater = 1,
+	.gen = 4, .is_broadwater = 1, .num_pipes = 2,
 	.has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
-	.gen = 4, .is_crestline = 1,
+	.gen = 4, .is_crestline = 1, .num_pipes = 2,
 	.is_mobile = 1, .has_fbc = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 	.supports_tv = 1,
 };
 
 static const struct intel_device_info intel_g33_info = {
-	.gen = 3, .is_g33 = 1,
+	.gen = 3, .is_g33 = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_g45_info = {
-	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1,
+	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1, .num_pipes = 2,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_gm45_info = {
-	.gen = 4, .is_g4x = 1,
+	.gen = 4, .is_g4x = 1, .num_pipes = 2,
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.supports_tv = 1,
@@ -211,26 +211,26 @@ static const struct intel_device_info intel_gm45_info = {
 };
 
 static const struct intel_device_info intel_pineview_info = {
-	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1,
+	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
-	.gen = 5,
+	.gen = 5, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
-	.gen = 5, .is_mobile = 1,
+	.gen = 5, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
 	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
-	.gen = 6,
+	.gen = 6, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
@@ -239,7 +239,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
-	.gen = 6, .is_mobile = 1,
+	.gen = 6, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
 	.has_bsd_ring = 1,
@@ -249,7 +249,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 };
 
 static const struct intel_device_info intel_ivybridge_d_info = {
-	.is_ivybridge = 1, .gen = 7,
+	.is_ivybridge = 1, .gen = 7, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
@@ -258,7 +258,7 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
-	.is_ivybridge = 1, .gen = 7, .is_mobile = 1,
+	.is_ivybridge = 1, .gen = 7, .is_mobile = 1, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 0,	/* FBC is not enabled on Ivybridge mobile yet */
 	.has_bsd_ring = 1,
@@ -268,7 +268,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {
-	.gen = 7, .is_mobile = 1,
+	.gen = 7, .is_mobile = 1, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 0,
 	.has_bsd_ring = 1,
@@ -279,7 +279,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
-	.gen = 7,
+	.gen = 7, .num_pipes = 2,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 0,
 	.has_bsd_ring = 1,
@@ -290,7 +290,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 };
 
 static const struct intel_device_info intel_haswell_d_info = {
-	.is_haswell = 1, .gen = 7,
+	.is_haswell = 1, .gen = 7, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
@@ -299,7 +299,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
-	.is_haswell = 1, .gen = 7, .is_mobile = 1,
+	.is_haswell = 1, .gen = 7, .is_mobile = 1, .num_pipes = 3,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,

commit d7fee5f6faea17b6e702eba90037ab8f716faf8e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Mar 8 10:45:50 2013 -0800

    drm/i915: add more VLV IDs
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index db3099845877..2e4b4a3a77d2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -389,6 +389,9 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT2 mobile */
 	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT2 mobile */
 	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
+	INTEL_VGA_DEVICE(0x0f31, &intel_valleyview_m_info),
+	INTEL_VGA_DEVICE(0x0f32, &intel_valleyview_m_info),
+	INTEL_VGA_DEVICE(0x0f33, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0157, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0155, &intel_valleyview_d_info),
 	{0, 0, 0}

commit 0d4a42f6bd298e826620585e766a154ab460617a
Merge: d62b4892f3d9 a937536b868b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 19 09:47:30 2013 +0100

    Merge tag 'v3.9-rc3' into drm-intel-next-queued
    
    Backmerge so that I can merge Imre Deak's coalesced sg entries fixes,
    which depend upon the new for_each_sg_page introduce in
    
    commit a321e91b6d73ed011ffceed384c40d2785cf723b
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Feb 27 17:02:56 2013 -0800
    
        lib/scatterlist: add simple page iterator
    
    The merge itself is just two trivial conflicts:
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 248ee3a803bf5754b86aef6af8d2a8f8104c8215
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Mar 1 13:14:13 2013 -0800

    drm/i915: VLV has force wake
    
    This was omitted from
    
    commit b7884eb45ec98c0d34c7f49005ae9d4b4b4e38f6
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Mon Jun 4 11:18:15 2012 +0200
    
        drm/i915: hold forcewake around ring hw init
    
    which introduced the ->has_force_wake flag.
    
    Note that this only enables the above w/a hack.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: Put some interesting stuff into the empty commit message.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b342749fcc87..1ebed9670ab9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -275,6 +275,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.has_blt_ring = 1,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
@@ -285,6 +286,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.has_blt_ring = 1,
 	.is_valleyview = 1,
 	.display_mmio_offset = VLV_DISPLAY_BASE,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_haswell_d_info = {

commit 15239099d7a7a9ecdc1ccb5b187ae4cda5488ff9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 5 09:50:58 2013 +0100

    drm/i915: enable irqs earlier when resuming
    
    We need it to restore the ilk rc6 context, since the gpu wait no
    requires interrupts. But in general having interrupts around should
    help in code sanity, since more and more stuff is interrupt driven.
    
    This regression has been introduced in
    
    commit 3e9605018ab3e333d51cc90fccfde2031886763b
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Tue Nov 27 16:22:54 2012 +0000
    
        drm/i915: Rearrange code to only have a single method for waiting upon the ring
    
    Like in the driver load code we need to make sure that hotplug
    interrupts don't cause havoc with our modeset state, hence block them
    with the existing infrastructure. Again we ignore races where we might
    loose hotplug interrupts ...
    
    Note that the driver load part of the regression has already been
    fixed in
    
    commit 52d7ecedac3f96fb562cb482c139015372728638
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Sat Dec 1 21:03:22 2012 +0100
    
        drm/i915: reorder setup sequence to have irqs for output setup
    
    v2: Add a note to the commit message about which patch fixed the
    driver load part of the regression. Stable kernels need to backport
    both patches.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=54691
    Cc: stable@vger.kernel.org (for 3.8 only, plese backport
                                52d7ecedac3f96fb5 first)
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reported-and-Tested-by: Ilya Tumaykin <itumaykin@gmail.com>
    Reviewed-by: Chris wilson <chris@chris-wilson.co.uk> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2c5ee965e473..0a8eceb75902 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -495,6 +495,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 		intel_modeset_disable(dev);
 
 		drm_irq_uninstall(dev);
+		dev_priv->enable_hotplug_processing = false;
 	}
 
 	i915_save_state(dev);
@@ -568,10 +569,20 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		error = i915_gem_init_hw(dev);
 		mutex_unlock(&dev->struct_mutex);
 
+		/* We need working interrupts for modeset enabling ... */
+		drm_irq_install(dev);
+
 		intel_modeset_init_hw(dev);
 		intel_modeset_setup_hw_state(dev, false);
-		drm_irq_install(dev);
+
+		/*
+		 * ... but also need to make sure that hotplug processing
+		 * doesn't cause havoc. Like in the driver load code we don't
+		 * bother with the tiny race here where we might loose hotplug
+		 * notifications.
+		 * */
 		intel_hpd_init(dev);
+		dev_priv->enable_hotplug_processing = true;
 	}
 
 	intel_opregion_init(dev);

commit 86c268ed0f9b3b4d51d81dd8fcec533a164414d1
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Fri Mar 1 17:00:50 2013 -0800

    drm/i915: Fix Haswell/CRW PCI IDs.
    
    The second digit was off by one, which meant we accidentally treated
    GT(n) as GT(n-1).  This also meant no support for GT1 at all.
    
    Cc: stable@kernel.org
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c5b8c81b9440..2c5ee965e473 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -379,15 +379,15 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0A06, &intel_haswell_m_info), /* ULT GT1 mobile */
 	INTEL_VGA_DEVICE(0x0A16, &intel_haswell_m_info), /* ULT GT2 mobile */
 	INTEL_VGA_DEVICE(0x0A26, &intel_haswell_m_info), /* ULT GT2 mobile */
-	INTEL_VGA_DEVICE(0x0D12, &intel_haswell_d_info), /* CRW GT1 desktop */
+	INTEL_VGA_DEVICE(0x0D02, &intel_haswell_d_info), /* CRW GT1 desktop */
+	INTEL_VGA_DEVICE(0x0D12, &intel_haswell_d_info), /* CRW GT2 desktop */
 	INTEL_VGA_DEVICE(0x0D22, &intel_haswell_d_info), /* CRW GT2 desktop */
-	INTEL_VGA_DEVICE(0x0D32, &intel_haswell_d_info), /* CRW GT2 desktop */
-	INTEL_VGA_DEVICE(0x0D1A, &intel_haswell_d_info), /* CRW GT1 server */
+	INTEL_VGA_DEVICE(0x0D0A, &intel_haswell_d_info), /* CRW GT1 server */
+	INTEL_VGA_DEVICE(0x0D1A, &intel_haswell_d_info), /* CRW GT2 server */
 	INTEL_VGA_DEVICE(0x0D2A, &intel_haswell_d_info), /* CRW GT2 server */
-	INTEL_VGA_DEVICE(0x0D3A, &intel_haswell_d_info), /* CRW GT2 server */
-	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT1 mobile */
+	INTEL_VGA_DEVICE(0x0D06, &intel_haswell_m_info), /* CRW GT1 mobile */
+	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT2 mobile */
 	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT2 mobile */
-	INTEL_VGA_DEVICE(0x0D36, &intel_haswell_m_info), /* CRW GT2 mobile */
 	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0157, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0155, &intel_valleyview_d_info),

commit 3f1e109a8be5670487e00e1c6bc0670526325227
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Feb 18 19:00:21 2013 -0300

    drm/i915: use FPGA_DBG for the "unclaimed register" checks
    
    We plan to treat GEN7_ERR_INT as an interrupt, so use this register
    for the checks inside I915_WRITE. This way we can have the best of
    both worlds: the error message with a register address and the
    
    V2: Split in 2 patches: one for the macro, one for changing the
    register, as requested by Ben.
    V3: Rebase.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 07ac769d7313..b342749fcc87 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1133,10 +1133,10 @@ static void
 hsw_unclaimed_reg_clear(struct drm_i915_private *dev_priv, u32 reg)
 {
 	if (IS_HASWELL(dev_priv->dev) &&
-	    (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) {
+	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
 		DRM_ERROR("Unknown unclaimed register before writing to %x\n",
 			  reg);
-		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED);
+		I915_WRITE_NOTRACE(FPGA_DBG, FPGA_DBG_RM_NOCLAIM);
 	}
 }
 
@@ -1144,9 +1144,9 @@ static void
 hsw_unclaimed_reg_check(struct drm_i915_private *dev_priv, u32 reg)
 {
 	if (IS_HASWELL(dev_priv->dev) &&
-	    (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) {
+	    (I915_READ_NOTRACE(FPGA_DBG) & FPGA_DBG_RM_NOCLAIM)) {
 		DRM_ERROR("Unclaimed write to %x\n", reg);
-		writel(ERR_INT_MMIO_UNCLAIMED, dev_priv->regs + GEN7_ERR_INT);
+		I915_WRITE_NOTRACE(FPGA_DBG, FPGA_DBG_RM_NOCLAIM);
 	}
 }
 

commit 115bc2de52af131c2c9bb2bda1adde88c9aa8fef
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Feb 18 19:00:20 2013 -0300

    drm/i915: create functions for the "unclaimed register" checks
    
    This avoids polluting i915_write##x and also allows us to reuse code
    on i915_read##x.
    
    v2: Rebase
    v3: Convert the macros to static functions
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 857dd2ce30aa..07ac769d7313 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1129,6 +1129,27 @@ ilk_dummy_write(struct drm_i915_private *dev_priv)
 	I915_WRITE_NOTRACE(MI_MODE, 0);
 }
 
+static void
+hsw_unclaimed_reg_clear(struct drm_i915_private *dev_priv, u32 reg)
+{
+	if (IS_HASWELL(dev_priv->dev) &&
+	    (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) {
+		DRM_ERROR("Unknown unclaimed register before writing to %x\n",
+			  reg);
+		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED);
+	}
+}
+
+static void
+hsw_unclaimed_reg_check(struct drm_i915_private *dev_priv, u32 reg)
+{
+	if (IS_HASWELL(dev_priv->dev) &&
+	    (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) {
+		DRM_ERROR("Unclaimed write to %x\n", reg);
+		writel(ERR_INT_MMIO_UNCLAIMED, dev_priv->regs + GEN7_ERR_INT);
+	}
+}
+
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \
@@ -1165,18 +1186,12 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 	} \
 	if (IS_GEN5(dev_priv->dev)) \
 		ilk_dummy_write(dev_priv); \
-	if (IS_HASWELL(dev_priv->dev) && (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) { \
-		DRM_ERROR("Unknown unclaimed register before writing to %x\n", reg); \
-		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED); \
-	} \
+	hsw_unclaimed_reg_clear(dev_priv, reg); \
 	write##y(val, dev_priv->regs + reg); \
 	if (unlikely(__fifo_ret)) { \
 		gen6_gt_check_fifodbg(dev_priv); \
 	} \
-	if (IS_HASWELL(dev_priv->dev) && (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) { \
-		DRM_ERROR("Unclaimed write to %x\n", reg); \
-		writel(ERR_INT_MMIO_UNCLAIMED, dev_priv->regs + GEN7_ERR_INT);	\
-	} \
+	hsw_unclaimed_reg_check(dev_priv, reg); \
 }
 __i915_write(8, b)
 __i915_write(16, w)

commit c4aaf3501ee4f86f3dce1120e4bcff32c683a26c
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Feb 18 16:47:42 2013 +0000

    drm/i915: Remove platforms in the preliminary_hw_support description
    
    We already managed to get it out of sync (Haswell has been promoted out
    of this option), so let's remove all mentions to platforms.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c5b8c81b9440..857dd2ce30aa 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -121,9 +121,7 @@ MODULE_PARM_DESC(i915_enable_ppgtt,
 unsigned int i915_preliminary_hw_support __read_mostly = 0;
 module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 0600);
 MODULE_PARM_DESC(preliminary_hw_support,
-		"Enable preliminary hardware support. "
-		"Enable Haswell and ValleyView Support. "
-		"(default: false)");
+		"Enable preliminary hardware support. (default: false)");
 
 static struct drm_driver driver;
 extern int intel_agp_enabled;

commit b8efb17b3d687695b81485f606fc4e6c35a50f9a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Feb 5 15:41:53 2013 +0800

    i915: ignore lid open event when resuming
    
    i915 driver needs to do modeset when
    1. system resumes from sleep
    2. lid is opened
    
    In PM_SUSPEND_MEM state, all the GPEs are cleared when system resumes,
    thus it is the i915_resume code does the modeset rather than intel_lid_notify().
    
    But in PM_SUSPEND_FREEZE state, this will be broken because
    system is still responsive to the lid events.
    1. When we close the lid in Freeze state, intel_lid_notify() sets modeset_on_lid.
    2. When we reopen the lid, intel_lid_notify() will do a modeset,
       before the system is resumed.
    here is the error log,
    
    [92146.548074] WARNING: at drivers/gpu/drm/i915/intel_display.c:1028 intel_wait_for_pipe_off+0x184/0x190 [i915]()
    [92146.548076] Hardware name: VGN-Z540N
    [92146.548078] pipe_off wait timed out
    [92146.548167] Modules linked in: hid_generic usbhid hid snd_hda_codec_realtek snd_hda_intel snd_hda_codec parport_pc snd_hwdep ppdev snd_pcm_oss i915 snd_mixer_oss snd_pcm arc4 iwldvm snd_seq_dummy mac80211 snd_seq_oss snd_seq_midi fbcon tileblit font bitblit softcursor drm_kms_helper snd_rawmidi snd_seq_midi_event coretemp drm snd_seq kvm btusb bluetooth snd_timer iwlwifi pcmcia tpm_infineon i2c_algo_bit joydev snd_seq_device intel_agp cfg80211 snd intel_gtt yenta_socket pcmcia_rsrc sony_laptop agpgart microcode psmouse tpm_tis serio_raw mxm_wmi soundcore snd_page_alloc tpm acpi_cpufreq lpc_ich pcmcia_core tpm_bios mperf processor lp parport firewire_ohci firewire_core crc_itu_t sdhci_pci sdhci thermal e1000e
    [92146.548173] Pid: 4304, comm: kworker/0:0 Tainted: G        W    3.8.0-rc3-s0i3-v3-test+ #9
    [92146.548175] Call Trace:
    [92146.548189]  [<c10378e2>] warn_slowpath_common+0x72/0xa0
    [92146.548227]  [<f86398b4>] ? intel_wait_for_pipe_off+0x184/0x190 [i915]
    [92146.548263]  [<f86398b4>] ? intel_wait_for_pipe_off+0x184/0x190 [i915]
    [92146.548270]  [<c10379b3>] warn_slowpath_fmt+0x33/0x40
    [92146.548307]  [<f86398b4>] intel_wait_for_pipe_off+0x184/0x190 [i915]
    [92146.548344]  [<f86399c2>] intel_disable_pipe+0x102/0x190 [i915]
    [92146.548380]  [<f8639ea4>] ? intel_disable_plane+0x64/0x80 [i915]
    [92146.548417]  [<f8639f7c>] i9xx_crtc_disable+0xbc/0x150 [i915]
    [92146.548456]  [<f863ebee>] intel_crtc_update_dpms+0x5e/0x90 [i915]
    [92146.548493]  [<f86437cf>] intel_modeset_setup_hw_state+0x42f/0x8f0 [i915]
    [92146.548535]  [<f8645b0b>] intel_lid_notify+0x9b/0xc0 [i915]
    [92146.548543]  [<c15610d3>] notifier_call_chain+0x43/0x60
    [92146.548550]  [<c105d1e1>] __blocking_notifier_call_chain+0x41/0x80
    [92146.548556]  [<c105d23f>] blocking_notifier_call_chain+0x1f/0x30
    [92146.548563]  [<c131a684>] acpi_lid_send_state+0x78/0xa4
    [92146.548569]  [<c131aa9e>] acpi_button_notify+0x3b/0xf1
    [92146.548577]  [<c12df56a>] ? acpi_os_execute+0x17/0x19
    [92146.548582]  [<c12e591a>] ? acpi_ec_sync_query+0xa5/0xbc
    [92146.548589]  [<c12e2b82>] acpi_device_notify+0x16/0x18
    [92146.548595]  [<c12f4904>] acpi_ev_notify_dispatch+0x38/0x4f
    [92146.548600]  [<c12df0e8>] acpi_os_execute_deferred+0x20/0x2b
    [92146.548607]  [<c1051208>] process_one_work+0x128/0x3f0
    [92146.548613]  [<c1564f73>] ? common_interrupt+0x33/0x38
    [92146.548618]  [<c104f8c0>] ? wake_up_worker+0x30/0x30
    [92146.548624]  [<c12df0c8>] ? acpi_os_wait_events_complete+0x1e/0x1e
    [92146.548629]  [<c10524f9>] worker_thread+0x119/0x3b0
    [92146.548634]  [<c10523e0>] ? manage_workers+0x240/0x240
    [92146.548640]  [<c1056e84>] kthread+0x94/0xa0
    [92146.548647]  [<c1060000>] ? ftrace_raw_output_sched_stat_runtime+0x70/0xf0
    [92146.548652]  [<c15649b7>] ret_from_kernel_thread+0x1b/0x28
    [92146.548658]  [<c1056df0>] ? kthread_create_on_node+0xc0/0xc0
    
    three different modeset flags are introduced in this patch
    MODESET_ON_LID_OPEN: do modeset on next lid open event
    MODESET_DONE:  modeset already done
    MODESET_SUSPENDED:  suspended, only do modeset when system is resumed
    
    In this way,
    1. when lid is closed, MODESET_ON_LID_OPEN is set so that
       we'll do modeset on next lid open event.
    2. when lid is opened, MODESET_DONE is set
       so that duplicate lid open events will be ignored.
    3. when system suspends, MODESET_SUSPENDED is set.
       In this case, we will not do modeset on any lid events.
    
    Plus, locking mechanism is also introduced to avoid racing.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d159d7a402e9..c5b8c81b9440 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -470,6 +470,11 @@ static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	/* ignore lid events during suspend */
+	mutex_lock(&dev_priv->modeset_restore_lock);
+	dev_priv->modeset_restore = MODESET_SUSPENDED;
+	mutex_unlock(&dev_priv->modeset_restore_lock);
+
 	intel_set_power_well(dev, true);
 
 	drm_kms_helper_poll_disable(dev);
@@ -496,9 +501,6 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	intel_opregion_fini(dev);
 
-	/* Modeset on resume, not lid events */
-	dev_priv->modeset_on_lid = 0;
-
 	console_lock();
 	intel_fbdev_set_suspend(dev, 1);
 	console_unlock();
@@ -574,8 +576,6 @@ static int __i915_drm_thaw(struct drm_device *dev)
 
 	intel_opregion_init(dev);
 
-	dev_priv->modeset_on_lid = 0;
-
 	/*
 	 * The console lock can be pretty contented on resume due
 	 * to all the printk activity.  Try to keep it out of the hot
@@ -588,6 +588,9 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		schedule_work(&dev_priv->console_resume_work);
 	}
 
+	mutex_lock(&dev_priv->modeset_restore_lock);
+	dev_priv->modeset_restore = MODESET_DONE;
+	mutex_unlock(&dev_priv->modeset_restore_lock);
 	return error;
 }
 

commit fe31b574fb2563f3aaa24dec302ddd0a033cda0f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Jan 25 21:44:47 2013 +0200

    drm/i915: Kill IS_DISPLAYREG()
    
    All display registers should now include the proper offset on VLV.
    That means IS_DISPLAYREG() is now useless, and we can eliminate it.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9cc8f8780cf8..d159d7a402e9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1119,102 +1119,6 @@ MODULE_LICENSE("GPL and additional rights");
 	((HAS_FORCE_WAKE((dev_priv)->dev)) && \
 	 ((reg) < 0x40000) &&            \
 	 ((reg) != FORCEWAKE))
-
-static bool IS_DISPLAYREG(u32 reg)
-{
-	/*
-	 * This should make it easier to transition modules over to the
-	 * new register block scheme, since we can do it incrementally.
-	 */
-	if (reg >= VLV_DISPLAY_BASE)
-		return false;
-
-	if (reg >= RENDER_RING_BASE &&
-	    reg < RENDER_RING_BASE + 0xff)
-		return false;
-	if (reg >= GEN6_BSD_RING_BASE &&
-	    reg < GEN6_BSD_RING_BASE + 0xff)
-		return false;
-	if (reg >= BLT_RING_BASE &&
-	    reg < BLT_RING_BASE + 0xff)
-		return false;
-
-	if (reg == PGTBL_ER)
-		return false;
-
-	if (reg >= IPEIR_I965 &&
-	    reg < HWSTAM)
-		return false;
-
-	if (reg == MI_MODE)
-		return false;
-
-	if (reg == GFX_MODE_GEN7)
-		return false;
-
-	if (reg == RENDER_HWS_PGA_GEN7 ||
-	    reg == BSD_HWS_PGA_GEN7 ||
-	    reg == BLT_HWS_PGA_GEN7)
-		return false;
-
-	if (reg == GEN6_BSD_SLEEP_PSMI_CONTROL ||
-	    reg == GEN6_BSD_RNCID)
-		return false;
-
-	if (reg == GEN6_BLITTER_ECOSKPD)
-		return false;
-
-	if (reg >= 0x4000c &&
-	    reg <= 0x4002c)
-		return false;
-
-	if (reg >= 0x4f000 &&
-	    reg <= 0x4f08f)
-		return false;
-
-	if (reg >= 0x4f100 &&
-	    reg <= 0x4f11f)
-		return false;
-
-	if (reg >= VLV_MASTER_IER &&
-	    reg <= GEN6_PMIER)
-		return false;
-
-	if (reg >= FENCE_REG_SANDYBRIDGE_0 &&
-	    reg < (FENCE_REG_SANDYBRIDGE_0 + (16*8)))
-		return false;
-
-	if (reg >= VLV_IIR_RW &&
-	    reg <= VLV_ISR)
-		return false;
-
-	if (reg == FORCEWAKE_VLV ||
-	    reg == FORCEWAKE_ACK_VLV)
-		return false;
-
-	if (reg == GEN6_GDRST)
-		return false;
-
-	switch (reg) {
-	case _3D_CHICKEN3:
-	case IVB_CHICKEN3:
-	case GEN7_COMMON_SLICE_CHICKEN1:
-	case GEN7_L3CNTLREG1:
-	case GEN7_L3_CHICKEN_MODE_REGISTER:
-	case GEN7_ROW_CHICKEN2:
-	case GEN7_L3SQCREG4:
-	case GEN7_SQ_CHICKEN_MBCUNIT_CONFIG:
-	case GEN7_HALF_SLICE_CHICKEN1:
-	case GEN6_MBCTL:
-	case GEN6_UCGCTL2:
-		return false;
-	default:
-		break;
-	}
-
-	return true;
-}
-
 static void
 ilk_dummy_write(struct drm_i915_private *dev_priv)
 {
@@ -1238,8 +1142,6 @@ u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 		if (dev_priv->forcewake_count == 0) \
 			dev_priv->gt.force_wake_put(dev_priv); \
 		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
-	} else if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
-		val = read##y(dev_priv->regs + reg + 0x180000);		\
 	} else { \
 		val = read##y(dev_priv->regs + reg); \
 	} \
@@ -1266,11 +1168,7 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 		DRM_ERROR("Unknown unclaimed register before writing to %x\n", reg); \
 		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED); \
 	} \
-	if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
-		write##y(val, dev_priv->regs + reg + 0x180000);		\
-	} else {							\
-		write##y(val, dev_priv->regs + reg);			\
-	}								\
+	write##y(val, dev_priv->regs + reg); \
 	if (unlikely(__fifo_ret)) { \
 		gen6_gt_check_fifodbg(dev_priv); \
 	} \

commit cb10799c194369633b183262edc75ec4b3e4e346
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Jan 25 16:59:15 2013 -0200

    drm/i915: turn on the power well before suspending
    
    Our suspend code touches a lot of registers all over the place, so we
    need to enable the power well before suspending.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    [danvet: Fixup compilation by stealing the header decl from the
    dynamic power wells patch.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 521a25376718..9cc8f8780cf8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -470,6 +470,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	intel_set_power_well(dev, true);
+
 	drm_kms_helper_poll_disable(dev);
 
 	pci_save_state(dev->pdev);

commit fba5d532d16db812dabaa80fb7570820daa2707b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jan 24 15:29:56 2013 +0200

    drm/i915: Set display_mmio_offset for VLV
    
    This will cause display registers to include the correct
    offset on VLV.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ff8e73f4341..521a25376718 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -276,6 +276,7 @@ static const struct intel_device_info intel_valleyview_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.is_valleyview = 1,
+	.display_mmio_offset = VLV_DISPLAY_BASE,
 };
 
 static const struct intel_device_info intel_valleyview_d_info = {
@@ -285,6 +286,7 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.is_valleyview = 1,
+	.display_mmio_offset = VLV_DISPLAY_BASE,
 };
 
 static const struct intel_device_info intel_haswell_d_info = {

commit 99584db33ba4f864777e2cfef5329ed1bf13f714
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 14 17:14:04 2012 +0100

    drm/i915: extract hangcheck/reset/error_state state into substruct
    
    This has been sprinkled all over the place in dev_priv. I think
    it'd be good to also move all the code into a separate file like
    i915_gem_error.c, but that's for another patch.
    
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c8cbc32fe8db..3ff8e73f4341 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -779,9 +779,9 @@ int intel_gpu_reset(struct drm_device *dev)
 	}
 
 	/* Also reset the gpu hangman. */
-	if (dev_priv->stop_rings) {
+	if (dev_priv->gpu_error.stop_rings) {
 		DRM_DEBUG("Simulated gpu hang, resetting stop_rings\n");
-		dev_priv->stop_rings = 0;
+		dev_priv->gpu_error.stop_rings = 0;
 		if (ret == -ENODEV) {
 			DRM_ERROR("Reset not implemented, but ignoring "
 				  "error for simulated gpu hangs\n");
@@ -820,12 +820,12 @@ int i915_reset(struct drm_device *dev)
 	i915_gem_reset(dev);
 
 	ret = -ENODEV;
-	if (get_seconds() - dev_priv->last_gpu_reset < 5)
+	if (get_seconds() - dev_priv->gpu_error.last_reset < 5)
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
 	else
 		ret = intel_gpu_reset(dev);
 
-	dev_priv->last_gpu_reset = get_seconds();
+	dev_priv->gpu_error.last_reset = get_seconds();
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");
 		mutex_unlock(&dev->struct_mutex);

commit b5cc6c0387b2f8d269c1df1e68c97c958dd22fed
Merge: 9931faca02c6 c0c36b941b6f
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 17 20:34:08 2013 +1000

    Merge tag 'drm-intel-next-2012-12-21' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    - seqno wrap fixes and debug infrastructure from Mika Kuoppala and Chris
      Wilson
    - some leftover kill-agp on gen6+ patches from Ben
    - hotplug improvements from Damien
    - clear fb when allocated from stolen, avoids dirt on the fbcon (Chris)
    - Stolen mem support from Chris Wilson, one of the many steps to get to
      real fastboot support.
    - Some DDI code cleanups from Paulo.
    - Some refactorings around lvds and dp code.
    - some random little bits&pieces
    
    * tag 'drm-intel-next-2012-12-21' of git://people.freedesktop.org/~danvet/drm-intel: (93 commits)
      drm/i915: Return the real error code from intel_set_mode()
      drm/i915: Make GSM void
      drm/i915: Move GSM mapping into dev_priv
      drm/i915: Move even more gtt code to i915_gem_gtt
      drm/i915: Make next_seqno debugs entry to use i915_gem_set_seqno
      drm/i915: Introduce i915_gem_set_seqno()
      drm/i915: Always clear semaphore mboxes on seqno wrap
      drm/i915: Initialize hardware semaphore state on ring init
      drm/i915: Introduce ring set_seqno
      drm/i915: Missed conversion to gtt_pte_t
      drm/i915: Bug on unsupported swizzled platforms
      drm/i915: BUG() if fences are used on unsupported platform
      drm/i915: fixup overlay stolen memory leak
      drm/i915: clean up PIPECONF bpc #defines
      drm/i915: add intel_dp_set_signal_levels
      drm/i915: remove leftover display.update_wm assignment
      drm/i915: check for the PCH when setting pch_transcoder
      drm/i915: Clear the stolen fb before enabling
      drm/i915: Access to snooped system memory through the GTT is incoherent
      drm/i915: Remove stale comment about intel_dp_detect()
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c

commit 56550d94cbaeaa195cb98c95d012b301cbd65a8d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:09:25 2012 -0800

    Drivers: gpu: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: David Airlie <airlied@linux.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 530db83ef320..117265840b1f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -877,8 +877,7 @@ int i915_reset(struct drm_device *dev)
 	return 0;
 }
 
-static int __devinit
-i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;

commit 20afbda209d708be66944907966486d0c1331cb8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 11 14:05:07 2012 +0100

    drm/i915: Fixup hpd irq register setup ordering
    
    For GMCH platforms we set up the hpd irq registers in the irq
    postinstall hook. But since we only enable the irq sources we actually
    need in PORT_HOTPLUG_EN/STATUS, taking dev_priv->hotplug_supported_mask
    into account, no hpd interrupt sources is enabled since
    
    commit 52d7ecedac3f96fb562cb482c139015372728638
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Sat Dec 1 21:03:22 2012 +0100
    
        drm/i915: reorder setup sequence to have irqs for output setup
    
    Wrongly set-up interrupts also lead to broken hw-based load-detection
    on at least GM45, resulting in ghost VGA/TV-out outputs.
    
    To fix this, delay the hotplug register setup until after all outputs
    are set up, by moving it into a new dev_priv->display.hpd_irq_callback.
    We might also move the PCH_SPLIT platforms to such a setup eventually.
    
    Another funny part is that we need to delay the fbdev initial config
    probing until after the hpd regs are setup, for otherwise it'll detect
    ghost outputs. But we can only enable the hpd interrupt handling
    itself (and the output polling) _after_ that initial scan, due to
    massive locking brain-damage in the fbdev setup code. Add a big
    comment to explain this cute little dragon lair.
    
    v2: Encapsulate all the fbdev handling by wrapping the move call into
    intel_fbdev_initial_config in intel_fb.c. Requested by Chris Wilson.
    
    v3: Applied bikeshed from Jesse Barnes.
    
    v4: Imre Deak noticed that we also need to call intel_hpd_init after
    the drm_irqinstall calls in the gpu reset and resume paths - otherwise
    hotplug will be broken. Also improve the comment a bit about why
    hpd_init needs to be called before we set up the initial fbdev config.
    
    Bugzilla: Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=54943
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org> (v3)
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a12921892446..fbd0b28b7200 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -566,6 +566,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		intel_modeset_init_hw(dev);
 		intel_modeset_setup_hw_state(dev, false);
 		drm_irq_install(dev);
+		intel_hpd_init(dev);
 	}
 
 	intel_opregion_init(dev);
@@ -871,6 +872,7 @@ int i915_reset(struct drm_device *dev)
 
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);
+		intel_hpd_init(dev);
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}

commit dde86e2db54545ef981b64805097a7b4c3156d6e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Sat Dec 1 12:04:25 2012 -0200

    drm/i915: add lpt_init_pch_refclk
    
    We need this code to init the PCH SSC refclk and the FDI registers.
    The BIOS does this too and that's why VGA worked before this patch,
    until you tried to suspend the machine...
    
    This patch implements the "Sequence to enable CLKOUT_DP for FDI usage
    and configure PCH FDI/IO" from our documentation.
    
    v2:
    - Squash Damien Lespiau's reset spelling fix on top.
    - Add a comment that we don't need to bother about the ULT special
      case Damien noticed, since ULT won't have VGA.
    - Add a comment to rip out the SDV codepaths once haswell ships for
      real.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a12921892446..530db83ef320 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -554,8 +554,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
-			ironlake_init_pch_refclk(dev);
+		intel_init_pch_refclk(dev);
 
 		mutex_lock(&dev->struct_mutex);
 		dev_priv->mm.suspended = 0;

commit 45e2b5f640b3766da3eda48f6c35f088155c06f3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Nov 23 18:16:34 2012 +0100

    drm/i915: force restore on lid open
    
    There seem to be indeed some awkwards machines around, mostly those
    without OpRegion support, where the firmware changes the display hw
    state behind our backs when closing the lid.
    
    This force-restore logic has been originally introduced in
    
    commit c1c7af60892070e4b82ad63bbfb95ae745056de0
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Thu Sep 10 15:28:03 2009 -0700
    
        drm/i915: force mode set at lid open time
    
    but after the modeset-rework we've disabled it in the vain hope that
    it's no longer required:
    
    commit 3b7a89fce3e3dc96b549d6d829387b4439044d0d
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Mon Sep 17 22:27:21 2012 +0200
    
        drm/i915: fix OOPS in lid_notify
    
    Alas, no.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=54677
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=57434
    Tested-by: Krzysztof Mazur <krzysiek@podlesie.net>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6745c7f976db..a12921892446 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -564,7 +564,7 @@ static int __i915_drm_thaw(struct drm_device *dev)
 		mutex_unlock(&dev->struct_mutex);
 
 		intel_modeset_init_hw(dev);
-		intel_modeset_setup_hw_state(dev);
+		intel_modeset_setup_hw_state(dev, false);
 		drm_irq_install(dev);
 	}
 

commit 70b12bb415463c1bd146b67c5fbf6784fd046ad9
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Nov 20 13:32:30 2012 -0200

    drm/i915: promote Haswell to full support
    
    Since it should be working a little bit better now.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d5d8f2f2ed09..6745c7f976db 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -884,7 +884,7 @@ i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;
 
-	if (intel_info->is_haswell || intel_info->is_valleyview)
+	if (intel_info->is_valleyview)
 		if(!i915_preliminary_hw_support) {
 			DRM_ERROR("Preliminary hardware support disabled\n");
 			return -ENODEV;

commit 17a303ec7cd5a245c621b6d0898eb3ef9fc96329
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Nov 20 15:12:07 2012 -0200

    drm/i915: make DP work on LPT-LP machines
    
    We need to enable a special bit, otherwise none of the DP functions
    requiring the PCH will work.
    
    Version 2: store the PCH ID inside dev_priv, as suggested by Daniel
    Vetter.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f7aef97290bc..d5d8f2f2ed09 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -396,13 +396,6 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 MODULE_DEVICE_TABLE(pci, pciidlist);
 #endif
 
-#define INTEL_PCH_DEVICE_ID_MASK	0xff00
-#define INTEL_PCH_IBX_DEVICE_ID_TYPE	0x3b00
-#define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
-#define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
-#define INTEL_PCH_LPT_DEVICE_ID_TYPE	0x8c00
-#define INTEL_PCH_LPT_LP_DEVICE_ID_TYPE	0x9c00
-
 void intel_detect_pch(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -417,8 +410,9 @@ void intel_detect_pch(struct drm_device *dev)
 	pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL);
 	if (pch) {
 		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
-			int id;
+			unsigned short id;
 			id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+			dev_priv->pch_id = id;
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_IBX;

commit c54e59046c825266ca0decdac47fcfcf902b6cd6
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Nov 20 13:27:38 2012 -0200

    drm/i915: fix false positive "Unclaimed write" messages
    
    We don't check if the "unclaimed register" bit is set before we call
    writel, so if it was already set before, we might print a misleading
    message about "unclaimed write" on the wrong register.
    
    This patch makes us check the unclaimed bit before the writel, so we
    can print a new "Unknown unclaimed register before writing to %x"
    message.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f5b505a5b81e..f7aef97290bc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1264,6 +1264,10 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 	} \
 	if (IS_GEN5(dev_priv->dev)) \
 		ilk_dummy_write(dev_priv); \
+	if (IS_HASWELL(dev_priv->dev) && (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) { \
+		DRM_ERROR("Unknown unclaimed register before writing to %x\n", reg); \
+		I915_WRITE_NOTRACE(GEN7_ERR_INT, ERR_INT_MMIO_UNCLAIMED); \
+	} \
 	if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
 		write##y(val, dev_priv->regs + reg + 0x180000);		\
 	} else {							\

commit a726915cef1daab57aad4c5b5e4773822f0a4bf8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Nov 20 14:50:08 2012 +0100

    drm/i915: resurrect panel lid handling
    
    But disabled by default. This essentially reverts
    
    commit bcd5023c961a44c7149936553b6929b2b233dd27
    Author: Dave Airlie <airlied@redhat.com>
    Date:   Mon Mar 14 14:17:55 2011 +1000
    
        drm/i915: disable opregion lid detection for now
    
    but leaves the autodetect mode disabled. There's also the explicit lid
    status option added in
    
    commit fca874092597ef946b8f07031d8c31c58b212144
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Thu Feb 17 13:44:48 2011 +0000
    
        drm/i915: Add a module parameter to ignore lid status
    
    Which overloaded the meaning for the panel_ignore_lid parameter even
    more. To fix up this mess, give the non-negative numbers 0,1 the
    original meaning back and use negative numbers to force a given state.
    So now we have
    
    1  - disable autodetect, return unknown
    0  - enable autodetect
    -1 - force to disconnected/lid closed
    -2 - force to connected/lid open
    
    v2: My C programmer license has been revoked ...
    
    v3: Beautify the code a bit, as suggested by Chris Wilson.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=27622
    Tested-by: Andreas Sturmlechner <andreas.sturmlechner@gmail.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a3d754dba5a9..f5b505a5b81e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,11 +47,11 @@ MODULE_PARM_DESC(modeset,
 unsigned int i915_fbpercrtc __always_unused = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
-int i915_panel_ignore_lid __read_mostly = 0;
+int i915_panel_ignore_lid __read_mostly = 1;
 module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
 MODULE_PARM_DESC(panel_ignore_lid,
-		"Override lid status (0=autodetect [default], 1=lid open, "
-		"-1=lid closed)");
+		"Override lid status (0=autodetect, 1=autodetect disabled [default], "
+		"-1=force lid closed, -2=force lid open)");
 
 unsigned int i915_powersave __read_mostly = 1;
 module_param_named(powersave, i915_powersave, int, 0600);

commit ae6935ddda178f6d2b327cd9bf09add133315f15
Author: Wei Shun Chang <wei.shun.chang@intel.com>
Date:   Mon Nov 12 18:54:13 2012 -0200

    drm/i915: add LynxPoint-LP PCH ID
    
    [pzanoni: rebase, print it's an LP PCH]
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Tested-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f85e8b0ec00f..a3d754dba5a9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -401,6 +401,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 #define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
 #define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
 #define INTEL_PCH_LPT_DEVICE_ID_TYPE	0x8c00
+#define INTEL_PCH_LPT_LP_DEVICE_ID_TYPE	0x9c00
 
 void intel_detect_pch(struct drm_device *dev)
 {
@@ -440,6 +441,11 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->num_pch_pll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 				WARN_ON(!IS_HASWELL(dev));
+			} else if (id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_LPT;
+				dev_priv->num_pch_pll = 0;
+				DRM_DEBUG_KMS("Found LynxPoint LP PCH\n");
+				WARN_ON(!IS_HASWELL(dev));
 			}
 			BUG_ON(dev_priv->num_pch_pll > I915_NUM_PLLS);
 		}

commit 9fabd4eedeb904173d05cb1ced3c3e6b9d2e8137
Merge: 6380813c6e31 6b8294a4d392
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 20 09:22:35 2012 +1000

    Merge branch 'for-airlied' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    Highlights of this -next round:
    - ivb fdi B/C fixes
    - hsw sprite/plane offset fixes from Damien
    - unified dp/hdmi encoder for hsw, finally external dp support on hsw
      (Paulo)
    - kill-agp and some other prep work in the gtt code from Ben
    - some fb handling fixes from Ville
    - massive pile of patches to align hsw VGA with the spec and make it
      actually work (Paulo)
    - pile of workarounds from Jesse, mostly for vlv, but also some other
      related platforms
    - start of a dev_priv reorg, that thing grew out of bounds and chaotic
    - small bits&pieces all over the place, down to better error handling for
      load-detect on gen2 (Chris, Jani, Mika, Zhenyu, ...)
    
    On top of the previous pile (just copypasta):
    - tons of hsw dp prep patches form Paulo
    - round scheduled work items and timers to nearest second (Chris)
    - some hw workarounds (Jesse&Damien)
    - vlv dp support and related fixups (Vijay et al.)
    - basic haswell dp support, not yet wired up for external ports (Paulo)
    - edp support (Paulo)
    - tons of refactorings to prepare for the above (Paulo)
    - panel rework, unifiying code between lvds and edp panels (Jani)
    - panel fitter scaling modes (Jani + Yuly Novikov)
    - panel power improvements, should now work without the BIOS setting it up
    - extracting some dp helpers from radeon/i915 and move them to
      drm_dp_helper.c
    - randome pile of workarounds (Damien, Ben, ...)
    - some cleanups for the register restore code for suspend/resume
    - secure batchbuffer support, should enable tear-free blits on gen6+
      Chris)
    - random smaller fixlets and cleanups.
    
    * 'for-airlied' of git://people.freedesktop.org/~danvet/drm-intel: (231 commits)
      drm/i915: Restore physical HWS_PGA after resume
      drm/i915: Report amount of usable graphics memory in MiB
      drm/i915/i2c: Track users of GMBUS force-bit
      drm/i915: Allocate the proper size for contexts.
      drm/i915: Update load-detect failure paths for modeset-rework
      drm/i915: Clear unused fields of mode for framebuffer creation
      drm/i915: Always calculate 8xx WM values based on a 32-bpp framebuffer
      drm/i915: Fix sparse warnings in from AGP kill code
      drm/i915: Missed lock change with rps lock
      drm/i915: Move the remaining gtt code
      drm/i915: flush system agent TLBs on SNB
      drm/i915: Kill off now unused gen6+ AGP code
      drm/i915: Calculate correct stolen size for GEN7+
      drm/i915: Stop using AGP layer for GEN6+
      drm/i915: drop the double-OP_STOREDW usage in blt_ring_flush
      drm/i915: don't rewrite the GTT on resume v4
      drm/i915: protect RPS/RC6 related accesses (including PCU) with a new mutex
      drm/i915: put ring frequency and turbo setup into a work queue v5
      drm/i915: don't block resume on fb console resume v2
      drm/i915: extract l3_parity substruct from dev_priv
      ...

commit 1abd02e2dd7e0bd577000301fb2fd47780637387
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Nov 2 11:14:02 2012 -0700

    drm/i915: don't rewrite the GTT on resume v4
    
    The BIOS shouldn't be touching this memory across suspend/resume, so
    just leave it alone.  This saves us ~6ms on resume on my T420 (retested
    with write combined PTEs).
    
    v2: change gtt restore default on pre-gen4 (Chris)
        move needs_gtt_restore flag into dev_priv
    v3: make sure we restore GTT on resume from hibernate (Daniel)
        use opregion support as the cutoff for restore from resume (Chris)
    v4: use a better check for opregion (Chris)
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: Kill the needs_gtt_restore indirection and check directly for
    OpRegion. Also explain in a comment what's going on.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 577858bd0809..f8ba5feb9277 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -537,19 +537,11 @@ void intel_console_resume(struct work_struct *work)
 	console_unlock();
 }
 
-static int i915_drm_thaw(struct drm_device *dev)
+static int __i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
-	intel_gt_reset(dev);
-
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		mutex_lock(&dev->struct_mutex);
-		i915_gem_restore_gtt_mappings(dev);
-		mutex_unlock(&dev->struct_mutex);
-	}
-
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
@@ -588,8 +580,26 @@ static int i915_drm_thaw(struct drm_device *dev)
 	return error;
 }
 
+static int i915_drm_thaw(struct drm_device *dev)
+{
+	int error = 0;
+
+	intel_gt_reset(dev);
+
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		mutex_lock(&dev->struct_mutex);
+		i915_gem_restore_gtt_mappings(dev);
+		mutex_unlock(&dev->struct_mutex);
+	}
+
+	__i915_drm_thaw(dev);
+
+	return error;
+}
+
 int i915_resume(struct drm_device *dev)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
@@ -600,7 +610,20 @@ int i915_resume(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	ret = i915_drm_thaw(dev);
+	intel_gt_reset(dev);
+
+	/*
+	 * Platforms with opregion should have sane BIOS, older ones (gen3 and
+	 * earlier) need this since the BIOS might clear all our scratch PTEs.
+	 */
+	if (drm_core_check_feature(dev, DRIVER_MODESET) &&
+	    !dev_priv->opregion.header) {
+		mutex_lock(&dev->struct_mutex);
+		i915_gem_restore_gtt_mappings(dev);
+		mutex_unlock(&dev->struct_mutex);
+	}
+
+	ret = __i915_drm_thaw(dev);
 	if (ret)
 		return ret;
 

commit 1a01ab3b2dc4394c46c4c3230805748f632f6f74
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Nov 2 11:14:00 2012 -0700

    drm/i915: put ring frequency and turbo setup into a work queue v5
    
    Communicating via the mailbox registers with the PCU can take quite
    awhile.  And updating the ring frequency or enabling turbo is not
    something that needs to happen synchronously, so take it out of our init
    and resume paths to speed things up (~200ms on my T420).
    
    v2: add comment about why we use a work queue (Daniel)
        make sure work queue is idle on suspend (Daniel)
        use a delayed work queue since there's no hurry (Daniel)
    v3: make cleanup symmetric and just call cancel work directly (Daniel)
    v4: schedule the work using round_jiffies_up to batch work better (Chris)
    v5: fix the right schedule_delayed_work call (Chris)
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=54089
    
    Signed-of-by: Jesse Barnes <jbarnes@virtuougseek.org>
    [danvet: bikeshed the placement of the new delayed work, move it to
    all the other gen6 power mgmt stuff.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cfd8920537c5..577858bd0809 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -474,6 +474,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 			return error;
 		}
 
+		cancel_delayed_work_sync(&dev_priv->rps.delayed_resume_work);
+
 		intel_modeset_disable(dev);
 
 		drm_irq_uninstall(dev);

commit 073f34d9d49bdbadbea8198ddc3fbb7e736a94dd
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Nov 2 11:13:59 2012 -0700

    drm/i915: don't block resume on fb console resume v2
    
    The console lock can be contended, so rather than prevent other drivers
    after us from being held up, queue the console suspend into the global
    work queue that can happen anytime.  I've measured this to take around
    200ms on my T420.  Combined with the ring freq/turbo change, we should
    save almost 1/2 a second on resume.
    
    v2: use console_trylock() to try to resume the console immediately (Chris)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: move dev_priv->console_resume_work next to the fbdev
    pointer.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a08e9cafb7f2..cfd8920537c5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -523,6 +523,18 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	return 0;
 }
 
+void intel_console_resume(struct work_struct *work)
+{
+	struct drm_i915_private *dev_priv =
+		container_of(work, struct drm_i915_private,
+			     console_resume_work);
+	struct drm_device *dev = dev_priv->dev;
+
+	console_lock();
+	intel_fbdev_set_suspend(dev, 0);
+	console_unlock();
+}
+
 static int i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -559,9 +571,18 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 	dev_priv->modeset_on_lid = 0;
 
-	console_lock();
-	intel_fbdev_set_suspend(dev, 0);
-	console_unlock();
+	/*
+	 * The console lock can be pretty contented on resume due
+	 * to all the printk activity.  Try to keep it out of the hot
+	 * path of resume if possible.
+	 */
+	if (console_trylock()) {
+		intel_fbdev_set_suspend(dev, 0);
+		console_unlock();
+	} else {
+		schedule_work(&dev_priv->console_resume_work);
+	}
+
 	return error;
 }
 

commit 310c53a84f592d3e4a54dc26d512d1429695080b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Oct 25 12:15:48 2012 -0700

    drm/i915: add clock gating regs to VLV offset check function
    
    So we can write them properly.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Antti Koskipää <antti.koskipaa@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 513856359ca3..a08e9cafb7f2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1133,8 +1133,17 @@ static bool IS_DISPLAYREG(u32 reg)
 		return false;
 
 	switch (reg) {
+	case _3D_CHICKEN3:
+	case IVB_CHICKEN3:
+	case GEN7_COMMON_SLICE_CHICKEN1:
+	case GEN7_L3CNTLREG1:
+	case GEN7_L3_CHICKEN_MODE_REGISTER:
 	case GEN7_ROW_CHICKEN2:
+	case GEN7_L3SQCREG4:
+	case GEN7_SQ_CHICKEN_MBCUNIT_CONFIG:
 	case GEN7_HALF_SLICE_CHICKEN1:
+	case GEN6_MBCTL:
+	case GEN6_UCGCTL2:
 		return false;
 	default:
 		break;

commit 12f3382bc0262e981a2e58aca900cbbdbbe66825
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Oct 25 12:15:45 2012 -0700

    drm/i915: implement WaDisablePSDDualDispatchEnable on IVB & VLV
    
    Workaround for dual port PS dispatch on GT1.
    
    v2: pull in register definition & offset handling
    v3: use IVB GT1 macro to get the right regs (Ben)
    v4: add for VLV too (Ben)
    v5: don't read the reg, it's masked so we'll only enable the one extra bit (Chris)
    v6: use a _GT2 suffix for the second reg (Chris)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Antti Koskipää <antti.koskipaa@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ba74df2e2ff1..513856359ca3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1134,6 +1134,7 @@ static bool IS_DISPLAYREG(u32 reg)
 
 	switch (reg) {
 	case GEN7_ROW_CHICKEN2:
+	case GEN7_HALF_SLICE_CHICKEN1:
 		return false;
 	default:
 		break;

commit 8ab4397640de51f4a93845b09270ad717244ccb3
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Oct 25 12:15:42 2012 -0700

    drm/i915: implement WaDisableDopClockGatingisable on VLV and IVB
    
    v2: use correct register
    v3: remove extra hunks, pull in register definitions & offset check directly
    v4: add GT1 vs GT2 distinction for IVB portion (Ben)
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=50233
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Antti Koskipää <antti.koskipaa@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4be4841854b0..ba74df2e2ff1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1132,6 +1132,13 @@ static bool IS_DISPLAYREG(u32 reg)
 	if (reg == GEN6_GDRST)
 		return false;
 
+	switch (reg) {
+	case GEN7_ROW_CHICKEN2:
+		return false;
+	default:
+		break;
+	}
+
 	return true;
 }
 

commit 7fcb83cde02da2f0c7d7eb8ba2c51df24495c0a8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 31 22:52:27 2012 +0100

    drm/i915: check whether the pch is the soulmate of the cpu
    
    We don't really support fancy north display/pch combinations, so
    put a big yelling WARN_ON in there. It /should/ be impossible, but
    alas, the rumours don't stop (mostly due to really early silicon
    sometimes using older PCHs).
    
    v2: Fixup the logic fumble noticed by Paulo Zanoni. I should actually
    try to test run the patch next time around ...
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 42388533708f..4be4841854b0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -416,19 +416,23 @@ void intel_detect_pch(struct drm_device *dev)
 				dev_priv->pch_type = PCH_IBX;
 				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
+				WARN_ON(!IS_GEN5(dev));
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
 				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
 				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
+				WARN_ON(!(IS_GEN6(dev) || IS_IVYBRIDGE(dev)));
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
 				dev_priv->num_pch_pll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
+				WARN_ON(!IS_HASWELL(dev));
 			}
 			BUG_ON(dev_priv->num_pch_pll > I915_NUM_PLLS);
 		}

commit a8b1397d717e36abd9e45f8fee61d800f7d236ec
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 14:16:09 2012 +0200

    drm/i915: implement WaIssueDummyWriteToWakeupFromRC6
    
    Or at least our best understanding of it.
    
    v2: Fixup commit message and put the wa name into the comment block.
    And actually update the commit, too.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 59dc4817964b..42388533708f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1131,9 +1131,20 @@ static bool IS_DISPLAYREG(u32 reg)
 	return true;
 }
 
+static void
+ilk_dummy_write(struct drm_i915_private *dev_priv)
+{
+	/* WaIssueDummyWriteToWakeupFromRC6: Issue a dummy write to wake up the
+	 * chip from rc6 before touching it for real. MI_MODE is masked, hence
+	 * harmless to write 0 into. */
+	I915_WRITE_NOTRACE(MI_MODE, 0);
+}
+
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \
+	if (IS_GEN5(dev_priv->dev)) \
+		ilk_dummy_write(dev_priv); \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
 		unsigned long irqflags; \
 		spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
@@ -1165,6 +1176,8 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
 		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \
 	} \
+	if (IS_GEN5(dev_priv->dev)) \
+		ilk_dummy_write(dev_priv); \
 	if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
 		write##y(val, dev_priv->regs + reg + 0x180000);		\
 	} else {							\

commit c2fb7916927e989ea424e61ce5fe617e54878827
Merge: 29de6ce57487 6f0c0580b70c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 22 14:34:51 2012 +0200

    Merge tag 'v3.7-rc2' into drm-intel-next-queued
    
    Linux 3.7-rc2
    
    Backmerge to solve two ugly conflicts:
    - uapi. We've already added new ioctl definitions for -next. Do I need to say more?
    - wc support gtt ptes. We've had to revert this for snb+ for 3.7 and
      also fix a few other things in the code. Now we know how to make it
      work on snb+, but to avoid losing the other fixes do the backmerge
      first before re-enabling wc gtt ptes on snb+.
    
    And a few other minor things, among them git getting confused in
    intel_dp.c and seemingly causing a conflict out of nothing ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_reg.h
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
            drivers/gpu/drm/i915/intel_modes.c
            include/drm/i915_drm.h
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 64acba6a7adfe8be2e28b7e903092db685328a08
Merge: 6f0c0580b70c 74ce6b6c6326
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Oct 22 09:55:29 2012 +1000

    Merge branch 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel into drm-fixes
    
    Daniel writes:
    The big thing is the disabling of the hsw support by default, cc: stable.
    We've aimed for basic hsw support in 3.6, but due to a few bad
    happenstances we've screwed up and only 3.8 will have better modeset
    support than vesa. To avoid yet another round of fallout from such a
    gaffle on for the next platform we've added a module option to disable
    early hw support by default. That should also give us more flexibility in
    bring-up.
    
     Otherwise just small fixes:
     - 3 fixes from Egbert for sdvo corner cases
     - invert-brightness quirk entry from Egbert
     - revert a dp link training change, it regresses some setups
     - and shut up a spurious WARN in our gem fault handler.
     - regression fix for an oops on bit17 swizzling machines, introduce in 3.7
     - another no-lvds quirk
    
    * 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel:
      drm/i915: Initialize obj->pages before use by i915_gem_object_do_bit17_swizzle()
      drm/i915: Add no-lvds quirk for Supermicro X7SPA-H
      drm/i915: Insert i915_preliminary_hw_support variable.
      drm/i915: shut up spurious WARN in the gtt fault handler
      Revert "drm/i915: Try harder to complete DP training pattern 1"
      DRM/i915: Restore sdvo_flags after dtd->mode->dtd Roundrtrip.
      DRM/i915: Don't clone SDVO LVDS with analog.
      DRM/i915: Add QUIRK_INVERT_BRIGHTNESS for NCR machines.
      DRM/i915: Don't delete DPLL Multiplier during DAC init.

commit 16995a9fe140802c026c2ce17bf7e232f86d57ab
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Oct 18 11:46:10 2012 +0100

    drm/i915: Clear FORCEWAKE when taking over from BIOS
    
    Some BIOSes may forcibly suspend RC6 during their operation which
    trigger a warning as we find the hardware in a perplexing state upon
    first use. So far that appears to be the worst symptom as fortuituously
    we use the same values as the BIOS for programming the FORCEWAKE register.
    
    Reported-by: Oleksij Rempel <bug-track@fisher-privat.net>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2aabce716da4..9e7e6474ecfd 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -525,6 +525,8 @@ static int i915_drm_thaw(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
+	intel_gt_reset(dev);
+
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
 		i915_gem_restore_gtt_mappings(dev);

commit 2e9388923e83bc4e2726f170a984621f1d582e77
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 11 20:08:24 2012 +0200

    drm/i915/crt: explicitly set up HOTPLUG_BITS on resume
    
    ... instead of relying on the register save/restore madness to do this.
    
    To extract a bit of code call drm_mode_config_reset both on resume
    and boot-up and move the hw state frobbing from the crt_init to the
    ->reset callback. The crt connector is the only one with a ->reset
    callback, hence we can easily do this.
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a7837e556945..2aabce716da4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -547,7 +547,6 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 		intel_modeset_init_hw(dev);
 		intel_modeset_setup_hw_state(dev);
-		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 	}
 

commit 0a3af268644e0217ea22d6899a76187f930e9590
Author: Rodrigo Vivi <rodrigo.vivi@gmail.com>
Date:   Mon Oct 15 17:16:23 2012 -0300

    drm/i915: Insert i915_preliminary_hw_support variable.
    
    On the worst scenario, users with new hardwares and old kernel from
    enabling times can get black screens.  So, from now on, this
    perliminary_hw_support module parameter shall be used by all upcoming
    platforms that are still under enabling. The second option would be to
    merge the pci ids after basic modeset works, but that makes testing
    and development while bringing up hw a rather tedious afair.
    
    Although it is uncomfortable for developers use this extra variable it
    brings more stability for end users.
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    [danvet: dropped the i915_ param prefix, i915.i915_ is just tedious.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a7837e556945..16564755406d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -119,6 +119,13 @@ module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0600);
 MODULE_PARM_DESC(i915_enable_ppgtt,
 		"Enable PPGTT (default: true)");
 
+unsigned int i915_preliminary_hw_support __read_mostly = 0;
+module_param_named(preliminary_hw_support, i915_preliminary_hw_support, int, 0600);
+MODULE_PARM_DESC(preliminary_hw_support,
+		"Enable preliminary hardware support. "
+		"Enable Haswell and ValleyView Support. "
+		"(default: false)");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 
@@ -827,6 +834,12 @@ i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct intel_device_info *intel_info =
 		(struct intel_device_info *) ent->driver_data;
 
+	if (intel_info->is_haswell || intel_info->is_valleyview)
+		if(!i915_preliminary_hw_support) {
+			DRM_ERROR("Preliminary hardware support disabled\n");
+			return -ENODEV;
+		}
+
 	/* Only bind to function 0 of the device. Early generations
 	 * used function 1 as a placeholder for multi-head. This causes
 	 * us confusion instead, especially on the systems where both

commit 612a9aab56a93533e76e3ad91642db7033e03b69
Merge: 3a494318b14b 268d28371cd3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 3 23:29:23 2012 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge (part 1) from Dave Airlie:
     "So first of all my tree and uapi stuff has a conflict mess, its my
      fault as the nouveau stuff didn't hit -next as were trying to rebase
      regressions out of it before we merged.
    
      Highlights:
       - SH mobile modesetting driver and associated helpers
       - some DRM core documentation
       - i915 modesetting rework, haswell hdmi, haswell and vlv fixes, write
         combined pte writing, ilk rc6 support,
       - nouveau: major driver rework into a hw core driver, makes features
         like SLI a lot saner to implement,
       - psb: add eDP/DP support for Cedarview
       - radeon: 2 layer page tables, async VM pte updates, better PLL
         selection for > 2 screens, better ACPI interactions
    
      The rest is general grab bag of fixes.
    
      So why part 1? well I have the exynos pull req which came in a bit
      late but was waiting for me to do something they shouldn't have and it
      looks fairly safe, and David Howells has some more header cleanups
      he'd like me to pull, that seem like a good idea, but I'd like to get
      this merge out of the way so -next dosen't get blocked."
    
    Tons of conflicts mostly due to silly include line changes, but mostly
    mindless.  A few other small semantic conflicts too, noted from Dave's
    pre-merged branch.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (447 commits)
      drm/nv98/crypt: fix fuc build with latest envyas
      drm/nouveau/devinit: fixup various issues with subdev ctor/init ordering
      drm/nv41/vm: fix and enable use of "real" pciegart
      drm/nv44/vm: fix and enable use of "real" pciegart
      drm/nv04/dmaobj: fixup vm target handling in preparation for nv4x pcie
      drm/nouveau: store supported dma mask in vmmgr
      drm/nvc0/ibus: initial implementation of subdev
      drm/nouveau/therm: add support for fan-control modes
      drm/nouveau/hwmon: rename pwm0* to pmw1* to follow hwmon's rules
      drm/nouveau/therm: calculate the pwm divisor on nv50+
      drm/nouveau/fan: rewrite the fan tachometer driver to get more precision, faster
      drm/nouveau/therm: move thermal-related functions to the therm subdev
      drm/nouveau/bios: parse the pwm divisor from the perf table
      drm/nouveau/therm: use the EXTDEV table to detect i2c monitoring devices
      drm/nouveau/therm: rework thermal table parsing
      drm/nouveau/gpio: expose the PWM/TOGGLE parameter found in the gpio vbios table
      drm/nouveau: fix pm initialization order
      drm/nouveau/bios: check that fixed tvdac gpio data is valid before using it
      drm/nouveau: log channel debug/error messages from client object rather than drm client
      drm/nouveau: have drm debugging macros build on top of core macros
      ...

commit 760285e7e7ab282c25b5e90816f7c47000557f4f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:07 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in drivers/gpu/
    
    Convert #include "..." to #include <path/...> in drivers/gpu/.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a0819f4085d3..f6825324e72d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -28,15 +28,15 @@
  */
 
 #include <linux/device.h>
-#include "drmP.h"
-#include "i915_drm.h"
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
 #include "i915_drv.h"
 #include "i915_trace.h"
 #include "intel_drv.h"
 
 #include <linux/console.h>
 #include <linux/module.h>
-#include "drm_crtc_helper.h"
+#include <drm/drm_crtc_helper.h>
 
 static int i915_modeset __read_mostly = -1;
 module_param_named(modeset, i915_modeset, int, 0400);

commit 4126d5d61f8466be3f76c1bc4e16d46eb2c9641b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:05 2012 +0100

    UAPI: (Scripted) Remove redundant DRM UAPI header #inclusions from drivers/gpu/.
    
    Remove redundant DRM UAPI header #inclusions from drivers/gpu/.
    
    Remove redundant #inclusions of core DRM UAPI headers (drm.h, drm_mode.h and
    drm_sarea.h).  They are now #included via drmP.h and drm_crtc.h via a preceding
    patch.
    
    Without this patch and the patch to make include the UAPI headers from the core
    headers, after the UAPI split, the DRM C sources cannot find these UAPI headers
    because the DRM code relies on specific -I flags to make #include "..."  work
    on headers in include/drm/ - but that does not work after the UAPI split without
    adding more -I flags.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a24ffbe97c01..a0819f4085d3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -29,7 +29,6 @@
 
 #include <linux/device.h>
 #include "drmP.h"
-#include "drm.h"
 #include "i915_drm.h"
 #include "i915_drv.h"
 #include "i915_trace.h"

commit a1ceb677518a16903c3656c7079f9611315a0422
Merge: 8c3f929b6147 b980514c9adf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Sep 6 22:51:48 2012 +0200

    Merge the modeset-rework, basic conversion into drm-intel-next
    
    As a quick reference I'll detail the motivation and design of the new code a
    bit here (mostly stitched together from patchbomb announcements and commits
    introducing the new concepts).
    
    The crtc helper code has the fundamental assumption that encoders and crtcs can
    be enabled/disabled in any order, as long as we take care of depencies (which
    means that enabled encoders need an enabled crtc to feed them data,
    essentially).
    
    Our hw works differently. We already have tons of ugly cases where crtc code
    enables encoder hw (or encoder->mode_set enables stuff that should only be
    enabled in enocder->commit) to work around these issues. But on the disable
    side we can't pull off similar tricks - there we actually need to rework the
    modeset sequence that controls all this. And this is also the real motivation
    why I've finally undertaken this rewrite: eDP on my shiny new Ivybridge
    Ultrabook is broken, and it's broken due to the wrong disable sequence ...
    
    The new code introduces a few interfaces and concepts:
    
    - Add new encoder->enable/disable functions which are directly called from the
    crtc->enable/disable function. This ensures that the encoder's can be
    enabled/disabled at a very specific in the modeset sequence, controlled by our
    platform specific code (instead of the crtc helper code calling them at a time
    it deems convenient).
    
    - Rework the dpms code - our code has mostly 1:1 connector:encoder mappings and
    does support cloning on only a few encoders, so we can simplify things quite a
    bit.
    
    - Also only ever disable/enable the entire output pipeline. This ensures that
    we obey the right sequence of enabling/disabling things, trying to be clever
    here mostly just complicates the code and results in bugs. For cloneable
    encoders this requires a bit of special handling to ensure that outputs can
    still be disabled individually, but it simplifies the common case.
    
    - Add infrastructure to read out the current hw state. No amount of careful
    ordering will help us if we brick the hw on the initial modeset setup. Which
    could happen if we just randomly disable things, oblivious to the state set up
    by the bios. Hence we need to be able to read that out. As a benefit, we grow a
    few generic functions useful to cross-check our modeset code with actual hw
    state.
    
    With all this in place, we can copy&paste the crtc helper code into the
    drm/i915 driver and start to rework it:
    
    - As detailed above, the new code only disables/enables an entire output pipe.
    As a preparation for global mode-changes (e.g. reassigning shared resources) it
    keeps track of which pipes need to be touched by a set of bitmasks.
    
    - To ensure that we correctly disable the current display pipes, we need to
    know the currently active connector/encoder/crtc linking. The old crtc helper
    simply overwrote these links with the new setup, the new code stages the new
    links in ->new_* pointers. Those get commited to the real linking pointers once
    the old output configuration has been torn down, before the ->mode_set
    callbacks are called.
    
    - Finally the code adds tons of self-consistency checks by employing the new hw
    state readout functions to cross-check the actual hw state with what the
    datastructure think it should be. These checks are done both after every
    modeset and after the hw state has been read out and sanitized at boot/resume
    time. All these checks greatly helped in tracking down regressions and bugs in
    the new code.
    
    With this new basis, a lot of cleanups and improvements to the code are now
    possible (besides the DP fixes that ultimately made me write this), but not yet
    done:
    
    - I think we should create struct intel_mode and use it as the adjusted mode
    everywhere to store little pieces like needs_tvclock, pipe dithering values or
    dp link parameters. That would still be a layering violation, but at least we
    wouldn't need to recompute these kinds of things in intel_display.c. Especially
    the port bpc computation needed for selecting the pipe bpc and dithering
    settings in intel_display.c is rather gross.
    
    - In a related rework we could implement ->mode_valid in terms of ->mode_fixup
    in a generic way - I've hunted down too many bugs where ->mode_valid did the
    right thing, but ->mode_fixup didn't. Or vice versa, resulting in funny bugs
    for user-supplied modes.
    
    - Ditch the idea to rework the hdp handling in the common crtc helper code and
    just move things to i915.ko. Which would rid us of the ->detect crtc helper
    dependencies.
    
    - LVDS wire pair and pll enabling is all done in the crtc->mode_set function
    currently. We should be able to move this to the crtc_enable callbacks (or in
    the case of the LVDS wire pair enabling, into some encoder callback).
    
    Last, but not least, this new code should also help in enabling a few neat
    features: The hw state readout code prepares (but there are still big pieces
    missing) for fastboot, i.e. avoiding the inital modeset at boot-up and just
    taking over the configuration left behind by the bios. We also should be able
    to extend the configuration checks in the beginning of the modeset sequence and
    make better decisions about shared resources (which is the entire point behind
    the atomic/global modeset ioctl).
    
    Tested-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Ben Widawsky <ben@bwidawsk.net>
    Tested-by: Damien Lespiau <damien.lespiau@intel.com>
    Tested-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: Vijay Purushothaman <vijay.a.purushothaman@intel.com>
    Acked-by: Vijay Purushothaman <vijay.a.purushothaman@intel.com>
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Acked-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Tested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 9dc10f37e326d5d789929e1886b5a8089ccee5a7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 29 22:58:07 2012 +0200

    drm/i915: no longer call drm_helper_resume_force_mode
    
    Since this only calls crtc helper functions, of which a shocking
    amount are NULL.
    
    Now the curious thing is how the new modeset code worked with this
    function call still present:
    
    Thanks to the hw state readout and the suspend fixes to properly
    quiescent the register state, nothing is actually enabled at resume
    (if the bios doesn't set up anything). Which means resume_force_mode
    doesn't actually do anything and hence nothing blows up at resume
    time.
    
    The other reason things do work is that the fbcon layer has it's own
    resume notifier callback, which restores the mode. And thanks to the
    force vt switch at suspend/resume, that then forces X to restore it's
    own mode.
    
    Hence everything still worked (as long as the bios doesn't enable
    anything). And we can just kill the call to resume_force_mode.
    
    The upside of both this patch and the preceeding patch to quiescent
    the modeset state is that our resume path is much simpler:
    - We now longer restore bogus register values (which most often would
      enable the backlight a bit and a few ports), causing flickering.
    - We now longer call resume_force_mode to restore a mode that the
      fbcon layer would overwrite right away anyway.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fe7512ae3945..cd6697c98c5a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -549,11 +549,6 @@ static int i915_drm_thaw(struct drm_device *dev)
 		intel_modeset_setup_hw_state(dev);
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
-
-		/* Resume the modeset for every activated CRTC */
-		mutex_lock(&dev->mode_config.mutex);
-		drm_helper_resume_force_mode(dev);
-		mutex_unlock(&dev->mode_config.mutex);
 	}
 
 	intel_opregion_init(dev);

commit a261b246ebd552fd5d5a8ed84cc931bb821c427f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 26 19:21:47 2012 +0200

    drm/i915: disable all crtcs at suspend time
    
    We need this to avoid confusing the hw state readout code with the cpt
    pch plls at resume time: We'd read the new pipe state (which is
    disabled), but still believe that we have a life pll connected to that
    pipe (from before the suspend). Hence properly disable pipes to clear
    out all the residual state.
    
    This has the neat side-effect that we don't enable ports prematurely
    by restoring bogus state from the saved register values.
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4abac6d6c3e6..fe7512ae3945 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -470,6 +470,9 @@ static int i915_drm_freeze(struct drm_device *dev)
 				"GEM idle failed, resume might fail\n");
 			return error;
 		}
+
+		intel_modeset_disable(dev);
+
 		drm_irq_uninstall(dev);
 	}
 

commit 24929352481f085c5f85d4d4cbc919ddf106d381
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 2 20:28:59 2012 +0200

    drm/i915: read out the modeset hw state at load and resume time
    
    ... instead of resetting a few things and hoping that this will work
    out.
    
    To properly disable the output pipelines at the initial modeset after
    resume or boot up we need to have an accurate picture of which outputs
    are enabled and connected to which crtcs. Otherwise we risk disabling
    things at the wrong time, which can lead to hangs (or at least royally
    confused panels), both requiring a walk to the reset button to fix.
    
    Hence read out the hw state with the freshly introduce get_hw_state
    functions and then sanitize it afterwards.
    
    For a full modeset readout (which would allow us to avoid the initial
    modeset at boot up) a few things are still missing:
    - Reading out the mode from the pipe, especially the dotclock
      computation is quite some fun.
    - Reading out the parameters for the stolen memory framebuffer and
      wrapping it up.
    - Reading out the pch pll connections - luckily the disable code
      simply bails out if the crtc doesn't have a pch pll attached (even
      for configurations that would need one).
    
    This patch here turned up tons of smelly stuff around resume: We
    restore tons of register in seemingly random way (well, not quite, but
    we're not too careful either), which leaves the hw in a rather
    ill-defined state: E.g. the port registers are sometimes
    unconditionally restore (lvds, crt), leaving us with an active
    encoder/connector but no active pipe connected to it. Luckily the hw
    state sanitizer detects this madness and fixes things up a bit.
    
    v2: When checking whether an encoder with active connectors has a crtc
    wire up to it, check for both the crtc _and_ it's active state.
    
    v3:
    - Extract intel_sanitize_encoder.
    - Manually disable active encoders without an active pipe.
    
    v4: Correclty fix up the pipe<->plane mapping on machines where we
    switch pipes/planes. Noticed by Chris Wilson, who also provided the
    fixup.
    
    v5: Spelling fix in a comment, noticed by Paulo Zanoni
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7ebb13b65133..4abac6d6c3e6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -543,6 +543,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 		mutex_unlock(&dev->struct_mutex);
 
 		intel_modeset_init_hw(dev);
+		intel_modeset_setup_hw_state(dev);
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 

commit b4c145c1d245c2cc19754dbe4b718f5a48755993
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Aug 20 16:15:14 2012 -0700

    drm/i915: Find unclaimed MMIO writes.
    
    ERR_INT on HSW will display unclaimed MMIO accesses. This can be either
    the result of a driver bug writing to an invalid addresses, or the
    result of RC6.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Antti Koskipaa <antti.koskipaa@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7ebb13b65133..7f3863fb138c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1174,6 +1174,10 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 	if (unlikely(__fifo_ret)) { \
 		gen6_gt_check_fifodbg(dev_priv); \
 	} \
+	if (IS_HASWELL(dev_priv->dev) && (I915_READ_NOTRACE(GEN7_ERR_INT) & ERR_INT_MMIO_UNCLAIMED)) { \
+		DRM_ERROR("Unclaimed write to %x\n", reg); \
+		writel(ERR_INT_MMIO_UNCLAIMED, dev_priv->regs + GEN7_ERR_INT);	\
+	} \
 }
 __i915_write(8, b)
 __i915_write(16, w)

commit a22ddff8bedfe33eeb1330bbb7ef1fbe007a42c4
Merge: 20d5a540e55a d9875690d9b8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 17 08:57:56 2012 +0200

    Merge tag 'v3.6-rc2' into drm-intel-next
    
    Backmerge Linux 3.6-rc2 to resolve a few funny conflicts before we put
    even more madness on top:
    
    - drivers/gpu/drm/i915/i915_irq.c: Just a spurious WARN removed in
      -fixes, that has been changed in a variable-rename in -next, too.
    
    - drivers/gpu/drm/i915/intel_ringbuffer.c: -next remove scratch_addr
      (since all their users have been extracted in another fucntion),
      -fixes added another user for a hw workaroudn.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit da612d880fbc598ac0efcef579355fb90d4bca4e
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Mon Aug 6 18:45:01 2012 -0300

    drm/i915: add more Haswell PCI IDs
    
    Also properly indent the HB IDs.
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ed22612bc847..a24ffbe97c01 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -346,11 +346,40 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
 	INTEL_VGA_DEVICE(0x0402, &intel_haswell_d_info), /* GT1 desktop */
 	INTEL_VGA_DEVICE(0x0412, &intel_haswell_d_info), /* GT2 desktop */
+	INTEL_VGA_DEVICE(0x0422, &intel_haswell_d_info), /* GT2 desktop */
 	INTEL_VGA_DEVICE(0x040a, &intel_haswell_d_info), /* GT1 server */
 	INTEL_VGA_DEVICE(0x041a, &intel_haswell_d_info), /* GT2 server */
+	INTEL_VGA_DEVICE(0x042a, &intel_haswell_d_info), /* GT2 server */
 	INTEL_VGA_DEVICE(0x0406, &intel_haswell_m_info), /* GT1 mobile */
 	INTEL_VGA_DEVICE(0x0416, &intel_haswell_m_info), /* GT2 mobile */
-	INTEL_VGA_DEVICE(0x0c16, &intel_haswell_d_info), /* SDV */
+	INTEL_VGA_DEVICE(0x0426, &intel_haswell_m_info), /* GT2 mobile */
+	INTEL_VGA_DEVICE(0x0C02, &intel_haswell_d_info), /* SDV GT1 desktop */
+	INTEL_VGA_DEVICE(0x0C12, &intel_haswell_d_info), /* SDV GT2 desktop */
+	INTEL_VGA_DEVICE(0x0C22, &intel_haswell_d_info), /* SDV GT2 desktop */
+	INTEL_VGA_DEVICE(0x0C0A, &intel_haswell_d_info), /* SDV GT1 server */
+	INTEL_VGA_DEVICE(0x0C1A, &intel_haswell_d_info), /* SDV GT2 server */
+	INTEL_VGA_DEVICE(0x0C2A, &intel_haswell_d_info), /* SDV GT2 server */
+	INTEL_VGA_DEVICE(0x0C06, &intel_haswell_m_info), /* SDV GT1 mobile */
+	INTEL_VGA_DEVICE(0x0C16, &intel_haswell_m_info), /* SDV GT2 mobile */
+	INTEL_VGA_DEVICE(0x0C26, &intel_haswell_m_info), /* SDV GT2 mobile */
+	INTEL_VGA_DEVICE(0x0A02, &intel_haswell_d_info), /* ULT GT1 desktop */
+	INTEL_VGA_DEVICE(0x0A12, &intel_haswell_d_info), /* ULT GT2 desktop */
+	INTEL_VGA_DEVICE(0x0A22, &intel_haswell_d_info), /* ULT GT2 desktop */
+	INTEL_VGA_DEVICE(0x0A0A, &intel_haswell_d_info), /* ULT GT1 server */
+	INTEL_VGA_DEVICE(0x0A1A, &intel_haswell_d_info), /* ULT GT2 server */
+	INTEL_VGA_DEVICE(0x0A2A, &intel_haswell_d_info), /* ULT GT2 server */
+	INTEL_VGA_DEVICE(0x0A06, &intel_haswell_m_info), /* ULT GT1 mobile */
+	INTEL_VGA_DEVICE(0x0A16, &intel_haswell_m_info), /* ULT GT2 mobile */
+	INTEL_VGA_DEVICE(0x0A26, &intel_haswell_m_info), /* ULT GT2 mobile */
+	INTEL_VGA_DEVICE(0x0D12, &intel_haswell_d_info), /* CRW GT1 desktop */
+	INTEL_VGA_DEVICE(0x0D22, &intel_haswell_d_info), /* CRW GT2 desktop */
+	INTEL_VGA_DEVICE(0x0D32, &intel_haswell_d_info), /* CRW GT2 desktop */
+	INTEL_VGA_DEVICE(0x0D1A, &intel_haswell_d_info), /* CRW GT1 server */
+	INTEL_VGA_DEVICE(0x0D2A, &intel_haswell_d_info), /* CRW GT2 server */
+	INTEL_VGA_DEVICE(0x0D3A, &intel_haswell_d_info), /* CRW GT2 server */
+	INTEL_VGA_DEVICE(0x0D16, &intel_haswell_m_info), /* CRW GT1 mobile */
+	INTEL_VGA_DEVICE(0x0D26, &intel_haswell_m_info), /* CRW GT2 mobile */
+	INTEL_VGA_DEVICE(0x0D36, &intel_haswell_m_info), /* CRW GT2 mobile */
 	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0157, &intel_valleyview_m_info),
 	INTEL_VGA_DEVICE(0x0155, &intel_valleyview_d_info),

commit a7e806de4e53f7496a6701194d736a92a80db5b3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jul 11 16:27:55 2012 +0200

    drm/i915: create VLV_DSIPLAY_BASE #define
    
    Will be used more in the next patch.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ab3b9d38e153..ff569cc35376 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1031,7 +1031,7 @@ static bool IS_DISPLAYREG(u32 reg)
 	 * This should make it easier to transition modules over to the
 	 * new register block scheme, since we can do it incrementally.
 	 */
-	if (reg >= 0x180000)
+	if (reg >= VLV_DISPLAY_BASE)
 		return false;
 
 	if (reg >= RENDER_RING_BASE &&

commit c0c7babc48c4f6943ed3070d04630ea3ac9272ee
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Thu Jul 12 11:01:05 2012 -0700

    drm/i915: add register read IOCTL
    
    The interface's immediate purpose is to do synchronous timestamp queries
    as required by GL_TIMESTAMP. The GPU has a register for reading the
    timestamp but because that would normally require root access through
    libpciaccess, the IOCTL can provide this service instead.
    
    Currently the implementation whitelists only the render ring timestamp
    register, because that is the only thing we need to expose at this time.
    
    v2: make size implicit based on the register offset
    Add a generation check
    
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Cc: Jacek Lawrynowicz <jacek.lawrynowicz@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    [danvet: fixup the ioctl numerb:]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ed22612bc847..ab3b9d38e153 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1151,3 +1151,49 @@ __i915_write(16, w)
 __i915_write(32, l)
 __i915_write(64, q)
 #undef __i915_write
+
+static const struct register_whitelist {
+	uint64_t offset;
+	uint32_t size;
+	uint32_t gen_bitmask; /* support gens, 0x10 for 4, 0x30 for 4 and 5, etc. */
+} whitelist[] = {
+	{ RING_TIMESTAMP(RENDER_RING_BASE), 8, 0xF0 },
+};
+
+int i915_reg_read_ioctl(struct drm_device *dev,
+			void *data, struct drm_file *file)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_reg_read *reg = data;
+	struct register_whitelist const *entry = whitelist;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(whitelist); i++, entry++) {
+		if (entry->offset == reg->offset &&
+		    (1 << INTEL_INFO(dev)->gen & entry->gen_bitmask))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(whitelist))
+		return -EINVAL;
+
+	switch (entry->size) {
+	case 8:
+		reg->val = I915_READ64(reg->offset);
+		break;
+	case 4:
+		reg->val = I915_READ(reg->offset);
+		break;
+	case 2:
+		reg->val = I915_READ16(reg->offset);
+		break;
+	case 1:
+		reg->val = I915_READ8(reg->offset);
+		break;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	return 0;
+}

commit b0071efe827f68cf173e1a8868b70618e9aca7d7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 26 00:20:57 2011 +0200

    drm: kill reclaim_buffers callback
    
    All leftover users either haven't set DRIVER_HAVE_DMA, in which
    case this will never be called, or use the drm_core implementation.
    
    Call that directly in the only callsite.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e754cdfaec79..ed22612bc847 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -940,7 +940,6 @@ static struct drm_driver driver = {
 	.resume = i915_resume,
 
 	.device_is_agp = i915_driver_device_is_agp,
-	.reclaim_buffers = drm_core_reclaim_buffers,
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,
 #if defined(CONFIG_DEBUG_FS)

commit d54a02c041ccfdcfe3efcd1e5b90c6e8d5e7a8d9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jul 4 22:18:39 2012 +0200

    drm/i915: don't trylock in the gpu reset code
    
    Simply failing to reset the gpu because someone else might still hold
    the mutex isn't a great idea - I see reliable silent reset failures.
    And gpu reset simply needs to be reliable and Just Work.
    
    "But ... the deadlocks!"
    
    We already kick all processes waiting for the gpu before launching the
    reset work item. New waiters need to check the wedging state anyway
    and then bail out. If we have places that can deadlock, we simply need
    to fix them.
    
    "But ... testing!"
    
    We have the gpu hangman, and if the current gpu load gem_exec_nop
    isn't good enough to hit a specific case, we can add a new one.
    
    "But ...  don't we return -EAGAIN for non-interruptible calls to
    wait_seqno now?"
    
    Yep, but this problem already exists in the current code. A follow up
    patch will remedy this by returning -EIO for non-interruptible sleeps
    if the gpu died and the low-level wait bails out with -EAGAIN.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6edb2d5ec13c..e754cdfaec79 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -730,8 +730,7 @@ int i915_reset(struct drm_device *dev)
 	if (!i915_try_reset)
 		return 0;
 
-	if (!mutex_trylock(&dev->struct_mutex))
-		return -EBUSY;
+	mutex_lock(&dev->struct_mutex);
 
 	i915_gem_reset(dev);
 

commit 40579abed0624ce1dd0e54da312566dcc5f0622a
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Jul 3 15:57:33 2012 -0300

    drm/i915: don't ironlake_init_pch_refclk() on LPT
    
    This function is used to set the PCH_DREF_CONTROL register, which does
    not exist on LPT anymore.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f2c0100e0630..6edb2d5ec13c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -504,7 +504,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		if (HAS_PCH_SPLIT(dev))
+		if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
 			ironlake_init_pch_refclk(dev);
 
 		mutex_lock(&dev->struct_mutex);

commit 45e6e3a1cd2f53fd5996e75b4029defed97ca585
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Jul 3 15:57:32 2012 -0300

    drm/i915: get rid of dev_priv->info->has_pch_split
    
    Previously we had has_pch_split to tell us whether we had a PCH or not
    and we also had dev_priv->pch_type to tell us which kind of PCH it
    was, but it could only be used if we were 100% sure we did have a PCH.
    Now that PCH_NONE was added to dev_priv->pch_type we don't need
    has_pch_split anymore: we can just check for pch_type != PCH_NONE.
    
    The HAS_PCH_{IBX,CPT,LPT} macros use dev_priv->pch_type, so they can
    only be called after intel_detect_pch. The HAS_PCH_SPLIT macro looks
    at dev_priv->info->has_pch_split, which is available earlier.
    
    Since the goal is to implement HAS_PCH_SPLIT using dev_priv->pch_type
    instead of dev_priv->info->has_pch_split, we need to make sure that
    intel_detect_pch is called before any calls to HAS_PCH_SPLIT are made.
    So we moved the intel_detect_pch call to an earlier stage.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c7e76e03a684..f2c0100e0630 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -216,7 +216,6 @@ static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
-	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
@@ -224,7 +223,6 @@ static const struct intel_device_info intel_ironlake_m_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
 	.has_bsd_ring = 1,
-	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
@@ -233,7 +231,6 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 
@@ -244,7 +241,6 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 
@@ -254,7 +250,6 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 
@@ -265,7 +260,6 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 
@@ -293,7 +287,6 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 
@@ -303,7 +296,6 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
-	.has_pch_split = 1,
 	.has_force_wake = 1,
 };
 

commit 6590190d12442b94e83f4f4590f3bb5d2848dd07
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Mon Jul 2 11:51:11 2012 -0300

    drm/i915: move force wake support into intel_pm
    
    This commit moves force wake support routines into intel_pm modules, and
    exports the gen6_gt_check_fifodbg routine (used in I915_READ).
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ac414ff7f84..c7e76e03a684 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -433,197 +433,6 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return 1;
 }
 
-static void __gen6_gt_wait_for_thread_c0(struct drm_i915_private *dev_priv)
-{
-	u32 gt_thread_status_mask;
-
-	if (IS_HASWELL(dev_priv->dev))
-		gt_thread_status_mask = GEN6_GT_THREAD_STATUS_CORE_MASK_HSW;
-	else
-		gt_thread_status_mask = GEN6_GT_THREAD_STATUS_CORE_MASK;
-
-	/* w/a for a sporadic read returning 0 by waiting for the GT
-	 * thread to wake up.
-	 */
-	if (wait_for_atomic_us((I915_READ_NOTRACE(GEN6_GT_THREAD_STATUS_REG) & gt_thread_status_mask) == 0, 500))
-		DRM_ERROR("GT thread status wait timed out\n");
-}
-
-static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
-{
-	u32 forcewake_ack;
-
-	if (IS_HASWELL(dev_priv->dev))
-		forcewake_ack = FORCEWAKE_ACK_HSW;
-	else
-		forcewake_ack = FORCEWAKE_ACK;
-
-	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1) == 0, 500))
-		DRM_ERROR("Force wake wait timed out\n");
-
-	I915_WRITE_NOTRACE(FORCEWAKE, 1);
-
-	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1), 500))
-		DRM_ERROR("Force wake wait timed out\n");
-
-	__gen6_gt_wait_for_thread_c0(dev_priv);
-}
-
-static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
-{
-	u32 forcewake_ack;
-
-	if (IS_HASWELL(dev_priv->dev))
-		forcewake_ack = FORCEWAKE_ACK_HSW;
-	else
-		forcewake_ack = FORCEWAKE_MT_ACK;
-
-	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1) == 0, 500))
-		DRM_ERROR("Force wake wait timed out\n");
-
-	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_ENABLE(1));
-
-	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1), 500))
-		DRM_ERROR("Force wake wait timed out\n");
-
-	__gen6_gt_wait_for_thread_c0(dev_priv);
-}
-
-/*
- * Generally this is called implicitly by the register read function. However,
- * if some sequence requires the GT to not power down then this function should
- * be called at the beginning of the sequence followed by a call to
- * gen6_gt_force_wake_put() at the end of the sequence.
- */
-void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
-{
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
-	if (dev_priv->forcewake_count++ == 0)
-		dev_priv->gt.force_wake_get(dev_priv);
-	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
-}
-
-static void gen6_gt_check_fifodbg(struct drm_i915_private *dev_priv)
-{
-	u32 gtfifodbg;
-	gtfifodbg = I915_READ_NOTRACE(GTFIFODBG);
-	if (WARN(gtfifodbg & GT_FIFO_CPU_ERROR_MASK,
-	     "MMIO read or write has been dropped %x\n", gtfifodbg))
-		I915_WRITE_NOTRACE(GTFIFODBG, GT_FIFO_CPU_ERROR_MASK);
-}
-
-static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
-{
-	I915_WRITE_NOTRACE(FORCEWAKE, 0);
-	/* The below doubles as a POSTING_READ */
-	gen6_gt_check_fifodbg(dev_priv);
-}
-
-static void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
-{
-	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_DISABLE(1));
-	/* The below doubles as a POSTING_READ */
-	gen6_gt_check_fifodbg(dev_priv);
-}
-
-/*
- * see gen6_gt_force_wake_get()
- */
-void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
-{
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
-	if (--dev_priv->forcewake_count == 0)
-		dev_priv->gt.force_wake_put(dev_priv);
-	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
-}
-
-int __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
-{
-	int ret = 0;
-
-	if (dev_priv->gt_fifo_count < GT_FIFO_NUM_RESERVED_ENTRIES) {
-		int loop = 500;
-		u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
-		while (fifo <= GT_FIFO_NUM_RESERVED_ENTRIES && loop--) {
-			udelay(10);
-			fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
-		}
-		if (WARN_ON(loop < 0 && fifo <= GT_FIFO_NUM_RESERVED_ENTRIES))
-			++ret;
-		dev_priv->gt_fifo_count = fifo;
-	}
-	dev_priv->gt_fifo_count--;
-
-	return ret;
-}
-
-static void vlv_force_wake_get(struct drm_i915_private *dev_priv)
-{
-	/* Already awake? */
-	if ((I915_READ(0x130094) & 0xa1) == 0xa1)
-		return;
-
-	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffffffff);
-	POSTING_READ(FORCEWAKE_VLV);
-
-	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK_VLV) & 1), 500))
-		DRM_ERROR("Force wake wait timed out\n");
-
-	__gen6_gt_wait_for_thread_c0(dev_priv);
-}
-
-static void vlv_force_wake_put(struct drm_i915_private *dev_priv)
-{
-	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffff0000);
-	/* FIXME: confirm VLV behavior with Punit folks */
-	POSTING_READ(FORCEWAKE_VLV);
-}
-
-void intel_gt_init(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
-	spin_lock_init(&dev_priv->gt_lock);
-
-	if (IS_VALLEYVIEW(dev)) {
-		dev_priv->gt.force_wake_get = vlv_force_wake_get;
-		dev_priv->gt.force_wake_put = vlv_force_wake_put;
-	} else if (INTEL_INFO(dev)->gen >= 6) {
-		dev_priv->gt.force_wake_get = __gen6_gt_force_wake_get;
-		dev_priv->gt.force_wake_put = __gen6_gt_force_wake_put;
-
-		/* IVB configs may use multi-threaded forcewake */
-		if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev)) {
-			u32 ecobus;
-
-			/* A small trick here - if the bios hasn't configured
-			 * MT forcewake, and if the device is in RC6, then
-			 * force_wake_mt_get will not wake the device and the
-			 * ECOBUS read will return zero. Which will be
-			 * (correctly) interpreted by the test below as MT
-			 * forcewake being disabled.
-			 */
-			mutex_lock(&dev->struct_mutex);
-			__gen6_gt_force_wake_mt_get(dev_priv);
-			ecobus = I915_READ_NOTRACE(ECOBUS);
-			__gen6_gt_force_wake_mt_put(dev_priv);
-			mutex_unlock(&dev->struct_mutex);
-
-			if (ecobus & FORCEWAKE_MT_ENABLE) {
-				DRM_DEBUG_KMS("Using MT version of forcewake\n");
-				dev_priv->gt.force_wake_get =
-					__gen6_gt_force_wake_mt_get;
-				dev_priv->gt.force_wake_put =
-					__gen6_gt_force_wake_mt_put;
-			}
-		}
-	}
-}
-
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;

commit e7911c48a05bc0002616a51e99761dec36110b04
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Mon Jul 2 11:51:04 2012 -0300

    drm/i915: support Haswell force waking
    
    There is a different ACK register for force wake on Haswell, so account
    for that.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a4ea4a9fc425..3ac414ff7f84 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -451,12 +451,19 @@ static void __gen6_gt_wait_for_thread_c0(struct drm_i915_private *dev_priv)
 
 static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
-	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1) == 0, 500))
+	u32 forcewake_ack;
+
+	if (IS_HASWELL(dev_priv->dev))
+		forcewake_ack = FORCEWAKE_ACK_HSW;
+	else
+		forcewake_ack = FORCEWAKE_ACK;
+
+	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1) == 0, 500))
 		DRM_ERROR("Force wake wait timed out\n");
 
 	I915_WRITE_NOTRACE(FORCEWAKE, 1);
 
-	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1), 500))
+	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1), 500))
 		DRM_ERROR("Force wake wait timed out\n");
 
 	__gen6_gt_wait_for_thread_c0(dev_priv);
@@ -464,12 +471,19 @@ static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 
 static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
 {
-	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1) == 0, 500))
+	u32 forcewake_ack;
+
+	if (IS_HASWELL(dev_priv->dev))
+		forcewake_ack = FORCEWAKE_ACK_HSW;
+	else
+		forcewake_ack = FORCEWAKE_MT_ACK;
+
+	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1) == 0, 500))
 		DRM_ERROR("Force wake wait timed out\n");
 
 	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_ENABLE(1));
 
-	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1), 500))
+	if (wait_for_atomic_us((I915_READ_NOTRACE(forcewake_ack) & 1), 500))
 		DRM_ERROR("Force wake wait timed out\n");
 
 	__gen6_gt_wait_for_thread_c0(dev_priv);

commit c4de7b0ffda2bb4843fd7f1052d0a2bb90bd08a5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 2 11:51:03 2012 -0300

    drm/i915: Implement w/a for sporadic read failures on waking from rc6
    
    As a w/a to prevent reads sporadically returning 0, we need to wait for
    the GT thread to return to TC0 before proceeding to read the registers.
    
    v2: adapt for Haswell changes (Eugeni).
    
    v3: use wait_for_atomic_us for thread status polling.
    
    v3: *really* use wait_for_atomic for polling.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=50243
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 928b6677759d..a4ea4a9fc425 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -433,6 +433,22 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return 1;
 }
 
+static void __gen6_gt_wait_for_thread_c0(struct drm_i915_private *dev_priv)
+{
+	u32 gt_thread_status_mask;
+
+	if (IS_HASWELL(dev_priv->dev))
+		gt_thread_status_mask = GEN6_GT_THREAD_STATUS_CORE_MASK_HSW;
+	else
+		gt_thread_status_mask = GEN6_GT_THREAD_STATUS_CORE_MASK;
+
+	/* w/a for a sporadic read returning 0 by waiting for the GT
+	 * thread to wake up.
+	 */
+	if (wait_for_atomic_us((I915_READ_NOTRACE(GEN6_GT_THREAD_STATUS_REG) & gt_thread_status_mask) == 0, 500))
+		DRM_ERROR("GT thread status wait timed out\n");
+}
+
 static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
 	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1) == 0, 500))
@@ -442,6 +458,8 @@ static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 
 	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1), 500))
 		DRM_ERROR("Force wake wait timed out\n");
+
+	__gen6_gt_wait_for_thread_c0(dev_priv);
 }
 
 static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
@@ -453,6 +471,8 @@ static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
 
 	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1), 500))
 		DRM_ERROR("Force wake wait timed out\n");
+
+	__gen6_gt_wait_for_thread_c0(dev_priv);
 }
 
 /*
@@ -538,6 +558,8 @@ static void vlv_force_wake_get(struct drm_i915_private *dev_priv)
 
 	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK_VLV) & 1), 500))
 		DRM_ERROR("Force wake wait timed out\n");
+
+	__gen6_gt_wait_for_thread_c0(dev_priv);
 }
 
 static void vlv_force_wake_put(struct drm_i915_private *dev_priv)

commit 990bbdadabaa51828e475eda86ee5720a4910cc3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 2 11:51:02 2012 -0300

    drm/i915: Group the GT routines together in both code and vtable
    
    Tidy up the routines for interacting with the GT (in particular the
    forcewake dance) which are scattered throughout the code in a single
    structure.
    
    v2: use wait_for_atomic for polling.
    
    v3: *really* use wait_for_atomic for polling.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 79be8799ea6c..928b6677759d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -32,6 +32,7 @@
 #include "drm.h"
 #include "i915_drm.h"
 #include "i915_drv.h"
+#include "i915_trace.h"
 #include "intel_drv.h"
 
 #include <linux/console.h>
@@ -432,36 +433,26 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	return 1;
 }
 
-void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
+static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
-	int count;
-
-	count = 0;
-	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK) & 1))
-		udelay(10);
+	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1) == 0, 500))
+		DRM_ERROR("Force wake wait timed out\n");
 
 	I915_WRITE_NOTRACE(FORCEWAKE, 1);
-	POSTING_READ(FORCEWAKE);
 
-	count = 0;
-	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK) & 1) == 0)
-		udelay(10);
+	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK) & 1), 500))
+		DRM_ERROR("Force wake wait timed out\n");
 }
 
-void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
+static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
 {
-	int count;
-
-	count = 0;
-	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1))
-		udelay(10);
+	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1) == 0, 500))
+		DRM_ERROR("Force wake wait timed out\n");
 
 	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_ENABLE(1));
-	POSTING_READ(FORCEWAKE_MT);
 
-	count = 0;
-	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1) == 0)
-		udelay(10);
+	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1), 500))
+		DRM_ERROR("Force wake wait timed out\n");
 }
 
 /*
@@ -476,7 +467,7 @@ void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 
 	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
 	if (dev_priv->forcewake_count++ == 0)
-		dev_priv->display.force_wake_get(dev_priv);
+		dev_priv->gt.force_wake_get(dev_priv);
 	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
@@ -489,14 +480,14 @@ static void gen6_gt_check_fifodbg(struct drm_i915_private *dev_priv)
 		I915_WRITE_NOTRACE(GTFIFODBG, GT_FIFO_CPU_ERROR_MASK);
 }
 
-void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
+static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
 	/* The below doubles as a POSTING_READ */
 	gen6_gt_check_fifodbg(dev_priv);
 }
 
-void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
+static void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_DISABLE(1));
 	/* The below doubles as a POSTING_READ */
@@ -512,7 +503,7 @@ void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 
 	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
 	if (--dev_priv->forcewake_count == 0)
-		dev_priv->display.force_wake_put(dev_priv);
+		dev_priv->gt.force_wake_put(dev_priv);
 	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
@@ -536,12 +527,8 @@ int __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
-void vlv_force_wake_get(struct drm_i915_private *dev_priv)
+static void vlv_force_wake_get(struct drm_i915_private *dev_priv)
 {
-	int count;
-
-	count = 0;
-
 	/* Already awake? */
 	if ((I915_READ(0x130094) & 0xa1) == 0xa1)
 		return;
@@ -549,18 +536,58 @@ void vlv_force_wake_get(struct drm_i915_private *dev_priv)
 	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffffffff);
 	POSTING_READ(FORCEWAKE_VLV);
 
-	count = 0;
-	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK_VLV) & 1) == 0)
-		udelay(10);
+	if (wait_for_atomic_us((I915_READ_NOTRACE(FORCEWAKE_ACK_VLV) & 1), 500))
+		DRM_ERROR("Force wake wait timed out\n");
 }
 
-void vlv_force_wake_put(struct drm_i915_private *dev_priv)
+static void vlv_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffff0000);
 	/* FIXME: confirm VLV behavior with Punit folks */
 	POSTING_READ(FORCEWAKE_VLV);
 }
 
+void intel_gt_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	spin_lock_init(&dev_priv->gt_lock);
+
+	if (IS_VALLEYVIEW(dev)) {
+		dev_priv->gt.force_wake_get = vlv_force_wake_get;
+		dev_priv->gt.force_wake_put = vlv_force_wake_put;
+	} else if (INTEL_INFO(dev)->gen >= 6) {
+		dev_priv->gt.force_wake_get = __gen6_gt_force_wake_get;
+		dev_priv->gt.force_wake_put = __gen6_gt_force_wake_put;
+
+		/* IVB configs may use multi-threaded forcewake */
+		if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev)) {
+			u32 ecobus;
+
+			/* A small trick here - if the bios hasn't configured
+			 * MT forcewake, and if the device is in RC6, then
+			 * force_wake_mt_get will not wake the device and the
+			 * ECOBUS read will return zero. Which will be
+			 * (correctly) interpreted by the test below as MT
+			 * forcewake being disabled.
+			 */
+			mutex_lock(&dev->struct_mutex);
+			__gen6_gt_force_wake_mt_get(dev_priv);
+			ecobus = I915_READ_NOTRACE(ECOBUS);
+			__gen6_gt_force_wake_mt_put(dev_priv);
+			mutex_unlock(&dev->struct_mutex);
+
+			if (ecobus & FORCEWAKE_MT_ENABLE) {
+				DRM_DEBUG_KMS("Using MT version of forcewake\n");
+				dev_priv->gt.force_wake_get =
+					__gen6_gt_force_wake_mt_get;
+				dev_priv->gt.force_wake_put =
+					__gen6_gt_force_wake_mt_put;
+			}
+		}
+	}
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -797,9 +824,9 @@ static int gen6_do_reset(struct drm_device *dev)
 
 	/* If reset with a user forcewake, try to restore, otherwise turn it off */
 	if (dev_priv->forcewake_count)
-		dev_priv->display.force_wake_get(dev_priv);
+		dev_priv->gt.force_wake_get(dev_priv);
 	else
-		dev_priv->display.force_wake_put(dev_priv);
+		dev_priv->gt.force_wake_put(dev_priv);
 
 	/* Restore fifo count */
 	dev_priv->gt_fifo_count = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
@@ -1248,10 +1275,10 @@ u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 		unsigned long irqflags; \
 		spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
 		if (dev_priv->forcewake_count == 0) \
-			dev_priv->display.force_wake_get(dev_priv); \
+			dev_priv->gt.force_wake_get(dev_priv); \
 		val = read##y(dev_priv->regs + reg); \
 		if (dev_priv->forcewake_count == 0) \
-			dev_priv->display.force_wake_put(dev_priv); \
+			dev_priv->gt.force_wake_put(dev_priv); \
 		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
 	} else if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
 		val = read##y(dev_priv->regs + reg + 0x180000);		\

commit 01a06850fb45ace55ed67d1d9da2df553a041e40
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 25 15:58:49 2012 +0200

    drm/i915: disable drm agp support for !gen3 with kms enabled
    
    This is the quick&dirty way Dave Airlie suggested to workaround the
    midlayer drm agp brain-damange. Note that i915_probe is only called
    when the driver has ksm enabled, so no need to check for that.
    
    We also need to move the intel_agp_enabled check at the right place.
    Note that the only thing this does is enforce the correct module load
    order (by using a symbol from intel-agp.ko) to ensure that the fake
    agp driver is ready before the drm core tries to set up the agp stuff.
    
    v2: Add a comment to explain why gen3 needs all this legacy fake agp
    stuff - we've shipped an XvMC library with a kms-enabled ddx that
    requires it (but only on gen3).
    
    v3: Make it clear that this is only a gen3 issue in the comment.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a378c0800304..79be8799ea6c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -930,10 +930,12 @@ int i915_reset(struct drm_device *dev)
 	return 0;
 }
 
-
 static int __devinit
 i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
+	struct intel_device_info *intel_info =
+		(struct intel_device_info *) ent->driver_data;
+
 	/* Only bind to function 0 of the device. Early generations
 	 * used function 1 as a placeholder for multi-head. This causes
 	 * us confusion instead, especially on the systems where both
@@ -942,6 +944,18 @@ i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (PCI_FUNC(pdev->devfn))
 		return -ENODEV;
 
+	/* We've managed to ship a kms-enabled ddx that shipped with an XvMC
+	 * implementation for gen3 (and only gen3) that used legacy drm maps
+	 * (gasp!) to share buffers between X and the client. Hence we need to
+	 * keep around the fake agp stuff for gen3, even when kms is enabled. */
+	if (intel_info->gen != 3) {
+		driver.driver_features &=
+			~(DRIVER_USE_AGP | DRIVER_REQUIRE_AGP);
+	} else if (!intel_agp_enabled) {
+		DRM_ERROR("drm/i915 can't work without intel_agp module!\n");
+		return -ENODEV;
+	}
+
 	return drm_get_pci_dev(pdev, ent, &driver);
 }
 
@@ -1102,11 +1116,6 @@ static struct pci_driver i915_pci_driver = {
 
 static int __init i915_init(void)
 {
-	if (!intel_agp_enabled) {
-		DRM_ERROR("drm/i915 can't work without intel_agp module!\n");
-		return -ENODEV;
-	}
-
 	driver.num_ioctls = i915_max_ioctl;
 
 	/*

commit 7b0cfee1a24efdfe0235bac62e53f686fe8a8e24
Merge: 9756fe38d10b 6b16351acbd4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 25 19:06:12 2012 +0200

    Merge tag 'v3.5-rc4' into drm-intel-next-queued
    
    I want to merge the "no more fake agp on gen6+" patches into
    drm-intel-next (well, the last pieces). But a patch in 3.5-rc4 also
    adds a new use of dev->agp. Hence the backmarge to sort this out, for
    otherwise drm-intel-next merged into Linus' tree would conflict in the
    relevant code, things would compile but nicely OOPS at driver load :(
    
    Conflicts in this merge are just simple cases of "both branches
    changed/added lines at the same place". The only tricky part is to
    keep the order correct wrt the unwind code in case of errors in
    intel_ringbuffer.c (and the MI_DISPLAY_FLIP #defines in i915_reg.h
    together, obviously).
    
    Conflicts:
            drivers/gpu/drm/i915/i915_reg.h
            drivers/gpu/drm/i915/intel_ringbuffer.c
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit ff049b6ce21d2814451afd4a116d001712e0116b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jun 20 10:53:13 2012 -0700

    drm/i915: bind driver to ValleyView chipsets
    
    With the code in place, we can bind the driver, should make bisect possible.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d1306c0f44f9..05adbf23951a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -352,6 +352,9 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0406, &intel_haswell_m_info), /* GT1 mobile */
 	INTEL_VGA_DEVICE(0x0416, &intel_haswell_m_info), /* GT2 mobile */
 	INTEL_VGA_DEVICE(0x0c16, &intel_haswell_d_info), /* SDV */
+	INTEL_VGA_DEVICE(0x0f30, &intel_valleyview_m_info),
+	INTEL_VGA_DEVICE(0x0157, &intel_valleyview_m_info),
+	INTEL_VGA_DEVICE(0x0155, &intel_valleyview_d_info),
 	{0, 0, 0}
 };
 

commit f7dff0c9cbb89e9c406c0ca47f32129b61721174
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jun 15 11:55:17 2012 -0700

    drm/i915: access VLV regs through read/write switch
    
    Since the offsets have all moved around.
    
    v2: switch IS_DISPLAYREG and IS_VALLEYVIEW checks around since the latter is
        cheaper (Daniel)
        bail out early in IS_DISPLAYREG if the reg is in the new range (Daniel)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: Fixup if cascading fail that broke HAS_FORCEWAKE machines.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d7dd60bb2745..d1306c0f44f9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1146,6 +1146,84 @@ MODULE_LICENSE("GPL and additional rights");
         ((reg) != FORCEWAKE)) && \
        (!IS_VALLEYVIEW((dev_priv)->dev))
 
+static bool IS_DISPLAYREG(u32 reg)
+{
+	/*
+	 * This should make it easier to transition modules over to the
+	 * new register block scheme, since we can do it incrementally.
+	 */
+	if (reg >= 0x180000)
+		return false;
+
+	if (reg >= RENDER_RING_BASE &&
+	    reg < RENDER_RING_BASE + 0xff)
+		return false;
+	if (reg >= GEN6_BSD_RING_BASE &&
+	    reg < GEN6_BSD_RING_BASE + 0xff)
+		return false;
+	if (reg >= BLT_RING_BASE &&
+	    reg < BLT_RING_BASE + 0xff)
+		return false;
+
+	if (reg == PGTBL_ER)
+		return false;
+
+	if (reg >= IPEIR_I965 &&
+	    reg < HWSTAM)
+		return false;
+
+	if (reg == MI_MODE)
+		return false;
+
+	if (reg == GFX_MODE_GEN7)
+		return false;
+
+	if (reg == RENDER_HWS_PGA_GEN7 ||
+	    reg == BSD_HWS_PGA_GEN7 ||
+	    reg == BLT_HWS_PGA_GEN7)
+		return false;
+
+	if (reg == GEN6_BSD_SLEEP_PSMI_CONTROL ||
+	    reg == GEN6_BSD_RNCID)
+		return false;
+
+	if (reg == GEN6_BLITTER_ECOSKPD)
+		return false;
+
+	if (reg >= 0x4000c &&
+	    reg <= 0x4002c)
+		return false;
+
+	if (reg >= 0x4f000 &&
+	    reg <= 0x4f08f)
+		return false;
+
+	if (reg >= 0x4f100 &&
+	    reg <= 0x4f11f)
+		return false;
+
+	if (reg >= VLV_MASTER_IER &&
+	    reg <= GEN6_PMIER)
+		return false;
+
+	if (reg >= FENCE_REG_SANDYBRIDGE_0 &&
+	    reg < (FENCE_REG_SANDYBRIDGE_0 + (16*8)))
+		return false;
+
+	if (reg >= VLV_IIR_RW &&
+	    reg <= VLV_ISR)
+		return false;
+
+	if (reg == FORCEWAKE_VLV ||
+	    reg == FORCEWAKE_ACK_VLV)
+		return false;
+
+	if (reg == GEN6_GDRST)
+		return false;
+
+	return true;
+}
+
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \
@@ -1158,6 +1236,8 @@ u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 		if (dev_priv->forcewake_count == 0) \
 			dev_priv->display.force_wake_put(dev_priv); \
 		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
+	} else if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
+		val = read##y(dev_priv->regs + reg + 0x180000);		\
 	} else { \
 		val = read##y(dev_priv->regs + reg); \
 	} \
@@ -1178,7 +1258,11 @@ void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
 		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \
 	} \
-	write##y(val, dev_priv->regs + reg); \
+	if (IS_VALLEYVIEW(dev_priv->dev) && IS_DISPLAYREG(reg)) { \
+		write##y(val, dev_priv->regs + reg + 0x180000);		\
+	} else {							\
+		write##y(val, dev_priv->regs + reg);			\
+	}								\
 	if (unlikely(__fifo_ret)) { \
 		gen6_gt_check_fifodbg(dev_priv); \
 	} \

commit 8e88a2bd5987178d16d53686197404e149e996d9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jun 19 18:40:00 2012 +0200

    drm/i915: don't call modeset_init_hw in i915_reset
    
    It seems to blow up my ilk in all kinds of strange ways. And now that
    we're no longer resetting the entire modeset state, it shouldn't be
    necessary any longer.
    
    This essentially reverts
    
    commit f817586cebf1b946d1f327f9a596048efd6b64e9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Apr 10 15:50:11 2012 +0200
    
        drm/i915: re-init modeset hw state after gpu reset
    
    safe for the introduction of modeset_init_hw, that one is nice to
    prevent code duplication between driver load and resume.
    
    v2: Add a comment to the code to warn future travellers of the dragon
    dungeon ahead, suggested by Chris Wilson.
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e41aadef9937..d7dd60bb2745 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -904,10 +904,13 @@ int i915_reset(struct drm_device *dev)
 		i915_gem_context_init(dev);
 		i915_gem_init_ppgtt(dev);
 
-		mutex_unlock(&dev->struct_mutex);
+		/*
+		 * It would make sense to re-init all the other hw state, at
+		 * least the rps/rc6/emon init done within modeset_init_hw. For
+		 * some unknown reason, this blows up my ilk, so don't.
+		 */
 
-		if (drm_core_check_feature(dev, DRIVER_MODESET))
-			intel_modeset_init_hw(dev);
+		mutex_unlock(&dev->struct_mutex);
 
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);

commit e080b915ecea3fff3e0d8d380a221677add419a5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Jun 16 18:29:44 2012 +0200

    drm/i915: fixup hangman rebase goof-up
    
    I've added a bit of logic such that running the hangman test on chips
    without any hw reset support at all doesn't wedge the gpu because the
    reset failed. This relied on checking for non-null stop_rings.
    Unfortunately I've botched a rebase somewhere and stop_rings is still
    cleared at the old place before the reset code.
    
    Fix this up so that running the i-g-t tests on gen2/3 doesn't result
    in a wedged gpu.
    
    v2: Actually remove the lines instead of adding them twice ... my git
    license should be revoked immediately.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f0bd30ab1551..e41aadef9937 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -860,8 +860,6 @@ int i915_reset(struct drm_device *dev)
 	if (!mutex_trylock(&dev->struct_mutex))
 		return -EBUSY;
 
-	dev_priv->stop_rings = 0;
-
 	i915_gem_reset(dev);
 
 	ret = -ENODEV;

commit 8e96d9c4d9843f00ebeb4a9b33596d96602ea101
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Jun 4 14:42:56 2012 -0700

    drm/i915: reset the GPU on context fini
    
    It's the only way we know how to make the GPU actually forget about the
    default context.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5d9e07ece3c2..f0bd30ab1551 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -799,7 +799,7 @@ static int gen6_do_reset(struct drm_device *dev)
 	return ret;
 }
 
-static int intel_gpu_reset(struct drm_device *dev)
+int intel_gpu_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret = -ENODEV;

commit 254f965c39e3918544395f4ebac8c589d890bae6
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Jun 4 14:42:42 2012 -0700

    drm/i915: preliminary context support
    
    Very basic code for context setup/destruction in the driver.
    
    Adds the file i915_gem_context.c This file implements HW context
    support. On gen5+ a HW context consists of an opaque GPU object which is
    referenced at times of context saves and restores.  With RC6 enabled,
    the context is also referenced as the GPU enters and exists from RC6
    (GPU has it's own internal power context, except on gen5).  Though
    something like a context does exist for the media ring, the code only
    supports contexts for the render ring.
    
    In software, there is a distinction between contexts created by the
    user, and the default HW context. The default HW context is used by GPU
    clients that do not request setup of their own hardware context. The
    default context's state is never restored to help prevent programming
    errors. This would happen if a client ran and piggy-backed off another
    clients GPU state.  The default context only exists to give the GPU some
    offset to load as the current to invoke a save of the context we
    actually care about. In fact, the code could likely be constructed,
    albeit in a more complicated fashion, to never use the default context,
    though that limits the driver's ability to swap out, and/or destroy
    other contexts.
    
    All other contexts are created as a request by the GPU client. These
    contexts store GPU state, and thus allow GPU clients to not re-emit
    state (and potentially query certain state) at any time. The kernel
    driver makes certain that the appropriate commands are inserted.
    
    There are 4 entry points into the contexts, init, fini, open, close.
    The names are self-explanatory except that init can be called during
    reset, and also during pm thaw/resume. As we expect our context to be
    preserved across these events, we do not reinitialize in this case.
    
    As Adam Jackson pointed out, The cutoff of 1MB where a HW context is
    considered too big is arbitrary. The reason for this is even though
    context sizes are increasing with every generation, they have yet to
    eclipse even 32k. If we somehow read back way more than that, it
    probably means BIOS has done something strange, or we're running on a
    platform that wasn't designed for this.
    
    v2: rename load/unload to init/fini (daniel)
    remove ILK support for get_size() (indirectly daniel)
    add HAS_HW_CONTEXTS macro to clarify supported platforms (daniel)
    added comments (Ben)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 238a52165833..5d9e07ece3c2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -903,6 +903,7 @@ int i915_reset(struct drm_device *dev)
 		for_each_ring(ring, dev_priv, i)
 			ring->init(ring);
 
+		i915_gem_context_init(dev);
 		i915_gem_init_ppgtt(dev);
 
 		mutex_unlock(&dev->struct_mutex);

commit b7884eb45ec98c0d34c7f49005ae9d4b4b4e38f6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 4 11:18:15 2012 +0200

    drm/i915: hold forcewake around ring hw init
    
    Empirical evidence suggests that we need to: On at least one ivb
    machine when running the hangman i-g-t test, the rings don't properly
    initialize properly - the RING_START registers seems to be stuck at
    all zeros.
    
    Holding forcewake around this register init sequences makes chip reset
    reliable again. Note that this is not the first such issue:
    
    commit f01db988ef6f6c70a6cc36ee71e4a98a68901229
    Author: Sean Paul <seanpaul@chromium.org>
    Date:   Fri Mar 16 12:43:22 2012 -0400
    
        drm/i915: Add wait_for in init_ring_common
    
    added delay loops to make RING_START and RING_CTL initialization
    reliable on the blt ring at boot-up. So I guess it won't hurt if we do
    this unconditionally for all force_wake needing gpus.
    
    To avoid copy&pasting of the HAS_FORCE_WAKE check I've added a new
    intel_info bit for that.
    
    v2: Fixup missing commas in static struct and properly handling the
    error case in init_ring_common, both noticed by Jani Nikula.
    
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Yang Guang <guang.a.yang@intel.com>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=50522
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 238a52165833..9fe9ebe52a7a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -233,6 +233,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -243,6 +244,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_d_info = {
@@ -252,6 +254,7 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
@@ -262,6 +265,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {
@@ -289,6 +293,7 @@ static const struct intel_device_info intel_haswell_d_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct intel_device_info intel_haswell_m_info = {
@@ -298,6 +303,7 @@ static const struct intel_device_info intel_haswell_m_info = {
 	.has_blt_ring = 1,
 	.has_llc = 1,
 	.has_pch_split = 1,
+	.has_force_wake = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */
@@ -1139,10 +1145,9 @@ MODULE_LICENSE("GPL and additional rights");
 
 /* We give fast paths for the really cool registers */
 #define NEEDS_FORCE_WAKE(dev_priv, reg) \
-       (((dev_priv)->info->gen >= 6) && \
-        ((reg) < 0x40000) &&            \
-        ((reg) != FORCEWAKE)) && \
-       (!IS_VALLEYVIEW((dev_priv)->dev))
+	((HAS_FORCE_WAKE((dev_priv)->dev)) && \
+	 ((reg) < 0x40000) &&            \
+	 ((reg) != FORCEWAKE))
 
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \

commit 1286ff7397737e407cdd8e5cd574318db177ba1f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 10 15:25:09 2012 +0200

    i915: add dmabuf/prime buffer sharing support.
    
    This adds handle->fd and fd->handle support to i915, this is to allow
    for offloading of rendering in one direction and outputs in the other.
    
    v2 from Daniel Vetter:
    - fixup conflicts with the prepare/finish gtt prep work.
    - implement ppgtt binding support.
    
    Note that we have squat i-g-t testcoverage for any of the lifetime and
    access rules dma_buf/prime support brings along. And there are quite a
    few intricate situations here.
    
    Also note that the integration with the existing code is a bit
    hackish, especially around get_gtt_pages and put_gtt_pages. It imo
    would be easier with the prep code from Chris Wilson's unbound series,
    but that is for 3.6.
    
    Also note that I didn't bother to put the new prepare/finish gtt hooks
    to good use by moving the dma_buf_map/unmap_attachment calls in there
    (like we've originally planned for).
    
    Last but not least this patch is only compile-tested, but I've changed
    very little compared to Dave Airlie's version. So there's a decent
    chance v2 on drm-next works as well as v1 on 3.4-rc.
    
    v3: Right when I've hit sent I've noticed that I've screwed up one
    obj->sg_list (for dmar support) and obj->sg_table (for prime support)
    disdinction. We should be able to merge these 2 paths, but that's
    material for another patch.
    
    v4: fix the error reporting bugs pointed out by ickle.
    
    v5: fix another error, and stop non-gtt mmaps on shared objects
    stop pread/pwrite on imported objects, add fake kmap
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7b967d5bf51d..238a52165833 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1039,7 +1039,7 @@ static struct drm_driver driver = {
 	 */
 	.driver_features =
 	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM,
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM | DRIVER_PRIME,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,
 	.open = i915_driver_open,
@@ -1062,6 +1062,12 @@ static struct drm_driver driver = {
 	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
+
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_export = i915_gem_prime_export,
+	.gem_prime_import = i915_gem_prime_import,
+
 	.dumb_create = i915_gem_dumb_create,
 	.dumb_map_offset = i915_gem_mmap_gtt,
 	.dumb_destroy = i915_gem_dumb_destroy,

commit 78b68556a964e74fb803b08c5b2d9c6ba3ec3787
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 17 13:27:22 2012 +0200

    drm: Constify gem_vm_ops pointer
    
    The GEM vm operations structure is passed to the VM core that stores it
    in a const field. There vm operations structures can thus be const in
    DRM as well.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Rob Clark <rob.clark@linaro.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d3e194853061..7b967d5bf51d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -1012,7 +1012,7 @@ static const struct dev_pm_ops i915_pm_ops = {
 	.restore = i915_pm_resume,
 };
 
-static struct vm_operations_struct i915_gem_vm_ops = {
+static const struct vm_operations_struct i915_gem_vm_ops = {
 	.fault = i915_gem_fault,
 	.open = drm_gem_vm_open,
 	.close = drm_gem_vm_close,

commit b4519513e8ca3bd82eabff9874d69166b58b6db9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri May 11 14:29:30 2012 +0100

    drm/i915: Introduce for_each_ring() macro
    
    In many places we wish to iterate over the rings associated with the
    GPU, so refactor them to use a common macro.
    
    Along the way, there are a few code removals that should be side-effect
    free and some rearrangement which should only have a cosmetic impact,
    such as error-state.
    
    Note that this slightly changes the semantics in the hangcheck code:
    We now always cycle through all enabled rings instead of
    short-circuiting the logic.
    
    v2: Pull in a couple of suggestions from Ben and Daniel for
    intel_ring_initialized() and not removing the warning (just moving them
    to a new home, closer to the error).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    [danvet: Added note to commit message about the small behaviour
    change, suggested by Ben Widawsky.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f0763f29aef8..d3e194853061 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -893,15 +893,15 @@ int i915_reset(struct drm_device *dev)
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
 			!dev_priv->mm.suspended) {
+		struct intel_ring_buffer *ring;
+		int i;
+
 		dev_priv->mm.suspended = 0;
 
 		i915_gem_init_swizzling(dev);
 
-		dev_priv->ring[RCS].init(&dev_priv->ring[RCS]);
-		if (HAS_BSD(dev))
-		    dev_priv->ring[VCS].init(&dev_priv->ring[VCS]);
-		if (HAS_BLT(dev))
-		    dev_priv->ring[BCS].init(&dev_priv->ring[BCS]);
+		for_each_ring(ring, dev_priv, i)
+			ring->init(ring);
 
 		i915_gem_init_ppgtt(dev);
 

commit c14f52860e9e8a6e6db65b7d10dfea7c8f82aa1e
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Wed May 9 15:37:32 2012 -0300

    drm/i915: hook Haswell devices in place
    
    This patch enables i915 driver to handle Haswell devices. It should go in
    last, when things are working stable enough.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 88d329088927..f0763f29aef8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -345,6 +345,13 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0162, &intel_ivybridge_d_info), /* GT2 desktop */
 	INTEL_VGA_DEVICE(0x015a, &intel_ivybridge_d_info), /* GT1 server */
 	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
+	INTEL_VGA_DEVICE(0x0402, &intel_haswell_d_info), /* GT1 desktop */
+	INTEL_VGA_DEVICE(0x0412, &intel_haswell_d_info), /* GT2 desktop */
+	INTEL_VGA_DEVICE(0x040a, &intel_haswell_d_info), /* GT1 server */
+	INTEL_VGA_DEVICE(0x041a, &intel_haswell_d_info), /* GT2 server */
+	INTEL_VGA_DEVICE(0x0406, &intel_haswell_m_info), /* GT1 mobile */
+	INTEL_VGA_DEVICE(0x0416, &intel_haswell_m_info), /* GT2 mobile */
+	INTEL_VGA_DEVICE(0x0c16, &intel_haswell_d_info), /* SDV */
 	{0, 0, 0}
 };
 

commit 1833b134454d5300d8a9d07b78876a20395f01a9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 9 11:56:28 2012 +0100

    drm/i915: gen6_enable_rps() wants to be called after ring initialisation
    
    Currently we call gen6_enable_rps() (which writes into the per-ring
    register mmio space) from intel_modeset_init_hw() which is called before
    we initialise the rings. If we defer intel_modeset_init_hw() until
    afterwards (in the intel_modeset_gem_init() phase) all is well.
    
    v2: Rectify ordering of gem vs display HW init upon resume. (Daniel)
    
    v3: Fix up locking. (Paulo)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    [danvet: Smash Paulo's locking fix onto Chris' patch.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1ccfc23d1abf..88d329088927 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -624,15 +624,16 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		if (HAS_PCH_SPLIT(dev))
+			ironlake_init_pch_refclk(dev);
+
 		mutex_lock(&dev->struct_mutex);
 		dev_priv->mm.suspended = 0;
 
 		error = i915_gem_init_hw(dev);
 		mutex_unlock(&dev->struct_mutex);
 
-		if (HAS_PCH_SPLIT(dev))
-			ironlake_init_pch_refclk(dev);
-
+		intel_modeset_init_hw(dev);
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 
@@ -640,9 +641,6 @@ static int i915_drm_thaw(struct drm_device *dev)
 		mutex_lock(&dev->mode_config.mutex);
 		drm_helper_resume_force_mode(dev);
 		mutex_unlock(&dev->mode_config.mutex);
-
-		if (IS_IRONLAKE_M(dev))
-			ironlake_enable_rc6(dev);
 	}
 
 	intel_opregion_init(dev);

commit 59de3295adaf9503e91e7e6d323cf9becef600de
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 2 20:48:43 2012 +0200

    drm/i915: enable semaphores on gen6 if dmar is not active
    
    Inspired by the recent ppgtt regression report, where switching of
    dmar only for the gpu seems to fix things completely, I've looked
    again at the semaphores+vt-d situation.
    
    Contrary to my earlier testing a few months back my system is now
    stable with dmar disabled for the igd, and not only when disabling
    dmar completely.
    
    So I'm rather hopeful that all our recent fixes for snb have changed
    things for code and it's time to try enabling semaphores again. We've
    also had issues with enabling semaphores which are not vt-d related,
    but I guess these are all fixed by the autoreport-disabling and lazy
    request fix. And there's only one way to find out whether there are
    still other issues ...
    
    When I've tried to apply this patch I've noticed that semaphores on
    gen6 have already silently been enabled in
    
    commit 2911a35b2e4eb87ec48d03aeb11f019e51ae3c0d
    Author: Ben Widawsky <ben@bwidawsk.net>
    Date:   Thu Apr 5 14:47:36 2012 -0700
    
        drm/i915: use semaphores for the display plane
    
    Fix this up by only checking whether dmar is enabled on the gfx (not
    on the entire system).
    
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77b7a50e2014..1ccfc23d1abf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -407,9 +407,11 @@ bool i915_semaphore_is_enabled(struct drm_device *dev)
 	if (i915_semaphores >= 0)
 		return i915_semaphores;
 
+#ifdef CONFIG_INTEL_IOMMU
 	/* Enable semaphores on SNB when IO remapping is off */
-	if (INTEL_INFO(dev)->gen == 6)
-		return !intel_iommu_enabled;
+	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)
+		return false;
+#endif
 
 	return 1;
 }

commit 5fe9fe8c98eeed86650e9e5e9eaa156cf0ce1282
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 2 21:33:52 2012 +0200

    drm/i915: fix gen4 gpu reset
    
    While trying to fix up gen4 gpu reset in
    
    commit f49f0586191fe16140410db0a46d43bdc690d6af
    Author: Kenneth Graunke <kenneth@whitecape.org>
    Date:   Sat Sep 11 01:19:14 2010 -0700
    
        drm/i915: Actually set the reset bit in i965_reset
    
    a little confusion about when wait_for times out has been introduced -
    wait for loops _until_ the condition is true.
    
    This fixes gpu reset on my gm45, testing with my hangman code shows
    that it's now fairly reliable - it only died after well over 100 reset
    cycles.
    
    Cc: Eric Anholt <eric@anholt.net>
    Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 133f1014ed90..77b7a50e2014 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -707,7 +707,7 @@ static int i965_reset_complete(struct drm_device *dev)
 {
 	u8 gdrst;
 	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
-	return gdrst & 0x1;
+	return (gdrst & GRDOM_RESET_ENABLE) == 0;
 }
 
 static int i965_do_reset(struct drm_device *dev)

commit 523bcb28c3fb92baecda6daa60560f67eb4a6177
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:46 2012 +0200

    drm/i915: remove modeset reset from i915_reset
    
    On gen4+ we don't reset the display unit, so resetting the complete
    modeset state should not be necessary.
    
    We can't do reset on gen3 anyway, which leaves us with gen2 reset:
    According to Chris Wilson, that doesn't work so great, so he suggested
    we just ignore that. If the need ever arrises, we can re-add it later
    on.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 45c9430cf629..133f1014ed90 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -904,21 +904,11 @@ int i915_reset(struct drm_device *dev)
 			intel_modeset_init_hw(dev);
 
 		drm_irq_uninstall(dev);
-		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 	} else {
 		mutex_unlock(&dev->struct_mutex);
 	}
 
-	/*
-	 * Perform a full modeset as on later generations, e.g. Ironlake, we may
-	 * need to retrain the display link and cannot just restore the register
-	 * values.
-	 */
-	mutex_lock(&dev->mode_config.mutex);
-	drm_helper_resume_force_mode(dev);
-	mutex_unlock(&dev->mode_config.mutex);
-
 	return 0;
 }
 

commit 5ccce180fe6d484454650d8b2a71fde22d311013
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:45 2012 +0200

    drm/i915: also reset the media engine on gen4/5
    
    ... we actually use it.
    
    Unfortunately we can't reset both at the same time without also
    resetting the display unit, so do render and media separately.
    
    Also replace magic constants with proper #defines.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2ecfcc2ef408..45c9430cf629 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -712,6 +712,7 @@ static int i965_reset_complete(struct drm_device *dev)
 
 static int i965_do_reset(struct drm_device *dev)
 {
+	int ret;
 	u8 gdrst;
 
 	/*
@@ -721,7 +722,17 @@ static int i965_do_reset(struct drm_device *dev)
 	 */
 	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
 	pci_write_config_byte(dev->pdev, I965_GDRST,
-			      gdrst | GRDOM_RENDER | 0x1);
+			      gdrst | GRDOM_RENDER |
+			      GRDOM_RESET_ENABLE);
+	ret =  wait_for(i965_reset_complete(dev), 500);
+	if (ret)
+		return ret;
+
+	/* We can't reset render&media without also resetting display ... */
+	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
+	pci_write_config_byte(dev->pdev, I965_GDRST,
+			      gdrst | GRDOM_MEDIA |
+			      GRDOM_RESET_ENABLE);
 
 	return wait_for(i965_reset_complete(dev), 500);
 }
@@ -729,9 +740,20 @@ static int i965_do_reset(struct drm_device *dev)
 static int ironlake_do_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	u32 gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
+	u32 gdrst;
+	int ret;
+
+	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
+	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
+		   gdrst | GRDOM_RENDER | GRDOM_RESET_ENABLE);
+	ret = wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
+	if (ret)
+		return ret;
+
+	/* We can't reset render&media without also resetting display ... */
+	gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
 	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
-		   gdrst | GRDOM_RENDER | 0x1);
+		   gdrst | GRDOM_MEDIA | GRDOM_RESET_ENABLE);
 	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
 }
 

commit d4b8bb2ac1254b98631909251f299f7789b5bed5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:44 2012 +0200

    drm/i915: kill flags parameter for reset functions
    
    Only half of them even cared, and it's always the same one.
    
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dbe0f88ad3d0..2ecfcc2ef408 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -673,7 +673,7 @@ int i915_resume(struct drm_device *dev)
 	return 0;
 }
 
-static int i8xx_do_reset(struct drm_device *dev, u8 flags)
+static int i8xx_do_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
@@ -710,7 +710,7 @@ static int i965_reset_complete(struct drm_device *dev)
 	return gdrst & 0x1;
 }
 
-static int i965_do_reset(struct drm_device *dev, u8 flags)
+static int i965_do_reset(struct drm_device *dev)
 {
 	u8 gdrst;
 
@@ -720,20 +720,22 @@ static int i965_do_reset(struct drm_device *dev, u8 flags)
 	 * triggers the reset; when done, the hardware will clear it.
 	 */
 	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
-	pci_write_config_byte(dev->pdev, I965_GDRST, gdrst | flags | 0x1);
+	pci_write_config_byte(dev->pdev, I965_GDRST,
+			      gdrst | GRDOM_RENDER | 0x1);
 
 	return wait_for(i965_reset_complete(dev), 500);
 }
 
-static int ironlake_do_reset(struct drm_device *dev, u8 flags)
+static int ironlake_do_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
-	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR, gdrst | flags | 0x1);
+	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR,
+		   gdrst | GRDOM_RENDER | 0x1);
 	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
 }
 
-static int gen6_do_reset(struct drm_device *dev, u8 flags)
+static int gen6_do_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int	ret;
@@ -768,7 +770,7 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 	return ret;
 }
 
-static int intel_gpu_reset(struct drm_device *dev, u8 flags)
+static int intel_gpu_reset(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret = -ENODEV;
@@ -776,16 +778,16 @@ static int intel_gpu_reset(struct drm_device *dev, u8 flags)
 	switch (INTEL_INFO(dev)->gen) {
 	case 7:
 	case 6:
-		ret = gen6_do_reset(dev, flags);
+		ret = gen6_do_reset(dev);
 		break;
 	case 5:
-		ret = ironlake_do_reset(dev, flags);
+		ret = ironlake_do_reset(dev);
 		break;
 	case 4:
-		ret = i965_do_reset(dev, flags);
+		ret = i965_do_reset(dev);
 		break;
 	case 2:
-		ret = i8xx_do_reset(dev, flags);
+		ret = i8xx_do_reset(dev);
 		break;
 	}
 
@@ -806,7 +808,6 @@ static int intel_gpu_reset(struct drm_device *dev, u8 flags)
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
- * @flags: reset domains
  *
  * Reset the chip.  Useful if a hang is detected. Returns zero on successful
  * reset or otherwise an error code.
@@ -819,7 +820,7 @@ static int intel_gpu_reset(struct drm_device *dev, u8 flags)
  *   - re-init interrupt state
  *   - re-init display
  */
-int i915_reset(struct drm_device *dev, u8 flags)
+int i915_reset(struct drm_device *dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	int ret;
@@ -838,7 +839,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	if (get_seconds() - dev_priv->last_gpu_reset < 5)
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
 	else
-		ret = intel_gpu_reset(dev, flags);
+		ret = intel_gpu_reset(dev);
 
 	dev_priv->last_gpu_reset = get_seconds();
 	if (ret) {

commit 2b9dc9a27b5869f082b08306da14f7c232693954
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:43 2012 +0200

    drm/i915: make gpu hangman more resilient
    
    - reset the stop_rings infrastructure while resetting the hw to
      avoid angering the hangcheck right away (and potentially declaring
      the gpu permanently wedged).
    
    - ignore reset failures when hanging due to the hangman - we don't
      have reset code for all generations.
    
    v2: Ensure that we only ignore reset failures when the hw reset is not
    implemented and not when it failed.
    
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 27630842bdcc..dbe0f88ad3d0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -770,6 +770,7 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 
 static int intel_gpu_reset(struct drm_device *dev, u8 flags)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret = -ENODEV;
 
 	switch (INTEL_INFO(dev)->gen) {
@@ -788,6 +789,17 @@ static int intel_gpu_reset(struct drm_device *dev, u8 flags)
 		break;
 	}
 
+	/* Also reset the gpu hangman. */
+	if (dev_priv->stop_rings) {
+		DRM_DEBUG("Simulated gpu hang, resetting stop_rings\n");
+		dev_priv->stop_rings = 0;
+		if (ret == -ENODEV) {
+			DRM_ERROR("Reset not implemented, but ignoring "
+				  "error for simulated gpu hangs\n");
+			ret = 0;
+		}
+	}
+
 	return ret;
 }
 

commit 350d2706209cabb187a86508ecd7763237f938c8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:42 2012 +0200

    drm/i915: extract intel_gpu_reset
    
    Slightly cleans up the code and could be useful for e.g. Ben
    Widawsky's hw context patches.
    
    v2: New colours!
    
    Cc: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3ffa9e7c0a8c..27630842bdcc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -768,6 +768,29 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 	return ret;
 }
 
+static int intel_gpu_reset(struct drm_device *dev, u8 flags)
+{
+	int ret = -ENODEV;
+
+	switch (INTEL_INFO(dev)->gen) {
+	case 7:
+	case 6:
+		ret = gen6_do_reset(dev, flags);
+		break;
+	case 5:
+		ret = ironlake_do_reset(dev, flags);
+		break;
+	case 4:
+		ret = i965_do_reset(dev, flags);
+		break;
+	case 2:
+		ret = i8xx_do_reset(dev, flags);
+		break;
+	}
+
+	return ret;
+}
+
 /**
  * i915_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -800,23 +823,11 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	i915_gem_reset(dev);
 
 	ret = -ENODEV;
-	if (get_seconds() - dev_priv->last_gpu_reset < 5) {
+	if (get_seconds() - dev_priv->last_gpu_reset < 5)
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
-	} else switch (INTEL_INFO(dev)->gen) {
-	case 7:
-	case 6:
-		ret = gen6_do_reset(dev, flags);
-		break;
-	case 5:
-		ret = ironlake_do_reset(dev, flags);
-		break;
-	case 4:
-		ret = i965_do_reset(dev, flags);
-		break;
-	case 2:
-		ret = i8xx_do_reset(dev, flags);
-		break;
-	}
+	else
+		ret = intel_gpu_reset(dev, flags);
+
 	dev_priv->last_gpu_reset = get_seconds();
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");

commit bcbc324a2136849a6264e775a465921856286e06
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 27 15:17:41 2012 +0200

    drm/i915: simplify i915_reset a bit
    
    - need_display is always true, scrap it.
    - don't reacquire the mutex to do nothing after having restored the
      gem state.
    
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 90a84f9de8e9..3ffa9e7c0a8c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -787,11 +787,6 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 int i915_reset(struct drm_device *dev, u8 flags)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-	/*
-	 * We really should only reset the display subsystem if we actually
-	 * need to
-	 */
-	bool need_display = true;
 	int ret;
 
 	if (!i915_try_reset)
@@ -865,22 +860,18 @@ int i915_reset(struct drm_device *dev, u8 flags)
 		drm_irq_uninstall(dev);
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
-
-		mutex_lock(&dev->struct_mutex);
+	} else {
+		mutex_unlock(&dev->struct_mutex);
 	}
 
-	mutex_unlock(&dev->struct_mutex);
-
 	/*
 	 * Perform a full modeset as on later generations, e.g. Ironlake, we may
 	 * need to retrain the display link and cannot just restore the register
 	 * values.
 	 */
-	if (need_display) {
-		mutex_lock(&dev->mode_config.mutex);
-		drm_helper_resume_force_mode(dev);
-		mutex_unlock(&dev->mode_config.mutex);
-	}
+	mutex_lock(&dev->mode_config.mutex);
+	drm_helper_resume_force_mode(dev);
+	mutex_unlock(&dev->mode_config.mutex);
 
 	return 0;
 }

commit e5eb3d63c6182d3f21fbfc836ded748d49d521f9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 3 14:48:16 2012 +0200

    drm/i915: add interface to simulate gpu hangs
    
    gpu reset is a very important piece of our infrastructure.
    Unfortunately we only really it test by actually hanging the gpu,
    which often has bad side-effects for the entire system. And the gpu
    hang handling code is one of the rather complicated pieces of code we
    have, consisting of
    - hang detection
    - error capture
    - actual gpu reset
    - reset of all the gem bookkeeping
    - reinitialition of the entire gpu
    
    This patch adds a debugfs to selectively stopping rings by ceasing to
    update the hw tail pointer, which will result in the gpu no longer
    updating it's head pointer and eventually to the hangcheck firing.
    This way we can exercise the gpu hang code under controlled conditions
    without a dying gpu taking down the entire systems.
    
    Patch motivated by me forgetting to properly reinitialize ppgtt after
    a gpu reset.
    
    Usage:
    
    echo $((1 << $ringnum)) > i915_ring_stop # stops one ring
    
    echo 0xffffffff > i915_ring_stop # stops all, future-proof version
    
    then run whatever testload is desired. i915_ring_stop automatically
    resets after a gpu hang is detected to avoid hanging the gpu to fast
    and declaring it wedged.
    
    v2: Incorporate feedback from Chris Wilson.
    
    v3: Add the missing cleanup.
    
    v4: Fix up inconsistent size of ring_stop_read vs _write, noticed by
    Eugeni Dodonov.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8a98f9a16418..90a84f9de8e9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -800,6 +800,8 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	if (!mutex_trylock(&dev->struct_mutex))
 		return -EBUSY;
 
+	dev_priv->stop_rings = 0;
+
 	i915_gem_reset(dev);
 
 	ret = -ENODEV;

commit 6b26c86d615747f67fede6ca9609b0f8b2037d11
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 24 14:04:12 2012 +0200

    drm/i915: create macros to handle masked bits
    
    ... and put them to so good use.
    
    Note that there's functional change in vlv clock gating code, we now
    no longer spuriously read back the current value of the bit. According
    to Bspec the high bits should always read zero, so ORing this in
    should have no effect.
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 95ccdffb5deb..8a98f9a16418 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -438,7 +438,7 @@ void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
 	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1))
 		udelay(10);
 
-	I915_WRITE_NOTRACE(FORCEWAKE_MT, (1<<16) | 1);
+	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_ENABLE(1));
 	POSTING_READ(FORCEWAKE_MT);
 
 	count = 0;
@@ -480,7 +480,7 @@ void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 
 void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
 {
-	I915_WRITE_NOTRACE(FORCEWAKE_MT, (1<<16) | 0);
+	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_DISABLE(1));
 	/* The below doubles as a POSTING_READ */
 	gen6_gt_check_fifodbg(dev_priv);
 }

commit ee7b9f93fd96a72e5d09e2b44024c11880873c6b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Apr 20 17:11:53 2012 +0100

    drm/i915: manage PCH PLLs separately from pipes
    
    PCH PLLs aren't required for outputs on the CPU, so we shouldn't just
    treat them as part of the pipe.
    
    So split the code out and manage PCH PLLs separately, allocating them
    when needed or trying to re-use existing PCH PLL setups when the timings
    match.
    
    v2: add num_pch_pll field to dev_priv (Daniel)
        don't NULL the pch_pll pointer in disable or DPMS will fail (Jesse)
        put register offsets in pll struct (Chris)
    
    v3: Decouple enable/disable of PLLs from get/put.
    v4: Track temporary PLL disabling during modeset
    v5: Tidy PLL initialisation by only checking for num_pch_pll == 0 (Eugeni)
    v6: Avoid mishandling allocation failure by embedding the small array of
        PLLs into the device struct
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=44309
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org> (up to v2)
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk> (v3+)
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Tested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3effcf71e1b1..95ccdffb5deb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -377,18 +377,23 @@ void intel_detect_pch(struct drm_device *dev)
 
 			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_IBX;
+				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
 			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
+				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
+				dev_priv->num_pch_pll = 2;
 				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
 			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_LPT;
+				dev_priv->num_pch_pll = 0;
 				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 			}
+			BUG_ON(dev_priv->num_pch_pll > I915_NUM_PLLS);
 		}
 		pci_dev_put(pch);
 	}

commit 767878908e7cc28c440c5431f6591157d8bd4ae7
Merge: 17038de5f165 e816b57a337e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 17 11:13:03 2012 +0200

    Merge tag 'v3.4-rc3' into drm-intel-next-queued
    
    Backmerge Linux 3.4-rc3 into drm-intel-next to resolve a few things
    that conflict/depend upon patches in -rc3:
    - Second part of the Sandybridge workaround series - it changes some
      of the same registers.
    - Preparation for Chris Wilson's fencing cleanup - we need the fix
      from -rc3 merged before we can move around all that code.
    - Resolve the gmbus conflict - gmbus has been disabled in 3.4 again,
      but should be enabled on all generations in 3.5.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_i2c.c
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit f817586cebf1b946d1f327f9a596048efd6b64e9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 10 15:50:11 2012 +0200

    drm/i915: re-init modeset hw state after gpu reset
    
    After a gpu reset we need to re-init some of the hw state we only
    initialize when modeset is enabled, like rc6, hw contexts or render/GT
    core clock gating and workaround register settings.
    
    Note that this patch has a small change in the resume code:
    - rc6 on gen6+ is only restored for the modeset case (for more
      consistency with other callsites). This is no problem because recent
      kernels refuse to load drm/i915 without kms on gen6+
    - rc6/emon on ilk is only restored for the modeset case. This is no
      problem because rc6 is disabled by default on ilk, and ums on ilk
      has never really been a supported option outside of horrible rhel
      backports.
    
    v2: Chris Wilson noticed that we not only fail to restore the clock
    gating settings after gpu reset.
    
    v3: Move the call to modeset_init_hw in _reset out of the
    struct_mutext protected area - other callers don't hold it, too.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 96f8efc7a0d0..ccfdc813171d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -851,9 +851,14 @@ int i915_reset(struct drm_device *dev, u8 flags)
 		i915_gem_init_ppgtt(dev);
 
 		mutex_unlock(&dev->struct_mutex);
+
+		if (drm_core_check_feature(dev, DRIVER_MODESET))
+			intel_modeset_init_hw(dev);
+
 		drm_irq_uninstall(dev);
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
+
 		mutex_lock(&dev->struct_mutex);
 	}
 

commit 2911a35b2e4eb87ec48d03aeb11f019e51ae3c0d
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Thu Apr 5 14:47:36 2012 -0700

    drm/i915: use semaphores for the display plane
    
    In theory this will have performance and power improvements. Performance
    because we don't need to stall when the scanout BO is busy, and power
    because we don't have to stall when the BO is busy (and the ring can
    even go to sleep if the HW supports it).
    
    v2:
    squash 2 patches into 1 (me)
    un-inline the enable_semaphores function (Daniel)
    remove comment about SNB hangs from i915_gem_object_sync (Chris)
    rename intel_enable_semaphores to i915_semaphore_is_enabled (me)
    removed page flip comment; "no why" (Chris)
    
    To address other comments from Daniel (irc):
    update the comment to say 'vt-d is crap, don't enable semaphores'
      - I think you misinterpreted Chris' comment, it already exists.
    checking out whether we can pageflip on the render ring on ivb (didn't
    work on early silicon)
      - We don't want to enable workarounds for early silicon unless we have
        to.
      - I can't find any references in the docs about this.
    optionally use it if the fb is already busy on the render ring
      - This should be how the code already worked, unless I am
        misunderstanding your meaning.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c33b0a41a73d..96f8efc7a0d0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -394,6 +394,21 @@ void intel_detect_pch(struct drm_device *dev)
 	}
 }
 
+bool i915_semaphore_is_enabled(struct drm_device *dev)
+{
+	if (INTEL_INFO(dev)->gen < 6)
+		return 0;
+
+	if (i915_semaphores >= 0)
+		return i915_semaphores;
+
+	/* Enable semaphores on SNB when IO remapping is off */
+	if (INTEL_INFO(dev)->gen == 6)
+		return !intel_iommu_enabled;
+
+	return 1;
+}
+
 void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
 	int count;

commit effbc4fd8e37e41d6f2bb6bcc611c14b4fbdcf9b
Merge: 6a7068b4ef17 ec34a01de311
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 12 10:27:01 2012 +0100

    Merge branch 'drm-intel-next' of git://people.freedesktop.org/~danvet/drm-intel into drm-core-next
    
    Daniel Vetter wrote
    First pull request for 3.5-next, slightly large than usual because new
    things kept coming in since the last pull for 3.4.
    Highlights:
    - first batch of hw enablement for vlv (Jesse et al) and hsw (Eugeni). pci
     ids are not yet added, and there's still quite a few patches to merge
     (mostly modesetting). To make QA easier I've decided to merge this stuff
     in pieces.
    - loads of cleanups and prep patches spurred by the above. Especially vlv
     is a real frankenstein chip, but also hsw is stretching our driver's
     code design. Expect more to come in this area for 3.5.
    - more gmbus fixes, cleanups and improvements by Daniel Kurtz. Again,
     there are more patches needed (and some already queued up), but I wanted
     to split this a bit for better testing.
    - pwrite/pread rework and retuning. This series has been in the works for
     a few months already and a lot of i-g-t tests have been created for it.
     Now it's finally ready to be merged.  Note that one patch in this series
     touches include/pagemap.h, that patch is acked-by akpm.
    - reduce mappable pressure and relocation throughput improvements from
     Chris.
    - mmap offset exhaustion mitigation by Chris Wilson.
    - a start at figuring out which codepaths in our messy dri1/ums+gem/kms
     driver we actually need to support by bailing out of unsupported case.
     The driver now refuses to load without kms on gen6+ and disallows a few
     ioctls that userspace never used in certain cases. More of this will
     definitely come.
    - More decoupling of global gtt and ppgtt.
    - Improved dual-link lvds detection by Takashi Iwai.
    - Shut up the compiler + plus fix the fallout (Ben)
    - Inverted panel brightness handling (mostly Acer manages to break things
     in this way).
    - Small fixlets and adjustements and some minor things to help debugging.
    
    Regression-wise QA reported quite a few issues on ivb, but all of them
    turned out to be hw stability issues which are already fixed in
    drm-intel-fixes (QA runs the nightly regression tests on -next alone,
    without -fixes automatically merged in). There's still one issue open on
    snb, it looks like occlusion query writes are not quite as cache coherent
    as we've expected. With some of the pwrite adjustements we can now
    reliably hit this. Kernel workaround for it is in the works."
    
    * 'drm-intel-next' of git://people.freedesktop.org/~danvet/drm-intel: (101 commits)
      drm/i915: VCS is not the last ring
      drm/i915: Add a dual link lvds quirk for MacBook Pro 8,2
      drm/i915: make quirks more verbose
      drm/i915: dump the DMA fetch addr register on pre-gen6
      drm/i915/sdvo: Include YRPB as an additional TV output type
      drm/i915: disallow gem init ioctl on ilk
      drm/i915: refuse to load on gen6+ without kms
      drm/i915: extract gt interrupt handler
      drm/i915: use render gen to switch ring irq functions
      drm/i915: rip out old HWSTAM missed irq WA for vlv
      drm/i915: open code gen6+ ring irqs
      drm/i915: ring irq cleanups
      drm/i915: add SFUSE_STRAP registers for digital port detection
      drm/i915: add WM_LINETIME registers
      drm/i915: add WRPLL clocks
      drm/i915: add LCPLL control registers
      drm/i915: add SSC offsets for SBI access
      drm/i915: add port clock selection support for HSW
      drm/i915: add S PLL control
      drm/i915: add PIXCLK_GATE register
      ...
    
    Conflicts:
            drivers/char/agp/intel-agp.h
            drivers/char/agp/intel-gtt.c
            drivers/gpu/drm/i915/i915_debugfs.c

commit f57f9c167af7cb3fd315e6a8ebe194a8aea0832a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Apr 11 09:39:02 2012 -0700

    drm/i915: make rc6 module parameter read-only
    
    People have been getting confused and thinking this is a runtime control.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dfa55e7478fb..ae8a64f9f845 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -64,7 +64,7 @@ MODULE_PARM_DESC(semaphores,
 		"Use semaphores for inter-ring sync (default: -1 (use per-chip defaults))");
 
 int i915_enable_rc6 __read_mostly = -1;
-module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
+module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0400);
 MODULE_PARM_DESC(i915_enable_rc6,
 		"Enable power-saving render C-state 6. "
 		"Different stages can be selected via bitmask values "

commit eb877ebfd38b096a60a375785952cc460628d6b2
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Thu Mar 29 12:32:20 2012 -0300

    drm/i915: add support for LynxPoint PCH
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6d7548d1f94b..0efc02e4e7ce 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -351,6 +351,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 #define INTEL_PCH_IBX_DEVICE_ID_TYPE	0x3b00
 #define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
 #define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
+#define INTEL_PCH_LPT_DEVICE_ID_TYPE	0x8c00
 
 void intel_detect_pch(struct drm_device *dev)
 {
@@ -379,6 +380,9 @@ void intel_detect_pch(struct drm_device *dev)
 				/* PantherPoint is CPT compatible */
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
+			} else if (id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_LPT;
+				DRM_DEBUG_KMS("Found LynxPoint PCH\n");
 			}
 		}
 		pci_dev_put(pch);

commit 4cae9ae052fe630e63f28be6b0b115fbf52e63fb
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Thu Mar 29 12:32:18 2012 -0300

    drm/i915: add Haswell devices and their PCI IDs
    
    This adds product definitions for desktop, mobile and server boards.
    
    v2: split into a separate patch, add .has_pch_split feature.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2fd6694fa21e..6d7548d1f94b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -278,6 +278,24 @@ static const struct intel_device_info intel_valleyview_d_info = {
 	.is_valleyview = 1,
 };
 
+static const struct intel_device_info intel_haswell_d_info = {
+	.is_haswell = 1, .gen = 7,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+	.has_llc = 1,
+	.has_pch_split = 1,
+};
+
+static const struct intel_device_info intel_haswell_m_info = {
+	.is_haswell = 1, .gen = 7, .is_mobile = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+	.has_llc = 1,
+	.has_pch_split = 1,
+};
+
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),		/* I830_M */
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),		/* 845_G */

commit 7e508a275b9425d612b845cac534e6b35a3f95e3
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Thu Mar 29 12:32:17 2012 -0300

    drm/i915: transform HAS_PCH_SPLIT in a feature check
    
    The macro is becoming too complex and with VLV upon us it can lead to
    confusion. So transforming this into a feature check instead.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    [danvet: fixed conflict with is_valleyview addition.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0d92e5eb1295..2fd6694fa21e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -211,6 +211,7 @@ static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
@@ -218,6 +219,7 @@ static const struct intel_device_info intel_ironlake_m_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 1,
 	.has_bsd_ring = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
@@ -226,6 +228,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -235,6 +238,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_d_info = {
@@ -243,6 +247,7 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
@@ -252,6 +257,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 	.has_llc = 1,
+	.has_pch_split = 1,
 };
 
 static const struct intel_device_info intel_valleyview_m_info = {

commit 927a2f119e8235238a2fc64871051b16c9bdae75
Author: Sean Paul <seanpaul@chromium.org>
Date:   Fri Mar 23 08:52:58 2012 -0400

    drm/i915: Add lock on drm_helper_resume_force_mode
    
    i915_drm_thaw was not locking the mode_config lock when calling
    drm_helper_resume_force_mode. When there were multiple wake sources,
    this caused FDI training failure on SNB which in turn corrupted the
    display.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 19d55bc54873..dfa55e7478fb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -538,7 +538,9 @@ static int i915_drm_thaw(struct drm_device *dev)
 		drm_irq_install(dev);
 
 		/* Resume the modeset for every activated CRTC */
+		mutex_lock(&dev->mode_config.mutex);
 		drm_helper_resume_force_mode(dev);
+		mutex_unlock(&dev->mode_config.mutex);
 
 		if (IS_IRONLAKE_M(dev))
 			ironlake_enable_rc6(dev);

commit 650dc07ec3b0eba8ff21da706d2b1876ada59fc3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 2 10:08:35 2012 +0200

    drm/i915: disable ppgtt on snb when dmar is enabled
    
    Totally unexpected that this regressed. Luckily it sounds like we just
    need to have dmar disable on the igfx, not the entire system. At least
    that's what a few days of testing between Tony Vroon and me indicates.
    
    Reported-by: Tony Vroon <tony@linx.net>
    Cc: Tony Vroon <tony@linx.net>
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=43024
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77afd3176dd0..19d55bc54873 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -107,8 +107,8 @@ MODULE_PARM_DESC(enable_hangcheck,
 		"WARNING: Disabling this can cause system wide hangs. "
 		"(default: true)");
 
-bool i915_enable_ppgtt __read_mostly = 1;
-module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, bool, 0600);
+int i915_enable_ppgtt __read_mostly = -1;
+module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, int, 0600);
 MODULE_PARM_DESC(i915_enable_ppgtt,
 		"Enable PPGTT (default: true)");
 

commit cc22a938fc1db0c8ef5e693a69b159c4b851dab3
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Thu Mar 29 20:55:48 2012 -0300

    drm/i915: add Ivy Bridge GT2 Server entries
    
    This adds PCI ID for IVB GT2 server variant which we were missing.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    [danvet: fix up conflict because the patch has been diffed against next. tsk.]
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c7d689e4247c..77afd3176dd0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -296,6 +296,7 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0152, &intel_ivybridge_d_info), /* GT1 desktop */
 	INTEL_VGA_DEVICE(0x0162, &intel_ivybridge_d_info), /* GT2 desktop */
 	INTEL_VGA_DEVICE(0x015a, &intel_ivybridge_d_info), /* GT1 server */
+	INTEL_VGA_DEVICE(0x016a, &intel_ivybridge_d_info), /* GT2 server */
 	{0, 0, 0}
 };
 

commit 83b7f9ac9126f0532ca34c14e4f0582c565c6b0d
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Fri Mar 23 11:57:18 2012 -0300

    drm/i915: allow to select rc6 modes via kernel parameter
    
    This allows to select which rc6 modes are to be used via kernel parameter,
    via a bitmask parameter. E.g.:
    
    - to enable rc6, i915_enable_rc6=1
    - to enable rc6 and deep rc6, i915_enable_rc6=3
    - to enable rc6 and deepest rc6, use i915_enable_rc6=5
    - to enable rc6, deep and deepest rc6, use i915_enable_rc6=7
    
    Please keep in mind that the deepest RC6 state really should NOT be used
    by default, as it could potentially worsen the issues with deep RC6. So do
    enable it only when you know what you are doing. However, having it around
    could help solving possible future rc6-related issues and their debugging
    on user machines.
    
    Note that this changes behavior - previously, value of 1 would enable both
    RC6 and deep RC6. Now it should only enable RC6 and deep/deepest RC6
    stages must be enabled manually.
    
    v2: address Chris Wilson comments and clean up the code.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=42579
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ben Widawsky <benjamin.widawsky@intel.com>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1a7559b59997..c7d689e4247c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -66,7 +66,11 @@ MODULE_PARM_DESC(semaphores,
 int i915_enable_rc6 __read_mostly = -1;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 MODULE_PARM_DESC(i915_enable_rc6,
-		"Enable power-saving render C-state 6 (default: -1 (use per-chip default)");
+		"Enable power-saving render C-state 6. "
+		"Different stages can be selected via bitmask values "
+		"(0 = disable; 1 = enable rc6; 2 = enable deep rc6; 4 = enable deepest rc6). "
+		"For example, 3 would enable rc6 and deep rc6, and 7 would enable everything. "
+		"default: -1 (use per-chip default)");
 
 int i915_enable_fbc __read_mostly = -1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);

commit 3fa016a0b5c5237e9c387fc3249592b2cb5391c6
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 28 10:48:49 2012 +0100

    drm/i915: suspend fbdev device around suspend/hibernate
    
    Looking at hibernate overwriting I though it looked like a cursor,
    so I tracked down this missing piece to stop the cursor blink
    timer. I've no idea if this is sufficient to fix the hibernate
    problems people are seeing, but please test it.
    
    Both radeon and nouveau have done this for a long time.
    
    I've run this personally all night hib/resume cycles with no fails.
    
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Reported-by: Petr Tesarik <kernel@tesarici.cz>
    Reported-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Reported-by: Lots of misc segfaults after hibernate across the world.
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=37142
    Tested-by: Dave Airlie <airlied@redhat.com>
    Tested-by: Bojan Smojver <bojan@rexursive.com>
    Tested-by: Andreas Hartmann <andihartmann@01019freenet.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0694e170a338..1a7559b59997 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -467,6 +467,10 @@ static int i915_drm_freeze(struct drm_device *dev)
 	/* Modeset on resume, not lid events */
 	dev_priv->modeset_on_lid = 0;
 
+	console_lock();
+	intel_fbdev_set_suspend(dev, 1);
+	console_unlock();
+
 	return 0;
 }
 
@@ -539,6 +543,9 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 	dev_priv->modeset_on_lid = 0;
 
+	console_lock();
+	intel_fbdev_set_suspend(dev, 0);
+	console_unlock();
 	return error;
 }
 

commit 575155a9af9ba5e384caa6979cd918387d712221
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Mar 28 13:39:37 2012 -0700

    drm/i915: add ValleyView specific force wake get/put functions
    
    ValleyView handles force wake differently than previous chipsets, so add
    a couple of new functions for it.  But leave it disabled by default
    until we test it (need a chip with the Punit enabled first).
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 77f11b9dd14e..0d92e5eb1295 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -465,6 +465,31 @@ int __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 	return ret;
 }
 
+void vlv_force_wake_get(struct drm_i915_private *dev_priv)
+{
+	int count;
+
+	count = 0;
+
+	/* Already awake? */
+	if ((I915_READ(0x130094) & 0xa1) == 0xa1)
+		return;
+
+	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffffffff);
+	POSTING_READ(FORCEWAKE_VLV);
+
+	count = 0;
+	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK_VLV) & 1) == 0)
+		udelay(10);
+}
+
+void vlv_force_wake_put(struct drm_i915_private *dev_priv)
+{
+	I915_WRITE_NOTRACE(FORCEWAKE_VLV, 0xffff0000);
+	/* FIXME: confirm VLV behavior with Punit folks */
+	POSTING_READ(FORCEWAKE_VLV);
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -1007,7 +1032,8 @@ MODULE_LICENSE("GPL and additional rights");
 #define NEEDS_FORCE_WAKE(dev_priv, reg) \
        (((dev_priv)->info->gen >= 6) && \
         ((reg) < 0x40000) &&            \
-        ((reg) != FORCEWAKE))
+        ((reg) != FORCEWAKE)) && \
+       (!IS_VALLEYVIEW((dev_priv)->dev))
 
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \

commit 70a3eb7a3e598f92604267d8ed695057f257ddb0
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Mar 28 13:39:21 2012 -0700

    drm/i915: add ValleyView driver structs and IS_VALLEYVIEW macro
    
    For use by the rest of the ValleyView code.
    
    v2: fix desktop variant to not set is_mobile (Ben)
    
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9a7f265db1a4..77f11b9dd14e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -254,6 +254,24 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.has_llc = 1,
 };
 
+static const struct intel_device_info intel_valleyview_m_info = {
+	.gen = 7, .is_mobile = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_fbc = 0,
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+	.is_valleyview = 1,
+};
+
+static const struct intel_device_info intel_valleyview_d_info = {
+	.gen = 7,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_fbc = 0,
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+	.is_valleyview = 1,
+};
+
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),		/* I830_M */
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),		/* 845_G */

commit b7d84096d3c45f4e397e913da4ce24ec9a32022e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Mar 22 14:38:43 2012 -0700

    drm/i915: move NEEDS_FORCE_WAKE to i915_drv.c
    
    It's only used by the main read/write functions, so we can keep it with
    them.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8e2c52ec5a9e..9a7f265db1a4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -985,6 +985,12 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
 
+/* We give fast paths for the really cool registers */
+#define NEEDS_FORCE_WAKE(dev_priv, reg) \
+       (((dev_priv)->info->gen >= 6) && \
+        ((reg) < 0x40000) &&            \
+        ((reg) != FORCEWAKE))
+
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \

commit 121d527a323f3fde313a8f522060ba859ee405b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 20 13:07:06 2012 +0100

    drm/i915: Add lvds_channel module option
    
    Add a new module optoin lvds_channel to specify the LVDS channel mode
    explicitly instead of probing the LVDS register value set by BIOS.
    This will be helpful when VBT is broken or incompatible with the
    current code.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=42842
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0e797d3cb5f4..8e2c52ec5a9e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -80,6 +80,12 @@ MODULE_PARM_DESC(lvds_downclock,
 		"Use panel (LVDS/eDP) downclocking for power savings "
 		"(default: false)");
 
+int i915_lvds_channel_mode __read_mostly;
+module_param_named(lvds_channel_mode, i915_lvds_channel_mode, int, 0600);
+MODULE_PARM_DESC(lvds_channel_mode,
+		 "Specify LVDS channel mode "
+		 "(0=probe BIOS [default], 1=single-channel, 2=dual-channel)");
+
 int i915_panel_use_ssc __read_mostly = -1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 MODULE_PARM_DESC(lvds_use_ssc,

commit c10e408a00bb74c39f4f9b817f2b948851513377
Author: Mathias Fröhlich <Mathias.Froehlich@web.de>
Date:   Thu Mar 1 06:44:35 2012 +0100

    i915: Add option to bypass vbt table.
    
    This change enables the use of displays where the vbt table just
    contains inappropriate values, but either the vesa defaults or
    the video=... modes do something sensible with the attached display.
    
    The problem happens with an embedded board that contains vbt bios
    tables that do not match the attached display.  Using this change and
    the appropriate kernel boot command line they are able to use an
    otherwise completely unusable secondary display on that embedded
    board.
    
    Reviewed-by: Paul Menzel <paulepanter@users.sourceforge.net>
    Signed-off-by: Mathias Froehlich <Mathias.Froehlich@web.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0694e170a338..0e797d3cb5f4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -89,8 +89,8 @@ MODULE_PARM_DESC(lvds_use_ssc,
 int i915_vbt_sdvo_panel_type __read_mostly = -1;
 module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
 MODULE_PARM_DESC(vbt_sdvo_panel_type,
-		"Override selection of SDVO panel mode in the VBT "
-		"(default: auto)");
+		"Override/Ignore selection of SDVO panel mode in the VBT "
+		"(-2=ignore, -1=auto [default], index in VBT BIOS table)");
 
 static bool i915_try_reset __read_mostly = true;
 module_param_named(reset, i915_try_reset, bool, 0600);

commit 67a3744f7515edda9888df5b226ec3b358908b42
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Thu Feb 9 10:15:20 2012 +0100

    drm/i915: check gtfifodbg after possibly failed writes
    
    If we don't have a sufficient number of free entries in the FIFO, we
    proceed to do a write anyway. With this check we should have a clue if
    that write actually failed or not.
    
    After some discussion with Daniel Vetter regarding his original
    complaint, we agreed upon this.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d783e2b4c914..0694e170a338 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -421,8 +421,10 @@ void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
-void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
+int __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 {
+	int ret = 0;
+
 	if (dev_priv->gt_fifo_count < GT_FIFO_NUM_RESERVED_ENTRIES) {
 		int loop = 500;
 		u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
@@ -430,10 +432,13 @@ void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 			udelay(10);
 			fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
 		}
-		WARN_ON(loop < 0 && fifo <= GT_FIFO_NUM_RESERVED_ENTRIES);
+		if (WARN_ON(loop < 0 && fifo <= GT_FIFO_NUM_RESERVED_ENTRIES))
+			++ret;
 		dev_priv->gt_fifo_count = fifo;
 	}
 	dev_priv->gt_fifo_count--;
+
+	return ret;
 }
 
 static int i915_drm_freeze(struct drm_device *dev)
@@ -1001,11 +1006,15 @@ __i915_read(64, q)
 
 #define __i915_write(x, y) \
 void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
+	u32 __fifo_ret = 0; \
 	trace_i915_reg_rw(true, reg, val, sizeof(val)); \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
-		__gen6_gt_wait_for_fifo(dev_priv); \
+		__fifo_ret = __gen6_gt_wait_for_fifo(dev_priv); \
 	} \
 	write##y(val, dev_priv->regs + reg); \
+	if (unlikely(__fifo_ret)) { \
+		gen6_gt_check_fifodbg(dev_priv); \
+	} \
 }
 __i915_write(8, b)
 __i915_write(16, w)

commit ee64cbdbf617067988168a4a49fcaabdd2743da6
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Thu Feb 9 10:15:19 2012 +0100

    drm/i915: catch gtfifo errors on forcewake_put
    
    This is similar to a patch I wrote several months ago. It's been updated
    for the new FORCEWAKE_MT. As recommended by Chris Wilson, use WARN()
    instead of DRM_ERROR, so we can get a backtrace.
    
    This shouldn't impact performance too much as the extra register read
    can replace the POSTING_READ we had previously.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 189041984aba..d783e2b4c914 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -385,16 +385,27 @@ void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
+static void gen6_gt_check_fifodbg(struct drm_i915_private *dev_priv)
+{
+	u32 gtfifodbg;
+	gtfifodbg = I915_READ_NOTRACE(GTFIFODBG);
+	if (WARN(gtfifodbg & GT_FIFO_CPU_ERROR_MASK,
+	     "MMIO read or write has been dropped %x\n", gtfifodbg))
+		I915_WRITE_NOTRACE(GTFIFODBG, GT_FIFO_CPU_ERROR_MASK);
+}
+
 void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
-	POSTING_READ(FORCEWAKE);
+	/* The below doubles as a POSTING_READ */
+	gen6_gt_check_fifodbg(dev_priv);
 }
 
 void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE_MT, (1<<16) | 0);
-	POSTING_READ(FORCEWAKE_MT);
+	/* The below doubles as a POSTING_READ */
+	gen6_gt_check_fifodbg(dev_priv);
 }
 
 /*

commit 9edd576d89a5b6d3e136d7dcab654d887c0d25b7
Merge: e21af88d3979 28a4d5675857
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Feb 10 16:52:55 2012 +0100

    Merge remote-tracking branch 'airlied/drm-fixes' into drm-intel-next-queued
    
    Back-merge from drm-fixes into drm-intel-next to sort out two things:
    
    - interlaced support: -fixes contains a bugfix to correctly clear
      interlaced configuration bits in case the bios sets up an interlaced
      mode and we want to set up the progressive mode (current kernels
      don't support interlaced). The actual feature work to support
      interlaced depends upon (and conflicts with) this bugfix.
    
    - forcewake voodoo to workaround missed IRQ issues: -fixes only enabled
      this for ivybridge, but some recent bug reports indicate that we
      need this on Sandybridge, too. But in a slightly different flavour
      and with other fixes and reworks on top. Additionally there are some
      forcewake cleanup patches heading to -next that would conflict with
      currrent -fixes.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit e21af88d39796c907c38648c824be3d646ffbe35
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Feb 9 20:53:27 2012 +0100

    drm/i915: enable ppgtt
    
    We want to unconditionally enable ppgtt for two reasons:
    - Windows uses this on snb and later.
    - We need the basic hw support to work before we can think about real
      per-process address spaces and other cool features we want.
    
    But Chris Wilson was complaining all over irc and intel-gfx that this
    will blow up if we don't have a module option to disable it. Hence add
    one, to prevent this.
    
    ppgtt support seems to slightly change the timings and make crashy
    things slightly more or less crashy. Now in my testing and the testing
    this got on troublesome snb machines, it seems to have improved things
    only. But on ivb it makes quite a few crashes happen much more often,
    see
    
    https://bugs.freedesktop.org/show_bug.cgi?id=41353
    
    Luckily Eugeni Dodonov seems to have a set of workarounds that fix
    this issue.
    
    v2: Don't try to enable ppgtt on pre-snb.
    
    v3: Pimp commit message and make Chris Wilson less grumpy by adding a
    module option.
    
    v4: New try at making Chris Wilson happy.
    
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 12ddf47b8187..d92c92dea4ec 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -103,6 +103,11 @@ MODULE_PARM_DESC(enable_hangcheck,
 		"WARNING: Disabling this can cause system wide hangs. "
 		"(default: true)");
 
+bool i915_enable_ppgtt __read_mostly = 1;
+module_param_named(i915_enable_ppgtt, i915_enable_ppgtt, bool, 0600);
+MODULE_PARM_DESC(i915_enable_ppgtt,
+		"Enable PPGTT (default: true)");
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 
@@ -694,6 +699,8 @@ int i915_reset(struct drm_device *dev, u8 flags)
 		if (HAS_BLT(dev))
 		    dev_priv->ring[BCS].init(&dev_priv->ring[BCS]);
 
+		i915_gem_init_ppgtt(dev);
+
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);
 		drm_mode_config_reset(dev);

commit f691e2f4cec334e906f971471b3bf1460c6256d4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Feb 2 09:58:12 2012 +0100

    drm/i915: swizzling support for snb/ivb
    
    We have to do this manually. Somebody had a Great Idea.
    
    I've measured speed-ups just a few percent above the noise level
    (below 5% for the best case), but no slowdows. Chris Wilson measured
    quite a bit more (10-20% above the usual snb variance) on a more
    recent and better tuned version of sna, but also recorded a few
    slow-downs on benchmarks know for uglier amounts of snb-induced
    variance.
    
    v2: Incorporate Ben Widawsky's preliminary review comments and
    elaborate a bit about the performance impact in the changelog.
    
    v3: Add a comment as to why we don't need to check the 3rd memory
    channel.
    
    v4: Fixup whitespace.
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1658cfd85aa7..12ddf47b8187 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -495,7 +495,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 		mutex_lock(&dev->struct_mutex);
 		dev_priv->mm.suspended = 0;
 
-		error = i915_gem_init_ringbuffer(dev);
+		error = i915_gem_init_hw(dev);
 		mutex_unlock(&dev->struct_mutex);
 
 		if (HAS_PCH_SPLIT(dev))
@@ -686,6 +686,8 @@ int i915_reset(struct drm_device *dev, u8 flags)
 			!dev_priv->mm.suspended) {
 		dev_priv->mm.suspended = 0;
 
+		i915_gem_init_swizzling(dev);
+
 		dev_priv->ring[RCS].init(&dev_priv->ring[RCS]);
 		if (HAS_BSD(dev))
 		    dev_priv->ring[VCS].init(&dev_priv->ring[VCS]);

commit c937504e2b96af3b281b1ef859e063ef4af656c1
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Jan 6 11:48:38 2012 -0800

    drm/i915: Hold gt_lock across forcewake register reads
    
    Along with the previous patch to make the reset operation protected by
    the gt_lock as well, this ensures that all register read operations
    will occur with the forcewake hardware enabled. As an added bonus,
    this makes read operations more efficient by taking the spinlock only
    once per read instead of twice.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 062d1d27f704..308f81913562 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -954,9 +954,14 @@ MODULE_LICENSE("GPL and additional rights");
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \
 	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
-		gen6_gt_force_wake_get(dev_priv); \
+		unsigned long irqflags; \
+		spin_lock_irqsave(&dev_priv->gt_lock, irqflags); \
+		if (dev_priv->forcewake_count == 0) \
+			dev_priv->display.force_wake_get(dev_priv); \
 		val = read##y(dev_priv->regs + reg); \
-		gen6_gt_force_wake_put(dev_priv); \
+		if (dev_priv->forcewake_count == 0) \
+			dev_priv->display.force_wake_put(dev_priv); \
+		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags); \
 	} else { \
 		val = read##y(dev_priv->regs + reg); \
 	} \

commit 286fed412a134e76be55899bc628c6fa59cb70da
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Jan 6 11:44:11 2012 -0800

    drm/i915: Hold gt_lock during reset
    
    This ensures that no register reads occur while the forcewake state of
    the hardware is indeterminate during the reset operation.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a6fcd941e3ab..062d1d27f704 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,12 +603,31 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 	int	ret;
 	unsigned long irqflags;
 
-	I915_WRITE(GEN6_GDRST, GEN6_GRDOM_FULL);
-	ret = wait_for((I915_READ(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
-	/* If reset with a user forcewake, try to restore */
+	/* Hold gt_lock across reset to prevent any register access
+	 * with forcewake not set correctly
+	 */
 	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
+
+	/* Reset the chip */
+
+	/* GEN6_GDRST is not in the gt power well, no need to check
+	 * for fifo space for the write or forcewake the chip for
+	 * the read
+	 */
+	I915_WRITE_NOTRACE(GEN6_GDRST, GEN6_GRDOM_FULL);
+
+	/* Spin waiting for the device to ack the reset request */
+	ret = wait_for((I915_READ_NOTRACE(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
+
+	/* If reset with a user forcewake, try to restore, otherwise turn it off */
 	if (dev_priv->forcewake_count)
 		dev_priv->display.force_wake_get(dev_priv);
+	else
+		dev_priv->display.force_wake_put(dev_priv);
+
+	/* Restore fifo count */
+	dev_priv->gt_fifo_count = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+
 	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 	return ret;
 }

commit b6e45f866465f42b53d803b0c574da0fc508a0e9
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Jan 6 11:34:04 2012 -0800

    drm/i915: Move reset forcewake processing to gen6_do_reset
    
    No reason to have half of the reset split from the other half.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bdf6a1b36223..a6fcd941e3ab 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -600,9 +600,17 @@ static int ironlake_do_reset(struct drm_device *dev, u8 flags)
 static int gen6_do_reset(struct drm_device *dev, u8 flags)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	int	ret;
+	unsigned long irqflags;
 
 	I915_WRITE(GEN6_GDRST, GEN6_GRDOM_FULL);
-	return wait_for((I915_READ(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
+	ret = wait_for((I915_READ(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
+	/* If reset with a user forcewake, try to restore */
+	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
+	if (dev_priv->forcewake_count)
+		dev_priv->display.force_wake_get(dev_priv);
+	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
+	return ret;
 }
 
 /**
@@ -629,7 +637,6 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	 * need to
 	 */
 	bool need_display = true;
-	unsigned long irqflags;
 	int ret;
 
 	if (!i915_try_reset)
@@ -647,11 +654,6 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	case 7:
 	case 6:
 		ret = gen6_do_reset(dev, flags);
-		/* If reset with a user forcewake, try to restore */
-		spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
-		if (dev_priv->forcewake_count)
-			dev_priv->display.force_wake_get(dev_priv);
-		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 		break;
 	case 5:
 		ret = ironlake_do_reset(dev, flags);

commit 9f1f46a45a681d357d1ceedecec3671a5ae957f4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 14 13:57:03 2011 +0100

    drm/i915: protect force_wake_(get|put) with the gt_lock
    
    The problem this patch solves is that the forcewake accounting
    necessary for register reads is protected by dev->struct_mutex. But the
    hangcheck and error_capture code need to access registers without
    grabbing this mutex because we hold it while waiting for the gpu.
    So a new lock is required. Because currently the error_state capture
    is called from the error irq handler and the hangcheck code runs from
    a timer, it needs to be an irqsafe spinlock (note that the registers
    used by the irq handler (neglecting the error handling part) only uses
    registers that don't need the forcewake dance).
    
    We could tune this down to a normal spinlock when we rework the
    error_state capture and hangcheck code to run from a workqueue.  But
    we don't have any read in a fastpath that needs forcewake, so I've
    decided to not care much about overhead.
    
    This prevents tests/gem_hangcheck_forcewake from i-g-t from killing my
    snb on recent kernels - something must have slightly changed the
    timings. On previous kernels it only trigger a WARN about the broken
    locking.
    
    v2: Drop the previous patch for the register writes.
    
    v3: Improve the commit message per Chris Wilson's suggestions.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 46c36f5cafb1..bdf6a1b36223 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -368,11 +368,12 @@ void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
  */
 void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
-	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
+	unsigned long irqflags;
 
-	/* Forcewake is atomic in case we get in here without the lock */
-	if (atomic_add_return(1, &dev_priv->forcewake_count) == 1)
+	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
+	if (dev_priv->forcewake_count++ == 0)
 		dev_priv->display.force_wake_get(dev_priv);
+	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
 void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
@@ -392,10 +393,12 @@ void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
  */
 void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
-	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
+	unsigned long irqflags;
 
-	if (atomic_dec_and_test(&dev_priv->forcewake_count))
+	spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
+	if (--dev_priv->forcewake_count == 0)
 		dev_priv->display.force_wake_put(dev_priv);
+	spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 }
 
 void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
@@ -626,6 +629,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	 * need to
 	 */
 	bool need_display = true;
+	unsigned long irqflags;
 	int ret;
 
 	if (!i915_try_reset)
@@ -644,8 +648,10 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	case 6:
 		ret = gen6_do_reset(dev, flags);
 		/* If reset with a user forcewake, try to restore */
-		if (atomic_read(&dev_priv->forcewake_count))
+		spin_lock_irqsave(&dev_priv->gt_lock, irqflags);
+		if (dev_priv->forcewake_count)
 			dev_priv->display.force_wake_get(dev_priv);
+		spin_unlock_irqrestore(&dev_priv->gt_lock, irqflags);
 		break;
 	case 5:
 		ret = ironlake_do_reset(dev, flags);

commit 3d29b842e58fbca2c13a9f458fddbaa535c6e578
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Tue Jan 17 14:43:53 2012 -0200

    drm/i915: add a LLC feature flag in device description
    
    LLC is not SNB/IVB-specific, so we should check for it in a more generic
    way.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7578c08110f7..1658cfd85aa7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -214,6 +214,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
+	.has_llc = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
@@ -222,6 +223,7 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_fbc = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
+	.has_llc = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_d_info = {
@@ -229,6 +231,7 @@ static const struct intel_device_info intel_ivybridge_d_info = {
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
+	.has_llc = 1,
 };
 
 static const struct intel_device_info intel_ivybridge_m_info = {
@@ -237,6 +240,7 @@ static const struct intel_device_info intel_ivybridge_m_info = {
 	.has_fbc = 0,	/* FBC is not enabled on Ivybridge mobile yet */
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
+	.has_llc = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit f3953dcb98bad1c3badf451bcf41bf83ae2ce542
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Mon Nov 28 16:15:17 2011 -0200

    drm/i915: fix typo in function name
    
    Fix function name in comments, a left-over from when i965_reset was
    renamed to i915_reset.
    
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 057c27225944..7578c08110f7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -603,7 +603,7 @@ static int gen6_do_reset(struct drm_device *dev, u8 flags)
 }
 
 /**
- * i965_reset - reset chip after a hang
+ * i915_reset - reset chip after a hang
  * @dev: drm device to reset
  * @flags: reset domains
  *

commit 5a117db77e47e3946d1aaa7ce8deafafd9d76746
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Thu Jan 5 09:34:29 2012 -0200

    drm/i915: there is no pipe CxSR on ironlake
    
    After checking the specs and discussing with Jesse, turns out CxSR is not
    available on Ironlake and gen5, and its advertisement on the device
    description is misleading.
    
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8f7187915b0d..057c27225944 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -198,7 +198,7 @@ static const struct intel_device_info intel_pineview_info = {
 
 static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5,
-	.need_gfx_hws = 1, .has_pipe_cxsr = 1, .has_hotplug = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 };
 

commit 8109021313c7a3d8947677391ce6ab9cd0bb1d28
Author: Daniel Vetter <daniel@ffwll.ch>
Date:   Fri Jan 13 16:20:06 2012 -0800

    drm/i915: convert force_wake_get to func pointer in the gpu reset code
    
    This was forgotten in the original multi-threaded forcewake
    conversion:
    
    commit 8d715f0024f64ad1b1be85d8c081cf577944c847
    Author: Keith Packard <keithp at keithp.com>
    Date:   Fri Nov 18 20:39:01 2011 -0800
    
        drm/i915: add multi-threaded forcewake support
    
    Signed-Off-by: Daniel Vetter <daniel.vetter at ffwll.ch>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8f7187915b0d..46c36f5cafb1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -645,7 +645,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 		ret = gen6_do_reset(dev, flags);
 		/* If reset with a user forcewake, try to restore */
 		if (atomic_read(&dev_priv->forcewake_count))
-			__gen6_gt_force_wake_get(dev_priv);
+			dev_priv->display.force_wake_get(dev_priv);
 		break;
 	case 5:
 		ret = ironlake_do_reset(dev, flags);

commit c7dffff7cc8de748edf0e9f6571cdabecb198705
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Dec 9 11:33:00 2011 -0800

    drm/i915: Clean up multi-threaded forcewake patch
    
    We learned that the ECOBUS register was inside the GT power well, and
    so *did* need force wake to be read, so it gets removed from the list
    of 'doesn't need force wake' registers.
    
    That means the code reading ECOBUS after forcing the mt_force_wake
    function to be called needs to use I915_READ_NOTRACE; it doesn't need
    to do more force wake fun as it's already done it manually.
    
    This also adds a comment explaining why the MT forcewake testing code
    only needs to call mt_forcewake_get/put and not disable RC6 manually
    -- the ECOBUS read will return 0 if the device is in RC6 and isn't
    using MT forcewake, causing the test to work correctly.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 22c8ab70db2c..8f7187915b0d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -923,13 +923,6 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
 
-/* We give fast paths for the really cool registers */
-#define NEEDS_FORCE_WAKE(dev_priv, reg) \
-	(((dev_priv)->info->gen >= 6) && \
-	 ((reg) < 0x40000) &&		 \
-	 ((reg) != FORCEWAKE) &&	 \
-	 ((reg) != ECOBUS))
-
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \

commit 1fbe6f625f69e48c4001051dc1431afc704acfaa
Merge: 0cecdd818cd7 384703b8e6cd
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 20 14:43:53 2011 +0000

    Merge tag 'v3.2-rc6' of /home/airlied/devel/kernel/linux-2.6 into drm-core-next
    
    Merge in the upstream tree to bring in the mainline fixes.
    
    Conflicts:
            drivers/gpu/drm/exynos/exynos_drm_fbdev.c
            drivers/gpu/drm/nouveau/nouveau_sgdma.c

commit f45b55575cedb7efa782e43f1ea74338456d0381
Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date:   Fri Dec 9 17:16:37 2011 -0800

    drm/i915: enable semaphores on per-device defaults
    
    This adds a default setting for semaphores parameter, and enables
    semaphores by default on IVB.
    
    For now, as semaphores interaction with VTd causes random issues on
    SNB, we do not enable them by default. But they can still be enabled
    via the semaphores=1 kernel parameter.
    
    v2: enables semaphores on SNB when IO remapping is disabled, with base
    on Keith Packard patch.
    
    CC: Daniel Vetter <daniel.vetter@ffwll.ch>
    CC: Ben Widawsky <ben@bwidawsk.net>
    CC: Keith Packard <keithp@keithp.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=42696
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=40564
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=41353
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=38862
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 47a42eb6cc43..a1103fc6597d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -58,10 +58,10 @@ module_param_named(powersave, i915_powersave, int, 0600);
 MODULE_PARM_DESC(powersave,
 		"Enable powersavings, fbc, downclocking, etc. (default: true)");
 
-unsigned int i915_semaphores __read_mostly = 0;
+int i915_semaphores __read_mostly = -1;
 module_param_named(semaphores, i915_semaphores, int, 0600);
 MODULE_PARM_DESC(semaphores,
-		"Use semaphores for inter-ring sync (default: false)");
+		"Use semaphores for inter-ring sync (default: -1 (use per-chip defaults))");
 
 int i915_enable_rc6 __read_mostly = -1;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);

commit c0f372b3746d4ede07b2ace2beabd38d9c045b25
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Nov 16 22:24:52 2011 -0800

    drm/i915: By default, enable RC6 on IVB and SNB when reasonable
    
    RC6 should always work on IVB, and should work on SNB whenever IO
    remapping is disabled. RC6 never works on Ironlake. Make the default
    value for the parameter follow these guidelines. Setting the value
    to either 0 or 1 will force the specified behavior.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=38567
    Cc: Ted Phelps <phelps@gnusto.com>
    Cc: Peter <pab1612@gmail.com>
    Cc: Lukas Hejtmanek <xhejtman@fi.muni.cz>
    Cc: Andrew Lutomirski <luto@mit.edu>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 28836fe72211..47a42eb6cc43 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -63,10 +63,10 @@ module_param_named(semaphores, i915_semaphores, int, 0600);
 MODULE_PARM_DESC(semaphores,
 		"Use semaphores for inter-ring sync (default: false)");
 
-unsigned int i915_enable_rc6 __read_mostly = 0;
+int i915_enable_rc6 __read_mostly = -1;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 MODULE_PARM_DESC(i915_enable_rc6,
-		"Enable power-saving render C-state 6 (default: true)");
+		"Enable power-saving render C-state 6 (default: -1 (use per-chip default)");
 
 int i915_enable_fbc __read_mostly = -1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);

commit 8d715f0024f64ad1b1be85d8c081cf577944c847
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Nov 18 20:39:01 2011 -0800

    drm/i915: add multi-threaded forcewake support
    
    On IVB C0+ with newer BIOSes, the forcewake handshake has changed.  There's
    now a bitfield for different driver components to keep the GT powered
    on.  On Linux, we centralize forcewake handling in one place, so we
    still just need a single bit, but we need to use the new registers if MT
    forcewake is enabled.
    
    This needs testing on affected machines.  Please reply with your
    tested-by if you had problems after a BIOS upgrade and this patch fixes
    them.
    
    v2: force MT mode. shift by 16
    v3: set MT force wake bits then check ECOBUS
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=42923
    Tested-by: Manoj Iyer <manoj.iyer@canonical.com>
    Tested-by: Robert Hooker <robert.hooker@canonical.com>
    Tested-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 15bfa9145d2b..28836fe72211 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -328,7 +328,7 @@ void intel_detect_pch(struct drm_device *dev)
 	}
 }
 
-static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
+void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
 	int count;
 
@@ -344,6 +344,22 @@ static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 		udelay(10);
 }
 
+void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
+{
+	int count;
+
+	count = 0;
+	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1))
+		udelay(10);
+
+	I915_WRITE_NOTRACE(FORCEWAKE_MT, (1<<16) | 1);
+	POSTING_READ(FORCEWAKE_MT);
+
+	count = 0;
+	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_MT_ACK) & 1) == 0)
+		udelay(10);
+}
+
 /*
  * Generally this is called implicitly by the register read function. However,
  * if some sequence requires the GT to not power down then this function should
@@ -356,15 +372,21 @@ void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 
 	/* Forcewake is atomic in case we get in here without the lock */
 	if (atomic_add_return(1, &dev_priv->forcewake_count) == 1)
-		__gen6_gt_force_wake_get(dev_priv);
+		dev_priv->display.force_wake_get(dev_priv);
 }
 
-static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
+void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
 	POSTING_READ(FORCEWAKE);
 }
 
+void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
+{
+	I915_WRITE_NOTRACE(FORCEWAKE_MT, (1<<16) | 0);
+	POSTING_READ(FORCEWAKE_MT);
+}
+
 /*
  * see gen6_gt_force_wake_get()
  */
@@ -373,7 +395,7 @@ void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
 
 	if (atomic_dec_and_test(&dev_priv->forcewake_count))
-		__gen6_gt_force_wake_put(dev_priv);
+		dev_priv->display.force_wake_put(dev_priv);
 }
 
 void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
@@ -903,8 +925,9 @@ MODULE_LICENSE("GPL and additional rights");
 /* We give fast paths for the really cool registers */
 #define NEEDS_FORCE_WAKE(dev_priv, reg) \
 	(((dev_priv)->info->gen >= 6) && \
-	((reg) < 0x40000) && \
-	((reg) != FORCEWAKE))
+	 ((reg) < 0x40000) &&		 \
+	 ((reg) != FORCEWAKE) &&	 \
+	 ((reg) != ECOBUS))
 
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \

commit 2d0f2400a49be3a177695eda381d91fec18cbd0e
Merge: b4bbb02934e4 a5cd335165e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 23 09:47:25 2011 -0800

    Merge branch 'drm-fixes' of git://people.freedesktop.org/~airlied/linux
    
    * 'drm-fixes' of git://people.freedesktop.org/~airlied/linux: (31 commits)
      drm: integer overflow in drm_mode_dirtyfb_ioctl()
      drivers/gpu/vga/vgaarb.c: add missing kfree
      drm/radeon/kms/atom: unify i2c gpio table handling
      drm/radeon/kms: fix up gpio i2c mask bits for r4xx for real
      ttm: Don't return the bo reserved on error path
      drm/radeon/kms: add a CS ioctl flag not to rewrite tiling flags in the CS
      drm/i915: Fix inconsistent backlight level during disabled
      drm, i915: Fix memory leak in i915_gem_busy_ioctl().
      drm/i915: Use DPCD value for max DP lanes.
      drm/i915: Initiate DP link training only on the lanes we'll be using
      drm/i915: Remove trailing white space
      drm/i915: Try harder during dp pattern 1 link training
      drm/i915: Make DP prepare/commit consistent with DP dpms
      drm/i915: Let panel power sequencing hardware do its job
      drm/i915: Treat PCH eDP like DP in most places
      drm/i915: Remove link_status field from intel_dp structure
      drm/i915: Move common PCH_PP_CONTROL setup to ironlake_get_pp_control
      drm/i915: Module parameters using '-1' as default must be signed type
      drm/i915: Turn on another required clock gating bit on gen6.
      drm/i915: Turn on a required 3D clock gating bit on Sandybridge.
      ...

commit cdaeb578aca9e017deb0f55f1af8a94a4d63efb3
Merge: e70f224c1938 04b38670cf46
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 22 20:01:00 2011 +0000

    Merge branch 'drm-intel-fixes' of git://people.freedesktop.org/~keithp/linux into drm-fixes
    
    * 'drm-intel-fixes' of git://people.freedesktop.org/~keithp/linux: (25 commits)
      drm/i915: Fix inconsistent backlight level during disabled
      drm, i915: Fix memory leak in i915_gem_busy_ioctl().
      drm/i915: Use DPCD value for max DP lanes.
      drm/i915: Initiate DP link training only on the lanes we'll be using
      drm/i915: Remove trailing white space
      drm/i915: Try harder during dp pattern 1 link training
      drm/i915: Make DP prepare/commit consistent with DP dpms
      drm/i915: Let panel power sequencing hardware do its job
      drm/i915: Treat PCH eDP like DP in most places
      drm/i915: Remove link_status field from intel_dp structure
      drm/i915: Move common PCH_PP_CONTROL setup to ironlake_get_pp_control
      drm/i915: Module parameters using '-1' as default must be signed type
      drm/i915: Turn on another required clock gating bit on gen6.
      drm/i915: Turn on a required 3D clock gating bit on Sandybridge.
      drm/i915: enable cacheable objects on Ivybridge
      drm/i915: add constants to size fence arrays and fields
      drm/i915: Ivybridge still has fences!
      drm/i915: forcewake warning fixes in debugfs
      drm/i915: Fix object refcount leak on mmappable size limit error path.
      drm/i915: Use mode_config.mutex in ironlake_panel_vdd_work
      ...

commit e08e96de986ceb2c6b683df0bd0c4ddd4f91dcfd
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Oct 31 07:28:57 2011 -0700

    drm: Make the per-driver file_operations struct const
    
    From fdf1fdebaa00f81de18c227f32f8074c8b352d50 Mon Sep 17 00:00:00 2001
    From: Arjan van de Ven <arjan@linux.intel.com>
    Date: Sun, 30 Oct 2011 19:06:07 -0700
    Subject: [PATCH] drm: Make the per-driver file_operations struct const
    
    The DRM layer keeps a copy of struct file_operations inside its
    big driver struct... which prevents it from being consistent and static.
    For consistency (and the general security objective of having such things
    static), it's desirable to get this fixed.
    
    This patch splits out the file_operations field to its own struct,
    which is then "static const", and just stick a pointer to this into
    the driver struct, making it more consistent with how the rest of the
    kernel does this.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cc531bb59c26..9f592703c369 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -788,6 +788,21 @@ static struct vm_operations_struct i915_gem_vm_ops = {
 	.close = drm_gem_vm_close,
 };
 
+static const struct file_operations i915_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.release = drm_release,
+	.unlocked_ioctl = drm_ioctl,
+	.mmap = drm_gem_mmap,
+	.poll = drm_poll,
+	.fasync = drm_fasync,
+	.read = drm_read,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = i915_compat_ioctl,
+#endif
+	.llseek = noop_llseek,
+};
+
 static struct drm_driver driver = {
 	/* don't use mtrr's here, the Xserver or user space app should
 	 * deal with them for intel hardware.
@@ -821,21 +836,7 @@ static struct drm_driver driver = {
 	.dumb_map_offset = i915_gem_mmap_gtt,
 	.dumb_destroy = i915_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
-	.fops = {
-		 .owner = THIS_MODULE,
-		 .open = drm_open,
-		 .release = drm_release,
-		 .unlocked_ioctl = drm_ioctl,
-		 .mmap = drm_gem_mmap,
-		 .poll = drm_poll,
-		 .fasync = drm_fasync,
-		 .read = drm_read,
-#ifdef CONFIG_COMPAT
-		 .compat_ioctl = i915_compat_ioctl,
-#endif
-		 .llseek = noop_llseek,
-	},
-
+	.fops = &i915_driver_fops,
 	.name = DRIVER_NAME,
 	.desc = DRIVER_DESC,
 	.date = DRIVER_DATE,

commit 4415e63b13c68c2f56d16d400a1ae345f68cf655
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Nov 9 09:57:50 2011 -0800

    drm/i915: Module parameters using '-1' as default must be signed type
    
    Testing i915_panel_use_ssc for the default value was broken, so the
    driver would never autodetect the correct value.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by:   Michel Alexandre Salim <salimma@fedoraproject.org>
    Tested-by:     Michel Alexandre Salim <salimma@fedoraproject.org>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 548e04bade3c..13488be4ae4b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -67,7 +67,7 @@ module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 MODULE_PARM_DESC(i915_enable_rc6,
 		"Enable power-saving render C-state 6 (default: true)");
 
-unsigned int i915_enable_fbc __read_mostly = -1;
+int i915_enable_fbc __read_mostly = -1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
 MODULE_PARM_DESC(i915_enable_fbc,
 		"Enable frame buffer compression for power savings "
@@ -79,7 +79,7 @@ MODULE_PARM_DESC(lvds_downclock,
 		"Use panel (LVDS/eDP) downclocking for power savings "
 		"(default: false)");
 
-unsigned int i915_panel_use_ssc __read_mostly = -1;
+int i915_panel_use_ssc __read_mostly = -1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 MODULE_PARM_DESC(lvds_use_ssc,
 		"Use Spread Spectrum Clock with panels [LVDS/eDP] "

commit 5c24d8b2bf99ee93049a6f8154ef9cd7897a6e36
Merge: b32fc0a0629b bcd3cfc12138
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Nov 6 21:40:22 2011 -0800

    Merge branch 'docs/docbook/drm' of git://github.com/mfwitten/linux into docs-move

commit e0cd3608135b2ed8eddbe3fdf048d22e0593d836
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Aug 30 11:04:30 2011 -0400

    gpu: add module.h to drivers/gpu files as required.
    
    So that we don't get build failures once the implicit module.h
    presence is removed.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4c8d681c2151..cc531bb59c26 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -35,6 +35,7 @@
 #include "intel_drv.h"
 
 #include <linux/console.h>
+#include <linux/module.h>
 #include "drm_crtc_helper.h"
 
 static int i915_modeset __read_mostly = -1;

commit 80a2901d2a59946d098c4479d650d0c3c82c3d85
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 11 10:59:05 2011 +0200

    drm/i915: only match on PCI_BASE_CLASS_DISPLAY
    
    ... not DISPLAY_VGA, because we ignore the VGA subclass with our
    class_mask.
    
    It confused me until Chris Wilson clued me up.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4c8d681c2151..548e04bade3c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -106,7 +106,7 @@ static struct drm_driver driver;
 extern int intel_agp_enabled;
 
 #define INTEL_VGA_DEVICE(id, info) {		\
-	.class = PCI_CLASS_DISPLAY_VGA << 8,	\
+	.class = PCI_BASE_CLASS_DISPLAY << 16,	\
 	.class_mask = 0xff0000,			\
 	.vendor = 0x8086,			\
 	.device = id,				\

commit f700088333c5c7e5a7f4ab71b642362290259e26
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 13 16:08:51 2011 -0700

    i915: Move i915_read/write out of line
    
    With the tracing code in there they are far too big to inline.
    
    .text savings compared to a non force inline kernel:
    
    i915_restore_display                        4393   12036   +7643
    i915_save_display                           4295   11459   +7164
    i915_handle_error                           2979    6666   +3687
    i915_driver_irq_handler                     2923    5086   +2163
    i915_ringbuffer_info                         458    1661   +1203
    i915_save_vga                                  -    1200   +1200
    i915_driver_irq_uninstall                    453    1624   +1171
    i915_driver_irq_postinstall                  913    2078   +1165
    ironlake_enable_drps                         719    1872   +1153
    i915_restore_vga                               -    1142   +1142
    intel_display_capture_error_state            784    2030   +1246
    intel_init_emon                              719    2016   +1297
    
    and more ...
    
    [AK: these are older numbers, with the new SNB forcewake checks
    it will be even worse]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 74f2cdbad821..4c8d681c2151 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -898,3 +898,43 @@ module_exit(i915_exit);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL and additional rights");
+
+/* We give fast paths for the really cool registers */
+#define NEEDS_FORCE_WAKE(dev_priv, reg) \
+	(((dev_priv)->info->gen >= 6) && \
+	((reg) < 0x40000) && \
+	((reg) != FORCEWAKE))
+
+#define __i915_read(x, y) \
+u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
+	u##x val = 0; \
+	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
+		gen6_gt_force_wake_get(dev_priv); \
+		val = read##y(dev_priv->regs + reg); \
+		gen6_gt_force_wake_put(dev_priv); \
+	} else { \
+		val = read##y(dev_priv->regs + reg); \
+	} \
+	trace_i915_reg_rw(false, reg, val, sizeof(val)); \
+	return val; \
+}
+
+__i915_read(8, b)
+__i915_read(16, w)
+__i915_read(32, l)
+__i915_read(64, q)
+#undef __i915_read
+
+#define __i915_write(x, y) \
+void i915_write##x(struct drm_i915_private *dev_priv, u32 reg, u##x val) { \
+	trace_i915_reg_rw(true, reg, val, sizeof(val)); \
+	if (NEEDS_FORCE_WAKE((dev_priv), (reg))) { \
+		__gen6_gt_wait_for_fifo(dev_priv); \
+	} \
+	write##y(val, dev_priv->regs + reg); \
+}
+__i915_write(8, b)
+__i915_write(16, w)
+__i915_write(32, l)
+__i915_write(64, q)
+#undef __i915_write

commit 9a1f57808afd65b1d066d5e1907526a1e45215df
Merge: 86a3073e480c 9fb526db9795
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Oct 20 14:10:43 2011 -0700

    Merge branch 'fix-pch-refclk' into foo

commit 0ac225e56997ef89f46eb51b02799a685b78f214
Merge: 64a742fac3a2 cd0de039bff3
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Sep 28 14:44:38 2011 -0700

    Merge branch 'drm-intel-fixes' into drm-intel-next

commit 9fb526db979581841227e1ed4f75a5fbe853db4a
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Sep 26 22:24:57 2011 -0700

    drm/i915: Initialize PCH refclks at modeset init time
    
    The reference clock configuration must be done before any mode setting
    can occur as all outputs must be disabled to change
    anything. Initialize the clocks after turning everything off during
    the initialization process.
    
    Also, re-initialize the refclk at resume time.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 58480deacc07..2b6c2d2f223b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -471,6 +471,9 @@ static int i915_drm_thaw(struct drm_device *dev)
 		error = i915_gem_init_ringbuffer(dev);
 		mutex_unlock(&dev->struct_mutex);
 
+		if (HAS_PCH_SPLIT(dev))
+			ironlake_init_pch_refclk(dev);
+
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 

commit 72bbe58cd9568c7766cc219a779ea68a02132797
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Sep 26 16:09:45 2011 -0700

    drm/i915: Allow SSC parameter to override VBT value
    
    Allow SSC to be enabled even when the BIOS disables it for testing SSC paths.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f07e4252b708..58480deacc07 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -79,11 +79,11 @@ MODULE_PARM_DESC(lvds_downclock,
 		"Use panel (LVDS/eDP) downclocking for power savings "
 		"(default: false)");
 
-unsigned int i915_panel_use_ssc __read_mostly = 1;
+unsigned int i915_panel_use_ssc __read_mostly = -1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 MODULE_PARM_DESC(lvds_use_ssc,
 		"Use Spread Spectrum Clock with panels [LVDS/eDP] "
-		"(default: true)");
+		"(default: auto from VBT)");
 
 int i915_vbt_sdvo_panel_type __read_mostly = -1;
 module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);

commit cd0de039bff32ee314046c0e4c047c38aa696f84
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Sep 19 21:34:19 2011 -0700

    drm/i915: FBC off for ironlake and older, otherwise on by default
    
    Make the default FBC behaviour chipset specific, allowing us to turn
    it on by default for Ironlake and older where it has been seen to
    cause trouble with screen updates.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Tested-by: Francis Moreau <francis.moro@gmail.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ce045a8cf82c..f07e4252b708 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -67,11 +67,11 @@ module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 MODULE_PARM_DESC(i915_enable_rc6,
 		"Enable power-saving render C-state 6 (default: true)");
 
-unsigned int i915_enable_fbc __read_mostly = 1;
+unsigned int i915_enable_fbc __read_mostly = -1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
 MODULE_PARM_DESC(i915_enable_fbc,
 		"Enable frame buffer compression for power savings "
-		"(default: false)");
+		"(default: -1 (use per-chip default))");
 
 unsigned int i915_lvds_downclock __read_mostly = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);

commit 0206e353a0416ad63ce07f53c807c2c725633b87
Author: Akshay Joshi <me@akshayjoshi.com>
Date:   Tue Aug 16 15:34:10 2011 -0400

    Drivers: i915: Fix all space related issues.
    
    Various issues involved with the space character were generating
    warnings in the checkpatch.pl file. This patch removes most of those
    warnings.
    
    Signed-off-by: Akshay Joshi <me@akshayjoshi.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ce045a8cf82c..b79c6f14fb72 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -294,7 +294,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 #define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
 #define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
 
-void intel_detect_pch (struct drm_device *dev)
+void intel_detect_pch(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct pci_dev *pch;
@@ -377,7 +377,7 @@ void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 
 void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 {
-	if (dev_priv->gt_fifo_count < GT_FIFO_NUM_RESERVED_ENTRIES ) {
+	if (dev_priv->gt_fifo_count < GT_FIFO_NUM_RESERVED_ENTRIES) {
 		int loop = 500;
 		u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
 		while (fifo <= GT_FIFO_NUM_RESERVED_ENTRIES && loop--) {
@@ -770,12 +770,12 @@ static int i915_pm_poweroff(struct device *dev)
 }
 
 static const struct dev_pm_ops i915_pm_ops = {
-     .suspend = i915_pm_suspend,
-     .resume = i915_pm_resume,
-     .freeze = i915_pm_freeze,
-     .thaw = i915_pm_thaw,
-     .poweroff = i915_pm_poweroff,
-     .restore = i915_pm_resume,
+	.suspend = i915_pm_suspend,
+	.resume = i915_pm_resume,
+	.freeze = i915_pm_freeze,
+	.thaw = i915_pm_thaw,
+	.poweroff = i915_pm_poweroff,
+	.restore = i915_pm_resume,
 };
 
 static struct vm_operations_struct i915_gem_vm_ops = {

commit 0c54781bc5aaec1e23bc50a4ef757b8e8bfc693b
Author: Michael Witten <mfwitten@gmail.com>
Date:   Thu Aug 25 17:55:54 2011 +0000

    DocBook/drm: Clean up code comment
    
    Signed-off-by: Michael Witten <mfwitten@gmail.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ce045a8cf82c..acf4ea84c801 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -785,8 +785,8 @@ static struct vm_operations_struct i915_gem_vm_ops = {
 };
 
 static struct drm_driver driver = {
-	/* don't use mtrr's here, the Xserver or user space app should
-	 * deal with them for intel hardware.
+	/* Don't use MTRRs here; the Xserver or userspace app should
+	 * deal with them for Intel hardware.
 	 */
 	.driver_features =
 	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/

commit 6e96e7757a0133a9a66fd9b86cd04b5e7b88122a
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Wed Jul 13 14:38:18 2011 -0700

    drm/i915: provide module parameter description
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ef5cf036364d..ce045a8cf82c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -39,39 +39,68 @@
 
 static int i915_modeset __read_mostly = -1;
 module_param_named(modeset, i915_modeset, int, 0400);
+MODULE_PARM_DESC(modeset,
+		"Use kernel modesetting [KMS] (0=DRM_I915_KMS from .config, "
+		"1=on, -1=force vga console preference [default])");
 
 unsigned int i915_fbpercrtc __always_unused = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
 int i915_panel_ignore_lid __read_mostly = 0;
 module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
+MODULE_PARM_DESC(panel_ignore_lid,
+		"Override lid status (0=autodetect [default], 1=lid open, "
+		"-1=lid closed)");
 
 unsigned int i915_powersave __read_mostly = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
+MODULE_PARM_DESC(powersave,
+		"Enable powersavings, fbc, downclocking, etc. (default: true)");
 
 unsigned int i915_semaphores __read_mostly = 0;
 module_param_named(semaphores, i915_semaphores, int, 0600);
+MODULE_PARM_DESC(semaphores,
+		"Use semaphores for inter-ring sync (default: false)");
 
 unsigned int i915_enable_rc6 __read_mostly = 0;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
+MODULE_PARM_DESC(i915_enable_rc6,
+		"Enable power-saving render C-state 6 (default: true)");
 
 unsigned int i915_enable_fbc __read_mostly = 1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
+MODULE_PARM_DESC(i915_enable_fbc,
+		"Enable frame buffer compression for power savings "
+		"(default: false)");
 
 unsigned int i915_lvds_downclock __read_mostly = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
+MODULE_PARM_DESC(lvds_downclock,
+		"Use panel (LVDS/eDP) downclocking for power savings "
+		"(default: false)");
 
 unsigned int i915_panel_use_ssc __read_mostly = 1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
+MODULE_PARM_DESC(lvds_use_ssc,
+		"Use Spread Spectrum Clock with panels [LVDS/eDP] "
+		"(default: true)");
 
 int i915_vbt_sdvo_panel_type __read_mostly = -1;
 module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
+MODULE_PARM_DESC(vbt_sdvo_panel_type,
+		"Override selection of SDVO panel mode in the VBT "
+		"(default: auto)");
 
 static bool i915_try_reset __read_mostly = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
+MODULE_PARM_DESC(reset, "Attempt GPU resets (default: true)");
 
 bool i915_enable_hangcheck __read_mostly = true;
 module_param_named(enable_hangcheck, i915_enable_hangcheck, bool, 0644);
+MODULE_PARM_DESC(enable_hangcheck,
+		"Periodically check GPU activity for detecting hangs. "
+		"WARNING: Disabling this can cause system wide hangs. "
+		"(default: true)");
 
 static struct drm_driver driver;
 extern int intel_agp_enabled;

commit a35d9d3cf75604e9ef17faedd333bf2a66a513d8
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Wed Jul 13 14:38:17 2011 -0700

    drm/i915: add module parameter compiler hints
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d988cc350f66..ef5cf036364d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -37,40 +37,40 @@
 #include <linux/console.h>
 #include "drm_crtc_helper.h"
 
-static int i915_modeset = -1;
+static int i915_modeset __read_mostly = -1;
 module_param_named(modeset, i915_modeset, int, 0400);
 
-unsigned int i915_fbpercrtc = 0;
+unsigned int i915_fbpercrtc __always_unused = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
-int i915_panel_ignore_lid = 0;
+int i915_panel_ignore_lid __read_mostly = 0;
 module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
 
-unsigned int i915_powersave = 1;
+unsigned int i915_powersave __read_mostly = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
 
-unsigned int i915_semaphores = 0;
+unsigned int i915_semaphores __read_mostly = 0;
 module_param_named(semaphores, i915_semaphores, int, 0600);
 
-unsigned int i915_enable_rc6 = 0;
+unsigned int i915_enable_rc6 __read_mostly = 0;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 
-unsigned int i915_enable_fbc = 1;
+unsigned int i915_enable_fbc __read_mostly = 1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
 
-unsigned int i915_lvds_downclock = 0;
+unsigned int i915_lvds_downclock __read_mostly = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
-unsigned int i915_panel_use_ssc = 1;
+unsigned int i915_panel_use_ssc __read_mostly = 1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 
-int i915_vbt_sdvo_panel_type = -1;
+int i915_vbt_sdvo_panel_type __read_mostly = -1;
 module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
 
-static bool i915_try_reset = true;
+static bool i915_try_reset __read_mostly = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
 
-bool i915_enable_hangcheck = true;
+bool i915_enable_hangcheck __read_mostly = true;
 module_param_named(enable_hangcheck, i915_enable_hangcheck, bool, 0644);
 
 static struct drm_driver driver;

commit 95736720fc866eadb2ce1789631b907c0f38cb7c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu May 12 22:17:09 2011 +0100

    drm/i915: Cache GT fifo count for SandyBridge
    
    The read back of the available FIFO entries is vital for system
    stability, but extremely costly. However, we only need a guide so as to
    avoid eating into the reserved entries and since we are the only
    consumer we can cache the read of the count from the last write.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6ed73ae2133a..d988cc350f66 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -348,12 +348,17 @@ void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 
 void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 {
-	int loop = 500;
-	u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
-	while (fifo < 20 && loop--) {
-		udelay(10);
-		fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+	if (dev_priv->gt_fifo_count < GT_FIFO_NUM_RESERVED_ENTRIES ) {
+		int loop = 500;
+		u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+		while (fifo <= GT_FIFO_NUM_RESERVED_ENTRIES && loop--) {
+			udelay(10);
+			fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+		}
+		WARN_ON(loop < 0 && fifo <= GT_FIFO_NUM_RESERVED_ENTRIES);
+		dev_priv->gt_fifo_count = fifo;
 	}
+	dev_priv->gt_fifo_count--;
 }
 
 static int i915_drm_freeze(struct drm_device *dev)

commit 9aa73a51c91cb0d0af4caaa9823969c1a1179a12
Merge: c7c369472dad a94919eaddaa
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Jul 12 10:40:25 2011 -0700

    Merge branch 'drm-intel-fixes' into drm-intel-next

commit 05bd42688dbc066d4e2689b6f73c0470601f788b
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Jul 12 08:49:31 2011 -0700

    Revert "drm/i915: enable rc6 by default"
    
    This reverts commit a51f7a66fb5e4af5ec4286baef940d06594b59d2.
    
    We still have a few Ironlake and Sandybridge machines which fail when
    RC6 is enabled. Better luck next release?
    
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 58222e86e291..eb91e2dd7914 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -52,7 +52,7 @@ module_param_named(powersave, i915_powersave, int, 0600);
 unsigned int i915_semaphores = 0;
 module_param_named(semaphores, i915_semaphores, int, 0600);
 
-unsigned int i915_enable_rc6 = 1;
+unsigned int i915_enable_rc6 = 0;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 
 unsigned int i915_enable_fbc = 0;

commit c7c369472dad852f6fe06a8be94dea72de784934
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Jul 8 10:29:42 2011 -0700

    drm/i915: Enable i915 frame buffer compression by default
    
    We'll try again with the new fixes. Prepare to see this reverted when
    we get regression reports...
    
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ec4308d765c5..629d24ca73e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -55,7 +55,7 @@ module_param_named(semaphores, i915_semaphores, int, 0600);
 unsigned int i915_enable_rc6 = 1;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 
-unsigned int i915_enable_fbc = 0;
+unsigned int i915_enable_fbc = 1;
 module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
 
 unsigned int i915_lvds_downclock = 0;

commit 6fe5a7e3cac5b60774186a95bbb7555fa604080c
Merge: bc67f799e766 1083694ab052
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Jul 7 15:39:51 2011 -0700

    Merge branch 'drm-intel-fixes' into drm-intel-next

commit 1083694ab052e5ba38a8f9a057c4745448977837
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Thu Jul 7 15:33:26 2011 -0700

    drm/i915: Enable GPU reset on Ivybridge.
    
    According to the hardware documentation, GDRST is exactly the same as on
    Sandybridge.  So simply enable the existing code.
    
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 013d304455b9..58222e86e291 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -577,6 +577,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	if (get_seconds() - dev_priv->last_gpu_reset < 5) {
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
 	} else switch (INTEL_INFO(dev)->gen) {
+	case 7:
 	case 6:
 		ret = gen6_do_reset(dev, flags);
 		/* If reset with a user forcewake, try to restore */

commit bee4d4acf563f91a7796cca53111d91be2532935
Merge: e489bda422b0 f71d4af4cd47
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Jun 29 20:38:41 2011 -0700

    Merge branch 'drm-intel-fixes' into drm-intel-next

commit f71d4af4cd475aced6d9ec9730b03885ac80b833
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Jun 28 13:00:41 2011 -0700

    drm/i915: move IRQ function table init to i915_irq.c
    
    This lets us make the various IRQ functions static and helps avoid
    problems like the one fixed in "drm/i915: Use chipset-specific irq
    installers" where one of the exported functions was called rather than
    the chipset specific version.
    
    This also fixes a UMS-mode bug -- the correct irq functions for IRL
    and later chips were only getting loaded in the KMS path.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 609358faaa90..013d304455b9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -765,14 +765,6 @@ static struct drm_driver driver = {
 	.resume = i915_resume,
 
 	.device_is_agp = i915_driver_device_is_agp,
-	.enable_vblank = i915_enable_vblank,
-	.disable_vblank = i915_disable_vblank,
-	.get_vblank_timestamp = i915_get_vblank_timestamp,
-	.get_scanout_position = i915_get_crtc_scanoutpos,
-	.irq_preinstall = i915_driver_irq_preinstall,
-	.irq_postinstall = i915_driver_irq_postinstall,
-	.irq_uninstall = i915_driver_irq_uninstall,
-	.irq_handler = i915_driver_irq_handler,
 	.reclaim_buffers = drm_core_reclaim_buffers,
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,

commit 3e0dc6b01f5301d63046f6deddde2c7f5c57d67a
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Wed Jun 29 10:26:42 2011 -0700

    drm/i915: hangcheck disable parameter
    
    Provide a parameter to disable hanghcheck. This is useful mostly for
    developers trying to debug known problems, and probably should not be
    touched by normal users.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 609358faaa90..b54f7d9b173a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -70,6 +70,9 @@ module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
 static bool i915_try_reset = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
 
+bool i915_enable_hangcheck = true;
+module_param_named(enable_hangcheck, i915_enable_hangcheck, bool, 0644);
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 

commit 25732821cb965f00475922ca46e84f78e4bada95
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Jun 24 14:31:47 2011 -0700

    drm/i915: forcewake fix after reset
    
    The failure is as follows:
    
    1. Userspace gets forcewake lock, lock count >=1
    2. GPU hang/reset occurs (forcewake bit is reset)
    3. count is now incorrect
    
    The failure can only occur when using the forcewake userspace lock.
    
    This has the unfortunate consequence of messing up the driver as well as
    userspace, unless userspace closes the debugfs file, the kernel will
    never end up waking the GT since the refcount will be > 1.
    
    The solution is to try to recover the correct forcewake state based on
    the refcount. There is a period of time where userspace reads/writes may
    occur after the reset, before the GT has been forcewaked. The interface
    was never designed to be a perfect solution for userspace reads/writes,
    and the kernel portion is fixed by this patch.
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0defd4270594..609358faaa90 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -579,6 +579,9 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	} else switch (INTEL_INFO(dev)->gen) {
 	case 6:
 		ret = gen6_do_reset(dev, flags);
+		/* If reset with a user forcewake, try to restore */
+		if (atomic_read(&dev_priv->forcewake_count))
+			__gen6_gt_force_wake_get(dev_priv);
 		break;
 	case 5:
 		ret = ironlake_do_reset(dev, flags);

commit 98b98d316349e9a028e632629fe813d07fa5afdd
Merge: 0d66cba1ac3a 931474c4c306
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 24 12:06:40 2011 -0700

    Merge branch 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6
    
    * 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6: (169 commits)
      drivers/gpu/drm/radeon/atom.c: fix warning
      drm/radeon/kms: bump kms version number
      drm/radeon/kms: properly set num banks for fusion asics
      drm/radeon/kms/atom: move dig phy init out of modesetting
      drm/radeon/kms/cayman: fix typo in register mask
      drm/radeon/kms: fix typo in spread spectrum code
      drm/radeon/kms: fix tile_config value reported to userspace on cayman.
      drm/radeon/kms: fix incorrect comparison in cayman setup code.
      drm/radeon/kms: add wait idle ioctl for eg->cayman
      drm/radeon/cayman: setup hdp to invalidate and flush when asked
      drm/radeon/evergreen/btc/fusion: setup hdp to invalidate and flush when asked
      agp/uninorth: Fix lockups with radeon KMS and >1x.
      drm/radeon/kms: the SS_Id field in the LCD table if for LVDS only
      drm/radeon/kms: properly set the CLK_REF bit for DCE3 devices
      drm/radeon/kms: fixup eDP connector handling
      drm/radeon/kms: bail early for eDP in hotplug callback
      drm/radeon/kms: simplify hotplug handler logic
      drm/radeon/kms: rewrite DP handling
      drm/radeon/kms/atom: add support for setting DP panel mode
      drm/radeon/kms: atombios.h updates for DP panel mode
      ...

commit a51f7a66fb5e4af5ec4286baef940d06594b59d2
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu May 5 14:42:26 2011 -0700

    drm/i915: enable rc6 by default
    
    With FBC disabled by default, it should be safe to enable RC6.  So let's
    give it a try.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4c9e92f8abc2..817fd9cbb113 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -52,7 +52,7 @@ module_param_named(powersave, i915_powersave, int, 0600);
 unsigned int i915_semaphores = 1;
 module_param_named(semaphores, i915_semaphores, int, 0600);
 
-unsigned int i915_enable_rc6 = 0;
+unsigned int i915_enable_rc6 = 1;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 
 unsigned int i915_enable_fbc = 0;

commit c1a9f047638b27e481d097910604316b8a0d132b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu May 5 15:24:21 2011 -0700

    drm/i915: add fbc enable flag, but disable by default
    
    FBC has too many corner cases that we don't currently deal with, so
    disable it by default so we can enable more important features like RC6,
    which conflicts in some configurations.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=31742
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c4fcbb8a4cb..4c9e92f8abc2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -55,6 +55,9 @@ module_param_named(semaphores, i915_semaphores, int, 0600);
 unsigned int i915_enable_rc6 = 0;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 
+unsigned int i915_enable_fbc = 0;
+module_param_named(i915_enable_fbc, i915_enable_fbc, int, 0600);
+
 unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
@@ -169,7 +172,7 @@ static const struct intel_device_info intel_ironlake_d_info = {
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
-	.has_fbc = 0, /* disabled due to buggy hardware */
+	.has_fbc = 1,
 	.has_bsd_ring = 1,
 };
 

commit 90711d50d0bc3dde0c2bd214abda8cdaf62f7b2e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Apr 28 14:48:02 2011 -0700

    drm/i915: set IBX pch type explicitly
    
    This is a little less confusing than relying on the implicit zeroing of
    the dev_priv.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dc2c1a294668..8c4fcbb8a4cb 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -255,6 +255,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 #endif
 
 #define INTEL_PCH_DEVICE_ID_MASK	0xff00
+#define INTEL_PCH_IBX_DEVICE_ID_TYPE	0x3b00
 #define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
 #define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
 
@@ -275,7 +276,10 @@ void intel_detect_pch (struct drm_device *dev)
 			int id;
 			id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
 
-			if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
+			if (id == INTEL_PCH_IBX_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_IBX;
+				DRM_DEBUG_KMS("Found Ibex Peak PCH\n");
+			} else if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
 			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {

commit c76b615c43a1189c32058ff3ab5634fc3fa97ae5
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Apr 28 14:32:07 2011 -0700

    drm/i915: add Ivy Bridge PCI IDs and driver feature structs
    
    There are several variants, set feature bits appropriately for both
    mobile and desktop parts.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3930c77ac4ac..dc2c1a294668 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -188,6 +188,21 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_blt_ring = 1,
 };
 
+static const struct intel_device_info intel_ivybridge_d_info = {
+	.is_ivybridge = 1, .gen = 7,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+};
+
+static const struct intel_device_info intel_ivybridge_m_info = {
+	.is_ivybridge = 1, .gen = 7, .is_mobile = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_fbc = 0,	/* FBC is not enabled on Ivybridge mobile yet */
+	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
+};
+
 static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),		/* I830_M */
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),		/* 845_G */
@@ -227,6 +242,11 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0116, &intel_sandybridge_m_info),
 	INTEL_VGA_DEVICE(0x0126, &intel_sandybridge_m_info),
 	INTEL_VGA_DEVICE(0x010A, &intel_sandybridge_d_info),
+	INTEL_VGA_DEVICE(0x0156, &intel_ivybridge_m_info), /* GT1 mobile */
+	INTEL_VGA_DEVICE(0x0166, &intel_ivybridge_m_info), /* GT2 mobile */
+	INTEL_VGA_DEVICE(0x0152, &intel_ivybridge_d_info), /* GT1 desktop */
+	INTEL_VGA_DEVICE(0x0162, &intel_ivybridge_d_info), /* GT2 desktop */
+	INTEL_VGA_DEVICE(0x015a, &intel_ivybridge_d_info), /* GT1 server */
 	{0, 0, 0}
 };
 

commit c792513bd1760c364b36391028512fbf2a4eb903
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Apr 7 12:33:56 2011 -0700

    drm/i915: add PantherPoint PCH ID
    
    We can treat PantherPoint as CougarPoint as far as display goes.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 52e52ce067e1..3930c77ac4ac 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -236,6 +236,7 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 
 #define INTEL_PCH_DEVICE_ID_MASK	0xff00
 #define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
+#define INTEL_PCH_PPT_DEVICE_ID_TYPE	0x1e00
 
 void intel_detect_pch (struct drm_device *dev)
 {
@@ -257,6 +258,10 @@ void intel_detect_pch (struct drm_device *dev)
 			if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
 				dev_priv->pch_type = PCH_CPT;
 				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+			} else if (id == INTEL_PCH_PPT_DEVICE_ID_TYPE) {
+				/* PantherPoint is CPT compatible */
+				dev_priv->pch_type = PCH_CPT;
+				DRM_DEBUG_KMS("Found PatherPoint PCH\n");
 			}
 		}
 		pci_dev_put(pch);

commit 087fbc9962e10a65fb0b542ecfc116ebf6cf1735
Author: Andy Lutomirski <luto@mit.edu>
Date:   Fri May 13 12:14:54 2011 -0400

    drm/i915: Revert i915.semaphore=1 default from i915 merge
    
    My Q67 / i7-2600 box has rev09 Sandy Bridge graphics.  It hangs
    instantly when GNOME loads and it hangs so hard the reset button
    doesn't work.  Setting i915.semaphore=0 fixes it.
    
    Semaphores were disabled in a1656b9090f7 ("drm/i915: Disable GPU
    semaphores by default") in 2.6.38 but were then re-enabled (by mistake?)
    by the merge 47ae63e0c2e5 ("Merge branch 'drm-intel-fixes' into
    drm-intel-next").
    
    (It's worth noting that the offending change is i915_drv.c, which was
    not marked as a conflict - although a 'git show --cc' on the merge does
    show that neither parent had it set to 1)
    
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c34a8dd31d02..32d1b3e829c8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,7 +49,7 @@ module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
 unsigned int i915_powersave = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
 
-unsigned int i915_semaphores = 1;
+unsigned int i915_semaphores = 0;
 module_param_named(semaphores, i915_semaphores, int, 0600);
 
 unsigned int i915_enable_rc6 = 0;

commit fcca7926299944841569515da321bef9655b7703
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Mon Apr 25 11:23:07 2011 -0700

    drm/i915: reference counted forcewake
    
    Provide a reference count to track the forcewake state of the GPU and
    give a safe mechanism for userspace to wake the GT. This also potentially
    saves a UC read if the GT is known to be awake already.
    
    The reference count is atomic, but the register access and hardware wake
    sequence is protected by struct_mutex.
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c34a8dd31d02..52e52ce067e1 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -263,7 +263,7 @@ void intel_detect_pch (struct drm_device *dev)
 	}
 }
 
-void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
+static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
 	int count;
 
@@ -279,12 +279,38 @@ void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 		udelay(10);
 }
 
-void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
+/*
+ * Generally this is called implicitly by the register read function. However,
+ * if some sequence requires the GT to not power down then this function should
+ * be called at the beginning of the sequence followed by a call to
+ * gen6_gt_force_wake_put() at the end of the sequence.
+ */
+void gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
+{
+	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
+
+	/* Forcewake is atomic in case we get in here without the lock */
+	if (atomic_add_return(1, &dev_priv->forcewake_count) == 1)
+		__gen6_gt_force_wake_get(dev_priv);
+}
+
+static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
 	POSTING_READ(FORCEWAKE);
 }
 
+/*
+ * see gen6_gt_force_wake_get()
+ */
+void gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
+{
+	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
+
+	if (atomic_dec_and_test(&dev_priv->forcewake_count))
+		__gen6_gt_force_wake_put(dev_priv);
+}
+
 void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
 {
 	int loop = 500;

commit 34db18abd376b2075c760c38f0b861aed379415d
Merge: e73f88af66fc 47ae63e0c2e5
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 14 14:15:13 2011 +1000

    Merge remote branch 'intel/drm-intel-next' of ../drm-next into drm-core-next
    
    * 'intel/drm-intel-next' of ../drm-next: (755 commits)
      drm/i915: Only wait on a pending flip if we intend to write to the buffer
      drm/i915/dp: Sanity check eDP existence
      drm/i915: Rebind the buffer if its alignment constraints changes with tiling
      drm/i915: Disable GPU semaphores by default
      drm/i915: Do not overflow the MMADDR write FIFO
      Revert "drm/i915: fix corruptions on i8xx due to relaxed fencing"
      drm/i915: Don't save/restore hardware status page address register
      drm/i915: don't store the reg value for HWS_PGA
      drm/i915: fix memory corruption with GM965 and >4GB RAM
      Linux 2.6.38-rc7
      Revert "TPM: Long default timeout fix"
      drm/i915: Re-enable GPU semaphores for SandyBridge mobile
      drm/i915: Replace vblank PM QoS with "Interrupt-Based AGPBUSY#"
      Revert "drm/i915: Use PM QoS to prevent C-State starvation of gen3 GPU"
      drm/i915: Allow relocation deltas outside of target bo
      drm/i915: Silence an innocuous compiler warning for an unused variable
      fs/block_dev.c: fix new kernel-doc warning
      ACPI: Fix build for CONFIG_NET unset
      mm: <asm-generic/pgtable.h> must include <linux/mm_types.h>
      x86: Use u32 instead of long to set reset vector back to 0
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_gem.c

commit 47ae63e0c2e5fdb582d471dc906eb29be94c732f
Merge: c59a333f7386 467cffba8579
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 7 12:32:44 2011 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Apply the trivial conflicting regression fixes, but keep GPU semaphores
    enabled.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/i915/i915_gem_execbuffer.c

commit a1656b9090f7008d2941c314f5a64724bea2ae37
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 4 18:48:03 2011 +0000

    drm/i915: Disable GPU semaphores by default
    
    Andi Kleen narrowed his GPU hangs on his Sugar Bay (SNB desktop) rev 09
    down to the use of GPU semaphores, and we already know that they appear
    broken up to Huron River (mobile) rev 08. (I'm optimistic that disabling
    GPU semaphores is simply hiding another bug by the latency and
    side-effects of the additional device interaction it introduces...)
    
    However, use of semaphores is a massive performance improvement... Only
    as long as the system remains stable. Enable at your peril.
    
    Reported-by: Andi Kleen <andi-fd@firstfloor.org>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=33921
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 37d672a116db..22ec066adae6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -46,6 +46,9 @@ module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 unsigned int i915_powersave = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
 
+unsigned int i915_semaphores = 0;
+module_param_named(semaphores, i915_semaphores, int, 0600);
+
 unsigned int i915_enable_rc6 = 0;
 module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
 

commit 91355834646328e7edc6bd25176ae44bcd7386c7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 4 19:22:40 2011 +0000

    drm/i915: Do not overflow the MMADDR write FIFO
    
    Whilst the GT is powered down (rc6), writes to MMADDR are placed in a
    FIFO by the System Agent. This is a limited resource, only 64 entries, of
    which 20 are reserved for Display and PCH writes, and so we must take
    care not to queue up too many writes. To avoid this, there is counter
    which we can poll to ensure there are sufficient free entries in the
    fifo.
    
    "Issuing a write to a full FIFO is not supported; at worst it could
    result in corruption or a system hang."
    
    Reported-and-Tested-by: Matt Turner <mattst88@gmail.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=34056
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0ad533f06af9..37d672a116db 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -254,7 +254,7 @@ void intel_detect_pch (struct drm_device *dev)
 	}
 }
 
-void __gen6_force_wake_get(struct drm_i915_private *dev_priv)
+void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
 {
 	int count;
 
@@ -270,12 +270,22 @@ void __gen6_force_wake_get(struct drm_i915_private *dev_priv)
 		udelay(10);
 }
 
-void __gen6_force_wake_put(struct drm_i915_private *dev_priv)
+void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
 {
 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
 	POSTING_READ(FORCEWAKE);
 }
 
+void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv)
+{
+	int loop = 500;
+	u32 fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+	while (fifo < 20 && loop--) {
+		udelay(10);
+		fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+	}
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;

commit fca874092597ef946b8f07031d8c31c58b212144
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 17 13:44:48 2011 +0000

    drm/i915: Add a module parameter to ignore lid status
    
    Seems like we are forever to be cursed with buggy firmware, so allow the
    user to explicitly set the panel connection status.
    
    Of secondary utility for cases where I run laptops with the lid closed,
    but still want to configure the LVDS.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 64fb21e4bd2d..bdf4ceb1049d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -43,6 +43,9 @@ module_param_named(modeset, i915_modeset, int, 0400);
 unsigned int i915_fbpercrtc = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
+int i915_panel_ignore_lid = 0;
+module_param_named(panel_ignore_lid, i915_panel_ignore_lid, int, 0600);
+
 unsigned int i915_powersave = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
 

commit 9035a97a32836d0e456ddafaaf249a844e6e4b5e
Merge: fe16d949b450 452858338aec
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 16 09:36:05 2011 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Grab the latest stabilisation bits from -fixes and some suspend and
    resume fixes from linus.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/i915/i915_irq.c

commit ac66808814036b4c33dd98091b2176ae6157f1a8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 9 16:15:32 2011 +0000

    drm/i915: Disable RC6 on Ironlake
    
    The automatic powersaving feature is once again causing havoc, with 100%
    reliable hangs on boot and resume on affected machines.
    
    Reported-by: Francesco Allertsen <fallertsen@gmail.com>
    Reported-by: Gui Rui <chaos.proton@gmail.com>
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=28582
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cfb56d0ff367..0ad533f06af9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -46,6 +46,9 @@ module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 unsigned int i915_powersave = 1;
 module_param_named(powersave, i915_powersave, int, 0600);
 
+unsigned int i915_enable_rc6 = 0;
+module_param_named(i915_enable_rc6, i915_enable_rc6, int, 0600);
+
 unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
@@ -360,7 +363,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 		/* Resume the modeset for every activated CRTC */
 		drm_helper_resume_force_mode(dev);
 
-		if (dev_priv->renderctx && dev_priv->pwrctx)
+		if (IS_IRONLAKE_M(dev))
 			ironlake_enable_rc6(dev);
 	}
 

commit 8410ea3b95d105a5be5db501656f44bbb91197c1
Author: Dave Airlie <airlied@gmail.com>
Date:   Wed Dec 15 03:16:38 2010 +1000

    drm: rework PCI/platform driver interface.
    
    This abstracts the pci/platform interface out a step further,
    we can go further but this is far enough for now to allow USB
    to be plugged in.
    
    The drivers now just call the init code directly for their
    device type.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 17fde2f27418..9ad42d583493 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -719,14 +719,6 @@ static struct drm_driver driver = {
 		 .llseek = noop_llseek,
 	},
 
-	.pci_driver = {
-		 .name = DRIVER_NAME,
-		 .id_table = pciidlist,
-		 .probe = i915_pci_probe,
-		 .remove = i915_pci_remove,
-		 .driver.pm = &i915_pm_ops,
-	},
-
 	.name = DRIVER_NAME,
 	.desc = DRIVER_DESC,
 	.date = DRIVER_DATE,
@@ -735,6 +727,14 @@ static struct drm_driver driver = {
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
 
+static struct pci_driver i915_pci_driver = {
+	.name = DRIVER_NAME,
+	.id_table = pciidlist,
+	.probe = i915_pci_probe,
+	.remove = i915_pci_remove,
+	.driver.pm = &i915_pm_ops,
+};
+
 static int __init i915_init(void)
 {
 	if (!intel_agp_enabled) {
@@ -768,12 +768,12 @@ static int __init i915_init(void)
 	if (!(driver.driver_features & DRIVER_MODESET))
 		driver.get_vblank_timestamp = NULL;
 
-	return drm_init(&driver);
+	return drm_pci_init(&driver, &i915_pci_driver);
 }
 
 static void __exit i915_exit(void)
 {
-	drm_exit(&driver);
+	drm_pci_exit(&driver, &i915_pci_driver);
 }
 
 module_init(i915_init);

commit ff72145badb834e8051719ea66e024784d000cb4
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 7 12:16:14 2011 +1000

    drm: dumb scanout create/mmap for intel/radeon (v3)
    
    This is just an idea that might or might not be a good idea,
    it basically adds two ioctls to create a dumb and map a dumb buffer
    suitable for scanout. The handle can be passed to the KMS ioctls to create
    a framebuffer.
    
    It looks to me like it would be useful in the following cases:
    a) in development drivers - we can always provide a shadowfb fallback.
    b) libkms users - we can clean up libkms a lot and avoid linking
    to libdrm_*.
    c) plymouth via libkms is a lot easier.
    
    Userspace bits would be just calls + mmaps. We could probably
    mark these handles somehow as not being suitable for acceleartion
    so as top stop people who are dumber than dumb.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cfb56d0ff367..17fde2f27418 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -700,6 +700,9 @@ static struct drm_driver driver = {
 	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,
+	.dumb_create = i915_gem_dumb_create,
+	.dumb_map_offset = i915_gem_mmap_gtt,
+	.dumb_destroy = i915_gem_dumb_destroy,
 	.ioctls = i915_ioctls,
 	.fops = {
 		 .owner = THIS_MODULE,

commit 5fe49d86f9d01044abf687a8cd21edef636d58aa
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Feb 1 19:43:02 2011 +0000

    drm/i915: Only bind to function 0 of the PCI device
    
    Early chipsets (gen2/3) used function 1 as a placeholder for multi-head.
    We used to ignore these since they were not assigned to
    PCI_CLASS_DISPLAY_VGA. However with 934f992c7 we attempt to bind to all
    Intel PCI_CLASS_DISPLAY devices (and functions) to work in multi-gpu
    systems. This fails hard on gen2/3.
    
    Reported-by: Ferenc Wágner <wferi@niif.hu>
    Tested-by: Ferenc Wágner <wferi@niif.hu>
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=28012
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e517447b0880..cfb56d0ff367 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -568,6 +568,14 @@ int i915_reset(struct drm_device *dev, u8 flags)
 static int __devinit
 i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
+	/* Only bind to function 0 of the device. Early generations
+	 * used function 1 as a placeholder for multi-head. This causes
+	 * us confusion instead, especially on the systems where both
+	 * functions have the same PCI-ID!
+	 */
+	if (PCI_FUNC(pdev->devfn))
+		return -ENODEV;
+
 	return drm_get_pci_dev(pdev, ent, &driver);
 }
 

commit 4a1dc3ff68807bf3c76563bf439166854d063adc
Merge: 72557b4f326a 78c6e170badd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Feb 1 08:49:07 2011 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Merge resume fixes from -fixes and an important fix for SDVO GMBUS.

commit 5a1e5b6c460dccfd189c7e962281c8cce75da728
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Jan 29 16:50:25 2011 +0000

    drm/i915: Override SDVO panel type in VBT
    
    Judging by comments in the BIOS, if the SDVO LVDS option h40 is enabled,
    then we are supposed to query the real panel type via Int15. We don't do
    this and so for the Sony Vaio VGC-JS210J which has otherwise default
    values, we choose the wrong mode.
    
    This patch adds a driver option, i915.vbt_sdvo_panel_type, which can be
    used to override the value in the VBT.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=33691
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 211de8e57200..db13d4d46042 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -52,6 +52,9 @@ module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 unsigned int i915_panel_use_ssc = 1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 
+int i915_vbt_sdvo_panel_type = -1;
+module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
+
 static bool i915_try_reset = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
 

commit 500f7147cf5bafd139056d521536b10c2bc2e154
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 24 15:14:41 2011 +0000

    drm/i915: Reset state after a GPU reset or resume
    
    Call drm_mode_config_reset() after an invalidation event to restore any
    cached state to unknown.
    
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 66796bb82d3e..e517447b0880 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -354,6 +354,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 		error = i915_gem_init_ringbuffer(dev);
 		mutex_unlock(&dev->struct_mutex);
 
+		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 
 		/* Resume the modeset for every activated CRTC */
@@ -542,6 +543,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);
+		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 		mutex_lock(&dev->struct_mutex);
 	}

commit bdd92c9ad287e03a2ec52f5a89c470cd5caae1c2
Merge: a37f2f87edc1 8e934dbf2644
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Jan 23 17:24:26 2011 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Merge important suspend and resume regression fixes and resolve the
    small conflict.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c

commit 3885c6bbd0c6c9cc3c8e6d4f723abc87c593b07a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Jan 23 10:45:14 2011 +0000

    drm/i915: Disable high-precision vblank timestamping for UMS
    
    We only have sufficient information for accurate (sub-frame) timestamping
    when the modesetting is under our control.
    
    Reported-by: Chris Clayton <chris2553@googlemail.com>
    Tested-by: Chris Clayton <chris2553@googlemail.com>
    Reviewed-by: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 59eb19b13b3f..66796bb82d3e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -752,6 +752,9 @@ static int __init i915_init(void)
 		driver.driver_features &= ~DRIVER_MODESET;
 #endif
 
+	if (!(driver.driver_features & DRIVER_MODESET))
+		driver.get_vblank_timestamp = NULL;
+
 	return drm_init(&driver);
 }
 

commit 934f992c763ae1e5eefcce8af769c16444085df7
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 20 13:09:12 2011 +0000

    drm/i915: Recognise non-VGA display devices
    
    Starting with SandyBridge (though possible with earlier hacked BIOSes),
    the BIOS may initialise the IGFX as secondary to a discrete GPU. Prior,
    it would simply disable the integrated GPU. So we adjust our PCI class
    mask to match any DISPLAY_CLASS device.
    
    In such a configuration, the IGFX is not a primary VGA controller and
    so should not take part in VGA arbitration, and the error return from
    vga_client_register() is expected.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 72fea2bcfc4f..59eb19b13b3f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -60,7 +60,7 @@ extern int intel_agp_enabled;
 
 #define INTEL_VGA_DEVICE(id, info) {		\
 	.class = PCI_CLASS_DISPLAY_VGA << 8,	\
-	.class_mask = 0xffff00,			\
+	.class_mask = 0xff0000,			\
 	.vendor = 0x8086,			\
 	.device = id,				\
 	.subvendor = PCI_ANY_ID,		\

commit 311bd68e024f9006db66cbadc3bd9f62fd663f4b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 13 19:06:50 2011 +0000

    drm/i915: Trivial sparse fixes
    
    Move code around and invoke iomem annotation in a few more places in
    order to silence sparse. Still a few more iomem annotations to go...
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 72fea2bcfc4f..2d31f5fd08f5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -52,7 +52,7 @@ module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 unsigned int i915_panel_use_ssc = 1;
 module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
 
-bool i915_try_reset = true;
+static bool i915_try_reset = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
 
 static struct drm_driver driver;

commit a76150302d6e7ebc43e1a1ddaee7fd51db8da3b3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jan 12 17:04:08 2011 +0000

    drm/i915: Add a module option to override the use of SSC
    
    In order to workaround the issue with LVDS not working on the Lenovo
    U160 apparently due to using the wrong SSC frequency, add an option to
    disable SSC.
    
    Suggested-by: Lukács, Árpád <lukacs.arpad@gmail.com>
    Bugzillla: https://bugs.freedesktop.org/show_bug.cgi?id=32748
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0de75a23f8e7..72fea2bcfc4f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,9 @@ module_param_named(powersave, i915_powersave, int, 0600);
 unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
+unsigned int i915_panel_use_ssc = 1;
+module_param_named(lvds_use_ssc, i915_panel_use_ssc, int, 0600);
+
 bool i915_try_reset = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
 

commit d5bb081b027b520f9e59b4fb8faea83a136ec15e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jan 5 12:01:26 2011 -0800

    drm/i915: cleanup rc6 code
    
    Cleanup several aspects of the rc6 code:
      - misnamed intel_disable_clock_gating function (was only about rc6)
      - remove commented call to intel_disable_clock_gating
      - rc6 enabling code belongs in its own function (allows us to move the
        actual clock gating enable call back into restore_state)
      - allocate power & render contexts up front, only free on unload
        (avoids ugly lazy init at rc6 enable time)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [ickle: checkpatch cleanup]
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 02fce7fbcd8a..0de75a23f8e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -355,10 +355,10 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 		/* Resume the modeset for every activated CRTC */
 		drm_helper_resume_force_mode(dev);
-	}
 
-	/* Clock gating state */
-	intel_enable_clock_gating(dev);
+		if (dev_priv->renderctx && dev_priv->pwrctx)
+			ironlake_enable_rc6(dev);
+	}
 
 	intel_opregion_init(dev);
 

commit 1daed3fb8324d517a1f9da43f1a1d3619d1b0ddc
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jan 5 12:01:25 2011 -0800

    drm/i915: fix rc6 enabling around suspend/resume
    
    Enabling RC6 implies setting a graphics context.  Make sure we do that
    only after the ring has been enabled, otherwise our ring commands will
    hang.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2913496e8716..02fce7fbcd8a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -357,6 +357,9 @@ static int i915_drm_thaw(struct drm_device *dev)
 		drm_helper_resume_force_mode(dev);
 	}
 
+	/* Clock gating state */
+	intel_enable_clock_gating(dev);
+
 	intel_opregion_init(dev);
 
 	dev_priv->modeset_on_lid = 0;

commit d78cb50baa9177353d6719612b83558a9bf2d59b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Dec 23 13:33:15 2010 +0000

    drm/i915: add 'reset' parameter
    
    When bringing up new hardware, or otherwise experimenting, GPU hangs are
    a way of life. However, the automatic GPU reset can do more harm than
    good under these circumstances, as we may wish to capture a full trace for
    debugging.
    
    Based on a patch by Zhenyu Wang.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 872493331988..2913496e8716 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,9 @@ module_param_named(powersave, i915_powersave, int, 0600);
 unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
+bool i915_try_reset = true;
+module_param_named(reset, i915_try_reset, bool, 0600);
+
 static struct drm_driver driver;
 extern int intel_agp_enabled;
 
@@ -475,6 +478,9 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	bool need_display = true;
 	int ret;
 
+	if (!i915_try_reset)
+		return 0;
+
 	if (!mutex_trylock(&dev->struct_mutex))
 		return -EBUSY;
 

commit 5bcf719b7db0f9366cedaf102b081f99b1c325ae
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 7 09:20:40 2010 +1000

    drm/switcheroo: track state of switch in drivers.
    
    We need to track the state of the switch in drivers, so that after s/r
    we don't resume the card we've explicitly switched off before. Also
    don't allow a userspace open to occur if we've switched the gpu off.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 9eee6cf7901e..872493331988 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -271,6 +271,8 @@ static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	drm_kms_helper_poll_disable(dev);
+
 	pci_save_state(dev->pdev);
 
 	/* If KMS is active, we do the leavevt stuff here */
@@ -307,7 +309,9 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (state.event == PM_EVENT_PRETHAW)
 		return 0;
 
-	drm_kms_helper_poll_disable(dev);
+
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
 
 	error = i915_drm_freeze(dev);
 	if (error)
@@ -361,6 +365,9 @@ int i915_resume(struct drm_device *dev)
 {
 	int ret;
 
+	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	if (pci_enable_device(dev->pdev))
 		return -EIO;
 
@@ -569,6 +576,9 @@ static int i915_pm_suspend(struct device *dev)
 		return -ENODEV;
 	}
 
+	if (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF)
+		return 0;
+
 	error = i915_drm_freeze(drm_dev);
 	if (error)
 		return error;

commit 0af7e4dff50454905092d468e91c1ef92e10e6b4
Author: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
Date:   Wed Dec 8 04:07:19 2010 +0100

    drm/i915: Add support for precise vblank timestamping (v2)
    
    v2: Change IS_IRONLAKE to IS_GEN5 to adapt to 2.6.37
    
    This patch adds new functions for use by the drm core:
    
    .get_vblank_timestamp() provides a precise timestamp
    for the end of the most recent (or current) vblank
    interval of a given crtc, as needed for the DRI2
    implementation of the OML_sync_control extension.
    It is a thin wrapper around the drm function
    drm_calc_vbltimestamp_from_scanoutpos() which does
    almost all the work.
    
    .get_scanout_position() provides the current horizontal
    and vertical video scanout position and "in vblank"
    status of a given crtc, as needed by the drm for use by
    drm_calc_vbltimestamp_from_scanoutpos().
    
    The patch modifies the pageflip completion routine
    to use these precise vblank timestamps as the timestamps
    for pageflip completion events.
    
    This code has been only tested on a HP-Mini Netbook with
    Atom processor and Intel 945GME gpu. The codepath for
    (IS_G4X(dev) || IS_GEN5(dev) || IS_GEN6(dev)) gpu's
    has not been tested so far due to lack of hardware.
    
    Signed-off-by: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index bdb29b2a01ed..9eee6cf7901e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -652,6 +652,8 @@ static struct drm_driver driver = {
 	.device_is_agp = i915_driver_device_is_agp,
 	.enable_vblank = i915_enable_vblank,
 	.disable_vblank = i915_disable_vblank,
+	.get_vblank_timestamp = i915_get_vblank_timestamp,
+	.get_scanout_position = i915_get_crtc_scanoutpos,
 	.irq_preinstall = i915_driver_irq_preinstall,
 	.irq_postinstall = i915_driver_irq_postinstall,
 	.irq_uninstall = i915_driver_irq_uninstall,

commit 9c04f015ebc2cc2cca5a4a576deb82a311578edc
Author: Yuanhan Liu <yuanhan.liu@linux.intel.com>
Date:   Wed Dec 15 15:42:32 2010 +0800

    drm/i915: Add frame buffer compression on Sandybridge
    
    Add frame buffer compression on Sandybridge. The method is similar to
    Ironlake, except that two new registers of type GTTMMADR must be written
    with the right fence info.
    
    Signed-off-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5f20cd988612..bdb29b2a01ed 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -165,6 +165,7 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 static const struct intel_device_info intel_sandybridge_m_info = {
 	.gen = 6, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_fbc = 1,
 	.has_bsd_ring = 1,
 	.has_blt_ring = 1,
 };

commit eb43f4af7ecb7d51ba44f5e96bf74eedf1c27d62
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Dec 8 17:32:24 2010 +0000

    drm/i915: Terminate the FORCE WAKE after we have finished reading
    
    Once we have read the value out of the GT power well, we need to remove
    the FORCE WAKE bit to allow the system to auto-power down.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2be344a8e93b..5f20cd988612 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -244,6 +244,28 @@ void intel_detect_pch (struct drm_device *dev)
 	}
 }
 
+void __gen6_force_wake_get(struct drm_i915_private *dev_priv)
+{
+	int count;
+
+	count = 0;
+	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK) & 1))
+		udelay(10);
+
+	I915_WRITE_NOTRACE(FORCEWAKE, 1);
+	POSTING_READ(FORCEWAKE);
+
+	count = 0;
+	while (count++ < 50 && (I915_READ_NOTRACE(FORCEWAKE_ACK) & 1) == 0)
+		udelay(10);
+}
+
+void __gen6_force_wake_put(struct drm_i915_private *dev_priv)
+{
+	I915_WRITE_NOTRACE(FORCEWAKE, 0);
+	POSTING_READ(FORCEWAKE);
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;

commit d1c3b177b9940541e89015a726ac279caf1a21f3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Dec 8 14:26:19 2010 +0000

    drm/i915: Restore GTT mapping first upon resume
    
    As suggested by Daniel Vetter, this is a safeguard should any of the
    registers cause reference to PTE entries.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ad28b21f4d03..2be344a8e93b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -304,13 +304,18 @@ static int i915_drm_thaw(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		mutex_lock(&dev->struct_mutex);
+		i915_gem_restore_gtt_mappings(dev);
+		mutex_unlock(&dev->struct_mutex);
+	}
+
 	i915_restore_state(dev);
 	intel_opregion_setup(dev);
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
-		i915_gem_restore_gtt_mappings(dev);
 		dev_priv->mm.suspended = 0;
 
 		error = i915_gem_init_ringbuffer(dev);

commit 4a19d02e0a8cd8799e5d150d8eb74861e1a4cdec
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Dec 8 13:31:49 2010 +0000

    drm/i915: driver.suspend and .resume are always set
    
    So we can remove the repeated initialisation.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 91a3ad2cf942..ad28b21f4d03 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -700,11 +700,6 @@ static int __init i915_init(void)
 		driver.driver_features &= ~DRIVER_MODESET;
 #endif
 
-	if (!(driver.driver_features & DRIVER_MODESET)) {
-		driver.suspend = i915_suspend;
-		driver.resume = i915_resume;
-	}
-
 	return drm_init(&driver);
 }
 

commit e3c4e5dd5ad1993a3687862c982272f8f00cae30
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Dec 5 16:49:51 2010 +0000

    drm/i915: caps.has_rc6 is no longer used, remove it.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 413a040386a9..91a3ad2cf942 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -111,7 +111,7 @@ static const struct intel_device_info intel_i965g_info = {
 
 static const struct intel_device_info intel_i965gm_info = {
 	.gen = 4, .is_crestline = 1,
-	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.is_mobile = 1, .has_fbc = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 	.supports_tv = 1,
 };
@@ -130,7 +130,7 @@ static const struct intel_device_info intel_g45_info = {
 
 static const struct intel_device_info intel_gm45_info = {
 	.gen = 4, .is_g4x = 1,
-	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
+	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.supports_tv = 1,
 	.has_bsd_ring = 1,
@@ -150,7 +150,7 @@ static const struct intel_device_info intel_ironlake_d_info = {
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_mobile = 1,
-	.need_gfx_hws = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_fbc = 0, /* disabled due to buggy hardware */
 	.has_bsd_ring = 1,
 };

commit 1ec14ad3132702694f2e1a90b30641cf111183b9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Dec 4 11:30:53 2010 +0000

    drm/i915: Implement GPU semaphores for inter-ring synchronisation on SNB
    
    The bulk of the change is to convert the growing list of rings into an
    array so that the relationship between the rings and the semaphore sync
    registers can be easily computed.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 64844e2e9f86..413a040386a9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -487,11 +487,11 @@ int i915_reset(struct drm_device *dev, u8 flags)
 			!dev_priv->mm.suspended) {
 		dev_priv->mm.suspended = 0;
 
-		dev_priv->render_ring.init(&dev_priv->render_ring);
+		dev_priv->ring[RCS].init(&dev_priv->ring[RCS]);
 		if (HAS_BSD(dev))
-		    dev_priv->bsd_ring.init(&dev_priv->bsd_ring);
+		    dev_priv->ring[VCS].init(&dev_priv->ring[VCS]);
 		if (HAS_BLT(dev))
-		    dev_priv->blt_ring.init(&dev_priv->blt_ring);
+		    dev_priv->ring[BCS].init(&dev_priv->ring[BCS]);
 
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);

commit 340479aac697bc73e225c122a9753d4964eeda3f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Dec 4 18:17:15 2010 +0000

    drm/i915: Be paranoid and bail on resetting if we can't take the lock.
    
    This will declare the machine wedged, but is better than truly wedging
    the machine.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1a15b7886b8c..64844e2e9f86 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -440,7 +440,8 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	bool need_display = true;
 	int ret;
 
-	mutex_lock(&dev->struct_mutex);
+	if (!mutex_trylock(&dev->struct_mutex))
+		return -EBUSY;
 
 	i915_gem_reset(dev);
 

commit 76aaf22016caa7764f40e792aaca7b4918312b22
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Nov 5 22:23:30 2010 +0100

    drm/i915: restore gtt on resume in the drm instead of in intel-gtt.ko
    
    This still uses the agp functions to actually reinstate the mappings
    (with a gross hack to make agp cooperate), but it wires everything
    up correctly for the switchover.
    
    The call to agp_rebind_memory can be dropped because all non-kms drivers
    do all their rebinding on EnterVT.
    
    v2: Be more paranoid and flush the chipset cache after restoring gtt
    mappings.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 8c5541950b8d..1a15b7886b8c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -310,6 +310,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
+		i915_gem_restore_gtt_mappings(dev);
 		dev_priv->mm.suspended = 0;
 
 		error = i915_gem_init_ringbuffer(dev);

commit cff458c21063de960bde0e39770a0f4cd0477d95
Author: Eric Anholt <eric@anholt.net>
Date:   Thu Nov 18 09:31:14 2010 +0800

    drm/i915: Add support for GPU reset on gen6.
    
    This has proven sufficient to recover from a hang of the GPU using the
    gem_bad_blit test while at the KMS console then starting X.  When
    attempting the same during an X session, the timer doesn't appear to
    trigger.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 99b574050fde..8c5541950b8d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -405,6 +405,14 @@ static int ironlake_do_reset(struct drm_device *dev, u8 flags)
 	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
 }
 
+static int gen6_do_reset(struct drm_device *dev, u8 flags)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	I915_WRITE(GEN6_GDRST, GEN6_GRDOM_FULL);
+	return wait_for((I915_READ(GEN6_GDRST) & GEN6_GRDOM_FULL) == 0, 500);
+}
+
 /**
  * i965_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -439,6 +447,9 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	if (get_seconds() - dev_priv->last_gpu_reset < 5) {
 		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
 	} else switch (INTEL_INFO(dev)->gen) {
+	case 6:
+		ret = gen6_do_reset(dev, flags);
+		break;
 	case 5:
 		ret = ironlake_do_reset(dev, flags);
 		break;

commit 75a6898ffd20a13aba8d03f005eb4ab940134fcb
Author: Eric Anholt <eric@anholt.net>
Date:   Thu Nov 18 09:31:13 2010 +0800

    drm/i915: Also reinit the BSD and BLT rings after a GPU reset.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f0e6bd06fc0e..99b574050fde 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -472,9 +472,14 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
 			!dev_priv->mm.suspended) {
-		struct intel_ring_buffer *ring = &dev_priv->render_ring;
 		dev_priv->mm.suspended = 0;
-		ring->init(ring);
+
+		dev_priv->render_ring.init(&dev_priv->render_ring);
+		if (HAS_BSD(dev))
+		    dev_priv->bsd_ring.init(&dev_priv->bsd_ring);
+		if (HAS_BLT(dev))
+		    dev_priv->blt_ring.init(&dev_priv->blt_ring);
+
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);

commit e624ae8e0d4243e71daedce7570e91290438eaca
Merge: c4a1d9e4dc5d 4ab0fbd3a290
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Nov 22 08:51:36 2010 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Conflicts:
            drivers/gpu/drm/i915/i915_gem.c

commit 16c59ef33b389217c29122235e475557bc1412a1
Author: Alex Shi <alex.shi@intel.com>
Date:   Fri Nov 19 09:33:55 2010 +0000

    drm/i915: Disable FBC on Ironlake to save 1W
    
    Frame buffer compression is broken on Ironlake due to buggy hardware.
    Currently it is disabled through chicken bits, but it still consumes
    over 1W more than if we simply never attempt to enable the FBC code
    paths.
    
    Signed-off-by: Alex Shi <alex.shi@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 80745f85902c..f737960712e6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -150,7 +150,8 @@ static const struct intel_device_info intel_ironlake_d_info = {
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_mobile = 1,
-	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.need_gfx_hws = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.has_fbc = 0, /* disabled due to buggy hardware */
 	.has_bsd_ring = 1,
 };
 

commit 8c1812ad4879676bec1bd20f8ff478c8a076f3fc
Merge: 8d19215be825 5588978882b5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 2 10:53:29 2010 +0000

    Merge branch 'drm-intel-fixes' into drm-intel-next
    
    Immediate merge to resolve conflicts from applying a stability fix to
    both branches.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_ringbuffer.c
            drivers/gpu/drm/i915/intel_ringbuffer.h

commit 0aa992777270f0ea7097170fa50a1d98615eb0d4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 2 09:20:50 2010 +0000

    drm/i915: Allow powersave modparam to be adjusted at runtime.
    
    2.6.36 appears to respect the 0400 mode we assigned to the parameter
    preventing it from being adjusted after loading. However, this is safe
    to adjust at runtime.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=31311
    Reported-by: Fernando Lemos <fernandotcl@gmail.com>
    Cc: stable@kernel.org
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3467dd420760..80745f85902c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -44,7 +44,7 @@ unsigned int i915_fbpercrtc = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
 unsigned int i915_powersave = 1;
-module_param_named(powersave, i915_powersave, int, 0400);
+module_param_named(powersave, i915_powersave, int, 0600);
 
 unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);

commit 17250b71553680bc6e927497aa619ab06ab1015b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Oct 28 12:51:39 2010 +0100

    drm/i915: Make the inactive object shrinker per-device
    
    Eliminate the racy device unload by embedding a shrinker into each
    device. Smaller, simpler code.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 82c19ab3e1e2..d22aab94d645 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -660,8 +660,6 @@ static int __init i915_init(void)
 
 	driver.num_ioctls = i915_max_ioctl;
 
-	i915_gem_shrinker_init();
-
 	/*
 	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless
 	 * explicitly disabled with the module pararmeter.
@@ -693,7 +691,6 @@ static int __init i915_init(void)
 
 static void __exit i915_exit(void)
 {
-	i915_gem_shrinker_exit();
 	drm_exit(&driver);
 }
 

commit 78501eac34f372bfbeb4e1d9de688c13efa916f6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 27 12:18:21 2010 +0100

    drm/i915/ringbuffer: Drop the redundant dev from the vfunc interface
    
    The ringbuffer keeps a pointer to the parent device, so we can use that
    instead of passing around the pointer on the stack.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 3467dd420760..82c19ab3e1e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -473,7 +473,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 			!dev_priv->mm.suspended) {
 		struct intel_ring_buffer *ring = &dev_priv->render_ring;
 		dev_priv->mm.suspended = 0;
-		ring->init(dev, ring);
+		ring->init(ring);
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);

commit c48c43e422c1404fd72c57d1d21a6f6d01e18900
Merge: 520045db940a 135cba0dc399
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 18:57:59 2010 -0700

    Merge branch 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6
    
    * 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6: (476 commits)
      vmwgfx: Implement a proper GMR eviction mechanism
      drm/radeon/kms: fix r6xx/7xx 1D tiling CS checker v2
      drm/radeon/kms: properly compute group_size on 6xx/7xx
      drm/radeon/kms: fix 2D tile height alignment in the r600 CS checker
      drm/radeon/kms/evergreen: set the clear state to the blit state
      drm/radeon/kms: don't poll dac load detect.
      gpu: Add Intel GMA500(Poulsbo) Stub Driver
      drm/radeon/kms: MC vram map needs to be >= pci aperture size
      drm/radeon/kms: implement display watermark support for evergreen
      drm/radeon/kms/evergreen: add some additional safe regs v2
      drm/radeon/r600: fix tiling issues in CS checker.
      drm/i915: Move gpu_write_list to per-ring
      drm/i915: Invalidate the to-ring, flush the old-ring when updating domains
      drm/i915/ringbuffer: Write the value passed in to the tail register
      agp/intel: Restore valid PTE bit for Sandybridge after bdd3072
      drm/i915: Fix flushing regression from 9af90d19f
      drm/i915/sdvo: Remove unused encoding member
      i915: enable AVI infoframe for intel_hdmi.c [v4]
      drm/i915: Fix current fb blocking for page flip
      drm/i915: IS_IRONLAKE is synonymous with gen == 5
      ...
    
    Fix up conflicts in
     - drivers/gpu/drm/i915/{i915_gem.c, i915/intel_overlay.c}: due to the
       new simplified stack-based kmap_atomic() interface
     - drivers/gpu/drm/vmwgfx/vmwgfx_drv.c: added .llseek entry due to BKL
       removal cleanups.

commit 092e0e7e520a1fca03e13c9f2d157432a8657ff2
Merge: 79f14b7c56d3 776c163b1b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:56 2010 -0700

    Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      vfs: make no_llseek the default
      vfs: don't use BKL in default_llseek
      llseek: automatically add .llseek fop
      libfs: use generic_file_llseek for simple_attr
      mac80211: disallow seeks in minstrel debug code
      lirc: make chardev nonseekable
      viotape: use noop_llseek
      raw: use explicit llseek file operations
      ibmasmfs: use generic_file_llseek
      spufs: use llseek in all file operations
      arm/omap: use generic_file_llseek in iommu_debug
      lkdtm: use generic_file_llseek in debugfs
      net/wireless: use generic_file_llseek in debugfs
      drm: use noop_llseek

commit f00a3ddf91d596bece5fa31e8ce2e8a3b4c0623b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Oct 21 14:57:17 2010 +0100

    drm/i915: IS_IRONLAKE is synonymous with gen == 5
    
    So remove the redundant bit in the capabilities block and
    s/IS_IRONLAKE/IS_GEN5/.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 90f9c3e3fee3..8e632110c58f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -143,13 +143,13 @@ static const struct intel_device_info intel_pineview_info = {
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
-	.gen = 5, .is_ironlake = 1,
+	.gen = 5,
 	.need_gfx_hws = 1, .has_pipe_cxsr = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
-	.gen = 5, .is_ironlake = 1, .is_mobile = 1,
+	.gen = 5, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
 };

commit 549f7365820a212a1cfd0871d377b1ad0d1e5723
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 19 11:19:32 2010 +0100

    drm/i915: Enable SandyBridge blitter ring
    
    Based on an original patch by Zhenyu Wang, this initializes the BLT ring for
    SandyBridge and enables support for user execbuffers.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c3decb2fef4b..90f9c3e3fee3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -158,12 +158,14 @@ static const struct intel_device_info intel_sandybridge_d_info = {
 	.gen = 6,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
 	.gen = 6, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_bsd_ring = 1,
+	.has_blt_ring = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit ae681d969ac0946e09636f2bef7a126d73e1ad6b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 1 14:57:56 2010 +0100

    drm/i915: If the GPU hangs twice within 5 seconds, declare it wedged.
    
    The issue is that we may become stuck executing a long running shader
    and continually attempt to reset the GPU. (Or maybe we tickle some bug
    and need to break the vicious cycle.) So if we are detect a second hang
    within 5 seconds, give up trying to programme the GPU and report it
    wedged.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f3243a3abc37..c3decb2fef4b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -383,6 +383,11 @@ static int i965_do_reset(struct drm_device *dev, u8 flags)
 {
 	u8 gdrst;
 
+	/*
+	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
+	 * well as the reset bit (GR/bit 0).  Setting the GR bit
+	 * triggers the reset; when done, the hardware will clear it.
+	 */
 	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
 	pci_write_config_byte(dev->pdev, I965_GDRST, gdrst | flags | 0x1);
 
@@ -427,13 +432,10 @@ int i915_reset(struct drm_device *dev, u8 flags)
 
 	i915_gem_reset(dev);
 
-	/*
-	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
-	 * well as the reset bit (GR/bit 0).  Setting the GR bit
-	 * triggers the reset; when done, the hardware will clear it.
-	 */
 	ret = -ENODEV;
-	switch (INTEL_INFO(dev)->gen) {
+	if (get_seconds() - dev_priv->last_gpu_reset < 5) {
+		DRM_ERROR("GPU hanging too fast, declaring wedged!\n");
+	} else switch (INTEL_INFO(dev)->gen) {
 	case 5:
 		ret = ironlake_do_reset(dev, flags);
 		break;
@@ -444,6 +446,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 		ret = i8xx_do_reset(dev, flags);
 		break;
 	}
+	dev_priv->last_gpu_reset = get_seconds();
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");
 		mutex_unlock(&dev->struct_mutex);

commit dc96e9b8e37641d9d15a8a4cdd18ed7680d8f546
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 1 12:05:06 2010 +0100

    drm/i915: Try to reset gen2 devices.
    
    So far only found registers for i830, i845, i865 and one of those has no
    effect on i865!
    
    At this moment in time, attempting to reset i8xx is a little
    optimistic...
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2109537d1b90..f3243a3abc37 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -342,6 +342,36 @@ int i915_resume(struct drm_device *dev)
 	return 0;
 }
 
+static int i8xx_do_reset(struct drm_device *dev, u8 flags)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	if (IS_I85X(dev))
+		return -ENODEV;
+
+	I915_WRITE(D_STATE, I915_READ(D_STATE) | DSTATE_GFX_RESET_I830);
+	POSTING_READ(D_STATE);
+
+	if (IS_I830(dev) || IS_845G(dev)) {
+		I915_WRITE(DEBUG_RESET_I830,
+			   DEBUG_RESET_DISPLAY |
+			   DEBUG_RESET_RENDER |
+			   DEBUG_RESET_FULL);
+		POSTING_READ(DEBUG_RESET_I830);
+		msleep(1);
+
+		I915_WRITE(DEBUG_RESET_I830, 0);
+		POSTING_READ(DEBUG_RESET_I830);
+	}
+
+	msleep(1);
+
+	I915_WRITE(D_STATE, I915_READ(D_STATE) & ~DSTATE_GFX_RESET_I830);
+	POSTING_READ(D_STATE);
+
+	return 0;
+}
+
 static int i965_reset_complete(struct drm_device *dev)
 {
 	u8 gdrst;
@@ -410,6 +440,9 @@ int i915_reset(struct drm_device *dev, u8 flags)
 	case 4:
 		ret = i965_do_reset(dev, flags);
 		break;
+	case 2:
+		ret = i8xx_do_reset(dev, flags);
+		break;
 	}
 	if (ret) {
 		DRM_ERROR("Failed to reset chip.\n");

commit 069efc1dac477a4a51e42c0fe50bdcf85ada626a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Sep 30 16:53:18 2010 +0100

    drm/i915: Clear fence registers on GPU reset
    
    When the GPU is reset, the fence registers are invalidated, so release
    the objects and clear them out.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2184d29e7a9f..2109537d1b90 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -395,7 +395,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 
 	mutex_lock(&dev->struct_mutex);
 
-	i915_gem_reset_lists(dev);
+	i915_gem_reset(dev);
 
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as

commit dfaae392f4461785eb1c92aeaf2a1040b184edba
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 22 10:31:52 2010 +0100

    drm/i915: Clear the gpu_write_list on resetting write_domain upon hang
    
    Otherwise we will hit a list handling assertion when moving the object
    to the inactive list.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4e83bb36888e..2184d29e7a9f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -395,21 +395,7 @@ int i915_reset(struct drm_device *dev, u8 flags)
 
 	mutex_lock(&dev->struct_mutex);
 
-	/*
-	 * Clear request list
-	 */
-	i915_gem_retire_requests(dev);
-
-	/* Remove anything from the flushing lists. The GPU cache is likely
-	 * to be lost on reset along with the data, so simply move the
-	 * lost bo to the inactive list.
-	 */
-	i915_gem_reset_flushing_list(dev);
-
-	/* Move everything out of the GPU domains to ensure we do any
-	 * necessary invalidation upon reuse.
-	 */
-	i915_gem_reset_inactive_gpu_domains(dev);
+	i915_gem_reset_lists(dev);
 
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as

commit 6eecba33f2fc24544073631dc1b23b7a312e644b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 8 09:45:11 2010 +0100

    drm/i915: Disable output polling across suspend & resume
    
    Suspending (especially hibernating) may take a finite amount of time,
    during which a hotplug event may trigger and we will attempt to handle
    it with inconsistent state. Disable hotplug polling around suspend and
    resume.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=30070
    Reported-by: Rui Tiago Matos <tiagomatos@gmail.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2c87f9b97b6f..4e83bb36888e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -281,6 +281,8 @@ int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (state.event == PM_EVENT_PRETHAW)
 		return 0;
 
+	drm_kms_helper_poll_disable(dev);
+
 	error = i915_drm_freeze(dev);
 	if (error)
 		return error;
@@ -325,12 +327,19 @@ static int i915_drm_thaw(struct drm_device *dev)
 
 int i915_resume(struct drm_device *dev)
 {
+	int ret;
+
 	if (pci_enable_device(dev->pdev))
 		return -EIO;
 
 	pci_set_master(dev->pdev);
 
-	return i915_drm_thaw(dev);
+	ret = i915_drm_thaw(dev);
+	if (ret)
+		return ret;
+
+	drm_kms_helper_poll_enable(dev);
+	return 0;
 }
 
 static int i965_reset_complete(struct drm_device *dev)

commit 881f47b64723f4d697084533491a489e3e74b10f
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Sun Sep 19 14:40:43 2010 +0100

    drm/i915: add a new BSD ring buffer for Sandybridge
    
    This ring buffer is used for video decoding/encoding on Sandybridge.
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 393696cee86d..2c87f9b97b6f 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -157,11 +157,13 @@ static const struct intel_device_info intel_ironlake_m_info = {
 static const struct intel_device_info intel_sandybridge_d_info = {
 	.gen = 6,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
 	.gen = 6, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit 92f49d9cec0052e09d938ac913d8e9ab432a0584
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Thu Sep 16 10:43:10 2010 +0800

    drm/i915: fix HAS_BSD with a device info flag
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2ddac06d5967..393696cee86d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -125,6 +125,7 @@ static const struct intel_device_info intel_g33_info = {
 static const struct intel_device_info intel_g45_info = {
 	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_gm45_info = {
@@ -132,6 +133,7 @@ static const struct intel_device_info intel_gm45_info = {
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 	.supports_tv = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_pineview_info = {
@@ -143,11 +145,13 @@ static const struct intel_device_info intel_pineview_info = {
 static const struct intel_device_info intel_ironlake_d_info = {
 	.gen = 5, .is_ironlake = 1,
 	.need_gfx_hws = 1, .has_pipe_cxsr = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_ironlake = 1, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.has_bsd_ring = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {

commit f803aa5532d14efc463abbeae10faa115c457a07
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Sep 19 12:38:26 2010 +0100

    drm/i915: Clean up bo lists on all hung gpus
    
    Previously we only tidied up the active bo lists for chipsets were we
    would attempt to reset the GPU. However, this action is necessary for
    the system to continue and reclaim the dead bo for all chipsets.
    
    Pointed out, in passing, by Owain Ainsworth.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 38e889bfd99c..2ddac06d5967 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -368,7 +368,7 @@ static int ironlake_do_reset(struct drm_device *dev, u8 flags)
  *   - re-init interrupt state
  *   - re-init display
  */
-int i965_reset(struct drm_device *dev, u8 flags)
+int i915_reset(struct drm_device *dev, u8 flags)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	/*
@@ -401,14 +401,19 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit
 	 * triggers the reset; when done, the hardware will clear it.
 	 */
-	if (IS_IRONLAKE(dev))
+	ret = -ENODEV;
+	switch (INTEL_INFO(dev)->gen) {
+	case 5:
 		ret = ironlake_do_reset(dev, flags);
-	else
+		break;
+	case 4:
 		ret = i965_do_reset(dev, flags);
+		break;
+	}
 	if (ret) {
-		WARN(true, "i915: Failed to reset chip\n");
+		DRM_ERROR("Failed to reset chip.\n");
 		mutex_unlock(&dev->struct_mutex);
-		return -EIO;
+		return ret;
 	}
 
 	/* Ok, now get things going again... */

commit 77f01230223a08792f5320ebba27af9cbb81b0cf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Sep 19 12:31:36 2010 +0100

    drm/i915: Clear GPU read domains on reset
    
    Clear the GPU read domain for the inactive objects on a reset so that
    they are correctly invalidated on reuse.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cb1ddc6af6a6..38e889bfd99c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -391,6 +391,11 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 */
 	i915_gem_reset_flushing_list(dev);
 
+	/* Move everything out of the GPU domains to ensure we do any
+	 * necessary invalidation upon reuse.
+	 */
+	i915_gem_reset_inactive_gpu_domains(dev);
+
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit

commit 9375e446e7f43be9a7c21e246cee35ea912532ec
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Sep 19 12:21:28 2010 +0100

    drm/i915: Clear flushing lists on GPU reset
    
    Owain Ainsworth noticed that the reset code failed to clear the flushing
    list leaving the driver in an inconsistent state following a hung GPU.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e58e91736f81..cb1ddc6af6a6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -385,6 +385,12 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 */
 	i915_gem_retire_requests(dev);
 
+	/* Remove anything from the flushing lists. The GPU cache is likely
+	 * to be lost on reset along with the data, so simply move the
+	 * lost bo to the inactive list.
+	 */
+	i915_gem_reset_flushing_list(dev);
+
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit

commit 9fd981413e005827e7363a37fd0b61f9d0928034
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Sep 18 08:08:06 2010 +0100

    drm/i915: After a reset perform a forced modeset
    
    On more recent chipsets, restoring the display is not as simple as
    writing a few registers, so force a full modeset of the current
    configuration in order to retrain the display link.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e88aabdfd1d9..e58e91736f81 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -385,9 +385,6 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 */
 	i915_gem_retire_requests(dev);
 
-	if (need_display)
-		i915_save_display(dev);
-
 	/*
 	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit
@@ -428,13 +425,19 @@ int i965_reset(struct drm_device *dev, u8 flags)
 		mutex_lock(&dev->struct_mutex);
 	}
 
+	mutex_unlock(&dev->struct_mutex);
+
 	/*
-	 * Display needs restore too...
+	 * Perform a full modeset as on later generations, e.g. Ironlake, we may
+	 * need to retrain the display link and cannot just restore the register
+	 * values.
 	 */
-	if (need_display)
-		i915_restore_display(dev);
+	if (need_display) {
+		mutex_lock(&dev->mode_config.mutex);
+		drm_helper_resume_force_mode(dev);
+		mutex_unlock(&dev->mode_config.mutex);
+	}
 
-	mutex_unlock(&dev->struct_mutex);
 	return 0;
 }
 

commit 0573ed4a947d7a563db197511611d8a9039feb41
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Sat Sep 11 03:17:19 2010 -0700

    drm/i915: Add support for GPU soft reset on Ironlake.
    
    Ironlake's graphics reset register has to be accessed via the MCHBAR,
    rather than via PCI config space, which requires some refactoring.
    
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 45027d5ad1e5..e88aabdfd1d9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -334,6 +334,24 @@ static int i965_reset_complete(struct drm_device *dev)
 	return gdrst & 0x1;
 }
 
+static int i965_do_reset(struct drm_device *dev, u8 flags)
+{
+	u8 gdrst;
+
+	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
+	pci_write_config_byte(dev->pdev, I965_GDRST, gdrst | flags | 0x1);
+
+	return wait_for(i965_reset_complete(dev), 500);
+}
+
+static int ironlake_do_reset(struct drm_device *dev, u8 flags)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	u32 gdrst = I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR);
+	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR, gdrst | flags | 0x1);
+	return wait_for(I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & 0x1, 500);
+}
+
 /**
  * i965_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -353,12 +371,12 @@ static int i965_reset_complete(struct drm_device *dev)
 int i965_reset(struct drm_device *dev, u8 flags)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-	u8 gdrst;
 	/*
 	 * We really should only reset the display subsystem if we actually
 	 * need to
 	 */
 	bool need_display = true;
+	int ret;
 
 	mutex_lock(&dev->struct_mutex);
 
@@ -375,11 +393,11 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit
 	 * triggers the reset; when done, the hardware will clear it.
 	 */
-	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
-	pci_write_config_byte(dev->pdev, I965_GDRST, gdrst | flags | 0x1);
-
-	/* Wait for the hardware to reset (but no more than 500 ms) */
-	if (wait_for(i965_reset_complete(dev), 500)) {
+	if (IS_IRONLAKE(dev))
+		ret = ironlake_do_reset(dev, flags);
+	else
+		ret = i965_do_reset(dev, flags);
+	if (ret) {
 		WARN(true, "i915: Failed to reset chip\n");
 		mutex_unlock(&dev->struct_mutex);
 		return -EIO;

commit eeccdcac07c1e21d25e7d3cf70030059a3017f0c
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Sat Sep 11 01:24:50 2010 -0700

    drm/i915: Rename graphics reset registers.
    
    The graphics domains are listed as GRDOM in the documentation, and the
    GDRST PCI config register (0xc0) is only valid on I965 and GM45.  Newer
    chips (like Sandy Bridge) have a different GDRST.
    
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7209997f18fe..45027d5ad1e5 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -330,7 +330,7 @@ int i915_resume(struct drm_device *dev)
 static int i965_reset_complete(struct drm_device *dev)
 {
 	u8 gdrst;
-	pci_read_config_byte(dev->pdev, GDRST, &gdrst);
+	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
 	return gdrst & 0x1;
 }
 
@@ -375,8 +375,8 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 * well as the reset bit (GR/bit 0).  Setting the GR bit
 	 * triggers the reset; when done, the hardware will clear it.
 	 */
-	pci_read_config_byte(dev->pdev, GDRST, &gdrst);
-	pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | 0x1);
+	pci_read_config_byte(dev->pdev, I965_GDRST, &gdrst);
+	pci_write_config_byte(dev->pdev, I965_GDRST, gdrst | flags | 0x1);
 
 	/* Wait for the hardware to reset (but no more than 500 ms) */
 	if (wait_for(i965_reset_complete(dev), 500)) {

commit f49f0586191fe16140410db0a46d43bdc690d6af
Author: Kenneth Graunke <kenneth@whitecape.org>
Date:   Sat Sep 11 01:19:14 2010 -0700

    drm/i915: Actually set the reset bit in i965_reset.
    
    Previously, it was only being set if passed GDRST_FULL - but the only
    caller passed GDRST_RENDER.  So the hardware never actually reset.
    The comments also did not match the code.
    
    Instead, just set the reset bit regardless of what flags were passed.
    The GPU now resets correctly on my GM45.
    
    Signed-off-by: Kenneth Graunke <kenneth@whitecape.org>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 87c6b5f81fea..7209997f18fe 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -32,6 +32,7 @@
 #include "drm.h"
 #include "i915_drm.h"
 #include "i915_drv.h"
+#include "intel_drv.h"
 
 #include <linux/console.h>
 #include "drm_crtc_helper.h"
@@ -326,6 +327,13 @@ int i915_resume(struct drm_device *dev)
 	return i915_drm_thaw(dev);
 }
 
+static int i965_reset_complete(struct drm_device *dev)
+{
+	u8 gdrst;
+	pci_read_config_byte(dev->pdev, GDRST, &gdrst);
+	return gdrst & 0x1;
+}
+
 /**
  * i965_reset - reset chip after a hang
  * @dev: drm device to reset
@@ -345,7 +353,6 @@ int i915_resume(struct drm_device *dev)
 int i965_reset(struct drm_device *dev, u8 flags)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-	unsigned long timeout;
 	u8 gdrst;
 	/*
 	 * We really should only reset the display subsystem if we actually
@@ -364,23 +371,15 @@ int i965_reset(struct drm_device *dev, u8 flags)
 		i915_save_display(dev);
 
 	/*
-	 * Set the domains we want to reset, then the reset bit (bit 0).
-	 * Clear the reset bit after a while and wait for hardware status
-	 * bit (bit 1) to be set
+	 * Set the domains we want to reset (GRDOM/bits 2 and 3) as
+	 * well as the reset bit (GR/bit 0).  Setting the GR bit
+	 * triggers the reset; when done, the hardware will clear it.
 	 */
 	pci_read_config_byte(dev->pdev, GDRST, &gdrst);
-	pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | ((flags == GDRST_FULL) ? 0x1 : 0x0));
-	udelay(50);
-	pci_write_config_byte(dev->pdev, GDRST, gdrst & 0xfe);
-
-	/* ...we don't want to loop forever though, 500ms should be plenty */
-       timeout = jiffies + msecs_to_jiffies(500);
-	do {
-		udelay(100);
-		pci_read_config_byte(dev->pdev, GDRST, &gdrst);
-	} while ((gdrst & 0x1) && time_after(timeout, jiffies));
-
-	if (gdrst & 0x1) {
+	pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | 0x1);
+
+	/* Wait for the hardware to reset (but no more than 500 ms) */
+	if (wait_for(i965_reset_complete(dev), 500)) {
 		WARN(true, "i915: Failed to reset chip\n");
 		mutex_unlock(&dev->struct_mutex);
 		return -EIO;

commit a6c45cf013a57e32ddae43dd4ac911eb4a3919fd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 17 00:32:17 2010 +0100

    drm/i915: INTEL_INFO->gen supercedes i8xx, i9xx, i965g
    
    Avoid confusion between i965g meaning broadwater and the gen4+ chipset
    families.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 13dca9da6507..87c6b5f81fea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,97 +61,101 @@ extern int intel_agp_enabled;
 	.driver_data = (unsigned long) info }
 
 static const struct intel_device_info intel_i830_info = {
-	.gen = 2, .is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
+	.gen = 2, .is_mobile = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_845g_info = {
-	.gen = 2, .is_i8xx = 1,
+	.gen = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i85x_info = {
-	.gen = 2, .is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
+	.gen = 2, .is_i85x = 1, .is_mobile = 1,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i865g_info = {
-	.gen = 2, .is_i8xx = 1,
+	.gen = 2,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i915g_info = {
-	.gen = 3, .is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
+	.gen = 3, .is_i915g = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i915gm_info = {
-	.gen = 3, .is_i9xx = 1,  .is_mobile = 1,
+	.gen = 3, .is_mobile = 1,
 	.cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.supports_tv = 1,
 };
 static const struct intel_device_info intel_i945g_info = {
-	.gen = 3, .is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
+	.gen = 3, .has_hotplug = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945gm_info = {
-	.gen = 3, .is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
+	.gen = 3, .is_i945gm = 1, .is_mobile = 1,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 	.has_overlay = 1, .overlay_needs_physical = 1,
+	.supports_tv = 1,
 };
 
 static const struct intel_device_info intel_i965g_info = {
-	.gen = 4, .is_broadwater = 1, .is_i965g = 1, .is_i9xx = 1,
+	.gen = 4, .is_broadwater = 1,
 	.has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
-	.gen = 4, .is_crestline = 1, .is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
+	.gen = 4, .is_crestline = 1,
 	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
 	.has_overlay = 1,
+	.supports_tv = 1,
 };
 
 static const struct intel_device_info intel_g33_info = {
-	.gen = 3, .is_g33 = 1, .is_i9xx = 1,
+	.gen = 3, .is_g33 = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_g45_info = {
-	.gen = 4, .is_i965g = 1, .is_g4x = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.gen = 4, .is_g4x = 1, .need_gfx_hws = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_gm45_info = {
-	.gen = 4, .is_i965g = 1, .is_g4x = 1, .is_i9xx = 1,
+	.gen = 4, .is_g4x = 1,
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_pipe_cxsr = 1, .has_hotplug = 1,
+	.supports_tv = 1,
 };
 
 static const struct intel_device_info intel_pineview_info = {
-	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
+	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
-	.gen = 5, .is_ironlake = 1, .is_i965g = 1, .is_i9xx = 1,
+	.gen = 5, .is_ironlake = 1,
 	.need_gfx_hws = 1, .has_pipe_cxsr = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
-	.gen = 5, .is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
+	.gen = 5, .is_ironlake = 1, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
-	.gen = 6, .is_i965g = 1, .is_i9xx = 1,
+	.gen = 6,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
-	.gen = 6, .is_i965g = 1, .is_mobile = 1, .is_i9xx = 1,
+	.gen = 6, .is_mobile = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
@@ -359,33 +363,27 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	if (need_display)
 		i915_save_display(dev);
 
-	if (IS_I965G(dev) || IS_G4X(dev)) {
-		/*
-		 * Set the domains we want to reset, then the reset bit (bit 0).
-		 * Clear the reset bit after a while and wait for hardware status
-		 * bit (bit 1) to be set
-		 */
+	/*
+	 * Set the domains we want to reset, then the reset bit (bit 0).
+	 * Clear the reset bit after a while and wait for hardware status
+	 * bit (bit 1) to be set
+	 */
+	pci_read_config_byte(dev->pdev, GDRST, &gdrst);
+	pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | ((flags == GDRST_FULL) ? 0x1 : 0x0));
+	udelay(50);
+	pci_write_config_byte(dev->pdev, GDRST, gdrst & 0xfe);
+
+	/* ...we don't want to loop forever though, 500ms should be plenty */
+       timeout = jiffies + msecs_to_jiffies(500);
+	do {
+		udelay(100);
 		pci_read_config_byte(dev->pdev, GDRST, &gdrst);
-		pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | ((flags == GDRST_FULL) ? 0x1 : 0x0));
-		udelay(50);
-		pci_write_config_byte(dev->pdev, GDRST, gdrst & 0xfe);
-
-		/* ...we don't want to loop forever though, 500ms should be plenty */
-	       timeout = jiffies + msecs_to_jiffies(500);
-		do {
-			udelay(100);
-			pci_read_config_byte(dev->pdev, GDRST, &gdrst);
-		} while ((gdrst & 0x1) && time_after(timeout, jiffies));
-
-		if (gdrst & 0x1) {
-			WARN(true, "i915: Failed to reset chip\n");
-			mutex_unlock(&dev->struct_mutex);
-			return -EIO;
-		}
-	} else {
-		DRM_ERROR("Error occurred. Don't know how to reset this chip.\n");
+	} while ((gdrst & 0x1) && time_after(timeout, jiffies));
+
+	if (gdrst & 0x1) {
+		WARN(true, "i915: Failed to reset chip\n");
 		mutex_unlock(&dev->struct_mutex);
-		return -ENODEV;
+		return -EIO;
 	}
 
 	/* Ok, now get things going again... */

commit e9e5f8e8d373e72f5c39dafde1ce110fc7082118
Merge: f899fc64cda8 db8c076b9206
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Sep 21 11:19:32 2010 +0100

    Merge branch 'drm-intel-fixes' into HEAD
    
    Conflicts:
            drivers/char/agp/intel-agp.c
            drivers/gpu/drm/i915/intel_crt.c

commit 41a51428916ab04587bacee2dda61c4a0c4fc02f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 17 08:22:30 2010 +0100

    drm/i915,agp/intel: Add second set of PCI-IDs for B43
    
    There is a second revision of B43 (a desktop gen4 part) floating around,
    functionally equivalent to the original B43, so simply add the new
    PCI-IDs.
    
    Bugzilla: https://bugs.freedesktop.org/show_bugs.cgi?id=30221
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 216deb579785..6dbe14cc4f74 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -170,6 +170,7 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x2e22, &intel_g45_info),		/* G45_G */
 	INTEL_VGA_DEVICE(0x2e32, &intel_g45_info),		/* G41_G */
 	INTEL_VGA_DEVICE(0x2e42, &intel_g45_info),		/* B43_G */
+	INTEL_VGA_DEVICE(0x2e92, &intel_g45_info),		/* B43_G.1 */
 	INTEL_VGA_DEVICE(0xa001, &intel_pineview_info),
 	INTEL_VGA_DEVICE(0xa011, &intel_pineview_info),
 	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),

commit dc880abef75e7c62c9048171f5112500f36a9244
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 6 18:54:47 2010 +0200

    drm: use noop_llseek
    
    The drm device drivers currently allow seeking on the
    character device but never care about the actual
    file position.
    
    When we change the default llseek operation to be
    no_llseek, calling llseek on a drm device would
    return an error condition, which is an API change.
    
    Explicitly setting noop_llseek lets us keep the
    current API.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 216deb579785..a6fdb481500c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -547,6 +547,7 @@ static struct drm_driver driver = {
 #ifdef CONFIG_COMPAT
 		 .compat_ioctl = i915_compat_ioctl,
 #endif
+		 .llseek = noop_llseek,
 	},
 
 	.pci_driver = {

commit 31578148b2c62612f9516fdcf5ebb64ab32ed12d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 12 09:42:51 2010 +0100

    drm/i915/overlay: Move capabilities bits to common info block.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2879a768d65c..dffc1bcf7b79 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -62,49 +62,60 @@ extern int intel_agp_enabled;
 
 static const struct intel_device_info intel_i830_info = {
 	.gen = 2, .is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_845g_info = {
 	.gen = 2, .is_i8xx = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i85x_info = {
 	.gen = 2, .is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
 	.cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i865g_info = {
 	.gen = 2, .is_i8xx = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i915g_info = {
 	.gen = 3, .is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i915gm_info = {
 	.gen = 3, .is_i9xx = 1,  .is_mobile = 1,
 	.cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945g_info = {
 	.gen = 3, .is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945gm_info = {
 	.gen = 3, .is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
+	.has_overlay = 1, .overlay_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i965g_info = {
 	.gen = 4, .is_broadwater = 1, .is_i965g = 1, .is_i9xx = 1,
 	.has_hotplug = 1,
+	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
 	.gen = 4, .is_crestline = 1, .is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
 	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_g33_info = {
 	.gen = 3, .is_g33 = 1, .is_i9xx = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_g45_info = {
@@ -121,6 +132,7 @@ static const struct intel_device_info intel_gm45_info = {
 static const struct intel_device_info intel_pineview_info = {
 	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
 	.need_gfx_hws = 1, .has_hotplug = 1,
+	.has_overlay = 1,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {

commit 44834a67c0082e2cf74b16be91e49108b1432d65
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 19 16:09:23 2010 +0100

    drm/i915: Use the VBT from OpRegion when available (v3)
    
    It is recommended that we use the Video BIOS tables that were copied
    into the OpRegion during POST when initialising the driver. This saves
    us from having to furtle around inside the ROM ourselves and possibly
    allows the vBIOS to adjust the tables prior to initialisation.
    
    On some systems, such as the Samsung N210, there is no accessible VBIOS
    and the only means of finding the VBT is through the OpRegion.
    
    v2: Rearrange the code so that ASLE is enabled along with ACPI
    v3: Enable OpRegion parsing even without ACPI
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ba75255ec450..2879a768d65c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -236,7 +236,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	i915_save_state(dev);
 
-	intel_opregion_free(dev, 1);
+	intel_opregion_fini(dev);
 
 	/* Modeset on resume, not lid events */
 	dev_priv->modeset_on_lid = 0;
@@ -276,8 +276,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 	int error = 0;
 
 	i915_restore_state(dev);
-
-	intel_opregion_init(dev, 1);
+	intel_opregion_setup(dev);
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
@@ -293,6 +292,8 @@ static int i915_drm_thaw(struct drm_device *dev)
 		drm_helper_resume_force_mode(dev);
 	}
 
+	intel_opregion_init(dev);
+
 	dev_priv->modeset_on_lid = 0;
 
 	return error;

commit b970be7c4114173e733309eec092a0269e1e6a61
Merge: c3add4b63438 cbc60ca04b34
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 8 10:13:14 2010 +0100

    Merge remote branch 'airlied/drm-core-next' into HEAD

commit 8554048070906579ec9fa19ac381deddd2d7b155
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Sep 7 13:45:32 2010 +0800

    intel_agp,i915: Add more sandybridge graphics device ids
    
    New pci ids for GT2 and GT2+ on desktop and mobile sandybridge,
    and graphics device ids for server sandybridge. Also rename original
    ids string to reflect GT1 version.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5363985673a4..216deb579785 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -175,8 +175,12 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),
 	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
 	INTEL_VGA_DEVICE(0x0102, &intel_sandybridge_d_info),
+	INTEL_VGA_DEVICE(0x0112, &intel_sandybridge_d_info),
+	INTEL_VGA_DEVICE(0x0122, &intel_sandybridge_d_info),
 	INTEL_VGA_DEVICE(0x0106, &intel_sandybridge_m_info),
+	INTEL_VGA_DEVICE(0x0116, &intel_sandybridge_m_info),
 	INTEL_VGA_DEVICE(0x0126, &intel_sandybridge_m_info),
+	INTEL_VGA_DEVICE(0x010A, &intel_sandybridge_d_info),
 	{0, 0, 0}
 };
 

commit c96c3a8cb7fadcb33d9a5ebe35fcee8b7d0a7946
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 11 09:59:24 2010 +0100

    drm/i915: Include a generation number in the device info
    
    To simplify the IS_GEN[234] macros and to enable switching.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 00befce8fbb7..5363985673a4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -61,91 +61,86 @@ extern int intel_agp_enabled;
 	.driver_data = (unsigned long) info }
 
 static const struct intel_device_info intel_i830_info = {
-	.is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
+	.gen = 2, .is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_845g_info = {
-	.is_i8xx = 1,
+	.gen = 2, .is_i8xx = 1,
 };
 
 static const struct intel_device_info intel_i85x_info = {
-	.is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
+	.gen = 2, .is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
 	.cursor_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i865g_info = {
-	.is_i8xx = 1,
+	.gen = 2, .is_i8xx = 1,
 };
 
 static const struct intel_device_info intel_i915g_info = {
-	.is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
+	.gen = 3, .is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
 };
 static const struct intel_device_info intel_i915gm_info = {
-	.is_i9xx = 1,  .is_mobile = 1,
+	.gen = 3, .is_i9xx = 1,  .is_mobile = 1,
 	.cursor_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945g_info = {
-	.is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
+	.gen = 3, .is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
 };
 static const struct intel_device_info intel_i945gm_info = {
-	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
+	.gen = 3, .is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 };
 
 static const struct intel_device_info intel_i965g_info = {
-	.is_broadwater = 1, .is_i965g = 1, .is_i9xx = 1, .has_hotplug = 1,
+	.gen = 4, .is_broadwater = 1, .is_i965g = 1, .is_i9xx = 1,
+	.has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
-	.is_crestline = 1, .is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
-	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1,
-	.has_hotplug = 1,
+	.gen = 4, .is_crestline = 1, .is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
+	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_g33_info = {
-	.is_g33 = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_hotplug = 1,
+	.gen = 3, .is_g33 = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_g45_info = {
-	.is_i965g = 1, .is_g4x = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_pipe_cxsr = 1,
-	.has_hotplug = 1,
+	.gen = 4, .is_i965g = 1, .is_g4x = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_pipe_cxsr = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_gm45_info = {
-	.is_i965g = 1, .is_g4x = 1, .is_i9xx = 1,
+	.gen = 4, .is_i965g = 1, .is_g4x = 1, .is_i9xx = 1,
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
-	.has_pipe_cxsr = 1,
-	.has_hotplug = 1,
+	.has_pipe_cxsr = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_pineview_info = {
-	.is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
-	.need_gfx_hws = 1,
-	.has_hotplug = 1,
+	.gen = 3, .is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_ironlake_d_info = {
-	.is_ironlake = 1, .is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_pipe_cxsr = 1,
-	.has_hotplug = 1,
+	.gen = 5, .is_ironlake = 1, .is_i965g = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_pipe_cxsr = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_ironlake_m_info = {
-	.is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
-	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
-	.has_hotplug = 1,
+	.gen = 5, .is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_d_info = {
-	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_hotplug = 1, .is_gen6 = 1,
+	.gen = 6, .is_i965g = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_sandybridge_m_info = {
-	.is_i965g = 1, .is_mobile = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_hotplug = 1, .is_gen6 = 1,
+	.gen = 6, .is_i965g = 1, .is_mobile = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_hotplug = 1,
 };
 
 static const struct pci_device_id pciidlist[] = {		/* aka */

commit cbc60ca04b342a4e1f2a1086a7277c077f07dbed
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 23 22:53:28 2010 +0200

    drm: kill get_reg_ofs callback
    
    Every driver used the default implementation. Fold that one into
    the only callsite and drop the callback.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d079f7b86cca..e6afa68775b0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -524,7 +524,6 @@ static struct drm_driver driver = {
 	.irq_uninstall = i915_driver_irq_uninstall,
 	.irq_handler = i915_driver_irq_handler,
 	.reclaim_buffers = drm_core_reclaim_buffers,
-	.get_reg_ofs = drm_core_get_reg_ofs,
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,
 #if defined(CONFIG_DEBUG_FS)

commit 793a97e4cc38f834e0488ccc1ecbfe52ff6f5b84
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 23 22:53:27 2010 +0200

    drm: kill drm_map_ofs callbacks
    
    All drivers happily copy&pasted the default implementation without
    checking whether this callback is used at all. It's not. Sigh.
    
    Kill it.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 00befce8fbb7..d079f7b86cca 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -524,7 +524,6 @@ static struct drm_driver driver = {
 	.irq_uninstall = i915_driver_irq_uninstall,
 	.irq_handler = i915_driver_irq_handler,
 	.reclaim_buffers = drm_core_reclaim_buffers,
-	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,

commit 4fefe435626758b14e6c05d2a5f8d71a997c0ad6
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Thu Aug 19 09:46:16 2010 +0800

    drm/i915,intel_agp: Add support for Sandybridge D0
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5044f653e8ea..00befce8fbb7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -181,6 +181,7 @@ static const struct pci_device_id pciidlist[] = {		/* aka */
 	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
 	INTEL_VGA_DEVICE(0x0102, &intel_sandybridge_d_info),
 	INTEL_VGA_DEVICE(0x0106, &intel_sandybridge_m_info),
+	INTEL_VGA_DEVICE(0x0126, &intel_sandybridge_m_info),
 	{0, 0, 0}
 };
 

commit b09a1feca65764311f8a3e14befb52b98d705f0a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 23 23:18:49 2010 +0100

    drm/i915: Refactor i915_gem_retire_requests()
    
    Combine the iteration over active render rings into a common function.
    This is in preparation for reusing the idle function to also retire
    deferred free requests.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 119692f3ce9d..5044f653e8ea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -340,7 +340,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	/*
 	 * Clear request list
 	 */
-	i915_gem_retire_requests(dev, &dev_priv->render_ring);
+	i915_gem_retire_requests(dev);
 
 	if (need_display)
 		i915_save_display(dev);

commit 6103da0d03d5f185070be50a0cb8813f6bf30dc1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 5 18:01:47 2010 +0100

    drm/i915: Include any alternate names by which the device is known.
    
    When trying to keep track of features between the kernel, the 2D driver,
    mesa and the specs, it helps to list any other name by which the device
    is referred to.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ca740d9170a3..119692f3ce9d 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -148,33 +148,33 @@ static const struct intel_device_info intel_sandybridge_m_info = {
 	.has_hotplug = 1, .is_gen6 = 1,
 };
 
-static const struct pci_device_id pciidlist[] = {
-	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
-	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
-	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),
+static const struct pci_device_id pciidlist[] = {		/* aka */
+	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),		/* I830_M */
+	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),		/* 845_G */
+	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),		/* I855_GM */
 	INTEL_VGA_DEVICE(0x358e, &intel_i85x_info),
-	INTEL_VGA_DEVICE(0x2572, &intel_i865g_info),
-	INTEL_VGA_DEVICE(0x2582, &intel_i915g_info),
-	INTEL_VGA_DEVICE(0x258a, &intel_i915g_info),
-	INTEL_VGA_DEVICE(0x2592, &intel_i915gm_info),
-	INTEL_VGA_DEVICE(0x2772, &intel_i945g_info),
-	INTEL_VGA_DEVICE(0x27a2, &intel_i945gm_info),
-	INTEL_VGA_DEVICE(0x27ae, &intel_i945gm_info),
-	INTEL_VGA_DEVICE(0x2972, &intel_i965g_info),
-	INTEL_VGA_DEVICE(0x2982, &intel_i965g_info),
-	INTEL_VGA_DEVICE(0x2992, &intel_i965g_info),
-	INTEL_VGA_DEVICE(0x29a2, &intel_i965g_info),
-	INTEL_VGA_DEVICE(0x29b2, &intel_g33_info),
-	INTEL_VGA_DEVICE(0x29c2, &intel_g33_info),
-	INTEL_VGA_DEVICE(0x29d2, &intel_g33_info),
-	INTEL_VGA_DEVICE(0x2a02, &intel_i965gm_info),
-	INTEL_VGA_DEVICE(0x2a12, &intel_i965gm_info),
-	INTEL_VGA_DEVICE(0x2a42, &intel_gm45_info),
-	INTEL_VGA_DEVICE(0x2e02, &intel_g45_info),
-	INTEL_VGA_DEVICE(0x2e12, &intel_g45_info),
-	INTEL_VGA_DEVICE(0x2e22, &intel_g45_info),
-	INTEL_VGA_DEVICE(0x2e32, &intel_g45_info),
-	INTEL_VGA_DEVICE(0x2e42, &intel_g45_info),
+	INTEL_VGA_DEVICE(0x2572, &intel_i865g_info),		/* I865_G */
+	INTEL_VGA_DEVICE(0x2582, &intel_i915g_info),		/* I915_G */
+	INTEL_VGA_DEVICE(0x258a, &intel_i915g_info),		/* E7221_G */
+	INTEL_VGA_DEVICE(0x2592, &intel_i915gm_info),		/* I915_GM */
+	INTEL_VGA_DEVICE(0x2772, &intel_i945g_info),		/* I945_G */
+	INTEL_VGA_DEVICE(0x27a2, &intel_i945gm_info),		/* I945_GM */
+	INTEL_VGA_DEVICE(0x27ae, &intel_i945gm_info),		/* I945_GME */
+	INTEL_VGA_DEVICE(0x2972, &intel_i965g_info),		/* I946_GZ */
+	INTEL_VGA_DEVICE(0x2982, &intel_i965g_info),		/* G35_G */
+	INTEL_VGA_DEVICE(0x2992, &intel_i965g_info),		/* I965_Q */
+	INTEL_VGA_DEVICE(0x29a2, &intel_i965g_info),		/* I965_G */
+	INTEL_VGA_DEVICE(0x29b2, &intel_g33_info),		/* Q35_G */
+	INTEL_VGA_DEVICE(0x29c2, &intel_g33_info),		/* G33_G */
+	INTEL_VGA_DEVICE(0x29d2, &intel_g33_info),		/* Q33_G */
+	INTEL_VGA_DEVICE(0x2a02, &intel_i965gm_info),		/* I965_GM */
+	INTEL_VGA_DEVICE(0x2a12, &intel_i965gm_info),		/* I965_GME */
+	INTEL_VGA_DEVICE(0x2a42, &intel_gm45_info),		/* GM45_G */
+	INTEL_VGA_DEVICE(0x2e02, &intel_g45_info),		/* IGD_E_G */
+	INTEL_VGA_DEVICE(0x2e12, &intel_g45_info),		/* Q45_G */
+	INTEL_VGA_DEVICE(0x2e22, &intel_g45_info),		/* G45_G */
+	INTEL_VGA_DEVICE(0x2e32, &intel_g45_info),		/* G41_G */
+	INTEL_VGA_DEVICE(0x2e42, &intel_g45_info),		/* B43_G */
 	INTEL_VGA_DEVICE(0xa001, &intel_pineview_info),
 	INTEL_VGA_DEVICE(0xa011, &intel_pineview_info),
 	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),

commit 534843dabf79da40561148764916e1b2e6bbcebe
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 5 18:01:46 2010 +0100

    drm/i915: Use 128k alignment for untiled display surface on i965 (v2)
    
    The original i965, including the revised G35 and Q35, requires an
    alignment of 128K for the display surface with linear memory, so
    increase the requirement from 64k for these chipsets. For the later
    chipsets in the i965 family, only a 4k alignment is required. (So
    long as we do not start performing asynchronous flips.)
    
    Note the impact of this should be slight as on i965 we should be using a
    tiled frontbuffer for anything up to a 4096x4096 display.
    
    v2: compilation fixes and note that the docs do not exclude the G35 from
    the extra alignment.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 04d9d1f73d1b..ca740d9170a3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -93,11 +93,11 @@ static const struct intel_device_info intel_i945gm_info = {
 };
 
 static const struct intel_device_info intel_i965g_info = {
-	.is_i965g = 1, .is_i9xx = 1, .has_hotplug = 1,
+	.is_broadwater = 1, .is_i965g = 1, .is_i9xx = 1, .has_hotplug = 1,
 };
 
 static const struct intel_device_info intel_i965gm_info = {
-	.is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
+	.is_crestline = 1, .is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
 	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_hotplug = 1,
 };

commit b4b78d12d7c5108b9a71752b59dcc51b11cd9ea6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Jun 6 15:40:20 2010 +0100

    drm/i915: Silence sparse over non-static local structure.
    
    drivers/gpu/drm/i915/i915_drv.c|485 col 25| warning: symbol 'i915_pm_ops' was not declared. Should it be static?
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 39eaa3737220..04d9d1f73d1b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -482,7 +482,7 @@ static int i915_pm_poweroff(struct device *dev)
 	return i915_drm_freeze(drm_dev);
 }
 
-const struct dev_pm_ops i915_pm_ops = {
+static const struct dev_pm_ops i915_pm_ops = {
      .suspend = i915_pm_suspend,
      .resume = i915_pm_resume,
      .freeze = i915_pm_freeze,

commit 2d3fa0de689e1a53fdfc3db50732b62e58d0ca6b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sun Jun 6 15:40:19 2010 +0100

    drm/i915: Silence sparse over duplicate members in static initializer
    
    drivers/gpu/drm/i915/i915_drv.c|100 col 18| warning: Initializer entry defined twice
    drivers/gpu/drm/i915/i915_drv.c|101 col 3| also defined here
    drivers/gpu/drm/i915/i915_drv.c|117 col 18| warning: Initializer entry defined twice
    drivers/gpu/drm/i915/i915_drv.c|118 col 3| also defined here
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b5694d24b541..39eaa3737220 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -97,7 +97,7 @@ static const struct intel_device_info intel_i965g_info = {
 };
 
 static const struct intel_device_info intel_i965gm_info = {
-	.is_i965g = 1, .is_mobile = 1, .is_i965gm = 1, .is_i9xx = 1,
+	.is_i965g = 1, .is_i965gm = 1, .is_i9xx = 1,
 	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_hotplug = 1,
 };
@@ -114,7 +114,7 @@ static const struct intel_device_info intel_g45_info = {
 };
 
 static const struct intel_device_info intel_gm45_info = {
-	.is_i965g = 1, .is_mobile = 1, .is_g4x = 1, .is_i9xx = 1,
+	.is_i965g = 1, .is_g4x = 1, .is_i9xx = 1,
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_pipe_cxsr = 1,
 	.has_hotplug = 1,

commit b52eb4dcab23fe0c52a437276258e0afcf913ef5
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Sat Jun 12 14:32:27 2010 +0800

    drm/i915: Add frame buffer compression support on Ironlake mobile
    
    About 0.2W power can be saved on one HP laptop.
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 65d3f3e8475b..b5694d24b541 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -134,7 +134,7 @@ static const struct intel_device_info intel_ironlake_d_info = {
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
-	.need_gfx_hws = 1, .has_rc6 = 1,
+	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_hotplug = 1,
 };
 

commit db8cc27b804f89e8fd5f9d5385161956a777c471
Merge: 6dbe7465713f 05269a3a5a78
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jul 7 18:37:35 2010 +1000

    Merge branch 'drm-platform' into drm-testing
    
    * drm-platform:
      drm: Make sure the DRM offset matches the CPU
      drm: Add __arm defines to DRM
      drm: Add support for platform devices to register as DRM devices
      drm: Remove drm_resource wrappers

commit dcdb167402cbdca1d021bdfa5f63995ee0a79317
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Thu May 27 13:40:25 2010 -0600

    drm: Add support for platform devices to register as DRM devices
    
    Allow platform devices without PCI resources to be DRM devices.
    
    [airlied: fixup warnings with dev pointers]
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5c51e45ab68d..b7aecf5ea1fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -435,7 +435,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 static int __devinit
 i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	return drm_get_dev(pdev, ent, &driver);
+	return drm_get_pci_dev(pdev, ent, &driver);
 }
 
 static void

commit 9a7e8492d17394a81d5534abf90b5b2ada7ea3c0
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu May 20 10:33:46 2010 +0200

    drm/i915: Storage class should be before const qualifier
    
    The C99 specification states in section 6.11.5:
    
    The placement of a storage-class specifier other than at the beginning
    of the declaration specifiers in a declaration is an obsolescent
    feature.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c072b212979c..423dc90c1e20 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -60,95 +60,95 @@ extern int intel_agp_enabled;
 	.subdevice = PCI_ANY_ID,		\
 	.driver_data = (unsigned long) info }
 
-const static struct intel_device_info intel_i830_info = {
+static const struct intel_device_info intel_i830_info = {
 	.is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
 };
 
-const static struct intel_device_info intel_845g_info = {
+static const struct intel_device_info intel_845g_info = {
 	.is_i8xx = 1,
 };
 
-const static struct intel_device_info intel_i85x_info = {
+static const struct intel_device_info intel_i85x_info = {
 	.is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
 	.cursor_needs_physical = 1,
 };
 
-const static struct intel_device_info intel_i865g_info = {
+static const struct intel_device_info intel_i865g_info = {
 	.is_i8xx = 1,
 };
 
-const static struct intel_device_info intel_i915g_info = {
+static const struct intel_device_info intel_i915g_info = {
 	.is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
 };
-const static struct intel_device_info intel_i915gm_info = {
+static const struct intel_device_info intel_i915gm_info = {
 	.is_i9xx = 1,  .is_mobile = 1,
 	.cursor_needs_physical = 1,
 };
-const static struct intel_device_info intel_i945g_info = {
+static const struct intel_device_info intel_i945g_info = {
 	.is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
 };
-const static struct intel_device_info intel_i945gm_info = {
+static const struct intel_device_info intel_i945gm_info = {
 	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 };
 
-const static struct intel_device_info intel_i965g_info = {
+static const struct intel_device_info intel_i965g_info = {
 	.is_i965g = 1, .is_i9xx = 1, .has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_i965gm_info = {
+static const struct intel_device_info intel_i965gm_info = {
 	.is_i965g = 1, .is_mobile = 1, .is_i965gm = 1, .is_i9xx = 1,
 	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_g33_info = {
+static const struct intel_device_info intel_g33_info = {
 	.is_g33 = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_g45_info = {
+static const struct intel_device_info intel_g45_info = {
 	.is_i965g = 1, .is_g4x = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_pipe_cxsr = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_gm45_info = {
+static const struct intel_device_info intel_gm45_info = {
 	.is_i965g = 1, .is_mobile = 1, .is_g4x = 1, .is_i9xx = 1,
 	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
 	.has_pipe_cxsr = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_pineview_info = {
+static const struct intel_device_info intel_pineview_info = {
 	.is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
 	.need_gfx_hws = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_ironlake_d_info = {
+static const struct intel_device_info intel_ironlake_d_info = {
 	.is_ironlake = 1, .is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_pipe_cxsr = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_ironlake_m_info = {
+static const struct intel_device_info intel_ironlake_m_info = {
 	.is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
 	.need_gfx_hws = 1, .has_rc6 = 1,
 	.has_hotplug = 1,
 };
 
-const static struct intel_device_info intel_sandybridge_d_info = {
+static const struct intel_device_info intel_sandybridge_d_info = {
 	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_hotplug = 1, .is_gen6 = 1,
 };
 
-const static struct intel_device_info intel_sandybridge_m_info = {
+static const struct intel_device_info intel_sandybridge_m_info = {
 	.is_i965g = 1, .is_mobile = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_hotplug = 1, .is_gen6 = 1,
 };
 
-const static struct pci_device_id pciidlist[] = {
+static const struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
 	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),

commit f953c9353f5fe6e98fa7f32f51060a74d845b5f8
Author: Daniel J Blueman <daniel.blueman@gmail.com>
Date:   Mon May 17 14:23:52 2010 +0100

    i915: fix lock imbalance on error path...
    
    While investigating Intel i5 Arrandale GPU lockups with -rc4, I
    noticed a lock imbalance.
    
    Signed-off-by: Daniel J Blueman <daniel.blueman@gmail.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d40f62d36453..c072b212979c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -370,6 +370,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 		}
 	} else {
 		DRM_ERROR("Error occurred. Don't know how to reset this chip.\n");
+		mutex_unlock(&dev->struct_mutex);
 		return -ENODEV;
 	}
 

commit 852835f343146a82a528c3b712b373661d4fa17a
Author: Zou Nan hai <nanhai.zou@intel.com>
Date:   Fri May 21 09:08:56 2010 +0800

    drm/i915: convert some gem structures to per-ring V2
    
    The active list and request list move into the ringbuffer structure,
    so each can track its active objects in the order they are in that
    ring.  The flushing list does not, as it doesn't matter which ring
    caused data to end up in the render cache.  Objects gain a pointer to
    the ring they are active on (if any).
    
    Signed-off-by: Zou Nan hai <nanhai.zou@intel.com>
    Signed-off-by: Xiang Hai hao <haihao.xiang@intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c57c54f403da..d40f62d36453 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -340,7 +340,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	/*
 	 * Clear request list
 	 */
-	i915_gem_retire_requests(dev);
+	i915_gem_retire_requests(dev, &dev_priv->render_ring);
 
 	if (need_display)
 		i915_save_display(dev);

commit 8187a2b70e34c727a06617441f74f202b6fefaf9
Author: Zou Nan hai <nanhai.zou@intel.com>
Date:   Fri May 21 09:08:55 2010 +0800

    drm/i915: introduce intel_ring_buffer structure (V2)
    
    Introduces a more complete intel_ring_buffer structure with callbacks
    for setup and management of a particular ringbuffer, and converts the
    render ring buffer consumers to use it.
    
    Signed-off-by: Zou Nan hai <nanhai.zou@intel.com>
    Signed-off-by: Xiang Hai hao <haihao.xiang@intel.com>
    [anholt: Fixed up whitespace fail and rebased against prep patches]
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a1814f65fdb4..c57c54f403da 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -388,33 +388,10 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 * switched away).
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
-	    !dev_priv->mm.suspended) {
-		drm_i915_ring_buffer_t *ring = &dev_priv->render_ring;
-		struct drm_gem_object *obj = ring->ring_obj;
-		struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
+			!dev_priv->mm.suspended) {
+		struct intel_ring_buffer *ring = &dev_priv->render_ring;
 		dev_priv->mm.suspended = 0;
-
-		/* Stop the ring if it's running. */
-		I915_WRITE(PRB0_CTL, 0);
-		I915_WRITE(PRB0_TAIL, 0);
-		I915_WRITE(PRB0_HEAD, 0);
-
-		/* Initialize the ring. */
-		I915_WRITE(PRB0_START, obj_priv->gtt_offset);
-		I915_WRITE(PRB0_CTL,
-			   ((obj->size - 4096) & RING_NR_PAGES) |
-			   RING_NO_REPORT |
-			   RING_VALID);
-		if (!drm_core_check_feature(dev, DRIVER_MODESET))
-			i915_kernel_lost_context(dev);
-		else {
-			ring->head = I915_READ(PRB0_HEAD) & HEAD_ADDR;
-			ring->tail = I915_READ(PRB0_TAIL) & TAIL_ADDR;
-			ring->space = ring->head - (ring->tail + 8);
-			if (ring->space < 0)
-				ring->space += ring->Size;
-		}
-
+		ring->init(dev, ring);
 		mutex_unlock(&dev->struct_mutex);
 		drm_irq_uninstall(dev);
 		drm_irq_install(dev);

commit d3301d86b4bf2bcf649982ae464211d8bcf9575a
Author: Eric Anholt <eric@anholt.net>
Date:   Fri May 21 13:55:54 2010 -0700

    drm/i915: Rename dev_priv->ring to dev_priv->render_ring.
    
    With the advent of the BSD ring, be clear about which ring this is.
    The docs are pretty consistent with calling this the Render engine at
    this point.

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 5c51e45ab68d..a1814f65fdb4 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -389,7 +389,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	 */
 	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
 	    !dev_priv->mm.suspended) {
-		drm_i915_ring_buffer_t *ring = &dev_priv->ring;
+		drm_i915_ring_buffer_t *ring = &dev_priv->render_ring;
 		struct drm_gem_object *obj = ring->ring_obj;
 		struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
 		dev_priv->mm.suspended = 0;

commit 34dc4d4423dc342848d72be764832cbc0852854a
Merge: 3d8620cc5f85 722154e4cacf
Author: Eric Anholt <eric@anholt.net>
Date:   Fri May 7 14:30:03 2010 -0700

    Merge remote branch 'origin/master' into drm-intel-next
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/radeon/r300.c
    
    The BSD ringbuffer support that is landing in this branch
    significantly conflicts with the Ironlake PIPE_CONTROL fix on master,
    and requires it to be tested successfully anyway.

commit 5ce8ba7c9279a63f99e1f131602580472b8af968
Author: Adam Jackson <ajax@redhat.com>
Date:   Thu Apr 15 14:03:30 2010 -0400

    drm/i915: Fix 82854 PCI ID, and treat it like other 85X
    
    pci.ids and the datasheet both say it's 358e, not 35e8.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0af3dcc85ce9..cc03537bb883 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -69,7 +69,8 @@ const static struct intel_device_info intel_845g_info = {
 };
 
 const static struct intel_device_info intel_i85x_info = {
-	.is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
+	.is_i8xx = 1, .is_i85x = 1, .is_mobile = 1,
+	.cursor_needs_physical = 1,
 };
 
 const static struct intel_device_info intel_i865g_info = {
@@ -151,7 +152,7 @@ const static struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
 	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),
-	INTEL_VGA_DEVICE(0x35e8, &intel_i85x_info),
+	INTEL_VGA_DEVICE(0x358e, &intel_i85x_info),
 	INTEL_VGA_DEVICE(0x2572, &intel_i865g_info),
 	INTEL_VGA_DEVICE(0x2582, &intel_i915g_info),
 	INTEL_VGA_DEVICE(0x258a, &intel_i915g_info),

commit 3bad0781832e4e8c9a532f1169bfcd7257bcfd9e
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Wed Apr 7 16:15:53 2010 +0800

    drm/i915: Probe for PCH chipset type
    
    PCH is the new name for south bridge from Ironlake/Sandybridge,
    which contains most of the display outputs except eDP. This one
    adds a probe function to detect current PCH type, and method to
    detect Cougarpoint PCH.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0af3dcc85ce9..01e91ea5bdea 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -187,6 +187,35 @@ const static struct pci_device_id pciidlist[] = {
 MODULE_DEVICE_TABLE(pci, pciidlist);
 #endif
 
+#define INTEL_PCH_DEVICE_ID_MASK	0xff00
+#define INTEL_PCH_CPT_DEVICE_ID_TYPE	0x1c00
+
+void intel_detect_pch (struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct pci_dev *pch;
+
+	/*
+	 * The reason to probe ISA bridge instead of Dev31:Fun0 is to
+	 * make graphics device passthrough work easy for VMM, that only
+	 * need to expose ISA bridge to let driver know the real hardware
+	 * underneath. This is a requirement from virtualization team.
+	 */
+	pch = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL);
+	if (pch) {
+		if (pch->vendor == PCI_VENDOR_ID_INTEL) {
+			int id;
+			id = pch->device & INTEL_PCH_DEVICE_ID_MASK;
+
+			if (id == INTEL_PCH_CPT_DEVICE_ID_TYPE) {
+				dev_priv->pch_type = PCH_CPT;
+				DRM_DEBUG_KMS("Found CougarPoint PCH\n");
+			}
+		}
+		pci_dev_put(pch);
+	}
+}
+
 static int i915_drm_freeze(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;

commit 23010e43b353c2cdc9725cbedc7e364708039bf7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 8 13:35:02 2010 +0100

    drm/i915: introduce to_intel_bo helper
    
    This is a purely cosmetic change to make changes in this area easier.
    And hey, it's not only clearer and typechecked, but actually shorter,
    too!
    
    [anholt: To clarify, this is a change to let us later make
    drm_i915_gem_object subclass drm_gem_object, instead of having
    drm_gem_object have a pointer to i915's private data]
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1a39ec75d76b..0af3dcc85ce9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -361,7 +361,7 @@ int i965_reset(struct drm_device *dev, u8 flags)
 	    !dev_priv->mm.suspended) {
 		drm_i915_ring_buffer_t *ring = &dev_priv->ring;
 		struct drm_gem_object *obj = ring->ring_obj;
-		struct drm_i915_gem_object *obj_priv = obj->driver_private;
+		struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
 		dev_priv->mm.suspended = 0;
 
 		/* Stop the ring if it's running. */

commit 8d06a1e1e9c69244f08beb7d17146483f9dcd120
Author: Robert Hooker <sarvatt@ubuntu.com>
Date:   Fri Mar 19 15:13:27 2010 -0400

    drm/i915: Disable FBC on 915GM and 945GM.
    
    It is causing hangs after a suspend/resume cycle with the default
    powersave=1 module option on these chipsets since 2.6.32-rc.
    
    BugLink: http://bugs.launchpad.net/bugs/492392
    Signed-off-by: Robert Hooker <sarvatt@ubuntu.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 4b26919abdb2..1a39ec75d76b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -80,14 +80,14 @@ const static struct intel_device_info intel_i915g_info = {
 	.is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i915gm_info = {
-	.is_i9xx = 1,  .is_mobile = 1, .has_fbc = 1,
+	.is_i9xx = 1,  .is_mobile = 1,
 	.cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i945g_info = {
 	.is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i945gm_info = {
-	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1, .has_fbc = 1,
+	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1,
 	.has_hotplug = 1, .cursor_needs_physical = 1,
 };
 

commit 59f2d0fc4bdfbbfabfa3715ba17d0609e5964c7e
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Mar 9 23:37:07 2010 +0800

    drm/i915: Fix check with IS_GEN6
    
    IS_GEN6 missed to include SandyBridge mobile chip, which failed in
    i915_probe_agp() for memory config detection. Fix it with a device
    info flag.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b2e95455c05..4b26919abdb2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -139,12 +139,12 @@ const static struct intel_device_info intel_ironlake_m_info = {
 
 const static struct intel_device_info intel_sandybridge_d_info = {
 	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_hotplug = 1,
+	.has_hotplug = 1, .is_gen6 = 1,
 };
 
 const static struct intel_device_info intel_sandybridge_m_info = {
 	.is_i965g = 1, .is_mobile = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_hotplug = 1,
+	.has_hotplug = 1, .is_gen6 = 1,
 };
 
 const static struct pci_device_id pciidlist[] = {

commit 1c62233508ef7104f8a78e571fdf5c72d0dc0200
Merge: 6d9c13513661 6a9ee8af344e
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 1 16:22:38 2010 +1000

    Merge branch 'gpu-switcher' of /ssd/git//linux-2.6 into drm-next-stage
    
    * 'gpu-switcher' of /ssd/git//linux-2.6:
      vga_switcheroo: initial implementation (v15)
      fb: for framebuffer handover don't exit the loop early.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/radeon/Makefile
            drivers/gpu/drm/radeon/radeon.h

commit 6a9ee8af344e3bd7dbd61e67037096cdf7f83289
Author: Dave Airlie <airlied@linux.ie>
Date:   Mon Feb 1 15:38:10 2010 +1000

    vga_switcheroo: initial implementation (v15)
    
    Many new laptops now come with 2 gpus, one to be used for low power
    modes and one for gaming/on-ac applications. These GPUs are typically
    wired to the laptop panel and VGA ports via a multiplexer unit which
    is controlled via ACPI methods.
    
    4 combinations of systems typically exist - with 2 ACPI methods.
    Intel/ATI - Lenovo W500/T500 - use ATPX ACPI method
    ATI/ATI - some ASUS - use ATPX ACPI Method
    Intel/Nvidia - - use _DSM ACPI method
    Nvidia/Nvidia -  - use _DSM ACPI method.
    
    TODO:
    This patch adds support for the ATPX method and initial bits
    for the _DSM methods that need to written by someone with
    access to the hardware.
    Add a proper non-debugfs interface - need to get some proper
    testing first.
    
    v2: add power up/down support for both devices
    on W500 puts i915/radeon into D3 and cuts power to radeon.
    
    v3: redo probing methods, no DMI list, drm devices call to
    register with switcheroo, it tries to find an ATPX method on
    any device and once there is two devices + ATPX it inits the
    switcher.
    
    v4: ATPX msg handling using buffers - should work on more machines
    
    v5: rearchitect after more mjg59 discussion - move ATPX handling to
        radeon driver.
    
    v6: add file headers + initial nouveau bits (to be filled out).
    
    v7: merge delayed switcher code.
    
    v8: avoid suspend/resume of gpu that is off
    
    v9: rearchitect - mjg59 is always right. - move all ATPX code to
    radeon, should allow simpler DSM also proper ATRM handling
    
    v10: add ATRM support for radeon BIOS, add mutex to lock vgasr_priv
    
    v11: fix bug in resuming Intel for 2nd time.
    
    v12: start fixing up nvidia code blindly.
    
    v13: blindly guess at finishing nvidia code
    
    v14: remove radeon audio hacks - fix up intel resume more like upstream
    
    v15: clean up printks + remove unnecessary igd/dis pointers
    
    mount debugfs
    
    /sys/kernel/debug/vgaswitcheroo/switch - should exist if ATPX detected
     + 2 cards.
    
    DIS - immediate change to discrete
    IGD - immediate change to IGD
    DDIS - delayed change to discrete
    DIGD - delayed change to IGD
    ON - turn on not in use
    OFF - turn off not in use
    
    Tested on W500 (Intel/ATI) and T500 (Intel/ATI)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cf4cb3e9a0c2..fd739efe73ce 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -201,7 +201,7 @@ static int i915_drm_freeze(struct drm_device *dev)
 	return 0;
 }
 
-static int i915_suspend(struct drm_device *dev, pm_message_t state)
+int i915_suspend(struct drm_device *dev, pm_message_t state)
 {
 	int error;
 
@@ -255,7 +255,7 @@ static int i915_drm_thaw(struct drm_device *dev)
 	return error;
 }
 
-static int i915_resume(struct drm_device *dev)
+int i915_resume(struct drm_device *dev)
 {
 	if (pci_enable_device(dev->pdev))
 		return -EIO;

commit 1f7a6e372e9cb4d749f34c0738d832e6cadb4071
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Tue Feb 23 14:05:24 2010 +0800

    drm/i915: Add dependency on the intel agp module
    
    See http://bugzilla.kernel.org/show_bug.cgi?id=15021
    
    Make sure that the appropriate AGP module is loaded and probed before
    trying to set up the DRM.  The DRM already depends on the AGP core,
    but in this case we know the specific AGP driver we need too, and can
    help users avoid the trap of loading the AGP driver after the DRM
    driver.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2a9178bb2748..85ad020125c8 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -49,6 +49,7 @@ unsigned int i915_lvds_downclock = 0;
 module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
 
 static struct drm_driver driver;
+extern int intel_agp_enabled;
 
 #define INTEL_VGA_DEVICE(id, info) {		\
 	.class = PCI_CLASS_DISPLAY_VGA << 8,	\
@@ -558,6 +559,11 @@ static struct drm_driver driver = {
 
 static int __init i915_init(void)
 {
+	if (!intel_agp_enabled) {
+		DRM_ERROR("drm/i915 can't work without intel_agp module!\n");
+		return -ENODEV;
+	}
+
 	driver.num_ioctls = i915_max_ioctl;
 
 	i915_gem_shrinker_init();

commit faa7bde6cb1227d13d011042f17bda0869c3bd1e
Author: Eric Anholt <eric@anholt.net>
Date:   Thu Jan 28 16:13:29 2010 -0800

    drm/i915: Correct the Sandybridge chipset info structs.
    
    Disables CXSR until it's done, and sets the mobile bit on mobile.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 94e74a426ef9..2a9178bb2748 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -138,13 +138,11 @@ const static struct intel_device_info intel_ironlake_m_info = {
 
 const static struct intel_device_info intel_sandybridge_d_info = {
 	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_pipe_cxsr = 1,
 	.has_hotplug = 1,
 };
 
 const static struct intel_device_info intel_sandybridge_m_info = {
-	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
-	.has_pipe_cxsr = 1,
+	.is_i965g = 1, .is_mobile = 1, .is_i9xx = 1, .need_gfx_hws = 1,
 	.has_hotplug = 1,
 };
 

commit a13e4093cbd3db91cc65ac8b8c2baadffa603ee9
Author: Eric Anholt <eric@anholt.net>
Date:   Thu Jan 7 15:08:18 2010 -0800

    drm/i915: Add a new mobile Sandybridge PCI ID.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b57efca02901..94e74a426ef9 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -142,6 +142,12 @@ const static struct intel_device_info intel_sandybridge_d_info = {
 	.has_hotplug = 1,
 };
 
+const static struct intel_device_info intel_sandybridge_m_info = {
+	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
 const static struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
@@ -174,6 +180,7 @@ const static struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),
 	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
 	INTEL_VGA_DEVICE(0x0102, &intel_sandybridge_d_info),
+	INTEL_VGA_DEVICE(0x0106, &intel_sandybridge_m_info),
 	{0, 0, 0}
 };
 

commit f6e450a6417460db6a74241de8aaab5116cac140
Author: Eric Anholt <eric@anholt.net>
Date:   Mon Nov 2 12:08:22 2009 -0800

    drm/i915: Fix sandybridge status page setup.
    
    The register's moved to the same location as the one for the BCS, it seems.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 742bd8f738ca..b57efca02901 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -136,6 +136,12 @@ const static struct intel_device_info intel_ironlake_m_info = {
 	.has_hotplug = 1,
 };
 
+const static struct intel_device_info intel_sandybridge_d_info = {
+	.is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
 const static struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
 	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
@@ -167,6 +173,7 @@ const static struct pci_device_id pciidlist[] = {
 	INTEL_VGA_DEVICE(0xa011, &intel_pineview_info),
 	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),
 	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
+	INTEL_VGA_DEVICE(0x0102, &intel_sandybridge_d_info),
 	{0, 0, 0}
 };
 

commit 30d6c72c4a760cfc9069ee100786e4d6cf6de59d
Merge: de19322d554f 9df30794f609
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 25 13:39:36 2010 +1000

    Merge remote branch 'anholt/drm-intel-next' into drm-next-stage
    
    * anholt/drm-intel-next:
      drm/i915: Record batch buffer following GPU error
      drm/i915: give up on 8xx lid status
      drm/i915: reduce some of the duplication of tiling checking
      drm/i915: blow away userspace mappings before fence change
      drm/i915: move a gtt flush to the correct place
      agp/intel: official names for Pineview and Ironlake
      drm/i915: overlay: drop superflous gpu flushes
      drm/i915: overlay: nuke readback to flush wc caches
      drm/i915: provide self-refresh status in debugfs
      drm/i915: provide FBC status in debugfs
      drm/i915: fix drps disable so unload & re-load works
      drm/i915: Fix OGLC performance regression on 945
      drm/i915: Deobfuscate the render p-state obfuscation
      drm/i915: add dynamic performance control support for Ironlake
      drm/i915: enable memory self refresh on 9xx
      drm/i915: Don't reserve compatibility fence regs in KMS mode.
      drm/i915: Keep MCHBAR always enabled
      drm/i915: Replace open-coded eviction in i915_gem_idle()

commit 61caf87cb5c2a198966018343a6ce4c5ab6cf8df
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Feb 18 23:06:27 2010 +0100

    i915 / PM: Fix hibernate regression caused by suspend/resume splitting
    
    Commit 84b79f8d2882b0a84330c04839ed4d3cefd2ff77 (drm/i915: Fix crash
    while aborting hibernation) attempted to fix a regression introduced
    by commit cbda12d77ea590082edb6d30bd342a67ebc459e0 (drm/i915:
    implement new pm ops for i915), but it went too far trying to split
    the freeze/suspend and resume/thaw parts of the code.  As a result,
    it introduced another regression, which only is visible on some systems.
    
    Fix the problem by merging i915_drm_suspend() with
    i915_drm_freeze() and moving some code from i915_resume()
    into i915_drm_thaw(), so that intel_opregion_free() and
    intel_opregion_init() are also executed in the freeze and thaw code
    paths, respectively.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Pedro Ribeiro <pedrib@gmail.com>
    Tested-by: Tino Keitel <tino.keitel@tikei.de>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 79beffcf5936..cf4cb3e9a0c2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -176,6 +176,8 @@ MODULE_DEVICE_TABLE(pci, pciidlist);
 
 static int i915_drm_freeze(struct drm_device *dev)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
 	pci_save_state(dev->pdev);
 
 	/* If KMS is active, we do the leavevt stuff here */
@@ -191,17 +193,12 @@ static int i915_drm_freeze(struct drm_device *dev)
 
 	i915_save_state(dev);
 
-	return 0;
-}
-
-static void i915_drm_suspend(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
 	intel_opregion_free(dev, 1);
 
 	/* Modeset on resume, not lid events */
 	dev_priv->modeset_on_lid = 0;
+
+	return 0;
 }
 
 static int i915_suspend(struct drm_device *dev, pm_message_t state)
@@ -221,8 +218,6 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	if (error)
 		return error;
 
-	i915_drm_suspend(dev);
-
 	if (state.event == PM_EVENT_SUSPEND) {
 		/* Shut down the device */
 		pci_disable_device(dev->pdev);
@@ -237,6 +232,10 @@ static int i915_drm_thaw(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int error = 0;
 
+	i915_restore_state(dev);
+
+	intel_opregion_init(dev, 1);
+
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
@@ -263,10 +262,6 @@ static int i915_resume(struct drm_device *dev)
 
 	pci_set_master(dev->pdev);
 
-	i915_restore_state(dev);
-
-	intel_opregion_init(dev, 1);
-
 	return i915_drm_thaw(dev);
 }
 
@@ -423,8 +418,6 @@ static int i915_pm_suspend(struct device *dev)
 	if (error)
 		return error;
 
-	i915_drm_suspend(drm_dev);
-
 	pci_disable_device(pdev);
 	pci_set_power_state(pdev, PCI_D3hot);
 
@@ -464,13 +457,8 @@ static int i915_pm_poweroff(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-	int error;
-
-	error = i915_drm_freeze(drm_dev);
-	if (!error)
-		i915_drm_suspend(drm_dev);
 
-	return error;
+	return i915_drm_freeze(drm_dev);
 }
 
 const struct dev_pm_ops i915_pm_ops = {

commit f97108d1d0facc7902134ebc453b226bbd4d1cdb
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jan 29 11:27:07 2010 -0800

    drm/i915: add dynamic performance control support for Ironlake
    
    Ironlake (and 965GM, which this patch doesn't support) supports a
    hardware performance and power management feature that allows it to
    adjust to changes in GPU load over time with software help.  The goal
    if this is to maximize performance/power for a given workload.
    
    This patch enables that feature, which is also a requirement for
    supporting Intelligent Power Sharing, a feature which allows for
    dynamic budgeting of power between the CPU and GPU in Arrandale
    platforms.
    
    Tested-by: ykzhao <yakui.zhao@intel.com>
    [anholt: Resolved against the irq handler loop removal]
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 79beffcf5936..89f1cb86c32b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -583,6 +583,11 @@ static int __init i915_init(void)
 		driver.driver_features &= ~DRIVER_MODESET;
 #endif
 
+	if (!(driver.driver_features & DRIVER_MODESET)) {
+		driver.suspend = i915_suspend;
+		driver.resume = i915_resume;
+	}
+
 	return drm_init(&driver);
 }
 

commit 84b79f8d2882b0a84330c04839ed4d3cefd2ff77
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 7 21:48:24 2010 +0100

    drm/i915: Fix crash while aborting hibernation
    
    Commit cbda12d77ea590082edb6d30bd342a67ebc459e0 (drm/i915: implement
    new pm ops for i915) introduced the problem that if s2disk hibernation
    is aborted, the system will crash, because i915_pm_freeze() does
    nothing, while it should at least reverse some operations carried out
    by i915_suspend().
    
    Fix this issue by splitting the i915 suspend into a freeze part a
    suspend part, where the latter is not executed before creating a
    hibernation image, and the i915 resume into a "low-level" resume part
    and a thaw part, where the former is not executed after the image has
    been created.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index ecac882e1d54..79beffcf5936 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -174,78 +174,100 @@ const static struct pci_device_id pciidlist[] = {
 MODULE_DEVICE_TABLE(pci, pciidlist);
 #endif
 
-static int i915_suspend(struct drm_device *dev, pm_message_t state)
+static int i915_drm_freeze(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
-	if (!dev || !dev_priv) {
-		DRM_ERROR("dev: %p, dev_priv: %p\n", dev, dev_priv);
-		DRM_ERROR("DRM not initialized, aborting suspend.\n");
-		return -ENODEV;
-	}
-
-	if (state.event == PM_EVENT_PRETHAW)
-		return 0;
-
 	pci_save_state(dev->pdev);
 
 	/* If KMS is active, we do the leavevt stuff here */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
-		if (i915_gem_idle(dev))
+		int error = i915_gem_idle(dev);
+		if (error) {
 			dev_err(&dev->pdev->dev,
-				"GEM idle failed, resume may fail\n");
+				"GEM idle failed, resume might fail\n");
+			return error;
+		}
 		drm_irq_uninstall(dev);
 	}
 
 	i915_save_state(dev);
 
+	return 0;
+}
+
+static void i915_drm_suspend(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
 	intel_opregion_free(dev, 1);
 
+	/* Modeset on resume, not lid events */
+	dev_priv->modeset_on_lid = 0;
+}
+
+static int i915_suspend(struct drm_device *dev, pm_message_t state)
+{
+	int error;
+
+	if (!dev || !dev->dev_private) {
+		DRM_ERROR("dev: %p\n", dev);
+		DRM_ERROR("DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
+
+	if (state.event == PM_EVENT_PRETHAW)
+		return 0;
+
+	error = i915_drm_freeze(dev);
+	if (error)
+		return error;
+
+	i915_drm_suspend(dev);
+
 	if (state.event == PM_EVENT_SUSPEND) {
 		/* Shut down the device */
 		pci_disable_device(dev->pdev);
 		pci_set_power_state(dev->pdev, PCI_D3hot);
 	}
 
-	/* Modeset on resume, not lid events */
-	dev_priv->modeset_on_lid = 0;
-
 	return 0;
 }
 
-static int i915_resume(struct drm_device *dev)
+static int i915_drm_thaw(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int ret = 0;
-
-	if (pci_enable_device(dev->pdev))
-		return -1;
-	pci_set_master(dev->pdev);
-
-	i915_restore_state(dev);
-
-	intel_opregion_init(dev, 1);
+	int error = 0;
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		mutex_lock(&dev->struct_mutex);
 		dev_priv->mm.suspended = 0;
 
-		ret = i915_gem_init_ringbuffer(dev);
-		if (ret != 0)
-			ret = -1;
+		error = i915_gem_init_ringbuffer(dev);
 		mutex_unlock(&dev->struct_mutex);
 
 		drm_irq_install(dev);
-	}
-	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+
 		/* Resume the modeset for every activated CRTC */
 		drm_helper_resume_force_mode(dev);
 	}
 
 	dev_priv->modeset_on_lid = 0;
 
-	return ret;
+	return error;
+}
+
+static int i915_resume(struct drm_device *dev)
+{
+	if (pci_enable_device(dev->pdev))
+		return -EIO;
+
+	pci_set_master(dev->pdev);
+
+	i915_restore_state(dev);
+
+	intel_opregion_init(dev, 1);
+
+	return i915_drm_thaw(dev);
 }
 
 /**
@@ -386,57 +408,69 @@ i915_pci_remove(struct pci_dev *pdev)
 	drm_put_dev(dev);
 }
 
-static int
-i915_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+static int i915_pm_suspend(struct device *dev)
 {
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	int error;
 
-	return i915_suspend(dev, state);
-}
+	if (!drm_dev || !drm_dev->dev_private) {
+		dev_err(dev, "DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
 
-static int
-i915_pci_resume(struct pci_dev *pdev)
-{
-	struct drm_device *dev = pci_get_drvdata(pdev);
+	error = i915_drm_freeze(drm_dev);
+	if (error)
+		return error;
 
-	return i915_resume(dev);
-}
+	i915_drm_suspend(drm_dev);
 
-static int
-i915_pm_suspend(struct device *dev)
-{
-	return i915_pci_suspend(to_pci_dev(dev), PMSG_SUSPEND);
-}
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
 
-static int
-i915_pm_resume(struct device *dev)
-{
-	return i915_pci_resume(to_pci_dev(dev));
+	return 0;
 }
 
-static int
-i915_pm_freeze(struct device *dev)
+static int i915_pm_resume(struct device *dev)
 {
-	return i915_pci_suspend(to_pci_dev(dev), PMSG_FREEZE);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	return i915_resume(drm_dev);
 }
 
-static int
-i915_pm_thaw(struct device *dev)
+static int i915_pm_freeze(struct device *dev)
 {
-	/* thaw during hibernate, do nothing! */
-	return 0;
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	if (!drm_dev || !drm_dev->dev_private) {
+		dev_err(dev, "DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
+
+	return i915_drm_freeze(drm_dev);
 }
 
-static int
-i915_pm_poweroff(struct device *dev)
+static int i915_pm_thaw(struct device *dev)
 {
-	return i915_pci_suspend(to_pci_dev(dev), PMSG_HIBERNATE);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+
+	return i915_drm_thaw(drm_dev);
 }
 
-static int
-i915_pm_restore(struct device *dev)
+static int i915_pm_poweroff(struct device *dev)
 {
-	return i915_pci_resume(to_pci_dev(dev));
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	int error;
+
+	error = i915_drm_freeze(drm_dev);
+	if (!error)
+		i915_drm_suspend(drm_dev);
+
+	return error;
 }
 
 const struct dev_pm_ops i915_pm_ops = {
@@ -445,7 +479,7 @@ const struct dev_pm_ops i915_pm_ops = {
      .freeze = i915_pm_freeze,
      .thaw = i915_pm_thaw,
      .poweroff = i915_pm_poweroff,
-     .restore = i915_pm_restore,
+     .restore = i915_pm_resume,
 };
 
 static struct vm_operations_struct i915_gem_vm_ops = {

commit 8a6c77d645d9111f7bc01f908464301f5c3e0a05
Author: Li Peng <peng.li@linux.intel.com>
Date:   Thu Jan 21 18:45:46 2010 +0800

    drm/i915: Fix the device info of Pineview
    
    Pineview doesn't has CXSR and need GTT-based hardware status page.
    It fixes a X boot hung issue on Pinview since commit cfdf1f
    
    Signed-off-by: Li Peng <peng.li@intel.com>
    Acked-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 46d88965852a..ecac882e1d54 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -120,7 +120,7 @@ const static struct intel_device_info intel_gm45_info = {
 
 const static struct intel_device_info intel_pineview_info = {
 	.is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
-	.has_pipe_cxsr = 1,
+	.need_gfx_hws = 1,
 	.has_hotplug = 1,
 };
 

commit 33814341f22f13cec17e8d7fbf6f7e8000e3efa4
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Jan 14 20:48:02 2010 +0000

    drm/i915: disable LVDS downclock by default
    
    Many platform support this feature, and it can provide significant
    power savings when the reduced refresh rate is low.  However, on some
    platforms a secondary (reduced) timing is provided but not actually
    supported by the hardware.  This results in undesirable flicker at
    runtime.
    
    So disable the feature by default, but allow users to opt-in to the
    reduced clock behavior with a new module parameter, lvds_downclock,
    that can be set to 1 to enable the feature.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 66f7bac2ee55..46d88965852a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -45,6 +45,9 @@ module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 unsigned int i915_powersave = 1;
 module_param_named(powersave, i915_powersave, int, 0400);
 
+unsigned int i915_lvds_downclock = 0;
+module_param_named(lvds_downclock, i915_lvds_downclock, int, 0400);
+
 static struct drm_driver driver;
 
 #define INTEL_VGA_DEVICE(id, info) {		\

commit d8e292093a3a78a7967757e90abbe64869e4cb7c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 9 00:45:33 2010 +0100

    drm/i915: Fix resume regression on MSI Wind U100 w/o KMS
    
    Commit cbda12d77ea590082edb6d30bd342a67ebc459e0 (drm/i915: implement
    new pm ops for i915), among other things, removed the .suspend and
    .resume pointers from the struct drm_driver object in i915_drv.c,
    which broke resume without KMS on my MSI Wind U100.
    
    Fix this by reverting that part of commit cbda12d77ea59.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [anholt: added comment explaining when .suspend/.resume matter]
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2ffffd7ae09a..66f7bac2ee55 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -464,6 +464,11 @@ static struct drm_driver driver = {
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,
 	.postclose = i915_driver_postclose,
+
+	/* Used in place of i915_pm_ops for non-DRIVER_MODESET */
+	.suspend = i915_suspend,
+	.resume = i915_resume,
+
 	.device_is_agp = i915_driver_device_is_agp,
 	.enable_vblank = i915_enable_vblank,
 	.disable_vblank = i915_disable_vblank,

commit 635b3c9d5508d1dfe02ee5f882becea37e294111
Merge: 7959722b951c 823f68fd646d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 6 18:16:17 2010 -0800

    Merge branch 'drm-intel-next' of git://git.kernel.org/pub/scm/linux/kernel/git/anholt/drm-intel
    
    * 'drm-intel-next' of git://git.kernel.org/pub/scm/linux/kernel/git/anholt/drm-intel: (23 commits)
      drm/i915: remove full registers dump debug
      drm/i915: Add DP dpll limit on ironlake and use existing DPLL search function
      drm/i915: Select the correct BPC for LVDS on Ironlake
      drm/i915: Make the BPC in FDI rx/transcoder be consistent with that in pipeconf on Ironlake
      drm/i915: Enable/disable the dithering for LVDS based on VBT setting
      drm/i915: Permit pinning whilst the device is 'suspended'
      drm/i915: Hold struct mutex whilst pinning power context bo.
      drm/i915: fix unused var
      drm/i915: Storage class should be before const qualifier
      drm/i915: remove render reclock support
      drm/i915: Fix RC6 suspend/resume
      drm/i915: execbuf2 support
      drm/i915: Reload hangcheck timer too for Ironlake
      drm/i915: only enable hotplug for detected outputs
      drm/i915: Track whether cursor needs physical address in intel_device_info
      drm/i915: Implement IS_* macros using static tables
      drm/i915: Move PCI IDs into i915 driver
      drm/i915: Update LVDS connector status when receiving ACPI LID event
      drm/i915: Add MALATA PC-81005 to ACPI LID quirk list
      drm/i915: implement new pm ops for i915
      ...

commit ed8b67040965e4fe695db333d5914e18ea5f146f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 16 22:17:09 2009 +0000

    drm: convert drm_ioctl to unlocked_ioctl
    
    drm_ioctl is called with the Big Kernel Lock held,
    which shows up very high in statistics on vfs_ioctl.
    
    Moving the lock into the drm_ioctl function itself
    makes sure we blame the right subsystem and it gets
    us one step closer to eliminating the locked version
    of fops->ioctl.
    
    Since drm_ioctl does not require the lock itself,
    we only need to hold it while calling the specific
    handler. The 32 bit conversion handlers do not
    interact with any other code, so they don't need
    the BKL here either and can just call drm_ioctl.
    
    As a bonus, this cleans up all the other users
    of drm_ioctl which now no longer have to find
    the inode or call lock_kernel.
    
    [airlied: squashed the non-driver bits
    of the second patch in here, this provides
    the flag for drivers to use to select unlocked
    ioctls - but doesn't modify any drivers].
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.sourceforge.net
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2fa217862058..24286ca168fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -329,7 +329,7 @@ static struct drm_driver driver = {
 		 .owner = THIS_MODULE,
 		 .open = drm_open,
 		 .release = drm_release,
-		 .ioctl = drm_ioctl,
+		 .unlocked_ioctl = drm_ioctl,
 		 .mmap = drm_gem_mmap,
 		 .poll = drm_poll,
 		 .fasync = drm_fasync,

commit b295d1b6e3e3f240d27cbe556d33ff5eb54721a7
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Wed Dec 16 15:16:17 2009 -0500

    drm/i915: Track whether cursor needs physical address in intel_device_info
    
    Signed-off-by: Kristian Høgsberg <krh@bitplanet.net>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b256de24563..a0a2cad8c016 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -57,7 +57,7 @@ static struct drm_driver driver;
 	.driver_data = (unsigned long) info }
 
 const static struct intel_device_info intel_i830_info = {
-	.is_i8xx = 1, .is_mobile = 1,
+	.is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
 };
 
 const static struct intel_device_info intel_845g_info = {
@@ -65,7 +65,7 @@ const static struct intel_device_info intel_845g_info = {
 };
 
 const static struct intel_device_info intel_i85x_info = {
-	.is_i8xx = 1, .is_mobile = 1,
+	.is_i8xx = 1, .is_mobile = 1, .cursor_needs_physical = 1,
 };
 
 const static struct intel_device_info intel_i865g_info = {
@@ -73,17 +73,18 @@ const static struct intel_device_info intel_i865g_info = {
 };
 
 const static struct intel_device_info intel_i915g_info = {
-	.is_i915g = 1, .is_i9xx = 1,
+	.is_i915g = 1, .is_i9xx = 1, .cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i915gm_info = {
 	.is_i9xx = 1,  .is_mobile = 1, .has_fbc = 1,
+	.cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i945g_info = {
-	.is_i9xx = 1, .has_hotplug = 1,
+	.is_i9xx = 1, .has_hotplug = 1, .cursor_needs_physical = 1,
 };
 const static struct intel_device_info intel_i945gm_info = {
 	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1, .has_fbc = 1,
-	.has_hotplug = 1,
+	.has_hotplug = 1, .cursor_needs_physical = 1,
 };
 
 const static struct intel_device_info intel_i965g_info = {

commit cfdf1fa23f4074c9f8766dc67a928bbf680b1ac9
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Wed Dec 16 15:16:16 2009 -0500

    drm/i915: Implement IS_* macros using static tables
    
    Instead of using the IS_I9XX etc macros that expand to a ton of
    comparisons, use new struct intel_device_info to capture the
    capabilities of the different chipsets.  The drm_i915_private struct
    will be initialized to point to the device info that correspond to
    the actual device and this way, testing for a specific capability is
    just a matter of checking a bit field.
    
    Signed-off-by: Kristian Høgsberg <krh@bitplanet.net>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b6ec949361e2..1b256de24563 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -47,46 +47,122 @@ module_param_named(powersave, i915_powersave, int, 0400);
 
 static struct drm_driver driver;
 
-#define INTEL_VGA_DEVICE(id) {			\
+#define INTEL_VGA_DEVICE(id, info) {		\
 	.class = PCI_CLASS_DISPLAY_VGA << 8,	\
 	.class_mask = 0xffff00,			\
 	.vendor = 0x8086,			\
 	.device = id,				\
 	.subvendor = PCI_ANY_ID,		\
 	.subdevice = PCI_ANY_ID,		\
-	.driver_data = 0 }
-
-static struct pci_device_id pciidlist[] = {
-	INTEL_VGA_DEVICE(0x3577),
-	INTEL_VGA_DEVICE(0x2562),
-	INTEL_VGA_DEVICE(0x3582),
-	INTEL_VGA_DEVICE(0x2572),
-	INTEL_VGA_DEVICE(0x2582),
-	INTEL_VGA_DEVICE(0x258a),
-	INTEL_VGA_DEVICE(0x2592),
-	INTEL_VGA_DEVICE(0x2772),
-	INTEL_VGA_DEVICE(0x27a2),
-	INTEL_VGA_DEVICE(0x27ae),
-	INTEL_VGA_DEVICE(0x2972),
-	INTEL_VGA_DEVICE(0x2982),
-	INTEL_VGA_DEVICE(0x2992),
-	INTEL_VGA_DEVICE(0x29a2),
-	INTEL_VGA_DEVICE(0x29b2),
-	INTEL_VGA_DEVICE(0x29c2),
-	INTEL_VGA_DEVICE(0x29d2),
-	INTEL_VGA_DEVICE(0x2a02),
-	INTEL_VGA_DEVICE(0x2a12),
-	INTEL_VGA_DEVICE(0x2a42),
-	INTEL_VGA_DEVICE(0x2e02),
-	INTEL_VGA_DEVICE(0x2e12),
-	INTEL_VGA_DEVICE(0x2e22),
-	INTEL_VGA_DEVICE(0x2e32),
-	INTEL_VGA_DEVICE(0x2e42),
-	INTEL_VGA_DEVICE(0xa001),
-	INTEL_VGA_DEVICE(0xa011),
-	INTEL_VGA_DEVICE(0x35e8),
-	INTEL_VGA_DEVICE(0x0042),
-	INTEL_VGA_DEVICE(0x0046),
+	.driver_data = (unsigned long) info }
+
+const static struct intel_device_info intel_i830_info = {
+	.is_i8xx = 1, .is_mobile = 1,
+};
+
+const static struct intel_device_info intel_845g_info = {
+	.is_i8xx = 1,
+};
+
+const static struct intel_device_info intel_i85x_info = {
+	.is_i8xx = 1, .is_mobile = 1,
+};
+
+const static struct intel_device_info intel_i865g_info = {
+	.is_i8xx = 1,
+};
+
+const static struct intel_device_info intel_i915g_info = {
+	.is_i915g = 1, .is_i9xx = 1,
+};
+const static struct intel_device_info intel_i915gm_info = {
+	.is_i9xx = 1,  .is_mobile = 1, .has_fbc = 1,
+};
+const static struct intel_device_info intel_i945g_info = {
+	.is_i9xx = 1, .has_hotplug = 1,
+};
+const static struct intel_device_info intel_i945gm_info = {
+	.is_i945gm = 1, .is_i9xx = 1, .is_mobile = 1, .has_fbc = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_i965g_info = {
+	.is_i965g = 1, .is_i9xx = 1, .has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_i965gm_info = {
+	.is_i965g = 1, .is_mobile = 1, .is_i965gm = 1, .is_i9xx = 1,
+	.is_mobile = 1, .has_fbc = 1, .has_rc6 = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_g33_info = {
+	.is_g33 = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_g45_info = {
+	.is_i965g = 1, .is_g4x = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_gm45_info = {
+	.is_i965g = 1, .is_mobile = 1, .is_g4x = 1, .is_i9xx = 1,
+	.is_mobile = 1, .need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_pineview_info = {
+	.is_g33 = 1, .is_pineview = 1, .is_mobile = 1, .is_i9xx = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_ironlake_d_info = {
+	.is_ironlake = 1, .is_i965g = 1, .is_i9xx = 1, .need_gfx_hws = 1,
+	.has_pipe_cxsr = 1,
+	.has_hotplug = 1,
+};
+
+const static struct intel_device_info intel_ironlake_m_info = {
+	.is_ironlake = 1, .is_mobile = 1, .is_i965g = 1, .is_i9xx = 1,
+	.need_gfx_hws = 1, .has_rc6 = 1,
+	.has_hotplug = 1,
+};
+
+const static struct pci_device_id pciidlist[] = {
+	INTEL_VGA_DEVICE(0x3577, &intel_i830_info),
+	INTEL_VGA_DEVICE(0x2562, &intel_845g_info),
+	INTEL_VGA_DEVICE(0x3582, &intel_i85x_info),
+	INTEL_VGA_DEVICE(0x35e8, &intel_i85x_info),
+	INTEL_VGA_DEVICE(0x2572, &intel_i865g_info),
+	INTEL_VGA_DEVICE(0x2582, &intel_i915g_info),
+	INTEL_VGA_DEVICE(0x258a, &intel_i915g_info),
+	INTEL_VGA_DEVICE(0x2592, &intel_i915gm_info),
+	INTEL_VGA_DEVICE(0x2772, &intel_i945g_info),
+	INTEL_VGA_DEVICE(0x27a2, &intel_i945gm_info),
+	INTEL_VGA_DEVICE(0x27ae, &intel_i945gm_info),
+	INTEL_VGA_DEVICE(0x2972, &intel_i965g_info),
+	INTEL_VGA_DEVICE(0x2982, &intel_i965g_info),
+	INTEL_VGA_DEVICE(0x2992, &intel_i965g_info),
+	INTEL_VGA_DEVICE(0x29a2, &intel_i965g_info),
+	INTEL_VGA_DEVICE(0x29b2, &intel_g33_info),
+	INTEL_VGA_DEVICE(0x29c2, &intel_g33_info),
+	INTEL_VGA_DEVICE(0x29d2, &intel_g33_info),
+	INTEL_VGA_DEVICE(0x2a02, &intel_i965gm_info),
+	INTEL_VGA_DEVICE(0x2a12, &intel_i965gm_info),
+	INTEL_VGA_DEVICE(0x2a42, &intel_gm45_info),
+	INTEL_VGA_DEVICE(0x2e02, &intel_g45_info),
+	INTEL_VGA_DEVICE(0x2e12, &intel_g45_info),
+	INTEL_VGA_DEVICE(0x2e22, &intel_g45_info),
+	INTEL_VGA_DEVICE(0x2e32, &intel_g45_info),
+	INTEL_VGA_DEVICE(0x2e42, &intel_g45_info),
+	INTEL_VGA_DEVICE(0xa001, &intel_pineview_info),
+	INTEL_VGA_DEVICE(0xa011, &intel_pineview_info),
+	INTEL_VGA_DEVICE(0x0042, &intel_ironlake_d_info),
+	INTEL_VGA_DEVICE(0x0046, &intel_ironlake_m_info),
 	{0, 0, 0}
 };
 

commit 49ae35f2dd1ff78ee88d5f8a38d0af63c3ad9f71
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Wed Dec 16 15:16:15 2009 -0500

    drm/i915: Move PCI IDs into i915 driver
    
    The old include/drm/drm_pciids.h used to be generated from the libdrm
    git repo.  We don't use that anymore so just use a local list in the
    driver like everybody else.
    
    Signed-off-by: Kristian Høgsberg <krh@bitplanet.net>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6978a22f70e7..b6ec949361e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -33,7 +33,6 @@
 #include "i915_drm.h"
 #include "i915_drv.h"
 
-#include "drm_pciids.h"
 #include <linux/console.h>
 #include "drm_crtc_helper.h"
 
@@ -48,8 +47,47 @@ module_param_named(powersave, i915_powersave, int, 0400);
 
 static struct drm_driver driver;
 
+#define INTEL_VGA_DEVICE(id) {			\
+	.class = PCI_CLASS_DISPLAY_VGA << 8,	\
+	.class_mask = 0xffff00,			\
+	.vendor = 0x8086,			\
+	.device = id,				\
+	.subvendor = PCI_ANY_ID,		\
+	.subdevice = PCI_ANY_ID,		\
+	.driver_data = 0 }
+
 static struct pci_device_id pciidlist[] = {
-	i915_PCI_IDS
+	INTEL_VGA_DEVICE(0x3577),
+	INTEL_VGA_DEVICE(0x2562),
+	INTEL_VGA_DEVICE(0x3582),
+	INTEL_VGA_DEVICE(0x2572),
+	INTEL_VGA_DEVICE(0x2582),
+	INTEL_VGA_DEVICE(0x258a),
+	INTEL_VGA_DEVICE(0x2592),
+	INTEL_VGA_DEVICE(0x2772),
+	INTEL_VGA_DEVICE(0x27a2),
+	INTEL_VGA_DEVICE(0x27ae),
+	INTEL_VGA_DEVICE(0x2972),
+	INTEL_VGA_DEVICE(0x2982),
+	INTEL_VGA_DEVICE(0x2992),
+	INTEL_VGA_DEVICE(0x29a2),
+	INTEL_VGA_DEVICE(0x29b2),
+	INTEL_VGA_DEVICE(0x29c2),
+	INTEL_VGA_DEVICE(0x29d2),
+	INTEL_VGA_DEVICE(0x2a02),
+	INTEL_VGA_DEVICE(0x2a12),
+	INTEL_VGA_DEVICE(0x2a42),
+	INTEL_VGA_DEVICE(0x2e02),
+	INTEL_VGA_DEVICE(0x2e12),
+	INTEL_VGA_DEVICE(0x2e22),
+	INTEL_VGA_DEVICE(0x2e32),
+	INTEL_VGA_DEVICE(0x2e42),
+	INTEL_VGA_DEVICE(0xa001),
+	INTEL_VGA_DEVICE(0xa011),
+	INTEL_VGA_DEVICE(0x35e8),
+	INTEL_VGA_DEVICE(0x0042),
+	INTEL_VGA_DEVICE(0x0046),
+	{0, 0, 0}
 };
 
 #if defined(CONFIG_DRM_I915_KMS)

commit cbda12d77ea590082edb6d30bd342a67ebc459e0
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Wed Dec 16 13:36:10 2009 +0800

    drm/i915: implement new pm ops for i915
    
    One problem in i915 hibernate with current legacy pci pm ops is
    that after we do freeze, we'll be forced to do resume once again,
    which re-init some resources and do modesetting again, that is
    unnecessary for hibernate. This patch trys to bypass that.
    
    We can't resolve this within legacy pm framework, but can do it
    easily with new pm ops. Suspend (S3) process has also been kept
    without change.
    
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 2fa217862058..6978a22f70e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -284,6 +284,52 @@ i915_pci_resume(struct pci_dev *pdev)
 	return i915_resume(dev);
 }
 
+static int
+i915_pm_suspend(struct device *dev)
+{
+	return i915_pci_suspend(to_pci_dev(dev), PMSG_SUSPEND);
+}
+
+static int
+i915_pm_resume(struct device *dev)
+{
+	return i915_pci_resume(to_pci_dev(dev));
+}
+
+static int
+i915_pm_freeze(struct device *dev)
+{
+	return i915_pci_suspend(to_pci_dev(dev), PMSG_FREEZE);
+}
+
+static int
+i915_pm_thaw(struct device *dev)
+{
+	/* thaw during hibernate, do nothing! */
+	return 0;
+}
+
+static int
+i915_pm_poweroff(struct device *dev)
+{
+	return i915_pci_suspend(to_pci_dev(dev), PMSG_HIBERNATE);
+}
+
+static int
+i915_pm_restore(struct device *dev)
+{
+	return i915_pci_resume(to_pci_dev(dev));
+}
+
+const struct dev_pm_ops i915_pm_ops = {
+     .suspend = i915_pm_suspend,
+     .resume = i915_pm_resume,
+     .freeze = i915_pm_freeze,
+     .thaw = i915_pm_thaw,
+     .poweroff = i915_pm_poweroff,
+     .restore = i915_pm_restore,
+};
+
 static struct vm_operations_struct i915_gem_vm_ops = {
 	.fault = i915_gem_fault,
 	.open = drm_gem_vm_open,
@@ -303,8 +349,6 @@ static struct drm_driver driver = {
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,
 	.postclose = i915_driver_postclose,
-	.suspend = i915_suspend,
-	.resume = i915_resume,
 	.device_is_agp = i915_driver_device_is_agp,
 	.enable_vblank = i915_enable_vblank,
 	.disable_vblank = i915_disable_vblank,
@@ -344,10 +388,7 @@ static struct drm_driver driver = {
 		 .id_table = pciidlist,
 		 .probe = i915_pci_probe,
 		 .remove = i915_pci_remove,
-#ifdef CONFIG_PM
-		 .resume = i915_pci_resume,
-		 .suspend = i915_pci_suspend,
-#endif
+		 .driver.pm = &i915_pm_ops,
 	},
 
 	.name = DRIVER_NAME,

commit c9a9c5e02aedc1a2815877b0268f886d2640b771
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Sat Sep 12 04:33:34 2009 +1000

    drm: Add async event synchronization for drmWaitVblank
    
    This patch adds a new flag to the drmWaitVblank ioctl, which asks the drm
    to return immediately and notify userspace when the specified vblank sequence
    happens by sending an event back on the drm fd.
    
    The event mechanism works with the other flags supported by the ioctls,
    specifically, the vblank sequence can be specified relatively or absolutely,
    and works for primary and seconday crtc.
    
    The signal field of the vblank request is used to provide user data,
    which will be sent back to user space in the vblank event.
    
    Signed-off-by: Kristian Høgsberg <krh@redhat.com>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 7f436ec075f6..2fa217862058 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -333,6 +333,7 @@ static struct drm_driver driver = {
 		 .mmap = drm_gem_mmap,
 		 .poll = drm_poll,
 		 .fasync = drm_fasync,
+		 .read = drm_read,
 #ifdef CONFIG_COMPAT
 		 .compat_ioctl = i915_compat_ioctl,
 #endif

commit c9354c85c1c7bac788ce57d3c17f2016c1c45b1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 2 09:29:55 2009 -0800

    i915: fix intel graphics suspend breakage due to resume/lid event confusion
    
    In commit c1c7af60892070e4b82ad63bbfb95ae745056de0 ("drm/i915: force
    mode set at lid open time") the intel graphics driver was taught to
    restore the LVDS mode on lid open.
    
    That caused problems with interaction with the suspend/resume code,
    which commonly runs at the same time (suspend is often caused by the lid
    close event, while lid open is commonly a resume event), which was
    worked around with in commit 06891e27a9b5dba5268bb80e41a283f51335afe7
    ("drm/i915: fix suspend/resume breakage in lid notifier").
    
    However, in the meantime the lid event code had also grown a user event
    notifier (commit 06324194eee97a51b5f172270df49ec39192d6cc: "drm/i915:
    generate a KMS uevent at lid open/close time"), and now _that_ causes
    problems with suspend/resume and some versions of Xorg reacting to those
    uevents by setting the mode.
    
    So this effectively reverts that commit 06324194ee, and makes the lid
    open protection logic against suspend/resume more explicit.  This fixes
    at least one laptop. See
    
            http://bugzilla.kernel.org/show_bug.cgi?id=14484
    
    for more details.
    
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Riccardo Magliocchetti <riccardo.magliocchetti@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b93814c0d3e2..7f436ec075f6 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -89,7 +89,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		pci_set_power_state(dev->pdev, PCI_D3hot);
 	}
 
-	dev_priv->suspended = 1;
+	/* Modeset on resume, not lid events */
+	dev_priv->modeset_on_lid = 0;
 
 	return 0;
 }
@@ -124,7 +125,7 @@ static int i915_resume(struct drm_device *dev)
 		drm_helper_resume_force_mode(dev);
 	}
 
-	dev_priv->suspended = 0;
+	dev_priv->modeset_on_lid = 0;
 
 	return ret;
 }

commit b7e53aba2f0e6abf23e3f07b38b241145c33a005
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Mon Sep 14 10:47:07 2009 +0800

    drm/i915: remove restore in resume
    
    Don't need extra config restore like for intel_agp, which
    might cause resume hang issue found by Alan on 845G.
    
    Cc: Stable Team <stable@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c57c1744cecf..b93814c0d3e2 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -99,8 +99,6 @@ static int i915_resume(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret = 0;
 
-	pci_set_power_state(dev->pdev, PCI_D0);
-	pci_restore_state(dev->pdev);
 	if (pci_enable_device(dev->pdev))
 		return -1;
 	pci_set_master(dev->pdev);

commit 31169714fc928aed4e945b959dca2bedd259b9c9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Sep 14 16:50:28 2009 +0100

    drm/i915: Register a shrinker to free inactive lists under memory pressure
    
    This should help GEM handle memory pressure sitatuions more gracefully.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1f9e4503b072..c57c1744cecf 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -362,6 +362,8 @@ static int __init i915_init(void)
 {
 	driver.num_ioctls = i915_max_ioctl;
 
+	i915_gem_shrinker_init();
+
 	/*
 	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless
 	 * explicitly disabled with the module pararmeter.
@@ -388,6 +390,7 @@ static int __init i915_init(void)
 
 static void __exit i915_exit(void)
 {
+	i915_gem_shrinker_exit();
 	drm_exit(&driver);
 }
 

commit 06891e27a9b5dba5268bb80e41a283f51335afe7
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Sep 14 10:58:48 2009 -0700

    drm/i915: fix suspend/resume breakage in lid notifier
    
    We now unconditionally restore the mode at lid open time since some
    platforms turn off the panel, pipes or other display elements when the
    lid is closed.  There's a problem with doing this at resume time
    however.
    
    At resume time, we'll get a lid event, but restoring the mode at that
    time may not be safe (e.g. if we get the lid event before global state
    has been restored), so check the suspended state and make sure our
    restore is locked against other mode updates.
    
    Tested-by: Ben Gamari <bgamari.foss@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 435082e40736..1f9e4503b072 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -89,6 +89,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		pci_set_power_state(dev->pdev, PCI_D3hot);
 	}
 
+	dev_priv->suspended = 1;
+
 	return 0;
 }
 
@@ -124,6 +126,8 @@ static int i915_resume(struct drm_device *dev)
 		drm_helper_resume_force_mode(dev);
 	}
 
+	dev_priv->suspended = 0;
+
 	return ret;
 }
 

commit 11ed50ec2a316928c2bacc1149bded86c6a96068
Author: Ben Gamari <bgamari.foss@gmail.com>
Date:   Mon Sep 14 17:48:45 2009 -0400

    drm/i915: Implement GPU reset on i965
    
    This patch puts in place the machinery to attempt to reset the GPU. This
    will be used when attempting to recover from a GPU hang.
    
    Signed-off-by: Owain G. Ainsworth <oga@openbsd.org>
    Signed-off-by: Ben Gamari <bgamari.foss@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index dbe568c9327b..435082e40736 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -127,6 +127,130 @@ static int i915_resume(struct drm_device *dev)
 	return ret;
 }
 
+/**
+ * i965_reset - reset chip after a hang
+ * @dev: drm device to reset
+ * @flags: reset domains
+ *
+ * Reset the chip.  Useful if a hang is detected. Returns zero on successful
+ * reset or otherwise an error code.
+ *
+ * Procedure is fairly simple:
+ *   - reset the chip using the reset reg
+ *   - re-init context state
+ *   - re-init hardware status page
+ *   - re-init ring buffer
+ *   - re-init interrupt state
+ *   - re-init display
+ */
+int i965_reset(struct drm_device *dev, u8 flags)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	unsigned long timeout;
+	u8 gdrst;
+	/*
+	 * We really should only reset the display subsystem if we actually
+	 * need to
+	 */
+	bool need_display = true;
+
+	mutex_lock(&dev->struct_mutex);
+
+	/*
+	 * Clear request list
+	 */
+	i915_gem_retire_requests(dev);
+
+	if (need_display)
+		i915_save_display(dev);
+
+	if (IS_I965G(dev) || IS_G4X(dev)) {
+		/*
+		 * Set the domains we want to reset, then the reset bit (bit 0).
+		 * Clear the reset bit after a while and wait for hardware status
+		 * bit (bit 1) to be set
+		 */
+		pci_read_config_byte(dev->pdev, GDRST, &gdrst);
+		pci_write_config_byte(dev->pdev, GDRST, gdrst | flags | ((flags == GDRST_FULL) ? 0x1 : 0x0));
+		udelay(50);
+		pci_write_config_byte(dev->pdev, GDRST, gdrst & 0xfe);
+
+		/* ...we don't want to loop forever though, 500ms should be plenty */
+	       timeout = jiffies + msecs_to_jiffies(500);
+		do {
+			udelay(100);
+			pci_read_config_byte(dev->pdev, GDRST, &gdrst);
+		} while ((gdrst & 0x1) && time_after(timeout, jiffies));
+
+		if (gdrst & 0x1) {
+			WARN(true, "i915: Failed to reset chip\n");
+			mutex_unlock(&dev->struct_mutex);
+			return -EIO;
+		}
+	} else {
+		DRM_ERROR("Error occurred. Don't know how to reset this chip.\n");
+		return -ENODEV;
+	}
+
+	/* Ok, now get things going again... */
+
+	/*
+	 * Everything depends on having the GTT running, so we need to start
+	 * there.  Fortunately we don't need to do this unless we reset the
+	 * chip at a PCI level.
+	 *
+	 * Next we need to restore the context, but we don't use those
+	 * yet either...
+	 *
+	 * Ring buffer needs to be re-initialized in the KMS case, or if X
+	 * was running at the time of the reset (i.e. we weren't VT
+	 * switched away).
+	 */
+	if (drm_core_check_feature(dev, DRIVER_MODESET) ||
+	    !dev_priv->mm.suspended) {
+		drm_i915_ring_buffer_t *ring = &dev_priv->ring;
+		struct drm_gem_object *obj = ring->ring_obj;
+		struct drm_i915_gem_object *obj_priv = obj->driver_private;
+		dev_priv->mm.suspended = 0;
+
+		/* Stop the ring if it's running. */
+		I915_WRITE(PRB0_CTL, 0);
+		I915_WRITE(PRB0_TAIL, 0);
+		I915_WRITE(PRB0_HEAD, 0);
+
+		/* Initialize the ring. */
+		I915_WRITE(PRB0_START, obj_priv->gtt_offset);
+		I915_WRITE(PRB0_CTL,
+			   ((obj->size - 4096) & RING_NR_PAGES) |
+			   RING_NO_REPORT |
+			   RING_VALID);
+		if (!drm_core_check_feature(dev, DRIVER_MODESET))
+			i915_kernel_lost_context(dev);
+		else {
+			ring->head = I915_READ(PRB0_HEAD) & HEAD_ADDR;
+			ring->tail = I915_READ(PRB0_TAIL) & TAIL_ADDR;
+			ring->space = ring->head - (ring->tail + 8);
+			if (ring->space < 0)
+				ring->space += ring->Size;
+		}
+
+		mutex_unlock(&dev->struct_mutex);
+		drm_irq_uninstall(dev);
+		drm_irq_install(dev);
+		mutex_lock(&dev->struct_mutex);
+	}
+
+	/*
+	 * Display needs restore too...
+	 */
+	if (need_display)
+		i915_restore_display(dev);
+
+	mutex_unlock(&dev->struct_mutex);
+	return 0;
+}
+
+
 static int __devinit
 i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {

commit d6073d775c4b26107351cb8d5e21cec4391f6314
Author: Kyle McMartin <kyle@redhat.com>
Date:   Tue May 26 12:27:34 2009 -0400

    drm/i915: i915_modeset is signed
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 81ab4883d898..dbe568c9327b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -37,7 +37,7 @@
 #include <linux/console.h>
 #include "drm_crtc_helper.h"
 
-static unsigned int i915_modeset = -1;
+static int i915_modeset = -1;
 module_param_named(modeset, i915_modeset, int, 0400);
 
 unsigned int i915_fbpercrtc = 0;

commit 652c393a3368af84359da37c45afc35a91144960
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Aug 17 13:31:43 2009 -0700

    drm/i915: add dynamic clock frequency control
    
    There are several sources of unnecessary power consumption on Intel
    graphics systems. The first is the LVDS clock. TFTs don't suffer from
    persistence issues like CRTs, and so we can reduce the LVDS refresh rate
    when the screen is idle. It will be automatically upclocked when
    userspace triggers graphical activity. Beyond that, we can enable memory
    self refresh. This allows the memory to go into a lower power state when
    the graphics are idle. Finally, we can drop some clocks on the gpu
    itself. All of these things can be reenabled between frames when GPU
    activity is triggered, and so there should be no user visible graphical
    changes.
    
    Signed-off-by: Jesse Barnes <jesse.barnes@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 263636e77e61..81ab4883d898 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -43,6 +43,9 @@ module_param_named(modeset, i915_modeset, int, 0400);
 unsigned int i915_fbpercrtc = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
+unsigned int i915_powersave = 1;
+module_param_named(powersave, i915_powersave, int, 0400);
+
 static struct drm_driver driver;
 
 static struct pci_device_id pciidlist[] = {

commit 27c202ad7f141d4efa9c64e30bf4a4d3bcd799ae
Author: Ben Gamari <bgamari.foss@gmail.com>
Date:   Wed Jul 1 22:26:52 2009 -0400

    drm/i915: Move i915_gem_debugfs.c to i915_debugfs.c
    
    Signed-off-by: Ben Gamari <bgamari.foss@gmail.com>
    [anholt: hand-applied for conflicts]
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index fc4b68aa2d05..263636e77e61 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -188,8 +188,8 @@ static struct drm_driver driver = {
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,
 #if defined(CONFIG_DEBUG_FS)
-	.debugfs_init = i915_gem_debugfs_init,
-	.debugfs_cleanup = i915_gem_debugfs_cleanup,
+	.debugfs_init = i915_debugfs_init,
+	.debugfs_cleanup = i915_debugfs_cleanup,
 #endif
 	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,

commit 354ff96772540d2e836194bf14dd9c05c274055c
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Wed Jul 8 14:13:12 2009 +0800

    drm/i915: Restore the KMS modeset for every activated CRTC
    
    Restore the modeset for every activated CRTC in course of resume.
    This is realized by calling the function of drm_helper_resume_force_mode.
    Note: it is meaningful only for the KMS mode.
    
    https://bugs.freedesktop.org/show_bug.cgi?id=21719
    https://bugs.freedesktop.org/show_bug.cgi?id=21708
    https://bugs.freedesktop.org/show_bug.cgi?id=22285
    https://bugs.freedesktop.org/show_bug.cgi?id=22263
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aef2a261a837..fc4b68aa2d05 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -35,6 +35,7 @@
 
 #include "drm_pciids.h"
 #include <linux/console.h>
+#include "drm_crtc_helper.h"
 
 static unsigned int i915_modeset = -1;
 module_param_named(modeset, i915_modeset, int, 0400);
@@ -115,6 +116,10 @@ static int i915_resume(struct drm_device *dev)
 
 		drm_irq_install(dev);
 	}
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		/* Resume the modeset for every activated CRTC */
+		drm_helper_resume_force_mode(dev);
+	}
 
 	return ret;
 }

commit 1ae8c0a56eeb3ed358b78ccadd024d6b721f26bc
Author: Keith Packard <keithp@keithp.com>
Date:   Sun Jun 28 15:42:17 2009 -0700

    drm/i915: Make driver less chatty
    
    Convert many printk calls to DRM_DEBUG calls to reduce kernel log noise
    for normal activities. Switch other printk calls to DRM_ERROR or DRM_INFO.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e3cb4025e323..aef2a261a837 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -57,8 +57,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	if (!dev || !dev_priv) {
-		printk(KERN_ERR "dev: %p, dev_priv: %p\n", dev, dev_priv);
-		printk(KERN_ERR "DRM not initialized, aborting suspend.\n");
+		DRM_ERROR("dev: %p, dev_priv: %p\n", dev, dev_priv);
+		DRM_ERROR("DRM not initialized, aborting suspend.\n");
 		return -ENODEV;
 	}
 

commit 9e06dd39f2b6d7e35981e0d7aded618686b32ccb
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Jun 22 18:05:12 2009 -0700

    drm/i915: correct suspend/resume ordering
    
    We need to save register state *after* idling GEM, clearing the ring,
    and uninstalling the IRQ handler, or we might end up saving bogus
    fence regs, for one.  Our restore ordering should already be correct,
    since we do GEM, ring and IRQ init after restoring the last register
    state, which prevents us from clobbering things.
    
    I put this together to potentially address a bug, but I haven't heard
    back if it fixes it yet.  However I think it stands on its own, so I'm
    sending it in.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 98560e1e899a..e3cb4025e323 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -67,8 +67,6 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 	pci_save_state(dev->pdev);
 
-	i915_save_state(dev);
-
 	/* If KMS is active, we do the leavevt stuff here */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
 		if (i915_gem_idle(dev))
@@ -77,6 +75,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		drm_irq_uninstall(dev);
 	}
 
+	i915_save_state(dev);
+
 	intel_opregion_free(dev, 1);
 
 	if (state.event == PM_EVENT_SUSPEND) {

commit 3b1c1c1118880921da1188b7245e0470742802f8
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Wed Apr 1 19:52:29 2009 +0100

    drm/i915: Unregister ACPI video driver when exiting
    
    The i915 DRM triggers registration of the ACPI video driver on load. It
    should unregister it at unload in order to avoid generating backtraces on
    being reloaded.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6503e2210f65..98560e1e899a 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -77,7 +77,7 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		drm_irq_uninstall(dev);
 	}
 
-	intel_opregion_free(dev);
+	intel_opregion_free(dev, 1);
 
 	if (state.event == PM_EVENT_SUSPEND) {
 		/* Shut down the device */

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 74a365b3f354fafc537efa5867deb7a9fadbfe27
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Thu Mar 19 21:35:39 2009 +0000

    ACPI: Populate DIDL before registering ACPI video device on Intel
    
    Intel graphics hardware that implements the ACPI IGD OpRegion spec
    requires that the list of display devices be populated before any ACPI
    video methods are called. Detect when this is the case and defer
    registration until the opregion code calls it. Fixes crashes on HP
    laptops.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=11259
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b293ef0bae71..209592fdb7e7 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -99,7 +99,7 @@ static int i915_resume(struct drm_device *dev)
 
 	i915_restore_state(dev);
 
-	intel_opregion_init(dev);
+	intel_opregion_init(dev, 1);
 
 	/* KMS EnterVT equivalent */
 	if (drm_core_check_feature(dev, DRIVER_MODESET)) {

commit 955b12def42e83287c1bdb1411d99451753c1391
Author: Ben Gamari <bgamari@gmail.com>
Date:   Tue Feb 17 20:08:49 2009 -0500

    drm: Convert proc files to seq_file and introduce debugfs
    
    The old mechanism to formatting proc files is extremely ugly. The
    seq_file API was designed specifically for cases like this and greatly
    simplifies the process.
    
    Also, most of the files in /proc really don't belong there. This patch
    introduces the infrastructure for putting these into debugfs and exposes
    all of the proc files in debugfs as well.
    
    This contains the i915 hooks rewrite as well, to make bisectability better.
    
    Signed-off-by: Ben Gamari <bgamari@gmail.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d10ec9e5033c..2c0167693450 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -182,8 +182,10 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.master_create = i915_master_create,
 	.master_destroy = i915_master_destroy,
-	.proc_init = i915_gem_proc_init,
-	.proc_cleanup = i915_gem_proc_cleanup,
+#if defined(CONFIG_DEBUG_FS)
+	.debugfs_init = i915_gem_debugfs_init,
+	.debugfs_cleanup = i915_gem_debugfs_cleanup,
+#endif
 	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,
 	.gem_vm_ops = &i915_gem_vm_ops,

commit 112b715e8e2f9ef7b96930888bb099ce10b4c3cc
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Sun Jan 4 16:55:33 2009 -0500

    drm: claim PCI device when running in modesetting mode.
    
    Under kernel modesetting, we manage the device at all times, regardless
    of VT switching and X servers, so the only decent thing to do is to
    claim the PCI device.  In that case, we call the suspend/resume hooks
    directly from the pci driver hooks instead of the current class device detour.
    
    Signed-off-by: Kristian Høgsberg <krh@redhat.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index b293ef0bae71..d10ec9e5033c 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -42,6 +42,8 @@ module_param_named(modeset, i915_modeset, int, 0400);
 unsigned int i915_fbpercrtc = 0;
 module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
+static struct drm_driver driver;
+
 static struct pci_device_id pciidlist[] = {
 	i915_PCI_IDS
 };
@@ -117,6 +119,36 @@ static int i915_resume(struct drm_device *dev)
 	return ret;
 }
 
+static int __devinit
+i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+static void
+i915_pci_remove(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	drm_put_dev(dev);
+}
+
+static int
+i915_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	return i915_suspend(dev, state);
+}
+
+static int
+i915_pci_resume(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	return i915_resume(dev);
+}
+
 static struct vm_operations_struct i915_gem_vm_ops = {
 	.fault = i915_gem_fault,
 	.open = drm_gem_vm_open,
@@ -172,6 +204,12 @@ static struct drm_driver driver = {
 	.pci_driver = {
 		 .name = DRIVER_NAME,
 		 .id_table = pciidlist,
+		 .probe = i915_pci_probe,
+		 .remove = i915_pci_remove,
+#ifdef CONFIG_PM
+		 .resume = i915_pci_resume,
+		 .suspend = i915_pci_suspend,
+#endif
 	},
 
 	.name = DRIVER_NAME,

commit 226485e9a91ee89c941d8cb7714f85644a8071d0
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Feb 23 15:41:09 2009 -0800

    i915: suspend/resume interrupt state
    
    In the KMS case, enter/leavevt won't fix up the interrupt handler for
    us, so we need to do it at suspend/resume time.  Make sure we don't fail
    the resume if the chip is hung either.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 0692622ee2b3..b293ef0bae71 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -68,9 +68,11 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	i915_save_state(dev);
 
 	/* If KMS is active, we do the leavevt stuff here */
-	if (drm_core_check_feature(dev, DRIVER_MODESET) && i915_gem_idle(dev)) {
-		dev_err(&dev->pdev->dev, "GEM idle failed, aborting suspend\n");
-		return -EBUSY;
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		if (i915_gem_idle(dev))
+			dev_err(&dev->pdev->dev,
+				"GEM idle failed, resume may fail\n");
+		drm_irq_uninstall(dev);
 	}
 
 	intel_opregion_free(dev);
@@ -108,6 +110,8 @@ static int i915_resume(struct drm_device *dev)
 		if (ret != 0)
 			ret = -1;
 		mutex_unlock(&dev->struct_mutex);
+
+		drm_irq_install(dev);
 	}
 
 	return ret;

commit 5669fcacc58bf3a7386057addffd280d75380858
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Feb 17 15:13:31 2009 -0800

    drm/i915: suspend/resume GEM when KMS is active
    
    In the KMS case, we need to suspend/resume GEM as well.  So on suspend, make
    sure we idle GEM and stop any new rendering from coming in, and on resume,
    re-init the framebuffer and clear the suspended flag.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a31cbdbc3c54..0692622ee2b3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -27,6 +27,7 @@
  *
  */
 
+#include <linux/device.h>
 #include "drmP.h"
 #include "drm.h"
 #include "i915_drm.h"
@@ -66,6 +67,12 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 	i915_save_state(dev);
 
+	/* If KMS is active, we do the leavevt stuff here */
+	if (drm_core_check_feature(dev, DRIVER_MODESET) && i915_gem_idle(dev)) {
+		dev_err(&dev->pdev->dev, "GEM idle failed, aborting suspend\n");
+		return -EBUSY;
+	}
+
 	intel_opregion_free(dev);
 
 	if (state.event == PM_EVENT_SUSPEND) {
@@ -79,6 +86,9 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 static int i915_resume(struct drm_device *dev)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret = 0;
+
 	pci_set_power_state(dev->pdev, PCI_D0);
 	pci_restore_state(dev->pdev);
 	if (pci_enable_device(dev->pdev))
@@ -89,7 +99,18 @@ static int i915_resume(struct drm_device *dev)
 
 	intel_opregion_init(dev);
 
-	return 0;
+	/* KMS EnterVT equivalent */
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		mutex_lock(&dev->struct_mutex);
+		dev_priv->mm.suspended = 0;
+
+		ret = i915_gem_init_ringbuffer(dev);
+		if (ret != 0)
+			ret = -1;
+		mutex_unlock(&dev->struct_mutex);
+	}
+
+	return ret;
 }
 
 static struct vm_operations_struct i915_gem_vm_ops = {

commit ab00b3e5210954cbaff9207db874a9f03197e3ba
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Feb 11 14:01:46 2009 -0800

    drm/i915: Keep refs on the object over the lifetime of vmas for GTT mmap.
    
    This fixes potential fault at fault time if the object was unreferenced
    while the mapping still existed.  Now, while the mmap_offset only lives
    for the lifetime of the object, the object also stays alive while a vma
    exists that needs it.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index aac12ee31a46..a31cbdbc3c54 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -94,6 +94,8 @@ static int i915_resume(struct drm_device *dev)
 
 static struct vm_operations_struct i915_gem_vm_ops = {
 	.fault = i915_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
 };
 
 static struct drm_driver driver = {

commit 9880b7a527ffbb52f65c2de0a8d4eea86e24775e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Feb 6 10:22:41 2009 -0800

    drm/i915: add get_vblank_counter function for GM45
    
    As discussed in the long thread about vblank related timeouts, it turns out
    GM45 has different frame count registers than previous chips.  This patch
    adds support for them, which prevents us from waiting on really stale
    sequence values in drm_wait_vblank (which rather than returning immediately
    ends up timing out or getting interrupted).
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index f8b3df0926c0..aac12ee31a46 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -112,7 +112,6 @@ static struct drm_driver driver = {
 	.suspend = i915_suspend,
 	.resume = i915_resume,
 	.device_is_agp = i915_driver_device_is_agp,
-	.get_vblank_counter = i915_get_vblank_counter,
 	.enable_vblank = i915_enable_vblank,
 	.disable_vblank = i915_disable_vblank,
 	.irq_preinstall = i915_driver_irq_preinstall,

commit b358d0a6252d8ed16afb20caaec35b24c76074bb
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Thu Dec 18 21:18:47 2008 +0100

    drm/i915: fix sparse warnings: make symbols static
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index cbee41c32417..f8b3df0926c0 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -35,7 +35,7 @@
 #include "drm_pciids.h"
 #include <linux/console.h>
 
-unsigned int i915_modeset = -1;
+static unsigned int i915_modeset = -1;
 module_param_named(modeset, i915_modeset, int, 0400);
 
 unsigned int i915_fbpercrtc = 0;

commit 79e539453b34e35f39299a899d263b0a1f1670bd
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Nov 7 14:24:08 2008 -0800

    DRM: i915: add mode setting support
    
    This commit adds i915 driver support for the DRM mode setting APIs.
    Currently, VGA, LVDS, SDVO DVI & VGA, TV and DVO LVDS outputs are
    supported.  HDMI, DisplayPort and additional SDVO output support will
    follow.
    
    Support for the mode setting code is controlled by the new 'modeset'
    module option.  A new config option, CONFIG_DRM_I915_KMS controls the
    default behavior, and whether a PCI ID list is built into the module for
    use by user level module utilities.
    
    Note that if mode setting is enabled, user level drivers that access
    display registers directly or that don't use the kernel graphics memory
    manager will likely corrupt kernel graphics memory, disrupt output
    configuration (possibly leading to hangs and/or blank displays), and
    prevent panic/oops messages from appearing.  So use caution when
    enabling this code; be sure your user level code supports the new
    interfaces.
    
    A new SysRq key, 'g', provides emergency support for switching back to
    the kernel's framebuffer console; which is useful for testing.
    
    Co-authors: Dave Airlie <airlied@linux.ie>, Hong Liu <hong.liu@intel.com>
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index e0d996ed9026..cbee41c32417 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -33,11 +33,22 @@
 #include "i915_drv.h"
 
 #include "drm_pciids.h"
+#include <linux/console.h>
+
+unsigned int i915_modeset = -1;
+module_param_named(modeset, i915_modeset, int, 0400);
+
+unsigned int i915_fbpercrtc = 0;
+module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
 
 static struct pci_device_id pciidlist[] = {
 	i915_PCI_IDS
 };
 
+#if defined(CONFIG_DRM_I915_KMS)
+MODULE_DEVICE_TABLE(pci, pciidlist);
+#endif
+
 static int i915_suspend(struct drm_device *dev, pm_message_t state)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -148,6 +159,28 @@ static struct drm_driver driver = {
 static int __init i915_init(void)
 {
 	driver.num_ioctls = i915_max_ioctl;
+
+	/*
+	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless
+	 * explicitly disabled with the module pararmeter.
+	 *
+	 * Otherwise, just follow the parameter (defaulting to off).
+	 *
+	 * Allow optional vga_text_mode_force boot option to override
+	 * the default behavior.
+	 */
+#if defined(CONFIG_DRM_I915_KMS)
+	if (i915_modeset != 0)
+		driver.driver_features |= DRIVER_MODESET;
+#endif
+	if (i915_modeset == 1)
+		driver.driver_features |= DRIVER_MODESET;
+
+#ifdef CONFIG_VGA_CONSOLE
+	if (vgacon_text_force() && i915_modeset == -1)
+		driver.driver_features &= ~DRIVER_MODESET;
+#endif
+
 	return drm_init(&driver);
 }
 

commit de151cf67ce52ed2d88083daa5e60c7858947329
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Nov 12 10:03:55 2008 -0800

    drm/i915: add GEM GTT mapping support
    
    Use the new core GEM object mapping code to allow GTT mapping of GEM
    objects on i915.  The fault handler will make sure a fence register is
    allocated too, if the object in question is tiled.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index c91648320a8b..e0d996ed9026 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -81,6 +81,10 @@ static int i915_resume(struct drm_device *dev)
 	return 0;
 }
 
+static struct vm_operations_struct i915_gem_vm_ops = {
+	.fault = i915_gem_fault,
+};
+
 static struct drm_driver driver = {
 	/* don't use mtrr's here, the Xserver or user space app should
 	 * deal with them for intel hardware.
@@ -113,13 +117,14 @@ static struct drm_driver driver = {
 	.proc_cleanup = i915_gem_proc_cleanup,
 	.gem_init_object = i915_gem_init_object,
 	.gem_free_object = i915_gem_free_object,
+	.gem_vm_ops = &i915_gem_vm_ops,
 	.ioctls = i915_ioctls,
 	.fops = {
 		 .owner = THIS_MODULE,
 		 .open = drm_open,
 		 .release = drm_release,
 		 .ioctl = drm_ioctl,
-		 .mmap = drm_mmap,
+		 .mmap = drm_gem_mmap,
 		 .poll = drm_poll,
 		 .fasync = drm_fasync,
 #ifdef CONFIG_COMPAT

commit 7c1c2871a6a3a114853ec6836e9035ac1c0c7f7a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Nov 28 14:22:24 2008 +1000

    drm: move to kref per-master structures.
    
    This is step one towards having multiple masters sharing a drm
    device in order to get fast-user-switching to work.
    
    It splits out the information associated with the drm master
    into a separate kref counted structure, and allocates this when
    a master opens the device node. It also allows the current master
    to abdicate (say while VT switched), and a new master to take over
    the hardware.
    
    It moves the Intel and radeon drivers to using the sarea from
    within the new master structures.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index a80ead215282..c91648320a8b 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -107,6 +107,8 @@ static struct drm_driver driver = {
 	.reclaim_buffers = drm_core_reclaim_buffers,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
+	.master_create = i915_master_create,
+	.master_destroy = i915_master_destroy,
 	.proc_init = i915_gem_proc_init,
 	.proc_cleanup = i915_gem_proc_cleanup,
 	.gem_init_object = i915_gem_init_object,

commit 673a394b1e3b69be886ff24abfd6df97c52e8d08
Author: Eric Anholt <eric@anholt.net>
Date:   Wed Jul 30 12:06:12 2008 -0700

    drm: Add GEM ("graphics execution manager") to i915 driver.
    
    GEM allows the creation of persistent buffer objects accessible by the
    graphics device through new ioctls for managing execution of commands on the
    device.  The userland API is almost entirely driver-specific to ensure that
    any driver building on this model can easily map the interface to individual
    driver requirements.
    
    GEM is used by the 2d driver for managing its internal state allocations and
    will be used for pixmap storage to reduce memory consumption and enable
    zero-copy GLX_EXT_texture_from_pixmap, and in the 3d driver is used to enable
    GL_EXT_framebuffer_object and GL_ARB_pixel_buffer_object.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 37af03f4db36..a80ead215282 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -85,12 +85,15 @@ static struct drm_driver driver = {
 	/* don't use mtrr's here, the Xserver or user space app should
 	 * deal with them for intel hardware.
 	 */
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP |
-		DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,
+	.open = i915_driver_open,
 	.lastclose = i915_driver_lastclose,
 	.preclose = i915_driver_preclose,
+	.postclose = i915_driver_postclose,
 	.suspend = i915_suspend,
 	.resume = i915_resume,
 	.device_is_agp = i915_driver_device_is_agp,
@@ -104,6 +107,10 @@ static struct drm_driver driver = {
 	.reclaim_buffers = drm_core_reclaim_buffers,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
+	.proc_init = i915_gem_proc_init,
+	.proc_cleanup = i915_gem_proc_cleanup,
+	.gem_init_object = i915_gem_init_object,
+	.gem_free_object = i915_gem_free_object,
 	.ioctls = i915_ioctls,
 	.fops = {
 		 .owner = THIS_MODULE,

commit 0a3e67a4caac273a3bfc4ced3da364830b1ab241
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Sep 30 12:14:26 2008 -0700

    drm: Rework vblank-wait handling to allow interrupt reduction.
    
    Previously, drivers supporting vblank interrupt waits would run the interrupt
    all the time, or all the time that any 3d client was running, preventing the
    CPU from sleeping for long when the system was otherwise idle.  Now, interrupts
    are disabled any time that no client is waiting on a vblank event. The new
    method uses vblank counters on the chipsets when the interrupts are turned
    off, rather than counting interrupts, so that we can continue to present
    accurate vblank numbers.
    
    Co-author: Michel Dänzer <michel@tungstengraphics.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index eff66ed3e58e..37af03f4db36 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -85,10 +85,8 @@ static struct drm_driver driver = {
 	/* don't use mtrr's here, the Xserver or user space app should
 	 * deal with them for intel hardware.
 	 */
-	.driver_features =
-	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL |
-	    DRIVER_IRQ_VBL2,
+	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP |
+		DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
 	.load = i915_driver_load,
 	.unload = i915_driver_unload,
 	.lastclose = i915_driver_lastclose,
@@ -96,8 +94,9 @@ static struct drm_driver driver = {
 	.suspend = i915_suspend,
 	.resume = i915_resume,
 	.device_is_agp = i915_driver_device_is_agp,
-	.vblank_wait = i915_driver_vblank_wait,
-	.vblank_wait2 = i915_driver_vblank_wait2,
+	.get_vblank_counter = i915_get_vblank_counter,
+	.enable_vblank = i915_enable_vblank,
+	.disable_vblank = i915_disable_vblank,
 	.irq_preinstall = i915_driver_irq_preinstall,
 	.irq_postinstall = i915_driver_irq_postinstall,
 	.irq_uninstall = i915_driver_irq_uninstall,

commit 317c35d1446f68b34d4de4e1100fc01680bd4877
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Aug 25 15:11:06 2008 -0700

    separate i915 suspend/resume functions into their own file
    
    [Patch against drm-next.  Consider this a trial balloon for our new Linux
    development model.]
    
    This is a big chunk of code.  Separating it out makes it easier to change
    without churn on the main i915_drv.c file (and there will be churn as we
    fix bugs and add things like kernel mode setting).  Also makes it easier
    to share this file with BSD.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index d95eca2bc454..eff66ed3e58e 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -38,211 +38,9 @@ static struct pci_device_id pciidlist[] = {
 	i915_PCI_IDS
 };
 
-enum pipe {
-    PIPE_A = 0,
-    PIPE_B,
-};
-
-static bool i915_pipe_enabled(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
-	if (pipe == PIPE_A)
-		return (I915_READ(DPLL_A) & DPLL_VCO_ENABLE);
-	else
-		return (I915_READ(DPLL_B) & DPLL_VCO_ENABLE);
-}
-
-static void i915_save_palette(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
-	u32 *array;
-	int i;
-
-	if (!i915_pipe_enabled(dev, pipe))
-		return;
-
-	if (pipe == PIPE_A)
-		array = dev_priv->save_palette_a;
-	else
-		array = dev_priv->save_palette_b;
-
-	for(i = 0; i < 256; i++)
-		array[i] = I915_READ(reg + (i << 2));
-}
-
-static void i915_restore_palette(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
-	u32 *array;
-	int i;
-
-	if (!i915_pipe_enabled(dev, pipe))
-		return;
-
-	if (pipe == PIPE_A)
-		array = dev_priv->save_palette_a;
-	else
-		array = dev_priv->save_palette_b;
-
-	for(i = 0; i < 256; i++)
-		I915_WRITE(reg + (i << 2), array[i]);
-}
-
-static u8 i915_read_indexed(u16 index_port, u16 data_port, u8 reg)
-{
-	outb(reg, index_port);
-	return inb(data_port);
-}
-
-static u8 i915_read_ar(u16 st01, u8 reg, u16 palette_enable)
-{
-	inb(st01);
-	outb(palette_enable | reg, VGA_AR_INDEX);
-	return inb(VGA_AR_DATA_READ);
-}
-
-static void i915_write_ar(u8 st01, u8 reg, u8 val, u16 palette_enable)
-{
-	inb(st01);
-	outb(palette_enable | reg, VGA_AR_INDEX);
-	outb(val, VGA_AR_DATA_WRITE);
-}
-
-static void i915_write_indexed(u16 index_port, u16 data_port, u8 reg, u8 val)
-{
-	outb(reg, index_port);
-	outb(val, data_port);
-}
-
-static void i915_save_vga(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-	u16 cr_index, cr_data, st01;
-
-	/* VGA color palette registers */
-	dev_priv->saveDACMASK = inb(VGA_DACMASK);
-	/* DACCRX automatically increments during read */
-	outb(0, VGA_DACRX);
-	/* Read 3 bytes of color data from each index */
-	for (i = 0; i < 256 * 3; i++)
-		dev_priv->saveDACDATA[i] = inb(VGA_DACDATA);
-
-	/* MSR bits */
-	dev_priv->saveMSR = inb(VGA_MSR_READ);
-	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
-		cr_index = VGA_CR_INDEX_CGA;
-		cr_data = VGA_CR_DATA_CGA;
-		st01 = VGA_ST01_CGA;
-	} else {
-		cr_index = VGA_CR_INDEX_MDA;
-		cr_data = VGA_CR_DATA_MDA;
-		st01 = VGA_ST01_MDA;
-	}
-
-	/* CRT controller regs */
-	i915_write_indexed(cr_index, cr_data, 0x11,
-			   i915_read_indexed(cr_index, cr_data, 0x11) &
-			   (~0x80));
-	for (i = 0; i <= 0x24; i++)
-		dev_priv->saveCR[i] =
-			i915_read_indexed(cr_index, cr_data, i);
-	/* Make sure we don't turn off CR group 0 writes */
-	dev_priv->saveCR[0x11] &= ~0x80;
-
-	/* Attribute controller registers */
-	inb(st01);
-	dev_priv->saveAR_INDEX = inb(VGA_AR_INDEX);
-	for (i = 0; i <= 0x14; i++)
-		dev_priv->saveAR[i] = i915_read_ar(st01, i, 0);
-	inb(st01);
-	outb(dev_priv->saveAR_INDEX, VGA_AR_INDEX);
-	inb(st01);
-
-	/* Graphics controller registers */
-	for (i = 0; i < 9; i++)
-		dev_priv->saveGR[i] =
-			i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, i);
-
-	dev_priv->saveGR[0x10] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10);
-	dev_priv->saveGR[0x11] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11);
-	dev_priv->saveGR[0x18] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18);
-
-	/* Sequencer registers */
-	for (i = 0; i < 8; i++)
-		dev_priv->saveSR[i] =
-			i915_read_indexed(VGA_SR_INDEX, VGA_SR_DATA, i);
-}
-
-static void i915_restore_vga(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-	u16 cr_index, cr_data, st01;
-
-	/* MSR bits */
-	outb(dev_priv->saveMSR, VGA_MSR_WRITE);
-	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
-		cr_index = VGA_CR_INDEX_CGA;
-		cr_data = VGA_CR_DATA_CGA;
-		st01 = VGA_ST01_CGA;
-	} else {
-		cr_index = VGA_CR_INDEX_MDA;
-		cr_data = VGA_CR_DATA_MDA;
-		st01 = VGA_ST01_MDA;
-	}
-
-	/* Sequencer registers, don't write SR07 */
-	for (i = 0; i < 7; i++)
-		i915_write_indexed(VGA_SR_INDEX, VGA_SR_DATA, i,
-				   dev_priv->saveSR[i]);
-
-	/* CRT controller regs */
-	/* Enable CR group 0 writes */
-	i915_write_indexed(cr_index, cr_data, 0x11, dev_priv->saveCR[0x11]);
-	for (i = 0; i <= 0x24; i++)
-		i915_write_indexed(cr_index, cr_data, i, dev_priv->saveCR[i]);
-
-	/* Graphics controller regs */
-	for (i = 0; i < 9; i++)
-		i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, i,
-				   dev_priv->saveGR[i]);
-
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10,
-			   dev_priv->saveGR[0x10]);
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11,
-			   dev_priv->saveGR[0x11]);
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18,
-			   dev_priv->saveGR[0x18]);
-
-	/* Attribute controller registers */
-	inb(st01);
-	for (i = 0; i <= 0x14; i++)
-		i915_write_ar(st01, i, dev_priv->saveAR[i], 0);
-	inb(st01); /* switch back to index mode */
-	outb(dev_priv->saveAR_INDEX | 0x20, VGA_AR_INDEX);
-	inb(st01);
-
-	/* VGA color palette registers */
-	outb(dev_priv->saveDACMASK, VGA_DACMASK);
-	/* DACCRX automatically increments during read */
-	outb(0, VGA_DACWX);
-	/* Read 3 bytes of color data from each index */
-	for (i = 0; i < 256 * 3; i++)
-		outb(dev_priv->saveDACDATA[i], VGA_DACDATA);
-
-}
-
 static int i915_suspend(struct drm_device *dev, pm_message_t state)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
 
 	if (!dev || !dev_priv) {
 		printk(KERN_ERR "dev: %p, dev_priv: %p\n", dev, dev_priv);
@@ -254,122 +52,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		return 0;
 
 	pci_save_state(dev->pdev);
-	pci_read_config_byte(dev->pdev, LBB, &dev_priv->saveLBB);
-
-	/* Display arbitration control */
-	dev_priv->saveDSPARB = I915_READ(DSPARB);
-
-	/* Pipe & plane A info */
-	dev_priv->savePIPEACONF = I915_READ(PIPEACONF);
-	dev_priv->savePIPEASRC = I915_READ(PIPEASRC);
-	dev_priv->saveFPA0 = I915_READ(FPA0);
-	dev_priv->saveFPA1 = I915_READ(FPA1);
-	dev_priv->saveDPLL_A = I915_READ(DPLL_A);
-	if (IS_I965G(dev))
-		dev_priv->saveDPLL_A_MD = I915_READ(DPLL_A_MD);
-	dev_priv->saveHTOTAL_A = I915_READ(HTOTAL_A);
-	dev_priv->saveHBLANK_A = I915_READ(HBLANK_A);
-	dev_priv->saveHSYNC_A = I915_READ(HSYNC_A);
-	dev_priv->saveVTOTAL_A = I915_READ(VTOTAL_A);
-	dev_priv->saveVBLANK_A = I915_READ(VBLANK_A);
-	dev_priv->saveVSYNC_A = I915_READ(VSYNC_A);
-	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
-
-	dev_priv->saveDSPACNTR = I915_READ(DSPACNTR);
-	dev_priv->saveDSPASTRIDE = I915_READ(DSPASTRIDE);
-	dev_priv->saveDSPASIZE = I915_READ(DSPASIZE);
-	dev_priv->saveDSPAPOS = I915_READ(DSPAPOS);
-	dev_priv->saveDSPAADDR = I915_READ(DSPAADDR);
-	if (IS_I965G(dev)) {
-		dev_priv->saveDSPASURF = I915_READ(DSPASURF);
-		dev_priv->saveDSPATILEOFF = I915_READ(DSPATILEOFF);
-	}
-	i915_save_palette(dev, PIPE_A);
-	dev_priv->savePIPEASTAT = I915_READ(PIPEASTAT);
-
-	/* Pipe & plane B info */
-	dev_priv->savePIPEBCONF = I915_READ(PIPEBCONF);
-	dev_priv->savePIPEBSRC = I915_READ(PIPEBSRC);
-	dev_priv->saveFPB0 = I915_READ(FPB0);
-	dev_priv->saveFPB1 = I915_READ(FPB1);
-	dev_priv->saveDPLL_B = I915_READ(DPLL_B);
-	if (IS_I965G(dev))
-		dev_priv->saveDPLL_B_MD = I915_READ(DPLL_B_MD);
-	dev_priv->saveHTOTAL_B = I915_READ(HTOTAL_B);
-	dev_priv->saveHBLANK_B = I915_READ(HBLANK_B);
-	dev_priv->saveHSYNC_B = I915_READ(HSYNC_B);
-	dev_priv->saveVTOTAL_B = I915_READ(VTOTAL_B);
-	dev_priv->saveVBLANK_B = I915_READ(VBLANK_B);
-	dev_priv->saveVSYNC_B = I915_READ(VSYNC_B);
-	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
-
-	dev_priv->saveDSPBCNTR = I915_READ(DSPBCNTR);
-	dev_priv->saveDSPBSTRIDE = I915_READ(DSPBSTRIDE);
-	dev_priv->saveDSPBSIZE = I915_READ(DSPBSIZE);
-	dev_priv->saveDSPBPOS = I915_READ(DSPBPOS);
-	dev_priv->saveDSPBADDR = I915_READ(DSPBADDR);
-	if (IS_I965GM(dev) || IS_IGD_GM(dev)) {
-		dev_priv->saveDSPBSURF = I915_READ(DSPBSURF);
-		dev_priv->saveDSPBTILEOFF = I915_READ(DSPBTILEOFF);
-	}
-	i915_save_palette(dev, PIPE_B);
-	dev_priv->savePIPEBSTAT = I915_READ(PIPEBSTAT);
-
-	/* CRT state */
-	dev_priv->saveADPA = I915_READ(ADPA);
 
-	/* LVDS state */
-	dev_priv->savePP_CONTROL = I915_READ(PP_CONTROL);
-	dev_priv->savePFIT_PGM_RATIOS = I915_READ(PFIT_PGM_RATIOS);
-	dev_priv->saveBLC_PWM_CTL = I915_READ(BLC_PWM_CTL);
-	if (IS_I965G(dev))
-		dev_priv->saveBLC_PWM_CTL2 = I915_READ(BLC_PWM_CTL2);
-	if (IS_MOBILE(dev) && !IS_I830(dev))
-		dev_priv->saveLVDS = I915_READ(LVDS);
-	if (!IS_I830(dev) && !IS_845G(dev))
-		dev_priv->savePFIT_CONTROL = I915_READ(PFIT_CONTROL);
-	dev_priv->savePP_ON_DELAYS = I915_READ(PP_ON_DELAYS);
-	dev_priv->savePP_OFF_DELAYS = I915_READ(PP_OFF_DELAYS);
-	dev_priv->savePP_DIVISOR = I915_READ(PP_DIVISOR);
-
-	/* FIXME: save TV & SDVO state */
-
-	/* FBC state */
-	dev_priv->saveFBC_CFB_BASE = I915_READ(FBC_CFB_BASE);
-	dev_priv->saveFBC_LL_BASE = I915_READ(FBC_LL_BASE);
-	dev_priv->saveFBC_CONTROL2 = I915_READ(FBC_CONTROL2);
-	dev_priv->saveFBC_CONTROL = I915_READ(FBC_CONTROL);
-
-	/* Interrupt state */
-	dev_priv->saveIIR = I915_READ(IIR);
-	dev_priv->saveIER = I915_READ(IER);
-	dev_priv->saveIMR = I915_READ(IMR);
-
-	/* VGA state */
-	dev_priv->saveVGA0 = I915_READ(VGA0);
-	dev_priv->saveVGA1 = I915_READ(VGA1);
-	dev_priv->saveVGA_PD = I915_READ(VGA_PD);
-	dev_priv->saveVGACNTRL = I915_READ(VGACNTRL);
-
-	/* Clock gating state */
-	dev_priv->saveD_STATE = I915_READ(D_STATE);
-	dev_priv->saveCG_2D_DIS = I915_READ(CG_2D_DIS);
-
-	/* Cache mode state */
-	dev_priv->saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
-
-	/* Memory Arbitration state */
-	dev_priv->saveMI_ARB_STATE = I915_READ(MI_ARB_STATE);
-
-	/* Scratch space */
-	for (i = 0; i < 16; i++) {
-		dev_priv->saveSWF0[i] = I915_READ(SWF00 + (i << 2));
-		dev_priv->saveSWF1[i] = I915_READ(SWF10 + (i << 2));
-	}
-	for (i = 0; i < 3; i++)
-		dev_priv->saveSWF2[i] = I915_READ(SWF30 + (i << 2));
-
-	i915_save_vga(dev);
+	i915_save_state(dev);
 
 	intel_opregion_free(dev);
 
@@ -384,155 +68,13 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 static int i915_resume(struct drm_device *dev)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-
 	pci_set_power_state(dev->pdev, PCI_D0);
 	pci_restore_state(dev->pdev);
 	if (pci_enable_device(dev->pdev))
 		return -1;
 	pci_set_master(dev->pdev);
 
-	pci_write_config_byte(dev->pdev, LBB, dev_priv->saveLBB);
-
-	I915_WRITE(DSPARB, dev_priv->saveDSPARB);
-
-	/* Pipe & plane A info */
-	/* Prime the clock */
-	if (dev_priv->saveDPLL_A & DPLL_VCO_ENABLE) {
-		I915_WRITE(DPLL_A, dev_priv->saveDPLL_A &
-			   ~DPLL_VCO_ENABLE);
-		udelay(150);
-	}
-	I915_WRITE(FPA0, dev_priv->saveFPA0);
-	I915_WRITE(FPA1, dev_priv->saveFPA1);
-	/* Actually enable it */
-	I915_WRITE(DPLL_A, dev_priv->saveDPLL_A);
-	udelay(150);
-	if (IS_I965G(dev))
-		I915_WRITE(DPLL_A_MD, dev_priv->saveDPLL_A_MD);
-	udelay(150);
-
-	/* Restore mode */
-	I915_WRITE(HTOTAL_A, dev_priv->saveHTOTAL_A);
-	I915_WRITE(HBLANK_A, dev_priv->saveHBLANK_A);
-	I915_WRITE(HSYNC_A, dev_priv->saveHSYNC_A);
-	I915_WRITE(VTOTAL_A, dev_priv->saveVTOTAL_A);
-	I915_WRITE(VBLANK_A, dev_priv->saveVBLANK_A);
-	I915_WRITE(VSYNC_A, dev_priv->saveVSYNC_A);
-	I915_WRITE(BCLRPAT_A, dev_priv->saveBCLRPAT_A);
-
-	/* Restore plane info */
-	I915_WRITE(DSPASIZE, dev_priv->saveDSPASIZE);
-	I915_WRITE(DSPAPOS, dev_priv->saveDSPAPOS);
-	I915_WRITE(PIPEASRC, dev_priv->savePIPEASRC);
-	I915_WRITE(DSPAADDR, dev_priv->saveDSPAADDR);
-	I915_WRITE(DSPASTRIDE, dev_priv->saveDSPASTRIDE);
-	if (IS_I965G(dev)) {
-		I915_WRITE(DSPASURF, dev_priv->saveDSPASURF);
-		I915_WRITE(DSPATILEOFF, dev_priv->saveDSPATILEOFF);
-	}
-
-	I915_WRITE(PIPEACONF, dev_priv->savePIPEACONF);
-
-	i915_restore_palette(dev, PIPE_A);
-	/* Enable the plane */
-	I915_WRITE(DSPACNTR, dev_priv->saveDSPACNTR);
-	I915_WRITE(DSPAADDR, I915_READ(DSPAADDR));
-
-	/* Pipe & plane B info */
-	if (dev_priv->saveDPLL_B & DPLL_VCO_ENABLE) {
-		I915_WRITE(DPLL_B, dev_priv->saveDPLL_B &
-			   ~DPLL_VCO_ENABLE);
-		udelay(150);
-	}
-	I915_WRITE(FPB0, dev_priv->saveFPB0);
-	I915_WRITE(FPB1, dev_priv->saveFPB1);
-	/* Actually enable it */
-	I915_WRITE(DPLL_B, dev_priv->saveDPLL_B);
-	udelay(150);
-	if (IS_I965G(dev))
-		I915_WRITE(DPLL_B_MD, dev_priv->saveDPLL_B_MD);
-	udelay(150);
-
-	/* Restore mode */
-	I915_WRITE(HTOTAL_B, dev_priv->saveHTOTAL_B);
-	I915_WRITE(HBLANK_B, dev_priv->saveHBLANK_B);
-	I915_WRITE(HSYNC_B, dev_priv->saveHSYNC_B);
-	I915_WRITE(VTOTAL_B, dev_priv->saveVTOTAL_B);
-	I915_WRITE(VBLANK_B, dev_priv->saveVBLANK_B);
-	I915_WRITE(VSYNC_B, dev_priv->saveVSYNC_B);
-	I915_WRITE(BCLRPAT_B, dev_priv->saveBCLRPAT_B);
-
-	/* Restore plane info */
-	I915_WRITE(DSPBSIZE, dev_priv->saveDSPBSIZE);
-	I915_WRITE(DSPBPOS, dev_priv->saveDSPBPOS);
-	I915_WRITE(PIPEBSRC, dev_priv->savePIPEBSRC);
-	I915_WRITE(DSPBADDR, dev_priv->saveDSPBADDR);
-	I915_WRITE(DSPBSTRIDE, dev_priv->saveDSPBSTRIDE);
-	if (IS_I965G(dev)) {
-		I915_WRITE(DSPBSURF, dev_priv->saveDSPBSURF);
-		I915_WRITE(DSPBTILEOFF, dev_priv->saveDSPBTILEOFF);
-	}
-
-	I915_WRITE(PIPEBCONF, dev_priv->savePIPEBCONF);
-
-	i915_restore_palette(dev, PIPE_B);
-	/* Enable the plane */
-	I915_WRITE(DSPBCNTR, dev_priv->saveDSPBCNTR);
-	I915_WRITE(DSPBADDR, I915_READ(DSPBADDR));
-
-	/* CRT state */
-	I915_WRITE(ADPA, dev_priv->saveADPA);
-
-	/* LVDS state */
-	if (IS_I965G(dev))
-		I915_WRITE(BLC_PWM_CTL2, dev_priv->saveBLC_PWM_CTL2);
-	if (IS_MOBILE(dev) && !IS_I830(dev))
-		I915_WRITE(LVDS, dev_priv->saveLVDS);
-	if (!IS_I830(dev) && !IS_845G(dev))
-		I915_WRITE(PFIT_CONTROL, dev_priv->savePFIT_CONTROL);
-
-	I915_WRITE(PFIT_PGM_RATIOS, dev_priv->savePFIT_PGM_RATIOS);
-	I915_WRITE(BLC_PWM_CTL, dev_priv->saveBLC_PWM_CTL);
-	I915_WRITE(PP_ON_DELAYS, dev_priv->savePP_ON_DELAYS);
-	I915_WRITE(PP_OFF_DELAYS, dev_priv->savePP_OFF_DELAYS);
-	I915_WRITE(PP_DIVISOR, dev_priv->savePP_DIVISOR);
-	I915_WRITE(PP_CONTROL, dev_priv->savePP_CONTROL);
-
-	/* FIXME: restore TV & SDVO state */
-
-	/* FBC info */
-	I915_WRITE(FBC_CFB_BASE, dev_priv->saveFBC_CFB_BASE);
-	I915_WRITE(FBC_LL_BASE, dev_priv->saveFBC_LL_BASE);
-	I915_WRITE(FBC_CONTROL2, dev_priv->saveFBC_CONTROL2);
-	I915_WRITE(FBC_CONTROL, dev_priv->saveFBC_CONTROL);
-
-	/* VGA state */
-	I915_WRITE(VGACNTRL, dev_priv->saveVGACNTRL);
-	I915_WRITE(VGA0, dev_priv->saveVGA0);
-	I915_WRITE(VGA1, dev_priv->saveVGA1);
-	I915_WRITE(VGA_PD, dev_priv->saveVGA_PD);
-	udelay(150);
-
-	/* Clock gating state */
-	I915_WRITE (D_STATE, dev_priv->saveD_STATE);
-	I915_WRITE(CG_2D_DIS, dev_priv->saveCG_2D_DIS);
-
-	/* Cache mode state */
-	I915_WRITE (CACHE_MODE_0, dev_priv->saveCACHE_MODE_0 | 0xffff0000);
-
-	/* Memory arbitration state */
-	I915_WRITE (MI_ARB_STATE, dev_priv->saveMI_ARB_STATE | 0xffff0000);
-
-	for (i = 0; i < 16; i++) {
-		I915_WRITE(SWF00 + (i << 2), dev_priv->saveSWF0[i]);
-		I915_WRITE(SWF10 + (i << 2), dev_priv->saveSWF1[i+7]);
-	}
-	for (i = 0; i < 3; i++)
-		I915_WRITE(SWF30 + (i << 2), dev_priv->saveSWF2[i]);
-
-	i915_restore_vga(dev);
+	i915_restore_state(dev);
 
 	intel_opregion_init(dev);
 

commit 8ee1c3db9075cb3211352e737e0feb98fd733b20
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Tue Aug 5 19:37:25 2008 +0100

    Add Intel ACPI IGD OpRegion support
    
    This adds the support necessary for allowing ACPI backlight control to
    work on some newer Intel-based graphics systems. Tested on Thinkpad T61
    and HP 2510p hardware.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 6c99aab12da3..d95eca2bc454 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -371,6 +371,8 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 	i915_save_vga(dev);
 
+	intel_opregion_free(dev);
+
 	if (state.event == PM_EVENT_SUSPEND) {
 		/* Shut down the device */
 		pci_disable_device(dev->pdev);
@@ -532,6 +534,8 @@ static int i915_resume(struct drm_device *dev)
 
 	i915_restore_vga(dev);
 
+	intel_opregion_init(dev);
+
 	return 0;
 }
 

commit 585fb111348f7cdc30c6a1b903987612ddeafb23
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Jul 29 11:54:06 2008 -0700

    i915: Use more consistent names for regs, and store them in a separate file.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 93aed1c38bd2..6c99aab12da3 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -279,13 +279,13 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	dev_priv->saveDSPASTRIDE = I915_READ(DSPASTRIDE);
 	dev_priv->saveDSPASIZE = I915_READ(DSPASIZE);
 	dev_priv->saveDSPAPOS = I915_READ(DSPAPOS);
-	dev_priv->saveDSPABASE = I915_READ(DSPABASE);
+	dev_priv->saveDSPAADDR = I915_READ(DSPAADDR);
 	if (IS_I965G(dev)) {
 		dev_priv->saveDSPASURF = I915_READ(DSPASURF);
 		dev_priv->saveDSPATILEOFF = I915_READ(DSPATILEOFF);
 	}
 	i915_save_palette(dev, PIPE_A);
-	dev_priv->savePIPEASTAT = I915_READ(I915REG_PIPEASTAT);
+	dev_priv->savePIPEASTAT = I915_READ(PIPEASTAT);
 
 	/* Pipe & plane B info */
 	dev_priv->savePIPEBCONF = I915_READ(PIPEBCONF);
@@ -307,13 +307,13 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	dev_priv->saveDSPBSTRIDE = I915_READ(DSPBSTRIDE);
 	dev_priv->saveDSPBSIZE = I915_READ(DSPBSIZE);
 	dev_priv->saveDSPBPOS = I915_READ(DSPBPOS);
-	dev_priv->saveDSPBBASE = I915_READ(DSPBBASE);
+	dev_priv->saveDSPBADDR = I915_READ(DSPBADDR);
 	if (IS_I965GM(dev) || IS_IGD_GM(dev)) {
 		dev_priv->saveDSPBSURF = I915_READ(DSPBSURF);
 		dev_priv->saveDSPBTILEOFF = I915_READ(DSPBTILEOFF);
 	}
 	i915_save_palette(dev, PIPE_B);
-	dev_priv->savePIPEBSTAT = I915_READ(I915REG_PIPEBSTAT);
+	dev_priv->savePIPEBSTAT = I915_READ(PIPEBSTAT);
 
 	/* CRT state */
 	dev_priv->saveADPA = I915_READ(ADPA);
@@ -328,9 +328,9 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 		dev_priv->saveLVDS = I915_READ(LVDS);
 	if (!IS_I830(dev) && !IS_845G(dev))
 		dev_priv->savePFIT_CONTROL = I915_READ(PFIT_CONTROL);
-	dev_priv->saveLVDSPP_ON = I915_READ(LVDSPP_ON);
-	dev_priv->saveLVDSPP_OFF = I915_READ(LVDSPP_OFF);
-	dev_priv->savePP_CYCLE = I915_READ(PP_CYCLE);
+	dev_priv->savePP_ON_DELAYS = I915_READ(PP_ON_DELAYS);
+	dev_priv->savePP_OFF_DELAYS = I915_READ(PP_OFF_DELAYS);
+	dev_priv->savePP_DIVISOR = I915_READ(PP_DIVISOR);
 
 	/* FIXME: save TV & SDVO state */
 
@@ -341,19 +341,19 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 	dev_priv->saveFBC_CONTROL = I915_READ(FBC_CONTROL);
 
 	/* Interrupt state */
-	dev_priv->saveIIR = I915_READ(I915REG_INT_IDENTITY_R);
-	dev_priv->saveIER = I915_READ(I915REG_INT_ENABLE_R);
-	dev_priv->saveIMR = I915_READ(I915REG_INT_MASK_R);
+	dev_priv->saveIIR = I915_READ(IIR);
+	dev_priv->saveIER = I915_READ(IER);
+	dev_priv->saveIMR = I915_READ(IMR);
 
 	/* VGA state */
-	dev_priv->saveVCLK_DIVISOR_VGA0 = I915_READ(VCLK_DIVISOR_VGA0);
-	dev_priv->saveVCLK_DIVISOR_VGA1 = I915_READ(VCLK_DIVISOR_VGA1);
-	dev_priv->saveVCLK_POST_DIV = I915_READ(VCLK_POST_DIV);
+	dev_priv->saveVGA0 = I915_READ(VGA0);
+	dev_priv->saveVGA1 = I915_READ(VGA1);
+	dev_priv->saveVGA_PD = I915_READ(VGA_PD);
 	dev_priv->saveVGACNTRL = I915_READ(VGACNTRL);
 
 	/* Clock gating state */
 	dev_priv->saveD_STATE = I915_READ(D_STATE);
-	dev_priv->saveDSPCLK_GATE_D = I915_READ(DSPCLK_GATE_D);
+	dev_priv->saveCG_2D_DIS = I915_READ(CG_2D_DIS);
 
 	/* Cache mode state */
 	dev_priv->saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
@@ -363,7 +363,7 @@ static int i915_suspend(struct drm_device *dev, pm_message_t state)
 
 	/* Scratch space */
 	for (i = 0; i < 16; i++) {
-		dev_priv->saveSWF0[i] = I915_READ(SWF0 + (i << 2));
+		dev_priv->saveSWF0[i] = I915_READ(SWF00 + (i << 2));
 		dev_priv->saveSWF1[i] = I915_READ(SWF10 + (i << 2));
 	}
 	for (i = 0; i < 3; i++)
@@ -424,7 +424,7 @@ static int i915_resume(struct drm_device *dev)
 	I915_WRITE(DSPASIZE, dev_priv->saveDSPASIZE);
 	I915_WRITE(DSPAPOS, dev_priv->saveDSPAPOS);
 	I915_WRITE(PIPEASRC, dev_priv->savePIPEASRC);
-	I915_WRITE(DSPABASE, dev_priv->saveDSPABASE);
+	I915_WRITE(DSPAADDR, dev_priv->saveDSPAADDR);
 	I915_WRITE(DSPASTRIDE, dev_priv->saveDSPASTRIDE);
 	if (IS_I965G(dev)) {
 		I915_WRITE(DSPASURF, dev_priv->saveDSPASURF);
@@ -436,7 +436,7 @@ static int i915_resume(struct drm_device *dev)
 	i915_restore_palette(dev, PIPE_A);
 	/* Enable the plane */
 	I915_WRITE(DSPACNTR, dev_priv->saveDSPACNTR);
-	I915_WRITE(DSPABASE, I915_READ(DSPABASE));
+	I915_WRITE(DSPAADDR, I915_READ(DSPAADDR));
 
 	/* Pipe & plane B info */
 	if (dev_priv->saveDPLL_B & DPLL_VCO_ENABLE) {
@@ -466,7 +466,7 @@ static int i915_resume(struct drm_device *dev)
 	I915_WRITE(DSPBSIZE, dev_priv->saveDSPBSIZE);
 	I915_WRITE(DSPBPOS, dev_priv->saveDSPBPOS);
 	I915_WRITE(PIPEBSRC, dev_priv->savePIPEBSRC);
-	I915_WRITE(DSPBBASE, dev_priv->saveDSPBBASE);
+	I915_WRITE(DSPBADDR, dev_priv->saveDSPBADDR);
 	I915_WRITE(DSPBSTRIDE, dev_priv->saveDSPBSTRIDE);
 	if (IS_I965G(dev)) {
 		I915_WRITE(DSPBSURF, dev_priv->saveDSPBSURF);
@@ -478,7 +478,7 @@ static int i915_resume(struct drm_device *dev)
 	i915_restore_palette(dev, PIPE_B);
 	/* Enable the plane */
 	I915_WRITE(DSPBCNTR, dev_priv->saveDSPBCNTR);
-	I915_WRITE(DSPBBASE, I915_READ(DSPBBASE));
+	I915_WRITE(DSPBADDR, I915_READ(DSPBADDR));
 
 	/* CRT state */
 	I915_WRITE(ADPA, dev_priv->saveADPA);
@@ -493,9 +493,9 @@ static int i915_resume(struct drm_device *dev)
 
 	I915_WRITE(PFIT_PGM_RATIOS, dev_priv->savePFIT_PGM_RATIOS);
 	I915_WRITE(BLC_PWM_CTL, dev_priv->saveBLC_PWM_CTL);
-	I915_WRITE(LVDSPP_ON, dev_priv->saveLVDSPP_ON);
-	I915_WRITE(LVDSPP_OFF, dev_priv->saveLVDSPP_OFF);
-	I915_WRITE(PP_CYCLE, dev_priv->savePP_CYCLE);
+	I915_WRITE(PP_ON_DELAYS, dev_priv->savePP_ON_DELAYS);
+	I915_WRITE(PP_OFF_DELAYS, dev_priv->savePP_OFF_DELAYS);
+	I915_WRITE(PP_DIVISOR, dev_priv->savePP_DIVISOR);
 	I915_WRITE(PP_CONTROL, dev_priv->savePP_CONTROL);
 
 	/* FIXME: restore TV & SDVO state */
@@ -508,14 +508,14 @@ static int i915_resume(struct drm_device *dev)
 
 	/* VGA state */
 	I915_WRITE(VGACNTRL, dev_priv->saveVGACNTRL);
-	I915_WRITE(VCLK_DIVISOR_VGA0, dev_priv->saveVCLK_DIVISOR_VGA0);
-	I915_WRITE(VCLK_DIVISOR_VGA1, dev_priv->saveVCLK_DIVISOR_VGA1);
-	I915_WRITE(VCLK_POST_DIV, dev_priv->saveVCLK_POST_DIV);
+	I915_WRITE(VGA0, dev_priv->saveVGA0);
+	I915_WRITE(VGA1, dev_priv->saveVGA1);
+	I915_WRITE(VGA_PD, dev_priv->saveVGA_PD);
 	udelay(150);
 
 	/* Clock gating state */
 	I915_WRITE (D_STATE, dev_priv->saveD_STATE);
-	I915_WRITE (DSPCLK_GATE_D, dev_priv->saveDSPCLK_GATE_D);
+	I915_WRITE(CG_2D_DIS, dev_priv->saveCG_2D_DIS);
 
 	/* Cache mode state */
 	I915_WRITE (CACHE_MODE_0, dev_priv->saveCACHE_MODE_0 | 0xffff0000);
@@ -524,7 +524,7 @@ static int i915_resume(struct drm_device *dev)
 	I915_WRITE (MI_ARB_STATE, dev_priv->saveMI_ARB_STATE | 0xffff0000);
 
 	for (i = 0; i < 16; i++) {
-		I915_WRITE(SWF0 + (i << 2), dev_priv->saveSWF0[i]);
+		I915_WRITE(SWF00 + (i << 2), dev_priv->saveSWF0[i]);
 		I915_WRITE(SWF10 + (i << 2), dev_priv->saveSWF1[i+7]);
 	}
 	for (i = 0; i < 3; i++)

commit c0e09200dc0813972442e550a5905a132768e56c
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 29 10:09:59 2008 +1000

    drm: reorganise drm tree to be more future proof.
    
    With the coming of kernel based modesetting and the memory manager stuff,
    the everything in one directory approach was getting very ugly and
    starting to be unmanageable.
    
    This restructures the drm along the lines of other kernel components.
    
    It creates a drivers/gpu/drm directory and moves the hw drivers into
    subdirectores. It moves the includes into an include/drm, and
    sets up the unifdef for the userspace headers we should be exporting.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
new file mode 100644
index 000000000000..93aed1c38bd2
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -0,0 +1,605 @@
+/* i915_drv.c -- i830,i845,i855,i865,i915 driver -*- linux-c -*-
+ */
+/*
+ *
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+#include "i915_drv.h"
+
+#include "drm_pciids.h"
+
+static struct pci_device_id pciidlist[] = {
+	i915_PCI_IDS
+};
+
+enum pipe {
+    PIPE_A = 0,
+    PIPE_B,
+};
+
+static bool i915_pipe_enabled(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	if (pipe == PIPE_A)
+		return (I915_READ(DPLL_A) & DPLL_VCO_ENABLE);
+	else
+		return (I915_READ(DPLL_B) & DPLL_VCO_ENABLE);
+}
+
+static void i915_save_palette(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
+	u32 *array;
+	int i;
+
+	if (!i915_pipe_enabled(dev, pipe))
+		return;
+
+	if (pipe == PIPE_A)
+		array = dev_priv->save_palette_a;
+	else
+		array = dev_priv->save_palette_b;
+
+	for(i = 0; i < 256; i++)
+		array[i] = I915_READ(reg + (i << 2));
+}
+
+static void i915_restore_palette(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
+	u32 *array;
+	int i;
+
+	if (!i915_pipe_enabled(dev, pipe))
+		return;
+
+	if (pipe == PIPE_A)
+		array = dev_priv->save_palette_a;
+	else
+		array = dev_priv->save_palette_b;
+
+	for(i = 0; i < 256; i++)
+		I915_WRITE(reg + (i << 2), array[i]);
+}
+
+static u8 i915_read_indexed(u16 index_port, u16 data_port, u8 reg)
+{
+	outb(reg, index_port);
+	return inb(data_port);
+}
+
+static u8 i915_read_ar(u16 st01, u8 reg, u16 palette_enable)
+{
+	inb(st01);
+	outb(palette_enable | reg, VGA_AR_INDEX);
+	return inb(VGA_AR_DATA_READ);
+}
+
+static void i915_write_ar(u8 st01, u8 reg, u8 val, u16 palette_enable)
+{
+	inb(st01);
+	outb(palette_enable | reg, VGA_AR_INDEX);
+	outb(val, VGA_AR_DATA_WRITE);
+}
+
+static void i915_write_indexed(u16 index_port, u16 data_port, u8 reg, u8 val)
+{
+	outb(reg, index_port);
+	outb(val, data_port);
+}
+
+static void i915_save_vga(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+	u16 cr_index, cr_data, st01;
+
+	/* VGA color palette registers */
+	dev_priv->saveDACMASK = inb(VGA_DACMASK);
+	/* DACCRX automatically increments during read */
+	outb(0, VGA_DACRX);
+	/* Read 3 bytes of color data from each index */
+	for (i = 0; i < 256 * 3; i++)
+		dev_priv->saveDACDATA[i] = inb(VGA_DACDATA);
+
+	/* MSR bits */
+	dev_priv->saveMSR = inb(VGA_MSR_READ);
+	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
+		cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* CRT controller regs */
+	i915_write_indexed(cr_index, cr_data, 0x11,
+			   i915_read_indexed(cr_index, cr_data, 0x11) &
+			   (~0x80));
+	for (i = 0; i <= 0x24; i++)
+		dev_priv->saveCR[i] =
+			i915_read_indexed(cr_index, cr_data, i);
+	/* Make sure we don't turn off CR group 0 writes */
+	dev_priv->saveCR[0x11] &= ~0x80;
+
+	/* Attribute controller registers */
+	inb(st01);
+	dev_priv->saveAR_INDEX = inb(VGA_AR_INDEX);
+	for (i = 0; i <= 0x14; i++)
+		dev_priv->saveAR[i] = i915_read_ar(st01, i, 0);
+	inb(st01);
+	outb(dev_priv->saveAR_INDEX, VGA_AR_INDEX);
+	inb(st01);
+
+	/* Graphics controller registers */
+	for (i = 0; i < 9; i++)
+		dev_priv->saveGR[i] =
+			i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, i);
+
+	dev_priv->saveGR[0x10] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10);
+	dev_priv->saveGR[0x11] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11);
+	dev_priv->saveGR[0x18] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18);
+
+	/* Sequencer registers */
+	for (i = 0; i < 8; i++)
+		dev_priv->saveSR[i] =
+			i915_read_indexed(VGA_SR_INDEX, VGA_SR_DATA, i);
+}
+
+static void i915_restore_vga(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+	u16 cr_index, cr_data, st01;
+
+	/* MSR bits */
+	outb(dev_priv->saveMSR, VGA_MSR_WRITE);
+	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
+		cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* Sequencer registers, don't write SR07 */
+	for (i = 0; i < 7; i++)
+		i915_write_indexed(VGA_SR_INDEX, VGA_SR_DATA, i,
+				   dev_priv->saveSR[i]);
+
+	/* CRT controller regs */
+	/* Enable CR group 0 writes */
+	i915_write_indexed(cr_index, cr_data, 0x11, dev_priv->saveCR[0x11]);
+	for (i = 0; i <= 0x24; i++)
+		i915_write_indexed(cr_index, cr_data, i, dev_priv->saveCR[i]);
+
+	/* Graphics controller regs */
+	for (i = 0; i < 9; i++)
+		i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, i,
+				   dev_priv->saveGR[i]);
+
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10,
+			   dev_priv->saveGR[0x10]);
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11,
+			   dev_priv->saveGR[0x11]);
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18,
+			   dev_priv->saveGR[0x18]);
+
+	/* Attribute controller registers */
+	inb(st01);
+	for (i = 0; i <= 0x14; i++)
+		i915_write_ar(st01, i, dev_priv->saveAR[i], 0);
+	inb(st01); /* switch back to index mode */
+	outb(dev_priv->saveAR_INDEX | 0x20, VGA_AR_INDEX);
+	inb(st01);
+
+	/* VGA color palette registers */
+	outb(dev_priv->saveDACMASK, VGA_DACMASK);
+	/* DACCRX automatically increments during read */
+	outb(0, VGA_DACWX);
+	/* Read 3 bytes of color data from each index */
+	for (i = 0; i < 256 * 3; i++)
+		outb(dev_priv->saveDACDATA[i], VGA_DACDATA);
+
+}
+
+static int i915_suspend(struct drm_device *dev, pm_message_t state)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+
+	if (!dev || !dev_priv) {
+		printk(KERN_ERR "dev: %p, dev_priv: %p\n", dev, dev_priv);
+		printk(KERN_ERR "DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
+
+	if (state.event == PM_EVENT_PRETHAW)
+		return 0;
+
+	pci_save_state(dev->pdev);
+	pci_read_config_byte(dev->pdev, LBB, &dev_priv->saveLBB);
+
+	/* Display arbitration control */
+	dev_priv->saveDSPARB = I915_READ(DSPARB);
+
+	/* Pipe & plane A info */
+	dev_priv->savePIPEACONF = I915_READ(PIPEACONF);
+	dev_priv->savePIPEASRC = I915_READ(PIPEASRC);
+	dev_priv->saveFPA0 = I915_READ(FPA0);
+	dev_priv->saveFPA1 = I915_READ(FPA1);
+	dev_priv->saveDPLL_A = I915_READ(DPLL_A);
+	if (IS_I965G(dev))
+		dev_priv->saveDPLL_A_MD = I915_READ(DPLL_A_MD);
+	dev_priv->saveHTOTAL_A = I915_READ(HTOTAL_A);
+	dev_priv->saveHBLANK_A = I915_READ(HBLANK_A);
+	dev_priv->saveHSYNC_A = I915_READ(HSYNC_A);
+	dev_priv->saveVTOTAL_A = I915_READ(VTOTAL_A);
+	dev_priv->saveVBLANK_A = I915_READ(VBLANK_A);
+	dev_priv->saveVSYNC_A = I915_READ(VSYNC_A);
+	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
+
+	dev_priv->saveDSPACNTR = I915_READ(DSPACNTR);
+	dev_priv->saveDSPASTRIDE = I915_READ(DSPASTRIDE);
+	dev_priv->saveDSPASIZE = I915_READ(DSPASIZE);
+	dev_priv->saveDSPAPOS = I915_READ(DSPAPOS);
+	dev_priv->saveDSPABASE = I915_READ(DSPABASE);
+	if (IS_I965G(dev)) {
+		dev_priv->saveDSPASURF = I915_READ(DSPASURF);
+		dev_priv->saveDSPATILEOFF = I915_READ(DSPATILEOFF);
+	}
+	i915_save_palette(dev, PIPE_A);
+	dev_priv->savePIPEASTAT = I915_READ(I915REG_PIPEASTAT);
+
+	/* Pipe & plane B info */
+	dev_priv->savePIPEBCONF = I915_READ(PIPEBCONF);
+	dev_priv->savePIPEBSRC = I915_READ(PIPEBSRC);
+	dev_priv->saveFPB0 = I915_READ(FPB0);
+	dev_priv->saveFPB1 = I915_READ(FPB1);
+	dev_priv->saveDPLL_B = I915_READ(DPLL_B);
+	if (IS_I965G(dev))
+		dev_priv->saveDPLL_B_MD = I915_READ(DPLL_B_MD);
+	dev_priv->saveHTOTAL_B = I915_READ(HTOTAL_B);
+	dev_priv->saveHBLANK_B = I915_READ(HBLANK_B);
+	dev_priv->saveHSYNC_B = I915_READ(HSYNC_B);
+	dev_priv->saveVTOTAL_B = I915_READ(VTOTAL_B);
+	dev_priv->saveVBLANK_B = I915_READ(VBLANK_B);
+	dev_priv->saveVSYNC_B = I915_READ(VSYNC_B);
+	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
+
+	dev_priv->saveDSPBCNTR = I915_READ(DSPBCNTR);
+	dev_priv->saveDSPBSTRIDE = I915_READ(DSPBSTRIDE);
+	dev_priv->saveDSPBSIZE = I915_READ(DSPBSIZE);
+	dev_priv->saveDSPBPOS = I915_READ(DSPBPOS);
+	dev_priv->saveDSPBBASE = I915_READ(DSPBBASE);
+	if (IS_I965GM(dev) || IS_IGD_GM(dev)) {
+		dev_priv->saveDSPBSURF = I915_READ(DSPBSURF);
+		dev_priv->saveDSPBTILEOFF = I915_READ(DSPBTILEOFF);
+	}
+	i915_save_palette(dev, PIPE_B);
+	dev_priv->savePIPEBSTAT = I915_READ(I915REG_PIPEBSTAT);
+
+	/* CRT state */
+	dev_priv->saveADPA = I915_READ(ADPA);
+
+	/* LVDS state */
+	dev_priv->savePP_CONTROL = I915_READ(PP_CONTROL);
+	dev_priv->savePFIT_PGM_RATIOS = I915_READ(PFIT_PGM_RATIOS);
+	dev_priv->saveBLC_PWM_CTL = I915_READ(BLC_PWM_CTL);
+	if (IS_I965G(dev))
+		dev_priv->saveBLC_PWM_CTL2 = I915_READ(BLC_PWM_CTL2);
+	if (IS_MOBILE(dev) && !IS_I830(dev))
+		dev_priv->saveLVDS = I915_READ(LVDS);
+	if (!IS_I830(dev) && !IS_845G(dev))
+		dev_priv->savePFIT_CONTROL = I915_READ(PFIT_CONTROL);
+	dev_priv->saveLVDSPP_ON = I915_READ(LVDSPP_ON);
+	dev_priv->saveLVDSPP_OFF = I915_READ(LVDSPP_OFF);
+	dev_priv->savePP_CYCLE = I915_READ(PP_CYCLE);
+
+	/* FIXME: save TV & SDVO state */
+
+	/* FBC state */
+	dev_priv->saveFBC_CFB_BASE = I915_READ(FBC_CFB_BASE);
+	dev_priv->saveFBC_LL_BASE = I915_READ(FBC_LL_BASE);
+	dev_priv->saveFBC_CONTROL2 = I915_READ(FBC_CONTROL2);
+	dev_priv->saveFBC_CONTROL = I915_READ(FBC_CONTROL);
+
+	/* Interrupt state */
+	dev_priv->saveIIR = I915_READ(I915REG_INT_IDENTITY_R);
+	dev_priv->saveIER = I915_READ(I915REG_INT_ENABLE_R);
+	dev_priv->saveIMR = I915_READ(I915REG_INT_MASK_R);
+
+	/* VGA state */
+	dev_priv->saveVCLK_DIVISOR_VGA0 = I915_READ(VCLK_DIVISOR_VGA0);
+	dev_priv->saveVCLK_DIVISOR_VGA1 = I915_READ(VCLK_DIVISOR_VGA1);
+	dev_priv->saveVCLK_POST_DIV = I915_READ(VCLK_POST_DIV);
+	dev_priv->saveVGACNTRL = I915_READ(VGACNTRL);
+
+	/* Clock gating state */
+	dev_priv->saveD_STATE = I915_READ(D_STATE);
+	dev_priv->saveDSPCLK_GATE_D = I915_READ(DSPCLK_GATE_D);
+
+	/* Cache mode state */
+	dev_priv->saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
+
+	/* Memory Arbitration state */
+	dev_priv->saveMI_ARB_STATE = I915_READ(MI_ARB_STATE);
+
+	/* Scratch space */
+	for (i = 0; i < 16; i++) {
+		dev_priv->saveSWF0[i] = I915_READ(SWF0 + (i << 2));
+		dev_priv->saveSWF1[i] = I915_READ(SWF10 + (i << 2));
+	}
+	for (i = 0; i < 3; i++)
+		dev_priv->saveSWF2[i] = I915_READ(SWF30 + (i << 2));
+
+	i915_save_vga(dev);
+
+	if (state.event == PM_EVENT_SUSPEND) {
+		/* Shut down the device */
+		pci_disable_device(dev->pdev);
+		pci_set_power_state(dev->pdev, PCI_D3hot);
+	}
+
+	return 0;
+}
+
+static int i915_resume(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+
+	pci_set_power_state(dev->pdev, PCI_D0);
+	pci_restore_state(dev->pdev);
+	if (pci_enable_device(dev->pdev))
+		return -1;
+	pci_set_master(dev->pdev);
+
+	pci_write_config_byte(dev->pdev, LBB, dev_priv->saveLBB);
+
+	I915_WRITE(DSPARB, dev_priv->saveDSPARB);
+
+	/* Pipe & plane A info */
+	/* Prime the clock */
+	if (dev_priv->saveDPLL_A & DPLL_VCO_ENABLE) {
+		I915_WRITE(DPLL_A, dev_priv->saveDPLL_A &
+			   ~DPLL_VCO_ENABLE);
+		udelay(150);
+	}
+	I915_WRITE(FPA0, dev_priv->saveFPA0);
+	I915_WRITE(FPA1, dev_priv->saveFPA1);
+	/* Actually enable it */
+	I915_WRITE(DPLL_A, dev_priv->saveDPLL_A);
+	udelay(150);
+	if (IS_I965G(dev))
+		I915_WRITE(DPLL_A_MD, dev_priv->saveDPLL_A_MD);
+	udelay(150);
+
+	/* Restore mode */
+	I915_WRITE(HTOTAL_A, dev_priv->saveHTOTAL_A);
+	I915_WRITE(HBLANK_A, dev_priv->saveHBLANK_A);
+	I915_WRITE(HSYNC_A, dev_priv->saveHSYNC_A);
+	I915_WRITE(VTOTAL_A, dev_priv->saveVTOTAL_A);
+	I915_WRITE(VBLANK_A, dev_priv->saveVBLANK_A);
+	I915_WRITE(VSYNC_A, dev_priv->saveVSYNC_A);
+	I915_WRITE(BCLRPAT_A, dev_priv->saveBCLRPAT_A);
+
+	/* Restore plane info */
+	I915_WRITE(DSPASIZE, dev_priv->saveDSPASIZE);
+	I915_WRITE(DSPAPOS, dev_priv->saveDSPAPOS);
+	I915_WRITE(PIPEASRC, dev_priv->savePIPEASRC);
+	I915_WRITE(DSPABASE, dev_priv->saveDSPABASE);
+	I915_WRITE(DSPASTRIDE, dev_priv->saveDSPASTRIDE);
+	if (IS_I965G(dev)) {
+		I915_WRITE(DSPASURF, dev_priv->saveDSPASURF);
+		I915_WRITE(DSPATILEOFF, dev_priv->saveDSPATILEOFF);
+	}
+
+	I915_WRITE(PIPEACONF, dev_priv->savePIPEACONF);
+
+	i915_restore_palette(dev, PIPE_A);
+	/* Enable the plane */
+	I915_WRITE(DSPACNTR, dev_priv->saveDSPACNTR);
+	I915_WRITE(DSPABASE, I915_READ(DSPABASE));
+
+	/* Pipe & plane B info */
+	if (dev_priv->saveDPLL_B & DPLL_VCO_ENABLE) {
+		I915_WRITE(DPLL_B, dev_priv->saveDPLL_B &
+			   ~DPLL_VCO_ENABLE);
+		udelay(150);
+	}
+	I915_WRITE(FPB0, dev_priv->saveFPB0);
+	I915_WRITE(FPB1, dev_priv->saveFPB1);
+	/* Actually enable it */
+	I915_WRITE(DPLL_B, dev_priv->saveDPLL_B);
+	udelay(150);
+	if (IS_I965G(dev))
+		I915_WRITE(DPLL_B_MD, dev_priv->saveDPLL_B_MD);
+	udelay(150);
+
+	/* Restore mode */
+	I915_WRITE(HTOTAL_B, dev_priv->saveHTOTAL_B);
+	I915_WRITE(HBLANK_B, dev_priv->saveHBLANK_B);
+	I915_WRITE(HSYNC_B, dev_priv->saveHSYNC_B);
+	I915_WRITE(VTOTAL_B, dev_priv->saveVTOTAL_B);
+	I915_WRITE(VBLANK_B, dev_priv->saveVBLANK_B);
+	I915_WRITE(VSYNC_B, dev_priv->saveVSYNC_B);
+	I915_WRITE(BCLRPAT_B, dev_priv->saveBCLRPAT_B);
+
+	/* Restore plane info */
+	I915_WRITE(DSPBSIZE, dev_priv->saveDSPBSIZE);
+	I915_WRITE(DSPBPOS, dev_priv->saveDSPBPOS);
+	I915_WRITE(PIPEBSRC, dev_priv->savePIPEBSRC);
+	I915_WRITE(DSPBBASE, dev_priv->saveDSPBBASE);
+	I915_WRITE(DSPBSTRIDE, dev_priv->saveDSPBSTRIDE);
+	if (IS_I965G(dev)) {
+		I915_WRITE(DSPBSURF, dev_priv->saveDSPBSURF);
+		I915_WRITE(DSPBTILEOFF, dev_priv->saveDSPBTILEOFF);
+	}
+
+	I915_WRITE(PIPEBCONF, dev_priv->savePIPEBCONF);
+
+	i915_restore_palette(dev, PIPE_B);
+	/* Enable the plane */
+	I915_WRITE(DSPBCNTR, dev_priv->saveDSPBCNTR);
+	I915_WRITE(DSPBBASE, I915_READ(DSPBBASE));
+
+	/* CRT state */
+	I915_WRITE(ADPA, dev_priv->saveADPA);
+
+	/* LVDS state */
+	if (IS_I965G(dev))
+		I915_WRITE(BLC_PWM_CTL2, dev_priv->saveBLC_PWM_CTL2);
+	if (IS_MOBILE(dev) && !IS_I830(dev))
+		I915_WRITE(LVDS, dev_priv->saveLVDS);
+	if (!IS_I830(dev) && !IS_845G(dev))
+		I915_WRITE(PFIT_CONTROL, dev_priv->savePFIT_CONTROL);
+
+	I915_WRITE(PFIT_PGM_RATIOS, dev_priv->savePFIT_PGM_RATIOS);
+	I915_WRITE(BLC_PWM_CTL, dev_priv->saveBLC_PWM_CTL);
+	I915_WRITE(LVDSPP_ON, dev_priv->saveLVDSPP_ON);
+	I915_WRITE(LVDSPP_OFF, dev_priv->saveLVDSPP_OFF);
+	I915_WRITE(PP_CYCLE, dev_priv->savePP_CYCLE);
+	I915_WRITE(PP_CONTROL, dev_priv->savePP_CONTROL);
+
+	/* FIXME: restore TV & SDVO state */
+
+	/* FBC info */
+	I915_WRITE(FBC_CFB_BASE, dev_priv->saveFBC_CFB_BASE);
+	I915_WRITE(FBC_LL_BASE, dev_priv->saveFBC_LL_BASE);
+	I915_WRITE(FBC_CONTROL2, dev_priv->saveFBC_CONTROL2);
+	I915_WRITE(FBC_CONTROL, dev_priv->saveFBC_CONTROL);
+
+	/* VGA state */
+	I915_WRITE(VGACNTRL, dev_priv->saveVGACNTRL);
+	I915_WRITE(VCLK_DIVISOR_VGA0, dev_priv->saveVCLK_DIVISOR_VGA0);
+	I915_WRITE(VCLK_DIVISOR_VGA1, dev_priv->saveVCLK_DIVISOR_VGA1);
+	I915_WRITE(VCLK_POST_DIV, dev_priv->saveVCLK_POST_DIV);
+	udelay(150);
+
+	/* Clock gating state */
+	I915_WRITE (D_STATE, dev_priv->saveD_STATE);
+	I915_WRITE (DSPCLK_GATE_D, dev_priv->saveDSPCLK_GATE_D);
+
+	/* Cache mode state */
+	I915_WRITE (CACHE_MODE_0, dev_priv->saveCACHE_MODE_0 | 0xffff0000);
+
+	/* Memory arbitration state */
+	I915_WRITE (MI_ARB_STATE, dev_priv->saveMI_ARB_STATE | 0xffff0000);
+
+	for (i = 0; i < 16; i++) {
+		I915_WRITE(SWF0 + (i << 2), dev_priv->saveSWF0[i]);
+		I915_WRITE(SWF10 + (i << 2), dev_priv->saveSWF1[i+7]);
+	}
+	for (i = 0; i < 3; i++)
+		I915_WRITE(SWF30 + (i << 2), dev_priv->saveSWF2[i]);
+
+	i915_restore_vga(dev);
+
+	return 0;
+}
+
+static struct drm_driver driver = {
+	/* don't use mtrr's here, the Xserver or user space app should
+	 * deal with them for intel hardware.
+	 */
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL |
+	    DRIVER_IRQ_VBL2,
+	.load = i915_driver_load,
+	.unload = i915_driver_unload,
+	.lastclose = i915_driver_lastclose,
+	.preclose = i915_driver_preclose,
+	.suspend = i915_suspend,
+	.resume = i915_resume,
+	.device_is_agp = i915_driver_device_is_agp,
+	.vblank_wait = i915_driver_vblank_wait,
+	.vblank_wait2 = i915_driver_vblank_wait2,
+	.irq_preinstall = i915_driver_irq_preinstall,
+	.irq_postinstall = i915_driver_irq_postinstall,
+	.irq_uninstall = i915_driver_irq_uninstall,
+	.irq_handler = i915_driver_irq_handler,
+	.reclaim_buffers = drm_core_reclaim_buffers,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.ioctls = i915_ioctls,
+	.fops = {
+		 .owner = THIS_MODULE,
+		 .open = drm_open,
+		 .release = drm_release,
+		 .ioctl = drm_ioctl,
+		 .mmap = drm_mmap,
+		 .poll = drm_poll,
+		 .fasync = drm_fasync,
+#ifdef CONFIG_COMPAT
+		 .compat_ioctl = i915_compat_ioctl,
+#endif
+	},
+
+	.pci_driver = {
+		 .name = DRIVER_NAME,
+		 .id_table = pciidlist,
+	},
+
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCHLEVEL,
+};
+
+static int __init i915_init(void)
+{
+	driver.num_ioctls = i915_max_ioctl;
+	return drm_init(&driver);
+}
+
+static void __exit i915_exit(void)
+{
+	drm_exit(&driver);
+}
+
+module_init(i915_init);
+module_exit(i915_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL and additional rights");
