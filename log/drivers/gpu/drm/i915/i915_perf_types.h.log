commit d7d50f801d445f9f17221573c2eda9f7b23fb891
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 27 11:22:12 2020 +0000

    drm/i915/perf: Schedule oa_config after modifying the contexts
    
    We wish that the scheduler emit the context modification commands prior
    to enabling the oa_config, for which we must explicitly inform it of the
    ordering constraints. This is especially important as we now wait for
    the final oa_config setup to be completed and as this wait may be on a
    distinct context to the state modifications, we need that command packet
    to be always last in the queue.
    
    We borrow the i915_active for its ability to track multiple timelines
    and the last dma_fence on each; a flexible dma_resv. Keeping track of
    each dma_fence is important for us so that we can efficiently schedule
    the requests and reprioritise as required.
    
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200327112212.16046-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 371dcf243622..a36a455ae336 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -22,6 +22,7 @@
 
 struct drm_i915_private;
 struct file;
+struct i915_active;
 struct i915_gem_context;
 struct i915_perf;
 struct i915_vma;
@@ -340,8 +341,8 @@ struct i915_oa_ops {
 	 * counter reports being sampled. May apply system constraints such as
 	 * disabling EU clock gating as required.
 	 */
-	struct i915_request *
-		(*enable_metric_set)(struct i915_perf_stream *stream);
+	int (*enable_metric_set)(struct i915_perf_stream *stream,
+				 struct i915_active *active);
 
 	/**
 	 * @disable_metric_set: Remove system constraints associated with using

commit 4ef10fe05ba0b08ce7029c07878afe3c8d5754d8
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 24 11:54:57 2020 -0700

    drm/i915/perf: add new open param to configure polling of OA buffer
    
    This new parameter let's the application choose how often the OA
    buffer should be checked on the CPU side for data availability. Longer
    polling period tend to reduce CPU overhead if the application does not
    care about somewhat real time data collection.
    
    v2: Allow disabling polling completely with 0 value (Lionel)
    v3: Version the new parameter (Joonas)
    v4: Rebase (Umesh)
    v5: Make poll delay value of 0 invalid (Umesh)
    v6:
    - Describe poll_oa_period (Ashutosh)
    - Fix comment for new poll parameter (Lionel)
    - Drop open_flags in read_properties_unlocked (Lionel)
    - Rename uapi parameter (Ashutosh)
    v7: Reword the comment in uapi (Ashutosh)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Reviewed-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324185457.14635-4-umesh.nerlige.ramappa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index c3ab184c604a..371dcf243622 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -304,6 +304,12 @@ struct i915_perf_stream {
 	 * reprogrammed.
 	 */
 	struct i915_vma *noa_wait;
+
+	/**
+	 * @poll_oa_period: The period in nanoseconds at which the OA
+	 * buffer should be checked for available data.
+	 */
+	u64 poll_oa_period;
 };
 
 /**

commit d1df41eb72efbd132df5196e265a5fa1165b3255
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 24 11:54:55 2020 -0700

    drm/i915/perf: rework aging tail workaround
    
    We're about to introduce an options to open the perf stream, giving
    the user ability to configure how often it wants the kernel to poll
    the OA registers for available data.
    
    Right now the workaround against the OA tail pointer race condition
    requires at least twice the internal kernel polling timer to make any
    data available.
    
    This changes introduce checks on the OA data written into the circular
    buffer to make as much data as possible available on the first
    iteration of the polling timer.
    
    v2: Use OA_TAKEN macro without the gtt_offset (Lionel)
    v3: (Umesh)
    - Rebase
    - Change report to report32 from below review
      https://patchwork.freedesktop.org/patch/330704/?series=66697&rev=1
    v4: (Ashutosh, Lionel)
    - Fix checkpatch errors
    - Fix aging_timestamp initialization
    - Check for only one valid landed report
    - Fix check for unlanded report
    v5: (Ashutosh)
    - Fix bug in accurately determining landed report.
    - Optimize the check for landed reports by going as far as the
      previously determined aged tail.
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Reviewed-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324185457.14635-2-umesh.nerlige.ramappa@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 32289cbda648..c3ab184c604a 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -273,21 +273,10 @@ struct i915_perf_stream {
 		spinlock_t ptr_lock;
 
 		/**
-		 * @tails: One 'aging' tail pointer and one 'aged' tail pointer ready to
-		 * used for reading.
-		 *
-		 * Initial values of 0xffffffff are invalid and imply that an
-		 * update is required (and should be ignored by an attempted
-		 * read)
+		 * @aging_tail: The last HW tail reported by HW. The data
+		 * might not have made it to memory yet though.
 		 */
-		struct {
-			u32 offset;
-		} tails[2];
-
-		/**
-		 * @aged_tail_idx: Index for the aged tail ready to read() data up to.
-		 */
-		unsigned int aged_tail_idx;
+		u32 aging_tail;
 
 		/**
 		 * @aging_timestamp: A monotonic timestamp for when the current aging tail pointer
@@ -303,6 +292,11 @@ struct i915_perf_stream {
 		 * OA buffer data to userspace.
 		 */
 		u32 head;
+
+		/**
+		 * @tail: The last verified tail that can be read by userspace.
+		 */
+		u32 tail;
 	} oa_buffer;
 
 	/**
@@ -420,6 +414,12 @@ struct i915_perf {
 	 */
 	struct ratelimit_state spurious_report_rs;
 
+	/**
+	 * For rate limiting any notifications of tail pointer
+	 * race.
+	 */
+	struct ratelimit_state tail_pointer_race;
+
 	u32 gen7_latched_oastatus1;
 	u32 ctx_oactxctrl_offset;
 	u32 ctx_flexeu0_offset;

commit 11ecbdddf2f8b6cc2480aff6d877b7a4076e3b7f
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 17 15:22:22 2020 +0200

    drm/i915/perf: introduce global sseu pinning
    
    On Gen11 powergating half the execution units is a functional
    requirement when using the VME samplers. Not fullfilling this
    requirement can lead to hangs.
    
    This unfortunately plays fairly poorly with the NOA requirements. NOA
    requires a stable power configuration to maintain its configuration.
    
    As a result using OA (and NOA feeding into it) so far has required us
    to use a power configuration that can work for all contexts. The only
    power configuration fullfilling this is powergating half the execution
    units.
    
    This makes performance analysis for 3D workloads somewhat pointless.
    
    Failing to find a solution that would work for everybody, this change
    introduces a new i915-perf stream open parameter that punts the
    decision off to userspace. If this parameter is omitted, the existing
    Gen11 behavior remains (half EU array powergating).
    
    This change takes the initiative to move all perf related sseu
    configuration into i915_perf.c
    
    v2: Make parameter priviliged if different from default
    
    v3: Fix context modifying its sseu config while i915-perf is enabled
    
    v4: Always consider global sseu a privileged operation (Tvrtko)
        Override req_sseu point in intel_sseu_make_rpcs() (Tvrtko)
        Remove unrelated changes (Tvrtko)
    
    v5: Some typos (Tvrtko)
        Process sseu param in read_properties_unlocked() (Tvrtko)
    
    v6: Actually commit the bits from v5...
        Fixup some checkpath warnings
    
    v7: Only compare engine uabi field (Chris)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200317132222.2638719-3-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index f4ccd2adfee6..32289cbda648 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -16,6 +16,7 @@
 #include <linux/uuid.h>
 #include <linux/wait.h>
 
+#include "gt/intel_sseu.h"
 #include "i915_reg.h"
 #include "intel_wakeref.h"
 
@@ -407,6 +408,12 @@ struct i915_perf {
 	 */
 	struct i915_perf_stream *exclusive_stream;
 
+	/**
+	 * @sseu: sseu configuration selected to run while perf is active,
+	 * applies to all contexts.
+	 */
+	struct intel_sseu sseu;
+
 	/**
 	 * For rate limiting any notifications of spurious
 	 * invalid OA reports

commit 9aba9c188da136f22938f9d19b71affe84381b05
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 17 15:22:20 2020 +0200

    drm/i915/perf: remove generated code
    
    A little bit of history :
    
       Back when i915-perf was introduced (4.13), there was no way to
       dynamically add new OA configurations to i915. Only the generated
       configs baked in at build time were allowed.
    
       It quickly became obvious that we would need to allow applications
       to upload their own configurations, for instance to be able to test
       new ones, and so by the next stable version (4.14) we added uAPIs
       to allow uploading new configurations.
    
       When adding that capability, we took the opportunity to remove most
       HW configurations except the TestOa one which is a configuration
       IGT would rely on to verify that the HW is outputting correct
       values. At the time it made sense to have that confiuration in at
       the same time a given HW platform added to the i915-perf driver.
    
    Now that IGT has become the reference point for HW configurations (see
    commit 53f8f541ca ("lib: Add i915_perf library"), previously this was
    located in the GPUTop repository), the need for having those
    configurations in i915-perf is gone.
    
    On the Mesa side, we haven't relied on this test configuration for a
    while. The MDAPI library always required 4.14 feature level and always
    loaded its configuration into i915.
    
    I'm sure nobody will miss this generated stuff in i915 :)
    
    v2: Fix selftests by creating an empty config
    
    v3: Fix unlocking on allocation error (Dan Carpenter)
    
    v4: Fixup checkpatch warnings
    
    v5: Fix incorrect unlock in error path (Umesh)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200317132222.2638719-1-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index a0e22f00f6cf..f4ccd2adfee6 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -413,8 +413,6 @@ struct i915_perf {
 	 */
 	struct ratelimit_state spurious_report_rs;
 
-	struct i915_oa_config test_config;
-
 	u32 gen7_latched_oastatus1;
 	u32 ctx_oactxctrl_offset;
 	u32 ctx_flexeu0_offset;

commit 4b4e973d5eb89244b67d3223b60f752d0479f253
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 2 08:57:57 2020 +0000

    drm/i915/perf: Reintroduce wait on OA configuration completion
    
    We still need to wait for the initial OA configuration to happen
    before we enable OA report writes to the OA buffer.
    
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Fixes: 15d0ace1f876 ("drm/i915/perf: execute OA configuration from command stream")
    Closes: https://gitlab.freedesktop.org/drm/intel/issues/1356
    Testcase: igt/perf/stream-open-close
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200302085812.4172450-7-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 45e581455f5d..a0e22f00f6cf 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -339,7 +339,8 @@ struct i915_oa_ops {
 	 * counter reports being sampled. May apply system constraints such as
 	 * disabling EU clock gating as required.
 	 */
-	int (*enable_metric_set)(struct i915_perf_stream *stream);
+	struct i915_request *
+		(*enable_metric_set)(struct i915_perf_stream *stream);
 
 	/**
 	 * @disable_metric_set: Remove system constraints associated with using

commit 3dc716fd3cfddfaabf919f5337d5ff8b199b1cb4
Author: Venkata Sandeep Dhanalakota <venkata.s.dhanalakota@intel.com>
Date:   Fri Dec 13 07:51:51 2019 -0800

    drm/i915/perf: Register sysctl path globally
    
    We do not require to register the sysctl paths per instance,
    so making registration global.
    
    v2: make sysctl path register and unregister function driver
        specific (Tvrtko and Lucas).
    
    Cc: Sudeep Dutt <sudeep.dutt@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Venkata Sandeep Dhanalakota <venkata.s.dhanalakota@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191213155152.69182-1-venkata.s.dhanalakota@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 74ddc20a0d37..45e581455f5d 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -380,7 +380,6 @@ struct i915_perf {
 	struct drm_i915_private *i915;
 
 	struct kobject *metrics_kobj;
-	struct ctl_table_header *sysctl_header;
 
 	/*
 	 * Lock associated with adding/modifying/removing OA configs

commit 71b1c99081aec38b947d678b78a1ebe75c7260db
Author: Anna Karas <anna.karas@intel.com>
Date:   Tue Oct 22 13:13:38 2019 +0300

    drm/i915/perf: Describe structure members in documentation
    
    Add missing descriptions of i915_perf_stream structure members
    to documentation.
    
    Cc: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Robert Bragg <robert@sixbynine.org>
    Signed-off-by: Anna Karas <anna.karas@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022101338.17048-1-anna.karas@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index a1f733fc905a..74ddc20a0d37 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -199,14 +199,43 @@ struct i915_perf_stream {
 	 * @pinned_ctx: The OA context specific information.
 	 */
 	struct intel_context *pinned_ctx;
+
+	/**
+	 * @specific_ctx_id: The id of the specific context.
+	 */
 	u32 specific_ctx_id;
+
+	/**
+	 * @specific_ctx_id_mask: The mask used to masking specific_ctx_id bits.
+	 */
 	u32 specific_ctx_id_mask;
 
+	/**
+	 * @poll_check_timer: High resolution timer that will periodically
+	 * check for data in the circular OA buffer for notifying userspace
+	 * (e.g. during a read() or poll()).
+	 */
 	struct hrtimer poll_check_timer;
+
+	/**
+	 * @poll_wq: The wait queue that hrtimer callback wakes when it
+	 * sees data ready to read in the circular OA buffer.
+	 */
 	wait_queue_head_t poll_wq;
+
+	/**
+	 * @pollin: Whether there is data available to read.
+	 */
 	bool pollin;
 
+	/**
+	 * @periodic: Whether periodic sampling is currently enabled.
+	 */
 	bool periodic;
+
+	/**
+	 * @period_exponent: The OA unit sampling frequency is derived from this.
+	 */
 	int period_exponent;
 
 	/**
@@ -276,7 +305,7 @@ struct i915_perf_stream {
 	} oa_buffer;
 
 	/**
-	 * A batch buffer doing a wait on the GPU for the NOA logic to be
+	 * @noa_wait: A batch buffer doing a wait on the GPU for the NOA logic to be
 	 * reprogrammed.
 	 */
 	struct i915_vma *noa_wait;

commit 9cd20ef7803cc53a00c6eb7198b3d870ac7b3766
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Oct 14 21:14:04 2019 +0100

    drm/i915/perf: allow holding preemption on filtered ctx
    
    We would like to make use of perf in Vulkan. The Vulkan API is much
    lower level than OpenGL, with applications directly exposed to the
    concept of command buffers (pretty much equivalent to our batch
    buffers). In Vulkan, queries are always limited in scope to a command
    buffer. In OpenGL, the lack of command buffer concept meant that
    queries' duration could span multiple command buffers.
    
    With that restriction gone in Vulkan, we would like to simplify
    measuring performance just by measuring the deltas between the counter
    snapshots written by 2 MI_RECORD_PERF_COUNT commands, rather than the
    more complex scheme we currently have in the GL driver, using 2
    MI_RECORD_PERF_COUNT commands and doing some post processing on the
    stream of OA reports, coming from the global OA buffer, to remove any
    unrelated deltas in between the 2 MI_RECORD_PERF_COUNT.
    
    Disabling preemption only apply to a single context with which want to
    query performance counters for and is considered a privileged
    operation, by default protected by CAP_SYS_ADMIN. It is possible to
    enable it for a normal user by disabling the paranoid stream setting.
    
    v2: Store preemption setting in intel_context (Chris)
    
    v3: Use priorities to avoid preemption rather than the HW mechanism
    
    v4: Just modify the port priority reporting function
    
    v5: Add nopreempt flag on gem context and always flag requests
        appropriately, regarless of OA reconfiguration.
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/932
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191014201404.22468-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index d35a3c1946c3..a1f733fc905a 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -170,6 +170,14 @@ struct i915_perf_stream {
 	 */
 	bool enabled;
 
+	/**
+	 * @hold_preemption: Whether preemption is put on hold for command
+	 * submissions done on the @ctx. This is useful for some drivers that
+	 * cannot easily post process the OA buffer context to subtract delta
+	 * of performance counters not associated with @ctx.
+	 */
+	bool hold_preemption;
+
 	/**
 	 * @ops: The callbacks providing the implementation of this specific
 	 * type of configured stream.

commit daed3e44396d178cf2098b754bb8ef5ca4e918bc
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Sat Oct 12 08:23:07 2019 +0100

    drm/i915/perf: implement active wait for noa configurations
    
    NOA configuration take some amount of time to apply. That amount of
    time depends on the size of the GT. There is no documented time for
    this. For example, past experimentations with powergating
    configuration changes seem to indicate a 60~70us delay. We go with
    500us as default for now which should be over the required amount of
    time (according to HW architects).
    
    v2: Don't forget to save/restore registers used for the wait (Chris)
    
    v3: Name used CS_GPR registers (Chris)
        Fix compile issue due to rebase (Lionel)
    
    v4: Fix save/restore helpers (Umesh)
    
    v5: Move noa_wait from drm_i915_private to i915_perf_stream (Lionel)
    
    v6: Add missing struct declarations in i915_perf.h
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191012072308.30312-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 337cd7d2ad77..d35a3c1946c3 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -266,6 +266,12 @@ struct i915_perf_stream {
 		 */
 		u32 head;
 	} oa_buffer;
+
+	/**
+	 * A batch buffer doing a wait on the GPU for the NOA logic to be
+	 * reprogrammed.
+	 */
+	struct i915_vma *noa_wait;
 };
 
 /**
@@ -385,6 +391,8 @@ struct i915_perf {
 
 	struct i915_oa_ops ops;
 	const struct i915_oa_format *oa_formats;
+
+	atomic64_t noa_programming_delay;
 };
 
 #endif /* _I915_PERF_TYPES_H_ */

commit 6a45008ab7bb5e13b543de0c141b94aaa71d8397
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Sat Oct 12 08:23:06 2019 +0100

    drm/i915/perf: allow for CS OA configs to be created lazily
    
    Here we introduce a mechanism by which the execbuf part of the i915
    driver will be able to request that a batch buffer containing the
    programming for a particular OA config be created.
    
    We'll execute these OA configuration buffers right before executing a
    set of userspace commands so that a particular user batchbuffer be
    executed with a given OA configuration.
    
    This mechanism essentially allows the userspace driver to go through
    several OA configuration without having to open/close the i915/perf
    stream.
    
    v2: No need for locking on object OA config object creation (Chris)
        Flush cpu mapping of OA config (Chris)
    
    v3: Properly deal with the perf_metric lock (Chris/Lionel)
    
    v4: Fix oa config unref/put when not found (Lionel)
    
    v5: Allocate BOs for configurations on the stream instead of globally
        (Lionel)
    
    v6: Fix 64bit division (Chris)
    
    v7: Store allocated config BOs into the stream (Lionel)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191012072308.30312-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index eb8d1ebd5095..337cd7d2ad77 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -9,7 +9,7 @@
 #include <linux/atomic.h>
 #include <linux/device.h>
 #include <linux/hrtimer.h>
-#include <linux/list.h>
+#include <linux/llist.h>
 #include <linux/poll.h>
 #include <linux/sysfs.h>
 #include <linux/types.h>
@@ -22,6 +22,7 @@
 struct drm_i915_private;
 struct file;
 struct i915_gem_context;
+struct i915_perf;
 struct i915_vma;
 struct intel_context;
 struct intel_engine_cs;
@@ -37,6 +38,8 @@ struct i915_oa_reg {
 };
 
 struct i915_oa_config {
+	struct i915_perf *perf;
+
 	char uuid[UUID_STRING_LEN + 1];
 	int id;
 
@@ -51,7 +54,8 @@ struct i915_oa_config {
 	struct attribute *attrs[2];
 	struct device_attribute sysfs_metric_id;
 
-	atomic_t ref_count;
+	struct kref ref;
+	struct rcu_head rcu;
 };
 
 struct i915_perf_stream;
@@ -177,6 +181,12 @@ struct i915_perf_stream {
 	 */
 	struct i915_oa_config *oa_config;
 
+	/**
+	 * @oa_config_bos: A list of struct i915_oa_config_bo allocated lazily
+	 * each time @oa_config changes.
+	 */
+	struct llist_head oa_config_bos;
+
 	/**
 	 * @pinned_ctx: The OA context specific information.
 	 */
@@ -331,13 +341,13 @@ struct i915_perf {
 
 	/*
 	 * Lock associated with adding/modifying/removing OA configs
-	 * in dev_priv->perf.metrics_idr.
+	 * in perf->metrics_idr.
 	 */
 	struct mutex metrics_lock;
 
 	/*
-	 * List of dynamic configurations, you need to hold
-	 * dev_priv->perf.metrics_lock to access it.
+	 * List of dynamic configurations (struct i915_oa_config), you
+	 * need to hold perf->metrics_lock to access it.
 	 */
 	struct idr metrics_idr;
 
@@ -350,8 +360,7 @@ struct i915_perf {
 	/*
 	 * The stream currently using the OA unit. If accessed
 	 * outside a syscall associated to its file
-	 * descriptor, you need to hold
-	 * dev_priv->drm.struct_mutex.
+	 * descriptor.
 	 */
 	struct i915_perf_stream *exclusive_stream;
 

commit a5efcde69b112d276416f8e6e5e9fd8ede13bfc5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 11 20:03:17 2019 +0100

    drm/i915/perf: Replace global wakeref tracking with engine-pm
    
    As we now have a specific engine to use OA on, exchange the top-level
    runtime-pm wakeref with the engine-pm. This still results in the same
    top-level runtime-pm, but with more nuances to keep the engine and its
    gt awake.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191011190325.10979-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index a91ae2d1a543..eb8d1ebd5095 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -134,12 +134,6 @@ struct i915_perf_stream {
 	 */
 	struct intel_uncore *uncore;
 
-	/**
-	 * @wakeref: As we keep the device awake while the perf stream is
-	 * active, we track our runtime pm reference for later release.
-	 */
-	intel_wakeref_t wakeref;
-
 	/**
 	 * @engine: Engine associated with this performance stream.
 	 */

commit 52111c4628a29973d8be266f45b464318912b199
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Oct 10 16:05:20 2019 +0100

    drm/i915/perf: Store shortcut to intel_uncore
    
    Now that we have the engine stored in i915_perf, we have a means of
    accessing intel_gt should we require it. However, we are currently only
    using the intel_gt to find the right intel_uncore, so replace our
    i915_perf.gt pointer with the more useful i915_perf.uncore.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191010150520.26488-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 82cd3b295037..a91ae2d1a543 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -130,9 +130,9 @@ struct i915_perf_stream {
 	struct i915_perf *perf;
 
 	/**
-	 * @gt: intel_gt container
+	 * @uncore: mmio access path
 	 */
-	struct intel_gt *gt;
+	struct intel_uncore *uncore;
 
 	/**
 	 * @wakeref: As we keep the device awake while the perf stream is

commit 9a61363a6310dda769b8c7601fc9de8ed81e6bc8
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Thu Oct 10 16:05:19 2019 +0100

    drm/i915/perf: store the associated engine of a stream
    
    We'll use this information later to verify that a client trying to
    reconfigure the stream does so on the right engine. For now, we want to
    pull the knowledge of which engine we use into a central property.
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191010150520.26488-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 2d17059d32ee..82cd3b295037 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -140,6 +140,11 @@ struct i915_perf_stream {
 	 */
 	intel_wakeref_t wakeref;
 
+	/**
+	 * @engine: Engine associated with this performance stream.
+	 */
+	struct intel_engine_cs *engine;
+
 	/**
 	 * @sample_flags: Flags representing the `DRM_I915_PERF_PROP_SAMPLE_*`
 	 * properties given when opening a stream, representing the contents

commit 23b9e41a3dbdad16266b16d0c16ac629f0b6d732
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Oct 8 15:01:11 2019 +0100

    drm/i915/perf: drop list of streams
    
    At some point in time there was the idea that we could have multiple
    stream from the same piece of HW but that never materialized and given
    the hard time we already have making everything work with the
    submission side, there is no real point having this list of 1 element
    around.
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191008140111.5437-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index 3c6246064a0b..2d17059d32ee 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -134,11 +134,6 @@ struct i915_perf_stream {
 	 */
 	struct intel_gt *gt;
 
-	/**
-	 * @link: Links the stream into ``&drm_i915_private->streams``
-	 */
-	struct list_head link;
-
 	/**
 	 * @wakeref: As we keep the device awake while the perf stream is
 	 * active, we track our runtime pm reference for later release.
@@ -352,7 +347,6 @@ struct i915_perf {
 	 * except exclusive_stream.
 	 */
 	struct mutex lock;
-	struct list_head streams;
 
 	/*
 	 * The stream currently using the OA unit. If accessed

commit 8f8b1171e1a514c2fdfd388b662a7e5b34e839a8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Oct 7 22:09:41 2019 +0100

    drm/i915/perf: Wean ourselves off dev_priv
    
    Use the local uncore accessors for the GT rather than using the [not-so]
    magic global dev_priv mmio routines. In the process, we also teach the
    perf stream to use backpointers to the i915_perf rather than digging it
    out of dev_priv.
    
    v2: Rebase onto i915_perf_types.h
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com> #v1
    Link: https://patchwork.freedesktop.org/patch/msgid/20191007140812.10963-1-chris@chris-wilson.co.uk
    Link: https://patchwork.freedesktop.org/patch/msgid/20191007210942.18145-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
index edcab2df74fb..3c6246064a0b 100644
--- a/drivers/gpu/drm/i915/i915_perf_types.h
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -12,6 +12,7 @@
 #include <linux/list.h>
 #include <linux/poll.h>
 #include <linux/sysfs.h>
+#include <linux/types.h>
 #include <linux/uuid.h>
 #include <linux/wait.h>
 
@@ -124,9 +125,14 @@ struct i915_perf_stream_ops {
  */
 struct i915_perf_stream {
 	/**
-	 * @dev_priv: i915 drm device
+	 * @perf: i915_perf backpointer
 	 */
-	struct drm_i915_private *dev_priv;
+	struct i915_perf *perf;
+
+	/**
+	 * @gt: intel_gt container
+	 */
+	struct intel_gt *gt;
 
 	/**
 	 * @link: Links the stream into ``&drm_i915_private->streams``
@@ -266,20 +272,19 @@ struct i915_oa_ops {
 	 * @is_valid_b_counter_reg: Validates register's address for
 	 * programming boolean counters for a particular platform.
 	 */
-	bool (*is_valid_b_counter_reg)(struct drm_i915_private *dev_priv,
-				       u32 addr);
+	bool (*is_valid_b_counter_reg)(struct i915_perf *perf, u32 addr);
 
 	/**
 	 * @is_valid_mux_reg: Validates register's address for programming mux
 	 * for a particular platform.
 	 */
-	bool (*is_valid_mux_reg)(struct drm_i915_private *dev_priv, u32 addr);
+	bool (*is_valid_mux_reg)(struct i915_perf *perf, u32 addr);
 
 	/**
 	 * @is_valid_flex_reg: Validates register's address for programming
 	 * flex EU filtering for a particular platform.
 	 */
-	bool (*is_valid_flex_reg)(struct drm_i915_private *dev_priv, u32 addr);
+	bool (*is_valid_flex_reg)(struct i915_perf *perf, u32 addr);
 
 	/**
 	 * @enable_metric_set: Selects and applies any MUX configuration to set
@@ -324,4 +329,60 @@ struct i915_oa_ops {
 	u32 (*oa_hw_tail_read)(struct i915_perf_stream *stream);
 };
 
+struct i915_perf {
+	struct drm_i915_private *i915;
+
+	struct kobject *metrics_kobj;
+	struct ctl_table_header *sysctl_header;
+
+	/*
+	 * Lock associated with adding/modifying/removing OA configs
+	 * in dev_priv->perf.metrics_idr.
+	 */
+	struct mutex metrics_lock;
+
+	/*
+	 * List of dynamic configurations, you need to hold
+	 * dev_priv->perf.metrics_lock to access it.
+	 */
+	struct idr metrics_idr;
+
+	/*
+	 * Lock associated with anything below within this structure
+	 * except exclusive_stream.
+	 */
+	struct mutex lock;
+	struct list_head streams;
+
+	/*
+	 * The stream currently using the OA unit. If accessed
+	 * outside a syscall associated to its file
+	 * descriptor, you need to hold
+	 * dev_priv->drm.struct_mutex.
+	 */
+	struct i915_perf_stream *exclusive_stream;
+
+	/**
+	 * For rate limiting any notifications of spurious
+	 * invalid OA reports
+	 */
+	struct ratelimit_state spurious_report_rs;
+
+	struct i915_oa_config test_config;
+
+	u32 gen7_latched_oastatus1;
+	u32 ctx_oactxctrl_offset;
+	u32 ctx_flexeu0_offset;
+
+	/**
+	 * The RPT_ID/reason field for Gen8+ includes a bit
+	 * to determine if the CTX ID in the report is valid
+	 * but the specific bit differs between Gen 8 and 9
+	 */
+	u32 gen8_valid_ctx_bit;
+
+	struct i915_oa_ops ops;
+	const struct i915_oa_format *oa_formats;
+};
+
 #endif /* _I915_PERF_TYPES_H_ */

commit 1d0f2ebf392ef11465cefb29d545ed9e3222b29e
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Sep 9 12:31:09 2019 +0300

    drm/i915/perf: move perf types to their own header
    
    Following a pattern used throughout the driver.
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190909093116.7747-7-lionel.g.landwerlin@intel.com

diff --git a/drivers/gpu/drm/i915/i915_perf_types.h b/drivers/gpu/drm/i915/i915_perf_types.h
new file mode 100644
index 000000000000..edcab2df74fb
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_perf_types.h
@@ -0,0 +1,327 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright Â© 2019 Intel Corporation
+ */
+
+#ifndef _I915_PERF_TYPES_H_
+#define _I915_PERF_TYPES_H_
+
+#include <linux/atomic.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/list.h>
+#include <linux/poll.h>
+#include <linux/sysfs.h>
+#include <linux/uuid.h>
+#include <linux/wait.h>
+
+#include "i915_reg.h"
+#include "intel_wakeref.h"
+
+struct drm_i915_private;
+struct file;
+struct i915_gem_context;
+struct i915_vma;
+struct intel_context;
+struct intel_engine_cs;
+
+struct i915_oa_format {
+	u32 format;
+	int size;
+};
+
+struct i915_oa_reg {
+	i915_reg_t addr;
+	u32 value;
+};
+
+struct i915_oa_config {
+	char uuid[UUID_STRING_LEN + 1];
+	int id;
+
+	const struct i915_oa_reg *mux_regs;
+	u32 mux_regs_len;
+	const struct i915_oa_reg *b_counter_regs;
+	u32 b_counter_regs_len;
+	const struct i915_oa_reg *flex_regs;
+	u32 flex_regs_len;
+
+	struct attribute_group sysfs_metric;
+	struct attribute *attrs[2];
+	struct device_attribute sysfs_metric_id;
+
+	atomic_t ref_count;
+};
+
+struct i915_perf_stream;
+
+/**
+ * struct i915_perf_stream_ops - the OPs to support a specific stream type
+ */
+struct i915_perf_stream_ops {
+	/**
+	 * @enable: Enables the collection of HW samples, either in response to
+	 * `I915_PERF_IOCTL_ENABLE` or implicitly called when stream is opened
+	 * without `I915_PERF_FLAG_DISABLED`.
+	 */
+	void (*enable)(struct i915_perf_stream *stream);
+
+	/**
+	 * @disable: Disables the collection of HW samples, either in response
+	 * to `I915_PERF_IOCTL_DISABLE` or implicitly called before destroying
+	 * the stream.
+	 */
+	void (*disable)(struct i915_perf_stream *stream);
+
+	/**
+	 * @poll_wait: Call poll_wait, passing a wait queue that will be woken
+	 * once there is something ready to read() for the stream
+	 */
+	void (*poll_wait)(struct i915_perf_stream *stream,
+			  struct file *file,
+			  poll_table *wait);
+
+	/**
+	 * @wait_unlocked: For handling a blocking read, wait until there is
+	 * something to ready to read() for the stream. E.g. wait on the same
+	 * wait queue that would be passed to poll_wait().
+	 */
+	int (*wait_unlocked)(struct i915_perf_stream *stream);
+
+	/**
+	 * @read: Copy buffered metrics as records to userspace
+	 * **buf**: the userspace, destination buffer
+	 * **count**: the number of bytes to copy, requested by userspace
+	 * **offset**: zero at the start of the read, updated as the read
+	 * proceeds, it represents how many bytes have been copied so far and
+	 * the buffer offset for copying the next record.
+	 *
+	 * Copy as many buffered i915 perf samples and records for this stream
+	 * to userspace as will fit in the given buffer.
+	 *
+	 * Only write complete records; returning -%ENOSPC if there isn't room
+	 * for a complete record.
+	 *
+	 * Return any error condition that results in a short read such as
+	 * -%ENOSPC or -%EFAULT, even though these may be squashed before
+	 * returning to userspace.
+	 */
+	int (*read)(struct i915_perf_stream *stream,
+		    char __user *buf,
+		    size_t count,
+		    size_t *offset);
+
+	/**
+	 * @destroy: Cleanup any stream specific resources.
+	 *
+	 * The stream will always be disabled before this is called.
+	 */
+	void (*destroy)(struct i915_perf_stream *stream);
+};
+
+/**
+ * struct i915_perf_stream - state for a single open stream FD
+ */
+struct i915_perf_stream {
+	/**
+	 * @dev_priv: i915 drm device
+	 */
+	struct drm_i915_private *dev_priv;
+
+	/**
+	 * @link: Links the stream into ``&drm_i915_private->streams``
+	 */
+	struct list_head link;
+
+	/**
+	 * @wakeref: As we keep the device awake while the perf stream is
+	 * active, we track our runtime pm reference for later release.
+	 */
+	intel_wakeref_t wakeref;
+
+	/**
+	 * @sample_flags: Flags representing the `DRM_I915_PERF_PROP_SAMPLE_*`
+	 * properties given when opening a stream, representing the contents
+	 * of a single sample as read() by userspace.
+	 */
+	u32 sample_flags;
+
+	/**
+	 * @sample_size: Considering the configured contents of a sample
+	 * combined with the required header size, this is the total size
+	 * of a single sample record.
+	 */
+	int sample_size;
+
+	/**
+	 * @ctx: %NULL if measuring system-wide across all contexts or a
+	 * specific context that is being monitored.
+	 */
+	struct i915_gem_context *ctx;
+
+	/**
+	 * @enabled: Whether the stream is currently enabled, considering
+	 * whether the stream was opened in a disabled state and based
+	 * on `I915_PERF_IOCTL_ENABLE` and `I915_PERF_IOCTL_DISABLE` calls.
+	 */
+	bool enabled;
+
+	/**
+	 * @ops: The callbacks providing the implementation of this specific
+	 * type of configured stream.
+	 */
+	const struct i915_perf_stream_ops *ops;
+
+	/**
+	 * @oa_config: The OA configuration used by the stream.
+	 */
+	struct i915_oa_config *oa_config;
+
+	/**
+	 * @pinned_ctx: The OA context specific information.
+	 */
+	struct intel_context *pinned_ctx;
+	u32 specific_ctx_id;
+	u32 specific_ctx_id_mask;
+
+	struct hrtimer poll_check_timer;
+	wait_queue_head_t poll_wq;
+	bool pollin;
+
+	bool periodic;
+	int period_exponent;
+
+	/**
+	 * @oa_buffer: State of the OA buffer.
+	 */
+	struct {
+		struct i915_vma *vma;
+		u8 *vaddr;
+		u32 last_ctx_id;
+		int format;
+		int format_size;
+		int size_exponent;
+
+		/**
+		 * @ptr_lock: Locks reads and writes to all head/tail state
+		 *
+		 * Consider: the head and tail pointer state needs to be read
+		 * consistently from a hrtimer callback (atomic context) and
+		 * read() fop (user context) with tail pointer updates happening
+		 * in atomic context and head updates in user context and the
+		 * (unlikely) possibility of read() errors needing to reset all
+		 * head/tail state.
+		 *
+		 * Note: Contention/performance aren't currently a significant
+		 * concern here considering the relatively low frequency of
+		 * hrtimer callbacks (5ms period) and that reads typically only
+		 * happen in response to a hrtimer event and likely complete
+		 * before the next callback.
+		 *
+		 * Note: This lock is not held *while* reading and copying data
+		 * to userspace so the value of head observed in htrimer
+		 * callbacks won't represent any partial consumption of data.
+		 */
+		spinlock_t ptr_lock;
+
+		/**
+		 * @tails: One 'aging' tail pointer and one 'aged' tail pointer ready to
+		 * used for reading.
+		 *
+		 * Initial values of 0xffffffff are invalid and imply that an
+		 * update is required (and should be ignored by an attempted
+		 * read)
+		 */
+		struct {
+			u32 offset;
+		} tails[2];
+
+		/**
+		 * @aged_tail_idx: Index for the aged tail ready to read() data up to.
+		 */
+		unsigned int aged_tail_idx;
+
+		/**
+		 * @aging_timestamp: A monotonic timestamp for when the current aging tail pointer
+		 * was read; used to determine when it is old enough to trust.
+		 */
+		u64 aging_timestamp;
+
+		/**
+		 * @head: Although we can always read back the head pointer register,
+		 * we prefer to avoid trusting the HW state, just to avoid any
+		 * risk that some hardware condition could * somehow bump the
+		 * head pointer unpredictably and cause us to forward the wrong
+		 * OA buffer data to userspace.
+		 */
+		u32 head;
+	} oa_buffer;
+};
+
+/**
+ * struct i915_oa_ops - Gen specific implementation of an OA unit stream
+ */
+struct i915_oa_ops {
+	/**
+	 * @is_valid_b_counter_reg: Validates register's address for
+	 * programming boolean counters for a particular platform.
+	 */
+	bool (*is_valid_b_counter_reg)(struct drm_i915_private *dev_priv,
+				       u32 addr);
+
+	/**
+	 * @is_valid_mux_reg: Validates register's address for programming mux
+	 * for a particular platform.
+	 */
+	bool (*is_valid_mux_reg)(struct drm_i915_private *dev_priv, u32 addr);
+
+	/**
+	 * @is_valid_flex_reg: Validates register's address for programming
+	 * flex EU filtering for a particular platform.
+	 */
+	bool (*is_valid_flex_reg)(struct drm_i915_private *dev_priv, u32 addr);
+
+	/**
+	 * @enable_metric_set: Selects and applies any MUX configuration to set
+	 * up the Boolean and Custom (B/C) counters that are part of the
+	 * counter reports being sampled. May apply system constraints such as
+	 * disabling EU clock gating as required.
+	 */
+	int (*enable_metric_set)(struct i915_perf_stream *stream);
+
+	/**
+	 * @disable_metric_set: Remove system constraints associated with using
+	 * the OA unit.
+	 */
+	void (*disable_metric_set)(struct i915_perf_stream *stream);
+
+	/**
+	 * @oa_enable: Enable periodic sampling
+	 */
+	void (*oa_enable)(struct i915_perf_stream *stream);
+
+	/**
+	 * @oa_disable: Disable periodic sampling
+	 */
+	void (*oa_disable)(struct i915_perf_stream *stream);
+
+	/**
+	 * @read: Copy data from the circular OA buffer into a given userspace
+	 * buffer.
+	 */
+	int (*read)(struct i915_perf_stream *stream,
+		    char __user *buf,
+		    size_t count,
+		    size_t *offset);
+
+	/**
+	 * @oa_hw_tail_read: read the OA tail pointer register
+	 *
+	 * In particular this enables us to share all the fiddly code for
+	 * handling the OA unit tail pointer race that affects multiple
+	 * generations.
+	 */
+	u32 (*oa_hw_tail_read)(struct i915_perf_stream *stream);
+};
+
+#endif /* _I915_PERF_TYPES_H_ */
