commit 875c3b4b5c2fb8190f3e60b3b0f7c55c05b2255a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 9 11:09:31 2020 +0000

    drm/i915/gt: Mark up racy check of last list element
    
    [   25.025543] BUG: KCSAN: data-race in __i915_request_create [i915] / process_csb [i915]
    [   25.025561]
    [   25.025573] write (marked) to 0xffff8881e85c1620 of 8 bytes by task 696 on cpu 1:
    [   25.025789]  __i915_request_create+0x54b/0x5d0 [i915]
    [   25.026001]  i915_request_create+0xcc/0x150 [i915]
    [   25.026218]  i915_gem_do_execbuffer+0x2f70/0x4c20 [i915]
    [   25.026428]  i915_gem_execbuffer2_ioctl+0x2c3/0x580 [i915]
    [   25.026445]  drm_ioctl_kernel+0xe4/0x120
    [   25.026459]  drm_ioctl+0x297/0x4c7
    [   25.026472]  ksys_ioctl+0x89/0xb0
    [   25.026484]  __x64_sys_ioctl+0x42/0x60
    [   25.026497]  do_syscall_64+0x6e/0x2c0
    [   25.026510]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [   25.026522]
    [   25.026532] read to 0xffff8881e85c1620 of 8 bytes by interrupt on cpu 2:
    [   25.026742]  process_csb+0x8d6/0x1070 [i915]
    [   25.026949]  execlists_submission_tasklet+0x30/0x170 [i915]
    [   25.026969]  tasklet_action_common.isra.0+0x42/0xa0
    [   25.026984]  __do_softirq+0xd7/0x2cd
    [   25.026997]  irq_exit+0xbe/0xe0
    [   25.027009]  do_IRQ+0x51/0x100
    [   25.027021]  ret_from_intr+0x0/0x1c
    [   25.027033]  poll_idle+0x3e/0x13b
    [   25.027047]  cpuidle_enter_state+0x189/0x5d0
    [   25.027060]  cpuidle_enter+0x50/0x90
    [   25.027074]  do_idle+0x1a1/0x1f0
    [   25.027086]  cpu_startup_entry+0x14/0x16
    [   25.027100]  start_secondary+0x120/0x180
    [   25.027116]  secondary_startup_64+0xa4/0xb0
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200309110934.868-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 26f3a4a50b40..03a73d2bd50d 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -260,6 +260,12 @@ static inline void __list_del_many(struct list_head *head,
 	WRITE_ONCE(head->next, first);
 }
 
+static inline int list_is_last_rcu(const struct list_head *list,
+				   const struct list_head *head)
+{
+	return READ_ONCE(list->next) == head;
+}
+
 /*
  * Wait until the work is finally complete, even if it tries to postpone
  * by requeueing itself. Note, that if the worker never cancels itself,

commit 520f8350364dc0f1cfcb82360f9e22400dd7887d
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Fri Mar 6 09:47:35 2020 +0000

    drm/i915: properly sanity check batch_start_offset
    
    Check the edge case where batch_start_offset sits exactly on the batch
    size.
    
    v2: add new range_overflows variant to capture the special case where
    the size is permitted to be zero, like with batch_len.
    
    v3: other way around. the common case is the exclusive one which should
    just be >=, with that we then just need to convert the three odd ball
    cases that don't apply to use the new inclusive _end version.
    
    Testcase: igt/gem_exec_params/invalid-batch-start-offset
    Fixes: 0b5372727be3 ("drm/i915/cmdparser: Use cached vmappings")
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200306094735.258285-1-matthew.auld@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 024a9e224ff3..26f3a4a50b40 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -102,12 +102,24 @@ bool i915_error_injected(void);
 	typeof(max) max__ = (max); \
 	(void)(&start__ == &size__); \
 	(void)(&start__ == &max__); \
-	start__ > max__ || size__ > max__ - start__; \
+	start__ >= max__ || size__ > max__ - start__; \
 })
 
 #define range_overflows_t(type, start, size, max) \
 	range_overflows((type)(start), (type)(size), (type)(max))
 
+#define range_overflows_end(start, size, max) ({ \
+	typeof(start) start__ = (start); \
+	typeof(size) size__ = (size); \
+	typeof(max) max__ = (max); \
+	(void)(&start__ == &size__); \
+	(void)(&start__ == &max__); \
+	start__ > max__ || size__ > max__ - start__; \
+})
+
+#define range_overflows_end_t(type, start, size, max) \
+	range_overflows_end((type)(start), (type)(size), (type)(max))
+
 /* Note we don't consider signbits :| */
 #define overflows_type(x, T) \
 	(sizeof(x) > sizeof(T) && (x) >> BITS_PER_TYPE(T))

commit 2920516b2f719546f55079bc39a7fe409d9e80ab
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Thu Mar 5 20:35:34 2020 +0000

    drm/i915: be more solid in checking the alignment
    
    The alignment is u64, and yet is_power_of_2() assumes unsigned long,
    which might give different results between 32b and 64b kernel.
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200305203534.210466-1-matthew.auld@intel.com
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index cae0ae520398..024a9e224ff3 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -236,6 +236,11 @@ static inline u64 ptr_to_u64(const void *ptr)
 	__idx;								\
 })
 
+static inline bool is_power_of_2_u64(u64 n)
+{
+	return (n != 0 && ((n & (n - 1)) == 0));
+}
+
 static inline void __list_del_many(struct list_head *head,
 				   struct list_head *first)
 {

commit 17f5d57915be108b4967b7770c9ea87c493b30a7
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 3 16:53:18 2020 -0500

    drm/i915: Force DPCD backlight mode on X1 Extreme 2nd Gen 4K AMOLED panel
    
    The X1 Extreme is one of the systems that lies about which backlight
    interface that it uses in its VBIOS as PWM backlight controls don't work
    at all on this machine. It's possible that this panel could be one of
    the infamous ones that can switch between PWM mode and DPCD backlight
    control mode, but we haven't gotten any more details on this from Lenovo
    just yet. For the time being though, making sure the backlight 'just
    works' is a bit more important.
    
    So, add a quirk to force DPCD backlight controls on for these systems
    based on EDID (since this panel doesn't appear to fill in the device ID).
    Hopefully in the future we'll figure out a better way of probing this.
    
    Changes since v2:
    * The bugzilla URL is deprecated, bug reporting happens on gitlab now.
      Update the messages we print to reflect this
    * Also, take the opportunity to move FDO_BUG_URL out of i915_utils.c and
      into i915_utils.h so that other places which print things that aren't
      traditional errors but are worth filing bugs about, can actually use
      it.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200303215320.93491-1-lyude@redhat.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index b0ade76bec90..cae0ae520398 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -34,6 +34,8 @@
 struct drm_i915_private;
 struct timer_list;
 
+#define FDO_BUG_URL "https://gitlab.freedesktop.org/drm/intel/-/wikis/How-to-file-i915-bugs"
+
 #undef WARN_ON
 /* Many gcc seem to no see through this and fall over :( */
 #if 0

commit b58a8813ee6d65e98ee02b3d3036c6a75ac7e694
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Dec 12 12:19:03 2019 +0000

    drm/i915: Improve i915_inject_probe_error macro
    
    On non-debug builds we were not using i915 param and thus
    we may cause "unused variable" warning/error if caller was
    not using i915 elsewhere. Let compiler see this param.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191212121903.72524-1-michal.wajdeczko@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 04139ba1191e..b0ade76bec90 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -69,7 +69,7 @@ bool i915_error_injected(void);
 
 #else
 
-#define i915_inject_probe_error(_i915, _err) 0
+#define i915_inject_probe_error(i915, e) ({ BUILD_BUG_ON_INVALID(i915); 0; })
 #define i915_error_injected() false
 
 #endif

commit dd6e38dfc1286d307489a1ad890a87e096d9873b
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Tue Oct 29 11:20:35 2019 +0100

    drm/i915: Fix i915_inject_load_error() name to read *_probe_*
    
    Commit 50d84418f586 ("drm/i915: Add i915 to i915_inject_probe_failure")
    introduced new functions unfortunately named incompatibly with rules
    established by commit f2db53f14d3d ("drm/i915: Replace "_load" with
    "_probe" consequently").  Fix it for consistency.
    
    Suggested-by: Michał Wajdeczko <michal.wajdeczko@intel.com>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Cc: Michał Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Piotr Piórkowski <piotr.piorkowski@intel.com>
    Cc: Tomasz Lis <tomasz.lis@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191029102036.6326-2-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 00b55252ef51..04139ba1191e 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -61,20 +61,20 @@ __i915_printk(struct drm_i915_private *dev_priv, const char *level,
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
 
-int __i915_inject_load_error(struct drm_i915_private *i915, int err,
-			     const char *func, int line);
-#define i915_inject_load_error(_i915, _err) \
-	__i915_inject_load_error((_i915), (_err), __func__, __LINE__)
+int __i915_inject_probe_error(struct drm_i915_private *i915, int err,
+			      const char *func, int line);
+#define i915_inject_probe_error(_i915, _err) \
+	__i915_inject_probe_error((_i915), (_err), __func__, __LINE__)
 bool i915_error_injected(void);
 
 #else
 
-#define i915_inject_load_error(_i915, _err) 0
+#define i915_inject_probe_error(_i915, _err) 0
 #define i915_error_injected() false
 
 #endif
 
-#define i915_inject_probe_failure(i915) i915_inject_load_error((i915), -ENODEV)
+#define i915_inject_probe_failure(i915) i915_inject_probe_error((i915), -ENODEV)
 
 #define i915_probe_error(i915, fmt, ...)				   \
 	__i915_printk(i915, i915_error_injected() ? KERN_DEBUG : KERN_ERR, \

commit babaab2f473817f173a2d08e410c25abf5ed0f6b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 25 14:59:42 2019 +0100

    drm/i915: Encapsulate kconfig constant values inside boolean predicates
    
    Avoid angering clang and smatch by using a constant value in a '&&' test,
    by forcing that constant value into a boolean.
    
    E.g.,
    drivers/gpu/drm/i915/gt/intel_engine_heartbeat.c:159:13: warning: use of logical '&&' with constant operand [-Wconstant-logical-operand]
            if (!delay && CONFIG_DRM_I915_PREEMPT_TIMEOUT) {
                          ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191025135943.12524-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 94f136d8a5fd..00b55252ef51 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -430,4 +430,17 @@ static inline bool timer_expired(const struct timer_list *t)
 	return READ_ONCE(t->expires) && !timer_pending(t);
 }
 
+/*
+ * This is a lookalike for IS_ENABLED() that takes a kconfig value,
+ * e.g. CONFIG_DRM_I915_SPIN_REQUEST, and evaluates whether it is non-zero
+ * i.e. whether the configuration is active. Wrapping up the config inside
+ * a boolean context prevents clang and smatch from complaining about potential
+ * issues in confusing logical-&& with bitwise-& for constants.
+ *
+ * Sadly IS_ENABLED() itself does not work with kconfig values.
+ *
+ * Returns 0 if @config is 0, 1 if set to any value.
+ */
+#define IS_ACTIVE(config) ((config) != 0)
+
 #endif /* !__I915_UTILS_H */

commit 3a7a92aba8fb77162e1e9963360fd81fc15c39a5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 23 14:31:05 2019 +0100

    drm/i915/execlists: Force preemption
    
    If the preempted context takes too long to relinquish control, e.g. it
    is stuck inside a shader with arbitration disabled, evict that context
    with an engine reset. This ensures that preemptions are reasonably
    responsive, providing a tighter QoS for the more important context at
    the cost of flagging unresponsive contexts more frequently (i.e. instead
    of using an ~10s hangcheck, we now evict at ~100ms).  The challenge of
    lies in picking a timeout that can be reasonably serviced by HW for
    typical workloads, balancing the existing clients against the needs for
    responsiveness.
    
    Note that coupled with timeslicing, this will lead to rapid GPU "hang"
    detection with multiple active contexts vying for GPU time.
    
    The forced preemption mechanism can be compiled out with
    
            ./scripts/config --set-val DRM_I915_PREEMPT_TIMEOUT 0
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191023133108.21401-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 562f756da421..94f136d8a5fd 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -32,6 +32,7 @@
 #include <linux/workqueue.h>
 
 struct drm_i915_private;
+struct timer_list;
 
 #undef WARN_ON
 /* Many gcc seem to no see through this and fall over :( */
@@ -421,4 +422,12 @@ static inline void add_taint_for_CI(unsigned int taint)
 	add_taint(taint, LOCKDEP_STILL_OK);
 }
 
+void cancel_timer(struct timer_list *t);
+void set_timer_ms(struct timer_list *t, unsigned long timeout);
+
+static inline bool timer_expired(const struct timer_list *t)
+{
+	return READ_ONCE(t->expires) && !timer_pending(t);
+}
+
 #endif /* !__I915_UTILS_H */

commit df403069029dc61e0fc09cbeb0b5900705edec5b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 16 18:16:08 2019 +0100

    drm/i915/execlists: Lift process_csb() out of the irq-off spinlock
    
    If we only call process_csb() from the tasklet, though we lose the
    ability to bypass ksoftirqd interrupt processing on direct submission
    paths, we can push it out of the irq-off spinlock.
    
    The penalty is that we then allow schedule_out to be called concurrently
    with schedule_in requiring us to handle the usage count (baked into the
    pointer itself) atomically.
    
    As we do kick the tasklets (via local_bh_enable()) after our submission,
    there is a possibility there to see if we can pull the local softirq
    processing back from the ksoftirqd.
    
    v2: Store the 'switch_priority_hint' on submission, so that we can
    safely check during process_csb().
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190816171608.11760-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index d652ba5d2320..562f756da421 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -161,17 +161,15 @@ __check_struct_size(size_t base, size_t arr, size_t count, size_t *size)
 	((typeof(ptr))((unsigned long)(ptr) | __bits));			\
 })
 
-#define ptr_count_dec(p_ptr) do {					\
-	typeof(p_ptr) __p = (p_ptr);					\
-	unsigned long __v = (unsigned long)(*__p);			\
-	*__p = (typeof(*p_ptr))(--__v);					\
-} while (0)
-
-#define ptr_count_inc(p_ptr) do {					\
-	typeof(p_ptr) __p = (p_ptr);					\
-	unsigned long __v = (unsigned long)(*__p);			\
-	*__p = (typeof(*p_ptr))(++__v);					\
-} while (0)
+#define ptr_dec(ptr) ({							\
+	unsigned long __v = (unsigned long)(ptr);			\
+	(typeof(ptr))(__v - 1);						\
+})
+
+#define ptr_inc(ptr) ({							\
+	unsigned long __v = (unsigned long)(ptr);			\
+	(typeof(ptr))(__v + 1);						\
+})
 
 #define page_mask_bits(ptr) ptr_mask_bits(ptr, PAGE_SHIFT)
 #define page_unmask_bits(ptr) ptr_unmask_bits(ptr, PAGE_SHIFT)

commit 358c855cb60a27a2e91e002604d2c9ed03bdcb96
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:43 2019 +0300

    drm/i915: move printing and load error inject to i915_utils.[ch]
    
    Seems like a better fit. Reduce clutter in i915_drv.[ch].
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/bc458fa5e62fc8dae46216666f64ed6976fafaee.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 0c0fda36334d..d652ba5d2320 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -31,6 +31,8 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 
+struct drm_i915_private;
+
 #undef WARN_ON
 /* Many gcc seem to no see through this and fall over :( */
 #if 0
@@ -49,6 +51,34 @@
 #define MISSING_CASE(x) WARN(1, "Missing case (%s == %ld)\n", \
 			     __stringify(x), (long)(x))
 
+void __printf(3, 4)
+__i915_printk(struct drm_i915_private *dev_priv, const char *level,
+	      const char *fmt, ...);
+
+#define i915_report_error(dev_priv, fmt, ...)				   \
+	__i915_printk(dev_priv, KERN_ERR, fmt, ##__VA_ARGS__)
+
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
+
+int __i915_inject_load_error(struct drm_i915_private *i915, int err,
+			     const char *func, int line);
+#define i915_inject_load_error(_i915, _err) \
+	__i915_inject_load_error((_i915), (_err), __func__, __LINE__)
+bool i915_error_injected(void);
+
+#else
+
+#define i915_inject_load_error(_i915, _err) 0
+#define i915_error_injected() false
+
+#endif
+
+#define i915_inject_probe_failure(i915) i915_inject_load_error((i915), -ENODEV)
+
+#define i915_probe_error(i915, fmt, ...)				   \
+	__i915_printk(i915, i915_error_injected() ? KERN_DEBUG : KERN_ERR, \
+		      fmt, ##__VA_ARGS__)
+
 #if defined(GCC_VERSION) && GCC_VERSION >= 70000
 #define add_overflows_t(T, A, B) \
 	__builtin_add_overflow_p((A), (B), (T)0)

commit e3adffe838ffe0f400cc69248ee605493d083dc2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Aug 8 16:42:41 2019 +0300

    drm/i915: move add_taint_for_CI() to i915_utils.h
    
    Seems like a better fit. Reduce clutter in i915_drv.h.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/a82d8c4e95496b3b4a9a251b655ea56a35c9d752.1565271681.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 4920ff9aba62..0c0fda36334d 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -382,4 +382,15 @@ static inline const char *enableddisabled(bool v)
 	return v ? "enabled" : "disabled";
 }
 
+static inline void add_taint_for_CI(unsigned int taint)
+{
+	/*
+	 * The system is "ok", just about surviving for the user, but
+	 * CI results are now unreliable as the HW is very suspect.
+	 * CI checks the taint state after every test and will reboot
+	 * the machine if the kernel is tainted.
+	 */
+	add_taint(taint, LOCKDEP_STILL_OK);
+}
+
 #endif /* !__I915_UTILS_H */

commit 22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jun 20 15:20:51 2019 +0100

    drm/i915/execlists: Preempt-to-busy
    
    When using a global seqno, we required a precise stop-the-workd event to
    handle preemption and unwind the global seqno counter. To accomplish
    this, we would preempt to a special out-of-band context and wait for the
    machine to report that it was idle. Given an idle machine, we could very
    precisely see which requests had completed and which we needed to feed
    back into the run queue.
    
    However, now that we have scrapped the global seqno, we no longer need
    to precisely unwind the global counter and only track requests by their
    per-context seqno. This allows us to loosely unwind inflight requests
    while scheduling a preemption, with the enormous caveat that the
    requests we put back on the run queue are still _inflight_ (until the
    preemption request is complete). This makes request tracking much more
    messy, as at any point then we can see a completed request that we
    believe is not currently scheduled for execution. We also have to be
    careful not to rewind RING_TAIL past RING_HEAD on preempting to the
    running context, and for this we use a semaphore to prevent completion
    of the request before continuing.
    
    To accomplish this feat, we change how we track requests scheduled to
    the HW. Instead of appending our requests onto a single list as we
    submit, we track each submission to ELSP as its own block. Then upon
    receiving the CS preemption event, we promote the pending block to the
    inflight block (discarding what was previously being tracked). As normal
    CS completion events arrive, we then remove stale entries from the
    inflight tracker.
    
    v2: Be a tinge paranoid and ensure we flush the write into the HWS page
    for the GPU semaphore to pick in a timely fashion.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190620142052.19311-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 2987219a6300..4920ff9aba62 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -131,6 +131,18 @@ __check_struct_size(size_t base, size_t arr, size_t count, size_t *size)
 	((typeof(ptr))((unsigned long)(ptr) | __bits));			\
 })
 
+#define ptr_count_dec(p_ptr) do {					\
+	typeof(p_ptr) __p = (p_ptr);					\
+	unsigned long __v = (unsigned long)(*__p);			\
+	*__p = (typeof(*p_ptr))(--__v);					\
+} while (0)
+
+#define ptr_count_inc(p_ptr) do {					\
+	typeof(p_ptr) __p = (p_ptr);					\
+	unsigned long __v = (unsigned long)(*__p);			\
+	*__p = (typeof(*p_ptr))(++__v);					\
+} while (0)
+
 #define page_mask_bits(ptr) ptr_mask_bits(ptr, PAGE_SHIFT)
 #define page_unmask_bits(ptr) ptr_unmask_bits(ptr, PAGE_SHIFT)
 #define page_pack_bits(ptr, bits) ptr_pack_bits(ptr, bits, PAGE_SHIFT)

commit d45a1a533499d3ef1f3d9b750de93306f0c3dbe8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 28 10:29:52 2019 +0100

    drm/i915: Move GEM object waiting to its own file
    
    Continuing the decluttering of i915_gem.c by moving the object wait
    decomposition into its own file.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190528092956.14910-11-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index e52866084891..2987219a6300 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -220,16 +220,6 @@ static inline unsigned long msecs_to_jiffies_timeout(const unsigned int m)
 	return min_t(unsigned long, MAX_JIFFY_OFFSET, j + 1);
 }
 
-static inline unsigned long nsecs_to_jiffies_timeout(const u64 n)
-{
-	/* nsecs_to_jiffies64() does not guard against overflow */
-	if (NSEC_PER_SEC % HZ &&
-	    div_u64(n, NSEC_PER_SEC) >= MAX_JIFFY_OFFSET / HZ)
-		return MAX_JIFFY_OFFSET;
-
-        return min_t(u64, MAX_JIFFY_OFFSET, nsecs_to_jiffies64(n) + 1);
-}
-
 /*
  * If you need to wait X milliseconds between events A and B, but event B
  * doesn't happen exactly after event A, you record the timestamp (jiffies) of

commit 976b55f0e1db5cb8fccb0a42f68ea77ae42604a6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:26 2019 +0100

    drm/i915: Allow a context to define its set of engines
    
    Over the last few years, we have debated how to extend the user API to
    support an increase in the number of engines, that may be sparse and
    even be heterogeneous within a class (not all video decoders created
    equal). We settled on using (class, instance) tuples to identify a
    specific engine, with an API for the user to construct a map of engines
    to capabilities. Into this picture, we then add a challenge of virtual
    engines; one user engine that maps behind the scenes to any number of
    physical engines. To keep it general, we want the user to have full
    control over that mapping. To that end, we allow the user to constrain a
    context to define the set of engines that it can access, order fully
    controlled by the user via (class, instance). With such precise control
    in context setup, we can continue to use the existing execbuf uABI of
    specifying a single index; only now it doesn't automagically map onto
    the engines, it uses the user defined engine map from the context.
    
    v2: Fixup freeing of local on success of get_engines()
    v3: Allow empty engines[]
    v4: s/nengine/num_engines/
    v5: Replace 64 limit on num_engines with a note that execbuf is
    currently limited to only using the first 64 engines.
    v6: Actually use the engines_mutex to guard the ctx->engines.
    
    Testcase: igt/gem_ctx_engines
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 5c94c7ab4607..e52866084891 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -26,6 +26,7 @@
 #define __I915_UTILS_H
 
 #include <linux/list.h>
+#include <linux/overflow.h>
 #include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/workqueue.h>
@@ -78,6 +79,39 @@
 #define overflows_type(x, T) \
 	(sizeof(x) > sizeof(T) && (x) >> BITS_PER_TYPE(T))
 
+static inline bool
+__check_struct_size(size_t base, size_t arr, size_t count, size_t *size)
+{
+	size_t sz;
+
+	if (check_mul_overflow(count, arr, &sz))
+		return false;
+
+	if (check_add_overflow(sz, base, &sz))
+		return false;
+
+	*size = sz;
+	return true;
+}
+
+/**
+ * check_struct_size() - Calculate size of structure with trailing array.
+ * @p: Pointer to the structure.
+ * @member: Name of the array member.
+ * @n: Number of elements in the array.
+ * @sz: Total size of structure and array
+ *
+ * Calculates size of memory needed for structure @p followed by an
+ * array of @n @member elements, like struct_size() but reports
+ * whether it overflowed, and the resultant size in @sz
+ *
+ * Return: false if the calculation overflowed.
+ */
+#define check_struct_size(p, member, n, sz) \
+	likely(__check_struct_size(sizeof(*(p)), \
+				   sizeof(*(p)->member) + __must_be_array((p)->member), \
+				   n, sz))
+
 #define ptr_mask_bits(ptr, n) ({					\
 	unsigned long __v = (unsigned long)(ptr);			\
 	(typeof(ptr))(__v & -BIT(n));					\

commit 4547c255f4420e20c6cda2ee4172ae68b323e695
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu May 9 20:34:36 2019 +0300

    drm/i915: Add support for tracking wakerefs w/o power-on guarantee
    
    It's useful to track runtime PM refs that don't guarantee a device
    power-on state to the rest of the driver. One such case is holding a
    reference that will be put asynchronously, during which normal users
    without their own reference shouldn't access the HW. A follow-up patch
    will add support for disabling display power domains asynchronously
    which needs this.
    
    For this we can split wakeref_count into a low half-word tracking
    all references (raw-wakerefs) and a high half-word tracking
    references guaranteeing a power-on state (wakelocks).
    
    Follow-up patches will make use of the API added here.
    
    While at it add the missing docbook header for the unchecked
    display-power and runtime_pm put functions.
    
    No functional changes, except for printing leaked raw-wakerefs
    and wakelocks separately in intel_runtime_pm_cleanup().
    
    v2:
    - Track raw wakerefs/wakelocks in the low/high half-word of
      wakeref_count, instead of adding a new counter. (Chris)
    v3:
    - Add a struct_member(T, m) helper instead of open-coding it. (Chris)
    - Checkpatch indentation formatting fix.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190509173446.31095-2-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index c849cfa7cb28..5c94c7ab4607 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -102,6 +102,8 @@
 #define page_pack_bits(ptr, bits) ptr_pack_bits(ptr, bits, PAGE_SHIFT)
 #define page_unpack_bits(ptr, bits) ptr_unpack_bits(ptr, bits, PAGE_SHIFT)
 
+#define struct_member(T, member) (((T *)0)->member)
+
 #define ptr_offset(ptr, member) offsetof(typeof(*(ptr)), member)
 
 #define fetch_and_zero(ptr) ({						\
@@ -118,7 +120,7 @@
  */
 #define container_of_user(ptr, type, member) ({				\
 	void __user *__mptr = (void __user *)(ptr);			\
-	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
+	BUILD_BUG_ON_MSG(!__same_type(*(ptr), struct_member(type, member)) && \
 			 !__same_type(*(ptr), void),			\
 			 "pointer type mismatch in container_of()");	\
 	((type __user *)(__mptr - offsetof(type, member))); })

commit b30ed4cc2e8a5a1be4c6d85d6e18d08262749683
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 2 18:02:46 2019 +0300

    drm/i915: move more generic utils to i915_utils.h
    
    Reduce clutter from i915_drv.h and intel_drv.h.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/8c197872384fc35442b738c21ba0da9336e02a85.1556809195.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 26117bf7da0c..c849cfa7cb28 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -26,6 +26,7 @@
 #define __I915_UTILS_H
 
 #include <linux/list.h>
+#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/workqueue.h>
 
@@ -176,6 +177,158 @@ static inline void drain_delayed_work(struct delayed_work *dw)
 	} while (delayed_work_pending(dw));
 }
 
+static inline unsigned long msecs_to_jiffies_timeout(const unsigned int m)
+{
+	unsigned long j = msecs_to_jiffies(m);
+
+	return min_t(unsigned long, MAX_JIFFY_OFFSET, j + 1);
+}
+
+static inline unsigned long nsecs_to_jiffies_timeout(const u64 n)
+{
+	/* nsecs_to_jiffies64() does not guard against overflow */
+	if (NSEC_PER_SEC % HZ &&
+	    div_u64(n, NSEC_PER_SEC) >= MAX_JIFFY_OFFSET / HZ)
+		return MAX_JIFFY_OFFSET;
+
+        return min_t(u64, MAX_JIFFY_OFFSET, nsecs_to_jiffies64(n) + 1);
+}
+
+/*
+ * If you need to wait X milliseconds between events A and B, but event B
+ * doesn't happen exactly after event A, you record the timestamp (jiffies) of
+ * when event A happened, then just before event B you call this function and
+ * pass the timestamp as the first argument, and X as the second argument.
+ */
+static inline void
+wait_remaining_ms_from_jiffies(unsigned long timestamp_jiffies, int to_wait_ms)
+{
+	unsigned long target_jiffies, tmp_jiffies, remaining_jiffies;
+
+	/*
+	 * Don't re-read the value of "jiffies" every time since it may change
+	 * behind our back and break the math.
+	 */
+	tmp_jiffies = jiffies;
+	target_jiffies = timestamp_jiffies +
+			 msecs_to_jiffies_timeout(to_wait_ms);
+
+	if (time_after(target_jiffies, tmp_jiffies)) {
+		remaining_jiffies = target_jiffies - tmp_jiffies;
+		while (remaining_jiffies)
+			remaining_jiffies =
+			    schedule_timeout_uninterruptible(remaining_jiffies);
+	}
+}
+
+/**
+ * __wait_for - magic wait macro
+ *
+ * Macro to help avoid open coding check/wait/timeout patterns. Note that it's
+ * important that we check the condition again after having timed out, since the
+ * timeout could be due to preemption or similar and we've never had a chance to
+ * check the condition before the timeout.
+ */
+#define __wait_for(OP, COND, US, Wmin, Wmax) ({ \
+	const ktime_t end__ = ktime_add_ns(ktime_get_raw(), 1000ll * (US)); \
+	long wait__ = (Wmin); /* recommended min for usleep is 10 us */	\
+	int ret__;							\
+	might_sleep();							\
+	for (;;) {							\
+		const bool expired__ = ktime_after(ktime_get_raw(), end__); \
+		OP;							\
+		/* Guarantee COND check prior to timeout */		\
+		barrier();						\
+		if (COND) {						\
+			ret__ = 0;					\
+			break;						\
+		}							\
+		if (expired__) {					\
+			ret__ = -ETIMEDOUT;				\
+			break;						\
+		}							\
+		usleep_range(wait__, wait__ * 2);			\
+		if (wait__ < (Wmax))					\
+			wait__ <<= 1;					\
+	}								\
+	ret__;								\
+})
+
+#define _wait_for(COND, US, Wmin, Wmax)	__wait_for(, (COND), (US), (Wmin), \
+						   (Wmax))
+#define wait_for(COND, MS)		_wait_for((COND), (MS) * 1000, 10, 1000)
+
+/* If CONFIG_PREEMPT_COUNT is disabled, in_atomic() always reports false. */
+#if defined(CONFIG_DRM_I915_DEBUG) && defined(CONFIG_PREEMPT_COUNT)
+# define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) WARN_ON_ONCE((ATOMIC) && !in_atomic())
+#else
+# define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) do { } while (0)
+#endif
+
+#define _wait_for_atomic(COND, US, ATOMIC) \
+({ \
+	int cpu, ret, timeout = (US) * 1000; \
+	u64 base; \
+	_WAIT_FOR_ATOMIC_CHECK(ATOMIC); \
+	if (!(ATOMIC)) { \
+		preempt_disable(); \
+		cpu = smp_processor_id(); \
+	} \
+	base = local_clock(); \
+	for (;;) { \
+		u64 now = local_clock(); \
+		if (!(ATOMIC)) \
+			preempt_enable(); \
+		/* Guarantee COND check prior to timeout */ \
+		barrier(); \
+		if (COND) { \
+			ret = 0; \
+			break; \
+		} \
+		if (now - base >= timeout) { \
+			ret = -ETIMEDOUT; \
+			break; \
+		} \
+		cpu_relax(); \
+		if (!(ATOMIC)) { \
+			preempt_disable(); \
+			if (unlikely(cpu != smp_processor_id())) { \
+				timeout -= now - base; \
+				cpu = smp_processor_id(); \
+				base = local_clock(); \
+			} \
+		} \
+	} \
+	ret; \
+})
+
+#define wait_for_us(COND, US) \
+({ \
+	int ret__; \
+	BUILD_BUG_ON(!__builtin_constant_p(US)); \
+	if ((US) > 10) \
+		ret__ = _wait_for((COND), (US), 10, 10); \
+	else \
+		ret__ = _wait_for_atomic((COND), (US), 0); \
+	ret__; \
+})
+
+#define wait_for_atomic_us(COND, US) \
+({ \
+	BUILD_BUG_ON(!__builtin_constant_p(US)); \
+	BUILD_BUG_ON((US) > 50000); \
+	_wait_for_atomic((COND), (US), 1); \
+})
+
+#define wait_for_atomic(COND, MS) wait_for_atomic_us((COND), (MS) * 1000)
+
+#define KHz(x) (1000 * (x))
+#define MHz(x) KHz(1000 * (x))
+
+#define KBps(x) (1000 * (x))
+#define MBps(x) KBps(1000 * (x))
+#define GBps(x) ((u64)1000 * MBps((x)))
+
 static inline const char *yesno(bool v)
 {
 	return v ? "yes" : "no";

commit cb363304676934cd7c6ac8f99ef1861e7b603f01
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 2 18:02:45 2019 +0300

    drm/i915: make i915_utils.h self-contained
    
    And ensure it stays that way.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/69bcebefa6d8689d4a962394b0c6db04904354ed.1556809195.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 2dbe8933b50a..26117bf7da0c 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -25,6 +25,10 @@
 #ifndef __I915_UTILS_H
 #define __I915_UTILS_H
 
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
 #undef WARN_ON
 /* Many gcc seem to no see through this and fall over :( */
 #if 0
@@ -152,8 +156,6 @@ static inline u64 ptr_to_u64(const void *ptr)
 	__idx;								\
 })
 
-#include <linux/list.h>
-
 static inline void __list_del_many(struct list_head *head,
 				   struct list_head *first)
 {

commit 0e2f54f88b8b9bbdb3a73b6e67cffb402187c73f
Merge: 96fd2c6633b0 0bec6219e5a0
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Wed Mar 27 18:23:53 2019 +0200

    Merge drm/drm-next into drm-intel-next-queued
    
    This is needed to get the fourcc code merged without conflicts.
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 9d1305ef80b95dde0337106ed8b826604e2155ad
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:22 2019 +0000

    drm/i915: Introduce the i915_user_extension_method
    
    An idea for extending uABI inspired by Vulkan's extension chains.
    Instead of expanding the data struct for each ioctl every time we need
    to add a new feature, define an extension chain instead. As we add
    optional interfaces to control the ioctl, we define a new extension
    struct that can be linked into the ioctl data only when required by the
    user. The key advantage being able to ignore large control structs for
    optional interfaces/extensions, while being able to process them in a
    consistent manner.
    
    In comparison to other extensible ioctls, the key difference is the
    use of a linked chain of extension structs vs an array of tagged
    pointers. For example,
    
    struct drm_amdgpu_cs_chunk {
            __u32           chunk_id;
            __u32           length_dw;
            __u64           chunk_data;
    };
    
    struct drm_amdgpu_cs_in {
            __u32           ctx_id;
            __u32           bo_list_handle;
            __u32           num_chunks;
            __u32           _pad;
            __u64           chunks;
    };
    
    allows userspace to pass in array of pointers to extension structs, but
    must therefore keep constructing that array along side the command stream.
    In dynamic situations like that, a linked list is preferred and does not
    similar from extra cache line misses as the extension structs themselves
    must still be loaded separate to the chunks array.
    
    v2: Apply the tail call optimisation directly to nip the worry of stack
    overflow in the bud.
    v3: Defend against recursion.
    v4: Fixup local types to match new uabi
    
    Opens:
    - do we include the result as an out-field in each chain?
    struct i915_user_extension {
            __u64 next_extension;
            __u64 name;
            __s32 result;
            __u32 mbz; /* reserved for future use */
    };
    * Undecided, so provision some room for future expansion.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 9726df37c4c4..8baedcaddbba 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -105,6 +105,37 @@
 	__T;								\
 })
 
+/*
+ * container_of_user: Extract the superclass from a pointer to a member.
+ *
+ * Exactly like container_of() with the exception that it plays nicely
+ * with sparse for __user @ptr.
+ */
+#define container_of_user(ptr, type, member) ({				\
+	void __user *__mptr = (void __user *)(ptr);			\
+	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&	\
+			 !__same_type(*(ptr), void),			\
+			 "pointer type mismatch in container_of()");	\
+	((type __user *)(__mptr - offsetof(type, member))); })
+
+/*
+ * check_user_mbz: Check that a user value exists and is zero
+ *
+ * Frequently in our uABI we reserve space for future extensions, and
+ * two ensure that userspace is prepared we enforce that space must
+ * be zero. (Then any future extension can safely assume a default value
+ * of 0.)
+ *
+ * check_user_mbz() combines checking that the user pointer is accessible
+ * and that the contained value is zero.
+ *
+ * Returns: -EFAULT if not accessible, -EINVAL if !zero, or 0 on success.
+ */
+#define check_user_mbz(U) ({						\
+	typeof(*(U)) mbz__;						\
+	get_user(mbz__, (U)) ? -EFAULT : mbz__ ? -EINVAL : 0;		\
+})
+
 static inline u64 ptr_to_u64(const void *ptr)
 {
 	return (uintptr_t)ptr;

commit 70b44595eafe9c7c235f076d653a268ca1ab9fdb
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Tue Mar 5 15:44:54 2019 -0800

    mm, compaction: use free lists to quickly locate a migration source
    
    The migration scanner is a linear scan of a zone with a potentiall large
    search space.  Furthermore, many pageblocks are unusable such as those
    filled with reserved pages or partially filled with pages that cannot
    migrate.  These still get scanned in the common case of allocating a THP
    and the cost accumulates.
    
    The patch uses a partial search of the free lists to locate a migration
    source candidate that is marked as MOVABLE when allocating a THP.  It
    prefers picking a block with a larger number of free pages already on
    the basis that there are fewer pages to migrate to free the entire
    block.  The lowest PFN found during searches is tracked as the basis of
    the start for the linear search after the first search of the free list
    fails.  After the search, the free list is shuffled so that the next
    search will not encounter the same page.  If the search fails then the
    subsequent searches will be shorter and the linear scanner is used.
    
    If this search fails, or if the request is for a small or
    unmovable/reclaimable allocation then the linear scanner is still used.
    It is somewhat pointless to use the list search in those cases.  Small
    free pages must be used for the search and there is no guarantee that
    movable pages are located within that block that are contiguous.
    
                                         5.0.0-rc1              5.0.0-rc1
                                     noboost-v3r10          findmig-v3r15
    Amean     fault-both-3      3771.41 (   0.00%)     3390.40 (  10.10%)
    Amean     fault-both-5      5409.05 (   0.00%)     5082.28 (   6.04%)
    Amean     fault-both-7      7040.74 (   0.00%)     7012.51 (   0.40%)
    Amean     fault-both-12    11887.35 (   0.00%)    11346.63 (   4.55%)
    Amean     fault-both-18    16718.19 (   0.00%)    15324.19 (   8.34%)
    Amean     fault-both-24    21157.19 (   0.00%)    16088.50 *  23.96%*
    Amean     fault-both-30    21175.92 (   0.00%)    18723.42 *  11.58%*
    Amean     fault-both-32    21339.03 (   0.00%)    18612.01 *  12.78%*
    
                                    5.0.0-rc1              5.0.0-rc1
                                noboost-v3r10          findmig-v3r15
    Percentage huge-3        86.50 (   0.00%)       89.83 (   3.85%)
    Percentage huge-5        92.52 (   0.00%)       91.96 (  -0.61%)
    Percentage huge-7        92.44 (   0.00%)       92.85 (   0.44%)
    Percentage huge-12       92.98 (   0.00%)       92.74 (  -0.25%)
    Percentage huge-18       91.70 (   0.00%)       91.71 (   0.02%)
    Percentage huge-24       91.59 (   0.00%)       92.13 (   0.60%)
    Percentage huge-30       90.14 (   0.00%)       93.79 (   4.04%)
    Percentage huge-32       90.03 (   0.00%)       91.27 (   1.37%)
    
    This shows an improvement in allocation latencies with similar
    allocation success rates.  While not presented, there was a 31%
    reduction in migration scanning and a 8% reduction on system CPU usage.
    A 2-socket machine showed similar benefits.
    
    [mgorman@techsingularity.net: several fixes]
      Link: http://lkml.kernel.org/r/20190204120111.GL9565@techsingularity.net
    [vbabka@suse.cz: migrate block that was found-fast, some optimisations]
    Link: http://lkml.kernel.org/r/20190118175136.31341-10-mgorman@techsingularity.net
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Acked-by: Vlastimil Babka <Vbabka@suse.cz>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 9726df37c4c4..540e20eb032c 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -123,12 +123,6 @@ static inline u64 ptr_to_u64(const void *ptr)
 
 #include <linux/list.h>
 
-static inline int list_is_first(const struct list_head *list,
-				const struct list_head *head)
-{
-	return head->next == list;
-}
-
 static inline void __list_del_many(struct list_head *head,
 				   struct list_head *first)
 {

commit 70bbe53c6eacdf01485848b7568609e33372cad0
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Oct 23 19:02:01 2018 +0300

    drm/i915: Make sure fb gtt offsets stay within 32bits
    
    Let's try to make sure the fb offset computations never hit
    an integer overflow by making sure the entire fb stays
    below 32bits. framebuffer_check() in the core already does
    the same check, but as it doesn't know about tiling some things
    can slip through. Repeat the check in the driver with tiling
    taken into account.
    
    v2: Use add_overflows() after massaging it to work for me (Chris)
    v3: Call it add_overflow_t() to match min_t() & co. (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181023160201.9840-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 5858a43e19da..9726df37c4c4 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -44,16 +44,19 @@
 			     __stringify(x), (long)(x))
 
 #if defined(GCC_VERSION) && GCC_VERSION >= 70000
-#define add_overflows(A, B) \
-	__builtin_add_overflow_p((A), (B), (typeof((A) + (B)))0)
+#define add_overflows_t(T, A, B) \
+	__builtin_add_overflow_p((A), (B), (T)0)
 #else
-#define add_overflows(A, B) ({ \
+#define add_overflows_t(T, A, B) ({ \
 	typeof(A) a = (A); \
 	typeof(B) b = (B); \
-	a + b < a; \
+	(T)(a + b) < a; \
 })
 #endif
 
+#define add_overflows(A, B) \
+	add_overflows_t(typeof((A) + (B)), (A), (B))
+
 #define range_overflows(start, size, max) ({ \
 	typeof(start) start__ = (start); \
 	typeof(size) size__ = (size); \

commit 74f6e183913b5dc90a004cafa84159ddb61cd0f0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 26 11:47:07 2018 +0100

    drm/i915: Convert to BITS_PER_TYPE
    
    In commit 9144d75e22ca ("include/linux/bitops.h: introduce BITS_PER_TYPE"),
    we made BITS_PER_TYPE available to all and now we can use the macro to
    replace some open-coded computation of sizeof(T) * BITS_PER_BYTE.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180926104707.17410-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 395dd2511568..5858a43e19da 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -68,7 +68,7 @@
 
 /* Note we don't consider signbits :| */
 #define overflows_type(x, T) \
-	(sizeof(x) > sizeof(T) && (x) >> (sizeof(T) * BITS_PER_BYTE))
+	(sizeof(x) > sizeof(T) && (x) >> BITS_PER_TYPE(T))
 
 #define ptr_mask_bits(ptr, n) ({					\
 	unsigned long __v = (unsigned long)(ptr);			\

commit 815f0ddb346c196018d4d8f8f55c12b83da1de3f
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Wed Aug 22 16:37:24 2018 -0700

    include/linux/compiler*.h: make compiler-*.h mutually exclusive
    
    Commit cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
    recently exposed a brittle part of the build for supporting non-gcc
    compilers.
    
    Both Clang and ICC define __GNUC__, __GNUC_MINOR__, and
    __GNUC_PATCHLEVEL__ for quick compatibility with code bases that haven't
    added compiler specific checks for __clang__ or __INTEL_COMPILER.
    
    This is brittle, as they happened to get compatibility by posing as a
    certain version of GCC.  This broke when upgrading the minimal version
    of GCC required to build the kernel, to a version above what ICC and
    Clang claim to be.
    
    Rather than always including compiler-gcc.h then undefining or
    redefining macros in compiler-intel.h or compiler-clang.h, let's
    separate out the compiler specific macro definitions into mutually
    exclusive headers, do more proper compiler detection, and keep shared
    definitions in compiler_types.h.
    
    Fixes: cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
    Reported-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Suggested-by: Eli Friedman <efriedma@codeaurora.org>
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 00165ad55fb3..395dd2511568 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -43,7 +43,7 @@
 #define MISSING_CASE(x) WARN(1, "Missing case (%s == %ld)\n", \
 			     __stringify(x), (long)(x))
 
-#if GCC_VERSION >= 70000
+#if defined(GCC_VERSION) && GCC_VERSION >= 70000
 #define add_overflows(A, B) \
 	__builtin_add_overflow_p((A), (B), (typeof((A) + (B)))0)
 #else

commit b887d61546245389c0304d8b1371bab9af8106c2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Apr 30 14:15:02 2018 +0100

    drm/i915: Retire requests along rings
    
    In the next patch, rings are the central timeline as requests may jump
    between engines. Therefore in the future as we retire in order along the
    engine timeline, we may retire out-of-order within a ring (as the ring now
    occurs along multiple engines), leading to much hilarity in miscomputing
    the position of ring->head.
    
    As an added bonus, retiring along the ring reduces the penalty of having
    one execlists client do cleanup for another (old legacy submission
    shares a ring between all clients). The downside is that slow and
    irregular (off the critical path) process of cleaning up stale requests
    after userspace becomes a modicum less efficient.
    
    In the long run, it will become apparent that the ordered
    ring->request_list matches the ring->timeline, a fun challenge for the
    future will be unifying the two lists to avoid duplication!
    
    v2: We need both engine-order and ring-order processing to maintain our
    knowledge of where individual rings have completed upto as well as
    knowing what was last executing on any engine. And finally by decoupling
    retiring the contexts on the engine and the timelines along the rings,
    we do have to keep a reference to the context on each request
    (previously it was guaranteed by the context being pinned).
    
    v3: Not just a reference to the context, but we need to keep it pinned
    as we manipulate the rings; i.e. we need a pin for both the manipulation
    of the engine state during its retirements, and a separate pin for the
    manipulation of the ring state.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180430131503.5375-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 0695717522ea..00165ad55fb3 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -120,6 +120,12 @@ static inline u64 ptr_to_u64(const void *ptr)
 
 #include <linux/list.h>
 
+static inline int list_is_first(const struct list_head *list,
+				const struct list_head *head)
+{
+	return head->next == list;
+}
+
 static inline void __list_del_many(struct list_head *head,
 				   struct list_head *first)
 {

commit 57bdff48a0a553468f16a65149d51213b5f25fee
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Mon Mar 19 10:37:20 2018 -0700

    drm/i915: Reword warning for missing cases
    
    In some places we end up converting switch statements to a series of
    if/else, particularly when introducing helper functions to handle a
    group of cases. It's tempting to either leave a wrong warning (since now
    we don't have a switch case anymore) or to convert to WARN(1, ...),
    but we can just provide a better message and avoid the doubt when such
    conversions arrise.
    
    Introducing a warning inside i915_driver_load() just for tests we get:
    
    [ 4535.233717] Missing case (ret == 0)
    [ 4535.233868] WARNING: CPU: 1 PID: 795 at drivers/gpu/drm/i915/i915_drv.c:1341 i915_driver_load+0x42/0x10e0 [i915]
    
    which is clear enough.
    
    v2: remove __func__ since this is already on the warning.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180319173720.6974-1-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 51dbfe5bb418..0695717522ea 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -40,8 +40,8 @@
 #undef WARN_ON_ONCE
 #define WARN_ON_ONCE(x) WARN_ONCE((x), "%s", "WARN_ON_ONCE(" __stringify(x) ")")
 
-#define MISSING_CASE(x) WARN(1, "Missing switch case (%lu) in %s\n", \
-			     (long)(x), __func__)
+#define MISSING_CASE(x) WARN(1, "Missing case (%s == %ld)\n", \
+			     __stringify(x), (long)(x))
 
 #if GCC_VERSION >= 70000
 #define add_overflows(A, B) \

commit b74eeeb6b1ab6e09311cc4a78c60309f1461dac8
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Thu Dec 21 21:57:29 2017 +0000

    drm/i915: Move some utility functions to i915_util.h
    
    We have dedicated header file for utility functions and macros.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221185334.17396-2-michal.wajdeczko@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171221215735.30314-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 8d07764887ec..51dbfe5bb418 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -140,4 +140,19 @@ static inline void drain_delayed_work(struct delayed_work *dw)
 	} while (delayed_work_pending(dw));
 }
 
+static inline const char *yesno(bool v)
+{
+	return v ? "yes" : "no";
+}
+
+static inline const char *onoff(bool v)
+{
+	return v ? "on" : "off";
+}
+
+static inline const char *enableddisabled(bool v)
+{
+	return v ? "enabled" : "disabled";
+}
+
 #endif /* !__I915_UTILS_H */

commit 2d7514152b1c82c81a363f8a171237567ebb7e66
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Nov 3 09:05:38 2017 +0000

    drm/i915: Warn in debug builds of incorrect usages of ptr_pack_bits
    
    GEM_BUG_ON if the packed bits do not fit into the specified width.
    
    v2: Avoid using the macro argument twice.
    v3: Drop unnecessary braces. (Joonas)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171103090538.14474-1-tvrtko.ursulin@linux.intel.com

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index af3d7cc53fa1..8d07764887ec 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -83,8 +83,11 @@
 	(typeof(ptr))(__v & -BIT(n));					\
 })
 
-#define ptr_pack_bits(ptr, bits, n)					\
-	((typeof(ptr))((unsigned long)(ptr) | (bits)))
+#define ptr_pack_bits(ptr, bits, n) ({					\
+	unsigned long __bits = (bits);					\
+	GEM_BUG_ON(__bits & -BIT(n));					\
+	((typeof(ptr))((unsigned long)(ptr) | __bits));			\
+})
 
 #define page_mask_bits(ptr) ptr_mask_bits(ptr, PAGE_SHIFT)
 #define page_unmask_bits(ptr) ptr_unmask_bits(ptr, PAGE_SHIFT)

commit 7c26240e8a19240924b029215989f28995f16d8c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 6 11:40:38 2017 +0100

    drm/i915: Try harder to finish the idle-worker
    
    If a worker requeues itself, it may switch to a different kworker pool,
    which flush_work() considers as complete. To be strict, we then need to
    keep flushing the work until it is no longer pending.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=102456
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171006104038.22337-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index c242327d5217..af3d7cc53fa1 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -124,4 +124,17 @@ static inline void __list_del_many(struct list_head *head,
 	WRITE_ONCE(head->next, first);
 }
 
+/*
+ * Wait until the work is finally complete, even if it tries to postpone
+ * by requeueing itself. Note, that if the worker never cancels itself,
+ * we will spin forever.
+ */
+static inline void drain_delayed_work(struct delayed_work *dw)
+{
+	do {
+		while (flush_delayed_work(dw))
+			;
+	} while (delayed_work_pending(dw));
+}
+
 #endif /* !__I915_UTILS_H */

commit bb8920f5bea53317c15d1c14f2704f2deaeb9ffd
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Fri Oct 6 13:08:44 2017 +0000

    drm/i915: Fix pointer-to-int conversion
    
    Commit faf654864b25 ("drm/i915: Unify uC variable types to avoid
    flooding checkpatch.pl") breaks 32-bit kernel builds. Lets use
    cast helper to make compiler happy.
    
    v2: introduce ptr_to_u64 (Chris)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171006130844.49012-1-michal.wajdeczko@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 12fc250b47b9..c242327d5217 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -99,6 +99,11 @@
 	__T;								\
 })
 
+static inline u64 ptr_to_u64(const void *ptr)
+{
+	return (uintptr_t)ptr;
+}
+
 #define u64_to_ptr(T, x) ({						\
 	typecheck(u64, x);						\
 	(T *)(uintptr_t)(x);						\

commit 4ff4b44cbb70c269259958cbcc48d7b8a2cb9ec8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 16 15:05:16 2017 +0100

    drm/i915: Store a direct lookup from object handle to vma
    
    The advent of full-ppgtt lead to an extra indirection between the object
    and its binding. That extra indirection has a noticeable impact on how
    fast we can convert from the user handles to our internal vma for
    execbuffer. In order to bypass the extra indirection, we use a
    resizable hashtable to jump from the object to the per-ctx vma.
    rhashtable was considered but we don't need the online resizing feature
    and the extra complexity proved to undermine its usefulness. Instead, we
    simply reallocate the hastable on demand in a background task and
    serialize it before iterating.
    
    In non-full-ppgtt modes, multiple files and multiple contexts can share
    the same vma. This leads to having multiple possible handle->vma links,
    so we only use the first to establish the fast path. The majority of
    buffers are not shared and so we should still be able to realise
    speedups with multiple clients.
    
    v2: Prettier names, more magic.
    v3: Many style tweaks, most notably hiding the misuse of execobj[].rsvd2
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 16ecd1ab108d..12fc250b47b9 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -99,6 +99,11 @@
 	__T;								\
 })
 
+#define u64_to_ptr(T, x) ({						\
+	typecheck(u64, x);						\
+	(T *)(uintptr_t)(x);						\
+})
+
 #define __mask_next_bit(mask) ({					\
 	int __idx = ffs(mask) - 1;					\
 	mask &= ~BIT(__idx);						\

commit 6c067579e69b42bff476959fd7bb561ffa3f11e0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 17 13:10:03 2017 +0100

    drm/i915: Split execlist priority queue into rbtree + linked list
    
    All the requests at the same priority are executed in FIFO order. They
    do not need to be stored in the rbtree themselves, as they are a simple
    list within a level. If we move the requests at one priority into a list,
    we can then reduce the rbtree to the set of priorities. This should keep
    the height of the rbtree small, as the number of active priorities can not
    exceed the number of active requests and should be typically only a few.
    
    Currently, we have ~2k possible different priority levels, that may
    increase to allow even more fine grained selection. Allocating those in
    advance seems a waste (and may be impossible), so we opt for allocating
    upon first use, and freeing after its requests are depleted. To avoid
    the possibility of an allocation failure causing us to lose a request,
    we preallocate the default priority (0) and bump any request to that
    priority if we fail to allocate it the appropriate plist. Having a
    request (that is ready to run, so not leading to corruption) execute
    out-of-order is better than leaking the request (and its dependency
    tree) entirely.
    
    There should be a benefit to reducing execlists_dequeue() to principally
    using a simple list (and reducing the frequency of both rbtree iteration
    and balancing on erase) but for typical workloads, request coalescing
    should be small enough that we don't notice any change. The main gain is
    from improving PI calls to schedule, and the explicit list within a
    level should make request unwinding simpler (we just need to insert at
    the head of the list rather than the tail and not have to make the
    rbtree search more complicated).
    
    v2: Avoid use-after-free when deleting a depleted priolist
    
    v3: Michał found the solution to handling the allocation failure
    gracefully. If we disable all priority scheduling following the
    allocation failure, those requests will be executed in fifo and we will
    ensure that this request and its dependencies are in strict fifo (even
    when it doesn't realise it is only a single list). Normal scheduling is
    restored once we know the device is idle, until the next failure!
    Suggested-by: Michał Wajdeczko <michal.wajdeczko@intel.com>
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Michał Winiarski <michal.winiarski@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170517121007.27224-8-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index d9df23795f9a..16ecd1ab108d 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -105,4 +105,13 @@
 	__idx;								\
 })
 
+#include <linux/list.h>
+
+static inline void __list_del_many(struct list_head *head,
+				   struct list_head *first)
+{
+	first->prev = head;
+	WRITE_ONCE(head->next, first);
+}
+
 #endif /* !__I915_UTILS_H */

commit 0ce81788080570e28efb43a4036976854e0edca8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 17 13:09:59 2017 +0100

    drm/i915: Redefine ptr_pack_bits() and friends
    
    Rebrand the current (pointer | bits) pack/unpack utility macros as
    explicit bit twiddling for PAGE_SIZE so that we can use the more
    flexible underlying macros for different bits.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170517121007.27224-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 18630d8f4be8..d9df23795f9a 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -70,20 +70,27 @@
 #define overflows_type(x, T) \
 	(sizeof(x) > sizeof(T) && (x) >> (sizeof(T) * BITS_PER_BYTE))
 
-#define ptr_mask_bits(ptr) ({						\
+#define ptr_mask_bits(ptr, n) ({					\
 	unsigned long __v = (unsigned long)(ptr);			\
-	(typeof(ptr))(__v & PAGE_MASK);					\
+	(typeof(ptr))(__v & -BIT(n));					\
 })
 
-#define ptr_unpack_bits(ptr, bits) ({					\
+#define ptr_unmask_bits(ptr, n) ((unsigned long)(ptr) & (BIT(n) - 1))
+
+#define ptr_unpack_bits(ptr, bits, n) ({				\
 	unsigned long __v = (unsigned long)(ptr);			\
-	*(bits) = __v & ~PAGE_MASK;					\
-	(typeof(ptr))(__v & PAGE_MASK);					\
+	*(bits) = __v & (BIT(n) - 1);					\
+	(typeof(ptr))(__v & -BIT(n));					\
 })
 
-#define ptr_pack_bits(ptr, bits)					\
+#define ptr_pack_bits(ptr, bits, n)					\
 	((typeof(ptr))((unsigned long)(ptr) | (bits)))
 
+#define page_mask_bits(ptr) ptr_mask_bits(ptr, PAGE_SHIFT)
+#define page_unmask_bits(ptr) ptr_unmask_bits(ptr, PAGE_SHIFT)
+#define page_pack_bits(ptr, bits) ptr_pack_bits(ptr, bits, PAGE_SHIFT)
+#define page_unpack_bits(ptr, bits) ptr_unpack_bits(ptr, bits, PAGE_SHIFT)
+
 #define ptr_offset(ptr, member) offsetof(typeof(*(ptr)), member)
 
 #define fetch_and_zero(ptr) ({						\

commit 991bfc64db096cb924d5d216a9cb469590f00428
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 17 13:09:58 2017 +0100

    drm/i915: Make ptr_unpack_bits() more function-like
    
    ptr_unpack_bits() is a function-like macro, as such it is meant to be
    replaceable by a function. In this case, we should be passing in the
    out-param as a pointer.
    
    Bizarrely this does affect code generation:
    
    function                                     old     new   delta
    i915_gem_object_pin_map                      409     389     -20
    
    An improvement(?) in this case, but one can't help wonder what
    strict-aliasing optimisations we are preventing.
    
    The generated code looks identical in using ptr_unpack_bits (no extra
    motions to stack, the pointer and bits appear to be kept in registers),
    the difference appears to be code ordering and with a reorder it is able
    to use smaller forward jumps.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170517121007.27224-3-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index f9d6607ef52f..18630d8f4be8 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -77,7 +77,7 @@
 
 #define ptr_unpack_bits(ptr, bits) ({					\
 	unsigned long __v = (unsigned long)(ptr);			\
-	(bits) = __v & ~PAGE_MASK;					\
+	*(bits) = __v & ~PAGE_MASK;					\
 	(typeof(ptr))(__v & PAGE_MASK);					\
 })
 

commit 16586fcd86c4a498bbfc2643490a5a38648e1d5e
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Tue May 9 09:20:21 2017 +0000

    drm/i915: Move uncore definitions into a separate header
    
    In order to allow use of e.g. forcewake_domains in a other feature headers
    included from the top of i915_drv.h, move all uncore related definitions
    into their own header.
    
    v2: move __mask_next_bit macro to utils header (Mika)
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Suggested-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index c5455d36b617..f9d6607ef52f 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -92,4 +92,10 @@
 	__T;								\
 })
 
+#define __mask_next_bit(mask) ({					\
+	int __idx = ffs(mask) - 1;					\
+	mask &= ~BIT(__idx);						\
+	__idx;								\
+})
+
 #endif /* !__I915_UTILS_H */

commit f0d661534fc90da1774e8af7e7faf5043375606f
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Tue Mar 28 08:45:12 2017 +0000

    drm/i915: Move WARN_ON/MISSING_CASE macros to i915_utils.h
    
    We can't sometimes use these macros in other headers due to
    include and definition order. As i915_utils.h already contains
    other helper macros move these macros there.
    
    v2: checkpatch cleanup for WARN() macro.
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170328084513.174200-1-michal.wajdeczko@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 94a3a3299910..c5455d36b617 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -25,6 +25,24 @@
 #ifndef __I915_UTILS_H
 #define __I915_UTILS_H
 
+#undef WARN_ON
+/* Many gcc seem to no see through this and fall over :( */
+#if 0
+#define WARN_ON(x) ({ \
+	bool __i915_warn_cond = (x); \
+	if (__builtin_constant_p(__i915_warn_cond)) \
+		BUILD_BUG_ON(__i915_warn_cond); \
+	WARN(__i915_warn_cond, "WARN_ON(" #x ")"); })
+#else
+#define WARN_ON(x) WARN((x), "%s", "WARN_ON(" __stringify(x) ")")
+#endif
+
+#undef WARN_ON_ONCE
+#define WARN_ON_ONCE(x) WARN_ONCE((x), "%s", "WARN_ON_ONCE(" __stringify(x) ")")
+
+#define MISSING_CASE(x) WARN(1, "Missing switch case (%lu) in %s\n", \
+			     (long)(x), __func__)
+
 #if GCC_VERSION >= 70000
 #define add_overflows(A, B) \
 	__builtin_add_overflow_p((A), (B), (typeof((A) + (B)))0)

commit 16f11f46964fda7c1f8ee0cd137689abea142365
Author: Michal Wajdeczko <michal.wajdeczko@intel.com>
Date:   Tue Mar 14 13:33:09 2017 +0000

    drm/i915/guc: Use formalized struct definition for ads object
    
    Manual pointer manipulation is error prone. Let compiler calculate
    right offsets for us in case we need to change ads layout.
    
    v2: don't call it object (Chris)
    v3: restyle offset assignments (Chris)
    v4: stylistic reductions
    
    Signed-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>
    Cc: Oscar Mateo <oscar.mateo@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170314133309.126432-1-michal.wajdeczko@intel.com
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index b8ba0f2f92af..94a3a3299910 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -66,6 +66,8 @@
 #define ptr_pack_bits(ptr, bits)					\
 	((typeof(ptr))((unsigned long)(ptr) | (bits)))
 
+#define ptr_offset(ptr, member) offsetof(typeof(*(ptr)), member)
+
 #define fetch_and_zero(ptr) ({						\
 	typeof(*ptr) __T = *(ptr);					\
 	*(ptr) = (typeof(*ptr))0;					\

commit 1692cd60d999b00a0491692dab0286e6011abd36
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 30 13:47:21 2017 +0000

    drm/i915: Sanity check the computed size and base of stolen memory
    
    Just do a quick check that the stolen memory address range doesn't
    overflow our chosen integer type.
    
    v2: Add add_overflows() to utils with the promise that gcc7 can do this
    better than C and then maybe it will have a proper definition in core.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170130134721.5159-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 34020873e1f6..b8ba0f2f92af 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -25,6 +25,17 @@
 #ifndef __I915_UTILS_H
 #define __I915_UTILS_H
 
+#if GCC_VERSION >= 70000
+#define add_overflows(A, B) \
+	__builtin_add_overflow_p((A), (B), (typeof((A) + (B)))0)
+#else
+#define add_overflows(A, B) ({ \
+	typeof(A) a = (A); \
+	typeof(B) b = (B); \
+	a + b < a; \
+})
+#endif
+
 #define range_overflows(start, size, max) ({ \
 	typeof(start) start__ = (start); \
 	typeof(size) size__ = (size); \

commit b7163936bd99dab90a71c2496295f62f2b4874ab
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 5 16:41:48 2017 +0000

    drm/i915: Move a few more utility macros to i915_utils.h
    
    Now that we have split out a header file for simple macros (that maybe
    we can promote into a core header), move a few macros across from
    i915_drv.h
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170105164148.26875-1-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
index 9983ef30bac8..34020873e1f6 100644
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -41,4 +41,24 @@
 #define overflows_type(x, T) \
 	(sizeof(x) > sizeof(T) && (x) >> (sizeof(T) * BITS_PER_BYTE))
 
+#define ptr_mask_bits(ptr) ({						\
+	unsigned long __v = (unsigned long)(ptr);			\
+	(typeof(ptr))(__v & PAGE_MASK);					\
+})
+
+#define ptr_unpack_bits(ptr, bits) ({					\
+	unsigned long __v = (unsigned long)(ptr);			\
+	(bits) = __v & ~PAGE_MASK;					\
+	(typeof(ptr))(__v & PAGE_MASK);					\
+})
+
+#define ptr_pack_bits(ptr, bits)					\
+	((typeof(ptr))((unsigned long)(ptr) | (bits)))
+
+#define fetch_and_zero(ptr) ({						\
+	typeof(*ptr) __T = *(ptr);					\
+	*(ptr) = (typeof(*ptr))0;					\
+	__T;								\
+})
+
 #endif /* !__I915_UTILS_H */

commit 40b326eefe0ae89fa7e8b272f51382c55563e179
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 5 15:30:22 2017 +0000

    drm/i915: Move a few utility macros into a separate header
    
    In order to defeat some circular dependencies between headers to allow use
    of e.g. range_overflows() in a header, move the simple independent macros
    into their own header.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170105153023.30575-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/i915_utils.h b/drivers/gpu/drm/i915/i915_utils.h
new file mode 100644
index 000000000000..9983ef30bac8
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_UTILS_H
+#define __I915_UTILS_H
+
+#define range_overflows(start, size, max) ({ \
+	typeof(start) start__ = (start); \
+	typeof(size) size__ = (size); \
+	typeof(max) max__ = (max); \
+	(void)(&start__ == &size__); \
+	(void)(&start__ == &max__); \
+	start__ > max__ || size__ > max__ - start__; \
+})
+
+#define range_overflows_t(type, start, size, max) \
+	range_overflows((type)(start), (type)(size), (type)(max))
+
+/* Note we don't consider signbits :| */
+#define overflows_type(x, T) \
+	(sizeof(x) > sizeof(T) && (x) >> (sizeof(T) * BITS_PER_BYTE))
+
+#endif /* !__I915_UTILS_H */
