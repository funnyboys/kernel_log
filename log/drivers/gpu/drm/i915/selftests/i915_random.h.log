commit ea38aa2ea5b0969776f0a47f174ce928a22be803
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Jan 7 21:50:14 2020 +0800

    drm/i915: Add missing include file <linux/math64.h>
    
    Fix build error:
    ./drivers/gpu/drm/i915/selftests/i915_random.h: In function i915_prandom_u32_max_state:
    ./drivers/gpu/drm/i915/selftests/i915_random.h:48:23: error:
     implicit declaration of function mul_u32_u32; did you mean mul_u64_u32_div? [-Werror=implicit-function-declaration]
      return upper_32_bits(mul_u32_u32(prandom_u32_state(state), ep_ro));
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Fixes: 7ce5b6850b47 ("drm/i915/selftests: Use mul_u32_u32() for 32b x 32b -> 64b result")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200107135014.36472-1-yuehaibing@huawei.com
    (cherry picked from commit 62bf5465b26d1f502430b9c654be7d16bf2e242d)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
index 35cc69a3a1b9..05364eca20f7 100644
--- a/drivers/gpu/drm/i915/selftests/i915_random.h
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -25,6 +25,7 @@
 #ifndef __I915_SELFTESTS_RANDOM_H__
 #define __I915_SELFTESTS_RANDOM_H__
 
+#include <linux/math64.h>
 #include <linux/random.h>
 
 #include "../i915_selftest.h"

commit dfe324f34c53af095bfe54b322e1a338421a6b0e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 2 13:24:30 2019 +0100

    drm/i915/selftests: Extract random_offset() for use with a prng
    
    For selftests, we desire repeatability and so prefer using a prng with
    known seed over true randomness. Extract random_offset() as a selftest
    utility that can take the prng state.
    
    Suggested-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191002122430.23205-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
index 8e1ff9c105b6..35cc69a3a1b9 100644
--- a/drivers/gpu/drm/i915/selftests/i915_random.h
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -57,4 +57,8 @@ void i915_random_reorder(unsigned int *order,
 void i915_prandom_shuffle(void *arr, size_t elsz, size_t count,
 			  struct rnd_state *state);
 
+u64 igt_random_offset(struct rnd_state *state,
+		      u64 start, u64 end,
+		      u64 len, u64 align);
+
 #endif /* !__I915_SELFTESTS_RANDOM_H__ */

commit 8ba306a6a362ef6f3c005ec8819c8890a6fadcd1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 28 18:18:10 2019 +0000

    drm/i915: Share per-timeline HWSP using a slab suballocator
    
    If we restrict ourselves to only using a cacheline for each timeline's
    HWSP (we could go smaller, but want to avoid needless polluting
    cachelines on different engines between different contexts), then we can
    suballocate a single 4k page into 64 different timeline HWSP. By
    treating each fresh allocation as a slab of 64 entries, we can keep it
    around for the next 64 allocation attempts until we need to refresh the
    slab cache.
    
    John Harrison noted the issue of fragmentation leading to the same worst
    case performance of one page per timeline as before, which can be
    mitigated by adopting a freelist.
    
    v2: Keep all partially allocated HWSP on a freelist
    
    This is still without migration, so it is possible for the system to end
    up with each timeline in its own page, but we ensure that no new
    allocation would needless allocate a fresh page!
    
    v3: Throw a selftest at the allocator to try and catch invalid cacheline
    reuse.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: John Harrison <John.C.Harrison@Intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190128181812.22804-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
index 7dffedc501ca..8e1ff9c105b6 100644
--- a/drivers/gpu/drm/i915/selftests/i915_random.h
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -54,4 +54,7 @@ void i915_random_reorder(unsigned int *order,
 			 unsigned int count,
 			 struct rnd_state *state);
 
+void i915_prandom_shuffle(void *arr, size_t elsz, size_t count,
+			  struct rnd_state *state);
+
 #endif /* !__I915_SELFTESTS_RANDOM_H__ */

commit 7ce5b6850b47824a2b8d0a17b5fe75f9942e5cd1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 13 11:51:54 2017 +0100

    drm/i915/selftests: Use mul_u32_u32() for 32b x 32b -> 64b result
    
    As realised by commit 9e3d6223d209 ("math64, timers: Fix 32bit
    mul_u64_u32_shr() and friends"), GCC does not always generate ideal code
    for performing a 32b x 32b multiply returning a 64b result (i.e. where
    we idiomatically use u64 result = (u64)x * (u32)x).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170913105154.2910-2-chris@chris-wilson.co.uk
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
index 6c9379871384..7dffedc501ca 100644
--- a/drivers/gpu/drm/i915/selftests/i915_random.h
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -43,6 +43,11 @@
 
 u64 i915_prandom_u64_state(struct rnd_state *rnd);
 
+static inline u32 i915_prandom_u32_max_state(u32 ep_ro, struct rnd_state *state)
+{
+	return upper_32_bits(mul_u32_u32(prandom_u32_state(state), ep_ro));
+}
+
 unsigned int *i915_random_order(unsigned int count,
 				struct rnd_state *state);
 void i915_random_reorder(unsigned int *order,

commit 4797948071f607c5b43753cb8f1b7ddcf22e146d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 3 10:39:21 2017 +0100

    drm/i915: Squash repeated awaits on the same fence
    
    Track the latest fence waited upon on each context, and only add a new
    asynchronous wait if the new fence is more recent than the recorded
    fence for that context. This requires us to filter out unordered
    timelines, which are noted by DMA_FENCE_NO_CONTEXT. However, in the
    absence of a universal identifier, we have to use our own
    i915->mm.unordered_timeline token.
    
    v2: Throw around the debug crutches
    v3: Inline the likely case of the pre-allocation cache being full.
    v4: Drop the pre-allocation support, we can lose the most recent fence
    in case of allocation failure -- it just means we may emit more awaits
    than strictly necessary but will not break.
    v5: Trim allocation size for leaf nodes, they only need an array of u32
    not pointers.
    v6: Create mock_timeline to tidy selftest writing
    v7: s/intel_timeline_sync_get/intel_timeline_sync_is_later/ (Tvrtko)
    v8: Prune the stale sync points when we idle.
    v9: Include a small benchmark in the kselftests
    v10: Separate the idr implementation into its own compartment. (Tvrkto)
    v11: Refactor igt_sync kselftests to avoid deep nesting (Tvrkto)
    v12: __sync_leaf_idx() to assert that p->height is 0 when checking leaves
    v13: kselftests to investigate struct i915_syncmap itself (Tvrtko)
    v14: Foray into ascii art graphs
    v15: Take into account that the random lookup/insert does 2 prng calls,
    not 1, when benchmarking, and use for_each_set_bit() (Tvrtko)
    v16: Improved ascii art
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170503093924.5320-4-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
index b9c334ce6cd9..6c9379871384 100644
--- a/drivers/gpu/drm/i915/selftests/i915_random.h
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -41,6 +41,8 @@
 #define I915_RND_SUBSTATE(name__, parent__) \
 	struct rnd_state name__ = I915_RND_STATE_INITIALIZER(prandom_u32_state(&(parent__)))
 
+u64 i915_prandom_u64_state(struct rnd_state *rnd);
+
 unsigned int *i915_random_order(unsigned int count,
 				struct rnd_state *state);
 void i915_random_reorder(unsigned int *order,

commit 953c7f82eb890085c60dbe22578e883d6837c674
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 13 17:15:12 2017 +0000

    drm/i915: Provide a hook for selftests
    
    Some pieces of code are independent of hardware but are very tricky to
    exercise through the normal userspace ABI or via debugfs hooks. Being
    able to create mock unit tests and execute them through CI is vital.
    Start by adding a central point where we can execute unit tests and
    a parameter to enable them. This is disabled by default as the
    expectation is that these tests will occasionally explode.
    
    To facilitate integration with igt, any parameter beginning with
    i915.igt__ is interpreted as a subtest executable independently via
    igt/drv_selftest.
    
    Two classes of selftests are recognised: mock unit tests and integration
    tests. Mock unit tests are run as soon as the module is loaded, before
    the device is probed. At that point there is no driver instantiated and
    all hw interactions must be "mocked". This is very useful for writing
    universal tests to exercise code not typically run on a broad range of
    architectures. Alternatively, you can hook into the live selftests and
    run when the device has been instantiated - hw interactions are real.
    
    v2: Add a macro for compiling conditional code for mock objects inside
    real objects.
    v3: Differentiate between mock unit tests and late integration test.
    v4: List the tests in natural order, use igt to sort after modparam.
    v5: s/late/live/
    v6: s/unsigned long/unsigned int/
    v7: Use igt_ prefixes for long helpers.
    v8: Deobfuscate macros overriding functions, stop using -I$(src)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170213171558.20942-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/selftests/i915_random.h b/drivers/gpu/drm/i915/selftests/i915_random.h
new file mode 100644
index 000000000000..b9c334ce6cd9
--- /dev/null
+++ b/drivers/gpu/drm/i915/selftests/i915_random.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_SELFTESTS_RANDOM_H__
+#define __I915_SELFTESTS_RANDOM_H__
+
+#include <linux/random.h>
+
+#include "../i915_selftest.h"
+
+#define I915_RND_STATE_INITIALIZER(x) ({				\
+	struct rnd_state state__;					\
+	prandom_seed_state(&state__, (x));				\
+	state__;							\
+})
+
+#define I915_RND_STATE(name__) \
+	struct rnd_state name__ = I915_RND_STATE_INITIALIZER(i915_selftest.random_seed)
+
+#define I915_RND_SUBSTATE(name__, parent__) \
+	struct rnd_state name__ = I915_RND_STATE_INITIALIZER(prandom_u32_state(&(parent__)))
+
+unsigned int *i915_random_order(unsigned int count,
+				struct rnd_state *state);
+void i915_random_reorder(unsigned int *order,
+			 unsigned int count,
+			 struct rnd_state *state);
+
+#endif /* !__I915_SELFTESTS_RANDOM_H__ */
