commit 20f505f2253106f695ba6fa0a415159145a8fb2a
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Thu May 14 10:48:52 2020 +0300

    drm/i915: Restrict qgv points which don't have enough bandwidth.
    
    According to BSpec 53998, we should try to
    restrict qgv points, which can't provide
    enough bandwidth for desired display configuration.
    
    Currently we are just comparing against all of
    those and take minimum(worst case).
    
    v2: Fixed wrong PCode reply mask, removed hardcoded
        values.
    
    v3: Forbid simultaneous legacy SAGV PCode requests and
        restricting qgv points. Put the actual restriction
        to commit function, added serialization(thanks to Ville)
        to prevent commit being applied out of order in case of
        nonblocking and/or nomodeset commits.
    
    v4:
        - Minor code refactoring, fixed few typos(thanks to James Ausmus)
        - Change the naming of qgv point
          masking/unmasking functions(James Ausmus).
        - Simplify the masking/unmasking operation itself,
          as we don't need to mask only single point per request(James Ausmus)
        - Reject and stick to highest bandwidth point if SAGV
          can't be enabled(BSpec)
    
    v5:
        - Add new mailbox reply codes, which seems to happen during boot
          time for TGL and indicate that QGV setting is not yet available.
    
    v6:
        - Increase number of supported QGV points to be in sync with BSpec.
    
    v7: - Rebased and resolved conflict to fix build failure.
        - Fix NUM_QGV_POINTS to 8 and moved that to header file(James Ausmus)
    
    v8: - Don't report an error if we can't restrict qgv points, as SAGV
          can be disabled by BIOS, which is completely legal. So don't
          make CI panic. Instead if we detect that there is only 1 QGV
          point accessible just analyze if we can fit the required bandwidth
          requirements, but no need in restricting.
    
    v9: - Fix wrong QGV transition if we have 0 planes and no SAGV
          simultaneously.
    
    v10: - Fix CDCLK corruption, because of global state getting serialized
           without modeset, which caused copying of non-calculated cdclk
           to be copied to dev_priv(thanks to Ville for the hint).
    
    v11: - Remove unneeded headers and spaces(Matthew Roper)
         - Remove unneeded intel_qgv_info qi struct from bw check and zero
           out the needed one(Matthew Roper)
         - Changed QGV error message to have more clear meaning(Matthew Roper)
         - Use state->modeset_set instead of any_ms(Matthew Roper)
         - Moved NUM_SAGV_POINTS from i915_reg.h to i915_drv.h where it's used
         - Keep using crtc_state->hw.active instead of .enable(Matthew Roper)
         - Moved unrelated changes to other patch(using latency as parameter
           for plane wm calculation, moved to SAGV refactoring patch)
    
    v12: - Fix rebase conflict with own temporary SAGV/QGV fix.
         - Remove unnecessary mask being zero check when unmasking
           qgv points as this is completely legal(Matt Roper)
         - Check if we are setting the same mask as already being set
           in hardware to prevent error from PCode.
         - Fix error message when restricting/unrestricting qgv points
           to "mask/unmask" which sounds more accurate(Matt Roper)
         - Move sagv status setting to icl_get_bw_info from atomic check
           as this should be calculated only once.(Matt Roper)
         - Edited comments for the case when we can't enable SAGV and
           use only 1 QGV point with highest bandwidth to be more
           understandable.(Matt Roper)
    
    v13: - Moved max_data_rate in bw check to closer scope(Ville Syrjälä)
         - Changed comment for zero new_mask in qgv points masking function
           to better reflect reality(Ville Syrjälä)
         - Simplified bit mask operation in qgv points masking function
           (Ville Syrjälä)
         - Moved intel_qgv_points_mask closer to gen11 SAGV disabling,
           however this still can't be under modeset condition(Ville Syrjälä)
         - Packed qgv_points_mask as u8 and moved closer to pipe_sagv_mask
           (Ville Syrjälä)
         - Extracted PCode changes to separate patch.(Ville Syrjälä)
         - Now treat num_planes 0 same as 1 to avoid confusion and
           returning max_bw as 0, which would prevent choosing QGV
           point having max bandwidth in case if SAGV is not allowed,
           as per BSpec(Ville Syrjälä)
         - Do the actual qgv_points_mask swap in the same place as
           all other global state parts like cdclk are swapped.
           In the next patch, this all will be moved to bw state as
           global state, once new global state patch series from Ville
           lands
    
    v14: - Now using global state to serialize access to qgv points
         - Added global state locking back, otherwise we seem to read
           bw state in a wrong way.
    
    v15: - Added TODO comment for near atomic global state locking in
           bw code.
    
    v16: - Fixed intel_atomic_bw_* functions to be intel_bw_* as discussed
           with Jani Nikula.
         - Take bw_state_changed flag into use.
    
    v17: - Moved qgv point related manipulations next to SAGV code, as
           those are semantically related(Ville Syrjälä)
         - Renamed those into intel_sagv_(pre)|(post)_plane_update
           (Ville Syrjälä)
    
    v18: - Move sagv related calls from commit tail into
           intel_sagv_(pre)|(post)_plane_update(Ville Syrjälä)
    
    v19: - Use intel_atomic_get_bw_(old)|(new)_state which is intended
           for commit tail stage.
    
    v20: - Return max bandwidth for 0 planes(Ville)
         - Constify old_bw_state in bw_atomic_check(Ville)
         - Removed some debugs(Ville)
         - Added data rate to debug print when no QGV points(Ville)
         - Removed some comments(Ville)
    
    v21, v22, v23: - Fixed rebase conflict
    
    v24: - Changed PCode mask to use ICL_ prefix
    v25: - Resolved rebase conflict
    
    v26: - Removed redundant NULL checks(Ville)
         - Removed redundant error prints(Ville)
    
    v27: - Use device specific drm_err(Ville)
         - Fixed parenthesis ident reported by checkpatch
           Line over 100 warns to be fixed together with
           existing code style.
    
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@intel.com>
    Cc: James Ausmus <james.ausmus@intel.com>
    [vsyrjala: Drop duplicate intel_sagv_{pre,post}_plane_update() prototypes
               and drop unused NUM_SAGV_POINTS define]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200514074853.9508-3-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index 898b4a85ccab..bbcaaa73ec1b 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -24,6 +24,13 @@ struct intel_bw_state {
 	 */
 	u8 pipe_sagv_reject;
 
+	/*
+	 * Current QGV points mask, which restricts
+	 * some particular SAGV states, not to confuse
+	 * with pipe_sagv_mask.
+	 */
+	u8 qgv_points_mask;
+
 	unsigned int data_rate[I915_MAX_PIPES];
 	u8 num_active_planes[I915_MAX_PIPES];
 
@@ -47,5 +54,7 @@ int intel_bw_init(struct drm_i915_private *dev_priv);
 int intel_bw_atomic_check(struct intel_atomic_state *state);
 void intel_bw_crtc_update(struct intel_bw_state *bw_state,
 			  const struct intel_crtc_state *crtc_state);
+int icl_pcode_restrict_qgv_points(struct drm_i915_private *dev_priv,
+				  u32 points_mask);
 
 #endif /* __INTEL_BW_H__ */

commit ecab0f3d055d333640bbe2aa5a5141574a65c534
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Thu Apr 30 22:56:34 2020 +0300

    drm/i915: Track active_pipes in bw_state
    
    We need to calculate SAGV mask also in a non-modeset
    commit, however currently active_pipes are only calculated
    for modesets in global atomic state, thus now we will be
    tracking those also in bw_state in order to be able to
    properly access global data.
    
    v2: - Removed pre/post plane SAGV updates from modeset(Ville)
        - Now tracking active pipes in intel_can_enable_sagv(Ville)
    
    v3: - lock global state if active_pipes change as well(Ville)
    
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200430195634.7666-1-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index d6df91058223..898b4a85ccab 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -26,6 +26,9 @@ struct intel_bw_state {
 
 	unsigned int data_rate[I915_MAX_PIPES];
 	u8 num_active_planes[I915_MAX_PIPES];
+
+	/* bitmask of active pipes */
+	u8 active_pipes;
 };
 
 #define to_intel_bw_state(x) container_of((x), struct intel_bw_state, base)

commit 9728889f42b9ba078f86cd11535a89df29e93b33
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Thu Apr 30 22:17:57 2020 +0300

    drm/i915: Use bw state for per crtc SAGV evaluation
    
    Future platforms require per-crtc SAGV evaluation
    and serializing global state when those are changed
    from different commits.
    
    v2: - Add has_sagv check to intel_crtc_can_enable_sagv
          so that it sets bit in reject mask.
        - Use bw_state in intel_pre/post_plane_enable_sagv
          instead of atomic state
    
    v3: - Fixed rebase conflict, now using
          intel_atomic_crtc_state_for_each_plane_state in
          order to call it from atomic check
    v4: - Use fb modifier from plane state
    
    v5: - Make intel_has_sagv static again(Ville)
        - Removed unnecessary NULL assignments(Ville)
        - Removed unnecessary SAGV debug(Ville)
        - Call intel_compute_sagv_mask only for modesets(Ville)
        - Serialize global state only if sagv results change, but
          not mask itself(Ville)
    
    v6: - use lock global state instead of serialize(Ville)
    v7: - use both global state lock and serialize depending on
          if we need to change only global state or access hw
          (Ville)
    
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@intel.com>
    Cc: James Ausmus <james.ausmus@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200430191757.18206-1-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index ac004d6f4276..d6df91058223 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -18,6 +18,12 @@ struct intel_crtc_state;
 struct intel_bw_state {
 	struct intel_global_state base;
 
+	/*
+	 * Contains a bit mask, used to determine, whether correspondent
+	 * pipe allows SAGV or not.
+	 */
+	u8 pipe_sagv_reject;
+
 	unsigned int data_rate[I915_MAX_PIPES];
 	u8 num_active_planes[I915_MAX_PIPES];
 };

commit 442e7ee834e8528ec85ea0df3c76bfe6c6742f5a
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Wed Apr 15 17:39:02 2020 +0300

    drm/i915: Add intel_atomic_get_bw_*_state helpers
    
    Add correspondent helpers to be able to get old/new bandwidth
    global state object.
    
    v2: - Fixed typo in function call
    v3: - Changed new functions naming to use convention proposed
          by Jani Nikula, i.e intel_bw_* in intel_bw.c file.
    v4: - Change function naming back to intel_atomic* pattern,
          was decided to rename in a separate patch series.
    v5: - Fix function naming to match existing practices(Ville)
    v6: - Removed spurious whitespace
    v7: - Removed bw_state NULL checks(Ville)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415143911.10244-3-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index a8aa7624c5aa..ac004d6f4276 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -24,6 +24,15 @@ struct intel_bw_state {
 
 #define to_intel_bw_state(x) container_of((x), struct intel_bw_state, base)
 
+struct intel_bw_state *
+intel_atomic_get_old_bw_state(struct intel_atomic_state *state);
+
+struct intel_bw_state *
+intel_atomic_get_new_bw_state(struct intel_atomic_state *state);
+
+struct intel_bw_state *
+intel_atomic_get_bw_state(struct intel_atomic_state *state);
+
 void intel_bw_init_hw(struct drm_i915_private *dev_priv);
 int intel_bw_init(struct drm_i915_private *dev_priv);
 int intel_bw_atomic_check(struct intel_atomic_state *state);

commit fd1a9bba73fa10e1601a43264283fe4696d6f82c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:25 2020 +0200

    drm/i915: Convert bandwidth state to global state
    
    Now that we have the more formal global state thing let's
    use if for memory bandwidth tracking. No real difference
    to the current private object usage since we already
    tried to avoid taking the single serializing lock needlessly.
    But since we're going to roll the global state out to more
    things probably a good idea to unify the approaches a bit.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-16-ville.syrjala@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index 20b9ad241802..a8aa7624c5aa 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -9,13 +9,14 @@
 #include <drm/drm_atomic.h>
 
 #include "intel_display.h"
+#include "intel_global_state.h"
 
 struct drm_i915_private;
 struct intel_atomic_state;
 struct intel_crtc_state;
 
 struct intel_bw_state {
-	struct drm_private_state base;
+	struct intel_global_state base;
 
 	unsigned int data_rate[I915_MAX_PIPES];
 	u8 num_active_planes[I915_MAX_PIPES];
@@ -25,7 +26,6 @@ struct intel_bw_state {
 
 void intel_bw_init_hw(struct drm_i915_private *dev_priv);
 int intel_bw_init(struct drm_i915_private *dev_priv);
-void intel_bw_cleanup(struct drm_i915_private *dev_priv);
 int intel_bw_atomic_check(struct intel_atomic_state *state);
 void intel_bw_crtc_update(struct intel_bw_state *bw_state,
 			  const struct intel_crtc_state *crtc_state);

commit b42d3b159ad8073602e466244f49f29f327e6798
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Mon Dec 9 20:09:02 2019 +0530

    drm/i915/display: cleanup intel_bw_state on i915 module removal
    
    intel_bw_state allocated memory is not getting freed even after
    module removal.
    
    kmemleak reported backtrace:
    
        [<0000000079019739>] kmemdup+0x17/0x40
        [<00000000d58c1b9d>] intel_bw_duplicate_state+0x1b/0x40 [i915]
        [<000000007423ed0c>] drm_atomic_get_private_obj_state+0xca/0x140
        [<00000000100e3533>] intel_bw_atomic_check+0x133/0x350 [i915]
        [<00000000126d0e0c>] intel_atomic_check+0x1ab7/0x20d0 [i915]
        [<00000000d5dfc004>] drm_atomic_check_only+0x563/0x810
        [<00000000c9379611>] drm_atomic_commit+0xe/0x50
        [<00000000ec82b765>] drm_atomic_helper_disable_all+0x133/0x160
        [<000000003c44760c>] drm_atomic_helper_shutdown+0x65/0xc0
        [<00000000414e3e5c>] i915_driver_remove+0xcb/0x130 [i915]
        [<00000000f8544c2a>] i915_pci_remove+0x19/0x40 [i915]
        [<000000002dcbd148>] pci_device_remove+0x36/0xb0
        [<000000003c8c6b0a>] device_release_driver_internal+0xe0/0x1c0
        [<00000000580e9566>] unbind_store+0xc3/0x120
        [<00000000869d0df5>] kernfs_fop_write+0x104/0x190
        [<000000004dc1a355>] vfs_write+0xb9/0x1d0
    
    Call the drm_atomic_private_obj_fini(), which inturn calls the
    intel_bw_destroy_state() to make sure the intel_bw_state memory is
    freed properly.
    
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Signed-off-by: Uma Shankar <uma.shankar@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191209143921.9240-1-pankaj.laxminarayan.bharadiya@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index 9db10af012f4..20b9ad241802 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -25,6 +25,7 @@ struct intel_bw_state {
 
 void intel_bw_init_hw(struct drm_i915_private *dev_priv);
 int intel_bw_init(struct drm_i915_private *dev_priv);
+void intel_bw_cleanup(struct drm_i915_private *dev_priv);
 int intel_bw_atomic_check(struct intel_atomic_state *state);
 void intel_bw_crtc_update(struct intel_bw_state *bw_state,
 			  const struct intel_crtc_state *crtc_state);

commit 366b6200f76e0f1241be262ea044eee44ded8fc6
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Aug 6 13:07:25 2019 +0300

    drm/i915/bw: make intel_atomic_get_bw_state() static
    
    No need for this function to be accessible outside of intel_bw.c. Avoid
    including the i915_drv.h mega header from other header files to make
    further header cleanup easier.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/6c898ec6511af47c1c5b679e516dc757cd207146.1565085691.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
index e9d9c6d63bc3..9db10af012f4 100644
--- a/drivers/gpu/drm/i915/display/intel_bw.h
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -8,7 +8,6 @@
 
 #include <drm/drm_atomic.h>
 
-#include "i915_drv.h"
 #include "intel_display.h"
 
 struct drm_i915_private;
@@ -24,20 +23,6 @@ struct intel_bw_state {
 
 #define to_intel_bw_state(x) container_of((x), struct intel_bw_state, base)
 
-static inline struct intel_bw_state *
-intel_atomic_get_bw_state(struct intel_atomic_state *state)
-{
-	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
-	struct drm_private_state *bw_state;
-
-	bw_state = drm_atomic_get_private_obj_state(&state->base,
-						    &dev_priv->bw_obj);
-	if (IS_ERR(bw_state))
-		return ERR_CAST(bw_state);
-
-	return to_intel_bw_state(bw_state);
-}
-
 void intel_bw_init_hw(struct drm_i915_private *dev_priv);
 int intel_bw_init(struct drm_i915_private *dev_priv);
 int intel_bw_atomic_check(struct intel_atomic_state *state);

commit df0566a641f959108c152be748a0a58794280e0e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jun 13 11:44:16 2019 +0300

    drm/i915: move modesetting core code under display/
    
    Now that we have a new subdirectory for display code, continue by moving
    modesetting core code.
    
    display/intel_frontbuffer.h sticks out like a sore thumb, otherwise this
    is, again, a surprisingly clean operation.
    
    v2:
    - don't move intel_sideband.[ch] (Ville)
    - use tabs for Makefile file lists and sort them
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613084416.6794-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_bw.h b/drivers/gpu/drm/i915/display/intel_bw.h
new file mode 100644
index 000000000000..e9d9c6d63bc3
--- /dev/null
+++ b/drivers/gpu/drm/i915/display/intel_bw.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2019 Intel Corporation
+ */
+
+#ifndef __INTEL_BW_H__
+#define __INTEL_BW_H__
+
+#include <drm/drm_atomic.h>
+
+#include "i915_drv.h"
+#include "intel_display.h"
+
+struct drm_i915_private;
+struct intel_atomic_state;
+struct intel_crtc_state;
+
+struct intel_bw_state {
+	struct drm_private_state base;
+
+	unsigned int data_rate[I915_MAX_PIPES];
+	u8 num_active_planes[I915_MAX_PIPES];
+};
+
+#define to_intel_bw_state(x) container_of((x), struct intel_bw_state, base)
+
+static inline struct intel_bw_state *
+intel_atomic_get_bw_state(struct intel_atomic_state *state)
+{
+	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+	struct drm_private_state *bw_state;
+
+	bw_state = drm_atomic_get_private_obj_state(&state->base,
+						    &dev_priv->bw_obj);
+	if (IS_ERR(bw_state))
+		return ERR_CAST(bw_state);
+
+	return to_intel_bw_state(bw_state);
+}
+
+void intel_bw_init_hw(struct drm_i915_private *dev_priv);
+int intel_bw_init(struct drm_i915_private *dev_priv);
+int intel_bw_atomic_check(struct intel_atomic_state *state);
+void intel_bw_crtc_update(struct intel_bw_state *bw_state,
+			  const struct intel_crtc_state *crtc_state);
+
+#endif /* __INTEL_BW_H__ */
