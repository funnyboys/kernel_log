commit 6cf991611bc72c077f0cc64e23987341ad7ef41e
Merge: bfbe1744e441 3a36aa237e4e
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 20 13:36:44 2020 +1000

    Merge tag 'drm-intel-next-2020-05-15' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    UAPI Changes:
    
    - drm/i915: Show per-engine default property values in sysfs
    
        By providing the default values configured into the kernel via sysfs, it
        is much more convenient for userspace to restore those sane defaults, or
        at least know what are considered good baseline. This is useful, for
        example, to cleanup after any failed userspace prior to commencing new
        jobs.
    
    Cross-subsystem Changes:
    
    - video/hdmi: Add Unpack only function for DRM infoframe
    - Includes pull request gvt-next-2020-05-12
    
    Driver Changes:
    
    - Restore Cherryview back to full-ppgtt (Chris, Mika)
    - Document locking guidelines for i915 (Chris, Daniel, Joonas)
    - Fix GitLab #1746: Handle idling during i915_gem_evict_something busy loops (Chris)
    - Display WA #1105: Require linear fb stride to be multiple of 512 bytes on
      gen9/glk (Ville)
    - Add Wa_14010685332 for ICP/ICL (Matt R)
    - Restrict w/a 1607087056 for EHL/JSL (Swathi)
    - Fix interrupt handling for DP AUX transactions on Tigerlake (Imre)
    - Revert "drm/i915/tgl: Include ro parts of l3 to invalidate" (Mika)
    - Fix HDC pipeline flush hardware bit on Gen12 (Mika)
    - Flush L3 when flushing render on Gen12 (Mika)
    - Invalidate aux table entries forcibly between BB on Gen12 (Mika)
    - Add aux table invalidate for all engines on Gen12 (Mika)
    - Force pte cacheline to main memory Gen8+ (Mika)
    - Add and enable TGL+ SAGV support (Stanislav)
    - Implement vm_ops->access on i915 mmaps for GDB (Chris, Kristian)
    - Replace zero-length array with flexible-array (Gustavo)
    - Improve batch buffer pool effectiveness to mitigate soft-rc6 hit (Chris)
    - Remove wait priority boosting (Chris)
    - Keep driver module referenced when PMU is active (Chris)
    - Sanitize RPS interrupts upon resume (Chris)
    - Extend pcode read timeout to 20 ms (Chris)
    - Wait for ACT sent before enabling MST pipe (Ville)
    - Extend support to async relocations to SNB (Chris)
    - Remove CNL pre-prod workarounds (Ville)
    - Don't enable WaIncreaseLatencyIPCEnabled when IPC is disabled (Sultan)
    - Record the active CCID from before reset (Chris)
    - Mark concurrent submissions with a weak-dependency (Chris)
    - Peel dma-fence-chains for await to allow engine-to-engine sync (Lionel)
    - Prevent using semaphores to chain up to external fences (Chris)
    - Fix GLK watermark calculations (Ville)
    - Emit await(batch) before MI_BB_START (Chris)
    - Reset execlists registers before HWSP (Chris)
    - Drop no-semaphore boosting in favor of fast timeslicing (Chris)
    - Fix enabled infoframe states of lspcon (Gwan-gyeong)
    - Program DP SDPs on pipe updates (Gwan-gyeong)
    - Stop sending DP SDPs on ddi disable (Gwan-gyeong)
    - Store CS timestamp frequency in Hz (Ville)
    
    - Remove unused HAS_FWTABLE macro (Pascal)
    - Use batchbuffer chaining for relocations to save ring space (Chris)
    - Try different engines for relocs if MI ops not supported (Chris, Tvrtko)
    - Lazily acquire the device wakeref for freeing objects (Chris)
    - Streamline display code arithmetics around rounding etc. (Ville)
    - Use bw state for per crtc SAGV evaluation (Stanislav)
    - Track active_pipes in bw_state (Stanislav)
    - Nuke mode.vrefresh usage (Ville)
    - Warn if the FBC is still writing to stolen on removal (Chris)
    - Added new PCode commands prepping for QGV rescricting (Stansilav)
    - Stop holding onto the pinned_default_state (Chris)
    - Propagate error from completed fences (Chris)
    - Ignore submit-fences on the same timeline (Chris)
    - Pull waiting on an external dma-fence into its routine (Chris)
    - Replace the hardcoded I915_FENCE_TIMEOUT with Kconfig (Chris)
    - Mark up the racy read of execlists->context_tag (Chris)
    - Tidy up the return handling for completed dma-fences (Chris)
    - Introduce skl_plane_wm_level accessor (Stanislav)
    - Extract SKL SAGV checking (Stanislav)
    - Make active_pipes check skl specific (Stanislav)
    - Suspend tasklets before resume sanitization (Chris)
    - Remove redundant exec_fence (Chris)
    - Mark the addition of the initial-breadcrumb in the request (Chris)
    - Transfer old virtual breadcrumbs to irq_worker (Chris)
    - Read the DP SDPs from the video DIP (Gwan-gyeong)
    - Program DP SDPs with computed configs (Gwan-gyeong)
    - Add state readout for DP VSC and DP HDR Metadata Infoframe SDP
      (Gwan-gyeong)
    - Add compute routine for DP PSR VSC SDP (Gwan-gyeong)
    - Use new DP VSC SDP compute routine on PSR (Gwan-gyeong)
    - Restrict qgv points which don't have enough bandwidth. (Stanislav)
    - Nuke pointless div by 64bit (Ville)
    
    - Static checker code fixes (Nathan, Mika, Chris)
    - Add logging function for DP VSC SDP (Gwan-gyeong)
    - Include HDMI DRM infoframe, DP HDR metadata and DP VSC SDP in the
      crtc state dump (Gwan-gyeong)
    - Make timeslicing explicit engine property (Chris, Tvrtko)
    - Selftest and debugging improvements (Chris)
    - Align variable names with BSpec (Ville)
    - Tidy up gen8+ breadcrumb emission code (Chris)
    - Turn intel_digital_port_connected() in a vfunc (Ville)
    - Use stashed away hpd isr bits in intel_digital_port_connected() (Ville)
    - Extract i915_cs_timestamp_{ns_to_ticks,tick_to_ns}() (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200515160703.GA19043@jlahtine-desk.ger.corp.intel.com

commit 7241c57d3140ad3b613777a8515ffe1f653d4800
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Thu May 14 10:48:51 2020 +0300

    drm/i915: Add TGL+ SAGV support
    
    Starting from TGL we need to have a separate wm0
    values for SAGV and non-SAGV which affects
    how calculations are done.
    
    v2: Remove long lines
    v3: Removed COLOR_PLANE enum references
    v4, v5, v6: Fixed rebase conflict
    v7: - Removed skl_plane_wm_level accessor from skl_allocate_pipe_ddb(Ville)
        - Removed sagv_uv_wm0(Ville)
        - can_sagv->use_sagv_wm(Ville)
    
    v8: - Moved tgl_crtc_can_enable_sagv function up(Ville)
        - Changed comment regarding pipe_wm usage(Ville)
        - Call intel_can_enable_sagv and tgl_compute_sagv_wm only
          for Gen12(Ville)
        - Some sagv debugs removed(Ville)
        - skl_print_wm_changes improvements(Ville)
        - Do assignment instead of memcpy in
          skl_pipe_wm_get_hw_state(Ville)
    
    v9: - Removed can_sagv variable(Ville)
        - Removed spurious line(Ville)
        - Changed u32 to unsigned int as agreed(Ville)
        - Assign sagv only for gen12 in
          skl_pipe_wm_get_hw_state(Ville)
    
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    [vsyrjala: Remove the dead 'return false' from intel_crtc_can_enable_sagv()]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200514074853.9508-2-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 1b689d6bac4c..6a27e72ccf01 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -688,11 +688,13 @@ struct skl_plane_wm {
 	struct skl_wm_level wm[8];
 	struct skl_wm_level uv_wm[8];
 	struct skl_wm_level trans_wm;
+	struct skl_wm_level sagv_wm0;
 	bool is_planar;
 };
 
 struct skl_pipe_wm {
 	struct skl_plane_wm planes[I915_MAX_PLANES];
+	bool use_sagv_wm;
 };
 
 enum vlv_wm_level {

commit a1fb548962397bb8609bb46e566809a9a1b30044
Merge: 3fd911b69b31 230982d8d8df
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 14 11:33:09 2020 +1000

    Merge tag 'drm-intel-next-2020-04-30' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Driver Changes:
    
    - Fix GitLab #1698: Performance regression with Linux 5.7-rc1 on
      Iris Plus 655 and 4K screen (Chris)
    - Add Wa_14011059788 for Tigerlake (Matt A)
    - Add per ctx batchbuffer wa for timestamp for Gen12 (Mika)
    - Use indirect ctx bb to load cmd buffer control value
      from context image to avoid corruption (Mika)
    - Enable DP Display Audio WA (Uma, Jani)
    - Update forcewake firmware ranges for Icelake (Radhakrishna)
    - Add missing deinitialization cases of load failure for display (Jose)
    - Implement TC cold sequences for Icelake and Tigerlake (Jose)
    - Unbreak enable_dpcd_backlight modparam (Lyude)
    - Move the late flush_submission in retire to the end (Chris)
    - Demote "Reducing compressed framebufer size" message to info (Peter)
    - Push MST link retraining to the hotplug work (Ville)
    - Hold obj->vma.lock over for_each_ggtt_vma() (Chris)
    - Fix timeout handling during TypeC AUX power well enabling for ICL (Imre)
    - Fix skl+ non-scaled pfit modes (Ville)
    - Prefer soft-rc6 over RPS DOWN_TIMEOUT (Chris)
    - Sanitize GT first before poisoning HWSP (Chris)
    - Fix up clock RPS frequency readout (Chris)
    - Avoid reusing the same logical CCID (Chris)
    - Avoid dereferencing a dead context (Chris)
    - Always enable busy-stats for execlists (Chris)
    - Apply the aggressive downclocking to parking (Chris)
    - Restore aggressive post-boost downclocking (Chris)
    
    - Scrub execlists state on resume (Chris)
    - Add debugfs attributes for LPSP (Ansuman)
    - Improvements to kernel selftests (Chris, Mika)
    - Add tiled blits selftest (Zbigniew)
    - Fix error handling in __live_lrc_indirect_ctx_bb() (Dan)
    - Add pre/post plane updates for SAGV (Stanislav)
    - Add ICL PG3 PW ID for EHL (Anshuman)
    - Fix Sphinx build duplicate label warning (Jani)
    - Error log non-zero audio power refcount after unbind (Jani)
    - Remove object_is_locked assertion from unpin_from_display_plane (Chris)
    - Use single set of AUX powerwell ops for gen11+ (Matt R)
    - Prefer drm_WARN_ON over WARN_ON (Pankaj)
    - Poison residual state [HWSP] across resume (Chris, Tvrtko)
    - Convert request-before-CS assertion to debug (Chris)
    - Carefully order virtual_submission_tasklet (Chris)
    - Check carefully for an idle engine in wait-for-idle (Chris)
    - Only close vma we open (Chris)
    - Trace RPS events (Chris)
    - Use the RPM config register to determine clk frequencies (Chris)
    - Drop rq->ring->vma peeking from error capture (Chris)
    - Check preempt-timeout target before submit_ports (Chris)
    - Check HWSP cacheline is valid before acquiring (Chris)
    - Use proper fault mask in interrupt postinstall too (Matt R)
    - Keep a no-frills swappable copy of the default context state (Chris)
    
    - Add atomic helpers for bandwidth (Stanislav)
    - Refactor setting dma info to a common helper from device info (Michael)
    - Refactor DDI transcoder code for clairty (Ville)
    - Extend PG3 power well ID to ICL (Anshuman)
    - Refactor PFIT code for readability and future extensibility (Ville)
    - Clarify code split between intel_ddi.c and intel_dp.c (Ville)
    - Move out code to return the digital_port of the aux ch (Jose)
    - Move rps.enabled/active  and use of RPS interrupts to flags (Chris)
    - Remove superfluous inlines and dead code (Jani)
    - Re-disable -Wframe-address from top-level Makefile (Nick)
    - Static checker and spelling fixes (Colin, Nathan)
    - Split long lines (Ville)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200430124904.GA100924@jlahtine-desk.ger.corp.intel.com

commit edc0e09c6ba81fc7a06cc68deec430519b7d18d8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 11 17:54:20 2020 +0200

    drm/i915: Turn intel_digital_port_connected() in a vfunc
    
    Let's get rid of the platform if ladders in
    intel_digital_port_connected() and make it a vfunc. Now the if
    ladders are at the encoder initialization which makes them a bit
    less convoluted.
    
    v2: Add forward decl for intel_encoder in intel_tc.h
    v3: Duplicate stuff to avoid exposing platform specific
        functions across files (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200311155422.3043-2-ville.syrjala@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index e58e25779bd6..1b689d6bac4c 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1424,6 +1424,7 @@ struct intel_digital_port {
 			       const struct drm_connector_state *conn_state);
 	u32 (*infoframes_enabled)(struct intel_encoder *encoder,
 				  const struct intel_crtc_state *pipe_config);
+	bool (*connected)(struct intel_encoder *encoder);
 };
 
 struct intel_dp_mst_encoder {

commit 8fdda3854967d003f743059bb64ace8154266381
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Apr 20 23:06:09 2020 +0300

    drm/i915: Introduce .set_idle_link_train() vfunc
    
    Relocate a bunch of DDI specific code from intel_dp.c to intel_ddi.c
    by introducing a .set_idle_link_train() vfunc.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200420200610.31798-3-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index baafd4a6ca24..e58e25779bd6 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1368,6 +1368,7 @@ struct intel_dp {
 	/* This is called before a link training is starterd */
 	void (*prepare_link_retrain)(struct intel_dp *intel_dp);
 	void (*set_link_train)(struct intel_dp *intel_dp, u8 dp_train_pat);
+	void (*set_idle_link_train)(struct intel_dp *intel_dp);
 	void (*set_signal_levels)(struct intel_dp *intel_dp);
 
 	/* Displayport compliance testing */

commit fb83f72c48a52201431945d31843a964b927a8e3
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Apr 20 23:06:08 2020 +0300

    drm/i915: Introduce .set_signal_levels() vfunc
    
    Sort out some of the mess between intel_ddi.c intel_dp.c by
    introducing a .set_signal_levels() vfunc.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200420200610.31798-2-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 991dbd8ed314..baafd4a6ca24 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1368,6 +1368,7 @@ struct intel_dp {
 	/* This is called before a link training is starterd */
 	void (*prepare_link_retrain)(struct intel_dp *intel_dp);
 	void (*set_link_train)(struct intel_dp *intel_dp, u8 dp_train_pat);
+	void (*set_signal_levels)(struct intel_dp *intel_dp);
 
 	/* Displayport compliance testing */
 	struct intel_dp_compliance compliance;

commit eee3f91195ad8a096048fb5869e7299fd1e3ea5f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Apr 20 23:06:07 2020 +0300

    drm/i915: Introduce .set_link_train() vfunc
    
    Sort out some of the mess between intel_ddi.c intel_dp.c by
    introducing a .set_link_train() vfunc.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200420200610.31798-1-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index b37129ca0518..991dbd8ed314 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1367,6 +1367,7 @@ struct intel_dp {
 
 	/* This is called before a link training is starterd */
 	void (*prepare_link_retrain)(struct intel_dp *intel_dp);
+	void (*set_link_train)(struct intel_dp *intel_dp, u8 dp_train_pat);
 
 	/* Displayport compliance testing */
 	struct intel_dp_compliance compliance;

commit 35dd95b4ee19787d4dd321ea88dd72c9b87d9425
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 22 19:19:14 2020 +0300

    drm/i915: Use drm_rect to store the pfit window pos/size
    
    Make things a bit more abstract by replacing the pch_pfit.pos/size
    raw register values with a drm_rect. Makes it slighly more convenient
    to eg. compute the scaling factors.
    
    v2: Use drm_rect_init()
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200422161917.17389-3-ville.syrjala@linux.intel.com
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 8752f4d6ea9b..b37129ca0518 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -974,8 +974,7 @@ struct intel_crtc_state {
 
 	/* Panel fitter placement and size for Ironlake+ */
 	struct {
-		u32 pos;
-		u32 size;
+		struct drm_rect dst;
 		bool enabled;
 		bool force_thru;
 	} pch_pfit;

commit 1aa63ddf726ea049279989b93b69b57ce6efd75b
Merge: 774f1eeb18b0 14d0066b8477
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 22 10:40:34 2020 +1000

    Merge tag 'drm-misc-next-2020-04-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.8:
    
    UAPI Changes:
    
      - drm: error out with EBUSY when device has existing master
      - drm: rework SET_MASTER and DROP_MASTER perm handling
    
    Cross-subsystem Changes:
    
      - mm: export two symbols from slub/slob
      - fbdev: savage: fix -Wextra build warning
      - video: omap2: Use scnprintf() for avoiding potential buffer overflow
    
    Core Changes:
    
      - Remove drm_pci.h
      - drm_pci_{alloc/free)() are now legacy
      - Introduce managed DRM resourcesA
      - Allow drivers to subclass struct drm_framebuffer
      - Introduce struct drm_afbc_framebuffer and helpers
      - fbdev: remove return value from generic fbdev setup
      - Introduce simple-encoder helper
      - vram-helpers: set fence on plane
      - dp_mst: ACT timeout improvements
      - dp_mst: Remove drm_dp_mst_has_audio()
      - TTM: ttm_trace_dma_{map/unmap}() cleanups
      - dma-buf: add flag for PCIP2P support
      - EDID: Various improvements
      - Encoder: cleanup semantics of possible_clones and possible_crtcs
      - VBLANK documentation updates
      - Writeback documentation updates
    
    Driver Changes:
    
      - Convert several drivers to i2c_new_client_device()
      - Drop explicit drm_mode_config_cleanup() calls from drivers
      - Auto-release device structures with drmm_add_final_kfree()
      - Init bfdev console after registering DRM device
      - Make various .debugfs functions return 0 unconditionally; ignore errors
      - video: Use scnprintf() to avoid buffer overflows
      - Convert drivers to simple encoders
    
      - drm/amdgpu: note that we can handle peer2peer DMA-buf
      - drm/amdgpu: add support for exporting VRAM using DMA-buf v3
      - drm/kirin: Revert change to register connectors
      - drm/lima: Add optional devfreq and cooling device support
      - drm/lima: Various improvements wrt. task handling
      - drm/panel: nt39016: Support multiple modes and 50Hz
      - drm/panel: Support Leadtek LTK050H3146W
      - drm/rockchip: Add support for afbc
      - drm/virtio: Various cleanups
      - drm/hisilicon/hibmc: Enforce 128-byte stride alignment
      - drm/qxl: Fix notify port address of cursor ring buffer
      - drm/sun4i: Improvements to format handling
      - drm/bridge: dw-hdmi: Various improvements
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200414090738.GA16827@linux-uq9g

commit cef622d7634e0adc351d795f089e7b77700272ca
Merge: 2b703bbda271 8cdf72711928
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 16 14:36:38 2020 +0300

    Merge tag 'topic/phy-compliance-2020-04-08' of git://anongit.freedesktop.org/drm/drm-misc into drm-intel-next-queued
    
    Topic pull request for topic/phy-compliance:
    - Standardize DP_PHY_TEST_PATTERN name.
    - Add support for setting/getting test pattern from sink.
    - Implement DP PHY compliance to i915.
    
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/efb3d0d9-2cf7-046b-3a9b-2548d086258e@linux.intel.com
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 88afbfdbfda88fd07f01f1ba1731b090f32a5a3f
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Mon Mar 16 16:07:56 2020 +0530

    drm/i915/dp: Preparation for DP phy compliance auto test
    
    During DP phy compliance auto test mode, sink will request
    combination of different test pattern with differnt level of
    vswing, pre-emphasis. Function added to prepare for it.
    
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200316103759.12867-5-animesh.manna@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 5e00e611f077..42d0b102c2cf 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1238,6 +1238,7 @@ struct intel_dp_compliance_data {
 	u8 video_pattern;
 	u16 hdisplay, vdisplay;
 	u8 bpc;
+	struct drm_dp_phy_test_params phytest;
 };
 
 struct intel_dp_compliance {

commit 75727b30809266decfe21ed1143ef5cfd27bac89
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon Apr 6 16:06:41 2020 -0400

    drm/i915/dp_mst: Cast intel_connector->port as drm_dp_mst_port
    
    The only reason for having this cast as void * before was because we
    originally needed to use drm_dp_mst_get_port_validated() and friends in
    order to (attempt to) safely access MST ports. However, we've since
    improved how reference counting works with ports and mstbs such that we
    can now rely on drm_dp_mst_port structs remaining in memory for as long
    as the driver needs. This means we don't really need to cast this as
    void* anymore, and can just access the struct directly.
    
    We'll also need this for the next commit, so that we can remove
    drm_dp_mst_port_has_audio().
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Sean Paul <sean@poorly.run>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200406200646.1263435-1-lyude@redhat.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 5e00e611f077..e67474a71761 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -429,7 +429,7 @@ struct intel_connector {
 	   state of connector->polled in case hotplug storm detection changes it */
 	u8 polled;
 
-	void *port; /* store this opaque as its illegal to dereference it */
+	struct drm_dp_mst_port *port;
 
 	struct intel_dp *mst_port;
 

commit 8c8919c7c99f097c9e6a441486c1c263277288b0
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Mar 30 12:54:24 2020 +0300

    drm/i915: Add a retry counter for hotplug detect retries
    
    On TypeC connectors we need to retry the detection after hotplug events
    for a longer time, so add a retry counter to support this. The next
    patch will add detection retries on TypeC ports needing this.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200330095425.29113-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 2bedd626c686..5a0adf14ebef 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -132,8 +132,7 @@ struct intel_encoder {
 	u16 cloneable;
 	u8 pipe_mask;
 	enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
-					    struct intel_connector *connector,
-					    bool irq_received);
+					    struct intel_connector *connector);
 	enum intel_output_type (*compute_output_type)(struct intel_encoder *,
 						      struct intel_crtc_state *,
 						      struct drm_connector_state *);
@@ -432,6 +431,9 @@ struct intel_connector {
 	struct edid *edid;
 	struct edid *detect_edid;
 
+	/* Number of times hotplug detection was tried after an HPD interrupt */
+	int hotplug_retries;
+
 	/* since POLL and HPD connectors may use the same HPD line keep the native
 	   state of connector->polled in case hotplug storm detection changes it */
 	u8 polled;

commit ede9771d7f84025e64ed5cbd683c5f0e4e7f2187
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Mar 13 18:48:30 2020 +0200

    drm/i915: Pass atomic state to encoder hooks
    
    We're going to want access to the atomic state for iterating
    the slave crtcs when enabling the port sync master crtc. Pass
    the atomic state all the way down.
    
    The alternative would be yet another encoder hook which we'll
    have to call after all the normal modeset stuff is done. Not
    really a fan of yet another hook just for this.
    
    Note that during readout state sanitation we are now going
    to pass NULL as the atomic state since we don't have one.
    We need to change that and then we can also s/crtc_state/crtc/
    and s/conn_state/conn/ for the encoder hooks as well.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200313164831.5980-13-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 176ab5f1e867..2bedd626c686 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -146,28 +146,35 @@ struct intel_encoder {
 	void (*update_prepare)(struct intel_atomic_state *,
 			       struct intel_encoder *,
 			       struct intel_crtc *);
-	void (*pre_pll_enable)(struct intel_encoder *,
+	void (*pre_pll_enable)(struct intel_atomic_state *,
+			       struct intel_encoder *,
 			       const struct intel_crtc_state *,
 			       const struct drm_connector_state *);
-	void (*pre_enable)(struct intel_encoder *,
+	void (*pre_enable)(struct intel_atomic_state *,
+			   struct intel_encoder *,
 			   const struct intel_crtc_state *,
 			   const struct drm_connector_state *);
-	void (*enable)(struct intel_encoder *,
+	void (*enable)(struct intel_atomic_state *,
+		       struct intel_encoder *,
 		       const struct intel_crtc_state *,
 		       const struct drm_connector_state *);
 	void (*update_complete)(struct intel_atomic_state *,
 				struct intel_encoder *,
 				struct intel_crtc *);
-	void (*disable)(struct intel_encoder *,
+	void (*disable)(struct intel_atomic_state *,
+			struct intel_encoder *,
 			const struct intel_crtc_state *,
 			const struct drm_connector_state *);
-	void (*post_disable)(struct intel_encoder *,
+	void (*post_disable)(struct intel_atomic_state *,
+			     struct intel_encoder *,
 			     const struct intel_crtc_state *,
 			     const struct drm_connector_state *);
-	void (*post_pll_disable)(struct intel_encoder *,
+	void (*post_pll_disable)(struct intel_atomic_state *,
+				 struct intel_encoder *,
 				 const struct intel_crtc_state *,
 				 const struct drm_connector_state *);
-	void (*update_pipe)(struct intel_encoder *,
+	void (*update_pipe)(struct intel_atomic_state *,
+			    struct intel_encoder *,
 			    const struct intel_crtc_state *,
 			    const struct drm_connector_state *);
 	/* Read out the current hw state of this connector, returning true if

commit b683e6d9a679141e4d28dc1c4ba8286041691803
Author: Vandita Kulkarni <vandita.kulkarni@intel.com>
Date:   Thu Mar 12 11:08:35 2020 +0530

    drm/i915/dsi: Add cmd mode flags in display mode private flags
    
    Adding TE flags and periodic command mode flags
    as part of private flags to indicate what TE interrupts
    we would be getting instead of vblanks in case of mipi dsi
    command mode.
    
    v2: Add TE flag description (Jani)
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Vandita Kulkarni <vandita.kulkarni@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200312053841.2794-4-vandita.kulkarni@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 7de4249f2292..176ab5f1e867 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -640,6 +640,16 @@ struct intel_crtc_scaler_state {
 #define I915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP (1<<1)
 /* Flag to use the scanline counter instead of the pixel counter */
 #define I915_MODE_FLAG_USE_SCANLINE_COUNTER (1<<2)
+/*
+ * TE0 or TE1 flag is set if the crtc has a DSI encoder which
+ * is operating in command mode.
+ * Flag to use TE from DSI0 instead of VBI in command mode
+ */
+#define I915_MODE_FLAG_DSI_USE_TE0 (1<<3)
+/* Flag to use TE from DSI1 instead of VBI in command mode */
+#define I915_MODE_FLAG_DSI_USE_TE1 (1<<4)
+/* Flag to indicate mipi dsi periodic command mode where we do not get TE */
+#define I915_MODE_FLAG_DSI_PERIODIC_CMD_MODE (1<<5)
 
 struct intel_wm_level {
 	bool enable;

commit 9799c4c3b76e540d97e302f9beb5971ef6a9b473
Author: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Date:   Tue Feb 11 09:46:41 2020 +0200

    drm/i915/dp: Add compute routine for DP VSC SDP
    
    In order to support state readout for DP VSC SDP, we need to have a
    structure which holds DP VSC SDP payload data such as
    "union hdmi_infoframe drm" which is used for DRM infoframe.
    It adds a struct drm_dp_vsc_sdp vsc to intel_crtc_state.infoframes.
    
    And it stores computed dp vsc sdp to infoframes.vsc of crtc state.
    While computing we'll also fill out the inforames.enable bitmask
    appropriately.
    
    The compute routine follows DP 1.4 spec [Table 2-117: VSC SDP Payload for
    DB16 through DB18].
    
    v3: Replace a structure name to drm_dp_vsc_sdp from intel_dp_vsc_sdp
    v5:
      - Rebased
      - Add warning where a bpc is 6 and a pixel format is RGB.
    v7: Fix the wrong check of combination bpc 6 and RGB pixelformat
    
    Signed-off-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211074657.231405-3-gwan-gyeong.mun@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 5e00e611f077..7de4249f2292 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1015,6 +1015,7 @@ struct intel_crtc_state {
 		union hdmi_infoframe spd;
 		union hdmi_infoframe hdmi;
 		union hdmi_infoframe drm;
+		struct drm_dp_vsc_sdp vsc;
 	} infoframes;
 
 	/* HDMI scrambling status */

commit 0883ce8146ed6074c76399f4e70dbed788582e12
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Feb 11 13:33:46 2020 -0500

    drm/dp: Introduce EDID-based quirks
    
    The whole point of using OUIs is so that we can recognize certain
    devices and potentially apply quirks for them. Normally this should work
    quite well, but there appears to be quite a number of laptop panels out
    there that will fill the OUI but not the device ID. As such, for devices
    like this I can't imagine it's a very good idea to try relying on OUIs
    for applying quirks. As well, some laptop vendors have confirmed to us
    that their panels have this exact issue.
    
    So, let's introduce the ability to apply DP quirks based on EDID
    identification. We reuse the same quirk bits for OUI-based quirks, so
    that callers can simply check all possible quirks using
    drm_dp_has_quirk().
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211183358.157448-2-lyude@redhat.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index bd37c7058f93..5e00e611f077 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1280,6 +1280,7 @@ struct intel_dp {
 	int max_link_rate;
 	/* sink or branch descriptor */
 	struct drm_dp_desc desc;
+	u32 edid_quirks;
 	struct drm_dp_aux aux;
 	u32 aux_busy_last_status;
 	u8 train_set[4];

commit a10510afa0bbd5cdf4867dfff8905bbbfce1515e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 19:00:47 2020 +0200

    drm/i915: move watermark structs more towards usage
    
    Shrink i915_drv.h a bit by moving watermark structs where they are
    needed.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227170047.31089-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index ac5d066e23a0..bd37c7058f93 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -641,6 +641,14 @@ struct intel_crtc_scaler_state {
 /* Flag to use the scanline counter instead of the pixel counter */
 #define I915_MODE_FLAG_USE_SCANLINE_COUNTER (1<<2)
 
+struct intel_wm_level {
+	bool enable;
+	u32 pri_val;
+	u32 spr_val;
+	u32 cur_val;
+	u32 fbc_val;
+};
+
 struct intel_pipe_wm {
 	struct intel_wm_level wm[5];
 	bool fbc_wm_enabled;
@@ -649,6 +657,14 @@ struct intel_pipe_wm {
 	bool sprites_scaled;
 };
 
+struct skl_wm_level {
+	u16 min_ddb_alloc;
+	u16 plane_res_b;
+	u8 plane_res_l;
+	bool plane_en;
+	bool ignore_lines;
+};
+
 struct skl_plane_wm {
 	struct skl_wm_level wm[8];
 	struct skl_wm_level uv_wm[8];

commit 00535527350c1ab139ae31e0128d936d44b11004
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Feb 27 18:12:53 2020 +0200

    drm/i915/crc: move pipe_crc from drm_i915_private to intel_crtc
    
    Having an array pipe_crc[I915_MAX_PIPES] in struct drm_i915_private
    should be an obvious clue this should be located in struct intel_crtc
    instead. Make it so.
    
    As a side-effect, fix some errors in indexing pipe_crc with both pipe
    and crtc index. And, of course, reduce the size of i915_drv.h.
    
    Cc: Anshuman Gupta <anshuman.gupta@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227161253.15741-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 0a06043d4d4c..ac5d066e23a0 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1045,6 +1045,32 @@ struct intel_crtc_state {
 	enum transcoder mst_master_transcoder;
 };
 
+enum intel_pipe_crc_source {
+	INTEL_PIPE_CRC_SOURCE_NONE,
+	INTEL_PIPE_CRC_SOURCE_PLANE1,
+	INTEL_PIPE_CRC_SOURCE_PLANE2,
+	INTEL_PIPE_CRC_SOURCE_PLANE3,
+	INTEL_PIPE_CRC_SOURCE_PLANE4,
+	INTEL_PIPE_CRC_SOURCE_PLANE5,
+	INTEL_PIPE_CRC_SOURCE_PLANE6,
+	INTEL_PIPE_CRC_SOURCE_PLANE7,
+	INTEL_PIPE_CRC_SOURCE_PIPE,
+	/* TV/DP on pre-gen5/vlv can't use the pipe source. */
+	INTEL_PIPE_CRC_SOURCE_TV,
+	INTEL_PIPE_CRC_SOURCE_DP_B,
+	INTEL_PIPE_CRC_SOURCE_DP_C,
+	INTEL_PIPE_CRC_SOURCE_DP_D,
+	INTEL_PIPE_CRC_SOURCE_AUTO,
+	INTEL_PIPE_CRC_SOURCE_MAX,
+};
+
+#define INTEL_PIPE_CRC_ENTRIES_NR	128
+struct intel_pipe_crc {
+	spinlock_t lock;
+	int skipped;
+	enum intel_pipe_crc_source source;
+};
+
 struct intel_crtc {
 	struct drm_crtc base;
 	enum pipe pipe;
@@ -1088,6 +1114,10 @@ struct intel_crtc {
 
 	/* per pipe DSB related info */
 	struct intel_dsb dsb;
+
+#ifdef CONFIG_DEBUG_FS
+	struct intel_pipe_crc pipe_crc;
+#endif
 };
 
 struct intel_plane {

commit 83d2bdb6a0e088a0ec8fe1e2877c8aa1a4a80330
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Feb 25 15:31:31 2020 +0200

    drm/i915: significantly reduce the use of <drm/i915_drm.h>
    
    The #include has been splattered all over the place, but there are
    precious few places, all .c files, that actually need it.
    
    v2: remove leftover double newlines
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225133131.3301-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 61f4628f5602..0a06043d4d4c 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -39,7 +39,6 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_rect.h>
 #include <drm/drm_vblank.h>
-#include <drm/i915_drm.h>
 #include <drm/i915_mei_hdcp_interface.h>
 #include <media/cec-notifier.h>
 

commit b1852b73f25b2de737c5ce97e8b0d17d3a232127
Author: Anshuman Gupta <anshuman.gupta@intel.com>
Date:   Mon Feb 24 18:10:03 2020 +0530

    drm/i915: Add WARN_ON in intel_get_crtc_for_pipe()
    
    Add a WARN_ON for a disabled pipe in pipe_mask at
    intel_get_crtc_for_pipe() function.
    
    v2:
    - Use drm_WARN_ON instead of WARN_ON.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200224124004.26712-7-anshuman.gupta@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 3ca6cf7f3986..61f4628f5602 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1415,6 +1415,9 @@ intel_get_first_crtc(struct drm_i915_private *dev_priv)
 static inline struct intel_crtc *
 intel_get_crtc_for_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)
 {
+	/* pipe_to_crtc_mapping may have hole on any of 3 display pipe system */
+	drm_WARN_ON(&dev_priv->drm,
+		    !(INTEL_INFO(dev_priv)->pipe_mask & BIT(pipe)));
 	return dev_priv->pipe_to_crtc_mapping[pipe];
 }
 

commit eae3da27ba84a95ade67b03318d7f1f003bd376a
Author: Anshuman Gupta <anshuman.gupta@intel.com>
Date:   Mon Feb 24 18:10:02 2020 +0530

    drm/i915: Get first crtc instead of PIPE_A crtc
    
    intel_plane_fb_max_stride should return the max stride of
    primary plane for first available pipe in intel device info
    pipe_mask.
    Similarly glk_force_audio_cdclk() should also use the first
    available CRTC instead of pipe 'A' crtc to force the cdclk
    changes.
    
    changes since RFC:
    - Introduced a helper to get first intel_crtc intel_get_first_crtc. [Ville]
    v1:
    - Used intel_get_first_crtc() instead of PIPE_A crtc in
      glk_force_audio_cdclk(). [Ville]
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200224124004.26712-6-anshuman.gupta@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 380ebe5ee26d..3ca6cf7f3986 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1406,6 +1406,12 @@ vlv_pipe_to_channel(enum pipe pipe)
 	}
 }
 
+static inline struct intel_crtc *
+intel_get_first_crtc(struct drm_i915_private *dev_priv)
+{
+	return to_intel_crtc(drm_crtc_from_index(&dev_priv->drm, 0));
+}
+
 static inline struct intel_crtc *
 intel_get_crtc_for_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)
 {

commit aca9310a0c7d8e8ddab3412ad63939cc29d283f4
Author: Anshuman Gupta <anshuman.gupta@intel.com>
Date:   Mon Feb 24 18:09:59 2020 +0530

    drm/i915: Remove (pipe == crtc->index) assumption
    
    we can't have (pipe == crtc->index) assumption in
    driver in order to support 3 non-contiguous
    display pipe system.
    
    FIXME: Remove the WARN_ON(drm_crtc_index(&crtc->base) != crtc->pipe)
    when we will fix all such assumption.
    
    changes since RFC:
    - Added again removed (pipe == crtc->index) WARN_ON.
    - Pass drm_crtc_index instead of intel pipe in order to
      call drm_handle_vblank().
    v2:
    - Used drm_crtc_handle_vblank()/drm_crtc_wait_one_vblank()
      instead of drm_handle_vblank/drm_wait_one_vblank(). [Jani]
    - Introduced intel_handle_vblank() helper to avoid sprinkle
      of intel_crtc across irq_handlers. [Ville]
    v3:
    - Moved intel_handle_vblank() from header to i915_irq.c. [Ville]
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200224124004.26712-3-anshuman.gupta@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 0d8a64305464..380ebe5ee26d 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1598,11 +1598,15 @@ intel_crtc_has_dp_encoder(const struct intel_crtc_state *crtc_state)
 		 (1 << INTEL_OUTPUT_DP_MST) |
 		 (1 << INTEL_OUTPUT_EDP));
 }
+
 static inline void
 intel_wait_for_vblank(struct drm_i915_private *dev_priv, enum pipe pipe)
 {
-	drm_wait_one_vblank(&dev_priv->drm, pipe);
+	struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
+
+	drm_crtc_wait_one_vblank(&crtc->base);
 }
+
 static inline void
 intel_wait_for_vblank_if_active(struct drm_i915_private *dev_priv, enum pipe pipe)
 {

commit ff36e78fdb251b9fa65028554689806961e011eb
Merge: 143d9c3e7b6a 1b245ec5b685
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Tue Feb 25 09:29:58 2020 -0800

    Merge drm/drm-next into drm-intel-next-queued
    
    Some DSI and VBT pending patches from Hans will apply
    cleanly and with less ugly conflicts if they are rebuilt
    on top of other patches that recently landed on drm-next.
    
    Reference: https://patchwork.freedesktop.org/series/70952/
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com

commit 1b245ec5b685ebf8e6e5d1e6b5bcc03b6608e8b0
Merge: 11a48a5a18c6 06f749af622c
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 20 15:21:02 2020 +1000

    Merge tag 'drm-misc-next-2020-02-10' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.7:
    
    UAPI Changes:
      - lima: Add support for heap buffers
    
    Cross-subsystem Changes:
    
    Core Changes:
      - Implement mode_config mode_valid for memory constrained drivers
      - Bus format negociation between bridges
      - Consolidate fake vblank events for drivers without vblank interrupts
      - drm/bufs: dma_alloc related cleanups
      - drm/dp_mst: Various fixes
      - drm/print: New drm_device based print helpers
      - Thomas is a drm-misc maintainer now!
    
    Driver Changes:
      - DPMS cleanups for atomic drivers
      - Removal of owner field in SPI tinydrm drivers
      - Removal of explicit dependency on DT for tinydrm drivers
      - Conversion to YAML schemas for DT bindings
      - tidss: New driver
      - virtio: various reworks and fixes
      - Our usual dozen or so new panels or bridges
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime@cerno.tech>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200210093421.xu4sofldm6wm6xq6@gilmour.lan

commit f28014244d54114ee3b9ea27a3b48a9bee4a4e18
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Feb 14 03:41:24 2020 -0800

    drm/i915: Introduce encoder->compute_config_late()
    
    Add an optional secondary encoder state compute hook. This gets
    called after the normak .compute_config() has been called for
    all the encoders in the state. Thus in the new hook we can rely
    on all derived state populated by .compute_config() to be already
    set up. Should be useful for MST and port sync master/slave
    transcoder selection.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Uma Shankar <uma.shankar@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200214114126.13192-1-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index ceabb4d23892..e6147364c413 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -141,6 +141,9 @@ struct intel_encoder {
 	int (*compute_config)(struct intel_encoder *,
 			      struct intel_crtc_state *,
 			      struct drm_connector_state *);
+	int (*compute_config_late)(struct intel_encoder *,
+				   struct intel_crtc_state *,
+				   struct drm_connector_state *);
 	void (*update_prepare)(struct intel_atomic_state *,
 			       struct intel_encoder *,
 			       struct intel_crtc *);

commit 0f0f9aeee3347fa76e4c5c376867b64240a541b7
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Mon Feb 3 01:06:29 2020 +0200

    drm/i915: Manipulate DBuf slices properly
    
    Start manipulating DBuf slices as a mask,
    but not as a total number, as current approach
    doesn't give us full control on all combinations
    of slices, which we might need(like enabling S2
    only can't enabled by setting enabled_slices=1).
    
    Removed wrong code from intel_get_ddb_size as
    it doesn't match to BSpec. For now still just
    use DBuf slice until proper algorithm is implemented.
    
    Other minor code refactoring to get prepared
    for major DBuf assignment changes landed:
    - As now enabled slices contain a mask
      we still need some value which should
      reflect how much DBuf slices are supported
      by the platform, now device info contains
      num_supported_dbuf_slices.
    - Removed unneeded assertion as we are now
      manipulating slices in a more proper way.
    
    v2: Start using enabled_slices in dev_priv
    
    v3: "enabled_slices" is now "enabled_dbuf_slices_mask",
        as this now sits in dev_priv independently.
    
    v4: - Fixed debug print formatting to hex(Matt Roper)
        - Optimized dbuf slice updates to be used only
          if slice union is different from current conf(Matt Roper)
        - Fixed some functions to be static(Matt Roper)
        - Created a parameterized version for DBUF_CTL to
          simplify DBuf programming cycle(Matt Roper)
        - Removed unrequred field from GEN10_FEATURES(Matt Roper)
    
    v5: - Removed redundant programming dbuf slices helper(Ville Syrjälä)
        - Started to use parameterized loop for hw readout to get slices
          (Ville Syrjälä)
        - Added back assertion checking amount of DBUF slices enabled
          after DC states 5/6 transition, also added new assertion
          as starting from ICL DMC seems to restore the last DBuf
          power state set, rather than power up all dbuf slices
          as assertion was previously expecting(Ville Syrjälä)
    
    v6: - Now using enum for DBuf slices in this patch (Ville Syrjälä)
        - Removed gen11_assert_dbuf_enabled and put gen9_assert_dbuf_enabled
          back, as we really need to have a single unified assert here
          however currently enabling always slice 1 is enforced by BSpec,
          so we will have to OR enabled slices mask with 1 in order
          to be consistent with BSpec, that way we can unify that
          assertion and against the actual state from the driver, but
          not some hardcoded value.(concluded with Ville)
        - Remove parameterized DBUF_CTL version, to extract it to another
          patch.(Ville Syrjälä)
    v7:
        - Removed unneeded hardcoded return value for older gens from
          intel_enabled_dbuf_slices_mask - this now is handled in a
          unified manner since device info anyway returns max dbuf slices
          as 1 for older platforms(Matthew Roper)
        - Now using INTEL_INFO(dev_priv)->num_supported_dbuf_slices instead
          of intel_dbuf_max_slices function as it is trivial(Matthew Roper)
    
    v8: - Fixed icl_dbuf_disable to disable all dbufs still(Ville Syrjälä)
    
    v9: - Renamed _DBUF_CTL_S to DBUF_CTL_S(Ville Syrjälä)
        - Now using power_domain mutex to protect from race condition, which
          can occur because intel_dbuf_slices_update might be running in
          parallel to gen9_dc_off_power_well_enable being called from
          intel_dp_detect for instance, which causes assertion triggered by
          race condition, as gen9_assert_dbuf_enabled might preempt this
          when registers were already updated, while dev_priv was not.
    
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200202230630.8975-6-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 91267063cf27..ceabb4d23892 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -496,7 +496,7 @@ struct intel_atomic_state {
 	bool global_state_changed;
 
 	/* Number of enabled DBuf slices */
-	u8 enabled_dbuf_slices_num;
+	u8 enabled_dbuf_slices_mask;
 
 	struct i915_sw_fence commit_ready;
 

commit 072fcc306be3a63923a3b25cbe7c1fff436f8838
Author: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
Date:   Mon Feb 3 01:06:25 2020 +0200

    drm/i915: Remove skl_ddl_allocation struct
    
    Current consensus that it is redundant as
    we already have skl_ddb_values struct out there,
    also this struct contains only single member
    which makes it unnecessary.
    
    v2: As dirty_pipes soon going to be nuked away
        from skl_ddb_values, evacuating enabled_slices
        to safer in dev_priv.
    
    v3: Changed "enabled_slices" to be "enabled_dbuf_slices_num"
        (Matt Roper)
    
    v4: - Wrapped the line getting number of dbuf slices(Matt Roper)
        - Removed indeed redundant skl_ddb_values declaration(Matt Roper)
    
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200202230630.8975-2-stanislav.lisovskiy@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 276737371bd3..91267063cf27 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -495,8 +495,8 @@ struct intel_atomic_state {
 	 */
 	bool global_state_changed;
 
-	/* Gen9+ only */
-	struct skl_ddb_values wm_results;
+	/* Number of enabled DBuf slices */
+	u8 enabled_dbuf_slices_num;
 
 	struct i915_sw_fence commit_ready;
 

commit 9c4ce97d80257ff48f850a6f13fd9a8f7b37a6e4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Feb 4 09:48:02 2020 +0000

    drm/i915/display: Be explicit in handling the preallocated vma
    
    As only the display codes tries to pin its preallocated framebuffer into
    an exact location in the GGTT, remove the convenience function and make
    the pin management explicit in the display code. Then throughout the
    display management, we track the framebuffer and its plane->vma; with
    less single purpose code and ready for first class i915_vma.
    
    In doing so, this should fix the BUG_ON(vma->pages) on fi-kbl-soraka.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200204094801.877288-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 9f0f68f33a31..276737371bd3 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -592,6 +592,7 @@ struct intel_plane_state {
 
 struct intel_initial_plane_config {
 	struct intel_framebuffer *fb;
+	struct i915_vma *vma;
 	unsigned int tiling;
 	int size;
 	u32 base;

commit 28a30b45f5e9e5a7e51fb93c06ae50a01d89b005
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 21 16:03:53 2020 +0200

    drm/i915: Convert cdclk to global state
    
    Let's convert cdclk_state to be a proper global state. That allows
    us to use the regular atomic old vs. new state accessor, hopefully
    making the code less confusing.
    
    We do have to deal with a few more error cases in case the cdclk
    state duplication fails. But so be it.
    
    v2: Fix new plane min_cdclk vs. old crtc min_cdclk check
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200121140353.25997-1-ville.syrjala@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index efeda019ba79..9f0f68f33a31 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -466,8 +466,6 @@ struct intel_atomic_state {
 	struct __intel_global_objs_state *global_objs;
 	int num_global_objs;
 
-	struct intel_cdclk_state cdclk_state;
-
 	bool dpll_set, modeset;
 
 	/*
@@ -494,7 +492,6 @@ struct intel_atomic_state {
 
 	/*
 	 * active_pipes
-	 * cdclk_state
 	 */
 	bool global_state_changed;
 

commit 0ef1905ecf2e0e9b2ff8903ea3150b4dd2faa6c0
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:24 2020 +0200

    drm/i915: Introduce better global state handling
    
    Our current global state handling is pretty ad-hoc. Let's try to
    make it better by imitating the standard drm core private object
    approach.
    
    The reason why we don't want to directly use the private objects
    is locking; Each private object has its own lock so if we
    introduce any global private objects we get serialized by that
    single lock across all pipes. The global state apporoach instead
    uses a read/write lock type of approach where each individual
    crtc lock counts as a read lock, and grabbing all the crtc locks
    allows one write access.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-15-ville.syrjala@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index aa2e212f5db2..efeda019ba79 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -47,6 +47,7 @@
 #include "intel_de.h"
 
 struct drm_printer;
+struct __intel_global_objs_state;
 
 /*
  * Display related stuff
@@ -462,6 +463,9 @@ struct intel_atomic_state {
 
 	intel_wakeref_t wakeref;
 
+	struct __intel_global_objs_state *global_objs;
+	int num_global_objs;
+
 	struct intel_cdclk_state cdclk_state;
 
 	bool dpll_set, modeset;

commit 1965de63a93aecd788874e921f074b52fbea81a8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:19 2020 +0200

    drm/i915: Extract intel_cdclk_state
    
    Use the same structure to store the cdclk state in both
    intel_atomic_state and dev_priv. First step towards proper
    old vs. new cdclk states.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-10-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 6ef0760bcae9..aa2e212f5db2 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -462,31 +462,7 @@ struct intel_atomic_state {
 
 	intel_wakeref_t wakeref;
 
-	struct {
-		/*
-		 * Logical configuration of cdclk (used for all scaling,
-		 * watermark, etc. calculations and checks). This is
-		 * computed as if all enabled crtcs were active.
-		 */
-		struct intel_cdclk_config logical;
-
-		/*
-		 * Actual configuration of cdclk, can be different from the
-		 * logical configuration only when all crtc's are DPMS off.
-		 */
-		struct intel_cdclk_config actual;
-
-		int force_min_cdclk;
-		bool force_min_cdclk_changed;
-
-		/* minimum acceptable cdclk for each pipe */
-		int min_cdclk[I915_MAX_PIPES];
-		/* minimum acceptable voltage level for each pipe */
-		u8 min_voltage_level[I915_MAX_PIPES];
-
-		/* pipe to which cd2x update is synchronized */
-		enum pipe pipe;
-	} cdclk;
+	struct intel_cdclk_state cdclk_state;
 
 	bool dpll_set, modeset;
 
@@ -514,9 +490,7 @@ struct intel_atomic_state {
 
 	/*
 	 * active_pipes
-	 * min_cdclk[]
-	 * min_voltage_level[]
-	 * cdclk.*
+	 * cdclk_state
 	 */
 	bool global_state_changed;
 

commit 0bb94e03834eaa9d5925b259ea140e53fdf68cfb
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:17 2020 +0200

    drm/i915: s/cdclk_state/cdclk_config/
    
    I want to have a higher level cdclk state object so let's rename
    the current lower level thing to cdclk_config (because I lack
    imagination).
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-8-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 9d557c9fb3b2..6ef0760bcae9 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -464,17 +464,17 @@ struct intel_atomic_state {
 
 	struct {
 		/*
-		 * Logical state of cdclk (used for all scaling, watermark,
-		 * etc. calculations and checks). This is computed as if all
-		 * enabled crtcs were active.
+		 * Logical configuration of cdclk (used for all scaling,
+		 * watermark, etc. calculations and checks). This is
+		 * computed as if all enabled crtcs were active.
 		 */
-		struct intel_cdclk_state logical;
+		struct intel_cdclk_config logical;
 
 		/*
-		 * Actual state of cdclk, can be different from the logical
-		 * state only when all crtc's are DPMS off.
+		 * Actual configuration of cdclk, can be different from the
+		 * logical configuration only when all crtc's are DPMS off.
 		 */
-		struct intel_cdclk_state actual;
+		struct intel_cdclk_config actual;
 
 		int force_min_cdclk;
 		bool force_min_cdclk_changed;

commit b4db3a8c689ba5f5ced764ab1377ad6411003b0b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:15 2020 +0200

    drm/i915: Collect more cdclk state under the same roof
    
    Move the min_cdclk[] and min_voltage_level[] arrays under the
    rest of the cdclk state. And while at it provide a simple
    helper (intel_cdclk_clear_state()) to clear the state during
    the ww_mutex backoff dance.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-6-ville.syrjala@linux.intel.com
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a4ff025daa5a..9d557c9fb3b2 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -478,6 +478,12 @@ struct intel_atomic_state {
 
 		int force_min_cdclk;
 		bool force_min_cdclk_changed;
+
+		/* minimum acceptable cdclk for each pipe */
+		int min_cdclk[I915_MAX_PIPES];
+		/* minimum acceptable voltage level for each pipe */
+		u8 min_voltage_level[I915_MAX_PIPES];
+
 		/* pipe to which cd2x update is synchronized */
 		enum pipe pipe;
 	} cdclk;
@@ -495,10 +501,6 @@ struct intel_atomic_state {
 	u8 active_pipe_changes;
 
 	u8 active_pipes;
-	/* minimum acceptable cdclk for each pipe */
-	int min_cdclk[I915_MAX_PIPES];
-	/* minimum acceptable voltage level for each pipe */
-	u8 min_voltage_level[I915_MAX_PIPES];
 
 	struct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];
 

commit 6dcde04706d88284f6326a6b1bafe9cb9d50490d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:12 2020 +0200

    drm/i915: Move linetime wms into the crtc state
    
    The linetime watermarks really have very little in common with the
    plane watermarks. It looks to be cleaner to simply track them in
    the crtc_state and program them from the normal modeset/fastset
    paths.
    
    The only dark cloud comes from the fact that the register is
    still supposedly single buffered. So in theory it might still
    need some form of two stage programming. Note that even though
    HSW/BDWhave two stage programming we never computed any special
    intermediate values for the linetime watermarks, and on SKL+
    we don't even have the two stage stuff plugged in since everything
    else is double buffered. So let's assume it's all fine and
    continue doing what we've been doing.
    
    Actually on HSW/BDW the value should not even change without
    a full modeset since it doesn't account for pfit downscaling.
    Thus only fastboot might be affected. But on SKL+ the pfit
    scaling factor is take into consideration so the value may
    change during any fastset.
    
    As a bonus we'll plug this thing into the state
    checker/dump now.
    
    v2: Rebase due to bigjoiner prep
    v2: Only compute ips linetime for IPS capable pipes.
        Bspec says the register values is ignored for other
        pipes, but in fact it can't even be written so the
        state checker becomes unhappy if we don't compute
        it as zero.
    
    Cc: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-3-ville.syrjala@linux.intel.com
    Reviewed-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index baca171b74db..a4ff025daa5a 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -663,8 +663,6 @@ struct intel_crtc_scaler_state {
 
 struct intel_pipe_wm {
 	struct intel_wm_level wm[5];
-	u16 linetime;
-	u16 ips_linetime;
 	bool fbc_wm_enabled;
 	bool pipe_enabled;
 	bool sprites_enabled;
@@ -680,7 +678,6 @@ struct skl_plane_wm {
 
 struct skl_pipe_wm {
 	struct skl_plane_wm planes[I915_MAX_PLANES];
-	u32 linetime;
 };
 
 enum vlv_wm_level {
@@ -1051,6 +1048,10 @@ struct intel_crtc_state {
 		struct drm_dsc_config config;
 	} dsc;
 
+	/* HSW+ linetime watermarks */
+	u16 linetime;
+	u16 ips_linetime;
+
 	/* Forward Error correction State */
 	bool fec_enable;
 

commit 0560b0c6b36c160fa15e692ba8cda7730d16ffdb
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jan 20 19:47:11 2020 +0200

    drm/i915: Polish WM_LINETIME register stuff
    
    Let's store the normal and IPS linetime watermarks individually,
    and while at it we'll pimp the register definitions as well.
    
    v2: Deal with gvt
    
    Reviewed-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-2-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a366f9974fce..baca171b74db 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -663,7 +663,8 @@ struct intel_crtc_scaler_state {
 
 struct intel_pipe_wm {
 	struct intel_wm_level wm[5];
-	u32 linetime;
+	u16 linetime;
+	u16 ips_linetime;
 	bool fbc_wm_enabled;
 	bool pipe_enabled;
 	bool sprites_enabled;

commit 9c757aeaaaa18d36eba5a464109690e8f7990a40
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jan 21 13:39:15 2020 +0200

    drm/i915: add display engine uncore helpers
    
    Add convenience helpers for the most common uncore operations with
    struct drm_i915_private * as context rather than struct intel_uncore *.
    
    The goal is to replace all instances of I915_READ(),
    I915_POSTING_READ(), I915_WRITE(), I915_READ_FW(), and I915_WRITE_FW()
    in display/ with these, to finally be able to get rid of the implicit
    dev_priv local parameter use.
    
    The idea is that any non-u32 reads or writes are special enough that
    they can use the intel_uncore_* functions directly.
    
    v2:
    - rename the file intel_de.h
    - move intel_de_wait_for_* there too
    - also add de fw helpers
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Lucas De Marchi <lucas.demarchi@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200121113915.9813-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 85d98da56c3f..a366f9974fce 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -44,6 +44,7 @@
 #include <media/cec-notifier.h>
 
 #include "i915_drv.h"
+#include "intel_de.h"
 
 struct drm_printer;
 

commit 5d1db3f61aa919dfbe7c80ab51b5ec981e3a995c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 4 20:05:48 2019 +0200

    drm/i915: Rename conn_to_dig_port() to intel_attached_dig_port()
    
    Use the standard naming convention and rename conn_to_dig_port()
    to intel_attached_dig_port().
    
    @@
    @@
    - conn_to_dig_port
    + intel_attached_dig_port
            (...)
    {
    ...
    }
    
    @@
    expression C;
    @@
    - conn_to_dig_port(C)
    + intel_attached_dig_port(C)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204180549.1267-9-ville.syrjala@linux.intel.com
    Reviewed-by: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 9e19de0778f5..85d98da56c3f 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1472,7 +1472,7 @@ enc_to_dig_port(struct intel_encoder *encoder)
 }
 
 static inline struct intel_digital_port *
-conn_to_dig_port(struct intel_connector *connector)
+intel_attached_dig_port(struct intel_connector *connector)
 {
 	return enc_to_dig_port(intel_attached_encoder(connector));
 }

commit ecdfd84f3228cc0c5b8912fcbc09c94d8144c20d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 4 20:05:46 2019 +0200

    drm/i915: Relocate intel_attached_dp()
    
    We have uses for intel_attached_dp() outside of intel_dp.c. Move
    it to a header.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204180549.1267-7-ville.syrjala@linux.intel.com
    Reviewed-by: Mika Kahola <mika.kahola@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 778bd30743e5..9e19de0778f5 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1489,6 +1489,11 @@ static inline struct intel_dp *enc_to_intel_dp(struct intel_encoder *encoder)
 	return &enc_to_dig_port(encoder)->dp;
 }
 
+static inline struct intel_dp *intel_attached_dp(struct intel_connector *connector)
+{
+	return enc_to_intel_dp(intel_attached_encoder(connector));
+}
+
 static inline bool intel_encoder_is_dp(struct intel_encoder *encoder)
 {
 	switch (encoder->type) {

commit fde7266fb2f6fff2a7fe861474bf198ef0f2449f
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Jan 16 16:16:08 2020 -0500

    drm/i915: Fix eDP DPCD aux max backlight calculations
    
    Max backlight value for the panel was being calculated using byte
    count i.e. 0xffff if 2 bytes are supported for backlight brightness
    and 0xff if 1 byte is supported. However, EDP_PWMGEN_BIT_COUNT
    determines the number of active control bits used for the brightness
    setting. Thus, even if the panel uses 2 byte setting, it might not use
    all the control bits. Thus, max backlight should be set based on the
    value of EDP_PWMGEN_BIT_COUNT instead of assuming 65535 or 255.
    
    Additionally, EDP_PWMGEN_BIT_COUNT was being updated based on the VBT
    frequency which results in a different max backlight value. Thus,
    setting of EDP_PWMGEN_BIT_COUNT is moved to setup phase instead of
    enable so that max backlight can be calculated correctly. Only the
    frequency divider is set during the enable phase using the value of
    EDP_PWMGEN_BIT_COUNT.
    
    This is based off the original patch series from Furquan Shaikh
    <furquan@google.com>:
    
    https://patchwork.freedesktop.org/patch/317255/?series=62326&rev=3
    
    Changes since original patch:
    * Remove unused intel_dp variable in intel_dp_aux_setup_backlight()
    * Fix checkpatch issues
    * Make sure that we rewrite the pwmgen bit count whenever we bring the
      panel out of D3 mode
    
    v2 by Jani:
    * rebase
    * fix readb return value check
    
    Cc: Furquan Shaikh <furquan@google.com>
    Tested-by: AceLan Kao <acelan.kao@canonical.com>
    Tested-by: Perry Yuan <pyuan@redhat.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200116211623.53799-2-lyude@redhat.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 888ea8a170d1..778bd30743e5 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -214,6 +214,9 @@ struct intel_panel {
 		u8 controller;		/* bxt+ only */
 		struct pwm_device *pwm;
 
+		/* DPCD backlight */
+		u8 pwmgen_bit_count;
+
 		struct backlight_device *device;
 
 		/* Connector and platform specific backlight functions */

commit b7d02c3a124d9be9cdd4982505d1ac00de4c70f2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 4 20:05:43 2019 +0200

    drm/i915: Pass intel_encoder to enc_to_*()
    
    Lots of enc_to_foo(&encoder->base) around. Simplify by passing
    in the intel_encoder instead.
    
    @find@
    identifier F =~ "^enc_to_.*";
    identifier E;
    @@
    F(struct drm_encoder *E)
    {
    ...
    }
    
    @@
    identifier find.F;
    identifier find.E;
    @@
    F(
    - struct drm_encoder *E
    + struct intel_encoder *encoder
      )
    {
    <...
    - E
    + &encoder->base
    ...>
    }
    
    @@
    identifier find.F;
    expression E;
    @@
    - F(E)
    + F(to_intel_encoder(E))
    
    @@
    expression E;
    @@
    - to_intel_encoder(&E->base)
    + E
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204180549.1267-4-ville.syrjala@linux.intel.com
    Reviewed-by: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 19b394cc81b4..888ea8a170d1 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1457,12 +1457,12 @@ static inline bool intel_encoder_is_dig_port(struct intel_encoder *encoder)
 }
 
 static inline struct intel_digital_port *
-enc_to_dig_port(struct drm_encoder *encoder)
+enc_to_dig_port(struct intel_encoder *encoder)
 {
-	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
+	struct intel_encoder *intel_encoder = encoder;
 
 	if (intel_encoder_is_dig_port(intel_encoder))
-		return container_of(encoder, struct intel_digital_port,
+		return container_of(&encoder->base, struct intel_digital_port,
 				    base.base);
 	else
 		return NULL;
@@ -1471,16 +1471,17 @@ enc_to_dig_port(struct drm_encoder *encoder)
 static inline struct intel_digital_port *
 conn_to_dig_port(struct intel_connector *connector)
 {
-	return enc_to_dig_port(&intel_attached_encoder(connector)->base);
+	return enc_to_dig_port(intel_attached_encoder(connector));
 }
 
 static inline struct intel_dp_mst_encoder *
-enc_to_mst(struct drm_encoder *encoder)
+enc_to_mst(struct intel_encoder *encoder)
 {
-	return container_of(encoder, struct intel_dp_mst_encoder, base.base);
+	return container_of(&encoder->base, struct intel_dp_mst_encoder,
+			    base.base);
 }
 
-static inline struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder)
+static inline struct intel_dp *enc_to_intel_dp(struct intel_encoder *encoder)
 {
 	return &enc_to_dig_port(encoder)->dp;
 }
@@ -1493,14 +1494,14 @@ static inline bool intel_encoder_is_dp(struct intel_encoder *encoder)
 		return true;
 	case INTEL_OUTPUT_DDI:
 		/* Skip pure HDMI/DVI DDI encoders */
-		return i915_mmio_reg_valid(enc_to_intel_dp(&encoder->base)->output_reg);
+		return i915_mmio_reg_valid(enc_to_intel_dp(encoder)->output_reg);
 	default:
 		return false;
 	}
 }
 
 static inline struct intel_lspcon *
-enc_to_intel_lspcon(struct drm_encoder *encoder)
+enc_to_intel_lspcon(struct intel_encoder *encoder)
 {
 	return &enc_to_dig_port(encoder)->lspcon;
 }

commit 43a6d19cace6e179fd129806874e96e81291485b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 4 20:05:42 2019 +0200

    drm/i915: Pass intel_connector to intel_attached_*()
    
    Life is usually easier when we pass around intel_ types instead
    of drm_ types. In this case it might not be, but I think being
    consistent is a good thing anyway. Also some of this might get
    cleaned up a bit more later as we keep propagating the intel_
    types further.
    
    @find@
    identifier F =~ "^intel_attached_.*";
    identifier C;
    @@
    F(struct drm_connector *C)
    {
    ...
    }
    
    @@
    identifier find.F;
    identifier find.C;
    @@
    F(
    - struct drm_connector *C
    + struct intel_connector *connector
      )
    {
    <...
    - C
    + &connector->base
    ...>
    }
    
    @@
    identifier find.F;
    expression C;
    @@
    - F(C)
    + F(to_intel_connector(C))
    
    @@
    expression C;
    @@
    - to_intel_connector(&C->base)
    + C
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204180549.1267-3-ville.syrjala@linux.intel.com
    Reviewed-by: Mika Kahola <mika.kahola@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a1a73209d824..19b394cc81b4 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1438,9 +1438,9 @@ struct intel_load_detect_pipe {
 };
 
 static inline struct intel_encoder *
-intel_attached_encoder(struct drm_connector *connector)
+intel_attached_encoder(struct intel_connector *connector)
 {
-	return to_intel_connector(connector)->encoder;
+	return connector->encoder;
 }
 
 static inline bool intel_encoder_is_dig_port(struct intel_encoder *encoder)
@@ -1471,7 +1471,7 @@ enc_to_dig_port(struct drm_encoder *encoder)
 static inline struct intel_digital_port *
 conn_to_dig_port(struct intel_connector *connector)
 {
-	return enc_to_dig_port(&intel_attached_encoder(&connector->base)->base);
+	return enc_to_dig_port(&intel_attached_encoder(connector)->base);
 }
 
 static inline struct intel_dp_mst_encoder *

commit e5124751892a5ca66d07aead1e74bc6c55638d74
Author: Oleg Vasilev <oleg.vasilev@intel.com>
Date:   Thu Aug 29 14:48:48 2019 +0300

    drm: move DP_MAX_DOWNSTREAM_PORTS from i915 to drm core
    
    DP_MAX_DOWNSTREAM_PORTS=0x10 is a vendor-independent constant.
    
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Oleg Vasilev <oleg.vasilev@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190829114854.1539-1-oleg.vasilev@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 83ea04149b77..3fd822d536c9 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1178,8 +1178,6 @@ struct intel_hdmi {
 };
 
 struct intel_dp_mst_encoder;
-#define DP_MAX_DOWNSTREAM_PORTS		0x10
-
 /*
  * enum link_m_n_set:
  *	When platform provides two set of M_N registers for dp, we can

commit 2dfbf9d2873a0f76a6c6ad727711a4391d7936b7
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Tue Dec 17 15:23:29 2019 +0200

    drm/i915/tgl: Gen-12 display can decompress surfaces compressed by the media engine
    
    Detect the modifier corresponding to media compression to enable
    display decompression for YUV and xRGB packed formats. A new modifier is
    added so that the driver can distinguish between media and render
    compressed buffers. Unlike render decompression, plane 6 and  plane 7 do not
    support media decompression.
    
    v2: Fix checkpatch warnings on code style (Lucas)
    
    From DK:
    Separate modifier array for planes that cannot decompress media (Ville)
    
    v3: Support planar formats
    v4: Switch plane order
    v5:
    - Use format block descriptors to get CCS subsampling calculation right
      everywhere.
    - Extend the plane state normal view array to accommodate 4 color planes.
    - Use helpers to convert between main and CCS planes.
    v6: Add missing packed YUV formats to the MC format list. (Yang)
    v7: Align UV planes to tile-row size.
    
    Cc: Nanley G Chery <nanley.g.chery@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Yang A Shi <yang.a.shi@intel.com>
    Cc: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191231233756.18753-8-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 630a94892b7b..a1a73209d824 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -90,8 +90,8 @@ struct intel_framebuffer {
 	/* for each plane in the normal GTT view */
 	struct {
 		unsigned int x, y;
-	} normal[2];
-	/* for each plane in the rotated GTT view */
+	} normal[4];
+	/* for each plane in the rotated GTT view for no-CCS formats */
 	struct {
 		unsigned int x, y;
 		unsigned int pitch; /* pixels */
@@ -555,7 +555,7 @@ struct intel_plane_state {
 		 */
 		u32 stride;
 		int x, y;
-	} color_plane[2];
+	} color_plane[4];
 
 	/* plane control register */
 	u32 ctl;

commit 6671c367a9beae742855317d278cf9922bf556fe
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Sun Dec 22 17:06:49 2019 -0800

    drm/i915/tgl: Select master transcoder for MST stream
    
    On TGL the blending of all the streams have moved from DDI to
    transcoder, so now every transcoder working over the same MST port must
    send its stream to a master transcoder and master will send to DDI
    respecting the time slots.
    
    So here adding all the CRTCs that shares the same MST stream if
    needed and computing their state again, it will pick the lowest
    pipe/transcoder among the ones in the same stream to be master.
    
    Most of the time skl_commit_modeset_enables() enables pipes in a
    crescent order but due DDB overlapping it might not happen, this
    scenarios will be handled in the next patch.
    
    v2:
    - Using recently added intel_crtc_state_reset() to set
    mst_master_transcoder to invalid transcoder for all non gen12 & MST
    code paths
    - Setting lowest pipe/transcoder as master, previously it was the
    first one but setting a predictable one will help in future MST e
    port sync integration
    - Moving to intel type as much as we can
    
    v3:
    - Now intel_dp_mst_master_trans_compute() returns the MST master transcoder
    - Replaced stdbool.h by linux/types.h
    - Skip the connector being checked in
    intel_dp_mst_atomic_master_trans_check()
    - Using pipe instead of transcoder to compute MST master
    
    v4:
    - renamed connector_state to conn_state
    
    v5:
    - Improved the parameters of intel_dp_mst_master_trans_compute() to
    simply code
    - Added call drm_atomic_add_affected_planes() in
    intel_dp_mst_atomic_master_trans_check() as helper could not do it
    for us
    - Removed "if (ret)" left over from v3 changes
    
    v6:
    - handled ret == I915_MAX_PIPES case in compute
    
    BSpec: 50493
    BSpec: 49190
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191223010654.67037-2-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 83ea04149b77..630a94892b7b 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1054,6 +1054,9 @@ struct intel_crtc_state {
 
 	/* Bitmask to indicate slaves attached */
 	u8 sync_mode_slaves_mask;
+
+	/* Only valid on TGL+ */
+	enum transcoder mst_master_transcoder;
 };
 
 struct intel_crtc {

commit 0ccc42a2fd5107a7f58e62c8b35b61de9a70ce82
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Oct 30 21:08:15 2019 +0200

    drm/i915: Preload LUTs if the hw isn't currently using them
    
    The LUTs are single buffered so in order to program them without
    tearing we'd have to do it during vblank (actually to be 100%
    effective it has to happen between start of vblank and frame start).
    We have no proper mechanism for that at the moment so we just
    defer loading them after the vblank waits have happened. That
    is not quite sufficient (especially when committing multiple pipes
    whose vblanks don't line up) so the LUT load will often leak into
    the following frame causing tearing.
    
    However in case the hardware wasn't previously using the LUT we
    can preload it before setting the enable bit (which is double
    buffered so won't tear). Let's determine if we can do such
    preloading and make it happen. Slight variation between the
    hardware requires some platforms specifics in the checks.
    
    Hans is seeing ugly colored flash on VLV/CHV macchines (GPD win
    and Asus T100HA) when the gamma LUT gets loaded for the first
    time as the BIOS has left some junk in the LUT memory.
    
    v2: Deal with uapi vs. hw crtc state split
        s/GCM/CGM/ typo fix
    
    Cc: Hans de Goede <hdegoede@redhat.com>
    Fixes: 051a6d8d3ca0 ("drm/i915: Move LUT programming to happen after vblank waits")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191030190815.7359-1-ville.syrjala@linux.intel.com
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index fadd9853f966..83ea04149b77 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -821,6 +821,7 @@ struct intel_crtc_state {
 	bool disable_cxsr;
 	bool update_wm_pre, update_wm_post; /* watermarks are updated */
 	bool fifo_changed; /* FIFO split is changed */
+	bool preload_luts;
 
 	/* Pipe source size (ie. panel fitter input size)
 	 * All planes will be positioned inside this space,

commit 142110c4ef6d2dfaf109ad60a3a2bcbc9bec0cd1
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Tue Oct 29 18:24:45 2019 -0700

    drm/i915: add wrappers to get intel connector state
    
    Wrap drm_atomic_get_old_connector_state so we can get the
    intel_digital_connector_state and make it easier to migrate to intel
    types.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191030012448.14937-3-lucas.demarchi@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 764a715c5d1c..fadd9853f966 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1570,6 +1570,24 @@ intel_atomic_get_new_crtc_state(struct intel_atomic_state *state,
 								 &crtc->base));
 }
 
+static inline struct intel_digital_connector_state *
+intel_atomic_get_new_connector_state(struct intel_atomic_state *state,
+				     struct intel_connector *connector)
+{
+	return to_intel_digital_connector_state(
+			drm_atomic_get_new_connector_state(&state->base,
+			&connector->base));
+}
+
+static inline struct intel_digital_connector_state *
+intel_atomic_get_old_connector_state(struct intel_atomic_state *state,
+				     struct intel_connector *connector)
+{
+	return to_intel_digital_connector_state(
+			drm_atomic_get_old_connector_state(&state->base,
+			&connector->base));
+}
+
 /* intel_display.c */
 static inline bool
 intel_crtc_has_type(const struct intel_crtc_state *crtc_state,

commit 1f594b209fe1c5fedd79e44939459f7e5ea525bb
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 31 12:26:10 2019 +0100

    drm/i915: Remove special case slave handling during hw programming, v3.
    
    Now that we split plane_state which I didn't want to do yet, we can
    program the slave plane without requiring the master plane.
    
    This is useful for programming bigjoiner slave planes as well. We
    will no longer need the master's plane_state.
    
    Changes since v1:
    - set src/dst rectangles after copy_uapi_to_hw_state.
    Changes since v2:
    - Use the correct color_plane for pre-gen11 by using planar_linked_plane != NULL.
    - Use drm_format_info_is_yuv_semiplanar in skl_plane_check() to fix gen11+.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191031112610.27608-12-maarten.lankhorst@linux.intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index cf1d71624783..764a715c5d1c 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -563,6 +563,9 @@ struct intel_plane_state {
 	/* plane color control register */
 	u32 color_ctl;
 
+	/* chroma upsampler control register */
+	u32 cus_ctl;
+
 	/*
 	 * scaler_id
 	 *    = -1 : not using a scaler
@@ -1122,9 +1125,6 @@ struct intel_plane {
 	void (*update_plane)(struct intel_plane *plane,
 			     const struct intel_crtc_state *crtc_state,
 			     const struct intel_plane_state *plane_state);
-	void (*update_slave)(struct intel_plane *plane,
-			     const struct intel_crtc_state *crtc_state,
-			     const struct intel_plane_state *plane_state);
 	void (*disable_plane)(struct intel_plane *plane,
 			      const struct intel_crtc_state *crtc_state);
 	bool (*get_hw_state)(struct intel_plane *plane, enum pipe *pipe);

commit 380015bfd9ceea7eb790ecd222dedb9f15613e59
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 31 12:26:09 2019 +0100

    drm/i915: Complete plane hw and uapi split, v2.
    
    Splitting plane state is easier than splitting crtc_state,
    before plane check we copy the drm properties to hw so we can
    do the same in bigjoiner later on.
    
    We copy the state after we did all the modeset handling, but fortunately
    i915 seems to be split correctly and nothing during modeset looks
    at plane_state.
    
    Changes since v1:
    - Do not clear hw state on duplication.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191031112610.27608-11-maarten.lankhorst@linux.intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 7f338c130ed7..cf1d71624783 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -523,11 +523,24 @@ struct intel_atomic_state {
 };
 
 struct intel_plane_state {
-	union {
-		struct drm_plane_state base;
-		struct drm_plane_state uapi;
-		struct drm_plane_state hw;
-	};
+	struct drm_plane_state uapi;
+
+	/*
+	 * actual hardware state, the state we program to the hardware.
+	 * The following members are used to verify the hardware state:
+	 * During initial hw readout, they need to be copied from uapi.
+	 */
+	struct {
+		struct drm_crtc *crtc;
+		struct drm_framebuffer *fb;
+
+		u16 alpha;
+		uint16_t pixel_blend_mode;
+		unsigned int rotation;
+		enum drm_color_encoding color_encoding;
+		enum drm_color_range color_range;
+	} hw;
+
 	struct i915_ggtt_view view;
 	struct i915_vma *vma;
 	unsigned long flags;

commit 5b6edb88008fe7988186fd4e4e4211396cde25bc
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 31 12:26:05 2019 +0100

    drm/i915: Add aliases for uapi and hw to plane_state
    
    Prepare to split up hw and uapi machinally, by adding a uapi and
    hw alias. We will remove the base in a bit. This is a split from the
    original uapi/hw patch, which did it all in one go.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191031112610.27608-7-maarten.lankhorst@linux.intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index dfa7bfc9c9a2..7f338c130ed7 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -523,7 +523,11 @@ struct intel_atomic_state {
 };
 
 struct intel_plane_state {
-	struct drm_plane_state base;
+	union {
+		struct drm_plane_state base;
+		struct drm_plane_state uapi;
+		struct drm_plane_state hw;
+	};
 	struct i915_ggtt_view view;
 	struct i915_vma *vma;
 	unsigned long flags;
@@ -1143,7 +1147,7 @@ struct cxsr_latency {
 #define to_intel_encoder(x) container_of(x, struct intel_encoder, base)
 #define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)
 #define to_intel_plane(x) container_of(x, struct intel_plane, base)
-#define to_intel_plane_state(x) container_of(x, struct intel_plane_state, base)
+#define to_intel_plane_state(x) container_of(x, struct intel_plane_state, uapi)
 #define intel_fb_obj(x) ((x) ? to_intel_bo((x)->obj[0]) : NULL)
 
 struct intel_hdmi {

commit 58d124ea2739e1440ddd743d46c470fe724aca9a
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 31 12:26:04 2019 +0100

    drm/i915: Complete crtc hw/uapi split, v6.
    
    Now that we separated everything into uapi and hw, it's
    time to make the split definitive. Remove the union and
    make a copy of the hw state on modeset and fastset.
    
    Color blobs are copied in crtc atomic_check(), right
    before color management is checked.
    
    Changes since v1:
    - Copy all blobs immediately after drm_atomic_helper_check_modeset().
    - Clear crtc_state->hw on disable, instead of using clear_intel_crtc_state().
    Changes since v2:
    - Use intel_crtc_free_hw_state + clear in intel_crtc_disable_noatomic().
    - Make a intel_crtc_prepare_state() function that clears the crtc_state
      and copies hw members.
    - Remove setting uapi.adjusted_mode, we now have a direct call to
      drm_calc_timestamping_constants().
    Changes since v3:
    - Rename prefix copy_hw_to_uapi_state() with intel_crtc.
    - Copy color blobs to uapi as well.
    - Add a intel_crtc_copy_uapi_to_hw_state_nomodeset() function for clarity.
    Changes since v4:
    - Copy hw.adjusted_mode back to uapi.adjusted_mode, to shut up
      the call to drm_calc_timestamping_constants() in
      drm_atomic_helper_update_legacy_modeset_state().
    - Use drm_property_replace_blob (Ville).
    Changes since v5:
    - Use hw->mode in intel_modeset_readout_hw_state(). (Ville)
    - Copy to uapi.mode using drm_atomic_set_mode_for_crtc(). (Ville)
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191031112610.27608-6-maarten.lankhorst@linux.intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 285b17c9d8d0..dfa7bfc9c9a2 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -757,8 +757,6 @@ enum intel_output_format {
 };
 
 struct intel_crtc_state {
-	union {
-	struct drm_crtc_state base;
 	/*
 	 * uapi (drm) state. This is the software state shown to userspace.
 	 * In particular, the following members are used for bookkeeping:
@@ -781,8 +779,11 @@ struct intel_crtc_state {
 	 *
 	 * During initial hw readout, they need to be copied to uapi.
 	 */
-	struct drm_crtc_state hw;
-	};
+	struct {
+		bool active, enable;
+		struct drm_property_blob *degamma_lut, *gamma_lut, *ctm;
+		struct drm_display_mode mode, adjusted_mode;
+	} hw;
 
 	/**
 	 * quirks - bitfield with hw state readout quirks

commit 2b808b3a27d1182a26182d622bb1b292fd4ed1f0
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 31 12:26:00 2019 +0100

    drm/i915: Add aliases for uapi and hw to crtc_state
    
    Prepare to split up hw and uapi machinally, by adding a uapi and
    hw alias. We will remove the base in a bit. This is a split from the
    original uapi/hw patch, which did it all in one go.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191031112610.27608-2-maarten.lankhorst@linux.intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 4341bd66a418..285b17c9d8d0 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -757,7 +757,32 @@ enum intel_output_format {
 };
 
 struct intel_crtc_state {
+	union {
 	struct drm_crtc_state base;
+	/*
+	 * uapi (drm) state. This is the software state shown to userspace.
+	 * In particular, the following members are used for bookkeeping:
+	 * - crtc
+	 * - state
+	 * - *_changed
+	 * - event
+	 * - commit
+	 * - mode_blob
+	 */
+	struct drm_crtc_state uapi;
+
+	/*
+	 * actual hardware state, the state we program to the hardware.
+	 * The following members are used to verify the hardware state:
+	 * - enable
+	 * - active
+	 * - mode / adjusted_mode
+	 * - color property blobs.
+	 *
+	 * During initial hw readout, they need to be copied to uapi.
+	 */
+	struct drm_crtc_state hw;
+	};
 
 	/**
 	 * quirks - bitfield with hw state readout quirks
@@ -1112,7 +1137,7 @@ struct cxsr_latency {
 
 #define to_intel_atomic_state(x) container_of(x, struct intel_atomic_state, base)
 #define to_intel_crtc(x) container_of(x, struct intel_crtc, base)
-#define to_intel_crtc_state(x) container_of(x, struct intel_crtc_state, base)
+#define to_intel_crtc_state(x) container_of(x, struct intel_crtc_state, uapi)
 #define to_intel_connector(x) container_of(x, struct intel_connector, base)
 #define to_intel_encoder(x) container_of(x, struct intel_encoder, base)
 #define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)

commit 981329ce3c3e13af6b9a11ec4948df45f5f4847e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Oct 2 19:25:02 2019 +0300

    drm/i915: s/crtc_mask/pipe_mask/
    
    Rename the encoder->crtc_mask to encoder->pipe_mask to better
    reflect what it actually contains.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191002162505.30716-3-ville.syrjala@linux.intel.com
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 40184e823c84..4341bd66a418 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -128,7 +128,8 @@ struct intel_encoder {
 
 	enum intel_output_type type;
 	enum port port;
-	unsigned int cloneable;
+	u16 cloneable;
+	u8 pipe_mask;
 	enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
 					    struct intel_connector *connector,
 					    bool irq_received);
@@ -187,7 +188,6 @@ struct intel_encoder {
 	 * device interrupts are disabled.
 	 */
 	void (*suspend)(struct intel_encoder *);
-	int crtc_mask;
 	enum hpd_pin hpd_pin;
 	enum intel_display_power_domain power_domain;
 	/* for communication with audio component; protected by av_mutex */

commit bb6ae9e653dc1019312466cde7be3db69681d3b6
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Oct 15 22:30:26 2019 +0300

    drm/i915: Allow planes to declare their minimum acceptable cdclk
    
    Various pixel formats and plane scaling impose additional constraints
    on the cdclk frequency. Provide a new plane->min_cdclk() hook that
    will be used to compute the minimum acceptable cdclk frequency for
    each plane.
    
    Annoyingly on some platforms the numer of active planes affects
    this calculation so we must also toss in more planes into the
    state when the number of active planes changes.
    
    The sequence of state computation must also be changed:
    1. check_plane() (updates plane's visibility etc.)
    2. figure out if more planes now require update min_cdclk
       computaion
    3. calculate the new min cdclk for each plane in the state
    4. if the minimum of any plane now exceeds the current
       logical cdclk we recompute the cdclk
    4. during cdclk computation take the planes' min_cdclk into
       accoutn
    5. follow the normal cdclk programming to change the
       cdclk frequency. This may now require a modeset (except
       on bxt/glk in some cases), which either succeeds or
       fails depending on whether userspace has given
       us permission to perform a modeset or not.
    
    v2: Fix plane id check in intel_crtc_add_planes_to_state()
        Only print the debug message when cdclk needs bumping
        Use dev_priv->cdclk... as the old state explicitly
    
    Reviewed-by: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191015193035.25982-5-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index d18208e590b0..40184e823c84 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -940,6 +940,8 @@ struct intel_crtc_state {
 
 	struct intel_crtc_wm_state wm;
 
+	int min_cdclk[I915_MAX_PLANES];
+
 	u32 data_rate[I915_MAX_PLANES];
 
 	/* Gamma mode programmed on the pipe */
@@ -1085,6 +1087,8 @@ struct intel_plane {
 	bool (*get_hw_state)(struct intel_plane *plane, enum pipe *pipe);
 	int (*check_plane)(struct intel_crtc_state *crtc_state,
 			   struct intel_plane_state *plane_state);
+	int (*min_cdclk)(const struct intel_crtc_state *crtc_state,
+			 const struct intel_plane_state *plane_state);
 };
 
 struct intel_watermark_params {

commit 1d5a95b5c943161bcefd487206ca848b81cac4df
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Oct 15 22:30:24 2019 +0300

    drm/i915: Rework global state locking
    
    So far we've sort of protected the global state under dev_priv with
    the connection_mutex. I wan to change that so that we can change the
    cdclk even for pure plane updates. To that end let's formalize the
    protection of the global state to follow what I started with the cdclk
    code already (though not entirely properly) such that any crtc mutex
    will suffice as a read lock, and all crtcs mutexes act as the write
    lock.
    
    We'll also pimp intel_atomic_state_clear() to clear the entire global
    state, so that we don't accidentally leak stale information between
    the locking retries.
    
    As a slight optimization we'll only lock the crtc mutexes to protect
    the global state, however if and when we actually have to poke the
    hw (eg. if the actual cdclk changes) we must serialize commits
    across all crtcs so that a parallel nonblocking commit can't get
    ahead of the cdclk reprogamming. We do that by adding all crtcs to
    the state.
    
    TODO: the old global state examined during commit may still
    be a problem since it always looks at the _latest_ swapped state
    in dev_priv. Need to add proper old/new state for that too I think.
    
    v2: Remeber to serialize the commits if necessary
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191015193035.25982-3-ville.syrjala@linux.intel.com
    Reviewed-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index bac40482a2aa..d18208e590b0 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -506,6 +506,14 @@ struct intel_atomic_state {
 
 	bool rps_interactive;
 
+	/*
+	 * active_pipes
+	 * min_cdclk[]
+	 * min_voltage_level[]
+	 * cdclk.*
+	 */
+	bool global_state_changed;
+
 	/* Gen9+ only */
 	struct skl_ddb_values wm_results;
 

commit aaed4dd6968668cc7ce9efafd865122bc08e0bc9
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Oct 22 16:34:14 2019 +0300

    drm/i915/dsc: move crtc state dp_dsc_cfg member under dsc as config
    
    DSC isn't DP specific, so remove the dp_ prefix from the crtc state
    member name. Also moving the member under the dsc sub-struct gives us
    enough context to allow shortening the name to just config. No
    functional changes.
    
    Cc: Manasi Navare <manasi.d.navare@intel.com>
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022133414.8293-2-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index db66f9d623f8..bac40482a2aa 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -986,8 +986,8 @@ struct intel_crtc_state {
 		bool dsc_split;
 		u16 compressed_bpp;
 		u8 slice_count;
+		struct drm_dsc_config config;
 	} dsc;
-	struct drm_dsc_config dp_dsc_cfg;
 
 	/* Forward Error correction State */
 	bool fec_enable;

commit 010663a61c40377adebb716d3fed341042b5651f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Oct 22 16:34:13 2019 +0300

    drm/i915/dsc: rename crtc state dsc_params member to dsc
    
    Reduce verbosity in code by renaming dsc_params member of crtc state to
    simply dsc. There is enough context for this to be clear. No functional
    changes.
    
    Cc: Manasi Navare <manasi.d.navare@intel.com>
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022133414.8293-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 8358152e403e..db66f9d623f8 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -986,7 +986,7 @@ struct intel_crtc_state {
 		bool dsc_split;
 		u16 compressed_bpp;
 		u8 slice_count;
-	} dsc_params;
+	} dsc;
 	struct drm_dsc_config dp_dsc_cfg;
 
 	/* Forward Error correction State */

commit bfb926e3238580a5b4c13509c6aa73d84643d75d
Author: Manasi Navare <manasi.d.navare@intel.com>
Date:   Fri Oct 18 10:27:20 2019 -0700

    drm/i915/display/icl: Save Master transcoder in slave's crtc_state for Transcoder Port Sync
    
    In case of tiled displays when the two tiles are sent across two CRTCs
    over two separate DP SST connectors, we need a mechanism to synchronize
    the two CRTCs and their corresponding transcoders.
    So use the master-slave mode where there is one master corresponding
    to last horizontal and vertical tile that needs to be genlocked with
    all other slave tiles.
    This patch identifies saves the master transcoder in all the slave
    CRTC states. This is needed to select the master CRTC/transcoder
    while configuring transcoder port sync for the corresponding slaves.
    
    v6:
    Rebase (manasi)
    v5:
    * Address Ville's comments
    * Just pass crtc_state, no need to check GEN (Ville)
    v4:
    * Rebase
    v3:
    * Use master_tramscoder instead of master_crtc for valid
    HW state readouts (Ville)
    v2:
    * Move this to intel_mode_set_pipe_config(Jani N, Ville)
    * Use slave_bitmask to save associated slaves in master crtc state (Ville)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191018172725.1338-1-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 40390d855815..8358152e403e 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -991,6 +991,12 @@ struct intel_crtc_state {
 
 	/* Forward Error correction State */
 	bool fec_enable;
+
+	/* Pointer to master transcoder in case of tiled displays */
+	enum transcoder master_transcoder;
+
+	/* Bitmask to indicate slaves attached */
+	u8 sync_mode_slaves_mask;
 };
 
 struct intel_crtc {

commit bdacf0871f8771c2763b53efb9f9aa9bdea7b570
Author: Anshuman Gupta <anshuman.gupta@intel.com>
Date:   Thu Oct 3 13:47:36 2019 +0530

    drm/i915/tgl: Do modeset to enable and configure DC3CO exitline
    
    DC3CO enabling B.Specs sequence requires to enable end configure
    exit scanlines to TRANS_EXITLINE register, programming this register
    has to be part of modeset sequence as this can't be change when
    transcoder or port is enabled.
    When system boots with only eDP panel there may not be real
    modeset as BIOS has already programmed the necessary registers,
    therefore it needs to force a modeset to enable and configure
    DC3CO exitline.
    
    v1: Computing dc3co_exitline crtc state from a DP encoder
        compute config. [Imre]
        Enabling and disabling DC3CO PSR2 transcoder exitline from
        encoder pre_enable and post_disable hooks. [Imre]
        Computing dc3co_exitline instead of has_dc3co_exitline bool. [Imre]
    v2: Code refactoring for symmetry and to avoid exported function. [Imre]
        Removing IS_TIGERLAKE check from compute_config, adding PIPE_A
        restriction and clearing dc3co_exitline state if crtc is not active
        or it is not PSR2 capable in dc3co exitline compute_config. [Imre]
        Using GEN >= 12 check in dc3co exitline get_config. [Imre]
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Animesh Manna <animesh.manna@intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191003081738.22101-5-anshuman.gupta@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 1602aac7ca0f..40390d855815 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -870,6 +870,7 @@ struct intel_crtc_state {
 
 	bool has_psr;
 	bool has_psr2;
+	u32 dc3co_exitline;
 
 	/*
 	 * Frequence the dpll for the port should run at. Differs from the

commit 81cdeca45a061f0ec9ecbbf7de864e2a57df5ee4
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Oct 2 17:41:38 2019 +0300

    drm/i915/dp: remove static variable for aux last status
    
    Add aux_busy_last_status to intel_dp. Don't bother with initializing to
    all ones; the only difference is potentially missing logging for one
    error case if the readout is all zeros.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191002144138.7917-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 976669f01a8c..1602aac7ca0f 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1185,6 +1185,7 @@ struct intel_dp {
 	/* sink or branch descriptor */
 	struct drm_dp_desc desc;
 	struct drm_dp_aux aux;
+	u32 aux_busy_last_status;
 	u8 train_set[4];
 	int panel_power_up_delay;
 	int panel_power_down_delay;

commit c47b7ddbcb29fca51515294a6fd2ed1d7d861939
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri Sep 20 13:42:20 2019 +0200

    drm/i915: Rename planar linked plane variables
    
    Rename linked_plane to planar_linked_plane and slave to planar_slave,
    this will make it easier to keep apart bigjoiner linking and planar plane
    linking.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920114235.22411-8-maarten.lankhorst@linux.intel.com
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a33644f12af1..976669f01a8c 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -559,24 +559,24 @@ struct intel_plane_state {
 	int scaler_id;
 
 	/*
-	 * linked_plane:
+	 * planar_linked_plane:
 	 *
 	 * ICL planar formats require 2 planes that are updated as pairs.
 	 * This member is used to make sure the other plane is also updated
 	 * when required, and for update_slave() to find the correct
 	 * plane_state to pass as argument.
 	 */
-	struct intel_plane *linked_plane;
+	struct intel_plane *planar_linked_plane;
 
 	/*
-	 * slave:
+	 * planar_slave:
 	 * If set don't update use the linked plane's state for updating
 	 * this plane during atomic commit with the update_slave() callback.
 	 *
 	 * It's also used by the watermark code to ignore wm calculations on
 	 * this plane. They're calculated by the linked plane's wm code.
 	 */
-	u32 slave;
+	u32 planar_slave;
 
 	struct drm_intel_sprite_colorkey ckey;
 };

commit c22d62e6e49beadea0024fe4eb9a02ce0f635657
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri Sep 20 13:42:18 2019 +0200

    drm/i915: Get rid of crtc_state->fb_changed
    
    We had this as an optimization to not do a plane update, but we killed
    it off because there are so many reasons we may have to do a plane
    update or fastset that it's best to just assume everything changed.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920114235.22411-6-maarten.lankhorst@linux.intel.com
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 6b0a646f0170..a33644f12af1 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -766,7 +766,6 @@ struct intel_crtc_state {
 	bool update_pipe; /* can a fast modeset be performed? */
 	bool disable_cxsr;
 	bool update_wm_pre, update_wm_post; /* watermarks are updated */
-	bool fb_changed; /* fb on any of the planes is changed */
 	bool fifo_changed; /* FIFO split is changed */
 
 	/* Pipe source size (ie. panel fitter input size)

commit 31d9ae9d734226b2ce3a1bc2ce1ed29a6997d556
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Fri Sep 20 13:58:06 2019 -0700

    drm/i915/tgl: Finish modular FIA support on registers
    
    If platform supports and has modular FIA is enabled, the registers
    bits also change, example: reading TC3 registers with modular FIA
    enabled, driver should read from FIA2 but with TC1 bits offsets.
    
    It is described in BSpec 50231 for DFLEXDPSP, other registers don't
    have the BSpec description but testing in real hardware have proven
    that it had moved for all other registers too.
    
    v2:
    - Caching index in tc_phy_fia_idx, instead of calculate it each time
    
    v3:
    - Setting tc_phy_fia and tc_phy_fia_idx in the same function
    
    Cc: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920205810.211048-3-jose.souza@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 49c902b00484..6b0a646f0170 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1288,6 +1288,7 @@ struct intel_digital_port {
 	char tc_port_name[8];
 	enum tc_port_mode tc_mode;
 	enum phy_fia tc_phy_fia;
+	u8 tc_phy_fia_idx;
 
 	void (*write_infoframe)(struct intel_encoder *encoder,
 				const struct intel_crtc_state *crtc_state,

commit 67f3b58f3bac975f35c312fd8876edb599cc24be
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Fri Sep 20 17:29:22 2019 +0530

    drm/i915/dsb: DSB context creation.
    
    This patch adds a function, which will internally get the gem buffer
    for DSB engine. The GEM buffer is from global GTT, and is mapped into
    CPU domain, contains the data + opcode to be feed to DSB engine.
    
    v1: Initial version.
    
    v2:
    - removed some unwanted code. (Chris)
    - Used i915_gem_object_create_internal instead of _shmem. (Chris)
    - cmd_buf_tail removed and can be derived through vma object. (Chris)
    
    v3: vma realeased if i915_gem_object_pin_map() failed. (Shashank)
    
    v4: for simplification and based on current usage added single dsb
    object in intel_crtc. (Shashank)
    
    v5: seting NULL to cmd_buf moved outside of mutex in dsb-put(). (Shashank)
    
    v6:
    - refcount machanism added.
    - Used atomic_add_return and atomic_dec_and_test instead of
    atomic_inc and atomic_dec. (Jani)
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    [Jani: added #include <linux/types.h> while pushing]
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920115930.27829-3-animesh.manna@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index d5cc4b810d9e..49c902b00484 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1033,6 +1033,9 @@ struct intel_crtc {
 
 	/* scalers available on this crtc */
 	int num_scalers;
+
+	/* per pipe DSB related info */
+	struct intel_dsb dsb;
 };
 
 struct intel_plane {

commit 4444df6e205bc1dc16ba112588815defe3c5a724
Author: Lucas De Marchi <lucas.demarchi@intel.com>
Date:   Wed Sep 4 14:34:17 2019 -0700

    drm/i915/tgl: move DP_TP_* to transcoder
    
    Gen 12 onwards moves the DP_TP_* registers to be transcoder-based rather
    than port-based. This adds the new register addresses and changes all
    the callers to use the register saved in intel_dp->regs.*. This is
    filled out when preparing to enable the port so we take into account if
    we should use the transcoder or the port.
    
    v2: reimplement by stashing the registers we want to access under
    intel_dp->reg. Now they are initialized when enabling the port.
    Ville suggested to store the transcoder to be used exclusively
    by TGL+. After implementing I thought just storing the register directly
    made it cleaner.
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190904213419.27547-5-jose.souza@intel.com
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 61277a87dbe7..d5cc4b810d9e 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1218,6 +1218,15 @@ struct intel_dp {
 	bool can_mst; /* this port supports mst */
 	bool is_mst;
 	int active_mst_links;
+
+	/*
+	 * DP_TP_* registers may be either on port or transcoder register space.
+	 */
+	struct {
+		i915_reg_t dp_tp_ctl;
+		i915_reg_t dp_tp_status;
+	} regs;
+
 	/* connector directly attached - won't be use for modeset in mst world */
 	struct intel_connector *attached_connector;
 

commit 39e2df090c3cdce23a064929333b3be119111765
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Wed Aug 28 22:12:15 2019 +0530

    drm/i915/hdcp: update current transcoder into intel_hdcp
    
    On gen12+ platforms, HDCP HW is associated to the transcoder.
    Hence on every modeset update associated transcoder into the
    intel_hdcp of the port.
    
    v2:
      s/trans/cpu_transcoder [Jani]
    v3:
      comment is added for fw_ddi init for gen12+ [Shashank]
      only hdcp capable transcoder is translated into fw_tc [Shashank]
    v4:
      fw_tc initialization is kept for modeset. [Tomas]
      few extra doc is added at port_data init [Tomas]
    v5:
      Few comments are improvised [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Uma Shankar <uma.shankar@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190828164216.405-6-ramalingam.c@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 96514dcc7812..61277a87dbe7 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -388,6 +388,13 @@ struct intel_hdcp {
 	wait_queue_head_t cp_irq_queue;
 	atomic_t cp_irq_count;
 	int cp_irq_count_cached;
+
+	/*
+	 * HDCP register access for gen12+ need the transcoder associated.
+	 * Transcoder attached to the connector could be changed at modeset.
+	 * Hence caching the transcoder here.
+	 */
+	enum transcoder cpu_transcoder;
 };
 
 struct intel_connector {

commit d048a2684a413b33a28be277a7e9cee960ec8bb2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Aug 21 20:30:31 2019 +0300

    drm/i915: Use enum pipe consistently
    
    Replace all "int pipe"s with "enum pipe pipe"s to make it clear
    what we're dealing with.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190821173033.24123-3-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 12523456143f..96514dcc7812 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1509,7 +1509,7 @@ intel_wait_for_vblank(struct drm_i915_private *dev_priv, enum pipe pipe)
 	drm_wait_one_vblank(&dev_priv->drm, pipe);
 }
 static inline void
-intel_wait_for_vblank_if_active(struct drm_i915_private *dev_priv, int pipe)
+intel_wait_for_vblank_if_active(struct drm_i915_private *dev_priv, enum pipe pipe)
 {
 	const struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
 

commit d06a79d33e0f97373a29decb66791758a6d2e968
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Aug 21 20:30:29 2019 +0300

    drm/i915: Use enum pipe instead of crtc index to track active pipes
    
    We may need to eliminate the crtc->index == pipe assumptions from
    the code to support arbitrary pipes being fused off. Start that by
    switching some bitmasks over to using pipe instead of the crtc index.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190821173033.24123-1-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 449abaea619f..12523456143f 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -481,9 +481,9 @@ struct intel_atomic_state {
 	 * but the converse is not necessarily true; simply changing a mode may
 	 * not flip the final active status of any CRTC's
 	 */
-	unsigned int active_pipe_changes;
+	u8 active_pipe_changes;
 
-	unsigned int active_crtcs;
+	u8 active_pipes;
 	/* minimum acceptable cdclk for each pipe */
 	int min_cdclk[I915_MAX_PIPES];
 	/* minimum acceptable voltage level for each pipe */

commit 2969a78aead38b49e80c821a5c683544ab16160d
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Aug 8 19:25:47 2019 +0300

    drm/i915: Fix HW readout for crtc_clock in HDMI mode
    
    The conversion during HDMI HW readout from port_clock to crtc_clock was
    missed when HDMI 10bpc support was added, so fix that.
    
    v2:
    - Unscrew the non-HDMI case.
    
    Fixes: cd9e11a8bf25 ("drm/i915/icl: Add 10-bit support for hdmi")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=109593
    Cc: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190808162547.7009-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 3c1a5f3e1d22..449abaea619f 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -867,7 +867,7 @@ struct intel_crtc_state {
 
 	/*
 	 * Frequence the dpll for the port should run at. Differs from the
-	 * adjusted dotclock e.g. for DP or 12bpc hdmi mode. This is also
+	 * adjusted dotclock e.g. for DP or 10/12bpc hdmi mode. This is also
 	 * already multiplied by pixel_multiplier.
 	 */
 	int port_clock;

commit 8e7cb1799b4f8bde3e7d9c80bf689e5408add271
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 16 08:46:35 2019 +0100

    drm/i915: Extract intel_frontbuffer active tracking
    
    Move the active tracking for the frontbuffer operations out of the
    i915_gem_object and into its own first class (refcounted) object. In the
    process of detangling, we switch from low level request tracking to the
    easier i915_active -- with the plan that this avoids any potential
    atomic callbacks as the frontbuffer tracking wishes to sleep as it
    flushes.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190816074635.26062-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index a88ec9aa9ca0..3c1a5f3e1d22 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -84,6 +84,7 @@ enum intel_broadcast_rgb {
 
 struct intel_framebuffer {
 	struct drm_framebuffer base;
+	struct intel_frontbuffer *frontbuffer;
 	struct intel_rotation_info rot_info;
 
 	/* for each plane in the normal GTT view */

commit 1c0023d4f5fd16bc9795c073cb31654d792712c5
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Aug 6 13:07:31 2019 +0300

    drm/i915: move property enums to intel_display_types.h
    
    Move the property enums closer to home. Acually make the broadcast
    macros an enum while at it.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/589d5449a504ec9742dc1fa8d4871d0d6d0cddca.1565085692.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index 3283f8d5c4e0..a88ec9aa9ca0 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -68,6 +68,20 @@ enum intel_output_type {
 	INTEL_OUTPUT_DP_MST = 11,
 };
 
+enum hdmi_force_audio {
+	HDMI_AUDIO_OFF_DVI = -2,	/* no aux data for HDMI-DVI converter */
+	HDMI_AUDIO_OFF,			/* force turn off HDMI audio */
+	HDMI_AUDIO_AUTO,		/* trust EDID */
+	HDMI_AUDIO_ON,			/* force turn on HDMI audio */
+};
+
+/* "Broadcast RGB" property */
+enum intel_broadcast_rgb {
+	INTEL_BROADCAST_RGB_AUTO,
+	INTEL_BROADCAST_RGB_FULL,
+	INTEL_BROADCAST_RGB_LIMITED,
+};
+
 struct intel_framebuffer {
 	struct drm_framebuffer base;
 	struct intel_rotation_info rot_info;

commit 1d455f8de8e8a211cc91e19484eeda2e454531a1
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Aug 6 14:39:33 2019 +0300

    drm/i915: rename intel_drv.h to display/intel_display_types.h
    
    Everything about the file is about display, and mostly about types
    related to display. Move under display/ as intel_display_types.h to
    reflect the facts.
    
    There's still plenty to clean up, but start off with moving the file
    where it logically belongs and naming according to contents.
    
    v2: fix the include guard name in the renamed file
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190806113933.11799-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
new file mode 100644
index 000000000000..3283f8d5c4e0
--- /dev/null
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -0,0 +1,1510 @@
+/*
+ * Copyright (c) 2006 Dave Airlie <airlied@linux.ie>
+ * Copyright (c) 2007-2008 Intel Corporation
+ *   Jesse Barnes <jesse.barnes@intel.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __INTEL_DISPLAY_TYPES_H__
+#define __INTEL_DISPLAY_TYPES_H__
+
+#include <linux/async.h>
+#include <linux/i2c.h>
+#include <linux/sched/clock.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_dp_dual_mode_helper.h>
+#include <drm/drm_dp_mst_helper.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_vblank.h>
+#include <drm/i915_drm.h>
+#include <drm/i915_mei_hdcp_interface.h>
+#include <media/cec-notifier.h>
+
+#include "i915_drv.h"
+
+struct drm_printer;
+
+/*
+ * Display related stuff
+ */
+
+/* these are outputs from the chip - integrated only
+   external chips are via DVO or SDVO output */
+enum intel_output_type {
+	INTEL_OUTPUT_UNUSED = 0,
+	INTEL_OUTPUT_ANALOG = 1,
+	INTEL_OUTPUT_DVO = 2,
+	INTEL_OUTPUT_SDVO = 3,
+	INTEL_OUTPUT_LVDS = 4,
+	INTEL_OUTPUT_TVOUT = 5,
+	INTEL_OUTPUT_HDMI = 6,
+	INTEL_OUTPUT_DP = 7,
+	INTEL_OUTPUT_EDP = 8,
+	INTEL_OUTPUT_DSI = 9,
+	INTEL_OUTPUT_DDI = 10,
+	INTEL_OUTPUT_DP_MST = 11,
+};
+
+struct intel_framebuffer {
+	struct drm_framebuffer base;
+	struct intel_rotation_info rot_info;
+
+	/* for each plane in the normal GTT view */
+	struct {
+		unsigned int x, y;
+	} normal[2];
+	/* for each plane in the rotated GTT view */
+	struct {
+		unsigned int x, y;
+		unsigned int pitch; /* pixels */
+	} rotated[2];
+};
+
+struct intel_fbdev {
+	struct drm_fb_helper helper;
+	struct intel_framebuffer *fb;
+	struct i915_vma *vma;
+	unsigned long vma_flags;
+	async_cookie_t cookie;
+	int preferred_bpp;
+
+	/* Whether or not fbdev hpd processing is temporarily suspended */
+	bool hpd_suspended : 1;
+	/* Set when a hotplug was received while HPD processing was
+	 * suspended
+	 */
+	bool hpd_waiting : 1;
+
+	/* Protects hpd_suspended */
+	struct mutex hpd_lock;
+};
+
+enum intel_hotplug_state {
+	INTEL_HOTPLUG_UNCHANGED,
+	INTEL_HOTPLUG_CHANGED,
+	INTEL_HOTPLUG_RETRY,
+};
+
+struct intel_encoder {
+	struct drm_encoder base;
+
+	enum intel_output_type type;
+	enum port port;
+	unsigned int cloneable;
+	enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
+					    struct intel_connector *connector,
+					    bool irq_received);
+	enum intel_output_type (*compute_output_type)(struct intel_encoder *,
+						      struct intel_crtc_state *,
+						      struct drm_connector_state *);
+	int (*compute_config)(struct intel_encoder *,
+			      struct intel_crtc_state *,
+			      struct drm_connector_state *);
+	void (*update_prepare)(struct intel_atomic_state *,
+			       struct intel_encoder *,
+			       struct intel_crtc *);
+	void (*pre_pll_enable)(struct intel_encoder *,
+			       const struct intel_crtc_state *,
+			       const struct drm_connector_state *);
+	void (*pre_enable)(struct intel_encoder *,
+			   const struct intel_crtc_state *,
+			   const struct drm_connector_state *);
+	void (*enable)(struct intel_encoder *,
+		       const struct intel_crtc_state *,
+		       const struct drm_connector_state *);
+	void (*update_complete)(struct intel_atomic_state *,
+				struct intel_encoder *,
+				struct intel_crtc *);
+	void (*disable)(struct intel_encoder *,
+			const struct intel_crtc_state *,
+			const struct drm_connector_state *);
+	void (*post_disable)(struct intel_encoder *,
+			     const struct intel_crtc_state *,
+			     const struct drm_connector_state *);
+	void (*post_pll_disable)(struct intel_encoder *,
+				 const struct intel_crtc_state *,
+				 const struct drm_connector_state *);
+	void (*update_pipe)(struct intel_encoder *,
+			    const struct intel_crtc_state *,
+			    const struct drm_connector_state *);
+	/* Read out the current hw state of this connector, returning true if
+	 * the encoder is active. If the encoder is enabled it also set the pipe
+	 * it is connected to in the pipe parameter. */
+	bool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);
+	/* Reconstructs the equivalent mode flags for the current hardware
+	 * state. This must be called _after_ display->get_pipe_config has
+	 * pre-filled the pipe config. Note that intel_encoder->base.crtc must
+	 * be set correctly before calling this function. */
+	void (*get_config)(struct intel_encoder *,
+			   struct intel_crtc_state *pipe_config);
+	/*
+	 * Acquires the power domains needed for an active encoder during
+	 * hardware state readout.
+	 */
+	void (*get_power_domains)(struct intel_encoder *encoder,
+				  struct intel_crtc_state *crtc_state);
+	/*
+	 * Called during system suspend after all pending requests for the
+	 * encoder are flushed (for example for DP AUX transactions) and
+	 * device interrupts are disabled.
+	 */
+	void (*suspend)(struct intel_encoder *);
+	int crtc_mask;
+	enum hpd_pin hpd_pin;
+	enum intel_display_power_domain power_domain;
+	/* for communication with audio component; protected by av_mutex */
+	const struct drm_connector *audio_connector;
+};
+
+struct intel_panel {
+	struct drm_display_mode *fixed_mode;
+	struct drm_display_mode *downclock_mode;
+
+	/* backlight */
+	struct {
+		bool present;
+		u32 level;
+		u32 min;
+		u32 max;
+		bool enabled;
+		bool combination_mode;	/* gen 2/4 only */
+		bool active_low_pwm;
+		bool alternate_pwm_increment;	/* lpt+ */
+
+		/* PWM chip */
+		bool util_pin_active_low;	/* bxt+ */
+		u8 controller;		/* bxt+ only */
+		struct pwm_device *pwm;
+
+		struct backlight_device *device;
+
+		/* Connector and platform specific backlight functions */
+		int (*setup)(struct intel_connector *connector, enum pipe pipe);
+		u32 (*get)(struct intel_connector *connector);
+		void (*set)(const struct drm_connector_state *conn_state, u32 level);
+		void (*disable)(const struct drm_connector_state *conn_state);
+		void (*enable)(const struct intel_crtc_state *crtc_state,
+			       const struct drm_connector_state *conn_state);
+		u32 (*hz_to_pwm)(struct intel_connector *connector, u32 hz);
+		void (*power)(struct intel_connector *, bool enable);
+	} backlight;
+};
+
+struct intel_digital_port;
+
+enum check_link_response {
+	HDCP_LINK_PROTECTED	= 0,
+	HDCP_TOPOLOGY_CHANGE,
+	HDCP_LINK_INTEGRITY_FAILURE,
+	HDCP_REAUTH_REQUEST
+};
+
+/*
+ * This structure serves as a translation layer between the generic HDCP code
+ * and the bus-specific code. What that means is that HDCP over HDMI differs
+ * from HDCP over DP, so to account for these differences, we need to
+ * communicate with the receiver through this shim.
+ *
+ * For completeness, the 2 buses differ in the following ways:
+ *	- DP AUX vs. DDC
+ *		HDCP registers on the receiver are set via DP AUX for DP, and
+ *		they are set via DDC for HDMI.
+ *	- Receiver register offsets
+ *		The offsets of the registers are different for DP vs. HDMI
+ *	- Receiver register masks/offsets
+ *		For instance, the ready bit for the KSV fifo is in a different
+ *		place on DP vs HDMI
+ *	- Receiver register names
+ *		Seriously. In the DP spec, the 16-bit register containing
+ *		downstream information is called BINFO, on HDMI it's called
+ *		BSTATUS. To confuse matters further, DP has a BSTATUS register
+ *		with a completely different definition.
+ *	- KSV FIFO
+ *		On HDMI, the ksv fifo is read all at once, whereas on DP it must
+ *		be read 3 keys at a time
+ *	- Aksv output
+ *		Since Aksv is hidden in hardware, there's different procedures
+ *		to send it over DP AUX vs DDC
+ */
+struct intel_hdcp_shim {
+	/* Outputs the transmitter's An and Aksv values to the receiver. */
+	int (*write_an_aksv)(struct intel_digital_port *intel_dig_port, u8 *an);
+
+	/* Reads the receiver's key selection vector */
+	int (*read_bksv)(struct intel_digital_port *intel_dig_port, u8 *bksv);
+
+	/*
+	 * Reads BINFO from DP receivers and BSTATUS from HDMI receivers. The
+	 * definitions are the same in the respective specs, but the names are
+	 * different. Call it BSTATUS since that's the name the HDMI spec
+	 * uses and it was there first.
+	 */
+	int (*read_bstatus)(struct intel_digital_port *intel_dig_port,
+			    u8 *bstatus);
+
+	/* Determines whether a repeater is present downstream */
+	int (*repeater_present)(struct intel_digital_port *intel_dig_port,
+				bool *repeater_present);
+
+	/* Reads the receiver's Ri' value */
+	int (*read_ri_prime)(struct intel_digital_port *intel_dig_port, u8 *ri);
+
+	/* Determines if the receiver's KSV FIFO is ready for consumption */
+	int (*read_ksv_ready)(struct intel_digital_port *intel_dig_port,
+			      bool *ksv_ready);
+
+	/* Reads the ksv fifo for num_downstream devices */
+	int (*read_ksv_fifo)(struct intel_digital_port *intel_dig_port,
+			     int num_downstream, u8 *ksv_fifo);
+
+	/* Reads a 32-bit part of V' from the receiver */
+	int (*read_v_prime_part)(struct intel_digital_port *intel_dig_port,
+				 int i, u32 *part);
+
+	/* Enables HDCP signalling on the port */
+	int (*toggle_signalling)(struct intel_digital_port *intel_dig_port,
+				 bool enable);
+
+	/* Ensures the link is still protected */
+	bool (*check_link)(struct intel_digital_port *intel_dig_port);
+
+	/* Detects panel's hdcp capability. This is optional for HDMI. */
+	int (*hdcp_capable)(struct intel_digital_port *intel_dig_port,
+			    bool *hdcp_capable);
+
+	/* HDCP adaptation(DP/HDMI) required on the port */
+	enum hdcp_wired_protocol protocol;
+
+	/* Detects whether sink is HDCP2.2 capable */
+	int (*hdcp_2_2_capable)(struct intel_digital_port *intel_dig_port,
+				bool *capable);
+
+	/* Write HDCP2.2 messages */
+	int (*write_2_2_msg)(struct intel_digital_port *intel_dig_port,
+			     void *buf, size_t size);
+
+	/* Read HDCP2.2 messages */
+	int (*read_2_2_msg)(struct intel_digital_port *intel_dig_port,
+			    u8 msg_id, void *buf, size_t size);
+
+	/*
+	 * Implementation of DP HDCP2.2 Errata for the communication of stream
+	 * type to Receivers. In DP HDCP2.2 Stream type is one of the input to
+	 * the HDCP2.2 Cipher for En/De-Cryption. Not applicable for HDMI.
+	 */
+	int (*config_stream_type)(struct intel_digital_port *intel_dig_port,
+				  bool is_repeater, u8 type);
+
+	/* HDCP2.2 Link Integrity Check */
+	int (*check_2_2_link)(struct intel_digital_port *intel_dig_port);
+};
+
+struct intel_hdcp {
+	const struct intel_hdcp_shim *shim;
+	/* Mutex for hdcp state of the connector */
+	struct mutex mutex;
+	u64 value;
+	struct delayed_work check_work;
+	struct work_struct prop_work;
+
+	/* HDCP1.4 Encryption status */
+	bool hdcp_encrypted;
+
+	/* HDCP2.2 related definitions */
+	/* Flag indicates whether this connector supports HDCP2.2 or not. */
+	bool hdcp2_supported;
+
+	/* HDCP2.2 Encryption status */
+	bool hdcp2_encrypted;
+
+	/*
+	 * Content Stream Type defined by content owner. TYPE0(0x0) content can
+	 * flow in the link protected by HDCP2.2 or HDCP1.4, where as TYPE1(0x1)
+	 * content can flow only through a link protected by HDCP2.2.
+	 */
+	u8 content_type;
+	struct hdcp_port_data port_data;
+
+	bool is_paired;
+	bool is_repeater;
+
+	/*
+	 * Count of ReceiverID_List received. Initialized to 0 at AKE_INIT.
+	 * Incremented after processing the RepeaterAuth_Send_ReceiverID_List.
+	 * When it rolls over re-auth has to be triggered.
+	 */
+	u32 seq_num_v;
+
+	/*
+	 * Count of RepeaterAuth_Stream_Manage msg propagated.
+	 * Initialized to 0 on AKE_INIT. Incremented after every successful
+	 * transmission of RepeaterAuth_Stream_Manage message. When it rolls
+	 * over re-Auth has to be triggered.
+	 */
+	u32 seq_num_m;
+
+	/*
+	 * Work queue to signal the CP_IRQ. Used for the waiters to read the
+	 * available information from HDCP DP sink.
+	 */
+	wait_queue_head_t cp_irq_queue;
+	atomic_t cp_irq_count;
+	int cp_irq_count_cached;
+};
+
+struct intel_connector {
+	struct drm_connector base;
+	/*
+	 * The fixed encoder this connector is connected to.
+	 */
+	struct intel_encoder *encoder;
+
+	/* ACPI device id for ACPI and driver cooperation */
+	u32 acpi_device_id;
+
+	/* Reads out the current hw, returning true if the connector is enabled
+	 * and active (i.e. dpms ON state). */
+	bool (*get_hw_state)(struct intel_connector *);
+
+	/* Panel info for eDP and LVDS */
+	struct intel_panel panel;
+
+	/* Cached EDID for eDP and LVDS. May hold ERR_PTR for invalid EDID. */
+	struct edid *edid;
+	struct edid *detect_edid;
+
+	/* since POLL and HPD connectors may use the same HPD line keep the native
+	   state of connector->polled in case hotplug storm detection changes it */
+	u8 polled;
+
+	void *port; /* store this opaque as its illegal to dereference it */
+
+	struct intel_dp *mst_port;
+
+	/* Work struct to schedule a uevent on link train failure */
+	struct work_struct modeset_retry_work;
+
+	struct intel_hdcp hdcp;
+};
+
+struct intel_digital_connector_state {
+	struct drm_connector_state base;
+
+	enum hdmi_force_audio force_audio;
+	int broadcast_rgb;
+};
+
+#define to_intel_digital_connector_state(x) container_of(x, struct intel_digital_connector_state, base)
+
+struct dpll {
+	/* given values */
+	int n;
+	int m1, m2;
+	int p1, p2;
+	/* derived values */
+	int	dot;
+	int	vco;
+	int	m;
+	int	p;
+};
+
+struct intel_atomic_state {
+	struct drm_atomic_state base;
+
+	intel_wakeref_t wakeref;
+
+	struct {
+		/*
+		 * Logical state of cdclk (used for all scaling, watermark,
+		 * etc. calculations and checks). This is computed as if all
+		 * enabled crtcs were active.
+		 */
+		struct intel_cdclk_state logical;
+
+		/*
+		 * Actual state of cdclk, can be different from the logical
+		 * state only when all crtc's are DPMS off.
+		 */
+		struct intel_cdclk_state actual;
+
+		int force_min_cdclk;
+		bool force_min_cdclk_changed;
+		/* pipe to which cd2x update is synchronized */
+		enum pipe pipe;
+	} cdclk;
+
+	bool dpll_set, modeset;
+
+	/*
+	 * Does this transaction change the pipes that are active?  This mask
+	 * tracks which CRTC's have changed their active state at the end of
+	 * the transaction (not counting the temporary disable during modesets).
+	 * This mask should only be non-zero when intel_state->modeset is true,
+	 * but the converse is not necessarily true; simply changing a mode may
+	 * not flip the final active status of any CRTC's
+	 */
+	unsigned int active_pipe_changes;
+
+	unsigned int active_crtcs;
+	/* minimum acceptable cdclk for each pipe */
+	int min_cdclk[I915_MAX_PIPES];
+	/* minimum acceptable voltage level for each pipe */
+	u8 min_voltage_level[I915_MAX_PIPES];
+
+	struct intel_shared_dpll_state shared_dpll[I915_NUM_PLLS];
+
+	/*
+	 * Current watermarks can't be trusted during hardware readout, so
+	 * don't bother calculating intermediate watermarks.
+	 */
+	bool skip_intermediate_wm;
+
+	bool rps_interactive;
+
+	/* Gen9+ only */
+	struct skl_ddb_values wm_results;
+
+	struct i915_sw_fence commit_ready;
+
+	struct llist_node freed;
+};
+
+struct intel_plane_state {
+	struct drm_plane_state base;
+	struct i915_ggtt_view view;
+	struct i915_vma *vma;
+	unsigned long flags;
+#define PLANE_HAS_FENCE BIT(0)
+
+	struct {
+		u32 offset;
+		/*
+		 * Plane stride in:
+		 * bytes for 0/180 degree rotation
+		 * pixels for 90/270 degree rotation
+		 */
+		u32 stride;
+		int x, y;
+	} color_plane[2];
+
+	/* plane control register */
+	u32 ctl;
+
+	/* plane color control register */
+	u32 color_ctl;
+
+	/*
+	 * scaler_id
+	 *    = -1 : not using a scaler
+	 *    >=  0 : using a scalers
+	 *
+	 * plane requiring a scaler:
+	 *   - During check_plane, its bit is set in
+	 *     crtc_state->scaler_state.scaler_users by calling helper function
+	 *     update_scaler_plane.
+	 *   - scaler_id indicates the scaler it got assigned.
+	 *
+	 * plane doesn't require a scaler:
+	 *   - this can happen when scaling is no more required or plane simply
+	 *     got disabled.
+	 *   - During check_plane, corresponding bit is reset in
+	 *     crtc_state->scaler_state.scaler_users by calling helper function
+	 *     update_scaler_plane.
+	 */
+	int scaler_id;
+
+	/*
+	 * linked_plane:
+	 *
+	 * ICL planar formats require 2 planes that are updated as pairs.
+	 * This member is used to make sure the other plane is also updated
+	 * when required, and for update_slave() to find the correct
+	 * plane_state to pass as argument.
+	 */
+	struct intel_plane *linked_plane;
+
+	/*
+	 * slave:
+	 * If set don't update use the linked plane's state for updating
+	 * this plane during atomic commit with the update_slave() callback.
+	 *
+	 * It's also used by the watermark code to ignore wm calculations on
+	 * this plane. They're calculated by the linked plane's wm code.
+	 */
+	u32 slave;
+
+	struct drm_intel_sprite_colorkey ckey;
+};
+
+struct intel_initial_plane_config {
+	struct intel_framebuffer *fb;
+	unsigned int tiling;
+	int size;
+	u32 base;
+	u8 rotation;
+};
+
+struct intel_scaler {
+	int in_use;
+	u32 mode;
+};
+
+struct intel_crtc_scaler_state {
+#define SKL_NUM_SCALERS 2
+	struct intel_scaler scalers[SKL_NUM_SCALERS];
+
+	/*
+	 * scaler_users: keeps track of users requesting scalers on this crtc.
+	 *
+	 *     If a bit is set, a user is using a scaler.
+	 *     Here user can be a plane or crtc as defined below:
+	 *       bits 0-30 - plane (bit position is index from drm_plane_index)
+	 *       bit 31    - crtc
+	 *
+	 * Instead of creating a new index to cover planes and crtc, using
+	 * existing drm_plane_index for planes which is well less than 31
+	 * planes and bit 31 for crtc. This should be fine to cover all
+	 * our platforms.
+	 *
+	 * intel_atomic_setup_scalers will setup available scalers to users
+	 * requesting scalers. It will gracefully fail if request exceeds
+	 * avilability.
+	 */
+#define SKL_CRTC_INDEX 31
+	unsigned scaler_users;
+
+	/* scaler used by crtc for panel fitting purpose */
+	int scaler_id;
+};
+
+/* drm_mode->private_flags */
+#define I915_MODE_FLAG_INHERITED (1<<0)
+/* Flag to get scanline using frame time stamps */
+#define I915_MODE_FLAG_GET_SCANLINE_FROM_TIMESTAMP (1<<1)
+/* Flag to use the scanline counter instead of the pixel counter */
+#define I915_MODE_FLAG_USE_SCANLINE_COUNTER (1<<2)
+
+struct intel_pipe_wm {
+	struct intel_wm_level wm[5];
+	u32 linetime;
+	bool fbc_wm_enabled;
+	bool pipe_enabled;
+	bool sprites_enabled;
+	bool sprites_scaled;
+};
+
+struct skl_plane_wm {
+	struct skl_wm_level wm[8];
+	struct skl_wm_level uv_wm[8];
+	struct skl_wm_level trans_wm;
+	bool is_planar;
+};
+
+struct skl_pipe_wm {
+	struct skl_plane_wm planes[I915_MAX_PLANES];
+	u32 linetime;
+};
+
+enum vlv_wm_level {
+	VLV_WM_LEVEL_PM2,
+	VLV_WM_LEVEL_PM5,
+	VLV_WM_LEVEL_DDR_DVFS,
+	NUM_VLV_WM_LEVELS,
+};
+
+struct vlv_wm_state {
+	struct g4x_pipe_wm wm[NUM_VLV_WM_LEVELS];
+	struct g4x_sr_wm sr[NUM_VLV_WM_LEVELS];
+	u8 num_levels;
+	bool cxsr;
+};
+
+struct vlv_fifo_state {
+	u16 plane[I915_MAX_PLANES];
+};
+
+enum g4x_wm_level {
+	G4X_WM_LEVEL_NORMAL,
+	G4X_WM_LEVEL_SR,
+	G4X_WM_LEVEL_HPLL,
+	NUM_G4X_WM_LEVELS,
+};
+
+struct g4x_wm_state {
+	struct g4x_pipe_wm wm;
+	struct g4x_sr_wm sr;
+	struct g4x_sr_wm hpll;
+	bool cxsr;
+	bool hpll_en;
+	bool fbc_en;
+};
+
+struct intel_crtc_wm_state {
+	union {
+		struct {
+			/*
+			 * Intermediate watermarks; these can be
+			 * programmed immediately since they satisfy
+			 * both the current configuration we're
+			 * switching away from and the new
+			 * configuration we're switching to.
+			 */
+			struct intel_pipe_wm intermediate;
+
+			/*
+			 * Optimal watermarks, programmed post-vblank
+			 * when this state is committed.
+			 */
+			struct intel_pipe_wm optimal;
+		} ilk;
+
+		struct {
+			/* gen9+ only needs 1-step wm programming */
+			struct skl_pipe_wm optimal;
+			struct skl_ddb_entry ddb;
+			struct skl_ddb_entry plane_ddb_y[I915_MAX_PLANES];
+			struct skl_ddb_entry plane_ddb_uv[I915_MAX_PLANES];
+		} skl;
+
+		struct {
+			/* "raw" watermarks (not inverted) */
+			struct g4x_pipe_wm raw[NUM_VLV_WM_LEVELS];
+			/* intermediate watermarks (inverted) */
+			struct vlv_wm_state intermediate;
+			/* optimal watermarks (inverted) */
+			struct vlv_wm_state optimal;
+			/* display FIFO split */
+			struct vlv_fifo_state fifo_state;
+		} vlv;
+
+		struct {
+			/* "raw" watermarks */
+			struct g4x_pipe_wm raw[NUM_G4X_WM_LEVELS];
+			/* intermediate watermarks */
+			struct g4x_wm_state intermediate;
+			/* optimal watermarks */
+			struct g4x_wm_state optimal;
+		} g4x;
+	};
+
+	/*
+	 * Platforms with two-step watermark programming will need to
+	 * update watermark programming post-vblank to switch from the
+	 * safe intermediate watermarks to the optimal final
+	 * watermarks.
+	 */
+	bool need_postvbl_update;
+};
+
+enum intel_output_format {
+	INTEL_OUTPUT_FORMAT_INVALID,
+	INTEL_OUTPUT_FORMAT_RGB,
+	INTEL_OUTPUT_FORMAT_YCBCR420,
+	INTEL_OUTPUT_FORMAT_YCBCR444,
+};
+
+struct intel_crtc_state {
+	struct drm_crtc_state base;
+
+	/**
+	 * quirks - bitfield with hw state readout quirks
+	 *
+	 * For various reasons the hw state readout code might not be able to
+	 * completely faithfully read out the current state. These cases are
+	 * tracked with quirk flags so that fastboot and state checker can act
+	 * accordingly.
+	 */
+#define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS	(1<<0) /* unreliable sync mode.flags */
+	unsigned long quirks;
+
+	unsigned fb_bits; /* framebuffers to flip */
+	bool update_pipe; /* can a fast modeset be performed? */
+	bool disable_cxsr;
+	bool update_wm_pre, update_wm_post; /* watermarks are updated */
+	bool fb_changed; /* fb on any of the planes is changed */
+	bool fifo_changed; /* FIFO split is changed */
+
+	/* Pipe source size (ie. panel fitter input size)
+	 * All planes will be positioned inside this space,
+	 * and get clipped at the edges. */
+	int pipe_src_w, pipe_src_h;
+
+	/*
+	 * Pipe pixel rate, adjusted for
+	 * panel fitter/pipe scaler downscaling.
+	 */
+	unsigned int pixel_rate;
+
+	/* Whether to set up the PCH/FDI. Note that we never allow sharing
+	 * between pch encoders and cpu encoders. */
+	bool has_pch_encoder;
+
+	/* Are we sending infoframes on the attached port */
+	bool has_infoframe;
+
+	/* CPU Transcoder for the pipe. Currently this can only differ from the
+	 * pipe on Haswell and later (where we have a special eDP transcoder)
+	 * and Broxton (where we have special DSI transcoders). */
+	enum transcoder cpu_transcoder;
+
+	/*
+	 * Use reduced/limited/broadcast rbg range, compressing from the full
+	 * range fed into the crtcs.
+	 */
+	bool limited_color_range;
+
+	/* Bitmask of encoder types (enum intel_output_type)
+	 * driven by the pipe.
+	 */
+	unsigned int output_types;
+
+	/* Whether we should send NULL infoframes. Required for audio. */
+	bool has_hdmi_sink;
+
+	/* Audio enabled on this pipe. Only valid if either has_hdmi_sink or
+	 * has_dp_encoder is set. */
+	bool has_audio;
+
+	/*
+	 * Enable dithering, used when the selected pipe bpp doesn't match the
+	 * plane bpp.
+	 */
+	bool dither;
+
+	/*
+	 * Dither gets enabled for 18bpp which causes CRC mismatch errors for
+	 * compliance video pattern tests.
+	 * Disable dither only if it is a compliance test request for
+	 * 18bpp.
+	 */
+	bool dither_force_disable;
+
+	/* Controls for the clock computation, to override various stages. */
+	bool clock_set;
+
+	/* SDVO TV has a bunch of special case. To make multifunction encoders
+	 * work correctly, we need to track this at runtime.*/
+	bool sdvo_tv_clock;
+
+	/*
+	 * crtc bandwidth limit, don't increase pipe bpp or clock if not really
+	 * required. This is set in the 2nd loop of calling encoder's
+	 * ->compute_config if the first pick doesn't work out.
+	 */
+	bool bw_constrained;
+
+	/* Settings for the intel dpll used on pretty much everything but
+	 * haswell. */
+	struct dpll dpll;
+
+	/* Selected dpll when shared or NULL. */
+	struct intel_shared_dpll *shared_dpll;
+
+	/* Actual register state of the dpll, for shared dpll cross-checking. */
+	struct intel_dpll_hw_state dpll_hw_state;
+
+	/*
+	 * ICL reserved DPLLs for the CRTC/port. The active PLL is selected by
+	 * setting shared_dpll and dpll_hw_state to one of these reserved ones.
+	 */
+	struct icl_port_dpll {
+		struct intel_shared_dpll *pll;
+		struct intel_dpll_hw_state hw_state;
+	} icl_port_dplls[ICL_PORT_DPLL_COUNT];
+
+	/* DSI PLL registers */
+	struct {
+		u32 ctrl, div;
+	} dsi_pll;
+
+	int pipe_bpp;
+	struct intel_link_m_n dp_m_n;
+
+	/* m2_n2 for eDP downclock */
+	struct intel_link_m_n dp_m2_n2;
+	bool has_drrs;
+
+	bool has_psr;
+	bool has_psr2;
+
+	/*
+	 * Frequence the dpll for the port should run at. Differs from the
+	 * adjusted dotclock e.g. for DP or 12bpc hdmi mode. This is also
+	 * already multiplied by pixel_multiplier.
+	 */
+	int port_clock;
+
+	/* Used by SDVO (and if we ever fix it, HDMI). */
+	unsigned pixel_multiplier;
+
+	u8 lane_count;
+
+	/*
+	 * Used by platforms having DP/HDMI PHY with programmable lane
+	 * latency optimization.
+	 */
+	u8 lane_lat_optim_mask;
+
+	/* minimum acceptable voltage level */
+	u8 min_voltage_level;
+
+	/* Panel fitter controls for gen2-gen4 + VLV */
+	struct {
+		u32 control;
+		u32 pgm_ratios;
+		u32 lvds_border_bits;
+	} gmch_pfit;
+
+	/* Panel fitter placement and size for Ironlake+ */
+	struct {
+		u32 pos;
+		u32 size;
+		bool enabled;
+		bool force_thru;
+	} pch_pfit;
+
+	/* FDI configuration, only valid if has_pch_encoder is set. */
+	int fdi_lanes;
+	struct intel_link_m_n fdi_m_n;
+
+	bool ips_enabled;
+
+	bool crc_enabled;
+
+	bool enable_fbc;
+
+	bool double_wide;
+
+	int pbn;
+
+	struct intel_crtc_scaler_state scaler_state;
+
+	/* w/a for waiting 2 vblanks during crtc enable */
+	enum pipe hsw_workaround_pipe;
+
+	/* IVB sprite scaling w/a (WaCxSRDisabledForSpriteScaling:ivb) */
+	bool disable_lp_wm;
+
+	struct intel_crtc_wm_state wm;
+
+	u32 data_rate[I915_MAX_PLANES];
+
+	/* Gamma mode programmed on the pipe */
+	u32 gamma_mode;
+
+	union {
+		/* CSC mode programmed on the pipe */
+		u32 csc_mode;
+
+		/* CHV CGM mode */
+		u32 cgm_mode;
+	};
+
+	/* bitmask of visible planes (enum plane_id) */
+	u8 active_planes;
+	u8 nv12_planes;
+	u8 c8_planes;
+
+	/* bitmask of planes that will be updated during the commit */
+	u8 update_planes;
+
+	struct {
+		u32 enable;
+		u32 gcp;
+		union hdmi_infoframe avi;
+		union hdmi_infoframe spd;
+		union hdmi_infoframe hdmi;
+		union hdmi_infoframe drm;
+	} infoframes;
+
+	/* HDMI scrambling status */
+	bool hdmi_scrambling;
+
+	/* HDMI High TMDS char rate ratio */
+	bool hdmi_high_tmds_clock_ratio;
+
+	/* Output format RGB/YCBCR etc */
+	enum intel_output_format output_format;
+
+	/* Output down scaling is done in LSPCON device */
+	bool lspcon_downsampling;
+
+	/* enable pipe gamma? */
+	bool gamma_enable;
+
+	/* enable pipe csc? */
+	bool csc_enable;
+
+	/* Display Stream compression state */
+	struct {
+		bool compression_enable;
+		bool dsc_split;
+		u16 compressed_bpp;
+		u8 slice_count;
+	} dsc_params;
+	struct drm_dsc_config dp_dsc_cfg;
+
+	/* Forward Error correction State */
+	bool fec_enable;
+};
+
+struct intel_crtc {
+	struct drm_crtc base;
+	enum pipe pipe;
+	/*
+	 * Whether the crtc and the connected output pipeline is active. Implies
+	 * that crtc->enabled is set, i.e. the current mode configuration has
+	 * some outputs connected to this crtc.
+	 */
+	bool active;
+	u8 plane_ids_mask;
+	unsigned long long enabled_power_domains;
+	struct intel_overlay *overlay;
+
+	struct intel_crtc_state *config;
+
+	/* Access to these should be protected by dev_priv->irq_lock. */
+	bool cpu_fifo_underrun_disabled;
+	bool pch_fifo_underrun_disabled;
+
+	/* per-pipe watermark state */
+	struct {
+		/* watermarks currently being used  */
+		union {
+			struct intel_pipe_wm ilk;
+			struct vlv_wm_state vlv;
+			struct g4x_wm_state g4x;
+		} active;
+	} wm;
+
+	int scanline_offset;
+
+	struct {
+		unsigned start_vbl_count;
+		ktime_t start_vbl_time;
+		int min_vbl, max_vbl;
+		int scanline_start;
+	} debug;
+
+	/* scalers available on this crtc */
+	int num_scalers;
+};
+
+struct intel_plane {
+	struct drm_plane base;
+	enum i9xx_plane_id i9xx_plane;
+	enum plane_id id;
+	enum pipe pipe;
+	bool has_fbc;
+	bool has_ccs;
+	u32 frontbuffer_bit;
+
+	struct {
+		u32 base, cntl, size;
+	} cursor;
+
+	/*
+	 * NOTE: Do not place new plane state fields here (e.g., when adding
+	 * new plane properties).  New runtime state should now be placed in
+	 * the intel_plane_state structure and accessed via plane_state.
+	 */
+
+	unsigned int (*max_stride)(struct intel_plane *plane,
+				   u32 pixel_format, u64 modifier,
+				   unsigned int rotation);
+	void (*update_plane)(struct intel_plane *plane,
+			     const struct intel_crtc_state *crtc_state,
+			     const struct intel_plane_state *plane_state);
+	void (*update_slave)(struct intel_plane *plane,
+			     const struct intel_crtc_state *crtc_state,
+			     const struct intel_plane_state *plane_state);
+	void (*disable_plane)(struct intel_plane *plane,
+			      const struct intel_crtc_state *crtc_state);
+	bool (*get_hw_state)(struct intel_plane *plane, enum pipe *pipe);
+	int (*check_plane)(struct intel_crtc_state *crtc_state,
+			   struct intel_plane_state *plane_state);
+};
+
+struct intel_watermark_params {
+	u16 fifo_size;
+	u16 max_wm;
+	u8 default_wm;
+	u8 guard_size;
+	u8 cacheline_size;
+};
+
+struct cxsr_latency {
+	bool is_desktop : 1;
+	bool is_ddr3 : 1;
+	u16 fsb_freq;
+	u16 mem_freq;
+	u16 display_sr;
+	u16 display_hpll_disable;
+	u16 cursor_sr;
+	u16 cursor_hpll_disable;
+};
+
+#define to_intel_atomic_state(x) container_of(x, struct intel_atomic_state, base)
+#define to_intel_crtc(x) container_of(x, struct intel_crtc, base)
+#define to_intel_crtc_state(x) container_of(x, struct intel_crtc_state, base)
+#define to_intel_connector(x) container_of(x, struct intel_connector, base)
+#define to_intel_encoder(x) container_of(x, struct intel_encoder, base)
+#define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)
+#define to_intel_plane(x) container_of(x, struct intel_plane, base)
+#define to_intel_plane_state(x) container_of(x, struct intel_plane_state, base)
+#define intel_fb_obj(x) ((x) ? to_intel_bo((x)->obj[0]) : NULL)
+
+struct intel_hdmi {
+	i915_reg_t hdmi_reg;
+	int ddc_bus;
+	struct {
+		enum drm_dp_dual_mode_type type;
+		int max_tmds_clock;
+	} dp_dual_mode;
+	bool has_hdmi_sink;
+	bool has_audio;
+	struct intel_connector *attached_connector;
+	struct cec_notifier *cec_notifier;
+};
+
+struct intel_dp_mst_encoder;
+#define DP_MAX_DOWNSTREAM_PORTS		0x10
+
+/*
+ * enum link_m_n_set:
+ *	When platform provides two set of M_N registers for dp, we can
+ *	program them and switch between them incase of DRRS.
+ *	But When only one such register is provided, we have to program the
+ *	required divider value on that registers itself based on the DRRS state.
+ *
+ * M1_N1	: Program dp_m_n on M1_N1 registers
+ *			  dp_m2_n2 on M2_N2 registers (If supported)
+ *
+ * M2_N2	: Program dp_m2_n2 on M1_N1 registers
+ *			  M2_N2 registers are not supported
+ */
+
+enum link_m_n_set {
+	/* Sets the m1_n1 and m2_n2 */
+	M1_N1 = 0,
+	M2_N2
+};
+
+struct intel_dp_compliance_data {
+	unsigned long edid;
+	u8 video_pattern;
+	u16 hdisplay, vdisplay;
+	u8 bpc;
+};
+
+struct intel_dp_compliance {
+	unsigned long test_type;
+	struct intel_dp_compliance_data test_data;
+	bool test_active;
+	int test_link_rate;
+	u8 test_lane_count;
+};
+
+struct intel_dp {
+	i915_reg_t output_reg;
+	u32 DP;
+	int link_rate;
+	u8 lane_count;
+	u8 sink_count;
+	bool link_mst;
+	bool link_trained;
+	bool has_audio;
+	bool reset_link_params;
+	u8 dpcd[DP_RECEIVER_CAP_SIZE];
+	u8 psr_dpcd[EDP_PSR_RECEIVER_CAP_SIZE];
+	u8 downstream_ports[DP_MAX_DOWNSTREAM_PORTS];
+	u8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE];
+	u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE];
+	u8 fec_capable;
+	/* source rates */
+	int num_source_rates;
+	const int *source_rates;
+	/* sink rates as reported by DP_MAX_LINK_RATE/DP_SUPPORTED_LINK_RATES */
+	int num_sink_rates;
+	int sink_rates[DP_MAX_SUPPORTED_RATES];
+	bool use_rate_select;
+	/* intersection of source and sink rates */
+	int num_common_rates;
+	int common_rates[DP_MAX_SUPPORTED_RATES];
+	/* Max lane count for the current link */
+	int max_link_lane_count;
+	/* Max rate for the current link */
+	int max_link_rate;
+	/* sink or branch descriptor */
+	struct drm_dp_desc desc;
+	struct drm_dp_aux aux;
+	u8 train_set[4];
+	int panel_power_up_delay;
+	int panel_power_down_delay;
+	int panel_power_cycle_delay;
+	int backlight_on_delay;
+	int backlight_off_delay;
+	struct delayed_work panel_vdd_work;
+	bool want_panel_vdd;
+	unsigned long last_power_on;
+	unsigned long last_backlight_off;
+	ktime_t panel_power_off_time;
+
+	struct notifier_block edp_notifier;
+
+	/*
+	 * Pipe whose power sequencer is currently locked into
+	 * this port. Only relevant on VLV/CHV.
+	 */
+	enum pipe pps_pipe;
+	/*
+	 * Pipe currently driving the port. Used for preventing
+	 * the use of the PPS for any pipe currentrly driving
+	 * external DP as that will mess things up on VLV.
+	 */
+	enum pipe active_pipe;
+	/*
+	 * Set if the sequencer may be reset due to a power transition,
+	 * requiring a reinitialization. Only relevant on BXT.
+	 */
+	bool pps_reset;
+	struct edp_power_seq pps_delays;
+
+	bool can_mst; /* this port supports mst */
+	bool is_mst;
+	int active_mst_links;
+	/* connector directly attached - won't be use for modeset in mst world */
+	struct intel_connector *attached_connector;
+
+	/* mst connector list */
+	struct intel_dp_mst_encoder *mst_encoders[I915_MAX_PIPES];
+	struct drm_dp_mst_topology_mgr mst_mgr;
+
+	u32 (*get_aux_clock_divider)(struct intel_dp *dp, int index);
+	/*
+	 * This function returns the value we have to program the AUX_CTL
+	 * register with to kick off an AUX transaction.
+	 */
+	u32 (*get_aux_send_ctl)(struct intel_dp *dp, int send_bytes,
+				u32 aux_clock_divider);
+
+	i915_reg_t (*aux_ch_ctl_reg)(struct intel_dp *dp);
+	i915_reg_t (*aux_ch_data_reg)(struct intel_dp *dp, int index);
+
+	/* This is called before a link training is starterd */
+	void (*prepare_link_retrain)(struct intel_dp *intel_dp);
+
+	/* Displayport compliance testing */
+	struct intel_dp_compliance compliance;
+
+	/* Display stream compression testing */
+	bool force_dsc_en;
+};
+
+enum lspcon_vendor {
+	LSPCON_VENDOR_MCA,
+	LSPCON_VENDOR_PARADE
+};
+
+struct intel_lspcon {
+	bool active;
+	enum drm_lspcon_mode mode;
+	enum lspcon_vendor vendor;
+};
+
+struct intel_digital_port {
+	struct intel_encoder base;
+	u32 saved_port_bits;
+	struct intel_dp dp;
+	struct intel_hdmi hdmi;
+	struct intel_lspcon lspcon;
+	enum irqreturn (*hpd_pulse)(struct intel_digital_port *, bool);
+	bool release_cl2_override;
+	u8 max_lanes;
+	/* Used for DP and ICL+ TypeC/DP and TypeC/HDMI ports. */
+	enum aux_ch aux_ch;
+	enum intel_display_power_domain ddi_io_power_domain;
+	struct mutex tc_lock;	/* protects the TypeC port mode */
+	intel_wakeref_t tc_lock_wakeref;
+	int tc_link_refcount;
+	bool tc_legacy_port:1;
+	char tc_port_name[8];
+	enum tc_port_mode tc_mode;
+	enum phy_fia tc_phy_fia;
+
+	void (*write_infoframe)(struct intel_encoder *encoder,
+				const struct intel_crtc_state *crtc_state,
+				unsigned int type,
+				const void *frame, ssize_t len);
+	void (*read_infoframe)(struct intel_encoder *encoder,
+			       const struct intel_crtc_state *crtc_state,
+			       unsigned int type,
+			       void *frame, ssize_t len);
+	void (*set_infoframes)(struct intel_encoder *encoder,
+			       bool enable,
+			       const struct intel_crtc_state *crtc_state,
+			       const struct drm_connector_state *conn_state);
+	u32 (*infoframes_enabled)(struct intel_encoder *encoder,
+				  const struct intel_crtc_state *pipe_config);
+};
+
+struct intel_dp_mst_encoder {
+	struct intel_encoder base;
+	enum pipe pipe;
+	struct intel_digital_port *primary;
+	struct intel_connector *connector;
+};
+
+static inline enum dpio_channel
+vlv_dport_to_channel(struct intel_digital_port *dport)
+{
+	switch (dport->base.port) {
+	case PORT_B:
+	case PORT_D:
+		return DPIO_CH0;
+	case PORT_C:
+		return DPIO_CH1;
+	default:
+		BUG();
+	}
+}
+
+static inline enum dpio_phy
+vlv_dport_to_phy(struct intel_digital_port *dport)
+{
+	switch (dport->base.port) {
+	case PORT_B:
+	case PORT_C:
+		return DPIO_PHY0;
+	case PORT_D:
+		return DPIO_PHY1;
+	default:
+		BUG();
+	}
+}
+
+static inline enum dpio_channel
+vlv_pipe_to_channel(enum pipe pipe)
+{
+	switch (pipe) {
+	case PIPE_A:
+	case PIPE_C:
+		return DPIO_CH0;
+	case PIPE_B:
+		return DPIO_CH1;
+	default:
+		BUG();
+	}
+}
+
+static inline struct intel_crtc *
+intel_get_crtc_for_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)
+{
+	return dev_priv->pipe_to_crtc_mapping[pipe];
+}
+
+static inline struct intel_crtc *
+intel_get_crtc_for_plane(struct drm_i915_private *dev_priv, enum i9xx_plane_id plane)
+{
+	return dev_priv->plane_to_crtc_mapping[plane];
+}
+
+struct intel_load_detect_pipe {
+	struct drm_atomic_state *restore_state;
+};
+
+static inline struct intel_encoder *
+intel_attached_encoder(struct drm_connector *connector)
+{
+	return to_intel_connector(connector)->encoder;
+}
+
+static inline bool intel_encoder_is_dig_port(struct intel_encoder *encoder)
+{
+	switch (encoder->type) {
+	case INTEL_OUTPUT_DDI:
+	case INTEL_OUTPUT_DP:
+	case INTEL_OUTPUT_EDP:
+	case INTEL_OUTPUT_HDMI:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline struct intel_digital_port *
+enc_to_dig_port(struct drm_encoder *encoder)
+{
+	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
+
+	if (intel_encoder_is_dig_port(intel_encoder))
+		return container_of(encoder, struct intel_digital_port,
+				    base.base);
+	else
+		return NULL;
+}
+
+static inline struct intel_digital_port *
+conn_to_dig_port(struct intel_connector *connector)
+{
+	return enc_to_dig_port(&intel_attached_encoder(&connector->base)->base);
+}
+
+static inline struct intel_dp_mst_encoder *
+enc_to_mst(struct drm_encoder *encoder)
+{
+	return container_of(encoder, struct intel_dp_mst_encoder, base.base);
+}
+
+static inline struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder)
+{
+	return &enc_to_dig_port(encoder)->dp;
+}
+
+static inline bool intel_encoder_is_dp(struct intel_encoder *encoder)
+{
+	switch (encoder->type) {
+	case INTEL_OUTPUT_DP:
+	case INTEL_OUTPUT_EDP:
+		return true;
+	case INTEL_OUTPUT_DDI:
+		/* Skip pure HDMI/DVI DDI encoders */
+		return i915_mmio_reg_valid(enc_to_intel_dp(&encoder->base)->output_reg);
+	default:
+		return false;
+	}
+}
+
+static inline struct intel_lspcon *
+enc_to_intel_lspcon(struct drm_encoder *encoder)
+{
+	return &enc_to_dig_port(encoder)->lspcon;
+}
+
+static inline struct intel_digital_port *
+dp_to_dig_port(struct intel_dp *intel_dp)
+{
+	return container_of(intel_dp, struct intel_digital_port, dp);
+}
+
+static inline struct intel_lspcon *
+dp_to_lspcon(struct intel_dp *intel_dp)
+{
+	return &dp_to_dig_port(intel_dp)->lspcon;
+}
+
+static inline struct drm_i915_private *
+dp_to_i915(struct intel_dp *intel_dp)
+{
+	return to_i915(dp_to_dig_port(intel_dp)->base.base.dev);
+}
+
+static inline struct intel_digital_port *
+hdmi_to_dig_port(struct intel_hdmi *intel_hdmi)
+{
+	return container_of(intel_hdmi, struct intel_digital_port, hdmi);
+}
+
+static inline struct intel_plane_state *
+intel_atomic_get_plane_state(struct intel_atomic_state *state,
+				 struct intel_plane *plane)
+{
+	struct drm_plane_state *ret =
+		drm_atomic_get_plane_state(&state->base, &plane->base);
+
+	if (IS_ERR(ret))
+		return ERR_CAST(ret);
+
+	return to_intel_plane_state(ret);
+}
+
+static inline struct intel_plane_state *
+intel_atomic_get_old_plane_state(struct intel_atomic_state *state,
+				 struct intel_plane *plane)
+{
+	return to_intel_plane_state(drm_atomic_get_old_plane_state(&state->base,
+								   &plane->base));
+}
+
+static inline struct intel_plane_state *
+intel_atomic_get_new_plane_state(struct intel_atomic_state *state,
+				 struct intel_plane *plane)
+{
+	return to_intel_plane_state(drm_atomic_get_new_plane_state(&state->base,
+								   &plane->base));
+}
+
+static inline struct intel_crtc_state *
+intel_atomic_get_old_crtc_state(struct intel_atomic_state *state,
+				struct intel_crtc *crtc)
+{
+	return to_intel_crtc_state(drm_atomic_get_old_crtc_state(&state->base,
+								 &crtc->base));
+}
+
+static inline struct intel_crtc_state *
+intel_atomic_get_new_crtc_state(struct intel_atomic_state *state,
+				struct intel_crtc *crtc)
+{
+	return to_intel_crtc_state(drm_atomic_get_new_crtc_state(&state->base,
+								 &crtc->base));
+}
+
+/* intel_display.c */
+static inline bool
+intel_crtc_has_type(const struct intel_crtc_state *crtc_state,
+		    enum intel_output_type type)
+{
+	return crtc_state->output_types & (1 << type);
+}
+static inline bool
+intel_crtc_has_dp_encoder(const struct intel_crtc_state *crtc_state)
+{
+	return crtc_state->output_types &
+		((1 << INTEL_OUTPUT_DP) |
+		 (1 << INTEL_OUTPUT_DP_MST) |
+		 (1 << INTEL_OUTPUT_EDP));
+}
+static inline void
+intel_wait_for_vblank(struct drm_i915_private *dev_priv, enum pipe pipe)
+{
+	drm_wait_one_vblank(&dev_priv->drm, pipe);
+}
+static inline void
+intel_wait_for_vblank_if_active(struct drm_i915_private *dev_priv, int pipe)
+{
+	const struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
+
+	if (crtc->active)
+		intel_wait_for_vblank(dev_priv, pipe);
+}
+
+static inline u32 intel_plane_ggtt_offset(const struct intel_plane_state *state)
+{
+	return i915_ggtt_offset(state->vma);
+}
+
+#endif /*  __INTEL_DISPLAY_TYPES_H__ */
