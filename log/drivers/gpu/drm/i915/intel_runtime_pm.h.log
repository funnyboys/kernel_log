commit ed32f8d42cee118b075e4372a55c7739a11094b2
Merge: 60a4233a4952 5f9e832c1370
Author: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date:   Mon Jul 29 08:51:48 2019 -0700

    Merge drm/drm-next into drm-intel-next-queued
    
    Catching up with 5.3-rc*
    
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 3b58a94551368924d8a49baa349bc7694fbd7ddd
Author: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Date:   Fri Jul 12 13:24:28 2019 +0200

    drm/i915: Propagate "_release" function name suffix down
    
    Replace mixed "_fini"/"_cleanup"/"_cleanup_hw" suffixes found in names
    of functions called from i915_driver_release() with "_release" suffix
    consistently.  This provides better code readability, especially
    helpful when trying to work out which phase the code is in.
    
    Functions names starting with "i915_driver_", i.e., those defined in
    drivers/gpu/dri/i915/i915_drv.c, just have their "cleanup" or "fini"
    parts of their names replaced with the "_release" suffix, while names
    of functions coming from other source files have been suffixed with
    "_driver_release" to avoid ambiguity with other possible .release entry
    points.
    
    v2: early_probe pairs better with late_release (Chris)
    v3: fix typo in commit message (Joonas)
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190712112429.740-5-janusz.krzysztofik@linux.intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 473c4850c01d..89f8d284239a 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -173,7 +173,7 @@ enable_rpm_wakeref_asserts(struct intel_runtime_pm *rpm)
 void intel_runtime_pm_init_early(struct intel_runtime_pm *rpm);
 void intel_runtime_pm_enable(struct intel_runtime_pm *rpm);
 void intel_runtime_pm_disable(struct intel_runtime_pm *rpm);
-void intel_runtime_pm_cleanup(struct intel_runtime_pm *rpm);
+void intel_runtime_pm_driver_release(struct intel_runtime_pm *rpm);
 
 intel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm);

commit df0566a641f959108c152be748a0a58794280e0e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Jun 13 11:44:16 2019 +0300

    drm/i915: move modesetting core code under display/
    
    Now that we have a new subdirectory for display code, continue by moving
    modesetting core code.
    
    display/intel_frontbuffer.h sticks out like a sore thumb, otherwise this
    is, again, a surprisingly clean operation.
    
    v2:
    - don't move intel_sideband.[ch] (Ville)
    - use tabs for Makefile file lists and sort them
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613084416.6794-3-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index f2d6299a8161..473c4850c01d 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -8,7 +8,8 @@
 
 #include <linux/types.h>
 
-#include "intel_display.h"
+#include "display/intel_display.h"
+
 #include "intel_wakeref.h"
 
 #include "i915_utils.h"

commit c447ff7db34807082dcabbdcbbba2445b49211d9
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:55 2019 -0700

    drm/i915: update with_intel_runtime_pm to use the rpm structure
    
    Matching the underlying get/put functions.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-8-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index f6445ca5bbf1..f2d6299a8161 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -179,13 +179,13 @@ intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_noresume(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_raw(struct intel_runtime_pm *rpm);
 
-#define with_intel_runtime_pm(i915, wf) \
-	for ((wf) = intel_runtime_pm_get(&(i915)->runtime_pm); (wf); \
-	     intel_runtime_pm_put(&(i915)->runtime_pm, (wf)), (wf) = 0)
+#define with_intel_runtime_pm(rpm, wf) \
+	for ((wf) = intel_runtime_pm_get(rpm); (wf); \
+	     intel_runtime_pm_put((rpm), (wf)), (wf) = 0)
 
-#define with_intel_runtime_pm_if_in_use(i915, wf) \
-	for ((wf) = intel_runtime_pm_get_if_in_use(&(i915)->runtime_pm); (wf); \
-	     intel_runtime_pm_put(&(i915)->runtime_pm, (wf)), (wf) = 0)
+#define with_intel_runtime_pm_if_in_use(rpm, wf) \
+	for ((wf) = intel_runtime_pm_get_if_in_use(rpm); (wf); \
+	     intel_runtime_pm_put((rpm), (wf)), (wf) = 0)
 
 void intel_runtime_pm_put_unchecked(struct intel_runtime_pm *rpm);
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)

commit d858d5695f3897d55df68452066a90d7560cb845
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:54 2019 -0700

    drm/i915: update rpm_get/put to use the rpm structure
    
    The functions where internally already only using the structure, so we
    need to just flip the interface.
    
    v2: rebase
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-7-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 0890e698f196..f6445ca5bbf1 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -174,30 +174,30 @@ void intel_runtime_pm_enable(struct intel_runtime_pm *rpm);
 void intel_runtime_pm_disable(struct intel_runtime_pm *rpm);
 void intel_runtime_pm_cleanup(struct intel_runtime_pm *rpm);
 
-intel_wakeref_t intel_runtime_pm_get(struct drm_i915_private *i915);
-intel_wakeref_t intel_runtime_pm_get_if_in_use(struct drm_i915_private *i915);
-intel_wakeref_t intel_runtime_pm_get_noresume(struct drm_i915_private *i915);
-intel_wakeref_t intel_runtime_pm_get_raw(struct drm_i915_private *i915);
+intel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm);
+intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm);
+intel_wakeref_t intel_runtime_pm_get_noresume(struct intel_runtime_pm *rpm);
+intel_wakeref_t intel_runtime_pm_get_raw(struct intel_runtime_pm *rpm);
 
 #define with_intel_runtime_pm(i915, wf) \
-	for ((wf) = intel_runtime_pm_get(i915); (wf); \
-	     intel_runtime_pm_put((i915), (wf)), (wf) = 0)
+	for ((wf) = intel_runtime_pm_get(&(i915)->runtime_pm); (wf); \
+	     intel_runtime_pm_put(&(i915)->runtime_pm, (wf)), (wf) = 0)
 
 #define with_intel_runtime_pm_if_in_use(i915, wf) \
-	for ((wf) = intel_runtime_pm_get_if_in_use(i915); (wf); \
-	     intel_runtime_pm_put((i915), (wf)), (wf) = 0)
+	for ((wf) = intel_runtime_pm_get_if_in_use(&(i915)->runtime_pm); (wf); \
+	     intel_runtime_pm_put(&(i915)->runtime_pm, (wf)), (wf) = 0)
 
-void intel_runtime_pm_put_unchecked(struct drm_i915_private *i915);
+void intel_runtime_pm_put_unchecked(struct intel_runtime_pm *rpm);
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
-void intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref);
+void intel_runtime_pm_put(struct intel_runtime_pm *rpm, intel_wakeref_t wref);
 #else
 static inline void
-intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref)
+intel_runtime_pm_put(struct intel_runtime_pm *rpm, intel_wakeref_t wref)
 {
-	intel_runtime_pm_put_unchecked(i915);
+	intel_runtime_pm_put_unchecked(rpm);
 }
 #endif
-void intel_runtime_pm_put_raw(struct drm_i915_private *i915, intel_wakeref_t wref);
+void intel_runtime_pm_put_raw(struct intel_runtime_pm *rpm, intel_wakeref_t wref);
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
 void print_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,

commit 69c663554452e6589144046331d08e597e7f5823
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:53 2019 -0700

    drm/i915: move a few more functions to accept the rpm structure
    
    Focusing on the functions called in few places.
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-6-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 40c6530af5bb..0890e698f196 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -169,10 +169,10 @@ enable_rpm_wakeref_asserts(struct intel_runtime_pm *rpm)
 		   &rpm->wakeref_count);
 }
 
-void intel_runtime_pm_init_early(struct drm_i915_private *dev_priv);
-void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);
-void intel_runtime_pm_disable(struct drm_i915_private *dev_priv);
-void intel_runtime_pm_cleanup(struct drm_i915_private *dev_priv);
+void intel_runtime_pm_init_early(struct intel_runtime_pm *rpm);
+void intel_runtime_pm_enable(struct intel_runtime_pm *rpm);
+void intel_runtime_pm_disable(struct intel_runtime_pm *rpm);
+void intel_runtime_pm_cleanup(struct intel_runtime_pm *rpm);
 
 intel_wakeref_t intel_runtime_pm_get(struct drm_i915_private *i915);
 intel_wakeref_t intel_runtime_pm_get_if_in_use(struct drm_i915_private *i915);
@@ -200,10 +200,10 @@ intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref)
 void intel_runtime_pm_put_raw(struct drm_i915_private *i915, intel_wakeref_t wref);
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
-void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
+void print_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,
 				    struct drm_printer *p);
 #else
-static inline void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
+static inline void print_intel_runtime_pm_wakeref(struct intel_runtime_pm *rpm,
 						  struct drm_printer *p)
 {
 }

commit 1bf676cc2dbaeec7a52ea93e71660f746123c2fe
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Thu Jun 13 16:21:52 2019 -0700

    drm/i915: move and rename i915_runtime_pm
    
    Asserts aside, all the code working on this structure is in
    intel_runtime_pm.c and uses the intel_ prefix, so move the
    structure to intel_runtime_pm.h and adopt the same prefix.
    
    Since all the asserts are now working on the runtime_pm structure,
    bring them across as well.
    
    v2: drop unneeded include (Chris), don't rename debugfs, rebase
    
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613232156.34940-5-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index a7acceb13473..40c6530af5bb 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -11,6 +11,9 @@
 #include "intel_display.h"
 #include "intel_wakeref.h"
 
+#include "i915_utils.h"
+
+struct device;
 struct drm_i915_private;
 struct drm_printer;
 
@@ -20,6 +23,152 @@ enum i915_drm_suspend_mode {
 	I915_DRM_SUSPEND_HIBERNATE,
 };
 
+/*
+ * This struct helps tracking the state needed for runtime PM, which puts the
+ * device in PCI D3 state. Notice that when this happens, nothing on the
+ * graphics device works, even register access, so we don't get interrupts nor
+ * anything else.
+ *
+ * Every piece of our code that needs to actually touch the hardware needs to
+ * either call intel_runtime_pm_get or call intel_display_power_get with the
+ * appropriate power domain.
+ *
+ * Our driver uses the autosuspend delay feature, which means we'll only really
+ * suspend if we stay with zero refcount for a certain amount of time. The
+ * default value is currently very conservative (see intel_runtime_pm_enable), but
+ * it can be changed with the standard runtime PM files from sysfs.
+ *
+ * The irqs_disabled variable becomes true exactly after we disable the IRQs and
+ * goes back to false exactly before we reenable the IRQs. We use this variable
+ * to check if someone is trying to enable/disable IRQs while they're supposed
+ * to be disabled. This shouldn't happen and we'll print some error messages in
+ * case it happens.
+ *
+ * For more, read the Documentation/power/runtime_pm.txt.
+ */
+struct intel_runtime_pm {
+	atomic_t wakeref_count;
+	struct device *kdev; /* points to i915->drm.pdev->dev */
+	bool available;
+	bool suspended;
+	bool irqs_enabled;
+
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+	/*
+	 * To aide detection of wakeref leaks and general misuse, we
+	 * track all wakeref holders. With manual markup (i.e. returning
+	 * a cookie to each rpm_get caller which they then supply to their
+	 * paired rpm_put) we can remove corresponding pairs of and keep
+	 * the array trimmed to active wakerefs.
+	 */
+	struct intel_runtime_pm_debug {
+		spinlock_t lock;
+
+		depot_stack_handle_t last_acquire;
+		depot_stack_handle_t last_release;
+
+		depot_stack_handle_t *owners;
+		unsigned long count;
+	} debug;
+#endif
+};
+
+#define BITS_PER_WAKEREF	\
+	BITS_PER_TYPE(struct_member(struct intel_runtime_pm, wakeref_count))
+#define INTEL_RPM_WAKELOCK_SHIFT	(BITS_PER_WAKEREF / 2)
+#define INTEL_RPM_WAKELOCK_BIAS		(1 << INTEL_RPM_WAKELOCK_SHIFT)
+#define INTEL_RPM_RAW_WAKEREF_MASK	(INTEL_RPM_WAKELOCK_BIAS - 1)
+
+static inline int
+intel_rpm_raw_wakeref_count(int wakeref_count)
+{
+	return wakeref_count & INTEL_RPM_RAW_WAKEREF_MASK;
+}
+
+static inline int
+intel_rpm_wakelock_count(int wakeref_count)
+{
+	return wakeref_count >> INTEL_RPM_WAKELOCK_SHIFT;
+}
+
+static inline void
+assert_rpm_device_not_suspended(struct intel_runtime_pm *rpm)
+{
+	WARN_ONCE(rpm->suspended,
+		  "Device suspended during HW access\n");
+}
+
+static inline void
+__assert_rpm_raw_wakeref_held(struct intel_runtime_pm *rpm, int wakeref_count)
+{
+	assert_rpm_device_not_suspended(rpm);
+	WARN_ONCE(!intel_rpm_raw_wakeref_count(wakeref_count),
+		  "RPM raw-wakeref not held\n");
+}
+
+static inline void
+__assert_rpm_wakelock_held(struct intel_runtime_pm *rpm, int wakeref_count)
+{
+	__assert_rpm_raw_wakeref_held(rpm, wakeref_count);
+	WARN_ONCE(!intel_rpm_wakelock_count(wakeref_count),
+		  "RPM wakelock ref not held during HW access\n");
+}
+
+static inline void
+assert_rpm_raw_wakeref_held(struct intel_runtime_pm *rpm)
+{
+	__assert_rpm_raw_wakeref_held(rpm, atomic_read(&rpm->wakeref_count));
+}
+
+static inline void
+assert_rpm_wakelock_held(struct intel_runtime_pm *rpm)
+{
+	__assert_rpm_wakelock_held(rpm, atomic_read(&rpm->wakeref_count));
+}
+
+/**
+ * disable_rpm_wakeref_asserts - disable the RPM assert checks
+ * @rpm: the intel_runtime_pm structure
+ *
+ * This function disable asserts that check if we hold an RPM wakelock
+ * reference, while keeping the device-not-suspended checks still enabled.
+ * It's meant to be used only in special circumstances where our rule about
+ * the wakelock refcount wrt. the device power state doesn't hold. According
+ * to this rule at any point where we access the HW or want to keep the HW in
+ * an active state we must hold an RPM wakelock reference acquired via one of
+ * the intel_runtime_pm_get() helpers. Currently there are a few special spots
+ * where this rule doesn't hold: the IRQ and suspend/resume handlers, the
+ * forcewake release timer, and the GPU RPS and hangcheck works. All other
+ * users should avoid using this function.
+ *
+ * Any calls to this function must have a symmetric call to
+ * enable_rpm_wakeref_asserts().
+ */
+static inline void
+disable_rpm_wakeref_asserts(struct intel_runtime_pm *rpm)
+{
+	atomic_add(INTEL_RPM_WAKELOCK_BIAS + 1,
+		   &rpm->wakeref_count);
+}
+
+/**
+ * enable_rpm_wakeref_asserts - re-enable the RPM assert checks
+ * @rpm: the intel_runtime_pm structure
+ *
+ * This function re-enables the RPM assert checks after disabling them with
+ * disable_rpm_wakeref_asserts. It's meant to be used only in special
+ * circumstances otherwise its use should be avoided.
+ *
+ * Any calls to this function must have a symmetric call to
+ * disable_rpm_wakeref_asserts().
+ */
+static inline void
+enable_rpm_wakeref_asserts(struct intel_runtime_pm *rpm)
+{
+	atomic_sub(INTEL_RPM_WAKELOCK_BIAS + 1,
+		   &rpm->wakeref_count);
+}
+
 void intel_runtime_pm_init_early(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_disable(struct drm_i915_private *dev_priv);

commit 7645b19d9bdd13ef3e32ab3a040b017f9d71f911
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Fri May 31 15:24:08 2019 -0700

    drm/i915: extract intel_display_power.h/c from intel_runtime_pm.h/c
    
    Keep all the device-level PM management in intel_runtime_pm.h/c and move
    all the display specific bits into their own file. Also add the new
    header to Makefile.header-test.
    
    Apart from the giant code move, the only difference is with the
    intel_runtime_<get/put>_raw() functions, which are now exposed in the
    header. The _put() version is also not conditionally compiled anymore
    since it is ok to always pass the wakeref taken from the _get() to
    __intel_runtime_pm_put (it is -1 if tracking is disabled).
    
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190531222409.9177-2-daniele.ceraolospurio@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 0a4c4b3aee7d..a7acceb13473 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -13,7 +13,6 @@
 
 struct drm_i915_private;
 struct drm_printer;
-struct intel_encoder;
 
 enum i915_drm_suspend_mode {
 	I915_DRM_SUSPEND_IDLE,
@@ -21,89 +20,15 @@ enum i915_drm_suspend_mode {
 	I915_DRM_SUSPEND_HIBERNATE,
 };
 
-void skl_enable_dc6(struct drm_i915_private *dev_priv);
-void gen9_sanitize_dc_state(struct drm_i915_private *dev_priv);
-void bxt_enable_dc9(struct drm_i915_private *dev_priv);
-void bxt_disable_dc9(struct drm_i915_private *dev_priv);
-void gen9_enable_dc5(struct drm_i915_private *dev_priv);
-
 void intel_runtime_pm_init_early(struct drm_i915_private *dev_priv);
-int intel_power_domains_init(struct drm_i915_private *);
-void intel_power_domains_cleanup(struct drm_i915_private *dev_priv);
-void intel_power_domains_init_hw(struct drm_i915_private *dev_priv, bool resume);
-void intel_power_domains_fini_hw(struct drm_i915_private *dev_priv);
-void icl_display_core_init(struct drm_i915_private *dev_priv, bool resume);
-void icl_display_core_uninit(struct drm_i915_private *dev_priv);
-void intel_power_domains_enable(struct drm_i915_private *dev_priv);
-void intel_power_domains_disable(struct drm_i915_private *dev_priv);
-void intel_power_domains_suspend(struct drm_i915_private *dev_priv,
-				 enum i915_drm_suspend_mode);
-void intel_power_domains_resume(struct drm_i915_private *dev_priv);
-void hsw_enable_pc8(struct drm_i915_private *dev_priv);
-void hsw_disable_pc8(struct drm_i915_private *dev_priv);
-void bxt_display_core_init(struct drm_i915_private *dev_priv, bool resume);
-void bxt_display_core_uninit(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_disable(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_cleanup(struct drm_i915_private *dev_priv);
 
-const char *
-intel_display_power_domain_str(enum intel_display_power_domain domain);
-
-bool intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
-				    enum intel_display_power_domain domain);
-bool __intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
-				      enum intel_display_power_domain domain);
-intel_wakeref_t intel_display_power_get(struct drm_i915_private *dev_priv,
-					enum intel_display_power_domain domain);
-intel_wakeref_t
-intel_display_power_get_if_enabled(struct drm_i915_private *dev_priv,
-				   enum intel_display_power_domain domain);
-void intel_display_power_put_unchecked(struct drm_i915_private *dev_priv,
-				       enum intel_display_power_domain domain);
-void __intel_display_power_put_async(struct drm_i915_private *i915,
-				     enum intel_display_power_domain domain,
-				     intel_wakeref_t wakeref);
-void intel_display_power_flush_work(struct drm_i915_private *i915);
-#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
-void intel_display_power_put(struct drm_i915_private *dev_priv,
-			     enum intel_display_power_domain domain,
-			     intel_wakeref_t wakeref);
-static inline void
-intel_display_power_put_async(struct drm_i915_private *i915,
-			      enum intel_display_power_domain domain,
-			      intel_wakeref_t wakeref)
-{
-	__intel_display_power_put_async(i915, domain, wakeref);
-}
-#else
-static inline void
-intel_display_power_put(struct drm_i915_private *i915,
-			enum intel_display_power_domain domain,
-			intel_wakeref_t wakeref)
-{
-	intel_display_power_put_unchecked(i915, domain);
-}
-
-static inline void
-intel_display_power_put_async(struct drm_i915_private *i915,
-			      enum intel_display_power_domain domain,
-			      intel_wakeref_t wakeref)
-{
-	__intel_display_power_put_async(i915, domain, -1);
-}
-#endif
-
-#define with_intel_display_power(i915, domain, wf) \
-	for ((wf) = intel_display_power_get((i915), (domain)); (wf); \
-	     intel_display_power_put_async((i915), (domain), (wf)), (wf) = 0)
-
-void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
-			    u8 req_slices);
-
 intel_wakeref_t intel_runtime_pm_get(struct drm_i915_private *i915);
 intel_wakeref_t intel_runtime_pm_get_if_in_use(struct drm_i915_private *i915);
 intel_wakeref_t intel_runtime_pm_get_noresume(struct drm_i915_private *i915);
+intel_wakeref_t intel_runtime_pm_get_raw(struct drm_i915_private *i915);
 
 #define with_intel_runtime_pm(i915, wf) \
 	for ((wf) = intel_runtime_pm_get(i915); (wf); \
@@ -123,6 +48,7 @@ intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref)
 	intel_runtime_pm_put_unchecked(i915);
 }
 #endif
+void intel_runtime_pm_put_raw(struct drm_i915_private *i915, intel_wakeref_t wref);
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
 void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
@@ -134,9 +60,4 @@ static inline void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
 }
 #endif
 
-void chv_phy_powergate_lanes(struct intel_encoder *encoder,
-			     bool override, unsigned int mask);
-bool chv_phy_powergate_ch(struct drm_i915_private *dev_priv, enum dpio_phy phy,
-			  enum dpio_channel ch, bool override);
-
 #endif /* __INTEL_RUNTIME_PM_H__ */

commit 09a93ef3d60f5a439613cd6a806bba265c3663ed
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 22 13:35:05 2019 +0300

    drm/i915: remove duplicate typedef for intel_wakeref_t
    
    Fix the duplicate typedef for intel_wakeref_t leading to Clang build
    issues. While at it, actually make the intel_runtime_pm.h header
    self-contained, which was claimed in the commit being fixed.
    
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    References: http://mid.mail-archive.com/20190521183850.GA9157@archlinux-epyc
    References: https://travis-ci.com/ClangBuiltLinux/continuous-integration/jobs/201754420#L2435
    Fixes: 0d5adc5f2f01 ("drm/i915: extract intel_runtime_pm.h from intel_drv.h")
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190522103505.2082-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index b964ca7af9c8..0a4c4b3aee7d 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -6,12 +6,14 @@
 #ifndef __INTEL_RUNTIME_PM_H__
 #define __INTEL_RUNTIME_PM_H__
 
-#include <linux/stackdepot.h>
 #include <linux/types.h>
 
-struct drm_i915_private;
+#include "intel_display.h"
+#include "intel_wakeref.h"
 
-typedef depot_stack_handle_t intel_wakeref_t;
+struct drm_i915_private;
+struct drm_printer;
+struct intel_encoder;
 
 enum i915_drm_suspend_mode {
 	I915_DRM_SUSPEND_IDLE,

commit 6cfe7ec02e854278fb341e62db54d49a2b199c62
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu May 9 20:34:42 2019 +0300

    drm/i915: Remove the unneeded AUX power ref from intel_dp_detect()
    
    We don't need the AUX power for the whole duration of the detect, only
    when we're doing AUX transfers. The AUX transfer function takes its own
    reference on the AUX power domain already. The two places during detect
    which access display core registers (not specific to a
    pipe/port/transcoder) only need the power domain that is required for
    that access. That power domain is equivalent to the device global power
    domain on most platforms (enabled whenever we hold a runtime PM
    reference) except on CHV/VLV where it's equivalent to the display power
    well.
    
    Add a new power domain that reflects the above, and use this at the two
    spots accessing registers. With that we can avoid taking the AUX
    reference for the whole duration of the detect function.
    
    Put the domains asynchronously to avoid the unneeded on-off-on toggling.
    
    Also adapt the idea from with_intel_runtime_pm et al. for making it easy
    to write short sequences where a display power ref is needed.
    
    v2: (Ville)
    - Add with_intel_display_power() helper to simplify things.
    - s/bool res/bool is_connected/
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190509173446.31095-8-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 56ad79ef0806..b964ca7af9c8 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -91,6 +91,11 @@ intel_display_power_put_async(struct drm_i915_private *i915,
 	__intel_display_power_put_async(i915, domain, -1);
 }
 #endif
+
+#define with_intel_display_power(i915, domain, wf) \
+	for ((wf) = intel_display_power_get((i915), (domain)); (wf); \
+	     intel_display_power_put_async((i915), (domain), (wf)), (wf) = 0)
+
 void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
 			    u8 req_slices);
 

commit e0da2d63ab3ac746d61b8861085fd3abbef011c6
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon May 13 22:25:33 2019 +0300

    drm/i915: Add support for asynchronous display power disabling
    
    By disabling a power domain asynchronously we can restrict holding a
    reference on that power domain to the actual code sequence that
    requires the power to be on for the HW access it's doing, by also
    avoiding unneeded on-off-on togglings of the power domain (since the
    disabling happens with a delay).
    
    One benefit is potential power saving due to the following two reasons:
    1. The fact that we will now be holding the reference only for the
       necessary duration by the end of the patchset. While simply not
       delaying the disabling has the same benefit, it has the problem that
       frequent on-off-on power switching has its own power cost (see the 2.
       point below) and the debug trace for power well on/off events will
       cause a lot of dmesg spam (see details about this further below).
    2. Avoiding the power cost of freuqent on-off-on power switching. This
       requires us to find the optimal disabling delay based on the measured
       power cost of on->off and off->on switching of each power well vs.
       the power of keeping the given power well on.
    
       In this patchset I'm not providing this optimal delay for two
       reasons:
       a) I don't have the means yet to perform the measurement (with high
          enough signal-to-noise ratio, or with the help of an energy
          counter that takes switching into account). I'm currently looking
          for a way to measure this.
    
       b) Before reducing the disabling delay we need an alternative way for
          debug tracing powerwell on/off events. Simply avoiding/throttling
          the debug messages is not a solution, see further below.
    
       Note that even in the case where we can't measure any considerable
       power cost of frequent on-off switching of powerwells, it still would
       make sense to do the disabling asynchronously (with 0 delay) to avoid
       blocking on the disabling. On VLV I measured this disabling time
       overhead to be 1ms on average with a worst case of 4ms.
    
    In the case of the AUX power domains on ICL we would also need to keep
    the sequence where we hold the power reference short, the way it would
    be by the end of this patchset where we hold it only for the actual AUX
    transfer. Anything else would make the locking we need for ICL TypeC
    ports (whenever we hold a reference on any AUX power domain) rather
    problematic, adding for instance unnecessary lockdep dependencies to
    the required TypeC port lock.
    
    I chose the disabling delay to be 100msec for now to avoid the unneeded
    toggling (and so not to introduce dmesg spamming) in the DP MST sideband
    signaling code. We could optimize this delay later, once we have the
    means to measure the switching power cost (see above).
    
    Note that simply removing/throttling the debug tracing for power well
    on/off events is not a solution. We need to know the exact spots of
    these events and cannot rely only on incorrect register accesses caught
    (due to not holding a wakeref at the time of access). Incorrect
    powerwell enabling/disabling could lead to other problems, for instance
    we need to keep certain powerwells enabled for the duration of modesets
    and AUX transfers.
    
    v2:
    - Clarify the commit log parts about power cost measurement and the
      problem of simply removing/throttling debug tracing. (Chris)
    - Optimize out local wakeref vars at intel_runtime_pm_put_raw() and
      intel_display_power_put_async() call sites if
      CONFIG_DRM_I915_DEBUG_RUNTIME_PM=n. (Chris)
    - Rebased on v2 of the wakeref w/o power-on guarantee patch.
    - Add missing docbook headers.
    v3:
    - Checkpatch spelling/missing-empty-line fix.
    v4:
    - Fix unintended local wakeref var optimization when using
      call-arguments with side-effects, by using inline funcs instead of
      macros. In this patch in particular this will fix the
      intel_display_power_grab_async_put_ref()->intel_runtime_pm_put_raw()
      call).
    
      No size change in practice (would be the same disregarding the
      corresponding change in intel_display_power_grab_async_put_ref()):
      $ size i915-macro.ko
         text          data     bss     dec     hex filename
      2455190        105890   10272 2571352  273c58 i915-macro.ko
      $ size i915-inline.ko
         text          data     bss     dec     hex filename
      2455195        105890   10272 2571357  273c5d i915-inline.ko
    
      Kudos to Stan for reporting the raw-wakeref WARNs this issue caused. His
      config has CONFIG_DRM_I915_DEBUG_RUNTIME_PM=n, which I didn't retest
      after v1, and we are also not testing this config in CI.
    
      Now tested both with CONFIG_DRM_I915_DEBUG_RUNTIME_PM=y/n on ICL,
      connecting both Chamelium and regular DP, HDMI sinks.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190513192533.12586-1-imre.deak@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index e30b38632bd2..56ad79ef0806 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -59,13 +59,37 @@ intel_display_power_get_if_enabled(struct drm_i915_private *dev_priv,
 				   enum intel_display_power_domain domain);
 void intel_display_power_put_unchecked(struct drm_i915_private *dev_priv,
 				       enum intel_display_power_domain domain);
+void __intel_display_power_put_async(struct drm_i915_private *i915,
+				     enum intel_display_power_domain domain,
+				     intel_wakeref_t wakeref);
+void intel_display_power_flush_work(struct drm_i915_private *i915);
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
 void intel_display_power_put(struct drm_i915_private *dev_priv,
 			     enum intel_display_power_domain domain,
 			     intel_wakeref_t wakeref);
+static inline void
+intel_display_power_put_async(struct drm_i915_private *i915,
+			      enum intel_display_power_domain domain,
+			      intel_wakeref_t wakeref)
+{
+	__intel_display_power_put_async(i915, domain, wakeref);
+}
 #else
-#define intel_display_power_put(i915, domain, wakeref) \
-	intel_display_power_put_unchecked(i915, domain)
+static inline void
+intel_display_power_put(struct drm_i915_private *i915,
+			enum intel_display_power_domain domain,
+			intel_wakeref_t wakeref)
+{
+	intel_display_power_put_unchecked(i915, domain);
+}
+
+static inline void
+intel_display_power_put_async(struct drm_i915_private *i915,
+			      enum intel_display_power_domain domain,
+			      intel_wakeref_t wakeref)
+{
+	__intel_display_power_put_async(i915, domain, -1);
+}
 #endif
 void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
 			    u8 req_slices);
@@ -86,7 +110,11 @@ void intel_runtime_pm_put_unchecked(struct drm_i915_private *i915);
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
 void intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref);
 #else
-#define intel_runtime_pm_put(i915, wref) intel_runtime_pm_put_unchecked(i915)
+static inline void
+intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref)
+{
+	intel_runtime_pm_put_unchecked(i915);
+}
 #endif
 
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)

commit 46034d2bb7c8d809e261bde6e2d7b73273a0ff36
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 3 22:31:43 2019 +0300

    drm/i915: Move the hsw/bdw pc8 code to intel_runtime_pm.c
    
    hsw_enable_pc8()/hsw_disable_pc8() are more less equivalent to
    the display core init/unit functions of later platforms. Relocate
    the hsw/bdw code into intel_runtime_pm.c so that it sits next to
    its cousins.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190503193143.28240-2-ville.syrjala@linux.intel.com
    Reviewed-by: Imre Deak <imre.deak@intel.com>

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 69227756de3e..e30b38632bd2 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -37,6 +37,8 @@ void intel_power_domains_disable(struct drm_i915_private *dev_priv);
 void intel_power_domains_suspend(struct drm_i915_private *dev_priv,
 				 enum i915_drm_suspend_mode);
 void intel_power_domains_resume(struct drm_i915_private *dev_priv);
+void hsw_enable_pc8(struct drm_i915_private *dev_priv);
+void hsw_disable_pc8(struct drm_i915_private *dev_priv);
 void bxt_display_core_init(struct drm_i915_private *dev_priv, bool resume);
 void bxt_display_core_uninit(struct drm_i915_private *dev_priv);
 void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);

commit 0d5adc5f2f01249eab256d77a55ea89bb87d7546
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 29 15:29:36 2019 +0300

    drm/i915: extract intel_runtime_pm.h from intel_drv.h
    
    It used to be handy that we only had a couple of headers, but over time
    intel_drv.h has become unwieldy. Extract declarations to a separate
    header file corresponding to the implementation module, clarifying the
    modularity of the driver.
    
    Ensure the new header is self-contained, and do so with minimal further
    includes, using forward declarations as needed. Include the new header
    only where needed, and sort the modified include directives while at it
    and as needed.
    
    No functional changes.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/87904259868782c1ad664d852b27a50c1597cfaa.1556540890.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
new file mode 100644
index 000000000000..69227756de3e
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2019 Intel Corporation
+ */
+
+#ifndef __INTEL_RUNTIME_PM_H__
+#define __INTEL_RUNTIME_PM_H__
+
+#include <linux/stackdepot.h>
+#include <linux/types.h>
+
+struct drm_i915_private;
+
+typedef depot_stack_handle_t intel_wakeref_t;
+
+enum i915_drm_suspend_mode {
+	I915_DRM_SUSPEND_IDLE,
+	I915_DRM_SUSPEND_MEM,
+	I915_DRM_SUSPEND_HIBERNATE,
+};
+
+void skl_enable_dc6(struct drm_i915_private *dev_priv);
+void gen9_sanitize_dc_state(struct drm_i915_private *dev_priv);
+void bxt_enable_dc9(struct drm_i915_private *dev_priv);
+void bxt_disable_dc9(struct drm_i915_private *dev_priv);
+void gen9_enable_dc5(struct drm_i915_private *dev_priv);
+
+void intel_runtime_pm_init_early(struct drm_i915_private *dev_priv);
+int intel_power_domains_init(struct drm_i915_private *);
+void intel_power_domains_cleanup(struct drm_i915_private *dev_priv);
+void intel_power_domains_init_hw(struct drm_i915_private *dev_priv, bool resume);
+void intel_power_domains_fini_hw(struct drm_i915_private *dev_priv);
+void icl_display_core_init(struct drm_i915_private *dev_priv, bool resume);
+void icl_display_core_uninit(struct drm_i915_private *dev_priv);
+void intel_power_domains_enable(struct drm_i915_private *dev_priv);
+void intel_power_domains_disable(struct drm_i915_private *dev_priv);
+void intel_power_domains_suspend(struct drm_i915_private *dev_priv,
+				 enum i915_drm_suspend_mode);
+void intel_power_domains_resume(struct drm_i915_private *dev_priv);
+void bxt_display_core_init(struct drm_i915_private *dev_priv, bool resume);
+void bxt_display_core_uninit(struct drm_i915_private *dev_priv);
+void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);
+void intel_runtime_pm_disable(struct drm_i915_private *dev_priv);
+void intel_runtime_pm_cleanup(struct drm_i915_private *dev_priv);
+
+const char *
+intel_display_power_domain_str(enum intel_display_power_domain domain);
+
+bool intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
+				    enum intel_display_power_domain domain);
+bool __intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
+				      enum intel_display_power_domain domain);
+intel_wakeref_t intel_display_power_get(struct drm_i915_private *dev_priv,
+					enum intel_display_power_domain domain);
+intel_wakeref_t
+intel_display_power_get_if_enabled(struct drm_i915_private *dev_priv,
+				   enum intel_display_power_domain domain);
+void intel_display_power_put_unchecked(struct drm_i915_private *dev_priv,
+				       enum intel_display_power_domain domain);
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+void intel_display_power_put(struct drm_i915_private *dev_priv,
+			     enum intel_display_power_domain domain,
+			     intel_wakeref_t wakeref);
+#else
+#define intel_display_power_put(i915, domain, wakeref) \
+	intel_display_power_put_unchecked(i915, domain)
+#endif
+void icl_dbuf_slices_update(struct drm_i915_private *dev_priv,
+			    u8 req_slices);
+
+intel_wakeref_t intel_runtime_pm_get(struct drm_i915_private *i915);
+intel_wakeref_t intel_runtime_pm_get_if_in_use(struct drm_i915_private *i915);
+intel_wakeref_t intel_runtime_pm_get_noresume(struct drm_i915_private *i915);
+
+#define with_intel_runtime_pm(i915, wf) \
+	for ((wf) = intel_runtime_pm_get(i915); (wf); \
+	     intel_runtime_pm_put((i915), (wf)), (wf) = 0)
+
+#define with_intel_runtime_pm_if_in_use(i915, wf) \
+	for ((wf) = intel_runtime_pm_get_if_in_use(i915); (wf); \
+	     intel_runtime_pm_put((i915), (wf)), (wf) = 0)
+
+void intel_runtime_pm_put_unchecked(struct drm_i915_private *i915);
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+void intel_runtime_pm_put(struct drm_i915_private *i915, intel_wakeref_t wref);
+#else
+#define intel_runtime_pm_put(i915, wref) intel_runtime_pm_put_unchecked(i915)
+#endif
+
+#if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
+				    struct drm_printer *p);
+#else
+static inline void print_intel_runtime_pm_wakeref(struct drm_i915_private *i915,
+						  struct drm_printer *p)
+{
+}
+#endif
+
+void chv_phy_powergate_lanes(struct intel_encoder *encoder,
+			     bool override, unsigned int mask);
+bool chv_phy_powergate_ch(struct drm_i915_private *dev_priv, enum dpio_phy phy,
+			  enum dpio_channel ch, bool override);
+
+#endif /* __INTEL_RUNTIME_PM_H__ */
