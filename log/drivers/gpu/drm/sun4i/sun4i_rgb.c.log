commit f9f3a38d16542cb6521a14b4c8ed674c1cae2355
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Mar 5 16:59:42 2020 +0100

    drm/sun4i: Use simple encoder
    
    The ingenic driver uses empty implementations for its encoders. Replace
    the code with the generic simple encoder.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200305155950.2705-15-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 3b23d5be3cf3..5a7d43939ae6 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -14,6 +14,7 @@
 #include <drm/drm_panel.h>
 #include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
 
 #include "sun4i_crtc.h"
 #include "sun4i_tcon.h"
@@ -188,15 +189,6 @@ static struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {
 	.mode_valid	= sun4i_rgb_mode_valid,
 };
 
-static void sun4i_rgb_enc_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-
-static struct drm_encoder_funcs sun4i_rgb_enc_funcs = {
-	.destroy	= sun4i_rgb_enc_destroy,
-};
-
 int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 {
 	struct drm_encoder *encoder;
@@ -218,11 +210,8 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 
 	drm_encoder_helper_add(&rgb->encoder,
 			       &sun4i_rgb_enc_helper_funcs);
-	ret = drm_encoder_init(drm,
-			       &rgb->encoder,
-			       &sun4i_rgb_enc_funcs,
-			       DRM_MODE_ENCODER_NONE,
-			       NULL);
+	ret = drm_simple_encoder_init(drm, &rgb->encoder,
+				      DRM_MODE_ENCODER_NONE);
 	if (ret) {
 		dev_err(drm->dev, "Couldn't initialise the rgb encoder\n");
 		goto err_out;

commit a25b988ff83f3ca0d8f5acf855fb1717c1c61a69
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:29 2020 +0200

    drm/bridge: Extend bridge API to disable connector creation
    
    Most bridge drivers create a DRM connector to model the connector at the
    output of the bridge. This model is historical and has worked pretty
    well so far, but causes several issues:
    
    - It prevents supporting more complex display pipelines where DRM
    connector operations are split over multiple components. For instance a
    pipeline with a bridge connected to the DDC signals to read EDID data,
    and another one connected to the HPD signal to detect connection and
    disconnection, will not be possible to support through this model.
    
    - It requires every bridge driver to implement similar connector
    handling code, resulting in code duplication.
    
    - It assumes that a bridge will either be wired to a connector or to
    another bridge, but doesn't support bridges that can be used in both
    positions very well (although there is some ad-hoc support for this in
    the analogix_dp bridge driver).
    
    In order to solve these issues, ownership of the connector should be
    moved to the display controller driver (where it can be implemented
    using helpers provided by the core).
    
    Extend the bridge API to allow disabling connector creation in bridge
    drivers as a first step towards the new model. The new flags argument to
    the bridge .attach() operation allows instructing the bridge driver to
    skip creating a connector. Unconditionally set the new flags argument to
    0 for now to keep the existing behaviour, and modify all existing bridge
    drivers to return an error when connector creation is not requested as
    they don't support this feature yet.
    
    The change is based on the following semantic patch, with manual review
    and edits.
    
    @ rule1 @
    identifier funcs;
    identifier fn;
    @@
     struct drm_bridge_funcs funcs = {
            ...,
            .attach = fn
     };
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge;
    statement S, S1;
    @@
     int fn(
            struct drm_bridge *bridge
    +       , enum drm_bridge_attach_flags flags
     )
     {
            ... when != S
    +       if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
    +               DRM_ERROR("Fix bridge driver to make connector optional!");
    +               return -EINVAL;
    +       }
    +
            S1
            ...
     }
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge, flags;
    expression E1, E2, E3;
    @@
     int fn(
            struct drm_bridge *bridge,
            enum drm_bridge_attach_flags flags
     ) {
     <...
     drm_bridge_attach(E1, E2, E3
    +       , flags
     )
     ...>
     }
    
    @@
    expression E1, E2, E3;
    @@
     drm_bridge_attach(E1, E2, E3
    +       , 0
     )
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-10-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index b27f16af50f5..3b23d5be3cf3 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -253,7 +253,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 	}
 
 	if (rgb->bridge) {
-		ret = drm_bridge_attach(encoder, rgb->bridge, NULL);
+		ret = drm_bridge_attach(encoder, rgb->bridge, NULL, 0);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't attach our bridge\n");
 			goto err_cleanup_connector;

commit 06c4a9c2ae606a8c9fab303613234804b9c45a64
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:34 2019 +0100

    drm/panel: decouple connector from drm_panel
    
    To facilitate moving connector creation to display drivers,
    decouple the drm_connector from drm_panel.
    
    This patch adds a connector argument to drm_panel_get_modes().
    
    All users of drm_panel_get_modes() already had the connector
    available, so updating users was trivial.
    
    With this patch drm_panel no longer keeps a reference to the drm_connector.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jeffrey Hugo <jeffrey.l.hugo@gmail.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Jonas Karlman <jonas@kwiboo.se>
    Cc: Jernej Skrabec <jernej.skrabec@siol.net>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Alison Wang <alison.wang@nxp.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: Fabio Estevam <festevam@gmail.com>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Marek Vasut <marex@denx.de>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: "Heiko St√ºbner" <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Torsten Duwe <duwe@lst.de>
    Cc: Vasily Khoruzhick <anarsoul@gmail.com>
    Cc: Icenowy Zheng <icenowy@aosc.io>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Boris Brezillon <boris.brezillon@collabora.com>
    Cc: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Cc: Alexios Zavras <alexios.zavras@intel.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Rob Clark <robdclark@chromium.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Allison Randal <allison@lohutok.net>
    Cc: Shayenne Moura <shayenneluzmoura@gmail.com>
    Cc: Abhinav Kumar <abhinavk@codeaurora.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-tegra@vger.kernel.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-7-sam@ravnborg.org

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index e74b9eddca01..b27f16af50f5 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -47,7 +47,7 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 	struct sun4i_rgb *rgb =
 		drm_connector_to_sun4i_rgb(connector);
 
-	return drm_panel_get_modes(rgb->panel);
+	return drm_panel_get_modes(rgb->panel, connector);
 }
 
 /*

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index aac56983f208..e74b9eddca01 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -9,6 +9,7 @@
 #include <linux/clk.h>
 
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
 #include <drm/drm_of.h>
 #include <drm/drm_panel.h>
 #include <drm/drm_print.h>

commit 9c25a297664518b36933dae0887cbea3008fb840
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jul 16 08:42:06 2019 +0200

    drm/sun4i: drop use of drmP.h
    
    Drop use of the deprecated drmP.h header file.
    
    While touching the list of include file, use the typical order of the
    blocks:
    \#include <linux/*>
    
    \#include <video/*>
    
    \#include <drm/*>
    
    \#include ""
    
    Within each block, sort the files.
    Include necessary files to fix build after the drmP.h removal.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190716064220.18157-6-sam@ravnborg.org

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index a901ec689b62..aac56983f208 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -8,10 +8,10 @@
 
 #include <linux/clk.h>
 
-#include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_of.h>
 #include <drm/drm_panel.h>
+#include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
 
 #include "sun4i_crtc.h"

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index d9e2502b49fa..a901ec689b62 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2015 Free Electrons
  * Copyright (C) 2015 NextThing Co
  *
  * Maxime Ripard <maxime.ripard@free-electrons.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
  */
 
 #include <linux/clk.h>

commit e2771deb5dece1acde9a406538e4f7ef9262d5cd
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Tue Feb 26 15:25:49 2019 +0100

    drm/sun4i: rgb: Change the pixel clock validation check
    
    The current code, since commit bb43d40d7c83 ("drm/sun4i: rgb: Validate the
    clock rate"), perform some validation on the pixel clock to filter out the
    EDID modes provided by monitors (through bridges) that we wouldn't be able
    to reach. For the usual modes, we're able to generate a perfect clock rate,
    so a strict check was enough.
    
    However, this had the side effect of preventing displays that would work
    otherwise to operate properly, since we would pretty much never be able to
    generate an exact rate for those displays, even though we would fall within
    that panel tolerance.
    
    This was also shown to happen for unusual modes exposed through EDIDs, for
    example on eDP panels.
    
    We can work around this by simplifying a bit the problem: no panels we've
    encountered so far actually needed that check. All of them are tied to a
    particular board when it is produced, and made to work with the Allwinner
    BSP. That pretty much guarantees that we never have a pixel clock out of
    reach.
    
    On the other hand, the EDIDs modes that needed to be validated have always
    been exposed through bridges.
    
    Let's just use that metric to instead of validating all modes, only
    validate modes when we have a bridge attached. It should be good enough for
    now, while we still have room for improvements or refinements using the
    display_timings structure for example for panels.
    
    We also add a tolerance for EDID-based modes instead of doing a strict
    check. This tolerance is of 0.5% which is the one advertised in the VESA
    DVT and CVT specs. If that needed to be extended in the future, we can add
    a custom module parameter to relax it a bit.
    
    Fixes: bb43d40d7c83 ("drm/sun4i: rgb: Validate the clock rate")
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Tested-by: Vasily Khoruzhick <anarsoul@gmail.com> # tested on pinebook
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ec2dc2a7b3d4bd44f7a2a6e1c1813f92449a7310.1551191081.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 8df2c17f8427..d9e2502b49fa 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -53,6 +53,14 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 	return drm_panel_get_modes(rgb->panel);
 }
 
+/*
+ * VESA DMT defines a tolerance of 0.5% on the pixel clock, while the
+ * CVT spec reuses that tolerance in its examples, so it looks to be a
+ * good default tolerance for the EDID-based modes. Define it to 5 per
+ * mille to avoid floating point operations.
+ */
+#define SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE	5
+
 static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
 						 const struct drm_display_mode *mode)
 {
@@ -61,6 +69,7 @@ static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
 	u32 hsync = mode->hsync_end - mode->hsync_start;
 	u32 vsync = mode->vsync_end - mode->vsync_start;
 	unsigned long long rate = mode->clock * 1000;
+	unsigned long long lowest, highest;
 	unsigned long long rounded_rate;
 
 	DRM_DEBUG_DRIVER("Validating modes...\n");
@@ -93,15 +102,39 @@ static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
 
 	DRM_DEBUG_DRIVER("Vertical parameters OK\n");
 
+	/*
+	 * TODO: We should use the struct display_timing if available
+	 * and / or trying to stretch the timings within that
+	 * tolerancy to take care of panels that we wouldn't be able
+	 * to have a exact match for.
+	 */
+	if (rgb->panel) {
+		DRM_DEBUG_DRIVER("RGB panel used, skipping clock rate checks");
+		goto out;
+	}
+
+	/*
+	 * That shouldn't ever happen unless something is really wrong, but it
+	 * doesn't harm to check.
+	 */
+	if (!rgb->bridge)
+		goto out;
+
 	tcon->dclk_min_div = 6;
 	tcon->dclk_max_div = 127;
 	rounded_rate = clk_round_rate(tcon->dclk, rate);
-	if (rounded_rate < rate)
+
+	lowest = rate * (1000 - SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE);
+	do_div(lowest, 1000);
+	if (rounded_rate < lowest)
 		return MODE_CLOCK_LOW;
 
-	if (rounded_rate > rate)
+	highest = rate * (1000 + SUN4I_RGB_DOTCLOCK_TOLERANCE_PER_MILLE);
+	do_div(highest, 1000);
+	if (rounded_rate > highest)
 		return MODE_CLOCK_HIGH;
 
+out:
 	DRM_DEBUG_DRIVER("Clock rate OK\n");
 
 	return MODE_OK;

commit 9f7dfd0cb50f93662b182c05e59987ba9db9505e
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Tue Feb 26 15:25:48 2019 +0100

    drm/sun4i: Move rate variables to long long
    
    Our clock rate variables are getting pretty close to the LONG_MAX / ULONG_MAX
    limit, especially since we will start doing arithmetic on it. Move those
    types to unsigned long long to be sure we don't overflow their type.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Tested-by: Vasily Khoruzhick <anarsoul@gmail.com> # tested on pinebook
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/022c3b850413edd6afbca20062f100971de2f5af.1551191081.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index fb32cce7ece2..8df2c17f8427 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -60,8 +60,8 @@ static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
 	struct sun4i_tcon *tcon = rgb->tcon;
 	u32 hsync = mode->hsync_end - mode->hsync_start;
 	u32 vsync = mode->vsync_end - mode->vsync_start;
-	unsigned long rate = mode->clock * 1000;
-	long rounded_rate;
+	unsigned long long rate = mode->clock * 1000;
+	unsigned long long rounded_rate;
 
 	DRM_DEBUG_DRIVER("Validating modes...\n");
 

commit 19d0ffe0ed79e2e801d0a07f3096f22436f76e4a
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Tue Feb 26 15:25:47 2019 +0100

    drm/sun4i: rgb: Store the bridge pointer
    
    We'll need the bridge pointer, if any, in the mode_valid callback in
    addition to the init function. Store the pointer to the bridge in the
    rgb private structure.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Tested-by: Vasily Khoruzhick <anarsoul@gmail.com> # tested on pinebook
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/2f16d70fb09613b3a030fd6a016343047d519d43.1551191081.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 8db0ebe19724..fb32cce7ece2 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -28,6 +28,7 @@ struct sun4i_rgb {
 
 	struct sun4i_tcon	*tcon;
 	struct drm_panel	*panel;
+	struct drm_bridge	*bridge;
 };
 
 static inline struct sun4i_rgb *
@@ -169,7 +170,6 @@ static struct drm_encoder_funcs sun4i_rgb_enc_funcs = {
 int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 {
 	struct drm_encoder *encoder;
-	struct drm_bridge *bridge;
 	struct sun4i_rgb *rgb;
 	int ret;
 
@@ -180,7 +180,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 	encoder = &rgb->encoder;
 
 	ret = drm_of_find_panel_or_bridge(tcon->dev->of_node, 1, 0,
-					  &rgb->panel, &bridge);
+					  &rgb->panel, &rgb->bridge);
 	if (ret) {
 		dev_info(drm->dev, "No panel or bridge found... RGB output disabled\n");
 		return 0;
@@ -222,8 +222,8 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 		}
 	}
 
-	if (bridge) {
-		ret = drm_bridge_attach(encoder, bridge, NULL);
+	if (rgb->bridge) {
+		ret = drm_bridge_attach(encoder, rgb->bridge, NULL);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't attach our bridge\n");
 			goto err_cleanup_connector;

commit 1ce6f91c5fdd7d8cdf04ebf9ef6713e265bed2a6
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Tue Feb 26 15:25:46 2019 +0100

    drm/sun4i: Move the panel pointer from the TCON to the encoders
    
    The TCON driver used to need the panel pointer in order to configure the
    tcon according to the various parameters of the panel. However, this has
    evolved over time (especially to support bridges), and therefore the panel
    pointer isn't needed anymore by the TCON driver.
    
    Move that pointer to the LVDS and RGB encoders drivers.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Tested-by: Vasily Khoruzhick <anarsoul@gmail.com> # tested on pinebook
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/13288b6b8f27b614a6c9aef348923c34b2803ad4.1551191081.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index cae19e7bbeaa..8db0ebe19724 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -27,6 +27,7 @@ struct sun4i_rgb {
 	struct drm_encoder	encoder;
 
 	struct sun4i_tcon	*tcon;
+	struct drm_panel	*panel;
 };
 
 static inline struct sun4i_rgb *
@@ -47,9 +48,8 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 {
 	struct sun4i_rgb *rgb =
 		drm_connector_to_sun4i_rgb(connector);
-	struct sun4i_tcon *tcon = rgb->tcon;
 
-	return drm_panel_get_modes(tcon->panel);
+	return drm_panel_get_modes(rgb->panel);
 }
 
 static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
@@ -114,9 +114,8 @@ static void
 sun4i_rgb_connector_destroy(struct drm_connector *connector)
 {
 	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
-	struct sun4i_tcon *tcon = rgb->tcon;
 
-	drm_panel_detach(tcon->panel);
+	drm_panel_detach(rgb->panel);
 	drm_connector_cleanup(connector);
 }
 
@@ -131,26 +130,24 @@ static const struct drm_connector_funcs sun4i_rgb_con_funcs = {
 static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_tcon *tcon = rgb->tcon;
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	if (tcon->panel) {
-		drm_panel_prepare(tcon->panel);
-		drm_panel_enable(tcon->panel);
+	if (rgb->panel) {
+		drm_panel_prepare(rgb->panel);
+		drm_panel_enable(rgb->panel);
 	}
 }
 
 static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_tcon *tcon = rgb->tcon;
 
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
-	if (tcon->panel) {
-		drm_panel_disable(tcon->panel);
-		drm_panel_unprepare(tcon->panel);
+	if (rgb->panel) {
+		drm_panel_disable(rgb->panel);
+		drm_panel_unprepare(rgb->panel);
 	}
 }
 
@@ -183,7 +180,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 	encoder = &rgb->encoder;
 
 	ret = drm_of_find_panel_or_bridge(tcon->dev->of_node, 1, 0,
-					  &tcon->panel, &bridge);
+					  &rgb->panel, &bridge);
 	if (ret) {
 		dev_info(drm->dev, "No panel or bridge found... RGB output disabled\n");
 		return 0;
@@ -204,7 +201,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 	/* The RGB encoder can only work with the TCON channel 0 */
 	rgb->encoder.possible_crtcs = drm_crtc_mask(&tcon->crtc->crtc);
 
-	if (tcon->panel) {
+	if (rgb->panel) {
 		drm_connector_helper_add(&rgb->connector,
 					 &sun4i_rgb_con_helper_funcs);
 		ret = drm_connector_init(drm, &rgb->connector,
@@ -218,7 +215,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 		drm_connector_attach_encoder(&rgb->connector,
 						  &rgb->encoder);
 
-		ret = drm_panel_attach(tcon->panel, &rgb->connector);
+		ret = drm_panel_attach(rgb->panel, &rgb->connector);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't attach our panel\n");
 			goto err_cleanup_connector;

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index f4a22689eb54..cae19e7bbeaa 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -14,9 +14,9 @@
 
 #include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc_helper.h>
 #include <drm/drm_of.h>
 #include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
 
 #include "sun4i_crtc.h"
 #include "sun4i_tcon.h"

commit 548ae867efb1741fa55cedb5e73d7d0e75acd1f2
Author: Giulio Benetti <giulio.benetti@micronovasrl.com>
Date:   Fri Oct 5 23:59:50 2018 +0200

    drm/sun4i: tcon: fix check of tcon->panel null pointer
    
    Since tcon->panel is a pointer returned by of_drm_find_panel() need to
    check if it is not NULL, hence a valid pointer.
    IS_ERR() instead checks return error values, not NULL pointers.
    
    Substitute "if (!IS_ERR(tcon->panel))" with "if (tcon->panel)".
    
    Signed-off-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181005215951.99003-1-giulio.benetti@micronovasrl.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index bf068da6b12e..f4a22689eb54 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -135,7 +135,7 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel)) {
+	if (tcon->panel) {
 		drm_panel_prepare(tcon->panel);
 		drm_panel_enable(tcon->panel);
 	}
@@ -148,7 +148,7 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel)) {
+	if (tcon->panel) {
 		drm_panel_disable(tcon->panel);
 		drm_panel_unprepare(tcon->panel);
 	}

commit cde4c44d8769c1be16074c097592c46c7d64092b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:07 2018 +0200

    drm: drop _mode_ from drm_mode_connector_attach_encoder
    
    Again to align with the usual prefix of just drm_connector_. Again
    done with sed + manual fixup for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-7-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 96d21b07f8fc..bf068da6b12e 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -215,7 +215,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 			goto err_cleanup_connector;
 		}
 
-		drm_mode_connector_attach_encoder(&rgb->connector,
+		drm_connector_attach_encoder(&rgb->connector,
 						  &rgb->encoder);
 
 		ret = drm_panel_attach(tcon->panel, &rgb->connector);

commit dbf8f9e40e6f5fc39e2e6c4c8a392fe99189c4d2
Author: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
Date:   Tue Jun 26 22:47:14 2018 +0300

    drm/sun4i: Use drm_crtc_mask()
    
    Use drm_crtc_mask() where appropriate.
    
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180626194716.12522-8-ville.syrjala@linux.intel.com
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index f2fa1f210509..96d21b07f8fc 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -202,7 +202,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 	}
 
 	/* The RGB encoder can only work with the TCON channel 0 */
-	rgb->encoder.possible_crtcs = BIT(drm_crtc_index(&tcon->crtc->crtc));
+	rgb->encoder.possible_crtcs = drm_crtc_mask(&tcon->crtc->crtc);
 
 	if (tcon->panel) {
 		drm_connector_helper_add(&rgb->connector,

commit 2b4f44eec2be2688511c2b617d0e1b4f94c45ba4
Merge: 33d009cd8894 3eb2ce825ea1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 28 14:30:41 2018 +1000

    Backmerge tag 'v4.16-rc7' into drm-next
    
    Linux 4.16-rc7
    
    This was requested by Daniel, and things were getting
    a bit hard to reconcile, most of the conflicts were
    trivial though.

commit cde8b7548272640437d2fa691ae211f940066f6b
Author: Giulio Benetti <giulio.benetti@micronovasrl.com>
Date:   Tue Mar 13 12:36:57 2018 +0100

    drm/sun4i: move rgb mode_valid from connector to encoder
    
    mode_valid function must be connected to encoder.
    Otherwise it could get not be called by drm in the case there's a
    bridge connected to encoder instead of a panel.
    
    Move mode_valid function pointer to encoder helper functions,
    changing its prototype according to encoder helper function pointer.
    
    Signed-off-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1520941017-81177-1-git-send-email-giulio.benetti@micronovasrl.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 832f8f9bc47f..a2a697a099e6 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -52,10 +52,10 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 	return drm_panel_get_modes(tcon->panel);
 }
 
-static int sun4i_rgb_mode_valid(struct drm_connector *connector,
-				struct drm_display_mode *mode)
+static enum drm_mode_status sun4i_rgb_mode_valid(struct drm_encoder *crtc,
+						 const struct drm_display_mode *mode)
 {
-	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
+	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(crtc);
 	struct sun4i_tcon *tcon = rgb->tcon;
 	u32 hsync = mode->hsync_end - mode->hsync_start;
 	u32 vsync = mode->vsync_end - mode->vsync_start;
@@ -106,7 +106,6 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 
 static struct drm_connector_helper_funcs sun4i_rgb_con_helper_funcs = {
 	.get_modes	= sun4i_rgb_get_modes,
-	.mode_valid	= sun4i_rgb_mode_valid,
 };
 
 static void
@@ -156,6 +155,7 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 static struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {
 	.disable	= sun4i_rgb_encoder_disable,
 	.enable		= sun4i_rgb_encoder_enable,
+	.mode_valid	= sun4i_rgb_mode_valid,
 };
 
 static void sun4i_rgb_enc_destroy(struct drm_encoder *encoder)

commit 5af894bd20fa16970378cae8ff55917294e0d9dd
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Wed Feb 21 13:57:02 2018 +0100

    drm/sun4i: rgb: Fix potential division by zero
    
    In the case where mode_valid callback of our RGB connector was called
    before mode_set was being called, the range of dividers would not be set,
    resulting in a division by zero later on in the clk_round_rate logic.
    
    Set the range of dividers before calling clk_round_rate to fix this.
    
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180221125703.4595-2-maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 832f8f9bc47f..b8da5a50a61d 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -92,6 +92,8 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 
 	DRM_DEBUG_DRIVER("Vertical parameters OK\n");
 
+	tcon->dclk_min_div = 6;
+	tcon->dclk_max_div = 127;
 	rounded_rate = clk_round_rate(tcon->dclk, rate);
 	if (rounded_rate < rate)
 		return MODE_CLOCK_LOW;

commit 5b8f09100d6c85c4a8049a830b57f199b5b08278
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Tue Oct 17 11:06:13 2017 +0200

    drm/sun4i: tcon: Don't rely on encoders to set the TCON mode
    
    Just like we did for the TCON enable and disable, for historical reasons we
    used to rely on the encoders calling the TCON mode_set function, while the
    CRTC has a callback for that.
    
    Let's implement it in order to reduce the boilerplate code.
    
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/faa3a4d511039af1d116270dfef3a8b60ca3591e.1508231063.git-series.maxime.ripard@free-electrons.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index a7f297ed40c1..832f8f9bc47f 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -153,22 +153,7 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 	}
 }
 
-static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
-				       struct drm_display_mode *mode,
-				       struct drm_display_mode *adjusted_mode)
-{
-	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_tcon *tcon = rgb->tcon;
-
-	sun4i_tcon0_mode_set(tcon, mode);
-	sun4i_tcon_set_mux(tcon, 0, encoder);
-
-	/* FIXME: This seems to be board specific */
-	clk_set_phase(tcon->dclk, 120);
-}
-
 static struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {
-	.mode_set	= sun4i_rgb_encoder_mode_set,
 	.disable	= sun4i_rgb_encoder_disable,
 	.enable		= sun4i_rgb_encoder_enable,
 };

commit 45e88f994add84d8cd3864d36064ea1ed1b08cdf
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Tue Oct 17 11:06:12 2017 +0200

    drm/sun4i: tcon: Don't rely on encoders to enable the TCON
    
    So far, we've required all the TCON-connected encoders to call the TCON
    enable and disable functions.
    
    This was made this way because in the RGB/LVDS case, the TCON is the CRTC
    and the encoder. However, in all the other cases (HDMI, TV, DSI, etc.), we
    have another encoder down the road that needs to be programmed.
    
    We also needed to know which channel the encoder is connected to, which is
    encoder-specific.
    
    The CRTC's enable and disable callbacks can work just fine for our use
    case, and we can get the channel to use just by looking at the type of
    encoder, since that is fixed. Implement those callbacks, which will
    remove some of the encoder boilerplate.
    
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/90b4396e19b3eca61b2ebfdae0672074b88ad74d.1508231063.git-series.maxime.ripard@free-electrons.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 7cd7090ad63a..a7f297ed40c1 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -134,13 +134,10 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel))
+	if (!IS_ERR(tcon->panel)) {
 		drm_panel_prepare(tcon->panel);
-
-	sun4i_tcon_channel_enable(tcon, 0);
-
-	if (!IS_ERR(tcon->panel))
 		drm_panel_enable(tcon->panel);
+	}
 }
 
 static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
@@ -150,13 +147,10 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel))
+	if (!IS_ERR(tcon->panel)) {
 		drm_panel_disable(tcon->panel);
-
-	sun4i_tcon_channel_disable(tcon, 0);
-
-	if (!IS_ERR(tcon->panel))
 		drm_panel_unprepare(tcon->panel);
+	}
 }
 
 static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,

commit 5fd27c2a1f75439ae72212e730c3bd73868f487c
Merge: f30b8eaa2c1b 998140d26723
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 21 09:05:01 2017 +1000

    Merge tag 'sunxi-drm-for-4.14' of https://git.kernel.org/pub/scm/linux/kernel/git/mripard/linux into drm-next
    
    Allwinner DRM changes for 4.14
    
    A few changes, but most notably improving the HDMI support merged in 4.13,
    by reporting the DDC adapter as an i2c bus, and by adding CEC support
    through the CEC framework.
    
    * tag 'sunxi-drm-for-4.14' of https://git.kernel.org/pub/scm/linux/kernel/git/mripard/linux:
      sun4i_hdmi: add CEC support
      dt-bindings: display: sunxi: Improve endpoint ID scheme readability
      drm/sun4i: tcon: remove unused function
      drm/sun4i: Remove useless atomic_check
      drm/sun4i: Add if statement instead of depends on
      drm/sun4i: hdmi: Implement I2C adapter for A10s DDC bus
      drm/sun4i: constify drm_plane_helper_funcs

commit 32b4d5756cfc3f3c6a27e37796d0ba9c9b19cff0
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Aug 8 16:58:31 2017 +0530

    drm/sun4i: make drm_connector_funcs structures const
    
    Make these const as they are only passed to the function
    drm_connector_init and the corresponding argument is of type const.
    Done using Coccinelle
    
    @match disable optional_qualifier@
    identifier s;
    @@
    static struct drm_connector_funcs s = {...};
    
    @ref@
    position p;
    identifier match.s;
    @@
    s@p
    
    @good1@
    identifier match.s;
    expression e1,e2;
    position ref.p;
    @@
    drm_connector_init(e1,e2,&s@p,...)
    
    @bad depends on  !good1@
    position ref.p;
    identifier match.s;
    @@
    s@p
    
    @depends on forall !bad disable optional_qualifier@
    identifier match.s;
    @@
    static
    + const
    struct drm_connector_funcs s;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1502191712-11231-3-git-send-email-bhumirks@gmail.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 550bb262943f..42a238bbb899 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -119,7 +119,7 @@ sun4i_rgb_connector_destroy(struct drm_connector *connector)
 	drm_connector_cleanup(connector);
 }
 
-static struct drm_connector_funcs sun4i_rgb_con_funcs = {
+static const struct drm_connector_funcs sun4i_rgb_con_funcs = {
 	.fill_modes		= drm_helper_probe_single_connector_modes,
 	.destroy		= sun4i_rgb_connector_destroy,
 	.reset			= drm_atomic_helper_connector_reset,

commit 7d902c05b480cc44033dcb56e12e51b082656b42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:21 2017 +0200

    drm: Nuke drm_atomic_helper_connector_dpms
    
    It's dead code, the core handles all this directly now.
    
    The only special case is nouveau and tda988x which used one function
    for both legacy modeset code and -nv50 atomic world instead of 2
    vtables. But amounts to exactly the same.
    
    v2: Rebase over the panel/brideg refactorings in stm/ltdc.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Peter Senna Tschudin <peter.senna@collabora.com>
    Cc: Martin Donnelly <martin.donnelly@ge.com>
    Cc: Martyn Welch <martyn.welch@collabora.co.uk>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Alison Wang <alison.wang@freescale.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Marek Vasut <marex@denx.de>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Yannick Fertre <yannick.fertre@st.com>
    Cc: Philippe Cornu <philippe.cornu@st.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Cc: Jeffy Chen <jeffy.chen@rock-chips.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Yakir Yang <kuankuan.y@gmail.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Romain Perier <romain.perier@collabora.com>
    Cc: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Cc: Xinliang Liu <z.liuxinliang@hisilicon.com>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Rongrong Zou <zourongrong@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Hai Li <hali@codeaurora.org>
    Cc: "Noralf Tr√∏nnes" <noralf@tronnes.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-tegra@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: zain wang <wzz@rock-chips.com>
    Cc: Baoyou Xie <baoyou.xie@linaro.org>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-8-daniel.vetter@ffwll.ch
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Archit Taneja <architt@codeaurora.org>
    Tested-by: Philippe Cornu <philippe.cornu@st.com> (on stm)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Noralf Tr√∏nnes <noralf@tronnes.org>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 422b191faa77..550bb262943f 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -120,7 +120,6 @@ sun4i_rgb_connector_destroy(struct drm_connector *connector)
 }
 
 static struct drm_connector_funcs sun4i_rgb_con_funcs = {
-	.dpms			= drm_atomic_helper_connector_dpms,
 	.fill_modes		= drm_helper_probe_single_connector_modes,
 	.destroy		= sun4i_rgb_connector_destroy,
 	.reset			= drm_atomic_helper_connector_reset,

commit 7d1a2bf41f06b360724f9b2156cc8a2da816b15c
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed Jun 21 15:54:53 2017 +0200

    drm/sun4i: Remove useless atomic_check
    
    The atomic_check callback is optional, and we don't implement anything in
    some parts of our drivers. Let's remove it.
    
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 422b191faa77..76362c09c608 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -128,13 +128,6 @@ static struct drm_connector_funcs sun4i_rgb_con_funcs = {
 	.atomic_destroy_state	= drm_atomic_helper_connector_destroy_state,
 };
 
-static int sun4i_rgb_atomic_check(struct drm_encoder *encoder,
-				  struct drm_crtc_state *crtc_state,
-				  struct drm_connector_state *conn_state)
-{
-	return 0;
-}
-
 static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
@@ -182,7 +175,6 @@ static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
 }
 
 static struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {
-	.atomic_check	= sun4i_rgb_atomic_check,
 	.mode_set	= sun4i_rgb_encoder_mode_set,
 	.disable	= sun4i_rgb_encoder_disable,
 	.enable		= sun4i_rgb_encoder_enable,

commit f8c73f4f027b11d1f5d3bebd9077b5a748ef2a02
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Sat May 27 18:09:27 2017 +0200

    drm/sun4i: tcon: Move the muxing out of the mode set function
    
    The muxing can actually happen on both channels on some SoCs, so it makes
    more sense to just move it out of the sun4i_tcon1_mode_set function and
    create a separate function that needs to be called by the encoders.
    
    Let's do that and convert the existing drivers.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index c9bbb3b560a5..422b191faa77 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -175,6 +175,7 @@ static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
 	struct sun4i_tcon *tcon = rgb->tcon;
 
 	sun4i_tcon0_mode_set(tcon, mode);
+	sun4i_tcon_set_mux(tcon, 0, encoder);
 
 	/* FIXME: This seems to be board specific */
 	clk_set_phase(tcon->dclk, 120);

commit 86cf6788a661b8cb459f259e373c5daf09221abe
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Tue Apr 25 23:25:04 2017 +0800

    drm/sun4i: Set TCON clock inside sun4i_tconX_mode_set
    
    Currently we are configuring the TCON's dot clock or special clock
    directly from the encoder mode_set functions. Since we already
    provide mode_set helper functions for the TCON's 2 channels, we
    can set the respective clock from those helpers, and reduce the
    exposure of the TCON's internals.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 67f0b91a99de..c9bbb3b560a5 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -176,8 +176,6 @@ static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
 
 	sun4i_tcon0_mode_set(tcon, mode);
 
-	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
-
 	/* FIXME: This seems to be board specific */
 	clk_set_phase(tcon->dclk, 120);
 }

commit cb2e77c1d53366696a7f47dbcedba99603ca1b55
Merge: 856ee92e8602 2da042ac05e9
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 20 13:19:34 2017 +1000

    Merge tag 'sunxi-drm-for-4.12' of https://git.kernel.org/pub/scm/linux/kernel/git/mripard/linux into drm-next
    
    Allwinner DRM changes for 4.12
    
    Not any functional changes, but a lot of preliminary rework in order to
    support multiple display pipelines.
    
    * tag 'sunxi-drm-for-4.12' of https://git.kernel.org/pub/scm/linux/kernel/git/mripard/linux: (26 commits)
      MAINTAINERS: Add sun4i-drm git repo
      drm/sun4i: Pass pointer for underlying backend into layer init
      drm/sun4i: Pass pointers for associated backend and tcon into crtc init
      drm/sun4i: tv: Get tcon and backend pointers from associated crtc
      drm/sun4i: Use embedded tcon pointer to get the tcon's output port node
      drm/sun4i: Fix tcon channel 0 comment about backporch = backporch + hsync
      drm/sun4i: Fix TCON clock and regmap initialization sequence
      drm/sun4i: Grab reserved memory region
      drm/sun4i: Add backend and tcon pointers to sun4i_crtc
      drm/sun4i: Add backend pointer to sun4i_layer
      drm/sun4i: rgb: Pass tcon pointer when initializing RGB encoder
      drm/sun4i: tv: Switch to drm_of_find_possible_crtcs
      drm/sun4i: Drop hardcoded .possible_crtcs values from layers
      drm/sun4i: Drop primary layer pointer from sun4i_drv
      drm/sun4i: Initialize crtc from tcon bind function
      drm/sun4i: Move layers from sun4i_drv to sun4i_crtc
      drm/sun4i: Add end of list element for sun4i_layers_init's returned list
      drm/sun4i: Set drm_crtc.port to the underlying TCON's output port node
      drm/sun4i: Make sunxi_rgb2yuv_coef constant
      drm/sun4i: Make sun4i_crtc_init return ERR_PTR style error codes
      ...

commit ebc9446135671b89c2397f438af45d9cef0d1368
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 29 13:55:46 2017 -0500

    drm: convert drivers to use drm_of_find_panel_or_bridge
    
    Similar to the previous commit, convert drivers open coding OF graph
    parsing to use drm_of_find_panel_or_bridge instead.
    
    This changes some error messages to debug messages (in the graph core).
    Graph connections are often "no connects" depending on the particular
    board, so we want to avoid spurious messages. Plus the kernel is not a
    DT validator.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    [seanpaul dropped rockchip changes since they're now obsolete]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 757208f51731..46280dd70c9e 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -15,6 +15,7 @@
 #include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_of.h>
 #include <drm/drm_panel.h>
 
 #include "sun4i_drv.h"
@@ -218,9 +219,9 @@ int sun4i_rgb_init(struct drm_device *drm)
 	rgb->drv = drv;
 	encoder = &rgb->encoder;
 
-	tcon->panel = sun4i_tcon_find_panel(tcon->dev->of_node);
-	bridge = sun4i_tcon_find_bridge(tcon->dev->of_node);
-	if (IS_ERR(tcon->panel) && IS_ERR(bridge)) {
+	ret = drm_of_find_panel_or_bridge(tcon->dev->of_node, 1, 0,
+					  &tcon->panel, &bridge);
+	if (ret) {
 		dev_info(drm->dev, "No panel or bridge found... RGB output disabled\n");
 		return 0;
 	}
@@ -240,7 +241,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 	/* The RGB encoder can only work with the TCON channel 0 */
 	rgb->encoder.possible_crtcs = BIT(0);
 
-	if (!IS_ERR(tcon->panel)) {
+	if (tcon->panel) {
 		drm_connector_helper_add(&rgb->connector,
 					 &sun4i_rgb_con_helper_funcs);
 		ret = drm_connector_init(drm, &rgb->connector,
@@ -261,7 +262,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 		}
 	}
 
-	if (!IS_ERR(bridge)) {
+	if (bridge) {
 		ret = drm_bridge_attach(encoder, bridge, NULL);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't attach our bridge\n");

commit b9c8506cb88b974522133d7eccc3d924ed29cf23
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Thu Feb 23 16:05:41 2017 +0800

    drm/sun4i: rgb: Pass tcon pointer when initializing RGB encoder
    
    The RGB encoder represents channel 0 of the TCON. Instead of fetching
    the pointer to its TCON from the main sun4i_drv structure, pass it in
    as part of the init call, save it, and use it directly in the encoder
    and connector callbacks.
    
    We can also drop the otherwise unused sun4i_drv pointer.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index c4865bf1b392..1147451eb993 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -18,7 +18,6 @@
 #include <drm/drm_panel.h>
 
 #include "sun4i_crtc.h"
-#include "sun4i_drv.h"
 #include "sun4i_tcon.h"
 #include "sun4i_rgb.h"
 
@@ -26,7 +25,7 @@ struct sun4i_rgb {
 	struct drm_connector	connector;
 	struct drm_encoder	encoder;
 
-	struct sun4i_drv	*drv;
+	struct sun4i_tcon	*tcon;
 };
 
 static inline struct sun4i_rgb *
@@ -47,8 +46,7 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 {
 	struct sun4i_rgb *rgb =
 		drm_connector_to_sun4i_rgb(connector);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 
 	return drm_panel_get_modes(tcon->panel);
 }
@@ -57,8 +55,7 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 				struct drm_display_mode *mode)
 {
 	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 	u32 hsync = mode->hsync_end - mode->hsync_start;
 	u32 vsync = mode->vsync_end - mode->vsync_start;
 	unsigned long rate = mode->clock * 1000;
@@ -115,8 +112,7 @@ static void
 sun4i_rgb_connector_destroy(struct drm_connector *connector)
 {
 	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 
 	drm_panel_detach(tcon->panel);
 	drm_connector_cleanup(connector);
@@ -141,8 +137,7 @@ static int sun4i_rgb_atomic_check(struct drm_encoder *encoder,
 static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
@@ -158,8 +153,7 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
@@ -177,8 +171,7 @@ static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
 				       struct drm_display_mode *adjusted_mode)
 {
 	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
-	struct sun4i_drv *drv = rgb->drv;
-	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_tcon *tcon = rgb->tcon;
 
 	sun4i_tcon0_mode_set(tcon, mode);
 
@@ -204,10 +197,8 @@ static struct drm_encoder_funcs sun4i_rgb_enc_funcs = {
 	.destroy	= sun4i_rgb_enc_destroy,
 };
 
-int sun4i_rgb_init(struct drm_device *drm)
+int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 {
-	struct sun4i_drv *drv = drm->dev_private;
-	struct sun4i_tcon *tcon = drv->tcon;
 	struct drm_encoder *encoder;
 	struct drm_bridge *bridge;
 	struct sun4i_rgb *rgb;
@@ -216,7 +207,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 	rgb = devm_kzalloc(drm->dev, sizeof(*rgb), GFP_KERNEL);
 	if (!rgb)
 		return -ENOMEM;
-	rgb->drv = drv;
+	rgb->tcon = tcon;
 	encoder = &rgb->encoder;
 
 	tcon->panel = sun4i_tcon_find_panel(tcon->dev->of_node);

commit a5154a4d01d7958788366894ceeddd9e1aab5b13
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Thu Feb 23 16:05:39 2017 +0800

    drm/sun4i: Drop hardcoded .possible_crtcs values from layers
    
    To support multiple display pipelines, we would have multiple crtcs,
    with one or more planes bound to them. Obviously having hardcoded
    values for the drm_plane .possible_crtcs field is not going to work.
    
    For primary and cursor planes, the value is set by
    drm_crtc_init_with_planes. We just need to set it for overlay planes.
    
    We also fix the value set for the RGB encoder, by referencing the
    crtc set in sun4i_drv.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 757208f51731..c4865bf1b392 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -17,6 +17,7 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_panel.h>
 
+#include "sun4i_crtc.h"
 #include "sun4i_drv.h"
 #include "sun4i_tcon.h"
 #include "sun4i_rgb.h"
@@ -238,7 +239,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 	}
 
 	/* The RGB encoder can only work with the TCON channel 0 */
-	rgb->encoder.possible_crtcs = BIT(0);
+	rgb->encoder.possible_crtcs = BIT(drm_crtc_index(&tcon->crtc->crtc));
 
 	if (!IS_ERR(tcon->panel)) {
 		drm_connector_helper_add(&rgb->connector,

commit 3bb80f249525c059572d4bc89ac77ac2e511bcbe
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 17:59:08 2016 +0200

    drm: bridge: Link encoder and bridge in core code
    
    Instead of linking encoders and bridges in every driver (and getting it
    wrong half of the time, as many drivers forget to set the drm_bridge
    encoder pointer), do so in core code. The drm_bridge_attach() function
    needs the encoder and optional previous bridge to perform that task,
    update all the callers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Stefan Agner <stefan@agner.ch> # For DCU
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # For atmel-hlcdc
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # For STI
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # For sun4i
    Acked-by: Xinliang Liu <z.liuxinliang@hisilicon.com> # For hisilicon
    Acked-by: Jyri Sarha <jsarha@ti.com> # For tilcdc
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-4-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index f5e86fe7750e..757208f51731 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -208,6 +208,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun4i_tcon *tcon = drv->tcon;
 	struct drm_encoder *encoder;
+	struct drm_bridge *bridge;
 	struct sun4i_rgb *rgb;
 	int ret;
 
@@ -218,8 +219,8 @@ int sun4i_rgb_init(struct drm_device *drm)
 	encoder = &rgb->encoder;
 
 	tcon->panel = sun4i_tcon_find_panel(tcon->dev->of_node);
-	encoder->bridge = sun4i_tcon_find_bridge(tcon->dev->of_node);
-	if (IS_ERR(tcon->panel) && IS_ERR(encoder->bridge)) {
+	bridge = sun4i_tcon_find_bridge(tcon->dev->of_node);
+	if (IS_ERR(tcon->panel) && IS_ERR(bridge)) {
 		dev_info(drm->dev, "No panel or bridge found... RGB output disabled\n");
 		return 0;
 	}
@@ -260,16 +261,12 @@ int sun4i_rgb_init(struct drm_device *drm)
 		}
 	}
 
-	if (!IS_ERR(encoder->bridge)) {
-		encoder->bridge->encoder = &rgb->encoder;
-
-		ret = drm_bridge_attach(drm, encoder->bridge);
+	if (!IS_ERR(bridge)) {
+		ret = drm_bridge_attach(encoder, bridge, NULL);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't attach our bridge\n");
 			goto err_cleanup_connector;
 		}
-	} else {
-		encoder->bridge = NULL;
 	}
 
 	return 0;

commit 75e75cbd55183ff12459666c0a1d3e71fe1481ab
Merge: 58309befa82d 197aa6ed522c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 6 10:26:30 2016 +0100

    Merge remote-tracking branch 'airlied/drm-next' into drm-misc-next
    
    Backmerge v4.9-rc8 to get at
    
    commit e94bd1736f1f60e916a85a80c0b0ebeaae36cce5
    Author: Michel D√§nzer <michel.daenzer@amd.com>
    Date:   Wed Nov 30 17:30:01 2016 +0900
    
    drm: Don't call drm_for_each_crtc with a non-KMS driver
    
    so I can apply Michel's follow-up patch.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 949f08862d662f17b9d2929c6afb2d4e8f5d50cb
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Nov 29 22:56:30 2016 +0200

    drm: Make the connector .detect() callback optional
    
    Many drivers (21 to be exact) create connectors that are always
    connected (for instance to an LVDS or DSI panel). Instead of forcing
    them to implement a dummy .detect() handler, make the callback optional
    and consider the connector as always connected in that case.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    [seanpaul fixed small conflict in rcar-du/rcar_du_lvdscon.c]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index c3ff10f559cc..5380085b3c06 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -110,12 +110,6 @@ static struct drm_connector_helper_funcs sun4i_rgb_con_helper_funcs = {
 	.mode_valid	= sun4i_rgb_mode_valid,
 };
 
-static enum drm_connector_status
-sun4i_rgb_connector_detect(struct drm_connector *connector, bool force)
-{
-	return connector_status_connected;
-}
-
 static void
 sun4i_rgb_connector_destroy(struct drm_connector *connector)
 {
@@ -129,7 +123,6 @@ sun4i_rgb_connector_destroy(struct drm_connector *connector)
 
 static struct drm_connector_funcs sun4i_rgb_con_funcs = {
 	.dpms			= drm_atomic_helper_connector_dpms,
-	.detect			= sun4i_rgb_connector_detect,
 	.fill_modes		= drm_helper_probe_single_connector_modes,
 	.destroy		= sun4i_rgb_connector_destroy,
 	.reset			= drm_atomic_helper_connector_reset,

commit 0df03b43035afd0a64916fe4e5bca978562ffa5a
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Sep 29 14:05:05 2016 +0200

    drm/sun4i: rgb: Remove the bridge enable/disable functions
    
    The atomic helpers already call the drm_bridge_enable on our behalf,
    there's no need to do it a second time.
    
    Reported-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 4e4bea6f395c..d198ad7e5323 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -155,9 +155,6 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 	if (!IS_ERR(tcon->panel))
 		drm_panel_prepare(tcon->panel);
 
-	/* encoder->bridge can be NULL; drm_bridge_enable checks for it */
-	drm_bridge_enable(encoder->bridge);
-
 	sun4i_tcon_channel_enable(tcon, 0);
 
 	if (!IS_ERR(tcon->panel))
@@ -177,9 +174,6 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 
 	sun4i_tcon_channel_disable(tcon, 0);
 
-	/* encoder->bridge can be NULL; drm_bridge_disable checks for it */
-	drm_bridge_disable(encoder->bridge);
-
 	if (!IS_ERR(tcon->panel))
 		drm_panel_unprepare(tcon->panel);
 }

commit 5647b25c3335a25ba32d73e61850a374a708788a
Author: Jonathan Liu <net147@gmail.com>
Date:   Mon Sep 26 20:21:45 2016 +1000

    drm/sun4i: rgb: Enable panel after controller
    
    The panel should be enabled after the controller so that we do not have
    visual glitches on the panel while the controller is setup. Similarly,
    the panel should be disabled before the controller.
    
    Signed-off-by: Jonathan Liu <net147@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index c3ff10f559cc..4e4bea6f395c 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -152,15 +152,16 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel)) {
+	if (!IS_ERR(tcon->panel))
 		drm_panel_prepare(tcon->panel);
-		drm_panel_enable(tcon->panel);
-	}
 
 	/* encoder->bridge can be NULL; drm_bridge_enable checks for it */
 	drm_bridge_enable(encoder->bridge);
 
 	sun4i_tcon_channel_enable(tcon, 0);
+
+	if (!IS_ERR(tcon->panel))
+		drm_panel_enable(tcon->panel);
 }
 
 static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
@@ -171,15 +172,16 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
+	if (!IS_ERR(tcon->panel))
+		drm_panel_disable(tcon->panel);
+
 	sun4i_tcon_channel_disable(tcon, 0);
 
 	/* encoder->bridge can be NULL; drm_bridge_disable checks for it */
 	drm_bridge_disable(encoder->bridge);
 
-	if (!IS_ERR(tcon->panel)) {
-		drm_panel_disable(tcon->panel);
+	if (!IS_ERR(tcon->panel))
 		drm_panel_unprepare(tcon->panel);
-	}
 }
 
 static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,

commit 0c3ff44cc23cbede56aa1ca5916b126e681ca69b
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Thu Sep 8 18:59:22 2016 +0800

    drm/sun4i: add missing header dependencies
    
    We get 5 warnings when building kernel with W=1:
    drivers/gpu/drm/sun4i/sun4i_framebuffer.c:33:23: warning: no previous prototype for 'sun4i_framebuffer_init' [-Wmissing-prototypes]
    drivers/gpu/drm/sun4i/sun4i_framebuffer.c:47:6: warning: no previous prototype for 'sun4i_framebuffer_free' [-Wmissing-prototypes]
    drivers/gpu/drm/sun4i/sun4i_rgb.c:202:5: warning: no previous prototype for 'sun4i_rgb_init' [-Wmissing-prototypes]
    drivers/gpu/drm/sun4i/sun4i_dotclock.c:151:5: warning: no previous prototype for 'sun4i_dclk_create' [-Wmissing-prototypes]
    drivers/gpu/drm/sun4i/sun4i_dotclock.c:186:5: warning: no previous prototype for 'sun4i_dclk_free' [-Wmissing-prototypes]
    
    In fact, these functions are declared in
    drivers/gpu/drm/sun4i/sun4i_framebuffer.h,
    drivers/gpu/drm/sun4i/sun4i_rgb.h,
    drivers/gpu/drm/sun4i/sun4i_dotclock.h,
    so this patch adds missing header dependencies.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index bc6eef27c12b..c3ff10f559cc 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -19,6 +19,7 @@
 
 #include "sun4i_drv.h"
 #include "sun4i_tcon.h"
+#include "sun4i_rgb.h"
 
 struct sun4i_rgb {
 	struct drm_connector	connector;

commit b5644a5e72f0a18c0cddf887bec1e1370cf67a8c
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Thu Sep 1 14:13:32 2016 +0800

    drm/sun4i: Clear encoder->bridge if a bridge is not found
    
    The KMS helpers (drm_atomic_helper_check_modeset/mode_fixup) pass
    encoder->bridge directly to drm_bridge_mode_fixup, which expects a
    valid pointer, or NULL (in which case it just returns).
    
    Clear encoder->bridge if a bridge is not found, instead of keeping
    the ERR_PTR value.
    
    Since other drm_bridge functions also follow this pattern of checking
    for a non-NULL pointer, we can drop the ifs around the calls and just
    pass the pointer directly.
    
    Fixes: 894f5a9f4b4a ("drm/sun4i: Add bridge support")
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index c07697902ab1..bc6eef27c12b 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -156,8 +156,8 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 		drm_panel_enable(tcon->panel);
 	}
 
-	if (!IS_ERR(encoder->bridge))
-		drm_bridge_enable(encoder->bridge);
+	/* encoder->bridge can be NULL; drm_bridge_enable checks for it */
+	drm_bridge_enable(encoder->bridge);
 
 	sun4i_tcon_channel_enable(tcon, 0);
 }
@@ -172,8 +172,8 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 
 	sun4i_tcon_channel_disable(tcon, 0);
 
-	if (!IS_ERR(encoder->bridge))
-		drm_bridge_disable(encoder->bridge);
+	/* encoder->bridge can be NULL; drm_bridge_disable checks for it */
+	drm_bridge_disable(encoder->bridge);
 
 	if (!IS_ERR(tcon->panel)) {
 		drm_panel_disable(tcon->panel);
@@ -278,6 +278,8 @@ int sun4i_rgb_init(struct drm_device *drm)
 			dev_err(drm->dev, "Couldn't attach our bridge\n");
 			goto err_cleanup_connector;
 		}
+	} else {
+		encoder->bridge = NULL;
 	}
 
 	return 0;

commit 4b30950252265140139ce441fd7d8743d1d6052e
Author: Jonathan Liu <net147@gmail.com>
Date:   Tue Aug 30 16:55:00 2016 +1000

    drm/sun4i: rgb: add missing calls to drm_panel_{prepare,unprepare}
    
    If the enable-gpios property of a simple panel in device tree is set,
    the GPIO is not toggled on/off because of missing calls to
    drm_panel_prepare and drm_panel_unprepare.
    
    Signed-off-by: Jonathan Liu <net147@gmail.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index d4e52522ec53..c07697902ab1 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -151,8 +151,10 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	if (!IS_ERR(tcon->panel))
+	if (!IS_ERR(tcon->panel)) {
+		drm_panel_prepare(tcon->panel);
 		drm_panel_enable(tcon->panel);
+	}
 
 	if (!IS_ERR(encoder->bridge))
 		drm_bridge_enable(encoder->bridge);
@@ -173,8 +175,10 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 	if (!IS_ERR(encoder->bridge))
 		drm_bridge_disable(encoder->bridge);
 
-	if (!IS_ERR(tcon->panel))
+	if (!IS_ERR(tcon->panel)) {
 		drm_panel_disable(tcon->panel);
+		drm_panel_unprepare(tcon->panel);
+	}
 }
 
 static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,

commit 894f5a9f4b4aaf154fce121d80199a2e2146d6d1
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Mon Apr 11 12:16:33 2016 +0200

    drm/sun4i: Add bridge support
    
    Our RGB bus can be either connected to a bridge or a panel. While the panel
    support was already there, the bridge was not.
    
    Fix that.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index d32f08f9ce5f..d4e52522ec53 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -151,7 +151,12 @@ static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Enabling RGB output\n");
 
-	drm_panel_enable(tcon->panel);
+	if (!IS_ERR(tcon->panel))
+		drm_panel_enable(tcon->panel);
+
+	if (!IS_ERR(encoder->bridge))
+		drm_bridge_enable(encoder->bridge);
+
 	sun4i_tcon_channel_enable(tcon, 0);
 }
 
@@ -164,7 +169,12 @@ static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
 	DRM_DEBUG_DRIVER("Disabling RGB output\n");
 
 	sun4i_tcon_channel_disable(tcon, 0);
-	drm_panel_disable(tcon->panel);
+
+	if (!IS_ERR(encoder->bridge))
+		drm_bridge_disable(encoder->bridge);
+
+	if (!IS_ERR(tcon->panel))
+		drm_panel_disable(tcon->panel);
 }
 
 static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
@@ -203,6 +213,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 {
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun4i_tcon *tcon = drv->tcon;
+	struct drm_encoder *encoder;
 	struct sun4i_rgb *rgb;
 	int ret;
 
@@ -210,10 +221,12 @@ int sun4i_rgb_init(struct drm_device *drm)
 	if (!rgb)
 		return -ENOMEM;
 	rgb->drv = drv;
+	encoder = &rgb->encoder;
 
 	tcon->panel = sun4i_tcon_find_panel(tcon->dev->of_node);
-	if (IS_ERR(tcon->panel)) {
-		dev_info(drm->dev, "No panel found... RGB output disabled\n");
+	encoder->bridge = sun4i_tcon_find_bridge(tcon->dev->of_node);
+	if (IS_ERR(tcon->panel) && IS_ERR(encoder->bridge)) {
+		dev_info(drm->dev, "No panel or bridge found... RGB output disabled\n");
 		return 0;
 	}
 
@@ -232,19 +245,36 @@ int sun4i_rgb_init(struct drm_device *drm)
 	/* The RGB encoder can only work with the TCON channel 0 */
 	rgb->encoder.possible_crtcs = BIT(0);
 
-	drm_connector_helper_add(&rgb->connector,
-				 &sun4i_rgb_con_helper_funcs);
-	ret = drm_connector_init(drm, &rgb->connector,
-				 &sun4i_rgb_con_funcs,
-				 DRM_MODE_CONNECTOR_Unknown);
-	if (ret) {
-		dev_err(drm->dev, "Couldn't initialise the rgb connector\n");
-		goto err_cleanup_connector;
+	if (!IS_ERR(tcon->panel)) {
+		drm_connector_helper_add(&rgb->connector,
+					 &sun4i_rgb_con_helper_funcs);
+		ret = drm_connector_init(drm, &rgb->connector,
+					 &sun4i_rgb_con_funcs,
+					 DRM_MODE_CONNECTOR_Unknown);
+		if (ret) {
+			dev_err(drm->dev, "Couldn't initialise the rgb connector\n");
+			goto err_cleanup_connector;
+		}
+
+		drm_mode_connector_attach_encoder(&rgb->connector,
+						  &rgb->encoder);
+
+		ret = drm_panel_attach(tcon->panel, &rgb->connector);
+		if (ret) {
+			dev_err(drm->dev, "Couldn't attach our panel\n");
+			goto err_cleanup_connector;
+		}
 	}
 
-	drm_mode_connector_attach_encoder(&rgb->connector, &rgb->encoder);
+	if (!IS_ERR(encoder->bridge)) {
+		encoder->bridge->encoder = &rgb->encoder;
 
-	drm_panel_attach(tcon->panel, &rgb->connector);
+		ret = drm_bridge_attach(drm, encoder->bridge);
+		if (ret) {
+			dev_err(drm->dev, "Couldn't attach our bridge\n");
+			goto err_cleanup_connector;
+		}
+	}
 
 	return 0;
 

commit a8444c7ee2c02b567731a6edcd5d328f85aac1b1
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed Jul 20 10:35:06 2016 +0200

    drm/sun4i: Move panel retrieval in RGB connector
    
    In order to properly support bridges and use drm_encoder's bridge pointer,
    move the panel (and bridge eventually) retrieval code in the RGB output
    init function.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index f5bbac6efb4c..d32f08f9ce5f 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -206,15 +206,17 @@ int sun4i_rgb_init(struct drm_device *drm)
 	struct sun4i_rgb *rgb;
 	int ret;
 
-	/* If we don't have a panel, there's no point in going on */
-	if (IS_ERR(tcon->panel))
-		return -ENODEV;
-
 	rgb = devm_kzalloc(drm->dev, sizeof(*rgb), GFP_KERNEL);
 	if (!rgb)
 		return -ENOMEM;
 	rgb->drv = drv;
 
+	tcon->panel = sun4i_tcon_find_panel(tcon->dev->of_node);
+	if (IS_ERR(tcon->panel)) {
+		dev_info(drm->dev, "No panel found... RGB output disabled\n");
+		return 0;
+	}
+
 	drm_encoder_helper_add(&rgb->encoder,
 			       &sun4i_rgb_enc_helper_funcs);
 	ret = drm_encoder_init(drm,

commit 542d972221e024681b502033154f917c1455469f
Merge: 583fa4e02775 4c2e07c6a29e
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Jul 2 15:56:01 2016 +1000

    Back-merge tag 'v4.7-rc5' into drm-next
    
    Linux 4.7-rc5
    
    The fsl-dcu pull needs -rc3 so go to -rc5 for now.

commit 99410f35944e2bf98c609a6ff164c30158050b60
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jun 7 13:48:07 2016 +0200

    drm: sun4i: Rely on the default ->best_encoder() behavior
    
    All outputs have a 1:1 relationship between connectors and encoders
    and the driver is relying on the atomic helpers: we can drop the custom
    ->best_encoder() implementations and let the core call
    drm_atomic_helper_best_encoder() for us.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465300095-16971-13-git-send-email-boris.brezillon@free-electrons.com

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index ab6494818050..442cfe271688 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -90,19 +90,9 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 	return MODE_OK;
 }
 
-static struct drm_encoder *
-sun4i_rgb_best_encoder(struct drm_connector *connector)
-{
-	struct sun4i_rgb *rgb =
-		drm_connector_to_sun4i_rgb(connector);
-
-	return &rgb->encoder;
-}
-
 static struct drm_connector_helper_funcs sun4i_rgb_con_helper_funcs = {
 	.get_modes	= sun4i_rgb_get_modes,
 	.mode_valid	= sun4i_rgb_mode_valid,
-	.best_encoder	= sun4i_rgb_best_encoder,
 };
 
 static enum drm_connector_status

commit 0de6e914a035076b1241f5738c06c9d3820abd6e
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed May 4 17:37:58 2016 +0200

    drm/sun4i: rgb: panel is an error pointer
    
    In case of an error, our pointer to the drm_panel structure attached to our
    encoder will hold an error pointer, not a NULL pointer.
    
    Make sure we check the right thing.
    
    Fixes: 29e57fab97fc ("drm: sun4i: Add RGB output")
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index fe7ef52a9346..aaffe9e64ffb 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -217,7 +217,7 @@ int sun4i_rgb_init(struct drm_device *drm)
 	int ret;
 
 	/* If we don't have a panel, there's no point in going on */
-	if (!tcon->panel)
+	if (IS_ERR(tcon->panel))
 		return -ENODEV;
 
 	rgb = devm_kzalloc(drm->dev, sizeof(*rgb), GFP_KERNEL);

commit bb43d40d7c830da5f623e3938fef908b003b7523
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Apr 21 11:25:26 2016 +0200

    drm/sun4i: rgb: Validate the clock rate
    
    Our pixel clock cannot reach a high enough rate for some rather high while
    common resolutions (like 1080p60).
    
    Make sure we filter the resolutions we cannot reach in our mode_valid
    function.
    
    Fixes: 29e57fab97fc ("drm: sun4i: Add RGB output")
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index ab6494818050..fe7ef52a9346 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -54,8 +54,13 @@ static int sun4i_rgb_get_modes(struct drm_connector *connector)
 static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 				struct drm_display_mode *mode)
 {
+	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
 	u32 hsync = mode->hsync_end - mode->hsync_start;
 	u32 vsync = mode->vsync_end - mode->vsync_start;
+	unsigned long rate = mode->clock * 1000;
+	long rounded_rate;
 
 	DRM_DEBUG_DRIVER("Validating modes...\n");
 
@@ -87,6 +92,15 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 
 	DRM_DEBUG_DRIVER("Vertical parameters OK\n");
 
+	rounded_rate = clk_round_rate(tcon->dclk, rate);
+	if (rounded_rate < rate)
+		return MODE_CLOCK_LOW;
+
+	if (rounded_rate > rate)
+		return MODE_CLOCK_HIGH;
+
+	DRM_DEBUG_DRIVER("Clock rate OK\n");
+
 	return MODE_OK;
 }
 

commit 29e57fab97fcdac9bf04db5f8f59ee63ab11b866
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Oct 29 09:37:32 2015 +0100

    drm: sun4i: Add RGB output
    
    One of the A10 display pipeline possible output is an RGB interface to
    drive LCD panels directly. This is done through the first channel of the
    TCON that will output our video signals directly.
    
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
new file mode 100644
index 000000000000..ab6494818050
--- /dev/null
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2015 Free Electrons
+ * Copyright (C) 2015 NextThing Co
+ *
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_panel.h>
+
+#include "sun4i_drv.h"
+#include "sun4i_tcon.h"
+
+struct sun4i_rgb {
+	struct drm_connector	connector;
+	struct drm_encoder	encoder;
+
+	struct sun4i_drv	*drv;
+};
+
+static inline struct sun4i_rgb *
+drm_connector_to_sun4i_rgb(struct drm_connector *connector)
+{
+	return container_of(connector, struct sun4i_rgb,
+			    connector);
+}
+
+static inline struct sun4i_rgb *
+drm_encoder_to_sun4i_rgb(struct drm_encoder *encoder)
+{
+	return container_of(encoder, struct sun4i_rgb,
+			    encoder);
+}
+
+static int sun4i_rgb_get_modes(struct drm_connector *connector)
+{
+	struct sun4i_rgb *rgb =
+		drm_connector_to_sun4i_rgb(connector);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
+
+	return drm_panel_get_modes(tcon->panel);
+}
+
+static int sun4i_rgb_mode_valid(struct drm_connector *connector,
+				struct drm_display_mode *mode)
+{
+	u32 hsync = mode->hsync_end - mode->hsync_start;
+	u32 vsync = mode->vsync_end - mode->vsync_start;
+
+	DRM_DEBUG_DRIVER("Validating modes...\n");
+
+	if (hsync < 1)
+		return MODE_HSYNC_NARROW;
+
+	if (hsync > 0x3ff)
+		return MODE_HSYNC_WIDE;
+
+	if ((mode->hdisplay < 1) || (mode->htotal < 1))
+		return MODE_H_ILLEGAL;
+
+	if ((mode->hdisplay > 0x7ff) || (mode->htotal > 0xfff))
+		return MODE_BAD_HVALUE;
+
+	DRM_DEBUG_DRIVER("Horizontal parameters OK\n");
+
+	if (vsync < 1)
+		return MODE_VSYNC_NARROW;
+
+	if (vsync > 0x3ff)
+		return MODE_VSYNC_WIDE;
+
+	if ((mode->vdisplay < 1) || (mode->vtotal < 1))
+		return MODE_V_ILLEGAL;
+
+	if ((mode->vdisplay > 0x7ff) || (mode->vtotal > 0xfff))
+		return MODE_BAD_VVALUE;
+
+	DRM_DEBUG_DRIVER("Vertical parameters OK\n");
+
+	return MODE_OK;
+}
+
+static struct drm_encoder *
+sun4i_rgb_best_encoder(struct drm_connector *connector)
+{
+	struct sun4i_rgb *rgb =
+		drm_connector_to_sun4i_rgb(connector);
+
+	return &rgb->encoder;
+}
+
+static struct drm_connector_helper_funcs sun4i_rgb_con_helper_funcs = {
+	.get_modes	= sun4i_rgb_get_modes,
+	.mode_valid	= sun4i_rgb_mode_valid,
+	.best_encoder	= sun4i_rgb_best_encoder,
+};
+
+static enum drm_connector_status
+sun4i_rgb_connector_detect(struct drm_connector *connector, bool force)
+{
+	return connector_status_connected;
+}
+
+static void
+sun4i_rgb_connector_destroy(struct drm_connector *connector)
+{
+	struct sun4i_rgb *rgb = drm_connector_to_sun4i_rgb(connector);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
+
+	drm_panel_detach(tcon->panel);
+	drm_connector_cleanup(connector);
+}
+
+static struct drm_connector_funcs sun4i_rgb_con_funcs = {
+	.dpms			= drm_atomic_helper_connector_dpms,
+	.detect			= sun4i_rgb_connector_detect,
+	.fill_modes		= drm_helper_probe_single_connector_modes,
+	.destroy		= sun4i_rgb_connector_destroy,
+	.reset			= drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_connector_destroy_state,
+};
+
+static int sun4i_rgb_atomic_check(struct drm_encoder *encoder,
+				  struct drm_crtc_state *crtc_state,
+				  struct drm_connector_state *conn_state)
+{
+	return 0;
+}
+
+static void sun4i_rgb_encoder_enable(struct drm_encoder *encoder)
+{
+	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
+
+	DRM_DEBUG_DRIVER("Enabling RGB output\n");
+
+	drm_panel_enable(tcon->panel);
+	sun4i_tcon_channel_enable(tcon, 0);
+}
+
+static void sun4i_rgb_encoder_disable(struct drm_encoder *encoder)
+{
+	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
+
+	DRM_DEBUG_DRIVER("Disabling RGB output\n");
+
+	sun4i_tcon_channel_disable(tcon, 0);
+	drm_panel_disable(tcon->panel);
+}
+
+static void sun4i_rgb_encoder_mode_set(struct drm_encoder *encoder,
+				       struct drm_display_mode *mode,
+				       struct drm_display_mode *adjusted_mode)
+{
+	struct sun4i_rgb *rgb = drm_encoder_to_sun4i_rgb(encoder);
+	struct sun4i_drv *drv = rgb->drv;
+	struct sun4i_tcon *tcon = drv->tcon;
+
+	sun4i_tcon0_mode_set(tcon, mode);
+
+	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
+
+	/* FIXME: This seems to be board specific */
+	clk_set_phase(tcon->dclk, 120);
+}
+
+static struct drm_encoder_helper_funcs sun4i_rgb_enc_helper_funcs = {
+	.atomic_check	= sun4i_rgb_atomic_check,
+	.mode_set	= sun4i_rgb_encoder_mode_set,
+	.disable	= sun4i_rgb_encoder_disable,
+	.enable		= sun4i_rgb_encoder_enable,
+};
+
+static void sun4i_rgb_enc_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+}
+
+static struct drm_encoder_funcs sun4i_rgb_enc_funcs = {
+	.destroy	= sun4i_rgb_enc_destroy,
+};
+
+int sun4i_rgb_init(struct drm_device *drm)
+{
+	struct sun4i_drv *drv = drm->dev_private;
+	struct sun4i_tcon *tcon = drv->tcon;
+	struct sun4i_rgb *rgb;
+	int ret;
+
+	/* If we don't have a panel, there's no point in going on */
+	if (!tcon->panel)
+		return -ENODEV;
+
+	rgb = devm_kzalloc(drm->dev, sizeof(*rgb), GFP_KERNEL);
+	if (!rgb)
+		return -ENOMEM;
+	rgb->drv = drv;
+
+	drm_encoder_helper_add(&rgb->encoder,
+			       &sun4i_rgb_enc_helper_funcs);
+	ret = drm_encoder_init(drm,
+			       &rgb->encoder,
+			       &sun4i_rgb_enc_funcs,
+			       DRM_MODE_ENCODER_NONE,
+			       NULL);
+	if (ret) {
+		dev_err(drm->dev, "Couldn't initialise the rgb encoder\n");
+		goto err_out;
+	}
+
+	/* The RGB encoder can only work with the TCON channel 0 */
+	rgb->encoder.possible_crtcs = BIT(0);
+
+	drm_connector_helper_add(&rgb->connector,
+				 &sun4i_rgb_con_helper_funcs);
+	ret = drm_connector_init(drm, &rgb->connector,
+				 &sun4i_rgb_con_funcs,
+				 DRM_MODE_CONNECTOR_Unknown);
+	if (ret) {
+		dev_err(drm->dev, "Couldn't initialise the rgb connector\n");
+		goto err_cleanup_connector;
+	}
+
+	drm_mode_connector_attach_encoder(&rgb->connector, &rgb->encoder);
+
+	drm_panel_attach(tcon->panel, &rgb->connector);
+
+	return 0;
+
+err_cleanup_connector:
+	drm_encoder_cleanup(&rgb->encoder);
+err_out:
+	return ret;
+}
+EXPORT_SYMBOL(sun4i_rgb_init);
