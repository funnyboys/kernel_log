commit 831adffb3b7b8df4c8e20b7b00843129fb87a166
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Tue May 14 22:43:37 2019 +0200

    drm/sun4i: Fix sun8i HDMI PHY configuration for > 148.5 MHz
    
    Vendor provided documentation says that EMP bits should be set to 3 for
    pixel clocks greater than 148.5 MHz.
    
    Fix that.
    
    Cc: stable@vger.kernel.org # 4.17+
    Fixes: 4f86e81748fe ("drm/sun4i: Add support for H3 HDMI PHY variant")
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190514204337.11068-3-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index afc6d4a9c20b..43643ad31730 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -293,7 +293,8 @@ static int sun8i_hdmi_phy_config_h3(struct dw_hdmi *hdmi,
 				 SUN8I_HDMI_PHY_ANA_CFG2_REG_BIGSW |
 				 SUN8I_HDMI_PHY_ANA_CFG2_REG_SLV(4);
 		ana_cfg3_init |= SUN8I_HDMI_PHY_ANA_CFG3_REG_AMPCK(9) |
-				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(13);
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(13) |
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_EMP(3);
 	}
 
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,

commit 8a943c6021ba8b95a36c842327e468df1fddd4a7
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Tue May 14 22:43:36 2019 +0200

    drm/sun4i: Fix sun8i HDMI PHY clock initialization
    
    Current code initializes HDMI PHY clock driver before reset line is
    deasserted and clocks enabled. Because of that, initial readout of
    clock divider is incorrect (0 instead of 2). This causes any clock
    rate with divider 1 (register value 0) to be set incorrectly.
    
    Fix this by moving initialization of HDMI PHY clock driver after reset
    line is deasserted and clocks enabled.
    
    Cc: stable@vger.kernel.org # 4.17+
    Fixes: 4f86e81748fe ("drm/sun4i: Add support for H3 HDMI PHY variant")
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190514204337.11068-2-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 66ea3a902e36..afc6d4a9c20b 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -672,22 +672,13 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 				goto err_put_clk_pll0;
 			}
 		}
-
-		ret = sun8i_phy_clk_create(phy, dev,
-					   phy->variant->has_second_pll);
-		if (ret) {
-			dev_err(dev, "Couldn't create the PHY clock\n");
-			goto err_put_clk_pll1;
-		}
-
-		clk_prepare_enable(phy->clk_phy);
 	}
 
 	phy->rst_phy = of_reset_control_get_shared(node, "phy");
 	if (IS_ERR(phy->rst_phy)) {
 		dev_err(dev, "Could not get phy reset control\n");
 		ret = PTR_ERR(phy->rst_phy);
-		goto err_disable_clk_phy;
+		goto err_put_clk_pll1;
 	}
 
 	ret = reset_control_deassert(phy->rst_phy);
@@ -708,18 +699,29 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 		goto err_disable_clk_bus;
 	}
 
+	if (phy->variant->has_phy_clk) {
+		ret = sun8i_phy_clk_create(phy, dev,
+					   phy->variant->has_second_pll);
+		if (ret) {
+			dev_err(dev, "Couldn't create the PHY clock\n");
+			goto err_disable_clk_mod;
+		}
+
+		clk_prepare_enable(phy->clk_phy);
+	}
+
 	hdmi->phy = phy;
 
 	return 0;
 
+err_disable_clk_mod:
+	clk_disable_unprepare(phy->clk_mod);
 err_disable_clk_bus:
 	clk_disable_unprepare(phy->clk_bus);
 err_deassert_rst_phy:
 	reset_control_assert(phy->rst_phy);
 err_put_rst_phy:
 	reset_control_put(phy->rst_phy);
-err_disable_clk_phy:
-	clk_disable_unprepare(phy->clk_phy);
 err_put_clk_pll1:
 	clk_put(phy->clk_pll1);
 err_put_clk_pll0:

commit 0fb4b858b1024a62788bef3bcaaa77d7b2359044
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Sun Nov 4 19:26:59 2018 +0100

    drm/sun4i: Add support for H6 HDMI PHY
    
    H6 has Synopsys DWC HDMI 2.0 TX PHY.
    
    There is no freely available documentation for it, only code found in
    BSP kernel. However, judging by the code, PHY is very similar to older
    Synopsys HDMI PHY described in i.MX6 documentation. Most registers seem
    to be the same.
    
    According to i.MX6 documentation, mpll settings are based on pixel clock
    and are not specific to each SoC. Because of that, mpll table in this
    commit is based on that documentation and not on BSP code. Other PHY
    settings were derived from BSP PHY driver code.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181104182705.18047-23-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 635825b55648..66ea3a902e36 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -14,6 +14,122 @@
  */
 #define I2C_ADDR	0x69
 
+static const struct dw_hdmi_mpll_config sun50i_h6_mpll_cfg[] = {
+	{
+		30666000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40f3, 0x0000 },
+		},
+	},  {
+		36800000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		46000000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		61333000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		73600000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		92000000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		122666000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		147200000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		184000000, {
+			{ 0x0051, 0x0002 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		226666000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		272000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		340000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		594000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	}, {
+		~0UL, {
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+		},
+	}
+};
+
+static const struct dw_hdmi_curr_ctrl sun50i_h6_cur_ctr[] = {
+	/* pixelclk    bpp8    bpp10   bpp12 */
+	{ 25175000,  { 0x0000, 0x0000, 0x0000 }, },
+	{ 27000000,  { 0x0012, 0x0000, 0x0000 }, },
+	{ 59400000,  { 0x0008, 0x0008, 0x0008 }, },
+	{ 72000000,  { 0x0008, 0x0008, 0x001b }, },
+	{ 74250000,  { 0x0013, 0x0013, 0x0013 }, },
+	{ 90000000,  { 0x0008, 0x001a, 0x001b }, },
+	{ 118800000, { 0x001b, 0x001a, 0x001b }, },
+	{ 144000000, { 0x001b, 0x001a, 0x0034 }, },
+	{ 180000000, { 0x001b, 0x0033, 0x0034 }, },
+	{ 216000000, { 0x0036, 0x0033, 0x0034 }, },
+	{ 237600000, { 0x0036, 0x0033, 0x001b }, },
+	{ 288000000, { 0x0036, 0x001b, 0x001b }, },
+	{ 297000000, { 0x0019, 0x001b, 0x0019 }, },
+	{ 330000000, { 0x0036, 0x001b, 0x001b }, },
+	{ 594000000, { 0x003f, 0x001b, 0x001b }, },
+	{ ~0UL,      { 0x0000, 0x0000, 0x0000 }, }
+};
+
+static const struct dw_hdmi_phy_config sun50i_h6_phy_config[] = {
+	/*pixelclk   symbol   term   vlev*/
+	{ 74250000,  0x8009, 0x0004, 0x0232},
+	{ 148500000, 0x8029, 0x0004, 0x0273},
+	{ 594000000, 0x8039, 0x0004, 0x014a},
+	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+};
+
 static int sun8i_hdmi_phy_config_a83t(struct dw_hdmi *hdmi,
 				      struct sun8i_hdmi_phy *phy,
 				      unsigned int clk_rate)
@@ -290,6 +406,16 @@ static void sun8i_hdmi_phy_unlock(struct sun8i_hdmi_phy *phy)
 		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
 }
 
+static void sun50i_hdmi_phy_init_h6(struct sun8i_hdmi_phy *phy)
+{
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
+			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN,
+			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN);
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
+			   0xffff0000, 0x80c00000);
+}
+
 static void sun8i_hdmi_phy_init_a83t(struct sun8i_hdmi_phy *phy)
 {
 	sun8i_hdmi_phy_unlock(phy);
@@ -446,6 +572,13 @@ static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
 	.phy_config = &sun8i_hdmi_phy_config_h3,
 };
 
+static const struct sun8i_hdmi_phy_variant sun50i_h6_hdmi_phy = {
+	.cur_ctr  = sun50i_h6_cur_ctr,
+	.mpll_cfg = sun50i_h6_mpll_cfg,
+	.phy_cfg  = sun50i_h6_phy_config,
+	.phy_init = &sun50i_hdmi_phy_init_h6,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
@@ -463,6 +596,10 @@ static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 		.compatible = "allwinner,sun50i-a64-hdmi-phy",
 		.data = &sun50i_a64_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun50i-h6-hdmi-phy",
+		.data = &sun50i_h6_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 

commit c71c9b2fee17996dc004c37772a5c38883543229
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Sun Nov 4 19:26:58 2018 +0100

    drm/sun4i: Add support for Synopsys HDMI PHY
    
    Currently sun8i-hdmi-phy driver supports only custom PHYs connected to
    DW HDMI controller. Since newest Allwinner SoCs have unmodified Synopsys
    PHY, driver has to be reorganized to support them.
    
    Variant structure is expanded to allow differentiation between custom
    and Sysnopsys PHYs and to hold Synopsys PHY settings.
    
    Since DW HDMI bridge platform data has different fields for custom and
    Sysnopsys PHY, function sun8i_hdmi_phy_get_ops() is replaced with
    sun8i_hdmi_phy_set_ops().
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181104182705.18047-22-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index adc3ba7df7e3..635825b55648 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -390,9 +390,20 @@ void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
 	phy->variant->phy_init(phy);
 }
 
-const struct dw_hdmi_phy_ops *sun8i_hdmi_phy_get_ops(void)
+void sun8i_hdmi_phy_set_ops(struct sun8i_hdmi_phy *phy,
+			    struct dw_hdmi_plat_data *plat_data)
 {
-	return &sun8i_hdmi_phy_ops;
+	struct sun8i_hdmi_phy_variant *variant = phy->variant;
+
+	if (variant->is_custom_phy) {
+		plat_data->phy_ops = &sun8i_hdmi_phy_ops;
+		plat_data->phy_name = "sun8i_dw_hdmi_phy";
+		plat_data->phy_data = phy;
+	} else {
+		plat_data->mpll_cfg = variant->mpll_cfg;
+		plat_data->cur_ctr = variant->cur_ctr;
+		plat_data->phy_config = variant->phy_cfg;
+	}
 }
 
 static struct regmap_config sun8i_hdmi_phy_regmap_config = {
@@ -404,6 +415,7 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 };
 
 static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
+	.is_custom_phy = true,
 	.phy_init = &sun8i_hdmi_phy_init_a83t,
 	.phy_disable = &sun8i_hdmi_phy_disable_a83t,
 	.phy_config = &sun8i_hdmi_phy_config_a83t,
@@ -411,6 +423,7 @@ static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
 
 static const struct sun8i_hdmi_phy_variant sun8i_h3_hdmi_phy = {
 	.has_phy_clk = true,
+	.is_custom_phy = true,
 	.phy_init = &sun8i_hdmi_phy_init_h3,
 	.phy_disable = &sun8i_hdmi_phy_disable_h3,
 	.phy_config = &sun8i_hdmi_phy_config_h3,
@@ -419,6 +432,7 @@ static const struct sun8i_hdmi_phy_variant sun8i_h3_hdmi_phy = {
 static const struct sun8i_hdmi_phy_variant sun8i_r40_hdmi_phy = {
 	.has_phy_clk = true,
 	.has_second_pll = true,
+	.is_custom_phy = true,
 	.phy_init = &sun8i_hdmi_phy_init_h3,
 	.phy_disable = &sun8i_hdmi_phy_disable_h3,
 	.phy_config = &sun8i_hdmi_phy_config_h3,
@@ -426,6 +440,7 @@ static const struct sun8i_hdmi_phy_variant sun8i_r40_hdmi_phy = {
 
 static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
 	.has_phy_clk = true,
+	.is_custom_phy = true,
 	.phy_init = &sun8i_hdmi_phy_init_h3,
 	.phy_disable = &sun8i_hdmi_phy_disable_h3,
 	.phy_config = &sun8i_hdmi_phy_config_h3,

commit 058262b1e5395b8430b1bcd1fde9d7e2e9e42085
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Sun Nov 4 19:26:57 2018 +0100

    drm/sun4i: dw-hdmi-phy: Reorder quirks by family
    
    Currently, quirks and compatibles are sorted alphabetically. However,
    they should be sorted by family release date and then alphabetically.
    
    Fix that by moving A64 quirks and compatible to bottom. No functional
    change is made.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181104182705.18047-21-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 365cb5a9fb77..adc3ba7df7e3 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -403,13 +403,6 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 	.name		= "phy"
 };
 
-static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
-	.has_phy_clk = true,
-	.phy_init = &sun8i_hdmi_phy_init_h3,
-	.phy_disable = &sun8i_hdmi_phy_disable_h3,
-	.phy_config = &sun8i_hdmi_phy_config_h3,
-};
-
 static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
 	.phy_init = &sun8i_hdmi_phy_init_a83t,
 	.phy_disable = &sun8i_hdmi_phy_disable_a83t,
@@ -431,11 +424,14 @@ static const struct sun8i_hdmi_phy_variant sun8i_r40_hdmi_phy = {
 	.phy_config = &sun8i_hdmi_phy_config_h3,
 };
 
+static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
+	.has_phy_clk = true,
+	.phy_init = &sun8i_hdmi_phy_init_h3,
+	.phy_disable = &sun8i_hdmi_phy_disable_h3,
+	.phy_config = &sun8i_hdmi_phy_config_h3,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
-	{
-		.compatible = "allwinner,sun50i-a64-hdmi-phy",
-		.data = &sun50i_a64_hdmi_phy,
-	},
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
 		.data = &sun8i_a83t_hdmi_phy,
@@ -448,6 +444,10 @@ static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 		.compatible = "allwinner,sun8i-r40-hdmi-phy",
 		.data = &sun8i_r40_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun50i-a64-hdmi-phy",
+		.data = &sun50i_a64_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 

commit cd54074e82e08054eb9905a8d11ee9b0a281076c
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Sun Nov 4 19:26:52 2018 +0100

    drm/sun4i: Not all DW HDMI controllers has scrambled addresses
    
    Currently supported Allwinner SoCs with DW HDMI controller have
    scrambled addresses and read lock. However, that is not true in general.
    For example, A80 and H6 have normal addresses and normal read access.
    
    Move code for unscrambling addresses and unlocking read access to it's
    own function and call it from init function.
    
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181104182705.18047-16-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 471993097ced..365cb5a9fb77 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -279,8 +279,21 @@ static const struct dw_hdmi_phy_ops sun8i_hdmi_phy_ops = {
 	.setup_hpd = &dw_hdmi_phy_setup_hpd,
 };
 
+static void sun8i_hdmi_phy_unlock(struct sun8i_hdmi_phy *phy)
+{
+	/* enable read access to HDMI controller */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_READ_EN_REG,
+		     SUN8I_HDMI_PHY_READ_EN_MAGIC);
+
+	/* unscramble register offsets */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
+		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
+}
+
 static void sun8i_hdmi_phy_init_a83t(struct sun8i_hdmi_phy *phy)
 {
+	sun8i_hdmi_phy_unlock(phy);
+
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
 			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK,
 			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK);
@@ -298,6 +311,8 @@ static void sun8i_hdmi_phy_init_h3(struct sun8i_hdmi_phy *phy)
 {
 	unsigned int val;
 
+	sun8i_hdmi_phy_unlock(phy);
+
 	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG, 0);
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
 			   SUN8I_HDMI_PHY_ANA_CFG1_ENBI,
@@ -372,14 +387,6 @@ static void sun8i_hdmi_phy_init_h3(struct sun8i_hdmi_phy *phy)
 
 void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
 {
-	/* enable read access to HDMI controller */
-	regmap_write(phy->regs, SUN8I_HDMI_PHY_READ_EN_REG,
-		     SUN8I_HDMI_PHY_READ_EN_MAGIC);
-
-	/* unscramble register offsets */
-	regmap_write(phy->regs, SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
-		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
-
 	phy->variant->phy_init(phy);
 }
 

commit bf78296ab1cb215d0609ac6cff4e43e941e51265
Merge: 18eb2f6e19d7 6bf4ca7fbc85
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Sep 27 11:06:46 2018 +1000

    BackMerge v4.19-rc5 into drm-next
    
    Sean Paul requested an -rc5 backmerge from some sun4i fixes.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 3536faefc03d48e97891ed7fc542ff85ce00a4e1
Author: Icenowy Zheng <icenowy@aosc.io>
Date:   Sun Sep 16 12:34:08 2018 +0800

    drm/sun4i: add support for R40 HDMI PHY
    
    The R40 SoC has a HDMI PHY that is possible to mux two video PLLs.
    
    Add support for it.
    
    Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180916043409.62374-4-icenowy@aosc.io

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 82502b351aec..856124806353 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -417,6 +417,14 @@ static const struct sun8i_hdmi_phy_variant sun8i_h3_hdmi_phy = {
 	.phy_config = &sun8i_hdmi_phy_config_h3,
 };
 
+static const struct sun8i_hdmi_phy_variant sun8i_r40_hdmi_phy = {
+	.has_phy_clk = true,
+	.has_second_pll = true,
+	.phy_init = &sun8i_hdmi_phy_init_h3,
+	.phy_disable = &sun8i_hdmi_phy_disable_h3,
+	.phy_config = &sun8i_hdmi_phy_config_h3,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 	{
 		.compatible = "allwinner,sun50i-a64-hdmi-phy",
@@ -430,6 +438,10 @@ static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 		.compatible = "allwinner,sun8i-h3-hdmi-phy",
 		.data = &sun8i_h3_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun8i-r40-hdmi-phy",
+		.data = &sun8i_r40_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 

commit 558a9ef94a329a1ac75613407ad15d0d0071ff4c
Author: Icenowy Zheng <icenowy@aosc.io>
Date:   Sun Sep 16 12:34:06 2018 +0800

    drm: sun4i: drop second PLL from A64 HDMI PHY
    
    The A64 HDMI PHY seems to be not able to use the second video PLL as
    clock parent in experiments.
    
    Drop the support for the second PLL from A64 HDMI PHY driver.
    
    Fixes: b46e2c9f5f64 ("drm/sun4i: Add support for A64 HDMI PHY")
    Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180916043409.62374-2-icenowy@aosc.io

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 82502b351aec..a564b5dfe082 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -398,7 +398,6 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 
 static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
 	.has_phy_clk = true,
-	.has_second_pll = true,
 	.phy_init = &sun8i_hdmi_phy_init_h3,
 	.phy_disable = &sun8i_hdmi_phy_disable_h3,
 	.phy_config = &sun8i_hdmi_phy_config_h3,

commit b46e2c9f5f64a3bbd925856cab5336680ca2e9be
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:03:00 2018 +0200

    drm/sun4i: Add support for A64 HDMI PHY
    
    PHY is the same as in H3, except it can switch between two clock
    parents.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-21-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index aea46b08f127..82502b351aec 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -396,6 +396,14 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 	.name		= "phy"
 };
 
+static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
+	.has_phy_clk = true,
+	.has_second_pll = true,
+	.phy_init = &sun8i_hdmi_phy_init_h3,
+	.phy_disable = &sun8i_hdmi_phy_disable_h3,
+	.phy_config = &sun8i_hdmi_phy_config_h3,
+};
+
 static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
 	.phy_init = &sun8i_hdmi_phy_init_a83t,
 	.phy_disable = &sun8i_hdmi_phy_disable_a83t,
@@ -410,6 +418,10 @@ static const struct sun8i_hdmi_phy_variant sun8i_h3_hdmi_phy = {
 };
 
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
+	{
+		.compatible = "allwinner,sun50i-a64-hdmi-phy",
+		.data = &sun50i_a64_hdmi_phy,
+	},
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
 		.data = &sun8i_a83t_hdmi_phy,

commit c891a65a7fc940ed387ad822732f711cae554b24
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:02:59 2018 +0200

    drm/sun4i: Add support for second clock parent to DW HDMI PHY clk driver
    
    Expand HDMI PHY clock driver to support second clock parent.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-20-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index f0877b3f67e7..aea46b08f127 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -491,7 +491,8 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 			}
 		}
 
-		ret = sun8i_phy_clk_create(phy, dev);
+		ret = sun8i_phy_clk_create(phy, dev,
+					   phy->variant->has_second_pll);
 		if (ret) {
 			dev_err(dev, "Couldn't create the PHY clock\n");
 			goto err_put_clk_pll1;

commit aef13fd8426279fcd9e0b2b5b446d35c0d49ec5d
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:02:58 2018 +0200

    drm/sun4i: DW HDMI PHY: Add support for second PLL
    
    Some DW HDMI PHYs, like those found in A64 and R40 SoCs, can select
    between two clock parents.
    
    Add code which reads second PLL from DT.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-19-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index e56b9e5b1c42..f0877b3f67e7 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -482,10 +482,19 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 			goto err_put_clk_mod;
 		}
 
+		if (phy->variant->has_second_pll) {
+			phy->clk_pll1 = of_clk_get_by_name(node, "pll-1");
+			if (IS_ERR(phy->clk_pll1)) {
+				dev_err(dev, "Could not get pll-1 clock\n");
+				ret = PTR_ERR(phy->clk_pll1);
+				goto err_put_clk_pll0;
+			}
+		}
+
 		ret = sun8i_phy_clk_create(phy, dev);
 		if (ret) {
 			dev_err(dev, "Couldn't create the PHY clock\n");
-			goto err_put_clk_pll0;
+			goto err_put_clk_pll1;
 		}
 
 		clk_prepare_enable(phy->clk_phy);
@@ -528,9 +537,10 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 	reset_control_put(phy->rst_phy);
 err_disable_clk_phy:
 	clk_disable_unprepare(phy->clk_phy);
+err_put_clk_pll1:
+	clk_put(phy->clk_pll1);
 err_put_clk_pll0:
-	if (phy->variant->has_phy_clk)
-		clk_put(phy->clk_pll0);
+	clk_put(phy->clk_pll0);
 err_put_clk_mod:
 	clk_put(phy->clk_mod);
 err_put_clk_bus:
@@ -551,8 +561,8 @@ void sun8i_hdmi_phy_remove(struct sun8i_dw_hdmi *hdmi)
 
 	reset_control_put(phy->rst_phy);
 
-	if (phy->variant->has_phy_clk)
-		clk_put(phy->clk_pll0);
+	clk_put(phy->clk_pll0);
+	clk_put(phy->clk_pll1);
 	clk_put(phy->clk_mod);
 	clk_put(phy->clk_bus);
 }

commit 09f380e3ba4103a32faf4fad35d90dc144578214
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:02:57 2018 +0200

    drm/sun4i: Don't change clock bits in DW HDMI PHY driver
    
    DW HDMI PHY driver and PHY clock driver share same registers. Make sure
    that DW HDMI PHY setup code doesn't change any clock related bits.
    During initialization, set PHY PLL parent bit to 0.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-18-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 966688f04741..e56b9e5b1c42 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -183,7 +183,13 @@ static int sun8i_hdmi_phy_config_h3(struct dw_hdmi *hdmi,
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
 			   SUN8I_HDMI_PHY_ANA_CFG1_TXEN_MASK, 0);
 
-	regmap_write(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG, pll_cfg1_init);
+	/*
+	 * NOTE: We have to be careful not to overwrite PHY parent
+	 * clock selection bit and clock divider.
+	 */
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG,
+			   (u32)~SUN8I_HDMI_PHY_PLL_CFG1_CKIN_SEL_MSK,
+			   pll_cfg1_init);
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG2_REG,
 			   (u32)~SUN8I_HDMI_PHY_PLL_CFG2_PREDIV_MSK,
 			   pll_cfg2_init);
@@ -352,6 +358,10 @@ static void sun8i_hdmi_phy_init_h3(struct sun8i_hdmi_phy *phy)
 			   SUN8I_HDMI_PHY_ANA_CFG3_SCLEN |
 			   SUN8I_HDMI_PHY_ANA_CFG3_SDAEN);
 
+	/* reset PHY PLL clock parent */
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG,
+			   SUN8I_HDMI_PHY_PLL_CFG1_CKIN_SEL_MSK, 0);
+
 	/* set HW control of CEC pins */
 	regmap_write(phy->regs, SUN8I_HDMI_PHY_CEC_REG, 0);
 

commit 09773c532d30187f86a142901c27c93e629ce6ba
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:02:56 2018 +0200

    drm/sun4i: Enable DW HDMI PHY clock
    
    Current DW HDMI PHY code never prepares and enables PHY clock after it is
    created. It's just used as it is. This may work in some cases, but it's
    clearly wrong. Fix it by adding proper calls to enable/disable PHY
    clock.
    
    Fixes: 4f86e81748fe ("drm/sun4i: Add support for H3 HDMI PHY variant")
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-17-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 5a52fc489a9d..966688f04741 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -477,13 +477,15 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 			dev_err(dev, "Couldn't create the PHY clock\n");
 			goto err_put_clk_pll0;
 		}
+
+		clk_prepare_enable(phy->clk_phy);
 	}
 
 	phy->rst_phy = of_reset_control_get_shared(node, "phy");
 	if (IS_ERR(phy->rst_phy)) {
 		dev_err(dev, "Could not get phy reset control\n");
 		ret = PTR_ERR(phy->rst_phy);
-		goto err_put_clk_pll0;
+		goto err_disable_clk_phy;
 	}
 
 	ret = reset_control_deassert(phy->rst_phy);
@@ -514,6 +516,8 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 	reset_control_assert(phy->rst_phy);
 err_put_rst_phy:
 	reset_control_put(phy->rst_phy);
+err_disable_clk_phy:
+	clk_disable_unprepare(phy->clk_phy);
 err_put_clk_pll0:
 	if (phy->variant->has_phy_clk)
 		clk_put(phy->clk_pll0);
@@ -531,6 +535,7 @@ void sun8i_hdmi_phy_remove(struct sun8i_dw_hdmi *hdmi)
 
 	clk_disable_unprepare(phy->clk_mod);
 	clk_disable_unprepare(phy->clk_bus);
+	clk_disable_unprepare(phy->clk_phy);
 
 	reset_control_assert(phy->rst_phy);
 

commit 4f86e81748fe230b9cf82a7fd69884c7a08ba9d1
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Thu Mar 1 22:34:38 2018 +0100

    drm/sun4i: Add support for H3 HDMI PHY variant
    
    While A83T HDMI PHY seems to be just customized Synopsys HDMI PHY, H3
    HDMI PHY is completely custom PHY.
    
    However, they still have many things in common like clock and reset
    setup, setting sync polarity and more.
    
    Add support for H3 HDMI PHY variant.
    
    While documentation exists for this PHY variant, it doesn't go in great
    details. Because of that, almost all settings are copied from BSP linux
    4.4. Interestingly, those settings are slightly different to those found
    in a older BSP with Linux 3.4. For now, no user visible difference was
    found between them.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180301213442.16677-13-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 16889bc0c62d..5a52fc489a9d 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2018 Jernej Skrabec <jernej.skrabec@siol.net>
  */
 
+#include <linux/delay.h>
 #include <linux/of_address.h>
 
 #include "sun8i_dw_hdmi.h"
@@ -73,7 +74,148 @@ static int sun8i_hdmi_phy_config_a83t(struct dw_hdmi *hdmi,
 	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
 
 	return 0;
-};
+}
+
+static int sun8i_hdmi_phy_config_h3(struct dw_hdmi *hdmi,
+				    struct sun8i_hdmi_phy *phy,
+				    unsigned int clk_rate)
+{
+	u32 pll_cfg1_init;
+	u32 pll_cfg2_init;
+	u32 ana_cfg1_end;
+	u32 ana_cfg2_init;
+	u32 ana_cfg3_init;
+	u32 b_offset = 0;
+	u32 val;
+
+	/* bandwidth / frequency independent settings */
+
+	pll_cfg1_init = SUN8I_HDMI_PHY_PLL_CFG1_LDO2_EN |
+			SUN8I_HDMI_PHY_PLL_CFG1_LDO1_EN |
+			SUN8I_HDMI_PHY_PLL_CFG1_LDO_VSET(7) |
+			SUN8I_HDMI_PHY_PLL_CFG1_UNKNOWN(1) |
+			SUN8I_HDMI_PHY_PLL_CFG1_PLLDBEN |
+			SUN8I_HDMI_PHY_PLL_CFG1_CS |
+			SUN8I_HDMI_PHY_PLL_CFG1_CP_S(2) |
+			SUN8I_HDMI_PHY_PLL_CFG1_CNT_INT(63) |
+			SUN8I_HDMI_PHY_PLL_CFG1_BWS;
+
+	pll_cfg2_init = SUN8I_HDMI_PHY_PLL_CFG2_SV_H |
+			SUN8I_HDMI_PHY_PLL_CFG2_VCOGAIN_EN |
+			SUN8I_HDMI_PHY_PLL_CFG2_SDIV2;
+
+	ana_cfg1_end = SUN8I_HDMI_PHY_ANA_CFG1_REG_SVBH(1) |
+		       SUN8I_HDMI_PHY_ANA_CFG1_AMP_OPT |
+		       SUN8I_HDMI_PHY_ANA_CFG1_EMP_OPT |
+		       SUN8I_HDMI_PHY_ANA_CFG1_AMPCK_OPT |
+		       SUN8I_HDMI_PHY_ANA_CFG1_EMPCK_OPT |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENRCAL |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENCALOG |
+		       SUN8I_HDMI_PHY_ANA_CFG1_REG_SCKTMDS |
+		       SUN8I_HDMI_PHY_ANA_CFG1_TMDSCLK_EN |
+		       SUN8I_HDMI_PHY_ANA_CFG1_TXEN_MASK |
+		       SUN8I_HDMI_PHY_ANA_CFG1_TXEN_ALL |
+		       SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDSCLK |
+		       SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS2 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS1 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS0 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS2 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS1 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS0 |
+		       SUN8I_HDMI_PHY_ANA_CFG1_CKEN |
+		       SUN8I_HDMI_PHY_ANA_CFG1_LDOEN |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENVBS |
+		       SUN8I_HDMI_PHY_ANA_CFG1_ENBI;
+
+	ana_cfg2_init = SUN8I_HDMI_PHY_ANA_CFG2_M_EN |
+			SUN8I_HDMI_PHY_ANA_CFG2_REG_DENCK |
+			SUN8I_HDMI_PHY_ANA_CFG2_REG_DEN |
+			SUN8I_HDMI_PHY_ANA_CFG2_REG_CKSS(1) |
+			SUN8I_HDMI_PHY_ANA_CFG2_REG_CSMPS(1);
+
+	ana_cfg3_init = SUN8I_HDMI_PHY_ANA_CFG3_REG_WIRE(0x3e0) |
+			SUN8I_HDMI_PHY_ANA_CFG3_SDAEN |
+			SUN8I_HDMI_PHY_ANA_CFG3_SCLEN;
+
+	/* bandwidth / frequency dependent settings */
+	if (clk_rate <= 27000000) {
+		pll_cfg1_init |= SUN8I_HDMI_PHY_PLL_CFG1_HV_IS_33 |
+				 SUN8I_HDMI_PHY_PLL_CFG1_CNT_INT(32);
+		pll_cfg2_init |= SUN8I_HDMI_PHY_PLL_CFG2_VCO_S(4) |
+				 SUN8I_HDMI_PHY_PLL_CFG2_S(4);
+		ana_cfg1_end |= SUN8I_HDMI_PHY_ANA_CFG1_REG_CALSW;
+		ana_cfg2_init |= SUN8I_HDMI_PHY_ANA_CFG2_REG_SLV(4) |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_RESDI(phy->rcal);
+		ana_cfg3_init |= SUN8I_HDMI_PHY_ANA_CFG3_REG_AMPCK(3) |
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(5);
+	} else if (clk_rate <= 74250000) {
+		pll_cfg1_init |= SUN8I_HDMI_PHY_PLL_CFG1_HV_IS_33 |
+				 SUN8I_HDMI_PHY_PLL_CFG1_CNT_INT(32);
+		pll_cfg2_init |= SUN8I_HDMI_PHY_PLL_CFG2_VCO_S(4) |
+				 SUN8I_HDMI_PHY_PLL_CFG2_S(5);
+		ana_cfg1_end |= SUN8I_HDMI_PHY_ANA_CFG1_REG_CALSW;
+		ana_cfg2_init |= SUN8I_HDMI_PHY_ANA_CFG2_REG_SLV(4) |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_RESDI(phy->rcal);
+		ana_cfg3_init |= SUN8I_HDMI_PHY_ANA_CFG3_REG_AMPCK(5) |
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(7);
+	} else if (clk_rate <= 148500000) {
+		pll_cfg1_init |= SUN8I_HDMI_PHY_PLL_CFG1_HV_IS_33 |
+				 SUN8I_HDMI_PHY_PLL_CFG1_CNT_INT(32);
+		pll_cfg2_init |= SUN8I_HDMI_PHY_PLL_CFG2_VCO_S(4) |
+				 SUN8I_HDMI_PHY_PLL_CFG2_S(6);
+		ana_cfg2_init |= SUN8I_HDMI_PHY_ANA_CFG2_REG_BIGSWCK |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_BIGSW |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_SLV(2);
+		ana_cfg3_init |= SUN8I_HDMI_PHY_ANA_CFG3_REG_AMPCK(7) |
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(9);
+	} else {
+		b_offset = 2;
+		pll_cfg1_init |= SUN8I_HDMI_PHY_PLL_CFG1_CNT_INT(63);
+		pll_cfg2_init |= SUN8I_HDMI_PHY_PLL_CFG2_VCO_S(6) |
+				 SUN8I_HDMI_PHY_PLL_CFG2_S(7);
+		ana_cfg2_init |= SUN8I_HDMI_PHY_ANA_CFG2_REG_BIGSWCK |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_BIGSW |
+				 SUN8I_HDMI_PHY_ANA_CFG2_REG_SLV(4);
+		ana_cfg3_init |= SUN8I_HDMI_PHY_ANA_CFG3_REG_AMPCK(9) |
+				 SUN8I_HDMI_PHY_ANA_CFG3_REG_AMP(13);
+	}
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_TXEN_MASK, 0);
+
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG, pll_cfg1_init);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG2_REG,
+			   (u32)~SUN8I_HDMI_PHY_PLL_CFG2_PREDIV_MSK,
+			   pll_cfg2_init);
+	usleep_range(10000, 15000);
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_PLL_CFG3_REG,
+		     SUN8I_HDMI_PHY_PLL_CFG3_SOUT_DIV2);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG,
+			   SUN8I_HDMI_PHY_PLL_CFG1_PLLEN,
+			   SUN8I_HDMI_PHY_PLL_CFG1_PLLEN);
+	msleep(100);
+
+	/* get B value */
+	regmap_read(phy->regs, SUN8I_HDMI_PHY_ANA_STS_REG, &val);
+	val = (val & SUN8I_HDMI_PHY_ANA_STS_B_OUT_MSK) >>
+		SUN8I_HDMI_PHY_ANA_STS_B_OUT_SHIFT;
+	val = min(val + b_offset, (u32)0x3f);
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG,
+			   SUN8I_HDMI_PHY_PLL_CFG1_REG_OD1 |
+			   SUN8I_HDMI_PHY_PLL_CFG1_REG_OD,
+			   SUN8I_HDMI_PHY_PLL_CFG1_REG_OD1 |
+			   SUN8I_HDMI_PHY_PLL_CFG1_REG_OD);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG,
+			   SUN8I_HDMI_PHY_PLL_CFG1_B_IN_MSK,
+			   val << SUN8I_HDMI_PHY_PLL_CFG1_B_IN_SHIFT);
+	msleep(100);
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG, ana_cfg1_end);
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG2_REG, ana_cfg2_init);
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG3_REG, ana_cfg3_init);
+
+	return 0;
+}
 
 static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
 				 struct drm_display_mode *mode)
@@ -90,6 +232,9 @@ static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
 			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK, val);
 
+	if (phy->variant->has_phy_clk)
+		clk_set_rate(phy->clk_phy, mode->crtc_clock * 1000);
+
 	return phy->variant->phy_config(hdmi, phy, mode->crtc_clock * 1000);
 };
 
@@ -103,6 +248,16 @@ static void sun8i_hdmi_phy_disable_a83t(struct dw_hdmi *hdmi,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN, 0);
 }
 
+static void sun8i_hdmi_phy_disable_h3(struct dw_hdmi *hdmi,
+				      struct sun8i_hdmi_phy *phy)
+{
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+		     SUN8I_HDMI_PHY_ANA_CFG1_LDOEN |
+		     SUN8I_HDMI_PHY_ANA_CFG1_ENVBS |
+		     SUN8I_HDMI_PHY_ANA_CFG1_ENBI);
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_PLL_CFG1_REG, 0);
+}
+
 static void sun8i_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
 {
 	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
@@ -133,6 +288,78 @@ static void sun8i_hdmi_phy_init_a83t(struct sun8i_hdmi_phy *phy)
 			   SUN8I_HDMI_PHY_DBG_CTRL_ADDR(I2C_ADDR));
 }
 
+static void sun8i_hdmi_phy_init_h3(struct sun8i_hdmi_phy *phy)
+{
+	unsigned int val;
+
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG, 0);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENBI,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENBI);
+	udelay(5);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_TMDSCLK_EN,
+			   SUN8I_HDMI_PHY_ANA_CFG1_TMDSCLK_EN);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENVBS,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENVBS);
+	usleep_range(10, 20);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_LDOEN,
+			   SUN8I_HDMI_PHY_ANA_CFG1_LDOEN);
+	udelay(5);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_CKEN,
+			   SUN8I_HDMI_PHY_ANA_CFG1_CKEN);
+	usleep_range(40, 100);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENRCAL,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENRCAL);
+	usleep_range(100, 200);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENCALOG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENCALOG);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS0 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS1 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS2,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS0 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS1 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDS2);
+
+	/* wait for calibration to finish */
+	regmap_read_poll_timeout(phy->regs, SUN8I_HDMI_PHY_ANA_STS_REG, val,
+				 (val & SUN8I_HDMI_PHY_ANA_STS_RCALEND2D),
+				 100, 2000);
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDSCLK,
+			   SUN8I_HDMI_PHY_ANA_CFG1_ENP2S_TMDSCLK);
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG1_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS0 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS1 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS2 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDSCLK,
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS0 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS1 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDS2 |
+			   SUN8I_HDMI_PHY_ANA_CFG1_BIASEN_TMDSCLK);
+
+	/* enable DDC communication */
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_ANA_CFG3_REG,
+			   SUN8I_HDMI_PHY_ANA_CFG3_SCLEN |
+			   SUN8I_HDMI_PHY_ANA_CFG3_SDAEN,
+			   SUN8I_HDMI_PHY_ANA_CFG3_SCLEN |
+			   SUN8I_HDMI_PHY_ANA_CFG3_SDAEN);
+
+	/* set HW control of CEC pins */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_CEC_REG, 0);
+
+	/* read calibration data */
+	regmap_read(phy->regs, SUN8I_HDMI_PHY_ANA_STS_REG, &val);
+	phy->rcal = (val & SUN8I_HDMI_PHY_ANA_STS_RCAL_MASK) >> 2;
+}
+
 void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
 {
 	/* enable read access to HDMI controller */
@@ -155,7 +382,7 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 	.reg_bits	= 32,
 	.val_bits	= 32,
 	.reg_stride	= 4,
-	.max_register	= SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
+	.max_register	= SUN8I_HDMI_PHY_CEC_REG,
 	.name		= "phy"
 };
 
@@ -165,11 +392,22 @@ static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
 	.phy_config = &sun8i_hdmi_phy_config_a83t,
 };
 
+static const struct sun8i_hdmi_phy_variant sun8i_h3_hdmi_phy = {
+	.has_phy_clk = true,
+	.phy_init = &sun8i_hdmi_phy_init_h3,
+	.phy_disable = &sun8i_hdmi_phy_disable_h3,
+	.phy_config = &sun8i_hdmi_phy_config_h3,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
 		.data = &sun8i_a83t_hdmi_phy,
 	},
+	{
+		.compatible = "allwinner,sun8i-h3-hdmi-phy",
+		.data = &sun8i_h3_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 
@@ -226,11 +464,26 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 		goto err_put_clk_bus;
 	}
 
+	if (phy->variant->has_phy_clk) {
+		phy->clk_pll0 = of_clk_get_by_name(node, "pll-0");
+		if (IS_ERR(phy->clk_pll0)) {
+			dev_err(dev, "Could not get pll-0 clock\n");
+			ret = PTR_ERR(phy->clk_pll0);
+			goto err_put_clk_mod;
+		}
+
+		ret = sun8i_phy_clk_create(phy, dev);
+		if (ret) {
+			dev_err(dev, "Couldn't create the PHY clock\n");
+			goto err_put_clk_pll0;
+		}
+	}
+
 	phy->rst_phy = of_reset_control_get_shared(node, "phy");
 	if (IS_ERR(phy->rst_phy)) {
 		dev_err(dev, "Could not get phy reset control\n");
 		ret = PTR_ERR(phy->rst_phy);
-		goto err_put_clk_mod;
+		goto err_put_clk_pll0;
 	}
 
 	ret = reset_control_deassert(phy->rst_phy);
@@ -261,6 +514,9 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 	reset_control_assert(phy->rst_phy);
 err_put_rst_phy:
 	reset_control_put(phy->rst_phy);
+err_put_clk_pll0:
+	if (phy->variant->has_phy_clk)
+		clk_put(phy->clk_pll0);
 err_put_clk_mod:
 	clk_put(phy->clk_mod);
 err_put_clk_bus:
@@ -280,6 +536,8 @@ void sun8i_hdmi_phy_remove(struct sun8i_dw_hdmi *hdmi)
 
 	reset_control_put(phy->rst_phy);
 
+	if (phy->variant->has_phy_clk)
+		clk_put(phy->clk_pll0);
 	clk_put(phy->clk_mod);
 	clk_put(phy->clk_bus);
 }

commit 6876b160b70eeab5c7e0c3888f4907502a1df4a7
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Thu Mar 1 22:34:37 2018 +0100

    drm/sun4i: Move and expand DW HDMI PHY register macros
    
    DW HDMI PHY macros are moved to header file and expanded with the
    registers present on newer SoCs like H3 and H5.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180301213442.16677-12-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 17aada64bafd..16889bc0c62d 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -7,23 +7,6 @@
 
 #include "sun8i_dw_hdmi.h"
 
-#define SUN8I_HDMI_PHY_DBG_CTRL_REG	0x0000
-#define SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK		BIT(0)
-#define SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK	GENMASK(15, 8)
-#define SUN8I_HDMI_PHY_DBG_CTRL_POL_NHSYNC	BIT(8)
-#define SUN8I_HDMI_PHY_DBG_CTRL_POL_NVSYNC	BIT(9)
-#define SUN8I_HDMI_PHY_DBG_CTRL_ADDR_MASK	GENMASK(23, 16)
-#define SUN8I_HDMI_PHY_DBG_CTRL_ADDR(addr)	(addr << 16)
-
-#define SUN8I_HDMI_PHY_REXT_CTRL_REG	0x0004
-#define SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN	BIT(31)
-
-#define SUN8I_HDMI_PHY_READ_EN_REG	0x0010
-#define SUN8I_HDMI_PHY_READ_EN_MAGIC		0x54524545
-
-#define SUN8I_HDMI_PHY_UNSCRAMBLE_REG	0x0014
-#define SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC		0x42494E47
-
 /*
  * Address can be actually any value. Here is set to same value as
  * it is set in BSP driver.

commit 6fd903102c9d9e1c2807d5fbbf011b44f122b20d
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Thu Mar 1 22:34:36 2018 +0100

    drm/sun4i: Add support for variants to DW HDMI PHY
    
    There are multiple variants of DW HDMI PHYs in Allwinner SoCs. While
    some things like clock and reset setup are the same, PHY configuration
    differs a lot.
    
    Split out code which is PHY specific to separate functions and create
    a structure which holds pointers to those functions.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180301213442.16677-11-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index 9d2f11ca3538..17aada64bafd 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -30,21 +30,10 @@
  */
 #define I2C_ADDR	0x69
 
-static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
-				 struct drm_display_mode *mode)
+static int sun8i_hdmi_phy_config_a83t(struct dw_hdmi *hdmi,
+				      struct sun8i_hdmi_phy *phy,
+				      unsigned int clk_rate)
 {
-	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
-	u32 val = 0;
-
-	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
-		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NHSYNC;
-
-	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
-		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NVSYNC;
-
-	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
-			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK, val);
-
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN);
@@ -64,21 +53,21 @@ static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
 	 * release any documentation, explanation of this values can
 	 * be found in i.MX 6Dual/6Quad Reference Manual.
 	 */
-	if (mode->crtc_clock <= 27000) {
+	if (clk_rate <= 27000000) {
 		dw_hdmi_phy_i2c_write(hdmi, 0x01e0, 0x06);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x15);
 		dw_hdmi_phy_i2c_write(hdmi, 0x08da, 0x10);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0007, 0x19);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0318, 0x0e);
 		dw_hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);
-	} else if (mode->crtc_clock <= 74250) {
+	} else if (clk_rate <= 74250000) {
 		dw_hdmi_phy_i2c_write(hdmi, 0x0540, 0x06);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0005, 0x15);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x10);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0007, 0x19);
 		dw_hdmi_phy_i2c_write(hdmi, 0x02b5, 0x0e);
 		dw_hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);
-	} else if (mode->crtc_clock <= 148500) {
+	} else if (clk_rate <= 148500000) {
 		dw_hdmi_phy_i2c_write(hdmi, 0x04a0, 0x06);
 		dw_hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
 		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x10);
@@ -103,10 +92,27 @@ static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
 	return 0;
 };
 
-static void sun8i_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
+static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
+				 struct drm_display_mode *mode)
 {
 	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
+	u32 val = 0;
+
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NHSYNC;
 
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NVSYNC;
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
+			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK, val);
+
+	return phy->variant->phy_config(hdmi, phy, mode->crtc_clock * 1000);
+};
+
+static void sun8i_hdmi_phy_disable_a83t(struct dw_hdmi *hdmi,
+					struct sun8i_hdmi_phy *phy)
+{
 	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
 	dw_hdmi_phy_gen2_pddq(hdmi, 1);
 
@@ -114,6 +120,13 @@ static void sun8i_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN, 0);
 }
 
+static void sun8i_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
+{
+	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
+
+	phy->variant->phy_disable(hdmi, phy);
+}
+
 static const struct dw_hdmi_phy_ops sun8i_hdmi_phy_ops = {
 	.init = &sun8i_hdmi_phy_config,
 	.disable = &sun8i_hdmi_phy_disable,
@@ -122,16 +135,8 @@ static const struct dw_hdmi_phy_ops sun8i_hdmi_phy_ops = {
 	.setup_hpd = &dw_hdmi_phy_setup_hpd,
 };
 
-void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
+static void sun8i_hdmi_phy_init_a83t(struct sun8i_hdmi_phy *phy)
 {
-	/* enable read access to HDMI controller */
-	regmap_write(phy->regs, SUN8I_HDMI_PHY_READ_EN_REG,
-		     SUN8I_HDMI_PHY_READ_EN_MAGIC);
-
-	/* unscramble register offsets */
-	regmap_write(phy->regs, SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
-		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
-
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
 			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK,
 			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK);
@@ -145,6 +150,19 @@ void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
 			   SUN8I_HDMI_PHY_DBG_CTRL_ADDR(I2C_ADDR));
 }
 
+void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
+{
+	/* enable read access to HDMI controller */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_READ_EN_REG,
+		     SUN8I_HDMI_PHY_READ_EN_MAGIC);
+
+	/* unscramble register offsets */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
+		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
+
+	phy->variant->phy_init(phy);
+}
+
 const struct dw_hdmi_phy_ops *sun8i_hdmi_phy_get_ops(void)
 {
 	return &sun8i_hdmi_phy_ops;
@@ -158,20 +176,31 @@ static struct regmap_config sun8i_hdmi_phy_regmap_config = {
 	.name		= "phy"
 };
 
+static const struct sun8i_hdmi_phy_variant sun8i_a83t_hdmi_phy = {
+	.phy_init = &sun8i_hdmi_phy_init_a83t,
+	.phy_disable = &sun8i_hdmi_phy_disable_a83t,
+	.phy_config = &sun8i_hdmi_phy_config_a83t,
+};
+
 static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
-	{ .compatible = "allwinner,sun8i-a83t-hdmi-phy" },
+	{
+		.compatible = "allwinner,sun8i-a83t-hdmi-phy",
+		.data = &sun8i_a83t_hdmi_phy,
+	},
 	{ /* sentinel */ }
 };
 
 int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 {
+	const struct of_device_id *match;
 	struct device *dev = hdmi->dev;
 	struct sun8i_hdmi_phy *phy;
 	struct resource res;
 	void __iomem *regs;
 	int ret;
 
-	if (!of_match_node(sun8i_hdmi_phy_of_table, node)) {
+	match = of_match_node(sun8i_hdmi_phy_of_table, node);
+	if (!match) {
 		dev_err(dev, "Incompatible HDMI PHY\n");
 		return -EINVAL;
 	}
@@ -180,6 +209,8 @@ int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
 	if (!phy)
 		return -ENOMEM;
 
+	phy->variant = (struct sun8i_hdmi_phy_variant *)match->data;
+
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
 		dev_err(dev, "phy: Couldn't get our resources\n");

commit e420ccd66d36e4ac2035620286495ce13a40b7f7
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Thu Mar 1 22:34:35 2018 +0100

    drm/sun4i: Fix polarity configuration for DW HDMI PHY
    
    Current polarity configuration code is cleary wrong since it compares
    same flag two times. However, even if flag name is fixed, it won't work
    well for resolutions which have one polarity positive and another
    negative.
    
    Fix that by properly set each bit according to each polarity. Since
    those two bits are not described in any documentation, relationships
    were obtained by experimentation.
    
    Fixes: b7c7436a5ff0 ("drm/sun4i: Implement A83T HDMI driver")
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180301213442.16677-10-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
index e5bfcdd43ec9..9d2f11ca3538 100644
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -10,7 +10,8 @@
 #define SUN8I_HDMI_PHY_DBG_CTRL_REG	0x0000
 #define SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK		BIT(0)
 #define SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK	GENMASK(15, 8)
-#define SUN8I_HDMI_PHY_DBG_CTRL_POL(val)	(val << 8)
+#define SUN8I_HDMI_PHY_DBG_CTRL_POL_NHSYNC	BIT(8)
+#define SUN8I_HDMI_PHY_DBG_CTRL_POL_NVSYNC	BIT(9)
 #define SUN8I_HDMI_PHY_DBG_CTRL_ADDR_MASK	GENMASK(23, 16)
 #define SUN8I_HDMI_PHY_DBG_CTRL_ADDR(addr)	(addr << 16)
 
@@ -35,14 +36,14 @@ static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
 	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
 	u32 val = 0;
 
-	if ((mode->flags & DRM_MODE_FLAG_NHSYNC) &&
-	    (mode->flags & DRM_MODE_FLAG_NHSYNC)) {
-		val = 0x03;
-	}
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NHSYNC;
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		val |= SUN8I_HDMI_PHY_DBG_CTRL_POL_NVSYNC;
 
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
-			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK,
-			   SUN8I_HDMI_PHY_DBG_CTRL_POL(val));
+			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK, val);
 
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN,

commit b7c7436a5ff0dd6a37de16310a7154cbfaca3a64
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Wed Feb 14 21:09:04 2018 +0100

    drm/sun4i: Implement A83T HDMI driver
    
    A83T has DW HDMI IP block with a custom PHY similar to Synopsys gen2
    HDMI PHY.
    
    Only video output was tested, while HW also supports audio and CEC.
    Support for them will be added later.
    
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180214200906.31509-11-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
new file mode 100644
index 000000000000..e5bfcdd43ec9
--- /dev/null
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2018 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#include <linux/of_address.h>
+
+#include "sun8i_dw_hdmi.h"
+
+#define SUN8I_HDMI_PHY_DBG_CTRL_REG	0x0000
+#define SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK		BIT(0)
+#define SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK	GENMASK(15, 8)
+#define SUN8I_HDMI_PHY_DBG_CTRL_POL(val)	(val << 8)
+#define SUN8I_HDMI_PHY_DBG_CTRL_ADDR_MASK	GENMASK(23, 16)
+#define SUN8I_HDMI_PHY_DBG_CTRL_ADDR(addr)	(addr << 16)
+
+#define SUN8I_HDMI_PHY_REXT_CTRL_REG	0x0004
+#define SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN	BIT(31)
+
+#define SUN8I_HDMI_PHY_READ_EN_REG	0x0010
+#define SUN8I_HDMI_PHY_READ_EN_MAGIC		0x54524545
+
+#define SUN8I_HDMI_PHY_UNSCRAMBLE_REG	0x0014
+#define SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC		0x42494E47
+
+/*
+ * Address can be actually any value. Here is set to same value as
+ * it is set in BSP driver.
+ */
+#define I2C_ADDR	0x69
+
+static int sun8i_hdmi_phy_config(struct dw_hdmi *hdmi, void *data,
+				 struct drm_display_mode *mode)
+{
+	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
+	u32 val = 0;
+
+	if ((mode->flags & DRM_MODE_FLAG_NHSYNC) &&
+	    (mode->flags & DRM_MODE_FLAG_NHSYNC)) {
+		val = 0x03;
+	}
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
+			   SUN8I_HDMI_PHY_DBG_CTRL_POL_MASK,
+			   SUN8I_HDMI_PHY_DBG_CTRL_POL(val));
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
+			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN,
+			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN);
+
+	/* power down */
+	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
+	dw_hdmi_phy_gen2_pddq(hdmi, 1);
+
+	dw_hdmi_phy_reset(hdmi);
+
+	dw_hdmi_phy_gen2_pddq(hdmi, 0);
+
+	dw_hdmi_phy_i2c_set_addr(hdmi, I2C_ADDR);
+
+	/*
+	 * Values are taken from BSP HDMI driver. Although AW didn't
+	 * release any documentation, explanation of this values can
+	 * be found in i.MX 6Dual/6Quad Reference Manual.
+	 */
+	if (mode->crtc_clock <= 27000) {
+		dw_hdmi_phy_i2c_write(hdmi, 0x01e0, 0x06);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x15);
+		dw_hdmi_phy_i2c_write(hdmi, 0x08da, 0x10);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0007, 0x19);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0318, 0x0e);
+		dw_hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);
+	} else if (mode->crtc_clock <= 74250) {
+		dw_hdmi_phy_i2c_write(hdmi, 0x0540, 0x06);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0005, 0x15);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x10);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0007, 0x19);
+		dw_hdmi_phy_i2c_write(hdmi, 0x02b5, 0x0e);
+		dw_hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);
+	} else if (mode->crtc_clock <= 148500) {
+		dw_hdmi_phy_i2c_write(hdmi, 0x04a0, 0x06);
+		dw_hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x10);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0002, 0x19);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0021, 0x0e);
+		dw_hdmi_phy_i2c_write(hdmi, 0x8029, 0x09);
+	} else {
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x06);
+		dw_hdmi_phy_i2c_write(hdmi, 0x000f, 0x15);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x10);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0002, 0x19);
+		dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x0e);
+		dw_hdmi_phy_i2c_write(hdmi, 0x802b, 0x09);
+	}
+
+	dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x1e);
+	dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x13);
+	dw_hdmi_phy_i2c_write(hdmi, 0x0000, 0x17);
+
+	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
+
+	return 0;
+};
+
+static void sun8i_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
+{
+	struct sun8i_hdmi_phy *phy = (struct sun8i_hdmi_phy *)data;
+
+	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
+	dw_hdmi_phy_gen2_pddq(hdmi, 1);
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
+			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN, 0);
+}
+
+static const struct dw_hdmi_phy_ops sun8i_hdmi_phy_ops = {
+	.init = &sun8i_hdmi_phy_config,
+	.disable = &sun8i_hdmi_phy_disable,
+	.read_hpd = &dw_hdmi_phy_read_hpd,
+	.update_hpd = &dw_hdmi_phy_update_hpd,
+	.setup_hpd = &dw_hdmi_phy_setup_hpd,
+};
+
+void sun8i_hdmi_phy_init(struct sun8i_hdmi_phy *phy)
+{
+	/* enable read access to HDMI controller */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_READ_EN_REG,
+		     SUN8I_HDMI_PHY_READ_EN_MAGIC);
+
+	/* unscramble register offsets */
+	regmap_write(phy->regs, SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
+		     SUN8I_HDMI_PHY_UNSCRAMBLE_MAGIC);
+
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
+			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK,
+			   SUN8I_HDMI_PHY_DBG_CTRL_PX_LOCK);
+
+	/*
+	 * Set PHY I2C address. It must match to the address set by
+	 * dw_hdmi_phy_set_slave_addr().
+	 */
+	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_DBG_CTRL_REG,
+			   SUN8I_HDMI_PHY_DBG_CTRL_ADDR_MASK,
+			   SUN8I_HDMI_PHY_DBG_CTRL_ADDR(I2C_ADDR));
+}
+
+const struct dw_hdmi_phy_ops *sun8i_hdmi_phy_get_ops(void)
+{
+	return &sun8i_hdmi_phy_ops;
+}
+
+static struct regmap_config sun8i_hdmi_phy_regmap_config = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= SUN8I_HDMI_PHY_UNSCRAMBLE_REG,
+	.name		= "phy"
+};
+
+static const struct of_device_id sun8i_hdmi_phy_of_table[] = {
+	{ .compatible = "allwinner,sun8i-a83t-hdmi-phy" },
+	{ /* sentinel */ }
+};
+
+int sun8i_hdmi_phy_probe(struct sun8i_dw_hdmi *hdmi, struct device_node *node)
+{
+	struct device *dev = hdmi->dev;
+	struct sun8i_hdmi_phy *phy;
+	struct resource res;
+	void __iomem *regs;
+	int ret;
+
+	if (!of_match_node(sun8i_hdmi_phy_of_table, node)) {
+		dev_err(dev, "Incompatible HDMI PHY\n");
+		return -EINVAL;
+	}
+
+	phy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);
+	if (!phy)
+		return -ENOMEM;
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret) {
+		dev_err(dev, "phy: Couldn't get our resources\n");
+		return ret;
+	}
+
+	regs = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(regs)) {
+		dev_err(dev, "Couldn't map the HDMI PHY registers\n");
+		return PTR_ERR(regs);
+	}
+
+	phy->regs = devm_regmap_init_mmio(dev, regs,
+					  &sun8i_hdmi_phy_regmap_config);
+	if (IS_ERR(phy->regs)) {
+		dev_err(dev, "Couldn't create the HDMI PHY regmap\n");
+		return PTR_ERR(phy->regs);
+	}
+
+	phy->clk_bus = of_clk_get_by_name(node, "bus");
+	if (IS_ERR(phy->clk_bus)) {
+		dev_err(dev, "Could not get bus clock\n");
+		return PTR_ERR(phy->clk_bus);
+	}
+
+	phy->clk_mod = of_clk_get_by_name(node, "mod");
+	if (IS_ERR(phy->clk_mod)) {
+		dev_err(dev, "Could not get mod clock\n");
+		ret = PTR_ERR(phy->clk_mod);
+		goto err_put_clk_bus;
+	}
+
+	phy->rst_phy = of_reset_control_get_shared(node, "phy");
+	if (IS_ERR(phy->rst_phy)) {
+		dev_err(dev, "Could not get phy reset control\n");
+		ret = PTR_ERR(phy->rst_phy);
+		goto err_put_clk_mod;
+	}
+
+	ret = reset_control_deassert(phy->rst_phy);
+	if (ret) {
+		dev_err(dev, "Cannot deassert phy reset control: %d\n", ret);
+		goto err_put_rst_phy;
+	}
+
+	ret = clk_prepare_enable(phy->clk_bus);
+	if (ret) {
+		dev_err(dev, "Cannot enable bus clock: %d\n", ret);
+		goto err_deassert_rst_phy;
+	}
+
+	ret = clk_prepare_enable(phy->clk_mod);
+	if (ret) {
+		dev_err(dev, "Cannot enable mod clock: %d\n", ret);
+		goto err_disable_clk_bus;
+	}
+
+	hdmi->phy = phy;
+
+	return 0;
+
+err_disable_clk_bus:
+	clk_disable_unprepare(phy->clk_bus);
+err_deassert_rst_phy:
+	reset_control_assert(phy->rst_phy);
+err_put_rst_phy:
+	reset_control_put(phy->rst_phy);
+err_put_clk_mod:
+	clk_put(phy->clk_mod);
+err_put_clk_bus:
+	clk_put(phy->clk_bus);
+
+	return ret;
+}
+
+void sun8i_hdmi_phy_remove(struct sun8i_dw_hdmi *hdmi)
+{
+	struct sun8i_hdmi_phy *phy = hdmi->phy;
+
+	clk_disable_unprepare(phy->clk_mod);
+	clk_disable_unprepare(phy->clk_bus);
+
+	reset_control_assert(phy->rst_phy);
+
+	reset_control_put(phy->rst_phy);
+
+	clk_put(phy->clk_mod);
+	clk_put(phy->clk_bus);
+}
