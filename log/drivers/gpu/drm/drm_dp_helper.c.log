commit 5afeb97a1844dd32c3065fa03e9ef121a6b37c18
Merge: 7dbbdd37f2ae 6f27e4c287d7
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 28 15:38:26 2020 +1000

    Merge tag 'drm-misc-next-fixes-2020-05-27' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    Short summary of fixes pull (less than what git shortlog provides):
    
    There's a fix for panel brighness on Lenovo X13 Yoga devices and a fix for
    -Wformat warnings on architectures where atomic-64 counters are not of
    type unsigned long long.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200527080123.GA8186@linux-uq9g

commit 0df3ff451287d71c620384eb7bb2cd3a8106412c
Author: Mark Pearson <mpearson.lenovo@gmail.com>
Date:   Mon May 18 22:56:35 2020 -0400

    drm/dp: Lenovo X13 Yoga OLED panel brightness fix
    
    Add another panel that needs the edid quirk to the list so that
    brightness control works correctly. Fixes issue seen on Lenovo X13 Yoga
    with OLED panel
    
    Co-developed-by: jendrina@lenovo.com
    Signed-off-by: Mark Pearson <mpearson@gmail.com>
    [fixed commit message, sobs]
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200519025635.22846-1-mpearson@lenovo.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index c6fbe6e6bc9d..41f0e797ce8c 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1313,6 +1313,7 @@ static const struct edid_quirk edid_quirk_list[] = {
 	{ MFG(0x06, 0xaf), PROD_ID(0xeb, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 	{ MFG(0x4d, 0x10), PROD_ID(0xc7, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 	{ MFG(0x4d, 0x10), PROD_ID(0xe6, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
+	{ MFG(0x4c, 0x83), PROD_ID(0x47, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 };
 
 #undef MFG

commit 2ba6221cca7e25bd05a416b0e64afb6a5b28dc9b
Author: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Date:   Thu May 14 09:07:21 2020 +0300

    drm: Add logging function for DP VSC SDP
    
    When receiving video it is very useful to be able to log DP VSC SDP.
    This greatly simplifies debugging.
    
    v2: Minor style fix
    v3: Move logging functions to drm core [Jani N]
    v5: Rebased
    v10: Rebased
    
    Signed-off-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200514060732.3378396-4-gwan-gyeong.mun@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 612a59ec8116..43e57632b00a 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1629,3 +1629,177 @@ int drm_dp_set_phy_test_pattern(struct drm_dp_aux *aux,
 	return 0;
 }
 EXPORT_SYMBOL(drm_dp_set_phy_test_pattern);
+
+static const char *dp_pixelformat_get_name(enum dp_pixelformat pixelformat)
+{
+	if (pixelformat < 0 || pixelformat > DP_PIXELFORMAT_RESERVED)
+		return "Invalid";
+
+	switch (pixelformat) {
+	case DP_PIXELFORMAT_RGB:
+		return "RGB";
+	case DP_PIXELFORMAT_YUV444:
+		return "YUV444";
+	case DP_PIXELFORMAT_YUV422:
+		return "YUV422";
+	case DP_PIXELFORMAT_YUV420:
+		return "YUV420";
+	case DP_PIXELFORMAT_Y_ONLY:
+		return "Y_ONLY";
+	case DP_PIXELFORMAT_RAW:
+		return "RAW";
+	default:
+		return "Reserved";
+	}
+}
+
+static const char *dp_colorimetry_get_name(enum dp_pixelformat pixelformat,
+					   enum dp_colorimetry colorimetry)
+{
+	if (pixelformat < 0 || pixelformat > DP_PIXELFORMAT_RESERVED)
+		return "Invalid";
+
+	switch (colorimetry) {
+	case DP_COLORIMETRY_DEFAULT:
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "sRGB";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "BT.601";
+		case DP_PIXELFORMAT_Y_ONLY:
+			return "DICOM PS3.14";
+		case DP_PIXELFORMAT_RAW:
+			return "Custom Color Profile";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_RGB_WIDE_FIXED: /* and DP_COLORIMETRY_BT709_YCC */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "Wide Fixed";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "BT.709";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_RGB_WIDE_FLOAT: /* and DP_COLORIMETRY_XVYCC_601 */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "Wide Float";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "xvYCC 601";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_OPRGB: /* and DP_COLORIMETRY_XVYCC_709 */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "OpRGB";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "xvYCC 709";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_DCI_P3_RGB: /* and DP_COLORIMETRY_SYCC_601 */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "DCI-P3";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "sYCC 601";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_RGB_CUSTOM: /* and DP_COLORIMETRY_OPYCC_601 */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "Custom Profile";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "OpYCC 601";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_BT2020_RGB: /* and DP_COLORIMETRY_BT2020_CYCC */
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_RGB:
+			return "BT.2020 RGB";
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "BT.2020 CYCC";
+		default:
+			return "Reserved";
+		}
+	case DP_COLORIMETRY_BT2020_YCC:
+		switch (pixelformat) {
+		case DP_PIXELFORMAT_YUV444:
+		case DP_PIXELFORMAT_YUV422:
+		case DP_PIXELFORMAT_YUV420:
+			return "BT.2020 YCC";
+		default:
+			return "Reserved";
+		}
+	default:
+		return "Invalid";
+	}
+}
+
+static const char *dp_dynamic_range_get_name(enum dp_dynamic_range dynamic_range)
+{
+	switch (dynamic_range) {
+	case DP_DYNAMIC_RANGE_VESA:
+		return "VESA range";
+	case DP_DYNAMIC_RANGE_CTA:
+		return "CTA range";
+	default:
+		return "Invalid";
+	}
+}
+
+static const char *dp_content_type_get_name(enum dp_content_type content_type)
+{
+	switch (content_type) {
+	case DP_CONTENT_TYPE_NOT_DEFINED:
+		return "Not defined";
+	case DP_CONTENT_TYPE_GRAPHICS:
+		return "Graphics";
+	case DP_CONTENT_TYPE_PHOTO:
+		return "Photo";
+	case DP_CONTENT_TYPE_VIDEO:
+		return "Video";
+	case DP_CONTENT_TYPE_GAME:
+		return "Game";
+	default:
+		return "Reserved";
+	}
+}
+
+void drm_dp_vsc_sdp_log(const char *level, struct device *dev,
+			const struct drm_dp_vsc_sdp *vsc)
+{
+#define DP_SDP_LOG(fmt, ...) dev_printk(level, dev, fmt, ##__VA_ARGS__)
+	DP_SDP_LOG("DP SDP: %s, revision %u, length %u\n", "VSC",
+		   vsc->revision, vsc->length);
+	DP_SDP_LOG("    pixelformat: %s\n",
+		   dp_pixelformat_get_name(vsc->pixelformat));
+	DP_SDP_LOG("    colorimetry: %s\n",
+		   dp_colorimetry_get_name(vsc->pixelformat, vsc->colorimetry));
+	DP_SDP_LOG("    bpc: %u\n", vsc->bpc);
+	DP_SDP_LOG("    dynamic range: %s\n",
+		   dp_dynamic_range_get_name(vsc->dynamic_range));
+	DP_SDP_LOG("    content type: %s\n",
+		   dp_content_type_get_name(vsc->content_type));
+#undef DP_SDP_LOG
+}
+EXPORT_SYMBOL(drm_dp_vsc_sdp_log);

commit cef622d7634e0adc351d795f089e7b77700272ca
Merge: 2b703bbda271 8cdf72711928
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 16 14:36:38 2020 +0300

    Merge tag 'topic/phy-compliance-2020-04-08' of git://anongit.freedesktop.org/drm/drm-misc into drm-intel-next-queued
    
    Topic pull request for topic/phy-compliance:
    - Standardize DP_PHY_TEST_PATTERN name.
    - Add support for setting/getting test pattern from sink.
    - Implement DP PHY compliance to i915.
    
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/efb3d0d9-2cf7-046b-3a9b-2548d086258e@linux.intel.com
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 2b703bbda2713fd2a7d98029ea6c44f9c3159f34
Merge: 3ffaf56e912e 8f3d9f354286
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Apr 16 14:35:16 2020 +0300

    Merge drm/drm-next into drm-intel-next-queued
    
    Backmerging in order to pull "topic/phy-compliance".
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 4342f839ae7e6117977c9e867a49645cc7625c5a
Author: Animesh Manna <animesh.manna@intel.com>
Date:   Mon Mar 16 16:07:54 2020 +0530

    drm/dp: get/set phy compliance pattern
    
    During phy compliance auto test mode source need to read
    requested test pattern from sink through DPCD. After processing
    the request source need to set the pattern. So set/get method
    added in drm layer as it is DP protocol.
    
    v2: As per review feedback from Manasi on RFC version,
    - added dp revision as function argument in set_phy_pattern api.
    - used int for link_rate and u8 for lane_count to align with existing code.
    
    v3: As per review feedback from Harry,
    - used sizeof() instead of magic number.
    - corrected kernel-doc for drm_dp_phy_test_params structure.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Animesh Manna <animesh.manna@intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200316103759.12867-3-animesh.manna@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index c6fbe6e6bc9d..28e59d1ffa93 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1533,3 +1533,97 @@ int drm_dp_dsc_sink_supported_input_bpcs(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_S
 	return num_bpc;
 }
 EXPORT_SYMBOL(drm_dp_dsc_sink_supported_input_bpcs);
+
+/**
+ * drm_dp_get_phy_test_pattern() - get the requested pattern from the sink.
+ * @aux: DisplayPort AUX channel
+ * @data: DP phy compliance test parameters.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_get_phy_test_pattern(struct drm_dp_aux *aux,
+				struct drm_dp_phy_test_params *data)
+{
+	int err;
+	u8 rate, lanes;
+
+	err = drm_dp_dpcd_readb(aux, DP_TEST_LINK_RATE, &rate);
+	if (err < 0)
+		return err;
+	data->link_rate = drm_dp_bw_code_to_link_rate(rate);
+
+	err = drm_dp_dpcd_readb(aux, DP_TEST_LANE_COUNT, &lanes);
+	if (err < 0)
+		return err;
+	data->num_lanes = lanes & DP_MAX_LANE_COUNT_MASK;
+
+	if (lanes & DP_ENHANCED_FRAME_CAP)
+		data->enhanced_frame_cap = true;
+
+	err = drm_dp_dpcd_readb(aux, DP_PHY_TEST_PATTERN, &data->phy_pattern);
+	if (err < 0)
+		return err;
+
+	switch (data->phy_pattern) {
+	case DP_PHY_TEST_PATTERN_80BIT_CUSTOM:
+		err = drm_dp_dpcd_read(aux, DP_TEST_80BIT_CUSTOM_PATTERN_7_0,
+				       &data->custom80, sizeof(data->custom80));
+		if (err < 0)
+			return err;
+
+		break;
+	case DP_PHY_TEST_PATTERN_CP2520:
+		err = drm_dp_dpcd_read(aux, DP_TEST_HBR2_SCRAMBLER_RESET,
+				       &data->hbr2_reset,
+				       sizeof(data->hbr2_reset));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_get_phy_test_pattern);
+
+/**
+ * drm_dp_set_phy_test_pattern() - set the pattern to the sink.
+ * @aux: DisplayPort AUX channel
+ * @data: DP phy compliance test parameters.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_set_phy_test_pattern(struct drm_dp_aux *aux,
+				struct drm_dp_phy_test_params *data, u8 dp_rev)
+{
+	int err, i;
+	u8 link_config[2];
+	u8 test_pattern;
+
+	link_config[0] = drm_dp_link_rate_to_bw_code(data->link_rate);
+	link_config[1] = data->num_lanes;
+	if (data->enhanced_frame_cap)
+		link_config[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
+	err = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, link_config, 2);
+	if (err < 0)
+		return err;
+
+	test_pattern = data->phy_pattern;
+	if (dp_rev < 0x12) {
+		test_pattern = (test_pattern << 2) &
+			       DP_LINK_QUAL_PATTERN_11_MASK;
+		err = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET,
+					 test_pattern);
+		if (err < 0)
+			return err;
+	} else {
+		for (i = 0; i < data->num_lanes; i++) {
+			err = drm_dp_dpcd_writeb(aux,
+						 DP_LINK_QUAL_LANE0_SET + i,
+						 test_pattern);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_set_phy_test_pattern);

commit 9001b17698d86f842e2b13e0cafe8021d43209e9
Merge: bda1fb0ed000 217a485c8399
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 19 10:39:27 2020 +1000

    Merge tag 'drm-intel-next-2020-03-13' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    UAPI Changes:
    
    On i915 we have a new UAPI to allow userspace to specify CS ring buffer size on
    construction (I915_CONTEXT_PARAM_RINGSIZE) and also new sysfs entries exposing
    various engine properties
    
    GVT Changes:
    
    VFIO edid getting expanded to all platforms and a big cleanup around attr
    group, unused vblank complete, kvmgt, Intel engine and dev_priv usages.
    
    i915 Changes:
    
    - new UAPI to allow userspace to specify CS ring buffer size on construction
      (I915_CONTEXT_PARAM_RINGSIZE) -  (Chris)
    - New sysfs entries exposing various engine properties (Chris)
    - Tiger Lake is out of require_force_probe protection (Jose)
    - Changes in many places around active requests, reset and heartbeat (Chris)
    - Stop assigning drm-dev_private pointer (Jani)
    - Many code refactor in many places, including intel_modeset_init,
      increasing use of intel_uncore_*, vgpu, and gvt stuff (Jani)
    - Fixes around display pipe iterators (Anshuman)
    - Tigerlake enabling work (Matt Ropper, Matt Atwood, Ville, Lucas, Daniele,
      Jose, Anusha, Vivek, Swathi, Caz. Kai)
    - Code clean-up like reducing use of drm/i915_drv.h, removing unused
      registers, removing garbage warns, and some other code polishing (Jani, Lucas,
      Ville)
    - Selftests fixes, improvements and additions (Chris, Dan, Aditya, Matt Auld)
    - Fix plane possible_crtcs bit mask (Anshuman)
    - Fixes and cleanup on GLK pre production identification and w/a (Ville)
    - Fix display orientation on few cases (Hans, Ville)
    - dbuf clean-up and improvements for slice arrays handling (Ville)
    - Improvement around min cdclk calculation (Stanislav)
    - Fixes and refactor around display PLLs (Imre)
    - Other execlists and perf fixes (Chris)
    - Documentation fixes (Jani, Chris)
    - Fix build issue (Anshuman)
    - Many more fixes around the locking mechanisms (Chris)
    - Other fixes and debugability info around preemption (Chris, Tvrtko)
    - Add mechanism to submit a context WA on ring submission (Mika)
    - Clear all Eu/L3 resitual context (Prathap)
    - More changes around local memory (Abdiel, Matt, Chris)
    - Fix RPS (Chris)
    - DP MST fix (Lyude)
    - Display FBC fixes (Jose, RK)
    - debugfs cleanup (Tvrtko)
    - More convertion towards drm_debive based loggin (Wambui, Ram)
    - Avoid potential buffer overflow (Takashi)
    - Ice Lake and Elkhart Lake workarounds (Matt Roper)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200314001535.GA2969344@intel.com

commit 639e0db2d70fb84833d96e782cc4a01825e03b13
Author: Mario Kleiner <mario.kleiner.de@gmail.com>
Date:   Mon Mar 16 05:23:40 2020 +0100

    drm/i915/dp: Add dpcd link_rate quirk for Apple 15" MBP 2017 (v3)
    
    This fixes a problem found on the MacBookPro 2017 Retina panel.
    
    The panel reports 10 bpc color depth in its EDID, and the
    firmware chooses link settings at boot which support enough
    bandwidth for 10 bpc (324000 kbit/sec = multiplier 0xc),
    but the DP_MAX_LINK_RATE dpcd register only reports
    2.7 Gbps (multiplier value 0xa) as possible, in direct
    contradiction of what the firmware successfully set up.
    
    This restricts the panel to 8 bpc, not providing the full
    color depth of the panel.
    
    This patch adds a quirk specific to the MBP 2017 15" Retina
    panel to add the additiional 324000 kbps link rate during
    edp setup.
    
    Link to previous discussion of a different attempted fix
    with Ville and Jani:
    
    https://patchwork.kernel.org/patch/11325935/
    
    v2: Follow Jani's proposal of defining quirk_rates[] instead
        of just appending 324000. This for better clarity.
    
    v3: Rebased onto current drm-tip, as of 16-March-2020. Adapt
        to new edid_quirks parameter of drm_dp_has_quirk().
    
    Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
    Tested-by: Mario Kleiner <mario.kleiner.de@gmail.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200316042340.4783-1-mario.kleiner.de@gmail.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 620d78ff2706..688c475d52b5 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1179,6 +1179,8 @@ static const struct dpcd_quirk dpcd_quirk_list[] = {
 	{ OUI(0x00, 0x00, 0x00), DEVICE_ID('C', 'H', '7', '5', '1', '1'), false, BIT(DP_DPCD_QUIRK_NO_SINK_COUNT) },
 	/* Synaptics DP1.4 MST hubs can support DSC without virtual DPCD */
 	{ OUI(0x90, 0xCC, 0x24), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD) },
+	/* Apple MacBookPro 2017 15 inch eDP Retina panel reports too low DP_MAX_LINK_RATE */
+	{ OUI(0x00, 0x10, 0xfa), DEVICE_ID(101, 68, 21, 101, 98, 97), false, BIT(DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS) },
 };
 
 #undef OUI

commit ba518bbd3f3c265419fa8c3702940cb7c642c6a5
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Feb 11 13:33:48 2020 -0500

    drm/i915: Force DPCD backlight mode for some Dell CML 2020 panels
    
    According to Dell, trying to match their panels via OUI is not reliable
    enough and we've been told that we should check against the EDID
    instead. As well, Dell seems to have some panels that are actually
    intended to switch between using PWM for backlight controls and DPCD for
    backlight controls depending on whether or not the panel is in HDR or
    SDR mode. Yikes.
    
    Regardless, we need to add quirks for these so that DPCD backlight
    controls get enabled by default, since without additional driver support
    that's the only form of brightness control that will work. Hopefully in
    the future we can remove these quirks once we have a better way of
    probing for this.
    
    Changes since v1:
    * Add one more EDID per Dell's request
    * Remove model number (which is possibly wrong) and replace with Dell
      CML 2020 systems
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211183358.157448-4-lyude@redhat.com
    Reviewed-by: Adam Jackson <ajax@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index a39c3cdacb20..620d78ff2706 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1240,6 +1240,20 @@ static const struct edid_quirk edid_quirk_list[] = {
 	 * only supports DPCD backlight controls
 	 */
 	{ MFG(0x4c, 0x83), PROD_ID(0x41, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
+	/*
+	 * Some Dell CML 2020 systems have panels support both AUX and PWM
+	 * backlight control, and some only support AUX backlight control. All
+	 * said panels start up in AUX mode by default, and we don't have any
+	 * support for disabling HDR mode on these panels which would be
+	 * required to switch to PWM backlight control mode (plus, I'm not
+	 * even sure we want PWM backlight controls over DPCD backlight
+	 * controls anyway...). Until we have a better way of detecting these,
+	 * force DPCD backlight mode on all of them.
+	 */
+	{ MFG(0x06, 0xaf), PROD_ID(0x9b, 0x32), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
+	{ MFG(0x06, 0xaf), PROD_ID(0xeb, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
+	{ MFG(0x4d, 0x10), PROD_ID(0xc7, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
+	{ MFG(0x4d, 0x10), PROD_ID(0xe6, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 };
 
 #undef MFG

commit 17f5d57915be108b4967b7770c9ea87c493b30a7
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 3 16:53:18 2020 -0500

    drm/i915: Force DPCD backlight mode on X1 Extreme 2nd Gen 4K AMOLED panel
    
    The X1 Extreme is one of the systems that lies about which backlight
    interface that it uses in its VBIOS as PWM backlight controls don't work
    at all on this machine. It's possible that this panel could be one of
    the infamous ones that can switch between PWM mode and DPCD backlight
    control mode, but we haven't gotten any more details on this from Lenovo
    just yet. For the time being though, making sure the backlight 'just
    works' is a bit more important.
    
    So, add a quirk to force DPCD backlight controls on for these systems
    based on EDID (since this panel doesn't appear to fill in the device ID).
    Hopefully in the future we'll figure out a better way of probing this.
    
    Changes since v2:
    * The bugzilla URL is deprecated, bug reporting happens on gitlab now.
      Update the messages we print to reflect this
    * Also, take the opportunity to move FDO_BUG_URL out of i915_utils.c and
      into i915_utils.h so that other places which print things that aren't
      traditional errors but are worth filing bugs about, can actually use
      it.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200303215320.93491-1-lyude@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index db23308f4d8b..a39c3cdacb20 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1236,6 +1236,10 @@ struct edid_quirk {
  * DP quirks in such cases.
  */
 static const struct edid_quirk edid_quirk_list[] = {
+	/* Optional 4K AMOLED panel in the ThinkPad X1 Extreme 2nd Generation
+	 * only supports DPCD backlight controls
+	 */
+	{ MFG(0x4c, 0x83), PROD_ID(0x41, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 };
 
 #undef MFG

commit 0883ce8146ed6074c76399f4e70dbed788582e12
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Feb 11 13:33:46 2020 -0500

    drm/dp: Introduce EDID-based quirks
    
    The whole point of using OUIs is so that we can recognize certain
    devices and potentially apply quirks for them. Normally this should work
    quite well, but there appears to be quite a number of laptop panels out
    there that will fill the OUI but not the device ID. As such, for devices
    like this I can't imagine it's a very good idea to try relying on OUIs
    for applying quirks. As well, some laptop vendors have confirmed to us
    that their panels have this exact issue.
    
    So, let's introduce the ability to apply DP quirks based on EDID
    identification. We reuse the same quirk bits for OUI-based quirks, so
    that callers can simply check all possible quirks using
    drm_dp_has_quirk().
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211183358.157448-2-lyude@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 5a103e9b3c86..db23308f4d8b 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1221,6 +1221,67 @@ drm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)
 #undef DEVICE_ID_ANY
 #undef DEVICE_ID
 
+struct edid_quirk {
+	u8 mfg_id[2];
+	u8 prod_id[2];
+	u32 quirks;
+};
+
+#define MFG(first, second) { (first), (second) }
+#define PROD_ID(first, second) { (first), (second) }
+
+/*
+ * Some devices have unreliable OUIDs where they don't set the device ID
+ * correctly, and as a result we need to use the EDID for finding additional
+ * DP quirks in such cases.
+ */
+static const struct edid_quirk edid_quirk_list[] = {
+};
+
+#undef MFG
+#undef PROD_ID
+
+/**
+ * drm_dp_get_edid_quirks() - Check the EDID of a DP device to find additional
+ * DP-specific quirks
+ * @edid: The EDID to check
+ *
+ * While OUIDs are meant to be used to recognize a DisplayPort device, a lot
+ * of manufacturers don't seem to like following standards and neglect to fill
+ * the dev-ID in, making it impossible to only use OUIDs for determining
+ * quirks in some cases. This function can be used to check the EDID and look
+ * up any additional DP quirks. The bits returned by this function correspond
+ * to the quirk bits in &drm_dp_quirk.
+ *
+ * Returns: a bitmask of quirks, if any. The driver can check this using
+ * drm_dp_has_quirk().
+ */
+u32 drm_dp_get_edid_quirks(const struct edid *edid)
+{
+	const struct edid_quirk *quirk;
+	u32 quirks = 0;
+	int i;
+
+	if (!edid)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {
+		quirk = &edid_quirk_list[i];
+		if (memcmp(quirk->mfg_id, edid->mfg_id,
+			   sizeof(edid->mfg_id)) == 0 &&
+		    memcmp(quirk->prod_id, edid->prod_code,
+			   sizeof(edid->prod_code)) == 0)
+			quirks |= quirk->quirks;
+	}
+
+	DRM_DEBUG_KMS("DP sink: EDID mfg %*phD prod-ID %*phD quirks: 0x%04x\n",
+		      (int)sizeof(edid->mfg_id), edid->mfg_id,
+		      (int)sizeof(edid->prod_code), edid->prod_code, quirks);
+
+	return quirks;
+}
+EXPORT_SYMBOL(drm_dp_get_edid_quirks);
+
 /**
  * drm_dp_read_desc - read sink/branch descriptor from DPCD
  * @aux: DisplayPort AUX channel

commit 1b245ec5b685ebf8e6e5d1e6b5bcc03b6608e8b0
Merge: 11a48a5a18c6 06f749af622c
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 20 15:21:02 2020 +1000

    Merge tag 'drm-misc-next-2020-02-10' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.7:
    
    UAPI Changes:
      - lima: Add support for heap buffers
    
    Cross-subsystem Changes:
    
    Core Changes:
      - Implement mode_config mode_valid for memory constrained drivers
      - Bus format negociation between bridges
      - Consolidate fake vblank events for drivers without vblank interrupts
      - drm/bufs: dma_alloc related cleanups
      - drm/dp_mst: Various fixes
      - drm/print: New drm_device based print helpers
      - Thomas is a drm-misc maintainer now!
    
    Driver Changes:
      - DPMS cleanups for atomic drivers
      - Removal of owner field in SPI tinydrm drivers
      - Removal of explicit dependency on DT for tinydrm drivers
      - Conversion to YAML schemas for DT bindings
      - tidss: New driver
      - virtio: various reworks and fixes
      - Our usual dozen or so new panels or bridges
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime@cerno.tech>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200210093421.xu4sofldm6wm6xq6@gilmour.lan

commit 28f2aff1caa4997f58ca31179cad1b4a84a62827
Merge: 3e8a3844fefb 11a48a5a18c6
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Mon Feb 17 10:34:34 2020 +0100

    Merge v5.6-rc2 into drm-misc-next
    
    Lyude needs some patches in 5.6-rc2 and we didn't bring drm-misc-next
    forward yet, so it looks like a good occasion.
    
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>

commit e11f5bd8228fc3760c221f940b9f6365dbf3e7ed
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Feb 11 11:08:32 2020 -0500

    drm: Add support for DP 1.4 Compliance edid corruption test
    
    Unlike DP 1.2 edid corruption test, DP 1.4 requires to calculate
    real CRC value of the last edid data block, and write it back.
    Current edid CRC calculates routine adds the last CRC byte,
    and check if non-zero.
    
    This behavior is not accurate; actually, we need to return
    the actual CRC value when corruption is detected.
    This commit changes this issue by returning the calculated CRC,
    and initiate the required sequence.
    
    Change since v7
    - Fix for CI.CHECKPATCH
    
    Change since v6
    - Add return check
    
    Change since v5
    - Obtain real CRC value before dumping bad edid
    
    Change since v4
    - Fix for CI.CHECKPATCH
    
    Change since v3
    - Fix a minor typo.
    
    Change since v2
    - Rewrite checksum computation routine to avoid duplicated code.
    - Rename to avoid confusion.
    
    Change since v1
    - Have separate routine for returning real CRC.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211160832.24259-1-Jerry.Zuo@amd.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f629fc5494a4..43e9f1968af4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -351,6 +351,65 @@ int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
 }
 EXPORT_SYMBOL(drm_dp_dpcd_read_link_status);
 
+/**
+ * drm_dp_send_real_edid_checksum() - send back real edid checksum value
+ * @aux: DisplayPort AUX channel
+ * @real_edid_checksum: real edid checksum for the last block
+ *
+ * Returns:
+ * True on success
+ */
+bool drm_dp_send_real_edid_checksum(struct drm_dp_aux *aux,
+				    u8 real_edid_checksum)
+{
+	u8 link_edid_read = 0, auto_test_req = 0, test_resp = 0;
+
+	if (drm_dp_dpcd_read(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,
+			     &auto_test_req, 1) < 1) {
+		DRM_ERROR("DPCD failed read at register 0x%x\n",
+			  DP_DEVICE_SERVICE_IRQ_VECTOR);
+		return false;
+	}
+	auto_test_req &= DP_AUTOMATED_TEST_REQUEST;
+
+	if (drm_dp_dpcd_read(aux, DP_TEST_REQUEST, &link_edid_read, 1) < 1) {
+		DRM_ERROR("DPCD failed read at register 0x%x\n",
+			  DP_TEST_REQUEST);
+		return false;
+	}
+	link_edid_read &= DP_TEST_LINK_EDID_READ;
+
+	if (!auto_test_req || !link_edid_read) {
+		DRM_DEBUG_KMS("Source DUT does not support TEST_EDID_READ\n");
+		return false;
+	}
+
+	if (drm_dp_dpcd_write(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,
+			      &auto_test_req, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_DEVICE_SERVICE_IRQ_VECTOR);
+		return false;
+	}
+
+	/* send back checksum for the last edid extension block data */
+	if (drm_dp_dpcd_write(aux, DP_TEST_EDID_CHECKSUM,
+			      &real_edid_checksum, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_TEST_EDID_CHECKSUM);
+		return false;
+	}
+
+	test_resp |= DP_TEST_EDID_CHECKSUM_WRITE;
+	if (drm_dp_dpcd_write(aux, DP_TEST_RESPONSE, &test_resp, 1) < 1) {
+		DRM_ERROR("DPCD failed write at register 0x%x\n",
+			  DP_TEST_RESPONSE);
+		return false;
+	}
+
+	return true;
+}
+EXPORT_SYMBOL(drm_dp_send_real_edid_checksum);
+
 /**
  * drm_dp_downstream_max_clock() - extract branch device max
  *                                 pixel rate for legacy VGA

commit b4c32073b8cfb7ad264bf65d40cc7419ff489ea0
Author: Oleg Vasilev <oleg.vasilev@intel.com>
Date:   Thu Aug 29 14:48:49 2019 +0300

    drm: always determine branch device with drm_dp_is_branch()
    
    The helper should always be used.
    
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Oleg Vasilev <oleg.vasilev@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190829114854.1539-2-oleg.vasilev@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 2c7870aef469..f629fc5494a4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -460,8 +460,7 @@ void drm_dp_downstream_debug(struct seq_file *m,
 	int len;
 	uint8_t rev[2];
 	int type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
-	bool branch_device = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
-			     DP_DWN_STRM_PORT_PRESENT;
+	bool branch_device = drm_dp_is_branch(dpcd);
 
 	seq_printf(m, "\tDP branch device present: %s\n",
 		   branch_device ? "yes" : "no");

commit c908b1c4bb56c27fa6fbb48e2d3dbebdad366706
Author: David (Dingchen) Zhang <dingchen.zhang@amd.com>
Date:   Fri Dec 6 17:56:37 2019 -0500

    drm: add dp helper to initialize remote aux channel.
    
    [why]
    We need to minimally initialize the remote aux channel, e.g. the
    crc work struct of remote aux to dump the sink's DPRX CRCs in MST
    setup.
    
    [how]
    Add helper that only initializes the crc work struct of the remote
    aux, hooke crc work queue to 'drm_dp_aux_crc_work'. Then call this
    helper in DP MST port initialization.
    This, plus David Francis' patch [1], fix the issue of MST remote
    aux DPCD CRCs read.
    
    [1] https://patchwork.kernel.org/patch/11217941/
    
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: David (Dingchen) Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 374cedc6c2ac..a5364b5192b8 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -978,6 +978,19 @@ static void drm_dp_aux_crc_work(struct work_struct *work)
 	}
 }
 
+/**
+ * drm_dp_remote_aux_init() - minimally initialise a remote aux channel
+ * @aux: DisplayPort AUX channel
+ *
+ * Used for remote aux channel in general. Merely initialize the crc work
+ * struct.
+ */
+void drm_dp_remote_aux_init(struct drm_dp_aux *aux)
+{
+	INIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);
+}
+EXPORT_SYMBOL(drm_dp_remote_aux_init);
+
 /**
  * drm_dp_aux_init() - minimally initialise an aux channel
  * @aux: DisplayPort AUX channel

commit 5b03f9d86880711441c5681244d352212460a595
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Fri Sep 20 15:44:56 2019 -0400

    drm/dp_mst: Add new quirk for Synaptics MST hubs
    
    Synaptics DP1.4 hubs (BRANCH_ID 0x90CC24) do not
    support virtual DPCD registers, but do support DSC.
    The DSC caps can be read from the physical aux,
    like in SST DSC. These hubs have many different
    DEVICE_IDs.  Add a new quirk to detect this case.
    
    v2: Fix error when checking return of drm_dp_read_desc
    
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 2faef8bd911f..374cedc6c2ac 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1165,6 +1165,8 @@ static const struct dpcd_quirk dpcd_quirk_list[] = {
 	{ OUI(0x00, 0x10, 0xfa), DEVICE_ID_ANY, false, BIT(DP_DPCD_QUIRK_NO_PSR) },
 	/* CH7511 seems to leave SINK_COUNT zeroed */
 	{ OUI(0x00, 0x00, 0x00), DEVICE_ID('C', 'H', '7', '5', '1', '1'), false, BIT(DP_DPCD_QUIRK_NO_SINK_COUNT) },
+	/* Synaptics DP1.4 MST hubs can support DSC without virtual DPCD */
+	{ OUI(0x90, 0xCC, 0x24), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD) },
 };
 
 #undef OUI

commit 2f221a5efed4cb369dc53cbbae3ba03fcf2ede49
Author: David Francis <David.Francis@amd.com>
Date:   Wed Jun 19 14:46:15 2019 -0400

    drm/dp_mst: Add MST support to DP DPCD R/W functions
    
    Instead of having drm_dp_dpcd_read/write and
    drm_dp_mst_dpcd_read/write as entry points into the
    aux code, have drm_dp_dpcd_read/write handle both.
    
    This means that DRM drivers can make MST DPCD read/writes.
    
    v2: Fix spacing
    v3: Dump dpcd access on MST read/writes
    v4: Fix calling wrong function on DPCD write
    v5: delete deprecated include of drmP.h
    
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 2c7870aef469..2faef8bd911f 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -32,6 +32,7 @@
 #include <drm/drm_dp_helper.h>
 #include <drm/drm_print.h>
 #include <drm/drm_vblank.h>
+#include <drm/drm_dp_mst_helper.h>
 
 #include "drm_crtc_helper_internal.h"
 
@@ -266,7 +267,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 
 /**
  * drm_dp_dpcd_read() - read a series of bytes from the DPCD
- * @aux: DisplayPort AUX channel
+ * @aux: DisplayPort AUX channel (SST or MST)
  * @offset: address of the (first) register to read
  * @buffer: buffer to store the register values
  * @size: number of bytes in @buffer
@@ -295,13 +296,18 @@ ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
 	 * We just have to do it before any DPCD access and hope that the
 	 * monitor doesn't power down exactly after the throw away read.
 	 */
-	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV, buffer,
-				 1);
-	if (ret != 1)
-		goto out;
+	if (!aux->is_remote) {
+		ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV,
+					 buffer, 1);
+		if (ret != 1)
+			goto out;
+	}
 
-	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,
-				 size);
+	if (aux->is_remote)
+		ret = drm_dp_mst_dpcd_read(aux, offset, buffer, size);
+	else
+		ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset,
+					 buffer, size);
 
 out:
 	drm_dp_dump_access(aux, DP_AUX_NATIVE_READ, offset, buffer, ret);
@@ -311,7 +317,7 @@ EXPORT_SYMBOL(drm_dp_dpcd_read);
 
 /**
  * drm_dp_dpcd_write() - write a series of bytes to the DPCD
- * @aux: DisplayPort AUX channel
+ * @aux: DisplayPort AUX channel (SST or MST)
  * @offset: address of the (first) register to write
  * @buffer: buffer containing the values to write
  * @size: number of bytes in @buffer
@@ -328,8 +334,12 @@ ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
 {
 	int ret;
 
-	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,
-				 size);
+	if (aux->is_remote)
+		ret = drm_dp_mst_dpcd_write(aux, offset, buffer, size);
+	else
+		ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset,
+					 buffer, size);
+
 	drm_dp_dump_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer, ret);
 	return ret;
 }

commit 9a42c7c647a9ad0f7ebb147a52eda3dcb7c84292
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 21 16:34:37 2019 +0200

    drm/tegra: Move drm_dp_link helpers to Tegra DRM
    
    During the discussion of patches that enhance the drm_dp_link helpers it
    was concluded that these helpers aren't very useful to begin with. After
    all other drivers have been converted not to use these helpers anymore,
    move these helpers into the last remaining user: Tegra DRM.
    
    If at some point these helpers are deemed more widely useful, they can
    be moved out into the DRM DP helpers again.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191021143437.1477719-14-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f567141aff54..2c7870aef469 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -351,134 +351,6 @@ int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
 }
 EXPORT_SYMBOL(drm_dp_dpcd_read_link_status);
 
-/**
- * drm_dp_link_probe() - probe a DisplayPort link for capabilities
- * @aux: DisplayPort AUX channel
- * @link: pointer to structure in which to return link capabilities
- *
- * The structure filled in by this function can usually be passed directly
- * into drm_dp_link_power_up() and drm_dp_link_configure() to power up and
- * configure the link based on the link's capabilities.
- *
- * Returns 0 on success or a negative error code on failure.
- */
-int drm_dp_link_probe(struct drm_dp_aux *aux, struct drm_dp_link *link)
-{
-	u8 values[3];
-	int err;
-
-	memset(link, 0, sizeof(*link));
-
-	err = drm_dp_dpcd_read(aux, DP_DPCD_REV, values, sizeof(values));
-	if (err < 0)
-		return err;
-
-	link->revision = values[0];
-	link->rate = drm_dp_bw_code_to_link_rate(values[1]);
-	link->num_lanes = values[2] & DP_MAX_LANE_COUNT_MASK;
-
-	if (values[2] & DP_ENHANCED_FRAME_CAP)
-		link->capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;
-
-	return 0;
-}
-EXPORT_SYMBOL(drm_dp_link_probe);
-
-/**
- * drm_dp_link_power_up() - power up a DisplayPort link
- * @aux: DisplayPort AUX channel
- * @link: pointer to a structure containing the link configuration
- *
- * Returns 0 on success or a negative error code on failure.
- */
-int drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)
-{
-	u8 value;
-	int err;
-
-	/* DP_SET_POWER register is only available on DPCD v1.1 and later */
-	if (link->revision < 0x11)
-		return 0;
-
-	err = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);
-	if (err < 0)
-		return err;
-
-	value &= ~DP_SET_POWER_MASK;
-	value |= DP_SET_POWER_D0;
-
-	err = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);
-	if (err < 0)
-		return err;
-
-	/*
-	 * According to the DP 1.1 specification, a "Sink Device must exit the
-	 * power saving state within 1 ms" (Section 2.5.3.1, Table 5-52, "Sink
-	 * Control Field" (register 0x600).
-	 */
-	usleep_range(1000, 2000);
-
-	return 0;
-}
-EXPORT_SYMBOL(drm_dp_link_power_up);
-
-/**
- * drm_dp_link_power_down() - power down a DisplayPort link
- * @aux: DisplayPort AUX channel
- * @link: pointer to a structure containing the link configuration
- *
- * Returns 0 on success or a negative error code on failure.
- */
-int drm_dp_link_power_down(struct drm_dp_aux *aux, struct drm_dp_link *link)
-{
-	u8 value;
-	int err;
-
-	/* DP_SET_POWER register is only available on DPCD v1.1 and later */
-	if (link->revision < 0x11)
-		return 0;
-
-	err = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);
-	if (err < 0)
-		return err;
-
-	value &= ~DP_SET_POWER_MASK;
-	value |= DP_SET_POWER_D3;
-
-	err = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-EXPORT_SYMBOL(drm_dp_link_power_down);
-
-/**
- * drm_dp_link_configure() - configure a DisplayPort link
- * @aux: DisplayPort AUX channel
- * @link: pointer to a structure containing the link configuration
- *
- * Returns 0 on success or a negative error code on failure.
- */
-int drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)
-{
-	u8 values[2];
-	int err;
-
-	values[0] = drm_dp_link_rate_to_bw_code(link->rate);
-	values[1] = link->num_lanes;
-
-	if (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)
-		values[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
-
-	err = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-EXPORT_SYMBOL(drm_dp_link_configure);
-
 /**
  * drm_dp_downstream_max_clock() - extract branch device max
  *                                 pixel rate for legacy VGA

commit 79465e0ffeb9e4866939ea562bc55367be91e595
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 21 16:34:31 2019 +0200

    drm/dp: Add helper to get post-cursor adjustments
    
    If the transmitter supports pre-emphasis post cursor2 the sink will
    request adjustments in a similar way to how it requests adjustments to
    the voltage swing and pre-emphasis settings.
    
    Add a helper to extract these adjustments on a per-lane basis from the
    DPCD link status.
    
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191021143437.1477719-8-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index ac802b04f120..f567141aff54 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -120,6 +120,16 @@ u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SI
 }
 EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
 
+u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE],
+					 unsigned int lane)
+{
+	unsigned int offset = DP_ADJUST_REQUEST_POST_CURSOR2;
+	u8 value = dp_link_status(link_status, offset);
+
+	return (value >> (lane << 1)) & 0x3;
+}
+EXPORT_SYMBOL(drm_dp_get_adjust_request_post_cursor);
+
 void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
 {
 	unsigned long rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &

commit fc6b42045e51a8e2793751e03daa39dc99c25983
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 21 16:34:30 2019 +0200

    drm/dp: Do not busy-loop during link training
    
    Use microsecond sleeps for the clock recovery and channel equalization
    delays during link training. The duration of these delays can be from
    100 us up to 16 ms. It is rude to busy-loop for that amount of time.
    
    While at it, also convert to standard coding style by putting the
    opening braces in a function definition on a new line. Also switch to
    using an unsigned int for the AUX read interval to match the data type
    of the parameters to usleep_range().
    
    v2: use correct multiplier for training delays (Philipp Zabel)
    v3: clarify data type change in commit message
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191021143437.1477719-7-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 8f2d7c4850ca..ac802b04f120 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -120,33 +120,39 @@ u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SI
 }
 EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
 
-void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
-	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
-			  DP_TRAINING_AUX_RD_MASK;
+void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	unsigned long rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+					 DP_TRAINING_AUX_RD_MASK;
 
 	if (rd_interval > 4)
-		DRM_DEBUG_KMS("AUX interval %d, out of range (max 4)\n",
+		DRM_DEBUG_KMS("AUX interval %lu, out of range (max 4)\n",
 			      rd_interval);
 
 	if (rd_interval == 0 || dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)
-		udelay(100);
+		rd_interval = 100;
 	else
-		mdelay(rd_interval * 4);
+		rd_interval *= 4 * USEC_PER_MSEC;
+
+	usleep_range(rd_interval, rd_interval * 2);
 }
 EXPORT_SYMBOL(drm_dp_link_train_clock_recovery_delay);
 
-void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
-	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
-			  DP_TRAINING_AUX_RD_MASK;
+void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	unsigned long rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+					 DP_TRAINING_AUX_RD_MASK;
 
 	if (rd_interval > 4)
-		DRM_DEBUG_KMS("AUX interval %d, out of range (max 4)\n",
+		DRM_DEBUG_KMS("AUX interval %lu, out of range (max 4)\n",
 			      rd_interval);
 
 	if (rd_interval == 0)
-		udelay(400);
+		rd_interval = 400;
 	else
-		mdelay(rd_interval * 4);
+		rd_interval *= 4 * USEC_PER_MSEC;
+
+	usleep_range(rd_interval, rd_interval * 2);
 }
 EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);
 

commit 2980426a779f227ffcac342240b0c3ca3d386da8
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 21 16:34:26 2019 +0200

    drm/dp: Remove a gratuituous blank line
    
    It's idiomatic to check the return value of a function call immediately
    after the function call, without any blank lines in between, to make it
    more obvious that the two lines belong together.
    
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191021143437.1477719-3-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f373798d82f6..8f2d7c4850ca 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -220,7 +220,6 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 		}
 
 		ret = aux->transfer(aux, &msg);
-
 		if (ret >= 0) {
 			native_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;
 			if (native_reply == DP_AUX_NATIVE_REPLY_ACK) {

commit 69b22f51e6644b6592087fe157537dd5f68e30bb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 17 14:09:36 2019 +0200

    drm/doc: Improve docs around connector (un)registration
    
    Current code is quite a mess unfortunately, so also add a todo.rst
    entry to maybe fix it up eventually.
    
    Cc: Michel Dänzer <michel@daenzer.net>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190917120936.7501-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index ffc68d305afe..f373798d82f6 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1109,6 +1109,14 @@ EXPORT_SYMBOL(drm_dp_aux_init);
  * @aux: DisplayPort AUX channel
  *
  * Automatically calls drm_dp_aux_init() if this hasn't been done yet.
+ * This should only be called when the underlying &struct drm_connector is
+ * initialiazed already. Therefore the best place to call this is from
+ * &drm_connector_funcs.late_register. Not that drivers which don't follow this
+ * will Oops when CONFIG_DRM_DP_AUX_CHARDEV is enabled.
+ *
+ * Drivers which need to use the aux channel before that point (e.g. at driver
+ * load time, before drm_dev_register() has been called) need to call
+ * drm_dp_aux_init().
  *
  * Returns 0 on success or a negative error code on failure.
  */

commit 57a1b0893782090738a879293efeb93885e0519c
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Jul 17 12:01:48 2019 -0400

    drm: Make the bw/link rate calculations more forgiving
    
    Although the DisplayPort spec explicitly calls out the 1.62/2.7/5.4/8.1
    link rates, the value of LINK_BW_SET is calculated.  The DisplayPort
    spec says "Main-Link Bandwidth Setting = Value x 0.27Gbps/lane".
    
    A bridge that we're looking to upstream uses 6.75Gbps rate (value 0x19)
    [1], and that precludes it from using these functions.
    
    This 6.75Gbps rate is defined in the spec as (credit to Ville for posting this):
      A MyDP Source device, upon reading the MAX_LINK_RATE register of the
      downstream DPRX programmed to 19h (which can be the case only for a
      MyDP-to-Legacy or MyDP-to-DP lane count converter) can program the
      LINK_BW_SET register (DPCD Address 00100h) to 19h to enable 6.75Gbps/lane."
    
    So to avoid failing on legitimate rates in the future, this patch calculates thevalues according to spec instead of restricting these values to one of the
    DP_LINK_BW_* #defines.
    
    No functional change for the well-defined values, but we lose the
    warning (and return the correct value) for ill-defined bw values.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    
    [1] https://chromium-review.googlesource.com/c/chromiumos/third_party/kernel/+/1689251/2/drivers/gpu/drm/bridge/analogix/anx7625.c#636
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190717160148.256826-1-sean@poorly.run

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 0b994d083a89..ffc68d305afe 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -152,38 +152,15 @@ EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);
 
 u8 drm_dp_link_rate_to_bw_code(int link_rate)
 {
-	switch (link_rate) {
-	default:
-		WARN(1, "unknown DP link rate %d, using %x\n", link_rate,
-		     DP_LINK_BW_1_62);
-		/* fall through */
-	case 162000:
-		return DP_LINK_BW_1_62;
-	case 270000:
-		return DP_LINK_BW_2_7;
-	case 540000:
-		return DP_LINK_BW_5_4;
-	case 810000:
-		return DP_LINK_BW_8_1;
-	}
+	/* Spec says link_bw = link_rate / 0.27Gbps */
+	return link_rate / 27000;
 }
 EXPORT_SYMBOL(drm_dp_link_rate_to_bw_code);
 
 int drm_dp_bw_code_to_link_rate(u8 link_bw)
 {
-	switch (link_bw) {
-	default:
-		WARN(1, "unknown DP link BW code %x, using 162000\n", link_bw);
-		/* fall through */
-	case DP_LINK_BW_1_62:
-		return 162000;
-	case DP_LINK_BW_2_7:
-		return 270000;
-	case DP_LINK_BW_5_4:
-		return 540000;
-	case DP_LINK_BW_8_1:
-		return 810000;
-	}
+	/* Spec says link_rate = link_bw * 0.27Gbps */
+	return link_bw * 27000;
 }
 EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);
 

commit 7974033e527a5dd12d96126d09d4cff4f9b65c69
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue May 28 17:06:49 2019 +0300

    drm/dp: Add DP_DPCD_QUIRK_NO_SINK_COUNT
    
    CH7511 eDP->LVDS bridge doesn't seem to set SINK_COUNT properly
    causing i915 to detect it as disconnected. Add a quirk to ignore
    SINK_COUNT on these devices.
    
    Cc: David S. <david@majinbuu.com>
    Cc: Peteris Rudzusiks <peteris.rudzusiks@gmail.com>
    Tested-by: Peteris Rudzusiks <peteris.rudzusiks@gmail.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=105406
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190528140650.19230-1-ville.syrjala@linux.intel.com
    Acked-by: Jani Nikula <jani.nikula@intel.com> #irc

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index e6af758a7d22..0b994d083a89 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1280,7 +1280,9 @@ static const struct dpcd_quirk dpcd_quirk_list[] = {
 	/* LG LP140WF6-SPM1 eDP panel */
 	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID('s', 'i', 'v', 'a', 'r', 'T'), false, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
 	/* Apple panels need some additional handling to support PSR */
-	{ OUI(0x00, 0x10, 0xfa), DEVICE_ID_ANY, false, BIT(DP_DPCD_QUIRK_NO_PSR) }
+	{ OUI(0x00, 0x10, 0xfa), DEVICE_ID_ANY, false, BIT(DP_DPCD_QUIRK_NO_PSR) },
+	/* CH7511 seems to leave SINK_COUNT zeroed */
+	{ OUI(0x00, 0x00, 0x00), DEVICE_ID('C', 'H', '7', '5', '1', '1'), false, BIT(DP_DPCD_QUIRK_NO_SINK_COUNT) },
 };
 
 #undef OUI

commit 580fc13f3ee438ca08d8ecfd337a8b1b555fcc35
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon May 6 12:52:47 2019 +0300

    drm/dp: drmP.h include removal
    
    Continue to get rid of drmP.h. Add minimal includes to build. Sort
    includes while at it.
    
    Reviewed-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190506095248.20874-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 54a6414c5d96..e6af758a7d22 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -20,16 +20,18 @@
  * OF THIS SOFTWARE.
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/delay.h>
-#include <linux/init.h>
 #include <linux/errno.h>
-#include <linux/sched.h>
 #include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
 #include <linux/seq_file.h>
+
 #include <drm/drm_dp_helper.h>
-#include <drm/drmP.h>
+#include <drm/drm_print.h>
+#include <drm/drm_vblank.h>
 
 #include "drm_crtc_helper_internal.h"
 

commit 05bad2357afcb9f89804f04f0ae5ac58ae898ec5
Author: Manasi Navare <manasi.d.navare@intel.com>
Date:   Wed Feb 6 13:31:48 2019 -0800

    drm/dsc: Add kernel documentation for DRM DP DSC helpers
    
    This patch adds appropriate kernel documentation for DRM DP helpers
    used for enabling Display Stream compression functionality in
    drm_dp_helper.h and drm_dp_helper.c as well as for the DSC spec
    related structure definitions and helpers in drm_dsc.c and drm_dsc.h
    Also add links between the functions and structures in the documentation.
    
    v3:
    * Fix the checkpatch warnings (Sean Paul)
    v2:
    * Add inline comments for longer structs (Daniel Vetter)
    * Split the summary and description (Daniel Vetter)
    
    Suggested-by: Daniel Vetter <daniel.vetter@intel.com>
    Suggested-by: Sean Paul <sean@poorly.run>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Sean Paul <sean@poorly.run>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Acked-by: Sean Paul <sean@poorly.run>
    Reviewed-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190206213148.21390-1-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 54120b6319e7..54a6414c5d96 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1360,7 +1360,20 @@ int drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,
 EXPORT_SYMBOL(drm_dp_read_desc);
 
 /**
- * DRM DP Helpers for DSC
+ * drm_dp_dsc_sink_max_slice_count() - Get the max slice count
+ * supported by the DSC sink.
+ * @dsc_dpcd: DSC capabilities from DPCD
+ * @is_edp: true if its eDP, false for DP
+ *
+ * Read the slice capabilities DPCD register from DSC sink to get
+ * the maximum slice count supported. This is used to populate
+ * the DSC parameters in the &struct drm_dsc_config by the driver.
+ * Driver creates an infoframe using these parameters to populate
+ * &struct drm_dsc_pps_infoframe. These are sent to the sink using DSC
+ * infoframe using the helper function drm_dsc_pps_infoframe_pack()
+ *
+ * Returns:
+ * Maximum slice count supported by DSC sink or 0 its invalid
  */
 u8 drm_dp_dsc_sink_max_slice_count(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],
 				   bool is_edp)
@@ -1405,6 +1418,21 @@ u8 drm_dp_dsc_sink_max_slice_count(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_dsc_sink_max_slice_count);
 
+/**
+ * drm_dp_dsc_sink_line_buf_depth() - Get the line buffer depth in bits
+ * @dsc_dpcd: DSC capabilities from DPCD
+ *
+ * Read the DSC DPCD register to parse the line buffer depth in bits which is
+ * number of bits of precision within the decoder line buffer supported by
+ * the DSC sink. This is used to populate the DSC parameters in the
+ * &struct drm_dsc_config by the driver.
+ * Driver creates an infoframe using these parameters to populate
+ * &struct drm_dsc_pps_infoframe. These are sent to the sink using DSC
+ * infoframe using the helper function drm_dsc_pps_infoframe_pack()
+ *
+ * Returns:
+ * Line buffer depth supported by DSC panel or 0 its invalid
+ */
 u8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
 {
 	u8 line_buf_depth = dsc_dpcd[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT];
@@ -1434,6 +1462,23 @@ u8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
 }
 EXPORT_SYMBOL(drm_dp_dsc_sink_line_buf_depth);
 
+/**
+ * drm_dp_dsc_sink_supported_input_bpcs() - Get all the input bits per component
+ * values supported by the DSC sink.
+ * @dsc_dpcd: DSC capabilities from DPCD
+ * @dsc_bpc: An array to be filled by this helper with supported
+ *           input bpcs.
+ *
+ * Read the DSC DPCD from the sink device to parse the supported bits per
+ * component values. This is used to populate the DSC parameters
+ * in the &struct drm_dsc_config by the driver.
+ * Driver creates an infoframe using these parameters to populate
+ * &struct drm_dsc_pps_infoframe. These are sent to the sink using DSC
+ * infoframe using the helper function drm_dsc_pps_infoframe_pack()
+ *
+ * Returns:
+ * Number of input BPC values parsed from the DPCD
+ */
 int drm_dp_dsc_sink_supported_input_bpcs(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],
 					 u8 dsc_bpc[3])
 {

commit d2c20b5d37820876a8beea4d8d0bc59147077dd5
Merge: b30b61ff6b1d 8ca4fd0406b4
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Thu Jan 24 11:03:16 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    danvet needs a backmerge to ease the upcoming drmP.h rework
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 8ca4fd0406b41a872055048d694f3702d8eddb76
Merge: f164a94c2c87 74256b7ecf77
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 24 19:44:16 2019 +1000

    Merge tag 'drm-intel-next-2019-01-10' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    - Unwind failure on pinning the gen7 PPGTT (Chris)
    - Fastset updates to make sure DRRS and PSR are properly enabled (Hans)
    - Header include clean-up (Brajeswar, Jani)
    - Improvements and clean-up on debugfs (Chris, Jani)
    - Avoid division by zero on CNL clocks setup (Xiao)
    - Restrict PSMI context load w/a to Haswell GT1 (Chris)
    - Remove HW semaphores for gen7 inter-engine sync (Chris)
    - Pull the render flush into breadcrumb emission (Chris)
    - i915_params copy and free helpers and other reorgs and docs (Jani)
    - Remove has_pooled_eu static initializer (Tvrtko)
    - Updates on kerneldoc (Chris)
    - Remove redundant trailing request flush (Chris)
    - ringbuffer irq seqno fixes and clean-up (Chris)
    - splitting off runtime device info and other clean-up around (Jani)
    - Selftests improvements (Chris, Daniele)
    - Flush RING_IMR changes before changing the global GT IMR on gen6 and HSW (Chris)
    - Some improvements and fixes around GPU reset and GPU hang report (Chris)
    - Remove partial attempt to swizzle on pread/pwrite (Chris)
    - Return immediately if trylock fails for direct-reclaim (Chris)
    - Downgrade scare message for unknown HuC firmware (Jani)
    - ACPI / PMIC for MIPI / DSI (Hans)
    - Reduce i915_request_alloc retirement to local context (Chris)
    - Init per-engine WAs for all engines (Daniele)
    - drop DPF code for gen8+ (Daniele)
    - Guard error capture against unpinned vma (Chris)
    - Use mutex_lock_killable from inside the shrinker (Chris)
    - Removing pooling from struct_mutex from vmap shrinker (Chris)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Fri 11 Jan 2019 09:58:18 AEST
    # gpg:                using RSA key FA625F640EEB13CA
    # gpg: Good signature from "Rodrigo Vivi <rodrigo.vivi@intel.com>"
    # gpg:                 aka "Rodrigo Vivi <rodrigo.vivi@gmail.com>"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: 6D20 7068 EEDD 6509 1C2C  E2A3 FA62 5F64 0EEB 13CA
    
    # Conflicts:
    #       drivers/gpu/drm/i915/intel_dp.c
    #       drivers/gpu/drm/i915/intel_drv.h
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190114183820.GA2855@intel.com

commit da279eb9a0764f688b627565c1c708c441103707
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Sep 28 21:04:01 2018 +0300

    drm/dp: Implement I2C_M_STOP for i2c-over-aux
    
    Consult the I2C_M_STOP flag to determine whether to set the MOT bit or
    not. Makes it possible to send multiple messages in one go with
    stop+start generated between the messages (as opposed nothing or
    repstart depending on whether thr address/rw changed).
    
    Not sure anyone has actual use for this but figured I'd handle it
    since I started to look at that flag for MST remote i2c xfers.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180928180403.22499-3-ville.syrjala@linux.intel.com
    Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index fc2a98a82250..d4ecedccbb31 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -887,7 +887,8 @@ static void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,
 {
 	msg->request = (i2c_msg->flags & I2C_M_RD) ?
 		DP_AUX_I2C_READ : DP_AUX_I2C_WRITE;
-	msg->request |= DP_AUX_I2C_MOT;
+	if (!(i2c_msg->flags & I2C_M_STOP))
+		msg->request |= DP_AUX_I2C_MOT;
 }
 
 /*

commit b64674465289866df095899a353d1e6bf21cdeef
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Jan 21 13:27:58 2019 +0200

    drm/dp: use DRM_DEBUG_DP() instead of drm_dbg for logging
    
    We have a wrapper for a reason.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190121112758.10978-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f51a116543f7..fc2a98a82250 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -194,11 +194,11 @@ drm_dp_dump_access(const struct drm_dp_aux *aux,
 	const char *arrow = request == DP_AUX_NATIVE_READ ? "->" : "<-";
 
 	if (ret > 0)
-		drm_dbg(DRM_UT_DP, "%s: 0x%05x AUX %s (ret=%3d) %*ph\n",
-			aux->name, offset, arrow, ret, min(ret, 20), buffer);
+		DRM_DEBUG_DP("%s: 0x%05x AUX %s (ret=%3d) %*ph\n",
+			     aux->name, offset, arrow, ret, min(ret, 20), buffer);
 	else
-		drm_dbg(DRM_UT_DP, "%s: 0x%05x AUX %s (ret=%3d)\n",
-			aux->name, offset, arrow, ret);
+		DRM_DEBUG_DP("%s: 0x%05x AUX %s (ret=%3d)\n",
+			     aux->name, offset, arrow, ret);
 }
 
 /**

commit e9c0c874711bdcd6254f6a26f11b4329d7517c2b
Author: Mathieu Malaterre <malat@debian.org>
Date:   Mon Jan 14 21:27:47 2019 +0100

    drm/dp: annotate implicit fall throughs
    
    There is a plan to build the kernel with -Wimplicit-fallthrough and
    these places in the code produced warnings (W=1). Fix them up.
    
    This commit remove the following warnings:
    
      include/linux/compiler.h:77:22: warning: this statement may fall through [-Wimplicit-fallthrough=]
      include/asm-generic/bug.h:134:2: note: in expansion of macro 'unlikely'
      drivers/gpu/drm/drm_dp_helper.c:155:3: note: in expansion of macro 'WARN'
      include/linux/compiler.h:77:22: warning: this statement may fall through [-Wimplicit-fallthrough=]
      include/asm-generic/bug.h:134:2: note: in expansion of macro 'unlikely'
      drivers/gpu/drm/drm_dp_helper.c:173:3: note: in expansion of macro 'WARN'
      drivers/gpu/drm/drm_dp_helper.c:547:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Acked-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190114202748.15584-1-malat@debian.org

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 2d6c491a0542..f51a116543f7 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -154,6 +154,7 @@ u8 drm_dp_link_rate_to_bw_code(int link_rate)
 	default:
 		WARN(1, "unknown DP link rate %d, using %x\n", link_rate,
 		     DP_LINK_BW_1_62);
+		/* fall through */
 	case 162000:
 		return DP_LINK_BW_1_62;
 	case 270000:
@@ -171,6 +172,7 @@ int drm_dp_bw_code_to_link_rate(u8 link_bw)
 	switch (link_bw) {
 	default:
 		WARN(1, "unknown DP link BW code %x, using 162000\n", link_bw);
+		/* fall through */
 	case DP_LINK_BW_1_62:
 		return 162000;
 	case DP_LINK_BW_2_7:
@@ -552,6 +554,7 @@ int drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
 		case DP_DS_16BPC:
 			return 16;
 		}
+		/* fall through */
 	default:
 		return 0;
 	}

commit 7c5c641a930ed06ca317ee39faee7d5824266348
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Mon Dec 3 16:33:55 2018 -0800

    drm/i915: Disable PSR in Apple panels
    
    i915 yet don't support PSR in Apple panels, so lets keep it disabled
    while we work on that.
    
    v2: Renamed DP_DPCD_QUIRK_PSR_NOT_CURRENTLY_SUPPORTED to
    DP_DPCD_QUIRK_NO_PSR (Ville)
    
    v3:
    Adding documentation to DP_DPCD_QUIRK_NO_PSR(Dhinakaran and Jani)
    Fixed typo in comment of the new quirk entry(Jani)
    
    Fixes: 598c6cfe0690 (drm/i915/psr: Enable PSR1 on gen-9+ HW)
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181204003403.23361-1-jose.souza@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 2d6c491a0542..516e82d0ed50 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1273,6 +1273,8 @@ static const struct dpcd_quirk dpcd_quirk_list[] = {
 	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
 	/* LG LP140WF6-SPM1 eDP panel */
 	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID('s', 'i', 'v', 'a', 'r', 'T'), false, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
+	/* Apple panels need some additional handling to support PSR */
+	{ OUI(0x00, 0x10, 0xfa), DEVICE_ID_ANY, false, BIT(DP_DPCD_QUIRK_NO_PSR) }
 };
 
 #undef OUI

commit 4d4101c8b32186657c4693e1c33f90679193280b
Author: Manasi Navare <manasi.d.navare@intel.com>
Date:   Tue Nov 27 13:41:03 2018 -0800

    drm/dsc: Modify DRM helper to return complete DSC color depth capabilities
    
    DSC DPCD color depth register advertises its color depth capabilities
    by setting each of the bits that corresponding to a specific color
    depth. This patch defines those specific color depths and adds
    a helper to return an array of color depth capabilities.
    
    v2:
    * Simplify the logic (Ville)
    
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Acked-by: Sean Paul <seanpaul@chromium.org> (For merging through
    drm-intel)
    Reviewed-by: Ville Syrjala <ville.syrjala@linux.intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181127214125.17658-1-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 6d483487f2b4..2d6c491a0542 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1428,17 +1428,19 @@ u8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
 }
 EXPORT_SYMBOL(drm_dp_dsc_sink_line_buf_depth);
 
-u8 drm_dp_dsc_sink_max_color_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
+int drm_dp_dsc_sink_supported_input_bpcs(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],
+					 u8 dsc_bpc[3])
 {
+	int num_bpc = 0;
 	u8 color_depth = dsc_dpcd[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];
 
 	if (color_depth & DP_DSC_12_BPC)
-		return 12;
+		dsc_bpc[num_bpc++] = 12;
 	if (color_depth & DP_DSC_10_BPC)
-		return 10;
+		dsc_bpc[num_bpc++] = 10;
 	if (color_depth & DP_DSC_8_BPC)
-		return 8;
+		dsc_bpc[num_bpc++] = 8;
 
-	return 0;
+	return num_bpc;
 }
-EXPORT_SYMBOL(drm_dp_dsc_sink_max_color_depth);
+EXPORT_SYMBOL(drm_dp_dsc_sink_supported_input_bpcs);

commit 0575650077eae2a431f33532de4e15405cc9f653
Author: Manasi Navare <manasi.d.navare@intel.com>
Date:   Tue Oct 30 17:19:20 2018 -0700

    drm/dp: DRM DP helper/macros to get DP sink DSC parameters
    
    This patch adds inline functions and helpers for obtaining
    DP sink's supported DSC parameters like DSC sink support,
    eDP compressed BPP supported, maximum slice count supported
    by the sink devices, DSC line buffer bit depth supported on DP sink,
    DSC sink maximum color depth by parsing corresponding DPCD registers.
    
    v4:
    * Add helper to give line buf bit depth (Manasi)
    * Correct the bit masking in color depth helper (manasi)
    v3:
    * Use SLICE_CAP_2 for DP (Anusha)
    v2:
    * Add DSC sink support macro (Jani N)
    
    Cc: Gaurav K Singh <gaurav.k.singh@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Reviewed-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Reviewed-by: Gaurav K Singh <gaurav.k.singh@intel.com>
    Acked-by: Sean Paul <seanpaul@chromium.org> (For merging through
    drm-intel)
    Link: https://patchwork.freedesktop.org/patch/msgid/20181031001923.31442-4-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 37c01b6076ec..6d483487f2b4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1352,3 +1352,93 @@ int drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,
 	return 0;
 }
 EXPORT_SYMBOL(drm_dp_read_desc);
+
+/**
+ * DRM DP Helpers for DSC
+ */
+u8 drm_dp_dsc_sink_max_slice_count(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],
+				   bool is_edp)
+{
+	u8 slice_cap1 = dsc_dpcd[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];
+
+	if (is_edp) {
+		/* For eDP, register DSC_SLICE_CAPABILITIES_1 gives slice count */
+		if (slice_cap1 & DP_DSC_4_PER_DP_DSC_SINK)
+			return 4;
+		if (slice_cap1 & DP_DSC_2_PER_DP_DSC_SINK)
+			return 2;
+		if (slice_cap1 & DP_DSC_1_PER_DP_DSC_SINK)
+			return 1;
+	} else {
+		/* For DP, use values from DSC_SLICE_CAP_1 and DSC_SLICE_CAP2 */
+		u8 slice_cap2 = dsc_dpcd[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];
+
+		if (slice_cap2 & DP_DSC_24_PER_DP_DSC_SINK)
+			return 24;
+		if (slice_cap2 & DP_DSC_20_PER_DP_DSC_SINK)
+			return 20;
+		if (slice_cap2 & DP_DSC_16_PER_DP_DSC_SINK)
+			return 16;
+		if (slice_cap1 & DP_DSC_12_PER_DP_DSC_SINK)
+			return 12;
+		if (slice_cap1 & DP_DSC_10_PER_DP_DSC_SINK)
+			return 10;
+		if (slice_cap1 & DP_DSC_8_PER_DP_DSC_SINK)
+			return 8;
+		if (slice_cap1 & DP_DSC_6_PER_DP_DSC_SINK)
+			return 6;
+		if (slice_cap1 & DP_DSC_4_PER_DP_DSC_SINK)
+			return 4;
+		if (slice_cap1 & DP_DSC_2_PER_DP_DSC_SINK)
+			return 2;
+		if (slice_cap1 & DP_DSC_1_PER_DP_DSC_SINK)
+			return 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dsc_sink_max_slice_count);
+
+u8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
+{
+	u8 line_buf_depth = dsc_dpcd[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT];
+
+	switch (line_buf_depth & DP_DSC_LINE_BUF_BIT_DEPTH_MASK) {
+	case DP_DSC_LINE_BUF_BIT_DEPTH_9:
+		return 9;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_10:
+		return 10;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_11:
+		return 11;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_12:
+		return 12;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_13:
+		return 13;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_14:
+		return 14;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_15:
+		return 15;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_16:
+		return 16;
+	case DP_DSC_LINE_BUF_BIT_DEPTH_8:
+		return 8;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dsc_sink_line_buf_depth);
+
+u8 drm_dp_dsc_sink_max_color_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])
+{
+	u8 color_depth = dsc_dpcd[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];
+
+	if (color_depth & DP_DSC_12_BPC)
+		return 12;
+	if (color_depth & DP_DSC_10_BPC)
+		return 10;
+	if (color_depth & DP_DSC_8_BPC)
+		return 8;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dsc_sink_max_color_depth);

commit e884818cc0edb9bd128de95e7ca6b569f4667c0f
Author: Lee, Shawn C <shawn.c.lee@intel.com>
Date:   Tue Sep 11 23:22:51 2018 -0700

    drm: add LG eDP panel to quirk database
    
    The N value was computed by kernel driver that based on synchronous clock
    mode. But only specific N value (0x8000) would be acceptable for
    LG LP140WF6-SPM1 eDP panel which is running at asynchronous clock mode.
    With the other N value, Tcon will enter BITS mode and display black screen.
    Add this panel into quirk database and give particular N value when
    calculate M/N divider.
    
    v2: no update
    v3: add lost commit messages back for version 2
    v4: send patch to both intel-gfx and dri-devel
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Cooper Chiou <cooper.chiou@intel.com>
    Cc: Matt Atwood <matthew.s.atwood@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Clint Taylor <clinton.a.taylor@intel.com>
    Signed-off-by: Lee, Shawn C <shawn.c.lee@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1536733371-25004-4-git-send-email-shawn.c.lee@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index c1fe1713eaef..37c01b6076ec 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1271,6 +1271,8 @@ struct dpcd_quirk {
 static const struct dpcd_quirk dpcd_quirk_list[] = {
 	/* Analogix 7737 needs reduced M and N at HBR2 link rates */
 	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
+	/* LG LP140WF6-SPM1 eDP panel */
+	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID('s', 'i', 'v', 'a', 'r', 'T'), false, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
 };
 
 #undef OUI

commit 53ca2edcf033f3368b2dc0ef3cbcc2f47d556d13
Author: Lee, Shawn C <shawn.c.lee@intel.com>
Date:   Tue Sep 11 23:22:50 2018 -0700

    drm: Change limited M/N quirk to constant N quirk.
    
    Some DP dongles in particular seem to be fussy about too large
    link M/N values. Set specific value for N divider can resolve
    this issue per dongle vendor's comment. So configure N as
    constant value (0x8000) to instead of reduce M/N formula when
    specific DP dongle connected.
    
    v2: add more comments for issue description and fix typo.
    v3: add lost commit messages back for version 2
    v4: send patch to both intel-gfx and dri-devel
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Cooper Chiou <cooper.chiou@intel.com>
    Cc: Matt Atwood <matthew.s.atwood@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Clint Taylor <clinton.a.taylor@intel.com>
    Tested-by: Clint Taylor <clinton.a.taylor@intel.com>
    Signed-off-by: Lee, Shawn C <shawn.c.lee@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1536733371-25004-3-git-send-email-shawn.c.lee@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 07167604e8cc..c1fe1713eaef 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1270,7 +1270,7 @@ struct dpcd_quirk {
 
 static const struct dpcd_quirk dpcd_quirk_list[] = {
 	/* Analogix 7737 needs reduced M and N at HBR2 link rates */
-	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_LIMITED_M_N) },
+	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_CONSTANT_N) },
 };
 
 #undef OUI

commit 0b49bbbd9f10dd5bcce126aa99041a44320767f7
Author: Lee, Shawn C <shawn.c.lee@intel.com>
Date:   Tue Sep 11 23:22:49 2018 -0700

    drm: Add support for device_id based detection.
    
    DP quirk list just compare sink or branch device's OUI so far.
    That means particular vendor's products will be applied specific
    change. This change would confirm device_id the same or not.
    Then driver can implement some changes for branch/sink device
    that really need additional WA.
    
    v2: use sizeof instead of hard coded '6'
    v3: add lost commit messages back for version 2
    v4: send patch to both intel-gfx and dri-devel
    
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Cooper Chiou <cooper.chiou@intel.com>
    Cc: Matt Atwood <matthew.s.atwood@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Clint Taylor <clinton.a.taylor@intel.com>
    Tested-by: Clint Taylor <clinton.a.taylor@intel.com>
    Signed-off-by: Lee, Shawn C <shawn.c.lee@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1536733371-25004-2-git-send-email-shawn.c.lee@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 8c6b9fd89f8a..07167604e8cc 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1257,15 +1257,20 @@ EXPORT_SYMBOL(drm_dp_stop_crc);
 
 struct dpcd_quirk {
 	u8 oui[3];
+	u8 device_id[6];
 	bool is_branch;
 	u32 quirks;
 };
 
 #define OUI(first, second, third) { (first), (second), (third) }
+#define DEVICE_ID(first, second, third, fourth, fifth, sixth) \
+	{ (first), (second), (third), (fourth), (fifth), (sixth) }
+
+#define DEVICE_ID_ANY	DEVICE_ID(0, 0, 0, 0, 0, 0)
 
 static const struct dpcd_quirk dpcd_quirk_list[] = {
 	/* Analogix 7737 needs reduced M and N at HBR2 link rates */
-	{ OUI(0x00, 0x22, 0xb9), true, BIT(DP_DPCD_QUIRK_LIMITED_M_N) },
+	{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_LIMITED_M_N) },
 };
 
 #undef OUI
@@ -1284,6 +1289,7 @@ drm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)
 	const struct dpcd_quirk *quirk;
 	u32 quirks = 0;
 	int i;
+	u8 any_device[] = DEVICE_ID_ANY;
 
 	for (i = 0; i < ARRAY_SIZE(dpcd_quirk_list); i++) {
 		quirk = &dpcd_quirk_list[i];
@@ -1294,12 +1300,19 @@ drm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)
 		if (memcmp(quirk->oui, ident->oui, sizeof(ident->oui)) != 0)
 			continue;
 
+		if (memcmp(quirk->device_id, any_device, sizeof(any_device)) != 0 &&
+		    memcmp(quirk->device_id, ident->device_id, sizeof(ident->device_id)) != 0)
+			continue;
+
 		quirks |= quirk->quirks;
 	}
 
 	return quirks;
 }
 
+#undef DEVICE_ID_ANY
+#undef DEVICE_ID
+
 /**
  * drm_dp_read_desc - read sink/branch descriptor from DPCD
  * @aux: DisplayPort AUX channel

commit 22e6de7074b820103cc566b1f57106515a054a39
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Jul 27 13:33:31 2018 -0700

    drm/dp: add missing ')' to I2C nack debug message
    
     "(an unmatched left parenthesis
      creates an unresolved tension
      that will stay with you all day."
                   -- Randall Munroe
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180727203331.27778-1-paulo.r.zanoni@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 0cccbcb2d03e..8c6b9fd89f8a 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -850,7 +850,8 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			return ret;
 
 		case DP_AUX_I2C_REPLY_NACK:
-			DRM_DEBUG_KMS("I2C nack (result=%d, size=%zu\n", ret, msg->size);
+			DRM_DEBUG_KMS("I2C nack (result=%d, size=%zu)\n",
+				      ret, msg->size);
 			aux->i2c_nack_count++;
 			return -EREMOTEIO;
 

commit a18b21929453af70390e14f8dee40acf00d428cb
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon Jul 16 11:44:32 2018 -0400

    drm/dp_helper: Add DP aux channel tracing
    
    This is something we've needed for a very long time now, as it makes
    debugging issues with faulty MST hubs along with debugging issues
    regarding us interfacing with hubs correctly vastly easier to debug.
    Currently this can actually be done if you trace the i2c devices for DP
    using ftrace but that's significantly less useful for a couple of
    reasons:
    
    - Tracing the i2c devices through ftrace means all of the traces are
      going to contain a lot of "garbage" output that we're sending over the
      i2c line. Most of this garbage comes from retrying transactions, DRM's
      helper library adding extra transactions to work around bad hubs, etc.
    - Having a user set up ftrace so that they can provide debugging
      information is a lot more difficult then being able to say "just boot
      with drm.debug=0x100"
    - We can potentially expand upon this tracing in the future to print
      debugging information in regards to other DP transactions like MST
      sideband transactions
    
    This is inspired by a patch Rob Clark sent to do this a long time back.
    Neither of us could find the patch however, so we both assumed it would
    probably just be easier to rewrite it anyway.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180716154432.13433-1-lyude@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f4a06b54aa7d..0cccbcb2d03e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -185,6 +185,20 @@ EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);
 
 #define AUX_RETRY_INTERVAL 500 /* us */
 
+static inline void
+drm_dp_dump_access(const struct drm_dp_aux *aux,
+		   u8 request, uint offset, void *buffer, int ret)
+{
+	const char *arrow = request == DP_AUX_NATIVE_READ ? "->" : "<-";
+
+	if (ret > 0)
+		drm_dbg(DRM_UT_DP, "%s: 0x%05x AUX %s (ret=%3d) %*ph\n",
+			aux->name, offset, arrow, ret, min(ret, 20), buffer);
+	else
+		drm_dbg(DRM_UT_DP, "%s: 0x%05x AUX %s (ret=%3d)\n",
+			aux->name, offset, arrow, ret);
+}
+
 /**
  * DOC: dp helpers
  *
@@ -288,10 +302,14 @@ ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
 	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV, buffer,
 				 1);
 	if (ret != 1)
-		return ret;
+		goto out;
 
-	return drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,
-				  size);
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,
+				 size);
+
+out:
+	drm_dp_dump_access(aux, DP_AUX_NATIVE_READ, offset, buffer, ret);
+	return ret;
 }
 EXPORT_SYMBOL(drm_dp_dpcd_read);
 
@@ -312,8 +330,12 @@ EXPORT_SYMBOL(drm_dp_dpcd_read);
 ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
 			  void *buffer, size_t size)
 {
-	return drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,
-				  size);
+	int ret;
+
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,
+				 size);
+	drm_dp_dump_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer, ret);
+	return ret;
 }
 EXPORT_SYMBOL(drm_dp_dpcd_write);
 

commit 2c6d1fffa1d9b0a5b5ac1a23be9ad64abe60910d
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Wed Jul 11 15:29:07 2018 +0200

    drm: add support for DisplayPort CEC-Tunneling-over-AUX
    
    This adds support for the DisplayPort CEC-Tunneling-over-AUX
    feature that is part of the DisplayPort 1.3 standard.
    
    Unfortunately, not all DisplayPort/USB-C to HDMI adapters with a
    chip that has this capability actually hook up the CEC pin, so
    even though a CEC device is created, it may not actually work.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180711132909.25409-2-hverkuil@xs4all.nl

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index a7ba602a43a8..f4a06b54aa7d 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1087,6 +1087,7 @@ static void drm_dp_aux_crc_work(struct work_struct *work)
 void drm_dp_aux_init(struct drm_dp_aux *aux)
 {
 	mutex_init(&aux->hw_mutex);
+	mutex_init(&aux->cec.lock);
 	INIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);
 
 	aux->ddc.algo = &drm_dp_i2c_algo;

commit 135c5504a600ff9b06e321694fbcac78a9530cd4
Merge: af6c5d5e01ad 568cf2e6aa0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 6 08:16:33 2018 -0700

    Merge tag 'drm-next-2018-06-06-1' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This starts to support NVIDIA volta hardware with nouveau, and adds
      amdgpu support for the GPU in the Kabylake-G (the intel + radeon
      single package chip), along with some initial Intel icelake enabling.
    
      Summary:
    
      New Drivers:
       - v3d - driver for broadcom V3D V3.x+ hardware
       - xen-front - XEN PV display frontend
    
      core:
       - handle zpos normalization in the core
       - stop looking at legacy pointers in atomic paths
       - improved scheduler documentation
       - improved aspect ratio validation
       - aspect ratio support for 64:27 and 256:135
       - drop unused control node code.
    
      i915:
       - Icelake (ICL) enabling
       - GuC/HuC refactoring
       - PSR/PSR2 enabling and fixes
       - DPLL management refactoring
       - DP MST fixes
       - NV12 enabling
       - HDCP improvements
       - GEM/Execlist/reset improvements
       - GVT improvements
       - stolen memory first 4k fix
    
      amdgpu:
       - Vega 20 support
       - VEGAM support (Kabylake-G)
       - preOS scanout buffer reservation
       - power management gfxoff support for raven
       - SR-IOV fixes
       - Vega10 power profiles and clock voltage control
       - scatter/gather display support on CZ/ST
    
      amdkfd:
       - GFX9 dGPU support
       - userptr memory mapping
    
      nouveau:
       - major refactoring for Volta GV100 support
    
      tda998x:
       - HDMI i2c CEC support
    
      etnaviv:
       - removed unused logging code
       - license text cleanups
       - MMU handling improvements
       - timeout fence fix for 50 days uptime
    
      tegra:
       - IOMMU support in gr2d/gr3d drivers
       - zpos support
    
      vc4:
       - syncobj support
       - CTM, plane alpha and async cursor support
    
      analogix_dp:
       - HPD and aux chan fixes
    
      sun4i:
       - MIPI DSI support
    
      tilcdc:
       - clock divider fixes for OMAP-l138 LCDK board
    
      rcar-du:
       - R8A77965 support
       - dma-buf fences fixes
       - hardware indexed crtc/du group handling
       - generic zplane property support
    
      atmel-hclcdc:
       - generic zplane property support
    
      mediatek:
       - use generic video mode function
    
      exynos:
       - S5PV210 FIMD variant support
       - IPP v2 framework
       - more HW overlays support"
    
    * tag 'drm-next-2018-06-06-1' of git://anongit.freedesktop.org/drm/drm: (1286 commits)
      drm/amdgpu: fix 32-bit build warning
      drm/exynos: fimc: signedness bug in fimc_setup_clocks()
      drm/exynos: scaler: fix static checker warning
      drm/amdgpu: Use dev_info() to report amdkfd is not supported for this ASIC
      drm/amd/display: Remove use of division operator for long longs
      drm/amdgpu: Update GFX info structure to match what vega20 used
      drm/amdgpu/pp: remove duplicate assignment
      drm/sched: add rcu_barrier after entity fini
      drm/amdgpu: move VM BOs on LRU again
      drm/amdgpu: consistenly use VM moved flag
      drm/amdgpu: kmap PDs/PTs in amdgpu_vm_update_directories
      drm/amdgpu: further optimize amdgpu_vm_handle_moved
      drm/amdgpu: cleanup amdgpu_vm_validate_pt_bos v2
      drm/amdgpu: rework VM state machine lock handling v2
      drm/amdgpu: Add runtime VCN PG support
      drm/amdgpu: Enable VCN static PG by default on RV
      drm/amdgpu: Add VCN static PG support on RV
      drm/amdgpu: Enable VCN CG by default on RV
      drm/amdgpu: Add static CG control for VCN on RV
      drm/exynos: Fix default value for zpos plane property
      ...

commit bdcc02cf1bb508fc700df7662f55058f651f2621
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri May 11 12:51:42 2018 -0700

    drm/psr: Fix missed entry in PSR setup time table.
    
    Entry corresponding to 220 us setup time was missing. I am not aware of
    any specific bug this fixes, but this could potentially result in enabling
    PSR on a panel with a higher setup time requirement than supported by the
    hardware.
    
    I verified the value is present in eDP spec versions 1.3, 1.4 and 1.4a.
    
    Fixes: 6608804b3d7f ("drm/dp: Add drm_dp_psr_setup_time()")
    Cc: stable@vger.kernel.org
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jose Roberto de Souza <jose.souza@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
    Reviewed-by: Tarun Vyas <tarun.vyas@intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180511195145.3829-3-dhinakaran.pandiyan@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index ffe14ec3e7f2..70ae1f232331 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1145,6 +1145,7 @@ int drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE])
 	static const u16 psr_setup_time_us[] = {
 		PSR_SETUP_TIME(330),
 		PSR_SETUP_TIME(275),
+		PSR_SETUP_TIME(220),
 		PSR_SETUP_TIME(165),
 		PSR_SETUP_TIME(110),
 		PSR_SETUP_TIME(55),

commit 2f065d8ae918159791474049ab67a0cb85723b81
Author: Matt Atwood <matthew.s.atwood@intel.com>
Date:   Fri May 4 15:18:00 2018 -0700

    drm/dp: Correctly mask DP_TRAINING_AUX_RD_INTERVAL values for DP 1.4
    
    DP_TRAINING_AUX_RD_INTERVAL with DP 1.3 spec changed bit scheeme from 8
    bits to 7 in DPCD 0x000e. The 8th bit is used to identify extended
    receiver capabilities. For panels that use this new feature wait interval
    would be increased by 512 ms, when spec is max 16 ms. This behavior is
    described in table 2-158 of DP 1.4 spec address 0000eh.
    
    With the introduction of DP 1.4 spec main link clock recovery was
    standardized to 100 us regardless of TRAINING_AUX_RD_INTERVAL value.
    
    To avoid breaking panels that are not spec compiant we now warn on
    invalid values.
    
    V2: commit title/message, masking all 7 bits, warn on out of spec values.
    V3: commit message, make link train clock recovery follow DP 1.4 spec.
    V4: style changes
    V5: typo
    V6: print statement revisions, DP_REV to DPCD_REV, comment correction
    V7: typo
    V8: Style
    V9: Strip out DPCD_REV_XX into seperate patch
    v10: DPCD_REV_XX to DP_DPCD_REV_XX
    
    Signed-off-by: Matt Atwood <matthew.s.atwood@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180504221800.17830-2-matthew.s.atwood@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index ffe14ec3e7f2..36c7609a4bd5 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -119,18 +119,32 @@ u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SI
 EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
 
 void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
-	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
+	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+			  DP_TRAINING_AUX_RD_MASK;
+
+	if (rd_interval > 4)
+		DRM_DEBUG_KMS("AUX interval %d, out of range (max 4)\n",
+			      rd_interval);
+
+	if (rd_interval == 0 || dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)
 		udelay(100);
 	else
-		mdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);
+		mdelay(rd_interval * 4);
 }
 EXPORT_SYMBOL(drm_dp_link_train_clock_recovery_delay);
 
 void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
-	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
+	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+			  DP_TRAINING_AUX_RD_MASK;
+
+	if (rd_interval > 4)
+		DRM_DEBUG_KMS("AUX interval %d, out of range (max 4)\n",
+			      rd_interval);
+
+	if (rd_interval == 0)
 		udelay(400);
 	else
-		mdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);
+		mdelay(rd_interval * 4);
 }
 EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);
 

commit e0bd878a959008f02a1280b1dd2c128324586af3
Author: Manasi Navare <manasi.d.navare@intel.com>
Date:   Mon Jan 22 14:43:10 2018 -0800

    drm/dp: Add HBR3 support in existing DRM DP helpers
    
    Existing helpers add support upto HBR2. This patch
    adds support for HBR3 rate (8.1 Gbps) introduced as
    part of DP 1.4 specification.
    
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1516660991-20697-1-git-send-email-manasi.d.navare@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index adf79be42c1e..ffe14ec3e7f2 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -146,6 +146,8 @@ u8 drm_dp_link_rate_to_bw_code(int link_rate)
 		return DP_LINK_BW_2_7;
 	case 540000:
 		return DP_LINK_BW_5_4;
+	case 810000:
+		return DP_LINK_BW_8_1;
 	}
 }
 EXPORT_SYMBOL(drm_dp_link_rate_to_bw_code);
@@ -161,6 +163,8 @@ int drm_dp_bw_code_to_link_rate(u8 link_bw)
 		return 270000;
 	case DP_LINK_BW_5_4:
 		return 540000;
+	case DP_LINK_BW_8_1:
+		return 810000;
 	}
 }
 EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);

commit 17ab7806de0c10d27cdbda8ef57ca680bdd24315
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Fri Jan 13 18:36:30 2017 +0100

    drm: don't link DP aux i2c adapter to the hardware device node
    
    The i2c adapter on DP AUX is purely a software construct. Linking
    it to the device node of the parent device is wrong, as it leads to
    2 devices sharing the same device node, which is bad practice, as
    well as the i2c trying to populate children of the i2c adapter by
    looking at the child device nodes of the parent device.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170113173630.22138-1-l.stach@pengutronix.de

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index b3d68964b407..adf79be42c1e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1097,7 +1097,6 @@ int drm_dp_aux_register(struct drm_dp_aux *aux)
 	aux->ddc.class = I2C_CLASS_DDC;
 	aux->ddc.owner = THIS_MODULE;
 	aux->ddc.dev.parent = aux->dev;
-	aux->ddc.dev.of_node = aux->dev->of_node;
 
 	strlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),
 		sizeof(aux->ddc.name));

commit cccf4e3fe3e286b55634c2c5d0c4399f4288e440
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Oct 9 12:29:57 2017 +0300

    drm/dp: WARN about invalid/unknown link rates and bw codes
    
    Falling back to the lowest value is likely the only thing we can do, but
    doing it silently seems like a bad thing to do. Catch it early and make
    loud noises.
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Manasi Navare <manasi.d.navare@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171009092959.29021-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 08af8d6b844b..b3d68964b407 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -137,8 +137,10 @@ EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);
 u8 drm_dp_link_rate_to_bw_code(int link_rate)
 {
 	switch (link_rate) {
-	case 162000:
 	default:
+		WARN(1, "unknown DP link rate %d, using %x\n", link_rate,
+		     DP_LINK_BW_1_62);
+	case 162000:
 		return DP_LINK_BW_1_62;
 	case 270000:
 		return DP_LINK_BW_2_7;
@@ -151,8 +153,9 @@ EXPORT_SYMBOL(drm_dp_link_rate_to_bw_code);
 int drm_dp_bw_code_to_link_rate(u8 link_bw)
 {
 	switch (link_bw) {
-	case DP_LINK_BW_1_62:
 	default:
+		WARN(1, "unknown DP link BW code %x, using 162000\n", link_bw);
+	case DP_LINK_BW_1_62:
 		return 162000;
 	case DP_LINK_BW_2_7:
 		return 270000;

commit 967003bb2cae121d345fd807eb757d9422229713
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 20 18:45:32 2017 +0100

    drm/dp: Don't trust drm_dp_downstream_id()
    
    Before we interpret drm_dp_downstream_id() as a string, make sure it is
    NULL terminated, even when drm_dp_downtsream_id() fails.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101660
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170720174532.23377-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 1d9e30f0dbf8..08af8d6b844b 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -544,7 +544,7 @@ void drm_dp_downstream_debug(struct seq_file *m,
 				 DP_DETAILED_CAP_INFO_AVAILABLE;
 	int clk;
 	int bpc;
-	char id[6];
+	char id[7];
 	int len;
 	uint8_t rev[2];
 	int type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
@@ -583,6 +583,7 @@ void drm_dp_downstream_debug(struct seq_file *m,
 		seq_puts(m, "\t\tType: N/A\n");
 	}
 
+	memset(id, 0, sizeof(id));
 	drm_dp_downstream_id(aux, id);
 	seq_printf(m, "\t\tID: %s\n", id);
 

commit c11a93f5fd9229dc7c8b90570c75cf70bc3976c2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 20 18:45:31 2017 +0100

    drm/dp: Fix read pointer for drm_dp_downsteam_debug()
    
    Pass in the array and not a pointer to the array to drm_dp_dpcd_read().
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170720174532.23377-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 213fb837e1c4..1d9e30f0dbf8 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -591,7 +591,7 @@ void drm_dp_downstream_debug(struct seq_file *m,
 		seq_printf(m, "\t\tHW: %d.%d\n",
 			   (rev[0] & 0xf0) >> 4, rev[0] & 0xf);
 
-	len = drm_dp_dpcd_read(aux, DP_BRANCH_SW_REV, &rev, 2);
+	len = drm_dp_dpcd_read(aux, DP_BRANCH_SW_REV, rev, 2);
 	if (len > 0)
 		seq_printf(m, "\t\tSW: %d.%d\n", rev[0], rev[1]);
 

commit 76fa998acd86b6b40d0217e12af39c2406bdcd2b
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 18 14:10:24 2017 +0300

    drm/dp: start a DPCD based DP sink/branch device quirk database
    
    Face the fact, there are Display Port sink and branch devices out there
    in the wild that don't follow the Display Port specifications, or they
    have bugs, or just otherwise require special treatment. Start a common
    quirk database the drivers can query based on the DP device
    identification. At least for now, we leave the workarounds for the
    drivers to implement as they see fit.
    
    For starters, add a branch device that can't handle full 24-bit main
    link Mdiv and Ndiv main link attributes properly. Naturally, the
    workaround of reducing main link attributes for all devices ended up in
    regressions for other devices. So here we are.
    
    v2: Rebase on DRM DP desc read helpers
    
    v3: Fix the OUI memcmp blunder (Clint)
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Clint Taylor <clinton.a.taylor@intel.com>
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Tested-by: Clinton Taylor <clinton.a.taylor@intel.com>
    Reviewed-by: Clinton Taylor <clinton.a.taylor@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> # v2
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/91ec198dd95258dbf3bee2f6be739e0da73b4fdd.1495105635.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 52e0ca9a5bb1..213fb837e1c4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1209,6 +1209,51 @@ int drm_dp_stop_crc(struct drm_dp_aux *aux)
 }
 EXPORT_SYMBOL(drm_dp_stop_crc);
 
+struct dpcd_quirk {
+	u8 oui[3];
+	bool is_branch;
+	u32 quirks;
+};
+
+#define OUI(first, second, third) { (first), (second), (third) }
+
+static const struct dpcd_quirk dpcd_quirk_list[] = {
+	/* Analogix 7737 needs reduced M and N at HBR2 link rates */
+	{ OUI(0x00, 0x22, 0xb9), true, BIT(DP_DPCD_QUIRK_LIMITED_M_N) },
+};
+
+#undef OUI
+
+/*
+ * Get a bit mask of DPCD quirks for the sink/branch device identified by
+ * ident. The quirk data is shared but it's up to the drivers to act on the
+ * data.
+ *
+ * For now, only the OUI (first three bytes) is used, but this may be extended
+ * to device identification string and hardware/firmware revisions later.
+ */
+static u32
+drm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)
+{
+	const struct dpcd_quirk *quirk;
+	u32 quirks = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpcd_quirk_list); i++) {
+		quirk = &dpcd_quirk_list[i];
+
+		if (quirk->is_branch != is_branch)
+			continue;
+
+		if (memcmp(quirk->oui, ident->oui, sizeof(ident->oui)) != 0)
+			continue;
+
+		quirks |= quirk->quirks;
+	}
+
+	return quirks;
+}
+
 /**
  * drm_dp_read_desc - read sink/branch descriptor from DPCD
  * @aux: DisplayPort AUX channel
@@ -1231,14 +1276,17 @@ int drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,
 	if (ret < 0)
 		return ret;
 
+	desc->quirks = drm_dp_get_quirks(ident, is_branch);
+
 	dev_id_len = strnlen(ident->device_id, sizeof(ident->device_id));
 
-	DRM_DEBUG_KMS("DP %s: OUI %*phD dev-ID %*pE HW-rev %d.%d SW-rev %d.%d\n",
+	DRM_DEBUG_KMS("DP %s: OUI %*phD dev-ID %*pE HW-rev %d.%d SW-rev %d.%d quirks 0x%04x\n",
 		      is_branch ? "branch" : "sink",
 		      (int)sizeof(ident->oui), ident->oui,
 		      dev_id_len, ident->device_id,
 		      ident->hw_rev >> 4, ident->hw_rev & 0xf,
-		      ident->sw_major_rev, ident->sw_minor_rev);
+		      ident->sw_major_rev, ident->sw_minor_rev,
+		      desc->quirks);
 
 	return 0;
 }

commit 118b90f3f18e733c99f0e8b98ea31a815ffc4d14
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu May 18 14:10:22 2017 +0300

    drm/dp: add helper for reading DP sink/branch device desc from DPCD
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/acba54da7d80eafea9e59a893e27e3c31028c0ba.1495105635.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 3e5f52110ea1..52e0ca9a5bb1 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1208,3 +1208,38 @@ int drm_dp_stop_crc(struct drm_dp_aux *aux)
 	return 0;
 }
 EXPORT_SYMBOL(drm_dp_stop_crc);
+
+/**
+ * drm_dp_read_desc - read sink/branch descriptor from DPCD
+ * @aux: DisplayPort AUX channel
+ * @desc: Device decriptor to fill from DPCD
+ * @is_branch: true for branch devices, false for sink devices
+ *
+ * Read DPCD 0x400 (sink) or 0x500 (branch) into @desc. Also debug log the
+ * identification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,
+		     bool is_branch)
+{
+	struct drm_dp_dpcd_ident *ident = &desc->ident;
+	unsigned int offset = is_branch ? DP_BRANCH_OUI : DP_SINK_OUI;
+	int ret, dev_id_len;
+
+	ret = drm_dp_dpcd_read(aux, offset, ident, sizeof(*ident));
+	if (ret < 0)
+		return ret;
+
+	dev_id_len = strnlen(ident->device_id, sizeof(ident->device_id));
+
+	DRM_DEBUG_KMS("DP %s: OUI %*phD dev-ID %*pE HW-rev %d.%d SW-rev %d.%d\n",
+		      is_branch ? "branch" : "sink",
+		      (int)sizeof(ident->oui), ident->oui,
+		      dev_id_len, ident->device_id,
+		      ident->hw_rev >> 4, ident->hw_rev & 0xf,
+		      ident->sw_major_rev, ident->sw_minor_rev);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_read_desc);

commit 0621ce1db336b40985658f6f0447936610f87fc2
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Mar 7 21:35:11 2017 +0100

    drm/dp: Add missing description to parameter
    
    Gabriel Krisman reported these warnings when building the documentation:
    
     ./drivers/gpu/drm/drm_dp_helper.c:1165: warning: No description found
    for parameter 'crtc'
    ./drivers/gpu/drm/drm_dp_helper.c:1166: warning: No description found
    for parameter 'crtc'
    
    Reported-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170307203511.14258-1-tomeu.vizoso@collabora.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index c40cfe2e63ab..3e5f52110ea1 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -1158,6 +1158,7 @@ EXPORT_SYMBOL(drm_dp_psr_setup_time);
 /**
  * drm_dp_start_crc() - start capture of frame CRCs
  * @aux: DisplayPort AUX channel
+ * @crtc: CRTC displaying the frames whose CRCs are to be captured
  *
  * Returns 0 on success or a negative error code on failure.
  */

commit 79c1da7c3bf74be9b1dae9450ef79f32dd22def6
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Mar 3 14:39:34 2017 +0100

    drm/dp: add helpers for capture of frame CRCs
    
    Adds helpers for starting and stopping capture of frame CRCs through the
    DPCD. When capture is on, a worker waits for vblanks and retrieves the
    frame CRC to put it in the queue on the CRTC that is using the
    eDP connector, so it's passed to userspace.
    
    v2: Reuse drm_crtc_wait_one_vblank
        Update locking, as drm_crtc_add_crc_entry now takes the lock
    
    v3: Don't call wake_up_interruptible directly, that's now done in
        drm_crtc_add_crc_entry.
    
    v4: Style fixes (Sean Paul)
        Reworked retry of CRC reads (Sean Paul)
        Flush worker after stopping CRC generationa (Sean Paul)
    
    v5: Move back to make the retry explicitly once
    
    v6: Set and use the drm_crtc backpointer (Sean Paul)
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170303133936.14964-3-tomeu.vizoso@collabora.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 68908c1d5ca1..c40cfe2e63ab 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -981,6 +981,78 @@ static const struct i2c_lock_operations drm_dp_i2c_lock_ops = {
 	.unlock_bus = unlock_bus,
 };
 
+static int drm_dp_aux_get_crc(struct drm_dp_aux *aux, u8 *crc)
+{
+	u8 buf, count;
+	int ret;
+
+	ret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);
+	if (ret < 0)
+		return ret;
+
+	WARN_ON(!(buf & DP_TEST_SINK_START));
+
+	ret = drm_dp_dpcd_readb(aux, DP_TEST_SINK_MISC, &buf);
+	if (ret < 0)
+		return ret;
+
+	count = buf & DP_TEST_COUNT_MASK;
+	if (count == aux->crc_count)
+		return -EAGAIN; /* No CRC yet */
+
+	aux->crc_count = count;
+
+	/*
+	 * At DP_TEST_CRC_R_CR, there's 6 bytes containing CRC data, 2 bytes
+	 * per component (RGB or CrYCb).
+	 */
+	ret = drm_dp_dpcd_read(aux, DP_TEST_CRC_R_CR, crc, 6);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void drm_dp_aux_crc_work(struct work_struct *work)
+{
+	struct drm_dp_aux *aux = container_of(work, struct drm_dp_aux,
+					      crc_work);
+	struct drm_crtc *crtc;
+	u8 crc_bytes[6];
+	uint32_t crcs[3];
+	int ret;
+
+	if (WARN_ON(!aux->crtc))
+		return;
+
+	crtc = aux->crtc;
+	while (crtc->crc.opened) {
+		drm_crtc_wait_one_vblank(crtc);
+		if (!crtc->crc.opened)
+			break;
+
+		ret = drm_dp_aux_get_crc(aux, crc_bytes);
+		if (ret == -EAGAIN) {
+			usleep_range(1000, 2000);
+			ret = drm_dp_aux_get_crc(aux, crc_bytes);
+		}
+
+		if (ret == -EAGAIN) {
+			DRM_DEBUG_KMS("Get CRC failed after retrying: %d\n",
+				      ret);
+			continue;
+		} else if (ret) {
+			DRM_DEBUG_KMS("Failed to get a CRC: %d\n", ret);
+			continue;
+		}
+
+		crcs[0] = crc_bytes[0] | crc_bytes[1] << 8;
+		crcs[1] = crc_bytes[2] | crc_bytes[3] << 8;
+		crcs[2] = crc_bytes[4] | crc_bytes[5] << 8;
+		drm_crtc_add_crc_entry(crtc, false, 0, crcs);
+	}
+}
+
 /**
  * drm_dp_aux_init() - minimally initialise an aux channel
  * @aux: DisplayPort AUX channel
@@ -993,6 +1065,7 @@ static const struct i2c_lock_operations drm_dp_i2c_lock_ops = {
 void drm_dp_aux_init(struct drm_dp_aux *aux)
 {
 	mutex_init(&aux->hw_mutex);
+	INIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);
 
 	aux->ddc.algo = &drm_dp_i2c_algo;
 	aux->ddc.algo_data = aux;
@@ -1081,3 +1154,56 @@ int drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE])
 EXPORT_SYMBOL(drm_dp_psr_setup_time);
 
 #undef PSR_SETUP_TIME
+
+/**
+ * drm_dp_start_crc() - start capture of frame CRCs
+ * @aux: DisplayPort AUX channel
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_start_crc(struct drm_dp_aux *aux, struct drm_crtc *crtc)
+{
+	u8 buf;
+	int ret;
+
+	ret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);
+	if (ret < 0)
+		return ret;
+
+	ret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf | DP_TEST_SINK_START);
+	if (ret < 0)
+		return ret;
+
+	aux->crc_count = 0;
+	aux->crtc = crtc;
+	schedule_work(&aux->crc_work);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_start_crc);
+
+/**
+ * drm_dp_stop_crc() - stop capture of frame CRCs
+ * @aux: DisplayPort AUX channel
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_stop_crc(struct drm_dp_aux *aux)
+{
+	u8 buf;
+	int ret;
+
+	ret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);
+	if (ret < 0)
+		return ret;
+
+	ret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf & ~DP_TEST_SINK_START);
+	if (ret < 0)
+		return ret;
+
+	flush_work(&aux->crc_work);
+	aux->crtc = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_stop_crc);

commit 6806cdf9aa1c822afd89881e48908315aed18451
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:43 2017 +0100

    drm/kms-helpers: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Comments from Gustavo.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Rewiewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 3e6fe82c6d64..68908c1d5ca1 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -725,7 +725,7 @@ MODULE_PARM_DESC(dp_aux_i2c_speed_khz,
 /*
  * Transfer a single I2C-over-AUX message and handle various error conditions,
  * retrying the transaction as appropriate.  It is assumed that the
- * aux->transfer function does not modify anything in the msg other than the
+ * &drm_dp_aux.transfer function does not modify anything in the msg other than the
  * reply field.
  *
  * Returns bytes transferred on success, or a negative error code on failure.

commit 6b25e21fa6f26d0f0d45f161d169029411c84286
Merge: a379f71a30dd 69405d3da98b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 11 18:12:22 2016 -0700

    Merge tag 'drm-for-v4.9' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Core:
       - Fence destaging work
       - DRIVER_LEGACY to split off legacy drm drivers
       - drm_mm refactoring
       - Splitting drm_crtc.c into chunks and documenting better
       - Display info fixes
       - rbtree support for prime buffer lookup
       - Simple VGA DAC driver
    
      Panel:
       - Add Nexus 7 panel
       - More simple panels
    
      i915:
       - Refactoring GEM naming
       - Refactored vma/active tracking
       - Lockless request lookups
       - Better stolen memory support
       - FBC fixes
       - SKL watermark fixes
       - VGPU improvements
       - dma-buf fencing support
       - Better DP dongle support
    
      amdgpu:
       - Powerplay for Iceland asics
       - Improved GPU reset support
       - UVD/VEC powergating support for CZ/ST
       - Preinitialised VRAM buffer support
       - Virtual display support
       - Initial SI support
       - GTT rework
       - PCI shutdown callback support
       - HPD IRQ storm fixes
    
      amdkfd:
       - bugfixes
    
      tilcdc:
       - Atomic modesetting support
    
      mediatek:
       - AAL + GAMMA engine support
       - Hook up gamma LUT
       - Temporal dithering support
    
      imx:
       - Pixel clock from devicetree
       - drm bridge support for LVDS bridges
       - active plane reconfiguration
       - VDIC deinterlacer support
       - Frame synchronisation unit support
       - Color space conversion support
    
      analogix:
       - PSR support
       - Better panel on/off support
    
      rockchip:
       - rk3399 vop/crtc support
       - PSR support
    
      vc4:
       - Interlaced vblank timing
       - 3D rendering CPU overhead reduction
       - HDMI output fixes
    
      tda998x:
       - HDMI audio ASoC support
    
      sunxi:
       - Allwinner A33 support
       - better TCON support
    
      msm:
       - DT binding cleanups
       - Explicit fence-fd support
    
      sti:
       - remove sti415/416 support
    
      etnaviv:
       - MMUv2 refactoring
       - GC3000 support
    
      exynos:
       - Refactoring HDMI DCC/PHY
       - G2D pm regression fix
       - Page fault issues with wait for vblank
    
      There is no nouveau work in this tree, as Ben didn't get a pull
      request in, and he was fighting moving to atomic and adding mst
      support, so maybe best it waits for a cycle"
    
    * tag 'drm-for-v4.9' of git://people.freedesktop.org/~airlied/linux: (1412 commits)
      drm/crtc: constify drm_crtc_index parameter
      drm/i915: Fix conflict resolution from backmerge of v4.8-rc8 to drm-next
      drm/i915/guc: Unwind GuC workqueue reservation if request construction fails
      drm/i915: Reset the breadcrumbs IRQ more carefully
      drm/i915: Force relocations via cpu if we run out of idle aperture
      drm/i915: Distinguish last emitted request from last submitted request
      drm/i915: Allow DP to work w/o EDID
      drm/i915: Move long hpd handling into the hotplug work
      drm/i915/execlists: Reinitialise context image after GPU hang
      drm/i915: Use correct index for backtracking HUNG semaphores
      drm/i915: Unalias obj->phys_handle and obj->userptr
      drm/i915: Just clear the mmiodebug before a register access
      drm/i915/gen9: only add the planes actually affected by ddb changes
      drm/i915: Allow PCH DPLL sharing regardless of DPLL_SDVO_HIGH_SPEED
      drm/i915/bxt: Fix HDMI DPLL configuration
      drm/i915/gen9: fix the watermark res_blocks value
      drm/i915/gen9: fix plane_blocks_per_line on watermarks calculations
      drm/i915/gen9: minimum scanlines for Y tile is not always 4
      drm/i915/gen9: fix the WaWmMemoryReadLatency implementation
      drm/i915/kbl: KBL also needs to run the SAGV code
      ...

commit 3f346d5dcb591c2a5a26653d093af710cf2e5a31
Merge: 196ebdcc1db2 089cfdd9b0ec
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Sep 28 10:28:23 2016 +1000

    Merge tag 'topic/drm-misc-2016-09-25' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - more core cleanup patches to prep drm_file to be used for
      kernel-internal contexts (David Herrmann)
    - more split-up+docs for drm_crtc.c
    - lots of small fixes and polish all over
    
    * tag 'topic/drm-misc-2016-09-25' of git://anongit.freedesktop.org/drm-intel: (37 commits)
      drm: bridge: analogix/dp: mark symbols static where possible
      drm/bochs: mark bochs_connector_get_modes() static
      drm/bridge: analogix_dp: Improve panel on time
      drm/bridge: analogix_dp: Don't read EDID if panel present
      drm/bridge: analogix_dp: Remove duplicated code
      Revert "drm/i2c: tda998x: don't register the connector"
      drm: Fix plane type uabi breakage
      dma-buf/sync_file: free fences array in num_fences is 1
      drm/i2c: tda998x: don't register the connector
      drm: Don't swallow error codes in drm_dev_alloc()
      drm: Distinguish no name from ENOMEM in set_unique()
      drm: Remove dirty property from docs
      drm/doc: Document color space handling
      drm: Extract drm_color_mgmt.[hc]
      drm/doc: Polish plane composition property docs
      drm: Conslidate blending properties in drm_blend.[hc]
      drm/doc: Polish for drm_plane.[hc]
      drm: Extract drm_plane.[hc]
      drm/tilcdc: Add atomic and crtc headers to crtc.c
      drm: Fix typo in encoder docs
      ...

commit b81a6179b6035a77d9d56d08ba1c0f81d6d4c2c5
Merge: bd4a68da1989 6e05f3d3b929
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Sep 20 06:23:22 2016 +1000

    Merge tag 'drm-intel-next-2016-09-19' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - refactor the sseu code (Imre)
    - refine guc dmesg output (Dave Gordon)
    - more vgpu work
    - more skl wm fixes (Lyude)
    - refactor dpll code in prep for upfront link training (Jim Bride et al)
    - consolidate all platform feature checks into intel_device_info (Carlos Santa)
    - refactor elsp/execlist submission as prep for re-submission after hang
      recovery and eventually scheduling (Chris Wilson)
    - allow synchronous gpu reset handling, to remove tricky/impossible/fragile
      error recovery code (Chris Wilson)
    - prep work for nonblocking (execlist) submission, using fences to track
      depencies and drive elsp submission (Chris Wilson)
    - partial error recover/resubmission of non-guilty batches after hangs (Chris Wilson)
    - full dma-buf implicit fencing support (Chris Wilson)
    - dp link training fixes (Jim, Dhinkaran, Navare, ...)
    - obey dp branch device pixel rate/bpc/clock limits (Mika Kahola), needed for
      many vga dongles
    - bunch of small cleanups and polish all over, as usual
    
    [airlied: printing macros collided]
    
    * tag 'drm-intel-next-2016-09-19' of git://anongit.freedesktop.org/drm-intel: (163 commits)
      drm/i915: Update DRIVER_DATE to 20160919
      drm: Fix DisplayPort branch device ID kernel-doc
      drm/i915: use NULL for NULL pointers
      drm/i915: do not use 'false' as a NULL pointer
      drm/i915: make intel_dp_compute_bpp static
      drm: Add DP branch device info on debugfs
      drm/i915: Update bits per component for display info
      drm/i915: Check pixel rate for DP to VGA dongle
      drm/i915: Read DP branch device SW revision
      drm/i915: Read DP branch device HW revision
      drm/i915: Cleanup DisplayPort AUX channel initialization
      drm: Read DP branch device id
      drm: Helper to read max bits per component
      drm: Helper to read max clock rate
      drm: Drop VGA from bpc definitions
      drm: Add missing DP downstream port types
      drm/i915: Add ddb size field to device info structure
      drm/i915/guc: general tidying up (submission)
      drm/i915/guc: general tidying up (loader)
      drm/i915: clarify PMINTRMSK/pm_intr_keep usage
      ...

commit 96106c9729f5d4fad5fe1cb874616d00008a973a
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 16 13:06:36 2016 +0300

    drm: fix implicit declaration build error on ia64
    
       drivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_downstream_debug':
    >> drivers/gpu/drm/drm_dp_helper.c:551:2: error: implicit declaration of
    >> function 'seq_printf' [-Werror=implicit-function-declaration]
         seq_printf(m, "\tDP branch device present: %s\n",
         ^
    >> drivers/gpu/drm/drm_dp_helper.c:559:3: error: implicit declaration of
    >> function 'seq_puts' [-Werror=implicit-function-declaration]
         seq_puts(m, "\t\tType: DisplayPort\n");
         ^
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    References: https://lists.freedesktop.org/archives/intel-gfx/2016-September/106638.html
    Fixes: 80209e5f2c42 ("drm: Add DP branch device info on debugfs")
    Cc: Mika Kahola <mika.kahola@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474020396-14875-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 031c4d335b08..48c122da27a6 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -27,6 +27,7 @@
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/i2c.h>
+#include <linux/seq_file.h>
 #include <drm/drm_dp_helper.h>
 #include <drm/drmP.h>
 

commit 3442d9eee459bb565c37a15eed57572b511e9c64
Author: Mika Kahola <mika.kahola@intel.com>
Date:   Fri Sep 16 13:39:15 2016 +0300

    drm: Fix DisplayPort branch device ID kernel-doc
    
    Fix missing parameter description for DisplayPort branch device ID.
    This fixes warning of "No description found for parameter 'id[6]'" when
    creating documentation by 'make htmldocs'.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    References: https://lists.freedesktop.org/archives/intel-gfx/2016-September/106645.html
    Fixes: 266d783baaf5 ("drm: Read DP branch device id")
    Signed-off-by: Mika Kahola <mika.kahola@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474022355-29990-1-git-send-email-mika.kahola@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index e26936309e07..559db96c2f8c 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -516,6 +516,7 @@ EXPORT_SYMBOL(drm_dp_downstream_max_bpc);
 /**
  * drm_dp_downstream_id() - identify branch device
  * @aux: DisplayPort AUX channel
+ * @id: DisplayPort branch device id
  *
  * Returns branch device id on success or NULL on failure
  */

commit 80209e5f2c42c491ec5f4a63705b4377b407587c
Author: Mika Kahola <mika.kahola@intel.com>
Date:   Fri Sep 9 14:10:57 2016 +0300

    drm: Add DP branch device info on debugfs
    
    Read DisplayPort branch device info from through debugfs
    interface.
    
    v2: use drm_dp_helper routines to collect data
    v3: cleanup to match the drm_dp_helper.c patches introduced
        earlier in this series
    v4: move DP branch device info to function 'intel_dp_branch_device_info()'
    v5: initial step to move debugging info from intel_dp. to drm_dp_helper.c (Daniel)
    v6: read hw and sw revision without using specific drm_dp_helper routines
    v7: indentation fixes (Jim Bride)
    
    Signed-off-by: Mika Kahola <mika.kahola@intel.com>
    Reviewed-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1473419458-17080-12-git-send-email-mika.kahola@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 7b3a638725d9..e26936309e07 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -525,6 +525,91 @@ int drm_dp_downstream_id(struct drm_dp_aux *aux, char id[6])
 }
 EXPORT_SYMBOL(drm_dp_downstream_id);
 
+/**
+ * drm_dp_downstream_debug() - debug DP branch devices
+ * @m: pointer for debugfs file
+ * @dpcd: DisplayPort configuration data
+ * @port_cap: port capabilities
+ * @aux: DisplayPort AUX channel
+ *
+ */
+void drm_dp_downstream_debug(struct seq_file *m,
+			     const u8 dpcd[DP_RECEIVER_CAP_SIZE],
+			     const u8 port_cap[4], struct drm_dp_aux *aux)
+{
+	bool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
+				 DP_DETAILED_CAP_INFO_AVAILABLE;
+	int clk;
+	int bpc;
+	char id[6];
+	int len;
+	uint8_t rev[2];
+	int type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
+	bool branch_device = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
+			     DP_DWN_STRM_PORT_PRESENT;
+
+	seq_printf(m, "\tDP branch device present: %s\n",
+		   branch_device ? "yes" : "no");
+
+	if (!branch_device)
+		return;
+
+	switch (type) {
+	case DP_DS_PORT_TYPE_DP:
+		seq_puts(m, "\t\tType: DisplayPort\n");
+		break;
+	case DP_DS_PORT_TYPE_VGA:
+		seq_puts(m, "\t\tType: VGA\n");
+		break;
+	case DP_DS_PORT_TYPE_DVI:
+		seq_puts(m, "\t\tType: DVI\n");
+		break;
+	case DP_DS_PORT_TYPE_HDMI:
+		seq_puts(m, "\t\tType: HDMI\n");
+		break;
+	case DP_DS_PORT_TYPE_NON_EDID:
+		seq_puts(m, "\t\tType: others without EDID support\n");
+		break;
+	case DP_DS_PORT_TYPE_DP_DUALMODE:
+		seq_puts(m, "\t\tType: DP++\n");
+		break;
+	case DP_DS_PORT_TYPE_WIRELESS:
+		seq_puts(m, "\t\tType: Wireless\n");
+		break;
+	default:
+		seq_puts(m, "\t\tType: N/A\n");
+	}
+
+	drm_dp_downstream_id(aux, id);
+	seq_printf(m, "\t\tID: %s\n", id);
+
+	len = drm_dp_dpcd_read(aux, DP_BRANCH_HW_REV, &rev[0], 1);
+	if (len > 0)
+		seq_printf(m, "\t\tHW: %d.%d\n",
+			   (rev[0] & 0xf0) >> 4, rev[0] & 0xf);
+
+	len = drm_dp_dpcd_read(aux, DP_BRANCH_SW_REV, &rev, 2);
+	if (len > 0)
+		seq_printf(m, "\t\tSW: %d.%d\n", rev[0], rev[1]);
+
+	if (detailed_cap_info) {
+		clk = drm_dp_downstream_max_clock(dpcd, port_cap);
+
+		if (clk > 0) {
+			if (type == DP_DS_PORT_TYPE_VGA)
+				seq_printf(m, "\t\tMax dot clock: %d kHz\n", clk);
+			else
+				seq_printf(m, "\t\tMax TMDS clock: %d kHz\n", clk);
+		}
+
+		bpc = drm_dp_downstream_max_bpc(dpcd, port_cap);
+
+		if (bpc > 0)
+			seq_printf(m, "\t\tMax bpc: %d\n", bpc);
+	}
+}
+EXPORT_SYMBOL(drm_dp_downstream_debug);
+
 /*
  * I2C-over-AUX implementation
  */

commit 266d783baaf5f34a5bea3b56489f091451a89767
Author: Mika Kahola <mika.kahola@intel.com>
Date:   Fri Sep 9 14:10:51 2016 +0300

    drm: Read DP branch device id
    
    Read DisplayPort branch device id string.
    
    Reviewed-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Mika Kahola <mika.kahola@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1473419458-17080-6-git-send-email-mika.kahola@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 57c61d126a56..7b3a638725d9 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -513,6 +513,18 @@ int drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_downstream_max_bpc);
 
+/**
+ * drm_dp_downstream_id() - identify branch device
+ * @aux: DisplayPort AUX channel
+ *
+ * Returns branch device id on success or NULL on failure
+ */
+int drm_dp_downstream_id(struct drm_dp_aux *aux, char id[6])
+{
+	return drm_dp_dpcd_read(aux, DP_BRANCH_ID, id, 6);
+}
+EXPORT_SYMBOL(drm_dp_downstream_id);
+
 /*
  * I2C-over-AUX implementation
  */

commit 7529d6af1cd16b0ecd286a1bf6ceee5328ab9809
Author: Mika Kahola <mika.kahola@intel.com>
Date:   Fri Sep 9 14:10:50 2016 +0300

    drm: Helper to read max bits per component
    
    Helper routine to read out maximum supported bits per
    component for DisplayPort legay converters.
    
    v2: Return early if detailed port cap info is not available.
        Replace if-else ladder with switch-case (Ville)
    
    Reviewed-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Mika Kahola <mika.kahola@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1473419458-17080-5-git-send-email-mika.kahola@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f171fbf8b1b9..57c61d126a56 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -471,6 +471,48 @@ int drm_dp_downstream_max_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_downstream_max_clock);
 
+/**
+ * drm_dp_downstream_max_bpc() - extract branch device max
+ *                               bits per component
+ * @dpcd: DisplayPort configuration data
+ * @port_cap: port capabilities
+ *
+ * Returns max bpc on success or 0 if max bpc not defined
+ */
+int drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
+			      const u8 port_cap[4])
+{
+	int type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
+	bool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
+		DP_DETAILED_CAP_INFO_AVAILABLE;
+	int bpc;
+
+	if (!detailed_cap_info)
+		return 0;
+
+	switch (type) {
+	case DP_DS_PORT_TYPE_VGA:
+	case DP_DS_PORT_TYPE_DVI:
+	case DP_DS_PORT_TYPE_HDMI:
+	case DP_DS_PORT_TYPE_DP_DUALMODE:
+		bpc = port_cap[2] & DP_DS_MAX_BPC_MASK;
+
+		switch (bpc) {
+		case DP_DS_8BPC:
+			return 8;
+		case DP_DS_10BPC:
+			return 10;
+		case DP_DS_12BPC:
+			return 12;
+		case DP_DS_16BPC:
+			return 16;
+		}
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL(drm_dp_downstream_max_bpc);
+
 /*
  * I2C-over-AUX implementation
  */

commit 1c29bd3d6011bed4cbae215571f6f4c25ab10012
Author: Mika Kahola <mika.kahola@intel.com>
Date:   Fri Sep 9 14:10:49 2016 +0300

    drm: Helper to read max clock rate
    
    Helper routine to read out maximum supported pixel rate
    for DisplayPort legay VGA converter or TMDS clock rate
    for other digital legacy converters. The helper returns
    clock rate in kHz.
    
    v2: Return early if detailed port cap info is not available.
        Replace if-else ladder with switch-case (Ville)
    
    Reviewed-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Mika Kahola <mika.kahola@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1473419458-17080-4-git-send-email-mika.kahola@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 5d20255f3db3..f171fbf8b1b9 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -438,6 +438,39 @@ int drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)
 }
 EXPORT_SYMBOL(drm_dp_link_configure);
 
+/**
+ * drm_dp_downstream_max_clock() - extract branch device max
+ *                                 pixel rate for legacy VGA
+ *                                 converter or max TMDS clock
+ *                                 rate for others
+ * @dpcd: DisplayPort configuration data
+ * @port_cap: port capabilities
+ *
+ * Returns max clock in kHz on success or 0 if max clock not defined
+ */
+int drm_dp_downstream_max_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
+				const u8 port_cap[4])
+{
+	int type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
+	bool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
+		DP_DETAILED_CAP_INFO_AVAILABLE;
+
+	if (!detailed_cap_info)
+		return 0;
+
+	switch (type) {
+	case DP_DS_PORT_TYPE_VGA:
+		return port_cap[1] * 8 * 1000;
+	case DP_DS_PORT_TYPE_DVI:
+	case DP_DS_PORT_TYPE_HDMI:
+	case DP_DS_PORT_TYPE_DP_DUALMODE:
+		return port_cap[1] * 2500;
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL(drm_dp_downstream_max_clock);
+
 /*
  * I2C-over-AUX implementation
  */

commit d1ed7985b9a6b85ea38a330108c51ec83381c01b
Author: Peter Rosin <peda@axentia.se>
Date:   Thu Aug 25 23:07:01 2016 +0200

    i2c: move locking operations to their own struct
    
    This makes it trivial to constify them, so do that.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index eae5ef963cb7..2bd064493ae7 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -790,6 +790,12 @@ static void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)
 	mutex_unlock(&i2c_to_aux(i2c)->hw_mutex);
 }
 
+static const struct i2c_lock_operations drm_dp_i2c_lock_ops = {
+	.lock_bus = lock_bus,
+	.trylock_bus = trylock_bus,
+	.unlock_bus = unlock_bus,
+};
+
 /**
  * drm_dp_aux_init() - minimally initialise an aux channel
  * @aux: DisplayPort AUX channel
@@ -807,9 +813,7 @@ void drm_dp_aux_init(struct drm_dp_aux *aux)
 	aux->ddc.algo_data = aux;
 	aux->ddc.retries = 3;
 
-	aux->ddc.lock_bus = lock_bus;
-	aux->ddc.trylock_bus = trylock_bus;
-	aux->ddc.unlock_bus = unlock_bus;
+	aux->ddc.lock_ops = &drm_dp_i2c_lock_ops;
 }
 EXPORT_SYMBOL(drm_dp_aux_init);
 

commit e15c8f4b6e5ecd370890c218688ead4e91f6b0d6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:52 2016 +0200

    drm: Don't export dp-aux devnode functions
    
    They're only used internally within the dp helpers. Also nuke the
    kerneldoc (we only document the driver interface in the drm shared
    functions). And move the header file from the public include/
    directory to the source files into drm_crtc_helper_internal.h, similar
    to how we already have drm_crtc_internal.h.
    
    While at it also move drm_fb_helper_modinit since that belongs in
    there, too.
    
    I noticed this all since I spotted kerneldoc which wasn't pulled into
    the rst templates.
    
    v2: Update Copyright date.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Rafael Antognolli <rafael.antognolli@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-16-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 5d20255f3db3..031c4d335b08 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -28,9 +28,10 @@
 #include <linux/sched.h>
 #include <linux/i2c.h>
 #include <drm/drm_dp_helper.h>
-#include <drm/drm_dp_aux_dev.h>
 #include <drm/drmP.h>
 
+#include "drm_crtc_helper_internal.h"
+
 /**
  * DOC: dp helpers
  *

commit 9622c38f1cbab00aa2f52715ec950c5c5f838aa5
Author: Lyude <cpaul@redhat.com>
Date:   Fri Aug 5 20:30:39 2016 -0400

    drm/dp_helper: Rate limit timeout errors from drm_dp_i2c_do_msg()
    
    Timeouts can be errors, but timeouts are also usually normal behavior
    and happen a lot. Since the kernel already lets us know when we're
    suppressing messages due to rate limiting, rate limit timeout errors so
    we don't make too much noise in the kernel log.
    
    Signed-off-by: Lyude <cpaul@redhat.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470443443-27252-8-git-send-email-cpaul@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 198e9e22f72b..5d20255f3db3 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -574,7 +574,17 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			if (ret == -EBUSY)
 				continue;
 
-			DRM_DEBUG_KMS("transaction failed: %d\n", ret);
+			/*
+			 * While timeouts can be errors, they're usually normal
+			 * behavior (for instance, when a driver tries to
+			 * communicate with a non-existant DisplayPort device).
+			 * Avoid spamming the kernel log with timeout errors.
+			 */
+			if (ret == -ETIMEDOUT)
+				DRM_DEBUG_KMS_RATELIMITED("transaction timed out\n");
+			else
+				DRM_DEBUG_KMS("transaction failed: %d\n", ret);
+
 			return ret;
 		}
 

commit 29f21e0491819d05d28b4a1f7a5b7e68f802c60b
Author: Lyude <cpaul@redhat.com>
Date:   Fri Aug 5 20:30:33 2016 -0400

    drm/dp_helper: Print first error received on failure in drm_dp_dpcd_access()
    
    Since we always retry in drm_dp_dpcd_access() regardless of the error,
    we're going to make a lot of noise if the aux->transfer function prints
    it's own errors (as is the case with radeon). If we can print the error
    code here, this reduces the need for drivers to do this. So instead of
    having to print "dp_aux_ch timed out" over 32 times we can just print
    once.
    
    Signed-off-by: Lyude <cpaul@redhat.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470443443-27252-2-git-send-email-cpaul@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index eae5ef963cb7..198e9e22f72b 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -223,7 +223,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 			err = ret;
 	}
 
-	DRM_DEBUG_KMS("too many retries, giving up\n");
+	DRM_DEBUG_KMS("Too many retries, giving up. First error: %d\n", err);
 	ret = err;
 
 unlock:

commit 6608804b3d7f0552a38641b03a4e3aa1852df15b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed May 18 11:57:29 2016 +0300

    drm/dp: Add drm_dp_psr_setup_time()
    
    Add a small helper to parse the PSR setup time from the DPCD PSR
    capabilities and return the value in microseconds.
    
    v2: Don't waste so many bytes on the psr_setup_time_us[] table
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 8f11b8741e42..eae5ef963cb7 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -860,3 +860,35 @@ void drm_dp_aux_unregister(struct drm_dp_aux *aux)
 	i2c_del_adapter(&aux->ddc);
 }
 EXPORT_SYMBOL(drm_dp_aux_unregister);
+
+#define PSR_SETUP_TIME(x) [DP_PSR_SETUP_TIME_ ## x >> DP_PSR_SETUP_TIME_SHIFT] = (x)
+
+/**
+ * drm_dp_psr_setup_time() - PSR setup in time usec
+ * @psr_cap: PSR capabilities from DPCD
+ *
+ * Returns:
+ * PSR setup time for the panel in microseconds,  negative
+ * error code on failure.
+ */
+int drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE])
+{
+	static const u16 psr_setup_time_us[] = {
+		PSR_SETUP_TIME(330),
+		PSR_SETUP_TIME(275),
+		PSR_SETUP_TIME(165),
+		PSR_SETUP_TIME(110),
+		PSR_SETUP_TIME(55),
+		PSR_SETUP_TIME(0),
+	};
+	int i;
+
+	i = (psr_cap[1] & DP_PSR_SETUP_TIME_MASK) >> DP_PSR_SETUP_TIME_SHIFT;
+	if (i >= ARRAY_SIZE(psr_setup_time_us))
+		return -EINVAL;
+
+	return psr_setup_time_us[i];
+}
+EXPORT_SYMBOL(drm_dp_psr_setup_time);
+
+#undef PSR_SETUP_TIME

commit a1f5524a66ff6284d1380cdd7723de82698ff9d3
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jul 28 17:54:42 2016 +0300

    drm: aux ->transfer() can return 0, deal with it
    
    Restore the correct behaviour (as in check msg.reply) when aux
    ->transfer() returns 0. It got removed in
    commit 82922da39190 ("drm/dp_helper: Retry aux transactions on all errors")
    
    Now I can actually dump the "entire" DPCD on a Dell UP2314Q with
    ddrescue. It has some offsets in the DPCD that can't be read
    for some resaon, all you get is defers. Previously ddrescue would
    just give up at the first unredable offset on account of
    read() returning 0 means EOF. Here's the ddrescue log
    for the interested:
    0x00000000  0x00001400  +
    0x00001400  0x00000030  -
    0x00001430  0x000001D0  +
    0x00001600  0x00000030  -
    0x00001630  0x0001F9D0  +
    0x00021000  0x00000001  -
    0x00021001  0x000DEFFF  +
    
    Cc: Lyude <cpaul@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch
    Cc: stable@vger.kernel.org
    Fixes: 82922da39190 ("drm/dp_helper: Retry aux transactions on all errors")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 091053e995e5..8f11b8741e42 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -203,7 +203,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 
 		ret = aux->transfer(aux, &msg);
 
-		if (ret > 0) {
+		if (ret >= 0) {
 			native_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;
 			if (native_reply == DP_AUX_NATIVE_REPLY_ACK) {
 				if (ret == size)

commit acd8f414c957406c8272cbc380dd50fea945dcf1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 17 09:33:18 2016 +0100

    drm: Minimally initialise drm_dp_aux
    
    When trying to split up the initialisation phase and the registration
    phase, one immediate problem encountered is trying to use our own i2c
    devices before registration with userspace (to read EDID during device
    discovery). drm_dp_aux in particular only offers an interface for setting
    up the device *after* we have exposed the connector via sysfs. In order
    to break the chicken-and-egg problem, export drm_dp_aux_init() to
    minimally prepare the i2c device for internal use before
    drm_connector_register().
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Rafael Antognolli <rafael.antognolli@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: dri-devel@lists.freedesktop.org
    [danvet: Amend kerneldoc slightly.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466152398-20157-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 4b088afa21b2..091053e995e5 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -791,15 +791,16 @@ static void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)
 }
 
 /**
- * drm_dp_aux_register() - initialise and register aux channel
+ * drm_dp_aux_init() - minimally initialise an aux channel
  * @aux: DisplayPort AUX channel
  *
- * Returns 0 on success or a negative error code on failure.
+ * If you need to use the drm_dp_aux's i2c adapter prior to registering it
+ * with the outside world, call drm_dp_aux_init() first. You must still
+ * call drm_dp_aux_register() once the connector has been registered to
+ * allow userspace access to the auxiliary DP channel.
  */
-int drm_dp_aux_register(struct drm_dp_aux *aux)
+void drm_dp_aux_init(struct drm_dp_aux *aux)
 {
-	int ret;
-
 	mutex_init(&aux->hw_mutex);
 
 	aux->ddc.algo = &drm_dp_i2c_algo;
@@ -809,6 +810,23 @@ int drm_dp_aux_register(struct drm_dp_aux *aux)
 	aux->ddc.lock_bus = lock_bus;
 	aux->ddc.trylock_bus = trylock_bus;
 	aux->ddc.unlock_bus = unlock_bus;
+}
+EXPORT_SYMBOL(drm_dp_aux_init);
+
+/**
+ * drm_dp_aux_register() - initialise and register aux channel
+ * @aux: DisplayPort AUX channel
+ *
+ * Automatically calls drm_dp_aux_init() if this hasn't been done yet.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_aux_register(struct drm_dp_aux *aux)
+{
+	int ret;
+
+	if (!aux->ddc.algo)
+		drm_dp_aux_init(aux);
 
 	aux->ddc.class = I2C_CLASS_DDC;
 	aux->ddc.owner = THIS_MODULE;

commit 0c2f6f1a561136a09c5de91889d0aa35e13f73d4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 17 09:33:17 2016 +0100

    drm: Pass the drm_dp_aux->hw_mutex to i2c for its locking
    
    Rather than have both drm_dp_aux lock within its transfer, and i2c to
    lock around the transfer, use the same lock by filling in the locking
    callbacks that i2c wants to use. We require our own hw_mutex as we
    bypass i2c_transfer for drm_dp_dpcd_access().
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Rafael Antognolli <rafael.antognolli@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466152398-20157-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index eeaf5a7c3aa7..4b088afa21b2 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -708,8 +708,6 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 
 	memset(&msg, 0, sizeof(msg));
 
-	mutex_lock(&aux->hw_mutex);
-
 	for (i = 0; i < num; i++) {
 		msg.address = msgs[i].addr;
 		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
@@ -764,8 +762,6 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 	msg.size = 0;
 	(void)drm_dp_i2c_do_msg(aux, &msg);
 
-	mutex_unlock(&aux->hw_mutex);
-
 	return err;
 }
 
@@ -774,6 +770,26 @@ static const struct i2c_algorithm drm_dp_i2c_algo = {
 	.master_xfer = drm_dp_i2c_xfer,
 };
 
+static struct drm_dp_aux *i2c_to_aux(struct i2c_adapter *i2c)
+{
+	return container_of(i2c, struct drm_dp_aux, ddc);
+}
+
+static void lock_bus(struct i2c_adapter *i2c, unsigned int flags)
+{
+	mutex_lock(&i2c_to_aux(i2c)->hw_mutex);
+}
+
+static int trylock_bus(struct i2c_adapter *i2c, unsigned int flags)
+{
+	return mutex_trylock(&i2c_to_aux(i2c)->hw_mutex);
+}
+
+static void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)
+{
+	mutex_unlock(&i2c_to_aux(i2c)->hw_mutex);
+}
+
 /**
  * drm_dp_aux_register() - initialise and register aux channel
  * @aux: DisplayPort AUX channel
@@ -790,6 +806,10 @@ int drm_dp_aux_register(struct drm_dp_aux *aux)
 	aux->ddc.algo_data = aux;
 	aux->ddc.retries = 3;
 
+	aux->ddc.lock_bus = lock_bus;
+	aux->ddc.trylock_bus = trylock_bus;
+	aux->ddc.unlock_bus = unlock_bus;
+
 	aux->ddc.class = I2C_CLASS_DDC;
 	aux->ddc.owner = THIS_MODULE;
 	aux->ddc.dev.parent = aux->dev;

commit f808f63372cc47119f81d94ec92f9d1b4e21c562
Author: Lyude <cpaul@redhat.com>
Date:   Fri Apr 15 10:25:35 2016 -0400

    drm/dp_helper: Perform throw-away read before actual read in drm_dp_dpcd_read()
    
    This is part of a patch series to migrate all of the workarounds for
    commonly seen behavior from bad sinks in intel_dp_dpcd_read_wake() to drm's
    DP helper.
    
    Some sinks will just return garbage for the first aux tranaction they
    receive when coming out of sleep mode, so we need to perform an additional
    read before the actual read to workaround this.
    
                                Changes since v5
    - If the throwaway read in drm_dp_dpcd_read() fails, return the error
      from that instead of continuing. This follows the same logic we do in
      drm_dp_dpcd_access() (e.g. the error from the first transaction may
      differ from the errors that proceeding attempts might return).
    
    Signed-off-by: Lyude <cpaul@redhat.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460730335-5012-1-git-send-email-cpaul@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 540c3e43a8ea..eeaf5a7c3aa7 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -248,6 +248,25 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
 			 void *buffer, size_t size)
 {
+	int ret;
+
+	/*
+	 * HP ZR24w corrupts the first DPCD access after entering power save
+	 * mode. Eg. on a read, the entire buffer will be filled with the same
+	 * byte. Do a throw away read to avoid corrupting anything we care
+	 * about. Afterwards things will work correctly until the monitor
+	 * gets woken up and subsequently re-enters power save mode.
+	 *
+	 * The user pressing any button on the monitor is enough to wake it
+	 * up, so there is no particularly good place to do the workaround.
+	 * We just have to do it before any DPCD access and hope that the
+	 * monitor doesn't power down exactly after the throw away read.
+	 */
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV, buffer,
+				 1);
+	if (ret != 1)
+		return ret;
+
 	return drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,
 				  size);
 }

commit 82922da39190199260a726d7081a8ea4873e5fd6
Author: Lyude <cpaul@redhat.com>
Date:   Wed Apr 13 10:58:31 2016 -0400

    drm/dp_helper: Retry aux transactions on all errors
    
    This is part of a patch series to migrate all of the workarounds for
    commonly seen behavior from bad sinks in intel_dp_dpcd_read_wake() to
    drm's DP helper.
    
    We cannot rely on sinks NACKing or deferring when they can't receive
    transactions, nor can we rely on any other sort of consistent error to
    know when we should stop retrying. As such, we need to just retry
    unconditionally on errors. We also make sure here to return the error we
    encountered during the first transaction, since it's possible that
    retrying the transaction might return a different error then we had
    originally.
    
    This, along with the previous patch, work around a weird bug with the
    ThinkPad T560's and it's dock. When resuming the laptop, it appears that
    there's a short period of time where we're unable to complete any aux
    transactions, as they all immediately timeout. The only machine I'm able
    to reproduce this on is the T560 as other production Skylake models seem
    to be fine. The period during which AUX transactions fail appears to be
    around 22ms long. AFAIK, the dock for the T560 never actually turns off,
    the only difference is that it's in SST mode at the start of the resume
    process, so it's unclear as to why it would need so much time to come
    back up.
    
    There's been a discussion on this issue going on for a while on the
    intel-gfx mailing list about this that has, in addition to including
    developers from Intel, also had the correspondence of one of the
    hardware engineers for Intel:
    
    http://www.spinics.net/lists/intel-gfx/msg88831.html
    http://www.spinics.net/lists/intel-gfx/msg88410.html
    
    We've already looked into a couple of possible explanations for the
    problem:
    
    - Calling intel_dp_mst_resume() before right fix.
      intel_runtime_pm_enable_interrupts(). This was the first fix I tried,
      and while it worked it definitely wasn't the right fix. This worked
      because DP aux transactions don't actually require interrupts to work:
    
            static uint32_t
            intel_dp_aux_wait_done(struct intel_dp *intel_dp, bool has_aux_irq)
            {
                    struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
                    struct drm_device *dev = intel_dig_port->base.base.dev;
                    struct drm_i915_private *dev_priv = dev->dev_private;
                    i915_reg_t ch_ctl = intel_dp->aux_ch_ctl_reg;
                    uint32_t status;
                    bool done;
    
            #define C (((status = I915_READ_NOTRACE(ch_ctl)) & DP_AUX_CH_CTL_SEND_BUSY) == 0)
                    if (has_aux_irq)
                            done = wait_event_timeout(dev_priv->gmbus_wait_queue, C,
                                                      msecs_to_jiffies_timeout(10));
                    else
                            done = wait_for_atomic(C, 10) == 0;
                    if (!done)
                            DRM_ERROR("dp aux hw did not signal timeout (has irq: %i)!\n",
                                      has_aux_irq);
            #undef C
    
                    return status;
            }
    
      When there's no interrupts enabled, we end up timing out on the
      wait_event_timeout() call, which causes us to check the DP status
      register once to see if the transaction was successful or not. Since
      this adds a 10ms delay to each aux transaction, it ends up adding a
      long enough delay to the resume process for aux transactions to become
      functional again. This gave us the illusion that enabling interrupts
      had something to do with making things work again, and put me on the
      wrong track for a while.
    
    - Interrupts occurring when we try to perform the aux transactions
      required to put the dock back into MST mode. This isn't the problem,
      as the only interrupts I've observed that come during this timeout
      period are from the snd_hda_intel driver, and disabling that driver
      doesn't appear to change the behavior at all.
    
    - Skylake's PSR block causing issues by performing aux transactions
      while we try to bring the dock out of MST mode. Disabling PSR through
      i915's command line options doesn't seem to change the behavior
      either, nor does preventing the DMC firmware from being loaded.
    
    Since this investigation went on for about 2 weeks, we decided it would
    be better for the time being to just workaround this issue by making
    sure AUX transactions wait a short period of time before retrying.
    
    Signed-off-by: Lyude <cpaul@redhat.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460559513-32280-3-git-send-email-cpaul@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 7dd330ae0e81..540c3e43a8ea 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -178,8 +178,8 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 			      unsigned int offset, void *buffer, size_t size)
 {
 	struct drm_dp_aux_msg msg;
-	unsigned int retry;
-	int err = 0;
+	unsigned int retry, native_reply;
+	int err = 0, ret = 0;
 
 	memset(&msg, 0, sizeof(msg));
 	msg.address = offset;
@@ -196,37 +196,39 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	 * sufficient, bump to 32 which makes Dell 4k monitors happier.
 	 */
 	for (retry = 0; retry < 32; retry++) {
-		if (err != 0 && err != -ETIMEDOUT) {
+		if (ret != 0 && ret != -ETIMEDOUT) {
 			usleep_range(AUX_RETRY_INTERVAL,
 				     AUX_RETRY_INTERVAL + 100);
 		}
 
-		err = aux->transfer(aux, &msg);
-		if (err < 0) {
-			if (err == -EBUSY)
-				continue;
-
-			goto unlock;
-		}
+		ret = aux->transfer(aux, &msg);
 
-		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
-		case DP_AUX_NATIVE_REPLY_ACK:
-			if (err < size)
-				err = -EPROTO;
-			goto unlock;
+		if (ret > 0) {
+			native_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;
+			if (native_reply == DP_AUX_NATIVE_REPLY_ACK) {
+				if (ret == size)
+					goto unlock;
 
-		case DP_AUX_NATIVE_REPLY_NACK:
-			err = -EIO;
-			goto unlock;
+				ret = -EPROTO;
+			} else
+				ret = -EIO;
 		}
+
+		/*
+		 * We want the error we return to be the error we received on
+		 * the first transaction, since we may get a different error the
+		 * next time we retry
+		 */
+		if (!err)
+			err = ret;
 	}
 
 	DRM_DEBUG_KMS("too many retries, giving up\n");
-	err = -EIO;
+	ret = err;
 
 unlock:
 	mutex_unlock(&aux->hw_mutex);
-	return err;
+	return ret;
 }
 
 /**

commit e1083ff35157185b01bc0a99cb19b7cbae0fc9fa
Author: Lyude <cpaul@redhat.com>
Date:   Wed Apr 13 10:58:30 2016 -0400

    drm/dp_helper: Always wait before retrying native aux transactions
    
    This is part of a patch series to migrate all of the workarounds for
    commonly seen behavior from bad sinks in intel_dp_dpcd_read_wake() to
    drm's DP helper.
    
    Some sinks need some time during the process of resuming the system from
    sleep before they're ready to handle transactions. While it would be
    nice if they responded with NACKs in these scenarios, this isn't always
    the case as a few sinks will just timeout on all of the transactions
    they receive until they're ready.
    
    Signed-off-by: Lyude <cpaul@redhat.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460559513-32280-2-git-send-email-cpaul@redhat.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index df64ed1c0139..7dd330ae0e81 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -196,6 +196,10 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	 * sufficient, bump to 32 which makes Dell 4k monitors happier.
 	 */
 	for (retry = 0; retry < 32; retry++) {
+		if (err != 0 && err != -ETIMEDOUT) {
+			usleep_range(AUX_RETRY_INTERVAL,
+				     AUX_RETRY_INTERVAL + 100);
+		}
 
 		err = aux->transfer(aux, &msg);
 		if (err < 0) {
@@ -205,7 +209,6 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 			goto unlock;
 		}
 
-
 		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
 		case DP_AUX_NATIVE_REPLY_ACK:
 			if (err < size)
@@ -215,10 +218,6 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 		case DP_AUX_NATIVE_REPLY_NACK:
 			err = -EIO;
 			goto unlock;
-
-		case DP_AUX_NATIVE_REPLY_DEFER:
-			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
-			break;
 		}
 	}
 

commit 7779c5e23c5132c22a219f1f5554ef81dd15ee91
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Feb 25 16:15:05 2016 -0500

    drm/dp: move hw_mutex up the call stack
    
    1) don't let other threads trying to bang on aux channel interrupt the
    defer timeout/logic
    2) don't let other threads interrupt the i2c over aux logic
    
    Technically, according to people who actually have the DP spec, this
    should not be required.  In practice, it makes some troublesome Dell
    monitor (and perhaps others) work, so probably a case of "It's compliant
    if it works with windows" on the hw vendor's part..
    
    v2: rebased to come before DPCD/AUX logging patch for easier backport
    to stable branches.
    
    Reported-by: Dave Wysochanski <dwysocha@redhat.com>
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1274157
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 7d58f594cffe..df64ed1c0139 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -179,7 +179,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 {
 	struct drm_dp_aux_msg msg;
 	unsigned int retry;
-	int err;
+	int err = 0;
 
 	memset(&msg, 0, sizeof(msg));
 	msg.address = offset;
@@ -187,6 +187,8 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	msg.buffer = buffer;
 	msg.size = size;
 
+	mutex_lock(&aux->hw_mutex);
+
 	/*
 	 * The specification doesn't give any recommendation on how often to
 	 * retry native transactions. We used to retry 7 times like for
@@ -195,25 +197,24 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	 */
 	for (retry = 0; retry < 32; retry++) {
 
-		mutex_lock(&aux->hw_mutex);
 		err = aux->transfer(aux, &msg);
-		mutex_unlock(&aux->hw_mutex);
 		if (err < 0) {
 			if (err == -EBUSY)
 				continue;
 
-			return err;
+			goto unlock;
 		}
 
 
 		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
 		case DP_AUX_NATIVE_REPLY_ACK:
 			if (err < size)
-				return -EPROTO;
-			return err;
+				err = -EPROTO;
+			goto unlock;
 
 		case DP_AUX_NATIVE_REPLY_NACK:
-			return -EIO;
+			err = -EIO;
+			goto unlock;
 
 		case DP_AUX_NATIVE_REPLY_DEFER:
 			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
@@ -222,7 +223,11 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	}
 
 	DRM_DEBUG_KMS("too many retries, giving up\n");
-	return -EIO;
+	err = -EIO;
+
+unlock:
+	mutex_unlock(&aux->hw_mutex);
+	return err;
 }
 
 /**
@@ -544,9 +549,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	int max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));
 
 	for (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {
-		mutex_lock(&aux->hw_mutex);
 		ret = aux->transfer(aux, msg);
-		mutex_unlock(&aux->hw_mutex);
 		if (ret < 0) {
 			if (ret == -EBUSY)
 				continue;
@@ -685,6 +688,8 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 
 	memset(&msg, 0, sizeof(msg));
 
+	mutex_lock(&aux->hw_mutex);
+
 	for (i = 0; i < num; i++) {
 		msg.address = msgs[i].addr;
 		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
@@ -739,6 +744,8 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 	msg.size = 0;
 	(void)drm_dp_i2c_do_msg(aux, &msg);
 
+	mutex_unlock(&aux->hw_mutex);
+
 	return err;
 }
 

commit e94cb37b34eb8a88fe847438dba55c3f18bf024a
Author: Rafael Antognolli <rafael.antognolli@intel.com>
Date:   Thu Jan 21 15:10:19 2016 -0800

    drm/dp: Add a drm_aux-dev module for reading/writing dpcd registers.
    
    This module is heavily based on i2c-dev. Once loaded, it provides one
    dev node per DP AUX channel, named drm_dp_auxN, where N is an integer.
    
    It's possible to know which connector owns this aux channel by looking
    at the respective sysfs /sys/class/drm_aux_dev/drm_dp_auxN/connector, if
    the connector device pointer was correctly set in the aux helper struct.
    
    Two main operations are provided on the registers read and write. The
    address of the register to be read or written is given using lseek. The
    seek position is updated upon read or write.
    
    v2:
     - lseek is used to select the register to read/write
     - read/write are used instead of ioctl
     - no blocking_notifier is used, just a direct callback
    
    v3:
     - use drm_dp_aux_dev prefix for public functions
     - chardev is named drm_dp_auxN
     - read/write don't allocate a buffer anymore, and transfer up to 16 bytes a
       time
     - remove notifier list from the implementation
     - option on menuconfig is now a boolean
     - add inline stub functions to avoid breakage when this option is disabled
    
    v4:
     - fix build system changes - actually disable this module when not selected.
    
    v5:
     - Use kref to avoid device closing while still in use
     - Don't use list, use an idr for storing aux_dev
     - Remove "connector" attribute
     - set aux.dev to the connector drm_connector device, instead of
       drm_device
    
    v6:
     - Use atomic_t for usage count
     - Use a mutex instead of spinlock for idr lock
     - Destroy chardev immediately on unregister
     - other minor suggestions from Ville
    
    v7:
     - style fixes
     - error handling fixes
    
    v8:
     - more error handling fixes
    
    v9:
     - remove module_init and module_exit, and add drm_dp_aux_dev_init/exit
     to drm_kms_helper_init/exit.
    
    Signed-off-by: Rafael Antognolli <rafael.antognolli@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453417821-2811-3-git-send-email-rafael.antognolli@intel.com

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 9535c5b60387..7d58f594cffe 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -28,6 +28,7 @@
 #include <linux/sched.h>
 #include <linux/i2c.h>
 #include <drm/drm_dp_helper.h>
+#include <drm/drm_dp_aux_dev.h>
 #include <drm/drmP.h>
 
 /**
@@ -754,6 +755,8 @@ static const struct i2c_algorithm drm_dp_i2c_algo = {
  */
 int drm_dp_aux_register(struct drm_dp_aux *aux)
 {
+	int ret;
+
 	mutex_init(&aux->hw_mutex);
 
 	aux->ddc.algo = &drm_dp_i2c_algo;
@@ -768,7 +771,17 @@ int drm_dp_aux_register(struct drm_dp_aux *aux)
 	strlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),
 		sizeof(aux->ddc.name));
 
-	return i2c_add_adapter(&aux->ddc);
+	ret = drm_dp_aux_register_devnode(aux);
+	if (ret)
+		return ret;
+
+	ret = i2c_add_adapter(&aux->ddc);
+	if (ret) {
+		drm_dp_aux_unregister_devnode(aux);
+		return ret;
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL(drm_dp_aux_register);
 
@@ -778,6 +791,7 @@ EXPORT_SYMBOL(drm_dp_aux_register);
  */
 void drm_dp_aux_unregister(struct drm_dp_aux *aux)
 {
+	drm_dp_aux_unregister_devnode(aux);
 	i2c_del_adapter(&aux->ddc);
 }
 EXPORT_SYMBOL(drm_dp_aux_unregister);

commit 646db260b843d2f758559a5483174354c304acf8
Merge: a645654b817f 1f93e4a96c91
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 22 11:02:18 2015 +0200

    Merge tag 'v4.3-rc2' into topic/drm-misc
    
    Backmerge Linux 4.3-rc2 because of conflicts in the dp helper code
    between bugfixes and new code. Just adjacent lines really.
    
    On top of that there's a silent conflict in the new fsl-dcu driver
    merged into 4.3 and
    
    commit 844f9111f6f54f88eb2f0fac121b82ce77193866
    Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Date:   Wed Sep 2 10:42:40 2015 +0200
    
        drm/atomic: Make prepare_fb/cleanup_fb only take state, v3.
    
    which Thierry Reding spotted and provided a fixup for.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 68ec2a2a24815c0ee359b1327b60a276cd2280d8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Aug 27 17:23:30 2015 +0300

    drm/dp: Use I2C_WRITE_STATUS_UPDATE to drain partial I2C_WRITE requests
    
    When an i2c WRITE gets an i2c defer or short i2c ack reply, we are
    supposed to switch the request from I2C_WRITE to I2C_WRITE_STATUS_UPDATE
    when we continue to poll for the completion of the request.
    
    v2: Don't assume DP_AUX_I2C_WRITE is 0 even though it is, to make the
        code more obvious to the casual reader (Jani)
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: Resolve conflict due to changed context.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 80a02a412607..5a55d905b8ee 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -422,6 +422,19 @@ static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
 	       I2C_FUNC_10BIT_ADDR;
 }
 
+static void drm_dp_i2c_msg_write_status_update(struct drm_dp_aux_msg *msg)
+{
+	/*
+	 * In case of i2c defer or short i2c ack reply to a write,
+	 * we need to switch to WRITE_STATUS_UPDATE to drain the
+	 * rest of the message
+	 */
+	if ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE) {
+		msg->request &= DP_AUX_I2C_MOT;
+		msg->request |= DP_AUX_I2C_WRITE_STATUS_UPDATE;
+	}
+}
+
 /*
  * Transfer a single I2C-over-AUX message and handle various error conditions,
  * retrying the transaction as appropriate.  It is assumed that the
@@ -490,6 +503,8 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			 * Both native ACK and I2C ACK replies received. We
 			 * can assume the transfer was successful.
 			 */
+			if (ret != msg->size)
+				drm_dp_i2c_msg_write_status_update(msg);
 			return ret;
 
 		case DP_AUX_I2C_REPLY_NACK:
@@ -507,6 +522,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			if (defer_i2c < 7)
 				defer_i2c++;
 			usleep_range(400, 500);
+			drm_dp_i2c_msg_write_status_update(msg);
 			continue;
 
 		default:
@@ -519,6 +535,14 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	return -EREMOTEIO;
 }
 
+static void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,
+				       const struct i2c_msg *i2c_msg)
+{
+	msg->request = (i2c_msg->flags & I2C_M_RD) ?
+		DP_AUX_I2C_READ : DP_AUX_I2C_WRITE;
+	msg->request |= DP_AUX_I2C_MOT;
+}
+
 /*
  * Keep retrying drm_dp_i2c_do_msg until all data has been transferred.
  *
@@ -572,10 +596,7 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 
 	for (i = 0; i < num; i++) {
 		msg.address = msgs[i].addr;
-		msg.request = (msgs[i].flags & I2C_M_RD) ?
-			DP_AUX_I2C_READ :
-			DP_AUX_I2C_WRITE;
-		msg.request |= DP_AUX_I2C_MOT;
+		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
 		/* Send a bare address packet to start the transaction.
 		 * Zero sized messages specify an address only (bare
 		 * address) transaction.
@@ -583,6 +604,13 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 		msg.buffer = NULL;
 		msg.size = 0;
 		err = drm_dp_i2c_do_msg(aux, &msg);
+
+		/*
+		 * Reset msg.request in case in case it got
+		 * changed into a WRITE_STATUS_UPDATE.
+		 */
+		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
+
 		if (err < 0)
 			break;
 		/* We want each transaction to be as large as possible, but
@@ -595,6 +623,13 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 			msg.size = min(transfer_size, msgs[i].len - j);
 
 			err = drm_dp_i2c_drain_msg(aux, &msg);
+
+			/*
+			 * Reset msg.request in case in case it got
+			 * changed into a WRITE_STATUS_UPDATE.
+			 */
+			drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
+
 			if (err < 0)
 				break;
 			transfer_size = err;

commit f36203be608a38a5b5523a7aa52cc72f757b9679
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Aug 26 22:55:07 2015 +0300

    drm/dp: Add dp_aux_i2c_speed_khz module param to set the assume i2c bus speed
    
    To help with debugging i2c-over-aux issues, add a module parameter than
    can be used to tweak the assumed i2c bus speed, and thus the maximum
    number of retries we will do for each aux message.
    
    Cc: Simon Farnsworth <simon.farnsworth@onelan.com>
    Cc: moosotc@gmail.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Simon Farnsworth <simon.farnsworth@onelan.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 214a4c649d56..291734e87fca 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -499,6 +499,15 @@ static int drm_dp_i2c_retry_count(const struct drm_dp_aux_msg *msg,
 	return DIV_ROUND_UP(i2c_time_us, aux_time_us + AUX_RETRY_INTERVAL);
 }
 
+/*
+ * FIXME currently assumes 10 kHz as some real world devices seem
+ * to require it. We should query/set the speed via DPCD if supported.
+ */
+static int dp_aux_i2c_speed_khz __read_mostly = 10;
+module_param_unsafe(dp_aux_i2c_speed_khz, int, 0644);
+MODULE_PARM_DESC(dp_aux_i2c_speed_khz,
+		 "Assumed speed of the i2c bus in kHz, (1-400, default 10)");
+
 /*
  * Transfer a single I2C-over-AUX message and handle various error conditions,
  * retrying the transaction as appropriate.  It is assumed that the
@@ -517,10 +526,8 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	 * before giving up the AUX transaction.
 	 *
 	 * We also try to account for the i2c bus speed.
-	 * FIXME currently assumes 10 kHz as some real world devices seem
-	 * to require it. We should query/set the speed via DPCD if supported.
 	 */
-	int max_retries = max(7, drm_dp_i2c_retry_count(msg, 10));
+	int max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));
 
 	for (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {
 		mutex_lock(&aux->hw_mutex);

commit 4efa83c8c786ab7ec7982e3dd348cb7e7ecbeb04
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Sep 1 20:12:54 2015 +0300

    drm/dp: Adjust i2c-over-aux retry count based on message size and i2c bus speed
    
    Calculate the number of retries we should do for each i2c-over-aux
    message based on the time it takes to perform the i2c transfer vs. the
    aux transfer. We assume the shortest possible length for the aux
    transfer, and the longest possible (exluding clock stretching) for the
    i2c transfer.
    
    The DP spec has some examples on how to calculate this, but we don't
    calculate things quite the same way. The spec doesn't account for the
    retry interval (assumes immediate retry on defer), and doesn't assume
    the best/worst case behaviour as we do.
    
    Note that currently we assume 10 kHz speed for the i2c bus. Some real
    world devices (eg. some Apple DP->VGA dongle) fails with less than 16
    retries. and that would correspond to something close to 15 kHz (with
    our method of calculating things) But let's just go for 10 kHz to be
    on the safe side. Ideally we should query/set the i2c bus speed via
    DPCD but for now this should at leaast remove the regression from the
    1->16 byte trasnfer size change. And of course if the sink completes
    the transfer quicker this shouldn't slow things down since we don't
    change the interval between retries.
    
    I did a few experiments with a DP->DVI dongle I have that allows you
    to change the i2c bus speed. Here are the results of me changing the
    actual bus speed and the assumed bus speed and seeing when we start
    to fail the operation:
    
    actual i2c khz          assumed i2c khz         max retries
    1                       1 ok -> 2 fail          211 ok -> 106 fail
    5                       8 ok -> 9 fail          27 ok -> 24 fail
    10                      17 ok -> 18 fail        13 ok -> 12 fail
    100                     210 ok -> 211 fail      2 ok -> 1 fail
    
    So based on that we have a fairly decent safety margin baked into
    the formula to calculate the max number of retries.
    
    Fixes a regression with some DP dongles from:
    commit 1d002fa720738bcd0bddb9178e9ea0773288e1dd
    Author: Simon Farnsworth <simon.farnsworth@onelan.co.uk>
    Date:   Tue Feb 10 18:38:08 2015 +0000
    
        drm/dp: Use large transactions for I2C over AUX
    
    v2: Use best case for AUX and worst case for i2c (Simon Farnsworth)
        Add a define our AUX retry interval and account for it
    v3: Make everything usecs to avoid confusion about units (Daniel)
        Add a comment reminding people about the AUX bitrate (Daniel)
        Use DIV_ROUND_UP() since we're after the "worst" case for i2c
    
    Cc: Simon Farnsworth <simon.farnsworth@onelan.com>
    Cc: moosotc@gmail.com
    Tested-by: moosotc@gmail.com
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91451
    Reviewed-by: Simon Farnsworth <simon.farnsworth@onelan.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 7069e54e5b43..214a4c649d56 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -424,6 +424,81 @@ static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
 	       I2C_FUNC_10BIT_ADDR;
 }
 
+#define AUX_PRECHARGE_LEN 10 /* 10 to 16 */
+#define AUX_SYNC_LEN (16 + 4) /* preamble + AUX_SYNC_END */
+#define AUX_STOP_LEN 4
+#define AUX_CMD_LEN 4
+#define AUX_ADDRESS_LEN 20
+#define AUX_REPLY_PAD_LEN 4
+#define AUX_LENGTH_LEN 8
+
+/*
+ * Calculate the duration of the AUX request/reply in usec. Gives the
+ * "best" case estimate, ie. successful while as short as possible.
+ */
+static int drm_dp_aux_req_duration(const struct drm_dp_aux_msg *msg)
+{
+	int len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +
+		AUX_CMD_LEN + AUX_ADDRESS_LEN + AUX_LENGTH_LEN;
+
+	if ((msg->request & DP_AUX_I2C_READ) == 0)
+		len += msg->size * 8;
+
+	return len;
+}
+
+static int drm_dp_aux_reply_duration(const struct drm_dp_aux_msg *msg)
+{
+	int len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +
+		AUX_CMD_LEN + AUX_REPLY_PAD_LEN;
+
+	/*
+	 * For read we expect what was asked. For writes there will
+	 * be 0 or 1 data bytes. Assume 0 for the "best" case.
+	 */
+	if (msg->request & DP_AUX_I2C_READ)
+		len += msg->size * 8;
+
+	return len;
+}
+
+#define I2C_START_LEN 1
+#define I2C_STOP_LEN 1
+#define I2C_ADDR_LEN 9 /* ADDRESS + R/W + ACK/NACK */
+#define I2C_DATA_LEN 9 /* DATA + ACK/NACK */
+
+/*
+ * Calculate the length of the i2c transfer in usec, assuming
+ * the i2c bus speed is as specified. Gives the the "worst"
+ * case estimate, ie. successful while as long as possible.
+ * Doesn't account the the "MOT" bit, and instead assumes each
+ * message includes a START, ADDRESS and STOP. Neither does it
+ * account for additional random variables such as clock stretching.
+ */
+static int drm_dp_i2c_msg_duration(const struct drm_dp_aux_msg *msg,
+				   int i2c_speed_khz)
+{
+	/* AUX bitrate is 1MHz, i2c bitrate as specified */
+	return DIV_ROUND_UP((I2C_START_LEN + I2C_ADDR_LEN +
+			     msg->size * I2C_DATA_LEN +
+			     I2C_STOP_LEN) * 1000, i2c_speed_khz);
+}
+
+/*
+ * Deterine how many retries should be attempted to successfully transfer
+ * the specified message, based on the estimated durations of the
+ * i2c and AUX transfers.
+ */
+static int drm_dp_i2c_retry_count(const struct drm_dp_aux_msg *msg,
+			      int i2c_speed_khz)
+{
+	int aux_time_us = drm_dp_aux_req_duration(msg) +
+		drm_dp_aux_reply_duration(msg);
+	int i2c_time_us = drm_dp_i2c_msg_duration(msg, i2c_speed_khz);
+
+	return DIV_ROUND_UP(i2c_time_us, aux_time_us + AUX_RETRY_INTERVAL);
+}
+
 /*
  * Transfer a single I2C-over-AUX message and handle various error conditions,
  * retrying the transaction as appropriate.  It is assumed that the
@@ -436,13 +511,18 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 {
 	unsigned int retry, defer_i2c;
 	int ret;
-
 	/*
 	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device
 	 * is required to retry at least seven times upon receiving AUX_DEFER
 	 * before giving up the AUX transaction.
+	 *
+	 * We also try to account for the i2c bus speed.
+	 * FIXME currently assumes 10 kHz as some real world devices seem
+	 * to require it. We should query/set the speed via DPCD if supported.
 	 */
-	for (retry = 0, defer_i2c = 0; retry < (7 + defer_i2c); retry++) {
+	int max_retries = max(7, drm_dp_i2c_retry_count(msg, 10));
+
+	for (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {
 		mutex_lock(&aux->hw_mutex);
 		ret = aux->transfer(aux, msg);
 		mutex_unlock(&aux->hw_mutex);

commit 79a2b161c12a1b751f53a7698494cb722530bca5
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Aug 26 22:55:05 2015 +0300

    drm/dp: Define AUX_RETRY_INTERVAL as 500 us
    
    Currently we react to native and i2c defers by waiting either 400-500 us
    or 500-600 us, depending on which code path we take. Consolidate them
    all to one define AUX_RETRY_INTERVAL which defines the minimum interval.
    Since we've been using two different intervals pick the longer of them
    and define AUX_RETRY_INTERVAL as 500 us. For the maximum just use
    AUX_RETRY_INTERVAL+100 us.
    
    I want to have a define for this so that I can use it when calculating
    the estimated duration of i2c-over-aux transfers. Without a define it
    would be very easy to change the sleep duration and neglect to update
    the i2c-over-aux estimates.
    
    Cc: Simon Farnsworth <simon.farnsworth@onelan.com>
    Cc: moosotc@gmail.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Simon Farnsworth <simon.farnsworth@onelan.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 80a02a412607..7069e54e5b43 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -159,6 +159,8 @@ int drm_dp_bw_code_to_link_rate(u8 link_bw)
 }
 EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);
 
+#define AUX_RETRY_INTERVAL 500 /* us */
+
 /**
  * DOC: dp helpers
  *
@@ -213,7 +215,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 			return -EIO;
 
 		case DP_AUX_NATIVE_REPLY_DEFER:
-			usleep_range(400, 500);
+			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
 			break;
 		}
 	}
@@ -476,7 +478,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			 * For now just defer for long enough to hopefully be
 			 * safe for all use-cases.
 			 */
-			usleep_range(500, 600);
+			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
 			continue;
 
 		default:
@@ -506,7 +508,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			aux->i2c_defer_count++;
 			if (defer_i2c < 7)
 				defer_i2c++;
-			usleep_range(400, 500);
+			usleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);
 			continue;
 
 		default:

commit 396aa4451e865d1e36d6d4e0686a9303c038b606
Author: Todd Previte <tprevite@gmail.com>
Date:   Sat Apr 18 00:04:18 2015 -0700

    drm: Fix for DP CTS test 4.2.2.5 - I2C DEFER handling
    
    For test 4.2.2.5 to pass per the Link CTS Core 1.2 rev1.1 spec, the source
    device must attempt at least 7 times to read the EDID when it receives an
    I2C defer. The normal DRM code makes only 7 retries, regardless of whether
    or not the response is a native defer or an I2C defer. Test 4.2.2.5 fails
    since there are native defers interspersed with the I2C defers which
    results in less than 7 EDID read attempts.
    
    The solution is to add the numer of defers to the retry counter when an I2C
    DEFER is returned such that another read attempt will be made. This situation
    should normally only occur in compliance testing, however, as a worse case
    real-world scenario, it would result in 13 attempts ( 6 native defers, 7 I2C
    defers) for a single transaction to complete. The net result is a slightly
    slower response to an EDID read that shouldn't significantly impact overall
    performance.
    
    V2:
    - Added a check on the number of I2C Defers to limit the number
      of times that the retries variable will be decremented. This
      is to address review feedback regarding possible infinite loops
      from misbehaving sink devices.
    V3:
    - Fixed the limit value to 7 instead of 8 to get the correct retry
      count.
    - Combined the increment of the defer count into the if-statement
    V4:
    - Removed i915 tag from subject as the patch is not i915-specific
    V5:
    - Updated the for-loop to add the number of i2c defers to the retry
      counter such that the correct number of retry attempts will be
      made
    
    Signed-off-by: Todd Previte <tprevite@gmail.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 575172ed6c32..80a02a412607 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -432,7 +432,7 @@ static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
  */
 static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 {
-	unsigned int retry;
+	unsigned int retry, defer_i2c;
 	int ret;
 
 	/*
@@ -440,7 +440,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	 * is required to retry at least seven times upon receiving AUX_DEFER
 	 * before giving up the AUX transaction.
 	 */
-	for (retry = 0; retry < 7; retry++) {
+	for (retry = 0, defer_i2c = 0; retry < (7 + defer_i2c); retry++) {
 		mutex_lock(&aux->hw_mutex);
 		ret = aux->transfer(aux, msg);
 		mutex_unlock(&aux->hw_mutex);
@@ -499,7 +499,13 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 
 		case DP_AUX_I2C_REPLY_DEFER:
 			DRM_DEBUG_KMS("I2C defer\n");
+			/* DP Compliance Test 4.2.2.5 Requirement:
+			 * Must have at least 7 retries for I2C defers on the
+			 * transaction to pass this test
+			 */
 			aux->i2c_defer_count++;
+			if (defer_i2c < 7)
+				defer_i2c++;
 			usleep_range(400, 500);
 			continue;
 

commit 747552b947e1013276851b6a19a9867a94ff1c4f
Author: Todd Previte <tprevite@gmail.com>
Date:   Wed Apr 15 08:38:47 2015 -0700

    drm: Fix the 'native defer' message in drm_dp_i2c_do_msg()
    
    The debug message is missing a newline at the end and it makes the
    logs hard to read when a device defers a lot. Simple 2-character fix
    adds the newline at the end.
    
    Signed-off-by: Todd Previte <tprevite@gmail.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 71dcbc64ae98..575172ed6c32 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -466,7 +466,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			return -EREMOTEIO;
 
 		case DP_AUX_NATIVE_REPLY_DEFER:
-			DRM_DEBUG_KMS("native defer");
+			DRM_DEBUG_KMS("native defer\n");
 			/*
 			 * We could check for I2C bit rate capabilities and if
 			 * available adjust this interval. We could also be

commit fb8c5e49887e21817fa2b63d296c378b847bb500
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Mar 19 13:38:57 2015 +0200

    drm/dp: Print the number of bytes processed for aux nacks
    
    When doing a native or i2c aux write the sink will indicate the number
    of bytes written even if it the nacks the transfer. When we receive a
    nack we just return an error upwards, but it might still be interesting
    to see how many bytes made it before the nack. So include that information
    in the debug messages.
    
    v2: Also print the message size (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index d5368ea56a0f..71dcbc64ae98 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -462,7 +462,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			break;
 
 		case DP_AUX_NATIVE_REPLY_NACK:
-			DRM_DEBUG_KMS("native nack\n");
+			DRM_DEBUG_KMS("native nack (result=%d, size=%zu)\n", ret, msg->size);
 			return -EREMOTEIO;
 
 		case DP_AUX_NATIVE_REPLY_DEFER:
@@ -493,7 +493,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			return ret;
 
 		case DP_AUX_I2C_REPLY_NACK:
-			DRM_DEBUG_KMS("I2C nack\n");
+			DRM_DEBUG_KMS("I2C nack (result=%d, size=%zu\n", ret, msg->size);
 			aux->i2c_nack_count++;
 			return -EREMOTEIO;
 

commit 1d002fa720738bcd0bddb9178e9ea0773288e1dd
Author: Simon Farnsworth <simon.farnsworth@onelan.co.uk>
Date:   Tue Feb 10 18:38:08 2015 +0000

    drm/dp: Use large transactions for I2C over AUX
    
    Older DisplayPort to DVI-D Dual Link adapters designed by Bizlink have bugs
    in their I2C over AUX implementation (fixed in newer revisions). They work
    fine with Windows, but fail with Linux.
    
    It turns out that they cannot keep an I2C transaction open unless the
    previous read was 16 bytes; shorter reads can only be followed by a zero
    byte transfer ending the I2C transaction.
    
    Copy Windows's behaviour, and read 16 bytes at a time. If we get a short
    reply, assume that there's a hardware bottleneck, and shrink our read size
    to match. For this purpose, use the algorithm in the DisplayPort 1.2 spec,
    in the hopes that it'll be closest to what Windows does.
    
    Also provide an unsafe module parameter for testing smaller transfer sizes,
    in case there are sinks out there that cannot work with Windows.
    
    Note also that despite the previous comment in drm_dp_i2c_xfer, this speeds
    up native DP EDID reads; Ville Syrjälä <ville.syrjala@linux.intel.com> found
    the following changes in his testing:
    
    Device under test:     old  -> with this patch
    DP->DVI (OUI 001cf8):  40ms -> 35ms
    DP->VGA (OUI 0022b9):  45ms -> 38ms
    Zotac DP->2xHDMI:      25ms ->  4ms
    Asus PB278 monitor:    22ms ->  3ms
    
    A back of the envelope calculation shows that peak theoretical transfer rate
    for 1 byte reads is around 60 kbit/s; with 16 byte reads, this increases to
    around 500 kbit/s, which explains the increase in speed.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=55228
    Tested-by: Aidan Marks <aidanamarks@gmail.com> (v3)
    Signed-off-by: Simon Farnsworth <simon.farnsworth@onelan.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f1283878ff6d..d5368ea56a0f 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -427,11 +427,13 @@ static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
  * retrying the transaction as appropriate.  It is assumed that the
  * aux->transfer function does not modify anything in the msg other than the
  * reply field.
+ *
+ * Returns bytes transferred on success, or a negative error code on failure.
  */
 static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 {
 	unsigned int retry;
-	int err;
+	int ret;
 
 	/*
 	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device
@@ -440,14 +442,14 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	 */
 	for (retry = 0; retry < 7; retry++) {
 		mutex_lock(&aux->hw_mutex);
-		err = aux->transfer(aux, msg);
+		ret = aux->transfer(aux, msg);
 		mutex_unlock(&aux->hw_mutex);
-		if (err < 0) {
-			if (err == -EBUSY)
+		if (ret < 0) {
+			if (ret == -EBUSY)
 				continue;
 
-			DRM_DEBUG_KMS("transaction failed: %d\n", err);
-			return err;
+			DRM_DEBUG_KMS("transaction failed: %d\n", ret);
+			return ret;
 		}
 
 
@@ -488,9 +490,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			 * Both native ACK and I2C ACK replies received. We
 			 * can assume the transfer was successful.
 			 */
-			if (err < msg->size)
-				return -EPROTO;
-			return 0;
+			return ret;
 
 		case DP_AUX_I2C_REPLY_NACK:
 			DRM_DEBUG_KMS("I2C nack\n");
@@ -513,14 +513,55 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	return -EREMOTEIO;
 }
 
+/*
+ * Keep retrying drm_dp_i2c_do_msg until all data has been transferred.
+ *
+ * Returns an error code on failure, or a recommended transfer size on success.
+ */
+static int drm_dp_i2c_drain_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *orig_msg)
+{
+	int err, ret = orig_msg->size;
+	struct drm_dp_aux_msg msg = *orig_msg;
+
+	while (msg.size > 0) {
+		err = drm_dp_i2c_do_msg(aux, &msg);
+		if (err <= 0)
+			return err == 0 ? -EPROTO : err;
+
+		if (err < msg.size && err < ret) {
+			DRM_DEBUG_KMS("Partial I2C reply: requested %zu bytes got %d bytes\n",
+				      msg.size, err);
+			ret = err;
+		}
+
+		msg.size -= err;
+		msg.buffer += err;
+	}
+
+	return ret;
+}
+
+/*
+ * Bizlink designed DP->DVI-D Dual Link adapters require the I2C over AUX
+ * packets to be as large as possible. If not, the I2C transactions never
+ * succeed. Hence the default is maximum.
+ */
+static int dp_aux_i2c_transfer_size __read_mostly = DP_AUX_MAX_PAYLOAD_BYTES;
+module_param_unsafe(dp_aux_i2c_transfer_size, int, 0644);
+MODULE_PARM_DESC(dp_aux_i2c_transfer_size,
+		 "Number of bytes to transfer in a single I2C over DP AUX CH message, (1-16, default 16)");
+
 static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 			   int num)
 {
 	struct drm_dp_aux *aux = adapter->algo_data;
 	unsigned int i, j;
+	unsigned transfer_size;
 	struct drm_dp_aux_msg msg;
 	int err = 0;
 
+	dp_aux_i2c_transfer_size = clamp(dp_aux_i2c_transfer_size, 1, DP_AUX_MAX_PAYLOAD_BYTES);
+
 	memset(&msg, 0, sizeof(msg));
 
 	for (i = 0; i < num; i++) {
@@ -538,20 +579,19 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 		err = drm_dp_i2c_do_msg(aux, &msg);
 		if (err < 0)
 			break;
-		/*
-		 * Many hardware implementations support FIFOs larger than a
-		 * single byte, but it has been empirically determined that
-		 * transferring data in larger chunks can actually lead to
-		 * decreased performance. Therefore each message is simply
-		 * transferred byte-by-byte.
+		/* We want each transaction to be as large as possible, but
+		 * we'll go to smaller sizes if the hardware gives us a
+		 * short reply.
 		 */
-		for (j = 0; j < msgs[i].len; j++) {
+		transfer_size = dp_aux_i2c_transfer_size;
+		for (j = 0; j < msgs[i].len; j += msg.size) {
 			msg.buffer = msgs[i].buf + j;
-			msg.size = 1;
+			msg.size = min(transfer_size, msgs[i].len - j);
 
-			err = drm_dp_i2c_do_msg(aux, &msg);
+			err = drm_dp_i2c_drain_msg(aux, &msg);
 			if (err < 0)
 				break;
+			transfer_size = err;
 		}
 		if (err < 0)
 			break;

commit d816f07736254d9e4745cff4d427404300c242ef
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Dec 2 10:43:07 2014 -0500

    drm/dp: add drm_dp_link_power_down() helper
    
    We had _power_up(), but drivers also need to be able to power down.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 79968e39c8d0..f1283878ff6d 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -353,6 +353,37 @@ int drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)
 }
 EXPORT_SYMBOL(drm_dp_link_power_up);
 
+/**
+ * drm_dp_link_power_down() - power down a DisplayPort link
+ * @aux: DisplayPort AUX channel
+ * @link: pointer to a structure containing the link configuration
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_link_power_down(struct drm_dp_aux *aux, struct drm_dp_link *link)
+{
+	u8 value;
+	int err;
+
+	/* DP_SET_POWER register is only available on DPCD v1.1 and later */
+	if (link->revision < 0x11)
+		return 0;
+
+	err = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);
+	if (err < 0)
+		return err;
+
+	value &= ~DP_SET_POWER_MASK;
+	value |= DP_SET_POWER_D3;
+
+	err = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_link_power_down);
+
 /**
  * drm_dp_link_configure() - configure a DisplayPort link
  * @aux: DisplayPort AUX channel

commit 19a93f042fc241ecdf98543cedfe7c171f8cdf53
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Nov 26 13:13:09 2014 +1000

    drm/dp: retry AUX transactions 32 times (v1.1)
    
    At least on two MST devices I've tested with, when
    they are link training downstream, they are totally
    unable to handle aux ch msgs, so they defer like nuts.
    I tried 16, it wasn't enough, 32 seems better.
    
    This fixes one Dell 4k monitor and one of the
    MST hubs.
    
    v1.1: fixup comment (Tom).
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 959e2074b0d4..79968e39c8d0 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -186,10 +186,11 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 
 	/*
 	 * The specification doesn't give any recommendation on how often to
-	 * retry native transactions, so retry 7 times like for I2C-over-AUX
-	 * transactions.
+	 * retry native transactions. We used to retry 7 times like for
+	 * aux i2c transactions but real world devices this wasn't
+	 * sufficient, bump to 32 which makes Dell 4k monitors happier.
 	 */
-	for (retry = 0; retry < 7; retry++) {
+	for (retry = 0; retry < 32; retry++) {
 
 		mutex_lock(&aux->hw_mutex);
 		err = aux->transfer(aux, &msg);

commit e9cf6194ab0cdb8f40f1eca7b230751c2289557e
Author: Todd Previte <tprevite@gmail.com>
Date:   Tue Nov 4 15:17:35 2014 -0700

    drm/dp: Add counters in the drm_dp_aux struct for I2C NACKs and DEFERs
    
    These counters are used for Displayort compliance testing to detect error
    conditions when executing tests 4.2.2.4 and 4.2.2.5 in the Displayport Link
    CTS specificaiton. They determine whether to use the preferred/requested
    mode or the failsafe mode during these tests.
    
    V2:
    - Addressed previous review feedback
    - Updated commit message
    - Changed from uint8_t to uint32_t
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Todd Previte <tprevite@gmail.com>
    [danvet: s/uint32_t/unsigned/ for clearer intent. Also drop the i915
    from the subject, it's all core stuff.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index c088bad7e72f..959e2074b0d4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -462,10 +462,12 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 
 		case DP_AUX_I2C_REPLY_NACK:
 			DRM_DEBUG_KMS("I2C nack\n");
+			aux->i2c_nack_count++;
 			return -EREMOTEIO;
 
 		case DP_AUX_I2C_REPLY_DEFER:
 			DRM_DEBUG_KMS("I2C defer\n");
+			aux->i2c_defer_count++;
 			usleep_range(400, 500);
 			continue;
 

commit e45708976aea3a3c3aa959e3cc2b703fefbd758a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 22 11:16:36 2014 +0200

    drm/dp-helper: Move the legacy helpers to gma500
    
    Except for gma500 all drivers are converted to the new style helpers,
    which have much better abstraction of the underlying hw protocols and
    already much more helper functions (including the entire mst library)
    on top of them. Since no one seems to work on converting gma500 let's
    just move the code away so that new drivers don't end up accidentally
    using this.
    
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Reviewed-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    [danvet: Add __deprecated as requested by Alan. Also add a short FIXME
    comment and drop the EXPORT_SYMBOL which is no longer needed.]
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 08e33b8b13a4..c088bad7e72f 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -39,198 +39,6 @@
  * blocks, ...
  */
 
-/* Run a single AUX_CH I2C transaction, writing/reading data as necessary */
-static int
-i2c_algo_dp_aux_transaction(struct i2c_adapter *adapter, int mode,
-			    uint8_t write_byte, uint8_t *read_byte)
-{
-	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
-	int ret;
-
-	ret = (*algo_data->aux_ch)(adapter, mode,
-				   write_byte, read_byte);
-	return ret;
-}
-
-/*
- * I2C over AUX CH
- */
-
-/*
- * Send the address. If the I2C link is running, this 'restarts'
- * the connection with the new address, this is used for doing
- * a write followed by a read (as needed for DDC)
- */
-static int
-i2c_algo_dp_aux_address(struct i2c_adapter *adapter, u16 address, bool reading)
-{
-	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
-	int mode = MODE_I2C_START;
-	int ret;
-
-	if (reading)
-		mode |= MODE_I2C_READ;
-	else
-		mode |= MODE_I2C_WRITE;
-	algo_data->address = address;
-	algo_data->running = true;
-	ret = i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);
-	return ret;
-}
-
-/*
- * Stop the I2C transaction. This closes out the link, sending
- * a bare address packet with the MOT bit turned off
- */
-static void
-i2c_algo_dp_aux_stop(struct i2c_adapter *adapter, bool reading)
-{
-	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
-	int mode = MODE_I2C_STOP;
-
-	if (reading)
-		mode |= MODE_I2C_READ;
-	else
-		mode |= MODE_I2C_WRITE;
-	if (algo_data->running) {
-		(void) i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);
-		algo_data->running = false;
-	}
-}
-
-/*
- * Write a single byte to the current I2C address, the
- * the I2C link must be running or this returns -EIO
- */
-static int
-i2c_algo_dp_aux_put_byte(struct i2c_adapter *adapter, u8 byte)
-{
-	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
-	int ret;
-
-	if (!algo_data->running)
-		return -EIO;
-
-	ret = i2c_algo_dp_aux_transaction(adapter, MODE_I2C_WRITE, byte, NULL);
-	return ret;
-}
-
-/*
- * Read a single byte from the current I2C address, the
- * I2C link must be running or this returns -EIO
- */
-static int
-i2c_algo_dp_aux_get_byte(struct i2c_adapter *adapter, u8 *byte_ret)
-{
-	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
-	int ret;
-
-	if (!algo_data->running)
-		return -EIO;
-
-	ret = i2c_algo_dp_aux_transaction(adapter, MODE_I2C_READ, 0, byte_ret);
-	return ret;
-}
-
-static int
-i2c_algo_dp_aux_xfer(struct i2c_adapter *adapter,
-		     struct i2c_msg *msgs,
-		     int num)
-{
-	int ret = 0;
-	bool reading = false;
-	int m;
-	int b;
-
-	for (m = 0; m < num; m++) {
-		u16 len = msgs[m].len;
-		u8 *buf = msgs[m].buf;
-		reading = (msgs[m].flags & I2C_M_RD) != 0;
-		ret = i2c_algo_dp_aux_address(adapter, msgs[m].addr, reading);
-		if (ret < 0)
-			break;
-		if (reading) {
-			for (b = 0; b < len; b++) {
-				ret = i2c_algo_dp_aux_get_byte(adapter, &buf[b]);
-				if (ret < 0)
-					break;
-			}
-		} else {
-			for (b = 0; b < len; b++) {
-				ret = i2c_algo_dp_aux_put_byte(adapter, buf[b]);
-				if (ret < 0)
-					break;
-			}
-		}
-		if (ret < 0)
-			break;
-	}
-	if (ret >= 0)
-		ret = num;
-	i2c_algo_dp_aux_stop(adapter, reading);
-	DRM_DEBUG_KMS("dp_aux_xfer return %d\n", ret);
-	return ret;
-}
-
-static u32
-i2c_algo_dp_aux_functionality(struct i2c_adapter *adapter)
-{
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
-	       I2C_FUNC_SMBUS_READ_BLOCK_DATA |
-	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |
-	       I2C_FUNC_10BIT_ADDR;
-}
-
-static const struct i2c_algorithm i2c_dp_aux_algo = {
-	.master_xfer	= i2c_algo_dp_aux_xfer,
-	.functionality	= i2c_algo_dp_aux_functionality,
-};
-
-static void
-i2c_dp_aux_reset_bus(struct i2c_adapter *adapter)
-{
-	(void) i2c_algo_dp_aux_address(adapter, 0, false);
-	(void) i2c_algo_dp_aux_stop(adapter, false);
-}
-
-static int
-i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
-{
-	adapter->algo = &i2c_dp_aux_algo;
-	adapter->retries = 3;
-	i2c_dp_aux_reset_bus(adapter);
-	return 0;
-}
-
-/**
- * i2c_dp_aux_add_bus() - register an i2c adapter using the aux ch helper
- * @adapter: i2c adapter to register
- *
- * This registers an i2c adapter that uses dp aux channel as it's underlaying
- * transport. The driver needs to fill out the &i2c_algo_dp_aux_data structure
- * and store it in the algo_data member of the @adapter argument. This will be
- * used by the i2c over dp aux algorithm to drive the hardware.
- *
- * RETURNS:
- * 0 on success, -ERRNO on failure.
- *
- * IMPORTANT:
- * This interface is deprecated, please switch to the new dp aux helpers and
- * drm_dp_aux_register().
- */
-int
-i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
-{
-	int error;
-
-	error = i2c_dp_aux_prepare_bus(adapter);
-	if (error)
-		return error;
-	error = i2c_add_adapter(adapter);
-	return error;
-}
-EXPORT_SYMBOL(i2c_dp_aux_add_bus);
-
 /* Helpers for DP link training */
 static u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)
 {

commit 4f71d0cb76339a10fd445b0b281acc45c71b6271
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jun 4 16:02:28 2014 +1000

    drm/dp: add a hw mutex around the transfer functions. (v2)
    
    This should avoid races between connector probing and HPD
    irqs in the future, currently mode_config.mutex blocks this
    possibility.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 494219ccdf96..08e33b8b13a4 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -216,7 +216,7 @@ i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
  *
  * IMPORTANT:
  * This interface is deprecated, please switch to the new dp aux helpers and
- * drm_dp_aux_register_i2c_bus().
+ * drm_dp_aux_register().
  */
 int
 i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
@@ -382,7 +382,10 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 	 * transactions.
 	 */
 	for (retry = 0; retry < 7; retry++) {
+
+		mutex_lock(&aux->hw_mutex);
 		err = aux->transfer(aux, &msg);
+		mutex_unlock(&aux->hw_mutex);
 		if (err < 0) {
 			if (err == -EBUSY)
 				continue;
@@ -596,7 +599,9 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 	 * before giving up the AUX transaction.
 	 */
 	for (retry = 0; retry < 7; retry++) {
+		mutex_lock(&aux->hw_mutex);
 		err = aux->transfer(aux, msg);
+		mutex_unlock(&aux->hw_mutex);
 		if (err < 0) {
 			if (err == -EBUSY)
 				continue;
@@ -729,13 +734,15 @@ static const struct i2c_algorithm drm_dp_i2c_algo = {
 };
 
 /**
- * drm_dp_aux_register_i2c_bus() - register an I2C adapter for I2C-over-AUX
+ * drm_dp_aux_register() - initialise and register aux channel
  * @aux: DisplayPort AUX channel
  *
  * Returns 0 on success or a negative error code on failure.
  */
-int drm_dp_aux_register_i2c_bus(struct drm_dp_aux *aux)
+int drm_dp_aux_register(struct drm_dp_aux *aux)
 {
+	mutex_init(&aux->hw_mutex);
+
 	aux->ddc.algo = &drm_dp_i2c_algo;
 	aux->ddc.algo_data = aux;
 	aux->ddc.retries = 3;
@@ -750,14 +757,14 @@ int drm_dp_aux_register_i2c_bus(struct drm_dp_aux *aux)
 
 	return i2c_add_adapter(&aux->ddc);
 }
-EXPORT_SYMBOL(drm_dp_aux_register_i2c_bus);
+EXPORT_SYMBOL(drm_dp_aux_register);
 
 /**
- * drm_dp_aux_unregister_i2c_bus() - unregister an I2C-over-AUX adapter
+ * drm_dp_aux_unregister() - unregister an AUX adapter
  * @aux: DisplayPort AUX channel
  */
-void drm_dp_aux_unregister_i2c_bus(struct drm_dp_aux *aux)
+void drm_dp_aux_unregister(struct drm_dp_aux *aux)
 {
 	i2c_del_adapter(&aux->ddc);
 }
-EXPORT_SYMBOL(drm_dp_aux_unregister_i2c_bus);
+EXPORT_SYMBOL(drm_dp_aux_unregister);

commit 2a8dc638f7af27ced60728e105752840fcd1538a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 7 10:23:55 2014 +0200

    drm/dp-helper: Deprecate old i2c-over-dp_aux heleprs
    
    Only gma500 is still using this, once that's converted we can kill all
    this code. If that conversion doesn't happen soonish I think we should
    just move this helper code into the gma500 driver itself to avoid
    abuse from new drivers.
    
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index a13f1f51f68e..494219ccdf96 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -213,6 +213,10 @@ i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
  *
  * RETURNS:
  * 0 on success, -ERRNO on failure.
+ *
+ * IMPORTANT:
+ * This interface is deprecated, please switch to the new dp aux helpers and
+ * drm_dp_aux_register_i2c_bus().
  */
 int
 i2c_dp_aux_add_bus(struct i2c_adapter *adapter)

commit 171f975d4c5c582c343c6807d6562b712fdb8d42
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Apr 29 11:44:37 2014 +0200

    drm/dp: Fix typo in comment
    
    Replace an occurrence of "adapater" with "adapter".
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 4b6e6f3ba0a1..a13f1f51f68e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -206,7 +206,7 @@ i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
  * i2c_dp_aux_add_bus() - register an i2c adapter using the aux ch helper
  * @adapter: i2c adapter to register
  *
- * This registers an i2c adapater that uses dp aux channel as it's underlaying
+ * This registers an i2c adapter that uses dp aux channel as it's underlaying
  * transport. The driver needs to fill out the &i2c_algo_dp_aux_data structure
  * and store it in the algo_data member of the @adapter argument. This will be
  * used by the i2c over dp aux algorithm to drive the hardware.

commit 732d50b431dca2f3f78fc21ba9b7ed9d06bb01ce
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Mon Apr 7 10:33:45 2014 -0400

    drm/dp/i2c: Update comments about common i2c over dp assumptions (v3)
    
    If you are using the common dp over i2c functionality, it is
    asumed that the aux transfer function does not modify the any
    of the msg structure other than the reply field.  Doing so
    breaks the logic in the common code.
    
    v2: update struct drm_dp_aux comments about assumptions
    v3 (chk): rebased on upstream changes
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index bcfb0d07718e..4b6e6f3ba0a1 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -577,7 +577,9 @@ static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
 
 /*
  * Transfer a single I2C-over-AUX message and handle various error conditions,
- * retrying the transaction as appropriate.
+ * retrying the transaction as appropriate.  It is assumed that the
+ * aux->transfer function does not modify anything in the msg other than the
+ * reply field.
  */
 static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 {

commit ccdb516e1873d9c69377bfec1e3392f3ed660102
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Mon Apr 7 10:33:44 2014 -0400

    drm/dp/i2c: send bare addresses to properly reset i2c connections (v4)
    
    We need bare address packets at the start and end of
    each i2c over aux transaction to properly reset the connection
    between transactions.  This mirrors what the existing dp i2c
    over aux algo currently does.
    
    This fixes EDID fetches on certain monitors especially with
    dp bridges.
    
    v2: update as per Ville's comments
        - Set buffer to NULL for zero sized packets
        - abort the entre transaction if one of the messages fails
    v3: drop leftover debugging code
    v4: integrate Thierry's comments
        - add comments about address only transactions
        - switch back to i and j
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 27671489477d..bcfb0d07718e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -665,11 +665,26 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 {
 	struct drm_dp_aux *aux = adapter->algo_data;
 	unsigned int i, j;
+	struct drm_dp_aux_msg msg;
+	int err = 0;
 
-	for (i = 0; i < num; i++) {
-		struct drm_dp_aux_msg msg;
-		int err;
+	memset(&msg, 0, sizeof(msg));
 
+	for (i = 0; i < num; i++) {
+		msg.address = msgs[i].addr;
+		msg.request = (msgs[i].flags & I2C_M_RD) ?
+			DP_AUX_I2C_READ :
+			DP_AUX_I2C_WRITE;
+		msg.request |= DP_AUX_I2C_MOT;
+		/* Send a bare address packet to start the transaction.
+		 * Zero sized messages specify an address only (bare
+		 * address) transaction.
+		 */
+		msg.buffer = NULL;
+		msg.size = 0;
+		err = drm_dp_i2c_do_msg(aux, &msg);
+		if (err < 0)
+			break;
 		/*
 		 * Many hardware implementations support FIFOs larger than a
 		 * single byte, but it has been empirically determined that
@@ -678,30 +693,28 @@ static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
 		 * transferred byte-by-byte.
 		 */
 		for (j = 0; j < msgs[i].len; j++) {
-			memset(&msg, 0, sizeof(msg));
-			msg.address = msgs[i].addr;
-
-			msg.request = (msgs[i].flags & I2C_M_RD) ?
-					DP_AUX_I2C_READ :
-					DP_AUX_I2C_WRITE;
-
-			/*
-			 * All messages except the last one are middle-of-
-			 * transfer messages.
-			 */
-			if ((i < num - 1) || (j < msgs[i].len - 1))
-				msg.request |= DP_AUX_I2C_MOT;
-
 			msg.buffer = msgs[i].buf + j;
 			msg.size = 1;
 
 			err = drm_dp_i2c_do_msg(aux, &msg);
 			if (err < 0)
-				return err;
+				break;
 		}
+		if (err < 0)
+			break;
 	}
+	if (err >= 0)
+		err = num;
+	/* Send a bare address packet to close out the transaction.
+	 * Zero sized messages specify an address only (bare
+	 * address) transaction.
+	 */
+	msg.request &= ~DP_AUX_I2C_MOT;
+	msg.buffer = NULL;
+	msg.size = 0;
+	(void)drm_dp_i2c_do_msg(aux, &msg);
 
-	return num;
+	return err;
 }
 
 static const struct i2c_algorithm drm_dp_i2c_algo = {

commit aa17edff0afa893b5ab1dd60d842cc6f42e847b4
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 4 11:34:37 2014 +1000

    drm/dp_helper: don't return EPROTO for defers (v2)
    
    If we get a msg.reply of REPLY_DEFER, we also get an err of 0
    so we fail reads with 0 < size and return -EPROTO instead of trying
    again.
    
    v2: same fix in i2c code.
    
    Found writing MST support.
    
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index f4babed2f557..27671489477d 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -386,11 +386,11 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 			return err;
 		}
 
-		if (err < size)
-			return -EPROTO;
 
 		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
 		case DP_AUX_NATIVE_REPLY_ACK:
+			if (err < size)
+				return -EPROTO;
 			return err;
 
 		case DP_AUX_NATIVE_REPLY_NACK:
@@ -599,8 +599,6 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			return err;
 		}
 
-		if (err < msg->size)
-			return -EPROTO;
 
 		switch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {
 		case DP_AUX_NATIVE_REPLY_ACK:
@@ -639,6 +637,8 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 			 * Both native ACK and I2C ACK replies received. We
 			 * can assume the transfer was successful.
 			 */
+			if (err < msg->size)
+				return -EPROTO;
 			return 0;
 
 		case DP_AUX_I2C_REPLY_NACK:

commit 66e514c14a1cb9c2540c685c40d94dc6ef6b6bb5
Merge: 2844ea3f2523 698b3135acb9
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 3 07:51:54 2014 +1000

    Merge tag 'drm-intel-next-2014-03-21' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - Inherit/reuse firmwar framebuffers (for real this time) from Jesse, less
      flicker for fastbooting.
    - More flexible cloning for hdmi (Ville).
    - Some PPGTT fixes from Ben.
    - Ring init fixes from Naresh Kumar.
    - set_cache_level regression fixes for the vma conversion from Ville&Chris.
    - Conversion to the new dp aux helpers (Jani).
    - Unification of runtime pm with pc8 support from Paulo, prep work for runtime
      pm on other platforms than HSW.
    - Larger cursor sizes (Sagar Kamble).
    - Piles of improvements and fixes all over, as usual.
    
    * tag 'drm-intel-next-2014-03-21' of git://anongit.freedesktop.org/drm-intel: (75 commits)
      drm/i915: Include a note about the dangers of I915_READ64/I915_WRITE64
      drm/i915/sdvo: fix questionable return value check
      drm/i915: Fix unsafe loop iteration over vma whilst unbinding them
      drm/i915: Enabling 128x128 and 256x256 ARGB Cursor Support
      drm/i915: Print how many objects are shared in per-process stats
      drm/i915: Per-process stats work better when evaluated per-process
      drm/i915: remove rps local variables
      drm/i915: Remove extraneous MMIO for RPS
      drm/i915: Rename and comment all the RPS *stuff*
      drm/i915: Store the HW min frequency as min_freq
      drm/i915: Fix coding style for RPS
      drm/i915: Reorganize the overclock code
      drm/i915: init pm.suspended earlier
      drm/i915: update the PC8 and runtime PM documentation
      drm/i915: rename __hsw_do_{en, dis}able_pc8
      drm/i915: kill struct i915_package_c8
      drm/i915: move pc8.irqs_disabled to pm.irqs_disabled
      drm/i915: remove dev_priv->pc8.enabled
      drm/i915: don't get/put PC8 when getting/putting power wells
      drm/i915: make intel_aux_display_runtime_get get runtime PM, not PC8
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c

commit 743b1e32f203ec1d28a65327dd98bd290a356ea0
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Fri Mar 21 10:34:06 2014 -0400

    drm/dp: make aux retries less chatty
    
    Switch to debug only to avoid flooding the logs.
    This mirrors the behavior in some other drivers.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 35251af3b14e..74724aacb8ae 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -402,7 +402,7 @@ static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
 		}
 	}
 
-	DRM_ERROR("too many retries, giving up\n");
+	DRM_DEBUG_KMS("too many retries, giving up\n");
 	return -EIO;
 }
 
@@ -656,7 +656,7 @@ static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 		}
 	}
 
-	DRM_ERROR("too many retries, giving up\n");
+	DRM_DEBUG_KMS("too many retries, giving up\n");
 	return -EREMOTEIO;
 }
 

commit 9dc4056026e0df30f6b29109e1e7a6958e7bea62
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Mar 14 16:51:12 2014 +0200

    drm/dp: let drivers specify the name of the I2C-over-AUX adapter
    
    Let the drivers specify the name of the I2C-over-AUX adapter to maintain
    backwards compatibility in the sysfs when converting to the new
    I2C-over-AUX helper infrastructure.
    
    The i915 driver currently uses DPDDC-A to DPDDC-D as names for the DP
    i2c adapters. These names show up in the i2c sysfs name attribute. We'd
    like to be able to maintain that when switching over to the new helpers.
    
    Due to i2c device and connector cleanup ordering issues we also recently
    made the drm device (instead of connector) the parent of the i2c
    adapters:
    
    commit 80f65de3c9b8101c1613fa82df500ba6a099a11c
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Tue Feb 11 17:12:49 2014 +0200
    
        drm/i915: dp: fix order of dp aux i2c device cleanup
    
    With the name picked up from the adapter parent using dev_name(), it
    would be the same for all i2c adapters with the current I2C-over-AUX
    helpers.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 35251af3b14e..17832d048147 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -726,7 +726,8 @@ int drm_dp_aux_register_i2c_bus(struct drm_dp_aux *aux)
 	aux->ddc.dev.parent = aux->dev;
 	aux->ddc.dev.of_node = aux->dev->of_node;
 
-	strncpy(aux->ddc.name, dev_name(aux->dev), sizeof(aux->ddc.name));
+	strlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),
+		sizeof(aux->ddc.name));
 
 	return i2c_add_adapter(&aux->ddc);
 }

commit 88759686c702f1fbbb8e737e6231b64a9880db73
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Dec 12 09:57:53 2013 +0100

    drm/dp: Allow registering AUX channels as I2C busses
    
    Implements an I2C-over-AUX I2C adapter on top of the generic drm_dp_aux
    infrastructure. It extracts the retry logic from existing drivers, which
    should help in porting those drivers to this new helper.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    ---
    Changes in v5:
    - move comments partially to to header file
    - keep MOT set between I2C messages
    - return -EPROTO on short reads
    
    Changes in v4:
    - fix typo "bitrate" -> "bit rate"
    
    Changes in v3:
    - add back DRM_DEBUG_KMS and DRM_ERROR messages
    - embed i2c_adapter within struct drm_dp_aux
    - fix typo in comment

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 177ac7bd1851..35251af3b14e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -357,13 +357,6 @@ EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);
  * Transactions are described using a hardware-independent drm_dp_aux_msg
  * structure, which is passed into a driver's .transfer() implementation.
  * Both native and I2C-over-AUX transactions are supported.
- *
- * An AUX channel can also be used to transport I2C messages to a sink. A
- * typical application of that is to access an EDID that's present in the
- * sink device. The .transfer() function can also be used to execute such
- * transactions. The drm_dp_aux_register_i2c_bus() function registers an
- * I2C adapter that can be passed to drm_probe_ddc(). Upon removal, drivers
- * should call drm_dp_aux_unregister_i2c_bus() to remove the I2C adapter.
  */
 
 static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
@@ -569,3 +562,182 @@ int drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)
 	return 0;
 }
 EXPORT_SYMBOL(drm_dp_link_configure);
+
+/*
+ * I2C-over-AUX implementation
+ */
+
+static u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
+	       I2C_FUNC_SMBUS_READ_BLOCK_DATA |
+	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |
+	       I2C_FUNC_10BIT_ADDR;
+}
+
+/*
+ * Transfer a single I2C-over-AUX message and handle various error conditions,
+ * retrying the transaction as appropriate.
+ */
+static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
+{
+	unsigned int retry;
+	int err;
+
+	/*
+	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device
+	 * is required to retry at least seven times upon receiving AUX_DEFER
+	 * before giving up the AUX transaction.
+	 */
+	for (retry = 0; retry < 7; retry++) {
+		err = aux->transfer(aux, msg);
+		if (err < 0) {
+			if (err == -EBUSY)
+				continue;
+
+			DRM_DEBUG_KMS("transaction failed: %d\n", err);
+			return err;
+		}
+
+		if (err < msg->size)
+			return -EPROTO;
+
+		switch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {
+		case DP_AUX_NATIVE_REPLY_ACK:
+			/*
+			 * For I2C-over-AUX transactions this isn't enough, we
+			 * need to check for the I2C ACK reply.
+			 */
+			break;
+
+		case DP_AUX_NATIVE_REPLY_NACK:
+			DRM_DEBUG_KMS("native nack\n");
+			return -EREMOTEIO;
+
+		case DP_AUX_NATIVE_REPLY_DEFER:
+			DRM_DEBUG_KMS("native defer");
+			/*
+			 * We could check for I2C bit rate capabilities and if
+			 * available adjust this interval. We could also be
+			 * more careful with DP-to-legacy adapters where a
+			 * long legacy cable may force very low I2C bit rates.
+			 *
+			 * For now just defer for long enough to hopefully be
+			 * safe for all use-cases.
+			 */
+			usleep_range(500, 600);
+			continue;
+
+		default:
+			DRM_ERROR("invalid native reply %#04x\n", msg->reply);
+			return -EREMOTEIO;
+		}
+
+		switch (msg->reply & DP_AUX_I2C_REPLY_MASK) {
+		case DP_AUX_I2C_REPLY_ACK:
+			/*
+			 * Both native ACK and I2C ACK replies received. We
+			 * can assume the transfer was successful.
+			 */
+			return 0;
+
+		case DP_AUX_I2C_REPLY_NACK:
+			DRM_DEBUG_KMS("I2C nack\n");
+			return -EREMOTEIO;
+
+		case DP_AUX_I2C_REPLY_DEFER:
+			DRM_DEBUG_KMS("I2C defer\n");
+			usleep_range(400, 500);
+			continue;
+
+		default:
+			DRM_ERROR("invalid I2C reply %#04x\n", msg->reply);
+			return -EREMOTEIO;
+		}
+	}
+
+	DRM_ERROR("too many retries, giving up\n");
+	return -EREMOTEIO;
+}
+
+static int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
+			   int num)
+{
+	struct drm_dp_aux *aux = adapter->algo_data;
+	unsigned int i, j;
+
+	for (i = 0; i < num; i++) {
+		struct drm_dp_aux_msg msg;
+		int err;
+
+		/*
+		 * Many hardware implementations support FIFOs larger than a
+		 * single byte, but it has been empirically determined that
+		 * transferring data in larger chunks can actually lead to
+		 * decreased performance. Therefore each message is simply
+		 * transferred byte-by-byte.
+		 */
+		for (j = 0; j < msgs[i].len; j++) {
+			memset(&msg, 0, sizeof(msg));
+			msg.address = msgs[i].addr;
+
+			msg.request = (msgs[i].flags & I2C_M_RD) ?
+					DP_AUX_I2C_READ :
+					DP_AUX_I2C_WRITE;
+
+			/*
+			 * All messages except the last one are middle-of-
+			 * transfer messages.
+			 */
+			if ((i < num - 1) || (j < msgs[i].len - 1))
+				msg.request |= DP_AUX_I2C_MOT;
+
+			msg.buffer = msgs[i].buf + j;
+			msg.size = 1;
+
+			err = drm_dp_i2c_do_msg(aux, &msg);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return num;
+}
+
+static const struct i2c_algorithm drm_dp_i2c_algo = {
+	.functionality = drm_dp_i2c_functionality,
+	.master_xfer = drm_dp_i2c_xfer,
+};
+
+/**
+ * drm_dp_aux_register_i2c_bus() - register an I2C adapter for I2C-over-AUX
+ * @aux: DisplayPort AUX channel
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_aux_register_i2c_bus(struct drm_dp_aux *aux)
+{
+	aux->ddc.algo = &drm_dp_i2c_algo;
+	aux->ddc.algo_data = aux;
+	aux->ddc.retries = 3;
+
+	aux->ddc.class = I2C_CLASS_DDC;
+	aux->ddc.owner = THIS_MODULE;
+	aux->ddc.dev.parent = aux->dev;
+	aux->ddc.dev.of_node = aux->dev->of_node;
+
+	strncpy(aux->ddc.name, dev_name(aux->dev), sizeof(aux->ddc.name));
+
+	return i2c_add_adapter(&aux->ddc);
+}
+EXPORT_SYMBOL(drm_dp_aux_register_i2c_bus);
+
+/**
+ * drm_dp_aux_unregister_i2c_bus() - unregister an I2C-over-AUX adapter
+ * @aux: DisplayPort AUX channel
+ */
+void drm_dp_aux_unregister_i2c_bus(struct drm_dp_aux *aux)
+{
+	i2c_del_adapter(&aux->ddc);
+}
+EXPORT_SYMBOL(drm_dp_aux_unregister_i2c_bus);

commit 516c0f7c0a608833cc01d3f5b2a357ee806b78a1
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Dec 9 11:47:55 2013 +0100

    drm/dp: Add DisplayPort link helpers
    
    Add a helper to probe a DP link (read out the supported DPCD revision,
    maximum rate, link count and capabilities) as well as power up the DP
    link and configure it accordingly.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    ---
    Changes in v5:
    - export helpers
    
    Changes in v4:
    - fix a couple of typos in comments as pointed out by Alex Deucher
    
    Changes in v3:
    - split into drm_dp_link_power_up() and drm_dp_link_configure()
    - do not change sink state for DPCD versions earlier than 1.1
    - sleep for 1-2 ms after setting local sink to D0 state
    - read and write consecutive registers where possible
    - read DPCD revision when link is probed
    - remove duplicate kerneldoc

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 84262ed64ce7..177ac7bd1851 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -472,3 +472,100 @@ int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
 				DP_LINK_STATUS_SIZE);
 }
 EXPORT_SYMBOL(drm_dp_dpcd_read_link_status);
+
+/**
+ * drm_dp_link_probe() - probe a DisplayPort link for capabilities
+ * @aux: DisplayPort AUX channel
+ * @link: pointer to structure in which to return link capabilities
+ *
+ * The structure filled in by this function can usually be passed directly
+ * into drm_dp_link_power_up() and drm_dp_link_configure() to power up and
+ * configure the link based on the link's capabilities.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_link_probe(struct drm_dp_aux *aux, struct drm_dp_link *link)
+{
+	u8 values[3];
+	int err;
+
+	memset(link, 0, sizeof(*link));
+
+	err = drm_dp_dpcd_read(aux, DP_DPCD_REV, values, sizeof(values));
+	if (err < 0)
+		return err;
+
+	link->revision = values[0];
+	link->rate = drm_dp_bw_code_to_link_rate(values[1]);
+	link->num_lanes = values[2] & DP_MAX_LANE_COUNT_MASK;
+
+	if (values[2] & DP_ENHANCED_FRAME_CAP)
+		link->capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_link_probe);
+
+/**
+ * drm_dp_link_power_up() - power up a DisplayPort link
+ * @aux: DisplayPort AUX channel
+ * @link: pointer to a structure containing the link configuration
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)
+{
+	u8 value;
+	int err;
+
+	/* DP_SET_POWER register is only available on DPCD v1.1 and later */
+	if (link->revision < 0x11)
+		return 0;
+
+	err = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);
+	if (err < 0)
+		return err;
+
+	value &= ~DP_SET_POWER_MASK;
+	value |= DP_SET_POWER_D0;
+
+	err = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);
+	if (err < 0)
+		return err;
+
+	/*
+	 * According to the DP 1.1 specification, a "Sink Device must exit the
+	 * power saving state within 1 ms" (Section 2.5.3.1, Table 5-52, "Sink
+	 * Control Field" (register 0x600).
+	 */
+	usleep_range(1000, 2000);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_link_power_up);
+
+/**
+ * drm_dp_link_configure() - configure a DisplayPort link
+ * @aux: DisplayPort AUX channel
+ * @link: pointer to a structure containing the link configuration
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)
+{
+	u8 values[2];
+	int err;
+
+	values[0] = drm_dp_link_rate_to_bw_code(link->rate);
+	values[1] = link->num_lanes;
+
+	if (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)
+		values[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
+
+	err = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_link_configure);

commit 8d4adc6a5807ca51999421b4d6d4f193c95775ba
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Nov 22 16:37:57 2013 +0100

    drm/dp: Add drm_dp_dpcd_read_link_status()
    
    The function reads the link status (6 bytes starting at offset 0x202)
    from the DPCD so that it can be conveniently passed to other DPCD
    helpers.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index da6bcfe178a6..84262ed64ce7 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -456,3 +456,19 @@ ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
 				  size);
 }
 EXPORT_SYMBOL(drm_dp_dpcd_write);
+
+/**
+ * drm_dp_dpcd_read_link_status() - read DPCD link status (bytes 0x202-0x207)
+ * @aux: DisplayPort AUX channel
+ * @status: buffer to store the link status in (must be at least 6 bytes)
+ *
+ * Returns the number of bytes transferred on success or a negative error
+ * code on failure.
+ */
+int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
+				 u8 status[DP_LINK_STATUS_SIZE])
+{
+	return drm_dp_dpcd_read(aux, DP_LANE0_1_STATUS, status,
+				DP_LINK_STATUS_SIZE);
+}
+EXPORT_SYMBOL(drm_dp_dpcd_read_link_status);

commit c197db75ff5c1d4f015c7668a3715e230a5d7e27
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Nov 28 11:31:00 2013 +0100

    drm/dp: Add AUX channel infrastructure
    
    This is a superset of the current i2c_dp_aux bus functionality and can
    be used to transfer native AUX in addition to I2C-over-AUX messages.
    
    Helpers are provided to read and write the DPCD, either blockwise or
    byte-wise. Many of the existing helpers for DisplayPort take a copy of a
    portion of the DPCD and operate on that, without a way to write data
    back to the DPCD (e.g. for configuration of the link).
    
    Subsequent patches will build upon this infrastructure to provide common
    functionality in a generic way.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    ---
    Changes in v5:
    - move comments partially to struct drm_dp_aux_msg in header file
    - return -EPROTO on short reads in DPCD helpers
    
    Changes in v4:
    - fix a typo in a comment
    
    Changes in v3:
    - reorder drm_dp_dpcd_writeb() arguments to be more intuitive
    - return number of bytes transferred in drm_dp_dpcd_write()
    - factor out drm_dp_dpcd_access()
    - describe error codes

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 9e978aae8972..da6bcfe178a6 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -346,3 +346,113 @@ int drm_dp_bw_code_to_link_rate(u8 link_bw)
 	}
 }
 EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);
+
+/**
+ * DOC: dp helpers
+ *
+ * The DisplayPort AUX channel is an abstraction to allow generic, driver-
+ * independent access to AUX functionality. Drivers can take advantage of
+ * this by filling in the fields of the drm_dp_aux structure.
+ *
+ * Transactions are described using a hardware-independent drm_dp_aux_msg
+ * structure, which is passed into a driver's .transfer() implementation.
+ * Both native and I2C-over-AUX transactions are supported.
+ *
+ * An AUX channel can also be used to transport I2C messages to a sink. A
+ * typical application of that is to access an EDID that's present in the
+ * sink device. The .transfer() function can also be used to execute such
+ * transactions. The drm_dp_aux_register_i2c_bus() function registers an
+ * I2C adapter that can be passed to drm_probe_ddc(). Upon removal, drivers
+ * should call drm_dp_aux_unregister_i2c_bus() to remove the I2C adapter.
+ */
+
+static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
+			      unsigned int offset, void *buffer, size_t size)
+{
+	struct drm_dp_aux_msg msg;
+	unsigned int retry;
+	int err;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.address = offset;
+	msg.request = request;
+	msg.buffer = buffer;
+	msg.size = size;
+
+	/*
+	 * The specification doesn't give any recommendation on how often to
+	 * retry native transactions, so retry 7 times like for I2C-over-AUX
+	 * transactions.
+	 */
+	for (retry = 0; retry < 7; retry++) {
+		err = aux->transfer(aux, &msg);
+		if (err < 0) {
+			if (err == -EBUSY)
+				continue;
+
+			return err;
+		}
+
+		if (err < size)
+			return -EPROTO;
+
+		switch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {
+		case DP_AUX_NATIVE_REPLY_ACK:
+			return err;
+
+		case DP_AUX_NATIVE_REPLY_NACK:
+			return -EIO;
+
+		case DP_AUX_NATIVE_REPLY_DEFER:
+			usleep_range(400, 500);
+			break;
+		}
+	}
+
+	DRM_ERROR("too many retries, giving up\n");
+	return -EIO;
+}
+
+/**
+ * drm_dp_dpcd_read() - read a series of bytes from the DPCD
+ * @aux: DisplayPort AUX channel
+ * @offset: address of the (first) register to read
+ * @buffer: buffer to store the register values
+ * @size: number of bytes in @buffer
+ *
+ * Returns the number of bytes transferred on success, or a negative error
+ * code on failure. -EIO is returned if the request was NAKed by the sink or
+ * if the retry count was exceeded. If not all bytes were transferred, this
+ * function returns -EPROTO. Errors from the underlying AUX channel transfer
+ * function, with the exception of -EBUSY (which causes the transaction to
+ * be retried), are propagated to the caller.
+ */
+ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
+			 void *buffer, size_t size)
+{
+	return drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,
+				  size);
+}
+EXPORT_SYMBOL(drm_dp_dpcd_read);
+
+/**
+ * drm_dp_dpcd_write() - write a series of bytes to the DPCD
+ * @aux: DisplayPort AUX channel
+ * @offset: address of the (first) register to write
+ * @buffer: buffer containing the values to write
+ * @size: number of bytes in @buffer
+ *
+ * Returns the number of bytes transferred on success, or a negative error
+ * code on failure. -EIO is returned if the request was NAKed by the sink or
+ * if the retry count was exceeded. If not all bytes were transferred, this
+ * function returns -EPROTO. Errors from the underlying AUX channel transfer
+ * function, with the exception of -EBUSY (which causes the transaction to
+ * be retried), are propagated to the caller.
+ */
+ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
+			  void *buffer, size_t size)
+{
+	return drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,
+				  size);
+}
+EXPORT_SYMBOL(drm_dp_dpcd_write);

commit 0aec288130713cf7bcf97c929ac5fab6a8e00e44
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 27 19:01:01 2013 +0300

    drm/dp: constify DP DPCD helpers
    
    None of the DP DPCD helpers need to modify the DPCD.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 89e196627160..9e978aae8972 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -228,12 +228,12 @@ i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
 EXPORT_SYMBOL(i2c_dp_aux_add_bus);
 
 /* Helpers for DP link training */
-static u8 dp_link_status(u8 link_status[DP_LINK_STATUS_SIZE], int r)
+static u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)
 {
 	return link_status[r - DP_LANE0_1_STATUS];
 }
 
-static u8 dp_get_lane_status(u8 link_status[DP_LINK_STATUS_SIZE],
+static u8 dp_get_lane_status(const u8 link_status[DP_LINK_STATUS_SIZE],
 			     int lane)
 {
 	int i = DP_LANE0_1_STATUS + (lane >> 1);
@@ -242,7 +242,7 @@ static u8 dp_get_lane_status(u8 link_status[DP_LINK_STATUS_SIZE],
 	return (l >> s) & 0xf;
 }
 
-bool drm_dp_channel_eq_ok(u8 link_status[DP_LINK_STATUS_SIZE],
+bool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
 			  int lane_count)
 {
 	u8 lane_align;
@@ -262,7 +262,7 @@ bool drm_dp_channel_eq_ok(u8 link_status[DP_LINK_STATUS_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_channel_eq_ok);
 
-bool drm_dp_clock_recovery_ok(u8 link_status[DP_LINK_STATUS_SIZE],
+bool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
 			      int lane_count)
 {
 	int lane;
@@ -277,7 +277,7 @@ bool drm_dp_clock_recovery_ok(u8 link_status[DP_LINK_STATUS_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_clock_recovery_ok);
 
-u8 drm_dp_get_adjust_request_voltage(u8 link_status[DP_LINK_STATUS_SIZE],
+u8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],
 				     int lane)
 {
 	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
@@ -290,7 +290,7 @@ u8 drm_dp_get_adjust_request_voltage(u8 link_status[DP_LINK_STATUS_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_get_adjust_request_voltage);
 
-u8 drm_dp_get_adjust_request_pre_emphasis(u8 link_status[DP_LINK_STATUS_SIZE],
+u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],
 					  int lane)
 {
 	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
@@ -303,7 +303,7 @@ u8 drm_dp_get_adjust_request_pre_emphasis(u8 link_status[DP_LINK_STATUS_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
 
-void drm_dp_link_train_clock_recovery_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
+void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
 	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
 		udelay(100);
 	else
@@ -311,7 +311,7 @@ void drm_dp_link_train_clock_recovery_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
 }
 EXPORT_SYMBOL(drm_dp_link_train_clock_recovery_delay);
 
-void drm_dp_link_train_channel_eq_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
+void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
 	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
 		udelay(400);
 	else

commit 28164fdad85ec806f30c76fe98ed0e3abc91d2d7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 1 14:45:18 2012 +0100

    drm/doc: add new dp helpers into drm DocBook
    
    I didn't bother with documenting the really trivial new "extract
    something from dpcd" helpers, but the i2c over aux ch is now
    documented a bit.
    
    v2: Clarify the comment for i2c_dp_aux_add_bus a bit.
    
    v3: Fix more spelling fail spotted by Laurent Pinchart.
    
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 3c4cccd0d753..89e196627160 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -30,6 +30,15 @@
 #include <drm/drm_dp_helper.h>
 #include <drm/drmP.h>
 
+/**
+ * DOC: dp helpers
+ *
+ * These functions contain some common logic and helpers at various abstraction
+ * levels to deal with Display Port sink devices and related things like DP aux
+ * channel transfers, EDID reading over DP aux channels, decoding certain DPCD
+ * blocks, ...
+ */
+
 /* Run a single AUX_CH I2C transaction, writing/reading data as necessary */
 static int
 i2c_algo_dp_aux_transaction(struct i2c_adapter *adapter, int mode,
@@ -193,6 +202,18 @@ i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
 	return 0;
 }
 
+/**
+ * i2c_dp_aux_add_bus() - register an i2c adapter using the aux ch helper
+ * @adapter: i2c adapter to register
+ *
+ * This registers an i2c adapater that uses dp aux channel as it's underlaying
+ * transport. The driver needs to fill out the &i2c_algo_dp_aux_data structure
+ * and store it in the algo_data member of the @adapter argument. This will be
+ * used by the i2c over dp aux algorithm to drive the hardware.
+ *
+ * RETURNS:
+ * 0 on success, -ERRNO on failure.
+ */
 int
 i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
 {

commit 3b5c662e8f536ca47396116de82f08d771727076
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 10:15:31 2012 +0200

    drm: extract dp link bw helpers
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 7ecaa11f35f6..3c4cccd0d753 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -297,3 +297,31 @@ void drm_dp_link_train_channel_eq_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
 		mdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);
 }
 EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);
+
+u8 drm_dp_link_rate_to_bw_code(int link_rate)
+{
+	switch (link_rate) {
+	case 162000:
+	default:
+		return DP_LINK_BW_1_62;
+	case 270000:
+		return DP_LINK_BW_2_7;
+	case 540000:
+		return DP_LINK_BW_5_4;
+	}
+}
+EXPORT_SYMBOL(drm_dp_link_rate_to_bw_code);
+
+int drm_dp_bw_code_to_link_rate(u8 link_bw)
+{
+	switch (link_bw) {
+	case DP_LINK_BW_1_62:
+	default:
+		return 162000;
+	case DP_LINK_BW_2_7:
+		return 270000;
+	case DP_LINK_BW_5_4:
+		return 540000;
+	}
+}
+EXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);

commit 1a644cd47ca0c40a9210db170bd0630031c3a60b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 15:32:40 2012 +0200

    drm: extract dp link train delay functions from radeon
    
    This requires a few changes since that dpcd value is above the
    range currently cached by radeon. I've check the dp specs, and
    above 0xf there's a big gap and nothing that looks like we should
    cache it while a given device is plugged in. It's also the same value
    that i915.ko uses.
    
    Hence extend the various dpcd arrays in the radeon driver, use
    proper symbolic constants where applicable (one place overallocated
    the dpcd array to 25 bytes). Then also drop the rd_interval cache -
    radeon_dp_link_train_init re-reads the dpcd block, so the values we'll
    consume in train_cr and train_ce will always be fresh.
    
    To avoid needless diff-churn, #define the old size of dpcd as the new
    one and keep it around.
    
    v2: Alex Deucher noticed one place where I've forgotten to replace 8
    with DP_RECEIVER_CAP_SIZE.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 9461e2f27316..7ecaa11f35f6 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -282,3 +282,18 @@ u8 drm_dp_get_adjust_request_pre_emphasis(u8 link_status[DP_LINK_STATUS_SIZE],
 }
 EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
 
+void drm_dp_link_train_clock_recovery_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
+	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
+		udelay(100);
+	else
+		mdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);
+}
+EXPORT_SYMBOL(drm_dp_link_train_clock_recovery_delay);
+
+void drm_dp_link_train_channel_eq_delay(u8 dpcd[DP_RECEIVER_CAP_SIZE]) {
+	if (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)
+		udelay(400);
+	else
+		mdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);
+}
+EXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);

commit 0f037bdee1a12947a0c55b21a05f57793332bc07
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 10:15:27 2012 +0200

    drm: extract helpers to compute new training values from sink request
    
    Safe for the minor difference that the intel versions get an offset
    into the link_status as an argument, both are the same again.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 1378b789bd10..9461e2f27316 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -255,3 +255,30 @@ bool drm_dp_clock_recovery_ok(u8 link_status[DP_LINK_STATUS_SIZE],
 	return true;
 }
 EXPORT_SYMBOL(drm_dp_clock_recovery_ok);
+
+u8 drm_dp_get_adjust_request_voltage(u8 link_status[DP_LINK_STATUS_SIZE],
+				     int lane)
+{
+	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
+	int s = ((lane & 1) ?
+		 DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :
+		 DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);
+	u8 l = dp_link_status(link_status, i);
+
+	return ((l >> s) & 0x3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;
+}
+EXPORT_SYMBOL(drm_dp_get_adjust_request_voltage);
+
+u8 drm_dp_get_adjust_request_pre_emphasis(u8 link_status[DP_LINK_STATUS_SIZE],
+					  int lane)
+{
+	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
+	int s = ((lane & 1) ?
+		 DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :
+		 DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);
+	u8 l = dp_link_status(link_status, i);
+
+	return ((l >> s) & 0x3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;
+}
+EXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);
+

commit 1ffdff134eb2d943bde3e4901ac48a9656a7e7a5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 10:15:24 2012 +0200

    drm: dp helper: extract drm_dp_channel_eq_ok
    
    radeon and intel use the exact same definition.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index bb4eaf60117f..1378b789bd10 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -205,3 +205,53 @@ i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
 	return error;
 }
 EXPORT_SYMBOL(i2c_dp_aux_add_bus);
+
+/* Helpers for DP link training */
+static u8 dp_link_status(u8 link_status[DP_LINK_STATUS_SIZE], int r)
+{
+	return link_status[r - DP_LANE0_1_STATUS];
+}
+
+static u8 dp_get_lane_status(u8 link_status[DP_LINK_STATUS_SIZE],
+			     int lane)
+{
+	int i = DP_LANE0_1_STATUS + (lane >> 1);
+	int s = (lane & 1) * 4;
+	u8 l = dp_link_status(link_status, i);
+	return (l >> s) & 0xf;
+}
+
+bool drm_dp_channel_eq_ok(u8 link_status[DP_LINK_STATUS_SIZE],
+			  int lane_count)
+{
+	u8 lane_align;
+	u8 lane_status;
+	int lane;
+
+	lane_align = dp_link_status(link_status,
+				    DP_LANE_ALIGN_STATUS_UPDATED);
+	if ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)
+		return false;
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = dp_get_lane_status(link_status, lane);
+		if ((lane_status & DP_CHANNEL_EQ_BITS) != DP_CHANNEL_EQ_BITS)
+			return false;
+	}
+	return true;
+}
+EXPORT_SYMBOL(drm_dp_channel_eq_ok);
+
+bool drm_dp_clock_recovery_ok(u8 link_status[DP_LINK_STATUS_SIZE],
+			      int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = dp_get_lane_status(link_status, lane);
+		if ((lane_status & DP_LANE_CR_DONE) == 0)
+			return false;
+	}
+	return true;
+}
+EXPORT_SYMBOL(drm_dp_clock_recovery_ok);

commit 00ae9a456dd9a3e26db2265c0d25dec0d1e74b07
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 18 10:15:23 2012 +0200

    drm: rename drm_dp_i2c_helper.c to drm_dp_helper.c
    
    I want to move some dp link training helpers into this place, so in
    the future this won't be just about i2c any longer.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
new file mode 100644
index 000000000000..bb4eaf60117f
--- /dev/null
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright © 2009 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drmP.h>
+
+/* Run a single AUX_CH I2C transaction, writing/reading data as necessary */
+static int
+i2c_algo_dp_aux_transaction(struct i2c_adapter *adapter, int mode,
+			    uint8_t write_byte, uint8_t *read_byte)
+{
+	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
+	int ret;
+
+	ret = (*algo_data->aux_ch)(adapter, mode,
+				   write_byte, read_byte);
+	return ret;
+}
+
+/*
+ * I2C over AUX CH
+ */
+
+/*
+ * Send the address. If the I2C link is running, this 'restarts'
+ * the connection with the new address, this is used for doing
+ * a write followed by a read (as needed for DDC)
+ */
+static int
+i2c_algo_dp_aux_address(struct i2c_adapter *adapter, u16 address, bool reading)
+{
+	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
+	int mode = MODE_I2C_START;
+	int ret;
+
+	if (reading)
+		mode |= MODE_I2C_READ;
+	else
+		mode |= MODE_I2C_WRITE;
+	algo_data->address = address;
+	algo_data->running = true;
+	ret = i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);
+	return ret;
+}
+
+/*
+ * Stop the I2C transaction. This closes out the link, sending
+ * a bare address packet with the MOT bit turned off
+ */
+static void
+i2c_algo_dp_aux_stop(struct i2c_adapter *adapter, bool reading)
+{
+	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
+	int mode = MODE_I2C_STOP;
+
+	if (reading)
+		mode |= MODE_I2C_READ;
+	else
+		mode |= MODE_I2C_WRITE;
+	if (algo_data->running) {
+		(void) i2c_algo_dp_aux_transaction(adapter, mode, 0, NULL);
+		algo_data->running = false;
+	}
+}
+
+/*
+ * Write a single byte to the current I2C address, the
+ * the I2C link must be running or this returns -EIO
+ */
+static int
+i2c_algo_dp_aux_put_byte(struct i2c_adapter *adapter, u8 byte)
+{
+	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
+	int ret;
+
+	if (!algo_data->running)
+		return -EIO;
+
+	ret = i2c_algo_dp_aux_transaction(adapter, MODE_I2C_WRITE, byte, NULL);
+	return ret;
+}
+
+/*
+ * Read a single byte from the current I2C address, the
+ * I2C link must be running or this returns -EIO
+ */
+static int
+i2c_algo_dp_aux_get_byte(struct i2c_adapter *adapter, u8 *byte_ret)
+{
+	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
+	int ret;
+
+	if (!algo_data->running)
+		return -EIO;
+
+	ret = i2c_algo_dp_aux_transaction(adapter, MODE_I2C_READ, 0, byte_ret);
+	return ret;
+}
+
+static int
+i2c_algo_dp_aux_xfer(struct i2c_adapter *adapter,
+		     struct i2c_msg *msgs,
+		     int num)
+{
+	int ret = 0;
+	bool reading = false;
+	int m;
+	int b;
+
+	for (m = 0; m < num; m++) {
+		u16 len = msgs[m].len;
+		u8 *buf = msgs[m].buf;
+		reading = (msgs[m].flags & I2C_M_RD) != 0;
+		ret = i2c_algo_dp_aux_address(adapter, msgs[m].addr, reading);
+		if (ret < 0)
+			break;
+		if (reading) {
+			for (b = 0; b < len; b++) {
+				ret = i2c_algo_dp_aux_get_byte(adapter, &buf[b]);
+				if (ret < 0)
+					break;
+			}
+		} else {
+			for (b = 0; b < len; b++) {
+				ret = i2c_algo_dp_aux_put_byte(adapter, buf[b]);
+				if (ret < 0)
+					break;
+			}
+		}
+		if (ret < 0)
+			break;
+	}
+	if (ret >= 0)
+		ret = num;
+	i2c_algo_dp_aux_stop(adapter, reading);
+	DRM_DEBUG_KMS("dp_aux_xfer return %d\n", ret);
+	return ret;
+}
+
+static u32
+i2c_algo_dp_aux_functionality(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
+	       I2C_FUNC_SMBUS_READ_BLOCK_DATA |
+	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |
+	       I2C_FUNC_10BIT_ADDR;
+}
+
+static const struct i2c_algorithm i2c_dp_aux_algo = {
+	.master_xfer	= i2c_algo_dp_aux_xfer,
+	.functionality	= i2c_algo_dp_aux_functionality,
+};
+
+static void
+i2c_dp_aux_reset_bus(struct i2c_adapter *adapter)
+{
+	(void) i2c_algo_dp_aux_address(adapter, 0, false);
+	(void) i2c_algo_dp_aux_stop(adapter, false);
+}
+
+static int
+i2c_dp_aux_prepare_bus(struct i2c_adapter *adapter)
+{
+	adapter->algo = &i2c_dp_aux_algo;
+	adapter->retries = 3;
+	i2c_dp_aux_reset_bus(adapter);
+	return 0;
+}
+
+int
+i2c_dp_aux_add_bus(struct i2c_adapter *adapter)
+{
+	int error;
+
+	error = i2c_dp_aux_prepare_bus(adapter);
+	if (error)
+		return error;
+	error = i2c_add_adapter(adapter);
+	return error;
+}
+EXPORT_SYMBOL(i2c_dp_aux_add_bus);
