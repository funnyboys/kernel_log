commit dc3260d0f6c67336d71143263091029d8f1f823a
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:40 2020 +0100

    drm/vkms: Convert to CRTC VBLANK callbacks
    
    VBLANK callbacks in struct drm_driver are deprecated in favor of
    their equivalents in struct drm_crtc_funcs. Convert vkms over.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueira@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueira@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-20-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 74f703b8d22a..ac85e17428f8 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -76,10 +76,12 @@ static void vkms_disable_vblank(struct drm_crtc *crtc)
 	hrtimer_cancel(&out->vblank_hrtimer);
 }
 
-bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
-			       int *max_error, ktime_t *vblank_time,
-			       bool in_vblank_irq)
+static bool vkms_get_vblank_timestamp(struct drm_crtc *crtc,
+				      int *max_error, ktime_t *vblank_time,
+				      bool in_vblank_irq)
 {
+	struct drm_device *dev = crtc->dev;
+	unsigned int pipe = crtc->index;
 	struct vkms_device *vkmsdev = drm_device_to_vkms_device(dev);
 	struct vkms_output *output = &vkmsdev->output;
 	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
@@ -154,6 +156,7 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.atomic_destroy_state   = vkms_atomic_crtc_destroy_state,
 	.enable_vblank		= vkms_enable_vblank,
 	.disable_vblank		= vkms_disable_vblank,
+	.get_vblank_timestamp	= vkms_get_vblank_timestamp,
 	.get_crc_sources	= vkms_get_crc_sources,
 	.set_crc_source		= vkms_set_crc_source,
 	.verify_crc_source	= vkms_verify_crc_source,

commit 88ad7f3a56603234eaa0297a722a3b8a338f2441
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 19 17:23:14 2019 +0200

    drm/vkms: Reduce critical section in vblank_simulate
    
    We can reduce the critical section in vkms_vblank_simulate under
    output->lock quite a lot:
    
    - hrtimer_forward_now just needs to be ordered correctly wrt
      drm_crtc_handle_vblank. We already access the hrtimer timestamp
      without locks. While auditing that I noticed that we don't correctly
      annotate the read there, so sprinkle a READ_ONCE to make sure the
      compiler doesn't do anything foolish.
    
    - drm_crtc_handle_vblank must stay under the lock to avoid races with
      drm_crtc_arm_vblank_event.
    
    - The access to vkms_ouptut->crc_state also must stay under the lock.
    
    - next problem is making sure the output->state structure doesn't get
      freed too early. First we rely on a given hrtimer being serialized:
      If we call drm_crtc_handle_vblank, then we are guaranteed that the
      previous call to vkms_vblank_simulate has completed. The other side
      of the coin is that the atomic updates waits for the vblank to
      happen before it releases the old state. Both taken together means
      that by the time the atomic update releases the old state, the
      hrtimer won't access it anymore (it might be accessing the new state
      at the same time, but that's ok).
    
    - state is invariant, except the few fields separate protected by
      state->crc_lock. So no need to hold the lock for that.
    
    - finally the queue_work. We need to make sure there's no races with
      the flush_work, i.e. when we call flush_work we need to guarantee
      that the hrtimer can't requeue the work again. This is guaranteed by
      the same vblank/hrtimer ordering guarantees like the reasoning above
      why state won't be freed too early: flush_work on the old state is
      called after wait_for_flip_done in the atomic commit code.
    
    Therefore we can also move everything after the output->crc_state out
    of the critical section.
    
    Motivated by suggestions from Rodrigo.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190719152314.7706-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 927dafaebc76..74f703b8d22a 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -16,17 +16,18 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	u64 ret_overrun;
 	bool ret;
 
-	spin_lock(&output->lock);
-
 	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
 					  output->period_ns);
 	WARN_ON(ret_overrun != 1);
 
+	spin_lock(&output->lock);
 	ret = drm_crtc_handle_vblank(crtc);
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
 	state = output->composer_state;
+	spin_unlock(&output->lock);
+
 	if (state && output->composer_enabled) {
 		u64 frame = drm_crtc_accurate_vblank_count(crtc);
 
@@ -48,8 +49,6 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 			DRM_DEBUG_DRIVER("Composer worker already queued\n");
 	}
 
-	spin_unlock(&output->lock);
-
 	return HRTIMER_RESTART;
 }
 
@@ -85,7 +84,7 @@ bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
 	struct vkms_output *output = &vkmsdev->output;
 	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
 
-	*vblank_time = output->vblank_hrtimer.node.expires;
+	*vblank_time = READ_ONCE(output->vblank_hrtimer.node.expires);
 
 	if (WARN_ON(*vblank_time == vblank->time))
 		return true;

commit ce672a1b21a8015c5a8de3a656d4c2edc22663b0
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 30 08:19:01 2019 +0200

    drm/vkms: drop use of drmP.h
    
    Drop use of the deprecated drmP.h header.
    Replace it with the necessary includes in the individual .c files.
    The header files was self-contained, and extra includes were not added
    there.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190630061922.7254-13-sam@ravnborg.org

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 49a8ec2cb1c1..927dafaebc76 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -1,9 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0+
 
-#include "vkms_drv.h"
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+
+#include "vkms_drv.h"
 
 static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 {

commit a4e7e98e90ebd9a801d6a383e1edd10b09d155ba
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Tue Jun 25 22:37:05 2019 -0300

    drm/vkms: Rename vkms_crc.c into vkms_composer.c
    
    As a preparation work for introducing writeback to vkms, this patch
    renames the file vkms_crc.c into vkms_composer.c. Accordingly, it also
    adjusts the functions and data structures to match the changes.
    
    No functional change.
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/dea62063077ebf5cc1dfce8876e56788d15367e6.1561491964.git.rodrigosiqueiramelo@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 7e2a081f3764..49a8ec2cb1c1 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -24,14 +24,14 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
-	state = output->crc_state;
-	if (state && output->crc_enabled) {
+	state = output->composer_state;
+	if (state && output->composer_enabled) {
 		u64 frame = drm_crtc_accurate_vblank_count(crtc);
 
-		/* update frame_start only if a queued vkms_crc_work_handle()
+		/* update frame_start only if a queued vkms_composer_worker()
 		 * has read the data
 		 */
-		spin_lock(&output->crc_lock);
+		spin_lock(&output->composer_lock);
 		if (!state->crc_pending)
 			state->frame_start = frame;
 		else
@@ -39,11 +39,11 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 					 state->frame_start, frame);
 		state->frame_end = frame;
 		state->crc_pending = true;
-		spin_unlock(&output->crc_lock);
+		spin_unlock(&output->composer_lock);
 
-		ret = queue_work(output->crc_workq, &state->crc_work);
+		ret = queue_work(output->composer_workq, &state->composer_work);
 		if (!ret)
-			DRM_DEBUG_DRIVER("vkms_crc_work_handle already queued\n");
+			DRM_DEBUG_DRIVER("Composer worker already queued\n");
 	}
 
 	spin_unlock(&output->lock);
@@ -114,7 +114,7 @@ vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);
 
-	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+	INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 
 	return &vkms_state->base;
 }
@@ -126,7 +126,7 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 
 	__drm_atomic_helper_crtc_destroy_state(state);
 
-	WARN_ON(work_pending(&vkms_state->crc_work));
+	WARN_ON(work_pending(&vkms_state->composer_work));
 	kfree(vkms_state->active_planes);
 	kfree(vkms_state);
 }
@@ -141,7 +141,7 @@ static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_reset(crtc, &vkms_state->base);
 	if (vkms_state)
-		INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+		INIT_WORK(&vkms_state->composer_work, vkms_composer_worker);
 }
 
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
@@ -222,7 +222,7 @@ static void vkms_crtc_atomic_begin(struct drm_crtc *crtc,
 	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
 
 	/* This lock is held across the atomic commit to block vblank timer
-	 * from scheduling vkms_crc_work_handle until the crc_data is updated
+	 * from scheduling vkms_composer_worker until the composer is updated
 	 */
 	spin_lock_irq(&vkms_output->lock);
 }
@@ -245,7 +245,7 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 		crtc->state->event = NULL;
 	}
 
-	vkms_output->crc_state = to_vkms_crtc_state(crtc->state);
+	vkms_output->composer_state = to_vkms_crtc_state(crtc->state);
 
 	spin_unlock_irq(&vkms_output->lock);
 }
@@ -274,10 +274,10 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
 	spin_lock_init(&vkms_out->lock);
-	spin_lock_init(&vkms_out->crc_lock);
+	spin_lock_init(&vkms_out->composer_lock);
 
-	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
-	if (!vkms_out->crc_workq)
+	vkms_out->composer_workq = alloc_ordered_workqueue("vkms_composer", 0);
+	if (!vkms_out->composer_workq)
 		return -ENOMEM;
 
 	return ret;

commit 8b1865873651daeffe412059c2c3c37021b9d92f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 7 00:27:50 2019 +0200

    drm/vkms: totally reworked crc data tracking
    
    The crc computation worker needs to be able to get at some data
    structures and framebuffer mappings, while potentially more atomic
    updates are going on. The solution thus far is to copy relevant bits
    around, but that's very tedious.
    
    Here's a new approach, which tries to be more clever, but relies on a
    few not-so-obvious things:
    - crtc_state is always updated when a plane_state changes. Therefore
      we can just stuff plane_state pointers into a crtc_state. That
      solves the problem of easily getting at the needed plane_states.
    - with the flushing changes from previous patches the above also holds
      without races due to the next atomic update being a bit eager with
      cleaning up pending work - we always wait for all crc work items to
      complete before unmapping framebuffers.
    - we also need to make sure that the hrtimer fires off the right
      worker. Keep a new distinct crc_state pointer, under the
      vkms_output->lock protection for this. Note that crtc->state is
      updated very early in the atomic commit, way before we arm the
      vblank event - the vblank event should always match the buffers we
      use to compute the crc. This also solves an issue in the hrtimer,
      where we've accessed drm_crtc->state without holding the right locks
      (we held none - oops).
    - in the worker itself we can then just access the plane states we
      need, again solving a bunch of ordering and locking issues.
      Accessing plane->state requires locks, accessing the private
      vkms_crtc_state->active_planes pointer only requires that the memory
      doesn't get freed too early.
    
    The idea behind vkms_crtc_state->active_planes is that this would
    contain all visible planes, in z-order, as a first step towards a more
    generic blending implementation.
    
    Note that this patch also fixes races between prepare_fb/cleanup_fb
    and the crc worker accessing ->vaddr.
    
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606222751.32567-10-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index d3d95b1e7292..7e2a081f3764 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0+
 
 #include "vkms_drv.h"
+#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_probe_helper.h>
 
@@ -9,7 +10,7 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	struct vkms_output *output = container_of(timer, struct vkms_output,
 						  vblank_hrtimer);
 	struct drm_crtc *crtc = &output->crtc;
-	struct vkms_crtc_state *state = to_vkms_crtc_state(crtc->state);
+	struct vkms_crtc_state *state;
 	u64 ret_overrun;
 	bool ret;
 
@@ -23,6 +24,7 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
+	state = output->crc_state;
 	if (state && output->crc_enabled) {
 		u64 frame = drm_crtc_accurate_vblank_count(crtc);
 
@@ -124,10 +126,9 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 
 	__drm_atomic_helper_crtc_destroy_state(state);
 
-	if (vkms_state) {
-		WARN_ON(work_pending(&vkms_state->crc_work));
-		kfree(vkms_state);
-	}
+	WARN_ON(work_pending(&vkms_state->crc_work));
+	kfree(vkms_state->active_planes);
+	kfree(vkms_state);
 }
 
 static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
@@ -157,6 +158,52 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.verify_crc_source	= vkms_verify_crc_source,
 };
 
+static int vkms_crtc_atomic_check(struct drm_crtc *crtc,
+				  struct drm_crtc_state *state)
+{
+	struct vkms_crtc_state *vkms_state = to_vkms_crtc_state(state);
+	struct drm_plane *plane;
+	struct drm_plane_state *plane_state;
+	int i = 0, ret;
+
+	if (vkms_state->active_planes)
+		return 0;
+
+	ret = drm_atomic_add_affected_planes(state->state, crtc);
+	if (ret < 0)
+		return ret;
+
+	drm_for_each_plane_mask(plane, crtc->dev, state->plane_mask) {
+		plane_state = drm_atomic_get_existing_plane_state(state->state,
+								  plane);
+		WARN_ON(!plane_state);
+
+		if (!plane_state->visible)
+			continue;
+
+		i++;
+	}
+
+	vkms_state->active_planes = kcalloc(i, sizeof(plane), GFP_KERNEL);
+	if (!vkms_state->active_planes)
+		return -ENOMEM;
+	vkms_state->num_active_planes = i;
+
+	i = 0;
+	drm_for_each_plane_mask(plane, crtc->dev, state->plane_mask) {
+		plane_state = drm_atomic_get_existing_plane_state(state->state,
+								  plane);
+
+		if (!plane_state->visible)
+			continue;
+
+		vkms_state->active_planes[i++] =
+			to_vkms_plane_state(plane_state);
+	}
+
+	return 0;
+}
+
 static void vkms_crtc_atomic_enable(struct drm_crtc *crtc,
 				    struct drm_crtc_state *old_state)
 {
@@ -198,10 +245,13 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 		crtc->state->event = NULL;
 	}
 
+	vkms_output->crc_state = to_vkms_crtc_state(crtc->state);
+
 	spin_unlock_irq(&vkms_output->lock);
 }
 
 static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs = {
+	.atomic_check	= vkms_crtc_atomic_check,
 	.atomic_begin	= vkms_crtc_atomic_begin,
 	.atomic_flush	= vkms_crtc_atomic_flush,
 	.atomic_enable	= vkms_crtc_atomic_enable,

commit 1c305e13ecc5579874464842e969f69ae032f4e4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 7 00:27:49 2019 +0200

    drm/vkms: No _irqsave within spin_lock_irq needed
    
    irqs are already off.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606222751.32567-9-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index a03f361e2fe0..d3d95b1e7292 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -184,17 +184,16 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 				   struct drm_crtc_state *old_crtc_state)
 {
 	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
-	unsigned long flags;
 
 	if (crtc->state->event) {
-		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		spin_lock(&crtc->dev->event_lock);
 
 		if (drm_crtc_vblank_get(crtc) != 0)
 			drm_crtc_send_vblank_event(crtc, crtc->state->event);
 		else
 			drm_crtc_arm_vblank_event(crtc, crtc->state->event);
 
-		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		spin_unlock(&crtc->dev->event_lock);
 
 		crtc->state->event = NULL;
 	}

commit 5ef8100a3919fb2fabae908554dc0823063e5be4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 7 00:27:47 2019 +0200

    drm/vkms: flush crc workers earlier in commit flow
    
    Currently, we flush pending CRC workers very late in the commit flow,
    when we destroy all the old crtc states. Unfortunately, at that point,
    the framebuffers are already unpinned (and our vaddr possible gone), so
    this isn't good. Also, the plane_states we need might also already be
    cleaned up, since cleanup order of state structures isn't well defined.
    
    Fix this by waiting for all CRC workers of the old state to complete
    before we start any of the cleanup work. For correct ordering and
    avoiding races, we can only flush_work after
    drm_atomic_helper_wait_for_vblanks() since we know that all subsequent
    queue_work will be for the new state. Only once that's done is
    flush_work() useful, before that we might flush the work, and then right
    after the hrtimer that simulates vblank queues it again. Every time you
    have a flush_work before cleaning up the work structure, the following
    sequence must be obeyed, or it can go wrong:
    
    1. Make sure no one else can re-queue the work anymore (in our case
    that's done by a combination of first updating output->crc_state and
    then waiting for the vblank to pass to make sure the hrtimer has noticed
    that change).
    2. flush_work()
    3. Actually clean up stuff (which isn't done here).
    
    Doing the flush_work before we even completed the output->state update,
    much less waited for the vblank to make sure that's happened, missed the
    point.
    
    Note that this is not yet race-free because of the hrtimer and crc
    worker look at the wrong state pointers, but that will be fixed in
    subsequent patches.
    
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606222751.32567-7-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 81bec95f163e..a03f361e2fe0 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -125,7 +125,7 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 	__drm_atomic_helper_crtc_destroy_state(state);
 
 	if (vkms_state) {
-		flush_work(&vkms_state->crc_work);
+		WARN_ON(work_pending(&vkms_state->crc_work));
 		kfree(vkms_state);
 	}
 }

commit fb4155fa4c0c0db488a9054502a4aef134a11c0f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 7 00:27:44 2019 +0200

    drm/vkms: Rename vkms_output.state_lock to crc_lock
    
    Plus add a comment about what it actually protects. It's very little.
    
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606222751.32567-4-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index f392fa13015b..81bec95f163e 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -29,7 +29,7 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 		/* update frame_start only if a queued vkms_crc_work_handle()
 		 * has read the data
 		 */
-		spin_lock(&output->state_lock);
+		spin_lock(&output->crc_lock);
 		if (!state->crc_pending)
 			state->frame_start = frame;
 		else
@@ -37,7 +37,7 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 					 state->frame_start, frame);
 		state->frame_end = frame;
 		state->crc_pending = true;
-		spin_unlock(&output->state_lock);
+		spin_unlock(&output->crc_lock);
 
 		ret = queue_work(output->crc_workq, &state->crc_work);
 		if (!ret)
@@ -225,7 +225,7 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
 	spin_lock_init(&vkms_out->lock);
-	spin_lock_init(&vkms_out->state_lock);
+	spin_lock_init(&vkms_out->crc_lock);
 
 	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
 	if (!vkms_out->crc_workq)

commit 18d0952a838ba559655b0cd9cf85097ad63d9bca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 7 00:27:42 2019 +0200

    drm/vkms: Fix crc worker races
    
    The issue we have is that the crc worker might fall behind. We've
    tried to handle this by tracking both the earliest frame for which it
    still needs to compute a crc, and the last one. Plus when the
    crtc_state changes, we have a new work item, which are all run in
    order due to the ordered workqueue we allocate for each vkms crtc.
    
    Trouble is there's been a few small issues in the current code:
    - we need to capture frame_end in the vblank hrtimer, not in the
      worker. The worker might run much later, and then we generate a lot
      of crc for which there's already a different worker queued up.
    - frame number might be 0, so create a new crc_pending boolean to
      track this without confusion.
    - we need to atomically grab frame_start/end and clear it, so do that
      all in one go. This is not going to create a new race, because if we
      race with the hrtimer then our work will be re-run.
    - only race that can happen is the following:
      1. worker starts
      2. hrtimer runs and updates frame_end
      3. worker grabs frame_start/end, already reading the new frame_end,
      and clears crc_pending
      4. hrtimer calls queue_work()
      5. worker completes
      6. worker gets  re-run, crc_pending is false
      Explain this case a bit better by rewording the comment.
    
    v2: Demote warning level output to debug when we fail to requeue, this
    is expected under high load when the crc worker can't quite keep up.
    
    Cc: Shayenne Moura <shayenneluzmoura@gmail.com>
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606222751.32567-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 4d11292bc6f3..f392fa13015b 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -30,13 +30,18 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 		 * has read the data
 		 */
 		spin_lock(&output->state_lock);
-		if (!state->frame_start)
+		if (!state->crc_pending)
 			state->frame_start = frame;
+		else
+			DRM_DEBUG_DRIVER("crc worker falling behind, frame_start: %llu, frame_end: %llu\n",
+					 state->frame_start, frame);
+		state->frame_end = frame;
+		state->crc_pending = true;
 		spin_unlock(&output->state_lock);
 
 		ret = queue_work(output->crc_workq, &state->crc_work);
 		if (!ret)
-			DRM_WARN("failed to queue vkms_crc_work_handle");
+			DRM_DEBUG_DRIVER("vkms_crc_work_handle already queued\n");
 	}
 
 	spin_unlock(&output->lock);

commit c936843f06ee4acfe91c2ef2909a2b46eb63c14a
Author: Oleg Vasilev <oleg.vasilev@intel.com>
Date:   Thu Jun 13 15:18:02 2019 +0300

    drm/vkms: add crc sources list
    
    Other drivers are able to list crc sources when accessing
    /sys/kernel/debug/dri/.../crtc-0/crc/control
    
    Even though VKMS now supports only 'auto' mode, it is more consistent to
    have the list available to the userspace.
    
    Signed-off-by: Oleg Vasilev <oleg.vasilev@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613121802.2193-3-oleg.vasilev@intel.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 1bbe099b7db8..4d11292bc6f3 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -147,6 +147,7 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.atomic_destroy_state   = vkms_atomic_crtc_destroy_state,
 	.enable_vblank		= vkms_enable_vblank,
 	.disable_vblank		= vkms_disable_vblank,
+	.get_crc_sources	= vkms_get_crc_sources,
 	.set_crc_source		= vkms_set_crc_source,
 	.verify_crc_source	= vkms_verify_crc_source,
 };

commit 7355965da22b8d9ebac8bce4b776399fb0bb9d32
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 6 10:44:04 2019 +0200

    drm/vkms: Forward timer right after drm_crtc_handle_vblank
    
    In
    
    commit def35e7c592616bc09be328de8795e5e624a3cf8
    Author: Shayenne Moura <shayenneluzmoura@gmail.com>
    Date:   Wed Jan 30 14:06:36 2019 -0200
    
        drm/vkms: Bugfix extra vblank frame
    
    we fixed the vblank counter to give accurate results outside of
    drm_crtc_handle_vblank, which fixed bugs around vblank timestamps
    being off-by-one and causing the vblank counter to jump when it
    shouldn't.
    
    The trouble is that this completely broke crc generation. Shayenne and
    Rodrigo tracked this down to the vblank timestamp going backwards in
    time somehow. Which then resulted in an underflow in drm_vblank.c
    code, which resulted in all kinds of things breaking really badly.
    
    The reason for this is that once we've called drm_crtc_handle_vblank
    and the hrtimer isn't forwarded yet, we're returning a vblank
    timestamp in the past. This race is really hard to hit since it's
    small, except when you enable crc generation: In that case there's a
    call to drm_crtc_accurate_vblank right in-betwen, so we're guaranteed
    to hit the bug.
    
    The fix is to roll the hrtimer forward _before_ we do the vblank
    processing (which has a side-effect of incrementing the vblank
    counter), and we always subtract one frame from the hrtimer - since
    now it's always one frame in the future.
    
    To make sure we don't hit this again also add a WARN_ON checking for
    whether our timestamp is somehow moving into the past, which is never
    should.
    
    This also aligns more with how real hw works:
    1. first all registers are updated with the new timestamp/vblank
    counter values.
    2. then an interrupt is generated
    3. kernel interrupt handler eventually fires.
    
    So doing this aligns vkms closer with what drm_vblank.c expects.
    Document this also in a comment.
    
    Cc: Shayenne Moura <shayenneluzmoura@gmail.com>
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Tested-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606084404.12014-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 7508815fac11..1bbe099b7db8 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -15,6 +15,10 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 
 	spin_lock(&output->lock);
 
+	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
+					  output->period_ns);
+	WARN_ON(ret_overrun != 1);
+
 	ret = drm_crtc_handle_vblank(crtc);
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
@@ -35,10 +39,6 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 			DRM_WARN("failed to queue vkms_crc_work_handle");
 	}
 
-	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
-					  output->period_ns);
-	WARN_ON(ret_overrun != 1);
-
 	spin_unlock(&output->lock);
 
 	return HRTIMER_RESTART;
@@ -74,11 +74,21 @@ bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
 {
 	struct vkms_device *vkmsdev = drm_device_to_vkms_device(dev);
 	struct vkms_output *output = &vkmsdev->output;
+	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
 
 	*vblank_time = output->vblank_hrtimer.node.expires;
 
-	if (!in_vblank_irq)
-		*vblank_time -= output->period_ns;
+	if (WARN_ON(*vblank_time == vblank->time))
+		return true;
+
+	/*
+	 * To prevent races we roll the hrtimer forward before we do any
+	 * interrupt processing - this is how real hw works (the interrupt is
+	 * only generated after all the vblank registers are updated) and what
+	 * the vblank core expects. Therefore we need to always correct the
+	 * timestampe by one frame.
+	 */
+	*vblank_time -= output->period_ns;
 
 	return true;
 }

commit 7a34d9c4e00376a6d91b99af97a05a2095d6d962
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri Mar 1 13:56:26 2019 +0100

    drm/vkms: Convert to using __drm_atomic_helper_crtc_reset() for reset.
    
    Convert vkms to using __drm_atomic_helper_crtc_reset(), instead of
    writing its own version. Instead of open coding destroy_state(),
    call it directly for freeing the old state.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190301125627.7285-17-maarten.lankhorst@linux.intel.com
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index bb66dbcd5e3f..7508815fac11 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -83,26 +83,6 @@ bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
 	return true;
 }
 
-static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
-{
-	struct vkms_crtc_state *vkms_state = NULL;
-
-	if (crtc->state) {
-		vkms_state = to_vkms_crtc_state(crtc->state);
-		__drm_atomic_helper_crtc_destroy_state(crtc->state);
-		kfree(vkms_state);
-		crtc->state = NULL;
-	}
-
-	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
-	if (!vkms_state)
-		return;
-	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
-
-	crtc->state = &vkms_state->base;
-	crtc->state->crtc = crtc;
-}
-
 static struct drm_crtc_state *
 vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
 {
@@ -135,6 +115,19 @@ static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 	}
 }
 
+static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
+{
+	struct vkms_crtc_state *vkms_state =
+		kzalloc(sizeof(*vkms_state), GFP_KERNEL);
+
+	if (crtc->state)
+		vkms_atomic_crtc_destroy_state(crtc, crtc->state);
+
+	__drm_atomic_helper_crtc_reset(crtc, &vkms_state->base);
+	if (vkms_state)
+		INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+}
+
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.set_config             = drm_atomic_helper_set_config,
 	.destroy                = drm_crtc_cleanup,

commit 208c6e8cff1b96eca401adbd544ac00133df9e90
Author: Kangjie Lu <kjlu@umn.edu>
Date:   Fri Mar 8 22:36:27 2019 -0600

    drm: vkms: check status of alloc_ordered_workqueue
    
    alloc_ordered_workqueue may fail and return NULL.
    The fix returns ENOMEM when it fails to avoid potential NULL
    pointer dereference.
    
    Signed-off-by: Kangjie Lu <kjlu@umn.edu>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190309043628.6078-1-kjlu@umn.edu

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 8a9aeb0a9ea8..bb66dbcd5e3f 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -219,6 +219,8 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	spin_lock_init(&vkms_out->state_lock);
 
 	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
+	if (!vkms_out->crc_workq)
+		return -ENOMEM;
 
 	return ret;
 }

commit c06de56121e3ac0f0f1f4a081c041654ffcacd62
Merge: 8d451a4b6e9f a3b22b9f11d9
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 18 13:27:15 2019 +1000

    Merge v5.0-rc7 into drm-next
    
    Backmerging for nouveau and imx that needed some fixes for next pulls.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 7fd56e0260a22c0cfaf9adb94a2427b76e239dd0
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Wed Feb 6 12:01:16 2019 -0200

    drm/vkms: Fix license inconsistent
    
    Fixes license inconsistent related to the VKMS driver and remove the
    redundant boilerplate comment.
    
    Fixes: 854502fa0a38 ("drm/vkms: Add basic CRTC initialization")
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190206140116.7qvy2lpwbcd7wds6@smtp.gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 177bbcb38306..eb56ee893761 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -1,10 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
+// SPDX-License-Identifier: GPL-2.0+
 
 #include "vkms_drv.h"
 #include <drm/drm_atomic_helper.h>

commit 09ef09b4ab95dc405ad4171ec2cd8a4ff5227108
Author: Shayenne Moura <shayenneluzmoura@gmail.com>
Date:   Wed Feb 6 18:08:13 2019 -0200

    drm/vkms: WARN when hrtimer_forward_now fails
    
    Add a warn to verify the hrtimer_forward_now return and changes
    ret_overrun from int to u64 to match the return value provided by
    hrtimer_forward_now.
    
    Signed-off-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190206200813.d5w7gjpepoeeadiy@smtp.gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 5a095610726b..734a3e197df8 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -16,7 +16,7 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 						  vblank_hrtimer);
 	struct drm_crtc *crtc = &output->crtc;
 	struct vkms_crtc_state *state = to_vkms_crtc_state(crtc->state);
-	int ret_overrun;
+	u64 ret_overrun;
 	bool ret;
 
 	spin_lock(&output->lock);
@@ -43,6 +43,8 @@ static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 
 	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
 					  output->period_ns);
+	WARN_ON(ret_overrun != 1);
+
 	spin_unlock(&output->lock);
 
 	return HRTIMER_RESTART;

commit ba420afab565bdc7b028ddd4f222260f2de7a1db
Author: Shayenne Moura <shayenneluzmoura@gmail.com>
Date:   Wed Jan 30 14:07:11 2019 -0200

    drm/vkms: Bugfix racing hrtimer vblank handle
    
    When the vblank irq happens, kernel time subsystem executes
    `vkms_vblank_simulate`. In parallel or not, it prepares all stuff
    necessary to the next vblank with arm, and it must flush these stuff
    before the next vblank irq. However, vblank counter is ahead when arm is
    executed in parallel with handle vblank.
    
    CPU 0:                                  CPU 1:
     |                                       |
    atomic_commit_tail is ongoing            |
     |                                       |
     |                                      hrtimer: vkms_vblank_simulate()
     |                                       |
     |                                      drm_crtc_handle_vblank()
     |                                       |
    drm_crtc_arm_vblank()                    |
     |                                       |
    ->get_vblank_timestamp()                 |
     |                                       |
     |                                      hrtimer_forward_now()
    
    Then, we should guarantee that the vblank interval time is correct (not
    changed) before finish the vblank handle.
    
    Fix the bug including the call to `hrtimer_forward_now()` in the same
    lock of `drm_crtc_handle_vblank()` to ensure that the timestamp update
    is correct when finish the vblank handle.
    
    Signed-off-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/e2e4b8f3a5cab7b2dba75bf1930f86b0a4ee08c9.1548856186.git.shayenneluzmoura@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 23146ff2a25b..5a095610726b 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -10,13 +10,17 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_probe_helper.h>
 
-static void _vblank_handle(struct vkms_output *output)
+static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
 {
+	struct vkms_output *output = container_of(timer, struct vkms_output,
+						  vblank_hrtimer);
 	struct drm_crtc *crtc = &output->crtc;
 	struct vkms_crtc_state *state = to_vkms_crtc_state(crtc->state);
+	int ret_overrun;
 	bool ret;
 
 	spin_lock(&output->lock);
+
 	ret = drm_crtc_handle_vblank(crtc);
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
@@ -37,19 +41,9 @@ static void _vblank_handle(struct vkms_output *output)
 			DRM_WARN("failed to queue vkms_crc_work_handle");
 	}
 
-	spin_unlock(&output->lock);
-}
-
-static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
-{
-	struct vkms_output *output = container_of(timer, struct vkms_output,
-						  vblank_hrtimer);
-	int ret_overrun;
-
-	_vblank_handle(output);
-
 	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
 					  output->period_ns);
+	spin_unlock(&output->lock);
 
 	return HRTIMER_RESTART;
 }

commit def35e7c592616bc09be328de8795e5e624a3cf8
Author: Shayenne Moura <shayenneluzmoura@gmail.com>
Date:   Wed Jan 30 14:06:36 2019 -0200

    drm/vkms: Bugfix extra vblank frame
    
    kms_flip tests are breaking on vkms when simulate vblank because vblank
    event sequence count returns one extra frame after arm vblank event to
    make a page flip.
    
    When vblank interrupt happens, userspace processes the vblank event and
    issues the next page flip command. Kernel calls queue_work to call
    commit_planes and arm the new page flip. The next vblank picks up the
    newly armed vblank event and vblank interrupt happens again.
    
    The arm and vblank event are asynchronous, then, on the next vblank, we
    receive x+2 from `get_vblank_timestamp`, instead x+1, although timestamp
    and vblank seqno matches.
    
    Function `get_vblank_timestamp` is reached by 2 ways:
    
      - from `drm_mode_page_flip_ioctl`: driver is doing one atomic
        operation to synchronize planes in the same output. There is no
        vblank simulation, the `drm_crtc_arm_vblank_event` function adds 1
        on vblank count, and the variable in_vblank_irq is false
      - from `vkms_vblank_simulate`: since the driver is doing a vblank
        simulation, the variable in_vblank_irq is true.
    
    Fix this problem subtracting one vblank period from vblank_time when
    `get_vblank_timestamp` is called from trace `drm_mode_page_flip_ioctl`,
    i.e., is not a real vblank interrupt, and getting the timestamp and
    vblank seqno when it is a real vblank interrupt.
    
    The reason for all this is that get_vblank_timestamp always supplies the
    timestamp for the next vblank event. The hrtimer is the vblank
    simulator, and it needs the correct previous value to present the next
    vblank. Since this is how hw timestamp registers work and what the
    vblank core expects.
    
    Signed-off-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/171e6e1c239cbca0c3df7183ed8acdfeeace9cf4.1548856186.git.shayenneluzmoura@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index d44bfc392491..23146ff2a25b 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -87,6 +87,9 @@ bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
 
 	*vblank_time = output->vblank_hrtimer.node.expires;
 
+	if (!in_vblank_irq)
+		*vblank_time -= output->period_ns;
+
 	return true;
 }
 

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 3c37d8c41d4a..d44bfc392491 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -8,7 +8,7 @@
 
 #include "vkms_drv.h"
 #include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
 
 static void _vblank_handle(struct vkms_output *output)
 {

commit b30b61ff6b1dc37f276cf56a8328b80086a3ffca
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sat Jan 19 01:43:43 2019 +0900

    drm/vkms: Fix flush_work() without INIT_WORK().
    
    syzbot is hitting a lockdep warning [1] because flush_work() is called
    without INIT_WORK() after kzalloc() at vkms_atomic_crtc_reset().
    
    Commit 6c234fe37c57627a ("drm/vkms: Implement CRC debugfs API") added
    INIT_WORK() to only vkms_atomic_crtc_duplicate_state() side. Assuming
    that lifecycle of crc_work is appropriately managed, fix this problem
    by adding INIT_WORK() to vkms_atomic_crtc_reset() side.
    
    [1] https://syzkaller.appspot.com/bug?id=a5954455fcfa51c29ca2ab55b203076337e1c770
    
    Reported-and-tested-by: syzbot <syzbot+12f1b031b6da017e34f8@syzkaller.appspotmail.com>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1547829823-9877-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 177bbcb38306..3c37d8c41d4a 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -104,6 +104,7 @@ static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
 	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
 	if (!vkms_state)
 		return;
+	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
 
 	crtc->state = &vkms_state->base;
 	crtc->state->crtc = crtc;

commit 0ca33adb91c0a94a29bdcecf49cd08fe24a21666
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Sep 4 00:18:17 2018 +0300

    drm/vkms: Fix race condition around accessing frame number
    
    crtc_state is accessed by both vblank_handle() and the ordered
    work_struct handle vkms_crc_work_handle() to retrieve and or update
    the frame number for computed CRC.
    
    Since work_struct can fail, add frame_end to account for missing frame
    numbers.
    
    Use (frame_[start/end]) for synchronization between hrtimer callback
    and ordered work_struct handle.
    
    This patch passes the following subtests from igt kms_pipe_crc_basic test:
    bad-source, read-crc-pipe-A, read-crc-pipe-A-frame-sequence,
    nonblocking-crc-pipe-A, nonblocking-crc-pipe-A-frame-sequence
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180903211743.GA2773@haneenDRM

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 9d0b1a325a78..177bbcb38306 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -22,8 +22,19 @@ static void _vblank_handle(struct vkms_output *output)
 		DRM_ERROR("vkms failure on handling vblank");
 
 	if (state && output->crc_enabled) {
-		state->n_frame = drm_crtc_accurate_vblank_count(crtc);
-		queue_work(output->crc_workq, &state->crc_work);
+		u64 frame = drm_crtc_accurate_vblank_count(crtc);
+
+		/* update frame_start only if a queued vkms_crc_work_handle()
+		 * has read the data
+		 */
+		spin_lock(&output->state_lock);
+		if (!state->frame_start)
+			state->frame_start = frame;
+		spin_unlock(&output->state_lock);
+
+		ret = queue_work(output->crc_workq, &state->crc_work);
+		if (!ret)
+			DRM_WARN("failed to queue vkms_crc_work_handle");
 	}
 
 	spin_unlock(&output->lock);
@@ -211,6 +222,7 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
 	spin_lock_init(&vkms_out->lock);
+	spin_lock_init(&vkms_out->state_lock);
 
 	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
 

commit af6979331da12d2db92a1fe7e1aba85ee5f4b06d
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Tue Aug 21 14:08:55 2018 +0530

    drm/vkms/crc: Implement verify_crc_source callback
    
    This patch implements "verify_crc_source" callback function for
    Virtual KMS drm driver.
    
    Changes Since V1:
    - update values_cnt in verify_crc_source
    Changes Since V2:
    - don't return early from set_crc_source to keep behavior same (Haneen)
    
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Reviewed-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180821083858.26275-2-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index bfe6e0312cc4..9d0b1a325a78 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -140,6 +140,7 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.enable_vblank		= vkms_enable_vblank,
 	.disable_vblank		= vkms_disable_vblank,
 	.set_crc_source		= vkms_set_crc_source,
+	.verify_crc_source	= vkms_verify_crc_source,
 };
 
 static void vkms_crtc_atomic_enable(struct drm_crtc *crtc,

commit 6c234fe37c57627a5baf96f552afa1fae2b67d4d
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Thu Aug 2 04:10:26 2018 +0300

    drm/vkms: Implement CRC debugfs API
    
    This patch implement the necessary functions to compute and add CRCs
    entries:
    
    - Implement the set_crc_source() callback.
    - Compute CRC using crc32 on the visible part of the framebuffer.
    - Use ordered workqueue per output to compute and add CRC at the end
      of a vblank.
    - Use appropriate synchronization methods since the CRC computation must
      be atomic wrt the generated vblank event for a given atomic update, by
      using spinlock across atomic_begin/atomic_flush to wrap the event
      handling code completely and match the flip event with the CRC.
    
    Since vkms_crc_work_handle() can sleep, spinlock can't be acquired
    while accessing vkms_output->primary_crc to compute CRC.
    To make sure the data is updated and released without conflict with
    the vkms_crc_work_handle(), the work_struct is flushed @crtc_destroy
    and the data is updated before scheduling the work handle again, as
    follow:
    
    * CRC data update:
    1- store vkms_crc_data {fb, src} per plane_state
    2- @plane_duplicate_state -> allocate vkms_crc_data
    3- during atomic commit (@atomic_update) ->
            a) copy {fb, src} to plane_state->crc_data
            b) get reference to fb,
    3- @plane_destroy_state -> a) if (fb refcount) remove reference to fb
                               b) deallocate crc_data
    
    * Atomic Commit:
    1- vkms_plane_atomic_check
    2- vkms_prepare_fb -> vmap vkms_gem_obj->vaddr
    3- atomic_begin -> hold crc spinlock
    4- atomic_plane_update -> a) update vkms_output->primary_crc
                              b) get reference to fb
    5- atomic_flush -> a) send vblank event while holding event_lock
                       b) release crc spinlock
    
    * hrtimer regular callback:
    1- hold crc spinlock
    2- drm_crtc_handle_vblank()
    3- queue vkms_crc_work_handle
    4- release crc spinlock
    
    * cleanup:
    1- @cleanup_fb ->vunmap vkms_gem_obj->vaddr
    2- @crtc_destroy -> flush work struct
    3- @plane_destroy -> a) if (fb refcount) remove reference to fb
                         b) deallocate crc_data
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    [seanpaul fixed typo in vkms_crtc s/vblamk/vblank/]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/b948327f48c3e70ab232b4a0848ee6d033b26484.1533171495.git.hamohammed.sa@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 26babb85ca77..bfe6e0312cc4 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -10,18 +10,33 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
 
-static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
+static void _vblank_handle(struct vkms_output *output)
 {
-	struct vkms_output *output = container_of(timer, struct vkms_output,
-						  vblank_hrtimer);
 	struct drm_crtc *crtc = &output->crtc;
-	int ret_overrun;
+	struct vkms_crtc_state *state = to_vkms_crtc_state(crtc->state);
 	bool ret;
 
+	spin_lock(&output->lock);
 	ret = drm_crtc_handle_vblank(crtc);
 	if (!ret)
 		DRM_ERROR("vkms failure on handling vblank");
 
+	if (state && output->crc_enabled) {
+		state->n_frame = drm_crtc_accurate_vblank_count(crtc);
+		queue_work(output->crc_workq, &state->crc_work);
+	}
+
+	spin_unlock(&output->lock);
+}
+
+static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
+{
+	struct vkms_output *output = container_of(timer, struct vkms_output,
+						  vblank_hrtimer);
+	int ret_overrun;
+
+	_vblank_handle(output);
+
 	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
 					  output->period_ns);
 
@@ -97,18 +112,22 @@ vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
 
 	__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);
 
+	INIT_WORK(&vkms_state->crc_work, vkms_crc_work_handle);
+
 	return &vkms_state->base;
 }
 
 static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
 					   struct drm_crtc_state *state)
 {
-	struct vkms_crtc_state *vkms_state;
-
-	vkms_state = to_vkms_crtc_state(state);
+	struct vkms_crtc_state *vkms_state = to_vkms_crtc_state(state);
 
 	__drm_atomic_helper_crtc_destroy_state(state);
-	kfree(vkms_state);
+
+	if (vkms_state) {
+		flush_work(&vkms_state->crc_work);
+		kfree(vkms_state);
+	}
 }
 
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
@@ -120,6 +139,7 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.atomic_destroy_state   = vkms_atomic_crtc_destroy_state,
 	.enable_vblank		= vkms_enable_vblank,
 	.disable_vblank		= vkms_disable_vblank,
+	.set_crc_source		= vkms_set_crc_source,
 };
 
 static void vkms_crtc_atomic_enable(struct drm_crtc *crtc,
@@ -134,9 +154,21 @@ static void vkms_crtc_atomic_disable(struct drm_crtc *crtc,
 	drm_crtc_vblank_off(crtc);
 }
 
+static void vkms_crtc_atomic_begin(struct drm_crtc *crtc,
+				   struct drm_crtc_state *old_crtc_state)
+{
+	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
+
+	/* This lock is held across the atomic commit to block vblank timer
+	 * from scheduling vkms_crc_work_handle until the crc_data is updated
+	 */
+	spin_lock_irq(&vkms_output->lock);
+}
+
 static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 				   struct drm_crtc_state *old_crtc_state)
 {
+	struct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);
 	unsigned long flags;
 
 	if (crtc->state->event) {
@@ -151,9 +183,12 @@ static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
 
 		crtc->state->event = NULL;
 	}
+
+	spin_unlock_irq(&vkms_output->lock);
 }
 
 static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs = {
+	.atomic_begin	= vkms_crtc_atomic_begin,
 	.atomic_flush	= vkms_crtc_atomic_flush,
 	.atomic_enable	= vkms_crtc_atomic_enable,
 	.atomic_disable	= vkms_crtc_atomic_disable,
@@ -162,6 +197,7 @@ static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs = {
 int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 		   struct drm_plane *primary, struct drm_plane *cursor)
 {
+	struct vkms_output *vkms_out = drm_crtc_to_vkms_output(crtc);
 	int ret;
 
 	ret = drm_crtc_init_with_planes(dev, crtc, primary, cursor,
@@ -173,5 +209,9 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 
 	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
 
+	spin_lock_init(&vkms_out->lock);
+
+	vkms_out->crc_workq = alloc_ordered_workqueue("vkms_crc_workq", 0);
+
 	return ret;
 }

commit dfb9f5cabfe31b8e936b725b5de8f787f7c18b0f
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Jul 24 19:31:05 2018 +0300

    drm/vkms: subclass CRTC state
    
    Subclass CRTC state struct to enable storing driver's private
    state. This patch only adds the base drm_crtc_state struct and
    the atomic functions that handle it.
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/1f3564a5a0a6c4410c5d383c86a572ddda4818a8.1532446182.git.hamohammed.sa@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index 875fca662ac0..26babb85ca77 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -64,13 +64,60 @@ bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
 	return true;
 }
 
+static void vkms_atomic_crtc_reset(struct drm_crtc *crtc)
+{
+	struct vkms_crtc_state *vkms_state = NULL;
+
+	if (crtc->state) {
+		vkms_state = to_vkms_crtc_state(crtc->state);
+		__drm_atomic_helper_crtc_destroy_state(crtc->state);
+		kfree(vkms_state);
+		crtc->state = NULL;
+	}
+
+	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
+	if (!vkms_state)
+		return;
+
+	crtc->state = &vkms_state->base;
+	crtc->state->crtc = crtc;
+}
+
+static struct drm_crtc_state *
+vkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct vkms_crtc_state *vkms_state;
+
+	if (WARN_ON(!crtc->state))
+		return NULL;
+
+	vkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);
+	if (!vkms_state)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);
+
+	return &vkms_state->base;
+}
+
+static void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,
+					   struct drm_crtc_state *state)
+{
+	struct vkms_crtc_state *vkms_state;
+
+	vkms_state = to_vkms_crtc_state(state);
+
+	__drm_atomic_helper_crtc_destroy_state(state);
+	kfree(vkms_state);
+}
+
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.set_config             = drm_atomic_helper_set_config,
 	.destroy                = drm_crtc_cleanup,
 	.page_flip              = drm_atomic_helper_page_flip,
-	.reset                  = drm_atomic_helper_crtc_reset,
-	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
-	.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,
+	.reset                  = vkms_atomic_crtc_reset,
+	.atomic_duplicate_state = vkms_atomic_crtc_duplicate_state,
+	.atomic_destroy_state   = vkms_atomic_crtc_destroy_state,
 	.enable_vblank		= vkms_enable_vblank,
 	.disable_vblank		= vkms_disable_vblank,
 };

commit 3a0709928b172a4123a76078f70e0a706265690c
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Wed Jul 11 23:02:26 2018 -0300

    drm/vkms: Add vblank events simulated by hrtimers
    
    This commit adds regular vblank events simulated through hrtimers, which
    is a feature required by VKMS to mimic real hardware. Additionally, all
    the vblank event send after pageflip is kept in the atomic_flush
    function.
    
    Changes since V1:
     - Compute the vblank timer interval per interruption
     Ville Syrjl and Daniel Vetter:
     - Removes hardcoded vblank interval to get it from user space
    
    Changes since V2:
     Chris Wilson
     - Removes unnecessary algorithm to compute the next period
     Daniel Vetter:
     - Uses drm_calc_timestamping_constants to get the vblank interval
       instead of calculating it manually
     - Adds disable_vblank helper that turns of crtc
     - Simplifies implementation by using drm_crtc_arm_vblank_event
     - Replaces the code in atomic_begin to atomic_flush
     - Removes unnecessary field in vkms_output
    
    Changes since V3:
     Daniel Vetter:
     - Squash "drm/vkms: Add atomic helpers functions" into the commit that
       handling vblank events simulated by hrtimers
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/7709bba40782ec06332d57fff337797b272581fc.1531359228.git.rodrigosiqueiramelo@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
index bf76cd39ece7..875fca662ac0 100644
--- a/drivers/gpu/drm/vkms/vkms_crtc.c
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -10,6 +10,60 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
 
+static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)
+{
+	struct vkms_output *output = container_of(timer, struct vkms_output,
+						  vblank_hrtimer);
+	struct drm_crtc *crtc = &output->crtc;
+	int ret_overrun;
+	bool ret;
+
+	ret = drm_crtc_handle_vblank(crtc);
+	if (!ret)
+		DRM_ERROR("vkms failure on handling vblank");
+
+	ret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,
+					  output->period_ns);
+
+	return HRTIMER_RESTART;
+}
+
+static int vkms_enable_vblank(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	unsigned int pipe = drm_crtc_index(crtc);
+	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
+	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
+
+	drm_calc_timestamping_constants(crtc, &crtc->mode);
+
+	hrtimer_init(&out->vblank_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	out->vblank_hrtimer.function = &vkms_vblank_simulate;
+	out->period_ns = ktime_set(0, vblank->framedur_ns);
+	hrtimer_start(&out->vblank_hrtimer, out->period_ns, HRTIMER_MODE_REL);
+
+	return 0;
+}
+
+static void vkms_disable_vblank(struct drm_crtc *crtc)
+{
+	struct vkms_output *out = drm_crtc_to_vkms_output(crtc);
+
+	hrtimer_cancel(&out->vblank_hrtimer);
+}
+
+bool vkms_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
+			       int *max_error, ktime_t *vblank_time,
+			       bool in_vblank_irq)
+{
+	struct vkms_device *vkmsdev = drm_device_to_vkms_device(dev);
+	struct vkms_output *output = &vkmsdev->output;
+
+	*vblank_time = output->vblank_hrtimer.node.expires;
+
+	return true;
+}
+
 static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.set_config             = drm_atomic_helper_set_config,
 	.destroy                = drm_crtc_cleanup,
@@ -17,6 +71,45 @@ static const struct drm_crtc_funcs vkms_crtc_funcs = {
 	.reset                  = drm_atomic_helper_crtc_reset,
 	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
 	.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank		= vkms_enable_vblank,
+	.disable_vblank		= vkms_disable_vblank,
+};
+
+static void vkms_crtc_atomic_enable(struct drm_crtc *crtc,
+				    struct drm_crtc_state *old_state)
+{
+	drm_crtc_vblank_on(crtc);
+}
+
+static void vkms_crtc_atomic_disable(struct drm_crtc *crtc,
+				     struct drm_crtc_state *old_state)
+{
+	drm_crtc_vblank_off(crtc);
+}
+
+static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,
+				   struct drm_crtc_state *old_crtc_state)
+{
+	unsigned long flags;
+
+	if (crtc->state->event) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+
+		if (drm_crtc_vblank_get(crtc) != 0)
+			drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		else
+			drm_crtc_arm_vblank_event(crtc, crtc->state->event);
+
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+
+		crtc->state->event = NULL;
+	}
+}
+
+static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs = {
+	.atomic_flush	= vkms_crtc_atomic_flush,
+	.atomic_enable	= vkms_crtc_atomic_enable,
+	.atomic_disable	= vkms_crtc_atomic_disable,
 };
 
 int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
@@ -31,5 +124,7 @@ int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
 		return ret;
 	}
 
+	drm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);
+
 	return ret;
 }

commit 854502fa0a38dc77c9e855c95d239a8fd50a9b13
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Wed May 16 20:56:21 2018 -0300

    drm/vkms: Add basic CRTC initialization
    
    This commit adds the essential infrastructure for around CRTCs which
    is composed of: a new data struct for output data information, a
    function for creating planes, and a simple encoder attached to the
    connector. Finally, due to the introduction of a new initialization
    function, connectors were moved from vkms_drv.c to vkms_display.c.
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Reviewed-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/b6e27bc6a54f5cb340658fa5969f7b48fbfbf1b7.1526514457.git.rodrigosiqueiramelo@gmail.com

diff --git a/drivers/gpu/drm/vkms/vkms_crtc.c b/drivers/gpu/drm/vkms/vkms_crtc.c
new file mode 100644
index 000000000000..bf76cd39ece7
--- /dev/null
+++ b/drivers/gpu/drm/vkms/vkms_crtc.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "vkms_drv.h"
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+
+static const struct drm_crtc_funcs vkms_crtc_funcs = {
+	.set_config             = drm_atomic_helper_set_config,
+	.destroy                = drm_crtc_cleanup,
+	.page_flip              = drm_atomic_helper_page_flip,
+	.reset                  = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,
+};
+
+int vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
+		   struct drm_plane *primary, struct drm_plane *cursor)
+{
+	int ret;
+
+	ret = drm_crtc_init_with_planes(dev, crtc, primary, cursor,
+					&vkms_crtc_funcs, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to init CRTC\n");
+		return ret;
+	}
+
+	return ret;
+}
