commit 5e2f97a93f7043f2a95caebceea1ac5f9adf8ff9
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jun 5 15:48:35 2019 +0200

    drm/sti: drop use of drmP.h
    
    Stop using the deprecated drmP.h header file.
    Replaced with relevant forwards or headers files.
    Header files sorted in all files touched.
    
    Build tested with allyesconfig, allmodconfig for a number of
    architectures.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190605134835.25112-2-sam@ravnborg.org

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 7c5a7830b6e8..5ff87a4a1c4c 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -4,6 +4,8 @@
  * Author: Vincent Abriou <vincent.abriou@st.com> for STMicroelectronics.
  */
 
+#include <drm/drm_print.h>
+
 #include "sti_awg_utils.h"
 
 #define AWG_DELAY (-5)

commit e28425702715dea9593a7d929f0bc64400c70368
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Wed Dec 6 12:29:47 2017 +0100

    gpu: drm: sti: Adopt SPDX identifiers
    
    Add SPDX identifiers to files under sti directory
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171206112947.9569-2-benjamin.gaignard@st.com

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 2da7d6866d5d..7c5a7830b6e8 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) STMicroelectronics SA 2014
  * Author: Vincent Abriou <vincent.abriou@st.com> for STMicroelectronics.
- * License terms:  GNU General Public License (GPL), version 2
  */
 
 #include "sti_awg_utils.h"

commit 4d7037708a357f5dbe9a51cc1aacf4dcb65b7192
Author: Bich Hemon <bich.hemon@st.com>
Date:   Tue Mar 15 17:11:14 2016 +0100

    drm/sti: adjust delay for AWG
    
    Compensate delay introduced by AWG IP during DE generation
    
    Signed-off-by: Bich Hemon <bich.hemon@st.com>
    Reviewed-by: Vincent ABRIOU <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index a516eb869f6f..2da7d6866d5d 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -6,6 +6,8 @@
 
 #include "sti_awg_utils.h"
 
+#define AWG_DELAY (-5)
+
 #define AWG_OPCODE_OFFSET 10
 #define AWG_MAX_ARG       0x3ff
 
@@ -125,7 +127,7 @@ static int awg_generate_line_signal(
 		val = timing->blanking_level;
 		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
 
-		val = timing->trailing_pixels - 1;
+		val = timing->trailing_pixels - 1 + AWG_DELAY;
 		ret |= awg_generate_instr(SKIP, val, 0, 0, fwparams);
 	}
 

commit b6bb679b5f807c5df002b2b9ef8fb651e23d932a
Author: Bich Hemon <bich.hemon@st.com>
Date:   Wed Feb 10 10:56:47 2016 +0100

    drm/sti: fix dvo data_enable signal
    
    Modify AWG algorithm in order to handle more than 1023 lines
    
    Signed-off-by: Bich Hemon <bich.hemon@st.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 2378b9392907..a516eb869f6f 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -7,6 +7,7 @@
 #include "sti_awg_utils.h"
 
 #define AWG_OPCODE_OFFSET 10
+#define AWG_MAX_ARG       0x3ff
 
 enum opcode {
 	SET,
@@ -67,7 +68,7 @@ static int awg_generate_instr(enum opcode opcode,
 
 			mux = 0;
 			data_enable = 0;
-			arg &= (0x3ff);
+			arg &= AWG_MAX_ARG;
 			break;
 		case REPEAT:
 		case REPLAY:
@@ -78,13 +79,13 @@ static int awg_generate_instr(enum opcode opcode,
 
 			mux = 0;
 			data_enable = 0;
-			arg &= (0x3ff);
+			arg &= AWG_MAX_ARG;
 			break;
 		case JUMP:
 			mux = 0;
 			data_enable = 0;
 			arg |= 0x40; /* for jump instruction 7th bit is 1 */
-			arg &= 0x3ff;
+			arg &= AWG_MAX_ARG;
 			break;
 		case STOP:
 			arg = 0;
@@ -112,22 +113,13 @@ static int awg_generate_instr(enum opcode opcode,
 	return 0;
 }
 
-int sti_awg_generate_code_data_enable_mode(
+static int awg_generate_line_signal(
 		struct awg_code_generation_params *fwparams,
 		struct awg_timing *timing)
 {
 	long int val;
 	int ret = 0;
 
-	if (timing->trailing_lines > 0) {
-		/* skip trailing lines */
-		val = timing->blanking_level;
-		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
-
-		val = timing->trailing_lines - 1;
-		ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
-	}
-
 	if (timing->trailing_pixels > 0) {
 		/* skip trailing pixel */
 		val = timing->blanking_level;
@@ -152,9 +144,36 @@ int sti_awg_generate_code_data_enable_mode(
 		ret |= awg_generate_instr(SET, val, 0, 0, fwparams);
 	}
 
-	/* replay the sequence as many active lines defined */
-	val = timing->active_lines - 1;
-	ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
+	return ret;
+}
+
+int sti_awg_generate_code_data_enable_mode(
+		struct awg_code_generation_params *fwparams,
+		struct awg_timing *timing)
+{
+	long int val, tmp_val;
+	int ret = 0;
+
+	if (timing->trailing_lines > 0) {
+		/* skip trailing lines */
+		val = timing->blanking_level;
+		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
+
+		val = timing->trailing_lines - 1;
+		ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
+	}
+
+	tmp_val = timing->active_lines - 1;
+
+	while (tmp_val > 0) {
+		/* generate DE signal for each line */
+		ret |= awg_generate_line_signal(fwparams, timing);
+		/* replay the sequence as many active lines defined */
+		ret |= awg_generate_instr(REPLAY,
+					  min_t(int, AWG_MAX_ARG, tmp_val),
+					  0, 0, fwparams);
+		tmp_val -= AWG_MAX_ARG;
+	}
 
 	if (timing->blanking_lines > 0) {
 		/* skip blanking lines */

commit bfbaf631bda0181e6ca47d9c049966daf6206c55
Author: Bich Hemon <bich.hemon@st.com>
Date:   Tue Jan 12 09:28:43 2016 +0100

    drm/sti: awg_utils code cleanup
    
    data_en is a local variable that doesn't need to be set as
    awg_generate_instr can be called directly with the requested value.
    
    Signed-off-by: Bich Hemon <bich.hemon@st.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 00d0698be9d3..2378b9392907 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -34,6 +34,8 @@ static int awg_generate_instr(enum opcode opcode,
 	/* skip, repeat and replay arg should not exceed 1023.
 	 * If user wants to exceed this value, the instruction should be
 	 * duplicate and arg should be adjust for each duplicated instruction.
+	 *
+	 * mux_sel is used in case of SAV/EAV synchronization.
 	 */
 
 	while (arg_tmp > 0) {
@@ -115,63 +117,52 @@ int sti_awg_generate_code_data_enable_mode(
 		struct awg_timing *timing)
 {
 	long int val;
-	long int data_en;
 	int ret = 0;
 
 	if (timing->trailing_lines > 0) {
 		/* skip trailing lines */
 		val = timing->blanking_level;
-		data_en = 0;
-		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
 
 		val = timing->trailing_lines - 1;
-		data_en = 0;
-		ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
 	}
 
 	if (timing->trailing_pixels > 0) {
 		/* skip trailing pixel */
 		val = timing->blanking_level;
-		data_en = 0;
-		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
 
 		val = timing->trailing_pixels - 1;
-		data_en = 0;
-		ret |= awg_generate_instr(SKIP, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(SKIP, val, 0, 0, fwparams);
 	}
 
 	/* set DE signal high */
 	val = timing->blanking_level;
-	data_en = 1;
 	ret |= awg_generate_instr((timing->trailing_pixels > 0) ? SET : RPLSET,
-			val, 0, data_en, fwparams);
+			val, 0, 1, fwparams);
 
 	if (timing->blanking_pixels > 0) {
 		/* skip the number of active pixel */
 		val = timing->active_pixels - 1;
-		data_en = 1;
-		ret |= awg_generate_instr(SKIP, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(SKIP, val, 0, 1, fwparams);
 
 		/* set DE signal low */
 		val = timing->blanking_level;
-		data_en = 0;
-		ret |= awg_generate_instr(SET, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(SET, val, 0, 0, fwparams);
 	}
 
 	/* replay the sequence as many active lines defined */
 	val = timing->active_lines - 1;
-	data_en = 0;
-	ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+	ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
 
 	if (timing->blanking_lines > 0) {
 		/* skip blanking lines */
 		val = timing->blanking_level;
-		data_en = 0;
-		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(RPLSET, val, 0, 0, fwparams);
 
 		val = timing->blanking_lines - 1;
-		data_en = 0;
-		ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+		ret |= awg_generate_instr(REPLAY, val, 0, 0, fwparams);
 	}
 
 	return ret;

commit cebd6fbeb2fc9e7c4f10f3656fe9f1ba863a8549
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Oct 16 15:14:55 2015 +0200

    drm/sti: remove redundant sign extensions
    
    arg is long int, so arg = (arg << 22) >> 22 makes the upper 22 bits of
    arg equal to bit 9 (or bit 41). But we then mask away all but bits 0-9, so
    this is entirely redundant.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 6029a2e3db1d..00d0698be9d3 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -65,7 +65,6 @@ static int awg_generate_instr(enum opcode opcode,
 
 			mux = 0;
 			data_enable = 0;
-			arg = (arg << 22) >> 22;
 			arg &= (0x3ff);
 			break;
 		case REPEAT:
@@ -77,14 +76,12 @@ static int awg_generate_instr(enum opcode opcode,
 
 			mux = 0;
 			data_enable = 0;
-			arg = (arg << 22) >> 22;
 			arg &= (0x3ff);
 			break;
 		case JUMP:
 			mux = 0;
 			data_enable = 0;
 			arg |= 0x40; /* for jump instruction 7th bit is 1 */
-			arg = (arg << 22) >> 22;
 			arg &= 0x3ff;
 			break;
 		case STOP:
@@ -94,7 +91,6 @@ static int awg_generate_instr(enum opcode opcode,
 		case RPTSET:
 		case RPLSET:
 		case HOLD:
-			arg = (arg << 24) >> 24;
 			arg &= (0x0ff);
 			break;
 		default:

commit 17ba9810ec4c8f95bfde516653e81d435809eb6b
Author: Vincent Abriou <vincent.abriou@st.com>
Date:   Wed Feb 4 16:54:13 2015 +0100

    drm: sti: fix static checker warning in sti_awg_utils
    
    The shift and the mask done on arg value is useless
    since arg is null.
    
    Signed-off-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
index 9fde3ee8b1a5..6029a2e3db1d 100644
--- a/drivers/gpu/drm/sti/sti_awg_utils.c
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -60,8 +60,6 @@ static int awg_generate_instr(enum opcode opcode,
 				 * pixel. So we transform SKIP into SET
 				 * instruction */
 				opcode = SET;
-				arg = (arg << 24) >> 24;
-				arg &= (0x0ff);
 				break;
 			}
 

commit f32c4c506f9b197f24d4be4ee7283bd549e3a30f
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Tue Dec 30 15:08:16 2014 +0100

    drm: sti: add DVO output connector
    
    Digital Video Out connector driver LCD panels.
    Like HDMI and HDA it create bridge, encoder and connector
    drm object.
    Add binding description.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>

diff --git a/drivers/gpu/drm/sti/sti_awg_utils.c b/drivers/gpu/drm/sti/sti_awg_utils.c
new file mode 100644
index 000000000000..9fde3ee8b1a5
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_awg_utils.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2014
+ * Author: Vincent Abriou <vincent.abriou@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "sti_awg_utils.h"
+
+#define AWG_OPCODE_OFFSET 10
+
+enum opcode {
+	SET,
+	RPTSET,
+	RPLSET,
+	SKIP,
+	STOP,
+	REPEAT,
+	REPLAY,
+	JUMP,
+	HOLD,
+};
+
+static int awg_generate_instr(enum opcode opcode,
+			      long int arg,
+			      long int mux_sel,
+			      long int data_en,
+			      struct awg_code_generation_params *fwparams)
+{
+	u32 instruction = 0;
+	u32 mux = (mux_sel << 8) & 0x1ff;
+	u32 data_enable = (data_en << 9) & 0x2ff;
+	long int arg_tmp = arg;
+
+	/* skip, repeat and replay arg should not exceed 1023.
+	 * If user wants to exceed this value, the instruction should be
+	 * duplicate and arg should be adjust for each duplicated instruction.
+	 */
+
+	while (arg_tmp > 0) {
+		arg = arg_tmp;
+		if (fwparams->instruction_offset >= AWG_MAX_INST) {
+			DRM_ERROR("too many number of instructions\n");
+			return -EINVAL;
+		}
+
+		switch (opcode) {
+		case SKIP:
+			/* leave 'arg' + 1 pixel elapsing without changing
+			 * output bus */
+			arg--; /* pixel adjustment */
+			arg_tmp--;
+
+			if (arg < 0) {
+				/* SKIP instruction not needed */
+				return 0;
+			}
+
+			if (arg == 0) {
+				/* SKIP 0 not permitted but we want to skip 1
+				 * pixel. So we transform SKIP into SET
+				 * instruction */
+				opcode = SET;
+				arg = (arg << 24) >> 24;
+				arg &= (0x0ff);
+				break;
+			}
+
+			mux = 0;
+			data_enable = 0;
+			arg = (arg << 22) >> 22;
+			arg &= (0x3ff);
+			break;
+		case REPEAT:
+		case REPLAY:
+			if (arg == 0) {
+				/* REPEAT or REPLAY instruction not needed */
+				return 0;
+			}
+
+			mux = 0;
+			data_enable = 0;
+			arg = (arg << 22) >> 22;
+			arg &= (0x3ff);
+			break;
+		case JUMP:
+			mux = 0;
+			data_enable = 0;
+			arg |= 0x40; /* for jump instruction 7th bit is 1 */
+			arg = (arg << 22) >> 22;
+			arg &= 0x3ff;
+			break;
+		case STOP:
+			arg = 0;
+			break;
+		case SET:
+		case RPTSET:
+		case RPLSET:
+		case HOLD:
+			arg = (arg << 24) >> 24;
+			arg &= (0x0ff);
+			break;
+		default:
+			DRM_ERROR("instruction %d does not exist\n", opcode);
+			return -EINVAL;
+		}
+
+		arg_tmp = arg_tmp - arg;
+
+		arg = ((arg + mux) + data_enable);
+
+		instruction = ((opcode) << AWG_OPCODE_OFFSET) | arg;
+		fwparams->ram_code[fwparams->instruction_offset] =
+			instruction & (0x3fff);
+		fwparams->instruction_offset++;
+	}
+	return 0;
+}
+
+int sti_awg_generate_code_data_enable_mode(
+		struct awg_code_generation_params *fwparams,
+		struct awg_timing *timing)
+{
+	long int val;
+	long int data_en;
+	int ret = 0;
+
+	if (timing->trailing_lines > 0) {
+		/* skip trailing lines */
+		val = timing->blanking_level;
+		data_en = 0;
+		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+
+		val = timing->trailing_lines - 1;
+		data_en = 0;
+		ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+	}
+
+	if (timing->trailing_pixels > 0) {
+		/* skip trailing pixel */
+		val = timing->blanking_level;
+		data_en = 0;
+		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+
+		val = timing->trailing_pixels - 1;
+		data_en = 0;
+		ret |= awg_generate_instr(SKIP, val, 0, data_en, fwparams);
+	}
+
+	/* set DE signal high */
+	val = timing->blanking_level;
+	data_en = 1;
+	ret |= awg_generate_instr((timing->trailing_pixels > 0) ? SET : RPLSET,
+			val, 0, data_en, fwparams);
+
+	if (timing->blanking_pixels > 0) {
+		/* skip the number of active pixel */
+		val = timing->active_pixels - 1;
+		data_en = 1;
+		ret |= awg_generate_instr(SKIP, val, 0, data_en, fwparams);
+
+		/* set DE signal low */
+		val = timing->blanking_level;
+		data_en = 0;
+		ret |= awg_generate_instr(SET, val, 0, data_en, fwparams);
+	}
+
+	/* replay the sequence as many active lines defined */
+	val = timing->active_lines - 1;
+	data_en = 0;
+	ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+
+	if (timing->blanking_lines > 0) {
+		/* skip blanking lines */
+		val = timing->blanking_level;
+		data_en = 0;
+		ret |= awg_generate_instr(RPLSET, val, 0, data_en, fwparams);
+
+		val = timing->blanking_lines - 1;
+		data_en = 0;
+		ret |= awg_generate_instr(REPLAY, val, 0, data_en, fwparams);
+	}
+
+	return ret;
+}
