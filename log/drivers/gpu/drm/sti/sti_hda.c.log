commit 54ac836b16de05c9ca2e4a910a0848c0fa1d4a0c
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Tue Mar 10 16:31:13 2020 +0300

    drm/sti: remove use of drm_debugfs functions as return values
    
    Since commit 987d65d01356 (drm: debugfs: make
    drm_debugfs_create_files() never fail), drm_debugfs_create_files() never
    fails, and should return void. This change therefore removes it uses as
    a return value in various functions across drm/sti.
    
    With these changes, the affected functions have been changed to use a void
    return value.
    
    v2: convert sti_mixer_debugfs_init() and sti_compositor_debugfs_init()
    to return void too. Also have sti_drm_dbg_init() to return 0 to avoid
    build issues.
    
    References: https://lists.freedesktop.org/archives/dri-devel/2020-February/257183.html
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200310133121.27913-10-wambui.karugax@gmail.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index f3f28d79b0e4..a1ec891eaf3a 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -367,16 +367,16 @@ static struct drm_info_list hda_debugfs_files[] = {
 	{ "hda", hda_dbg_show, 0, NULL },
 };
 
-static int hda_debugfs_init(struct sti_hda *hda, struct drm_minor *minor)
+static void hda_debugfs_init(struct sti_hda *hda, struct drm_minor *minor)
 {
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(hda_debugfs_files); i++)
 		hda_debugfs_files[i].data = hda;
 
-	return drm_debugfs_create_files(hda_debugfs_files,
-					ARRAY_SIZE(hda_debugfs_files),
-					minor->debugfs_root, minor);
+	drm_debugfs_create_files(hda_debugfs_files,
+				 ARRAY_SIZE(hda_debugfs_files),
+				 minor->debugfs_root, minor);
 }
 
 /**
@@ -643,10 +643,7 @@ static int sti_hda_late_register(struct drm_connector *connector)
 		= to_sti_hda_connector(connector);
 	struct sti_hda *hda = hda_connector->hda;
 
-	if (hda_debugfs_init(hda, hda->drm_dev->primary)) {
-		DRM_ERROR("HDA debugfs setup failed\n");
-		return -EINVAL;
-	}
+	hda_debugfs_init(hda, hda->drm_dev->primary);
 
 	return 0;
 }

commit a25b988ff83f3ca0d8f5acf855fb1717c1c61a69
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:29 2020 +0200

    drm/bridge: Extend bridge API to disable connector creation
    
    Most bridge drivers create a DRM connector to model the connector at the
    output of the bridge. This model is historical and has worked pretty
    well so far, but causes several issues:
    
    - It prevents supporting more complex display pipelines where DRM
    connector operations are split over multiple components. For instance a
    pipeline with a bridge connected to the DDC signals to read EDID data,
    and another one connected to the HPD signal to detect connection and
    disconnection, will not be possible to support through this model.
    
    - It requires every bridge driver to implement similar connector
    handling code, resulting in code duplication.
    
    - It assumes that a bridge will either be wired to a connector or to
    another bridge, but doesn't support bridges that can be used in both
    positions very well (although there is some ad-hoc support for this in
    the analogix_dp bridge driver).
    
    In order to solve these issues, ownership of the connector should be
    moved to the display controller driver (where it can be implemented
    using helpers provided by the core).
    
    Extend the bridge API to allow disabling connector creation in bridge
    drivers as a first step towards the new model. The new flags argument to
    the bridge .attach() operation allows instructing the bridge driver to
    skip creating a connector. Unconditionally set the new flags argument to
    0 for now to keep the existing behaviour, and modify all existing bridge
    drivers to return an error when connector creation is not requested as
    they don't support this feature yet.
    
    The change is based on the following semantic patch, with manual review
    and edits.
    
    @ rule1 @
    identifier funcs;
    identifier fn;
    @@
     struct drm_bridge_funcs funcs = {
            ...,
            .attach = fn
     };
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge;
    statement S, S1;
    @@
     int fn(
            struct drm_bridge *bridge
    +       , enum drm_bridge_attach_flags flags
     )
     {
            ... when != S
    +       if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
    +               DRM_ERROR("Fix bridge driver to make connector optional!");
    +               return -EINVAL;
    +       }
    +
            S1
            ...
     }
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge, flags;
    expression E1, E2, E3;
    @@
     int fn(
            struct drm_bridge *bridge,
            enum drm_bridge_attach_flags flags
     ) {
     <...
     drm_bridge_attach(E1, E2, E3
    +       , flags
     )
     ...>
     }
    
    @@
    expression E1, E2, E3;
    @@
     drm_bridge_attach(E1, E2, E3
    +       , 0
     )
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-10-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 2bb32009d117..f3f28d79b0e4 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -701,7 +701,7 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 
 	bridge->driver_private = hda;
 	bridge->funcs = &sti_hda_bridge_funcs;
-	drm_bridge_attach(encoder, bridge, NULL);
+	drm_bridge_attach(encoder, bridge, NULL, 0);
 
 	connector->encoder = encoder;
 

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 8f7bf33815fd..2bb32009d117 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -759,14 +759,14 @@ static int sti_hda_probe(struct platform_device *pdev)
 		DRM_ERROR("Invalid hda resource\n");
 		return -ENOMEM;
 	}
-	hda->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));
+	hda->regs = devm_ioremap(dev, res->start, resource_size(res));
 	if (!hda->regs)
 		return -ENOMEM;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 			"video-dacs-ctrl");
 	if (res) {
-		hda->video_dacs_ctrl = devm_ioremap_nocache(dev, res->start,
+		hda->video_dacs_ctrl = devm_ioremap(dev, res->start,
 				resource_size(res));
 		if (!hda->video_dacs_ctrl)
 			return -ENOMEM;

commit 5dec1affe0fa4c59fe02e5b5ec99c9cf8d2ca351
Author: Benjamin Gaignard <benjamin.gaignard@st.com>
Date:   Mon Sep 9 12:12:53 2019 +0200

    drm: sti: fix W=1 warnings
    
    Fix warnings when W=1.
    No code changes, only clean up in sti internal structures and functions
    descriptions.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190909101254.24191-1-benjamin.gaignard@st.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 9d3fd6370a29..8f7bf33815fd 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -231,7 +231,7 @@ static const struct sti_hda_video_config hda_supported_modes[] = {
 	 AWGi_720x480p_60, NN_720x480p_60, VID_ED}
 };
 
-/**
+/*
  * STI hd analog structure
  *
  * @dev: driver device

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 94e404f13234..9d3fd6370a29 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -12,6 +12,7 @@
 #include <linux/seq_file.h>
 
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
 #include <drm/drm_debugfs.h>
 #include <drm/drm_device.h>
 #include <drm/drm_file.h>

commit 5e2f97a93f7043f2a95caebceea1ac5f9adf8ff9
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jun 5 15:48:35 2019 +0200

    drm/sti: drop use of drmP.h
    
    Stop using the deprecated drmP.h header file.
    Replaced with relevant forwards or headers files.
    Header files sorted in all files touched.
    
    Build tested with allyesconfig, allmodconfig for a number of
    architectures.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190605134835.25112-2-sam@ravnborg.org

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index ff9256673fc8..94e404f13234 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -6,12 +6,16 @@
 
 #include <linux/clk.h>
 #include <linux/component.h>
+#include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/seq_file.h>
 
-#include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_debugfs.h>
+#include <drm/drm_device.h>
+#include <drm/drm_file.h>
+#include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
 
 /* HDformatter registers */

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index a63dd5eb7081..ff9256673fc8 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -12,7 +12,7 @@
 
 #include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
 
 /* HDformatter registers */
 #define HDA_ANA_CFG                     0x0000

commit 63f8f3badf799c8b63ff33a489886bc138ce5d09
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Apr 6 17:39:01 2018 +0300

    drm: bridge: Constify mode arguments to bridge .mode_set() operation
    
    The mode and ajusted_mode passed to the bridge .mode_set() operation
    should never be modified by the bridge (and are not in any of the
    existing bridge drivers). Make them const to make this clear.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 19b9b5ed1297..a63dd5eb7081 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -508,8 +508,8 @@ static void sti_hda_pre_enable(struct drm_bridge *bridge)
 }
 
 static void sti_hda_set_mode(struct drm_bridge *bridge,
-		struct drm_display_mode *mode,
-		struct drm_display_mode *adjusted_mode)
+			     const struct drm_display_mode *mode,
+			     const struct drm_display_mode *adjusted_mode)
 {
 	struct sti_hda *hda = bridge->driver_private;
 	u32 mode_idx;

commit 66e31a72dc38543b2d9d1ce267dc78ba9beebcfd
Author: Peter Rosin <peda@axentia.se>
Date:   Mon Aug 6 08:19:09 2018 +0200

    drm/sti: do not remove the drm_bridge that was never added
    
    Removing the drm_bridge_remove call should avoid a NULL dereference
    during list processing in drm_bridge_remove if the error path is ever
    taken.
    
    The more natural approach would perhaps be to add a drm_bridge_add,
    but there are several other bridges that never call drm_bridge_add.
    Just removing the drm_bridge_remove is the easier fix.
    
    Fixes: 84601dbdea36 ("drm: sti: rework init sequence")
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180806061910.29914-2-peda@axentia.se

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 49438337f70d..19b9b5ed1297 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -721,7 +721,6 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	return 0;
 
 err_sysfs:
-	drm_bridge_remove(bridge);
 	return -EINVAL;
 }
 

commit cde4c44d8769c1be16074c097592c46c7d64092b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:07 2018 +0200

    drm: drop _mode_ from drm_mode_connector_attach_encoder
    
    Again to align with the usual prefix of just drm_connector_. Again
    done with sed + manual fixup for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-7-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 67bbdb49fffc..49438337f70d 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -709,7 +709,7 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	drm_connector_helper_add(drm_connector,
 			&sti_hda_connector_helper_funcs);
 
-	err = drm_mode_connector_attach_encoder(drm_connector, encoder);
+	err = drm_connector_attach_encoder(drm_connector, encoder);
 	if (err) {
 		DRM_ERROR("Failed to attach a connector to a encoder\n");
 		goto err_sysfs;

commit e28425702715dea9593a7d929f0bc64400c70368
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Wed Dec 6 12:29:47 2017 +0100

    gpu: drm: sti: Adopt SPDX identifiers
    
    Add SPDX identifiers to files under sti directory
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171206112947.9569-2-benjamin.gaignard@st.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index cf65e32b5090..67bbdb49fffc 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) STMicroelectronics SA 2014
  * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
- * License terms:  GNU General Public License (GPL), version 2
  */
 
 #include <linux/clk.h>

commit 7d902c05b480cc44033dcb56e12e51b082656b42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:21 2017 +0200

    drm: Nuke drm_atomic_helper_connector_dpms
    
    It's dead code, the core handles all this directly now.
    
    The only special case is nouveau and tda988x which used one function
    for both legacy modeset code and -nv50 atomic world instead of 2
    vtables. But amounts to exactly the same.
    
    v2: Rebase over the panel/brideg refactorings in stm/ltdc.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Peter Senna Tschudin <peter.senna@collabora.com>
    Cc: Martin Donnelly <martin.donnelly@ge.com>
    Cc: Martyn Welch <martyn.welch@collabora.co.uk>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Alison Wang <alison.wang@freescale.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Marek Vasut <marex@denx.de>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Yannick Fertre <yannick.fertre@st.com>
    Cc: Philippe Cornu <philippe.cornu@st.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Cc: Jeffy Chen <jeffy.chen@rock-chips.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Yakir Yang <kuankuan.y@gmail.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Romain Perier <romain.perier@collabora.com>
    Cc: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Cc: Xinliang Liu <z.liuxinliang@hisilicon.com>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Rongrong Zou <zourongrong@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Hai Li <hali@codeaurora.org>
    Cc: "Noralf Trønnes" <noralf@tronnes.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-tegra@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: zain wang <wzz@rock-chips.com>
    Cc: Baoyou Xie <baoyou.xie@linaro.org>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-8-daniel.vetter@ffwll.ch
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Archit Taneja <architt@codeaurora.org>
    Tested-by: Philippe Cornu <philippe.cornu@st.com> (on stm)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index d6ed909d9d75..cf65e32b5090 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -647,7 +647,6 @@ static int sti_hda_late_register(struct drm_connector *connector)
 }
 
 static const struct drm_connector_funcs sti_hda_connector_funcs = {
-	.dpms = drm_atomic_helper_connector_dpms,
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.destroy = drm_connector_cleanup,
 	.reset = drm_atomic_helper_connector_reset,

commit e9635133d47b9c685bbb69c5e4a63408109d140f
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri May 5 15:00:46 2017 +0200

    drm/sti: Replace 17 seq_puts() calls by seq_putc()
    
    Single characters should be put into a sequence at several places.
    Thus use the corresponding function "seq_putc".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/5b4e2964-0742-8367-976f-678356d9347a@users.sourceforge.net

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index e3475a17eaeb..d6ed909d9d75 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -354,8 +354,7 @@ static int hda_dbg_show(struct seq_file *s, void *data)
 	hda_dbg_awg_microcode(s, hda->regs + HDA_SYNC_AWGI);
 	if (hda->video_dacs_ctrl)
 		hda_dbg_video_dacs_ctrl(s, hda->video_dacs_ctrl);
-	seq_puts(s, "\n");
-
+	seq_putc(s, '\n');
 	return 0;
 }
 

commit ecf79d15c7aa6ea4c22d6e9278eea92359bfa94a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri May 5 14:54:52 2017 +0200

    drm/sti: Reduce function calls for sequence output at five places
    
    Some data were put into a sequence by separate function calls.
    Print the same data by five single function calls instead.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1f5c5b0d-77c4-6efc-7906-cee76c33d2b0@users.sourceforge.net

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 0c0a75bc8bc3..e3475a17eaeb 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -320,8 +320,7 @@ static void hda_dbg_awg_microcode(struct seq_file *s, void __iomem *reg)
 {
 	unsigned int i;
 
-	seq_puts(s, "\n\n");
-	seq_puts(s, "  HDA AWG microcode:");
+	seq_puts(s, "\n\n  HDA AWG microcode:");
 	for (i = 0; i < AWG_MAX_INST; i++) {
 		if (i % 8 == 0)
 			seq_printf(s, "\n  %04X:", i);
@@ -333,8 +332,7 @@ static void hda_dbg_video_dacs_ctrl(struct seq_file *s, void __iomem *reg)
 {
 	u32 val = readl(reg);
 
-	seq_puts(s, "\n");
-	seq_printf(s, "\n  %-25s 0x%08X", "VIDEO_DACS_CONTROL", val);
+	seq_printf(s, "\n\n  %-25s 0x%08X", "VIDEO_DACS_CONTROL", val);
 	seq_puts(s, "\tHD DACs ");
 	seq_puts(s, val & DAC_CFG_HD_HZUVW_OFF_MASK ? "disabled" : "enabled");
 }

commit fc3706ea00303fd57cb0a47a75c956c24725e291
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Thu Jan 26 23:56:15 2017 +0100

    drm/sti: Remove drm_debugfs_remove_files() calls
    
    drm_debugfs_cleanup() now removes all minor->debugfs_list entries
    automatically, so it's not necessary to call
    drm_debugfs_remove_files(). Additionally it uses
    debugfs_remove_recursive() to clean up the debugfs files, so no need
    for adding fake drm_info_node entries.
    
    Cc: benjamin.gaignard@linaro.org
    Cc: vincent.abriou@st.com
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Tested-by: Vincent Abriou <vincent.abriou@st.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170126225621.12314-14-noralf@tronnes.org

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 66d37d78152a..0c0a75bc8bc3 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -365,13 +365,6 @@ static struct drm_info_list hda_debugfs_files[] = {
 	{ "hda", hda_dbg_show, 0, NULL },
 };
 
-static void hda_debugfs_exit(struct sti_hda *hda, struct drm_minor *minor)
-{
-	drm_debugfs_remove_files(hda_debugfs_files,
-				 ARRAY_SIZE(hda_debugfs_files),
-				 minor);
-}
-
 static int hda_debugfs_init(struct sti_hda *hda, struct drm_minor *minor)
 {
 	unsigned int i;
@@ -739,10 +732,6 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 static void sti_hda_unbind(struct device *dev,
 		struct device *master, void *data)
 {
-	struct sti_hda *hda = dev_get_drvdata(dev);
-	struct drm_device *drm_dev = data;
-
-	hda_debugfs_exit(hda, drm_dev->primary);
 }
 
 static const struct component_ops sti_hda_ops = {

commit 3bb80f249525c059572d4bc89ac77ac2e511bcbe
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 17:59:08 2016 +0200

    drm: bridge: Link encoder and bridge in core code
    
    Instead of linking encoders and bridges in every driver (and getting it
    wrong half of the time, as many drivers forget to set the drm_bridge
    encoder pointer), do so in core code. The drm_bridge_attach() function
    needs the encoder and optional previous bridge to perform that task,
    update all the callers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Stefan Agner <stefan@agner.ch> # For DCU
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # For atmel-hlcdc
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # For STI
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # For sun4i
    Acked-by: Xinliang Liu <z.liuxinliang@hisilicon.com> # For hisilicon
    Acked-by: Jyri Sarha <jsarha@ti.com> # For tilcdc
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-4-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 96f336dd0e29..66d37d78152a 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -707,9 +707,8 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 
 	bridge->driver_private = hda;
 	bridge->funcs = &sti_hda_bridge_funcs;
-	drm_bridge_attach(drm_dev, bridge);
+	drm_bridge_attach(encoder, bridge, NULL);
 
-	encoder->bridge = bridge;
 	connector->encoder = encoder;
 
 	drm_connector = (struct drm_connector *)connector;

commit 949f08862d662f17b9d2929c6afb2d4e8f5d50cb
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Nov 29 22:56:30 2016 +0200

    drm: Make the connector .detect() callback optional
    
    Many drivers (21 to be exact) create connectors that are always
    connected (for instance to an LVDS or DSI panel). Instead of forcing
    them to implement a dummy .detect() handler, make the callback optional
    and consider the connector as always connected in that case.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    [seanpaul fixed small conflict in rcar-du/rcar_du_lvdscon.c]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index e7c243f70870..96f336dd0e29 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -642,12 +642,6 @@ struct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {
 	.mode_valid = sti_hda_connector_mode_valid,
 };
 
-static enum drm_connector_status
-sti_hda_connector_detect(struct drm_connector *connector, bool force)
-{
-	return connector_status_connected;
-}
-
 static int sti_hda_late_register(struct drm_connector *connector)
 {
 	struct sti_hda_connector *hda_connector
@@ -665,7 +659,6 @@ static int sti_hda_late_register(struct drm_connector *connector)
 static const struct drm_connector_funcs sti_hda_connector_funcs = {
 	.dpms = drm_atomic_helper_connector_dpms,
 	.fill_modes = drm_helper_probe_single_connector_modes,
-	.detect = sti_hda_connector_detect,
 	.destroy = drm_connector_cleanup,
 	.reset = drm_atomic_helper_connector_reset,
 	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,

commit b4bba92dfbe23ccc4f1f6c93db88c39c10aa075a
Author: Vincent Abriou <vincent.abriou@st.com>
Date:   Tue Sep 20 15:03:33 2016 +0200

    drm/sti: remove stih415-416 platform support
    
    stih415 and stih416 platform are obsolete and no more supported.
    Only stih407 and stih410 platform are maintained.
    
    Signed-off-by: Vincent Abriou <vincent.abriou@st.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Peter Griffin <peter.griffin@linaro.org>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index a225c4d5189a..e7c243f70870 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -62,14 +62,8 @@
 #define SCALE_CTRL_CR_DFLT              0x00DB0249
 
 /* Video DACs control */
-#define VIDEO_DACS_CONTROL_MASK         0x0FFF
-#define VIDEO_DACS_CONTROL_SYSCFG2535   0x085C /* for stih416 */
-#define DAC_CFG_HD_OFF_SHIFT            5
-#define DAC_CFG_HD_OFF_MASK             (0x7 << DAC_CFG_HD_OFF_SHIFT)
-#define VIDEO_DACS_CONTROL_SYSCFG5072   0x0120 /* for stih407 */
 #define DAC_CFG_HD_HZUVW_OFF_MASK       BIT(1)
 
-
 /* Upsampler values for the alternative 2X Filter */
 #define SAMPLER_COEF_NB                 8
 #define HDA_ANA_SRC_Y_CFG_ALT_2X        0x01130000
@@ -300,28 +294,14 @@ static bool hda_get_mode_idx(struct drm_display_mode mode, int *idx)
  */
 static void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)
 {
-	u32 mask;
-
 	if (hda->video_dacs_ctrl) {
 		u32 val;
 
-		switch ((u32)hda->video_dacs_ctrl & VIDEO_DACS_CONTROL_MASK) {
-		case VIDEO_DACS_CONTROL_SYSCFG2535:
-			mask = DAC_CFG_HD_OFF_MASK;
-			break;
-		case VIDEO_DACS_CONTROL_SYSCFG5072:
-			mask = DAC_CFG_HD_HZUVW_OFF_MASK;
-			break;
-		default:
-			DRM_INFO("Video DACS control register not supported\n");
-			return;
-		}
-
 		val = readl(hda->video_dacs_ctrl);
 		if (enable)
-			val &= ~mask;
+			val &= ~DAC_CFG_HD_HZUVW_OFF_MASK;
 		else
-			val |= mask;
+			val |= DAC_CFG_HD_HZUVW_OFF_MASK;
 
 		writel(val, hda->video_dacs_ctrl);
 	}
@@ -352,24 +332,11 @@ static void hda_dbg_awg_microcode(struct seq_file *s, void __iomem *reg)
 static void hda_dbg_video_dacs_ctrl(struct seq_file *s, void __iomem *reg)
 {
 	u32 val = readl(reg);
-	u32 mask;
-
-	switch ((u32)reg & VIDEO_DACS_CONTROL_MASK) {
-	case VIDEO_DACS_CONTROL_SYSCFG2535:
-		mask = DAC_CFG_HD_OFF_MASK;
-		break;
-	case VIDEO_DACS_CONTROL_SYSCFG5072:
-		mask = DAC_CFG_HD_HZUVW_OFF_MASK;
-		break;
-	default:
-		DRM_DEBUG_DRIVER("Warning: DACS ctrl register not supported\n");
-		return;
-	}
 
 	seq_puts(s, "\n");
 	seq_printf(s, "\n  %-25s 0x%08X", "VIDEO_DACS_CONTROL", val);
 	seq_puts(s, "\tHD DACs ");
-	seq_puts(s, val & mask ? "disabled" : "enabled");
+	seq_puts(s, val & DAC_CFG_HD_HZUVW_OFF_MASK ? "disabled" : "enabled");
 }
 
 static int hda_dbg_show(struct seq_file *s, void *data)

commit 29ffa77668235bd4b39cd0bac209621a25355af2
Author: Fabien Dessenne <fabien.dessenne@st.com>
Date:   Tue Sep 6 09:41:35 2016 +0200

    drm/sti: fix debug logs
    
    Add some missing \n in logs.
    
    Signed-off-by: Fabien Dessenne <fabien.dessenne@st.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 8505569f75de..a225c4d5189a 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -313,7 +313,7 @@ static void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)
 			mask = DAC_CFG_HD_HZUVW_OFF_MASK;
 			break;
 		default:
-			DRM_INFO("Video DACS control register not supported!");
+			DRM_INFO("Video DACS control register not supported\n");
 			return;
 		}
 
@@ -362,7 +362,7 @@ static void hda_dbg_video_dacs_ctrl(struct seq_file *s, void __iomem *reg)
 		mask = DAC_CFG_HD_HZUVW_OFF_MASK;
 		break;
 	default:
-		DRM_DEBUG_DRIVER("Warning: DACS ctrl register not supported!");
+		DRM_DEBUG_DRIVER("Warning: DACS ctrl register not supported\n");
 		return;
 	}
 

commit 84601dbdea36634a300c24f93b149a251fc64fed
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Tue Jun 21 15:09:40 2016 +0200

    drm: sti: rework init sequence
    
    Use drm_dev_alloc() and drm_dev_register() instead of .load()
    To simplify init sequence only create fbdev when requested
    in output_poll_changed().
    
    version 2:
    remove call to drm_connector_unregister_all() and
    drm_dev_set_unique()
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466514580-15194-4-git-send-email-benjamin.gaignard@linaro.org

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index e31d52d73dde..8505569f75de 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -761,10 +761,6 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	drm_connector_helper_add(drm_connector,
 			&sti_hda_connector_helper_funcs);
 
-	err = drm_connector_register(drm_connector);
-	if (err)
-		goto err_connector;
-
 	err = drm_mode_connector_attach_encoder(drm_connector, encoder);
 	if (err) {
 		DRM_ERROR("Failed to attach a connector to a encoder\n");
@@ -777,9 +773,7 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	return 0;
 
 err_sysfs:
-	drm_connector_unregister(drm_connector);
-err_connector:
-	drm_connector_cleanup(drm_connector);
+	drm_bridge_remove(bridge);
 	return -EINVAL;
 }
 

commit 83af0a483ac44594620ecae10a4d708b284972e1
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Tue Jun 21 15:09:39 2016 +0200

    drm: sti: use late_register and early_unregister callbacks
    
    Make sti driver use register callback to move debugfs
    initialization out of sub-components creation.
    This will allow to convert driver .load() to
    drm_dev_alloc() and drm_dev_register().
    
    sti_compositor bring up 2 crtc but only one debugfs init is
    needed so use drm_crtc_index to do it on the first one.
    This can't be done in sti_drv because only sti_compositor have
    access to the devices.
    It is almost the same for sti_encoder which handle multiple
    encoder while one only debugfs entry is needed so add a boolean
    to avoid multiple debugfs initialization
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466514580-15194-3-git-send-email-benjamin.gaignard@linaro.org

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index dcec5a8eda59..e31d52d73dde 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -681,24 +681,29 @@ sti_hda_connector_detect(struct drm_connector *connector, bool force)
 	return connector_status_connected;
 }
 
-static void sti_hda_connector_destroy(struct drm_connector *connector)
+static int sti_hda_late_register(struct drm_connector *connector)
 {
 	struct sti_hda_connector *hda_connector
 		= to_sti_hda_connector(connector);
+	struct sti_hda *hda = hda_connector->hda;
+
+	if (hda_debugfs_init(hda, hda->drm_dev->primary)) {
+		DRM_ERROR("HDA debugfs setup failed\n");
+		return -EINVAL;
+	}
 
-	drm_connector_unregister(connector);
-	drm_connector_cleanup(connector);
-	kfree(hda_connector);
+	return 0;
 }
 
 static const struct drm_connector_funcs sti_hda_connector_funcs = {
 	.dpms = drm_atomic_helper_connector_dpms,
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.detect = sti_hda_connector_detect,
-	.destroy = sti_hda_connector_destroy,
+	.destroy = drm_connector_cleanup,
 	.reset = drm_atomic_helper_connector_reset,
 	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.late_register = sti_hda_late_register,
 };
 
 static struct drm_encoder *sti_hda_find_encoder(struct drm_device *dev)
@@ -769,9 +774,6 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	/* force to disable hd dacs at startup */
 	hda_enable_hd_dacs(hda, false);
 
-	if (hda_debugfs_init(hda, drm_dev->primary))
-		DRM_ERROR("HDA debugfs setup failed\n");
-
 	return 0;
 
 err_sysfs:

commit 9625bf55fb2deb87f4fa2f1d6d83748eff3dd9b0
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jun 7 13:48:06 2016 +0200

    drm: sti: Rely on the default ->best_encoder() behavior
    
    All outputs have a 1:1 relationship between connectors and encoders
    and the driver is relying on the atomic helpers: we can drop the custom
    ->best_encoder() implementations and let the core call
    drm_atomic_helper_best_encoder() for us.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465300095-16971-12-git-send-email-boris.brezillon@free-electrons.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 9f49c00f1a02..dcec5a8eda59 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -669,20 +669,10 @@ static int sti_hda_connector_mode_valid(struct drm_connector *connector,
 	return MODE_OK;
 }
 
-struct drm_encoder *sti_hda_best_encoder(struct drm_connector *connector)
-{
-	struct sti_hda_connector *hda_connector
-		= to_sti_hda_connector(connector);
-
-	/* Best encoder is the one associated during connector creation */
-	return hda_connector->encoder;
-}
-
 static const
 struct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {
 	.get_modes = sti_hda_connector_get_modes,
 	.mode_valid = sti_hda_connector_mode_valid,
-	.best_encoder = sti_hda_best_encoder,
 };
 
 static enum drm_connector_status

commit ac851bf14b40efde78c1c346d4ff0a8f0e2b83ce
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Mon May 30 19:53:10 2016 +0200

    drm: sti: remove useless call to dev->struct_mutex
    
    No need to protect debugfs functions with dev->struct_mutex
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464630800-30786-19-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index f7d3464cdf09..9f49c00f1a02 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -376,12 +376,6 @@ static int hda_dbg_show(struct seq_file *s, void *data)
 {
 	struct drm_info_node *node = s->private;
 	struct sti_hda *hda = (struct sti_hda *)node->info_ent->data;
-	struct drm_device *dev = node->minor->dev;
-	int ret;
-
-	ret = mutex_lock_interruptible(&dev->struct_mutex);
-	if (ret)
-		return ret;
 
 	seq_printf(s, "HD Analog: (vaddr = 0x%p)", hda->regs);
 	DBGFS_DUMP(HDA_ANA_CFG);
@@ -397,7 +391,6 @@ static int hda_dbg_show(struct seq_file *s, void *data)
 		hda_dbg_video_dacs_ctrl(s, hda->video_dacs_ctrl);
 	seq_puts(s, "\n");
 
-	mutex_unlock(&dev->struct_mutex);
 	return 0;
 }
 

commit 0f3e15618d5b2c47a14236be66ed0d3a1324a049
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 9 23:51:28 2016 +0200

    drm/sti: include linux/seq_file.h where needed
    
    The sti drm driver has a lot of debugfs interface that cause
    build errors in some configurations when seq_file.h is not
    included implicitly:
    
    drm/sti/sti_mixer.c: In function 'mixer_dbg_ctl':
    drm/sti/sti_mixer.c:88:2: error: implicit declaration of function 'seq_puts' [-Werror=implicit-function-declaration]
    drm/sti/sti_mixer.c:91:4: error: implicit declaration of function 'seq_printf' [-Werror=implicit-function-declaration]
    drm/sti/sti_gdp.c: In function 'gdp_dbg_ctl':
    drm/sti/sti_gdp.c:146:2: error: implicit declaration of function 'seq_puts' [-Werror=implicit-function-declaration]
    drm/sti/sti_gdp.c:149:4: error: implicit declaration of function 'seq_printf' [-Werror=implicit-function-declaration]
    drm/sti/sti_gdp.c: In function 'gdp_dbg_show':
    drm/sti/sti_gdp.c:208:32: error: dereferencing pointer to incomplete type 'struct seq_file'
    
    This adds an explicit #include statement in all of the affected files.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462830733-1710590-2-git-send-email-arnd@arndb.de

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index ec0d017eaf1a..f7d3464cdf09 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -8,6 +8,7 @@
 #include <linux/component.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/seq_file.h>
 
 #include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>

commit 6c84578c2c5cd5dfa2a25b52bf731dd2da5e700e
Author: Vincent Abriou <vincent.abriou@st.com>
Date:   Thu Feb 4 16:32:06 2016 +0100

    drm/sti: add debugfs entries for HDA connector
    
    Signed-off-by: Vincent Abriou <vincent.abriou@st.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 293a133ae9b1..ec0d017eaf1a 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -326,6 +326,103 @@ static void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)
 	}
 }
 
+#define DBGFS_DUMP(reg) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
+				   readl(hda->regs + reg))
+
+static void hda_dbg_cfg(struct seq_file *s, int val)
+{
+	seq_puts(s, "\tAWG ");
+	seq_puts(s, val & CFG_AWG_ASYNC_EN ? "enabled" : "disabled");
+}
+
+static void hda_dbg_awg_microcode(struct seq_file *s, void __iomem *reg)
+{
+	unsigned int i;
+
+	seq_puts(s, "\n\n");
+	seq_puts(s, "  HDA AWG microcode:");
+	for (i = 0; i < AWG_MAX_INST; i++) {
+		if (i % 8 == 0)
+			seq_printf(s, "\n  %04X:", i);
+		seq_printf(s, " %04X", readl(reg + i * 4));
+	}
+}
+
+static void hda_dbg_video_dacs_ctrl(struct seq_file *s, void __iomem *reg)
+{
+	u32 val = readl(reg);
+	u32 mask;
+
+	switch ((u32)reg & VIDEO_DACS_CONTROL_MASK) {
+	case VIDEO_DACS_CONTROL_SYSCFG2535:
+		mask = DAC_CFG_HD_OFF_MASK;
+		break;
+	case VIDEO_DACS_CONTROL_SYSCFG5072:
+		mask = DAC_CFG_HD_HZUVW_OFF_MASK;
+		break;
+	default:
+		DRM_DEBUG_DRIVER("Warning: DACS ctrl register not supported!");
+		return;
+	}
+
+	seq_puts(s, "\n");
+	seq_printf(s, "\n  %-25s 0x%08X", "VIDEO_DACS_CONTROL", val);
+	seq_puts(s, "\tHD DACs ");
+	seq_puts(s, val & mask ? "disabled" : "enabled");
+}
+
+static int hda_dbg_show(struct seq_file *s, void *data)
+{
+	struct drm_info_node *node = s->private;
+	struct sti_hda *hda = (struct sti_hda *)node->info_ent->data;
+	struct drm_device *dev = node->minor->dev;
+	int ret;
+
+	ret = mutex_lock_interruptible(&dev->struct_mutex);
+	if (ret)
+		return ret;
+
+	seq_printf(s, "HD Analog: (vaddr = 0x%p)", hda->regs);
+	DBGFS_DUMP(HDA_ANA_CFG);
+	hda_dbg_cfg(s, readl(hda->regs + HDA_ANA_CFG));
+	DBGFS_DUMP(HDA_ANA_SCALE_CTRL_Y);
+	DBGFS_DUMP(HDA_ANA_SCALE_CTRL_CB);
+	DBGFS_DUMP(HDA_ANA_SCALE_CTRL_CR);
+	DBGFS_DUMP(HDA_ANA_ANC_CTRL);
+	DBGFS_DUMP(HDA_ANA_SRC_Y_CFG);
+	DBGFS_DUMP(HDA_ANA_SRC_C_CFG);
+	hda_dbg_awg_microcode(s, hda->regs + HDA_SYNC_AWGI);
+	if (hda->video_dacs_ctrl)
+		hda_dbg_video_dacs_ctrl(s, hda->video_dacs_ctrl);
+	seq_puts(s, "\n");
+
+	mutex_unlock(&dev->struct_mutex);
+	return 0;
+}
+
+static struct drm_info_list hda_debugfs_files[] = {
+	{ "hda", hda_dbg_show, 0, NULL },
+};
+
+static void hda_debugfs_exit(struct sti_hda *hda, struct drm_minor *minor)
+{
+	drm_debugfs_remove_files(hda_debugfs_files,
+				 ARRAY_SIZE(hda_debugfs_files),
+				 minor);
+}
+
+static int hda_debugfs_init(struct sti_hda *hda, struct drm_minor *minor)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hda_debugfs_files); i++)
+		hda_debugfs_files[i].data = hda;
+
+	return drm_debugfs_create_files(hda_debugfs_files,
+					ARRAY_SIZE(hda_debugfs_files),
+					minor->debugfs_root, minor);
+}
+
 /**
  * Configure AWG, writing instructions
  *
@@ -688,6 +785,9 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 	/* force to disable hd dacs at startup */
 	hda_enable_hd_dacs(hda, false);
 
+	if (hda_debugfs_init(hda, drm_dev->primary))
+		DRM_ERROR("HDA debugfs setup failed\n");
+
 	return 0;
 
 err_sysfs:
@@ -700,7 +800,10 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 static void sti_hda_unbind(struct device *dev,
 		struct device *master, void *data)
 {
-	/* do nothing */
+	struct sti_hda *hda = dev_get_drvdata(dev);
+	struct drm_device *drm_dev = data;
+
+	hda_debugfs_exit(hda, drm_dev->primary);
 }
 
 static const struct component_ops sti_hda_ops = {

commit 9b60514d889a9914a5fc3c4b9e744a70dbeb1cfd
Author: Vincent Abriou <vincent.abriou@st.com>
Date:   Fri Feb 5 16:23:20 2016 +0100

    drm/sti: reset HD DACS when HDA connector is created
    
    Make sure the HD DACS are disabled when the HDA connector
    is created.
    
    Signed-off-by: Vincent Abriou <vincent.abriou@st.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 49cce833f2c8..293a133ae9b1 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -685,6 +685,9 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 		goto err_sysfs;
 	}
 
+	/* force to disable hd dacs at startup */
+	hda_enable_hd_dacs(hda, false);
+
 	return 0;
 
 err_sysfs:

commit d0b414216f907d38cd26810a5dfc23fe9a5c8254
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 3 23:14:15 2015 +0200

    drm/sti: Drop bogus drm_mode_sort() call
    
    sti seems confused about which mode list is used in its .get_modes()
    hook. It adds the modes to the probed_modes list (as is appropriate)
    but then for some reason it tries to sort the old mode list.
    
    Just drop the sorting since it does nothing, and let the probe helper
    do its thing. It will sort the final mode list after merging in the
    modes from the probed_modes list and validating them.
    
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449177255-9515-8-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index d735daccd458..49cce833f2c8 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -543,8 +543,6 @@ static int sti_hda_connector_get_modes(struct drm_connector *connector)
 		count++;
 	}
 
-	drm_mode_sort(&connector->modes);
-
 	return count;
 }
 

commit dcec16efd6776faca6f13ab698cb5cf031d62b66
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Sep 24 19:02:40 2015 +0200

    drm/sti: Build monolithic driver
    
    There's no use building the individual drivers as separate modules
    because they are all only useful if combined into a single DRM/KMS
    device.
    
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index be2563b3a3c2..d735daccd458 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -785,8 +785,6 @@ struct platform_driver sti_hda_driver = {
 	.remove = sti_hda_remove,
 };
 
-module_platform_driver(sti_hda_driver);
-
 MODULE_AUTHOR("Benjamin Gaignard <benjamin.gaignard@st.com>");
 MODULE_DESCRIPTION("STMicroelectronics SoC DRM driver");
 MODULE_LICENSE("GPL");

commit c5de48539cf1821180f4326c47ac1420625eef00
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Sep 2 13:44:15 2015 +0300

    drm/sti: Constify function pointer structs
    
    Moves a bunch of junk to .rodata from .data.
    
     drivers/gpu/drm/sti/sticompositor.ko:
    -.text                       12216
    +.text                       12212
    -.rodata                      1284
    +.rodata                      1400
    -.data                         488
    +.data                         372
    
     drivers/gpu/drm/sti/sti_drv.ko:
    -.rodata                      516
    +.rodata                      544
    -.data                        368
    +.data                        340
    
     drivers/gpu/drm/sti/stidvo.ko:
    -.text                       3356
    +.text                       3348
    -.rodata                      188
    +.rodata                      256
    -.data                        572
    +.data                        504
    
     drivers/gpu/drm/sti/sti_hda.ko:
    -.text                       3008
    +.text                       3004
    -.rodata                     2820
    +.rodata                     2888
    -.data                        684
    +.data                        616
    
     drivers/gpu/drm/sti/stihdmi.ko:
    -.text                        6988
    +.text                        6980
    -.rodata                      1340
    +.rodata                      1408
    -.data                         176
    +.data                         108
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 598cd78b0b16..be2563b3a3c2 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -589,7 +589,8 @@ struct drm_encoder *sti_hda_best_encoder(struct drm_connector *connector)
 	return hda_connector->encoder;
 }
 
-static struct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {
+static const
+struct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {
 	.get_modes = sti_hda_connector_get_modes,
 	.mode_valid = sti_hda_connector_mode_valid,
 	.best_encoder = sti_hda_best_encoder,
@@ -611,7 +612,7 @@ static void sti_hda_connector_destroy(struct drm_connector *connector)
 	kfree(hda_connector);
 }
 
-static struct drm_connector_funcs sti_hda_connector_funcs = {
+static const struct drm_connector_funcs sti_hda_connector_funcs = {
 	.dpms = drm_atomic_helper_connector_dpms,
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.detect = sti_hda_connector_detect,

commit de4b00b0937aba99b7099afc6ed17a81163faab3
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Thu Mar 19 13:35:16 2015 +0100

    drm: sti: convert driver to atomic modeset
    
    v1: This patch does the minimum to make sti driver use atomic helpers.
    No big bang, only adapt some functions to new call order.
    
    v2: Use dpms and page flip atomic helpers
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index a9bbb081ecad..598cd78b0b16 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -10,6 +10,7 @@
 #include <linux/platform_device.h>
 
 #include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
 
 /* HDformatter registers */
@@ -611,10 +612,13 @@ static void sti_hda_connector_destroy(struct drm_connector *connector)
 }
 
 static struct drm_connector_funcs sti_hda_connector_funcs = {
-	.dpms = drm_helper_connector_dpms,
+	.dpms = drm_atomic_helper_connector_dpms,
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.detect = sti_hda_connector_detect,
 	.destroy = sti_hda_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 };
 
 static struct drm_encoder *sti_hda_find_encoder(struct drm_device *dev)

commit 3d3f8b1f8b62c3a010976269df454baa9246fc65
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:44 2015 +0530

    drm/bridge: make bridge registration independent of drm flow
    
    Currently, third party bridge drivers(ptn3460) are dependent
    on the corresponding encoder driver init, since bridge driver
    needs a drm_device pointer to finish drm initializations.
    The encoder driver passes the drm_device pointer to the
    bridge driver. Because of this dependency, third party drivers
    like ptn3460 doesn't adhere to the driver model.
    
    In this patch, we reframe the bridge registration framework
    so that bridge initialization is split into 2 steps, and
    bridge registration happens independent of drm flow:
    --Step 1: gather all the bridge settings independent of drm and
              add the bridge onto a global list of bridges.
    --Step 2: when the encoder driver is probed, call drm_bridge_attach
              for the corresponding bridge so that the bridge receives
              drm_device pointer and continues with connector and other
              drm initializations.
    
    The old set of bridge helpers are removed, and a set of new helpers
    are added to accomplish the 2 step initialization.
    
    The bridge devices register themselves onto global list of bridges
    when they get probed by calling "drm_bridge_add".
    
    The parent encoder driver waits till the bridge is available
    in the lookup table(by calling "of_drm_find_bridge") and then
    continues with its initialization.
    
    The encoder driver should also call "drm_bridge_attach" to pass
    on the drm_device to the bridge object.
    
    drm_bridge_attach inturn calls "bridge->funcs->attach" so that
    bridge can continue with drm related initializations.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 6cf145de9b41..a9bbb081ecad 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -508,19 +508,12 @@ static void sti_hda_bridge_nope(struct drm_bridge *bridge)
 	/* do nothing */
 }
 
-static void sti_hda_brigde_destroy(struct drm_bridge *bridge)
-{
-	drm_bridge_cleanup(bridge);
-	kfree(bridge);
-}
-
 static const struct drm_bridge_funcs sti_hda_bridge_funcs = {
 	.pre_enable = sti_hda_pre_enable,
 	.enable = sti_hda_bridge_nope,
 	.disable = sti_hda_disable,
 	.post_disable = sti_hda_bridge_nope,
 	.mode_set = sti_hda_set_mode,
-	.destroy = sti_hda_brigde_destroy,
 };
 
 static int sti_hda_connector_get_modes(struct drm_connector *connector)
@@ -665,7 +658,7 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 
 	bridge->driver_private = hda;
 	bridge->funcs = &sti_hda_bridge_funcs;
-	drm_bridge_init(drm_dev, bridge);
+	drm_bridge_attach(drm_dev, bridge);
 
 	encoder->bridge = bridge;
 	connector->encoder = encoder;
@@ -694,7 +687,6 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 err_sysfs:
 	drm_connector_unregister(drm_connector);
 err_connector:
-	drm_bridge_cleanup(bridge);
 	drm_connector_cleanup(drm_connector);
 	return -EINVAL;
 }

commit b07b90fd178a4797b0454ead491b717b41046bee
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:43 2015 +0530

    drm/bridge: do not pass drm_bridge_funcs to drm_bridge_init
    
    Assign the pointer to bridge ops structure(drm_bridge_funcs) in
    the bridge driver itself, instead of passing it to drm_bridge_init.
    
    This will allow bridge driver developer to pack bridge private
    information inside the bridge object and pass only the drm-relevant
    information to drm_bridge_init.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 2ae9a9b73666..6cf145de9b41 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -664,7 +664,8 @@ static int sti_hda_bind(struct device *dev, struct device *master, void *data)
 		return -ENOMEM;
 
 	bridge->driver_private = hda;
-	drm_bridge_init(drm_dev, bridge, &sti_hda_bridge_funcs);
+	bridge->funcs = &sti_hda_bridge_funcs;
+	drm_bridge_init(drm_dev, bridge);
 
 	encoder->bridge = bridge;
 	connector->encoder = encoder;

commit 8e932cf0eb41a5a2294be76898433d1f137867be
Author: Kiran Padwal <kiran.padwal@smartplayin.com>
Date:   Tue Aug 26 12:25:24 2014 +0200

    drm: sti: Make of_device_id array const
    
    Make of_device_id array const, because all OF functions handle it as const.
    
    Signed-off-by: Kiran Padwal <kiran.padwal@smartplayin.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 2802b81cc9a2..2ae9a9b73666 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -770,7 +770,7 @@ static int sti_hda_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id hda_of_match[] = {
+static const struct of_device_id hda_of_match[] = {
 	{ .compatible = "st,stih416-hda", },
 	{ .compatible = "st,stih407-hda", },
 	{ /* end node */ }

commit 5024a2b7ae9a92b8ec97ac1507efb283778480ce
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Aug 26 12:23:52 2014 +0200

    drm: sti: hda: fix return value check in sti_hda_probe()
    
    In case of error, the function devm_ioremap_nocache() returns NULL
    pointer not ERR_PTR(). The IS_ERR() test in the return value check
    should be replaced with NULL test.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
index 72d957f81c05..2802b81cc9a2 100644
--- a/drivers/gpu/drm/sti/sti_hda.c
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -730,16 +730,16 @@ static int sti_hda_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 	hda->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));
-	if (IS_ERR(hda->regs))
-		return PTR_ERR(hda->regs);
+	if (!hda->regs)
+		return -ENOMEM;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 			"video-dacs-ctrl");
 	if (res) {
 		hda->video_dacs_ctrl = devm_ioremap_nocache(dev, res->start,
 				resource_size(res));
-		if (IS_ERR(hda->video_dacs_ctrl))
-			return PTR_ERR(hda->video_dacs_ctrl);
+		if (!hda->video_dacs_ctrl)
+			return -ENOMEM;
 	} else {
 		/* If no existing video-dacs-ctrl resource continue the probe */
 		DRM_DEBUG_DRIVER("No video-dacs-ctrl resource\n");

commit c86a5f6e1b9c84064231ec867aca281d9e8514a2
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Wed Jul 30 19:25:30 2014 +0200

    drm: sti: add HDA driver
    
    Add driver to support analog TV ouput.
    
    HDA driver is mapped on drm_bridge and drm_connector structures.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/sti/sti_hda.c b/drivers/gpu/drm/sti/sti_hda.c
new file mode 100644
index 000000000000..72d957f81c05
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_hda.c
@@ -0,0 +1,794 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2014
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+/* HDformatter registers */
+#define HDA_ANA_CFG                     0x0000
+#define HDA_ANA_SCALE_CTRL_Y            0x0004
+#define HDA_ANA_SCALE_CTRL_CB           0x0008
+#define HDA_ANA_SCALE_CTRL_CR           0x000C
+#define HDA_ANA_ANC_CTRL                0x0010
+#define HDA_ANA_SRC_Y_CFG               0x0014
+#define HDA_COEFF_Y_PH1_TAP123          0x0018
+#define HDA_COEFF_Y_PH1_TAP456          0x001C
+#define HDA_COEFF_Y_PH2_TAP123          0x0020
+#define HDA_COEFF_Y_PH2_TAP456          0x0024
+#define HDA_COEFF_Y_PH3_TAP123          0x0028
+#define HDA_COEFF_Y_PH3_TAP456          0x002C
+#define HDA_COEFF_Y_PH4_TAP123          0x0030
+#define HDA_COEFF_Y_PH4_TAP456          0x0034
+#define HDA_ANA_SRC_C_CFG               0x0040
+#define HDA_COEFF_C_PH1_TAP123          0x0044
+#define HDA_COEFF_C_PH1_TAP456          0x0048
+#define HDA_COEFF_C_PH2_TAP123          0x004C
+#define HDA_COEFF_C_PH2_TAP456          0x0050
+#define HDA_COEFF_C_PH3_TAP123          0x0054
+#define HDA_COEFF_C_PH3_TAP456          0x0058
+#define HDA_COEFF_C_PH4_TAP123          0x005C
+#define HDA_COEFF_C_PH4_TAP456          0x0060
+#define HDA_SYNC_AWGI                   0x0300
+
+/* HDA_ANA_CFG */
+#define CFG_AWG_ASYNC_EN                BIT(0)
+#define CFG_AWG_ASYNC_HSYNC_MTD         BIT(1)
+#define CFG_AWG_ASYNC_VSYNC_MTD         BIT(2)
+#define CFG_AWG_SYNC_DEL                BIT(3)
+#define CFG_AWG_FLTR_MODE_SHIFT         4
+#define CFG_AWG_FLTR_MODE_MASK          (0xF << CFG_AWG_FLTR_MODE_SHIFT)
+#define CFG_AWG_FLTR_MODE_SD            (0 << CFG_AWG_FLTR_MODE_SHIFT)
+#define CFG_AWG_FLTR_MODE_ED            (1 << CFG_AWG_FLTR_MODE_SHIFT)
+#define CFG_AWG_FLTR_MODE_HD            (2 << CFG_AWG_FLTR_MODE_SHIFT)
+#define CFG_SYNC_ON_PBPR_MASK           BIT(8)
+#define CFG_PREFILTER_EN_MASK           BIT(9)
+#define CFG_PBPR_SYNC_OFF_SHIFT         16
+#define CFG_PBPR_SYNC_OFF_MASK          (0x7FF << CFG_PBPR_SYNC_OFF_SHIFT)
+#define CFG_PBPR_SYNC_OFF_VAL           0x117 /* Voltage dependent. stiH416 */
+
+/* Default scaling values */
+#define SCALE_CTRL_Y_DFLT               0x00C50256
+#define SCALE_CTRL_CB_DFLT              0x00DB0249
+#define SCALE_CTRL_CR_DFLT              0x00DB0249
+
+/* Video DACs control */
+#define VIDEO_DACS_CONTROL_MASK         0x0FFF
+#define VIDEO_DACS_CONTROL_SYSCFG2535   0x085C /* for stih416 */
+#define DAC_CFG_HD_OFF_SHIFT            5
+#define DAC_CFG_HD_OFF_MASK             (0x7 << DAC_CFG_HD_OFF_SHIFT)
+#define VIDEO_DACS_CONTROL_SYSCFG5072   0x0120 /* for stih407 */
+#define DAC_CFG_HD_HZUVW_OFF_MASK       BIT(1)
+
+
+/* Upsampler values for the alternative 2X Filter */
+#define SAMPLER_COEF_NB                 8
+#define HDA_ANA_SRC_Y_CFG_ALT_2X        0x01130000
+static u32 coef_y_alt_2x[] = {
+	0x00FE83FB, 0x1F900401, 0x00000000, 0x00000000,
+	0x00F408F9, 0x055F7C25, 0x00000000, 0x00000000
+};
+
+#define HDA_ANA_SRC_C_CFG_ALT_2X        0x01750004
+static u32 coef_c_alt_2x[] = {
+	0x001305F7, 0x05274BD0, 0x00000000, 0x00000000,
+	0x0004907C, 0x09C80B9D, 0x00000000, 0x00000000
+};
+
+/* Upsampler values for the 4X Filter */
+#define HDA_ANA_SRC_Y_CFG_4X            0x01ED0005
+#define HDA_ANA_SRC_C_CFG_4X            0x01ED0004
+static u32 coef_yc_4x[] = {
+	0x00FC827F, 0x008FE20B, 0x00F684FC, 0x050F7C24,
+	0x00F4857C, 0x0A1F402E, 0x00FA027F, 0x0E076E1D
+};
+
+/* AWG instructions for some video modes */
+#define AWG_MAX_INST                    64
+
+/* 720p@50 */
+static u32 AWGi_720p_50[] = {
+	0x00000971, 0x00000C26, 0x0000013B, 0x00000CDA,
+	0x00000104, 0x00000E7E, 0x00000E7F, 0x0000013B,
+	0x00000D8E, 0x00000104, 0x00001804, 0x00000971,
+	0x00000C26, 0x0000003B, 0x00000FB4, 0x00000FB5,
+	0x00000104, 0x00001AE8
+};
+
+#define NN_720p_50 ARRAY_SIZE(AWGi_720p_50)
+
+/* 720p@60 */
+static u32 AWGi_720p_60[] = {
+	0x00000971, 0x00000C26, 0x0000013B, 0x00000CDA,
+	0x00000104, 0x00000E7E, 0x00000E7F, 0x0000013B,
+	0x00000C44, 0x00000104, 0x00001804, 0x00000971,
+	0x00000C26, 0x0000003B, 0x00000F0F, 0x00000F10,
+	0x00000104, 0x00001AE8
+};
+
+#define NN_720p_60 ARRAY_SIZE(AWGi_720p_60)
+
+/* 1080p@30 */
+static u32 AWGi_1080p_30[] = {
+	0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,
+	0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,
+	0x00000C2A, 0x00000104, 0x00001804, 0x00000971,
+	0x00000C2A, 0x0000003B, 0x00000EBE, 0x00000EBF,
+	0x00000EBF, 0x00000104, 0x00001A2F, 0x00001C4B,
+	0x00001C52
+};
+
+#define NN_1080p_30 ARRAY_SIZE(AWGi_1080p_30)
+
+/* 1080p@25 */
+static u32 AWGi_1080p_25[] = {
+	0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,
+	0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,
+	0x00000DE2, 0x00000104, 0x00001804, 0x00000971,
+	0x00000C2A, 0x0000003B, 0x00000F51, 0x00000F51,
+	0x00000F52, 0x00000104, 0x00001A2F, 0x00001C4B,
+	0x00001C52
+};
+
+#define NN_1080p_25 ARRAY_SIZE(AWGi_1080p_25)
+
+/* 1080p@24 */
+static u32 AWGi_1080p_24[] = {
+	0x00000971, 0x00000C2A, 0x0000013B, 0x00000C56,
+	0x00000104, 0x00000FDC, 0x00000FDD, 0x0000013B,
+	0x00000E50, 0x00000104, 0x00001804, 0x00000971,
+	0x00000C2A, 0x0000003B, 0x00000F76, 0x00000F76,
+	0x00000F76, 0x00000104, 0x00001A2F, 0x00001C4B,
+	0x00001C52
+};
+
+#define NN_1080p_24 ARRAY_SIZE(AWGi_1080p_24)
+
+/* 720x480p@60 */
+static u32 AWGi_720x480p_60[] = {
+	0x00000904, 0x00000F18, 0x0000013B, 0x00001805,
+	0x00000904, 0x00000C3D, 0x0000003B, 0x00001A06
+};
+
+#define NN_720x480p_60 ARRAY_SIZE(AWGi_720x480p_60)
+
+/* Video mode category */
+enum sti_hda_vid_cat {
+	VID_SD,
+	VID_ED,
+	VID_HD_74M,
+	VID_HD_148M
+};
+
+struct sti_hda_video_config {
+	struct drm_display_mode mode;
+	u32 *awg_instr;
+	int nb_instr;
+	enum sti_hda_vid_cat vid_cat;
+};
+
+/* HD analog supported modes
+ * Interlaced modes may be added when supported by the whole display chain
+ */
+static const struct sti_hda_video_config hda_supported_modes[] = {
+	/* 1080p30 74.250Mhz */
+	{{DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_1080p_30, NN_1080p_30, VID_HD_74M},
+	/* 1080p30 74.176Mhz */
+	{{DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74176, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_1080p_30, NN_1080p_30, VID_HD_74M},
+	/* 1080p24 74.250Mhz */
+	{{DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_1080p_24, NN_1080p_24, VID_HD_74M},
+	/* 1080p24 74.176Mhz */
+	{{DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74176, 1920, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_1080p_24, NN_1080p_24, VID_HD_74M},
+	/* 1080p25 74.250Mhz */
+	{{DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_1080p_25, NN_1080p_25, VID_HD_74M},
+	/* 720p60 74.250Mhz */
+	{{DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_720p_60, NN_720p_60, VID_HD_74M},
+	/* 720p60 74.176Mhz */
+	{{DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74176, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_720p_60, NN_720p_60, VID_HD_74M},
+	/* 720p50 74.250Mhz */
+	{{DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC)},
+	 AWGi_720p_50, NN_720p_50, VID_HD_74M},
+	/* 720x480p60 27.027Mhz */
+	{{DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27027, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC)},
+	 AWGi_720x480p_60, NN_720x480p_60, VID_ED},
+	/* 720x480p60 27.000Mhz */
+	{{DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC)},
+	 AWGi_720x480p_60, NN_720x480p_60, VID_ED}
+};
+
+/**
+ * STI hd analog structure
+ *
+ * @dev: driver device
+ * @drm_dev: pointer to drm device
+ * @mode: current display mode selected
+ * @regs: HD analog register
+ * @video_dacs_ctrl: video DACS control register
+ * @enabled: true if HD analog is enabled else false
+ */
+struct sti_hda {
+	struct device dev;
+	struct drm_device *drm_dev;
+	struct drm_display_mode mode;
+	void __iomem *regs;
+	void __iomem *video_dacs_ctrl;
+	struct clk *clk_pix;
+	struct clk *clk_hddac;
+	bool enabled;
+};
+
+struct sti_hda_connector {
+	struct drm_connector drm_connector;
+	struct drm_encoder *encoder;
+	struct sti_hda *hda;
+};
+
+#define to_sti_hda_connector(x) \
+	container_of(x, struct sti_hda_connector, drm_connector)
+
+static u32 hda_read(struct sti_hda *hda, int offset)
+{
+	return readl(hda->regs + offset);
+}
+
+static void hda_write(struct sti_hda *hda, u32 val, int offset)
+{
+	writel(val, hda->regs + offset);
+}
+
+/**
+ * Search for a video mode in the supported modes table
+ *
+ * @mode: mode being searched
+ * @idx: index of the found mode
+ *
+ * Return true if mode is found
+ */
+static bool hda_get_mode_idx(struct drm_display_mode mode, int *idx)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++)
+		if (drm_mode_equal(&hda_supported_modes[i].mode, &mode)) {
+			*idx = i;
+			return true;
+		}
+	return false;
+}
+
+/**
+ * Enable the HD DACS
+ *
+ * @hda: pointer to HD analog structure
+ * @enable: true if HD DACS need to be enabled, else false
+ */
+static void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)
+{
+	u32 mask;
+
+	if (hda->video_dacs_ctrl) {
+		u32 val;
+
+		switch ((u32)hda->video_dacs_ctrl & VIDEO_DACS_CONTROL_MASK) {
+		case VIDEO_DACS_CONTROL_SYSCFG2535:
+			mask = DAC_CFG_HD_OFF_MASK;
+			break;
+		case VIDEO_DACS_CONTROL_SYSCFG5072:
+			mask = DAC_CFG_HD_HZUVW_OFF_MASK;
+			break;
+		default:
+			DRM_INFO("Video DACS control register not supported!");
+			return;
+		}
+
+		val = readl(hda->video_dacs_ctrl);
+		if (enable)
+			val &= ~mask;
+		else
+			val |= mask;
+
+		writel(val, hda->video_dacs_ctrl);
+	}
+}
+
+/**
+ * Configure AWG, writing instructions
+ *
+ * @hda: pointer to HD analog structure
+ * @awg_instr: pointer to AWG instructions table
+ * @nb: nb of AWG instructions
+ */
+static void sti_hda_configure_awg(struct sti_hda *hda, u32 *awg_instr, int nb)
+{
+	unsigned int i;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	for (i = 0; i < nb; i++)
+		hda_write(hda, awg_instr[i], HDA_SYNC_AWGI + i * 4);
+	for (i = nb; i < AWG_MAX_INST; i++)
+		hda_write(hda, 0, HDA_SYNC_AWGI + i * 4);
+}
+
+static void sti_hda_disable(struct drm_bridge *bridge)
+{
+	struct sti_hda *hda = bridge->driver_private;
+	u32 val;
+
+	if (!hda->enabled)
+		return;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Disable HD DAC and AWG */
+	val = hda_read(hda, HDA_ANA_CFG);
+	val &= ~CFG_AWG_ASYNC_EN;
+	hda_write(hda, val, HDA_ANA_CFG);
+	hda_write(hda, 0, HDA_ANA_ANC_CTRL);
+
+	hda_enable_hd_dacs(hda, false);
+
+	/* Disable/unprepare hda clock */
+	clk_disable_unprepare(hda->clk_hddac);
+	clk_disable_unprepare(hda->clk_pix);
+
+	hda->enabled = false;
+}
+
+static void sti_hda_pre_enable(struct drm_bridge *bridge)
+{
+	struct sti_hda *hda = bridge->driver_private;
+	u32 val, i, mode_idx;
+	u32 src_filter_y, src_filter_c;
+	u32 *coef_y, *coef_c;
+	u32 filter_mode;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (hda->enabled)
+		return;
+
+	/* Prepare/enable clocks */
+	if (clk_prepare_enable(hda->clk_pix))
+		DRM_ERROR("Failed to prepare/enable hda_pix clk\n");
+	if (clk_prepare_enable(hda->clk_hddac))
+		DRM_ERROR("Failed to prepare/enable hda_hddac clk\n");
+
+	if (!hda_get_mode_idx(hda->mode, &mode_idx)) {
+		DRM_ERROR("Undefined mode\n");
+		return;
+	}
+
+	switch (hda_supported_modes[mode_idx].vid_cat) {
+	case VID_HD_148M:
+		DRM_ERROR("Beyond HD analog capabilities\n");
+		return;
+	case VID_HD_74M:
+		/* HD use alternate 2x filter */
+		filter_mode = CFG_AWG_FLTR_MODE_HD;
+		src_filter_y = HDA_ANA_SRC_Y_CFG_ALT_2X;
+		src_filter_c = HDA_ANA_SRC_C_CFG_ALT_2X;
+		coef_y = coef_y_alt_2x;
+		coef_c = coef_c_alt_2x;
+		break;
+	case VID_ED:
+		/* ED uses 4x filter */
+		filter_mode = CFG_AWG_FLTR_MODE_ED;
+		src_filter_y = HDA_ANA_SRC_Y_CFG_4X;
+		src_filter_c = HDA_ANA_SRC_C_CFG_4X;
+		coef_y = coef_yc_4x;
+		coef_c = coef_yc_4x;
+		break;
+	case VID_SD:
+		DRM_ERROR("Not supported\n");
+		return;
+	default:
+		DRM_ERROR("Undefined resolution\n");
+		return;
+	}
+	DRM_DEBUG_DRIVER("Using HDA mode #%d\n", mode_idx);
+
+	/* Enable HD Video DACs */
+	hda_enable_hd_dacs(hda, true);
+
+	/* Configure scaler */
+	hda_write(hda, SCALE_CTRL_Y_DFLT, HDA_ANA_SCALE_CTRL_Y);
+	hda_write(hda, SCALE_CTRL_CB_DFLT, HDA_ANA_SCALE_CTRL_CB);
+	hda_write(hda, SCALE_CTRL_CR_DFLT, HDA_ANA_SCALE_CTRL_CR);
+
+	/* Configure sampler */
+	hda_write(hda , src_filter_y, HDA_ANA_SRC_Y_CFG);
+	hda_write(hda, src_filter_c,  HDA_ANA_SRC_C_CFG);
+	for (i = 0; i < SAMPLER_COEF_NB; i++) {
+		hda_write(hda, coef_y[i], HDA_COEFF_Y_PH1_TAP123 + i * 4);
+		hda_write(hda, coef_c[i], HDA_COEFF_C_PH1_TAP123 + i * 4);
+	}
+
+	/* Configure main HDFormatter */
+	val = 0;
+	val |= (hda->mode.flags & DRM_MODE_FLAG_INTERLACE) ?
+	    0 : CFG_AWG_ASYNC_VSYNC_MTD;
+	val |= (CFG_PBPR_SYNC_OFF_VAL << CFG_PBPR_SYNC_OFF_SHIFT);
+	val |= filter_mode;
+	hda_write(hda, val, HDA_ANA_CFG);
+
+	/* Configure AWG */
+	sti_hda_configure_awg(hda, hda_supported_modes[mode_idx].awg_instr,
+			      hda_supported_modes[mode_idx].nb_instr);
+
+	/* Enable AWG */
+	val = hda_read(hda, HDA_ANA_CFG);
+	val |= CFG_AWG_ASYNC_EN;
+	hda_write(hda, val, HDA_ANA_CFG);
+
+	hda->enabled = true;
+}
+
+static void sti_hda_set_mode(struct drm_bridge *bridge,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	struct sti_hda *hda = bridge->driver_private;
+	u32 mode_idx;
+	int hddac_rate;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	memcpy(&hda->mode, mode, sizeof(struct drm_display_mode));
+
+	if (!hda_get_mode_idx(hda->mode, &mode_idx)) {
+		DRM_ERROR("Undefined mode\n");
+		return;
+	}
+
+	switch (hda_supported_modes[mode_idx].vid_cat) {
+	case VID_HD_74M:
+		/* HD use alternate 2x filter */
+		hddac_rate = mode->clock * 1000 * 2;
+		break;
+	case VID_ED:
+		/* ED uses 4x filter */
+		hddac_rate = mode->clock * 1000 * 4;
+		break;
+	default:
+		DRM_ERROR("Undefined mode\n");
+		return;
+	}
+
+	/* HD DAC = 148.5Mhz or 108 Mhz */
+	ret = clk_set_rate(hda->clk_hddac, hddac_rate);
+	if (ret < 0)
+		DRM_ERROR("Cannot set rate (%dHz) for hda_hddac clk\n",
+			  hddac_rate);
+
+	/* HDformatter clock = compositor clock */
+	ret = clk_set_rate(hda->clk_pix, mode->clock * 1000);
+	if (ret < 0)
+		DRM_ERROR("Cannot set rate (%dHz) for hda_pix clk\n",
+			  mode->clock * 1000);
+}
+
+static void sti_hda_bridge_nope(struct drm_bridge *bridge)
+{
+	/* do nothing */
+}
+
+static void sti_hda_brigde_destroy(struct drm_bridge *bridge)
+{
+	drm_bridge_cleanup(bridge);
+	kfree(bridge);
+}
+
+static const struct drm_bridge_funcs sti_hda_bridge_funcs = {
+	.pre_enable = sti_hda_pre_enable,
+	.enable = sti_hda_bridge_nope,
+	.disable = sti_hda_disable,
+	.post_disable = sti_hda_bridge_nope,
+	.mode_set = sti_hda_set_mode,
+	.destroy = sti_hda_brigde_destroy,
+};
+
+static int sti_hda_connector_get_modes(struct drm_connector *connector)
+{
+	unsigned int i;
+	int count = 0;
+	struct sti_hda_connector *hda_connector
+		= to_sti_hda_connector(connector);
+	struct sti_hda *hda = hda_connector->hda;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	for (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++) {
+		struct drm_display_mode *mode =
+			drm_mode_duplicate(hda->drm_dev,
+					&hda_supported_modes[i].mode);
+		if (!mode)
+			continue;
+		mode->vrefresh = drm_mode_vrefresh(mode);
+
+		/* the first mode is the preferred mode */
+		if (i == 0)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_probed_add(connector, mode);
+		count++;
+	}
+
+	drm_mode_sort(&connector->modes);
+
+	return count;
+}
+
+#define CLK_TOLERANCE_HZ 50
+
+static int sti_hda_connector_mode_valid(struct drm_connector *connector,
+					struct drm_display_mode *mode)
+{
+	int target = mode->clock * 1000;
+	int target_min = target - CLK_TOLERANCE_HZ;
+	int target_max = target + CLK_TOLERANCE_HZ;
+	int result;
+	int idx;
+	struct sti_hda_connector *hda_connector
+		= to_sti_hda_connector(connector);
+	struct sti_hda *hda = hda_connector->hda;
+
+	if (!hda_get_mode_idx(*mode, &idx)) {
+		return MODE_BAD;
+	} else {
+		result = clk_round_rate(hda->clk_pix, target);
+
+		DRM_DEBUG_DRIVER("target rate = %d => available rate = %d\n",
+				 target, result);
+
+		if ((result < target_min) || (result > target_max)) {
+			DRM_DEBUG_DRIVER("hda pixclk=%d not supported\n",
+					 target);
+			return MODE_BAD;
+		}
+	}
+
+	return MODE_OK;
+}
+
+struct drm_encoder *sti_hda_best_encoder(struct drm_connector *connector)
+{
+	struct sti_hda_connector *hda_connector
+		= to_sti_hda_connector(connector);
+
+	/* Best encoder is the one associated during connector creation */
+	return hda_connector->encoder;
+}
+
+static struct drm_connector_helper_funcs sti_hda_connector_helper_funcs = {
+	.get_modes = sti_hda_connector_get_modes,
+	.mode_valid = sti_hda_connector_mode_valid,
+	.best_encoder = sti_hda_best_encoder,
+};
+
+static enum drm_connector_status
+sti_hda_connector_detect(struct drm_connector *connector, bool force)
+{
+	return connector_status_connected;
+}
+
+static void sti_hda_connector_destroy(struct drm_connector *connector)
+{
+	struct sti_hda_connector *hda_connector
+		= to_sti_hda_connector(connector);
+
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+	kfree(hda_connector);
+}
+
+static struct drm_connector_funcs sti_hda_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = sti_hda_connector_detect,
+	.destroy = sti_hda_connector_destroy,
+};
+
+static struct drm_encoder *sti_hda_find_encoder(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (encoder->encoder_type == DRM_MODE_ENCODER_DAC)
+			return encoder;
+	}
+
+	return NULL;
+}
+
+static int sti_hda_bind(struct device *dev, struct device *master, void *data)
+{
+	struct sti_hda *hda = dev_get_drvdata(dev);
+	struct drm_device *drm_dev = data;
+	struct drm_encoder *encoder;
+	struct sti_hda_connector *connector;
+	struct drm_connector *drm_connector;
+	struct drm_bridge *bridge;
+	int err;
+
+	/* Set the drm device handle */
+	hda->drm_dev = drm_dev;
+
+	encoder = sti_hda_find_encoder(drm_dev);
+	if (!encoder)
+		return -ENOMEM;
+
+	connector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);
+	if (!connector)
+		return -ENOMEM;
+
+	connector->hda = hda;
+
+		bridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);
+	if (!bridge)
+		return -ENOMEM;
+
+	bridge->driver_private = hda;
+	drm_bridge_init(drm_dev, bridge, &sti_hda_bridge_funcs);
+
+	encoder->bridge = bridge;
+	connector->encoder = encoder;
+
+	drm_connector = (struct drm_connector *)connector;
+
+	drm_connector->polled = DRM_CONNECTOR_POLL_HPD;
+
+	drm_connector_init(drm_dev, drm_connector,
+			&sti_hda_connector_funcs, DRM_MODE_CONNECTOR_Component);
+	drm_connector_helper_add(drm_connector,
+			&sti_hda_connector_helper_funcs);
+
+	err = drm_connector_register(drm_connector);
+	if (err)
+		goto err_connector;
+
+	err = drm_mode_connector_attach_encoder(drm_connector, encoder);
+	if (err) {
+		DRM_ERROR("Failed to attach a connector to a encoder\n");
+		goto err_sysfs;
+	}
+
+	return 0;
+
+err_sysfs:
+	drm_connector_unregister(drm_connector);
+err_connector:
+	drm_bridge_cleanup(bridge);
+	drm_connector_cleanup(drm_connector);
+	return -EINVAL;
+}
+
+static void sti_hda_unbind(struct device *dev,
+		struct device *master, void *data)
+{
+	/* do nothing */
+}
+
+static const struct component_ops sti_hda_ops = {
+	.bind = sti_hda_bind,
+	.unbind = sti_hda_unbind,
+};
+
+static int sti_hda_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sti_hda *hda;
+	struct resource *res;
+
+	DRM_INFO("%s\n", __func__);
+
+	hda = devm_kzalloc(dev, sizeof(*hda), GFP_KERNEL);
+	if (!hda)
+		return -ENOMEM;
+
+	hda->dev = pdev->dev;
+
+	/* Get resources */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hda-reg");
+	if (!res) {
+		DRM_ERROR("Invalid hda resource\n");
+		return -ENOMEM;
+	}
+	hda->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));
+	if (IS_ERR(hda->regs))
+		return PTR_ERR(hda->regs);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+			"video-dacs-ctrl");
+	if (res) {
+		hda->video_dacs_ctrl = devm_ioremap_nocache(dev, res->start,
+				resource_size(res));
+		if (IS_ERR(hda->video_dacs_ctrl))
+			return PTR_ERR(hda->video_dacs_ctrl);
+	} else {
+		/* If no existing video-dacs-ctrl resource continue the probe */
+		DRM_DEBUG_DRIVER("No video-dacs-ctrl resource\n");
+		hda->video_dacs_ctrl = NULL;
+	}
+
+	/* Get clock resources */
+	hda->clk_pix = devm_clk_get(dev, "pix");
+	if (IS_ERR(hda->clk_pix)) {
+		DRM_ERROR("Cannot get hda_pix clock\n");
+		return PTR_ERR(hda->clk_pix);
+	}
+
+	hda->clk_hddac = devm_clk_get(dev, "hddac");
+	if (IS_ERR(hda->clk_hddac)) {
+		DRM_ERROR("Cannot get hda_hddac clock\n");
+		return PTR_ERR(hda->clk_hddac);
+	}
+
+	platform_set_drvdata(pdev, hda);
+
+	return component_add(&pdev->dev, &sti_hda_ops);
+}
+
+static int sti_hda_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &sti_hda_ops);
+	return 0;
+}
+
+static struct of_device_id hda_of_match[] = {
+	{ .compatible = "st,stih416-hda", },
+	{ .compatible = "st,stih407-hda", },
+	{ /* end node */ }
+};
+MODULE_DEVICE_TABLE(of, hda_of_match);
+
+struct platform_driver sti_hda_driver = {
+	.driver = {
+		.name = "sti-hda",
+		.owner = THIS_MODULE,
+		.of_match_table = hda_of_match,
+	},
+	.probe = sti_hda_probe,
+	.remove = sti_hda_remove,
+};
+
+module_platform_driver(sti_hda_driver);
+
+MODULE_AUTHOR("Benjamin Gaignard <benjamin.gaignard@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics SoC DRM driver");
+MODULE_LICENSE("GPL");
