commit 3cb6d8e5cf9811a62e27f366fd1c05f90310a8fd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 21 22:38:35 2019 +0200

    drm/crc: Actually allow to change the crc source
    
    Oops.
    
    Fixes: 9edbf1fa600a ("drm: Add API for capturing frame CRCs")
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Emil Velikov <emil.velikov@collabora.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190821203835.18314-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index e22b812c4b80..5d67a41f7c3a 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -372,7 +372,7 @@ void drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
 
 	crc_ent = debugfs_create_dir("crc", crtc->debugfs_entry);
 
-	debugfs_create_file("control", S_IRUGO, crc_ent, crtc,
+	debugfs_create_file("control", S_IRUGO | S_IWUSR, crc_ent, crtc,
 			    &drm_crtc_crc_control_fops);
 	debugfs_create_file("data", S_IRUGO, crc_ent, crtc,
 			    &drm_crtc_crc_data_fops);

commit 292f3e496be0cac933dfa86e9d0bea5d96224c14
Author: Dingchen Zhang <dingchen.zhang@amd.com>
Date:   Fri Jul 26 13:37:43 2019 -0400

    drm: Set crc->opened to false before setting crc source to NULL.
    
    to terminate the while-loop in drm_dp_aux_crc_work when
    drm_dp_start/stop_crc are called in the hook to set crc source.
    
    v3: set crc->opened to false without checking (Nick)
    v2: Move spin_lock around entire crc->opened use (Daniel)
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Harry Wentland <Harry.Wentland@amd.com>
    Cc: Nick Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Dingchen Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190726173743.11641-1-dingchen.zhang@amd.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 2ece2957da1a..e22b812c4b80 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -258,6 +258,11 @@ static int crtc_crc_release(struct inode *inode, struct file *filep)
 	struct drm_crtc *crtc = filep->f_inode->i_private;
 	struct drm_crtc_crc *crc = &crtc->crc;
 
+	/* terminate the infinite while loop if 'drm_dp_aux_crc_work' running */
+	spin_lock_irq(&crc->lock);
+	crc->opened = false;
+	spin_unlock_irq(&crc->lock);
+
 	crtc->funcs->set_crc_source(crtc, NULL);
 
 	spin_lock_irq(&crc->lock);

commit 72a848f5c46bab4c921edc9cbffd1ab273b2be17
Author: Dingchen Zhang <dingchen.zhang@amd.com>
Date:   Mon Jun 10 09:47:51 2019 -0400

    drm: remove the newline for CRC source name.
    
    userspace may transfer a newline, and this terminating newline
    is replaced by a '\0' to avoid followup issues.
    
    'len-1' is the index to replace the newline of CRC source name.
    
    v3: typo fix (Sam)
    
    v2: update patch subject, body and format. (Sam)
    
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Harry Wentland <Harry.Wentland@amd.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Dingchen Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190610134751.14356-1-dingchen.zhang@amd.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index ca3c55c6b815..2ece2957da1a 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -140,8 +140,8 @@ static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
 	if (IS_ERR(source))
 		return PTR_ERR(source);
 
-	if (source[len] == '\n')
-		source[len] = '\0';
+	if (source[len - 1] == '\n')
+		source[len - 1] = '\0';
 
 	ret = crtc->funcs->verify_crc_source(crtc, source, &values_cnt);
 	if (ret)

commit 1ab2a99edb374732f429282e3e8f89df1b0ceed2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Jul 10 15:51:43 2019 +0300

    drm: Fix return type of crc .poll()
    
    Sparse compains:
    ../drivers/gpu/drm/drm_debugfs_crc.c:350:17: warning: incorrect type in initializer (different base types)
    ../drivers/gpu/drm/drm_debugfs_crc.c:350:17:    expected restricted __poll_t ( *poll )( ... )
    ../drivers/gpu/drm/drm_debugfs_crc.c:350:17:    got unsigned int ( * )( ... )
    
    Change the .poll() return type to __poll_t to silence it.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190710125143.9965-5-ville.syrjala@linux.intel.com
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index be1b7ba92ffe..ca3c55c6b815 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -334,19 +334,17 @@ static ssize_t crtc_crc_read(struct file *filep, char __user *user_buf,
 	return LINE_LEN(crc->values_cnt);
 }
 
-static unsigned int crtc_crc_poll(struct file *file, poll_table *wait)
+static __poll_t crtc_crc_poll(struct file *file, poll_table *wait)
 {
 	struct drm_crtc *crtc = file->f_inode->i_private;
 	struct drm_crtc_crc *crc = &crtc->crc;
-	unsigned ret;
+	__poll_t ret = 0;
 
 	poll_wait(file, &crc->wq, wait);
 
 	spin_lock_irq(&crc->lock);
 	if (crc->source && crtc_crc_data_count(crc))
-		ret = POLLIN | POLLRDNORM;
-	else
-		ret = 0;
+		ret |= EPOLLIN | EPOLLRDNORM;
 	spin_unlock_irq(&crc->lock);
 
 	return ret;

commit 178e5f3a5bc1d67d1248a74c0abab41040abe7c4
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Tue Aug 6 13:46:22 2019 +0100

    drm/crc-debugfs: Add notes about CRC<->commit interactions
    
    CRC generation can be impacted by commits coming from userspace, and
    enabling CRC generation may itself trigger a commit. Add notes about
    this to the kerneldoc.
    
    Changes since v1:
     - Clarified that anything that would disable CRCs counts as a full
       modeset, and so userspace needs to reconfigure after full modesets
    
    Changes since v2:
     - Add these notes
     - Rebase onto drm-misc-next (trivial conflict in comment)
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    
    Link:- https://patchwork.freedesktop.org/patch/321974/

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 6604ed223160..be1b7ba92ffe 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -69,6 +69,15 @@
  * implement &drm_crtc_funcs.set_crc_source and &drm_crtc_funcs.verify_crc_source.
  * The debugfs files are automatically set up if those vfuncs are set. CRC samples
  * need to be captured in the driver by calling drm_crtc_add_crc_entry().
+ * Depending on the driver and HW requirements, &drm_crtc_funcs.set_crc_source
+ * may result in a commit (even a full modeset).
+ *
+ * CRC results must be reliable across non-full-modeset atomic commits, so if a
+ * commit via DRM_IOCTL_MODE_ATOMIC would disable or otherwise interfere with
+ * CRC generation, then the driver must mark that commit as a full modeset
+ * (drm_atomic_crtc_needs_modeset() should return true). As a result, to ensure
+ * consistent results, generic userspace must re-setup CRC generation after a
+ * legacy SETCRTC or an atomic commit with DRM_MODE_ATOMIC_ALLOW_MODESET.
  */
 
 static int crc_control_show(struct seq_file *m, void *data)

commit 84a68104193efd0e11dd9284e5be9070dde3fdd1
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Jul 3 15:56:03 2019 +0100

    drm/drm_debugfs_crc.c: Document that .verify_crc_source vfunc is required for enabling CRC support.
    
    drm_debugfs_crtc_crc_add() function checks that both .set_crc_source and
    .verify_crc_source hooks are provided before enabling debugfs support for
    reading per-frame CRC data. Make that explicit in the documentation.
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190703150330.21992-1-Liviu.Dudau@arm.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 7ca486d750e9..6604ed223160 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -66,9 +66,9 @@
  * the reported CRCs of frames that should have the same contents.
  *
  * On the driver side the implementation effort is minimal, drivers only need to
- * implement &drm_crtc_funcs.set_crc_source. The debugfs files are automatically
- * set up if that vfunc is set. CRC samples need to be captured in the driver by
- * calling drm_crtc_add_crc_entry().
+ * implement &drm_crtc_funcs.set_crc_source and &drm_crtc_funcs.verify_crc_source.
+ * The debugfs files are automatically set up if those vfuncs are set. CRC samples
+ * need to be captured in the driver by calling drm_crtc_add_crc_entry().
  */
 
 static int crc_control_show(struct seq_file *m, void *data)

commit b792e64021ecdefd27b84eb235d59b0476d4255c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:34:39 2019 +0200

    drm: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Because there is no need to check these functions, a number of local
    functions can be made to return void to simplify things as nothing can
    fail.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613133439.GA6715@kroah.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index d2f102f01515..7ca486d750e9 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -351,33 +351,19 @@ static const struct file_operations drm_crtc_crc_data_fops = {
 	.release = crtc_crc_release,
 };
 
-int drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
+void drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
 {
-	struct dentry *crc_ent, *ent;
+	struct dentry *crc_ent;
 
 	if (!crtc->funcs->set_crc_source || !crtc->funcs->verify_crc_source)
-		return 0;
+		return;
 
 	crc_ent = debugfs_create_dir("crc", crtc->debugfs_entry);
-	if (!crc_ent)
-		return -ENOMEM;
-
-	ent = debugfs_create_file("control", S_IRUGO, crc_ent, crtc,
-				  &drm_crtc_crc_control_fops);
-	if (!ent)
-		goto error;
-
-	ent = debugfs_create_file("data", S_IRUGO, crc_ent, crtc,
-				  &drm_crtc_crc_data_fops);
-	if (!ent)
-		goto error;
-
-	return 0;
-
-error:
-	debugfs_remove_recursive(crc_ent);
 
-	return -ENOMEM;
+	debugfs_create_file("control", S_IRUGO, crc_ent, crtc,
+			    &drm_crtc_crc_control_fops);
+	debugfs_create_file("data", S_IRUGO, crc_ent, crtc,
+			    &drm_crtc_crc_data_fops);
 }
 
 /**

commit d99004d7201aa653658ff2390d6e516567c96ebc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 6 23:15:44 2019 +0200

    drm/crc-debugfs: Also sprinkle irqrestore over early exits
    
    I. was. blind.
    
    Caught with vkms, which has some really slow crc computation function.
    
    Fixes: 1882018a70e0 ("drm/crc-debugfs: User irqsafe spinlock in drm_crtc_add_crc_entry")
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Emil Velikov <emil.velikov@collabora.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190606211544.5389-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 7f35b5ba1924..d2f102f01515 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -402,7 +402,7 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 
 	/* Caller may not have noticed yet that userspace has stopped reading */
 	if (!crc->entries) {
-		spin_unlock(&crc->lock);
+		spin_unlock_irqrestore(&crc->lock, flags);
 		return -EINVAL;
 	}
 
@@ -413,7 +413,7 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 		bool was_overflow = crc->overflow;
 
 		crc->overflow = true;
-		spin_unlock(&crc->lock);
+		spin_unlock_irqrestore(&crc->lock, flags);
 
 		if (!was_overflow)
 			DRM_ERROR("Overflow of CRC buffer, userspace reads too slow.\n");

commit 1882018a70e06376234133e69ede9dd743b4dbd9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 5 21:45:56 2019 +0200

    drm/crc-debugfs: User irqsafe spinlock in drm_crtc_add_crc_entry
    
    We can be called from any context, we need to be prepared.
    
    Noticed this while hacking on vkms, which calls this function from a
    normal worker. Which really upsets lockdep.
    
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Emil Velikov <emil.velikov@collabora.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190605194556.16744-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 585169f0dcc5..7f35b5ba1924 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -396,8 +396,9 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	struct drm_crtc_crc *crc = &crtc->crc;
 	struct drm_crtc_crc_entry *entry;
 	int head, tail;
+	unsigned long flags;
 
-	spin_lock(&crc->lock);
+	spin_lock_irqsave(&crc->lock, flags);
 
 	/* Caller may not have noticed yet that userspace has stopped reading */
 	if (!crc->entries) {
@@ -428,7 +429,7 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	head = (head + 1) & (DRM_CRC_ENTRIES_NR - 1);
 	crc->head = head;
 
-	spin_unlock(&crc->lock);
+	spin_unlock_irqrestore(&crc->lock, flags);
 
 	wake_up_interruptible(&crc->wq);
 

commit 0500c04ea14a4143edf902d087079c4e7b2f0229
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 26 19:35:35 2019 +0200

    drm: drop use of drmP.h in drm/*
    
    The use of the drmP.h header file is deprecated.
    Remove use from all files in drm/*
    so people do not look there and follow a bad example.
    
    Build tested allyesconfig,allmodconfig on x86, arm etc.
    Including alpha that is as always more challenging than
    the rest.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190526173535.32701-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 00e743153e94..585169f0dcc5 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -29,7 +29,14 @@
 #include <linux/circ_buf.h>
 #include <linux/ctype.h>
 #include <linux/debugfs.h>
-#include <drm/drmP.h>
+#include <linux/poll.h>
+#include <linux/uaccess.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_debugfs_crc.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_print.h>
+
 #include "drm_internal.h"
 
 /**

commit ad1a56f1bf2bd2394f98320baf9ad430f7b1534c
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Tue Aug 21 14:08:57 2018 +0530

    Revert "drm: crc: Wait for a frame before returning from open()"
    
    This reverts commit e8fa5671183c80342d520ad81d14fa79a9d4a680.
    
    Don't wait for first CRC during crtc_crc_open. It avoids one frame wait
    during open. If application want to wait after read call, it can use
    poll/read blocking read() call.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180821083858.26275-4-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 3e0a2cfaa35c..00e743153e94 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -228,24 +228,8 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	if (ret)
 		goto err;
 
-	spin_lock_irq(&crc->lock);
-	/*
-	 * Only return once we got a first frame, so userspace doesn't have to
-	 * guess when this particular piece of HW will be ready to start
-	 * generating CRCs.
-	 */
-	ret = wait_event_interruptible_lock_irq(crc->wq,
-						crtc_crc_data_count(crc),
-						crc->lock);
-	spin_unlock_irq(&crc->lock);
-
-	if (ret)
-		goto err_disable;
-
 	return 0;
 
-err_disable:
-	crtc->funcs->set_crc_source(crtc, NULL);
 err:
 	spin_lock_irq(&crc->lock);
 	crtc_crc_cleanup(crc);

commit c0811a7d5befe34a17772760100e26b09a561c0e
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Tue Aug 21 14:08:56 2018 +0530

    drm/crc: Cleanup crtc_crc_open function
    
    This patch make changes to allocate crc-entries buffer before
    enabling CRC generation.
    It moves all the failure check early in the function before setting
    the source or memory allocation.
    Now set_crc_source takes only two variable inputs, values_cnt we
    already gets as part of verify_crc_source.
    
    Changes since V1:
     - refactor code to use single spin lock
    Changes since V2:
     - rebase
    Changes since V3:
     - rebase on top of VKMS driver
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Leo Li <sunpeng.li@amd.com> (V2)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com> (V3)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180821083858.26275-3-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index d7e626331eca..3e0a2cfaa35c 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -127,11 +127,9 @@ static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
 	if (source[len] == '\n')
 		source[len] = '\0';
 
-	if (crtc->funcs->verify_crc_source) {
-		ret = crtc->funcs->verify_crc_source(crtc, source, &values_cnt);
-		if (ret)
-			return ret;
-	}
+	ret = crtc->funcs->verify_crc_source(crtc, source, &values_cnt);
+	if (ret)
+		return ret;
 
 	spin_lock_irq(&crc->lock);
 
@@ -197,40 +195,40 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 			return ret;
 	}
 
+	ret = crtc->funcs->verify_crc_source(crtc, crc->source, &values_cnt);
+	if (ret)
+		return ret;
+
+	if (WARN_ON(values_cnt > DRM_MAX_CRC_NR))
+		return -EINVAL;
+
+	if (WARN_ON(values_cnt == 0))
+		return -EINVAL;
+
+	entries = kcalloc(DRM_CRC_ENTRIES_NR, sizeof(*entries), GFP_KERNEL);
+	if (!entries)
+		return -ENOMEM;
+
 	spin_lock_irq(&crc->lock);
-	if (!crc->opened)
+	if (!crc->opened) {
 		crc->opened = true;
-	else
+		crc->entries = entries;
+		crc->values_cnt = values_cnt;
+	} else {
 		ret = -EBUSY;
+	}
 	spin_unlock_irq(&crc->lock);
 
-	if (ret)
+	if (ret) {
+		kfree(entries);
 		return ret;
+	}
 
-	ret = crtc->funcs->set_crc_source(crtc, crc->source, &values_cnt);
+	ret = crtc->funcs->set_crc_source(crtc, crc->source);
 	if (ret)
 		goto err;
 
-	if (WARN_ON(values_cnt > DRM_MAX_CRC_NR)) {
-		ret = -EINVAL;
-		goto err_disable;
-	}
-
-	if (WARN_ON(values_cnt == 0)) {
-		ret = -EINVAL;
-		goto err_disable;
-	}
-
-	entries = kcalloc(DRM_CRC_ENTRIES_NR, sizeof(*entries), GFP_KERNEL);
-	if (!entries) {
-		ret = -ENOMEM;
-		goto err_disable;
-	}
-
 	spin_lock_irq(&crc->lock);
-	crc->entries = entries;
-	crc->values_cnt = values_cnt;
-
 	/*
 	 * Only return once we got a first frame, so userspace doesn't have to
 	 * guess when this particular piece of HW will be ready to start
@@ -247,7 +245,7 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	return 0;
 
 err_disable:
-	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+	crtc->funcs->set_crc_source(crtc, NULL);
 err:
 	spin_lock_irq(&crc->lock);
 	crtc_crc_cleanup(crc);
@@ -259,9 +257,8 @@ static int crtc_crc_release(struct inode *inode, struct file *filep)
 {
 	struct drm_crtc *crtc = filep->f_inode->i_private;
 	struct drm_crtc_crc *crc = &crtc->crc;
-	size_t values_cnt;
 
-	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+	crtc->funcs->set_crc_source(crtc, NULL);
 
 	spin_lock_irq(&crc->lock);
 	crtc_crc_cleanup(crc);
@@ -367,7 +364,7 @@ int drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
 {
 	struct dentry *crc_ent, *ent;
 
-	if (!crtc->funcs->set_crc_source)
+	if (!crtc->funcs->set_crc_source || !crtc->funcs->verify_crc_source)
 		return 0;
 
 	crc_ent = debugfs_create_dir("crc", crtc->debugfs_entry);

commit 4396551e9cf3e7233d45a2ce92f73e085bcad4b2
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Jul 13 19:29:34 2018 +0530

    drm: crc: Introduce get_crc_sources callback
    
    This patch introduce a callback function "get_crc_sources" which
    will be called during read of control node. It is an optional
    callback function and if driver implements this callback, driver
    should return a constant pointer to an array of crc sources list
    and update count according to the number of source in the list.
    
    Changes Since V1: (Daniel)
     - return const pointer to an array of crc sources list
     - do validation of sources in CRC-core
    Changes Since V2:
     - update commit message
     - update callback documentation
     - print one source name per line
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180713135942.25061-3-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 72bfd8af3f7a..d7e626331eca 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -68,8 +68,29 @@ static int crc_control_show(struct seq_file *m, void *data)
 {
 	struct drm_crtc *crtc = m->private;
 
-	seq_printf(m, "%s\n", crtc->crc.source);
+	if (crtc->funcs->get_crc_sources) {
+		size_t count;
+		const char *const *sources = crtc->funcs->get_crc_sources(crtc,
+									&count);
+		size_t values_cnt;
+		int i;
+
+		if (count == 0 || !sources)
+			goto out;
+
+		for (i = 0; i < count; i++)
+			if (!crtc->funcs->verify_crc_source(crtc, sources[i],
+							    &values_cnt)) {
+				if (strcmp(sources[i], crtc->crc.source))
+					seq_printf(m, "%s\n", sources[i]);
+				else
+					seq_printf(m, "%s*\n", sources[i]);
+			}
+	}
+	return 0;
 
+out:
+	seq_printf(m, "%s*\n", crtc->crc.source);
 	return 0;
 }
 

commit d5cc15a0c66e207d5a7f1b92f32899cc8f380468
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Jul 13 19:29:33 2018 +0530

    drm: crc: Introduce verify_crc_source callback
    
    This patch adds a new callback function "verify_crc_source" which will
    be used during setting the crc source in control node. This will help
    in avoiding setting of wrong string for source.
    
    Changes since V1:
     - do not yet verify_crc_source during open.
    Changes since V1:
     - improve callback description
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180713135942.25061-2-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 99961192bf03..72bfd8af3f7a 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -87,6 +87,8 @@ static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
 	struct drm_crtc *crtc = m->private;
 	struct drm_crtc_crc *crc = &crtc->crc;
 	char *source;
+	size_t values_cnt;
+	int ret;
 
 	if (len == 0)
 		return 0;
@@ -104,6 +106,12 @@ static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
 	if (source[len] == '\n')
 		source[len] = '\0';
 
+	if (crtc->funcs->verify_crc_source) {
+		ret = crtc->funcs->verify_crc_source(crtc, source, &values_cnt);
+		if (ret)
+			return ret;
+	}
+
 	spin_lock_irq(&crc->lock);
 
 	if (crc->opened) {

commit a012024571d98e2e4bf29a9168fb7ddc44b7ab86
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Apr 18 14:51:21 2018 +0200

    drm/crc: Only report a single overflow when a CRC fd is opened
    
    This reduces the amount of spam when you debug a CRC reading
    program.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [mlankhorst: Change bool overflow to was_overflow (Ville)]
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180418125121.72081-1-maarten.lankhorst@linux.intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 9f8312137cad..99961192bf03 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -139,6 +139,7 @@ static int crtc_crc_data_count(struct drm_crtc_crc *crc)
 static void crtc_crc_cleanup(struct drm_crtc_crc *crc)
 {
 	kfree(crc->entries);
+	crc->overflow = false;
 	crc->entries = NULL;
 	crc->head = 0;
 	crc->tail = 0;
@@ -391,8 +392,14 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	tail = crc->tail;
 
 	if (CIRC_SPACE(head, tail, DRM_CRC_ENTRIES_NR) < 1) {
+		bool was_overflow = crc->overflow;
+
+		crc->overflow = true;
 		spin_unlock(&crc->lock);
-		DRM_ERROR("Overflow of CRC buffer, userspace reads too slow.\n");
+
+		if (!was_overflow)
+			DRM_ERROR("Overflow of CRC buffer, userspace reads too slow.\n");
+
 		return -ENOBUFS;
 	}
 

commit 4beb3b40ae7f994af01200323441df13f8f5b241
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri Feb 2 15:27:43 2018 +0100

    drm/crc: Add support for polling on the data fd.
    
    This will make it possible for userspace to know whether reading
    will block, without blocking on the fd. This makes it possible to
    drain all queued CRC's in blocking mode, without having to reopen
    the fd.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180202142743.68527-1-maarten.lankhorst@linux.intel.com
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [mlankhorst: Use POLLIN|POLLRDNORM, based on Ville's suggestion]

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 9dd879589a2c..9f8312137cad 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -307,10 +307,29 @@ static ssize_t crtc_crc_read(struct file *filep, char __user *user_buf,
 	return LINE_LEN(crc->values_cnt);
 }
 
+static unsigned int crtc_crc_poll(struct file *file, poll_table *wait)
+{
+	struct drm_crtc *crtc = file->f_inode->i_private;
+	struct drm_crtc_crc *crc = &crtc->crc;
+	unsigned ret;
+
+	poll_wait(file, &crc->wq, wait);
+
+	spin_lock_irq(&crc->lock);
+	if (crc->source && crtc_crc_data_count(crc))
+		ret = POLLIN | POLLRDNORM;
+	else
+		ret = 0;
+	spin_unlock_irq(&crc->lock);
+
+	return ret;
+}
+
 static const struct file_operations drm_crtc_crc_data_fops = {
 	.owner = THIS_MODULE,
 	.open = crtc_crc_open,
 	.read = crtc_crc_read,
+	.poll = crtc_crc_poll,
 	.release = crtc_crc_release,
 };
 

commit 6f8bcc744aad50d719845e4ce06a7831e96e1109
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Sep 12 15:37:44 2017 +0200

    drm/atomic: Prepare drm_modeset_lock infrastructure for interruptible waiting, v2.
    
    When we want to make drm_atomic_commit interruptible, there are a lot of
    places that call the lock function, which we don't have control over.
    
    Rather than trying to convert every single one, it's easier to toggle
    interruptible waiting per acquire_ctx. If drm_modeset_acquire_init is
    called with DRM_MODESET_ACQUIRE_INTERRUPTIBLE, then we will perform
    interruptible waits in drm_modeset_lock and drm_modeset_backoff.
    
    Changes since v1:
    - Fix locking example in drm_modeset_lock.c to be compatible
      with interruptible waiting (xexaxo) and make it default.
      Uninterruptible waiting shouldn't happen except in corner cases,
      but the example will still apply if the flag is removed.
    - Add drm_modeset_lock_single_interruptible() to documentation.
    - Fix dead link to removed drm_modeset_lock_interruptible() in
      drm_modeset_lock().
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> #v1
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170912133749.6532-2-maarten.lankhorst@linux.intel.com
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index f9e26dda56d6..9dd879589a2c 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -155,7 +155,7 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	int ret = 0;
 
 	if (drm_drv_uses_atomic_modeset(crtc->dev)) {
-		ret = drm_modeset_lock_interruptible(&crtc->mutex, NULL);
+		ret = drm_modeset_lock_single_interruptible(&crtc->mutex);
 		if (ret)
 			return ret;
 

commit 8038e09be5a3ac061118bd80c7a505829920b50f
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Jul 6 15:03:15 2017 +0200

    drm/crc: Only open CRC on atomic drivers when the CRTC is active.
    
    Commit e8fa5671183c ("drm: crc: Wait for a frame before returning
    from open()") adds a wait for CRC frame, but with the CRTC off
    this will never be generated. For atomic drivers we know if a CRTC
    is active through crtc_state->active, so when inactive reject the
    open with -EIO.
    
    Just like with the previous patch changing debugfs opening semantics,
    this patch has been tested against igt.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Fixes: e8fa5671183c ("drm: crc: Wait for a frame before returning from open()")
    Testcase: debugfs_test.read_all_entries
    Link: http://patchwork.freedesktop.org/patch/msgid/15f9d300-65d3-63aa-00e3-e83f5e4d5a7a@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index d0ea4627a093..f9e26dda56d6 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -154,6 +154,19 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	size_t values_cnt;
 	int ret = 0;
 
+	if (drm_drv_uses_atomic_modeset(crtc->dev)) {
+		ret = drm_modeset_lock_interruptible(&crtc->mutex, NULL);
+		if (ret)
+			return ret;
+
+		if (!crtc->state->active)
+			ret = -EIO;
+		drm_modeset_unlock(&crtc->mutex);
+
+		if (ret)
+			return ret;
+	}
+
 	spin_lock_irq(&crc->lock);
 	if (!crc->opened)
 		crc->opened = true;

commit eb42ea6d0b8ed9ca8e73cc24fa801f0d8ab28905
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Jun 21 13:00:07 2017 +0200

    drm/crc: Handle opening and closing crc better
    
    When I was doing a grep . -r /sys/kernel/debug/dri/0 I noticed a WARN
    appearing when I aborted the grep with ^C.
    
    After investigating I've also noticed that the error handling was
    lacking and there are race conditions involving multiple calls to
    open/close simultaneously.
    
    Fix this by setting the opened flag first and using crc->entries to
    decide when crc can be collected.
    
    Also call unset crc source before cleaning up, this way there is
    no race with a future open().
    
    This patch has been tested with all the tests in igt with CRC in their
    name.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170621110007.11674-1-maarten.lankhorst@linux.intel.com
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    [mlankhorst: Add description that this patch has been tested with IGT,
    based on tomeu's feedback]

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 1722d8f21449..d0ea4627a093 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -136,21 +136,38 @@ static int crtc_crc_data_count(struct drm_crtc_crc *crc)
 	return CIRC_CNT(crc->head, crc->tail, DRM_CRC_ENTRIES_NR);
 }
 
+static void crtc_crc_cleanup(struct drm_crtc_crc *crc)
+{
+	kfree(crc->entries);
+	crc->entries = NULL;
+	crc->head = 0;
+	crc->tail = 0;
+	crc->values_cnt = 0;
+	crc->opened = false;
+}
+
 static int crtc_crc_open(struct inode *inode, struct file *filep)
 {
 	struct drm_crtc *crtc = inode->i_private;
 	struct drm_crtc_crc *crc = &crtc->crc;
 	struct drm_crtc_crc_entry *entries = NULL;
 	size_t values_cnt;
-	int ret;
+	int ret = 0;
 
-	if (crc->opened)
-		return -EBUSY;
+	spin_lock_irq(&crc->lock);
+	if (!crc->opened)
+		crc->opened = true;
+	else
+		ret = -EBUSY;
+	spin_unlock_irq(&crc->lock);
 
-	ret = crtc->funcs->set_crc_source(crtc, crc->source, &values_cnt);
 	if (ret)
 		return ret;
 
+	ret = crtc->funcs->set_crc_source(crtc, crc->source, &values_cnt);
+	if (ret)
+		goto err;
+
 	if (WARN_ON(values_cnt > DRM_MAX_CRC_NR)) {
 		ret = -EINVAL;
 		goto err_disable;
@@ -170,7 +187,6 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	spin_lock_irq(&crc->lock);
 	crc->entries = entries;
 	crc->values_cnt = values_cnt;
-	crc->opened = true;
 
 	/*
 	 * Only return once we got a first frame, so userspace doesn't have to
@@ -182,12 +198,17 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 						crc->lock);
 	spin_unlock_irq(&crc->lock);
 
-	WARN_ON(ret);
+	if (ret)
+		goto err_disable;
 
 	return 0;
 
 err_disable:
 	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+err:
+	spin_lock_irq(&crc->lock);
+	crtc_crc_cleanup(crc);
+	spin_unlock_irq(&crc->lock);
 	return ret;
 }
 
@@ -197,17 +218,12 @@ static int crtc_crc_release(struct inode *inode, struct file *filep)
 	struct drm_crtc_crc *crc = &crtc->crc;
 	size_t values_cnt;
 
+	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+
 	spin_lock_irq(&crc->lock);
-	kfree(crc->entries);
-	crc->entries = NULL;
-	crc->head = 0;
-	crc->tail = 0;
-	crc->values_cnt = 0;
-	crc->opened = false;
+	crtc_crc_cleanup(crc);
 	spin_unlock_irq(&crc->lock);
 
-	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
-
 	return 0;
 }
 
@@ -334,7 +350,7 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	spin_lock(&crc->lock);
 
 	/* Caller may not have noticed yet that userspace has stopped reading */
-	if (!crc->opened) {
+	if (!crc->entries) {
 		spin_unlock(&crc->lock);
 		return -EINVAL;
 	}

commit c98cdff94a6a7877923dec1329c2b76d6247d076
Author: Sean Paul <seanpaul@chromium.org>
Date:   Fri Apr 7 16:15:30 2017 -0400

    Revert "drm: Don't allow interruptions when opening debugfs/crc"
    
    This reverts
    
    commit b8dfa821c27046ede9bf8eb14cc8109d379428e9
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Fri Apr 7 12:17:12 2017 +0100
        drm: Don't allow interruptions when opening debugfs/crc
    
    It reportedly breaks things, so let's revert now and try again later.
    
    Fixes: b8dfa821c270 ("drm: Don't allow interruptions when opening debugfs/crc")
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index aa13e734c9e5..1722d8f21449 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -177,9 +177,13 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	 * guess when this particular piece of HW will be ready to start
 	 * generating CRCs.
 	 */
-	wait_event_lock_irq(crc->wq, crtc_crc_data_count(crc), crc->lock);
+	ret = wait_event_interruptible_lock_irq(crc->wq,
+						crtc_crc_data_count(crc),
+						crc->lock);
 	spin_unlock_irq(&crc->lock);
 
+	WARN_ON(ret);
+
 	return 0;
 
 err_disable:

commit b8dfa821c27046ede9bf8eb14cc8109d379428e9
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 7 12:17:12 2017 +0100

    drm: Don't allow interruptions when opening debugfs/crc
    
    The code does not like to be interrupted when waiting for the first
    vblank after opening a debugfs/crc channel, so don't.
    
    [66285.716870] WARNING: CPU: 1 PID: 16615 at drivers/gpu/drm/drm_debugfs_crc.c:185 crtc_crc_open+0x1d0/0x1f0 [drm]
    [66285.716877] Modules linked in: i915 intel_powerclamp crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel cryptd intel_gtt i2c_algo_bit lpc_ich mfd_core drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops prime_numbers drm video button autofs4 sd_mod ahci libahci libata i2c_i801 scsi_mod i2c_designware_platform i2c_designware_core i2c_core
    [66285.716929] CPU: 1 PID: 16615 Comm: kms_frontbuffer Not tainted 4.11.0-rc5+ #7
    [66285.716935] Hardware name: GIGABYTE GB-BXBT-1900/MZBAYAB-00, BIOS F8 03/02/2016
    [66285.716941] Call Trace:
    [66285.716955]  dump_stack+0x4d/0x6f
    [66285.716966]  __warn+0xc1/0xe0
    [66285.716975]  warn_slowpath_null+0x18/0x20
    [66285.717004]  crtc_crc_open+0x1d0/0x1f0 [drm]
    [66285.717014]  ? wake_atomic_t_function+0x50/0x50
    [66285.717024]  full_proxy_open+0xf0/0x1b0
    [66285.717032]  ? full_proxy_release+0x80/0x80
    [66285.717042]  do_dentry_open.isra.17+0x14b/0x2d0
    [66285.717051]  vfs_open+0x42/0x60
    [66285.717064]  path_openat+0x5e7/0x13d0
    [66285.717074]  ? refcount_dec_and_test+0x11/0x20
    [66285.717081]  ? down_read+0xd/0x30
    [66285.717087]  do_filp_open+0x85/0xf0
    [66285.717093]  ? __vfs_write+0x23/0x120
    [66285.717100]  ? __alloc_fd+0x3a/0x170
    [66285.717107]  do_sys_open+0x11e/0x1f0
    [66285.717113]  ? do_sys_open+0x11e/0x1f0
    [66285.717119]  SyS_openat+0xf/0x20
    [66285.717125]  entry_SYSCALL_64_fastpath+0x17/0x98
    [66285.717131] RIP: 0033:0x7f5f2235146a
    [66285.717135] RSP: 002b:00007ffd892e6bc0 EFLAGS: 00000246 ORIG_RAX: 0000000000000101
    [66285.717142] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f5f2235146a
    [66285.717147] RDX: 0000000000000000 RSI: 00007ffd892e6c40 RDI: 0000000000000006
    [66285.717151] RBP: 00007ffd892e6b20 R08: 0000000000000000 R09: 000000000000000f
    [66285.717156] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001
    [66285.717161] R13: 00007ffd892e6b10 R14: 0000000000000004 R15: 00000000007e61f4
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100610
    Fixes: e8fa5671183c ("drm: crc: Wait for a frame before returning from open()")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170407111712.13962-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 1722d8f21449..aa13e734c9e5 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -177,13 +177,9 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	 * guess when this particular piece of HW will be ready to start
 	 * generating CRCs.
 	 */
-	ret = wait_event_interruptible_lock_irq(crc->wq,
-						crtc_crc_data_count(crc),
-						crc->lock);
+	wait_event_lock_irq(crc->wq, crtc_crc_data_count(crc), crc->lock);
 	spin_unlock_irq(&crc->lock);
 
-	WARN_ON(ret);
-
 	return 0;
 
 err_disable:

commit 760f71e72eb5c64b12d85d4e6dc79d28a708e09e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 09:36:04 2017 +0100

    drm: document driver interface for CRC capturing
    
    This was missed in Tomeu's patch. Also remove the kerneldoc for the
    internal function, we don't document that in general.
    
    While at it word-smith the docs slightly for more clarity.
    
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322083617.13361-4-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 96891c4a6e23..1722d8f21449 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -36,7 +36,7 @@
  * DOC: CRC ABI
  *
  * DRM device drivers can provide to userspace CRC information of each frame as
- * it reached a given hardware component (a "source").
+ * it reached a given hardware component (a CRC sampling "source").
  *
  * Userspace can control generation of CRCs in a given CRTC by writing to the
  * file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
@@ -57,6 +57,11 @@
  * rely on being able to generate matching CRC values for the frame contents that
  * it submits. In this general case, the maximum userspace can do is to compare
  * the reported CRCs of frames that should have the same contents.
+ *
+ * On the driver side the implementation effort is minimal, drivers only need to
+ * implement &drm_crtc_funcs.set_crc_source. The debugfs files are automatically
+ * set up if that vfunc is set. CRC samples need to be captured in the driver by
+ * calling drm_crtc_add_crc_entry().
  */
 
 static int crc_control_show(struct seq_file *m, void *data)
@@ -280,16 +285,6 @@ static const struct file_operations drm_crtc_crc_data_fops = {
 	.release = crtc_crc_release,
 };
 
-/**
- * drm_debugfs_crtc_crc_add - Add files to debugfs for capture of frame CRCs
- * @crtc: CRTC to whom the frames will belong
- *
- * Adds files to debugfs directory that allows userspace to control the
- * generation of frame CRCs and to read them.
- *
- * Returns:
- * Zero on success, error code on failure.
- */
 int drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
 {
 	struct dentry *crc_ent, *ent;

commit 9f547425fd9fbcb42b177ec7eec46bd4d7d4ae45
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Fri Jan 6 10:15:03 2017 +0100

    drm: crc: Call wake_up_interruptible() each time there is a new CRC entry
    
    Each time new data has being added in CRC list inform reader by calling
    wake_up_interruptible().
    This should avoid to do it in all drivers.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483694104-25627-1-git-send-email-benjamin.gaignard@linaro.org

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 8b0eeeed4d78..96891c4a6e23 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -363,6 +363,8 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 
 	spin_unlock(&crc->lock);
 
+	wake_up_interruptible(&crc->wq);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(drm_crtc_add_crc_entry);

commit e8fa5671183c80342d520ad81d14fa79a9d4a680
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Mon Jan 2 13:59:10 2017 +0100

    drm: crc: Wait for a frame before returning from open()
    
    Don't return from the open() call on the crc/data file until the HW has
    produced a first frame, as there's great variability in when the HW is
    able to do that and userspace shouldn't have to guess when this specific
    HW is ready to start giving frame CRCs.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170102125912.22305-3-tomeu.vizoso@collabora.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 68b171af237b..8b0eeeed4d78 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -125,6 +125,12 @@ static const struct file_operations drm_crtc_crc_control_fops = {
 	.write = crc_control_write
 };
 
+static int crtc_crc_data_count(struct drm_crtc_crc *crc)
+{
+	assert_spin_locked(&crc->lock);
+	return CIRC_CNT(crc->head, crc->tail, DRM_CRC_ENTRIES_NR);
+}
+
 static int crtc_crc_open(struct inode *inode, struct file *filep)
 {
 	struct drm_crtc *crtc = inode->i_private;
@@ -160,8 +166,19 @@ static int crtc_crc_open(struct inode *inode, struct file *filep)
 	crc->entries = entries;
 	crc->values_cnt = values_cnt;
 	crc->opened = true;
+
+	/*
+	 * Only return once we got a first frame, so userspace doesn't have to
+	 * guess when this particular piece of HW will be ready to start
+	 * generating CRCs.
+	 */
+	ret = wait_event_interruptible_lock_irq(crc->wq,
+						crtc_crc_data_count(crc),
+						crc->lock);
 	spin_unlock_irq(&crc->lock);
 
+	WARN_ON(ret);
+
 	return 0;
 
 err_disable:
@@ -189,12 +206,6 @@ static int crtc_crc_release(struct inode *inode, struct file *filep)
 	return 0;
 }
 
-static int crtc_crc_data_count(struct drm_crtc_crc *crc)
-{
-	assert_spin_locked(&crc->lock);
-	return CIRC_CNT(crc->head, crc->tail, DRM_CRC_ENTRIES_NR);
-}
-
 /*
  * 1 frame field of 10 chars plus a number of CRC fields of 10 chars each, space
  * separated, with a newline at the end and null-terminated.

commit 1aa81be3af121636824e40eec737706e62c9da0c
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Mon Jan 2 13:59:09 2017 +0100

    drm: Move locking into drm_debugfs_crtc_crc_add
    
    There's no reason any more for callers of this function to take the lock
    themselves, so just move the lock to the function to avoid confusion and
    bugs when more callers are contributed.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Robert Foss <robert.foss@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170102125912.22305-2-tomeu.vizoso@collabora.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 00e771fb7df2..68b171af237b 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -325,16 +325,19 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	struct drm_crtc_crc_entry *entry;
 	int head, tail;
 
-	assert_spin_locked(&crc->lock);
+	spin_lock(&crc->lock);
 
 	/* Caller may not have noticed yet that userspace has stopped reading */
-	if (!crc->opened)
+	if (!crc->opened) {
+		spin_unlock(&crc->lock);
 		return -EINVAL;
+	}
 
 	head = crc->head;
 	tail = crc->tail;
 
 	if (CIRC_SPACE(head, tail, DRM_CRC_ENTRIES_NR) < 1) {
+		spin_unlock(&crc->lock);
 		DRM_ERROR("Overflow of CRC buffer, userspace reads too slow.\n");
 		return -ENOBUFS;
 	}
@@ -347,6 +350,8 @@ int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
 	head = (head + 1) & (DRM_CRC_ENTRIES_NR - 1);
 	crc->head = head;
 
+	spin_unlock(&crc->lock);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(drm_crtc_add_crc_entry);

commit e3f56b2953ec8160629295bc2be0c8d3b8f4d1d3
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Oct 18 14:28:35 2016 +0300

    drm: fix sparse warnings on undeclared symbols in crc debugfs
    
    Fixes sparse warnings:
    
    drivers/gpu/drm/drm_debugfs_crc.c:118:30: warning: symbol
    'drm_crtc_crc_control_fops' was not declared. Should it be static?
    
    drivers/gpu/drm/drm_debugfs_crc.c:264:30: warning: symbol
    'drm_crtc_crc_data_fops' was not declared. Should it be static?
    
    drivers/gpu/drm/drm_debugfs_crc.c:281:5: warning: symbol
    'drm_debugfs_crtc_crc_add' was not declared. Should it be static?
    
    Fixes: 9edbf1fa600a ("drm: Add API for capturing frame CRCs")
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Emil Velikov <emil.velikov@collabora.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476790115-28665-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
index 4129405d17c0..00e771fb7df2 100644
--- a/drivers/gpu/drm/drm_debugfs_crc.c
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -30,6 +30,7 @@
 #include <linux/ctype.h>
 #include <linux/debugfs.h>
 #include <drm/drmP.h>
+#include "drm_internal.h"
 
 /**
  * DOC: CRC ABI
@@ -115,7 +116,7 @@ static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
 	return len;
 }
 
-const struct file_operations drm_crtc_crc_control_fops = {
+static const struct file_operations drm_crtc_crc_control_fops = {
 	.owner = THIS_MODULE,
 	.open = crc_control_open,
 	.read = seq_read,
@@ -261,7 +262,7 @@ static ssize_t crtc_crc_read(struct file *filep, char __user *user_buf,
 	return LINE_LEN(crc->values_cnt);
 }
 
-const struct file_operations drm_crtc_crc_data_fops = {
+static const struct file_operations drm_crtc_crc_data_fops = {
 	.owner = THIS_MODULE,
 	.open = crtc_crc_open,
 	.read = crtc_crc_read,

commit 9edbf1fa600a2ef17c7553c2103d0055d0320d15
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Oct 6 17:21:06 2016 +0200

    drm: Add API for capturing frame CRCs
    
    Adds files and directories to debugfs for controlling and reading frame
    CRCs, per CRTC:
    
    dri/0/crtc-0/crc
    dri/0/crtc-0/crc/control
    dri/0/crtc-0/crc/data
    
    Drivers can implement the set_crc_source callback() in drm_crtc_funcs to
    start and stop generating frame CRCs and can add entries to the output
    by calling drm_crtc_add_crc_entry.
    
    v2:
        - Lots of good fixes suggested by Thierry.
        - Added documentation.
        - Changed the debugfs layout.
        - Moved to allocate the entries circular queue once when frame
          generation gets enabled for the first time.
    v3:
        - Use the control file just to select the source, and start and stop
          capture when the data file is opened and closed, respectively.
        - Make variable the number of CRC values per entry, per source.
        - Allocate entries queue each time we start capturing as now there
          isn't a fixed number of CRC values per entry.
        - Store the frame counter in the data file as a 8-digit hex number.
        - For sources that cannot provide useful frame numbers, place
          XXXXXXXX in the frame field.
    
    v4:
        - Build only if CONFIG_DEBUG_FS is enabled.
        - Use memdup_user_nul.
        - Consolidate calculation of the size of an entry in a helper.
        - Add 0x prefix to hex numbers in the data file.
        - Remove unnecessary snprintf and strlen usage in read callback.
    
    v5:
        - Made the crcs array in drm_crtc_crc_entry fixed-size
        - Lots of other smaller improvements suggested by Emil Velikov
    
    v7:
        - Move definition of drm_debugfs_crtc_crc_add to drm_internal.h
    
    v8:
        - Call debugfs_remove_recursive when we fail to create the minor
          device
    
    v9:
        - Register the debugfs directory for a crtc from
          drm_crtc_register_all()
    
    v10:
        - Don't let debugfs failures interrupt CRTC registration (Emil
          Velikov)
    
    v11:
        - Remove extra brace that broke compilation. Sorry!
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1475767268-14379-3-git-send-email-tomeu.vizoso@collabora.com

diff --git a/drivers/gpu/drm/drm_debugfs_crc.c b/drivers/gpu/drm/drm_debugfs_crc.c
new file mode 100644
index 000000000000..4129405d17c0
--- /dev/null
+++ b/drivers/gpu/drm/drm_debugfs_crc.c
@@ -0,0 +1,351 @@
+/*
+ * Copyright © 2008 Intel Corporation
+ * Copyright © 2016 Collabora Ltd
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Based on code from the i915 driver.
+ * Original author: Damien Lespiau <damien.lespiau@intel.com>
+ *
+ */
+
+#include <linux/circ_buf.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <drm/drmP.h>
+
+/**
+ * DOC: CRC ABI
+ *
+ * DRM device drivers can provide to userspace CRC information of each frame as
+ * it reached a given hardware component (a "source").
+ *
+ * Userspace can control generation of CRCs in a given CRTC by writing to the
+ * file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
+ * Accepted values are source names (which are driver-specific) and the "auto"
+ * keyword, which will let the driver select a default source of frame CRCs
+ * for this CRTC.
+ *
+ * Once frame CRC generation is enabled, userspace can capture them by reading
+ * the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
+ * number in the first field and then a number of unsigned integer fields
+ * containing the CRC data. Fields are separated by a single space and the number
+ * of CRC fields is source-specific.
+ *
+ * Note that though in some cases the CRC is computed in a specified way and on
+ * the frame contents as supplied by userspace (eDP 1.3), in general the CRC
+ * computation is performed in an unspecified way and on frame contents that have
+ * been already processed in also an unspecified way and thus userspace cannot
+ * rely on being able to generate matching CRC values for the frame contents that
+ * it submits. In this general case, the maximum userspace can do is to compare
+ * the reported CRCs of frames that should have the same contents.
+ */
+
+static int crc_control_show(struct seq_file *m, void *data)
+{
+	struct drm_crtc *crtc = m->private;
+
+	seq_printf(m, "%s\n", crtc->crc.source);
+
+	return 0;
+}
+
+static int crc_control_open(struct inode *inode, struct file *file)
+{
+	struct drm_crtc *crtc = inode->i_private;
+
+	return single_open(file, crc_control_show, crtc);
+}
+
+static ssize_t crc_control_write(struct file *file, const char __user *ubuf,
+				 size_t len, loff_t *offp)
+{
+	struct seq_file *m = file->private_data;
+	struct drm_crtc *crtc = m->private;
+	struct drm_crtc_crc *crc = &crtc->crc;
+	char *source;
+
+	if (len == 0)
+		return 0;
+
+	if (len > PAGE_SIZE - 1) {
+		DRM_DEBUG_KMS("Expected < %lu bytes into crtc crc control\n",
+			      PAGE_SIZE);
+		return -E2BIG;
+	}
+
+	source = memdup_user_nul(ubuf, len);
+	if (IS_ERR(source))
+		return PTR_ERR(source);
+
+	if (source[len] == '\n')
+		source[len] = '\0';
+
+	spin_lock_irq(&crc->lock);
+
+	if (crc->opened) {
+		spin_unlock_irq(&crc->lock);
+		kfree(source);
+		return -EBUSY;
+	}
+
+	kfree(crc->source);
+	crc->source = source;
+
+	spin_unlock_irq(&crc->lock);
+
+	*offp += len;
+	return len;
+}
+
+const struct file_operations drm_crtc_crc_control_fops = {
+	.owner = THIS_MODULE,
+	.open = crc_control_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = crc_control_write
+};
+
+static int crtc_crc_open(struct inode *inode, struct file *filep)
+{
+	struct drm_crtc *crtc = inode->i_private;
+	struct drm_crtc_crc *crc = &crtc->crc;
+	struct drm_crtc_crc_entry *entries = NULL;
+	size_t values_cnt;
+	int ret;
+
+	if (crc->opened)
+		return -EBUSY;
+
+	ret = crtc->funcs->set_crc_source(crtc, crc->source, &values_cnt);
+	if (ret)
+		return ret;
+
+	if (WARN_ON(values_cnt > DRM_MAX_CRC_NR)) {
+		ret = -EINVAL;
+		goto err_disable;
+	}
+
+	if (WARN_ON(values_cnt == 0)) {
+		ret = -EINVAL;
+		goto err_disable;
+	}
+
+	entries = kcalloc(DRM_CRC_ENTRIES_NR, sizeof(*entries), GFP_KERNEL);
+	if (!entries) {
+		ret = -ENOMEM;
+		goto err_disable;
+	}
+
+	spin_lock_irq(&crc->lock);
+	crc->entries = entries;
+	crc->values_cnt = values_cnt;
+	crc->opened = true;
+	spin_unlock_irq(&crc->lock);
+
+	return 0;
+
+err_disable:
+	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+	return ret;
+}
+
+static int crtc_crc_release(struct inode *inode, struct file *filep)
+{
+	struct drm_crtc *crtc = filep->f_inode->i_private;
+	struct drm_crtc_crc *crc = &crtc->crc;
+	size_t values_cnt;
+
+	spin_lock_irq(&crc->lock);
+	kfree(crc->entries);
+	crc->entries = NULL;
+	crc->head = 0;
+	crc->tail = 0;
+	crc->values_cnt = 0;
+	crc->opened = false;
+	spin_unlock_irq(&crc->lock);
+
+	crtc->funcs->set_crc_source(crtc, NULL, &values_cnt);
+
+	return 0;
+}
+
+static int crtc_crc_data_count(struct drm_crtc_crc *crc)
+{
+	assert_spin_locked(&crc->lock);
+	return CIRC_CNT(crc->head, crc->tail, DRM_CRC_ENTRIES_NR);
+}
+
+/*
+ * 1 frame field of 10 chars plus a number of CRC fields of 10 chars each, space
+ * separated, with a newline at the end and null-terminated.
+ */
+#define LINE_LEN(values_cnt)	(10 + 11 * values_cnt + 1 + 1)
+#define MAX_LINE_LEN		(LINE_LEN(DRM_MAX_CRC_NR))
+
+static ssize_t crtc_crc_read(struct file *filep, char __user *user_buf,
+			     size_t count, loff_t *pos)
+{
+	struct drm_crtc *crtc = filep->f_inode->i_private;
+	struct drm_crtc_crc *crc = &crtc->crc;
+	struct drm_crtc_crc_entry *entry;
+	char buf[MAX_LINE_LEN];
+	int ret, i;
+
+	spin_lock_irq(&crc->lock);
+
+	if (!crc->source) {
+		spin_unlock_irq(&crc->lock);
+		return 0;
+	}
+
+	/* Nothing to read? */
+	while (crtc_crc_data_count(crc) == 0) {
+		if (filep->f_flags & O_NONBLOCK) {
+			spin_unlock_irq(&crc->lock);
+			return -EAGAIN;
+		}
+
+		ret = wait_event_interruptible_lock_irq(crc->wq,
+							crtc_crc_data_count(crc),
+							crc->lock);
+		if (ret) {
+			spin_unlock_irq(&crc->lock);
+			return ret;
+		}
+	}
+
+	/* We know we have an entry to be read */
+	entry = &crc->entries[crc->tail];
+
+	if (count < LINE_LEN(crc->values_cnt)) {
+		spin_unlock_irq(&crc->lock);
+		return -EINVAL;
+	}
+
+	BUILD_BUG_ON_NOT_POWER_OF_2(DRM_CRC_ENTRIES_NR);
+	crc->tail = (crc->tail + 1) & (DRM_CRC_ENTRIES_NR - 1);
+
+	spin_unlock_irq(&crc->lock);
+
+	if (entry->has_frame_counter)
+		sprintf(buf, "0x%08x", entry->frame);
+	else
+		sprintf(buf, "XXXXXXXXXX");
+
+	for (i = 0; i < crc->values_cnt; i++)
+		sprintf(buf + 10 + i * 11, " 0x%08x", entry->crcs[i]);
+	sprintf(buf + 10 + crc->values_cnt * 11, "\n");
+
+	if (copy_to_user(user_buf, buf, LINE_LEN(crc->values_cnt)))
+		return -EFAULT;
+
+	return LINE_LEN(crc->values_cnt);
+}
+
+const struct file_operations drm_crtc_crc_data_fops = {
+	.owner = THIS_MODULE,
+	.open = crtc_crc_open,
+	.read = crtc_crc_read,
+	.release = crtc_crc_release,
+};
+
+/**
+ * drm_debugfs_crtc_crc_add - Add files to debugfs for capture of frame CRCs
+ * @crtc: CRTC to whom the frames will belong
+ *
+ * Adds files to debugfs directory that allows userspace to control the
+ * generation of frame CRCs and to read them.
+ *
+ * Returns:
+ * Zero on success, error code on failure.
+ */
+int drm_debugfs_crtc_crc_add(struct drm_crtc *crtc)
+{
+	struct dentry *crc_ent, *ent;
+
+	if (!crtc->funcs->set_crc_source)
+		return 0;
+
+	crc_ent = debugfs_create_dir("crc", crtc->debugfs_entry);
+	if (!crc_ent)
+		return -ENOMEM;
+
+	ent = debugfs_create_file("control", S_IRUGO, crc_ent, crtc,
+				  &drm_crtc_crc_control_fops);
+	if (!ent)
+		goto error;
+
+	ent = debugfs_create_file("data", S_IRUGO, crc_ent, crtc,
+				  &drm_crtc_crc_data_fops);
+	if (!ent)
+		goto error;
+
+	return 0;
+
+error:
+	debugfs_remove_recursive(crc_ent);
+
+	return -ENOMEM;
+}
+
+/**
+ * drm_crtc_add_crc_entry - Add entry with CRC information for a frame
+ * @crtc: CRTC to which the frame belongs
+ * @has_frame: whether this entry has a frame number to go with
+ * @frame: number of the frame these CRCs are about
+ * @crcs: array of CRC values, with length matching #drm_crtc_crc.values_cnt
+ *
+ * For each frame, the driver polls the source of CRCs for new data and calls
+ * this function to add them to the buffer from where userspace reads.
+ */
+int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
+			   uint32_t frame, uint32_t *crcs)
+{
+	struct drm_crtc_crc *crc = &crtc->crc;
+	struct drm_crtc_crc_entry *entry;
+	int head, tail;
+
+	assert_spin_locked(&crc->lock);
+
+	/* Caller may not have noticed yet that userspace has stopped reading */
+	if (!crc->opened)
+		return -EINVAL;
+
+	head = crc->head;
+	tail = crc->tail;
+
+	if (CIRC_SPACE(head, tail, DRM_CRC_ENTRIES_NR) < 1) {
+		DRM_ERROR("Overflow of CRC buffer, userspace reads too slow.\n");
+		return -ENOBUFS;
+	}
+
+	entry = &crc->entries[head];
+	entry->frame = frame;
+	entry->has_frame_counter = has_frame;
+	memcpy(&entry->crcs, crcs, sizeof(*crcs) * crc->values_cnt);
+
+	head = (head + 1) & (DRM_CRC_ENTRIES_NR - 1);
+	crc->head = head;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(drm_crtc_add_crc_entry);
