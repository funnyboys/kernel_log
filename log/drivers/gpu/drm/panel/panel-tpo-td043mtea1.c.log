commit aa6c43644bc57b3d297247746184d1d82ed9de82
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:35 2019 +0100

    drm/panel: drop drm_device from drm_panel
    
    The panel drivers used drm_panel.drm for two purposes:
    1) Argument to drm_mode_duplicate()
    2) drm->dev was used in error messages
    
    The first usage is replaced with drm_connector.dev
    - drm_connector is already connected to a drm_device
      and we have a valid connector
    
    The second usage is replaced with drm_panel.dev
    - this makes drivers more consistent in their dev argument
      used for dev_err() and friends
    
    With these replacements there are no more uses of drm_panel.drm,
    so it is removed from struct drm_panel.
    With this change drm_panel_attach() and drm_panel_detach()
    no longer have any use as they are empty functions.
    
    v2:
      - editorial correction in changelog (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index 716f8ed1cc45..75f1f1f1b6de 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -351,7 +351,7 @@ static int td043mtea1_get_modes(struct drm_panel *panel,
 {
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(panel->drm, &td043mtea1_mode);
+	mode = drm_mode_duplicate(connector->dev, &td043mtea1_mode);
 	if (!mode)
 		return -ENOMEM;
 

commit 0ce8ddd8e06dcbcd8d31607921c31ad1c32ad56c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:33 2019 +0100

    drm/panel: add drm_connector argument to get_modes()
    
    Today the bridge creates the drm_connector, but that is planned
    to be moved to the display drivers.
    To facilitate this, update drm_panel_funcs.get_modes() to
    take drm_connector as an argument.
    All panel drivers implementing get_modes() are updated.
    
    v2:
      - drop accidental change (Laurent)
      - update docs for get_modes (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-6-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index 621b65feec07..716f8ed1cc45 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -346,9 +346,9 @@ static const struct drm_display_mode td043mtea1_mode = {
 	.height_mm = 56,
 };
 
-static int td043mtea1_get_modes(struct drm_panel *panel)
+static int td043mtea1_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
 {
-	struct drm_connector *connector = panel->connector;
 	struct drm_display_mode *mode;
 
 	mode = drm_mode_duplicate(panel->drm, &td043mtea1_mode);

commit 2e79e22e092acd55da0b2db066e4826d7d152c41
Merge: f1b4a9217efd 7d194c2100ad
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 23 12:02:47 2019 +0200

    Merge v5.4-rc4 into drm-next
    
    Thierry needs fd70c7755bf0 ("drm/bridge: tc358767: fix max_tu_symbol
    value") to be able to merge his dp_link patch series.
    
    Some adjacent changes conflicts, plus some clashes in i915 due to
    cherry-picking and git trying to be helpful and leaving both versions
    in.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit cc635be34eb672a30a4936db30987b7c2e91fb61
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Oct 7 20:08:01 2019 +0300

    drm/panel: tpo-td043mtea1: Fix SPI alias
    
    The panel-tpo-td043mtea1 driver incorrectly includes the OF vendor
    prefix in its SPI alias. Fix it, and move the manual alias to an SPI
    module device table.
    
    Fixes: dc2e1e5b2799 ("drm/panel: Add driver for the Toppoly TD043MTEA1 panel")
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191007170801.27647-6-laurent.pinchart@ideasonboard.com
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index 84370562910f..ba163c779084 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -491,9 +491,17 @@ static const struct of_device_id td043mtea1_of_match[] = {
 
 MODULE_DEVICE_TABLE(of, td043mtea1_of_match);
 
+static const struct spi_device_id td043mtea1_ids[] = {
+	{ "td043mtea1", 0 },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(spi, td043mtea1_ids);
+
 static struct spi_driver td043mtea1_driver = {
 	.probe		= td043mtea1_probe,
 	.remove		= td043mtea1_remove,
+	.id_table	= td043mtea1_ids,
 	.driver		= {
 		.name	= "panel-tpo-td043mtea1",
 		.pm	= &td043mtea1_pm_ops,
@@ -503,7 +511,6 @@ static struct spi_driver td043mtea1_driver = {
 
 module_spi_driver(td043mtea1_driver);
 
-MODULE_ALIAS("spi:tpo,td043mtea1");
 MODULE_AUTHOR("Gražvydas Ignotas <notasas@gmail.com>");
 MODULE_DESCRIPTION("TPO TD043MTEA1 Panel Driver");
 MODULE_LICENSE("GPL");

commit 9a2654c0f62a1704f36acb6329f9ccbd539f75ad
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 4 16:28:03 2019 +0300

    drm/panel: Add and fill drm_panel type field
    
    Add a type field to the drm_panel structure to report the panel type,
    using DRM_MODE_CONNECTOR_* macros (the values that make sense are LVDS,
    eDP, DSI and DPI). This will be used to initialise the corresponding
    connector type.
    
    Update all panel drivers accordingly. The panel-simple driver only
    specifies the type for the known to be LVDS panels, while all other
    panels are left as unknown and will be converted on a case-by-case
    basis as they all need to be carefully reviewed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190904132804.29680-2-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index bbf0c2e1c90f..416aebd23b6a 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -458,7 +458,8 @@ static int td043mtea1_probe(struct spi_device *spi)
 		return ret;
 	}
 
-	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td043mtea1_funcs);
+	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td043mtea1_funcs,
+		       DRM_MODE_CONNECTOR_DPI);
 
 	ret = drm_panel_add(&lcd->panel);
 	if (ret < 0) {

commit 6dbe0c4b0fc0646442b2b1580d022404e582fd7b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 23 22:32:43 2019 +0300

    drm/panel: Initialise panel dev and funcs through drm_panel_init()
    
    Instead of requiring all drivers to set the dev and funcs fields of
    drm_panel manually after calling drm_panel_init(), pass the data as
    arguments to the function. This simplifies the panel drivers, and will
    help future refactoring when adding new arguments to drm_panel_init().
    
    The panel drivers have been updated with the following Coccinelle
    semantic patch, with manual inspection to verify that no call to
    drm_panel_init() with a single argument still exists.
    
    @@
    expression panel;
    expression device;
    identifier ops;
    @@
     drm_panel_init(&panel
    +       , device, &ops
     );
     ...
    (
    -panel.dev = device;
    -panel.funcs = &ops;
    |
    -panel.funcs = &ops;
    -panel.dev = device;
    )
    
    Suggested-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823193245.23876-3-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index 84370562910f..bbf0c2e1c90f 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -458,9 +458,7 @@ static int td043mtea1_probe(struct spi_device *spi)
 		return ret;
 	}
 
-	drm_panel_init(&lcd->panel);
-	lcd->panel.dev = &lcd->spi->dev;
-	lcd->panel.funcs = &td043mtea1_funcs;
+	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td043mtea1_funcs);
 
 	ret = drm_panel_add(&lcd->panel);
 	if (ret < 0) {

commit b0baf85bb27ab028e726619f9162498f193cacbe
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Aug 17 13:21:24 2019 +0100

    drm/panel: tpo-td043mtea1: remove redundant assignment
    
    Variable val is initialized to a value in a for-loop that is
    never read and hence it is redundant. Remove it.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190817122124.29650-1-colin.king@canonical.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
index 3b4f30c0fdae..84370562910f 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -116,7 +116,7 @@ static void td043mtea1_write_gamma(struct td043mtea1_panel *lcd)
 	td043mtea1_write(lcd, 0x13, val);
 
 	/* gamma bits [7:0] */
-	for (val = i = 0; i < 12; i++)
+	for (i = 0; i < 12; i++)
 		td043mtea1_write(lcd, 0x14 + i, gamma[i] & 0xff);
 }
 

commit dc2e1e5b279966affbd11ff7cfef52eb634ca2c9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Aug 13 23:11:01 2019 +0300

    drm/panel: Add driver for the Toppoly TD043MTEA1 panel
    
    This panel is used on the OMAP3 Pandora.
    
    The code is based on the omapdrm-specific panel-tpo-td043mtea1 driver.
    
    v2:
    - fix checkpatch warnings
      o (lcd == NULL) => (!lcd) (sam)
      o alignment to open '(' (sam)
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190813201101.30980-10-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
new file mode 100644
index 000000000000..3b4f30c0fdae
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-tpo-td043mtea1.c
@@ -0,0 +1,509 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Toppoly TD043MTEA1 Panel Driver
+ *
+ * Copyright (C) 2019 Texas Instruments Incorporated
+ *
+ * Based on the omapdrm-specific panel-tpo-td043mtea1 driver
+ *
+ * Author: Gražvydas Ignotas <notasas@gmail.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_connector.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#define TPO_R02_MODE(x)			((x) & 7)
+#define TPO_R02_MODE_800x480		7
+#define TPO_R02_NCLK_RISING		BIT(3)
+#define TPO_R02_HSYNC_HIGH		BIT(4)
+#define TPO_R02_VSYNC_HIGH		BIT(5)
+
+#define TPO_R03_NSTANDBY		BIT(0)
+#define TPO_R03_EN_CP_CLK		BIT(1)
+#define TPO_R03_EN_VGL_PUMP		BIT(2)
+#define TPO_R03_EN_PWM			BIT(3)
+#define TPO_R03_DRIVING_CAP_100		BIT(4)
+#define TPO_R03_EN_PRE_CHARGE		BIT(6)
+#define TPO_R03_SOFTWARE_CTL		BIT(7)
+
+#define TPO_R04_NFLIP_H			BIT(0)
+#define TPO_R04_NFLIP_V			BIT(1)
+#define TPO_R04_CP_CLK_FREQ_1H		BIT(2)
+#define TPO_R04_VGL_FREQ_1H		BIT(4)
+
+#define TPO_R03_VAL_NORMAL \
+	(TPO_R03_NSTANDBY | TPO_R03_EN_CP_CLK | TPO_R03_EN_VGL_PUMP | \
+	 TPO_R03_EN_PWM | TPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \
+	 TPO_R03_SOFTWARE_CTL)
+
+#define TPO_R03_VAL_STANDBY \
+	(TPO_R03_DRIVING_CAP_100 | TPO_R03_EN_PRE_CHARGE | \
+	 TPO_R03_SOFTWARE_CTL)
+
+static const u16 td043mtea1_def_gamma[12] = {
+	105, 315, 381, 431, 490, 537, 579, 686, 780, 837, 880, 1023
+};
+
+struct td043mtea1_panel {
+	struct drm_panel panel;
+
+	struct spi_device *spi;
+	struct regulator *vcc_reg;
+	struct gpio_desc *reset_gpio;
+
+	unsigned int mode;
+	u16 gamma[12];
+	bool vmirror;
+	bool powered_on;
+	bool spi_suspended;
+	bool power_on_resume;
+};
+
+#define to_td043mtea1_device(p) container_of(p, struct td043mtea1_panel, panel)
+
+/* -----------------------------------------------------------------------------
+ * Hardware Access
+ */
+
+static int td043mtea1_write(struct td043mtea1_panel *lcd, u8 addr, u8 value)
+{
+	struct spi_message msg;
+	struct spi_transfer xfer;
+	u16 data;
+	int ret;
+
+	spi_message_init(&msg);
+
+	memset(&xfer, 0, sizeof(xfer));
+
+	data = ((u16)addr << 10) | (1 << 8) | value;
+	xfer.tx_buf = &data;
+	xfer.bits_per_word = 16;
+	xfer.len = 2;
+	spi_message_add_tail(&xfer, &msg);
+
+	ret = spi_sync(lcd->spi, &msg);
+	if (ret < 0)
+		dev_warn(&lcd->spi->dev, "failed to write to LCD reg (%d)\n",
+			 ret);
+
+	return ret;
+}
+
+static void td043mtea1_write_gamma(struct td043mtea1_panel *lcd)
+{
+	const u16 *gamma = lcd->gamma;
+	unsigned int i;
+	u8 val;
+
+	/* gamma bits [9:8] */
+	for (val = i = 0; i < 4; i++)
+		val |= (gamma[i] & 0x300) >> ((i + 1) * 2);
+	td043mtea1_write(lcd, 0x11, val);
+
+	for (val = i = 0; i < 4; i++)
+		val |= (gamma[i + 4] & 0x300) >> ((i + 1) * 2);
+	td043mtea1_write(lcd, 0x12, val);
+
+	for (val = i = 0; i < 4; i++)
+		val |= (gamma[i + 8] & 0x300) >> ((i + 1) * 2);
+	td043mtea1_write(lcd, 0x13, val);
+
+	/* gamma bits [7:0] */
+	for (val = i = 0; i < 12; i++)
+		td043mtea1_write(lcd, 0x14 + i, gamma[i] & 0xff);
+}
+
+static int td043mtea1_write_mirror(struct td043mtea1_panel *lcd)
+{
+	u8 reg4 = TPO_R04_NFLIP_H | TPO_R04_NFLIP_V |
+		TPO_R04_CP_CLK_FREQ_1H | TPO_R04_VGL_FREQ_1H;
+	if (lcd->vmirror)
+		reg4 &= ~TPO_R04_NFLIP_V;
+
+	return td043mtea1_write(lcd, 4, reg4);
+}
+
+static int td043mtea1_power_on(struct td043mtea1_panel *lcd)
+{
+	int ret;
+
+	if (lcd->powered_on)
+		return 0;
+
+	ret = regulator_enable(lcd->vcc_reg);
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the panel to stabilize. */
+	msleep(160);
+
+	gpiod_set_value(lcd->reset_gpio, 0);
+
+	td043mtea1_write(lcd, 2, TPO_R02_MODE(lcd->mode) | TPO_R02_NCLK_RISING);
+	td043mtea1_write(lcd, 3, TPO_R03_VAL_NORMAL);
+	td043mtea1_write(lcd, 0x20, 0xf0);
+	td043mtea1_write(lcd, 0x21, 0xf0);
+	td043mtea1_write_mirror(lcd);
+	td043mtea1_write_gamma(lcd);
+
+	lcd->powered_on = true;
+
+	return 0;
+}
+
+static void td043mtea1_power_off(struct td043mtea1_panel *lcd)
+{
+	if (!lcd->powered_on)
+		return;
+
+	td043mtea1_write(lcd, 3, TPO_R03_VAL_STANDBY | TPO_R03_EN_PWM);
+
+	gpiod_set_value(lcd->reset_gpio, 1);
+
+	/* wait for at least 2 vsyncs before cutting off power */
+	msleep(50);
+
+	td043mtea1_write(lcd, 3, TPO_R03_VAL_STANDBY);
+
+	regulator_disable(lcd->vcc_reg);
+
+	lcd->powered_on = false;
+}
+
+/* -----------------------------------------------------------------------------
+ * sysfs
+ */
+
+static ssize_t vmirror_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", lcd->vmirror);
+}
+
+static ssize_t vmirror_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+	int val;
+	int ret;
+
+	ret = kstrtoint(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	lcd->vmirror = !!val;
+
+	ret = td043mtea1_write_mirror(lcd);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t mode_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", lcd->mode);
+}
+
+static ssize_t mode_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	ret = kstrtol(buf, 0, &val);
+	if (ret != 0 || val & ~7)
+		return -EINVAL;
+
+	lcd->mode = val;
+
+	val |= TPO_R02_NCLK_RISING;
+	td043mtea1_write(lcd, 2, val);
+
+	return count;
+}
+
+static ssize_t gamma_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < ARRAY_SIZE(lcd->gamma); i++) {
+		ret = snprintf(buf + len, PAGE_SIZE - len, "%u ",
+			       lcd->gamma[i]);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t gamma_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+	unsigned int g[12];
+	unsigned int i;
+	int ret;
+
+	ret = sscanf(buf, "%u %u %u %u %u %u %u %u %u %u %u %u",
+		     &g[0], &g[1], &g[2], &g[3], &g[4], &g[5],
+		     &g[6], &g[7], &g[8], &g[9], &g[10], &g[11]);
+	if (ret != 12)
+		return -EINVAL;
+
+	for (i = 0; i < 12; i++)
+		lcd->gamma[i] = g[i];
+
+	td043mtea1_write_gamma(lcd);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(vmirror);
+static DEVICE_ATTR_RW(mode);
+static DEVICE_ATTR_RW(gamma);
+
+static struct attribute *td043mtea1_attrs[] = {
+	&dev_attr_vmirror.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_gamma.attr,
+	NULL,
+};
+
+static const struct attribute_group td043mtea1_attr_group = {
+	.attrs = td043mtea1_attrs,
+};
+
+/* -----------------------------------------------------------------------------
+ * Panel Operations
+ */
+
+static int td043mtea1_unprepare(struct drm_panel *panel)
+{
+	struct td043mtea1_panel *lcd = to_td043mtea1_device(panel);
+
+	if (!lcd->spi_suspended)
+		td043mtea1_power_off(lcd);
+
+	return 0;
+}
+
+static int td043mtea1_prepare(struct drm_panel *panel)
+{
+	struct td043mtea1_panel *lcd = to_td043mtea1_device(panel);
+	int ret;
+
+	/*
+	 * If we are resuming from system suspend, SPI might not be enabled
+	 * yet, so we'll program the LCD from SPI PM resume callback.
+	 */
+	if (lcd->spi_suspended)
+		return 0;
+
+	ret = td043mtea1_power_on(lcd);
+	if (ret) {
+		dev_err(&lcd->spi->dev, "%s: power on failed (%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct drm_display_mode td043mtea1_mode = {
+	.clock = 36000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 68,
+	.hsync_end = 800 + 68 + 1,
+	.htotal = 800 + 68 + 1 + 214,
+	.vdisplay = 480,
+	.vsync_start = 480 + 39,
+	.vsync_end = 480 + 39 + 1,
+	.vtotal = 480 + 39 + 1 + 34,
+	.vrefresh = 60,
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 94,
+	.height_mm = 56,
+};
+
+static int td043mtea1_get_modes(struct drm_panel *panel)
+{
+	struct drm_connector *connector = panel->connector;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(panel->drm, &td043mtea1_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = td043mtea1_mode.width_mm;
+	connector->display_info.height_mm = td043mtea1_mode.height_mm;
+	/*
+	 * FIXME: According to the datasheet sync signals are sampled on the
+	 * rising edge of the clock, but the code running on the OMAP3 Pandora
+	 * indicates sampling on the falling edge. This should be tested on a
+	 * real device.
+	 */
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH
+					  | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE
+					  | DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs td043mtea1_funcs = {
+	.unprepare = td043mtea1_unprepare,
+	.prepare = td043mtea1_prepare,
+	.get_modes = td043mtea1_get_modes,
+};
+
+/* -----------------------------------------------------------------------------
+ * Power Management, Probe and Remove
+ */
+
+static int __maybe_unused td043mtea1_suspend(struct device *dev)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+
+	if (lcd->powered_on) {
+		td043mtea1_power_off(lcd);
+		lcd->powered_on = true;
+	}
+
+	lcd->spi_suspended = true;
+
+	return 0;
+}
+
+static int __maybe_unused td043mtea1_resume(struct device *dev)
+{
+	struct td043mtea1_panel *lcd = dev_get_drvdata(dev);
+	int ret;
+
+	lcd->spi_suspended = false;
+
+	if (lcd->powered_on) {
+		lcd->powered_on = false;
+		ret = td043mtea1_power_on(lcd);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(td043mtea1_pm_ops, td043mtea1_suspend,
+			 td043mtea1_resume);
+
+static int td043mtea1_probe(struct spi_device *spi)
+{
+	struct td043mtea1_panel *lcd;
+	int ret;
+
+	lcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);
+	if (lcd == NULL)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, lcd);
+	lcd->spi = spi;
+	lcd->mode = TPO_R02_MODE_800x480;
+	memcpy(lcd->gamma, td043mtea1_def_gamma, sizeof(lcd->gamma));
+
+	lcd->vcc_reg = devm_regulator_get(&spi->dev, "vcc");
+	if (IS_ERR(lcd->vcc_reg)) {
+		dev_err(&spi->dev, "failed to get VCC regulator\n");
+		return PTR_ERR(lcd->vcc_reg);
+	}
+
+	lcd->reset_gpio = devm_gpiod_get(&spi->dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(lcd->reset_gpio)) {
+		dev_err(&spi->dev, "failed to get reset GPIO\n");
+		return PTR_ERR(lcd->reset_gpio);
+	}
+
+	spi->bits_per_word = 16;
+	spi->mode = SPI_MODE_0;
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev, "failed to setup SPI: %d\n", ret);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&spi->dev.kobj, &td043mtea1_attr_group);
+	if (ret < 0) {
+		dev_err(&spi->dev, "failed to create sysfs files\n");
+		return ret;
+	}
+
+	drm_panel_init(&lcd->panel);
+	lcd->panel.dev = &lcd->spi->dev;
+	lcd->panel.funcs = &td043mtea1_funcs;
+
+	ret = drm_panel_add(&lcd->panel);
+	if (ret < 0) {
+		sysfs_remove_group(&spi->dev.kobj, &td043mtea1_attr_group);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int td043mtea1_remove(struct spi_device *spi)
+{
+	struct td043mtea1_panel *lcd = spi_get_drvdata(spi);
+
+	drm_panel_remove(&lcd->panel);
+	drm_panel_disable(&lcd->panel);
+	drm_panel_unprepare(&lcd->panel);
+
+	sysfs_remove_group(&spi->dev.kobj, &td043mtea1_attr_group);
+
+	return 0;
+}
+
+static const struct of_device_id td043mtea1_of_match[] = {
+	{ .compatible = "tpo,td043mtea1", },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, td043mtea1_of_match);
+
+static struct spi_driver td043mtea1_driver = {
+	.probe		= td043mtea1_probe,
+	.remove		= td043mtea1_remove,
+	.driver		= {
+		.name	= "panel-tpo-td043mtea1",
+		.pm	= &td043mtea1_pm_ops,
+		.of_match_table = td043mtea1_of_match,
+	},
+};
+
+module_spi_driver(td043mtea1_driver);
+
+MODULE_ALIAS("spi:tpo,td043mtea1");
+MODULE_AUTHOR("Gražvydas Ignotas <notasas@gmail.com>");
+MODULE_DESCRIPTION("TPO TD043MTEA1 Panel Driver");
+MODULE_LICENSE("GPL");
