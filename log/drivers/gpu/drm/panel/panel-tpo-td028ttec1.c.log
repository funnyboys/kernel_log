commit dba9bf0a98c5fcfb3f616bf2446d5aeef67b632c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 8 14:51:05 2020 +0100

    drm: panel: fix excessive stack usage in td028ttec1_prepare
    
    With gcc -O3 in combination with the structleak plug, the compiler can
    inline very aggressively, leading to rather large stack usage:
    
    drivers/gpu/drm/panel/panel-tpo-td028ttec1.c: In function 'td028ttec1_prepare':
    drivers/gpu/drm/panel/panel-tpo-td028ttec1.c:233:1: error: the frame size of 2768 bytes is larger than 2048 bytes [-Werror=frame-larger-than=]
     }
    
    Marking jbt_reg_write_*() as noinline avoids the case where
    multiple instances of this function get inlined into the same
    stack frame and each one adds a copy of 'tx_buf'.
    
    The compiler is clearly making some bad decisions here, but I
    did not open a new bug report as this only happens in combination
    with the structleak plugin.
    
    This fixes mmtom ("init/Kconfig: enable -O3 for all arches")
    
    Link: https://lore.kernel.org/lkml/CAK8P3a3jAnFZA3GFRtdYdg1-i-oih3pOQzkkrK-X3BGsFrMiZQ@mail.gmail.com/
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org> [fix indent]
    Link: https://patchwork.freedesktop.org/patch/msgid/20200108135116.3687988-1-arnd@arndb.de

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index cf29405a2dbe..aeca15dfeb3c 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -86,7 +86,12 @@ struct td028ttec1_panel {
 
 #define to_td028ttec1_device(p) container_of(p, struct td028ttec1_panel, panel)
 
-static int jbt_ret_write_0(struct td028ttec1_panel *lcd, u8 reg, int *err)
+/*
+ * noinline_for_stack so we don't get multiple copies of tx_buf
+ * on the stack in case of gcc-plugin-structleak
+ */
+static int noinline_for_stack
+jbt_ret_write_0(struct td028ttec1_panel *lcd, u8 reg, int *err)
 {
 	struct spi_device *spi = lcd->spi;
 	u16 tx_buf = JBT_COMMAND | reg;
@@ -105,8 +110,9 @@ static int jbt_ret_write_0(struct td028ttec1_panel *lcd, u8 reg, int *err)
 	return ret;
 }
 
-static int jbt_reg_write_1(struct td028ttec1_panel *lcd,
-			   u8 reg, u8 data, int *err)
+static int noinline_for_stack
+jbt_reg_write_1(struct td028ttec1_panel *lcd,
+		u8 reg, u8 data, int *err)
 {
 	struct spi_device *spi = lcd->spi;
 	u16 tx_buf[2];
@@ -128,8 +134,9 @@ static int jbt_reg_write_1(struct td028ttec1_panel *lcd,
 	return ret;
 }
 
-static int jbt_reg_write_2(struct td028ttec1_panel *lcd,
-			   u8 reg, u16 data, int *err)
+static int noinline_for_stack
+jbt_reg_write_2(struct td028ttec1_panel *lcd,
+		u8 reg, u16 data, int *err)
 {
 	struct spi_device *spi = lcd->spi;
 	u16 tx_buf[3];

commit 3555339f6227ed0be2478f2993c5da825169ace8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:52 2019 +0100

    drm/panel: tpo-td028ttec1: use drm_panel backlight support
    
    Use the backlight support in drm_panel to simplify the driver
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-25-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index 37252590b541..cf29405a2dbe 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -17,7 +17,6 @@
  * H. Nikolaus Schaller <hns@goldelico.com>
  */
 
-#include <linux/backlight.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/spi/spi.h>
@@ -83,7 +82,6 @@ struct td028ttec1_panel {
 	struct drm_panel panel;
 
 	struct spi_device *spi;
-	struct backlight_device *backlight;
 };
 
 #define to_td028ttec1_device(p) container_of(p, struct td028ttec1_panel, panel)
@@ -243,8 +241,6 @@ static int td028ttec1_enable(struct drm_panel *panel)
 	if (ret)
 		return ret;
 
-	backlight_enable(lcd->backlight);
-
 	return 0;
 }
 
@@ -252,8 +248,6 @@ static int td028ttec1_disable(struct drm_panel *panel)
 {
 	struct td028ttec1_panel *lcd = to_td028ttec1_device(panel);
 
-	backlight_disable(lcd->backlight);
-
 	jbt_ret_write_0(lcd, JBT_REG_DISPLAY_OFF, NULL);
 
 	return 0;
@@ -334,10 +328,6 @@ static int td028ttec1_probe(struct spi_device *spi)
 	spi_set_drvdata(spi, lcd);
 	lcd->spi = spi;
 
-	lcd->backlight = devm_of_find_backlight(&spi->dev);
-	if (IS_ERR(lcd->backlight))
-		return PTR_ERR(lcd->backlight);
-
 	spi->mode = SPI_MODE_3;
 	spi->bits_per_word = 9;
 
@@ -350,6 +340,10 @@ static int td028ttec1_probe(struct spi_device *spi)
 	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td028ttec1_funcs,
 		       DRM_MODE_CONNECTOR_DPI);
 
+	ret = drm_panel_of_backlight(&lcd->panel);
+	if (ret)
+		return ret;
+
 	return drm_panel_add(&lcd->panel);
 }
 

commit aa6c43644bc57b3d297247746184d1d82ed9de82
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:35 2019 +0100

    drm/panel: drop drm_device from drm_panel
    
    The panel drivers used drm_panel.drm for two purposes:
    1) Argument to drm_mode_duplicate()
    2) drm->dev was used in error messages
    
    The first usage is replaced with drm_connector.dev
    - drm_connector is already connected to a drm_device
      and we have a valid connector
    
    The second usage is replaced with drm_panel.dev
    - this makes drivers more consistent in their dev argument
      used for dev_err() and friends
    
    With these replacements there are no more uses of drm_panel.drm,
    so it is removed from struct drm_panel.
    With this change drm_panel_attach() and drm_panel_detach()
    no longer have any use as they are empty functions.
    
    v2:
      - editorial correction in changelog (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index 5230176bd8e6..37252590b541 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -292,7 +292,7 @@ static int td028ttec1_get_modes(struct drm_panel *panel,
 {
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(panel->drm, &td028ttec1_mode);
+	mode = drm_mode_duplicate(connector->dev, &td028ttec1_mode);
 	if (!mode)
 		return -ENOMEM;
 

commit 0ce8ddd8e06dcbcd8d31607921c31ad1c32ad56c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:33 2019 +0100

    drm/panel: add drm_connector argument to get_modes()
    
    Today the bridge creates the drm_connector, but that is planned
    to be moved to the display drivers.
    To facilitate this, update drm_panel_funcs.get_modes() to
    take drm_connector as an argument.
    All panel drivers implementing get_modes() are updated.
    
    v2:
      - drop accidental change (Laurent)
      - update docs for get_modes (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-6-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index c44d6a65c0aa..5230176bd8e6 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -287,9 +287,9 @@ static const struct drm_display_mode td028ttec1_mode = {
 	.height_mm = 58,
 };
 
-static int td028ttec1_get_modes(struct drm_panel *panel)
+static int td028ttec1_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
 {
-	struct drm_connector *connector = panel->connector;
 	struct drm_display_mode *mode;
 
 	mode = drm_mode_duplicate(panel->drm, &td028ttec1_mode);

commit 2e79e22e092acd55da0b2db066e4826d7d152c41
Merge: f1b4a9217efd 7d194c2100ad
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 23 12:02:47 2019 +0200

    Merge v5.4-rc4 into drm-next
    
    Thierry needs fd70c7755bf0 ("drm/bridge: tc358767: fix max_tu_symbol
    value") to be able to merge his dp_link patch series.
    
    Some adjacent changes conflicts, plus some clashes in i915 due to
    cherry-picking and git trying to be helpful and leaving both versions
    in.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 692a5424b5b2a574d5050c0a5f93ae0429c4cb08
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Oct 7 20:08:00 2019 +0300

    drm/panel: tpo-td028ttec1: Fix SPI alias
    
    The panel-tpo-td028ttec1 driver incorrectly includes the OF vendor
    prefix in its SPI alias. Fix it.
    
    Fixes: 415b8dd08711 ("drm/panel: Add driver for the Toppoly TD028TTEC1 panel")
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191007170801.27647-5-laurent.pinchart@ideasonboard.com
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: Andreas Kemnade <andreas@kemnade.info>

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index d7b2e34626ef..f2baff827f50 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -375,8 +375,7 @@ static const struct of_device_id td028ttec1_of_match[] = {
 MODULE_DEVICE_TABLE(of, td028ttec1_of_match);
 
 static const struct spi_device_id td028ttec1_ids[] = {
-	{ "tpo,td028ttec1", 0},
-	{ "toppoly,td028ttec1", 0 },
+	{ "td028ttec1", 0 },
 	{ /* sentinel */ }
 };
 

commit 9a2654c0f62a1704f36acb6329f9ccbd539f75ad
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 4 16:28:03 2019 +0300

    drm/panel: Add and fill drm_panel type field
    
    Add a type field to the drm_panel structure to report the panel type,
    using DRM_MODE_CONNECTOR_* macros (the values that make sense are LVDS,
    eDP, DSI and DPI). This will be used to initialise the corresponding
    connector type.
    
    Update all panel drivers accordingly. The panel-simple driver only
    specifies the type for the known to be LVDS panels, while all other
    panels are left as unknown and will be converted on a case-by-case
    basis as they all need to be carefully reviewed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190904132804.29680-2-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index 8b1148d74e7b..1d08d03f509d 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -347,7 +347,8 @@ static int td028ttec1_probe(struct spi_device *spi)
 		return ret;
 	}
 
-	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td028ttec1_funcs);
+	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td028ttec1_funcs,
+		       DRM_MODE_CONNECTOR_DPI);
 
 	return drm_panel_add(&lcd->panel);
 }

commit 6dbe0c4b0fc0646442b2b1580d022404e582fd7b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 23 22:32:43 2019 +0300

    drm/panel: Initialise panel dev and funcs through drm_panel_init()
    
    Instead of requiring all drivers to set the dev and funcs fields of
    drm_panel manually after calling drm_panel_init(), pass the data as
    arguments to the function. This simplifies the panel drivers, and will
    help future refactoring when adding new arguments to drm_panel_init().
    
    The panel drivers have been updated with the following Coccinelle
    semantic patch, with manual inspection to verify that no call to
    drm_panel_init() with a single argument still exists.
    
    @@
    expression panel;
    expression device;
    identifier ops;
    @@
     drm_panel_init(&panel
    +       , device, &ops
     );
     ...
    (
    -panel.dev = device;
    -panel.funcs = &ops;
    |
    -panel.funcs = &ops;
    -panel.dev = device;
    )
    
    Suggested-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823193245.23876-3-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index d7b2e34626ef..8b1148d74e7b 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -347,9 +347,7 @@ static int td028ttec1_probe(struct spi_device *spi)
 		return ret;
 	}
 
-	drm_panel_init(&lcd->panel);
-	lcd->panel.dev = &lcd->spi->dev;
-	lcd->panel.funcs = &td028ttec1_funcs;
+	drm_panel_init(&lcd->panel, &lcd->spi->dev, &td028ttec1_funcs);
 
 	return drm_panel_add(&lcd->panel);
 }

commit dc2e1e5b279966affbd11ff7cfef52eb634ca2c9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Aug 13 23:11:01 2019 +0300

    drm/panel: Add driver for the Toppoly TD043MTEA1 panel
    
    This panel is used on the OMAP3 Pandora.
    
    The code is based on the omapdrm-specific panel-tpo-td043mtea1 driver.
    
    v2:
    - fix checkpatch warnings
      o (lcd == NULL) => (!lcd) (sam)
      o alignment to open '(' (sam)
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190813201101.30980-10-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
index a400c83486b4..d7b2e34626ef 100644
--- a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -328,7 +328,7 @@ static int td028ttec1_probe(struct spi_device *spi)
 	int ret;
 
 	lcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);
-	if (lcd == NULL)
+	if (!lcd)
 		return -ENOMEM;
 
 	spi_set_drvdata(spi, lcd);

commit 415b8dd087118829fd37548b0d75592e297c1fa9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Aug 13 23:11:00 2019 +0300

    drm/panel: Add driver for the Toppoly TD028TTEC1 panel
    
    This panel is used on the OpenMoko Neo FreeRunner and Neo 1973.
    
    The code is based on the omapdrm-specific panel-tpo-td028ttec1 driver.
    
    v2:
    - fix checkpatch warnings:
      o (lcd == NULL) => (!lcd) (sam)
      o (1 << X) => BIT(X) (sam)
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190813201101.30980-9-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
new file mode 100644
index 000000000000..a400c83486b4
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-tpo-td028ttec1.c
@@ -0,0 +1,399 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Toppoly TD028TTEC1 Panel Driver
+ *
+ * Copyright (C) 2019 Texas Instruments Incorporated
+ *
+ * Based on the omapdrm-specific panel-tpo-td028ttec1 driver
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
+ *
+ * Neo 1973 code (jbt6k74.c):
+ * Copyright (C) 2006-2007 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * Ported and adapted from Neo 1973 U-Boot by:
+ * H. Nikolaus Schaller <hns@goldelico.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_connector.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#define JBT_COMMAND			0x000
+#define JBT_DATA			0x100
+
+#define JBT_REG_SLEEP_IN		0x10
+#define JBT_REG_SLEEP_OUT		0x11
+
+#define JBT_REG_DISPLAY_OFF		0x28
+#define JBT_REG_DISPLAY_ON		0x29
+
+#define JBT_REG_RGB_FORMAT		0x3a
+#define JBT_REG_QUAD_RATE		0x3b
+
+#define JBT_REG_POWER_ON_OFF		0xb0
+#define JBT_REG_BOOSTER_OP		0xb1
+#define JBT_REG_BOOSTER_MODE		0xb2
+#define JBT_REG_BOOSTER_FREQ		0xb3
+#define JBT_REG_OPAMP_SYSCLK		0xb4
+#define JBT_REG_VSC_VOLTAGE		0xb5
+#define JBT_REG_VCOM_VOLTAGE		0xb6
+#define JBT_REG_EXT_DISPL		0xb7
+#define JBT_REG_OUTPUT_CONTROL		0xb8
+#define JBT_REG_DCCLK_DCEV		0xb9
+#define JBT_REG_DISPLAY_MODE1		0xba
+#define JBT_REG_DISPLAY_MODE2		0xbb
+#define JBT_REG_DISPLAY_MODE		0xbc
+#define JBT_REG_ASW_SLEW		0xbd
+#define JBT_REG_DUMMY_DISPLAY		0xbe
+#define JBT_REG_DRIVE_SYSTEM		0xbf
+
+#define JBT_REG_SLEEP_OUT_FR_A		0xc0
+#define JBT_REG_SLEEP_OUT_FR_B		0xc1
+#define JBT_REG_SLEEP_OUT_FR_C		0xc2
+#define JBT_REG_SLEEP_IN_LCCNT_D	0xc3
+#define JBT_REG_SLEEP_IN_LCCNT_E	0xc4
+#define JBT_REG_SLEEP_IN_LCCNT_F	0xc5
+#define JBT_REG_SLEEP_IN_LCCNT_G	0xc6
+
+#define JBT_REG_GAMMA1_FINE_1		0xc7
+#define JBT_REG_GAMMA1_FINE_2		0xc8
+#define JBT_REG_GAMMA1_INCLINATION	0xc9
+#define JBT_REG_GAMMA1_BLUE_OFFSET	0xca
+
+#define JBT_REG_BLANK_CONTROL		0xcf
+#define JBT_REG_BLANK_TH_TV		0xd0
+#define JBT_REG_CKV_ON_OFF		0xd1
+#define JBT_REG_CKV_1_2			0xd2
+#define JBT_REG_OEV_TIMING		0xd3
+#define JBT_REG_ASW_TIMING_1		0xd4
+#define JBT_REG_ASW_TIMING_2		0xd5
+
+#define JBT_REG_HCLOCK_VGA		0xec
+#define JBT_REG_HCLOCK_QVGA		0xed
+
+struct td028ttec1_panel {
+	struct drm_panel panel;
+
+	struct spi_device *spi;
+	struct backlight_device *backlight;
+};
+
+#define to_td028ttec1_device(p) container_of(p, struct td028ttec1_panel, panel)
+
+static int jbt_ret_write_0(struct td028ttec1_panel *lcd, u8 reg, int *err)
+{
+	struct spi_device *spi = lcd->spi;
+	u16 tx_buf = JBT_COMMAND | reg;
+	int ret;
+
+	if (err && *err)
+		return *err;
+
+	ret = spi_write(spi, (u8 *)&tx_buf, sizeof(tx_buf));
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s: SPI write failed: %d\n", __func__, ret);
+		if (err)
+			*err = ret;
+	}
+
+	return ret;
+}
+
+static int jbt_reg_write_1(struct td028ttec1_panel *lcd,
+			   u8 reg, u8 data, int *err)
+{
+	struct spi_device *spi = lcd->spi;
+	u16 tx_buf[2];
+	int ret;
+
+	if (err && *err)
+		return *err;
+
+	tx_buf[0] = JBT_COMMAND | reg;
+	tx_buf[1] = JBT_DATA | data;
+
+	ret = spi_write(spi, (u8 *)tx_buf, sizeof(tx_buf));
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s: SPI write failed: %d\n", __func__, ret);
+		if (err)
+			*err = ret;
+	}
+
+	return ret;
+}
+
+static int jbt_reg_write_2(struct td028ttec1_panel *lcd,
+			   u8 reg, u16 data, int *err)
+{
+	struct spi_device *spi = lcd->spi;
+	u16 tx_buf[3];
+	int ret;
+
+	if (err && *err)
+		return *err;
+
+	tx_buf[0] = JBT_COMMAND | reg;
+	tx_buf[1] = JBT_DATA | (data >> 8);
+	tx_buf[2] = JBT_DATA | (data & 0xff);
+
+	ret = spi_write(spi, (u8 *)tx_buf, sizeof(tx_buf));
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s: SPI write failed: %d\n", __func__, ret);
+		if (err)
+			*err = ret;
+	}
+
+	return ret;
+}
+
+static int td028ttec1_prepare(struct drm_panel *panel)
+{
+	struct td028ttec1_panel *lcd = to_td028ttec1_device(panel);
+	unsigned int i;
+	int ret = 0;
+
+	/* Three times command zero */
+	for (i = 0; i < 3; ++i) {
+		jbt_ret_write_0(lcd, 0x00, &ret);
+		usleep_range(1000, 2000);
+	}
+
+	/* deep standby out */
+	jbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x17, &ret);
+
+	/* RGB I/F on, RAM write off, QVGA through, SIGCON enable */
+	jbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE, 0x80, &ret);
+
+	/* Quad mode off */
+	jbt_reg_write_1(lcd, JBT_REG_QUAD_RATE, 0x00, &ret);
+
+	/* AVDD on, XVDD on */
+	jbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x16, &ret);
+
+	/* Output control */
+	jbt_reg_write_2(lcd, JBT_REG_OUTPUT_CONTROL, 0xfff9, &ret);
+
+	/* Sleep mode off */
+	jbt_ret_write_0(lcd, JBT_REG_SLEEP_OUT, &ret);
+
+	/* at this point we have like 50% grey */
+
+	/* initialize register set */
+	jbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE1, 0x01, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_DISPLAY_MODE2, 0x00, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_RGB_FORMAT, 0x60, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_DRIVE_SYSTEM, 0x10, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_BOOSTER_OP, 0x56, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_BOOSTER_MODE, 0x33, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_BOOSTER_FREQ, 0x11, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_BOOSTER_FREQ, 0x11, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_OPAMP_SYSCLK, 0x02, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_VSC_VOLTAGE, 0x2b, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_VCOM_VOLTAGE, 0x40, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_EXT_DISPL, 0x03, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_DCCLK_DCEV, 0x04, &ret);
+	/*
+	 * default of 0x02 in JBT_REG_ASW_SLEW responsible for 72Hz requirement
+	 * to avoid red / blue flicker
+	 */
+	jbt_reg_write_1(lcd, JBT_REG_ASW_SLEW, 0x04, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_DUMMY_DISPLAY, 0x00, &ret);
+
+	jbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_A, 0x11, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_B, 0x11, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_SLEEP_OUT_FR_C, 0x11, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_D, 0x2040, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_E, 0x60c0, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_F, 0x1020, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_SLEEP_IN_LCCNT_G, 0x60c0, &ret);
+
+	jbt_reg_write_2(lcd, JBT_REG_GAMMA1_FINE_1, 0x5533, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_GAMMA1_FINE_2, 0x00, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_GAMMA1_INCLINATION, 0x00, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_GAMMA1_BLUE_OFFSET, 0x00, &ret);
+
+	jbt_reg_write_2(lcd, JBT_REG_HCLOCK_VGA, 0x1f0, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_BLANK_CONTROL, 0x02, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_BLANK_TH_TV, 0x0804, &ret);
+
+	jbt_reg_write_1(lcd, JBT_REG_CKV_ON_OFF, 0x01, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_CKV_1_2, 0x0000, &ret);
+
+	jbt_reg_write_2(lcd, JBT_REG_OEV_TIMING, 0x0d0e, &ret);
+	jbt_reg_write_2(lcd, JBT_REG_ASW_TIMING_1, 0x11a4, &ret);
+	jbt_reg_write_1(lcd, JBT_REG_ASW_TIMING_2, 0x0e, &ret);
+
+	return ret;
+}
+
+static int td028ttec1_enable(struct drm_panel *panel)
+{
+	struct td028ttec1_panel *lcd = to_td028ttec1_device(panel);
+	int ret;
+
+	ret = jbt_ret_write_0(lcd, JBT_REG_DISPLAY_ON, NULL);
+	if (ret)
+		return ret;
+
+	backlight_enable(lcd->backlight);
+
+	return 0;
+}
+
+static int td028ttec1_disable(struct drm_panel *panel)
+{
+	struct td028ttec1_panel *lcd = to_td028ttec1_device(panel);
+
+	backlight_disable(lcd->backlight);
+
+	jbt_ret_write_0(lcd, JBT_REG_DISPLAY_OFF, NULL);
+
+	return 0;
+}
+
+static int td028ttec1_unprepare(struct drm_panel *panel)
+{
+	struct td028ttec1_panel *lcd = to_td028ttec1_device(panel);
+
+	jbt_reg_write_2(lcd, JBT_REG_OUTPUT_CONTROL, 0x8002, NULL);
+	jbt_ret_write_0(lcd, JBT_REG_SLEEP_IN, NULL);
+	jbt_reg_write_1(lcd, JBT_REG_POWER_ON_OFF, 0x00, NULL);
+
+	return 0;
+}
+
+static const struct drm_display_mode td028ttec1_mode = {
+	.clock = 22153,
+	.hdisplay = 480,
+	.hsync_start = 480 + 24,
+	.hsync_end = 480 + 24 + 8,
+	.htotal = 480 + 24 + 8 + 8,
+	.vdisplay = 640,
+	.vsync_start = 640 + 4,
+	.vsync_end = 640 + 4 + 2,
+	.vtotal = 640 + 4 + 2 + 2,
+	.vrefresh = 66,
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 43,
+	.height_mm = 58,
+};
+
+static int td028ttec1_get_modes(struct drm_panel *panel)
+{
+	struct drm_connector *connector = panel->connector;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(panel->drm, &td028ttec1_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = td028ttec1_mode.width_mm;
+	connector->display_info.height_mm = td028ttec1_mode.height_mm;
+	/*
+	 * FIXME: According to the datasheet sync signals are sampled on the
+	 * rising edge of the clock, but the code running on the OpenMoko Neo
+	 * FreeRunner and Neo 1973 indicates sampling on the falling edge. This
+	 * should be tested on a real device.
+	 */
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH
+					  | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE
+					  | DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs td028ttec1_funcs = {
+	.prepare = td028ttec1_prepare,
+	.enable = td028ttec1_enable,
+	.disable = td028ttec1_disable,
+	.unprepare = td028ttec1_unprepare,
+	.get_modes = td028ttec1_get_modes,
+};
+
+static int td028ttec1_probe(struct spi_device *spi)
+{
+	struct td028ttec1_panel *lcd;
+	int ret;
+
+	lcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);
+	if (lcd == NULL)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, lcd);
+	lcd->spi = spi;
+
+	lcd->backlight = devm_of_find_backlight(&spi->dev);
+	if (IS_ERR(lcd->backlight))
+		return PTR_ERR(lcd->backlight);
+
+	spi->mode = SPI_MODE_3;
+	spi->bits_per_word = 9;
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev, "failed to setup SPI: %d\n", ret);
+		return ret;
+	}
+
+	drm_panel_init(&lcd->panel);
+	lcd->panel.dev = &lcd->spi->dev;
+	lcd->panel.funcs = &td028ttec1_funcs;
+
+	return drm_panel_add(&lcd->panel);
+}
+
+static int td028ttec1_remove(struct spi_device *spi)
+{
+	struct td028ttec1_panel *lcd = spi_get_drvdata(spi);
+
+	drm_panel_remove(&lcd->panel);
+	drm_panel_disable(&lcd->panel);
+	drm_panel_unprepare(&lcd->panel);
+
+	return 0;
+}
+
+static const struct of_device_id td028ttec1_of_match[] = {
+	{ .compatible = "tpo,td028ttec1", },
+	/* DT backward compatibility. */
+	{ .compatible = "toppoly,td028ttec1", },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, td028ttec1_of_match);
+
+static const struct spi_device_id td028ttec1_ids[] = {
+	{ "tpo,td028ttec1", 0},
+	{ "toppoly,td028ttec1", 0 },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(spi, td028ttec1_ids);
+
+static struct spi_driver td028ttec1_driver = {
+	.probe		= td028ttec1_probe,
+	.remove		= td028ttec1_remove,
+	.id_table	= td028ttec1_ids,
+	.driver		= {
+		.name   = "panel-tpo-td028ttec1",
+		.of_match_table = td028ttec1_of_match,
+	},
+};
+
+module_spi_driver(td028ttec1_driver);
+
+MODULE_AUTHOR("H. Nikolaus Schaller <hns@goldelico.com>");
+MODULE_DESCRIPTION("Toppoly TD028TTEC1 panel driver");
+MODULE_LICENSE("GPL");
