commit 16b4511d836c7228cd0f59e5b43d52c9d9bcc68f
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Wed Apr 8 11:58:30 2020 +0200

    drm/panel: nt39016: Add support for 50 Hz refresh rate
    
    By changing the pixel clock and the length of the back porch, it is
    possible to obtain a perfect 50 Hz refresh rate.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200408095830.8131-2-paul@crapouillou.net
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index f1286cf6528b..05cae8d62d56 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -325,7 +325,7 @@ static int nt39016_remove(struct spi_device *spi)
 }
 
 static const struct drm_display_mode kd035g6_display_modes[] = {
-	{
+	{	/* 60 Hz */
 		.clock = 6000,
 		.hdisplay = 320,
 		.hsync_start = 320 + 10,
@@ -338,6 +338,19 @@ static const struct drm_display_mode kd035g6_display_modes[] = {
 		.vrefresh = 60,
 		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	},
+	{	/* 50 Hz */
+		.clock = 5400,
+		.hdisplay = 320,
+		.hsync_start = 320 + 42,
+		.hsync_end = 320 + 42 + 50,
+		.htotal = 320 + 42 + 50 + 20,
+		.vdisplay = 240,
+		.vsync_start = 240 + 5,
+		.vsync_end = 240 + 5 + 1,
+		.vtotal = 240 + 5 + 1 + 4,
+		.vrefresh = 50,
+		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	},
 };
 
 static const struct nt39016_panel_info kd035g6_info = {

commit fa361758b109aa7a4ce309fbd1adba2d9d76a197
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Wed Apr 8 11:58:29 2020 +0200

    drm/panel: nt39016: Add support for multiple modes
    
    Add support for multiple drm_display_mode entries. This will allow to
    add a 50 Hz mode later.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200408095830.8131-1-paul@crapouillou.net
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index a470810f7dbe..f1286cf6528b 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -49,7 +49,8 @@ enum nt39016_regs {
 #define NT39016_SYSTEM_STANDBY	BIT(1)
 
 struct nt39016_panel_info {
-	struct drm_display_mode display_mode;
+	const struct drm_display_mode *display_modes;
+	unsigned int num_modes;
 	u16 width_mm, height_mm;
 	u32 bus_format, bus_flags;
 };
@@ -212,15 +213,22 @@ static int nt39016_get_modes(struct drm_panel *drm_panel,
 	struct nt39016 *panel = to_nt39016(drm_panel);
 	const struct nt39016_panel_info *panel_info = panel->panel_info;
 	struct drm_display_mode *mode;
+	unsigned int i;
 
-	mode = drm_mode_duplicate(connector->dev, &panel_info->display_mode);
-	if (!mode)
-		return -ENOMEM;
+	for (i = 0; i < panel_info->num_modes; i++) {
+		mode = drm_mode_duplicate(connector->dev,
+					  &panel_info->display_modes[i]);
+		if (!mode)
+			return -ENOMEM;
+
+		drm_mode_set_name(mode);
 
-	drm_mode_set_name(mode);
+		mode->type = DRM_MODE_TYPE_DRIVER;
+		if (panel_info->num_modes == 1)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
 
-	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
-	drm_mode_probed_add(connector, mode);
+		drm_mode_probed_add(connector, mode);
+	}
 
 	connector->display_info.bpc = 8;
 	connector->display_info.width_mm = panel_info->width_mm;
@@ -230,7 +238,7 @@ static int nt39016_get_modes(struct drm_panel *drm_panel,
 					 &panel_info->bus_format, 1);
 	connector->display_info.bus_flags = panel_info->bus_flags;
 
-	return 1;
+	return panel_info->num_modes;
 }
 
 static const struct drm_panel_funcs nt39016_funcs = {
@@ -316,8 +324,8 @@ static int nt39016_remove(struct spi_device *spi)
 	return 0;
 }
 
-static const struct nt39016_panel_info kd035g6_info = {
-	.display_mode = {
+static const struct drm_display_mode kd035g6_display_modes[] = {
+	{
 		.clock = 6000,
 		.hdisplay = 320,
 		.hsync_start = 320 + 10,
@@ -330,6 +338,11 @@ static const struct nt39016_panel_info kd035g6_info = {
 		.vrefresh = 60,
 		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	},
+};
+
+static const struct nt39016_panel_info kd035g6_info = {
+	.display_modes = kd035g6_display_modes,
+	.num_modes = ARRAY_SIZE(kd035g6_display_modes),
 	.width_mm = 71,
 	.height_mm = 53,
 	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,

commit aa6c43644bc57b3d297247746184d1d82ed9de82
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:35 2019 +0100

    drm/panel: drop drm_device from drm_panel
    
    The panel drivers used drm_panel.drm for two purposes:
    1) Argument to drm_mode_duplicate()
    2) drm->dev was used in error messages
    
    The first usage is replaced with drm_connector.dev
    - drm_connector is already connected to a drm_device
      and we have a valid connector
    
    The second usage is replaced with drm_panel.dev
    - this makes drivers more consistent in their dev argument
      used for dev_err() and friends
    
    With these replacements there are no more uses of drm_panel.drm,
    so it is removed from struct drm_panel.
    With this change drm_panel_attach() and drm_panel_detach()
    no longer have any use as they are empty functions.
    
    v2:
      - editorial correction in changelog (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index 91ea49c05611..a470810f7dbe 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -213,7 +213,7 @@ static int nt39016_get_modes(struct drm_panel *drm_panel,
 	const struct nt39016_panel_info *panel_info = panel->panel_info;
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(drm_panel->drm, &panel_info->display_mode);
+	mode = drm_mode_duplicate(connector->dev, &panel_info->display_mode);
 	if (!mode)
 		return -ENOMEM;
 

commit 0ce8ddd8e06dcbcd8d31607921c31ad1c32ad56c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Dec 7 15:03:33 2019 +0100

    drm/panel: add drm_connector argument to get_modes()
    
    Today the bridge creates the drm_connector, but that is planned
    to be moved to the display drivers.
    To facilitate this, update drm_panel_funcs.get_modes() to
    take drm_connector as an argument.
    All panel drivers implementing get_modes() are updated.
    
    v2:
      - drop accidental change (Laurent)
      - update docs for get_modes (Laurent)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Stefan Mavrodiev <stefan@olimex.com>
    Cc: Robert Chiras <robert.chiras@nxp.com>
    Cc: "Guido Günther" <agx@sigxcpu.org>
    Cc: Purism Kernel Team <kernel@puri.sm>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191207140353.23967-6-sam@ravnborg.org

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index 60ccedce530c..91ea49c05611 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -206,11 +206,11 @@ static int nt39016_disable(struct drm_panel *drm_panel)
 	return 0;
 }
 
-static int nt39016_get_modes(struct drm_panel *drm_panel)
+static int nt39016_get_modes(struct drm_panel *drm_panel,
+			     struct drm_connector *connector)
 {
 	struct nt39016 *panel = to_nt39016(drm_panel);
 	const struct nt39016_panel_info *panel_info = panel->panel_info;
-	struct drm_connector *connector = drm_panel->connector;
 	struct drm_display_mode *mode;
 
 	mode = drm_mode_duplicate(drm_panel->drm, &panel_info->display_mode);

commit 9a2654c0f62a1704f36acb6329f9ccbd539f75ad
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 4 16:28:03 2019 +0300

    drm/panel: Add and fill drm_panel type field
    
    Add a type field to the drm_panel structure to report the panel type,
    using DRM_MODE_CONNECTOR_* macros (the values that make sense are LVDS,
    eDP, DSI and DPI). This will be used to initialise the corresponding
    connector type.
    
    Update all panel drivers accordingly. The panel-simple driver only
    specifies the type for the known to be LVDS panels, while all other
    panels are left as unknown and will be converted on a case-by-case
    basis as they all need to be carefully reviewed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190904132804.29680-2-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index 64cfe111aaad..60ccedce530c 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -292,7 +292,8 @@ static int nt39016_probe(struct spi_device *spi)
 		return err;
 	}
 
-	drm_panel_init(&panel->drm_panel, dev, &nt39016_funcs);
+	drm_panel_init(&panel->drm_panel, dev, &nt39016_funcs,
+		       DRM_MODE_CONNECTOR_DPI);
 
 	err = drm_panel_add(&panel->drm_panel);
 	if (err < 0) {

commit 6dbe0c4b0fc0646442b2b1580d022404e582fd7b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 23 22:32:43 2019 +0300

    drm/panel: Initialise panel dev and funcs through drm_panel_init()
    
    Instead of requiring all drivers to set the dev and funcs fields of
    drm_panel manually after calling drm_panel_init(), pass the data as
    arguments to the function. This simplifies the panel drivers, and will
    help future refactoring when adding new arguments to drm_panel_init().
    
    The panel drivers have been updated with the following Coccinelle
    semantic patch, with manual inspection to verify that no call to
    drm_panel_init() with a single argument still exists.
    
    @@
    expression panel;
    expression device;
    identifier ops;
    @@
     drm_panel_init(&panel
    +       , device, &ops
     );
     ...
    (
    -panel.dev = device;
    -panel.funcs = &ops;
    |
    -panel.funcs = &ops;
    -panel.dev = device;
    )
    
    Suggested-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190823193245.23876-3-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
index 2ad1063b068d..64cfe111aaad 100644
--- a/drivers/gpu/drm/panel/panel-novatek-nt39016.c
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -292,9 +292,7 @@ static int nt39016_probe(struct spi_device *spi)
 		return err;
 	}
 
-	drm_panel_init(&panel->drm_panel);
-	panel->drm_panel.dev = dev;
-	panel->drm_panel.funcs = &nt39016_funcs;
+	drm_panel_init(&panel->drm_panel, dev, &nt39016_funcs);
 
 	err = drm_panel_add(&panel->drm_panel);
 	if (err < 0) {

commit ecdcbbb7ceb1188474f603fac0ec48171761c842
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Mon Jun 3 17:25:55 2019 +0200

    drm/panel: Add Novatek NT39016 panel support
    
    Add support for display panels built around the Novatek NT39016 display
    controller, as found on e.g. the King Display KD035G6-54NT 24-bit
    320x240 3.5" LCD panel which equips the GCW Zero open-source handheld
    gaming console.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Maarten ter Huurne <maarten@treewalker.org>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190603152555.23527-2-paul@crapouillou.net

diff --git a/drivers/gpu/drm/panel/panel-novatek-nt39016.c b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
new file mode 100644
index 000000000000..2ad1063b068d
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-novatek-nt39016.c
@@ -0,0 +1,359 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Novatek NT39016 TFT LCD panel driver
+ *
+ * Copyright (C) 2017, Maarten ter Huurne <maarten@treewalker.org>
+ * Copyright (C) 2019, Paul Cercueil <paul@crapouillou.net>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+enum nt39016_regs {
+	NT39016_REG_SYSTEM,
+	NT39016_REG_TIMING,
+	NT39016_REG_OP,
+	NT39016_REG_DATA_IN,
+	NT39016_REG_SRC_TIMING_DELAY,
+	NT39016_REG_GATE_TIMING_DELAY,
+	NT39016_REG_RESERVED,
+	NT39016_REG_INITIAL_FUNC,
+	NT39016_REG_CONTRAST,
+	NT39016_REG_BRIGHTNESS,
+	NT39016_REG_HUE_SATURATION,
+	NT39016_REG_RB_SUBCONTRAST,
+	NT39016_REG_R_SUBBRIGHTNESS,
+	NT39016_REG_B_SUBBRIGHTNESS,
+	NT39016_REG_VCOMDC,
+	NT39016_REG_VCOMAC,
+	NT39016_REG_VGAM2,
+	NT39016_REG_VGAM34,
+	NT39016_REG_VGAM56,
+	NT39016_REG_VCOMDC_TRIM = 0x1e,
+	NT39016_REG_DISPLAY_MODE = 0x20,
+};
+
+#define NT39016_SYSTEM_RESET_N	BIT(0)
+#define NT39016_SYSTEM_STANDBY	BIT(1)
+
+struct nt39016_panel_info {
+	struct drm_display_mode display_mode;
+	u16 width_mm, height_mm;
+	u32 bus_format, bus_flags;
+};
+
+struct nt39016 {
+	struct drm_panel drm_panel;
+	struct device *dev;
+	struct regmap *map;
+	struct regulator *supply;
+	const struct nt39016_panel_info *panel_info;
+
+	struct gpio_desc *reset_gpio;
+
+	struct backlight_device *backlight;
+};
+
+static inline struct nt39016 *to_nt39016(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt39016, drm_panel);
+}
+
+#define RV(REG, VAL) { .reg = (REG), .def = (VAL), .delay_us = 2 }
+static const struct reg_sequence nt39016_panel_regs[] = {
+	RV(NT39016_REG_SYSTEM, 0x00),
+	RV(NT39016_REG_TIMING, 0x00),
+	RV(NT39016_REG_OP, 0x03),
+	RV(NT39016_REG_DATA_IN, 0xCC),
+	RV(NT39016_REG_SRC_TIMING_DELAY, 0x46),
+	RV(NT39016_REG_GATE_TIMING_DELAY, 0x05),
+	RV(NT39016_REG_RESERVED, 0x00),
+	RV(NT39016_REG_INITIAL_FUNC, 0x00),
+	RV(NT39016_REG_CONTRAST, 0x08),
+	RV(NT39016_REG_BRIGHTNESS, 0x40),
+	RV(NT39016_REG_HUE_SATURATION, 0x88),
+	RV(NT39016_REG_RB_SUBCONTRAST, 0x88),
+	RV(NT39016_REG_R_SUBBRIGHTNESS, 0x20),
+	RV(NT39016_REG_B_SUBBRIGHTNESS, 0x20),
+	RV(NT39016_REG_VCOMDC, 0x67),
+	RV(NT39016_REG_VCOMAC, 0xA4),
+	RV(NT39016_REG_VGAM2, 0x04),
+	RV(NT39016_REG_VGAM34, 0x24),
+	RV(NT39016_REG_VGAM56, 0x24),
+	RV(NT39016_REG_DISPLAY_MODE, 0x00),
+};
+
+#undef RV
+
+static const struct regmap_range nt39016_regmap_no_ranges[] = {
+	regmap_reg_range(0x13, 0x1D),
+	regmap_reg_range(0x1F, 0x1F),
+};
+
+static const struct regmap_access_table nt39016_regmap_access_table = {
+	.no_ranges = nt39016_regmap_no_ranges,
+	.n_no_ranges = ARRAY_SIZE(nt39016_regmap_no_ranges),
+};
+
+static const struct regmap_config nt39016_regmap_config = {
+	.reg_bits = 6,
+	.pad_bits = 2,
+	.val_bits = 8,
+
+	.max_register = NT39016_REG_DISPLAY_MODE,
+	.wr_table = &nt39016_regmap_access_table,
+	.write_flag_mask = 0x02,
+
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int nt39016_prepare(struct drm_panel *drm_panel)
+{
+	struct nt39016 *panel = to_nt39016(drm_panel);
+	int err;
+
+	err = regulator_enable(panel->supply);
+	if (err) {
+		dev_err(panel->dev, "Failed to enable power supply: %d", err);
+		return err;
+	}
+
+	/*
+	 * Reset the NT39016.
+	 * The documentation says the reset pulse should be at least 40 us to
+	 * pass the glitch filter, but when testing I see some resets fail and
+	 * some succeed when using a 70 us delay, so we use 100 us instead.
+	 */
+	gpiod_set_value_cansleep(panel->reset_gpio, 1);
+	usleep_range(100, 1000);
+	gpiod_set_value_cansleep(panel->reset_gpio, 0);
+	udelay(2);
+
+	/* Init all registers. */
+	err = regmap_multi_reg_write(panel->map, nt39016_panel_regs,
+				     ARRAY_SIZE(nt39016_panel_regs));
+	if (err) {
+		dev_err(panel->dev, "Failed to init registers: %d", err);
+		goto err_disable_regulator;
+	}
+
+	return 0;
+
+err_disable_regulator:
+	regulator_disable(panel->supply);
+	return err;
+}
+
+static int nt39016_unprepare(struct drm_panel *drm_panel)
+{
+	struct nt39016 *panel = to_nt39016(drm_panel);
+
+	gpiod_set_value_cansleep(panel->reset_gpio, 1);
+
+	regulator_disable(panel->supply);
+
+	return 0;
+}
+
+static int nt39016_enable(struct drm_panel *drm_panel)
+{
+	struct nt39016 *panel = to_nt39016(drm_panel);
+	int ret;
+
+	ret = regmap_write(panel->map, NT39016_REG_SYSTEM,
+			   NT39016_SYSTEM_RESET_N | NT39016_SYSTEM_STANDBY);
+	if (ret) {
+		dev_err(panel->dev, "Unable to enable panel: %d", ret);
+		return ret;
+	}
+
+	if (panel->backlight) {
+		/* Wait for the picture to be ready before enabling backlight */
+		msleep(150);
+
+		ret = backlight_enable(panel->backlight);
+	}
+
+	return ret;
+}
+
+static int nt39016_disable(struct drm_panel *drm_panel)
+{
+	struct nt39016 *panel = to_nt39016(drm_panel);
+	int err;
+
+	backlight_disable(panel->backlight);
+
+	err = regmap_write(panel->map, NT39016_REG_SYSTEM,
+			   NT39016_SYSTEM_RESET_N);
+	if (err) {
+		dev_err(panel->dev, "Unable to disable panel: %d", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nt39016_get_modes(struct drm_panel *drm_panel)
+{
+	struct nt39016 *panel = to_nt39016(drm_panel);
+	const struct nt39016_panel_info *panel_info = panel->panel_info;
+	struct drm_connector *connector = drm_panel->connector;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(drm_panel->drm, &panel_info->display_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = panel_info->width_mm;
+	connector->display_info.height_mm = panel_info->height_mm;
+
+	drm_display_info_set_bus_formats(&connector->display_info,
+					 &panel_info->bus_format, 1);
+	connector->display_info.bus_flags = panel_info->bus_flags;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt39016_funcs = {
+	.prepare	= nt39016_prepare,
+	.unprepare	= nt39016_unprepare,
+	.enable		= nt39016_enable,
+	.disable	= nt39016_disable,
+	.get_modes	= nt39016_get_modes,
+};
+
+static int nt39016_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct nt39016 *panel;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->dev = dev;
+	spi_set_drvdata(spi, panel);
+
+	panel->panel_info = of_device_get_match_data(dev);
+	if (!panel->panel_info)
+		return -EINVAL;
+
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply)) {
+		dev_err(dev, "Failed to get power supply");
+		return PTR_ERR(panel->supply);
+	}
+
+	panel->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(panel->reset_gpio)) {
+		dev_err(dev, "Failed to get reset GPIO");
+		return PTR_ERR(panel->reset_gpio);
+	}
+
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_3 | SPI_3WIRE;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(dev, "Failed to setup SPI");
+		return err;
+	}
+
+	panel->map = devm_regmap_init_spi(spi, &nt39016_regmap_config);
+	if (IS_ERR(panel->map)) {
+		dev_err(dev, "Failed to init regmap");
+		return PTR_ERR(panel->map);
+	}
+
+	panel->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(panel->backlight)) {
+		err = PTR_ERR(panel->backlight);
+		if (err != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get backlight handle");
+		return err;
+	}
+
+	drm_panel_init(&panel->drm_panel);
+	panel->drm_panel.dev = dev;
+	panel->drm_panel.funcs = &nt39016_funcs;
+
+	err = drm_panel_add(&panel->drm_panel);
+	if (err < 0) {
+		dev_err(dev, "Failed to register panel");
+		return err;
+	}
+
+	return 0;
+}
+
+static int nt39016_remove(struct spi_device *spi)
+{
+	struct nt39016 *panel = spi_get_drvdata(spi);
+
+	drm_panel_remove(&panel->drm_panel);
+
+	nt39016_disable(&panel->drm_panel);
+	nt39016_unprepare(&panel->drm_panel);
+
+	return 0;
+}
+
+static const struct nt39016_panel_info kd035g6_info = {
+	.display_mode = {
+		.clock = 6000,
+		.hdisplay = 320,
+		.hsync_start = 320 + 10,
+		.hsync_end = 320 + 10 + 50,
+		.htotal = 320 + 10 + 50 + 20,
+		.vdisplay = 240,
+		.vsync_start = 240 + 5,
+		.vsync_end = 240 + 5 + 1,
+		.vtotal = 240 + 5 + 1 + 4,
+		.vrefresh = 60,
+		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	},
+	.width_mm = 71,
+	.height_mm = 53,
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	.bus_flags = DRM_BUS_FLAG_PIXDATA_NEGEDGE,
+};
+
+static const struct of_device_id nt39016_of_match[] = {
+	{ .compatible = "kingdisplay,kd035g6-54nt", .data = &kd035g6_info },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt39016_of_match);
+
+static struct spi_driver nt39016_driver = {
+	.driver = {
+		.name = "nt39016",
+		.of_match_table = nt39016_of_match,
+	},
+	.probe = nt39016_probe,
+	.remove = nt39016_remove,
+};
+
+module_spi_driver(nt39016_driver);
+
+MODULE_AUTHOR("Maarten ter Huurne <maarten@treewalker.org>");
+MODULE_AUTHOR("Paul Cercueil <paul@crapouillou.net>");
+MODULE_LICENSE("GPL v2");
