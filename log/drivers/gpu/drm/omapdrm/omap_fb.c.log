commit 57d55bb5dc8690c8072f029796605498aeac0441
Author: zhengbin <zhengbin13@huawei.com>
Date:   Tue Oct 8 15:15:46 2019 +0800

    drm/omap: Remove set but not used variable 'plane'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/omapdrm/omap_fb.c: In function omap_framebuffer_update_scanout:
    drivers/gpu/drm/omapdrm/omap_fb.c:130:16: warning: variable plane set but not used [-Wunused-but-set-variable]
    
    It is not used since commit 2ecceeb53b19 ("drm/omap:
    Move buffer pitch/offset to drm_framebuffer")
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1570518949-47574-2-git-send-email-zhengbin13@huawei.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 7403316088b8..9aeab81dfb90 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -135,7 +135,6 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	const struct drm_format_info *format = omap_fb->format;
-	struct plane *plane = &omap_fb->planes[0];
 	u32 x, y, orient = 0;
 
 	info->fourcc = fb->format->format;
@@ -209,8 +208,6 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	info->screen_width /= format->cpp[0];
 
 	if (fb->format->format == DRM_FORMAT_NV12) {
-		plane = &omap_fb->planes[1];
-
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
 			WARN_ON(!(omap_gem_flags(fb->obj[1]) & OMAP_BO_TILED_MASK));
 			omap_gem_rotated_dma_addr(fb->obj[1], orient, x/2, y/2,

commit 48b34ac041756c2fd3a898d6e96be97416858b45
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Oct 10 13:59:57 2019 +0200

    drm/omap: remove OMAP_BO_TILED define
    
    OMAP_BO_TILED does not make sense, as OMAP_BO_TILED_* values are not
    bitmasks but normal values. As we already have OMAP_BO_TILED_MASK for
    the mask, we can remove OMAP_BO_TILED and use OMAP_BO_TILED_MASK
    instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Jean-Jacques Hiblot <jjhiblot@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191010120000.1421-6-jjhiblot@ti.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 1b8b5108caf8..7403316088b8 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -95,7 +95,7 @@ static u32 get_linear_addr(struct drm_framebuffer *fb,
 
 bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
 {
-	return omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED;
+	return omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED_MASK;
 }
 
 /* Note: DRM rotates counter-clockwise, TILER & DSS rotates clockwise */
@@ -154,7 +154,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	x = state->src_x >> 16;
 	y = state->src_y >> 16;
 
-	if (omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED) {
+	if (omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED_MASK) {
 		u32 w = state->src_w >> 16;
 		u32 h = state->src_h >> 16;
 
@@ -212,7 +212,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		plane = &omap_fb->planes[1];
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
-			WARN_ON(!(omap_gem_flags(fb->obj[1]) & OMAP_BO_TILED));
+			WARN_ON(!(omap_gem_flags(fb->obj[1]) & OMAP_BO_TILED_MASK));
 			omap_gem_rotated_dma_addr(fb->obj[1], orient, x/2, y/2,
 						  &info->p_uv_addr);
 		} else {

commit 03b0f2ce735e97e9f49790d4563c82515b8fa702
Merge: e4f86e437164 5f9e832c1370
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Mon Jul 22 21:24:10 2019 +0200

    Merge v5.3-rc1 into drm-misc-next
    
    Noralf needs some SPI patches in 5.3 to merge some work on tinydrm.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 81f6156ca5aea59640cc3a11565e10b0c4cac60b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jul 16 08:42:10 2019 +0200

    drm/omapdrm: drop use of drmP.h
    
    Drop use of the deprecated header drmP.h.
    Rearranged list of include files to match rest of
    DRM too.
    The drmP.h file was deleted from the header file, and the necessary
    includes was added to the .c files to fix build.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190716064220.18157-10-sam@ravnborg.org

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 06d5c5081e41..199ae8bf2769 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -15,10 +15,10 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <linux/seq_file.h>
+#include <linux/dma-mapping.h>
 
-#include <drm/drm_crtc.h>
 #include <drm/drm_modeset_helper.h>
+#include <drm/drm_fourcc.h>
 #include <drm/drm_gem_framebuffer_helper.h>
 
 #include "omap_dmm_tiler.h"

commit be8454afc50f43016ca8b6130d9673bdd0bd56ec
Merge: fec88ab0af97 3729fe2bc2a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 19:04:27 2019 -0700

    Merge tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "The biggest thing in this is the AMD Navi GPU support, this again
      contains a bunch of header files that are large. These are the new AMD
      RX5700 GPUs that just recently became available.
    
      New drivers:
       - ST-Ericsson MCDE driver
       - Ingenic JZ47xx SoC
    
      UAPI change:
       - HDR source metadata property
    
      Core:
       - HDR inforframes and EDID parsing
       - drm hdmi infoframe unpacking
       - remove prime sg_table caching into dma-buf
       - New gem vram helpers to reduce driver code
       - Lots of drmP.h removal
       - reservation fencing fix
       - documentation updates
       - drm_fb_helper_connector removed
       - mode name command handler rewrite
    
      fbcon:
       - Remove the fbcon notifiers
    
      ttm:
       - forward progress fixes
    
      dma-buf:
       - make mmap call optional
       - debugfs refcount fixes
       - dma-fence free with pending signals fix
       - each dma-buf gets an inode
    
      Panels:
       - Lots of additional panel bindings
    
      amdgpu:
       - initial navi10 support
       - avoid hw reset
       - HDR metadata support
       - new thermal sensors for vega asics
       - RAS fixes
       - use HMM rather than MMU notifier
       - xgmi topology via kfd
       - SR-IOV fixes
       - driver reload fixes
       - DC use a core bpc attribute
       - Aux fixes for DC
       - Bandwidth calc updates for DC
       - Clock handling refactor
       - kfd VEGAM support
    
      vmwgfx:
       - Coherent memory support changes
    
      i915:
       - HDR Support
       - HDMI i2c link
       - Icelake multi-segmented gamma support
       - GuC firmware update
       - Mule Creek Canyon PCH support for EHL
       - EHL platform updtes
       - move i915.alpha_support to i915.force_probe
       - runtime PM refactoring
       - VBT parsing refactoring
       - DSI fixes
       - struct mutex dependency reduction
       - GEM code reorg
    
      mali-dp:
       - Komeda driver features
    
      msm:
       - dsi vs EPROBE_DEFER fixes
       - msm8998 snapdragon 835 support
       - a540 gpu support
       - mdp5 and dpu interconnect support
    
      exynos:
       - drmP.h removal
    
      tegra:
       - misc fixes
    
      tda998x:
       - audio support improvements
       - pixel repeated mode support
       - quantisation range handling corrections
       - HDMI vendor info fix
    
      armada:
       - interlace support fix
       - overlay/video plane register handling refactor
       - add gamma support
    
      rockchip:
       - RX3328 support
    
      panfrost:
       - expose perf counters via hidden ioctls
    
      vkms:
       - enumerate CRC sources list
    
      ast:
       - rework BO handling
    
      mgag200:
       - rework BO handling
    
      dw-hdmi:
       - suspend/resume support
    
      rcar-du:
       - R8A774A1 Soc Support
       - LVDS dual-link mode support
       - Additional formats
       - Misc fixes
    
      omapdrm:
       - DSI command mode display support
    
      stm
       - fb modifier support
       - runtime PM support
    
      sun4i:
       - use vmap ops
    
      vc4:
       - binner bo binding rework
    
      v3d:
       - compute shader support
       - resync/sync fixes
       - job management refactoring
    
      lima:
       - NULL pointer in irq handler fix
       - scheduler default timeout
    
      virtio:
       - fence seqno support
       - trace events
    
      bochs:
       - misc fixes
    
      tc458767:
       - IRQ/HDP handling
    
      sii902x:
       - HDMI audio support
    
      atmel-hlcdc:
       - misc fixes
    
      meson:
       - zpos support"
    
    * tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm: (1815 commits)
      Revert "Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next"
      Revert "mm: adjust apply_to_pfn_range interface for dropped token."
      mm: adjust apply_to_pfn_range interface for dropped token.
      drm/amdgpu/navi10: add uclk activity sensor
      drm/amdgpu: properly guard the generic discovery code
      drm/amdgpu: add missing documentation on new module parameters
      drm/amdgpu: don't invalidate caches in RELEASE_MEM, only do the writeback
      drm/amd/display: avoid 64-bit division
      drm/amdgpu/psp11: simplify the ucode register logic
      drm/amdgpu: properly guard DC support in navi code
      drm/amd/powerplay: vega20: fix uninitialized variable use
      drm/amd/display: dcn20: include linux/delay.h
      amdgpu: make pmu support optional
      drm/amd/powerplay: Zero initialize current_rpm in vega20_get_fan_speed_percent
      drm/amd/powerplay: Zero initialize freq in smu_v11_0_get_current_clk_freq
      drm/amd/powerplay: Use memset to initialize metrics structs
      drm/amdgpu/mes10.1: Fix header guard
      drm/amd/powerplay: add temperature sensor support for navi10
      drm/amdgpu: fix scheduler timeout calc
      drm/amdgpu: Prepare for hmm_range_register API change (v2)
      ...

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 4f8eb9d08f99..1c9048e35d90 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/seq_file.h>

commit 1bb418bffdd6f95a41e8e59be63933bc84fde13c
Author: Sebastian Reichel <sebastian.reichel@collabora.com>
Date:   Thu May 23 22:07:56 2019 +0200

    drm/omap: add support for manually updated displays
    
    This adds the required infrastructure for manually updated displays,
    such as DSI command mode panels. While those panels often support
    partial updates we currently always do a full refresh.
    
    The display will be refreshed when something calls the dirty callback,
    such as libdrm's drmModeDirtyFB(). This is currently being done at least
    by the kernel console and Xorg (with modesetting driver) in their
    default configuration. Weston does not implement this and the fbdev
    backend does not work (display will not update). Weston's DRM backend
    uses double buffering and the page flip will also trigger a display
    refresh.
    
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 6557b2d6e16e..06d5c5081e41 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -66,8 +66,27 @@ struct omap_framebuffer {
 	struct mutex lock;
 };
 
+static int omap_framebuffer_dirty(struct drm_framebuffer *fb,
+				  struct drm_file *file_priv,
+				  unsigned flags, unsigned color,
+				  struct drm_clip_rect *clips,
+				  unsigned num_clips)
+{
+	struct drm_crtc *crtc;
+
+	drm_modeset_lock_all(fb->dev);
+
+	drm_for_each_crtc(crtc, fb->dev)
+		omap_crtc_flush(crtc);
+
+	drm_modeset_unlock_all(fb->dev);
+
+	return 0;
+}
+
 static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
 	.create_handle = drm_gem_fb_create_handle,
+	.dirty = omap_framebuffer_dirty,
 	.destroy = drm_gem_fb_destroy,
 };
 

commit 92f080762c3f45bbcfbe35e2ac610af1ee3bb2b9
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Thu May 16 12:31:51 2019 +0200

    drm: Replace instances of drm_format_info by drm_get_format_info
    
    drm_get_format_info directly calls into drm_format_info, but takes directly
    a struct drm_mode_fb_cmd2 pointer, instead of the fourcc directly. It's
    shorter to not dereference it, and we can customise the behaviour at the
    driver level if we want to, so let's switch to it where it makes sense.
    
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/5859d68664b8f0804a56e7386937f6db986b9e0f.1558002671.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index cfb641363a32..6557b2d6e16e 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -339,7 +339,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 			dev, mode_cmd, mode_cmd->width, mode_cmd->height,
 			(char *)&mode_cmd->pixel_format);
 
-	format = drm_format_info(mode_cmd->pixel_format);
+	format = drm_get_format_info(dev, mode_cmd);
 
 	for (i = 0; i < ARRAY_SIZE(formats); i++) {
 		if (formats[i] == mode_cmd->pixel_format)

commit 05c452c115bffa12f78346723f0282a4264ed200
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Thu May 16 12:31:47 2019 +0200

    drm: Remove users of drm_format_num_planes
    
    drm_format_num_planes() is basically a lookup in the drm_format_info table
    plus an access to the num_planes field of the appropriate entry.
    
    Most drivers are using this function while having access to the entry
    already, which means that we will perform an unnecessary lookup. Removing
    the call to drm_format_num_planes is therefore more efficient.
    
    Some drivers will not have access to that entry in the function, but in
    this case the overhead is minimal (we just have to call drm_format_info()
    to perform the lookup) and we can even avoid multiple, inefficient lookups
    in some places that need multiple fields from the drm_format_info
    structure.
    
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/5ffcec9d14a50ed538e37d565f546802452ee672.1558002671.git-series.maxime.ripard@bootlin.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 4f8eb9d08f99..cfb641363a32 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -298,7 +298,9 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)
 {
-	unsigned int num_planes = drm_format_num_planes(mode_cmd->pixel_format);
+	const struct drm_format_info *info = drm_get_format_info(dev,
+								 mode_cmd);
+	unsigned int num_planes = info->num_planes;
 	struct drm_gem_object *bos[4];
 	struct drm_framebuffer *fb;
 	int i;

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 4d264fd554d8..4f8eb9d08f99 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -18,7 +18,7 @@
 #include <linux/seq_file.h>
 
 #include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
+#include <drm/drm_modeset_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
 
 #include "omap_dmm_tiler.h"

commit e64d0229340dff8746a1b55e0bcf0dbac6cb5874
Author: Thomas Zimmermann <tdz@users.sourceforge.net>
Date:   Mon Jun 18 15:07:26 2018 +0200

    drm/omap: Replace drm_gem_object_unreference_unlocked with put function
    
    This patch unifies the naming of DRM functions for reference counting
    of struct drm_gem_object. The resulting code is more aligned with the
    rest of the Linux kernel interfaces.
    
    Signed-off-by: Thomas Zimmermann <tdz@users.sourceforge.net>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 9f1e3d8f8488..4d264fd554d8 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -319,7 +319,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 
 error:
 	while (--i >= 0)
-		drm_gem_object_unreference_unlocked(bos[i]);
+		drm_gem_object_put_unlocked(bos[i]);
 
 	return fb;
 }

commit b79df2767cc6bcb5da169d147fc199512a527d4b
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Thu Apr 5 18:13:58 2018 +0300

    drm/omapdrm: Nuke omap_framebuffer_get_next_connector()
    
    omap_framebuffer_get_next_connector() uses plane->fb which we want to
    deprecate for atomic drivers. As omap_framebuffer_get_next_connector()
    is unused just nuke the entire function.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180405151400.11326-11-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 9d75eab0d164..9f1e3d8f8488 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -279,33 +279,6 @@ void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 	mutex_unlock(&omap_fb->lock);
 }
 
-/* iterate thru all the connectors, returning ones that are attached
- * to the same fb..
- */
-struct drm_connector *omap_framebuffer_get_next_connector(
-		struct drm_framebuffer *fb, struct drm_connector *from)
-{
-	struct drm_device *dev = fb->dev;
-	struct list_head *connector_list = &dev->mode_config.connector_list;
-	struct drm_connector *connector = from;
-
-	if (!from)
-		return list_first_entry_or_null(connector_list, typeof(*from),
-						head);
-
-	list_for_each_entry_from(connector, connector_list, head) {
-		if (connector != from) {
-			struct drm_encoder *encoder = connector->encoder;
-			struct drm_crtc *crtc = encoder ? encoder->crtc : NULL;
-			if (crtc && crtc->primary->fb == fb)
-				return connector;
-
-		}
-	}
-
-	return NULL;
-}
-
 #ifdef CONFIG_DEBUG_FS
 void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 {

commit 2ecceeb53b19455ffa50b31fd3c20fe2974508a6
Author: Daniel Stone <daniels@collabora.com>
Date:   Fri Mar 30 15:11:21 2018 +0100

    drm/omap: Move buffer pitch/offset to drm_framebuffer
    
    drm_framebuffer already holds per-plane pitch and offsets, which is
    filled out for us when we create the framebuffer. Nuke our local copy in
    the plane struct.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180330141138.28987-7-daniels@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 3d6b6f3d6808..9d75eab0d164 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -52,8 +52,6 @@ static const u32 formats[] = {
 
 /* per-plane info for the fb: */
 struct plane {
-	u32 pitch;
-	u32 offset;
 	dma_addr_t dma_addr;
 };
 
@@ -73,14 +71,16 @@ static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
 	.destroy = drm_gem_fb_destroy,
 };
 
-static u32 get_linear_addr(struct plane *plane,
+static u32 get_linear_addr(struct drm_framebuffer *fb,
 		const struct drm_format_info *format, int n, int x, int y)
 {
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	struct plane *plane = &omap_fb->planes[n];
 	u32 offset;
 
-	offset = plane->offset
+	offset = fb->offsets[n]
 	       + (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))
-	       + (y * plane->pitch / (n == 0 ? 1 : format->vsub));
+	       + (y * fb->pitches[n] / (n == 0 ? 1 : format->vsub));
 
 	return plane->dma_addr + offset;
 }
@@ -191,10 +191,10 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 			break;
 		}
 
-		info->paddr         = get_linear_addr(plane, format, 0, x, y);
+		info->paddr         = get_linear_addr(fb, format, 0, x, y);
 		info->rotation_type = OMAP_DSS_ROT_NONE;
 		info->rotation      = DRM_MODE_ROTATE_0;
-		info->screen_width  = plane->pitch;
+		info->screen_width  = fb->pitches[0];
 	}
 
 	/* convert to pixels: */
@@ -208,7 +208,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 			omap_gem_rotated_dma_addr(fb->obj[1], orient, x/2, y/2,
 						  &info->p_uv_addr);
 		} else {
-			info->p_uv_addr = get_linear_addr(plane, format, 1, x, y);
+			info->p_uv_addr = get_linear_addr(fb, format, 1, x, y);
 		}
 	} else {
 		info->p_uv_addr = 0;
@@ -309,16 +309,14 @@ struct drm_connector *omap_framebuffer_get_next_connector(
 #ifdef CONFIG_DEBUG_FS
 void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 {
-	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	int i, n = fb->format->num_planes;
 
 	seq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,
 			(char *)&fb->format->format);
 
 	for (i = 0; i < n; i++) {
-		struct plane *plane = &omap_fb->planes[i];
 		seq_printf(m, "   %d: offset=%d pitch=%d, obj: ",
-				i, plane->offset, plane->pitch);
+				i, fb->offsets[n], fb->pitches[i]);
 		omap_gem_describe(fb->obj[i], m);
 	}
 }
@@ -425,8 +423,6 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		}
 
 		fb->obj[i]    = bos[i];
-		plane->offset = mode_cmd->offsets[i];
-		plane->pitch  = pitch;
 		plane->dma_addr  = 0;
 	}
 

commit 3e44255260dc3c329a92cf0aa64495951ccc4fb7
Author: Daniel Stone <daniels@collabora.com>
Date:   Fri Mar 30 15:11:20 2018 +0100

    drm/omap: Move GEM BO to drm_framebuffer
    
    Since drm_framebuffer can now store GEM objects directly, place them
    there rather than in our own subclass. As this makes the framebuffer
    create_handle and destroy functions the same as the GEM framebuffer
    helper, we can reuse those.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180330141138.28987-6-daniels@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 5fd22ca73913..3d6b6f3d6808 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -19,6 +19,7 @@
 
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
 
 #include "omap_dmm_tiler.h"
 #include "omap_drv.h"
@@ -51,7 +52,6 @@ static const u32 formats[] = {
 
 /* per-plane info for the fb: */
 struct plane {
-	struct drm_gem_object *bo;
 	u32 pitch;
 	u32 offset;
 	dma_addr_t dma_addr;
@@ -68,36 +68,9 @@ struct omap_framebuffer {
 	struct mutex lock;
 };
 
-static int omap_framebuffer_create_handle(struct drm_framebuffer *fb,
-		struct drm_file *file_priv,
-		unsigned int *handle)
-{
-	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	return drm_gem_handle_create(file_priv,
-			omap_fb->planes[0].bo, handle);
-}
-
-static void omap_framebuffer_destroy(struct drm_framebuffer *fb)
-{
-	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int i, n = fb->format->num_planes;
-
-	DBG("destroy: FB ID: %d (%p)", fb->base.id, fb);
-
-	drm_framebuffer_cleanup(fb);
-
-	for (i = 0; i < n; i++) {
-		struct plane *plane = &omap_fb->planes[i];
-
-		drm_gem_object_unreference_unlocked(plane->bo);
-	}
-
-	kfree(omap_fb);
-}
-
 static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
-	.create_handle = omap_framebuffer_create_handle,
-	.destroy = omap_framebuffer_destroy,
+	.create_handle = drm_gem_fb_create_handle,
+	.destroy = drm_gem_fb_destroy,
 };
 
 static u32 get_linear_addr(struct plane *plane,
@@ -114,10 +87,7 @@ static u32 get_linear_addr(struct plane *plane,
 
 bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
 {
-	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	struct plane *plane = &omap_fb->planes[0];
-
-	return omap_gem_flags(plane->bo) & OMAP_BO_TILED;
+	return omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED;
 }
 
 /* Note: DRM rotates counter-clockwise, TILER & DSS rotates clockwise */
@@ -176,7 +146,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	x = state->src_x >> 16;
 	y = state->src_y >> 16;
 
-	if (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {
+	if (omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED) {
 		u32 w = state->src_w >> 16;
 		u32 h = state->src_h >> 16;
 
@@ -201,12 +171,12 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 			x += w - 1;
 
 		/* Note: x and y are in TILER units, not pixels */
-		omap_gem_rotated_dma_addr(plane->bo, orient, x, y,
+		omap_gem_rotated_dma_addr(fb->obj[0], orient, x, y,
 					  &info->paddr);
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->rotation = state->rotation ?: DRM_MODE_ROTATE_0;
 		/* Note: stride in TILER units, not pixels */
-		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
+		info->screen_width  = omap_gem_tiled_stride(fb->obj[0], orient);
 	} else {
 		switch (state->rotation & DRM_MODE_ROTATE_MASK) {
 		case 0:
@@ -234,8 +204,8 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		plane = &omap_fb->planes[1];
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
-			WARN_ON(!(omap_gem_flags(plane->bo) & OMAP_BO_TILED));
-			omap_gem_rotated_dma_addr(plane->bo, orient, x/2, y/2,
+			WARN_ON(!(omap_gem_flags(fb->obj[1]) & OMAP_BO_TILED));
+			omap_gem_rotated_dma_addr(fb->obj[1], orient, x/2, y/2,
 						  &info->p_uv_addr);
 		} else {
 			info->p_uv_addr = get_linear_addr(plane, format, 1, x, y);
@@ -261,10 +231,10 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_pin(plane->bo, &plane->dma_addr);
+		ret = omap_gem_pin(fb->obj[i], &plane->dma_addr);
 		if (ret)
 			goto fail;
-		omap_gem_dma_sync_buffer(plane->bo, DMA_TO_DEVICE);
+		omap_gem_dma_sync_buffer(fb->obj[i], DMA_TO_DEVICE);
 	}
 
 	omap_fb->pin_count++;
@@ -276,7 +246,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 fail:
 	for (i--; i >= 0; i--) {
 		struct plane *plane = &omap_fb->planes[i];
-		omap_gem_unpin(plane->bo);
+		omap_gem_unpin(fb->obj[i]);
 		plane->dma_addr = 0;
 	}
 
@@ -302,7 +272,7 @@ void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		omap_gem_unpin(plane->bo);
+		omap_gem_unpin(fb->obj[i]);
 		plane->dma_addr = 0;
 	}
 
@@ -349,7 +319,7 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 		struct plane *plane = &omap_fb->planes[i];
 		seq_printf(m, "   %d: offset=%d pitch=%d, obj: ",
 				i, plane->offset, plane->pitch);
-		omap_gem_describe(plane->bo, m);
+		omap_gem_describe(fb->obj[i], m);
 	}
 }
 #endif
@@ -454,7 +424,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 			goto fail;
 		}
 
-		plane->bo     = bos[i];
+		fb->obj[i]    = bos[i];
 		plane->offset = mode_cmd->offsets[i];
 		plane->pitch  = pitch;
 		plane->dma_addr  = 0;

commit dfe9cfccb264889b025e443ca20e2fbb401295c2
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:33 2018 +0200

    drm: omapdrm: Use kernel integer types
    
    The standard kernel integer types are [us]{8,16,32}. Use them instead of
    the u?int{8,16,32}_t types.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index b2539a90e1a4..5fd22ca73913 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -52,8 +52,8 @@ static const u32 formats[] = {
 /* per-plane info for the fb: */
 struct plane {
 	struct drm_gem_object *bo;
-	uint32_t pitch;
-	uint32_t offset;
+	u32 pitch;
+	u32 offset;
 	dma_addr_t dma_addr;
 };
 
@@ -100,10 +100,10 @@ static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
 	.destroy = omap_framebuffer_destroy,
 };
 
-static uint32_t get_linear_addr(struct plane *plane,
+static u32 get_linear_addr(struct plane *plane,
 		const struct drm_format_info *format, int n, int x, int y)
 {
-	uint32_t offset;
+	u32 offset;
 
 	offset = plane->offset
 	       + (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))
@@ -121,9 +121,9 @@ bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
 }
 
 /* Note: DRM rotates counter-clockwise, TILER & DSS rotates clockwise */
-static uint32_t drm_rotation_to_tiler(unsigned int drm_rot)
+static u32 drm_rotation_to_tiler(unsigned int drm_rot)
 {
-	uint32_t orient;
+	u32 orient;
 
 	switch (drm_rot & DRM_MODE_ROTATE_MASK) {
 	default:
@@ -158,7 +158,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	const struct drm_format_info *format = omap_fb->format;
 	struct plane *plane = &omap_fb->planes[0];
-	uint32_t x, y, orient = 0;
+	u32 x, y, orient = 0;
 
 	info->fourcc = fb->format->format;
 
@@ -177,8 +177,8 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	y = state->src_y >> 16;
 
 	if (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {
-		uint32_t w = state->src_w >> 16;
-		uint32_t h = state->src_h >> 16;
+		u32 w = state->src_w >> 16;
+		u32 h = state->src_h >> 16;
 
 		orient = drm_rotation_to_tiler(state->rotation);
 

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index b1a762b70cbf..b2539a90e1a4 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -1,7 +1,5 @@
 /*
- * drivers/gpu/drm/omapdrm/omap_fb.c
- *
- * Copyright (C) 2011 Texas Instruments
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify it

commit 95552191f0a0c3632808d8883fc05d37a5c2fe14
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Aug 4 12:20:03 2017 +0300

    drm/omap: fix memory leak when FB init fails
    
    omap_framebuffer_create() fails to unref all the gem objects if creating
    the FB fails, leading to a memory leak.
    
    Fix the loop so that it goes through all the reffed gem objects.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index ddf7a457951b..b1a762b70cbf 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -379,7 +379,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 	return fb;
 
 error:
-	while (--i > 0)
+	while (--i >= 0)
 		drm_gem_object_unreference_unlocked(bos[i]);
 
 	return fb;

commit c4df6e4277503f0d05e261c3cae0c282fdca4437
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon May 15 11:09:25 2017 +0300

    drm/omap: fix YUV422 rotation with TILER
    
    TILER rotation with YUV422 pixelformats does not work at the moment. All
    other pixel formats work, because the pixelformat's pixel size is equal
    to tiler unit size (e.g. XR24's pixel size is 32 bits, and the TILER
    unit size that has to be used is 32 bits).
    
    For YUV422 formats this is not the case, as the TILER unit size has to
    be 32 bits, but the pixel size is 16 bits. The end result is OCP errors
    and sync losts.
    
    This patch adds the code to adjust the variables for YUV422 formats.
    
    We could make the code more generic by passing around the pixel format,
    rotation type, angle and the tiler unit size, which would allow us to do
    calculations without special case for YUV422. However, this would make
    the code more complex, and at least for now this is much more easier to
    handle with these two special cases for YUV422.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index c7a805702b54..ddf7a457951b 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -184,16 +184,30 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 
 		orient = drm_rotation_to_tiler(state->rotation);
 
+		/*
+		 * omap_gem_rotated_paddr() wants the x & y in tiler units.
+		 * Usually tiler unit size is the same as the pixel size, except
+		 * for YUV422 formats, for which the tiler unit size is 32 bits
+		 * and pixel size is 16 bits.
+		 */
+		if (fb->format->format == DRM_FORMAT_UYVY ||
+				fb->format->format == DRM_FORMAT_YUYV) {
+			x /= 2;
+			w /= 2;
+		}
+
 		/* adjust x,y offset for invert: */
 		if (orient & MASK_Y_INVERT)
 			y += h - 1;
 		if (orient & MASK_X_INVERT)
 			x += w - 1;
 
+		/* Note: x and y are in TILER units, not pixels */
 		omap_gem_rotated_dma_addr(plane->bo, orient, x, y,
 					  &info->paddr);
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->rotation = state->rotation ?: DRM_MODE_ROTATE_0;
+		/* Note: stride in TILER units, not pixels */
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
 		switch (state->rotation & DRM_MODE_ROTATE_MASK) {

commit 16f9ede51ff9b37e04fb64dad8b4099c2814c436
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 12:48:58 2017 +0300

    drm/omap: pass rotation to dispc
    
    The omapdrm driver has not passed the rotation value to the dispc
    driver. This doesn't affect RGB formats, but YUV formats don't work
    without dispc knowing the orientation.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 4093e0e38a90..c7a805702b54 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -193,6 +193,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		omap_gem_rotated_dma_addr(plane->bo, orient, x, y,
 					  &info->paddr);
 		info->rotation_type = OMAP_DSS_ROT_TILER;
+		info->rotation = state->rotation ?: DRM_MODE_ROTATE_0;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
 		switch (state->rotation & DRM_MODE_ROTATE_MASK) {
@@ -210,6 +211,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 
 		info->paddr         = get_linear_addr(plane, format, 0, x, y);
 		info->rotation_type = OMAP_DSS_ROT_NONE;
+		info->rotation      = DRM_MODE_ROTATE_0;
 		info->screen_width  = plane->pitch;
 	}
 

commit 218ed5358a4045382674f8feeee0efb526f9431b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon May 15 13:40:08 2017 +0300

    drm/omap: remove omap_drm_win
    
    struct omap_drm_window is only used to pass plane setup data to
    omap_framebuffer_update_scanout(). This can as well be accomplished by
    just passing the DRM state.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 2f461d427924..4093e0e38a90 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -155,7 +155,7 @@ static uint32_t drm_rotation_to_tiler(unsigned int drm_rot)
 /* update ovl info for scanout, handles cases of multi-planar fb's, etc.
  */
 void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
-		struct omap_drm_window *win, struct omap_overlay_info *info)
+		struct drm_plane_state *state, struct omap_overlay_info *info)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	const struct drm_format_info *format = omap_fb->format;
@@ -164,25 +164,27 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 
 	info->fourcc = fb->format->format;
 
-	info->pos_x      = win->crtc_x;
-	info->pos_y      = win->crtc_y;
-	info->out_width  = win->crtc_w;
-	info->out_height = win->crtc_h;
-	info->width      = win->src_w;
-	info->height     = win->src_h;
+	info->pos_x      = state->crtc_x;
+	info->pos_y      = state->crtc_y;
+	info->out_width  = state->crtc_w;
+	info->out_height = state->crtc_h;
+	info->width      = state->src_w >> 16;
+	info->height     = state->src_h >> 16;
 
-	x = win->src_x;
-	y = win->src_y;
+	/* DSS driver wants the w & h in rotated orientation */
+	if (drm_rotation_90_or_270(state->rotation))
+		swap(info->width, info->height);
+
+	x = state->src_x >> 16;
+	y = state->src_y >> 16;
 
 	if (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {
-		uint32_t w = win->src_w;
-		uint32_t h = win->src_h;
+		uint32_t w = state->src_w >> 16;
+		uint32_t h = state->src_h >> 16;
 
-		orient = drm_rotation_to_tiler(win->rotation);
+		orient = drm_rotation_to_tiler(state->rotation);
 
-		/* adjust x,y offset for flip/invert: */
-		if (orient & MASK_XY_FLIP)
-			swap(w, h);
+		/* adjust x,y offset for invert: */
 		if (orient & MASK_Y_INVERT)
 			y += h - 1;
 		if (orient & MASK_X_INVERT)
@@ -193,7 +195,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
-		switch (win->rotation & DRM_MODE_ROTATE_MASK) {
+		switch (state->rotation & DRM_MODE_ROTATE_MASK) {
 		case 0:
 		case DRM_MODE_ROTATE_0:
 			/* OK */
@@ -202,8 +204,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		default:
 			dev_warn(fb->dev->dev,
 				"rotation '%d' ignored for non-tiled fb\n",
-				win->rotation);
-			win->rotation = 0;
+				state->rotation);
 			break;
 		}
 

commit 8958aeb9c7bc86c89667af049243c47836111ab7
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon May 15 12:57:46 2017 +0300

    drm/omap: add drm_rotation_to_tiler helper()
    
    Add a helper function to convert DRM rotation to TILER rotation.
    
    Also drop a error print that can never happen, as the DRM framework
    makes sure the rotation is valid.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index c5b2088ee168..2f461d427924 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -122,6 +122,36 @@ bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
 	return omap_gem_flags(plane->bo) & OMAP_BO_TILED;
 }
 
+/* Note: DRM rotates counter-clockwise, TILER & DSS rotates clockwise */
+static uint32_t drm_rotation_to_tiler(unsigned int drm_rot)
+{
+	uint32_t orient;
+
+	switch (drm_rot & DRM_MODE_ROTATE_MASK) {
+	default:
+	case DRM_MODE_ROTATE_0:
+		orient = 0;
+		break;
+	case DRM_MODE_ROTATE_90:
+		orient = MASK_XY_FLIP | MASK_X_INVERT;
+		break;
+	case DRM_MODE_ROTATE_180:
+		orient = MASK_X_INVERT | MASK_Y_INVERT;
+		break;
+	case DRM_MODE_ROTATE_270:
+		orient = MASK_XY_FLIP | MASK_Y_INVERT;
+		break;
+	}
+
+	if (drm_rot & DRM_MODE_REFLECT_X)
+		orient ^= MASK_X_INVERT;
+
+	if (drm_rot & DRM_MODE_REFLECT_Y)
+		orient ^= MASK_Y_INVERT;
+
+	return orient;
+}
+
 /* update ovl info for scanout, handles cases of multi-planar fb's, etc.
  */
 void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
@@ -148,31 +178,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		uint32_t w = win->src_w;
 		uint32_t h = win->src_h;
 
-		switch (win->rotation & DRM_MODE_ROTATE_MASK) {
-		default:
-			dev_err(fb->dev->dev, "invalid rotation: %02x",
-					(uint32_t)win->rotation);
-			/* fallthru to default to no rotation */
-		case 0:
-		case DRM_MODE_ROTATE_0:
-			orient = 0;
-			break;
-		case DRM_MODE_ROTATE_90:
-			orient = MASK_XY_FLIP | MASK_X_INVERT;
-			break;
-		case DRM_MODE_ROTATE_180:
-			orient = MASK_X_INVERT | MASK_Y_INVERT;
-			break;
-		case DRM_MODE_ROTATE_270:
-			orient = MASK_XY_FLIP | MASK_Y_INVERT;
-			break;
-		}
-
-		if (win->rotation & DRM_MODE_REFLECT_X)
-			orient ^= MASK_X_INVERT;
-
-		if (win->rotation & DRM_MODE_REFLECT_Y)
-			orient ^= MASK_Y_INVERT;
+		orient = drm_rotation_to_tiler(win->rotation);
 
 		/* adjust x,y offset for flip/invert: */
 		if (orient & MASK_XY_FLIP)

commit 41aff42ae6e3e9dbb800640fe3bb62383d4aa6e3
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:31:56 2017 +0300

    drm/omap: rename color_mode to fourcc
    
    Now that we use fourccs, we can also rename the 'color_mode' variables
    to 'fourcc'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 16b510dcee2f..c5b2088ee168 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -132,7 +132,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	struct plane *plane = &omap_fb->planes[0];
 	uint32_t x, y, orient = 0;
 
-	info->color_mode = fb->format->format;
+	info->fourcc = fb->format->format;
 
 	info->pos_x      = win->crtc_x;
 	info->pos_y      = win->crtc_y;

commit c2e52e32049c0e94aa35a0635a2b150478ef3b2a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:29:58 2017 +0300

    drm/omap: cleanup formats array
    
    omap_fb.c has a table with DSS and DRM formats, used to convert between
    them. This is no longer needed, so we can change the array to a plain
    array of DRM_FORMAT_* values which contain all possible pixel formats
    supported by any DSS IP version.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 489d17ce8f11..16b510dcee2f 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -29,30 +29,26 @@
  * framebuffer funcs
  */
 
-/* DSS to DRM formats mapping */
-static const struct {
-	u32 dss_format;
-	uint32_t pixel_format;
-} formats[] = {
+static const u32 formats[] = {
 	/* 16bpp [A]RGB: */
-	{ DRM_FORMAT_RGB565,       DRM_FORMAT_RGB565 },   /* RGB16-565 */
-	{ DRM_FORMAT_RGBX4444,      DRM_FORMAT_RGBX4444 }, /* RGB12x-4444 */
-	{ DRM_FORMAT_XRGB4444,      DRM_FORMAT_XRGB4444 }, /* xRGB12-4444 */
-	{ DRM_FORMAT_RGBA4444,      DRM_FORMAT_RGBA4444 }, /* RGBA12-4444 */
-	{ DRM_FORMAT_ARGB4444,      DRM_FORMAT_ARGB4444 }, /* ARGB16-4444 */
-	{ DRM_FORMAT_XRGB1555, DRM_FORMAT_XRGB1555 }, /* xRGB15-1555 */
-	{ DRM_FORMAT_ARGB1555, DRM_FORMAT_ARGB1555 }, /* ARGB16-1555 */
+	DRM_FORMAT_RGB565, /* RGB16-565 */
+	DRM_FORMAT_RGBX4444, /* RGB12x-4444 */
+	DRM_FORMAT_XRGB4444, /* xRGB12-4444 */
+	DRM_FORMAT_RGBA4444, /* RGBA12-4444 */
+	DRM_FORMAT_ARGB4444, /* ARGB16-4444 */
+	DRM_FORMAT_XRGB1555, /* xRGB15-1555 */
+	DRM_FORMAT_ARGB1555, /* ARGB16-1555 */
 	/* 24bpp RGB: */
-	{ DRM_FORMAT_RGB888,      DRM_FORMAT_RGB888 },   /* RGB24-888 */
+	DRM_FORMAT_RGB888,   /* RGB24-888 */
 	/* 32bpp [A]RGB: */
-	{ DRM_FORMAT_RGBX8888,      DRM_FORMAT_RGBX8888 }, /* RGBx24-8888 */
-	{ DRM_FORMAT_XRGB8888,      DRM_FORMAT_XRGB8888 }, /* xRGB24-8888 */
-	{ DRM_FORMAT_RGBA8888,      DRM_FORMAT_RGBA8888 }, /* RGBA32-8888 */
-	{ DRM_FORMAT_ARGB8888,      DRM_FORMAT_ARGB8888 }, /* ARGB32-8888 */
+	DRM_FORMAT_RGBX8888, /* RGBx24-8888 */
+	DRM_FORMAT_XRGB8888, /* xRGB24-8888 */
+	DRM_FORMAT_RGBA8888, /* RGBA32-8888 */
+	DRM_FORMAT_ARGB8888, /* ARGB32-8888 */
 	/* YUV: */
-	{ DRM_FORMAT_NV12,        DRM_FORMAT_NV12 },
-	{ DRM_FORMAT_YUYV,        DRM_FORMAT_YUYV },
-	{ DRM_FORMAT_UYVY,        DRM_FORMAT_UYVY },
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY,
 };
 
 /* per-plane info for the fb: */
@@ -69,7 +65,6 @@ struct omap_framebuffer {
 	struct drm_framebuffer base;
 	int pin_count;
 	const struct drm_format_info *format;
-	u32 dss_format;
 	struct plane planes[2];
 	/* lock for pinning (pin_count and planes.dma_addr) */
 	struct mutex lock;
@@ -137,7 +132,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	struct plane *plane = &omap_fb->planes[0];
 	uint32_t x, y, orient = 0;
 
-	info->color_mode = omap_fb->dss_format;
+	info->color_mode = fb->format->format;
 
 	info->pos_x      = win->crtc_x;
 	info->pos_y      = win->crtc_y;
@@ -214,7 +209,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	/* convert to pixels: */
 	info->screen_width /= format->cpp[0];
 
-	if (omap_fb->dss_format == DRM_FORMAT_NV12) {
+	if (fb->format->format == DRM_FORMAT_NV12) {
 		plane = &omap_fb->planes[1];
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
@@ -373,7 +368,6 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	const struct drm_format_info *format = NULL;
 	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;
-	u32 dss_format = 0;
 	unsigned int pitch = mode_cmd->pitches[0];
 	int ret, i;
 
@@ -384,13 +378,11 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	format = drm_format_info(mode_cmd->pixel_format);
 
 	for (i = 0; i < ARRAY_SIZE(formats); i++) {
-		if (formats[i].pixel_format == mode_cmd->pixel_format) {
-			dss_format = formats[i].dss_format;
+		if (formats[i] == mode_cmd->pixel_format)
 			break;
-		}
 	}
 
-	if (!format || !dss_format) {
+	if (!format || i == ARRAY_SIZE(formats)) {
 		dev_dbg(dev->dev, "unsupported pixel format: %4.4s\n",
 			(char *)&mode_cmd->pixel_format);
 		ret = -EINVAL;
@@ -405,7 +397,6 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 
 	fb = &omap_fb->base;
 	omap_fb->format = format;
-	omap_fb->dss_format = dss_format;
 	mutex_init(&omap_fb->lock);
 
 	/*

commit eecad4371d986f38b66202817e2b461ac3c64139
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:27:49 2017 +0300

    drm/omap: remove omap_framebuffer_get_formats()
    
    We now get a fourcc array from dispc when asking for a plane's supported
    pixel formats, so we can drop omap_framebuffer_get_formats() which was
    used to convert between DSS and DRM pixel formats.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 9d5f6ad2059e..489d17ce8f11 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -55,28 +55,6 @@ static const struct {
 	{ DRM_FORMAT_UYVY,        DRM_FORMAT_UYVY },
 };
 
-/* convert from overlay's pixel formats bitmask to an array of fourcc's */
-uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,
-		uint32_t max_formats, const u32 *supported_modes)
-{
-	uint32_t nformats = 0;
-	int i = 0;
-
-	for (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++) {
-		unsigned int t;
-
-		for (t = 0; supported_modes[t]; ++t) {
-			if (supported_modes[t] != formats[i].dss_format)
-				continue;
-
-			pixel_formats[nformats++] = formats[i].pixel_format;
-			break;
-		}
-	}
-
-	return nformats;
-}
-
 /* per-plane info for the fb: */
 struct plane {
 	struct drm_gem_object *bo;

commit 3e1d65cdf84f88affa718396a392f9f9a0d8a5f6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 10:40:46 2017 +0300

    drm/omap: use DRM_FORMAT_* instead of OMAP_DSS_COLOR_*
    
    This patch changes omapdrm to use DRM_FORMAT_* values instead of
    OMAP_DSS_COLOR_* enum.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 71b3f25e61c2..9d5f6ad2059e 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -35,24 +35,24 @@ static const struct {
 	uint32_t pixel_format;
 } formats[] = {
 	/* 16bpp [A]RGB: */
-	{ OMAP_DSS_COLOR_RGB16,       DRM_FORMAT_RGB565 },   /* RGB16-565 */
-	{ OMAP_DSS_COLOR_RGB12U,      DRM_FORMAT_RGBX4444 }, /* RGB12x-4444 */
-	{ OMAP_DSS_COLOR_RGBX16,      DRM_FORMAT_XRGB4444 }, /* xRGB12-4444 */
-	{ OMAP_DSS_COLOR_RGBA16,      DRM_FORMAT_RGBA4444 }, /* RGBA12-4444 */
-	{ OMAP_DSS_COLOR_ARGB16,      DRM_FORMAT_ARGB4444 }, /* ARGB16-4444 */
-	{ OMAP_DSS_COLOR_XRGB16_1555, DRM_FORMAT_XRGB1555 }, /* xRGB15-1555 */
-	{ OMAP_DSS_COLOR_ARGB16_1555, DRM_FORMAT_ARGB1555 }, /* ARGB16-1555 */
+	{ DRM_FORMAT_RGB565,       DRM_FORMAT_RGB565 },   /* RGB16-565 */
+	{ DRM_FORMAT_RGBX4444,      DRM_FORMAT_RGBX4444 }, /* RGB12x-4444 */
+	{ DRM_FORMAT_XRGB4444,      DRM_FORMAT_XRGB4444 }, /* xRGB12-4444 */
+	{ DRM_FORMAT_RGBA4444,      DRM_FORMAT_RGBA4444 }, /* RGBA12-4444 */
+	{ DRM_FORMAT_ARGB4444,      DRM_FORMAT_ARGB4444 }, /* ARGB16-4444 */
+	{ DRM_FORMAT_XRGB1555, DRM_FORMAT_XRGB1555 }, /* xRGB15-1555 */
+	{ DRM_FORMAT_ARGB1555, DRM_FORMAT_ARGB1555 }, /* ARGB16-1555 */
 	/* 24bpp RGB: */
-	{ OMAP_DSS_COLOR_RGB24P,      DRM_FORMAT_RGB888 },   /* RGB24-888 */
+	{ DRM_FORMAT_RGB888,      DRM_FORMAT_RGB888 },   /* RGB24-888 */
 	/* 32bpp [A]RGB: */
-	{ OMAP_DSS_COLOR_RGBX32,      DRM_FORMAT_RGBX8888 }, /* RGBx24-8888 */
-	{ OMAP_DSS_COLOR_RGB24U,      DRM_FORMAT_XRGB8888 }, /* xRGB24-8888 */
-	{ OMAP_DSS_COLOR_RGBA32,      DRM_FORMAT_RGBA8888 }, /* RGBA32-8888 */
-	{ OMAP_DSS_COLOR_ARGB32,      DRM_FORMAT_ARGB8888 }, /* ARGB32-8888 */
+	{ DRM_FORMAT_RGBX8888,      DRM_FORMAT_RGBX8888 }, /* RGBx24-8888 */
+	{ DRM_FORMAT_XRGB8888,      DRM_FORMAT_XRGB8888 }, /* xRGB24-8888 */
+	{ DRM_FORMAT_RGBA8888,      DRM_FORMAT_RGBA8888 }, /* RGBA32-8888 */
+	{ DRM_FORMAT_ARGB8888,      DRM_FORMAT_ARGB8888 }, /* ARGB32-8888 */
 	/* YUV: */
-	{ OMAP_DSS_COLOR_NV12,        DRM_FORMAT_NV12 },
-	{ OMAP_DSS_COLOR_YUV2,        DRM_FORMAT_YUYV },
-	{ OMAP_DSS_COLOR_UYVY,        DRM_FORMAT_UYVY },
+	{ DRM_FORMAT_NV12,        DRM_FORMAT_NV12 },
+	{ DRM_FORMAT_YUYV,        DRM_FORMAT_YUYV },
+	{ DRM_FORMAT_UYVY,        DRM_FORMAT_UYVY },
 };
 
 /* convert from overlay's pixel formats bitmask to an array of fourcc's */
@@ -236,7 +236,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	/* convert to pixels: */
 	info->screen_width /= format->cpp[0];
 
-	if (omap_fb->dss_format == OMAP_DSS_COLOR_NV12) {
+	if (omap_fb->dss_format == DRM_FORMAT_NV12) {
 		plane = &omap_fb->planes[1];
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {

commit 9c39d17e0614d18d809ccf2c3858994feb4fcdaa
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:19:12 2017 +0300

    drm/omap: use u32 instead of enum omap_color_mode
    
    In this step we drop 'enum omap_color_mode', and use u32 instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 6fb25d35bc0a..71b3f25e61c2 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -31,7 +31,7 @@
 
 /* DSS to DRM formats mapping */
 static const struct {
-	enum omap_color_mode dss_format;
+	u32 dss_format;
 	uint32_t pixel_format;
 } formats[] = {
 	/* 16bpp [A]RGB: */
@@ -57,7 +57,7 @@ static const struct {
 
 /* convert from overlay's pixel formats bitmask to an array of fourcc's */
 uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,
-		uint32_t max_formats, const enum omap_color_mode *supported_modes)
+		uint32_t max_formats, const u32 *supported_modes)
 {
 	uint32_t nformats = 0;
 	int i = 0;
@@ -91,7 +91,7 @@ struct omap_framebuffer {
 	struct drm_framebuffer base;
 	int pin_count;
 	const struct drm_format_info *format;
-	enum omap_color_mode dss_format;
+	u32 dss_format;
 	struct plane planes[2];
 	/* lock for pinning (pin_count and planes.dma_addr) */
 	struct mutex lock;
@@ -395,7 +395,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	const struct drm_format_info *format = NULL;
 	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;
-	enum omap_color_mode dss_format = 0;
+	u32 dss_format = 0;
 	unsigned int pitch = mode_cmd->pitches[0];
 	int ret, i;
 

commit 18c0d6217a4898b9cae1b999e0dd37f8239ba0ae
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 10:27:53 2017 +0300

    drm/omap: change supported_modes to an array
    
    enum omap_color_mode is a bitmask, so at the moment we present the
    supported color modes as mask. To be able to move to fourccs, we need to
    use an array to present the supported color modes.
    
    As a first step towards fourccs, this patch changes the code to use an
    array to store the enums.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 1d2a94df7054..6fb25d35bc0a 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -57,14 +57,22 @@ static const struct {
 
 /* convert from overlay's pixel formats bitmask to an array of fourcc's */
 uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,
-		uint32_t max_formats, enum omap_color_mode supported_modes)
+		uint32_t max_formats, const enum omap_color_mode *supported_modes)
 {
 	uint32_t nformats = 0;
 	int i = 0;
 
-	for (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++)
-		if (formats[i].dss_format & supported_modes)
+	for (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++) {
+		unsigned int t;
+
+		for (t = 0; supported_modes[t]; ++t) {
+			if (supported_modes[t] != formats[i].dss_format)
+				continue;
+
 			pixel_formats[nformats++] = formats[i].pixel_format;
+			break;
+		}
+	}
 
 	return nformats;
 }

commit 517a8a9564c0dea98e6d4e2c7f0fe4cbb9b8c9ba
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 3 14:14:27 2017 +0300

    drm/omap: remove dma & vrfb rotation
    
    We have three rotation methods supported by the SoCs with DSS: DMA,
    VRFB and TILER.
    
    DMA rotation works in theory on all DSS platforms, but in practice it's
    unusable due to the huge amount of memory bandwidth it uses, and has
    never really been used.
    
    VRFB is available on OMAP3, but is not supported by omapdrm, even though
    we have some code for it in the dispc driver.
    
    TILER is supported on OMAP4/OMAP5/DRA7/AM5 platforms, but has some
    driver bugs.
    
    To clean up the driver to help fixing the TILER issues, this patch drops
    the DMA and VRFB rotation support, leaving only TILER rotation.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 4bf9fcfcf673..1d2a94df7054 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -221,7 +221,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		}
 
 		info->paddr         = get_linear_addr(plane, format, 0, x, y);
-		info->rotation_type = OMAP_DSS_ROT_DMA;
+		info->rotation_type = OMAP_DSS_ROT_NONE;
 		info->screen_width  = plane->pitch;
 	}
 

commit 2150c19b15b01458cfa0b2db68c7ad035011a1fb
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Feb 21 09:57:12 2017 +0200

    drm/omap: 64bit compile fixes
    
    Fix a few type issues that cause compile warnings on 64 bit ARM
    compiler. The change should not affect 32bit platforms.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index ee615fa048a5..4bf9fcfcf673 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -450,7 +450,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 
 		if (size > omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i]) {
 			dev_dbg(dev->dev,
-				"provided buffer object is too small! %d < %d\n",
+				"provided buffer object is too small! %zu < %d\n",
 				bos[i]->size - mode_cmd->offsets[i], size);
 			ret = -EINVAL;
 			goto fail;

commit d61ce7da02a3c52317474f2a15dd610ec652d513
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Apr 21 00:33:55 2017 +0300

    drm: omapdrm: Rename GEM DMA sync functions
    
    The omap_gem_cpu_sync() function operates at a page level, while the
    omap_gem_dma_sync() function operates at a buffer level. Rename them to
    omap_gem_cpu_sync_page() and omap_gem_dma_sync_buffer() respectively to
    avoid confusion.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 2e8d77166e1f..ee615fa048a5 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -262,7 +262,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 		ret = omap_gem_pin(plane->bo, &plane->dma_addr);
 		if (ret)
 			goto fail;
-		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
+		omap_gem_dma_sync_buffer(plane->bo, DMA_TO_DEVICE);
 	}
 
 	omap_fb->pin_count++;

commit bc20c85caba279b7c63146bab683ca1a81de9f79
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Apr 21 00:33:52 2017 +0300

    drm: omapdrm: Rename omap_gem_(get|put)_paddr() to omap_gem_(un)pin()
    
    The reflects the purpose of the function better.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 444bf92c5252..2e8d77166e1f 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -259,7 +259,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_get_paddr(plane->bo, &plane->dma_addr);
+		ret = omap_gem_pin(plane->bo, &plane->dma_addr);
 		if (ret)
 			goto fail;
 		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
@@ -274,7 +274,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 fail:
 	for (i--; i >= 0; i--) {
 		struct plane *plane = &omap_fb->planes[i];
-		omap_gem_put_paddr(plane->bo);
+		omap_gem_unpin(plane->bo);
 		plane->dma_addr = 0;
 	}
 
@@ -300,7 +300,7 @@ void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		omap_gem_put_paddr(plane->bo);
+		omap_gem_unpin(plane->bo);
 		plane->dma_addr = 0;
 	}
 

commit 16869083b9bec8c1090442bd176a5b376708aba0
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Apr 21 00:33:51 2017 +0300

    drm: omapdrm: Rename occurrences of paddr to dma_addr
    
    The fields, variables and functions deal with DMA addresses, name them
    accordingly. The omap_gem_get_paddr() and omap_gem_put_paddr() will be
    addressed differently separately.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 5fc240f3a67e..444bf92c5252 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -74,7 +74,7 @@ struct plane {
 	struct drm_gem_object *bo;
 	uint32_t pitch;
 	uint32_t offset;
-	dma_addr_t paddr;
+	dma_addr_t dma_addr;
 };
 
 #define to_omap_framebuffer(x) container_of(x, struct omap_framebuffer, base)
@@ -85,7 +85,7 @@ struct omap_framebuffer {
 	const struct drm_format_info *format;
 	enum omap_color_mode dss_format;
 	struct plane planes[2];
-	/* lock for pinning (pin_count and planes.paddr) */
+	/* lock for pinning (pin_count and planes.dma_addr) */
 	struct mutex lock;
 };
 
@@ -130,7 +130,7 @@ static uint32_t get_linear_addr(struct plane *plane,
 	       + (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))
 	       + (y * plane->pitch / (n == 0 ? 1 : format->vsub));
 
-	return plane->paddr + offset;
+	return plane->dma_addr + offset;
 }
 
 bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
@@ -201,7 +201,8 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		if (orient & MASK_X_INVERT)
 			x += w - 1;
 
-		omap_gem_rotated_paddr(plane->bo, orient, x, y, &info->paddr);
+		omap_gem_rotated_dma_addr(plane->bo, orient, x, y,
+					  &info->paddr);
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
@@ -232,8 +233,8 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
 			WARN_ON(!(omap_gem_flags(plane->bo) & OMAP_BO_TILED));
-			omap_gem_rotated_paddr(plane->bo, orient,
-					x/2, y/2, &info->p_uv_addr);
+			omap_gem_rotated_dma_addr(plane->bo, orient, x/2, y/2,
+						  &info->p_uv_addr);
 		} else {
 			info->p_uv_addr = get_linear_addr(plane, format, 1, x, y);
 		}
@@ -258,7 +259,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_get_paddr(plane->bo, &plane->paddr);
+		ret = omap_gem_get_paddr(plane->bo, &plane->dma_addr);
 		if (ret)
 			goto fail;
 		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
@@ -274,7 +275,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 	for (i--; i >= 0; i--) {
 		struct plane *plane = &omap_fb->planes[i];
 		omap_gem_put_paddr(plane->bo);
-		plane->paddr = 0;
+		plane->dma_addr = 0;
 	}
 
 	mutex_unlock(&omap_fb->lock);
@@ -300,7 +301,7 @@ void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
 		omap_gem_put_paddr(plane->bo);
-		plane->paddr = 0;
+		plane->dma_addr = 0;
 	}
 
 	mutex_unlock(&omap_fb->lock);
@@ -458,7 +459,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		plane->bo     = bos[i];
 		plane->offset = mode_cmd->offsets[i];
 		plane->pitch  = pitch;
-		plane->paddr  = 0;
+		plane->dma_addr  = 0;
 	}
 
 	drm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);

commit aa0408bcb1b8c2c5941b6e0e7ce0ad2b733bb971
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Apr 21 00:33:50 2017 +0300

    drm: omapdrm: Remove remap argument to omap_gem_get_paddr()
    
    The function is always called with the remap argument set to true.
    Hardcode that behaviour and remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 5ca0537bb427..5fc240f3a67e 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -258,7 +258,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);
+		ret = omap_gem_get_paddr(plane->bo, &plane->paddr);
 		if (ret)
 			goto fail;
 		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);

commit c2c446ad29437bb92b157423c632286608ebd3ec
Author: Robert Foss <robert.foss@collabora.com>
Date:   Fri May 19 16:50:17 2017 -0400

    drm: Add DRM_MODE_ROTATE_ and DRM_MODE_REFLECT_ to UAPI
    
    Add DRM_MODE_ROTATE_ and DRM_MODE_REFLECT_ defines to the UAPI
    as a convenience.
    
    Ideally the DRM_ROTATE_ and DRM_REFLECT_ property ids are looked up
    through the atomic API, but realizing that userspace is likely to take
    shortcuts and assume that the enum values are what is sent over the
    wire.
    
    As a result these defines are provided purely as a convenience to
    userspace applications.
    
    Changes since v3:
     - Switched away from past tense in comments
     - Add define name change to previously mis-spelled DRM_REFLECT_X comment
     - Improved the comment for the DRM_MODE_REFLECT_<axis> comment
    
    Changes since v2:
     - Changed define prefix from DRM_MODE_PROP_ to DRM_MODE_
     - Fix compilation errors
     - Changed comment formatting
     - Deduplicated comment lines
     - Clarified DRM_MODE_PROP_REFLECT_ comment
    
    Changes since v1:
     - Moved defines from drm.h to drm_mode.h
     - Changed define prefix from DRM_ to DRM_MODE_PROP_
     - Updated uses of the defines to the new prefix
     - Removed include from drm_rect.c
     - Stopped using the BIT() macro
    
    Signed-off-by: Robert Foss <robert.foss@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170519205017.23307-2-robert.foss@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 29dc677dd4d3..5ca0537bb427 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -167,30 +167,30 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		uint32_t w = win->src_w;
 		uint32_t h = win->src_h;
 
-		switch (win->rotation & DRM_ROTATE_MASK) {
+		switch (win->rotation & DRM_MODE_ROTATE_MASK) {
 		default:
 			dev_err(fb->dev->dev, "invalid rotation: %02x",
 					(uint32_t)win->rotation);
 			/* fallthru to default to no rotation */
 		case 0:
-		case DRM_ROTATE_0:
+		case DRM_MODE_ROTATE_0:
 			orient = 0;
 			break;
-		case DRM_ROTATE_90:
+		case DRM_MODE_ROTATE_90:
 			orient = MASK_XY_FLIP | MASK_X_INVERT;
 			break;
-		case DRM_ROTATE_180:
+		case DRM_MODE_ROTATE_180:
 			orient = MASK_X_INVERT | MASK_Y_INVERT;
 			break;
-		case DRM_ROTATE_270:
+		case DRM_MODE_ROTATE_270:
 			orient = MASK_XY_FLIP | MASK_Y_INVERT;
 			break;
 		}
 
-		if (win->rotation & DRM_REFLECT_X)
+		if (win->rotation & DRM_MODE_REFLECT_X)
 			orient ^= MASK_X_INVERT;
 
-		if (win->rotation & DRM_REFLECT_Y)
+		if (win->rotation & DRM_MODE_REFLECT_Y)
 			orient ^= MASK_Y_INVERT;
 
 		/* adjust x,y offset for flip/invert: */
@@ -205,9 +205,9 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
-		switch (win->rotation & DRM_ROTATE_MASK) {
+		switch (win->rotation & DRM_MODE_ROTATE_MASK) {
 		case 0:
-		case DRM_ROTATE_0:
+		case DRM_MODE_ROTATE_0:
 			/* OK */
 			break;
 

commit 01f5e6912c8abc8a23248e6cf66939756f0fb27c
Merge: d64a1661c8f7 42f7f3c4811b
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jan 23 10:17:06 2017 +1000

    Merge tag 'omapdrm-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux into drm-next
    
    omapdrm changes for 4.11
    
    The main change here is the IRQ code cleanup, which gives us properly working
    vblank counts and timestamps. We also get much less calls to runtime PM gets &
    puts.
    
    * tag 'omapdrm-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (26 commits)
      drm/omap: panel-sony-acx565akm.c: Add MODULE_ALIAS
      drm/omap: dsi: fix compile errors when enabling debug prints
      drm: omapdrm: Perform initialization/cleanup at probe/remove time
      drm: Move vblank cleanup from unregister to release
      drm: omapdrm: Use sizeof(*var) instead of sizeof(type) for structures
      drm: omapdrm: Remove global variables
      drm: omapdrm: Simplify IRQ wait implementation
      drm: omapdrm: Inline the pipe2vbl function
      drm: omapdrm: Don't call DISPC power handling in IRQ wait functions
      drm: omapdrm: Remove unused parameter from omap_drm_irq handler
      drm: omapdrm: Don't expose the omap_irq_(un)register() functions
      drm: omapdrm: Keep vblank interrupt enabled while CRTC is active
      drm: omapdrm: Use a spinlock to protect the CRTC pending flag
      drm: omapdrm: Prevent processing the same event multiple times
      drm: omapdrm: Check the CRTC software state at enable/disable time
      drm: omapdrm: Let the DRM core skip plane commit on inactive CRTCs
      drm: omapdrm: Replace DSS manager state check with omapdrm CRTC state
      drm: omapdrm: Handle OCP error IRQ directly
      drm: omapdrm: Handle CRTC error IRQs directly
      drm: omapdrm: Handle FIFO underflow IRQs internally
      ...

commit a078a3ddc7209474e8dd827743390e9ed4bc6881
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 26 20:02:49 2016 +0200

    drm: omapdrm: fb: Turn framebuffer creation error messages into debug
    
    Don't print userspace parameters validation failures as error messages
    to avoid giving userspace the ability to flood the kernel log.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 016aac9a7731..a30f2060c1d6 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -404,8 +404,8 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	}
 
 	if (!format || !dss_format) {
-		dev_err(dev->dev, "unsupported pixel format: %4.4s\n",
-				(char *)&mode_cmd->pixel_format);
+		dev_dbg(dev->dev, "unsupported pixel format: %4.4s\n",
+			(char *)&mode_cmd->pixel_format);
 		ret = -EINVAL;
 		goto fail;
 	}
@@ -427,13 +427,13 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	 * bytes per pixel.
 	 */
 	if (format->num_planes == 2 && pitch != mode_cmd->pitches[1]) {
-		dev_err(dev->dev, "pitches differ between planes 0 and 1\n");
+		dev_dbg(dev->dev, "pitches differ between planes 0 and 1\n");
 		ret = -EINVAL;
 		goto fail;
 	}
 
 	if (pitch % format->cpp[0]) {
-		dev_err(dev->dev,
+		dev_dbg(dev->dev,
 			"buffer pitch (%u bytes) is not a multiple of pixel size (%u bytes)\n",
 			pitch, format->cpp[0]);
 		ret = -EINVAL;
@@ -448,7 +448,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		size = pitch * mode_cmd->height / vsub;
 
 		if (size > omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i]) {
-			dev_err(dev->dev,
+			dev_dbg(dev->dev,
 				"provided buffer object is too small! %d < %d\n",
 				bos[i]->size - mode_cmd->offsets[i], size);
 			ret = -EINVAL;

commit 6941e3d12b3284ea5b8d32b7023221700cad5f49
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 26 20:01:13 2016 +0200

    drm: omapdrm: fb: Simplify mode command checks when creating framebuffer
    
    The hardware requires all planes to have an identical pitch in number of
    pixels. Given that all supported formats use the same number of bytes
    per pixel in all planes, framebuffer creation checks can be simplified.
    The implementations assumes that no format use more than two planes
    which is true with the existing hardware.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 195ab4c86244..016aac9a7731 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -387,6 +387,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;
 	enum omap_color_mode dss_format = 0;
+	unsigned int pitch = mode_cmd->pitches[0];
 	int ret, i;
 
 	DBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",
@@ -420,41 +421,36 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	omap_fb->dss_format = dss_format;
 	mutex_init(&omap_fb->lock);
 
+	/*
+	 * The code below assumes that no format use more than two planes, and
+	 * that the two planes of multiplane formats need the same number of
+	 * bytes per pixel.
+	 */
+	if (format->num_planes == 2 && pitch != mode_cmd->pitches[1]) {
+		dev_err(dev->dev, "pitches differ between planes 0 and 1\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	if (pitch % format->cpp[0]) {
+		dev_err(dev->dev,
+			"buffer pitch (%u bytes) is not a multiple of pixel size (%u bytes)\n",
+			pitch, format->cpp[0]);
+		ret = -EINVAL;
+		goto fail;
+	}
+
 	for (i = 0; i < format->num_planes; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		unsigned int pitch = mode_cmd->pitches[i];
-		unsigned int hsub = i == 0 ? 1 : format->hsub;
 		unsigned int vsub = i == 0 ? 1 : format->vsub;
 		unsigned int size;
 
-		if (pitch < mode_cmd->width * format->cpp[i] / hsub) {
-			dev_err(dev->dev, "provided buffer pitch is too small! %d < %d\n",
-				pitch, mode_cmd->width * format->cpp[i] / hsub);
-			ret = -EINVAL;
-			goto fail;
-		}
-
-		if (pitch % format->cpp[i] != 0) {
-			dev_err(dev->dev,
-				"buffer pitch (%d bytes) is not a multiple of pixel size (%d bytes)\n",
-				pitch, format->cpp[i]);
-			ret = -EINVAL;
-			goto fail;
-		}
-
 		size = pitch * mode_cmd->height / vsub;
 
-		if (size > (omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i])) {
-			dev_err(dev->dev, "provided buffer object is too small! %d < %d\n",
-					bos[i]->size - mode_cmd->offsets[i], size);
-			ret = -EINVAL;
-			goto fail;
-		}
-
-		if (i > 0 && pitch != mode_cmd->pitches[i - 1]) {
+		if (size > omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i]) {
 			dev_err(dev->dev,
-				"pitches are not the same between framebuffer planes %d != %d\n",
-				pitch, mode_cmd->pitches[i - 1]);
+				"provided buffer object is too small! %d < %d\n",
+				bos[i]->size - mode_cmd->offsets[i], size);
 			ret = -EINVAL;
 			goto fail;
 		}

commit a39c94e8138f4708b92245a7021ad4d40376360f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 26 19:51:57 2016 +0200

    drm: omapdrm: fb: Simplify objects lookup when creating framebuffer
    
    Merge the single-user objects_lookup inline function into its caller,
    allowing reuse of the error code path.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 6315d68989fc..195ab4c86244 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -354,22 +354,29 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)
 {
+	unsigned int num_planes = drm_format_num_planes(mode_cmd->pixel_format);
 	struct drm_gem_object *bos[4];
 	struct drm_framebuffer *fb;
-	int ret;
+	int i;
 
-	ret = objects_lookup(file, mode_cmd->pixel_format,
-			bos, mode_cmd->handles);
-	if (ret)
-		return ERR_PTR(ret);
+	for (i = 0; i < num_planes; i++) {
+		bos[i] = drm_gem_object_lookup(file, mode_cmd->handles[i]);
+		if (!bos[i]) {
+			fb = ERR_PTR(-ENOENT);
+			goto error;
+		}
+	}
 
 	fb = omap_framebuffer_init(dev, mode_cmd, bos);
-	if (IS_ERR(fb)) {
-		int i, n = drm_format_num_planes(mode_cmd->pixel_format);
-		for (i = 0; i < n; i++)
-			drm_gem_object_unreference_unlocked(bos[i]);
-		return fb;
-	}
+	if (IS_ERR(fb))
+		goto error;
+
+	return fb;
+
+error:
+	while (--i > 0)
+		drm_gem_object_unreference_unlocked(bos[i]);
+
 	return fb;
 }
 

commit c9028b39597fbdcdac96641e12cc656a27c137c1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 7 00:45:35 2016 +0300

    drm: omapdrm: fb: Use format information provided by the DRM core
    
    The driver stores in a custom structure named format several pieces of
    information about the format that are available in the DRM core. Remove
    them and get the information from the DRM core instead.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 7646df33f9a1..6315d68989fc 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -29,37 +29,30 @@
  * framebuffer funcs
  */
 
-/* per-format info: */
-struct format {
+/* DSS to DRM formats mapping */
+static const struct {
 	enum omap_color_mode dss_format;
 	uint32_t pixel_format;
-	struct {
-		int stride_bpp;           /* this times width is stride */
-		int sub_y;                /* sub-sample in y dimension */
-	} planes[2];
-	bool yuv;
-};
-
-static const struct format formats[] = {
+} formats[] = {
 	/* 16bpp [A]RGB: */
-	{ OMAP_DSS_COLOR_RGB16,       DRM_FORMAT_RGB565,   {{2, 1}}, false }, /* RGB16-565 */
-	{ OMAP_DSS_COLOR_RGB12U,      DRM_FORMAT_RGBX4444, {{2, 1}}, false }, /* RGB12x-4444 */
-	{ OMAP_DSS_COLOR_RGBX16,      DRM_FORMAT_XRGB4444, {{2, 1}}, false }, /* xRGB12-4444 */
-	{ OMAP_DSS_COLOR_RGBA16,      DRM_FORMAT_RGBA4444, {{2, 1}}, false }, /* RGBA12-4444 */
-	{ OMAP_DSS_COLOR_ARGB16,      DRM_FORMAT_ARGB4444, {{2, 1}}, false }, /* ARGB16-4444 */
-	{ OMAP_DSS_COLOR_XRGB16_1555, DRM_FORMAT_XRGB1555, {{2, 1}}, false }, /* xRGB15-1555 */
-	{ OMAP_DSS_COLOR_ARGB16_1555, DRM_FORMAT_ARGB1555, {{2, 1}}, false }, /* ARGB16-1555 */
+	{ OMAP_DSS_COLOR_RGB16,       DRM_FORMAT_RGB565 },   /* RGB16-565 */
+	{ OMAP_DSS_COLOR_RGB12U,      DRM_FORMAT_RGBX4444 }, /* RGB12x-4444 */
+	{ OMAP_DSS_COLOR_RGBX16,      DRM_FORMAT_XRGB4444 }, /* xRGB12-4444 */
+	{ OMAP_DSS_COLOR_RGBA16,      DRM_FORMAT_RGBA4444 }, /* RGBA12-4444 */
+	{ OMAP_DSS_COLOR_ARGB16,      DRM_FORMAT_ARGB4444 }, /* ARGB16-4444 */
+	{ OMAP_DSS_COLOR_XRGB16_1555, DRM_FORMAT_XRGB1555 }, /* xRGB15-1555 */
+	{ OMAP_DSS_COLOR_ARGB16_1555, DRM_FORMAT_ARGB1555 }, /* ARGB16-1555 */
 	/* 24bpp RGB: */
-	{ OMAP_DSS_COLOR_RGB24P,      DRM_FORMAT_RGB888,   {{3, 1}}, false }, /* RGB24-888 */
+	{ OMAP_DSS_COLOR_RGB24P,      DRM_FORMAT_RGB888 },   /* RGB24-888 */
 	/* 32bpp [A]RGB: */
-	{ OMAP_DSS_COLOR_RGBX32,      DRM_FORMAT_RGBX8888, {{4, 1}}, false }, /* RGBx24-8888 */
-	{ OMAP_DSS_COLOR_RGB24U,      DRM_FORMAT_XRGB8888, {{4, 1}}, false }, /* xRGB24-8888 */
-	{ OMAP_DSS_COLOR_RGBA32,      DRM_FORMAT_RGBA8888, {{4, 1}}, false }, /* RGBA32-8888 */
-	{ OMAP_DSS_COLOR_ARGB32,      DRM_FORMAT_ARGB8888, {{4, 1}}, false }, /* ARGB32-8888 */
+	{ OMAP_DSS_COLOR_RGBX32,      DRM_FORMAT_RGBX8888 }, /* RGBx24-8888 */
+	{ OMAP_DSS_COLOR_RGB24U,      DRM_FORMAT_XRGB8888 }, /* xRGB24-8888 */
+	{ OMAP_DSS_COLOR_RGBA32,      DRM_FORMAT_RGBA8888 }, /* RGBA32-8888 */
+	{ OMAP_DSS_COLOR_ARGB32,      DRM_FORMAT_ARGB8888 }, /* ARGB32-8888 */
 	/* YUV: */
-	{ OMAP_DSS_COLOR_NV12,        DRM_FORMAT_NV12,     {{1, 1}, {1, 2}}, true },
-	{ OMAP_DSS_COLOR_YUV2,        DRM_FORMAT_YUYV,     {{2, 1}}, true },
-	{ OMAP_DSS_COLOR_UYVY,        DRM_FORMAT_UYVY,     {{2, 1}}, true },
+	{ OMAP_DSS_COLOR_NV12,        DRM_FORMAT_NV12 },
+	{ OMAP_DSS_COLOR_YUV2,        DRM_FORMAT_YUYV },
+	{ OMAP_DSS_COLOR_UYVY,        DRM_FORMAT_UYVY },
 };
 
 /* convert from overlay's pixel formats bitmask to an array of fourcc's */
@@ -89,7 +82,8 @@ struct plane {
 struct omap_framebuffer {
 	struct drm_framebuffer base;
 	int pin_count;
-	const struct format *format;
+	const struct drm_format_info *format;
+	enum omap_color_mode dss_format;
 	struct plane planes[2];
 	/* lock for pinning (pin_count and planes.paddr) */
 	struct mutex lock;
@@ -128,13 +122,13 @@ static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
 };
 
 static uint32_t get_linear_addr(struct plane *plane,
-		const struct format *format, int n, int x, int y)
+		const struct drm_format_info *format, int n, int x, int y)
 {
 	uint32_t offset;
 
-	offset = plane->offset +
-			(x * format->planes[n].stride_bpp) +
-			(y * plane->pitch / format->planes[n].sub_y);
+	offset = plane->offset
+	       + (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))
+	       + (y * plane->pitch / (n == 0 ? 1 : format->vsub));
 
 	return plane->paddr + offset;
 }
@@ -153,11 +147,11 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		struct omap_drm_window *win, struct omap_overlay_info *info)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	const struct format *format = omap_fb->format;
+	const struct drm_format_info *format = omap_fb->format;
 	struct plane *plane = &omap_fb->planes[0];
 	uint32_t x, y, orient = 0;
 
-	info->color_mode = format->dss_format;
+	info->color_mode = omap_fb->dss_format;
 
 	info->pos_x      = win->crtc_x;
 	info->pos_y      = win->crtc_y;
@@ -231,9 +225,9 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	}
 
 	/* convert to pixels: */
-	info->screen_width /= format->planes[0].stride_bpp;
+	info->screen_width /= format->cpp[0];
 
-	if (format->dss_format == OMAP_DSS_COLOR_NV12) {
+	if (omap_fb->dss_format == OMAP_DSS_COLOR_NV12) {
 		plane = &omap_fb->planes[1];
 
 		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
@@ -382,23 +376,26 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
 {
+	const struct drm_format_info *format = NULL;
 	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;
-	const struct format *format = NULL;
-	int ret, i, n = drm_format_num_planes(mode_cmd->pixel_format);
+	enum omap_color_mode dss_format = 0;
+	int ret, i;
 
 	DBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",
 			dev, mode_cmd, mode_cmd->width, mode_cmd->height,
 			(char *)&mode_cmd->pixel_format);
 
+	format = drm_format_info(mode_cmd->pixel_format);
+
 	for (i = 0; i < ARRAY_SIZE(formats); i++) {
 		if (formats[i].pixel_format == mode_cmd->pixel_format) {
-			format = &formats[i];
+			dss_format = formats[i].dss_format;
 			break;
 		}
 	}
 
-	if (!format) {
+	if (!format || !dss_format) {
 		dev_err(dev->dev, "unsupported pixel format: %4.4s\n",
 				(char *)&mode_cmd->pixel_format);
 		ret = -EINVAL;
@@ -413,28 +410,32 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 
 	fb = &omap_fb->base;
 	omap_fb->format = format;
+	omap_fb->dss_format = dss_format;
 	mutex_init(&omap_fb->lock);
 
-	for (i = 0; i < n; i++) {
+	for (i = 0; i < format->num_planes; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		int size, pitch = mode_cmd->pitches[i];
+		unsigned int pitch = mode_cmd->pitches[i];
+		unsigned int hsub = i == 0 ? 1 : format->hsub;
+		unsigned int vsub = i == 0 ? 1 : format->vsub;
+		unsigned int size;
 
-		if (pitch < (mode_cmd->width * format->planes[i].stride_bpp)) {
+		if (pitch < mode_cmd->width * format->cpp[i] / hsub) {
 			dev_err(dev->dev, "provided buffer pitch is too small! %d < %d\n",
-					pitch, mode_cmd->width * format->planes[i].stride_bpp);
+				pitch, mode_cmd->width * format->cpp[i] / hsub);
 			ret = -EINVAL;
 			goto fail;
 		}
 
-		if (pitch % format->planes[i].stride_bpp != 0) {
+		if (pitch % format->cpp[i] != 0) {
 			dev_err(dev->dev,
 				"buffer pitch (%d bytes) is not a multiple of pixel size (%d bytes)\n",
-				pitch, format->planes[i].stride_bpp);
+				pitch, format->cpp[i]);
 			ret = -EINVAL;
 			goto fail;
 		}
 
-		size = pitch * mode_cmd->height / format->planes[i].sub_y;
+		size = pitch * mode_cmd->height / vsub;
 
 		if (size > (omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i])) {
 			dev_err(dev->dev, "provided buffer object is too small! %d < %d\n",

commit 4d20dfc053c7e0b2d155cbc6cb0817717753e2b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 26 19:24:01 2016 +0200

    drm: omapdrm: fb: Limit number of planes per framebuffer to two
    
    The only multi-planar format supported by the driver is NV12, there will
    thus never be more than two planes per framebuffer.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 5f3337f1e9aa..7646df33f9a1 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -36,7 +36,7 @@ struct format {
 	struct {
 		int stride_bpp;           /* this times width is stride */
 		int sub_y;                /* sub-sample in y dimension */
-	} planes[4];
+	} planes[2];
 	bool yuv;
 };
 
@@ -90,7 +90,7 @@ struct omap_framebuffer {
 	struct drm_framebuffer base;
 	int pin_count;
 	const struct format *format;
-	struct plane planes[4];
+	struct plane planes[2];
 	/* lock for pinning (pin_count and planes.paddr) */
 	struct mutex lock;
 };

commit 438b74a5497c36d6d59baded434002e30267cabe
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 23:32:55 2016 +0200

    drm: Nuke fb->pixel_format
    
    Replace uses of fb->pixel_format with fb->format->format.
    Less duplicated information is a good thing.
    
    Note that coccinelle failed to eliminate the
    "/* fourcc format */" comment from drm_framebuffer.h, so I had
    to do that part manually.
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     drm_helper_mode_fill_fb_struct(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     i9xx_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     ironlake_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     skylake_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *a;
    struct drm_framebuffer b;
    @@
    (
    - a->pixel_format
    + a->format->format
    |
    - b.pixel_format
    + b.format->format
    )
    
    @@
    struct drm_plane_state *a;
    struct drm_plane_state b;
    @@
    (
    - a->fb->pixel_format
    + a->fb->format->format
    |
    - b.fb->pixel_format
    + b.fb->format->format
    )
    
    @@
    struct drm_crtc *CRTC;
    @@
    (
    - CRTC->primary->fb->pixel_format
    + CRTC->primary->fb->format->format
    |
    - CRTC->primary->state->fb->pixel_format
    + CRTC->primary->state->fb->format->format
    )
    
    @@
    struct drm_mode_set *set;
    @@
    (
    - set->fb->pixel_format
    + set->fb->format->format
    |
    - set->crtc->primary->fb->pixel_format
    + set->crtc->primary->fb->format->format
    )
    
    @@
    @@
     struct drm_framebuffer {
             ...
    -        uint32_t pixel_format;
             ...
     };
    
    v2: Fix commit message (Laurent)
        Rebase due to earlier removal of many fb->pixel_format uses,
        including the 'fb->format = drm_format_info(fb->format->format);'
        snafu
    v3: Adjusted the semantic patch a bit and regenerated due to code
        changes
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com> (v1)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481751175-18463-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index c6ef457b9fca..bd6b94c38613 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -346,7 +346,7 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 	int i, n = fb->format->num_planes;
 
 	seq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,
-			(char *)&fb->pixel_format);
+			(char *)&fb->format->format);
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];

commit bcb0b461454c9cb3b5804cf75bacaadb52348864
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 23:30:22 2016 +0200

    drm: Replace drm_format_num_planes() with fb->format->num_planes
    
    Replace drm_format_num_planes(fb->pixel_format) with just
    fb->format->num_planes. Avoids the expensive format info lookup.
    
    @@
    struct drm_framebuffer *a;
    struct drm_framebuffer b;
    @@
    (
    - drm_format_num_planes(a->pixel_format)
    + a->format->num_planes
    |
    - drm_format_num_planes(b.pixel_format)
    + b.format->num_planes
    )
    
    @@
    struct drm_plane_state *a;
    struct drm_plane_state b;
    @@
    (
    - drm_format_num_planes(a->fb->pixel_format)
    + a->fb->format->num_planes
    |
    - drm_format_num_planes(b.fb->pixel_format)
    + b.fb->format->num_planes
    )
    
    @@
    struct drm_framebuffer *a;
    identifier T;
    @@
      T = a->pixel_format
    <+...
    - drm_format_num_planes(T)
    + a->format->num_planes
    ...+>
    
    @@
    struct drm_framebuffer b;
    identifier T;
    @@
      T = b.pixel_format
    <+...
    - drm_format_num_planes(T)
    + b.format->num_planes
    ...+>
    
    v2: Rerun spatch due to code changes
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481751022-18015-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 9875c99be009..c6ef457b9fca 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -107,7 +107,7 @@ static int omap_framebuffer_create_handle(struct drm_framebuffer *fb,
 static void omap_framebuffer_destroy(struct drm_framebuffer *fb)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int i, n = drm_format_num_planes(fb->pixel_format);
+	int i, n = fb->format->num_planes;
 
 	DBG("destroy: FB ID: %d (%p)", fb->base.id, fb);
 
@@ -252,7 +252,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 int omap_framebuffer_pin(struct drm_framebuffer *fb)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int ret, i, n = drm_format_num_planes(fb->pixel_format);
+	int ret, i, n = fb->format->num_planes;
 
 	mutex_lock(&omap_fb->lock);
 
@@ -292,7 +292,7 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int i, n = drm_format_num_planes(fb->pixel_format);
+	int i, n = fb->format->num_planes;
 
 	mutex_lock(&omap_fb->lock);
 
@@ -343,7 +343,7 @@ struct drm_connector *omap_framebuffer_get_next_connector(
 void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int i, n = drm_format_num_planes(fb->pixel_format);
+	int i, n = fb->format->num_planes;
 
 	seq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,
 			(char *)&fb->pixel_format);

commit a3f913ca98925d7e5bae725e9b2b38408215a695
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 22:48:59 2016 +0200

    drm: Pass 'dev' to drm_helper_mode_fill_fb_struct()
    
    Pass the drm_device to drm_helper_mode_fill_fb_struct() so that we can
    populate fb->dev early. Will make it easier to use the fb before we
    register it.
    
    @@
    identifier fb, mode_cmd;
    @@
     void drm_helper_mode_fill_fb_struct(
    +                                    struct drm_device *dev,
                                         struct drm_framebuffer *fb,
                                         const struct drm_mode_fb_cmd2 *mode_cmd
                                         );
    
    @@
    identifier fb, mode_cmd;
    @@
     void drm_helper_mode_fill_fb_struct(
    +                                    struct drm_device *dev,
                                         struct drm_framebuffer *fb,
                                         const struct drm_mode_fb_cmd2 *mode_cmd
                                         )
    { ... }
    
    @@
    function func;
    identifier dev;
    expression E1, E2;
    @@
    func(struct drm_device *dev, ...)
    {
     ...
     drm_helper_mode_fill_fb_struct(
    +                               dev,
                                    E1, E2);
     ...
    }
    
    @@
    expression E1, E2;
    @@
     drm_helper_mode_fill_fb_struct(
    +                               dev,
                                    E1, E2);
    
    v2: Rerun spatch due to code changes
    
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481748539-18283-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 5f3337f1e9aa..9875c99be009 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -457,7 +457,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		plane->paddr  = 0;
 	}
 
-	drm_helper_mode_fill_fb_struct(fb, mode_cmd);
+	drm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);
 
 	ret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);
 	if (ret) {

commit 31ad61e4afa53a7b2e364f7c021546fbc6ce0d85
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Jul 29 08:50:05 2016 +0300

    drm: BIT(DRM_ROTATE_?) -> DRM_ROTATE_?
    
    Only property creation uses the rotation as an index, so convert the
    to figure the index when needed.
    
    v2: Use the new defines to build the _MASK defines (Sean)
    
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: malidp@foss.arm.com
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com> (v1)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469771405-17653-1-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 31f5178c22c7..5f3337f1e9aa 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -179,24 +179,24 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 					(uint32_t)win->rotation);
 			/* fallthru to default to no rotation */
 		case 0:
-		case BIT(DRM_ROTATE_0):
+		case DRM_ROTATE_0:
 			orient = 0;
 			break;
-		case BIT(DRM_ROTATE_90):
+		case DRM_ROTATE_90:
 			orient = MASK_XY_FLIP | MASK_X_INVERT;
 			break;
-		case BIT(DRM_ROTATE_180):
+		case DRM_ROTATE_180:
 			orient = MASK_X_INVERT | MASK_Y_INVERT;
 			break;
-		case BIT(DRM_ROTATE_270):
+		case DRM_ROTATE_270:
 			orient = MASK_XY_FLIP | MASK_Y_INVERT;
 			break;
 		}
 
-		if (win->rotation & BIT(DRM_REFLECT_X))
+		if (win->rotation & DRM_REFLECT_X)
 			orient ^= MASK_X_INVERT;
 
-		if (win->rotation & BIT(DRM_REFLECT_Y))
+		if (win->rotation & DRM_REFLECT_Y)
 			orient ^= MASK_Y_INVERT;
 
 		/* adjust x,y offset for flip/invert: */
@@ -213,7 +213,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	} else {
 		switch (win->rotation & DRM_ROTATE_MASK) {
 		case 0:
-		case BIT(DRM_ROTATE_0):
+		case DRM_ROTATE_0:
 			/* OK */
 			break;
 

commit 76e4c327ea51d0da47938e343ef27b988bc5c659
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Jul 22 08:28:31 2016 +0200

    GPU-DRM-OMAP: Delete unnecessary checks before two function calls
    
    The following functions test whether their argument is NULL and then
    return immediately.
    * backlight_device_unregister
    * drm_gem_object_unreference_unlocked
    
    Thus the test around the calls is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/72ff4670-4f3d-c7ed-4f37-e49f2bbc7aba@users.sourceforge.net

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 983c8cf2441c..31f5178c22c7 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -115,8 +115,8 @@ static void omap_framebuffer_destroy(struct drm_framebuffer *fb)
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		if (plane->bo)
-			drm_gem_object_unreference_unlocked(plane->bo);
+
+		drm_gem_object_unreference_unlocked(plane->bo);
 	}
 
 	kfree(omap_fb);

commit 3c85f20a289d044f303f473ee6ab7502303fc3b0
Merge: 76c6dccf3441 492a426a2fc5
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 9 12:20:11 2016 +1000

    Merge tag 'omapdrm-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux into drm-next
    
    omapdrm changes for 4.8
    
    * Update MAINTAINERS file for omapdrm and tilcdc
    * PLL refactoring to allow versatile use of the PLL clocks
    * Public omapdss header refactoring to separate omapfb and omapdrm
    * Gamma table support
    * Support reset GPIO and vcc regulator in omapdrm's panel-dpi
    * Minor cleanups
    
    * tag 'omapdrm-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (69 commits)
      drm/omapdrm: Implement gamma_lut atomic crtc properties
      drm/omapdrm: Workaround for errata i734 (LCD1 Gamma) in DSS dispc
      drm/omapdrm: Add gamma table support to DSS dispc
      drm: drm_helper_crtc_enable_color_mgmt() => drm_crtc_enable_color_mgmt()
      drm/omap: rename panel/encoder Kconfig names
      drm: omapdrm: add DSI mapping
      drm: omapdrm: Remove unused omap_framebuffer_bo function
      drm: omapdrm: Remove unused omap_gem_tiled_size function
      drm: omapdrm: panel-lgphilips-lb035q02: Remove unused backlight GPIO
      drm/omap: panel-dpi: implement support for a vcc regulator
      drm/omap: panel-dpi: make (limited) use of a reset gpio
      devicetree/bindings: add reset-gpios and vcc-supply for panel-dpi
      MAINTAINERS: Add maintainer for TI LCDC DRM driver
      MAINTAINERS: Add maintainer for OMAP DRM driver
      drm/omap: fix pitch round-up
      drm/omap: remove align_pitch()
      drm/omap: remove unnecessary pitch round-up
      drm/omap: remove unneeded gpio includes
      drm/omap: Remove the video/omapdss.h and move it's content to local header file
      [media] omap_vout: Switch to use the video/omapfb_dss.h header file
      ...

commit bb4cec0222f984d7ef282c06cc3644069db21bac
Merge: fa625c195683 e1512ee08f00
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 9 11:02:30 2016 +1000

    Merge tag 'topic/lockless-gem-bo-freeing-2016-06-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    lockless gem bo freeing patches (and the oddball related patch) for all
    the drivers who's maintainers are asleep at the helm - includes you ;-)
    
    I based this on top of drm-fixes to include Chris' fix for the cma issue.
    
    * tag 'topic/lockless-gem-bo-freeing-2016-06-01' of git://anongit.freedesktop.org/drm-intel: (21 commits)
      drm/arcpgu: Use lockless gem BO free callback
      drm/sun4i: Use lockless gem BO free callback
      drm/omapdrm: Nuke dummy fb->dirty callback
      drm/msm: Nuke dummy fb->dirty callback
      drm/rockchip: Use cma gem vm ops
      drm/sti: Use lockless gem BO free callback
      drm: sti: remove useless call to dev->struct_mutex
      drm/virtio: Use lockless gem BO free callback
      drm/tilcdc: Use lockless gem BO free callback
      drm/shmob: Use lockless gem BO free callback
      drm/rockchip: Use lockless gem BO free callback
      drm/rcar-du: Use lockless gem BO free callback
      drm/qxl: Use lockless gem BO free callback
      drm/nouveau: Use lockless gem BO free callback
      drm/mga200g: Use lockless gem BO free callback
      drm/fls-dcu: Use lockless gem BO free callback
      drm/cirrus: Use lockless gem BO free callback
      drm/bochs: Use lockless gem BO free callback
      drm/atmel: Use lockless gem BO free callback
      drm/ast: Use lockless gem BO free callback
      ...

commit 6d39e63d5504a40a575a32b13f89423aa0a3698c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Apr 26 23:35:43 2016 +0300

    drm: omapdrm: Remove unused omap_framebuffer_bo function
    
    The function is never used, remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index f84570d1636c..530567cc25b7 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -320,14 +320,6 @@ void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 	mutex_unlock(&omap_fb->lock);
 }
 
-struct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p)
-{
-	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	if (p >= drm_format_num_planes(fb->pixel_format))
-		return NULL;
-	return omap_fb->planes[p].bo;
-}
-
 /* iterate thru all the connectors, returning ones that are attached
  * to the same fb..
  */

commit af3ef2925bb4b2b8e95411070f97de3fd48b685d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon May 30 19:53:14 2016 +0200

    drm/omapdrm: Nuke dummy fb->dirty callback
    
    It's an optional hook.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464630800-30786-23-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 94ec06d3d737..d639707f67db 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -120,17 +120,9 @@ static void omap_framebuffer_destroy(struct drm_framebuffer *fb)
 	kfree(omap_fb);
 }
 
-static int omap_framebuffer_dirty(struct drm_framebuffer *fb,
-		struct drm_file *file_priv, unsigned flags, unsigned color,
-		struct drm_clip_rect *clips, unsigned num_clips)
-{
-	return 0;
-}
-
 static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
 	.create_handle = omap_framebuffer_create_handle,
 	.destroy = omap_framebuffer_destroy,
-	.dirty = omap_framebuffer_dirty,
 };
 
 static uint32_t get_linear_addr(struct plane *plane,

commit 2d8024534a9ae8426ed249f317106b3404594c2d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed May 11 18:01:45 2016 +0200

    drm/omap: include linux/seq_file.h where needed
    
    The omapdrm driver relies on this header to be included
    implicitly, but this does not always work, and I get
    this error in randconfig builds:
    
    gpu/drm/omapdrm/dss/hdmi_phy.c: In function 'hdmi_phy_dump':
    gpu/drm/omapdrm/dss/hdmi_phy.c:34:2: error: implicit declaration of function 'seq_printf' [-Werror=implicit-function-declaration]
    gpu/drm/omapdrm/dss/hdmi_wp.c: In function 'hdmi_wp_dump':
    gpu/drm/omapdrm/dss/hdmi_wp.c:26:2: error: implicit declaration of function 'seq_printf' [-Werror=implicit-function-declaration]
    gpu/drm/omapdrm/dss/hdmi_pll.c: In function 'hdmi_pll_dump':
    gpu/drm/omapdrm/dss/hdmi_pll.c:30:2: error: implicit declaration of function 'seq_printf' [-Werror=implicit-function-declaration]
    
    This adds the #include statements in all files that have
    a seq_printf statement.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 94ec06d3d737..f84570d1636c 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -17,6 +17,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/seq_file.h>
+
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
 

commit a8ad0bd84f986072314595d05444719fdf29e412
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon May 9 11:04:54 2016 +0100

    drm: Remove unused drm_device from drm_gem_object_lookup()
    
    drm_gem_object_lookup() has never required the drm_device for its file
    local translation of the user handle to the GEM object. Let's remove the
    unused parameter and save some space.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    [danvet: Fixup kerneldoc too.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 610962396eb0..94ec06d3d737 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -378,7 +378,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 	struct drm_framebuffer *fb;
 	int ret;
 
-	ret = objects_lookup(dev, file, mode_cmd->pixel_format,
+	ret = objects_lookup(file, mode_cmd->pixel_format,
 			bos, mode_cmd->handles);
 	if (ret)
 		return ERR_PTR(ret);

commit bfeece553335f9b9bf0d4dc9ea8a602a2248dfd6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Aug 27 13:09:22 2015 +0300

    drm/omap: check if rotation is supported before commit
    
    omapdrm is missing a check on the validity of the rotation property.
    This leads to omapdrm possibly trying to use rotation on non-rotateable
    framebuffer, which causes the overlay setup to fail.
    
    This patch adds the necessary check to omap_plane_atomic_check().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 481512db2656..610962396eb0 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -145,6 +145,14 @@ static uint32_t get_linear_addr(struct plane *plane,
 	return plane->paddr + offset;
 }
 
+bool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	struct plane *plane = &omap_fb->planes[0];
+
+	return omap_gem_flags(plane->bo) & OMAP_BO_TILED;
+}
+
 /* update ovl info for scanout, handles cases of multi-planar fb's, etc.
  */
 void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,

commit be4f235c43f06ae749b8f99b04f899d1e9bd561e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jan 8 15:51:02 2016 +0200

    drm/omap: verify that fb plane pitches are the same
    
    The DSS hardware uses the same ROW_INC value for both Y and UV planes
    for NV12 format. This means that the pitches of the Y and UV planes have
    to match. omapdrm doesn't check this at the moment, and this can lead
    into a broken NV12 fb on the screen.
    
    This patch adds the check.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index ad202dfc1a49..481512db2656 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -449,6 +449,14 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 			goto fail;
 		}
 
+		if (i > 0 && pitch != mode_cmd->pitches[i - 1]) {
+			dev_err(dev->dev,
+				"pitches are not the same between framebuffer planes %d != %d\n",
+				pitch, mode_cmd->pitches[i - 1]);
+			ret = -EINVAL;
+			goto fail;
+		}
+
 		plane->bo     = bos[i];
 		plane->offset = mode_cmd->offsets[i];
 		plane->pitch  = pitch;

commit 1eb83451ba55d7a8c82b76b1591894ff2d4a95f2
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Wed Nov 11 19:11:29 2015 +0200

    drm: Pass the user drm_mode_fb_cmd2 as const to .fb_create()
    
    Drivers shouldn't clobber the passed in addfb ioctl parameters.
    i915 was doing just that. To prevent it from happening again,
    pass the struct around as const, starting all the way from
    internal_framebuffer_create().
    
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 636a1f921569..ad202dfc1a49 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -364,7 +364,7 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 #endif
 
 struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
-		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)
+		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)
 {
 	struct drm_gem_object *bos[4];
 	struct drm_framebuffer *fb;
@@ -386,7 +386,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 }
 
 struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
-		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
+		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
 {
 	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;

commit 14152c8d30bbe5155d0438feb0a1931aee0e5bce
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Oct 1 10:00:58 2015 +0300

    drm: Use DRM_ROTATE_MASK and DRM_REFLECT_MASK
    
    Avoid magic numbers and use the introduced defines.
    
    Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 51b1219af87f..636a1f921569 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -171,7 +171,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		uint32_t w = win->src_w;
 		uint32_t h = win->src_h;
 
-		switch (win->rotation & 0xf) {
+		switch (win->rotation & DRM_ROTATE_MASK) {
 		default:
 			dev_err(fb->dev->dev, "invalid rotation: %02x",
 					(uint32_t)win->rotation);
@@ -209,7 +209,7 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
-		switch (win->rotation & 0xf) {
+		switch (win->rotation & DRM_ROTATE_MASK) {
 		case 0:
 		case BIT(DRM_ROTATE_0):
 			/* OK */

commit 9c368506c96793f17934a61a0f06412afb7d2f8d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Apr 28 14:01:35 2015 +0300

    drm/omap: fix omap_framebuffer_unpin() error handling
    
    omap_framebuffer_unpin() check the return value of omap_gem_put_paddr()
    and return immediately if omap_gem_put_paddr() fails.
    
    This patch removes the check for the return value, and also removes the
    return value of omap_framebuffer_unpin(), because:
    
     * Nothing checks the return value of omap_framebuffer_unpin(), and even
       something did check it, there's nothing the caller can do to handle
       the error.
    
     * If a omap_gem_put_paddr() fails, the framebuffer's other planes will
       be left unreleased. So it's better to call omap_gem_put_paddr() for
       all the planes, even if one would fail.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 0b967e76df1a..51b1219af87f 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -287,10 +287,10 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 }
 
 /* unpin, no longer being scanned out: */
-int omap_framebuffer_unpin(struct drm_framebuffer *fb)
+void omap_framebuffer_unpin(struct drm_framebuffer *fb)
 {
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
-	int ret, i, n = drm_format_num_planes(fb->pixel_format);
+	int i, n = drm_format_num_planes(fb->pixel_format);
 
 	mutex_lock(&omap_fb->lock);
 
@@ -298,24 +298,16 @@ int omap_framebuffer_unpin(struct drm_framebuffer *fb)
 
 	if (omap_fb->pin_count > 0) {
 		mutex_unlock(&omap_fb->lock);
-		return 0;
+		return;
 	}
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_put_paddr(plane->bo);
-		if (ret)
-			goto fail;
+		omap_gem_put_paddr(plane->bo);
 		plane->paddr = 0;
 	}
 
 	mutex_unlock(&omap_fb->lock);
-
-	return 0;
-
-fail:
-	mutex_unlock(&omap_fb->lock);
-	return ret;
 }
 
 struct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p)

commit f524ab7c070b39f4c8bd76fede6cacd17057ebc3
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Jun 4 10:56:33 2015 +0300

    drm: omapdrm: add lock for fb pinning
    
    Before atomic modesetting omap_framebuffer_pin() and
    omap_framebuffer_unpin() were always called with modesetting locks
    taken. With atomic modesetting support this is no longer the case, and
    we need locking to protect the pin_count and the paddr, as multiple
    threads may pin the same fb concurrently.
    
    This patch adds a mutex to struct omap_framebuffer, and uses it in
    omap_framebuffer_pin() and omap_framebuffer_unpin().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index e505140a8782..0b967e76df1a 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -89,6 +89,8 @@ struct omap_framebuffer {
 	int pin_count;
 	const struct format *format;
 	struct plane planes[4];
+	/* lock for pinning (pin_count and planes.paddr) */
+	struct mutex lock;
 };
 
 static int omap_framebuffer_create_handle(struct drm_framebuffer *fb,
@@ -250,8 +252,11 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
+	mutex_lock(&omap_fb->lock);
+
 	if (omap_fb->pin_count > 0) {
 		omap_fb->pin_count++;
+		mutex_unlock(&omap_fb->lock);
 		return 0;
 	}
 
@@ -265,6 +270,8 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 
 	omap_fb->pin_count++;
 
+	mutex_unlock(&omap_fb->lock);
+
 	return 0;
 
 fail:
@@ -274,6 +281,8 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 		plane->paddr = 0;
 	}
 
+	mutex_unlock(&omap_fb->lock);
+
 	return ret;
 }
 
@@ -283,10 +292,14 @@ int omap_framebuffer_unpin(struct drm_framebuffer *fb)
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
+	mutex_lock(&omap_fb->lock);
+
 	omap_fb->pin_count--;
 
-	if (omap_fb->pin_count > 0)
+	if (omap_fb->pin_count > 0) {
+		mutex_unlock(&omap_fb->lock);
 		return 0;
+	}
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
@@ -296,9 +309,12 @@ int omap_framebuffer_unpin(struct drm_framebuffer *fb)
 		plane->paddr = 0;
 	}
 
+	mutex_unlock(&omap_fb->lock);
+
 	return 0;
 
 fail:
+	mutex_unlock(&omap_fb->lock);
 	return ret;
 }
 
@@ -411,6 +427,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 
 	fb = &omap_fb->base;
 	omap_fb->format = format;
+	mutex_init(&omap_fb->lock);
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];

commit 2d278f5414ae9cd535a7bdefaba2e2de38e116c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:31:37 2015 +0200

    drm: omapdrm: Clean up #include's
    
    Use the <...> include style instead of "..." for DRM headers and sort
    the headers alphabetically to ease detection of duplicates.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index b2c1a29cc12b..e505140a8782 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -17,11 +17,11 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "omap_drv.h"
-#include "omap_dmm_tiler.h"
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
 
-#include "drm_crtc.h"
-#include "drm_crtc_helper.h"
+#include "omap_dmm_tiler.h"
+#include "omap_drv.h"
 
 /*
  * framebuffer funcs

commit 2dab0bab6b749590086d44a04f9debc4fe894fd6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Sep 25 19:24:28 2014 +0000

    drm/omap: handle incompatible buffer stride and pixel size
    
    omapdrm doesn't check if the pitch of the framebuffer and the color
    format's bits-per-pixel are compatible. omapdss requires that the stride
    of a buffer is an integer number of pixels
    
    For example, when using modetest with a display that has x resolution of
    1280, and using packed 24 RGB mode (3 bytes per pixel), modetest
    allocates a buffer with a byte stride of 4 * 1280 = 5120. But 5120 / 3 =
    1706.666... pixels, which causes wrong colors and a tilt on the screen.
    
    Add a check into omapdrm to return an error if the user tries to use
    such a combination.
    
    Note: this is not a HW requirement at least for non-rotation use cases,
    but a SW driver requirement. In the future we should study if also
    rotation use cases are fine with any stride size, and if so, change the
    driver to allow these strides.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 3c6488e89788..b2c1a29cc12b 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -423,6 +423,14 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 			goto fail;
 		}
 
+		if (pitch % format->planes[i].stride_bpp != 0) {
+			dev_err(dev->dev,
+				"buffer pitch (%d bytes) is not a multiple of pixel size (%d bytes)\n",
+				pitch, format->planes[i].stride_bpp);
+			ret = -EINVAL;
+			goto fail;
+		}
+
 		size = pitch * mode_cmd->height / format->planes[i].sub_y;
 
 		if (size > (omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i])) {

commit 925e4940489a792b4aaf601c22c1943fbd9fd558
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Sep 25 19:24:27 2014 +0000

    drm/omap: fix error handling in omap_framebuffer_create()
    
    When an error happens in omap_framebuffer_create(),
    omap_framebuffer_create() calls omap_framebuffer_destroy() if the fb
    struct has been allocated. However, that crashes, as
    omap_framebuffer_destroy(), which calls drm_framebuffer_cleanup(),
    should only be called after drm_framebuffer_init()
    
    Fix this by just calling kfree() for the allocated fb when an error
    happens.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index d1e5f6da30d4..3c6488e89788 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -380,7 +380,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
 {
-	struct omap_framebuffer *omap_fb;
+	struct omap_framebuffer *omap_fb = NULL;
 	struct drm_framebuffer *fb = NULL;
 	const struct format *format = NULL;
 	int ret, i, n = drm_format_num_planes(mode_cmd->pixel_format);
@@ -451,8 +451,7 @@ struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
 	return fb;
 
 fail:
-	if (fb)
-		omap_framebuffer_destroy(fb);
+	kfree(omap_fb);
 
 	return ERR_PTR(ret);
 }

commit f36eb5a899d3ea57e3d167427260848e116e27a0
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Sep 3 19:25:54 2014 +0000

    drm/omap: add pin refcounting to omap_framebuffer
    
    omap_framebuffer_pin() and omap_framebuffer_unpin() are currently
    broken, as they cannot be called multiple times (i.e. pin, pin, unpin,
    unpin), which is what happens in certain cases. This issue causes the
    driver to possibly use 0 as an address for a displayed buffer, leading
    to OCP error from DSS.
    
    This patch fixes the issue by adding a simple pin_count, used to track
    the number of pins.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 45dd9eed9c57..d1e5f6da30d4 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -86,6 +86,7 @@ struct plane {
 
 struct omap_framebuffer {
 	struct drm_framebuffer base;
+	int pin_count;
 	const struct format *format;
 	struct plane planes[4];
 };
@@ -249,6 +250,11 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
+	if (omap_fb->pin_count > 0) {
+		omap_fb->pin_count++;
+		return 0;
+	}
+
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
 		ret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);
@@ -257,6 +263,8 @@ int omap_framebuffer_pin(struct drm_framebuffer *fb)
 		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
 	}
 
+	omap_fb->pin_count++;
+
 	return 0;
 
 fail:
@@ -275,6 +283,11 @@ int omap_framebuffer_unpin(struct drm_framebuffer *fb)
 	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
 	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
+	omap_fb->pin_count--;
+
+	if (omap_fb->pin_count > 0)
+		return 0;
+
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
 		ret = omap_gem_put_paddr(plane->bo);

commit 5a35876e2830511cb8110667fc426c6a6165a593
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jan 14 17:54:40 2015 +0200

    drm: omapdrm: Remove manual update display support
    
    All the manual update display code implements eventually ends up to just
    calls to omap_connector_flush(), currently implemented as an empty TODO
    stub. Remove it, the code can always be revived and implemented later if
    interest in manual update displays becomes a reality.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 2a5cacdc344b..45dd9eed9c57 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -121,18 +121,6 @@ static int omap_framebuffer_dirty(struct drm_framebuffer *fb,
 		struct drm_file *file_priv, unsigned flags, unsigned color,
 		struct drm_clip_rect *clips, unsigned num_clips)
 {
-	int i;
-
-	drm_modeset_lock_all(fb->dev);
-
-	for (i = 0; i < num_clips; i++) {
-		omap_framebuffer_flush(fb, clips[i].x1, clips[i].y1,
-					clips[i].x2 - clips[i].x1,
-					clips[i].y2 - clips[i].y1);
-	}
-
-	drm_modeset_unlock_all(fb->dev);
-
 	return 0;
 }
 
@@ -336,34 +324,6 @@ struct drm_connector *omap_framebuffer_get_next_connector(
 	return NULL;
 }
 
-/* flush an area of the framebuffer (in case of manual update display that
- * is not automatically flushed)
- */
-void omap_framebuffer_flush(struct drm_framebuffer *fb,
-		int x, int y, int w, int h)
-{
-	struct drm_connector *connector = NULL;
-
-	VERB("flush: %d,%d %dx%d, fb=%p", x, y, w, h, fb);
-
-	/* FIXME: This is racy - no protection against modeset config changes. */
-	while ((connector = omap_framebuffer_get_next_connector(fb, connector))) {
-		/* only consider connectors that are part of a chain */
-		if (connector->encoder && connector->encoder->crtc) {
-			/* TODO: maybe this should propagate thru the crtc who
-			 * could do the coordinate translation..
-			 */
-			struct drm_crtc *crtc = connector->encoder->crtc;
-			int cx = max(0, x - crtc->x);
-			int cy = max(0, y - crtc->y);
-			int cw = w + (x - crtc->x) - cx;
-			int ch = h + (y - crtc->y) - cy;
-
-			omap_connector_flush(connector, cx, cy, cw, ch);
-		}
-	}
-}
-
 #ifdef CONFIG_DEBUG_FS
 void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 {

commit 6e9f798d91c526982cca0026cd451e8fdbf18aaf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 29 23:54:47 2014 +0200

    drm: Split connection_mutex out of mode_config.mutex (v3)
    
    After the split-out of crtc locks from the big mode_config.mutex
    there's still two major areas it protects:
    - Various connector probe states, like connector->status, EDID
      properties, probed mode lists and similar information.
    - The links from connector->encoder and encoder->crtc and other
      modeset-relevant connector state (e.g. properties which control the
      panel fitter).
    
    The later is used by modeset operations. But they don't really care
    about the former since it's allowed to e.g. enable a disconnected VGA
    output or with a mode not in the probed list.
    
    Thus far this hasn't been a problem, but for the atomic modeset
    conversion Rob Clark needs to convert all modeset relevant locks into
    w/w locks. This is required because the order of acquisition is
    determined by how userspace supplies the atomic modeset data. This has
    run into troubles in the detect path since the i915 load detect code
    needs _both_ protections offered by the mode_config.mutex: It updates
    probe state and it needs to change the modeset configuration to enable
    the temporary load detect pipe.
    
    The big deal here is that for the probe/detect users of this lock a
    plain mutex fits best, but for atomic modesets we really want a w/w
    mutex. To fix this lets split out a new connection_mutex lock for the
    modeset relevant parts.
    
    For simplicity I've decided to only add one additional lock for all
    connector/encoder links and modeset configuration states. We have
    piles of different modeset objects in addition to those (like bridges
    or panels), so adding per-object locks would be much more effort.
    
    Also, we're guaranteed (at least for now) to do a full modeset if we
    need to acquire this lock. Which means that fine-grained locking is
    fairly irrelevant compared to the amount of time the full modeset will
    take.
    
    I've done a full audit, and there's just a few things that justify
    special focus:
    - Locking in drm_sysfs.c is almost completely absent. We should
      sprinkle mode_config.connection_mutex over this file a bit, but
      since it already lacks mode_config.mutex this patch wont make the
      situation any worse. This is material for a follow-up patch.
    
    - omap has a omap_framebuffer_flush function which walks the
      connector->encoder->crtc links and is called from many contexts.
      Some look like they don't acquire mode_config.mutex, so this is
      already racy. Again fixing this is material for a separate patch.
    
    - The radeon hot_plug function to retrain DP links looks at
      connector->dpms. Currently this happens without any locking, so is
      already racy. I think radeon_hotplug_work_func should gain
      mutex_lock/unlock calls for the mode_config.connection_mutex.
    
    - Same applies to i915's intel_dp_hot_plug. But again, this is already
      racy.
    
    - i915 load_detect code needs to acquire this lock. Which means the
      w/w dance due to Rob's work will be nicely contained to _just_ this
      function.
    
    I've added fixme comments everywhere where it looks suspicious but in
    the sysfs code. After a quick irc discussion with Dave Airlie it
    sounds like the lack of locking in there is due to sysfs cleanup fun
    at module unload.
    
    v1: original (only compile tested)
    
    v2: missing mutex_init(), etc (from Rob Clark)
    
    v3: i915 needs more care in the conversion:
    - Protect the edp pp logic with the connection_mutex.
    - Use connection_mutex in the backlight code due to
      get_pipe_from_connector.
    - Use drm_modeset_lock_all in suspend/resume paths.
    - Update lock checks in the overlay code.
    
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 8b019602ffe6..2a5cacdc344b 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -346,6 +346,7 @@ void omap_framebuffer_flush(struct drm_framebuffer *fb,
 
 	VERB("flush: %d,%d %dx%d, fb=%p", x, y, w, h, fb);
 
+	/* FIXME: This is racy - no protection against modeset config changes. */
 	while ((connector = omap_framebuffer_get_next_connector(fb, connector))) {
 		/* only consider connectors that are part of a chain */
 		if (connector->encoder && connector->encoder->crtc) {

commit 5ac96345899be859529e05af42f708ae7bd65782
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Apr 8 16:18:41 2014 +0300

    drm/omap: print warning when rotating non-TILER fb
    
    Print a warning when the user tries to rotate a non-TILER framebuffer.
    
    Also set the rotation to 0, to avoid constant flood of the warnings in
    case of page flipping.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index d2b8c49bfb4a..8b019602ffe6 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -218,6 +218,20 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 		info->rotation_type = OMAP_DSS_ROT_TILER;
 		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
 	} else {
+		switch (win->rotation & 0xf) {
+		case 0:
+		case BIT(DRM_ROTATE_0):
+			/* OK */
+			break;
+
+		default:
+			dev_warn(fb->dev->dev,
+				"rotation '%d' ignored for non-tiled fb\n",
+				win->rotation);
+			win->rotation = 0;
+			break;
+		}
+
 		info->paddr         = get_linear_addr(plane, format, 0, x, y);
 		info->rotation_type = OMAP_DSS_ROT_DMA;
 		info->screen_width  = plane->pitch;

commit 2614dc66837c2a6fd0e14e3f8e72343782c8b784
Merge: d9961b22716d 06fb220b2d1a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 4 08:03:21 2014 +1000

    Merge branch 'msm-next' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    * 'msm-next' of git://people.freedesktop.org/~robclark/linux:
      drm/omap: Don't dereference list head when the connectors list is empty
      drm/msm/mdp: add timeout for irq wait
      drm/msm: validate flags, etc
      drm/msm: use componentised device support
      drm/msm: add chip-id param
      drm/msm: crank down gpu when inactive
      drm/msm: spin helper
      drm/msm: add hang_debug module param
      drm/msm: hdmi audio support

commit f4510a2752b75ad5847b7935b68c233cab497f97
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:40 2014 -0700

    drm: Replace crtc fb with primary plane fb (v3)
    
    Now that CRTC's have a primary plane, there's no need to track the
    framebuffer in the CRTC.  Replace all references to the CRTC fb with the
    primary plane's fb.
    
    This patch was generated by the Coccinelle semantic patching tool using
    the following rules:
    
            @@ struct drm_crtc C; @@
            -   (C).fb
            +   C.primary->fb
    
            @@ struct drm_crtc *C; @@
            -   (C)->fb
            +   C->primary->fb
    
    v3: Generate patch via coccinelle.  Actual removal of crtc->fb has been
        moved to a subsequent patch.
    
    v2: Fixup several lingering crtc->fb instances that were missed in the
        first patch iteration.  [Rob Clark]
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index f466c4aaee94..0d5e9b7e8bbf 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -312,7 +312,7 @@ struct drm_connector *omap_framebuffer_get_next_connector(
 		if (connector != from) {
 			struct drm_encoder *encoder = connector->encoder;
 			struct drm_crtc *crtc = encoder ? encoder->crtc : NULL;
-			if (crtc && crtc->fb == fb)
+			if (crtc && crtc->primary->fb == fb)
 				return connector;
 
 		}

commit 06fb220b2d1a80be5621fa06ef276a3890e6be78
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Dec 24 12:58:01 2013 +0100

    drm/omap: Don't dereference list head when the connectors list is empty
    
    The connectors list iterator returns the list head when the list is
    empty. Fix it by returning NULL in that case.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index f466c4aaee94..19a9b8613620 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -306,7 +306,8 @@ struct drm_connector *omap_framebuffer_get_next_connector(
 	struct drm_connector *connector = from;
 
 	if (!from)
-		return list_first_entry(connector_list, typeof(*from), head);
+		return list_first_entry_or_null(connector_list, typeof(*from),
+						head);
 
 	list_for_each_entry_from(connector, connector_list, head) {
 		if (connector != from) {

commit 73e9efd4bddbf42d2938a150ba680b73b6126b77
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Wed Dec 4 14:13:58 2013 +0200

    drm: Push dirtyfb ioctl kms locking down to drivers
    
    Not all drivers will need take all the modeset locks for dirtyfb, so
    push the locking down to the drivers.
    
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index f2b8f0668c0c..f466c4aaee94 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -123,12 +123,16 @@ static int omap_framebuffer_dirty(struct drm_framebuffer *fb,
 {
 	int i;
 
+	drm_modeset_lock_all(fb->dev);
+
 	for (i = 0; i < num_clips; i++) {
 		omap_framebuffer_flush(fb, clips[i].x1, clips[i].y1,
 					clips[i].x2 - clips[i].x1,
 					clips[i].y2 - clips[i].y1);
 	}
 
+	drm_modeset_unlock_all(fb->dev);
+
 	return 0;
 }
 

commit 5833bd2fe1c7d9e2650a11a8785b848bbd0d0188
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Aug 7 13:41:21 2013 -0400

    drm/omap: use flip-work helper
    
    And simplify how we hold a ref+pin to what is being scanned out by using
    fb refcnt'ing.  The previous logic pre-dated fb refcnt, and as a result
    was less straightforward than it could have been.  By holding a ref to
    the fb, we don't have to care about how many plane's there are and
    holding a ref to each color plane's bo.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index 8031402e7951..f2b8f0668c0c 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -237,55 +237,49 @@ void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
 	}
 }
 
-/* Call for unpin 'a' (if not NULL), and pin 'b' (if not NULL).  Although
- * buffers to unpin are just pushed to the unpin fifo so that the
- * caller can defer unpin until vblank.
- *
- * Note if this fails (ie. something went very wrong!), all buffers are
- * unpinned, and the caller disables the overlay.  We could have tried
- * to revert back to the previous set of pinned buffers but if things are
- * hosed there is no guarantee that would succeed.
- */
-int omap_framebuffer_replace(struct drm_framebuffer *a,
-		struct drm_framebuffer *b, void *arg,
-		void (*unpin)(void *arg, struct drm_gem_object *bo))
+/* pin, prepare for scanout: */
+int omap_framebuffer_pin(struct drm_framebuffer *fb)
 {
-	int ret = 0, i, na, nb;
-	struct omap_framebuffer *ofba = to_omap_framebuffer(a);
-	struct omap_framebuffer *ofbb = to_omap_framebuffer(b);
-	uint32_t pinned_mask = 0;
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
-	na = a ? drm_format_num_planes(a->pixel_format) : 0;
-	nb = b ? drm_format_num_planes(b->pixel_format) : 0;
+	for (i = 0; i < n; i++) {
+		struct plane *plane = &omap_fb->planes[i];
+		ret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);
+		if (ret)
+			goto fail;
+		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
+	}
 
-	for (i = 0; i < max(na, nb); i++) {
-		struct plane *pa, *pb;
+	return 0;
 
-		pa = (i < na) ? &ofba->planes[i] : NULL;
-		pb = (i < nb) ? &ofbb->planes[i] : NULL;
+fail:
+	for (i--; i >= 0; i--) {
+		struct plane *plane = &omap_fb->planes[i];
+		omap_gem_put_paddr(plane->bo);
+		plane->paddr = 0;
+	}
 
-		if (pa)
-			unpin(arg, pa->bo);
+	return ret;
+}
 
-		if (pb && !ret) {
-			ret = omap_gem_get_paddr(pb->bo, &pb->paddr, true);
-			if (!ret) {
-				omap_gem_dma_sync(pb->bo, DMA_TO_DEVICE);
-				pinned_mask |= (1 << i);
-			}
-		}
-	}
+/* unpin, no longer being scanned out: */
+int omap_framebuffer_unpin(struct drm_framebuffer *fb)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	int ret, i, n = drm_format_num_planes(fb->pixel_format);
 
-	if (ret) {
-		/* something went wrong.. unpin what has been pinned */
-		for (i = 0; i < nb; i++) {
-			if (pinned_mask & (1 << i)) {
-				struct plane *pb = &ofba->planes[i];
-				unpin(arg, pb->bo);
-			}
-		}
+	for (i = 0; i < n; i++) {
+		struct plane *plane = &omap_fb->planes[i];
+		ret = omap_gem_put_paddr(plane->bo);
+		if (ret)
+			goto fail;
+		plane->paddr = 0;
 	}
 
+	return 0;
+
+fail:
 	return ret;
 }
 

commit fffddfd6c8e0c10c42c6e2cc54ba880fcc36ebbb
Merge: 69086a78bdc9 be88298b0a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:46:44 2013 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge from Dave Airlie:
     "Highlights:
    
       - TI LCD controller KMS driver
    
       - TI OMAP KMS driver merged from staging
    
       - drop gma500 stub driver
    
       - the fbcon locking fixes
    
       - the vgacon dirty like zebra fix.
    
       - open firmware videomode and hdmi common code helpers
    
       - major locking rework for kms object handling - pageflip/cursor
         won't block on polling anymore!
    
       - fbcon helper and prime helper cleanups
    
       - i915: all over the map, haswell power well enhancements, valleyview
         macro horrors cleaned up, killing lots of legacy GTT code,
    
       - radeon: CS ioctl unification, deprecated UMS support, gpu reset
         rework, VM fixes
    
       - nouveau: reworked thermal code, external dp/tmds encoder support
         (anx9805), fences sleep instead of polling,
    
       - exynos: all over the driver fixes."
    
    Lovely conflict in radeon/evergreen_cs.c between commit de0babd60d8d
    ("drm/radeon: enforce use of radeon_get_ib_value when reading user cmd")
    and the new changes that modified that evergreen_dma_cs_parse()
    function.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (508 commits)
      drm/tilcdc: only build on arm
      drm/i915: Revert hdmi HDP pin checks
      drm/tegra: Add list of framebuffers to debugfs
      drm/tegra: Fix color expansion
      drm/tegra: Split DC_CMD_STATE_CONTROL register write
      drm/tegra: Implement page-flipping support
      drm/tegra: Implement VBLANK support
      drm/tegra: Implement .mode_set_base()
      drm/tegra: Add plane support
      drm/tegra: Remove bogus tegra_framebuffer structure
      drm: Add consistency check for page-flipping
      drm/radeon: Use generic HDMI infoframe helpers
      drm/tegra: Use generic HDMI infoframe helpers
      drm: Add EDID helper documentation
      drm: Add HDMI infoframe helpers
      video: Add generic HDMI infoframe helpers
      drm: Add some missing forward declarations
      drm: Move mode tables to drm_edid.c
      drm: Remove duplicate drm_mode_cea_vic()
      gma500: Fix n, m1 and m2 clock limits for sdvo and lvds
      ...

commit 8bb0daffb0b8e45188066255b4203446eae181f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Feb 11 12:43:09 2013 -0500

    drm/omap: move out of staging
    
    Now that the omapdss interface has been reworked so that omapdrm can use
    dispc directly, we have been able to fix the remaining functional kms
    issues with omapdrm.  And in the mean time the PM sequencing and many
    other of that open issues have been solved.  So I think it makes sense
    to finally move omapdrm out of staging.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
new file mode 100644
index 000000000000..9d5f6f696c72
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -0,0 +1,472 @@
+/*
+ * drivers/gpu/drm/omapdrm/omap_fb.c
+ *
+ * Copyright (C) 2011 Texas Instruments
+ * Author: Rob Clark <rob@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "omap_drv.h"
+#include "omap_dmm_tiler.h"
+
+#include "drm_crtc.h"
+#include "drm_crtc_helper.h"
+
+/*
+ * framebuffer funcs
+ */
+
+/* per-format info: */
+struct format {
+	enum omap_color_mode dss_format;
+	uint32_t pixel_format;
+	struct {
+		int stride_bpp;           /* this times width is stride */
+		int sub_y;                /* sub-sample in y dimension */
+	} planes[4];
+	bool yuv;
+};
+
+static const struct format formats[] = {
+	/* 16bpp [A]RGB: */
+	{ OMAP_DSS_COLOR_RGB16,       DRM_FORMAT_RGB565,   {{2, 1}}, false }, /* RGB16-565 */
+	{ OMAP_DSS_COLOR_RGB12U,      DRM_FORMAT_RGBX4444, {{2, 1}}, false }, /* RGB12x-4444 */
+	{ OMAP_DSS_COLOR_RGBX16,      DRM_FORMAT_XRGB4444, {{2, 1}}, false }, /* xRGB12-4444 */
+	{ OMAP_DSS_COLOR_RGBA16,      DRM_FORMAT_RGBA4444, {{2, 1}}, false }, /* RGBA12-4444 */
+	{ OMAP_DSS_COLOR_ARGB16,      DRM_FORMAT_ARGB4444, {{2, 1}}, false }, /* ARGB16-4444 */
+	{ OMAP_DSS_COLOR_XRGB16_1555, DRM_FORMAT_XRGB1555, {{2, 1}}, false }, /* xRGB15-1555 */
+	{ OMAP_DSS_COLOR_ARGB16_1555, DRM_FORMAT_ARGB1555, {{2, 1}}, false }, /* ARGB16-1555 */
+	/* 24bpp RGB: */
+	{ OMAP_DSS_COLOR_RGB24P,      DRM_FORMAT_RGB888,   {{3, 1}}, false }, /* RGB24-888 */
+	/* 32bpp [A]RGB: */
+	{ OMAP_DSS_COLOR_RGBX32,      DRM_FORMAT_RGBX8888, {{4, 1}}, false }, /* RGBx24-8888 */
+	{ OMAP_DSS_COLOR_RGB24U,      DRM_FORMAT_XRGB8888, {{4, 1}}, false }, /* xRGB24-8888 */
+	{ OMAP_DSS_COLOR_RGBA32,      DRM_FORMAT_RGBA8888, {{4, 1}}, false }, /* RGBA32-8888 */
+	{ OMAP_DSS_COLOR_ARGB32,      DRM_FORMAT_ARGB8888, {{4, 1}}, false }, /* ARGB32-8888 */
+	/* YUV: */
+	{ OMAP_DSS_COLOR_NV12,        DRM_FORMAT_NV12,     {{1, 1}, {1, 2}}, true },
+	{ OMAP_DSS_COLOR_YUV2,        DRM_FORMAT_YUYV,     {{2, 1}}, true },
+	{ OMAP_DSS_COLOR_UYVY,        DRM_FORMAT_UYVY,     {{2, 1}}, true },
+};
+
+/* convert from overlay's pixel formats bitmask to an array of fourcc's */
+uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,
+		uint32_t max_formats, enum omap_color_mode supported_modes)
+{
+	uint32_t nformats = 0;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++)
+		if (formats[i].dss_format & supported_modes)
+			pixel_formats[nformats++] = formats[i].pixel_format;
+
+	return nformats;
+}
+
+/* per-plane info for the fb: */
+struct plane {
+	struct drm_gem_object *bo;
+	uint32_t pitch;
+	uint32_t offset;
+	dma_addr_t paddr;
+};
+
+#define to_omap_framebuffer(x) container_of(x, struct omap_framebuffer, base)
+
+struct omap_framebuffer {
+	struct drm_framebuffer base;
+	const struct format *format;
+	struct plane planes[4];
+};
+
+static int omap_framebuffer_create_handle(struct drm_framebuffer *fb,
+		struct drm_file *file_priv,
+		unsigned int *handle)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	return drm_gem_handle_create(file_priv,
+			omap_fb->planes[0].bo, handle);
+}
+
+static void omap_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	int i, n = drm_format_num_planes(fb->pixel_format);
+
+	DBG("destroy: FB ID: %d (%p)", fb->base.id, fb);
+
+	drm_framebuffer_cleanup(fb);
+
+	for (i = 0; i < n; i++) {
+		struct plane *plane = &omap_fb->planes[i];
+		if (plane->bo)
+			drm_gem_object_unreference_unlocked(plane->bo);
+	}
+
+	kfree(omap_fb);
+}
+
+static int omap_framebuffer_dirty(struct drm_framebuffer *fb,
+		struct drm_file *file_priv, unsigned flags, unsigned color,
+		struct drm_clip_rect *clips, unsigned num_clips)
+{
+	int i;
+
+	for (i = 0; i < num_clips; i++) {
+		omap_framebuffer_flush(fb, clips[i].x1, clips[i].y1,
+					clips[i].x2 - clips[i].x1,
+					clips[i].y2 - clips[i].y1);
+	}
+
+	return 0;
+}
+
+static const struct drm_framebuffer_funcs omap_framebuffer_funcs = {
+	.create_handle = omap_framebuffer_create_handle,
+	.destroy = omap_framebuffer_destroy,
+	.dirty = omap_framebuffer_dirty,
+};
+
+static uint32_t get_linear_addr(struct plane *plane,
+		const struct format *format, int n, int x, int y)
+{
+	uint32_t offset;
+
+	offset = plane->offset +
+			(x * format->planes[n].stride_bpp) +
+			(y * plane->pitch / format->planes[n].sub_y);
+
+	return plane->paddr + offset;
+}
+
+/* update ovl info for scanout, handles cases of multi-planar fb's, etc.
+ */
+void omap_framebuffer_update_scanout(struct drm_framebuffer *fb,
+		struct omap_drm_window *win, struct omap_overlay_info *info)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	const struct format *format = omap_fb->format;
+	struct plane *plane = &omap_fb->planes[0];
+	uint32_t x, y, orient = 0;
+
+	info->color_mode = format->dss_format;
+
+	info->pos_x      = win->crtc_x;
+	info->pos_y      = win->crtc_y;
+	info->out_width  = win->crtc_w;
+	info->out_height = win->crtc_h;
+	info->width      = win->src_w;
+	info->height     = win->src_h;
+
+	x = win->src_x;
+	y = win->src_y;
+
+	if (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {
+		uint32_t w = win->src_w;
+		uint32_t h = win->src_h;
+
+		switch (win->rotation & 0xf) {
+		default:
+			dev_err(fb->dev->dev, "invalid rotation: %02x",
+					(uint32_t)win->rotation);
+			/* fallthru to default to no rotation */
+		case 0:
+		case BIT(DRM_ROTATE_0):
+			orient = 0;
+			break;
+		case BIT(DRM_ROTATE_90):
+			orient = MASK_XY_FLIP | MASK_X_INVERT;
+			break;
+		case BIT(DRM_ROTATE_180):
+			orient = MASK_X_INVERT | MASK_Y_INVERT;
+			break;
+		case BIT(DRM_ROTATE_270):
+			orient = MASK_XY_FLIP | MASK_Y_INVERT;
+			break;
+		}
+
+		if (win->rotation & BIT(DRM_REFLECT_X))
+			orient ^= MASK_X_INVERT;
+
+		if (win->rotation & BIT(DRM_REFLECT_Y))
+			orient ^= MASK_Y_INVERT;
+
+		/* adjust x,y offset for flip/invert: */
+		if (orient & MASK_XY_FLIP)
+			swap(w, h);
+		if (orient & MASK_Y_INVERT)
+			y += h - 1;
+		if (orient & MASK_X_INVERT)
+			x += w - 1;
+
+		omap_gem_rotated_paddr(plane->bo, orient, x, y, &info->paddr);
+		info->rotation_type = OMAP_DSS_ROT_TILER;
+		info->screen_width  = omap_gem_tiled_stride(plane->bo, orient);
+	} else {
+		info->paddr         = get_linear_addr(plane, format, 0, x, y);
+		info->rotation_type = OMAP_DSS_ROT_DMA;
+		info->screen_width  = plane->pitch;
+	}
+
+	/* convert to pixels: */
+	info->screen_width /= format->planes[0].stride_bpp;
+
+	if (format->dss_format == OMAP_DSS_COLOR_NV12) {
+		plane = &omap_fb->planes[1];
+
+		if (info->rotation_type == OMAP_DSS_ROT_TILER) {
+			WARN_ON(!(omap_gem_flags(plane->bo) & OMAP_BO_TILED));
+			omap_gem_rotated_paddr(plane->bo, orient,
+					x/2, y/2, &info->p_uv_addr);
+		} else {
+			info->p_uv_addr = get_linear_addr(plane, format, 1, x, y);
+		}
+	} else {
+		info->p_uv_addr = 0;
+	}
+}
+
+/* Call for unpin 'a' (if not NULL), and pin 'b' (if not NULL).  Although
+ * buffers to unpin are just pushed to the unpin fifo so that the
+ * caller can defer unpin until vblank.
+ *
+ * Note if this fails (ie. something went very wrong!), all buffers are
+ * unpinned, and the caller disables the overlay.  We could have tried
+ * to revert back to the previous set of pinned buffers but if things are
+ * hosed there is no guarantee that would succeed.
+ */
+int omap_framebuffer_replace(struct drm_framebuffer *a,
+		struct drm_framebuffer *b, void *arg,
+		void (*unpin)(void *arg, struct drm_gem_object *bo))
+{
+	int ret = 0, i, na, nb;
+	struct omap_framebuffer *ofba = to_omap_framebuffer(a);
+	struct omap_framebuffer *ofbb = to_omap_framebuffer(b);
+	uint32_t pinned_mask = 0;
+
+	na = a ? drm_format_num_planes(a->pixel_format) : 0;
+	nb = b ? drm_format_num_planes(b->pixel_format) : 0;
+
+	for (i = 0; i < max(na, nb); i++) {
+		struct plane *pa, *pb;
+
+		pa = (i < na) ? &ofba->planes[i] : NULL;
+		pb = (i < nb) ? &ofbb->planes[i] : NULL;
+
+		if (pa)
+			unpin(arg, pa->bo);
+
+		if (pb && !ret) {
+			ret = omap_gem_get_paddr(pb->bo, &pb->paddr, true);
+			if (!ret) {
+				omap_gem_dma_sync(pb->bo, DMA_TO_DEVICE);
+				pinned_mask |= (1 << i);
+			}
+		}
+	}
+
+	if (ret) {
+		/* something went wrong.. unpin what has been pinned */
+		for (i = 0; i < nb; i++) {
+			if (pinned_mask & (1 << i)) {
+				struct plane *pb = &ofba->planes[i];
+				unpin(arg, pb->bo);
+			}
+		}
+	}
+
+	return ret;
+}
+
+struct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	if (p >= drm_format_num_planes(fb->pixel_format))
+		return NULL;
+	return omap_fb->planes[p].bo;
+}
+
+/* iterate thru all the connectors, returning ones that are attached
+ * to the same fb..
+ */
+struct drm_connector *omap_framebuffer_get_next_connector(
+		struct drm_framebuffer *fb, struct drm_connector *from)
+{
+	struct drm_device *dev = fb->dev;
+	struct list_head *connector_list = &dev->mode_config.connector_list;
+	struct drm_connector *connector = from;
+
+	if (!from)
+		return list_first_entry(connector_list, typeof(*from), head);
+
+	list_for_each_entry_from(connector, connector_list, head) {
+		if (connector != from) {
+			struct drm_encoder *encoder = connector->encoder;
+			struct drm_crtc *crtc = encoder ? encoder->crtc : NULL;
+			if (crtc && crtc->fb == fb)
+				return connector;
+
+		}
+	}
+
+	return NULL;
+}
+
+/* flush an area of the framebuffer (in case of manual update display that
+ * is not automatically flushed)
+ */
+void omap_framebuffer_flush(struct drm_framebuffer *fb,
+		int x, int y, int w, int h)
+{
+	struct drm_connector *connector = NULL;
+
+	VERB("flush: %d,%d %dx%d, fb=%p", x, y, w, h, fb);
+
+	while ((connector = omap_framebuffer_get_next_connector(fb, connector))) {
+		/* only consider connectors that are part of a chain */
+		if (connector->encoder && connector->encoder->crtc) {
+			/* TODO: maybe this should propagate thru the crtc who
+			 * could do the coordinate translation..
+			 */
+			struct drm_crtc *crtc = connector->encoder->crtc;
+			int cx = max(0, x - crtc->x);
+			int cy = max(0, y - crtc->y);
+			int cw = w + (x - crtc->x) - cx;
+			int ch = h + (y - crtc->y) - cy;
+
+			omap_connector_flush(connector, cx, cy, cw, ch);
+		}
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
+{
+	struct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);
+	int i, n = drm_format_num_planes(fb->pixel_format);
+
+	seq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,
+			(char *)&fb->pixel_format);
+
+	for (i = 0; i < n; i++) {
+		struct plane *plane = &omap_fb->planes[i];
+		seq_printf(m, "   %d: offset=%d pitch=%d, obj: ",
+				i, plane->offset, plane->pitch);
+		omap_gem_describe(plane->bo, m);
+	}
+}
+#endif
+
+struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
+		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_gem_object *bos[4];
+	struct drm_framebuffer *fb;
+	int ret;
+
+	ret = objects_lookup(dev, file, mode_cmd->pixel_format,
+			bos, mode_cmd->handles);
+	if (ret)
+		return ERR_PTR(ret);
+
+	fb = omap_framebuffer_init(dev, mode_cmd, bos);
+	if (IS_ERR(fb)) {
+		int i, n = drm_format_num_planes(mode_cmd->pixel_format);
+		for (i = 0; i < n; i++)
+			drm_gem_object_unreference_unlocked(bos[i]);
+		return fb;
+	}
+	return fb;
+}
+
+struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
+		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
+{
+	struct omap_framebuffer *omap_fb;
+	struct drm_framebuffer *fb = NULL;
+	const struct format *format = NULL;
+	int ret, i, n = drm_format_num_planes(mode_cmd->pixel_format);
+
+	DBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",
+			dev, mode_cmd, mode_cmd->width, mode_cmd->height,
+			(char *)&mode_cmd->pixel_format);
+
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		if (formats[i].pixel_format == mode_cmd->pixel_format) {
+			format = &formats[i];
+			break;
+		}
+	}
+
+	if (!format) {
+		dev_err(dev->dev, "unsupported pixel format: %4.4s\n",
+				(char *)&mode_cmd->pixel_format);
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	omap_fb = kzalloc(sizeof(*omap_fb), GFP_KERNEL);
+	if (!omap_fb) {
+		dev_err(dev->dev, "could not allocate fb\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	fb = &omap_fb->base;
+	omap_fb->format = format;
+
+	for (i = 0; i < n; i++) {
+		struct plane *plane = &omap_fb->planes[i];
+		int size, pitch = mode_cmd->pitches[i];
+
+		if (pitch < (mode_cmd->width * format->planes[i].stride_bpp)) {
+			dev_err(dev->dev, "provided buffer pitch is too small! %d < %d\n",
+					pitch, mode_cmd->width * format->planes[i].stride_bpp);
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		size = pitch * mode_cmd->height / format->planes[i].sub_y;
+
+		if (size > (omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i])) {
+			dev_err(dev->dev, "provided buffer object is too small! %d < %d\n",
+					bos[i]->size - mode_cmd->offsets[i], size);
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		plane->bo     = bos[i];
+		plane->offset = mode_cmd->offsets[i];
+		plane->pitch  = pitch;
+		plane->paddr  = 0;
+	}
+
+	drm_helper_mode_fill_fb_struct(fb, mode_cmd);
+
+	ret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);
+	if (ret) {
+		dev_err(dev->dev, "framebuffer init failed: %d\n", ret);
+		goto fail;
+	}
+
+	DBG("create: FB ID: %d (%p)", fb->base.id, fb);
+
+	return fb;
+
+fail:
+	if (fb)
+		omap_framebuffer_destroy(fb);
+
+	return ERR_PTR(ret);
+}
