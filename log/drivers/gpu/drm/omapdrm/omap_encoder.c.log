commit e086558ae923adc71c9718140ee0f6ba9508ec30
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:14 2020 +0200

    drm/omap: dss: Remove unused omap_dss_device operations
    
    The omap_dss_device .pre_enable(), .post_disable() and .set_timings()
    are not used anymore. Remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-55-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 18a79dde6815..ae4b867a67a3 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -113,13 +113,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	bus_flags = connector->display_info.bus_flags;
 	omap_encoder_update_videomode_flags(&vm, bus_flags);
 
-	/* Set timings for all devices in the display pipeline. */
+	/* Set timings for the dss manager. */
 	dss_mgr_set_timings(output, &vm);
-
-	for (dssdev = output; dssdev; dssdev = dssdev->next) {
-		if (dssdev->ops && dssdev->ops->set_timings)
-			dssdev->ops->set_timings(dssdev, adjusted_mode);
-	}
 }
 
 static void omap_encoder_disable(struct drm_encoder *encoder)
@@ -132,26 +127,10 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 	/*
 	 * Disable the chain of external devices, starting at the one at the
-	 * internal encoder's output.
+	 * internal encoder's output. This is used for DSI outputs only, as
+	 * dssdev->next is NULL for all other outputs.
 	 */
 	omapdss_device_disable(dssdev->next);
-
-	/*
-	 * Disable the internal encoder. This will disable the DSS output. The
-	 * DSI is treated as an exception as DSI pipelines still use the legacy
-	 * flow where the pipeline output controls the encoder.
-	 */
-	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
-		if (dssdev->ops && dssdev->ops->disable)
-			dssdev->ops->disable(dssdev);
-		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
-	}
-
-	/*
-	 * Perform the post-disable operations on the chain of external devices
-	 * to complete the display pipeline disable.
-	 */
-	omapdss_device_post_disable(dssdev->next);
 }
 
 static void omap_encoder_enable(struct drm_encoder *encoder)
@@ -162,23 +141,10 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "enable(%s)\n", dssdev->name);
 
-	/* Prepare the chain of external devices for pipeline enable. */
-	omapdss_device_pre_enable(dssdev->next);
-
-	/*
-	 * Enable the internal encoder. This will enable the DSS output. The
-	 * DSI is treated as an exception as DSI pipelines still use the legacy
-	 * flow where the pipeline output controls the encoder.
-	 */
-	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
-		if (dssdev->ops && dssdev->ops->enable)
-			dssdev->ops->enable(dssdev);
-		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
-	}
-
 	/*
 	 * Enable the chain of external devices, starting at the one at the
-	 * internal encoder's output.
+	 * internal encoder's output. This is used for DSI outputs only, as
+	 * dssdev->next is NULL for all other outputs.
 	 */
 	omapdss_device_enable(dssdev->next);
 }

commit 4fcbfbae7222eb399caa2cc04082fd07c6bd164b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:56 2020 +0200

    drm/omap: dss: Remove .set_hdmi_mode() and .set_infoframe() operations
    
    The omapdss_hdmi_ops .set_hdmi_mode() and .set_infoframe() operations
    operations are not used anymore, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-37-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index b232acd3bc3d..18a79dde6815 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -69,28 +69,6 @@ static void omap_encoder_update_videomode_flags(struct videomode *vm,
 	}
 }
 
-static void omap_encoder_hdmi_mode_set(struct drm_connector *connector,
-				       struct drm_encoder *encoder,
-				       struct drm_display_mode *adjusted_mode)
-{
-	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->output;
-	bool hdmi_mode = connector->display_info.is_hdmi;
-
-	if (dssdev->ops && dssdev->ops->hdmi.set_hdmi_mode)
-		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
-
-	if (hdmi_mode && dssdev->ops && dssdev->ops->hdmi.set_infoframe) {
-		struct hdmi_avi_infoframe avi;
-		int r;
-
-		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, connector,
-							     adjusted_mode);
-		if (r == 0)
-			dssdev->ops->hdmi.set_infoframe(dssdev, &avi);
-	}
-}
-
 static void omap_encoder_mode_set(struct drm_encoder *encoder,
 				  struct drm_display_mode *mode,
 				  struct drm_display_mode *adjusted_mode)
@@ -142,10 +120,6 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		if (dssdev->ops && dssdev->ops->set_timings)
 			dssdev->ops->set_timings(dssdev, adjusted_mode);
 	}
-
-	/* Set the HDMI mode and HDMI infoframe if applicable. */
-	if (output->type == OMAP_DISPLAY_TYPE_HDMI)
-		omap_encoder_hdmi_mode_set(connector, encoder, adjusted_mode);
 }
 
 static void omap_encoder_disable(struct drm_encoder *encoder)

commit db0fefd1b90d7d2a23090e9178ce742fe1b0aadd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:47 2020 +0200

    drm/omap: dss: Make omap_dss_device_ops optional
    
    As part of the move to drm_bridge ops, the dssdev ops will become empty
    for some of the internal encoders. Make them optional in the driver to
    allow them to be removed completely, easing the transition.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-28-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index a270173a2411..b232acd3bc3d 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -77,10 +77,10 @@ static void omap_encoder_hdmi_mode_set(struct drm_connector *connector,
 	struct omap_dss_device *dssdev = omap_encoder->output;
 	bool hdmi_mode = connector->display_info.is_hdmi;
 
-	if (dssdev->ops->hdmi.set_hdmi_mode)
+	if (dssdev->ops && dssdev->ops->hdmi.set_hdmi_mode)
 		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
 
-	if (hdmi_mode && dssdev->ops->hdmi.set_infoframe) {
+	if (hdmi_mode && dssdev->ops && dssdev->ops->hdmi.set_infoframe) {
 		struct hdmi_avi_infoframe avi;
 		int r;
 
@@ -139,7 +139,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	dss_mgr_set_timings(output, &vm);
 
 	for (dssdev = output; dssdev; dssdev = dssdev->next) {
-		if (dssdev->ops->set_timings)
+		if (dssdev->ops && dssdev->ops->set_timings)
 			dssdev->ops->set_timings(dssdev, adjusted_mode);
 	}
 
@@ -168,7 +168,8 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 	 * flow where the pipeline output controls the encoder.
 	 */
 	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
-		dssdev->ops->disable(dssdev);
+		if (dssdev->ops && dssdev->ops->disable)
+			dssdev->ops->disable(dssdev);
 		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	}
 
@@ -196,7 +197,8 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 	 * flow where the pipeline output controls the encoder.
 	 */
 	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
-		dssdev->ops->enable(dssdev);
+		if (dssdev->ops && dssdev->ops->enable)
+			dssdev->ops->enable(dssdev);
 		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 	}
 

commit a779618b4a07d90fd332b6dbb4e836678d0a1d43
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:44 2020 +0200

    drm/omap: Use the drm_panel_bridge API
    
    Replace the manual panel handling code by a drm_panel_bridge. This
    simplifies the driver and allows all components in the display pipeline
    to be treated as bridges, paving the way to generic connector handling.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-25-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index cb5aa01d2f87..a270173a2411 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -10,7 +10,6 @@
 #include <drm/drm_crtc.h>
 #include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_edid.h>
-#include <drm/drm_panel.h>
 
 #include "omap_drv.h"
 
@@ -157,12 +156,6 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "disable(%s)\n", dssdev->name);
 
-	/* Disable the panel if present. */
-	if (dssdev->panel) {
-		drm_panel_disable(dssdev->panel);
-		drm_panel_unprepare(dssdev->panel);
-	}
-
 	/*
 	 * Disable the chain of external devices, starting at the one at the
 	 * internal encoder's output.
@@ -212,12 +205,6 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 	 * internal encoder's output.
 	 */
 	omapdss_device_enable(dssdev->next);
-
-	/* Enable the panel if present. */
-	if (dssdev->panel) {
-		drm_panel_prepare(dssdev->panel);
-		drm_panel_enable(dssdev->panel);
-	}
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit 1516d11923d0f9f5db88041e8c4e097a59af0d5f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:42 2020 +0200

    drm/omap: Simplify HDMI mode and infoframe configuration
    
    Remove the omap_connector_get_hdmi_mode() function as the HDMI mode can
    be accessed directly from the connector's display info.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-23-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 4f2165a37795..cb5aa01d2f87 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -76,9 +76,7 @@ static void omap_encoder_hdmi_mode_set(struct drm_connector *connector,
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->output;
-	bool hdmi_mode;
-
-	hdmi_mode = omap_connector_get_hdmi_mode(connector);
+	bool hdmi_mode = connector->display_info.is_hdmi;
 
 	if (dssdev->ops->hdmi.set_hdmi_mode)
 		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);

commit fadf872d9d9274a3be34d8438e0f6bb465c8f98b
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Dec 3 15:15:06 2019 +0100

    drm/bridge: Introduce drm_bridge_get_next_bridge()
    
    And use it in drivers accessing the bridge->next field directly.
    This is part of our attempt to make the bridge chain a double-linked list
    based on the generic list helpers.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191203141515.3597631-3-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 24bbe9f2a32e..4f2165a37795 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -126,7 +126,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	for (dssdev = output; dssdev; dssdev = dssdev->next)
 		omap_encoder_update_videomode_flags(&vm, dssdev->bus_flags);
 
-	for (bridge = output->bridge; bridge; bridge = bridge->next) {
+	for (bridge = output->bridge; bridge;
+	     bridge = drm_bridge_get_next_bridge(bridge)) {
 		if (!bridge->timings)
 			continue;
 

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 6fe14111cd95..24bbe9f2a32e 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -6,6 +6,7 @@
 
 #include <linux/list.h>
 
+#include <drm/drm_bridge.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_edid.h>

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 40512419642b..6fe14111cd95 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/list.h>

commit 30b71761957c541cd9dfd6cd10e3feb21a8ddca1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Dec 7 23:08:35 2018 +0200

    drm/omap: Add support for drm_panel
    
    Hook up drm_panel support in the omapdrm driver. The change is
    relatively simply as the way has been paved by drm_bridge support
    already. In addition to looking up, attaching to and detaching from the
    panel, we only need to add panel support in the connector .get_modes()
    handler, take connector bus flags (set by the panel) into account, and
    enable/disable the panel in the encoder enable/disable operations
    handlers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 9eb3db9ba23f..40512419642b 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -20,6 +20,7 @@
 #include <drm/drm_crtc.h>
 #include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_edid.h>
+#include <drm/drm_panel.h>
 
 #include "omap_drv.h"
 
@@ -79,22 +80,15 @@ static void omap_encoder_update_videomode_flags(struct videomode *vm,
 	}
 }
 
-static void omap_encoder_hdmi_mode_set(struct drm_encoder *encoder,
+static void omap_encoder_hdmi_mode_set(struct drm_connector *connector,
+				       struct drm_encoder *encoder,
 				       struct drm_display_mode *adjusted_mode)
 {
-	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->output;
-	struct drm_connector *connector;
 	bool hdmi_mode;
 
-	hdmi_mode = false;
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			hdmi_mode = omap_connector_get_hdmi_mode(connector);
-			break;
-		}
-	}
+	hdmi_mode = omap_connector_get_hdmi_mode(connector);
 
 	if (dssdev->ops->hdmi.set_hdmi_mode)
 		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
@@ -117,8 +111,16 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *output = omap_encoder->output;
 	struct omap_dss_device *dssdev;
+	struct drm_device *dev = encoder->dev;
+	struct drm_connector *connector;
 	struct drm_bridge *bridge;
 	struct videomode vm = { 0 };
+	u32 bus_flags;
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder)
+			break;
+	}
 
 	drm_display_mode_to_videomode(adjusted_mode, &vm);
 
@@ -135,8 +137,6 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		omap_encoder_update_videomode_flags(&vm, dssdev->bus_flags);
 
 	for (bridge = output->bridge; bridge; bridge = bridge->next) {
-		u32 bus_flags;
-
 		if (!bridge->timings)
 			continue;
 
@@ -144,6 +144,9 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		omap_encoder_update_videomode_flags(&vm, bus_flags);
 	}
 
+	bus_flags = connector->display_info.bus_flags;
+	omap_encoder_update_videomode_flags(&vm, bus_flags);
+
 	/* Set timings for all devices in the display pipeline. */
 	dss_mgr_set_timings(output, &vm);
 
@@ -154,7 +157,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 
 	/* Set the HDMI mode and HDMI infoframe if applicable. */
 	if (output->type == OMAP_DISPLAY_TYPE_HDMI)
-		omap_encoder_hdmi_mode_set(encoder, adjusted_mode);
+		omap_encoder_hdmi_mode_set(connector, encoder, adjusted_mode);
 }
 
 static void omap_encoder_disable(struct drm_encoder *encoder)
@@ -165,6 +168,12 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "disable(%s)\n", dssdev->name);
 
+	/* Disable the panel if present. */
+	if (dssdev->panel) {
+		drm_panel_disable(dssdev->panel);
+		drm_panel_unprepare(dssdev->panel);
+	}
+
 	/*
 	 * Disable the chain of external devices, starting at the one at the
 	 * internal encoder's output.
@@ -214,6 +223,12 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 	 * internal encoder's output.
 	 */
 	omapdss_device_enable(dssdev->next);
+
+	/* Enable the panel if present. */
+	if (dssdev->panel) {
+		drm_panel_prepare(dssdev->panel);
+		drm_panel_enable(dssdev->panel);
+	}
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit 79107f274b2fc6bce13f687de33c8d0b70994558
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Sep 23 12:58:15 2018 +0300

    drm/omap: Add support for drm_bridge
    
    Hook up drm_bridge support in the omapdrm driver. Despite the recent
    extensive preparation work, this is a rather intrusive change, as the
    management of outputs needs to be adapted through the driver to handle
    both omap_dss_device and drm_bridge.
    
    Connector creation is skipped when using a drm_bridge, as the bridge
    creates the connector internally. This creates issues with systems that
    split connector operations (such as modes retrieval and hot-plug
    detection) across different bridges. These systems can't be supported
    using drm_bridge for now (their support through the omap_dss_device
    infrastructure is not affected), this will be fixed in subsequent
    changes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index b83a2ae64a03..9eb3db9ba23f 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -51,6 +51,34 @@ static const struct drm_encoder_funcs omap_encoder_funcs = {
 	.destroy = omap_encoder_destroy,
 };
 
+static void omap_encoder_update_videomode_flags(struct videomode *vm,
+						u32 bus_flags)
+{
+	if (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |
+			   DISPLAY_FLAGS_DE_HIGH))) {
+		if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+			vm->flags |= DISPLAY_FLAGS_DE_LOW;
+		else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
+			vm->flags |= DISPLAY_FLAGS_DE_HIGH;
+	}
+
+	if (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
+			   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
+		if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)
+			vm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
+		else if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
+			vm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+	}
+
+	if (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
+			   DISPLAY_FLAGS_SYNC_NEGEDGE))) {
+		if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE)
+			vm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
+		else if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE)
+			vm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
+	}
+}
+
 static void omap_encoder_hdmi_mode_set(struct drm_encoder *encoder,
 				       struct drm_display_mode *adjusted_mode)
 {
@@ -87,7 +115,9 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 				  struct drm_display_mode *adjusted_mode)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *output = omap_encoder->output;
 	struct omap_dss_device *dssdev;
+	struct drm_bridge *bridge;
 	struct videomode vm = { 0 };
 
 	drm_display_mode_to_videomode(adjusted_mode, &vm);
@@ -101,44 +131,29 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	 *
 	 * A better solution is to use DRM's bus-flags through the whole driver.
 	 */
-	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
-		unsigned long bus_flags = dssdev->bus_flags;
-
-		if (!(vm.flags & (DISPLAY_FLAGS_DE_LOW |
-				  DISPLAY_FLAGS_DE_HIGH))) {
-			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
-				vm.flags |= DISPLAY_FLAGS_DE_LOW;
-			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
-				vm.flags |= DISPLAY_FLAGS_DE_HIGH;
-		}
+	for (dssdev = output; dssdev; dssdev = dssdev->next)
+		omap_encoder_update_videomode_flags(&vm, dssdev->bus_flags);
 
-		if (!(vm.flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
-				  DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)
-				vm.flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
-				vm.flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
-		}
+	for (bridge = output->bridge; bridge; bridge = bridge->next) {
+		u32 bus_flags;
 
-		if (!(vm.flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
-				  DISPLAY_FLAGS_SYNC_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE)
-				vm.flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE)
-				vm.flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
-		}
+		if (!bridge->timings)
+			continue;
+
+		bus_flags = bridge->timings->input_bus_flags;
+		omap_encoder_update_videomode_flags(&vm, bus_flags);
 	}
 
 	/* Set timings for all devices in the display pipeline. */
-	dss_mgr_set_timings(omap_encoder->output, &vm);
+	dss_mgr_set_timings(output, &vm);
 
-	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
+	for (dssdev = output; dssdev; dssdev = dssdev->next) {
 		if (dssdev->ops->set_timings)
 			dssdev->ops->set_timings(dssdev, adjusted_mode);
 	}
 
 	/* Set the HDMI mode and HDMI infoframe if applicable. */
-	if (omap_encoder->output->type == OMAP_DISPLAY_TYPE_HDMI)
+	if (output->type == OMAP_DISPLAY_TYPE_HDMI)
 		omap_encoder_hdmi_mode_set(encoder, adjusted_mode);
 }
 

commit 88bc4178568b8e0331143cc0616640ab72f0cba1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Sep 22 15:02:42 2018 +0300

    drm: Use new DRM_BUS_FLAG_*_(DRIVE|SAMPLE)_(POS|NEG)EDGE flags
    
    The DRM_BUS_FLAG_PIXDATA_(POS|NEG)EDGE and
    DRM_BUS_FLAG_SYNC_(POS|NEG)EDGE flags are deprecated in favour of the
    new DRM_BUS_FLAG_PIXDATA_(DRIVE|SAMPLE)_(POS|NEG)EDGE and
    new DRM_BUS_FLAG_SYNC_(DRIVE|SAMPLE)_(POS|NEG)EDGE flags. Replace them
    through the code.
    
    This effectively changes the value of the .sampling_edge bridge timings
    field in the dumb-vga-dac driver. This is safe to do as no driver
    consumes these values yet.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 42748479d374..b83a2ae64a03 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -114,17 +114,17 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 
 		if (!(vm.flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
 				  DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
+			if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)
 				vm.flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
+			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
 				vm.flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
 		}
 
 		if (!(vm.flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
 				  DISPLAY_FLAGS_SYNC_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
+			if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE)
 				vm.flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
+			else if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE)
 				vm.flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
 		}
 	}

commit 0dbfc396672025d3ef8bacc934b80a5463e75c6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 10 14:00:38 2018 +0200

    drm/omap: Merge omap_dss_device type and output_type fields
    
    The omap_dss_device type and output_type fields differ mostly for
    historical reasons. The output_type field is required for all devices
    but the display at the end of the pipeline, and must be set to
    OMAP_DISPLAY_TYPE_NONE for the latter. The type field is required for
    all devices but the internal encoder, for which it is ignored.
    
    The only reason why the output_type field must be set to
    OMAP_DISPLAY_TYPE_NONE for the display at the end of the pipeline is to
    identify omap_dss_device instances corresponding to displays. This is
    not documented and confusing.
    
    Clean the code by adding a new display field to the omap_dss_device
    structure to identify displays, and merge the type and output_type
    fields.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 367234de5dc7..42748479d374 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -138,7 +138,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	}
 
 	/* Set the HDMI mode and HDMI infoframe if applicable. */
-	if (omap_encoder->output->output_type == OMAP_DISPLAY_TYPE_HDMI)
+	if (omap_encoder->output->type == OMAP_DISPLAY_TYPE_HDMI)
 		omap_encoder_hdmi_mode_set(encoder, adjusted_mode);
 }
 
@@ -161,7 +161,7 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 	 * DSI is treated as an exception as DSI pipelines still use the legacy
 	 * flow where the pipeline output controls the encoder.
 	 */
-	if (dssdev->output_type != OMAP_DISPLAY_TYPE_DSI) {
+	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
 		dssdev->ops->disable(dssdev);
 		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	}
@@ -189,7 +189,7 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 	 * DSI is treated as an exception as DSI pipelines still use the legacy
 	 * flow where the pipeline output controls the encoder.
 	 */
-	if (dssdev->output_type != OMAP_DISPLAY_TYPE_DSI) {
+	if (dssdev->type != OMAP_DISPLAY_TYPE_DSI) {
 		dssdev->ops->enable(dssdev);
 		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 	}

commit 41322aa691950431ccef115e85b2d6bba654bd70
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 17:00:29 2018 +0300

    drm/omap: Pass drm_display_mode to .check_timings() and .set_timings()
    
    The omap_dss_device .check_timings() and .set_timings() operations
    operate on struct videomode, while the DRM API operates on struct
    drm_display_mode. This forces conversion from to videomode in the
    callers. While that's not a problem per se, it creates a difference with
    the drm_bridge API.
    
    Replace the videomode parameter to the .check_timings() and
    .set_timings() operations with a drm_display_mode. This pushed the
    conversion to videomode down to the DSS devices in some cases. If needed
    they will be converted to operate on drm_display_mode natively.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 3a7cca01888e..367234de5dc7 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -134,7 +134,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 
 	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
 		if (dssdev->ops->set_timings)
-			dssdev->ops->set_timings(dssdev, &vm);
+			dssdev->ops->set_timings(dssdev, adjusted_mode);
 	}
 
 	/* Set the HDMI mode and HDMI infoframe if applicable. */

commit d68164fe29642270ffba64ed64b0178ef7d916bf
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 16:13:00 2018 +0300

    drm/omap: Factor out common mode validation code
    
    The encoder .atomic_check() and connector .mode_valid() operations both
    walk through the dss devices in the pipeline to validate the mode.
    Factor out the common code in a new omap_drm_connector_mode_fixup()
    function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 623154bc44bb..3a7cca01888e 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -206,29 +206,17 @@ static int omap_encoder_atomic_check(struct drm_encoder *encoder,
 				     struct drm_connector_state *conn_state)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct drm_device *dev = encoder->dev;
-	struct omap_dss_device *dssdev;
-	struct videomode vm = { 0 };
-	int ret;
-
-	drm_display_mode_to_videomode(&crtc_state->mode, &vm);
-
-	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
-		if (!dssdev->ops->check_timings)
-			continue;
-
-		ret = dssdev->ops->check_timings(dssdev, &vm);
-		if (ret)
-			goto done;
+	enum drm_mode_status status;
+
+	status = omap_connector_mode_fixup(omap_encoder->output,
+					   &crtc_state->mode,
+					   &crtc_state->adjusted_mode);
+	if (status != MODE_OK) {
+		dev_err(encoder->dev->dev, "invalid timings: %d\n", status);
+		return -EINVAL;
 	}
 
-	drm_display_mode_from_videomode(&vm, &crtc_state->adjusted_mode);
-
-done:
-	if (ret)
-		dev_err(dev->dev, "invalid timings: %d\n", ret);
-
-	return ret;
+	return 0;
 }
 
 static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {

commit 116c7721077cf82b942adaef146e97663247d972
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 20 00:17:42 2018 +0300

    drm/omap: Move DISPC timing checks to CRTC .mode_valid() operation
    
    The DISPC timings checks relate to the CRTC, but they're performed in
    the encoder and connector .atomic_check() and .mode_valid() operations.
    Move them to the CRTC .mode_valid() operation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 1f4172f653b9..623154bc44bb 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -206,19 +206,13 @@ static int omap_encoder_atomic_check(struct drm_encoder *encoder,
 				     struct drm_connector_state *conn_state)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	enum omap_channel channel = omap_encoder->output->dispc_channel;
 	struct drm_device *dev = encoder->dev;
-	struct omap_drm_private *priv = dev->dev_private;
 	struct omap_dss_device *dssdev;
 	struct videomode vm = { 0 };
 	int ret;
 
 	drm_display_mode_to_videomode(&crtc_state->mode, &vm);
 
-	ret = priv->dispc_ops->mgr_check_timings(priv->dispc, channel, &vm);
-	if (ret)
-		goto done;
-
 	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
 		if (!dssdev->ops->check_timings)
 			continue;

commit 79d11e96e397e1d70b23ac2174d0aba5d8e73b9e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 13 02:23:26 2018 +0300

    drm/omap: Don't pass display pointer to encoder init function
    
    The display isn't used by the encoder implementation, don't pass it to
    the initialization function and store it internally needlessly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index acdfd2176423..1f4172f653b9 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -37,7 +37,6 @@
 struct omap_encoder {
 	struct drm_encoder base;
 	struct omap_dss_device *output;
-	struct omap_dss_device *display;
 };
 
 static void omap_encoder_destroy(struct drm_encoder *encoder)
@@ -247,8 +246,7 @@ static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
 
 /* initialize encoder */
 struct drm_encoder *omap_encoder_init(struct drm_device *dev,
-				      struct omap_dss_device *output,
-				      struct omap_dss_device *display)
+				      struct omap_dss_device *output)
 {
 	struct drm_encoder *encoder = NULL;
 	struct omap_encoder *omap_encoder;
@@ -258,7 +256,6 @@ struct drm_encoder *omap_encoder_init(struct drm_device *dev,
 		goto fail;
 
 	omap_encoder->output = output;
-	omap_encoder->display = display;
 
 	encoder = &omap_encoder->base;
 

commit 19b4200d8f4b90b5a41592f9021b52153ac2b6b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 24 19:38:07 2018 +0300

    drm/omap: Reverse direction of the DSS device enable/disable operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    Reconcile the omapdrm and omapdss drivers with the DRM bridge and panel
    model by reversing the direction of the DSS device .enable() and
    .disable() operations. This completes the move to the DRM bridge model,
    with the notable exception of the DSI pipelines that will require more
    work.
    
    We also adapt the omapdss shutdown handler dss_shutdown() to shut down
    all active pipelines starting from the pipeline output device instead of
    the display device.
    
    As a consequence the for_each_dss_display() macro isn't used and can be
    removed, and the omapdss_device_get_next() function underlying the macro
    can be simplified to search for output devices only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index d14d465392dd..acdfd2176423 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -146,33 +146,60 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct omap_dss_device *dssdev = omap_encoder->output;
 	struct drm_device *dev = encoder->dev;
 
 	dev_dbg(dev->dev, "disable(%s)\n", dssdev->name);
 
-	dssdev->ops->disable(dssdev);
+	/*
+	 * Disable the chain of external devices, starting at the one at the
+	 * internal encoder's output.
+	 */
+	omapdss_device_disable(dssdev->next);
+
+	/*
+	 * Disable the internal encoder. This will disable the DSS output. The
+	 * DSI is treated as an exception as DSI pipelines still use the legacy
+	 * flow where the pipeline output controls the encoder.
+	 */
+	if (dssdev->output_type != OMAP_DISPLAY_TYPE_DSI) {
+		dssdev->ops->disable(dssdev);
+		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+	}
 
-	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+	/*
+	 * Perform the post-disable operations on the chain of external devices
+	 * to complete the display pipeline disable.
+	 */
+	omapdss_device_post_disable(dssdev->next);
 }
 
 static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct omap_dss_device *dssdev = omap_encoder->output;
 	struct drm_device *dev = encoder->dev;
-	int r;
 
 	dev_dbg(dev->dev, "enable(%s)\n", dssdev->name);
 
-	r = dssdev->ops->enable(dssdev);
-	if (r) {
-		dev_err(dev->dev, "Failed to enable display '%s': %d\n",
-			dssdev->name, r);
-		return;
+	/* Prepare the chain of external devices for pipeline enable. */
+	omapdss_device_pre_enable(dssdev->next);
+
+	/*
+	 * Enable the internal encoder. This will enable the DSS output. The
+	 * DSI is treated as an exception as DSI pipelines still use the legacy
+	 * flow where the pipeline output controls the encoder.
+	 */
+	if (dssdev->output_type != OMAP_DISPLAY_TYPE_DSI) {
+		dssdev->ops->enable(dssdev);
+		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 	}
 
-	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+	/*
+	 * Enable the chain of external devices, starting at the one at the
+	 * internal encoder's output.
+	 */
+	omapdss_device_enable(dssdev->next);
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit 3f3623dd0f881dd5615097fdc9eeeb1ec732e59a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Sep 8 11:45:14 2018 +0300

    drm/omap: Remove enable checks from display .enable() and .remove()
    
    The displays (connectors, panels and encoders) bail out from their
    .enable() and .disable() handlers if the dss device is already enabled
    or disabled. Those safety checks are not needed when the functions are
    called through the omapdss_device_ops, as the .enable() and .disable()
    handlers are called from the DRM atomic helpers that already guarantee
    that no double enabling or disabling can occur.
    
    However, the handlers are also called directly from the .remove()
    handler. While this shouldn't be needed either as the modules can't be
    removed as long as the device is in use, it's still a good practice to
    disable the device explicitly. There is currently a safety check in
    .remove() in some drivers but not all of them.
    
    Remove the safety checks from the .enable() and .disable() handlers, and
    add missing ones in the .remove() handler.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 3c3d88e1df38..d14d465392dd 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -151,9 +151,6 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "disable(%s)\n", dssdev->name);
 
-	if (!omapdss_device_is_enabled(dssdev))
-		return;
-
 	dssdev->ops->disable(dssdev);
 
 	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
@@ -168,9 +165,6 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "enable(%s)\n", dssdev->name);
 
-	if (omapdss_device_is_enabled(dssdev))
-		return;
-
 	r = dssdev->ops->enable(dssdev);
 	if (r) {
 		dev_err(dev->dev, "Failed to enable display '%s': %d\n",

commit b49a2139ba67da43915a483a2a7e8490ba6c2b57
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 4 23:53:34 2018 +0300

    drm/omap: Remove connection checks from display .enable() and .remove()
    
    The displays (connectors, panels and encoders) return an error from
    their .enable() handler when the dss device is not connected. They also
    disconnect the dss device explicitly from their .remove() handler if it
    is still connected.
    
    Those safety checks are not needed:
    
    - The .enable() handler is called from code paths that access the dss
      devices chain from the display device, which is set to NULL when the
      device isn't connected.
    
    - The .remove() handler can only be called when unloading the module as
      the driver has the suppress_bind_attrs attribute set, and a reference
      to the module is taken when constructing the dss devices chain, so the
      module can only be unloaded when the dss device is disconnected.
    
    Remove the safety checks.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 5427c0b3ff9e..3c3d88e1df38 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -168,24 +168,17 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 
 	dev_dbg(dev->dev, "enable(%s)\n", dssdev->name);
 
-	if (!omapdss_device_is_connected(dssdev)) {
-		r = -ENODEV;
-		goto error;
-	}
-
 	if (omapdss_device_is_enabled(dssdev))
 		return;
 
 	r = dssdev->ops->enable(dssdev);
-	if (r)
-		goto error;
+	if (r) {
+		dev_err(dev->dev, "Failed to enable display '%s': %d\n",
+			dssdev->name, r);
+		return;
+	}
 
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
-	return;
-
-error:
-	dev_err(dev->dev, "Failed to enable display '%s': %d\n",
-		dssdev->name, r);
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit b80bfc66b0eeaf887f49c9cdb92ebba5ec0a94aa
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 4 17:22:27 2018 +0300

    drm/omap: Move common display enable/disable code to encoder
    
    All .enable() and .disable() handlers for panels and connectors share
    common code that validates and updates the device's state. Move it to
    common locations in the omap_encoder_enable() and omap_encoder_disable()
    handlers.
    
    The enabled check in the .disable() handler is left untouched, it will
    be addressed separately.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0d85b3a35767..5427c0b3ff9e 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -147,21 +147,45 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct drm_device *dev = encoder->dev;
+
+	dev_dbg(dev->dev, "disable(%s)\n", dssdev->name);
+
+	if (!omapdss_device_is_enabled(dssdev))
+		return;
 
 	dssdev->ops->disable(dssdev);
+
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 }
 
 static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct drm_device *dev = encoder->dev;
 	int r;
 
+	dev_dbg(dev->dev, "enable(%s)\n", dssdev->name);
+
+	if (!omapdss_device_is_connected(dssdev)) {
+		r = -ENODEV;
+		goto error;
+	}
+
+	if (omapdss_device_is_enabled(dssdev))
+		return;
+
 	r = dssdev->ops->enable(dssdev);
 	if (r)
-		dev_err(encoder->dev->dev,
-			"Failed to enable display '%s': %d\n",
-			dssdev->name, r);
+		goto error;
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+	return;
+
+error:
+	dev_err(dev->dev, "Failed to enable display '%s': %d\n",
+		dssdev->name, r);
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 148b6b20274f..0d85b3a35767 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -18,7 +18,7 @@
 #include <linux/list.h>
 
 #include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
+#include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_edid.h>
 
 #include "omap_drv.h"

commit 23d19ba06b9c5614d6457f5fed349ec8f6d4dac9
Merge: 7d0250ed8e69 e3d093070eb0
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Jan 11 16:32:10 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    drm-next has been forwarded to 5.0-rc1, and we need it to apply the damage
    helper for dirtyfb series from Noralf Trønnes.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 13d0add333afea7b2fef77473232b10dea3627dd
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 8 19:28:25 2019 +0200

    drm/edid: Pass connector to AVI infoframe functions
    
    Make life easier for drivers by simply passing the connector
    to drm_hdmi_avi_infoframe_from_display_mode() and
    drm_hdmi_avi_infoframe_quant_range(). That way drivers don't
    need to worry about is_hdmi2_sink mess.
    
    v2: Make is_hdmi2_sink() return true for sil-sii8620
        Adapt to omap/vc4 changes
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: "Heiko Stübner" <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-tegra@vger.kernel.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108172828.15184-1-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 452e625f6ce3..4566e0a75cb8 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -128,8 +128,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	if (hdmi_mode && dssdev->ops->hdmi.set_infoframe) {
 		struct hdmi_avi_infoframe avi;
 
-		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode,
-							     false);
+		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, connector,
+							     adjusted_mode);
 		if (r == 0)
 			dssdev->ops->hdmi.set_infoframe(dssdev, &avi);
 	}

commit 3c613a3bddd322c87677604d81e267fee22c6f14
Author: Sebastian Reichel <sebastian.reichel@collabora.com>
Date:   Wed Nov 21 17:09:14 2018 +0100

    drm/omap: fix incorrect union usage
    
    The DSI encoder sets dssdev->ops->dsi.set_config, which is stored at the
    same offset as dssdev->ops->hdmi.set_hdmi_mode. The code in omap_encoder
    only checks if dssdev->ops->hdmi.set_hdmi_mode is NULL. Due to the way
    union works, it won't be NULL if dsi.set_config is set. This means
    dsi_set_config will be called with config=hdmi_mode=false=NULL parameter
    resulting in a NULL dereference. Also the dereference happens while
    console is locked, so kernel hangs without any debug output without
    "fb.lockless_register_fb=1" parameter.
    
    This restructures the code, so that the HDMI mode is only configured
    for HDMI output types.
    
    Fixes: 83910ad3f51fb ("drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops")
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    [tomi.valkeinen@ti.com: dropped the safeguard]
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181121160916.22017-5-sebastian.reichel@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 452e625f6ce3..933ebc9f9faa 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -52,17 +52,44 @@ static const struct drm_encoder_funcs omap_encoder_funcs = {
 	.destroy = omap_encoder_destroy,
 };
 
+static void omap_encoder_hdmi_mode_set(struct drm_encoder *encoder,
+				       struct drm_display_mode *adjusted_mode)
+{
+	struct drm_device *dev = encoder->dev;
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *dssdev = omap_encoder->output;
+	struct drm_connector *connector;
+	bool hdmi_mode;
+
+	hdmi_mode = false;
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			hdmi_mode = omap_connector_get_hdmi_mode(connector);
+			break;
+		}
+	}
+
+	if (dssdev->ops->hdmi.set_hdmi_mode)
+		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
+
+	if (hdmi_mode && dssdev->ops->hdmi.set_infoframe) {
+		struct hdmi_avi_infoframe avi;
+		int r;
+
+		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode,
+							     false);
+		if (r == 0)
+			dssdev->ops->hdmi.set_infoframe(dssdev, &avi);
+	}
+}
+
 static void omap_encoder_mode_set(struct drm_encoder *encoder,
 				  struct drm_display_mode *mode,
 				  struct drm_display_mode *adjusted_mode)
 {
-	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct drm_connector *connector;
 	struct omap_dss_device *dssdev;
 	struct videomode vm = { 0 };
-	bool hdmi_mode;
-	int r;
 
 	drm_display_mode_to_videomode(adjusted_mode, &vm);
 
@@ -112,27 +139,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	}
 
 	/* Set the HDMI mode and HDMI infoframe if applicable. */
-	hdmi_mode = false;
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			hdmi_mode = omap_connector_get_hdmi_mode(connector);
-			break;
-		}
-	}
-
-	dssdev = omap_encoder->output;
-
-	if (dssdev->ops->hdmi.set_hdmi_mode)
-		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
-
-	if (hdmi_mode && dssdev->ops->hdmi.set_infoframe) {
-		struct hdmi_avi_infoframe avi;
-
-		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode,
-							     false);
-		if (r == 0)
-			dssdev->ops->hdmi.set_infoframe(dssdev, &avi);
-	}
+	if (omap_encoder->output->output_type == OMAP_DISPLAY_TYPE_HDMI)
+		omap_encoder_hdmi_mode_set(encoder, adjusted_mode);
 }
 
 static void omap_encoder_disable(struct drm_encoder *encoder)

commit 6ea48430952323091194100d48c5610b9cd286b4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 19:55:04 2018 +0300

    drm/omap: Don't call .set_timings() operation recursively
    
    Instead of calling the .set_timings() operation recursively from the
    display device backwards, iterate over the devices manually in the DRM
    encoder code. This moves the complexity to a single central location and
    simplifies the logic in omap_dss_device drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 749d21a92edd..452e625f6ce3 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -58,7 +58,6 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *display = omap_encoder->display;
 	struct drm_connector *connector;
 	struct omap_dss_device *dssdev;
 	struct videomode vm = { 0 };
@@ -104,18 +103,15 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		}
 	}
 
-	/*
-	 * HACK: Call the .set_timings() operation if available, this will
-	 * eventually store timings in the CRTC. Otherwise (for DSI outputs)
-	 * store the timings directly.
-	 *
-	 * All outputs should be brought in sync to operate similarly.
-	 */
-	if (display->ops->set_timings)
-		display->ops->set_timings(display, &vm);
-	else
-		*omap_crtc_timings(encoder->crtc) = vm;
+	/* Set timings for all devices in the display pipeline. */
+	dss_mgr_set_timings(omap_encoder->output, &vm);
+
+	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
+		if (dssdev->ops->set_timings)
+			dssdev->ops->set_timings(dssdev, &vm);
+	}
 
+	/* Set the HDMI mode and HDMI infoframe if applicable. */
 	hdmi_mode = false;
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		if (connector->encoder == encoder) {

commit 7c27fa57ef31debf62c5529725d4fa096b336a99
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 5 01:57:09 2018 +0300

    drm/omap: Call dispc timings check operation directly
    
    Instead of call the dispc timings check function dispc_mgr_timings_ok()
    from the internal encoders .check_timings() operation, expose it through
    the dispc ops (after renaming it to check_timings) and call it directly
    from omapdrm. This allows removal of now empty omap_dss_device
    .check_timings() operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0177a2c4b77a..749d21a92edd 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -165,27 +165,35 @@ static int omap_encoder_atomic_check(struct drm_encoder *encoder,
 				     struct drm_connector_state *conn_state)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	enum omap_channel channel = omap_encoder->output->dispc_channel;
 	struct drm_device *dev = encoder->dev;
+	struct omap_drm_private *priv = dev->dev_private;
 	struct omap_dss_device *dssdev;
 	struct videomode vm = { 0 };
 	int ret;
 
 	drm_display_mode_to_videomode(&crtc_state->mode, &vm);
 
+	ret = priv->dispc_ops->mgr_check_timings(priv->dispc, channel, &vm);
+	if (ret)
+		goto done;
+
 	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
 		if (!dssdev->ops->check_timings)
 			continue;
 
 		ret = dssdev->ops->check_timings(dssdev, &vm);
-		if (ret) {
-			dev_err(dev->dev, "invalid timings: %d\n", ret);
-			return ret;
-		}
+		if (ret)
+			goto done;
 	}
 
 	drm_display_mode_from_videomode(&vm, &crtc_state->adjusted_mode);
 
-	return 0;
+done:
+	if (ret)
+		dev_err(dev->dev, "invalid timings: %d\n", ret);
+
+	return ret;
 }
 
 static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {

commit 3fbda31e814868d8477ddf52d74b7b8f596578e8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 17:58:57 2018 +0300

    drm/omap: Split mode fixup and mode set from encoder enable
    
    The encoder enable operation currently performs mode fixup and mode
    setting for all omap_dss_device instances in the display pipeline. There
    are dedicated encoder operations for those operations (respectively
    .atomic_check() and .mode_set()), but they are not used for this
    purpose.
    
    Move the mode fixup code to .atomic_check() and the mode set code
    .mode_set() to better fit the KMS model. The bus flags fixup has to
    happen at .mode_set() time as there is no place to store the bus flags
    in the atomic state structures. This could be solved by extending one of
    the state structures, but as the goal is to replace the fixup by direct
    usage of bus flags through the driver, that would be pointless.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 82cdcba961a8..0177a2c4b77a 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -53,16 +53,69 @@ static const struct drm_encoder_funcs omap_encoder_funcs = {
 };
 
 static void omap_encoder_mode_set(struct drm_encoder *encoder,
-				struct drm_display_mode *mode,
-				struct drm_display_mode *adjusted_mode)
+				  struct drm_display_mode *mode,
+				  struct drm_display_mode *adjusted_mode)
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->output;
+	struct omap_dss_device *display = omap_encoder->display;
 	struct drm_connector *connector;
+	struct omap_dss_device *dssdev;
+	struct videomode vm = { 0 };
 	bool hdmi_mode;
 	int r;
 
+	drm_display_mode_to_videomode(adjusted_mode, &vm);
+
+	/*
+	 * HACK: This fixes the vm flags.
+	 * struct drm_display_mode does not contain the VSYNC/HSYNC/DE flags and
+	 * they get lost when converting back and forth between struct
+	 * drm_display_mode and struct videomode. The hack below goes and
+	 * fetches the missing flags.
+	 *
+	 * A better solution is to use DRM's bus-flags through the whole driver.
+	 */
+	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
+		unsigned long bus_flags = dssdev->bus_flags;
+
+		if (!(vm.flags & (DISPLAY_FLAGS_DE_LOW |
+				  DISPLAY_FLAGS_DE_HIGH))) {
+			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+				vm.flags |= DISPLAY_FLAGS_DE_LOW;
+			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
+				vm.flags |= DISPLAY_FLAGS_DE_HIGH;
+		}
+
+		if (!(vm.flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
+				  DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
+				vm.flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
+				vm.flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+		}
+
+		if (!(vm.flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
+				  DISPLAY_FLAGS_SYNC_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
+				vm.flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
+				vm.flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
+		}
+	}
+
+	/*
+	 * HACK: Call the .set_timings() operation if available, this will
+	 * eventually store timings in the CRTC. Otherwise (for DSI outputs)
+	 * store the timings directly.
+	 *
+	 * All outputs should be brought in sync to operate similarly.
+	 */
+	if (display->ops->set_timings)
+		display->ops->set_timings(display, &vm);
+	else
+		*omap_crtc_timings(encoder->crtc) = vm;
+
 	hdmi_mode = false;
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		if (connector->encoder == encoder) {
@@ -71,6 +124,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		}
 	}
 
+	dssdev = omap_encoder->output;
+
 	if (dssdev->ops->hdmi.set_hdmi_mode)
 		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
 
@@ -92,78 +147,12 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 	dssdev->ops->disable(dssdev);
 }
 
-static int omap_encoder_update(struct drm_encoder *encoder,
-			       enum omap_channel channel,
-			       struct videomode *vm)
-{
-	struct drm_device *dev = encoder->dev;
-	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *display = omap_encoder->display;
-	struct omap_dss_device *dssdev;
-	int ret;
-
-	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
-		unsigned long bus_flags = dssdev->bus_flags;
-
-		if (dssdev->ops->check_timings) {
-			ret = dssdev->ops->check_timings(dssdev, vm);
-			if (ret) {
-				dev_err(dev->dev, "invalid timings: %d\n", ret);
-				return ret;
-			}
-		}
-
-		/*
-		 * HACK: This fixes the vm flags.
-		 * struct drm_display_mode does not contain the VSYNC/HSYNC/DE
-		 * flags and they get lost when converting back and forth
-		 * between struct drm_display_mode and struct videomode. The
-		 * hack below goes and fetches the missing flags.
-		 *
-		 * A better solution is to use DRM's bus-flags through the whole
-		 * driver.
-		 */
-
-		if (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |
-				   DISPLAY_FLAGS_DE_HIGH))) {
-			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
-				vm->flags |= DISPLAY_FLAGS_DE_LOW;
-			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
-				vm->flags |= DISPLAY_FLAGS_DE_HIGH;
-		}
-
-		if (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
-				   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
-				vm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
-				vm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
-		}
-
-		if (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
-				   DISPLAY_FLAGS_SYNC_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
-				vm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
-				vm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
-		}
-	}
-
-	if (display->ops->set_timings)
-		display->ops->set_timings(display, vm);
-
-	return 0;
-}
-
 static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->display;
 	int r;
 
-	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),
-			    omap_crtc_timings(encoder->crtc));
-
 	r = dssdev->ops->enable(dssdev);
 	if (r)
 		dev_err(encoder->dev->dev,
@@ -175,6 +164,27 @@ static int omap_encoder_atomic_check(struct drm_encoder *encoder,
 				     struct drm_crtc_state *crtc_state,
 				     struct drm_connector_state *conn_state)
 {
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct drm_device *dev = encoder->dev;
+	struct omap_dss_device *dssdev;
+	struct videomode vm = { 0 };
+	int ret;
+
+	drm_display_mode_to_videomode(&crtc_state->mode, &vm);
+
+	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
+		if (!dssdev->ops->check_timings)
+			continue;
+
+		ret = dssdev->ops->check_timings(dssdev, &vm);
+		if (ret) {
+			dev_err(dev->dev, "invalid timings: %d\n", ret);
+			return ret;
+		}
+	}
+
+	drm_display_mode_from_videomode(&vm, &crtc_state->adjusted_mode);
+
 	return 0;
 }
 

commit 8e9c1c6676ea3d0dc60d84ee9a69984a4bcf859f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 18:32:16 2018 +0300

    drm/omap: Move bus flag hack to encoder implementation
    
    The bus flags stored in omap_dss_device instances are used to fixup the
    video mode before setting it, to honour constraints that can't be
    expressed through drm_display_mode. The fixup occurs in the CRTC mode
    set operation and the resulting video mode is stored internally in the
    CRTC. It is then used next by omap_encoder_enable() to apply mode fixups
    for the omap_dss_device instances in omap_encoder_update().
    
    Move the hack to the omap_encoder_update() function right before
    applying the omap_dss_device fixups, in order to group all fixups
    together.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index bb010c20d8b8..82cdcba961a8 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -103,13 +103,49 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	int ret;
 
 	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
-		if (!dssdev->ops->check_timings)
-			continue;
+		unsigned long bus_flags = dssdev->bus_flags;
+
+		if (dssdev->ops->check_timings) {
+			ret = dssdev->ops->check_timings(dssdev, vm);
+			if (ret) {
+				dev_err(dev->dev, "invalid timings: %d\n", ret);
+				return ret;
+			}
+		}
+
+		/*
+		 * HACK: This fixes the vm flags.
+		 * struct drm_display_mode does not contain the VSYNC/HSYNC/DE
+		 * flags and they get lost when converting back and forth
+		 * between struct drm_display_mode and struct videomode. The
+		 * hack below goes and fetches the missing flags.
+		 *
+		 * A better solution is to use DRM's bus-flags through the whole
+		 * driver.
+		 */
+
+		if (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |
+				   DISPLAY_FLAGS_DE_HIGH))) {
+			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+				vm->flags |= DISPLAY_FLAGS_DE_LOW;
+			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
+				vm->flags |= DISPLAY_FLAGS_DE_HIGH;
+		}
+
+		if (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
+				   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
+				vm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
+				vm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+		}
 
-		ret = dssdev->ops->check_timings(dssdev, vm);
-		if (ret) {
-			dev_err(dev->dev, "invalid timings: %d\n", ret);
-			return ret;
+		if (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
+				   DISPLAY_FLAGS_SYNC_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
+				vm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
+				vm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
 		}
 	}
 

commit 28120302c2fdf29b515c8cbd4e3a3867cb0cde7d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jun 6 00:55:48 2018 +0300

    drm/omap: Don't call .check_timings() operation recursively
    
    The .check_timings() operation is called recursively from the display
    device back to the output device. Most components just forward the
    operation to the previous component in the chain, resulting in lots of
    duplicated pass-through functions. To avoid that, iterate over the
    components manually.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index a6dce480b2cf..bb010c20d8b8 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -98,17 +98,23 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct omap_dss_device *display = omap_encoder->display;
+	struct omap_dss_device *dssdev;
 	int ret;
 
-	ret = dssdev->ops->check_timings(dssdev, vm);
-	if (ret) {
-		dev_err(dev->dev, "invalid timings: %d\n", ret);
-		return ret;
+	for (dssdev = omap_encoder->output; dssdev; dssdev = dssdev->next) {
+		if (!dssdev->ops->check_timings)
+			continue;
+
+		ret = dssdev->ops->check_timings(dssdev, vm);
+		if (ret) {
+			dev_err(dev->dev, "invalid timings: %d\n", ret);
+			return ret;
+		}
 	}
 
-	if (dssdev->ops->set_timings)
-		dssdev->ops->set_timings(dssdev, vm);
+	if (display->ops->set_timings)
+		display->ops->set_timings(display, vm);
 
 	return 0;
 }

commit 138fe53ef8d341dd27a0f01d55f8774d33b880f8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jun 6 00:04:39 2018 +0300

    drm/omap: Remove unneeded fallback for missing .check_timings()
    
    The .check_timings() operation is present in all panels and connectors.
    The fallback that uses .get_timings() in the absence of .check_timings()
    is thus unneeded.
    
    While it could be argued that the fallback implements a useful check
    that should be extended to cover all fixed-resolution panels, the code
    is currently unused and gets in the way of the ongoing refactoring.
    Remove it, a similar feature can always be added later.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 94b75d018e71..a6dce480b2cf 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -101,21 +101,9 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	struct omap_dss_device *dssdev = omap_encoder->display;
 	int ret;
 
-	if (dssdev->ops->check_timings) {
-		ret = dssdev->ops->check_timings(dssdev, vm);
-	} else {
-		struct videomode t = {0};
-
-		dssdev->ops->get_timings(dssdev, &t);
-
-		if (memcmp(vm, &t, sizeof(*vm)))
-			ret = -EINVAL;
-		else
-			ret = 0;
-	}
-
+	ret = dssdev->ops->check_timings(dssdev, vm);
 	if (ret) {
-		dev_err(dev->dev, "could not set timings: %d\n", ret);
+		dev_err(dev->dev, "invalid timings: %d\n", ret);
 		return ret;
 	}
 

commit 7805d1e5098c1a90e5feb153809b16ba890b03e4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 31 22:56:59 2018 +0300

    drm/omap: Don't call HDMI mode and infoframe operations recursively
    
    The HDMI mode (.set_hdmi_mode()) and infoframe (.set_infoframe())
    operations are called recursively from the display device back to the
    HDMI encoder. This isn't required, as all components other than the HDMI
    encoder just forward the operation to the previous component in the
    chain. Call the operations directly on the HDMI encoder.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 2689ae74ea60..94b75d018e71 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -58,7 +58,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->display;
+	struct omap_dss_device *dssdev = omap_encoder->output;
 	struct drm_connector *connector;
 	bool hdmi_mode;
 	int r;

commit d96aaada55553b9e4264a2f2c8cc9599f027cd28
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 31 23:14:43 2018 +0300

    drm/omap: Pass both output and display omap_dss_device to encoder init
    
    The drm_encoder implementation requires access to the omap_dss_device
    corresponding to the display, which is passed to its initialization
    function and stored internally. Clean up of the HDMI mode and infoframe
    handling will require access to the output omap_dss_device. To prepare
    for that, pass it to the encoder initialization function and store it
    internally as well.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 87e2b3799a45..2689ae74ea60 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -36,7 +36,8 @@
  */
 struct omap_encoder {
 	struct drm_encoder base;
-	struct omap_dss_device *dssdev;
+	struct omap_dss_device *output;
+	struct omap_dss_device *display;
 };
 
 static void omap_encoder_destroy(struct drm_encoder *encoder)
@@ -57,7 +58,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_device *dssdev = omap_encoder->display;
 	struct drm_connector *connector;
 	bool hdmi_mode;
 	int r;
@@ -86,7 +87,7 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_device *dssdev = omap_encoder->display;
 
 	dssdev->ops->disable(dssdev);
 }
@@ -97,7 +98,7 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_device *dssdev = omap_encoder->display;
 	int ret;
 
 	if (dssdev->ops->check_timings) {
@@ -127,7 +128,7 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_device *dssdev = omap_encoder->display;
 	int r;
 
 	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),
@@ -156,7 +157,8 @@ static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
 
 /* initialize encoder */
 struct drm_encoder *omap_encoder_init(struct drm_device *dev,
-		struct omap_dss_device *dssdev)
+				      struct omap_dss_device *output,
+				      struct omap_dss_device *display)
 {
 	struct drm_encoder *encoder = NULL;
 	struct omap_encoder *omap_encoder;
@@ -165,7 +167,8 @@ struct drm_encoder *omap_encoder_init(struct drm_device *dev,
 	if (!omap_encoder)
 		goto fail;
 
-	omap_encoder->dssdev = dssdev;
+	omap_encoder->output = output;
+	omap_encoder->display = display;
 
 	encoder = &omap_encoder->base;
 

commit 70f9cbfc56a3239ff65796e024b4bbf653d1e0ba
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 31 23:04:30 2018 +0300

    drm/omap: Get from CRTC to display device directly
    
    The CRTC mode set implementation needs to access the omap_dss_device for
    the pipeline display. To do so, it iterates over all pipelines to find
    the one that contains an encoder corresponding to the CRTC, and request
    the display device from the encoder. That's a very complicated dance
    when the CRTC has a direct pipeline pointer already, and the pipeline
    contains a pointer to the display device.
    
    Replace the convoluted code with direct access.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 7bbf3700e393..87e2b3799a45 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -39,13 +39,6 @@ struct omap_encoder {
 	struct omap_dss_device *dssdev;
 };
 
-struct omap_dss_device *omap_encoder_get_dssdev(struct drm_encoder *encoder)
-{
-	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
-
-	return omap_encoder->dssdev;
-}
-
 static void omap_encoder_destroy(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);

commit 83910ad3f51fbc0e6546b60aafa90697b5127a8a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 1 19:45:01 2018 +0300

    drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops
    
    omap_dss_device instances have two ops structures, omap_dss_driver and
    omap_dss_device_ops. The former is used for devices at the end of the
    pipeline (a.k.a. display devices), and the latter for intermediate
    devices.
    
    Having two sets of operations isn't convenient as code that iterates
    over omap_dss_device instances need to take them both into account.
    There's currently a reasonably small amount of such code, but more will
    be introduced to move the driver away from recursive operations. To
    simplify current and future code, move all operations that are not
    specific to the display device to the omap_dss_device_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index ec0f451e3b36..7bbf3700e393 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -77,16 +77,16 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 		}
 	}
 
-	if (dssdev->driver->set_hdmi_mode)
-		dssdev->driver->set_hdmi_mode(dssdev, hdmi_mode);
+	if (dssdev->ops->hdmi.set_hdmi_mode)
+		dssdev->ops->hdmi.set_hdmi_mode(dssdev, hdmi_mode);
 
-	if (hdmi_mode && dssdev->driver->set_hdmi_infoframe) {
+	if (hdmi_mode && dssdev->ops->hdmi.set_infoframe) {
 		struct hdmi_avi_infoframe avi;
 
 		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode,
 							     false);
 		if (r == 0)
-			dssdev->driver->set_hdmi_infoframe(dssdev, &avi);
+			dssdev->ops->hdmi.set_infoframe(dssdev, &avi);
 	}
 }
 
@@ -94,9 +94,8 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	const struct omap_dss_driver *dssdrv = dssdev->driver;
 
-	dssdrv->disable(dssdev);
+	dssdev->ops->disable(dssdev);
 }
 
 static int omap_encoder_update(struct drm_encoder *encoder,
@@ -106,15 +105,14 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	const struct omap_dss_driver *dssdrv = dssdev->driver;
 	int ret;
 
-	if (dssdrv->check_timings) {
-		ret = dssdrv->check_timings(dssdev, vm);
+	if (dssdev->ops->check_timings) {
+		ret = dssdev->ops->check_timings(dssdev, vm);
 	} else {
 		struct videomode t = {0};
 
-		dssdrv->get_timings(dssdev, &t);
+		dssdev->ops->get_timings(dssdev, &t);
 
 		if (memcmp(vm, &t, sizeof(*vm)))
 			ret = -EINVAL;
@@ -127,8 +125,8 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 		return ret;
 	}
 
-	if (dssdrv->set_timings)
-		dssdrv->set_timings(dssdev, vm);
+	if (dssdev->ops->set_timings)
+		dssdev->ops->set_timings(dssdev, vm);
 
 	return 0;
 }
@@ -137,13 +135,12 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	const struct omap_dss_driver *dssdrv = dssdev->driver;
 	int r;
 
 	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),
 			    omap_crtc_timings(encoder->crtc));
 
-	r = dssdrv->enable(dssdev);
+	r = dssdev->ops->enable(dssdev);
 	if (r)
 		dev_err(encoder->dev->dev,
 			"Failed to enable display '%s': %d\n",

commit e0528c944058e137a1c74176173109a6864241ac
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 14 03:12:37 2018 +0200

    drm/omap: dss: Constify omap_dss_driver operations structure
    
    The structure contains function pointers that don't need to be modified.
    Make all its instances const to improve security.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index fcdf4b0a8eec..ec0f451e3b36 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -94,7 +94,7 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	struct omap_dss_driver *dssdrv = dssdev->driver;
+	const struct omap_dss_driver *dssdrv = dssdev->driver;
 
 	dssdrv->disable(dssdev);
 }
@@ -106,7 +106,7 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	struct omap_dss_driver *dssdrv = dssdev->driver;
+	const struct omap_dss_driver *dssdrv = dssdev->driver;
 	int ret;
 
 	if (dssdrv->check_timings) {
@@ -137,7 +137,7 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
-	struct omap_dss_driver *dssdrv = dssdev->driver;
+	const struct omap_dss_driver *dssdrv = dssdev->driver;
 	int r;
 
 	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 624f5b50b755..fcdf4b0a8eec 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -1,7 +1,5 @@
 /*
- * drivers/gpu/drm/omapdrm/omap_encoder.c
- *
- * Copyright (C) 2011 Texas Instruments
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify it

commit 0c1f528cb13708ff3ba462a5c757d5588fc47d36
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:07 2017 +0530

    drm: handle HDMI 2.0 VICs in AVI info-frames
    
    HDMI 1.4b support the CEA video modes as per range of CEA-861-D (VIC 1-64).
    For any other mode, the VIC filed in AVI infoframes should be 0.
    HDMI 2.0 sinks, support video modes range as per CEA-861-F spec, which is
    extended to (VIC 1-107).
    
    This patch adds a bool input variable, which indicates if the connected
    sink is a HDMI 2.0 sink or not. This will make sure that we don't pass a
    HDMI 2.0 VIC to a HDMI 1.4 sink.
    
    This patch touches all drm drivers, who are callers of this function
    drm_hdmi_avi_infoframe_from_display_mode but to make sure there is
    no change in current behavior, is_hdmi2 is kept as false.
    
    In case of I915 driver, this patch:
    - checks if the connected display is HDMI 2.0.
    - HDMI infoframes carry one of this two type of information:
            - VIC for 4K modes for HDMI 1.4 sinks
            - S3D information for S3D modes
      As CEA-861-F has already defined VICs for 4K videomodes, this
      patch doesn't allow sending HDMI infoframes for HDMI 2.0 sinks,
      until the mode is 3D.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Jose Abreu <jose.abreu@synopsys.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    
    PS: This patch touches a few lines in few files, which were
    already above 80 char, so checkpatch gives 80 char warning again.
    - gpu/drm/omapdrm/omap_encoder.c
    - gpu/drm/i915/intel_sdvo.c
    
    V2: Rebase, Added r-b from Andrzej
    V3: Addressed review comment from Ville:
            - Do not send VICs in both AVI-IF and HDMI-IF
              send only one of it.
    V4: Rebase
    V5: Added r-b from Neil.
        Addressed review comments from Ville
        - Do not block HDMI vendor IF, instead check for VIC while
          handling AVI infoframes
    V6: Rebase
    V7: Rebase
    
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-2-git-send-email-shashank.sharma@intel.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 86c977b7189a..624f5b50b755 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -85,7 +85,8 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	if (hdmi_mode && dssdev->driver->set_hdmi_infoframe) {
 		struct hdmi_avi_infoframe avi;
 
-		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode);
+		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode,
+							     false);
 		if (r == 0)
 			dssdev->driver->set_hdmi_infoframe(dssdev, &avi);
 	}

commit d501b12999eb9cdfc488127fabaf794171dd9bbf
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 12 11:57:24 2016 +0200

    drm: omapdrm: Use sizeof(*var) instead of sizeof(type) for structures
    
    By linking the sizeof to a variable type the code will be less prone to
    bugs due to future type changes of variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index a20f30039aee..86c977b7189a 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -117,7 +117,7 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 
 		dssdrv->get_timings(dssdev, &t);
 
-		if (memcmp(vm, &t, sizeof(struct videomode)))
+		if (memcmp(vm, &t, sizeof(*vm)))
 			ret = -EINVAL;
 		else
 			ret = 0;

commit da11bbbb10a964c293c2e2e702ea62ad6cba48b4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:04 2016 +0300

    drm/omap: Use consistent name for struct videomode
    
    Use 'vm' to refer to a struct videomode instead of 'p', 't', 'timings' or
    something else.
    
    The code will be easier to follow if we use consistent names.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index f54065e9e2bf..a20f30039aee 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -102,7 +102,7 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 static int omap_encoder_update(struct drm_encoder *encoder,
 			       enum omap_channel channel,
-			       struct videomode *timings)
+			       struct videomode *vm)
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
@@ -111,13 +111,13 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	int ret;
 
 	if (dssdrv->check_timings) {
-		ret = dssdrv->check_timings(dssdev, timings);
+		ret = dssdrv->check_timings(dssdev, vm);
 	} else {
 		struct videomode t = {0};
 
 		dssdrv->get_timings(dssdev, &t);
 
-		if (memcmp(timings, &t, sizeof(struct videomode)))
+		if (memcmp(vm, &t, sizeof(struct videomode)))
 			ret = -EINVAL;
 		else
 			ret = 0;
@@ -129,7 +129,7 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	}
 
 	if (dssdrv->set_timings)
-		dssdrv->set_timings(dssdev, timings);
+		dssdrv->set_timings(dssdev, vm);
 
 	return 0;
 }

commit 4520ff28aaa1e7f1b45f3abc0c45429ea9e93817
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:03 2016 +0300

    drm/omap: Replace struct omap_video_timings with videomode
    
    omap_video_timings can be replaced with the generic videomode in omapdrm
    and the omap_video_timings can be removed.
    
    This patch will replace the omap_video_timings with videomode.
    With the change we no longer need the functions to convert to/from
    videomode and drm_display_mode to omap_video_timings, these can be removed
    as well.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0bbb9c59622e..f54065e9e2bf 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -102,7 +102,7 @@ static void omap_encoder_disable(struct drm_encoder *encoder)
 
 static int omap_encoder_update(struct drm_encoder *encoder,
 			       enum omap_channel channel,
-			       struct omap_video_timings *timings)
+			       struct videomode *timings)
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
@@ -113,11 +113,11 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	if (dssdrv->check_timings) {
 		ret = dssdrv->check_timings(dssdev, timings);
 	} else {
-		struct omap_video_timings t = {0};
+		struct videomode t = {0};
 
 		dssdrv->get_timings(dssdev, &t);
 
-		if (memcmp(timings, &t, sizeof(struct omap_video_timings)))
+		if (memcmp(timings, &t, sizeof(struct videomode)))
 			ret = -EINVAL;
 		else
 			ret = 0;

commit 8d83bbd1198d7d0de2968ec0bde85810b26341e1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jan 5 11:43:16 2016 +0200

    drm/omap: print an error if display enable fails
    
    If the panel's enable fails, omap_encoder silently ignores the failure.
    omapdrm should really handle the failure, but unfortunately the whole
    encoder enable codepath is expected to always succeed.
    
    So for now, catch the enable failure and print an error.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 61714e9670ae..0bbb9c59622e 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -139,11 +139,16 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
 	struct omap_dss_driver *dssdrv = dssdev->driver;
+	int r;
 
 	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),
 			    omap_crtc_timings(encoder->crtc));
 
-	dssdrv->enable(dssdev);
+	r = dssdrv->enable(dssdev);
+	if (r)
+		dev_err(encoder->dev->dev,
+			"Failed to enable display '%s': %d\n",
+			dssdev->name, r);
 }
 
 static int omap_encoder_atomic_check(struct drm_encoder *encoder,

commit 9c8e566e4930a00b51bee7766a5c188f20fdb16b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 17:10:59 2015 +0200

    drm/omap: remove obsolete manager assignment
    
    omap_encoder_update() assigns an overlay manager to
    dssdev->src->manager. This assignment is not needed, as the connections
    in the display chain have already been made at connect step.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0c104ad7ef66..61714e9670ae 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -110,8 +110,6 @@ static int omap_encoder_update(struct drm_encoder *encoder,
 	struct omap_dss_driver *dssdrv = dssdev->driver;
 	int ret;
 
-	dssdev->src->manager = omap_dss_get_overlay_manager(channel);
-
 	if (dssdrv->check_timings) {
 		ret = dssdrv->check_timings(dssdev, timings);
 	} else {

commit 13a3d91f17a5f7ed2acd275d18b6acfdb131fb15
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:20:18 2015 +0200

    drm: Pass 'name' to drm_encoder_init()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          )
    { ... }
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          );
    
    @@
    expression E1, E2, E3, E4;
    @@
     drm_encoder_init(E1, E2, E3, E4
    +                 ,NULL
                      )
    
    v2: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670818-2966-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 7d9b32a0eb43..0c104ad7ef66 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -178,7 +178,7 @@ struct drm_encoder *omap_encoder_init(struct drm_device *dev,
 	encoder = &omap_encoder->base;
 
 	drm_encoder_init(dev, encoder, &omap_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS);
+			 DRM_MODE_ENCODER_TMDS, NULL);
 	drm_encoder_helper_add(encoder, &omap_encoder_helper_funcs);
 
 	return encoder;

commit 4029755e2a411c72f32b60b37ca8861f21647139
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 02:34:05 2015 +0300

    drm: omapdrm: Move encoder setup to encoder operations
    
    Now that the driver is fully converted to atomic operations, and that
    the atomic helpers call the operations in the right order, we can move
    encoder setup to where it belongs, in the encoder operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 54847ed089ef..7d9b32a0eb43 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -52,8 +52,6 @@ static void omap_encoder_destroy(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 
-	omap_encoder_set_enabled(encoder, false);
-
 	drm_encoder_cleanup(encoder);
 	kfree(omap_encoder);
 }
@@ -93,59 +91,18 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	}
 }
 
-/*
- * The CRTC drm_crtc_helper_set_mode() didn't really give us the right order.
- * The easiest way to work around this was to make all the encoder-helper's
- * no-op's and have the omap_crtc code take care of the sequencing and call
- * us in the right points.
- *
- * FIXME: Revisit this after switching to atomic updates completely.
- */
-
 static void omap_encoder_disable(struct drm_encoder *encoder)
-{
-}
-
-static void omap_encoder_enable(struct drm_encoder *encoder)
-{
-}
-
-static int omap_encoder_atomic_check(struct drm_encoder *encoder,
-				     struct drm_crtc_state *crtc_state,
-				     struct drm_connector_state *conn_state)
-{
-	return 0;
-}
-
-static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
-	.mode_set = omap_encoder_mode_set,
-	.disable = omap_encoder_disable,
-	.enable = omap_encoder_enable,
-	.atomic_check = omap_encoder_atomic_check,
-};
-
-/*
- * Instead of relying on the helpers for modeset, the omap_crtc code
- * calls these functions in the proper sequence.
- */
-
-int omap_encoder_set_enabled(struct drm_encoder *encoder, bool enabled)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
 	struct omap_dss_device *dssdev = omap_encoder->dssdev;
 	struct omap_dss_driver *dssdrv = dssdev->driver;
 
-	if (enabled) {
-		return dssdrv->enable(dssdev);
-	} else {
-		dssdrv->disable(dssdev);
-		return 0;
-	}
+	dssdrv->disable(dssdev);
 }
 
-int omap_encoder_update(struct drm_encoder *encoder,
-		struct omap_overlay_manager *mgr,
-		struct omap_video_timings *timings)
+static int omap_encoder_update(struct drm_encoder *encoder,
+			       enum omap_channel channel,
+			       struct omap_video_timings *timings)
 {
 	struct drm_device *dev = encoder->dev;
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
@@ -153,7 +110,7 @@ int omap_encoder_update(struct drm_encoder *encoder,
 	struct omap_dss_driver *dssdrv = dssdev->driver;
 	int ret;
 
-	dssdev->src->manager = mgr;
+	dssdev->src->manager = omap_dss_get_overlay_manager(channel);
 
 	if (dssdrv->check_timings) {
 		ret = dssdrv->check_timings(dssdev, timings);
@@ -179,6 +136,32 @@ int omap_encoder_update(struct drm_encoder *encoder,
 	return 0;
 }
 
+static void omap_encoder_enable(struct drm_encoder *encoder)
+{
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_driver *dssdrv = dssdev->driver;
+
+	omap_encoder_update(encoder, omap_crtc_channel(encoder->crtc),
+			    omap_crtc_timings(encoder->crtc));
+
+	dssdrv->enable(dssdev);
+}
+
+static int omap_encoder_atomic_check(struct drm_encoder *encoder,
+				     struct drm_crtc_state *crtc_state,
+				     struct drm_connector_state *conn_state)
+{
+	return 0;
+}
+
+static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
+	.mode_set = omap_encoder_mode_set,
+	.disable = omap_encoder_disable,
+	.enable = omap_encoder_enable,
+	.atomic_check = omap_encoder_atomic_check,
+};
+
 /* initialize encoder */
 struct drm_encoder *omap_encoder_init(struct drm_device *dev,
 		struct omap_dss_device *dssdev)

commit d97db134880986b7ebb6fc85995e8d6bc3ce477f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 23:04:30 2015 +0200

    drm: omapdrm: Replace encoder mode_fixup with atomic_check
    
    The encoder .mode_fixup() operation is legacy, atomic updates uses the
    new .atomic_check() operation. Convert the encoder driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 2aeb41f0881a..54847ed089ef 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -62,13 +62,6 @@ static const struct drm_encoder_funcs omap_encoder_funcs = {
 	.destroy = omap_encoder_destroy,
 };
 
-static bool omap_encoder_mode_fixup(struct drm_encoder *encoder,
-				  const struct drm_display_mode *mode,
-				  struct drm_display_mode *adjusted_mode)
-{
-	return true;
-}
-
 static void omap_encoder_mode_set(struct drm_encoder *encoder,
 				struct drm_display_mode *mode,
 				struct drm_display_mode *adjusted_mode)
@@ -117,11 +110,18 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 {
 }
 
+static int omap_encoder_atomic_check(struct drm_encoder *encoder,
+				     struct drm_crtc_state *crtc_state,
+				     struct drm_connector_state *conn_state)
+{
+	return 0;
+}
+
 static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
-	.mode_fixup = omap_encoder_mode_fixup,
 	.mode_set = omap_encoder_mode_set,
 	.disable = omap_encoder_disable,
 	.enable = omap_encoder_enable,
+	.atomic_check = omap_encoder_atomic_check,
 };
 
 /*

commit aea3cab1d109e37a06ac3f269444dffdfdc0347a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 22:50:51 2015 +0200

    drm: omapdrm: Switch connector DPMS to atomic helpers
    
    The atomic connector DPMS helper implements the connector DPMS operation
    using atomic commit, removing the need for DPMS helper operations on
    CRTCs and encoders.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 96459f709147..2aeb41f0881a 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -62,22 +62,6 @@ static const struct drm_encoder_funcs omap_encoder_funcs = {
 	.destroy = omap_encoder_destroy,
 };
 
-/*
- * The CRTC drm_crtc_helper_set_mode() doesn't really give us the right
- * order.. the easiest way to work around this for now is to make all
- * the encoder-helper's no-op's and have the omap_crtc code take care
- * of the sequencing and call us in the right points.
- *
- * Eventually to handle connecting CRTCs to different encoders properly,
- * either the CRTC helpers need to change or we need to replace
- * drm_crtc_helper_set_mode(), but lets wait until atomic-modeset for
- * that.
- */
-
-static void omap_encoder_dpms(struct drm_encoder *encoder, int mode)
-{
-}
-
 static bool omap_encoder_mode_fixup(struct drm_encoder *encoder,
 				  const struct drm_display_mode *mode,
 				  struct drm_display_mode *adjusted_mode)
@@ -116,6 +100,15 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	}
 }
 
+/*
+ * The CRTC drm_crtc_helper_set_mode() didn't really give us the right order.
+ * The easiest way to work around this was to make all the encoder-helper's
+ * no-op's and have the omap_crtc code take care of the sequencing and call
+ * us in the right points.
+ *
+ * FIXME: Revisit this after switching to atomic updates completely.
+ */
+
 static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 }
@@ -125,7 +118,6 @@ static void omap_encoder_enable(struct drm_encoder *encoder)
 }
 
 static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
-	.dpms = omap_encoder_dpms,
 	.mode_fixup = omap_encoder_mode_fixup,
 	.mode_set = omap_encoder_mode_set,
 	.disable = omap_encoder_disable,

commit 9416c9df8e05e375af859cfa856e1353e5a72d0d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:54:54 2015 +0200

    drm: omapdrm: Switch mode config to atomic helpers
    
    This removes the legacy mode config code. The CRTC and encoder prepare
    and commit operations are not used anymore, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0734527808d5..96459f709147 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -116,14 +116,6 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 	}
 }
 
-static void omap_encoder_prepare(struct drm_encoder *encoder)
-{
-}
-
-static void omap_encoder_commit(struct drm_encoder *encoder)
-{
-}
-
 static void omap_encoder_disable(struct drm_encoder *encoder)
 {
 }
@@ -136,8 +128,6 @@ static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
 	.dpms = omap_encoder_dpms,
 	.mode_fixup = omap_encoder_mode_fixup,
 	.mode_set = omap_encoder_mode_set,
-	.prepare = omap_encoder_prepare,
-	.commit = omap_encoder_commit,
 	.disable = omap_encoder_disable,
 	.enable = omap_encoder_enable,
 };

commit 68dc0390d4e9d3f73fa6a7756a948ff97a40eccb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 7 00:22:39 2015 +0200

    drm: omapdrm: Implement encoder .disable() and .enable() operations
    
    The operations are required by the atomic helpers, implement them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index ab6ed49f37ab..0734527808d5 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -124,12 +124,22 @@ static void omap_encoder_commit(struct drm_encoder *encoder)
 {
 }
 
+static void omap_encoder_disable(struct drm_encoder *encoder)
+{
+}
+
+static void omap_encoder_enable(struct drm_encoder *encoder)
+{
+}
+
 static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
 	.dpms = omap_encoder_dpms,
 	.mode_fixup = omap_encoder_mode_fixup,
 	.mode_set = omap_encoder_mode_set,
 	.prepare = omap_encoder_prepare,
 	.commit = omap_encoder_commit,
+	.disable = omap_encoder_disable,
+	.enable = omap_encoder_enable,
 };
 
 /*

commit 2d278f5414ae9cd535a7bdefaba2e2de38e116c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:31:37 2015 +0200

    drm: omapdrm: Clean up #include's
    
    Use the <...> include style instead of "..." for DRM headers and sort
    the headers alphabetically to ease detection of duplicates.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 7445fb1491ae..ab6ed49f37ab 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -17,16 +17,14 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/list.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
 #include <drm/drm_edid.h>
 
 #include "omap_drv.h"
 
-#include "drm_crtc.h"
-#include "drm_crtc_helper.h"
-
-#include <linux/list.h>
-
-
 /*
  * encoder funcs
  */

commit 4f930c0f273967b41f46ca84927ac0256bab4649
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jun 18 14:19:48 2014 +0300

    drm/omap: Add infoframe & dvi/hdmi mode support
    
    Make the omapdrm driver use the new HDMI ops when possible.
    
    omapdrm will call set_hdmi_mode (when available) to tell the encoder
    driver whether the monitor is a DVI or HDMI monitor, and if it's an HDMI
    monitor, omapdrm will call set_hdmi_infoframe to to set the AVI
    infoframe.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 5290a88c681d..7445fb1491ae 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -17,6 +17,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <drm/drm_edid.h>
+
 #include "omap_drv.h"
 
 #include "drm_crtc.h"
@@ -89,6 +91,31 @@ static void omap_encoder_mode_set(struct drm_encoder *encoder,
 				struct drm_display_mode *mode,
 				struct drm_display_mode *adjusted_mode)
 {
+	struct drm_device *dev = encoder->dev;
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct drm_connector *connector;
+	bool hdmi_mode;
+	int r;
+
+	hdmi_mode = false;
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			hdmi_mode = omap_connector_get_hdmi_mode(connector);
+			break;
+		}
+	}
+
+	if (dssdev->driver->set_hdmi_mode)
+		dssdev->driver->set_hdmi_mode(dssdev, hdmi_mode);
+
+	if (hdmi_mode && dssdev->driver->set_hdmi_infoframe) {
+		struct hdmi_avi_infoframe avi;
+
+		r = drm_hdmi_avi_infoframe_from_display_mode(&avi, adjusted_mode);
+		if (r == 0)
+			dssdev->driver->set_hdmi_infoframe(dssdev, &avi);
+	}
 }
 
 static void omap_encoder_prepare(struct drm_encoder *encoder)

commit ec72a81e27d735eb0b5f9325be3d88aa4cb5510a
Author: Archit Taneja <archit@ti.com>
Date:   Thu Jan 2 14:49:53 2014 +0530

    drm/omap: fix: disable encoder before destroying it
    
    Currently, an encoder is disabled only when an apply work is queued for the
    corresponding crtc. This works fine for the paths where userspace explicitly
    disables crtc, this results in disabling the omapdss device in the crtc's
    pre_apply function.
    
    However, when the omapdrm module is removed, there is no work queued to ensure
    that the encoder is disabled. This can result in an enabled omapdss device when
    removing omapdrm. omapdss is left in an inconsistent state, and that prevents us
    from using that omapdss device being used again.
    
    Disable enabled encoders in omap_encoder_destroy, we could consider a better
    place for doing this later.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 6a12e899235b..5290a88c681d 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -51,6 +51,9 @@ struct omap_dss_device *omap_encoder_get_dssdev(struct drm_encoder *encoder)
 static void omap_encoder_destroy(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+
+	omap_encoder_set_enabled(encoder, false);
+
 	drm_encoder_cleanup(encoder);
 	kfree(omap_encoder);
 }

commit a73fdc647417699833f22d0f239affe22e062827
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jul 24 13:01:34 2013 +0300

    OMAPDSS: rename omap_dss_device's 'output' to 'src'
    
    In the old panel device model we had "outputs", which were the encoders
    inside OMAP DSS block, and panel devices (omap_dss_device). The panel
    devices had a reference to the source of the video data, i.e. reference
    to an "output", in a field named "output".
    
    That was somewhat confusing even in the old panel device model, but even
    more so with the panel device model where we can have longer chains of
    display entities.
    
    This patch renames the "output" field to "src", which much better tells
    what the field points to.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Archit Taneja <archit@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index c29451ba65da..6a12e899235b 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -133,7 +133,7 @@ int omap_encoder_update(struct drm_encoder *encoder,
 	struct omap_dss_driver *dssdrv = dssdev->driver;
 	int ret;
 
-	dssdev->output->manager = mgr;
+	dssdev->src->manager = mgr;
 
 	if (dssdrv->check_timings) {
 		ret = dssdrv->check_timings(dssdev, timings);

commit 0d8f371f5a0cfdad946b5dd0ba9c77d2fbd5b2d3
Author: Archit Taneja <archit@ti.com>
Date:   Tue Mar 26 19:15:19 2013 +0530

    drm/omap: Fix and improve crtc and overlay manager correlation
    
    The omapdrm driver currently takes a config/module arg to figure out the number
    of crtcs it needs to create. We could create as many crtcs as there are overlay
    managers in the DSS hardware, but we don't do that because each crtc eats up
    one DSS overlay, and that reduces the number of planes we can attach to a single
    crtc.
    
    Since the number of crtcs may be lesser than the number of hardware overlay
    managers, we need to figure out which overlay managers to use for our crtcs. The
    current approach is to use pipe2chan(), which returns a higher numbered manager
    for the crtc.
    
    The problem with this approach is that it assumes that the overlay managers we
    choose will connect to the encoders the platform's panels are going to use,
    this isn't true, an overlay manager connects only to a few outputs/encoders, and
    choosing any overlay manager for our crtc might lead to a situation where the
    encoder cannot connect to any of the crtcs we have chosen. For example, an
    omap5-panda board has just one hdmi output. If num_crtc is set to 1, with the
    current approach, pipe2chan will pick up the LCD2 overlay manager, which cannot
    connect to the hdmi encoder at all. The only manager that could have connected
    to hdmi was the TV overlay manager.
    
    Therefore, there is a need to choose our overlay managers keeping in mind the
    panels we have on that platform. The new approach iterates through all the
    available panels, creates encoders and connectors for them, and then tries to
    get a suitable overlay manager to create a crtc which can connect to the
    encoders.
    
    We use the dispc_channel field in omap_dss_output to retrieve the desired
    overlay manager's channel number, we then check whether the manager had already
    been assigned to a crtc or not. If it was already assigned to a crtc, we assume
    that out of all the encoders which intend use this crtc, only one will run at a
    time. If the overlay manager wan't assigned to a crtc till then, we create a
    new crtc and link it with the overlay manager.
    
    This approach just looks for the best dispc_channel for each encoder. On DSS HW,
    some encoders can connect to multiple overlay managers. Since we don't try
    looking for alternate overlay managers, there is a greater possibility that 2
    or more encoders end up asking for the same crtc, causing only one encoder to
    run at a time.
    
    Also, this approach isn't the most optimal one, it can do either good or bad
    depending on the sequence in which the panels/outputs are parsed. The optimal
    way would be some sort of back tracking approach, where we improve the set of
    managers we use as we iterate through the list of panels/encoders. That's
    something left for later.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 18be00dd7b5e..c29451ba65da 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -41,6 +41,13 @@ struct omap_encoder {
 	struct omap_dss_device *dssdev;
 };
 
+struct omap_dss_device *omap_encoder_get_dssdev(struct drm_encoder *encoder)
+{
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+
+	return omap_encoder->dssdev;
+}
+
 static void omap_encoder_destroy(struct drm_encoder *encoder)
 {
 	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);

commit bddabbe174cfb6f944baaf13ed5b93c6ee89ec3d
Author: Archit Taneja <archit@ti.com>
Date:   Tue Mar 26 19:15:20 2013 +0530

    drm/omap: Make fixed resolution panels work
    
    The omapdrm driver requires omapdss panel drivers to expose ops like detect,
    set_timings and check_timings. These can be NULL for fixed panel DPI, DBI, DSI
    and SDI drivers. At some places, there are no checks to see if the panel driver
    has these ops or not, and that leads to a crash.
    
    The following things are done to make fixed panels work:
    
    - The omap_connector's detect function is modified such that it considers panel
      types which are generally fixed panels as always connected(provided the panel
      driver doesn't have a detect op). Hence, the connector corresponding to these
      panels is always in a 'connected' state.
    
    - If a panel driver doesn't have a check_timings op, assume that it supports the
      mode passed to omap_connector_mode_valid(the 'mode_valid' drm helper function)
    
    - The function omap_encoder_update shouldn't really do anything for fixed
      resolution panels, make sure that it calls set_timings only if the panel
      driver has one.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 21d126d0317e..18be00dd7b5e 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -128,13 +128,26 @@ int omap_encoder_update(struct drm_encoder *encoder,
 
 	dssdev->output->manager = mgr;
 
-	ret = dssdrv->check_timings(dssdev, timings);
+	if (dssdrv->check_timings) {
+		ret = dssdrv->check_timings(dssdev, timings);
+	} else {
+		struct omap_video_timings t = {0};
+
+		dssdrv->get_timings(dssdev, &t);
+
+		if (memcmp(timings, &t, sizeof(struct omap_video_timings)))
+			ret = -EINVAL;
+		else
+			ret = 0;
+	}
+
 	if (ret) {
 		dev_err(dev->dev, "could not set timings: %d\n", ret);
 		return ret;
 	}
 
-	dssdrv->set_timings(dssdev, timings);
+	if (dssdrv->set_timings)
+		dssdrv->set_timings(dssdev, timings);
 
 	return 0;
 }

commit fffddfd6c8e0c10c42c6e2cc54ba880fcc36ebbb
Merge: 69086a78bdc9 be88298b0a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:46:44 2013 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge from Dave Airlie:
     "Highlights:
    
       - TI LCD controller KMS driver
    
       - TI OMAP KMS driver merged from staging
    
       - drop gma500 stub driver
    
       - the fbcon locking fixes
    
       - the vgacon dirty like zebra fix.
    
       - open firmware videomode and hdmi common code helpers
    
       - major locking rework for kms object handling - pageflip/cursor
         won't block on polling anymore!
    
       - fbcon helper and prime helper cleanups
    
       - i915: all over the map, haswell power well enhancements, valleyview
         macro horrors cleaned up, killing lots of legacy GTT code,
    
       - radeon: CS ioctl unification, deprecated UMS support, gpu reset
         rework, VM fixes
    
       - nouveau: reworked thermal code, external dp/tmds encoder support
         (anx9805), fences sleep instead of polling,
    
       - exynos: all over the driver fixes."
    
    Lovely conflict in radeon/evergreen_cs.c between commit de0babd60d8d
    ("drm/radeon: enforce use of radeon_get_ib_value when reading user cmd")
    and the new changes that modified that evergreen_dma_cs_parse()
    function.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (508 commits)
      drm/tilcdc: only build on arm
      drm/i915: Revert hdmi HDP pin checks
      drm/tegra: Add list of framebuffers to debugfs
      drm/tegra: Fix color expansion
      drm/tegra: Split DC_CMD_STATE_CONTROL register write
      drm/tegra: Implement page-flipping support
      drm/tegra: Implement VBLANK support
      drm/tegra: Implement .mode_set_base()
      drm/tegra: Add plane support
      drm/tegra: Remove bogus tegra_framebuffer structure
      drm: Add consistency check for page-flipping
      drm/radeon: Use generic HDMI infoframe helpers
      drm/tegra: Use generic HDMI infoframe helpers
      drm: Add EDID helper documentation
      drm: Add HDMI infoframe helpers
      video: Add generic HDMI infoframe helpers
      drm: Add some missing forward declarations
      drm: Move mode tables to drm_edid.c
      drm: Remove duplicate drm_mode_cea_vic()
      gma500: Fix n, m1 and m2 clock limits for sdvo and lvds
      ...

commit 8bb0daffb0b8e45188066255b4203446eae181f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Feb 11 12:43:09 2013 -0500

    drm/omap: move out of staging
    
    Now that the omapdss interface has been reworked so that omapdrm can use
    dispc directly, we have been able to fix the remaining functional kms
    issues with omapdrm.  And in the mean time the PM sequencing and many
    other of that open issues have been solved.  So I think it makes sense
    to finally move omapdrm out of staging.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
new file mode 100644
index 000000000000..7e1f2ab65372
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -0,0 +1,170 @@
+/*
+ * drivers/gpu/drm/omapdrm/omap_encoder.c
+ *
+ * Copyright (C) 2011 Texas Instruments
+ * Author: Rob Clark <rob@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "omap_drv.h"
+
+#include "drm_crtc.h"
+#include "drm_crtc_helper.h"
+
+#include <linux/list.h>
+
+
+/*
+ * encoder funcs
+ */
+
+#define to_omap_encoder(x) container_of(x, struct omap_encoder, base)
+
+/* The encoder and connector both map to same dssdev.. the encoder
+ * handles the 'active' parts, ie. anything the modifies the state
+ * of the hw, and the connector handles the 'read-only' parts, like
+ * detecting connection and reading edid.
+ */
+struct omap_encoder {
+	struct drm_encoder base;
+	struct omap_dss_device *dssdev;
+};
+
+static void omap_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	drm_encoder_cleanup(encoder);
+	kfree(omap_encoder);
+}
+
+static const struct drm_encoder_funcs omap_encoder_funcs = {
+	.destroy = omap_encoder_destroy,
+};
+
+/*
+ * The CRTC drm_crtc_helper_set_mode() doesn't really give us the right
+ * order.. the easiest way to work around this for now is to make all
+ * the encoder-helper's no-op's and have the omap_crtc code take care
+ * of the sequencing and call us in the right points.
+ *
+ * Eventually to handle connecting CRTCs to different encoders properly,
+ * either the CRTC helpers need to change or we need to replace
+ * drm_crtc_helper_set_mode(), but lets wait until atomic-modeset for
+ * that.
+ */
+
+static void omap_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+}
+
+static bool omap_encoder_mode_fixup(struct drm_encoder *encoder,
+				  const struct drm_display_mode *mode,
+				  struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static void omap_encoder_mode_set(struct drm_encoder *encoder,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode)
+{
+}
+
+static void omap_encoder_prepare(struct drm_encoder *encoder)
+{
+}
+
+static void omap_encoder_commit(struct drm_encoder *encoder)
+{
+}
+
+static const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {
+	.dpms = omap_encoder_dpms,
+	.mode_fixup = omap_encoder_mode_fixup,
+	.mode_set = omap_encoder_mode_set,
+	.prepare = omap_encoder_prepare,
+	.commit = omap_encoder_commit,
+};
+
+/*
+ * Instead of relying on the helpers for modeset, the omap_crtc code
+ * calls these functions in the proper sequence.
+ */
+
+int omap_encoder_set_enabled(struct drm_encoder *encoder, bool enabled)
+{
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_driver *dssdrv = dssdev->driver;
+
+	if (enabled) {
+		return dssdrv->enable(dssdev);
+	} else {
+		dssdrv->disable(dssdev);
+		return 0;
+	}
+}
+
+int omap_encoder_update(struct drm_encoder *encoder,
+		struct omap_overlay_manager *mgr,
+		struct omap_video_timings *timings)
+{
+	struct drm_device *dev = encoder->dev;
+	struct omap_encoder *omap_encoder = to_omap_encoder(encoder);
+	struct omap_dss_device *dssdev = omap_encoder->dssdev;
+	struct omap_dss_driver *dssdrv = dssdev->driver;
+	int ret;
+
+	dssdev->output->manager = mgr;
+
+	ret = dssdrv->check_timings(dssdev, timings);
+	if (ret) {
+		dev_err(dev->dev, "could not set timings: %d\n", ret);
+		return ret;
+	}
+
+	dssdrv->set_timings(dssdev, timings);
+
+	return 0;
+}
+
+/* initialize encoder */
+struct drm_encoder *omap_encoder_init(struct drm_device *dev,
+		struct omap_dss_device *dssdev)
+{
+	struct drm_encoder *encoder = NULL;
+	struct omap_encoder *omap_encoder;
+
+	omap_encoder = kzalloc(sizeof(*omap_encoder), GFP_KERNEL);
+	if (!omap_encoder) {
+		dev_err(dev->dev, "could not allocate encoder\n");
+		goto fail;
+	}
+
+	omap_encoder->dssdev = dssdev;
+
+	encoder = &omap_encoder->base;
+
+	drm_encoder_init(dev, encoder, &omap_encoder_funcs,
+			 DRM_MODE_ENCODER_TMDS);
+	drm_encoder_helper_add(encoder, &omap_encoder_helper_funcs);
+
+	return encoder;
+
+fail:
+	if (encoder)
+		omap_encoder_destroy(encoder);
+
+	return NULL;
+}
