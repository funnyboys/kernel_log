commit bdc19ba651ca2ced6c80e58a46f5d51e35299f60
Author: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
Date:   Mon Dec 9 12:33:19 2019 +0000

    drm/omapdrm: Fix trivial spelling
    
    Fix trivial spelling identified while examining the code.
    
            s/supprted./supported./
    
    Signed-off-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191209123320.10186-1-kieran.bingham+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 3c5ddbf30e97..fce7e944a280 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -831,7 +831,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	 * OMAP_DSS_CHANNEL_DIGIT. X server assumes 256 element gamma
 	 * tables so lets use that. Size of HW gamma table can be
 	 * extracted with dispc_mgr_gamma_size(). If it returns 0
-	 * gamma table is not supprted.
+	 * gamma table is not supported.
 	 */
 	if (priv->dispc_ops->mgr_gamma_size(priv->dispc, channel)) {
 		unsigned int gamma_lut_size = 256;

commit 03b0f2ce735e97e9f49790d4563c82515b8fa702
Merge: e4f86e437164 5f9e832c1370
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Mon Jul 22 21:24:10 2019 +0200

    Merge v5.3-rc1 into drm-misc-next
    
    Noralf needs some SPI patches in 5.3 to merge some work on tinydrm.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 81f6156ca5aea59640cc3a11565e10b0c4cac60b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jul 16 08:42:10 2019 +0200

    drm/omapdrm: drop use of drmP.h
    
    Drop use of the deprecated header drmP.h.
    Rearranged list of include files to match rest of
    DRM too.
    The drmP.h file was deleted from the header file, and the necessary
    includes was added to the .c files to fix build.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190716064220.18157-10-sam@ravnborg.org

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index d61215494617..a8f09829fcab 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -15,12 +15,14 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/math64.h>
+
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_mode.h>
 #include <drm/drm_plane_helper.h>
-#include <linux/math64.h>
+#include <drm/drm_vblank.h>
 
 #include "omap_drv.h"
 

commit be8454afc50f43016ca8b6130d9673bdd0bd56ec
Merge: fec88ab0af97 3729fe2bc2a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 19:04:27 2019 -0700

    Merge tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "The biggest thing in this is the AMD Navi GPU support, this again
      contains a bunch of header files that are large. These are the new AMD
      RX5700 GPUs that just recently became available.
    
      New drivers:
       - ST-Ericsson MCDE driver
       - Ingenic JZ47xx SoC
    
      UAPI change:
       - HDR source metadata property
    
      Core:
       - HDR inforframes and EDID parsing
       - drm hdmi infoframe unpacking
       - remove prime sg_table caching into dma-buf
       - New gem vram helpers to reduce driver code
       - Lots of drmP.h removal
       - reservation fencing fix
       - documentation updates
       - drm_fb_helper_connector removed
       - mode name command handler rewrite
    
      fbcon:
       - Remove the fbcon notifiers
    
      ttm:
       - forward progress fixes
    
      dma-buf:
       - make mmap call optional
       - debugfs refcount fixes
       - dma-fence free with pending signals fix
       - each dma-buf gets an inode
    
      Panels:
       - Lots of additional panel bindings
    
      amdgpu:
       - initial navi10 support
       - avoid hw reset
       - HDR metadata support
       - new thermal sensors for vega asics
       - RAS fixes
       - use HMM rather than MMU notifier
       - xgmi topology via kfd
       - SR-IOV fixes
       - driver reload fixes
       - DC use a core bpc attribute
       - Aux fixes for DC
       - Bandwidth calc updates for DC
       - Clock handling refactor
       - kfd VEGAM support
    
      vmwgfx:
       - Coherent memory support changes
    
      i915:
       - HDR Support
       - HDMI i2c link
       - Icelake multi-segmented gamma support
       - GuC firmware update
       - Mule Creek Canyon PCH support for EHL
       - EHL platform updtes
       - move i915.alpha_support to i915.force_probe
       - runtime PM refactoring
       - VBT parsing refactoring
       - DSI fixes
       - struct mutex dependency reduction
       - GEM code reorg
    
      mali-dp:
       - Komeda driver features
    
      msm:
       - dsi vs EPROBE_DEFER fixes
       - msm8998 snapdragon 835 support
       - a540 gpu support
       - mdp5 and dpu interconnect support
    
      exynos:
       - drmP.h removal
    
      tegra:
       - misc fixes
    
      tda998x:
       - audio support improvements
       - pixel repeated mode support
       - quantisation range handling corrections
       - HDMI vendor info fix
    
      armada:
       - interlace support fix
       - overlay/video plane register handling refactor
       - add gamma support
    
      rockchip:
       - RX3328 support
    
      panfrost:
       - expose perf counters via hidden ioctls
    
      vkms:
       - enumerate CRC sources list
    
      ast:
       - rework BO handling
    
      mgag200:
       - rework BO handling
    
      dw-hdmi:
       - suspend/resume support
    
      rcar-du:
       - R8A774A1 Soc Support
       - LVDS dual-link mode support
       - Additional formats
       - Misc fixes
    
      omapdrm:
       - DSI command mode display support
    
      stm
       - fb modifier support
       - runtime PM support
    
      sun4i:
       - use vmap ops
    
      vc4:
       - binner bo binding rework
    
      v3d:
       - compute shader support
       - resync/sync fixes
       - job management refactoring
    
      lima:
       - NULL pointer in irq handler fix
       - scheduler default timeout
    
      virtio:
       - fence seqno support
       - trace events
    
      bochs:
       - misc fixes
    
      tc458767:
       - IRQ/HDP handling
    
      sii902x:
       - HDMI audio support
    
      atmel-hlcdc:
       - misc fixes
    
      meson:
       - zpos support"
    
    * tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm: (1815 commits)
      Revert "Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next"
      Revert "mm: adjust apply_to_pfn_range interface for dropped token."
      mm: adjust apply_to_pfn_range interface for dropped token.
      drm/amdgpu/navi10: add uclk activity sensor
      drm/amdgpu: properly guard the generic discovery code
      drm/amdgpu: add missing documentation on new module parameters
      drm/amdgpu: don't invalidate caches in RELEASE_MEM, only do the writeback
      drm/amd/display: avoid 64-bit division
      drm/amdgpu/psp11: simplify the ucode register logic
      drm/amdgpu: properly guard DC support in navi code
      drm/amd/powerplay: vega20: fix uninitialized variable use
      drm/amd/display: dcn20: include linux/delay.h
      amdgpu: make pmu support optional
      drm/amd/powerplay: Zero initialize current_rpm in vega20_get_fan_speed_percent
      drm/amd/powerplay: Zero initialize freq in smu_v11_0_get_current_clk_freq
      drm/amd/powerplay: Use memset to initialize metrics structs
      drm/amdgpu/mes10.1: Fix header guard
      drm/amd/powerplay: add temperature sensor support for navi10
      drm/amdgpu: fix scheduler timeout calc
      drm/amdgpu: Prepare for hmm_range_register API change (v2)
      ...

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5a29bf01c0e8..8712af79a49c 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <drm/drm_atomic.h>

commit 1bb418bffdd6f95a41e8e59be63933bc84fde13c
Author: Sebastian Reichel <sebastian.reichel@collabora.com>
Date:   Thu May 23 22:07:56 2019 +0200

    drm/omap: add support for manually updated displays
    
    This adds the required infrastructure for manually updated displays,
    such as DSI command mode panels. While those panels often support
    partial updates we currently always do a full refresh.
    
    The display will be refreshed when something calls the dirty callback,
    such as libdrm's drmModeDirtyFB(). This is currently being done at least
    by the kernel console and Xorg (with modesetting driver) in their
    default configuration. Weston does not implement this and the fbdev
    backend does not work (display will not update). Weston's DRM backend
    uses double buffering and the page flip will also trigger a display
    refresh.
    
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5b6a18a62bbb..d61215494617 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -32,6 +32,7 @@ struct omap_crtc_state {
 	/* Shadow values for legacy userspace support. */
 	unsigned int rotation;
 	unsigned int zpos;
+	bool manually_updated;
 };
 
 #define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
@@ -51,6 +52,7 @@ struct omap_crtc {
 	bool pending;
 	wait_queue_head_t pending_wait;
 	struct drm_pending_vblank_event *event;
+	struct delayed_work update_work;
 
 	void (*framedone_handler)(void *);
 	void *framedone_handler_data;
@@ -105,21 +107,18 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
 /*
  * Manager-ops, callbacks from output when they need to configure
  * the upstream part of the video pipe.
- *
- * Most of these we can ignore until we add support for command-mode
- * panels.. for video-mode the crtc-helpers already do an adequate
- * job of sequencing the setup of the video pipe in the proper order
  */
 
-/* we can probably ignore these until we support command-mode panels: */
 static void omap_crtc_dss_start_update(struct omap_drm_private *priv,
 				       enum omap_channel channel)
 {
+	priv->dispc_ops->mgr_enable(priv->dispc, channel, true);
 }
 
 /* Called only from the encoder enable/disable and suspend/resume handlers. */
 static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 {
+	struct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);
 	struct drm_device *dev = crtc->dev;
 	struct omap_drm_private *priv = dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -131,6 +130,12 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	if (WARN_ON(omap_crtc->enabled == enable))
 		return;
 
+	if (omap_state->manually_updated) {
+		omap_irq_enable_framedone(crtc, enable);
+		omap_crtc->enabled = enable;
+		return;
+	}
+
 	if (omap_crtc->pipe->output->type == OMAP_DISPLAY_TYPE_HDMI) {
 		priv->dispc_ops->mgr_enable(priv->dispc, channel, enable);
 		omap_crtc->enabled = enable;
@@ -350,6 +355,51 @@ void omap_crtc_framedone_irq(struct drm_crtc *crtc, uint32_t irqstatus)
 	wake_up(&omap_crtc->pending_wait);
 }
 
+void omap_crtc_flush(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);
+
+	if (!omap_state->manually_updated)
+		return;
+
+	if (!delayed_work_pending(&omap_crtc->update_work))
+		schedule_delayed_work(&omap_crtc->update_work, 0);
+}
+
+static void omap_crtc_manual_display_update(struct work_struct *data)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(data, struct omap_crtc, update_work.work);
+	struct drm_display_mode *mode = &omap_crtc->pipe->crtc->mode;
+	struct omap_dss_device *dssdev = omap_crtc->pipe->output->next;
+	struct drm_device *dev = omap_crtc->base.dev;
+	const struct omap_dss_driver *dssdrv;
+	int ret;
+
+	if (!dssdev) {
+		dev_err_once(dev->dev, "missing display dssdev!");
+		return;
+	}
+
+	dssdrv = dssdev->driver;
+	if (!dssdrv || !dssdrv->update) {
+		dev_err_once(dev->dev, "missing or incorrect dssdrv!");
+		return;
+	}
+
+	if (dssdrv->sync)
+		dssdrv->sync(dssdev);
+
+	ret = dssdrv->update(dssdev, 0, 0, mode->hdisplay, mode->vdisplay);
+	if (ret < 0) {
+		spin_lock_irq(&dev->event_lock);
+		omap_crtc->pending = false;
+		spin_unlock_irq(&dev->event_lock);
+		wake_up(&omap_crtc->pending_wait);
+	}
+}
+
 static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
@@ -399,12 +449,17 @@ static void omap_crtc_atomic_enable(struct drm_crtc *crtc,
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);
 	int ret;
 
 	DBG("%s", omap_crtc->name);
 
 	priv->dispc_ops->runtime_get(priv->dispc);
 
+	/* manual updated display will not trigger vsync irq */
+	if (omap_state->manually_updated)
+		return;
+
 	spin_lock_irq(&crtc->dev->event_lock);
 	drm_crtc_vblank_on(crtc);
 	ret = drm_crtc_vblank_get(crtc);
@@ -419,6 +474,7 @@ static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
 
 	DBG("%s", omap_crtc->name);
 
@@ -429,6 +485,11 @@ static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
 	}
 	spin_unlock_irq(&crtc->dev->event_lock);
 
+	cancel_delayed_work(&omap_crtc->update_work);
+
+	if (!omap_crtc_wait_pending(crtc))
+		dev_warn(dev->dev, "manual display update did not finish!");
+
 	drm_crtc_vblank_off(crtc);
 
 	priv->dispc_ops->runtime_put(priv->dispc);
@@ -499,6 +560,22 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
 }
 
+static bool omap_crtc_is_manually_updated(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_dss_device *display = omap_crtc->pipe->output->next;
+
+	if (!display)
+		return false;
+
+	if (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {
+		DBG("detected manually updated display!");
+		return true;
+	}
+
+	return false;
+}
+
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 				struct drm_crtc_state *state)
 {
@@ -520,6 +597,9 @@ static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 		/* Mirror new values for zpos and rotation in omap_crtc_state */
 		omap_crtc_state->zpos = pri_state->zpos;
 		omap_crtc_state->rotation = pri_state->rotation;
+
+		/* Check if this CRTC is for a manually updated display */
+		omap_crtc_state->manually_updated = omap_crtc_is_manually_updated(crtc);
 	}
 
 	return 0;
@@ -535,6 +615,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_crtc_state *omap_crtc_state = to_omap_crtc_state(crtc->state);
 	int ret;
 
 	if (crtc->state->color_mgmt_changed) {
@@ -559,6 +640,15 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	DBG("%s: GO", omap_crtc->name);
 
+	if (omap_crtc_state->manually_updated) {
+		/* send new image for page flips and modeset changes */
+		spin_lock_irq(&crtc->dev->event_lock);
+		omap_crtc_flush(crtc);
+		omap_crtc_arm_event(crtc);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		return;
+	}
+
 	ret = drm_crtc_vblank_get(crtc);
 	WARN_ON(ret != 0);
 
@@ -644,6 +734,7 @@ omap_crtc_duplicate_state(struct drm_crtc *crtc)
 
 	state->zpos = current_state->zpos;
 	state->rotation = current_state->rotation;
+	state->manually_updated = current_state->manually_updated;
 
 	return &state->base;
 }
@@ -720,6 +811,19 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];
 
+	/*
+	 * We want to refresh manually updated displays from dirty callback,
+	 * which is called quite often (e.g. for each drawn line). This will
+	 * be used to do the display update asynchronously to avoid blocking
+	 * the rendering process and merges multiple dirty calls into one
+	 * update if they arrive very fast. We also call this function for
+	 * atomic display updates (e.g. for page flips), which means we do
+	 * not need extra locking. Atomic updates should be synchronous, but
+	 * need to wait for the framedone interrupt anyways.
+	 */
+	INIT_DELAYED_WORK(&omap_crtc->update_work,
+			  omap_crtc_manual_display_update);
+
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {

commit 47103a80f55a6b7f5a51f1e9a4886e532cdfa4e2
Author: Sebastian Reichel <sebastian.reichel@collabora.com>
Date:   Thu May 23 22:07:55 2019 +0200

    drm/omap: add framedone interrupt support
    
    This prepares framedone interrupt handling for
    manual display update support.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 86827a061b0b..5b6a18a62bbb 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -51,6 +51,9 @@ struct omap_crtc {
 	bool pending;
 	wait_queue_head_t pending_wait;
 	struct drm_pending_vblank_event *event;
+
+	void (*framedone_handler)(void *);
+	void *framedone_handler_data;
 };
 
 /* -----------------------------------------------------------------------------
@@ -230,6 +233,18 @@ static int omap_crtc_dss_register_framedone(
 		struct omap_drm_private *priv, enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = omap_crtc->base.dev;
+
+	if (omap_crtc->framedone_handler)
+		return -EBUSY;
+
+	dev_dbg(dev->dev, "register framedone %s", omap_crtc->name);
+
+	omap_crtc->framedone_handler = handler;
+	omap_crtc->framedone_handler_data = data;
+
 	return 0;
 }
 
@@ -237,6 +252,17 @@ static void omap_crtc_dss_unregister_framedone(
 		struct omap_drm_private *priv, enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = omap_crtc->base.dev;
+
+	dev_dbg(dev->dev, "unregister framedone %s", omap_crtc->name);
+
+	WARN_ON(omap_crtc->framedone_handler != handler);
+	WARN_ON(omap_crtc->framedone_handler_data != data);
+
+	omap_crtc->framedone_handler = NULL;
+	omap_crtc->framedone_handler_data = NULL;
 }
 
 static const struct dss_mgr_ops mgr_ops = {
@@ -302,6 +328,28 @@ void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 	DBG("%s: apply done", omap_crtc->name);
 }
 
+void omap_crtc_framedone_irq(struct drm_crtc *crtc, uint32_t irqstatus)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	if (!omap_crtc->framedone_handler)
+		return;
+
+	omap_crtc->framedone_handler(omap_crtc->framedone_handler_data);
+
+	spin_lock(&crtc->dev->event_lock);
+	/* Send the vblank event if one has been requested. */
+	if (omap_crtc->event) {
+		drm_crtc_send_vblank_event(crtc, omap_crtc->event);
+		omap_crtc->event = NULL;
+	}
+	omap_crtc->pending = false;
+	spin_unlock(&crtc->dev->event_lock);
+
+	/* Wake up omap_atomic_complete. */
+	wake_up(&omap_crtc->pending_wait);
+}
+
 static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;

commit ad9df7d91b4a6e8f4b20c2bf539ac09b3b2ad6eb
Author: Sebastian Reichel <sebastian.reichel@collabora.com>
Date:   Thu May 23 22:07:54 2019 +0200

    drm/omap: don't check dispc timings for DSI
    
    While most display types only forward their VM to the DISPC, this
    is not true for DSI. DSI calculates the VM for DISPC based on its
    own, but it's not identical. Actually the DSI VM is not even a valid
    DISPC VM making this check fail. Let's restore the old behaviour
    and avoid checking the DISPC VM for DSI here.
    
    Fixes: 7c27fa57ef31 ("drm/omap: Call dispc timings check operation directly")
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5a29bf01c0e8..86827a061b0b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -395,10 +395,20 @@ static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,
 	int r;
 
 	drm_display_mode_to_videomode(mode, &vm);
-	r = priv->dispc_ops->mgr_check_timings(priv->dispc, omap_crtc->channel,
-					       &vm);
-	if (r)
-		return r;
+
+	/*
+	 * DSI might not call this, since the supplied mode is not a
+	 * valid DISPC mode. DSI will calculate and configure the
+	 * proper DISPC mode later.
+	 */
+	if (omap_crtc->pipe->output->next == NULL ||
+	    omap_crtc->pipe->output->next->type != OMAP_DISPLAY_TYPE_DSI) {
+		r = priv->dispc_ops->mgr_check_timings(priv->dispc,
+						       omap_crtc->channel,
+						       &vm);
+		if (r)
+			return r;
+	}
 
 	/* Check for bandwidth limit */
 	if (priv->max_bandwidth) {

commit 79107f274b2fc6bce13f687de33c8d0b70994558
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Sep 23 12:58:15 2018 +0300

    drm/omap: Add support for drm_bridge
    
    Hook up drm_bridge support in the omapdrm driver. Despite the recent
    extensive preparation work, this is a rather intrusive change, as the
    management of outputs needs to be adapted through the driver to handle
    both omap_dss_device and drm_bridge.
    
    Connector creation is skipped when using a drm_bridge, as the bridge
    creates the connector internally. This creates issues with systems that
    split connector operations (such as modes retrieval and hot-plug
    detection) across different bridges. These systems can't be supported
    using drm_bridge for now (their support through the omap_dss_device
    infrastructure is not affected), this will be fixed in subsequent
    changes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 1353aec73611..5a29bf01c0e8 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -666,7 +666,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {
 		dev_err(dev->dev, "%s(): could not init crtc for: %s\n",
-			__func__, pipe->display->name);
+			__func__, pipe->output->name);
 		kfree(omap_crtc);
 		return ERR_PTR(ret);
 	}

commit 0dbfc396672025d3ef8bacc934b80a5463e75c6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 10 14:00:38 2018 +0200

    drm/omap: Merge omap_dss_device type and output_type fields
    
    The omap_dss_device type and output_type fields differ mostly for
    historical reasons. The output_type field is required for all devices
    but the display at the end of the pipeline, and must be set to
    OMAP_DISPLAY_TYPE_NONE for the latter. The type field is required for
    all devices but the internal encoder, for which it is ignored.
    
    The only reason why the output_type field must be set to
    OMAP_DISPLAY_TYPE_NONE for the display at the end of the pipeline is to
    identify omap_dss_device instances corresponding to displays. This is
    not documented and confusing.
    
    Clean the code by adding a new display field to the omap_dss_device
    structure to identify displays, and merge the type and output_type
    fields.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index ae399435346b..1353aec73611 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -128,7 +128,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	if (WARN_ON(omap_crtc->enabled == enable))
 		return;
 
-	if (omap_crtc->pipe->output->output_type == OMAP_DISPLAY_TYPE_HDMI) {
+	if (omap_crtc->pipe->output->type == OMAP_DISPLAY_TYPE_HDMI) {
 		priv->dispc_ops->mgr_enable(priv->dispc, channel, enable);
 		omap_crtc->enabled = enable;
 		return;

commit 116c7721077cf82b942adaef146e97663247d972
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 20 00:17:42 2018 +0300

    drm/omap: Move DISPC timing checks to CRTC .mode_valid() operation
    
    The DISPC timings checks relate to the CRTC, but they're performed in
    the encoder and connector .atomic_check() and .mode_valid() operations.
    Move them to the CRTC .mode_valid() operation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index d99e24dcc0bf..ae399435346b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -390,6 +390,15 @@ static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,
 					const struct drm_display_mode *mode)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct videomode vm = {0};
+	int r;
+
+	drm_display_mode_to_videomode(mode, &vm);
+	r = priv->dispc_ops->mgr_check_timings(priv->dispc, omap_crtc->channel,
+					       &vm);
+	if (r)
+		return r;
 
 	/* Check for bandwidth limit */
 	if (priv->max_bandwidth) {

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 40acf4ce7c9f..d99e24dcc0bf 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -18,7 +18,6 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
 #include <drm/drm_mode.h>
 #include <drm/drm_plane_helper.h>
 #include <linux/math64.h>

commit c39ff7ea780549be960bea9d028f8b5a4aadf2c9
Author: Shayenne Moura <shayenneluzmoura@gmail.com>
Date:   Thu Dec 20 10:26:10 2018 -0200

    drm: omapdrm: Cleanup drm_display_mode print str
    
    This patch adjust the print string of drm_display_mode object
    to remove drm_mode_object dependency in omapdrm files.
    
    Signed-off-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/cb6079fa6de6fda8d865a1d2a61d7cf10019ae88.1545308167.git.shayenneluzmoura@gmail.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index caffc547ef97..40acf4ce7c9f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -427,12 +427,8 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
 
-	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
-	    omap_crtc->name, mode->base.id, mode->name,
-	    mode->vrefresh, mode->clock,
-	    mode->hdisplay, mode->hsync_start, mode->hsync_end, mode->htotal,
-	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
-	    mode->type, mode->flags);
+	DBG("%s: set mode: " DRM_MODE_FMT,
+	    omap_crtc->name, DRM_MODE_ARG(mode));
 
 	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
 }

commit 24ec84e854c68ceda59a26027114eb7f260f9411
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Nov 10 13:16:54 2018 +0200

    drm/omap: Move DISPC runtime PM handling to omapdrm
    
    The internal encoders (DSI, HDMI4, HDMI5 and VENC) runtime PM handlers
    attempt to manage the runtime PM state of the connected DISPC, based on
    the rationale that the DISPC providing data to the encoders requires
    ensuring that the display is active whenever the encoders are active.
    
    While the DISPC provides data to the encoders, it doesn't as such
    constitute a resource that encoders require in order to be taken out
    of suspend, contrary to for instance a functional clock or a power
    supply. Encoders registers can be accessed without the DISPC being
    active, and while the encoders will not output any video stream without
    being fed by the DISPC, the DISPC PM state doesn't influence the
    encoders PM state.
    
    For this reason the DISPC PM state is better managed from the omapdrm
    driver, in the CRTC enable and disable operations. This allows the
    encoders PM state to be handled separately from the DISPC, and in
    particular at times when the DISPC may not be available (for instance at
    probe due to the DSS probe being deferred, or at remove time du to the
    DISPC being already removed).
    
    Fixes: edb715dffdee ("drm/omap: dss: dsi: Move initialization code from bind to probe")
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181110111654.4387-5-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 62928ec0e7db..caffc547ef97 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -350,11 +350,14 @@ static void omap_crtc_arm_event(struct drm_crtc *crtc)
 static void omap_crtc_atomic_enable(struct drm_crtc *crtc,
 				    struct drm_crtc_state *old_state)
 {
+	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	int ret;
 
 	DBG("%s", omap_crtc->name);
 
+	priv->dispc_ops->runtime_get(priv->dispc);
+
 	spin_lock_irq(&crtc->dev->event_lock);
 	drm_crtc_vblank_on(crtc);
 	ret = drm_crtc_vblank_get(crtc);
@@ -367,6 +370,7 @@ static void omap_crtc_atomic_enable(struct drm_crtc *crtc,
 static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
 				     struct drm_crtc_state *old_state)
 {
+	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
 	DBG("%s", omap_crtc->name);
@@ -379,6 +383,8 @@ static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
 	spin_unlock_irq(&crtc->dev->event_lock);
 
 	drm_crtc_vblank_off(crtc);
+
+	priv->dispc_ops->runtime_put(priv->dispc);
 }
 
 static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,

commit 8e9c1c6676ea3d0dc60d84ee9a69984a4bcf859f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 18:32:16 2018 +0300

    drm/omap: Move bus flag hack to encoder implementation
    
    The bus flags stored in omap_dss_device instances are used to fixup the
    video mode before setting it, to honour constraints that can't be
    expressed through drm_display_mode. The fixup occurs in the CRTC mode
    set operation and the resulting video mode is stored internally in the
    CRTC. It is then used next by omap_encoder_enable() to apply mode fixups
    for the omap_dss_device instances in omap_encoder_update().
    
    Move the hack to the omap_encoder_update() function right before
    applying the omap_dss_device fixups, in order to group all fixups
    together.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 39693dfe54af..62928ec0e7db 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -420,8 +420,6 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	struct videomode *vm = &omap_crtc->vm;
-	struct omap_dss_device *dssdev;
 
 	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
 	    omap_crtc->name, mode->base.id, mode->name,
@@ -430,45 +428,7 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
 	    mode->type, mode->flags);
 
-	drm_display_mode_to_videomode(mode, vm);
-
-	/*
-	 * HACK: This fixes the vm flags.
-	 * struct drm_display_mode does not contain the VSYNC/HSYNC/DE flags
-	 * and they get lost when converting back and forth between
-	 * struct drm_display_mode and struct videomode. The hack below
-	 * goes and fetches the missing flags from the panel drivers.
-	 *
-	 * A better solution is to use DRM's bus-flags through the whole driver.
-	 */
-
-	for (dssdev = omap_crtc->pipe->output; dssdev; dssdev = dssdev->next) {
-		unsigned long bus_flags = dssdev->bus_flags;
-
-		if (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |
-				   DISPLAY_FLAGS_DE_HIGH))) {
-			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
-				vm->flags |= DISPLAY_FLAGS_DE_LOW;
-			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
-				vm->flags |= DISPLAY_FLAGS_DE_HIGH;
-		}
-
-		if (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
-				   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
-				vm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
-				vm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
-		}
-
-		if (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
-				   DISPLAY_FLAGS_SYNC_NEGEDGE))) {
-			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
-				vm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
-			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
-				vm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
-		}
-	}
+	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit b4935e3a3cfa456b356e9714e75513be672c227e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jun 6 15:20:01 2018 +0300

    drm/omap: Store bus flags in the omap_dss_device structure
    
    Source components in the display pipeline need to configure their output
    signals polarities and clock driving edge based on the requirements of
    the sink component.
    
    Those requirements are currently shared across the whole pipeline in the
    flags of a videomode structure, instead of being local to each bus. This
    both prevents multiple buses from having different configurations (when
    the hardware supports it), and makes it difficult to move from videomode
    to drm_display_mode as the latter doesn't contain bus polarities and
    clock edge flags.
    
    Add a bus_flags field to the omap_dss_device structure and move the
    DISPLAY_FLAGS_DE_(LOW|HIGH), DISPLAY_FLAGS_PIXDATA_(POS|NEG)EDGE and
    DISPLAY_FLAGS_SYNC_(POS|NEG)EDGE videomode flags to bus_flags in all
    external encoders, connectors and panels. The videomode flags are still
    used internally for internal encoders, this will be addressed in a
    second step.
    
    The related videomode flags in the default mode of the DVI connector can
    simply be dropped, as they are always overridden by the TFP410 driver.
    Note that this results in both the DISPLAY_FLAGS_SYNC_POSEDGE and
    DISPLAY_FLAGS_SYNC_NEGEDGE flags being set, which is invalid, but only
    the former is tested for when programming the DISPC, so the DVI
    connector flags are effectively overridden by the TFP410 flags.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 6e7a777907f5..39693dfe54af 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -419,12 +419,9 @@ static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_dss_device *display = omap_crtc->pipe->display;
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	const u32 flags_mask = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_DE_LOW |
-		DISPLAY_FLAGS_PIXDATA_POSEDGE | DISPLAY_FLAGS_PIXDATA_NEGEDGE |
-		DISPLAY_FLAGS_SYNC_POSEDGE | DISPLAY_FLAGS_SYNC_NEGEDGE;
-	struct videomode vm = {0};
+	struct videomode *vm = &omap_crtc->vm;
+	struct omap_dss_device *dssdev;
 
 	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
 	    omap_crtc->name, mode->base.id, mode->name,
@@ -433,7 +430,7 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
 	    mode->type, mode->flags);
 
-	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
+	drm_display_mode_to_videomode(mode, vm);
 
 	/*
 	 * HACK: This fixes the vm flags.
@@ -442,13 +439,36 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	 * struct drm_display_mode and struct videomode. The hack below
 	 * goes and fetches the missing flags from the panel drivers.
 	 *
-	 * Correct solution would be to use DRM's bus-flags, but that's not
-	 * easily possible before the omapdrm's panel/encoder driver model
-	 * has been changed to the DRM model.
+	 * A better solution is to use DRM's bus-flags through the whole driver.
 	 */
 
-	display->ops->get_timings(display, &vm);
-	omap_crtc->vm.flags |= vm.flags & flags_mask;
+	for (dssdev = omap_crtc->pipe->output; dssdev; dssdev = dssdev->next) {
+		unsigned long bus_flags = dssdev->bus_flags;
+
+		if (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |
+				   DISPLAY_FLAGS_DE_HIGH))) {
+			if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+				vm->flags |= DISPLAY_FLAGS_DE_LOW;
+			else if (bus_flags & DRM_BUS_FLAG_DE_HIGH)
+				vm->flags |= DISPLAY_FLAGS_DE_HIGH;
+		}
+
+		if (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
+				   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)
+				vm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE)
+				vm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+		}
+
+		if (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |
+				   DISPLAY_FLAGS_SYNC_NEGEDGE))) {
+			if (bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE)
+				vm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;
+			else if (bus_flags & DRM_BUS_FLAG_SYNC_NEGEDGE)
+				vm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;
+		}
+	}
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit 70f9cbfc56a3239ff65796e024b4bbf653d1e0ba
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 31 23:04:30 2018 +0300

    drm/omap: Get from CRTC to display device directly
    
    The CRTC mode set implementation needs to access the omap_dss_device for
    the pipeline display. To do so, it iterates over all pipelines to find
    the one that contains an encoder corresponding to the CRTC, and request
    the display device from the encoder. That's a very complicated dance
    when the CRTC has a direct pipeline pointer already, and the pipeline
    contains a pointer to the display device.
    
    Replace the convoluted code with direct access.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 197d05312306..6e7a777907f5 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -419,12 +419,12 @@ static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_dss_device *display = omap_crtc->pipe->display;
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	struct omap_drm_private *priv = crtc->dev->dev_private;
 	const u32 flags_mask = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_DE_LOW |
 		DISPLAY_FLAGS_PIXDATA_POSEDGE | DISPLAY_FLAGS_PIXDATA_NEGEDGE |
 		DISPLAY_FLAGS_SYNC_POSEDGE | DISPLAY_FLAGS_SYNC_NEGEDGE;
-	unsigned int i;
+	struct videomode vm = {0};
 
 	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
 	    omap_crtc->name, mode->base.id, mode->name,
@@ -447,25 +447,8 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	 * has been changed to the DRM model.
 	 */
 
-	for (i = 0; i < priv->num_pipes; ++i) {
-		struct drm_encoder *encoder = priv->pipes[i].encoder;
-
-		if (encoder->crtc == crtc) {
-			struct omap_dss_device *dssdev;
-
-			dssdev = omap_encoder_get_dssdev(encoder);
-
-			if (dssdev) {
-				struct videomode vm = {0};
-
-				dssdev->ops->get_timings(dssdev, &vm);
-
-				omap_crtc->vm.flags |= vm.flags & flags_mask;
-			}
-
-			break;
-		}
-	}
+	display->ops->get_timings(display, &vm);
+	omap_crtc->vm.flags |= vm.flags & flags_mask;
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit 83910ad3f51fbc0e6546b60aafa90697b5127a8a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 1 19:45:01 2018 +0300

    drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops
    
    omap_dss_device instances have two ops structures, omap_dss_driver and
    omap_dss_device_ops. The former is used for devices at the end of the
    pipeline (a.k.a. display devices), and the latter for intermediate
    devices.
    
    Having two sets of operations isn't convenient as code that iterates
    over omap_dss_device instances need to take them both into account.
    There's currently a reasonably small amount of such code, but more will
    be introduced to move the driver away from recursive operations. To
    simplify current and future code, move all operations that are not
    specific to the display device to the omap_dss_device_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 80498dcde6d7..197d05312306 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -458,7 +458,7 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 			if (dssdev) {
 				struct videomode vm = {0};
 
-				dssdev->driver->get_timings(dssdev, &vm);
+				dssdev->ops->get_timings(dssdev, &vm);
 
 				omap_crtc->vm.flags |= vm.flags & flags_mask;
 			}

commit 43f7078f6b6f8fed8edfbbdeff83e276306e5e6e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:34:53 2018 +0200

    drm/omap: dss: Remove the dss_mgr_(dis)connect() operations
    
    The dss_mgr .connect() and .disconnect() are implemented as no-op in
    omapdrm. The operations are unneeded, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7f837697e76c..80498dcde6d7 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -110,19 +110,6 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
  */
 
 /* we can probably ignore these until we support command-mode panels: */
-static int omap_crtc_dss_connect(struct omap_drm_private *priv,
-		enum omap_channel channel,
-		struct omap_dss_device *dst)
-{
-	return 0;
-}
-
-static void omap_crtc_dss_disconnect(struct omap_drm_private *priv,
-		enum omap_channel channel,
-		struct omap_dss_device *dst)
-{
-}
-
 static void omap_crtc_dss_start_update(struct omap_drm_private *priv,
 				       enum omap_channel channel)
 {
@@ -254,8 +241,6 @@ static void omap_crtc_dss_unregister_framedone(
 }
 
 static const struct dss_mgr_ops mgr_ops = {
-	.connect = omap_crtc_dss_connect,
-	.disconnect = omap_crtc_dss_disconnect,
 	.start_update = omap_crtc_dss_start_update,
 	.enable = omap_crtc_dss_enable,
 	.disable = omap_crtc_dss_disable,

commit 0f37938c7c432c7737d85940475bcbd3c362447e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:28:18 2018 +0200

    drm/omap: Set dispc_channel_connect from DSS output connect handlers
    
    The omap_dss_device.dispc_channel_connect field is used by DSS outputs
    to fail the .enable() operation if they're not connected. Set the field
    directly from the (dis)connect handlers of the DSS outputs instead of
    going through the CRTC dss_mgr operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 90917d040ddb..7f837697e76c 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -114,8 +114,6 @@ static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	dst->dispc_channel_connected = true;
-
 	return 0;
 }
 
@@ -123,7 +121,6 @@ static void omap_crtc_dss_disconnect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	dst->dispc_channel_connected = false;
 }
 
 static void omap_crtc_dss_start_update(struct omap_drm_private *priv,

commit d25a7d67465faa28062323d46a1d755d3ae6abc6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:22:10 2018 +0200

    drm/omap: Remove supported output check in CRTC connect handler
    
    The CRTC connect handler checks whether the DSS output supports the
    DISPC channel assigned to it. As the channel is assigned to the output
    by the output driver a failure there could only result from a driver
    bug. All the output drivers have been verified and they are always
    assigned a DISPC channel that is supported on the SoC they run on. The
    check can thus be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5a56c8e02179..90917d040ddb 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -114,12 +114,6 @@ static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	const struct dispc_ops *dispc_ops = priv->dispc_ops;
-	struct dispc_device *dispc = priv->dispc;
-
-	if (!(dispc_ops->mgr_get_supported_outputs(dispc, channel) & dst->id))
-		return -EINVAL;
-
 	dst->dispc_channel_connected = true;
 
 	return 0;

commit 67dfd2d3d0c24217e12d82909f88dfadb04f34bb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:38:21 2018 +0200

    drm/omap: Remove omap_crtc_output global array
    
    The omap_crtc_output global array is used to look up the DSS output
    device by channel. We can replace that by accessing the output device
    from the pipeline if we store the pipeline pointer in the omap_crtc
    structure.
    
    The global array is also used to protect against double connection of an
    output. This can't happen with the connection handling mechanism going
    from DSS outputs to displays. We can thus drop that check, allowing
    removal of the global array.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 9742d9f49a7c..5a56c8e02179 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -41,6 +41,7 @@ struct omap_crtc {
 	struct drm_crtc base;
 
 	const char *name;
+	struct omap_drm_pipeline *pipe;
 	enum omap_channel channel;
 
 	struct videomode vm;
@@ -108,9 +109,6 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
  * job of sequencing the setup of the video pipe in the proper order
  */
 
-/* ovl-mgr-id -> crtc */
-static struct omap_dss_device *omap_crtc_output[8];
-
 /* we can probably ignore these until we support command-mode panels: */
 static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 		enum omap_channel channel,
@@ -119,13 +117,9 @@ static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 	const struct dispc_ops *dispc_ops = priv->dispc_ops;
 	struct dispc_device *dispc = priv->dispc;
 
-	if (omap_crtc_output[channel])
-		return -EINVAL;
-
 	if (!(dispc_ops->mgr_get_supported_outputs(dispc, channel) & dst->id))
 		return -EINVAL;
 
-	omap_crtc_output[channel] = dst;
 	dst->dispc_channel_connected = true;
 
 	return 0;
@@ -135,7 +129,6 @@ static void omap_crtc_dss_disconnect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	omap_crtc_output[channel] = NULL;
 	dst->dispc_channel_connected = false;
 }
 
@@ -158,7 +151,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	if (WARN_ON(omap_crtc->enabled == enable))
 		return;
 
-	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
+	if (omap_crtc->pipe->output->output_type == OMAP_DISPLAY_TYPE_HDMI) {
 		priv->dispc_ops->mgr_enable(priv->dispc, channel, enable);
 		omap_crtc->enabled = enable;
 		return;
@@ -716,6 +709,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	init_waitqueue_head(&omap_crtc->pending_wait);
 
+	omap_crtc->pipe = pipe;
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];
 

commit e48f9f16a16a6ee1befda6d8e5486234ac3a5162
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:01:33 2018 +0200

    drm/omap: Store CRTC lookup by channel table in omap_drm_private
    
    The omap_crtcs global array is used to store pointers to omap_crtc
    indexed by DISPC channel number, in order to look them up in the dss_mgr
    operations. Store the information in the omap_drm_private structure in
    the form of an array of omap_drm_pipeline pointers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f5bdb8de98f4..9742d9f49a7c 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -109,7 +109,6 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
  */
 
 /* ovl-mgr-id -> crtc */
-static struct omap_crtc *omap_crtcs[8];
 static struct omap_dss_device *omap_crtc_output[8];
 
 /* we can probably ignore these until we support command-mode panels: */
@@ -215,7 +214,8 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 static int omap_crtc_dss_enable(struct omap_drm_private *priv,
 				enum omap_channel channel)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
 	priv->dispc_ops->mgr_set_timings(priv->dispc, omap_crtc->channel,
 					 &omap_crtc->vm);
@@ -227,7 +227,8 @@ static int omap_crtc_dss_enable(struct omap_drm_private *priv,
 static void omap_crtc_dss_disable(struct omap_drm_private *priv,
 				  enum omap_channel channel)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
 	omap_crtc_set_enabled(&omap_crtc->base, false);
 }
@@ -236,7 +237,9 @@ static void omap_crtc_dss_set_timings(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		const struct videomode *vm)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
 	DBG("%s", omap_crtc->name);
 	omap_crtc->vm = *vm;
 }
@@ -245,7 +248,8 @@ static void omap_crtc_dss_set_lcd_config(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		const struct dss_lcd_mgr_config *config)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct drm_crtc *crtc = priv->channels[channel]->crtc;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
 	DBG("%s", omap_crtc->name);
 	priv->dispc_ops->mgr_set_lcd_config(priv->dispc, omap_crtc->channel,
@@ -681,8 +685,6 @@ static const char *channel_names[] = {
 
 void omap_crtc_pre_init(struct omap_drm_private *priv)
 {
-	memset(omap_crtcs, 0, sizeof(omap_crtcs));
-
 	dss_install_mgr_ops(priv->dss, &mgr_ops, priv);
 }
 
@@ -706,10 +708,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	DBG("%s", channel_names[channel]);
 
-	/* Multiple displays on same channel is not allowed */
-	if (WARN_ON(omap_crtcs[channel] != NULL))
-		return ERR_PTR(-EINVAL);
-
 	omap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);
 	if (!omap_crtc)
 		return ERR_PTR(-ENOMEM);
@@ -748,7 +746,5 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	omap_plane_install_properties(crtc->primary, &crtc->base);
 
-	omap_crtcs[channel] = omap_crtc;
-
 	return crtc;
 }

commit 00b30e794ffc3bd8f4c6dc357fe7e881ae6e5373
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:37:25 2018 +0200

    drm/omap: Pass pipe pointer to omap_crtc_init()
    
    Replace the dss display device pointer by a pipe pointer that will allow
    the omap_crtc_init() function to access both the display and the DSS
    output. As a result we can remove the omapdss_device_get_dispc_channel()
    function that is now unneeded.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f5bf553a862f..f5bdb8de98f4 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -693,7 +693,8 @@ void omap_crtc_pre_uninit(struct omap_drm_private *priv)
 
 /* initialize crtc */
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
-		struct drm_plane *plane, struct omap_dss_device *dssdev)
+				struct omap_drm_pipeline *pipe,
+				struct drm_plane *plane)
 {
 	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_crtc *crtc = NULL;
@@ -701,7 +702,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	enum omap_channel channel;
 	int ret;
 
-	channel = omapdss_device_get_dispc_channel(dssdev);
+	channel = pipe->output->dispc_channel;
 
 	DBG("%s", channel_names[channel]);
 
@@ -724,7 +725,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {
 		dev_err(dev->dev, "%s(): could not init crtc for: %s\n",
-			__func__, dssdev->name);
+			__func__, pipe->display->name);
 		kfree(omap_crtc);
 		return ERR_PTR(ret);
 	}

commit 2ee767922e1bc7ede9ceb7aed9a14141480836a7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Mar 5 15:02:22 2018 +0200

    drm/omap: Group CRTC, encoder, connector and dssdev in a structure
    
    Create an omap_drm_pipeline structure to model display pipelines, made
    of a CRTC, an encoder, a connector and a DSS display device. This allows
    grouping related parameters together instead of storing them in
    independent arrays and thus improves code readability.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c5f1915aef67..f5bf553a862f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -474,8 +474,8 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	 * has been changed to the DRM model.
 	 */
 
-	for (i = 0; i < priv->num_encoders; ++i) {
-		struct drm_encoder *encoder = priv->encoders[i];
+	for (i = 0; i < priv->num_pipes; ++i) {
+		struct drm_encoder *encoder = priv->pipes[i].encoder;
 
 		if (encoder->crtc == crtc) {
 			struct omap_dss_device *dssdev;

commit 5c718e015a0f1280440f90ebf1c18e2b98a102e4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 03:11:49 2018 +0200

    drm/omap: dss: Modify omapdss_find_output_from_display() to return channel
    
    The omapdss_find_output_from_display() function is only used to retrieve
    the dispc channel corresponding to the display. Return the dispc channel
    directly, and rename the function to omapdss_device_get_dispc_channel()
    to match its new purpose.
    
    The dssdev->id check is removed as the dssdev is guaranteed to be an
    output and have a non-zero id, as proved by the lack of crash despite
    the caller never checking the returned pointer before dereferencing it.
    
    As the function is not specific to outputs anymore, move it from
    output.c to base.c.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 4ddc4ed18b47..c5f1915aef67 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -699,12 +699,9 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	struct drm_crtc *crtc = NULL;
 	struct omap_crtc *omap_crtc;
 	enum omap_channel channel;
-	struct omap_dss_device *out;
 	int ret;
 
-	out = omapdss_find_output_from_display(dssdev);
-	channel = out->dispc_channel;
-	omapdss_device_put(out);
+	channel = omapdss_device_get_dispc_channel(dssdev);
 
 	DBG("%s", channel_names[channel]);
 

commit 845417b3b3b0d6c1694394ae6c3e07b281b89f82
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 03:05:10 2018 +0200

    drm/omap: dss: Move DSS mgr ops and private data to dss_device
    
    The DSS manager ops and private data pointer are specific to a DSS
    instance. Store them in the dss_device structure instead of global
    variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e18ca6cdc0d6..4ddc4ed18b47 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -683,12 +683,12 @@ void omap_crtc_pre_init(struct omap_drm_private *priv)
 {
 	memset(omap_crtcs, 0, sizeof(omap_crtcs));
 
-	dss_install_mgr_ops(&mgr_ops, priv);
+	dss_install_mgr_ops(priv->dss, &mgr_ops, priv);
 }
 
-void omap_crtc_pre_uninit(void)
+void omap_crtc_pre_uninit(struct omap_drm_private *priv)
 {
-	dss_uninstall_mgr_ops();
+	dss_uninstall_mgr_ops(priv->dss);
 }
 
 /* initialize crtc */

commit c1dfe721e0966947019c43b65f2837c591fdcb3c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 02:43:45 2018 +0200

    drm/omap: dss: Move and rename omap_dss_(get|put)_device()
    
    The functions operate on any omap_dss_device, move them from display.c
    to base.c. While at it rename them to match the naming of the other
    functions operating on struct omap_dss_device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 6c4d40b824e4..e18ca6cdc0d6 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -704,7 +704,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	out = omapdss_find_output_from_display(dssdev);
 	channel = out->dispc_channel;
-	omap_dss_put_device(out);
+	omapdss_device_put(out);
 
 	DBG("%s", channel_names[channel]);
 

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index ffe4f698d291..6c4d40b824e4 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -117,10 +117,13 @@ static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
+	const struct dispc_ops *dispc_ops = priv->dispc_ops;
+	struct dispc_device *dispc = priv->dispc;
+
 	if (omap_crtc_output[channel])
 		return -EINVAL;
 
-	if (!(priv->dispc_ops->mgr_get_supported_outputs(channel) & dst->id))
+	if (!(dispc_ops->mgr_get_supported_outputs(dispc, channel) & dst->id))
 		return -EINVAL;
 
 	omap_crtc_output[channel] = dst;
@@ -157,7 +160,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 		return;
 
 	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
-		priv->dispc_ops->mgr_enable(channel, enable);
+		priv->dispc_ops->mgr_enable(priv->dispc, channel, enable);
 		omap_crtc->enabled = enable;
 		return;
 	}
@@ -170,8 +173,9 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 		omap_crtc->ignore_digit_sync_lost = true;
 	}
 
-	framedone_irq = priv->dispc_ops->mgr_get_framedone_irq(channel);
-	vsync_irq = priv->dispc_ops->mgr_get_vsync_irq(channel);
+	framedone_irq = priv->dispc_ops->mgr_get_framedone_irq(priv->dispc,
+							       channel);
+	vsync_irq = priv->dispc_ops->mgr_get_vsync_irq(priv->dispc, channel);
 
 	if (enable) {
 		wait = omap_irq_wait_init(dev, vsync_irq, 1);
@@ -191,7 +195,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 			wait = omap_irq_wait_init(dev, vsync_irq, 2);
 	}
 
-	priv->dispc_ops->mgr_enable(channel, enable);
+	priv->dispc_ops->mgr_enable(priv->dispc, channel, enable);
 	omap_crtc->enabled = enable;
 
 	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
@@ -213,7 +217,8 @@ static int omap_crtc_dss_enable(struct omap_drm_private *priv,
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 
-	priv->dispc_ops->mgr_set_timings(omap_crtc->channel, &omap_crtc->vm);
+	priv->dispc_ops->mgr_set_timings(priv->dispc, omap_crtc->channel,
+					 &omap_crtc->vm);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
 
 	return 0;
@@ -243,7 +248,8 @@ static void omap_crtc_dss_set_lcd_config(struct omap_drm_private *priv,
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 
 	DBG("%s", omap_crtc->name);
-	priv->dispc_ops->mgr_set_lcd_config(omap_crtc->channel, config);
+	priv->dispc_ops->mgr_set_lcd_config(priv->dispc, omap_crtc->channel,
+					    config);
 }
 
 static int omap_crtc_dss_register_framedone(
@@ -300,7 +306,7 @@ void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 	 * If the dispc is busy we're racing the flush operation. Try again on
 	 * the next vblank interrupt.
 	 */
-	if (priv->dispc_ops->mgr_go_busy(omap_crtc->channel)) {
+	if (priv->dispc_ops->mgr_go_busy(priv->dispc, omap_crtc->channel)) {
 		spin_unlock(&crtc->dev->event_lock);
 		return;
 	}
@@ -337,7 +343,7 @@ static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
 	info.partial_alpha_enabled = false;
 	info.cpr_enable = false;
 
-	priv->dispc_ops->mgr_setup(omap_crtc->channel, &info);
+	priv->dispc_ops->mgr_setup(priv->dispc, omap_crtc->channel, &info);
 }
 
 /* -----------------------------------------------------------------------------
@@ -537,7 +543,8 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 			length = crtc->state->gamma_lut->length /
 				sizeof(*lut);
 		}
-		priv->dispc_ops->mgr_set_gamma(omap_crtc->channel, lut, length);
+		priv->dispc_ops->mgr_set_gamma(priv->dispc, omap_crtc->channel,
+					       lut, length);
 	}
 
 	omap_crtc_write_crtc_properties(crtc);
@@ -552,7 +559,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	WARN_ON(ret != 0);
 
 	spin_lock_irq(&crtc->dev->event_lock);
-	priv->dispc_ops->mgr_go(omap_crtc->channel);
+	priv->dispc_ops->mgr_go(priv->dispc, omap_crtc->channel);
 	omap_crtc_arm_event(crtc);
 	spin_unlock_irq(&crtc->dev->event_lock);
 }
@@ -734,7 +741,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	 * extracted with dispc_mgr_gamma_size(). If it returns 0
 	 * gamma table is not supprted.
 	 */
-	if (priv->dispc_ops->mgr_gamma_size(channel)) {
+	if (priv->dispc_ops->mgr_gamma_size(priv->dispc, channel)) {
 		unsigned int gamma_lut_size = 256;
 
 		drm_crtc_enable_color_mgmt(crtc, 0, false, gamma_lut_size);

commit d3541ca81dbddeefa0c42df448211a9dbaef0843
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:41 2018 +0200

    drm: omapdrm: dss: Store dispc ops in dss_device structure
    
    Remove the global dispc ops variable by storing it in the dss_device
    structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 61d8d17a4243..ffe4f698d291 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -117,12 +117,10 @@ static int omap_crtc_dss_connect(struct omap_drm_private *priv,
 		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	const struct dispc_ops *dispc_ops = dispc_get_ops();
-
 	if (omap_crtc_output[channel])
 		return -EINVAL;
 
-	if ((dispc_ops->mgr_get_supported_outputs(channel) & dst->id) == 0)
+	if (!(priv->dispc_ops->mgr_get_supported_outputs(channel) & dst->id))
 		return -EINVAL;
 
 	omap_crtc_output[channel] = dst;

commit 64cb81797f8b56e1806d67024de561b60944d1a5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:39 2018 +0200

    drm: omapdrm: dss: Pass omap_drm_private pointer to dss_mgr_ops
    
    The dss_mgr_ops operations implemented by the omapdrm side have to look
    up the omap_crtc objects from global variables as they are only passed a
    channel number. In order to remove global variables in the omapdrm
    driver pass the omap_drm_private pointer to the dss_mgr_ops. This
    requires storing a pointer to the omap_drm_private in a global variable
    on the DSS side as a temporary measure until the omapdrm and omapdss
    drivers get merged.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 95615a86e9f7..61d8d17a4243 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -113,7 +113,8 @@ static struct omap_crtc *omap_crtcs[8];
 static struct omap_dss_device *omap_crtc_output[8];
 
 /* we can probably ignore these until we support command-mode panels: */
-static int omap_crtc_dss_connect(enum omap_channel channel,
+static int omap_crtc_dss_connect(struct omap_drm_private *priv,
+		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
 	const struct dispc_ops *dispc_ops = dispc_get_ops();
@@ -130,14 +131,16 @@ static int omap_crtc_dss_connect(enum omap_channel channel,
 	return 0;
 }
 
-static void omap_crtc_dss_disconnect(enum omap_channel channel,
+static void omap_crtc_dss_disconnect(struct omap_drm_private *priv,
+		enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
 	omap_crtc_output[channel] = NULL;
 	dst->dispc_channel_connected = false;
 }
 
-static void omap_crtc_dss_start_update(enum omap_channel channel)
+static void omap_crtc_dss_start_update(struct omap_drm_private *priv,
+				       enum omap_channel channel)
 {
 }
 
@@ -207,10 +210,10 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 }
 
 
-static int omap_crtc_dss_enable(enum omap_channel channel)
+static int omap_crtc_dss_enable(struct omap_drm_private *priv,
+				enum omap_channel channel)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
-	struct omap_drm_private *priv = omap_crtc->base.dev->dev_private;
 
 	priv->dispc_ops->mgr_set_timings(omap_crtc->channel, &omap_crtc->vm);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
@@ -218,14 +221,16 @@ static int omap_crtc_dss_enable(enum omap_channel channel)
 	return 0;
 }
 
-static void omap_crtc_dss_disable(enum omap_channel channel)
+static void omap_crtc_dss_disable(struct omap_drm_private *priv,
+				  enum omap_channel channel)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 
 	omap_crtc_set_enabled(&omap_crtc->base, false);
 }
 
-static void omap_crtc_dss_set_timings(enum omap_channel channel,
+static void omap_crtc_dss_set_timings(struct omap_drm_private *priv,
+		enum omap_channel channel,
 		const struct videomode *vm)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
@@ -233,25 +238,25 @@ static void omap_crtc_dss_set_timings(enum omap_channel channel,
 	omap_crtc->vm = *vm;
 }
 
-static void omap_crtc_dss_set_lcd_config(enum omap_channel channel,
+static void omap_crtc_dss_set_lcd_config(struct omap_drm_private *priv,
+		enum omap_channel channel,
 		const struct dss_lcd_mgr_config *config)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
-	struct omap_drm_private *priv = omap_crtc->base.dev->dev_private;
 
 	DBG("%s", omap_crtc->name);
 	priv->dispc_ops->mgr_set_lcd_config(omap_crtc->channel, config);
 }
 
 static int omap_crtc_dss_register_framedone(
-		enum omap_channel channel,
+		struct omap_drm_private *priv, enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
 	return 0;
 }
 
 static void omap_crtc_dss_unregister_framedone(
-		enum omap_channel channel,
+		struct omap_drm_private *priv, enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
 }
@@ -669,11 +674,11 @@ static const char *channel_names[] = {
 	[OMAP_DSS_CHANNEL_LCD3] = "lcd3",
 };
 
-void omap_crtc_pre_init(void)
+void omap_crtc_pre_init(struct omap_drm_private *priv)
 {
 	memset(omap_crtcs, 0, sizeof(omap_crtcs));
 
-	dss_install_mgr_ops(&mgr_ops);
+	dss_install_mgr_ops(&mgr_ops, priv);
 }
 
 void omap_crtc_pre_uninit(void)

commit dfe9cfccb264889b025e443ca20e2fbb401295c2
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:33 2018 +0200

    drm: omapdrm: Use kernel integer types
    
    The standard kernel integer types are [us]{8,16,32}. Use them instead of
    the u?int{8,16,32}_t types.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 1b8154e58d18..95615a86e9f7 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -272,7 +272,7 @@ static const struct dss_mgr_ops mgr_ops = {
  * Setup, Flush and Page Flip
  */
 
-void omap_crtc_error_irq(struct drm_crtc *crtc, uint32_t irqstatus)
+void omap_crtc_error_irq(struct drm_crtc *crtc, u32 irqstatus)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
@@ -492,7 +492,7 @@ static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 	struct drm_plane_state *pri_state;
 
 	if (state->color_mgmt_changed && state->gamma_lut) {
-		uint length = state->gamma_lut->length /
+		unsigned int length = state->gamma_lut->length /
 			sizeof(struct drm_color_lut);
 
 		if (length < 2)
@@ -526,7 +526,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	if (crtc->state->color_mgmt_changed) {
 		struct drm_color_lut *lut = NULL;
-		uint length = 0;
+		unsigned int length = 0;
 
 		if (crtc->state->gamma_lut) {
 			lut = (struct drm_color_lut *)
@@ -557,7 +557,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state,
 					 struct drm_property *property,
-					 uint64_t val)
+					 u64 val)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct drm_plane_state *plane_state;
@@ -585,7 +585,7 @@ static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 					 const struct drm_crtc_state *state,
 					 struct drm_property *property,
-					 uint64_t *val)
+					 u64 *val)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc_state *omap_state = to_omap_crtc_state(state);
@@ -732,7 +732,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	 * gamma table is not supprted.
 	 */
 	if (priv->dispc_ops->mgr_gamma_size(channel)) {
-		uint gamma_lut_size = 256;
+		unsigned int gamma_lut_size = 256;
 
 		drm_crtc_enable_color_mgmt(crtc, 0, false, gamma_lut_size);
 		drm_mode_crtc_set_gamma_size(crtc, gamma_lut_size);

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index ae2e16ed3874..1b8154e58d18 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -1,7 +1,5 @@
 /*
- * drivers/gpu/drm/omapdrm/omap_crtc.c
- *
- * Copyright (C) 2011 Texas Instruments
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify it

commit a7631c4b9846a433c06422c6cc64a8a5025071a2
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Nov 30 14:12:37 2017 +0200

    drm/omap: Filter displays mode based on bandwidth limit
    
    If we have memory bandwidth limit configured, reject the modes which would
    require more bandwidth than the limit if it is used with one full
    resolution plane (most common use case).
    
    This filtering is not providing full protection as it is possible that
    application would pick smaller crtc resolution with high resolution planes
    and down scaling, or can enable more smaller planes where the sum of their
    bandwidth need would be higher than the limit.
    
    This patch only allows us to filter out modes which would need more
    bandwidth if they were used with one full screen plane.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index cc85c16cbc2a..ae2e16ed3874 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -23,6 +23,7 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_mode.h>
 #include <drm/drm_plane_helper.h>
+#include <linux/math64.h>
 
 #include "omap_drv.h"
 
@@ -400,6 +401,41 @@ static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
 	drm_crtc_vblank_off(crtc);
 }
 
+static enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,
+					const struct drm_display_mode *mode)
+{
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+
+	/* Check for bandwidth limit */
+	if (priv->max_bandwidth) {
+		/*
+		 * Estimation for the bandwidth need of a given mode with one
+		 * full screen plane:
+		 * bandwidth = resolution * 32bpp * (pclk / (vtotal * htotal))
+		 *					^^ Refresh rate ^^
+		 *
+		 * The interlaced mode is taken into account by using the
+		 * pixelclock in the calculation.
+		 *
+		 * The equation is rearranged for 64bit arithmetic.
+		 */
+		uint64_t bandwidth = mode->clock * 1000;
+		unsigned int bpp = 4;
+
+		bandwidth = bandwidth * mode->hdisplay * mode->vdisplay * bpp;
+		bandwidth = div_u64(bandwidth, mode->htotal * mode->vtotal);
+
+		/*
+		 * Reject modes which would need more bandwidth if used with one
+		 * full resolution plane (most common use case).
+		 */
+		if (priv->max_bandwidth < bandwidth)
+			return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -621,6 +657,7 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.atomic_flush = omap_crtc_atomic_flush,
 	.atomic_enable = omap_crtc_atomic_enable,
 	.atomic_disable = omap_crtc_atomic_disable,
+	.mode_valid = omap_crtc_mode_valid,
 };
 
 /* -----------------------------------------------------------------------------

commit 2419672f4c96ca678a95d0f733f44d3ee036b5c8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Aug 11 23:16:06 2017 +0300

    drm/omap: Potential NULL deref in omap_crtc_duplicate_state()
    
    If the kmalloc() fails then we dereference "state" when we set
    "state->zpos".
    
    Fixes: 3dfeb631a15d ("drm/omap: Rework the rotation-on-crtc hack")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 400d0d2f6790..cc85c16cbc2a 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -589,8 +589,10 @@ omap_crtc_duplicate_state(struct drm_crtc *crtc)
 	current_state = to_omap_crtc_state(crtc->state);
 
 	state = kmalloc(sizeof(*state), GFP_KERNEL);
-	if (state)
-		__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);
+	if (!state)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);
 
 	state->zpos = current_state->zpos;
 	state->rotation = current_state->rotation;

commit b6715570c10de945a8f24693a1a76be6896587f9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:18 2017 +0200

    drm: Nuke drm_atomic_helper_crtc_set_property
    
    It's dead code because this is now handled in the core.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Eric Engestrom <eric@engestrom.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: "Ville Syrjälä" <ville.syrjala@linux.intel.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Philippe Cornu <philippe.cornu@st.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Sushmita Susheelendra <ssusheel@codeaurora.org>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-5-daniel.vetter@ffwll.ch
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Acked-by: Philippe Cornu <philippe.cornu@st.com>
    Tested-by: Philippe Cornu <philippe.cornu@st.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 09e05e002703..400d0d2f6790 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -604,7 +604,6 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.destroy = omap_crtc_destroy,
 	.page_flip = drm_atomic_helper_page_flip,
 	.gamma_set = drm_atomic_helper_legacy_gamma_set,
-	.set_property = drm_atomic_helper_crtc_set_property,
 	.atomic_duplicate_state = omap_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
 	.atomic_set_property = omap_crtc_atomic_set_property,

commit 3dfeb631a15db17f187f1e5cc522207f46506611
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Aug 7 12:20:06 2017 +0200

    drm/omap: Rework the rotation-on-crtc hack
    
    I want/need to rework the core property handling, and this hack is
    getting in the way. But since it's a non-standard propety only used by
    legacy userspace we know that this will only every be called from
    ioctl code. And never on some other free-standing state struct, where
    this old hack wouldn't work either.
    
    v2: don't forget zorder and get_property!
    
    v3: Shadow the legacy state to avoid locking issues in get_property
    (Maarten).
    
    v4: Review from Laurent
    - Move struct omap_crtc_state into omap_crtc.c
    - Clean up comments.
    - Don't forget to copy the shadowed state over on duplicate.
    
    v5: Don't forget to update the reset handler (Maarten).
    v6: Update omap_crtc_state shadow values in omap_crtc_atomic_check (Maarten).
    v7:
    - Fix get_property to return 0 and set value in *val (Maarten).
    - Update comment in set_property for changes in v6 (Maarten).
    
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com> (v4)
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com> (v4)
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/a6a10a4f-2ebc-5f81-00bd-5e906967f384@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 14e8a7738b06..09e05e002703 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -26,6 +26,16 @@
 
 #include "omap_drv.h"
 
+#define to_omap_crtc_state(x) container_of(x, struct omap_crtc_state, base)
+
+struct omap_crtc_state {
+	/* Must be first. */
+	struct drm_crtc_state base;
+	/* Shadow values for legacy userspace support. */
+	unsigned int rotation;
+	unsigned int zpos;
+};
+
 #define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
 
 struct omap_crtc {
@@ -445,6 +455,8 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 				struct drm_crtc_state *state)
 {
+	struct drm_plane_state *pri_state;
+
 	if (state->color_mgmt_changed && state->gamma_lut) {
 		uint length = state->gamma_lut->length /
 			sizeof(struct drm_color_lut);
@@ -453,6 +465,16 @@ static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 			return -EINVAL;
 	}
 
+	pri_state = drm_atomic_get_new_plane_state(state->state, crtc->primary);
+	if (pri_state) {
+		struct omap_crtc_state *omap_crtc_state =
+			to_omap_crtc_state(state);
+
+		/* Mirror new values for zpos and rotation in omap_crtc_state */
+		omap_crtc_state->zpos = pri_state->zpos;
+		omap_crtc_state->rotation = pri_state->rotation;
+	}
+
 	return 0;
 }
 
@@ -498,39 +520,32 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	spin_unlock_irq(&crtc->dev->event_lock);
 }
 
-static bool omap_crtc_is_plane_prop(struct drm_crtc *crtc,
-	struct drm_property *property)
-{
-	struct drm_device *dev = crtc->dev;
-	struct omap_drm_private *priv = dev->dev_private;
-
-	return property == priv->zorder_prop ||
-		property == crtc->primary->rotation_property;
-}
-
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state,
 					 struct drm_property *property,
 					 uint64_t val)
 {
-	if (omap_crtc_is_plane_prop(crtc, property)) {
-		struct drm_plane_state *plane_state;
-		struct drm_plane *plane = crtc->primary;
-
-		/*
-		 * Delegate property set to the primary plane. Get the plane
-		 * state and set the property directly.
-		 */
-
-		plane_state = drm_atomic_get_plane_state(state->state, plane);
-		if (IS_ERR(plane_state))
-			return PTR_ERR(plane_state);
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct drm_plane_state *plane_state;
 
-		return drm_atomic_plane_set_property(plane, plane_state,
-				property, val);
-	}
+	/*
+	 * Delegate property set to the primary plane. Get the plane state and
+	 * set the property directly, the shadow copy will be assigned in the
+	 * omap_crtc_atomic_check callback. This way updates to plane state will
+	 * always be mirrored in the crtc state correctly.
+	 */
+	plane_state = drm_atomic_get_plane_state(state->state, crtc->primary);
+	if (IS_ERR(plane_state))
+		return PTR_ERR(plane_state);
+
+	if (property == crtc->primary->rotation_property)
+		plane_state->rotation = val;
+	else if (property == priv->zorder_prop)
+		plane_state->zpos = val;
+	else
+		return -EINVAL;
 
-	return -EINVAL;
+	return 0;
 }
 
 static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
@@ -538,28 +553,59 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 					 struct drm_property *property,
 					 uint64_t *val)
 {
-	if (omap_crtc_is_plane_prop(crtc, property)) {
-		/*
-		 * Delegate property get to the primary plane. The
-		 * drm_atomic_plane_get_property() function isn't exported, but
-		 * can be called through drm_object_property_get_value() as that
-		 * will call drm_atomic_get_property() for atomic drivers.
-		 */
-		return drm_object_property_get_value(&crtc->primary->base,
-				property, val);
-	}
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct omap_crtc_state *omap_state = to_omap_crtc_state(state);
+
+	if (property == crtc->primary->rotation_property)
+		*val = omap_state->rotation;
+	else if (property == priv->zorder_prop)
+		*val = omap_state->zpos;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static void omap_crtc_reset(struct drm_crtc *crtc)
+{
+	if (crtc->state)
+		__drm_atomic_helper_crtc_destroy_state(crtc->state);
+
+	kfree(crtc->state);
+	crtc->state = kzalloc(sizeof(struct omap_crtc_state), GFP_KERNEL);
+
+	if (crtc->state)
+		crtc->state->crtc = crtc;
+}
+
+static struct drm_crtc_state *
+omap_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct omap_crtc_state *state, *current_state;
+
+	if (WARN_ON(!crtc->state))
+		return NULL;
+
+	current_state = to_omap_crtc_state(crtc->state);
+
+	state = kmalloc(sizeof(*state), GFP_KERNEL);
+	if (state)
+		__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);
+
+	state->zpos = current_state->zpos;
+	state->rotation = current_state->rotation;
 
-	return -EINVAL;
+	return &state->base;
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
-	.reset = drm_atomic_helper_crtc_reset,
+	.reset = omap_crtc_reset,
 	.set_config = drm_atomic_helper_set_config,
 	.destroy = omap_crtc_destroy,
 	.page_flip = drm_atomic_helper_page_flip,
 	.gamma_set = drm_atomic_helper_legacy_gamma_set,
 	.set_property = drm_atomic_helper_crtc_set_property,
-	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_duplicate_state = omap_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
 	.atomic_set_property = omap_crtc_atomic_set_property,
 	.atomic_get_property = omap_crtc_atomic_get_property,

commit 64581714b58bc3e16ede8dc37a025c3aa0e0eef1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:45 2017 +0300

    drm: Convert atomic drivers from CRTC .disable() to .atomic_disable()
    
    The CRTC .disable() helper operation is deprecated for atomic drivers,
    the new .atomic_disable() helper operation being preferred. Convert all
    atomic drivers to .atomic_disable() to avoid cargo-cult use of
    .disable() in new drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-3-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7a1b7a9cc270..14e8a7738b06 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -373,7 +373,8 @@ static void omap_crtc_atomic_enable(struct drm_crtc *crtc,
 	spin_unlock_irq(&crtc->dev->event_lock);
 }
 
-static void omap_crtc_disable(struct drm_crtc *crtc)
+static void omap_crtc_atomic_disable(struct drm_crtc *crtc,
+				     struct drm_crtc_state *old_state)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
@@ -568,11 +569,11 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
-	.disable = omap_crtc_disable,
 	.atomic_check = omap_crtc_atomic_check,
 	.atomic_begin = omap_crtc_atomic_begin,
 	.atomic_flush = omap_crtc_atomic_flush,
 	.atomic_enable = omap_crtc_atomic_enable,
+	.atomic_disable = omap_crtc_atomic_disable,
 };
 
 /* -----------------------------------------------------------------------------

commit 0b20a0f8c3cb6f74fe326101b62eeb5e2c56a53c
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:44 2017 +0300

    drm: Add old state pointer to CRTC .enable() helper function
    
    The old state is useful for drivers that need to perform operations at
    enable time that depend on the transition between the old and new
    states.
    
    While at it, rename the operation to .atomic_enable() to be consistent
    with .atomic_disable(), as the .enable() operation is used by atomic
    helpers only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for imx-drm and mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com> # for hdlcd and mali-dp
    Acked-by: Stefan Agner <stefan@agner.ch> # for fsl-dcu
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-2-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index dd0ef40ca469..7a1b7a9cc270 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -356,7 +356,8 @@ static void omap_crtc_arm_event(struct drm_crtc *crtc)
 	}
 }
 
-static void omap_crtc_enable(struct drm_crtc *crtc)
+static void omap_crtc_atomic_enable(struct drm_crtc *crtc,
+				    struct drm_crtc_state *old_state)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	int ret;
@@ -568,10 +569,10 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
 	.disable = omap_crtc_disable,
-	.enable = omap_crtc_enable,
 	.atomic_check = omap_crtc_atomic_check,
 	.atomic_begin = omap_crtc_atomic_begin,
 	.atomic_flush = omap_crtc_atomic_flush,
+	.atomic_enable = omap_crtc_atomic_enable,
 };
 
 /* -----------------------------------------------------------------------------

commit ce9a8f1ad7564fa24bc12066b41f2a09eb1a8394
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue May 9 01:27:09 2017 +0300

    drm: omapdrm: Handle events when enabling/disabling CRTCs
    
    The driver currently handles vblank events only when updating planes on
    an already enabled CRTC. The atomic update API however allows requesting
    an event when enabling or disabling a CRTC. This currently leads to
    event objects being leaked in the kernel and to events not being sent
    out. Fix it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index dccd03726796..dd0ef40ca469 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -343,6 +343,19 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 	kfree(omap_crtc);
 }
 
+static void omap_crtc_arm_event(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	WARN_ON(omap_crtc->pending);
+	omap_crtc->pending = true;
+
+	if (crtc->state->event) {
+		omap_crtc->event = crtc->state->event;
+		crtc->state->event = NULL;
+	}
+}
+
 static void omap_crtc_enable(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -355,8 +368,7 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 	ret = drm_crtc_vblank_get(crtc);
 	WARN_ON(ret != 0);
 
-	WARN_ON(omap_crtc->pending);
-	omap_crtc->pending = true;
+	omap_crtc_arm_event(crtc);
 	spin_unlock_irq(&crtc->dev->event_lock);
 }
 
@@ -366,6 +378,13 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
+	spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event) {
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+	}
+	spin_unlock_irq(&crtc->dev->event_lock);
+
 	drm_crtc_vblank_off(crtc);
 }
 
@@ -473,12 +492,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	spin_lock_irq(&crtc->dev->event_lock);
 	priv->dispc_ops->mgr_go(omap_crtc->channel);
-
-	WARN_ON(omap_crtc->pending);
-	omap_crtc->pending = true;
-
-	if (crtc->state->event)
-		omap_crtc->event = crtc->state->event;
+	omap_crtc_arm_event(crtc);
 	spin_unlock_irq(&crtc->dev->event_lock);
 }
 

commit e8e13b1521678af0df7b07f30745d77e8de1820a
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Mar 24 16:47:55 2017 +0200

    drm/omap: Major omap_modeset_init() cleanup
    
    Cleanup overly complex omap_modeset_init(). The function is trying to
    support many unusual configuration, that have never been tested and
    are not supported by other parts of the dirver.
    
    After cleanup the init function creates exactly one connector,
    encoder, crtc, and primary plane per each connected dss-device. Each
    connector->encoder->crtc chain is expected to be separate and each
    crtc is connect to a single dss-channel. If the configuration does not
    match the expectations or exceeds the available resources, the
    configuration is rejected.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 4f03f74685f0..dccd03726796 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -573,6 +573,8 @@ static const char *channel_names[] = {
 
 void omap_crtc_pre_init(void)
 {
+	memset(omap_crtcs, 0, sizeof(omap_crtcs));
+
 	dss_install_mgr_ops(&mgr_ops);
 }
 
@@ -583,18 +585,28 @@ void omap_crtc_pre_uninit(void)
 
 /* initialize crtc */
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
-		struct drm_plane *plane, enum omap_channel channel, int id)
+		struct drm_plane *plane, struct omap_dss_device *dssdev)
 {
 	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_crtc *crtc = NULL;
 	struct omap_crtc *omap_crtc;
+	enum omap_channel channel;
+	struct omap_dss_device *out;
 	int ret;
 
+	out = omapdss_find_output_from_display(dssdev);
+	channel = out->dispc_channel;
+	omap_dss_put_device(out);
+
 	DBG("%s", channel_names[channel]);
 
+	/* Multiple displays on same channel is not allowed */
+	if (WARN_ON(omap_crtcs[channel] != NULL))
+		return ERR_PTR(-EINVAL);
+
 	omap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);
 	if (!omap_crtc)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	crtc = &omap_crtc->base;
 
@@ -606,8 +618,10 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {
+		dev_err(dev->dev, "%s(): could not init crtc for: %s\n",
+			__func__, dssdev->name);
 		kfree(omap_crtc);
-		return NULL;
+		return ERR_PTR(ret);
 	}
 
 	drm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);

commit 50fa9f0bb8c1eb7d0dbd404766a67c34756d5a80
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 23 13:24:00 2016 +0200

    drm/omap: fix display SYNC/DE flags
    
    At the moment VSYNC/HSYNC/DE high/low flags set by the panel/encoder
    drivers get lost when the videotimings are translated to DRM's
    videomode, as DRM's mode does not have corresponding flags.
    
    DRM has bus-flags for this purpose, and while it lacks a few flags at
    the moment, it should be used here. However, until we rewrite omapdrm's
    device model, using bus-flags is rather difficult.
    
    As a short term fix, this patch makes sure that every time the videomode
    is set in omap_crtc_mode_set_nofb(), the driver asks for the SYNC/DE
    flags from the panel/encoder drivers, and thus we get the correct flags
    into use.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 1db96b077ae8..4f03f74685f0 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -373,6 +373,11 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	const u32 flags_mask = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_DE_LOW |
+		DISPLAY_FLAGS_PIXDATA_POSEDGE | DISPLAY_FLAGS_PIXDATA_NEGEDGE |
+		DISPLAY_FLAGS_SYNC_POSEDGE | DISPLAY_FLAGS_SYNC_NEGEDGE;
+	unsigned int i;
 
 	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
 	    omap_crtc->name, mode->base.id, mode->name,
@@ -382,9 +387,38 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	    mode->type, mode->flags);
 
 	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
-	omap_crtc->vm.flags |= DISPLAY_FLAGS_DE_HIGH |
-			       DISPLAY_FLAGS_PIXDATA_POSEDGE |
-			       DISPLAY_FLAGS_SYNC_NEGEDGE;
+
+	/*
+	 * HACK: This fixes the vm flags.
+	 * struct drm_display_mode does not contain the VSYNC/HSYNC/DE flags
+	 * and they get lost when converting back and forth between
+	 * struct drm_display_mode and struct videomode. The hack below
+	 * goes and fetches the missing flags from the panel drivers.
+	 *
+	 * Correct solution would be to use DRM's bus-flags, but that's not
+	 * easily possible before the omapdrm's panel/encoder driver model
+	 * has been changed to the DRM model.
+	 */
+
+	for (i = 0; i < priv->num_encoders; ++i) {
+		struct drm_encoder *encoder = priv->encoders[i];
+
+		if (encoder->crtc == crtc) {
+			struct omap_dss_device *dssdev;
+
+			dssdev = omap_encoder_get_dssdev(encoder);
+
+			if (dssdev) {
+				struct videomode vm = {0};
+
+				dssdev->driver->get_timings(dssdev, &vm);
+
+				omap_crtc->vm.flags |= vm.flags & flags_mask;
+			}
+
+			break;
+		}
+	}
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit 9f759225e42b00ad0c5a55907f443b388e8960f4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 18:39:52 2015 +0200

    drm/omap: use dispc_ops
    
    Change omapdrm to get dispc_ops and use that to call the dispc functions
    instead or direct function calls.
    
    The change is very straightforward.
    
    The only problem was in omap_crtc_init() which calls pipe2vbl(crtc), and
    at that point of time the crtc->dev link, which is used to get the
    dispc_ops, has not been set up yet. This patch makes omap_crtc_init()
    skip the call to pipe2vbl() and instead calls
    dispc_ops->mgr_get_vsync_irq() directly.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 49fc61963af4..1db96b077ae8 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -107,10 +107,12 @@ static struct omap_dss_device *omap_crtc_output[8];
 static int omap_crtc_dss_connect(enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
+	const struct dispc_ops *dispc_ops = dispc_get_ops();
+
 	if (omap_crtc_output[channel])
 		return -EINVAL;
 
-	if ((dispc_mgr_get_supported_outputs(channel) & dst->id) == 0)
+	if ((dispc_ops->mgr_get_supported_outputs(channel) & dst->id) == 0)
 		return -EINVAL;
 
 	omap_crtc_output[channel] = dst;
@@ -134,6 +136,7 @@ static void omap_crtc_dss_start_update(enum omap_channel channel)
 static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 {
 	struct drm_device *dev = crtc->dev;
+	struct omap_drm_private *priv = dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	enum omap_channel channel = omap_crtc->channel;
 	struct omap_irq_wait *wait;
@@ -144,7 +147,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 		return;
 
 	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
-		dispc_mgr_enable(channel, enable);
+		priv->dispc_ops->mgr_enable(channel, enable);
 		omap_crtc->enabled = enable;
 		return;
 	}
@@ -157,8 +160,8 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 		omap_crtc->ignore_digit_sync_lost = true;
 	}
 
-	framedone_irq = dispc_mgr_get_framedone_irq(channel);
-	vsync_irq = dispc_mgr_get_vsync_irq(channel);
+	framedone_irq = priv->dispc_ops->mgr_get_framedone_irq(channel);
+	vsync_irq = priv->dispc_ops->mgr_get_vsync_irq(channel);
 
 	if (enable) {
 		wait = omap_irq_wait_init(dev, vsync_irq, 1);
@@ -178,7 +181,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 			wait = omap_irq_wait_init(dev, vsync_irq, 2);
 	}
 
-	dispc_mgr_enable(channel, enable);
+	priv->dispc_ops->mgr_enable(channel, enable);
 	omap_crtc->enabled = enable;
 
 	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
@@ -198,9 +201,9 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 static int omap_crtc_dss_enable(enum omap_channel channel)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct omap_drm_private *priv = omap_crtc->base.dev->dev_private;
 
-	dispc_mgr_set_timings(omap_crtc->channel,
-			&omap_crtc->vm);
+	priv->dispc_ops->mgr_set_timings(omap_crtc->channel, &omap_crtc->vm);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
 
 	return 0;
@@ -225,8 +228,10 @@ static void omap_crtc_dss_set_lcd_config(enum omap_channel channel,
 		const struct dss_lcd_mgr_config *config)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
+	struct omap_drm_private *priv = omap_crtc->base.dev->dev_private;
+
 	DBG("%s", omap_crtc->name);
-	dispc_mgr_set_lcd_config(omap_crtc->channel, config);
+	priv->dispc_ops->mgr_set_lcd_config(omap_crtc->channel, config);
 }
 
 static int omap_crtc_dss_register_framedone(
@@ -274,6 +279,8 @@ void omap_crtc_error_irq(struct drm_crtc *crtc, uint32_t irqstatus)
 void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = omap_crtc->base.dev;
+	struct omap_drm_private *priv = dev->dev_private;
 	bool pending;
 
 	spin_lock(&crtc->dev->event_lock);
@@ -281,7 +288,7 @@ void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 	 * If the dispc is busy we're racing the flush operation. Try again on
 	 * the next vblank interrupt.
 	 */
-	if (dispc_mgr_go_busy(omap_crtc->channel)) {
+	if (priv->dispc_ops->mgr_go_busy(omap_crtc->channel)) {
 		spin_unlock(&crtc->dev->event_lock);
 		return;
 	}
@@ -307,6 +314,7 @@ void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 
 static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
 {
+	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct omap_overlay_manager_info info;
 
@@ -317,7 +325,7 @@ static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
 	info.partial_alpha_enabled = false;
 	info.cpr_enable = false;
 
-	dispc_mgr_setup(omap_crtc->channel, &info);
+	priv->dispc_ops->mgr_setup(omap_crtc->channel, &info);
 }
 
 /* -----------------------------------------------------------------------------
@@ -401,6 +409,7 @@ static void omap_crtc_atomic_begin(struct drm_crtc *crtc,
 static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 				   struct drm_crtc_state *old_crtc_state)
 {
+	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	int ret;
 
@@ -414,7 +423,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 			length = crtc->state->gamma_lut->length /
 				sizeof(*lut);
 		}
-		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
+		priv->dispc_ops->mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
 	omap_crtc_write_crtc_properties(crtc);
@@ -429,7 +438,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	WARN_ON(ret != 0);
 
 	spin_lock_irq(&crtc->dev->event_lock);
-	dispc_mgr_go(omap_crtc->channel);
+	priv->dispc_ops->mgr_go(omap_crtc->channel);
 
 	WARN_ON(omap_crtc->pending);
 	omap_crtc->pending = true;
@@ -542,6 +551,7 @@ void omap_crtc_pre_uninit(void)
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 		struct drm_plane *plane, enum omap_channel channel, int id)
 {
+	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_crtc *crtc = NULL;
 	struct omap_crtc *omap_crtc;
 	int ret;
@@ -575,7 +585,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	 * extracted with dispc_mgr_gamma_size(). If it returns 0
 	 * gamma table is not supprted.
 	 */
-	if (dispc_mgr_gamma_size(channel)) {
+	if (priv->dispc_ops->mgr_gamma_size(channel)) {
 		uint gamma_lut_size = 256;
 
 		drm_crtc_enable_color_mgmt(crtc, 0, false, gamma_lut_size);

commit 7e3d92749dd773b8a1bd35b02e2aa1271cb7a31b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Aug 10 12:08:50 2015 +0300

    drm/omap: refactor CRTC HW property setup
    
    The current driver doesn't expose any of the CRTC HW properties like
    background color or transparency key, and sets them at CRTC enable time.
    
    Refactor this into a separate function and call that function from
    omap_crtc_atomic_flush(). This is the behavior we want when the
    properties can be configured, so this patch makes it easier to add
    patches later which implement those properties.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2fe735c269fc..49fc61963af4 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -198,15 +198,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 static int omap_crtc_dss_enable(enum omap_channel channel)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
-	struct omap_overlay_manager_info info;
 
-	memset(&info, 0, sizeof(info));
-	info.default_color = 0x00000000;
-	info.trans_key = 0x00000000;
-	info.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
-	info.trans_enabled = false;
-
-	dispc_mgr_setup(omap_crtc->channel, &info);
 	dispc_mgr_set_timings(omap_crtc->channel,
 			&omap_crtc->vm);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
@@ -313,6 +305,21 @@ void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 	DBG("%s: apply done", omap_crtc->name);
 }
 
+static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_overlay_manager_info info;
+
+	memset(&info, 0, sizeof(info));
+
+	info.default_color = 0x000000;
+	info.trans_enabled = false;
+	info.partial_alpha_enabled = false;
+	info.cpr_enable = false;
+
+	dispc_mgr_setup(omap_crtc->channel, &info);
+}
+
 /* -----------------------------------------------------------------------------
  * CRTC Functions
  */
@@ -410,6 +417,8 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
+	omap_crtc_write_crtc_properties(crtc);
+
 	/* Only flush the CRTC if it is currently enabled. */
 	if (!omap_crtc->enabled)
 		return;

commit 8e22e1b3499a446df48c2b26667ca36c55bf864c
Merge: 00d3c14f14d5 64a577196d66
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Feb 26 21:34:42 2017 +0100

    Merge airlied/drm-next into drm-misc-next
    
    Backmerge the main pull request to sync up with all the newly landed
    drivers. Otherwise we'll have chaos even before 4.12 started in
    earnest.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit e025d3860bd9f718d4d8ce251e6a823dd8293b51
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Jan 27 12:04:54 2017 +0200

    Revert "drm: omapdrm: Let the DRM core skip plane commit on inactive CRTCs"
    
    This reverts commit dadf4659d0608e034b6633f30300c2eff2dafb4c.
    
    If planes are not disabled when the they are not on any crtc anymore
    they will remain active and may show as "ghosts" when the crtc they
    were last on is active again.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index dd47dc191e6b..b68c70eb395f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -410,13 +410,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
-	/*
-	 * Only flush the CRTC if it is currently enabled. CRTCs that require a
-	 * mode set are disabled prior plane updates and enabled afterwards.
-	 * They are thus not active (regardless of what their CRTC core state
-	 * reports) and the DRM core could thus call this function even though
-	 * the CRTC is currently disabled. Do nothing in that case.
-	 */
+	/* Only flush the CRTC if it is currently enabled. */
 	if (!omap_crtc->enabled)
 		return;
 

commit 0396162ab9c571ee31f01866cbf168066dbf395d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Feb 8 13:26:00 2017 +0200

    drm/omap: use vblank hooks in struct drm_crtc_funcs
    
    The vblank hooks in struct drm_driver are deprecated and only meant for
    legacy drivers.  For modern drivers with DRIVER_MODESET flag, the hooks
    in struct drm_crtc_funcs should be used instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index dd47dc191e6b..bd18e8c4f1d0 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -501,6 +501,8 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
 	.atomic_set_property = omap_crtc_atomic_set_property,
 	.atomic_get_property = omap_crtc_atomic_get_property,
+	.enable_vblank = omap_irq_enable_vblank,
+	.disable_vblank = omap_irq_disable_vblank,
 };
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {

commit ca52d2f33bbb5bbac0bd85c5ea50c0e85a416ebc
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed May 27 19:15:22 2015 +0300

    drm: omapdrm: Inline the pipe2vbl function
    
    The function is only used in omap_irq.c and is just a wrapper around
    dispc_mgr_get_vsync_irq(). Remove it and call the dispc function
    directly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 046d199ef036..dd47dc191e6b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -48,13 +48,6 @@ struct omap_crtc {
  * Helper Functions
  */
 
-uint32_t pipe2vbl(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	return dispc_mgr_get_vsync_irq(omap_crtc->channel);
-}
-
 struct videomode *omap_crtc_timings(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);

commit 14389a374b12347eecdc98a3082921ef68cad179
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Apr 19 01:43:03 2016 +0300

    drm: omapdrm: Keep vblank interrupt enabled while CRTC is active
    
    Instead of going through a complicated private IRQ registration
    mechanism, handle the vblank interrupt activation with the standard
    drm_crtc_vblank_get() and drm_crtc_vblank_put() mechanism. This will let
    the DRM core keep the vblank interrupt enabled as long as needed to
    update the frame counter.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 827ac46a6d5e..046d199ef036 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -36,8 +36,6 @@ struct omap_crtc {
 
 	struct videomode vm;
 
-	struct omap_drm_irq vblank_irq;
-
 	bool ignore_digit_sync_lost;
 
 	bool enabled;
@@ -275,22 +273,6 @@ static const struct dss_mgr_ops mgr_ops = {
  * Setup, Flush and Page Flip
  */
 
-static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_pending_vblank_event *event;
-	struct drm_device *dev = crtc->dev;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->event_lock, flags);
-	event = omap_crtc->event;
-	omap_crtc->event = NULL;
-
-	if (event)
-		drm_crtc_send_vblank_event(crtc, event);
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-}
-
 void omap_crtc_error_irq(struct drm_crtc *crtc, uint32_t irqstatus)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -304,30 +286,38 @@ void omap_crtc_error_irq(struct drm_crtc *crtc, uint32_t irqstatus)
 	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_crtc->name, irqstatus);
 }
 
-static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+void omap_crtc_vblank_irq(struct drm_crtc *crtc)
 {
-	struct omap_crtc *omap_crtc =
-			container_of(irq, struct omap_crtc, vblank_irq);
-	struct drm_device *dev = omap_crtc->base.dev;
-	struct drm_crtc *crtc = &omap_crtc->base;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	bool pending;
 
-	if (dispc_mgr_go_busy(omap_crtc->channel))
+	spin_lock(&crtc->dev->event_lock);
+	/*
+	 * If the dispc is busy we're racing the flush operation. Try again on
+	 * the next vblank interrupt.
+	 */
+	if (dispc_mgr_go_busy(omap_crtc->channel)) {
+		spin_unlock(&crtc->dev->event_lock);
 		return;
+	}
 
-	DBG("%s: apply done", omap_crtc->name);
-
-	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
+	/* Send the vblank event if one has been requested. */
+	if (omap_crtc->event) {
+		drm_crtc_send_vblank_event(crtc, omap_crtc->event);
+		omap_crtc->event = NULL;
+	}
 
-	spin_lock(&crtc->dev->event_lock);
-	WARN_ON(!omap_crtc->pending);
+	pending = omap_crtc->pending;
 	omap_crtc->pending = false;
 	spin_unlock(&crtc->dev->event_lock);
 
-	/* wake up userspace */
-	omap_crtc_complete_page_flip(&omap_crtc->base);
+	if (pending)
+		drm_crtc_vblank_put(crtc);
 
-	/* wake up omap_atomic_complete */
+	/* Wake up omap_atomic_complete. */
 	wake_up(&omap_crtc->pending_wait);
+
+	DBG("%s: apply done", omap_crtc->name);
 }
 
 /* -----------------------------------------------------------------------------
@@ -340,8 +330,6 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	WARN_ON(omap_crtc->vblank_irq.registered);
-
 	drm_crtc_cleanup(crtc);
 
 	kfree(omap_crtc);
@@ -350,17 +338,18 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 static void omap_crtc_enable(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	int ret;
 
 	DBG("%s", omap_crtc->name);
 
 	spin_lock_irq(&crtc->dev->event_lock);
+	drm_crtc_vblank_on(crtc);
+	ret = drm_crtc_vblank_get(crtc);
+	WARN_ON(ret != 0);
+
 	WARN_ON(omap_crtc->pending);
 	omap_crtc->pending = true;
 	spin_unlock_irq(&crtc->dev->event_lock);
-
-	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
-
-	drm_crtc_vblank_on(crtc);
 }
 
 static void omap_crtc_disable(struct drm_crtc *crtc)
@@ -413,8 +402,7 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 				   struct drm_crtc_state *old_crtc_state)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	WARN_ON(omap_crtc->vblank_irq.registered);
+	int ret;
 
 	if (crtc->state->color_mgmt_changed) {
 		struct drm_color_lut *lut = NULL;
@@ -441,16 +429,18 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	DBG("%s: GO", omap_crtc->name);
 
+	ret = drm_crtc_vblank_get(crtc);
+	WARN_ON(ret != 0);
+
 	spin_lock_irq(&crtc->dev->event_lock);
+	dispc_mgr_go(omap_crtc->channel);
+
 	WARN_ON(omap_crtc->pending);
 	omap_crtc->pending = true;
 
 	if (crtc->state->event)
 		omap_crtc->event = crtc->state->event;
 	spin_unlock_irq(&crtc->dev->event_lock);
-
-	dispc_mgr_go(omap_crtc->channel);
-	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 }
 
 static bool omap_crtc_is_plane_prop(struct drm_crtc *crtc,
@@ -571,9 +561,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];
 
-	omap_crtc->vblank_irq.irqmask = pipe2vbl(crtc);
-	omap_crtc->vblank_irq.irq = omap_crtc_vblank_irq;
-
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {

commit d173d3dc5e41af969c1b230a3a6357e51b9baaeb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Apr 19 01:31:21 2016 +0300

    drm: omapdrm: Use a spinlock to protect the CRTC pending flag
    
    The CRTC pending flag will need to be accessed atomically in the vblank
    interrupt handler, memory barriers won't be enough to protect it. Use a
    spinlock instead.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7b67ecb02b74..827ac46a6d5e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -69,6 +69,19 @@ enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
 	return omap_crtc->channel;
 }
 
+static bool omap_crtc_is_pending(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	unsigned long flags;
+	bool pending;
+
+	spin_lock_irqsave(&crtc->dev->event_lock, flags);
+	pending = omap_crtc->pending;
+	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+
+	return pending;
+}
+
 int omap_crtc_wait_pending(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -78,7 +91,7 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
 	 * a single frame refresh even on slower displays.
 	 */
 	return wait_event_timeout(omap_crtc->pending_wait,
-				  !omap_crtc->pending,
+				  !omap_crtc_is_pending(crtc),
 				  msecs_to_jiffies(250));
 }
 
@@ -296,6 +309,7 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	struct omap_crtc *omap_crtc =
 			container_of(irq, struct omap_crtc, vblank_irq);
 	struct drm_device *dev = omap_crtc->base.dev;
+	struct drm_crtc *crtc = &omap_crtc->base;
 
 	if (dispc_mgr_go_busy(omap_crtc->channel))
 		return;
@@ -304,10 +318,10 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 
 	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
 
-	rmb();
+	spin_lock(&crtc->dev->event_lock);
 	WARN_ON(!omap_crtc->pending);
 	omap_crtc->pending = false;
-	wmb();
+	spin_unlock(&crtc->dev->event_lock);
 
 	/* wake up userspace */
 	omap_crtc_complete_page_flip(&omap_crtc->base);
@@ -339,10 +353,10 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	rmb();
+	spin_lock_irq(&crtc->dev->event_lock);
 	WARN_ON(omap_crtc->pending);
 	omap_crtc->pending = true;
-	wmb();
+	spin_unlock_irq(&crtc->dev->event_lock);
 
 	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 
@@ -427,16 +441,13 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	DBG("%s: GO", omap_crtc->name);
 
-	rmb();
+	spin_lock_irq(&crtc->dev->event_lock);
 	WARN_ON(omap_crtc->pending);
 	omap_crtc->pending = true;
-	wmb();
 
-	if (crtc->state->event) {
-		spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event)
 		omap_crtc->event = crtc->state->event;
-		spin_unlock_irq(&crtc->dev->event_lock);
-	}
+	spin_unlock_irq(&crtc->dev->event_lock);
 
 	dispc_mgr_go(omap_crtc->channel);
 	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);

commit 577d3983c87a1bf47c4e761df3ba2b9c36229c8e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Apr 19 01:15:11 2016 +0300

    drm: omapdrm: Prevent processing the same event multiple times
    
    The vblank interrupt is disabled after one occurrence, preventing the
    atomic update event from being processed twice. However, this also
    prevents the software frame counter from being updated correctly that
    would require vblank interrupts to be kept enabled while the CRTC is
    active.
    
    In preparation for vblank interrupt fixes, make sure that the atomic
    update event will be processed once only when the vblank interrupt will
    be kept enabled.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index a0511cd5d380..7b67ecb02b74 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -43,6 +43,7 @@ struct omap_crtc {
 	bool enabled;
 	bool pending;
 	wait_queue_head_t pending_wait;
+	struct drm_pending_vblank_event *event;
 };
 
 /* -----------------------------------------------------------------------------
@@ -263,17 +264,17 @@ static const struct dss_mgr_ops mgr_ops = {
 
 static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 {
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_pending_vblank_event *event;
 	struct drm_device *dev = crtc->dev;
 	unsigned long flags;
 
-	event = crtc->state->event;
-
-	if (!event)
-		return;
-
 	spin_lock_irqsave(&dev->event_lock, flags);
-	drm_crtc_send_vblank_event(crtc, event);
+	event = omap_crtc->event;
+	omap_crtc->event = NULL;
+
+	if (event)
+		drm_crtc_send_vblank_event(crtc, event);
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
@@ -390,12 +391,12 @@ static int omap_crtc_atomic_check(struct drm_crtc *crtc,
 }
 
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc,
-                                  struct drm_crtc_state *old_crtc_state)
+				   struct drm_crtc_state *old_crtc_state)
 {
 }
 
 static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
-                                  struct drm_crtc_state *old_crtc_state)
+				   struct drm_crtc_state *old_crtc_state)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
@@ -431,6 +432,12 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	omap_crtc->pending = true;
 	wmb();
 
+	if (crtc->state->event) {
+		spin_lock_irq(&crtc->dev->event_lock);
+		omap_crtc->event = crtc->state->event;
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+
 	dispc_mgr_go(omap_crtc->channel);
 	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 }

commit 03af8157aac6db1d0a84747dec64b9f5a241ed62
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Apr 18 03:09:48 2016 +0300

    drm: omapdrm: Check the CRTC software state at enable/disable time
    
    The omapdrm DSS manager enable/disable operations check the DSS manager
    state to avoid double enabling/disabling. Check the CRTC software state
    instead to decrease the dependency of the DRM layer to the DSS layer.
    The dispc_mgr_is_enabled() function then be turned into a static
    function, but needs to be moved up in its compilation unit to avoid a
    forward declaration.
    
    Add a WARN_ON to catch double enable or disable that should be prevented
    by the DRM core and would be a clear sign of a bug. The warning should
    eventually be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2832dbffd873..a0511cd5d380 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -135,15 +135,15 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	u32 framedone_irq, vsync_irq;
 	int ret;
 
+	if (WARN_ON(omap_crtc->enabled == enable))
+		return;
+
 	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
 		dispc_mgr_enable(channel, enable);
 		omap_crtc->enabled = enable;
 		return;
 	}
 
-	if (dispc_mgr_is_enabled(channel) == enable)
-		return;
-
 	if (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {
 		/*
 		 * Digit output produces some sync lost interrupts during the

commit dadf4659d0608e034b6633f30300c2eff2dafb4c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jun 6 04:25:04 2016 +0300

    drm: omapdrm: Let the DRM core skip plane commit on inactive CRTCs
    
    The DRM core supports skipping plane update for inactive CRTCs for
    hardware that don't need it or can't cope with it. That's our case, and
    the driver already skips flushing planes on inactice CRTCs.
    
    We can't remove the check from the driver, as active CRTCs are disabled
    at the hardware level when an atomic flush is performed if a mode set is
    pending. There's however no need to forward the plane commit calls to
    the driver, so use the DRM core infrastructure to skip them with a
    detailed comment to explain why the check must still be kept in the
    driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 42c3b44f9689..2832dbffd873 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -414,7 +414,13 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
-	/* Only flush the CRTC if it is currently enabled. */
+	/*
+	 * Only flush the CRTC if it is currently enabled. CRTCs that require a
+	 * mode set are disabled prior plane updates and enabled afterwards.
+	 * They are thus not active (regardless of what their CRTC core state
+	 * reports) and the DRM core could thus call this function even though
+	 * the CRTC is currently disabled. Do nothing in that case.
+	 */
 	if (!omap_crtc->enabled)
 		return;
 

commit f933a3a93b2d74a255643b326316eee392fa1b80
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Apr 18 02:54:31 2016 +0300

    drm: omapdrm: Replace DSS manager state check with omapdrm CRTC state
    
    Instead of conditioning planes update based on the DSS manager hardware
    state, use the enabled field newly added to the omap_crtc structure.
    This reduces the dependency from the DRM layer to the DSS layer.
    
    The enabled field is a transitory measure, the implementation should use
    the CRTC atomic state instead. However, given that CRTCs are currently
    not enabled/disabled through their .enable() and .disable() operations
    but through a convoluted code paths starting at the associated encoder
    operations, there is not clear guarantee that the atomic state always
    matches the hardware state. This will be refactored later, at which
    point the enabled field will be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index ea274143cea0..42c3b44f9689 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -40,6 +40,7 @@ struct omap_crtc {
 
 	bool ignore_digit_sync_lost;
 
+	bool enabled;
 	bool pending;
 	wait_queue_head_t pending_wait;
 };
@@ -136,6 +137,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 
 	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
 		dispc_mgr_enable(channel, enable);
+		omap_crtc->enabled = enable;
 		return;
 	}
 
@@ -172,6 +174,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	}
 
 	dispc_mgr_enable(channel, enable);
+	omap_crtc->enabled = enable;
 
 	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
 	if (ret) {
@@ -411,18 +414,19 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
-	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
+	/* Only flush the CRTC if it is currently enabled. */
+	if (!omap_crtc->enabled)
+		return;
 
-		DBG("%s: GO", omap_crtc->name);
+	DBG("%s: GO", omap_crtc->name);
 
-		rmb();
-		WARN_ON(omap_crtc->pending);
-		omap_crtc->pending = true;
-		wmb();
+	rmb();
+	WARN_ON(omap_crtc->pending);
+	omap_crtc->pending = true;
+	wmb();
 
-		dispc_mgr_go(omap_crtc->channel);
-		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
-	}
+	dispc_mgr_go(omap_crtc->channel);
+	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 }
 
 static bool omap_crtc_is_plane_prop(struct drm_crtc *crtc,

commit e0519af75d6eabf1876cf6af0c60704f97ab82b3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 00:21:29 2015 +0300

    drm: omapdrm: Handle CRTC error IRQs directly
    
    Instead of going through a complicated registration mechanism, just
    expose the CRTC error IRQ function and call it directly from the main
    IRQ handler.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 8dea89030e66..ea274143cea0 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -37,7 +37,6 @@ struct omap_crtc {
 	struct videomode vm;
 
 	struct omap_drm_irq vblank_irq;
-	struct omap_drm_irq error_irq;
 
 	bool ignore_digit_sync_lost;
 
@@ -275,10 +274,9 @@ static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
-static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+void omap_crtc_error_irq(struct drm_crtc *crtc, uint32_t irqstatus)
 {
-	struct omap_crtc *omap_crtc =
-			container_of(irq, struct omap_crtc, error_irq);
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
 	if (omap_crtc->ignore_digit_sync_lost) {
 		irqstatus &= ~DISPC_IRQ_SYNC_LOST_DIGIT;
@@ -325,7 +323,6 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 	DBG("%s", omap_crtc->name);
 
 	WARN_ON(omap_crtc->vblank_irq.registered);
-	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 
 	drm_crtc_cleanup(crtc);
 
@@ -549,11 +546,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->vblank_irq.irqmask = pipe2vbl(crtc);
 	omap_crtc->vblank_irq.irq = omap_crtc_vblank_irq;
 
-	omap_crtc->error_irq.irqmask =
-			dispc_mgr_get_sync_lost_irq(channel);
-	omap_crtc->error_irq.irq = omap_crtc_error_irq;
-	omap_irq_register(dev, &omap_crtc->error_irq);
-
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {

commit da11bbbb10a964c293c2e2e702ea62ad6cba48b4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:04 2016 +0300

    drm/omap: Use consistent name for struct videomode
    
    Use 'vm' to refer to a struct videomode instead of 'p', 't', 'timings' or
    something else.
    
    The code will be easier to follow if we use consistent names.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c819e350fb1b..8dea89030e66 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -34,7 +34,7 @@ struct omap_crtc {
 	const char *name;
 	enum omap_channel channel;
 
-	struct videomode timings;
+	struct videomode vm;
 
 	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
@@ -59,7 +59,7 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
 struct videomode *omap_crtc_timings(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	return &omap_crtc->timings;
+	return &omap_crtc->vm;
 }
 
 enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
@@ -201,7 +201,7 @@ static int omap_crtc_dss_enable(enum omap_channel channel)
 
 	dispc_mgr_setup(omap_crtc->channel, &info);
 	dispc_mgr_set_timings(omap_crtc->channel,
-			&omap_crtc->timings);
+			&omap_crtc->vm);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
 
 	return 0;
@@ -215,11 +215,11 @@ static void omap_crtc_dss_disable(enum omap_channel channel)
 }
 
 static void omap_crtc_dss_set_timings(enum omap_channel channel,
-		const struct videomode *timings)
+		const struct videomode *vm)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 	DBG("%s", omap_crtc->name);
-	omap_crtc->timings = *timings;
+	omap_crtc->vm = *vm;
 }
 
 static void omap_crtc_dss_set_lcd_config(enum omap_channel channel,
@@ -369,10 +369,10 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
 	    mode->type, mode->flags);
 
-	drm_display_mode_to_videomode(mode, &omap_crtc->timings);
-	omap_crtc->timings.flags |= DISPLAY_FLAGS_DE_HIGH |
-				    DISPLAY_FLAGS_PIXDATA_POSEDGE |
-				    DISPLAY_FLAGS_SYNC_NEGEDGE;
+	drm_display_mode_to_videomode(mode, &omap_crtc->vm);
+	omap_crtc->vm.flags |= DISPLAY_FLAGS_DE_HIGH |
+			       DISPLAY_FLAGS_PIXDATA_POSEDGE |
+			       DISPLAY_FLAGS_SYNC_NEGEDGE;
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit 4520ff28aaa1e7f1b45f3abc0c45429ea9e93817
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:03 2016 +0300

    drm/omap: Replace struct omap_video_timings with videomode
    
    omap_video_timings can be replaced with the generic videomode in omapdrm
    and the omap_video_timings can be removed.
    
    This patch will replace the omap_video_timings with videomode.
    With the change we no longer need the functions to convert to/from
    videomode and drm_display_mode to omap_video_timings, these can be removed
    as well.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index a25d5f769d6f..c819e350fb1b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -34,7 +34,7 @@ struct omap_crtc {
 	const char *name;
 	enum omap_channel channel;
 
-	struct omap_video_timings timings;
+	struct videomode timings;
 
 	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
@@ -56,7 +56,7 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
 	return dispc_mgr_get_vsync_irq(omap_crtc->channel);
 }
 
-struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
+struct videomode *omap_crtc_timings(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	return &omap_crtc->timings;
@@ -215,7 +215,7 @@ static void omap_crtc_dss_disable(enum omap_channel channel)
 }
 
 static void omap_crtc_dss_set_timings(enum omap_channel channel,
-		const struct omap_video_timings *timings)
+		const struct videomode *timings)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 	DBG("%s", omap_crtc->name);
@@ -369,7 +369,10 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
 	    mode->type, mode->flags);
 
-	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
+	drm_display_mode_to_videomode(mode, &omap_crtc->timings);
+	omap_crtc->timings.flags |= DISPLAY_FLAGS_DE_HIGH |
+				    DISPLAY_FLAGS_PIXDATA_POSEDGE |
+				    DISPLAY_FLAGS_SYNC_NEGEDGE;
 }
 
 static int omap_crtc_atomic_check(struct drm_crtc *crtc,

commit a7e8cd39af6ac815736c31a65898a9951d9d2bd3
Author: Jyri Sarha <jsarha@ti.com>
Date:   Wed Aug 31 20:17:05 2016 +0300

    drm/omapdrm: Remove double gamma table write in omap_crtc_atomic_flush()
    
    Remove double gamma table write in omap_crtc_atomic_flush().
    Fixes commit 492a426a2fc53
    ("drm/omapdrm: Implement gamma_lut atomic crtc properties")
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 16c691dbc372..a25d5f769d6f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -411,19 +411,6 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
 	}
 
-	if (crtc->state->color_mgmt_changed) {
-		struct drm_color_lut *lut = NULL;
-		uint length = 0;
-
-		if (crtc->state->gamma_lut) {
-			lut = (struct drm_color_lut *)
-				crtc->state->gamma_lut->data;
-			length = crtc->state->gamma_lut->length /
-				sizeof(*lut);
-		}
-		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
-	}
-
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
 
 		DBG("%s: GO", omap_crtc->name);

commit 0da88db14034e8b309f1c4188123ca1a02f4b354
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 26 19:30:52 2016 +0300

    drm/omap: Use per-plane rotation property
    
    The global mode_config.rotation_property is going away, switch over to
    per-plane rotation_property.
    
    Not sure I got the annoying crtc rotation_property handling right.
    Might work, or migth not.
    
    v2: Drop the BIT()
        Don't create rotation property twice for each primary plane
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    [danvet: Add comment per discussion between Tomi&Ville.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474907460-10717-8-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 180f644e861e..16c691dbc372 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -438,13 +438,14 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	}
 }
 
-static bool omap_crtc_is_plane_prop(struct drm_device *dev,
+static bool omap_crtc_is_plane_prop(struct drm_crtc *crtc,
 	struct drm_property *property)
 {
+	struct drm_device *dev = crtc->dev;
 	struct omap_drm_private *priv = dev->dev_private;
 
 	return property == priv->zorder_prop ||
-		property == dev->mode_config.rotation_property;
+		property == crtc->primary->rotation_property;
 }
 
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
@@ -452,9 +453,7 @@ static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 					 struct drm_property *property,
 					 uint64_t val)
 {
-	struct drm_device *dev = crtc->dev;
-
-	if (omap_crtc_is_plane_prop(dev, property)) {
+	if (omap_crtc_is_plane_prop(crtc, property)) {
 		struct drm_plane_state *plane_state;
 		struct drm_plane *plane = crtc->primary;
 
@@ -479,9 +478,7 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 					 struct drm_property *property,
 					 uint64_t *val)
 {
-	struct drm_device *dev = crtc->dev;
-
-	if (omap_crtc_is_plane_prop(dev, property)) {
+	if (omap_crtc_is_plane_prop(crtc, property)) {
 		/*
 		 * Delegate property get to the primary plane. The
 		 * drm_atomic_plane_get_property() function isn't exported, but

commit 492a426a2fc531774356e05f1ad87ab49e80156c
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 7 15:09:17 2016 +0300

    drm/omapdrm: Implement gamma_lut atomic crtc properties
    
    Implement gamma_lut atomic crtc properties, set crtc gamma size to 256
    for all crtcs and use drm_atomic_helper_legacy_gamma_set() as
    gamma_set func. The tv-out crtc has 1024 element gamma table (with
    10bit precision) in HW, but current Xorg server does not accept
    anything else but 256 elements so that is used for all CRTCs. The dss
    dispc API converts table of any length for HW and uses linear
    interpolation in the process. The default gamma table is restored
    if gamma_lut property is deleted.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 075f2bb44867..180f644e861e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -372,6 +372,20 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
 }
 
+static int omap_crtc_atomic_check(struct drm_crtc *crtc,
+				struct drm_crtc_state *state)
+{
+	if (state->color_mgmt_changed && state->gamma_lut) {
+		uint length = state->gamma_lut->length /
+			sizeof(struct drm_color_lut);
+
+		if (length < 2)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc,
                                   struct drm_crtc_state *old_crtc_state)
 {
@@ -384,6 +398,32 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	WARN_ON(omap_crtc->vblank_irq.registered);
 
+	if (crtc->state->color_mgmt_changed) {
+		struct drm_color_lut *lut = NULL;
+		uint length = 0;
+
+		if (crtc->state->gamma_lut) {
+			lut = (struct drm_color_lut *)
+				crtc->state->gamma_lut->data;
+			length = crtc->state->gamma_lut->length /
+				sizeof(*lut);
+		}
+		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
+	}
+
+	if (crtc->state->color_mgmt_changed) {
+		struct drm_color_lut *lut = NULL;
+		uint length = 0;
+
+		if (crtc->state->gamma_lut) {
+			lut = (struct drm_color_lut *)
+				crtc->state->gamma_lut->data;
+			length = crtc->state->gamma_lut->length /
+				sizeof(*lut);
+		}
+		dispc_mgr_set_gamma(omap_crtc->channel, lut, length);
+	}
+
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
 
 		DBG("%s: GO", omap_crtc->name);
@@ -460,6 +500,7 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.set_config = drm_atomic_helper_set_config,
 	.destroy = omap_crtc_destroy,
 	.page_flip = drm_atomic_helper_page_flip,
+	.gamma_set = drm_atomic_helper_legacy_gamma_set,
 	.set_property = drm_atomic_helper_crtc_set_property,
 	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
@@ -471,6 +512,7 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
 	.disable = omap_crtc_disable,
 	.enable = omap_crtc_enable,
+	.atomic_check = omap_crtc_atomic_check,
 	.atomic_begin = omap_crtc_atomic_begin,
 	.atomic_flush = omap_crtc_atomic_flush,
 };
@@ -534,6 +576,20 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	drm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);
 
+	/* The dispc API adapts to what ever size, but the HW supports
+	 * 256 element gamma table for LCDs and 1024 element table for
+	 * OMAP_DSS_CHANNEL_DIGIT. X server assumes 256 element gamma
+	 * tables so lets use that. Size of HW gamma table can be
+	 * extracted with dispc_mgr_gamma_size(). If it returns 0
+	 * gamma table is not supprted.
+	 */
+	if (dispc_mgr_gamma_size(channel)) {
+		uint gamma_lut_size = 256;
+
+		drm_crtc_enable_color_mgmt(crtc, 0, false, gamma_lut_size);
+		drm_mode_crtc_set_gamma_size(crtc, gamma_lut_size);
+	}
+
 	omap_plane_install_properties(crtc->primary, &crtc->base);
 
 	omap_crtcs[channel] = omap_crtc;

commit 1a4be38a3a46898fee61b3ec1631d273dd66fcf2
Merge: c51e034fedb0 c1f415c9acb5
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 16 11:09:26 2016 +1000

    Merge tag 'topic/drm-misc-2016-03-14' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    * tag 'topic/drm-misc-2016-03-14' of git://anongit.freedesktop.org/drm-intel: (27 commits)
      drm: atomic helper: do not unreference error pointer
      drm/edid: Extract SADs properly from multiple audio data blocks
      drm: fix blob pointer check
      drm: introduce pipe color correction properties
      drm/atomic: Clean up update_connector_routing.
      drm/atomic: Clean up steal_encoder, v2.
      drm/atomic: Handle encoder assignment conflicts in a separate check, v3.
      drm/atomic: Handle encoder stealing from set_config better.
      drm/atomic: Always call steal_encoder, v2.
      drm/ast: removed optional dummy crtc mode_fixup function.
      drm/bochs: removed optional dummy crtc mode_fixup function.
      drm/fsl-dcu: removed optional dummy crtc mode_fixup function.
      drm/virtio: removed optional dummy crtc mode_fixup function.
      drm/nouveau/dispnv04: removed optional dummy crtc mode_fixup function.
      drm/atmel-hlcdc: remove optional dummy crtc mode_fixup function.
      drm/sti: removed optional dummy crtc mode_fixup function.
      drm/shmobile: removed optional dummy crtc mode_fixup function.
      drm/msm/mdp: removed optional dummy crtc mode_fixup function.
      drm/omapdrm: removed optional dummy crtc mode_fixup function.
      drm/rcar-du: removed optional dummy crtc mode_fixup function.
      ...

commit a90cc3f25065e5e8d5e336c75b04d5882912871f
Merge: 912b330c2009 1c278e5e3718
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Mar 5 08:07:58 2016 +1000

    Merge tag 'omapdrm-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux into drm-next
    
    omapdrm changes for v4.6
    
    * HDMI interlace output support
    * DMAbuf import support
    * Big refactoring leading to removal of legacy code
    * Various non-critical fixes
    
    * tag 'omapdrm-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (76 commits)
      drm/omap: no need to select OMAP2_DSS
      drm/omap: gem: Fix omap_gem_new() error path
      drm/omap: remove -Werror from Makefile
      drm/omap: remove dispc_ovl_check()
      drm/omap: remove dss compat code
      drm/omap: remove last uses of omap_overlay_manager
      drm/omap: DSI: remove uses of omap_overlay_manager
      drm/omap: VENC: remove uses of omap_overlay_manager
      drm/omap: SDI: remove uses of omap_overlay_manager
      drm/omap: HDMI4: remove uses of omap_overlay_manager
      drm/omap: HDMI5: remove uses of omap_overlay_manager
      drm/omap: DPI: remove uses of omap_overlay_manager
      drm/omap: remove extra manager checks on disconnect
      drm/omap: remove extra check in dpi and sdi
      drm/omap: convert dss_mgr_unregister_framedone_handler to accept omap_channel
      drm/omap: convert dss_mgr_register_framedone_handler to accept omap_channel
      drm/omap: convert dss_mgr_start_update to accept omap_channel
      drm/omap: convert dss_mgr_disable to accept omap_channel
      drm/omap: convert dss_mgr_enable to accept omap_channel
      drm/omap: convert dss_mgr_set_lcd_config to accept omap_channel
      ...

commit 4091e54e846c4813ef93f2471a0f358d07ca9510
Author: Carlos Palminha <CARLOS.PALMINHA@synopsys.com>
Date:   Tue Feb 16 14:18:12 2016 +0000

    drm/omapdrm: removed optional dummy crtc mode_fixup function.
    
    This patch set nukes all the dummy crtc mode_fixup implementations.
    (made on top of Daniel topic/drm-misc branch)
    
    Signed-off-by: Carlos Palminha <palminha@synopsys.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/101f043d5fa747291c09ae765bac4d55c6e39988.1455630967.git.palminha@synopsys.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index d38fcbcc43a8..483acdbd664b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -330,13 +330,6 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 	kfree(omap_crtc);
 }
 
-static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
-		const struct drm_display_mode *mode,
-		struct drm_display_mode *adjusted_mode)
-{
-	return true;
-}
-
 static void omap_crtc_enable(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -451,7 +444,6 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 };
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
-	.mode_fixup = omap_crtc_mode_fixup,
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
 	.disable = omap_crtc_disable,
 	.enable = omap_crtc_enable,

commit 751d2e18b0859ec3edc1c61bfcc09affdbd9b323
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 10:02:43 2015 +0200

    drm/omap: remove last uses of omap_overlay_manager
    
    We have now removed all uses of 'struct omap_overlay_manager', so we can
    now remove the last places where it is set.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 3667ff1d8474..263f4b7a5789 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -102,8 +102,6 @@ static struct omap_dss_device *omap_crtc_output[8];
 static int omap_crtc_dss_connect(enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	struct omap_overlay_manager *mgr = omap_dss_get_overlay_manager(channel);
-
 	if (omap_crtc_output[channel])
 		return -EINVAL;
 
@@ -113,22 +111,14 @@ static int omap_crtc_dss_connect(enum omap_channel channel,
 	omap_crtc_output[channel] = dst;
 	dst->dispc_channel_connected = true;
 
-	dst->manager = mgr;
-	mgr->output = dst;
-
 	return 0;
 }
 
 static void omap_crtc_dss_disconnect(enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	struct omap_overlay_manager *mgr = omap_dss_get_overlay_manager(channel);
-
 	omap_crtc_output[channel] = NULL;
 	dst->dispc_channel_connected = false;
-
-	mgr->output->manager = NULL;
-	mgr->output = NULL;
 }
 
 static void omap_crtc_dss_start_update(enum omap_channel channel)

commit 49239503a364bf09845d03536b28ea434b92184d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:34:31 2015 +0200

    drm/omap: add dispc_channel_connected field to omap_dss_device
    
    We want to remove the 'struct omap_overlay_manager' from
    omap_dss_device. At the moment that field is used, among some other
    uses, to see if the omap_dss_device is connected to an overlay manager.
    
    To make it possible to remove the 'struct omap_overlay_manager' field,
    this patch adds 'bool dispc_channel_connected' field to track the
    connected-or-not status.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index cb5a30e3109d..3667ff1d8474 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -111,6 +111,7 @@ static int omap_crtc_dss_connect(enum omap_channel channel,
 		return -EINVAL;
 
 	omap_crtc_output[channel] = dst;
+	dst->dispc_channel_connected = true;
 
 	dst->manager = mgr;
 	mgr->output = dst;
@@ -124,6 +125,7 @@ static void omap_crtc_dss_disconnect(enum omap_channel channel,
 	struct omap_overlay_manager *mgr = omap_dss_get_overlay_manager(channel);
 
 	omap_crtc_output[channel] = NULL;
+	dst->dispc_channel_connected = false;
 
 	mgr->output->manager = NULL;
 	mgr->output = NULL;

commit e5cbb6e8eaa6d4ae8b4acafd59e2e058105c8177
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 19:36:26 2015 +0200

    drm/omap: convert dss_mgr_ops to use omap_channel
    
    We are removing the use of 'struct omap_overlay_manager' from omapdrm.
    This patch changes the function pointers in 'dss_mgr_ops' to get 'enum
    omap_channel' parameter instead of 'struct omap_overlay_manager'.
    
    The change is very straightforward, as we still use 'struct
    omap_overlay_manager' inside the function implementations where needed.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e583de9e31db..cb5a30e3109d 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -99,16 +99,18 @@ static struct omap_crtc *omap_crtcs[8];
 static struct omap_dss_device *omap_crtc_output[8];
 
 /* we can probably ignore these until we support command-mode panels: */
-static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
+static int omap_crtc_dss_connect(enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	if (omap_crtc_output[mgr->id])
+	struct omap_overlay_manager *mgr = omap_dss_get_overlay_manager(channel);
+
+	if (omap_crtc_output[channel])
 		return -EINVAL;
 
-	if ((dispc_mgr_get_supported_outputs(mgr->id) & dst->id) == 0)
+	if ((dispc_mgr_get_supported_outputs(channel) & dst->id) == 0)
 		return -EINVAL;
 
-	omap_crtc_output[mgr->id] = dst;
+	omap_crtc_output[channel] = dst;
 
 	dst->manager = mgr;
 	mgr->output = dst;
@@ -116,16 +118,18 @@ static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
 	return 0;
 }
 
-static void omap_crtc_dss_disconnect(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_disconnect(enum omap_channel channel,
 		struct omap_dss_device *dst)
 {
-	omap_crtc_output[mgr->id] = NULL;
+	struct omap_overlay_manager *mgr = omap_dss_get_overlay_manager(channel);
+
+	omap_crtc_output[channel] = NULL;
 
 	mgr->output->manager = NULL;
 	mgr->output = NULL;
 }
 
-static void omap_crtc_dss_start_update(struct omap_overlay_manager *mgr)
+static void omap_crtc_dss_start_update(enum omap_channel channel)
 {
 }
 
@@ -192,9 +196,9 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 }
 
 
-static int omap_crtc_dss_enable(struct omap_overlay_manager *mgr)
+static int omap_crtc_dss_enable(enum omap_channel channel)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 	struct omap_overlay_manager_info info;
 
 	memset(&info, 0, sizeof(info));
@@ -211,38 +215,38 @@ static int omap_crtc_dss_enable(struct omap_overlay_manager *mgr)
 	return 0;
 }
 
-static void omap_crtc_dss_disable(struct omap_overlay_manager *mgr)
+static void omap_crtc_dss_disable(enum omap_channel channel)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 
 	omap_crtc_set_enabled(&omap_crtc->base, false);
 }
 
-static void omap_crtc_dss_set_timings(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_set_timings(enum omap_channel channel,
 		const struct omap_video_timings *timings)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 	DBG("%s", omap_crtc->name);
 	omap_crtc->timings = *timings;
 }
 
-static void omap_crtc_dss_set_lcd_config(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_set_lcd_config(enum omap_channel channel,
 		const struct dss_lcd_mgr_config *config)
 {
-	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_crtc *omap_crtc = omap_crtcs[channel];
 	DBG("%s", omap_crtc->name);
 	dispc_mgr_set_lcd_config(omap_crtc->channel, config);
 }
 
 static int omap_crtc_dss_register_framedone(
-		struct omap_overlay_manager *mgr,
+		enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
 	return 0;
 }
 
 static void omap_crtc_dss_unregister_framedone(
-		struct omap_overlay_manager *mgr,
+		enum omap_channel channel,
 		void (*handler)(void *), void *data)
 {
 }

commit 3a9241386494ed5797e4c7244b944ac312d35515
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Oct 21 16:34:08 2015 +0300

    drm/omap: remove crtc->mgr field
    
    In order to remove uses of 'struct omap_overlay_manager' from omapdrm,
    this patch removes the crtc->mgr field.
    
    To accomplish that, a new static array is added along the current
    'omap_crtcs' static array, which is used to store the output device
    connected to a crtc.
    
    Optimally we'd use the struct omap_crtc to store this information, but
    at the time when omap_crtc_dss_connect() is called, we don't yet have
    the omap_crtc instances. This might possibly be fixed later, but for now
    the static array does the job.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 6daf0bd67d06..e583de9e31db 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -34,14 +34,6 @@ struct omap_crtc {
 	const char *name;
 	enum omap_channel channel;
 
-	/*
-	 * Temporary: eventually this will go away, but it is needed
-	 * for now to keep the output's happy.  (They only need
-	 * mgr->id.)  Eventually this will be replaced w/ something
-	 * more common-panel-framework-y
-	 */
-	struct omap_overlay_manager *mgr;
-
 	struct omap_video_timings timings;
 
 	struct omap_drm_irq vblank_irq;
@@ -104,17 +96,20 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
 
 /* ovl-mgr-id -> crtc */
 static struct omap_crtc *omap_crtcs[8];
+static struct omap_dss_device *omap_crtc_output[8];
 
 /* we can probably ignore these until we support command-mode panels: */
 static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
 		struct omap_dss_device *dst)
 {
-	if (mgr->output)
+	if (omap_crtc_output[mgr->id])
 		return -EINVAL;
 
 	if ((dispc_mgr_get_supported_outputs(mgr->id) & dst->id) == 0)
 		return -EINVAL;
 
+	omap_crtc_output[mgr->id] = dst;
+
 	dst->manager = mgr;
 	mgr->output = dst;
 
@@ -124,6 +119,8 @@ static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
 static void omap_crtc_dss_disconnect(struct omap_overlay_manager *mgr,
 		struct omap_dss_device *dst)
 {
+	omap_crtc_output[mgr->id] = NULL;
+
 	mgr->output->manager = NULL;
 	mgr->output = NULL;
 }
@@ -142,7 +139,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	u32 framedone_irq, vsync_irq;
 	int ret;
 
-	if (omap_crtc->mgr->output->output_type == OMAP_DISPLAY_TYPE_HDMI) {
+	if (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {
 		dispc_mgr_enable(channel, enable);
 		return;
 	}
@@ -551,9 +548,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->error_irq.irq = omap_crtc_error_irq;
 	omap_irq_register(dev, &omap_crtc->error_irq);
 
-	/* temporary: */
-	omap_crtc->mgr = omap_dss_get_overlay_manager(channel);
-
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs, NULL);
 	if (ret < 0) {

commit 7b9cb5eeb4d0b1db63e198dfd02aadddaf245de4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 15:11:25 2015 +0200

    drm/omap: Add dispc_mgr_get_supported_outputs()
    
    We are removing the use of the 'struct omap_overlay_manager' from
    omapdrm, and one part of that is removing the use of
    mgr->supported_outputs field.
    
    This patch adds dispc_mgr_get_supported_outputs() function which can be
    used instead of mgr->supported_outputs. omap_crtc.c is changed to use
    the new function.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 8c5caf8bb1b9..6daf0bd67d06 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -112,7 +112,7 @@ static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
 	if (mgr->output)
 		return -EINVAL;
 
-	if ((mgr->supported_outputs & dst->id) == 0)
+	if ((dispc_mgr_get_supported_outputs(mgr->id) & dst->id) == 0)
 		return -EINVAL;
 
 	dst->manager = mgr;

commit 6bdad6cf98844e76f678da35dea09193bfb78be1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 18 18:47:14 2016 +0200

    drm/omap: fix crtc->plane property delegation
    
    Before universal planes we had to have plane specific properties for the
    crtc too, as on the hardware level a crtc uses a plane. In other words,
    e.g. 'zorder' property was added to both planes and crtcs, and
    omap_crtc.c would delegate the property set/get to the primary plane.
    
    However, the delegation was a bit too generic, delegating all property
    set/get calls to planes. Thus it's possible to set, say, FB_ID, on a
    crtc, which gets redirected to  the primary plane.
    
    This is not standard, and shouldn't be allowed. To keep backward
    compatibility, we still need to redirect the properties we supported
    earlier for crtcs, namely 'zorder' and 'rotation'.
    
    This patch redirects only the allowed properties from crtcs to planes.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f1cd2800055b..8c5caf8bb1b9 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -423,24 +423,40 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 	}
 }
 
+static bool omap_crtc_is_plane_prop(struct drm_device *dev,
+	struct drm_property *property)
+{
+	struct omap_drm_private *priv = dev->dev_private;
+
+	return property == priv->zorder_prop ||
+		property == dev->mode_config.rotation_property;
+}
+
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state,
 					 struct drm_property *property,
 					 uint64_t val)
 {
-	struct drm_plane_state *plane_state;
-	struct drm_plane *plane = crtc->primary;
+	struct drm_device *dev = crtc->dev;
 
-	/*
-	 * Delegate property set to the primary plane. Get the plane state and
-	 * set the property directly.
-	 */
+	if (omap_crtc_is_plane_prop(dev, property)) {
+		struct drm_plane_state *plane_state;
+		struct drm_plane *plane = crtc->primary;
+
+		/*
+		 * Delegate property set to the primary plane. Get the plane
+		 * state and set the property directly.
+		 */
 
-	plane_state = drm_atomic_get_plane_state(state->state, plane);
-	if (IS_ERR(plane_state))
-		return PTR_ERR(plane_state);
+		plane_state = drm_atomic_get_plane_state(state->state, plane);
+		if (IS_ERR(plane_state))
+			return PTR_ERR(plane_state);
 
-	return drm_atomic_plane_set_property(plane, plane_state, property, val);
+		return drm_atomic_plane_set_property(plane, plane_state,
+				property, val);
+	}
+
+	return -EINVAL;
 }
 
 static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
@@ -448,14 +464,20 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 					 struct drm_property *property,
 					 uint64_t *val)
 {
-	/*
-	 * Delegate property get to the primary plane. The
-	 * drm_atomic_plane_get_property() function isn't exported, but can be
-	 * called through drm_object_property_get_value() as that will call
-	 * drm_atomic_get_property() for atomic drivers.
-	 */
-	return drm_object_property_get_value(&crtc->primary->base, property,
-					     val);
+	struct drm_device *dev = crtc->dev;
+
+	if (omap_crtc_is_plane_prop(dev, property)) {
+		/*
+		 * Delegate property get to the primary plane. The
+		 * drm_atomic_plane_get_property() function isn't exported, but
+		 * can be called through drm_object_property_get_value() as that
+		 * will call drm_atomic_get_property() for atomic drivers.
+		 */
+		return drm_object_property_get_value(&crtc->primary->base,
+				property, val);
+	}
+
+	return -EINVAL;
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {

commit 61f3c40b489c7f3ca2f844e6513c1abd08e66a93
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 19 17:31:25 2015 +0200

    drm/omap: increase vblank wait timeout
    
    omap_crtc_wait_pending() waits until the config changes have been taken
    into use, usually at next vblank. The wait-timeout used is 50ms, which
    usually is enough, but in some rare cases not.
    
    As time wait-timeout is just a safety measure for cases where something
    is broken, we can just as well increase the timeout considerably.
    
    This patch makes the timeout 250ms.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f5b19d18fa8b..f1cd2800055b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -80,9 +80,13 @@ int omap_crtc_wait_pending(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
+	/*
+	 * Timeout is set to a "sufficiently" high value, which should cover
+	 * a single frame refresh even on slower displays.
+	 */
 	return wait_event_timeout(omap_crtc->pending_wait,
 				  !omap_crtc->pending,
-				  msecs_to_jiffies(50));
+				  msecs_to_jiffies(250));
 }
 
 /* -----------------------------------------------------------------------------

commit a7696ea7402fc8140f2023821e60adcf406679fe
Author: Jyri Sarha <jsarha@ti.com>
Date:   Wed Oct 28 14:00:42 2015 +0200

    drm/omap: drm_atomic_get_plane_state() may return ERR_PTR
    
    drm_atomic_get_plane_state() may return ERR_PTR. Handle
    drm_atomic_get_plane_state() return values right in
    omap_crtc_atomic_set_property().
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7dd3d44a93e5..f5b19d18fa8b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -433,8 +433,8 @@ static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 	 */
 
 	plane_state = drm_atomic_get_plane_state(state->state, plane);
-	if (!plane_state)
-		return -EINVAL;
+	if (IS_ERR(plane_state))
+		return PTR_ERR(plane_state);
 
 	return drm_atomic_plane_set_property(plane, plane_state, property, val);
 }

commit 4e4b53ceb59301b2a1dbf3a9f74ce5e17f64287d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Mar 24 15:46:35 2015 +0200

    drm/omap: HDMI: change enable/disable to avoid sync-losts
    
    We occasionally see DISPC sync-lost errors when enabling and disabling
    HDMI. Sometimes we get only a few, which get handled (ignored) by the
    driver, but sometimes there's a flood of the errors which doesn't seem
    to stop.
    
    The HW team has root caused this to the order in which HDMI and DISPC
    are enabled/disabled. Currently we enable HDMI first, and then DISPC,
    and vice versa when disabling. HW team's suggestion is to do it the
    other way around.
    
    This patch changes the order, but this has two side effects as the pixel
    clock is produced by HDMI, and the clock is not running when we
    enable/disable DISPC:
    
    * When enabling DISPC first, we don't get vertical sync events
    * When disabling DISPC last, we don't get FRAMEDONE event
    
    At the moment we use both of those to verify that DISPC has been
    enabled/disabled properly. Thus this patch also needs to change the
    omapdrm and omapdss which handle the DISPC side.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2ed0754ed19e..7dd3d44a93e5 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -138,6 +138,11 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	u32 framedone_irq, vsync_irq;
 	int ret;
 
+	if (omap_crtc->mgr->output->output_type == OMAP_DISPLAY_TYPE_HDMI) {
+		dispc_mgr_enable(channel, enable);
+		return;
+	}
+
 	if (dispc_mgr_is_enabled(channel) == enable)
 		return;
 

commit 8c04fdeef343a18617968b672f212d1634add14d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jan 25 22:16:50 2016 +0100

    drm/omap: Nuke close hooks
    
    Again since the core takes care of this we can remove them. While at
    it also remove the postclose hook, it's empty.
    
    v2: Laurent pointed me at even more code to delete.
    
    v3: Remove unused flags (Tomi).
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453756616-28942-9-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2ed0754ed19e..d38fcbcc43a8 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -269,18 +269,7 @@ static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 		return;
 
 	spin_lock_irqsave(&dev->event_lock, flags);
-
-	list_del(&event->base.link);
-
-	/*
-	 * Queue the event for delivery if it's still linked to a file
-	 * handle, otherwise just destroy it.
-	 */
-	if (event->base.file_priv)
-		drm_crtc_send_vblank_event(crtc, event);
-	else
-		event->base.destroy(&event->base);
-
+	drm_crtc_send_vblank_event(crtc, event);
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 

commit f98828769c8838f526703ef180b3088a714af2f9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:19:31 2015 +0200

    drm: Pass 'name' to drm_crtc_init_with_planes()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    I didn't convert drm_crtc_init() since passing the varargs through
    would mean either cpp macros or va_list, and I figured we don't
    care about these legacy functions enough to warrant the extra pain.
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   )
    { ... }
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   );
    
    @@
    expression E1, E2, E3, E4, E5;
    @@
     drm_crtc_init_with_planes(E1, E2, E3, E4, E5
    +                          ,NULL
                               )
    
    v2: Split crtc and plane changes apart
        Pass NULL for no-name instead of ""
        Leave drm_crtc_init() alone
    v3: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670771-2751-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index ad09590e8a46..2ed0754ed19e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -524,7 +524,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->mgr = omap_dss_get_overlay_manager(channel);
 
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
-					&omap_crtc_funcs);
+					&omap_crtc_funcs, NULL);
 	if (ret < 0) {
 		kfree(omap_crtc);
 		return NULL;

commit 33e0be63759d472e7a6996d1277ff66e92a8685d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Oct 16 18:38:39 2015 +0300

    drm: Check crtc viewport correctly with rotated primary plane on atomic drivers
    
    On atomic drivers we can dig out the primary plane rotation from the
    plane state instead of looking at the legacy crtc->invert_dimensions
    flag. The flag is not set by anyone except omapdrm, and it would be
    racy to set it the same way in the atomic helpers.
    
    v2: Kill crtc->invert_dimensions totally since omap is state based
        already and no one else ever used it (Matt)
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445009919-22746-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 9a4ba4f03567..ad09590e8a46 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -412,9 +412,6 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
 		dispc_mgr_go(omap_crtc->channel);
 		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 	}
-
-	crtc->invert_dimensions = !!(crtc->primary->state->rotation &
-				    (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270)));
 }
 
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,

commit c201d00f4a4c004482aec7de1bffdfe2d85e65cf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Aug 6 14:09:35 2015 +0200

    drm/omap: Fixup compile fail
    
    Maarten didn't fully test his patches on all drm drivers and
    apparently missed a few places when grepping.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 23d9c928cdc9..9a4ba4f03567 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -388,11 +388,13 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
 }
 
-static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
+static void omap_crtc_atomic_begin(struct drm_crtc *crtc,
+                                  struct drm_crtc_state *old_crtc_state)
 {
 }
 
-static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
+static void omap_crtc_atomic_flush(struct drm_crtc *crtc,
+                                  struct drm_crtc_state *old_crtc_state)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 

commit 5f741b39dde47c054af78727cce7202fff9f781b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri May 29 16:01:18 2015 +0300

    drm: omapdrm: new vblank and event handling
    
    Rework the crtc event/flip_wait system as follows:
    
    - If we enable a crtc (full modeset), we set omap_crtc->pending and
      register vblank irq.
    
    - If we need to set GO bit (page flip), we do the same but also set the
      GO bit.
    
    - On vblank we unregister the irq, clear the 'pending' flag, send vblank
      event to userspace if crtc->state->event != NULL, and wake up
      'pending_wait' wq.
    
    - In omap_atomic_complete() we wait for the 'pending' flag to get reset
      for all enabled crtcs  using 'pending_wait' wq.
    
    The above ensures that we send the events to userspace in vblank, and
    that after the wait in omap_atomic_complete() everything for the
    affected crtcs has been completed.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 8d2bf8565ddd..23d9c928cdc9 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -17,8 +17,6 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <linux/completion.h>
-
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
@@ -49,13 +47,10 @@ struct omap_crtc {
 	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
 
-	/* pending event */
-	struct drm_pending_vblank_event *event;
-	wait_queue_head_t flip_wait;
-
-	struct completion completion;
-
 	bool ignore_digit_sync_lost;
+
+	bool pending;
+	wait_queue_head_t pending_wait;
 };
 
 /* -----------------------------------------------------------------------------
@@ -81,6 +76,15 @@ enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
 	return omap_crtc->channel;
 }
 
+int omap_crtc_wait_pending(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	return wait_event_timeout(omap_crtc->pending_wait,
+				  !omap_crtc->pending,
+				  msecs_to_jiffies(50));
+}
+
 /* -----------------------------------------------------------------------------
  * DSS Manager Functions
  */
@@ -255,61 +259,29 @@ static const struct dss_mgr_ops mgr_ops = {
 
 static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 {
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_pending_vblank_event *event;
 	struct drm_device *dev = crtc->dev;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dev->event_lock, flags);
-
-	event = omap_crtc->event;
-	omap_crtc->event = NULL;
+	event = crtc->state->event;
 
-	if (event) {
-		list_del(&event->base.link);
-
-		/*
-		 * Queue the event for delivery if it's still linked to a file
-		 * handle, otherwise just destroy it.
-		 */
-		if (event->base.file_priv)
-			drm_crtc_send_vblank_event(crtc, event);
-		else
-			event->base.destroy(&event->base);
-
-		wake_up(&omap_crtc->flip_wait);
-		drm_crtc_vblank_put(crtc);
-	}
-
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-}
-
-static bool omap_crtc_page_flip_pending(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_device *dev = crtc->dev;
-	unsigned long flags;
-	bool pending;
+	if (!event)
+		return;
 
 	spin_lock_irqsave(&dev->event_lock, flags);
-	pending = omap_crtc->event != NULL;
-	spin_unlock_irqrestore(&dev->event_lock, flags);
 
-	return pending;
-}
+	list_del(&event->base.link);
 
-static void omap_crtc_wait_page_flip(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	if (wait_event_timeout(omap_crtc->flip_wait,
-			       !omap_crtc_page_flip_pending(crtc),
-			       msecs_to_jiffies(50)))
-		return;
-
-	dev_warn(crtc->dev->dev, "page flip timeout!\n");
+	/*
+	 * Queue the event for delivery if it's still linked to a file
+	 * handle, otherwise just destroy it.
+	 */
+	if (event->base.file_priv)
+		drm_crtc_send_vblank_event(crtc, event);
+	else
+		event->base.destroy(&event->base);
 
-	omap_crtc_complete_page_flip(crtc);
+	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -336,12 +308,19 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 		return;
 
 	DBG("%s: apply done", omap_crtc->name);
+
 	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
 
-	/* wakeup userspace */
+	rmb();
+	WARN_ON(!omap_crtc->pending);
+	omap_crtc->pending = false;
+	wmb();
+
+	/* wake up userspace */
 	omap_crtc_complete_page_flip(&omap_crtc->base);
 
-	complete(&omap_crtc->completion);
+	/* wake up omap_atomic_complete */
+	wake_up(&omap_crtc->pending_wait);
 }
 
 /* -----------------------------------------------------------------------------
@@ -375,6 +354,13 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
+	rmb();
+	WARN_ON(omap_crtc->pending);
+	omap_crtc->pending = true;
+	wmb();
+
+	omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
+
 	drm_crtc_vblank_on(crtc);
 }
 
@@ -384,7 +370,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	omap_crtc_wait_page_flip(crtc);
 	drm_crtc_vblank_off(crtc);
 }
 
@@ -405,19 +390,6 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 {
-	struct drm_pending_vblank_event *event = crtc->state->event;
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_device *dev = crtc->dev;
-	unsigned long flags;
-
-	if (event) {
-		WARN_ON(omap_crtc->event);
-		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
-
-		spin_lock_irqsave(&dev->event_lock, flags);
-		omap_crtc->event = event;
-		spin_unlock_irqrestore(&dev->event_lock, flags);
-	}
 }
 
 static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
@@ -427,14 +399,16 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
 	WARN_ON(omap_crtc->vblank_irq.registered);
 
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
+
 		DBG("%s: GO", omap_crtc->name);
 
+		rmb();
+		WARN_ON(omap_crtc->pending);
+		omap_crtc->pending = true;
+		wmb();
+
 		dispc_mgr_go(omap_crtc->channel);
 		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
-
-		WARN_ON(!wait_for_completion_timeout(&omap_crtc->completion,
-						     msecs_to_jiffies(100)));
-		reinit_completion(&omap_crtc->completion);
 	}
 
 	crtc->invert_dimensions = !!(crtc->primary->state->rotation &
@@ -534,8 +508,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	crtc = &omap_crtc->base;
 
-	init_waitqueue_head(&omap_crtc->flip_wait);
-	init_completion(&omap_crtc->completion);
+	init_waitqueue_head(&omap_crtc->pending_wait);
 
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];

commit 6646dfd02985eb67d8dcc00d0d345c8dc40f9925
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Jun 8 13:08:25 2015 +0300

    drm: omapdrm: merge omap_crtc_flush and omap_crtc_atomic_flush
    
    omap_crtc_atomic_flush() is the only user of omap_crtc_flush(), so just
    move the code from omap_crtc_flush() to omap_crtc_atomic_flush().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index abfafd1600b8..8d2bf8565ddd 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -344,26 +344,6 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	complete(&omap_crtc->completion);
 }
 
-static int omap_crtc_flush(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	DBG("%s: GO", omap_crtc->name);
-
-	WARN_ON(omap_crtc->vblank_irq.registered);
-
-	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
-		dispc_mgr_go(omap_crtc->channel);
-		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
-
-		WARN_ON(!wait_for_completion_timeout(&omap_crtc->completion,
-						     msecs_to_jiffies(100)));
-		reinit_completion(&omap_crtc->completion);
-	}
-
-	return 0;
-}
-
 /* -----------------------------------------------------------------------------
  * CRTC Functions
  */
@@ -442,7 +422,20 @@ static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 
 static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
 {
-	omap_crtc_flush(crtc);
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	WARN_ON(omap_crtc->vblank_irq.registered);
+
+	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
+		DBG("%s: GO", omap_crtc->name);
+
+		dispc_mgr_go(omap_crtc->channel);
+		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
+
+		WARN_ON(!wait_for_completion_timeout(&omap_crtc->completion,
+						     msecs_to_jiffies(100)));
+		reinit_completion(&omap_crtc->completion);
+	}
 
 	crtc->invert_dimensions = !!(crtc->primary->state->rotation &
 				    (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270)));

commit 0dce4d75c3fc585387fbfc7ab2126118d86bf0f9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed May 27 20:53:57 2015 +0300

    drm: omapdrm: Don't setup planes manually from CRTC .enable()/.disable()
    
    Planes setup is handled by the DRM core through the atomic helpers,
    there's no need to duplicate the code in the CRTC .enable() and
    .disable() operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 701406e1f0ee..abfafd1600b8 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -391,41 +391,21 @@ static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
 
 static void omap_crtc_enable(struct drm_crtc *crtc)
 {
-	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	unsigned int i;
 
 	DBG("%s", omap_crtc->name);
 
-	/* Enable all planes associated with the CRTC. */
-	for (i = 0; i < priv->num_planes; i++) {
-		struct drm_plane *plane = priv->planes[i];
-
-		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_setup(plane));
-	}
-
 	drm_crtc_vblank_on(crtc);
 }
 
 static void omap_crtc_disable(struct drm_crtc *crtc)
 {
-	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	unsigned int i;
 
 	DBG("%s", omap_crtc->name);
 
 	omap_crtc_wait_page_flip(crtc);
 	drm_crtc_vblank_off(crtc);
-
-	/* Disable all planes associated with the CRTC. */
-	for (i = 0; i < priv->num_planes; i++) {
-		struct drm_plane *plane = priv->planes[i];
-
-		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_setup(plane));
-	}
 }
 
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)

commit af6da31e9c8d25f4be524c2bf97a886071eb4a00
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 02:39:35 2015 +0300

    drm: omapdrm: Don't flush CRTC when enabling or disabling it
    
    The omap_crtc_flush() call in omap_crtc_enable() and omap_crtc_disable()
    is a no-op, as the display manager is always disabled at this point. Just
    remove the function call.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2236f52f8bc3..701406e1f0ee 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -405,8 +405,6 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_setup(plane));
 	}
 
-	omap_crtc_flush(crtc);
-
 	drm_crtc_vblank_on(crtc);
 }
 
@@ -428,8 +426,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 		if (plane->crtc == crtc)
 			WARN_ON(omap_plane_setup(plane));
 	}
-
-	omap_crtc_flush(crtc);
 }
 
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)

commit 4029755e2a411c72f32b60b37ca8861f21647139
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 02:34:05 2015 +0300

    drm: omapdrm: Move encoder setup to encoder operations
    
    Now that the driver is fully converted to atomic operations, and that
    the atomic helpers call the operations in the right order, we can move
    encoder setup to where it belongs, in the encoder operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 3a5e68a06af3..2236f52f8bc3 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -35,7 +35,6 @@ struct omap_crtc {
 
 	const char *name;
 	enum omap_channel channel;
-	struct drm_encoder *current_encoder;
 
 	/*
 	 * Temporary: eventually this will go away, but it is needed
@@ -70,7 +69,7 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
 	return dispc_mgr_get_vsync_irq(omap_crtc->channel);
 }
 
-const struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
+struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	return &omap_crtc->timings;
@@ -125,7 +124,7 @@ static void omap_crtc_dss_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
-/* Called only from omap_crtc_encoder_setup and suspend/resume handlers. */
+/* Called only from the encoder enable/disable and suspend/resume handlers. */
 static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 {
 	struct drm_device *dev = crtc->dev;
@@ -365,37 +364,6 @@ static int omap_crtc_flush(struct drm_crtc *crtc)
 	return 0;
 }
 
-static void omap_crtc_encoder_setup(struct drm_crtc *crtc, bool enable)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-	struct drm_encoder *encoder = NULL;
-	unsigned int i;
-
-	DBG("%s: enable=%d", omap_crtc->name, enable);
-
-	for (i = 0; i < priv->num_encoders; i++) {
-		if (priv->encoders[i]->crtc == crtc) {
-			encoder = priv->encoders[i];
-			break;
-		}
-	}
-
-	if (omap_crtc->current_encoder && encoder != omap_crtc->current_encoder)
-		omap_encoder_set_enabled(omap_crtc->current_encoder, false);
-
-	omap_crtc->current_encoder = encoder;
-
-	if (encoder) {
-		omap_encoder_set_enabled(encoder, false);
-		if (enable) {
-			omap_encoder_update(encoder, omap_crtc->mgr,
-					    &omap_crtc->timings);
-			omap_encoder_set_enabled(encoder, true);
-		}
-	}
-}
-
 /* -----------------------------------------------------------------------------
  * CRTC Functions
  */
@@ -437,7 +405,6 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_setup(plane));
 	}
 
-	omap_crtc_encoder_setup(crtc, true);
 	omap_crtc_flush(crtc);
 
 	drm_crtc_vblank_on(crtc);
@@ -462,7 +429,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_setup(plane));
 	}
 
-	omap_crtc_encoder_setup(crtc, false);
 	omap_crtc_flush(crtc);
 }
 

commit 69fb7c855c7bd4b4bc3fd6bec0885236365d5261
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 02:09:56 2015 +0300

    drm: omapdrm: Simplify DSS power management
    
    Instead of sprinkling dispc_runtime_get() and dispc_runtime_put() calls
    in various CRTC operations, move all power management code to the atomic
    commit function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 16f9c07dc4f6..3a5e68a06af3 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -429,8 +429,6 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	dispc_runtime_get();
-
 	/* Enable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
@@ -443,8 +441,6 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 	omap_crtc_flush(crtc);
 
 	drm_crtc_vblank_on(crtc);
-
-	dispc_runtime_put();
 }
 
 static void omap_crtc_disable(struct drm_crtc *crtc)
@@ -456,7 +452,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 	DBG("%s", omap_crtc->name);
 
 	omap_crtc_wait_page_flip(crtc);
-	dispc_runtime_get();
 	drm_crtc_vblank_off(crtc);
 
 	/* Disable all planes associated with the CRTC. */
@@ -469,8 +464,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 
 	omap_crtc_encoder_setup(crtc, false);
 	omap_crtc_flush(crtc);
-
-	dispc_runtime_put();
 }
 
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
@@ -495,8 +488,6 @@ static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 	struct drm_device *dev = crtc->dev;
 	unsigned long flags;
 
-	dispc_runtime_get();
-
 	if (event) {
 		WARN_ON(omap_crtc->event);
 		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
@@ -511,8 +502,6 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
 {
 	omap_crtc_flush(crtc);
 
-	dispc_runtime_put();
-
 	crtc->invert_dimensions = !!(crtc->primary->state->rotation &
 				    (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270)));
 }

commit fd93a252da41e40e2b6383122eb6009714faa51c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 01:58:02 2015 +0300

    drm: omapdrm: Remove nested PM get/sync when configuring encoders
    
    The omap_crtc_encoder_setup() function is always called with the DSS
    enabled. Remove the dispc_runtime_get() and dispc_runtime_put() calls.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index aa719ebfe787..16f9c07dc4f6 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -374,8 +374,6 @@ static void omap_crtc_encoder_setup(struct drm_crtc *crtc, bool enable)
 
 	DBG("%s: enable=%d", omap_crtc->name, enable);
 
-	dispc_runtime_get();
-
 	for (i = 0; i < priv->num_encoders; i++) {
 		if (priv->encoders[i]->crtc == crtc) {
 			encoder = priv->encoders[i];
@@ -396,8 +394,6 @@ static void omap_crtc_encoder_setup(struct drm_crtc *crtc, bool enable)
 			omap_encoder_set_enabled(encoder, true);
 		}
 	}
-
-	dispc_runtime_put();
 }
 
 /* -----------------------------------------------------------------------------

commit 1cfe19aa611b332e182cd9976e91a205121ac956
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Apr 16 22:35:20 2015 +0300

    drm: omapdrm: Support unlinking page flip events prematurely
    
    DRM page flip vblank events requested by page flips or atomic commits
    are created by the DRM core and then passed to driver through CRTC
    states (for atomic commit) or directly to the page flip handler (for
    legacy page flips). The events are then kept aside until the page flip
    completes, at which point drivers queue them for delivery with a call to
    drm_send_vblank_event().
    
    When a DRM file handle is closed events pending for delivery are cleaned
    up automatically by the DRM core. Events that have been passed to the
    driver but haven't completed yet, however, are not handled by the DRM
    core. Drivers are responsible for destroying them and must not attempt
    to queue them for delivery. This is usually handled by drivers'
    preclose() handlers that cancel and destroy page flip events that
    reference the file handle being closed.
    
    With asynchronous atomic updates the story becomes more complex. Several
    asynchronous atomic updates can be pending, each of them carrying
    per-CRTC events. As the atomic_commit() operation doesn't receive a file
    handle context, drivers can't know which file handle a pending update
    refers to, making it difficult to cancel or wait for completion of
    updates related to the file handle being closed.
    
    It should be noted that cancelling page flips or waiting for atomic
    updates completion isn't required by the DRM core when closing a file
    handle. The only requirement is that no event gets queued for delivery
    after the preclose() operation returns. This can easily be achieved by
    storing events for atomic commits in a list, unlinking events from the
    file handle being closed by setting the file_priv field to NULL, and
    skipping delivery of unlinked events.
    
    This logic replaces the page flip cancellation completely.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 8cbac72a1015..aa719ebfe787 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -254,30 +254,6 @@ static const struct dss_mgr_ops mgr_ops = {
  * Setup, Flush and Page Flip
  */
 
-void omap_crtc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_pending_vblank_event *event;
-	struct drm_device *dev = crtc->dev;
-	unsigned long flags;
-
-	/* Destroy the pending vertical blanking event associated with the
-	 * pending page flip, if any, and disable vertical blanking interrupts.
-	 */
-
-	spin_lock_irqsave(&dev->event_lock, flags);
-
-	event = omap_crtc->event;
-	omap_crtc->event = NULL;
-
-	if (event && event->base.file_priv == file) {
-		event->base.destroy(&event->base);
-		drm_crtc_vblank_put(crtc);
-	}
-
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-}
-
 static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -291,7 +267,17 @@ static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 	omap_crtc->event = NULL;
 
 	if (event) {
-		drm_crtc_send_vblank_event(crtc, event);
+		list_del(&event->base.link);
+
+		/*
+		 * Queue the event for delivery if it's still linked to a file
+		 * handle, otherwise just destroy it.
+		 */
+		if (event->base.file_priv)
+			drm_crtc_send_vblank_event(crtc, event);
+		else
+			event->base.destroy(&event->base);
+
 		wake_up(&omap_crtc->flip_wait);
 		drm_crtc_vblank_put(crtc);
 	}

commit 55613acf1d1e4e6511e85d823e9235941236e6d3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Apr 15 22:47:45 2015 +0300

    drm: omapdrm: omap_crtc_flush() isn't called with modeset locked
    
    When performing asynchronous atomic updates the modeset lock isn't taken
    around the callers of omap_crtc_flush(). This isn't an issue though, as
    access to the CRTC is properly serialized. Just drop the warning.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 993bd15ecfbd..8cbac72a1015 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -365,7 +365,6 @@ static int omap_crtc_flush(struct drm_crtc *crtc)
 
 	DBG("%s: GO", omap_crtc->name);
 
-	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
 	WARN_ON(omap_crtc->vblank_irq.registered);
 
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {

commit 0193f0c74445ab0da0b8870c18ea5ef071fa1ec1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Apr 15 21:51:45 2015 +0300

    drm: omapdrm: Don't get/put dispc in omap_crtc_flush()
    
    The omap_crtc_flush() function is always called with a reference to the
    dispc held. Remove unnecessary calls to dispc_runtime_get() and
    dispc_runtime_put().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 96ba21509607..993bd15ecfbd 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -368,8 +368,6 @@ static int omap_crtc_flush(struct drm_crtc *crtc)
 	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
 	WARN_ON(omap_crtc->vblank_irq.registered);
 
-	dispc_runtime_get();
-
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
 		dispc_mgr_go(omap_crtc->channel);
 		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
@@ -379,8 +377,6 @@ static int omap_crtc_flush(struct drm_crtc *crtc)
 		reinit_completion(&omap_crtc->completion);
 	}
 
-	dispc_runtime_put();
-
 	return 0;
 }
 

commit bec10a2a10f368e66f74a7f8b8795afe8070ae1f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Apr 15 21:47:34 2015 +0300

    drm: omapdrm: Make the omap_crtc_flush function static
    
    The function isn't used outside of its compilation unit, make it static.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 82d03ed92576..96ba21509607 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -359,7 +359,7 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	complete(&omap_crtc->completion);
 }
 
-int omap_crtc_flush(struct drm_crtc *crtc)
+static int omap_crtc_flush(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 

commit edc725577c52d4abe1dac54ccca1b7bc08672f13
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 19:18:56 2015 +0200

    drm: omapdrm: Remove omap_plane enabled field
    
    The field tracks the plane state to avoid double-enable or -disable.
    This isn't required anymore, as
    
    - the DRM atomic core guarantees that the plane atomic_update and
      atomic_disable functions will never be called on an enabled/disabled
      plane
    
    - the CRTC enable/disable operations that enable/disable the plane are
      already guarded against double enable/disable
    
    We can thus remove the enabled field completely. The
    omap_plane_set_enable() function then becomes a wrapper around
    omap_plane_setup() which can be called directly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e93ed34dea33..82d03ed92576 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -452,19 +452,21 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
+	dispc_runtime_get();
+
 	/* Enable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
 
 		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_set_enable(plane, true));
+			WARN_ON(omap_plane_setup(plane));
 	}
 
 	omap_crtc_encoder_setup(crtc, true);
 	omap_crtc_flush(crtc);
 
-	dispc_runtime_get();
 	drm_crtc_vblank_on(crtc);
+
 	dispc_runtime_put();
 }
 
@@ -479,18 +481,19 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 	omap_crtc_wait_page_flip(crtc);
 	dispc_runtime_get();
 	drm_crtc_vblank_off(crtc);
-	dispc_runtime_put();
 
 	/* Disable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
 
 		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_set_enable(plane, false));
+			WARN_ON(omap_plane_setup(plane));
 	}
 
 	omap_crtc_encoder_setup(crtc, false);
 	omap_crtc_flush(crtc);
+
+	dispc_runtime_put();
 }
 
 static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)

commit 6cca481c0556d197f8aa287aec784b20f515fd12
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Apr 15 18:55:27 2015 +0300

    drm: omapdrm: Remove omap_crtc enabled field
    
    The field tracks the CRTC state to avoid double-enable or -disable. As
    the DRM atomic core guarantees that the CRTC enable and disable
    functions won't be called on an already enabled or disabled CRTC, such
    tracking isn't needed. Remove the enabled field.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 430bf64521f0..e93ed34dea33 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -46,7 +46,6 @@ struct omap_crtc {
 	struct omap_overlay_manager *mgr;
 
 	struct omap_video_timings timings;
-	bool enabled;
 
 	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
@@ -126,7 +125,7 @@ static void omap_crtc_dss_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
-/* Called only from omap_crtc_setup and suspend/resume handlers. */
+/* Called only from omap_crtc_encoder_setup and suspend/resume handlers. */
 static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 {
 	struct drm_device *dev = crtc->dev;
@@ -385,14 +384,14 @@ int omap_crtc_flush(struct drm_crtc *crtc)
 	return 0;
 }
 
-static void omap_crtc_setup(struct drm_crtc *crtc)
+static void omap_crtc_encoder_setup(struct drm_crtc *crtc, bool enable)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct drm_encoder *encoder = NULL;
 	unsigned int i;
 
-	DBG("%s: enabled=%d", omap_crtc->name, omap_crtc->enabled);
+	DBG("%s: enable=%d", omap_crtc->name, enable);
 
 	dispc_runtime_get();
 
@@ -408,14 +407,11 @@ static void omap_crtc_setup(struct drm_crtc *crtc)
 
 	omap_crtc->current_encoder = encoder;
 
-	if (!omap_crtc->enabled) {
-		if (encoder)
-			omap_encoder_set_enabled(encoder, false);
-	} else {
-		if (encoder) {
-			omap_encoder_set_enabled(encoder, false);
+	if (encoder) {
+		omap_encoder_set_enabled(encoder, false);
+		if (enable) {
 			omap_encoder_update(encoder, omap_crtc->mgr,
-					&omap_crtc->timings);
+					    &omap_crtc->timings);
 			omap_encoder_set_enabled(encoder, true);
 		}
 	}
@@ -456,9 +452,6 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	if (omap_crtc->enabled)
-		return;
-
 	/* Enable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
@@ -467,9 +460,7 @@ static void omap_crtc_enable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_set_enable(plane, true));
 	}
 
-	omap_crtc->enabled = true;
-
-	omap_crtc_setup(crtc);
+	omap_crtc_encoder_setup(crtc, true);
 	omap_crtc_flush(crtc);
 
 	dispc_runtime_get();
@@ -485,9 +476,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	if (!omap_crtc->enabled)
-		return;
-
 	omap_crtc_wait_page_flip(crtc);
 	dispc_runtime_get();
 	drm_crtc_vblank_off(crtc);
@@ -501,9 +489,7 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_set_enable(plane, false));
 	}
 
-	omap_crtc->enabled = false;
-
-	omap_crtc_setup(crtc);
+	omap_crtc_encoder_setup(crtc, false);
 	omap_crtc_flush(crtc);
 }
 

commit dee8260d9c2e6f43ebecd2777caff3524477bf9f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 19:00:18 2015 +0200

    drm: omapdrm: Move crtc info out of the crtc structure
    
    The crtc info structure is only used to setup the crtc through the DSS
    API. Move it from the crtc structure to local variables in
    omap_crtc_dss_enable().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index b32a6fb05338..430bf64521f0 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -35,7 +35,6 @@ struct omap_crtc {
 
 	const char *name;
 	enum omap_channel channel;
-	struct omap_overlay_manager_info info;
 	struct drm_encoder *current_encoder;
 
 	/*
@@ -188,8 +187,15 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 static int omap_crtc_dss_enable(struct omap_overlay_manager *mgr)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_overlay_manager_info info;
 
-	dispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);
+	memset(&info, 0, sizeof(info));
+	info.default_color = 0x00000000;
+	info.trans_key = 0x00000000;
+	info.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
+	info.trans_enabled = false;
+
+	dispc_mgr_setup(omap_crtc->channel, &info);
 	dispc_mgr_set_timings(omap_crtc->channel,
 			&omap_crtc->timings);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
@@ -628,7 +634,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 {
 	struct drm_crtc *crtc = NULL;
 	struct omap_crtc *omap_crtc;
-	struct omap_overlay_manager_info *info;
 	int ret;
 
 	DBG("%s", channel_names[channel]);
@@ -656,13 +661,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	/* temporary: */
 	omap_crtc->mgr = omap_dss_get_overlay_manager(channel);
 
-	/* TODO: fix hard-coded setup.. add properties! */
-	info = &omap_crtc->info;
-	info->default_color = 0x00000000;
-	info->trans_key = 0x00000000;
-	info->trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
-	info->trans_enabled = false;
-
 	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
 					&omap_crtc_funcs);
 	if (ret < 0) {

commit afc34932439fdf134be391581edcee180dd0de80
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 18:35:16 2015 +0200

    drm: omapdrm: Switch crtc and plane set_property to atomic helpers
    
    Allow setting up plane properties atomically using the plane
    set_property atomic helper. The properties are now stored in the plane
    state (requiring subclassing it) and applied when updating the planes.
    
    The CRTC exposes the properties of its primary plane for legacy reason.
    We can't get rid of that API, so simply delegate it to the primary
    plane.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 646563e47562..b32a6fb05338 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -540,17 +540,44 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
 	omap_crtc_flush(crtc);
 
 	dispc_runtime_put();
+
+	crtc->invert_dimensions = !!(crtc->primary->state->rotation &
+				    (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270)));
 }
 
-static int omap_crtc_set_property(struct drm_crtc *crtc,
-		struct drm_property *property, uint64_t val)
+static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
+					 struct drm_crtc_state *state,
+					 struct drm_property *property,
+					 uint64_t val)
 {
-	if (property == crtc->dev->mode_config.rotation_property) {
-		crtc->invert_dimensions =
-				!!(val & ((1LL << DRM_ROTATE_90) | (1LL << DRM_ROTATE_270)));
-	}
+	struct drm_plane_state *plane_state;
+	struct drm_plane *plane = crtc->primary;
+
+	/*
+	 * Delegate property set to the primary plane. Get the plane state and
+	 * set the property directly.
+	 */
+
+	plane_state = drm_atomic_get_plane_state(state->state, plane);
+	if (!plane_state)
+		return -EINVAL;
+
+	return drm_atomic_plane_set_property(plane, plane_state, property, val);
+}
 
-	return omap_plane_set_property(crtc->primary, property, val);
+static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
+					 const struct drm_crtc_state *state,
+					 struct drm_property *property,
+					 uint64_t *val)
+{
+	/*
+	 * Delegate property get to the primary plane. The
+	 * drm_atomic_plane_get_property() function isn't exported, but can be
+	 * called through drm_object_property_get_value() as that will call
+	 * drm_atomic_get_property() for atomic drivers.
+	 */
+	return drm_object_property_get_value(&crtc->primary->base, property,
+					     val);
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
@@ -558,9 +585,11 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.set_config = drm_atomic_helper_set_config,
 	.destroy = omap_crtc_destroy,
 	.page_flip = drm_atomic_helper_page_flip,
-	.set_property = omap_crtc_set_property,
+	.set_property = drm_atomic_helper_crtc_set_property,
 	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.atomic_set_property = omap_crtc_atomic_set_property,
+	.atomic_get_property = omap_crtc_atomic_get_property,
 };
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {

commit 9d29c1f2d5510fc7cb95cacc27016fab279fb881
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 18:49:37 2015 +0200

    drm: omapdrm: Drop manual framebuffer pin handling
    
    Since the removal of omap_plane_mode_set(), framebuffers are now pinned
    exclusively through the plane .prepare_fb() and .cleanup_fb() operations
    as the remaining callers of omap_plane_setup() don't modify the
    framebuffer. Remove the manual pin/unpin infrastructure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index a87ec26a883b..646563e47562 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -52,9 +52,6 @@ struct omap_crtc {
 	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
 
-	/* list of framebuffers to unpin */
-	struct list_head pending_unpins;
-
 	/* pending event */
 	struct drm_pending_vblank_event *event;
 	wait_queue_head_t flip_wait;
@@ -64,11 +61,6 @@ struct omap_crtc {
 	bool ignore_digit_sync_lost;
 };
 
-struct omap_framebuffer_unpin {
-	struct list_head list;
-	struct drm_framebuffer *fb;
-};
-
 /* -----------------------------------------------------------------------------
  * Helper Functions
  */
@@ -365,7 +357,6 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 int omap_crtc_flush(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_framebuffer_unpin *fb, *next;
 
 	DBG("%s: GO", omap_crtc->name);
 
@@ -385,29 +376,6 @@ int omap_crtc_flush(struct drm_crtc *crtc)
 
 	dispc_runtime_put();
 
-	/* Unpin and unreference pending framebuffers. */
-	list_for_each_entry_safe(fb, next, &omap_crtc->pending_unpins, list) {
-		omap_framebuffer_unpin(fb->fb);
-		drm_framebuffer_unreference(fb->fb);
-		list_del(&fb->list);
-		kfree(fb);
-	}
-
-	return 0;
-}
-
-int omap_crtc_queue_unpin(struct drm_crtc *crtc, struct drm_framebuffer *fb)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_framebuffer_unpin *unpin;
-
-	unpin = kzalloc(sizeof(*unpin), GFP_KERNEL);
-	if (!unpin)
-		return -ENOMEM;
-
-	unpin->fb = fb;
-	list_add_tail(&unpin->list, &omap_crtc->pending_unpins);
-
 	return 0;
 }
 
@@ -643,9 +611,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	crtc = &omap_crtc->base;
 
 	init_waitqueue_head(&omap_crtc->flip_wait);
-
-	INIT_LIST_HEAD(&omap_crtc->pending_unpins);
-
 	init_completion(&omap_crtc->completion);
 
 	omap_crtc->channel = channel;

commit fa16d26289a03c2cf5189a2693c5615644e56ec3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 16:01:53 2015 +0200

    drm: omapdrm: Switch page flip to atomic helpers
    
    The atomic page flip helper implements the page flip operation using
    asynchronous commits.
    
    As the legacy page flip was the last caller of omap_plane_mode_set(),
    remove the function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5216fb07b534..a87ec26a883b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -30,18 +30,10 @@
 
 #define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
 
-enum omap_page_flip_state {
-	OMAP_PAGE_FLIP_IDLE,
-	OMAP_PAGE_FLIP_WAIT,
-	OMAP_PAGE_FLIP_QUEUED,
-	OMAP_PAGE_FLIP_CANCELLED,
-};
-
 struct omap_crtc {
 	struct drm_crtc base;
 
 	const char *name;
-	int pipe;
 	enum omap_channel channel;
 	struct omap_overlay_manager_info info;
 	struct drm_encoder *current_encoder;
@@ -63,25 +55,9 @@ struct omap_crtc {
 	/* list of framebuffers to unpin */
 	struct list_head pending_unpins;
 
-	/*
-	 * flip_state flag indicates the current page flap state: IDLE if no
-	 * page queue has been submitted, WAIT when waiting for GEM async
-	 * completion, QUEUED when the page flip has been queued to the hardware
-	 * or CANCELLED when the CRTC is turned off before the flip gets queued
-	 * to the hardware. The flip event, if any, is stored in flip_event, and
-	 * the framebuffer queued for page flip is stored in flip_fb. The
-	 * flip_wait wait queue is used to wait for page flip completion.
-	 *
-	 * The flip_work work queue handles page flip requests without caring
-	 * about what context the GEM async callback is called from. Possibly we
-	 * should just make omap_gem always call the cb from the worker so we
-	 * don't have to care about this.
-	 */
-	enum omap_page_flip_state flip_state;
-	struct drm_pending_vblank_event *flip_event;
-	struct drm_framebuffer *flip_fb;
+	/* pending event */
+	struct drm_pending_vblank_event *event;
 	wait_queue_head_t flip_wait;
-	struct work_struct flip_work;
 
 	struct completion completion;
 
@@ -284,39 +260,46 @@ static const struct dss_mgr_ops mgr_ops = {
 void omap_crtc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_pending_vblank_event *event;
 	struct drm_device *dev = crtc->dev;
 	unsigned long flags;
 
+	/* Destroy the pending vertical blanking event associated with the
+	 * pending page flip, if any, and disable vertical blanking interrupts.
+	 */
+
 	spin_lock_irqsave(&dev->event_lock, flags);
 
-	/* Only complete events queued for our file handle. */
-	if (omap_crtc->flip_event &&
-	    file == omap_crtc->flip_event->base.file_priv) {
-		drm_send_vblank_event(dev, omap_crtc->pipe,
-				      omap_crtc->flip_event);
-		omap_crtc->flip_event = NULL;
+	event = omap_crtc->event;
+	omap_crtc->event = NULL;
+
+	if (event && event->base.file_priv == file) {
+		event->base.destroy(&event->base);
+		drm_crtc_vblank_put(crtc);
 	}
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
-/* Must be called with dev->event_lock locked. */
-static void omap_crtc_complete_page_flip(struct drm_crtc *crtc,
-					 enum omap_page_flip_state state)
+static void omap_crtc_complete_page_flip(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_pending_vblank_event *event;
 	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
 
-	if (omap_crtc->flip_event) {
-		drm_send_vblank_event(dev, omap_crtc->pipe,
-				      omap_crtc->flip_event);
-		omap_crtc->flip_event = NULL;
-	}
+	spin_lock_irqsave(&dev->event_lock, flags);
 
-	omap_crtc->flip_state = state;
+	event = omap_crtc->event;
+	omap_crtc->event = NULL;
 
-	if (state == OMAP_PAGE_FLIP_IDLE)
+	if (event) {
+		drm_crtc_send_vblank_event(crtc, event);
 		wake_up(&omap_crtc->flip_wait);
+		drm_crtc_vblank_put(crtc);
+	}
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
 static bool omap_crtc_page_flip_pending(struct drm_crtc *crtc)
@@ -327,7 +310,7 @@ static bool omap_crtc_page_flip_pending(struct drm_crtc *crtc)
 	bool pending;
 
 	spin_lock_irqsave(&dev->event_lock, flags);
-	pending = omap_crtc->flip_state != OMAP_PAGE_FLIP_IDLE;
+	pending = omap_crtc->event != NULL;
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 
 	return pending;
@@ -336,28 +319,6 @@ static bool omap_crtc_page_flip_pending(struct drm_crtc *crtc)
 static void omap_crtc_wait_page_flip(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_device *dev = crtc->dev;
-	bool cancelled = false;
-	unsigned long flags;
-
-	/*
-	 * If we're still waiting for the GEM async operation to complete just
-	 * cancel the page flip, as we're holding the CRTC mutex preventing the
-	 * page flip work handler from queueing the page flip.
-	 *
-	 * We can't release the reference to the frame buffer here as the async
-	 * operation doesn't keep its own reference to the buffer. We'll just
-	 * let the page flip work queue handle that.
-	 */
-	spin_lock_irqsave(&dev->event_lock, flags);
-	if (omap_crtc->flip_state == OMAP_PAGE_FLIP_WAIT) {
-		omap_crtc_complete_page_flip(crtc, OMAP_PAGE_FLIP_CANCELLED);
-		cancelled = true;
-	}
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-
-	if (cancelled)
-		return;
 
 	if (wait_event_timeout(omap_crtc->flip_wait,
 			       !omap_crtc_page_flip_pending(crtc),
@@ -366,9 +327,7 @@ static void omap_crtc_wait_page_flip(struct drm_crtc *crtc)
 
 	dev_warn(crtc->dev->dev, "page flip timeout!\n");
 
-	spin_lock_irqsave(&dev->event_lock, flags);
-	omap_crtc_complete_page_flip(crtc, OMAP_PAGE_FLIP_IDLE);
-	spin_unlock_irqrestore(&dev->event_lock, flags);
+	omap_crtc_complete_page_flip(crtc);
 }
 
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -390,7 +349,6 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	struct omap_crtc *omap_crtc =
 			container_of(irq, struct omap_crtc, vblank_irq);
 	struct drm_device *dev = omap_crtc->base.dev;
-	unsigned long flags;
 
 	if (dispc_mgr_go_busy(omap_crtc->channel))
 		return;
@@ -399,9 +357,7 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
 
 	/* wakeup userspace */
-	spin_lock_irqsave(&dev->event_lock, flags);
-	omap_crtc_complete_page_flip(&omap_crtc->base, OMAP_PAGE_FLIP_IDLE);
-	spin_unlock_irqrestore(&dev->event_lock, flags);
+	omap_crtc_complete_page_flip(&omap_crtc->base);
 
 	complete(&omap_crtc->completion);
 }
@@ -594,124 +550,28 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 {
-	dispc_runtime_get();
-}
-
-static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
-{
-	omap_crtc_flush(crtc);
-
-	dispc_runtime_put();
-}
-
-static void page_flip_worker(struct work_struct *work)
-{
-	struct omap_crtc *omap_crtc =
-			container_of(work, struct omap_crtc, flip_work);
-	struct drm_crtc *crtc = &omap_crtc->base;
-	struct drm_display_mode *mode = &crtc->mode;
-	struct drm_device *dev = crtc->dev;
-	struct drm_framebuffer *fb;
-	struct drm_gem_object *bo;
-	unsigned long flags;
-	bool queue_flip;
-
-	drm_modeset_lock(&crtc->mutex, NULL);
-
-	spin_lock_irqsave(&dev->event_lock, flags);
-
-	/*
-	 * The page flip could have been cancelled while waiting for the GEM
-	 * async operation to complete. Don't queue the flip in that case.
-	 */
-	if (omap_crtc->flip_state == OMAP_PAGE_FLIP_WAIT) {
-		omap_crtc->flip_state = OMAP_PAGE_FLIP_QUEUED;
-		queue_flip = true;
-	} else {
-		omap_crtc->flip_state = OMAP_PAGE_FLIP_IDLE;
-		queue_flip = false;
-	}
-
-	fb = omap_crtc->flip_fb;
-	omap_crtc->flip_fb = NULL;
-
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-
-	if (queue_flip) {
-		omap_plane_mode_set(crtc->primary, crtc, fb,
-				    0, 0, mode->hdisplay, mode->vdisplay,
-				    crtc->x, crtc->y, mode->hdisplay,
-				    mode->vdisplay);
-		omap_crtc_flush(crtc);
-	}
-
-	drm_modeset_unlock(&crtc->mutex);
-
-	bo = omap_framebuffer_bo(fb, 0);
-	drm_gem_object_unreference_unlocked(bo);
-	drm_framebuffer_unreference(fb);
-}
-
-static void page_flip_cb(void *arg)
-{
-	struct drm_crtc *crtc = arg;
+	struct drm_pending_vblank_event *event = crtc->state->event;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-
-	/* avoid assumptions about what ctxt we are called from: */
-	queue_work(priv->wq, &omap_crtc->flip_work);
-}
-
-static int omap_crtc_page_flip(struct drm_crtc *crtc,
-			       struct drm_framebuffer *fb,
-			       struct drm_pending_vblank_event *event,
-			       uint32_t page_flip_flags)
-{
 	struct drm_device *dev = crtc->dev;
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_plane *primary = crtc->primary;
-	struct drm_gem_object *bo;
 	unsigned long flags;
 
-	DBG("%d -> %d (event=%p)", primary->fb ? primary->fb->base.id : -1,
-			fb->base.id, event);
+	dispc_runtime_get();
 
-	spin_lock_irqsave(&dev->event_lock, flags);
+	if (event) {
+		WARN_ON(omap_crtc->event);
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
 
-	if (omap_crtc->flip_state != OMAP_PAGE_FLIP_IDLE) {
+		spin_lock_irqsave(&dev->event_lock, flags);
+		omap_crtc->event = event;
 		spin_unlock_irqrestore(&dev->event_lock, flags);
-		dev_err(dev->dev, "already a pending flip\n");
-		return -EBUSY;
 	}
+}
 
-	/*
-	 * Store a reference to the framebuffer queued for page flip in the CRTC
-	 * private structure. We can't rely on crtc->primary->fb in the page
-	 * flip worker, as a racing CRTC disable (due for instance to an
-	 * explicit framebuffer deletion from userspace) would set that field to
-	 * NULL before the worker gets a change to run.
-	 */
-	drm_framebuffer_reference(fb);
-	omap_crtc->flip_fb = fb;
-	omap_crtc->flip_event = event;
-	omap_crtc->flip_state = OMAP_PAGE_FLIP_WAIT;
-
-	drm_atomic_set_fb_for_plane(primary->state, fb);
-	primary->fb = fb;
-
-	spin_unlock_irqrestore(&dev->event_lock, flags);
-
-	/*
-	 * Hold a reference temporarily until the crtc is updated
-	 * and takes the reference to the bo.  This avoids it
-	 * getting freed from under us:
-	 */
-	bo = omap_framebuffer_bo(fb, 0);
-	drm_gem_object_reference(bo);
-
-	omap_gem_op_async(bo, OMAP_GEM_READ, page_flip_cb, crtc);
+static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
+{
+	omap_crtc_flush(crtc);
 
-	return 0;
+	dispc_runtime_put();
 }
 
 static int omap_crtc_set_property(struct drm_crtc *crtc,
@@ -729,7 +589,7 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.reset = drm_atomic_helper_crtc_reset,
 	.set_config = drm_atomic_helper_set_config,
 	.destroy = omap_crtc_destroy,
-	.page_flip = omap_crtc_page_flip,
+	.page_flip = drm_atomic_helper_page_flip,
 	.set_property = omap_crtc_set_property,
 	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
@@ -782,7 +642,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	crtc = &omap_crtc->base;
 
-	INIT_WORK(&omap_crtc->flip_work, page_flip_worker);
 	init_waitqueue_head(&omap_crtc->flip_wait);
 
 	INIT_LIST_HEAD(&omap_crtc->pending_unpins);
@@ -791,7 +650,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];
-	omap_crtc->pipe = id;
 
 	omap_crtc->vblank_irq.irqmask = pipe2vbl(crtc);
 	omap_crtc->vblank_irq.irq = omap_crtc_vblank_irq;

commit aea3cab1d109e37a06ac3f269444dffdfdc0347a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 22:50:51 2015 +0200

    drm: omapdrm: Switch connector DPMS to atomic helpers
    
    The atomic connector DPMS helper implements the connector DPMS operation
    using atomic commit, removing the need for DPMS helper operations on
    CRTCs and encoders.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 68bf38bd0ce2..5216fb07b534 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -592,19 +592,6 @@ static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
 }
 
-static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	bool enable = (mode == DRM_MODE_DPMS_ON);
-
-	DBG("%s: %d", omap_crtc->name, mode);
-
-	if (enable)
-		omap_crtc_enable(crtc);
-	else
-		omap_crtc_disable(crtc);
-}
-
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 {
 	dispc_runtime_get();
@@ -749,7 +736,6 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 };
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
-	.dpms = omap_crtc_dpms,
 	.mode_fixup = omap_crtc_mode_fixup,
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
 	.disable = omap_crtc_disable,

commit 9416c9df8e05e375af859cfa856e1353e5a72d0d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:54:54 2015 +0200

    drm: omapdrm: Switch mode config to atomic helpers
    
    This removes the legacy mode config code. The CRTC and encoder prepare
    and commit operations are not used anymore, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 31d50533d538..68bf38bd0ce2 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -571,23 +571,6 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_set_enable(plane, false));
 	}
 
-	/*
-	 * HACK: Unpin the primary plane frame buffer if we're disabled without
-	 * going through full mode set.
-	 * HACK: The legacy set config helper drm_crtc_helper_set_config() that
-	 * we still use calls the .disable() operation directly when called with
-	 * a NULL frame buffer (for instance from drm_fb_release()). As a result
-	 * the CRTC is disabled without going through a full mode set, and the
-	 * primary plane' framebuffer is kept pin. Unpin it manually here until
-	 * we switch to the atomic set config helper.
-	 */
-	if (crtc->primary->fb) {
-		const struct drm_plane_helper_funcs *funcs;
-
-		funcs = crtc->primary->helper_private;
-		funcs->cleanup_fb(crtc->primary, crtc->primary->fb, NULL);
-	}
-
 	omap_crtc->enabled = false;
 
 	omap_crtc_setup(crtc);
@@ -622,20 +605,6 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 		omap_crtc_disable(crtc);
 }
 
-static void omap_crtc_prepare(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	DBG("%s", omap_crtc->name);
-	omap_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);
-}
-
-static void omap_crtc_commit(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	DBG("%s", omap_crtc->name);
-	omap_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
-}
-
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 {
 	dispc_runtime_get();
@@ -771,7 +740,7 @@ static int omap_crtc_set_property(struct drm_crtc *crtc,
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.reset = drm_atomic_helper_crtc_reset,
-	.set_config = drm_crtc_helper_set_config,
+	.set_config = drm_atomic_helper_set_config,
 	.destroy = omap_crtc_destroy,
 	.page_flip = omap_crtc_page_flip,
 	.set_property = omap_crtc_set_property,
@@ -782,11 +751,7 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.dpms = omap_crtc_dpms,
 	.mode_fixup = omap_crtc_mode_fixup,
-	.mode_set = drm_helper_crtc_mode_set,
-	.prepare = omap_crtc_prepare,
-	.commit = omap_crtc_commit,
 	.mode_set_nofb = omap_crtc_mode_set_nofb,
-	.mode_set_base = drm_helper_crtc_mode_set_base,
 	.disable = omap_crtc_disable,
 	.enable = omap_crtc_enable,
 	.atomic_begin = omap_crtc_atomic_begin,

commit f7a73b654710d5c0ff0c1b6ad5054336fb47e572
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 13:45:14 2015 +0200

    drm: omapdrm: Handle primary plane config through atomic plane ops
    
    Use the new CRTC atomic transitional helpers drm_helper_crtc_mode_set()
    and drm_helper_crtc_mode_set_base() to implement the CRTC .mode_set and
    .mode_set_base operations. This delegates primary plane configuration to
    the plane .atomic_update and .atomic_disable operations, removing
    duplicate code from the CRTC implementation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 277cad1dacf7..31d50533d538 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -571,42 +571,42 @@ static void omap_crtc_disable(struct drm_crtc *crtc)
 			WARN_ON(omap_plane_set_enable(plane, false));
 	}
 
+	/*
+	 * HACK: Unpin the primary plane frame buffer if we're disabled without
+	 * going through full mode set.
+	 * HACK: The legacy set config helper drm_crtc_helper_set_config() that
+	 * we still use calls the .disable() operation directly when called with
+	 * a NULL frame buffer (for instance from drm_fb_release()). As a result
+	 * the CRTC is disabled without going through a full mode set, and the
+	 * primary plane' framebuffer is kept pin. Unpin it manually here until
+	 * we switch to the atomic set config helper.
+	 */
+	if (crtc->primary->fb) {
+		const struct drm_plane_helper_funcs *funcs;
+
+		funcs = crtc->primary->helper_private;
+		funcs->cleanup_fb(crtc->primary, crtc->primary->fb, NULL);
+	}
+
 	omap_crtc->enabled = false;
 
 	omap_crtc_setup(crtc);
 	omap_crtc_flush(crtc);
 }
 
-static int omap_crtc_mode_set(struct drm_crtc *crtc,
-		struct drm_display_mode *mode,
-		struct drm_display_mode *adjusted_mode,
-		int x, int y,
-		struct drm_framebuffer *old_fb)
+static void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	mode = adjusted_mode;
+	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
 
 	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
-			omap_crtc->name, mode->base.id, mode->name,
-			mode->vrefresh, mode->clock,
-			mode->hdisplay, mode->hsync_start,
-			mode->hsync_end, mode->htotal,
-			mode->vdisplay, mode->vsync_start,
-			mode->vsync_end, mode->vtotal,
-			mode->type, mode->flags);
+	    omap_crtc->name, mode->base.id, mode->name,
+	    mode->vrefresh, mode->clock,
+	    mode->hdisplay, mode->hsync_start, mode->hsync_end, mode->htotal,
+	    mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,
+	    mode->type, mode->flags);
 
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
-
-	/*
-	 * The primary plane CRTC can be reset if the plane is disabled directly
-	 * through the universal plane API. Set it again here.
-	 */
-	crtc->primary->crtc = crtc;
-
-	return omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
-				   0, 0, mode->hdisplay, mode->vdisplay,
-				   x, y, mode->hdisplay, mode->vdisplay);
 }
 
 static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
@@ -636,22 +636,6 @@ static void omap_crtc_commit(struct drm_crtc *crtc)
 	omap_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
 }
 
-static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
-		struct drm_framebuffer *old_fb)
-{
-	struct drm_plane *plane = crtc->primary;
-	struct drm_display_mode *mode = &crtc->mode;
-	int ret;
-
-	ret = omap_plane_mode_set(plane, crtc, crtc->primary->fb,
-				  0, 0, mode->hdisplay, mode->vdisplay,
-				  x, y, mode->hdisplay, mode->vdisplay);
-	if (ret < 0)
-		return ret;
-
-	return omap_crtc_flush(crtc);
-}
-
 static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
 {
 	dispc_runtime_get();
@@ -798,10 +782,11 @@ static const struct drm_crtc_funcs omap_crtc_funcs = {
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.dpms = omap_crtc_dpms,
 	.mode_fixup = omap_crtc_mode_fixup,
-	.mode_set = omap_crtc_mode_set,
+	.mode_set = drm_helper_crtc_mode_set,
 	.prepare = omap_crtc_prepare,
 	.commit = omap_crtc_commit,
-	.mode_set_base = omap_crtc_mode_set_base,
+	.mode_set_nofb = omap_crtc_mode_set_nofb,
+	.mode_set_base = drm_helper_crtc_mode_set_base,
 	.disable = omap_crtc_disable,
 	.enable = omap_crtc_enable,
 	.atomic_begin = omap_crtc_atomic_begin,

commit de8e41000136bf9a0ccf652fc364658f3210b6f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 13:39:56 2015 +0200

    drm: omapdrm: Implement planes atomic operations
    
    Implement the CRTC .atomic_begin() and .atomic_flush() operations, the
    plane .atomic_check(), .atomic_update() and operations, and use the
    transitional atomic helpers to implement the plane update and disable
    operations on top of the new atomic operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5f4f5ad93345..277cad1dacf7 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -652,6 +652,18 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 	return omap_crtc_flush(crtc);
 }
 
+static void omap_crtc_atomic_begin(struct drm_crtc *crtc)
+{
+	dispc_runtime_get();
+}
+
+static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
+{
+	omap_crtc_flush(crtc);
+
+	dispc_runtime_put();
+}
+
 static void page_flip_worker(struct work_struct *work)
 {
 	struct omap_crtc *omap_crtc =
@@ -792,6 +804,8 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.mode_set_base = omap_crtc_mode_set_base,
 	.disable = omap_crtc_disable,
 	.enable = omap_crtc_enable,
+	.atomic_begin = omap_crtc_atomic_begin,
+	.atomic_flush = omap_crtc_atomic_flush,
 };
 
 /* -----------------------------------------------------------------------------

commit 69a12263f6f919cd53b10c849e1674e38931e74e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:38:16 2015 +0200

    drm: omapdrm: Wire up atomic state object scaffolding
    
    Hook up the default .reset(), .atomic_duplicate_state() and
    .atomic_free_state() helpers to ensure that state objects are properly
    created and destroyed, and call drm_mode_config_reset() at init time to
    create the initial state objects.
    
    Framebuffer reference count also gets maintained automatically by the
    transitional helpers except for the legacy page flip operation. Maintain
    it explicitly there.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 0359a67f8f8d..5f4f5ad93345 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -19,6 +19,8 @@
 
 #include <linux/completion.h>
 
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_mode.h>
@@ -742,6 +744,7 @@ static int omap_crtc_page_flip(struct drm_crtc *crtc,
 	omap_crtc->flip_event = event;
 	omap_crtc->flip_state = OMAP_PAGE_FLIP_WAIT;
 
+	drm_atomic_set_fb_for_plane(primary->state, fb);
 	primary->fb = fb;
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
@@ -771,10 +774,13 @@ static int omap_crtc_set_property(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
+	.reset = drm_atomic_helper_crtc_reset,
 	.set_config = drm_crtc_helper_set_config,
 	.destroy = omap_crtc_destroy,
 	.page_flip = omap_crtc_page_flip,
 	.set_property = omap_crtc_set_property,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
 };
 
 static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {

commit f1d57fb5172a27a481553439b22d8c751512f202
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 22:13:22 2015 +0200

    drm: omapdrm: Rework CRTC enable/disable for atomic updates
    
    When using atomic updates the CRTC .enable() and .disable() helper
    operations are preferred over the (then legacy) .prepare() and .commit()
    operations. Implement .enable() and rework .disable() to not depend on
    DPMS, easing DPMS removal later on.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 94c1bb8448be..0359a67f8f8d 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -509,50 +509,70 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 	kfree(omap_crtc);
 }
 
-static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
+static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
+		const struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static void omap_crtc_enable(struct drm_crtc *crtc)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	bool enable = (mode == DRM_MODE_DPMS_ON);
-	int i;
+	unsigned int i;
 
-	DBG("%s: %d", omap_crtc->name, mode);
+	DBG("%s", omap_crtc->name);
 
-	if (enable == omap_crtc->enabled)
+	if (omap_crtc->enabled)
 		return;
 
-	if (!enable) {
-		omap_crtc_wait_page_flip(crtc);
-		dispc_runtime_get();
-		drm_crtc_vblank_off(crtc);
-		dispc_runtime_put();
-	}
-
-	/* Enable/disable all planes associated with the CRTC. */
+	/* Enable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
 
 		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_set_enable(plane, enable));
+			WARN_ON(omap_plane_set_enable(plane, true));
 	}
 
-	omap_crtc->enabled = enable;
+	omap_crtc->enabled = true;
 
 	omap_crtc_setup(crtc);
 	omap_crtc_flush(crtc);
 
-	if (enable) {
-		dispc_runtime_get();
-		drm_crtc_vblank_on(crtc);
-		dispc_runtime_put();
-	}
+	dispc_runtime_get();
+	drm_crtc_vblank_on(crtc);
+	dispc_runtime_put();
 }
 
-static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
-		const struct drm_display_mode *mode,
-		struct drm_display_mode *adjusted_mode)
+static void omap_crtc_disable(struct drm_crtc *crtc)
 {
-	return true;
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	unsigned int i;
+
+	DBG("%s", omap_crtc->name);
+
+	if (!omap_crtc->enabled)
+		return;
+
+	omap_crtc_wait_page_flip(crtc);
+	dispc_runtime_get();
+	drm_crtc_vblank_off(crtc);
+	dispc_runtime_put();
+
+	/* Disable all planes associated with the CRTC. */
+	for (i = 0; i < priv->num_planes; i++) {
+		struct drm_plane *plane = priv->planes[i];
+
+		if (plane->crtc == crtc)
+			WARN_ON(omap_plane_set_enable(plane, false));
+	}
+
+	omap_crtc->enabled = false;
+
+	omap_crtc_setup(crtc);
+	omap_crtc_flush(crtc);
 }
 
 static int omap_crtc_mode_set(struct drm_crtc *crtc,
@@ -587,6 +607,19 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 				   x, y, mode->hdisplay, mode->vdisplay);
 }
 
+static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	bool enable = (mode == DRM_MODE_DPMS_ON);
+
+	DBG("%s: %d", omap_crtc->name, mode);
+
+	if (enable)
+		omap_crtc_enable(crtc);
+	else
+		omap_crtc_disable(crtc);
+}
+
 static void omap_crtc_prepare(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -751,6 +784,8 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.prepare = omap_crtc_prepare,
 	.commit = omap_crtc_commit,
 	.mode_set_base = omap_crtc_mode_set_base,
+	.disable = omap_crtc_disable,
+	.enable = omap_crtc_enable,
 };
 
 /* -----------------------------------------------------------------------------

commit 4343f0f85781d7821964fcf346d4c8aaf1f5d130
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 22:01:02 2015 +0200

    drm: omapdrm: Rename CRTC DSS operations with an omap_crtc_dss_ prefix
    
    The omap_crtc_enable() and omap_crtc_disable() DSS operations functions
    will clash with the new CRTC enable and disable helpers. Rename them to
    omap_crtc_dss_*, as well as the other DSS operations for consistency.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 6840ed5c45a7..94c1bb8448be 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -131,7 +131,7 @@ enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
 static struct omap_crtc *omap_crtcs[8];
 
 /* we can probably ignore these until we support command-mode panels: */
-static int omap_crtc_connect(struct omap_overlay_manager *mgr,
+static int omap_crtc_dss_connect(struct omap_overlay_manager *mgr,
 		struct omap_dss_device *dst)
 {
 	if (mgr->output)
@@ -146,14 +146,14 @@ static int omap_crtc_connect(struct omap_overlay_manager *mgr,
 	return 0;
 }
 
-static void omap_crtc_disconnect(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_disconnect(struct omap_overlay_manager *mgr,
 		struct omap_dss_device *dst)
 {
 	mgr->output->manager = NULL;
 	mgr->output = NULL;
 }
 
-static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
+static void omap_crtc_dss_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
@@ -215,7 +215,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 }
 
 
-static int omap_crtc_enable(struct omap_overlay_manager *mgr)
+static int omap_crtc_dss_enable(struct omap_overlay_manager *mgr)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 
@@ -227,14 +227,14 @@ static int omap_crtc_enable(struct omap_overlay_manager *mgr)
 	return 0;
 }
 
-static void omap_crtc_disable(struct omap_overlay_manager *mgr)
+static void omap_crtc_dss_disable(struct omap_overlay_manager *mgr)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 
 	omap_crtc_set_enabled(&omap_crtc->base, false);
 }
 
-static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_set_timings(struct omap_overlay_manager *mgr,
 		const struct omap_video_timings *timings)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
@@ -242,7 +242,7 @@ static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
 	omap_crtc->timings = *timings;
 }
 
-static void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,
+static void omap_crtc_dss_set_lcd_config(struct omap_overlay_manager *mgr,
 		const struct dss_lcd_mgr_config *config)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
@@ -250,29 +250,29 @@ static void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,
 	dispc_mgr_set_lcd_config(omap_crtc->channel, config);
 }
 
-static int omap_crtc_register_framedone_handler(
+static int omap_crtc_dss_register_framedone(
 		struct omap_overlay_manager *mgr,
 		void (*handler)(void *), void *data)
 {
 	return 0;
 }
 
-static void omap_crtc_unregister_framedone_handler(
+static void omap_crtc_dss_unregister_framedone(
 		struct omap_overlay_manager *mgr,
 		void (*handler)(void *), void *data)
 {
 }
 
 static const struct dss_mgr_ops mgr_ops = {
-	.connect = omap_crtc_connect,
-	.disconnect = omap_crtc_disconnect,
-	.start_update = omap_crtc_start_update,
-	.enable = omap_crtc_enable,
-	.disable = omap_crtc_disable,
-	.set_timings = omap_crtc_set_timings,
-	.set_lcd_config = omap_crtc_set_lcd_config,
-	.register_framedone_handler = omap_crtc_register_framedone_handler,
-	.unregister_framedone_handler = omap_crtc_unregister_framedone_handler,
+	.connect = omap_crtc_dss_connect,
+	.disconnect = omap_crtc_dss_disconnect,
+	.start_update = omap_crtc_dss_start_update,
+	.enable = omap_crtc_dss_enable,
+	.disable = omap_crtc_dss_disable,
+	.set_timings = omap_crtc_dss_set_timings,
+	.set_lcd_config = omap_crtc_dss_set_lcd_config,
+	.register_framedone_handler = omap_crtc_dss_register_framedone,
+	.unregister_framedone_handler = omap_crtc_dss_unregister_framedone,
 };
 
 /* -----------------------------------------------------------------------------

commit 2d278f5414ae9cd535a7bdefaba2e2de38e116c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:31:37 2015 +0200

    drm: omapdrm: Clean up #include's
    
    Use the <...> include style instead of "..." for DRM headers and sort
    the headers alphabetically to ease detection of duplicates.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 68abc4d7fa0d..6840ed5c45a7 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -19,12 +19,12 @@
 
 #include <linux/completion.h>
 
-#include "omap_drv.h"
-
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
 #include <drm/drm_mode.h>
 #include <drm/drm_plane_helper.h>
-#include "drm_crtc.h"
-#include "drm_crtc_helper.h"
+
+#include "omap_drv.h"
 
 #define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
 

commit 0c19ac9d033eed734b0e38c9147a1c893c0e4b12
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 4 18:24:18 2015 +0200

    drm: omapdrm: Fix page flip race with CRTC disable
    
    We can't rely on crtc->primary->fb in the page flip worker, as a racing
    CRTC disable (due for instance to an explicit framebuffer deletion from
    userspace) would set that field to NULL before the worker gets a change
    to run. Store the framebuffer queued for page flip in a new field of
    omap_crtc instead, and hold a reference to it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 1076bc0a7f78..68abc4d7fa0d 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -66,7 +66,8 @@ struct omap_crtc {
 	 * page queue has been submitted, WAIT when waiting for GEM async
 	 * completion, QUEUED when the page flip has been queued to the hardware
 	 * or CANCELLED when the CRTC is turned off before the flip gets queued
-	 * to the hardware. The flip event, if any, is stored in flip_event. The
+	 * to the hardware. The flip event, if any, is stored in flip_event, and
+	 * the framebuffer queued for page flip is stored in flip_fb. The
 	 * flip_wait wait queue is used to wait for page flip completion.
 	 *
 	 * The flip_work work queue handles page flip requests without caring
@@ -76,6 +77,7 @@ struct omap_crtc {
 	 */
 	enum omap_page_flip_state flip_state;
 	struct drm_pending_vblank_event *flip_event;
+	struct drm_framebuffer *flip_fb;
 	wait_queue_head_t flip_wait;
 	struct work_struct flip_work;
 
@@ -630,6 +632,7 @@ static void page_flip_worker(struct work_struct *work)
 	drm_modeset_lock(&crtc->mutex, NULL);
 
 	spin_lock_irqsave(&dev->event_lock, flags);
+
 	/*
 	 * The page flip could have been cancelled while waiting for the GEM
 	 * async operation to complete. Don't queue the flip in that case.
@@ -641,9 +644,11 @@ static void page_flip_worker(struct work_struct *work)
 		omap_crtc->flip_state = OMAP_PAGE_FLIP_IDLE;
 		queue_flip = false;
 	}
-	spin_unlock_irqrestore(&dev->event_lock, flags);
 
-	fb = crtc->primary->fb;
+	fb = omap_crtc->flip_fb;
+	omap_crtc->flip_fb = NULL;
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
 
 	if (queue_flip) {
 		omap_plane_mode_set(crtc->primary, crtc, fb,
@@ -657,7 +662,7 @@ static void page_flip_worker(struct work_struct *work)
 
 	bo = omap_framebuffer_bo(fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
-	drm_framebuffer_unreference(crtc->primary->fb);
+	drm_framebuffer_unreference(fb);
 }
 
 static void page_flip_cb(void *arg)
@@ -692,10 +697,19 @@ static int omap_crtc_page_flip(struct drm_crtc *crtc,
 		return -EBUSY;
 	}
 
+	/*
+	 * Store a reference to the framebuffer queued for page flip in the CRTC
+	 * private structure. We can't rely on crtc->primary->fb in the page
+	 * flip worker, as a racing CRTC disable (due for instance to an
+	 * explicit framebuffer deletion from userspace) would set that field to
+	 * NULL before the worker gets a change to run.
+	 */
+	drm_framebuffer_reference(fb);
+	omap_crtc->flip_fb = fb;
 	omap_crtc->flip_event = event;
 	omap_crtc->flip_state = OMAP_PAGE_FLIP_WAIT;
+
 	primary->fb = fb;
-	drm_framebuffer_reference(fb);
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 

commit c397cfd496f8b129a44962e84a9206afa0d7e431
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 25 22:42:30 2015 +0200

    drm: omapdrm: Turn vblank on/off when enabling/disabling CRTC
    
    The DRM core vblank handling mechanism requires drivers to forcefully
    turn vblank reporting off when disabling the CRTC, and to restore the
    vblank reporting status when enabling the CRTC.
    
    Implement this using the drm_crtc_vblank_on/off helpers. When disabling
    vblank we must first wait for page flips to complete, so implement page
    flip completion wait as well.
    
    Finally, drm_crtc_vblank_off() must be called at startup to synchronize
    the state of the vblank core code with the hardware, which is initially
    disabled. An interesting side effect is that the .disable_vblank()
    operation will now be called for the first time with the CRTC disabled
    and the DISPC runtime suspended. The dispc_runtime_get() call in
    .disable_vblank() is supposed to take care of that, but the operation is
    called with a spinlock held, which prevents it from sleeping.
    
    To fix that move DISPC runtime PM handling out of the vblank operations
    to the CRTC code, ensuring that the display controller will always be
    powered when enabling or disabling vblank interrupts.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c086f72e488d..1076bc0a7f78 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -76,6 +76,7 @@ struct omap_crtc {
 	 */
 	enum omap_page_flip_state flip_state;
 	struct drm_pending_vblank_event *flip_event;
+	wait_queue_head_t flip_wait;
 	struct work_struct flip_work;
 
 	struct completion completion;
@@ -309,6 +310,61 @@ static void omap_crtc_complete_page_flip(struct drm_crtc *crtc,
 	}
 
 	omap_crtc->flip_state = state;
+
+	if (state == OMAP_PAGE_FLIP_IDLE)
+		wake_up(&omap_crtc->flip_wait);
+}
+
+static bool omap_crtc_page_flip_pending(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
+	bool pending;
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+	pending = omap_crtc->flip_state != OMAP_PAGE_FLIP_IDLE;
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	return pending;
+}
+
+static void omap_crtc_wait_page_flip(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+	bool cancelled = false;
+	unsigned long flags;
+
+	/*
+	 * If we're still waiting for the GEM async operation to complete just
+	 * cancel the page flip, as we're holding the CRTC mutex preventing the
+	 * page flip work handler from queueing the page flip.
+	 *
+	 * We can't release the reference to the frame buffer here as the async
+	 * operation doesn't keep its own reference to the buffer. We'll just
+	 * let the page flip work queue handle that.
+	 */
+	spin_lock_irqsave(&dev->event_lock, flags);
+	if (omap_crtc->flip_state == OMAP_PAGE_FLIP_WAIT) {
+		omap_crtc_complete_page_flip(crtc, OMAP_PAGE_FLIP_CANCELLED);
+		cancelled = true;
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	if (cancelled)
+		return;
+
+	if (wait_event_timeout(omap_crtc->flip_wait,
+			       !omap_crtc_page_flip_pending(crtc),
+			       msecs_to_jiffies(50)))
+		return;
+
+	dev_warn(crtc->dev->dev, "page flip timeout!\n");
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+	omap_crtc_complete_page_flip(crtc, OMAP_PAGE_FLIP_IDLE);
+	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -455,26 +511,39 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 {
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	bool enabled = (mode == DRM_MODE_DPMS_ON);
+	bool enable = (mode == DRM_MODE_DPMS_ON);
 	int i;
 
 	DBG("%s: %d", omap_crtc->name, mode);
 
-	if (enabled == omap_crtc->enabled)
+	if (enable == omap_crtc->enabled)
 		return;
 
+	if (!enable) {
+		omap_crtc_wait_page_flip(crtc);
+		dispc_runtime_get();
+		drm_crtc_vblank_off(crtc);
+		dispc_runtime_put();
+	}
+
 	/* Enable/disable all planes associated with the CRTC. */
 	for (i = 0; i < priv->num_planes; i++) {
 		struct drm_plane *plane = priv->planes[i];
 
 		if (plane->crtc == crtc)
-			WARN_ON(omap_plane_set_enable(plane, enabled));
+			WARN_ON(omap_plane_set_enable(plane, enable));
 	}
 
-	omap_crtc->enabled = enabled;
+	omap_crtc->enabled = enable;
 
 	omap_crtc_setup(crtc);
 	omap_crtc_flush(crtc);
+
+	if (enable) {
+		dispc_runtime_get();
+		drm_crtc_vblank_on(crtc);
+		dispc_runtime_put();
+	}
 }
 
 static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
@@ -709,6 +778,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	crtc = &omap_crtc->base;
 
 	INIT_WORK(&omap_crtc->flip_work, page_flip_worker);
+	init_waitqueue_head(&omap_crtc->flip_wait);
 
 	INIT_LIST_HEAD(&omap_crtc->pending_unpins);
 

commit 15d02e921c3e9859d4ffb5308013b5e67cd70749
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 25 22:42:30 2015 +0200

    drm: omapdrm: Rework page flip handling
    
    To implement proper vblank control the driver will need to wait for page
    flip completion before disabling the vblank interrupt. This is made
    complex by the page flip implementation which queues and submits page
    flips to the hardware in two separate steps between which DRM locks are
    released. We thus need to avoid waiting on a page flip that has been
    queued but not submitted as submission and wait are covered by the same
    lock.
    
    Rework page flip handling as a first step by splitting the flip_pending
    boolean variable into an enumerated state and moving between states
    based on flip queue, submission and completion. The CANCELLED state will
    be used in a second step.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index a60f4e49b55f..c086f72e488d 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -28,6 +28,13 @@
 
 #define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
 
+enum omap_page_flip_state {
+	OMAP_PAGE_FLIP_IDLE,
+	OMAP_PAGE_FLIP_WAIT,
+	OMAP_PAGE_FLIP_QUEUED,
+	OMAP_PAGE_FLIP_CANCELLED,
+};
+
 struct omap_crtc {
 	struct drm_crtc base;
 
@@ -55,16 +62,19 @@ struct omap_crtc {
 	struct list_head pending_unpins;
 
 	/*
-	 * The flip_pending flag indicates if a page flip has been queued and
-	 * hasn't completed yet. The flip event, if any, is stored in
-	 * flip_event.
+	 * flip_state flag indicates the current page flap state: IDLE if no
+	 * page queue has been submitted, WAIT when waiting for GEM async
+	 * completion, QUEUED when the page flip has been queued to the hardware
+	 * or CANCELLED when the CRTC is turned off before the flip gets queued
+	 * to the hardware. The flip event, if any, is stored in flip_event. The
+	 * flip_wait wait queue is used to wait for page flip completion.
 	 *
 	 * The flip_work work queue handles page flip requests without caring
 	 * about what context the GEM async callback is called from. Possibly we
 	 * should just make omap_gem always call the cb from the worker so we
 	 * don't have to care about this.
 	 */
-	bool flip_pending;
+	enum omap_page_flip_state flip_state;
 	struct drm_pending_vblank_event *flip_event;
 	struct work_struct flip_work;
 
@@ -285,6 +295,22 @@ void omap_crtc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
+/* Must be called with dev->event_lock locked. */
+static void omap_crtc_complete_page_flip(struct drm_crtc *crtc,
+					 enum omap_page_flip_state state)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+
+	if (omap_crtc->flip_event) {
+		drm_send_vblank_event(dev, omap_crtc->pipe,
+				      omap_crtc->flip_event);
+		omap_crtc->flip_event = NULL;
+	}
+
+	omap_crtc->flip_state = state;
+}
+
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 {
 	struct omap_crtc *omap_crtc =
@@ -312,16 +338,9 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	DBG("%s: apply done", omap_crtc->name);
 	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
 
-	spin_lock_irqsave(&dev->event_lock, flags);
-
 	/* wakeup userspace */
-	if (omap_crtc->flip_event)
-		drm_send_vblank_event(dev, omap_crtc->pipe,
-				      omap_crtc->flip_event);
-
-	omap_crtc->flip_event = NULL;
-	omap_crtc->flip_pending = false;
-
+	spin_lock_irqsave(&dev->event_lock, flags);
+	omap_crtc_complete_page_flip(&omap_crtc->base, OMAP_PAGE_FLIP_IDLE);
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 
 	complete(&omap_crtc->completion);
@@ -533,16 +552,41 @@ static void page_flip_worker(struct work_struct *work)
 			container_of(work, struct omap_crtc, flip_work);
 	struct drm_crtc *crtc = &omap_crtc->base;
 	struct drm_display_mode *mode = &crtc->mode;
+	struct drm_device *dev = crtc->dev;
+	struct drm_framebuffer *fb;
 	struct drm_gem_object *bo;
+	unsigned long flags;
+	bool queue_flip;
 
 	drm_modeset_lock(&crtc->mutex, NULL);
-	omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
-			    0, 0, mode->hdisplay, mode->vdisplay,
-			    crtc->x, crtc->y, mode->hdisplay, mode->vdisplay);
-	omap_crtc_flush(crtc);
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+	/*
+	 * The page flip could have been cancelled while waiting for the GEM
+	 * async operation to complete. Don't queue the flip in that case.
+	 */
+	if (omap_crtc->flip_state == OMAP_PAGE_FLIP_WAIT) {
+		omap_crtc->flip_state = OMAP_PAGE_FLIP_QUEUED;
+		queue_flip = true;
+	} else {
+		omap_crtc->flip_state = OMAP_PAGE_FLIP_IDLE;
+		queue_flip = false;
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	fb = crtc->primary->fb;
+
+	if (queue_flip) {
+		omap_plane_mode_set(crtc->primary, crtc, fb,
+				    0, 0, mode->hdisplay, mode->vdisplay,
+				    crtc->x, crtc->y, mode->hdisplay,
+				    mode->vdisplay);
+		omap_crtc_flush(crtc);
+	}
+
 	drm_modeset_unlock(&crtc->mutex);
 
-	bo = omap_framebuffer_bo(crtc->primary->fb, 0);
+	bo = omap_framebuffer_bo(fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
 	drm_framebuffer_unreference(crtc->primary->fb);
 }
@@ -573,14 +617,14 @@ static int omap_crtc_page_flip(struct drm_crtc *crtc,
 
 	spin_lock_irqsave(&dev->event_lock, flags);
 
-	if (omap_crtc->flip_pending) {
+	if (omap_crtc->flip_state != OMAP_PAGE_FLIP_IDLE) {
 		spin_unlock_irqrestore(&dev->event_lock, flags);
 		dev_err(dev->dev, "already a pending flip\n");
 		return -EBUSY;
 	}
 
 	omap_crtc->flip_event = event;
-	omap_crtc->flip_pending = true;
+	omap_crtc->flip_state = OMAP_PAGE_FLIP_WAIT;
 	primary->fb = fb;
 	drm_framebuffer_reference(fb);
 

commit 1d5e5ea1f6061ec9ad4f43928697f479aeb884c6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 18 16:57:36 2015 +0200

    drm: omapdrm: Cancel pending page flips when closing device
    
    Pending page flips must be cancelled when closing the device, otherwise
    their completion at next vblank will result in nasty effects, including
    possible oopses due to resources required to complete the page flip
    being freed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 85129d56cf4c..a60f4e49b55f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -263,9 +263,28 @@ static const struct dss_mgr_ops mgr_ops = {
 };
 
 /* -----------------------------------------------------------------------------
- * Setup and Flush
+ * Setup, Flush and Page Flip
  */
 
+void omap_crtc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+
+	/* Only complete events queued for our file handle. */
+	if (omap_crtc->flip_event &&
+	    file == omap_crtc->flip_event->base.file_priv) {
+		drm_send_vblank_event(dev, omap_crtc->pipe,
+				      omap_crtc->flip_event);
+		omap_crtc->flip_event = NULL;
+	}
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 {
 	struct omap_crtc *omap_crtc =

commit 42fb61cc687822855bc140147a3ba044f23d023e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 26 02:58:51 2015 +0200

    drm: omapdrm: Rename omap_crtc page flip-related fields
    
    The old_fb field is only used to indicate whether a page flip is
    pending. Turn it into a bool named flip_pending. Rename event and
    page_flip_work to flip_event and flip_work for consistency.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7ef9147bde73..85129d56cf4c 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -54,19 +54,22 @@ struct omap_crtc {
 	/* list of framebuffers to unpin */
 	struct list_head pending_unpins;
 
-	/* if there is a pending flip, these will be non-null: */
-	struct drm_pending_vblank_event *event;
-	struct drm_framebuffer *old_fb;
+	/*
+	 * The flip_pending flag indicates if a page flip has been queued and
+	 * hasn't completed yet. The flip event, if any, is stored in
+	 * flip_event.
+	 *
+	 * The flip_work work queue handles page flip requests without caring
+	 * about what context the GEM async callback is called from. Possibly we
+	 * should just make omap_gem always call the cb from the worker so we
+	 * don't have to care about this.
+	 */
+	bool flip_pending;
+	struct drm_pending_vblank_event *flip_event;
+	struct work_struct flip_work;
 
 	struct completion completion;
 
-	/* for handling page flips without caring about what
-	 * the callback is called from.  Possibly we should just
-	 * make omap_gem always call the cb from the worker so
-	 * we don't have to care about this..
-	 */
-	struct work_struct page_flip_work;
-
 	bool ignore_digit_sync_lost;
 };
 
@@ -293,11 +296,12 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	spin_lock_irqsave(&dev->event_lock, flags);
 
 	/* wakeup userspace */
-	if (omap_crtc->event)
-		drm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);
+	if (omap_crtc->flip_event)
+		drm_send_vblank_event(dev, omap_crtc->pipe,
+				      omap_crtc->flip_event);
 
-	omap_crtc->event = NULL;
-	omap_crtc->old_fb = NULL;
+	omap_crtc->flip_event = NULL;
+	omap_crtc->flip_pending = false;
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 
@@ -507,7 +511,7 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 static void page_flip_worker(struct work_struct *work)
 {
 	struct omap_crtc *omap_crtc =
-			container_of(work, struct omap_crtc, page_flip_work);
+			container_of(work, struct omap_crtc, flip_work);
 	struct drm_crtc *crtc = &omap_crtc->base;
 	struct drm_display_mode *mode = &crtc->mode;
 	struct drm_gem_object *bo;
@@ -531,7 +535,7 @@ static void page_flip_cb(void *arg)
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 
 	/* avoid assumptions about what ctxt we are called from: */
-	queue_work(priv->wq, &omap_crtc->page_flip_work);
+	queue_work(priv->wq, &omap_crtc->flip_work);
 }
 
 static int omap_crtc_page_flip(struct drm_crtc *crtc,
@@ -550,15 +554,16 @@ static int omap_crtc_page_flip(struct drm_crtc *crtc,
 
 	spin_lock_irqsave(&dev->event_lock, flags);
 
-	if (omap_crtc->old_fb) {
+	if (omap_crtc->flip_pending) {
 		spin_unlock_irqrestore(&dev->event_lock, flags);
 		dev_err(dev->dev, "already a pending flip\n");
 		return -EBUSY;
 	}
 
-	omap_crtc->event = event;
-	omap_crtc->old_fb = primary->fb = fb;
-	drm_framebuffer_reference(omap_crtc->old_fb);
+	omap_crtc->flip_event = event;
+	omap_crtc->flip_pending = true;
+	primary->fb = fb;
+	drm_framebuffer_reference(fb);
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 
@@ -640,7 +645,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	crtc = &omap_crtc->base;
 
-	INIT_WORK(&omap_crtc->page_flip_work, page_flip_worker);
+	INIT_WORK(&omap_crtc->flip_work, page_flip_worker);
 
 	INIT_LIST_HEAD(&omap_crtc->pending_unpins);
 

commit 077db4da28e247942f6cafcf36796440f871d0a5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 18 16:36:19 2015 +0200

    drm: omapdrm: Rename omap_crtc_page_flip_locked to omap_crtc_page_flip
    
    The operation is called page_flip, rename its implementation
    accordingly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e5fb8c6e25e6..7ef9147bde73 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -534,10 +534,10 @@ static void page_flip_cb(void *arg)
 	queue_work(priv->wq, &omap_crtc->page_flip_work);
 }
 
-static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
-		 struct drm_framebuffer *fb,
-		 struct drm_pending_vblank_event *event,
-		 uint32_t page_flip_flags)
+static int omap_crtc_page_flip(struct drm_crtc *crtc,
+			       struct drm_framebuffer *fb,
+			       struct drm_pending_vblank_event *event,
+			       uint32_t page_flip_flags)
 {
 	struct drm_device *dev = crtc->dev;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -589,7 +589,7 @@ static int omap_crtc_set_property(struct drm_crtc *crtc,
 static const struct drm_crtc_funcs omap_crtc_funcs = {
 	.set_config = drm_crtc_helper_set_config,
 	.destroy = omap_crtc_destroy,
-	.page_flip = omap_crtc_page_flip_locked,
+	.page_flip = omap_crtc_page_flip,
 	.set_property = omap_crtc_set_property,
 };
 

commit a42133a780b368f9ed18045a4453f92292db4b18
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 19:09:26 2015 +0200

    drm: omapdrm: Apply settings synchronously
    
    The omapdrm driver implements a mechanism to apply new settings (due to
    plane update, plane disable, plane property set, CRTC mode set or CRTC
    DPMS) asynchronously. While this improves performance, it adds a level
    of complexity that makes transition to the atomic update API close to
    impossible. Furthermore the atomic update API requires part of the apply
    operations to be synchronous (such as pinning the framebuffers), so the
    current implementation needs to be changed.
    
    Simplify the CRTC and plane code by making updates synchronous to
    prepare for the switch to the atomic update API. Asynchronous update
    will be implemented in a second step.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7a64765d0537..e5fb8c6e25e6 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -17,6 +17,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/completion.h>
+
 #include "omap_drv.h"
 
 #include <drm/drm_mode.h>
@@ -46,36 +48,33 @@ struct omap_crtc {
 	struct omap_video_timings timings;
 	bool enabled;
 
-	struct omap_drm_apply apply;
-
-	struct omap_drm_irq apply_irq;
+	struct omap_drm_irq vblank_irq;
 	struct omap_drm_irq error_irq;
 
-	/* list of in-progress apply's: */
-	struct list_head pending_applies;
-
-	/* list of queued apply's: */
-	struct list_head queued_applies;
-
-	/* for handling queued and in-progress applies: */
-	struct work_struct apply_work;
+	/* list of framebuffers to unpin */
+	struct list_head pending_unpins;
 
 	/* if there is a pending flip, these will be non-null: */
 	struct drm_pending_vblank_event *event;
 	struct drm_framebuffer *old_fb;
 
+	struct completion completion;
+
 	/* for handling page flips without caring about what
 	 * the callback is called from.  Possibly we should just
 	 * make omap_gem always call the cb from the worker so
 	 * we don't have to care about this..
-	 *
-	 * XXX maybe fold into apply_work??
 	 */
 	struct work_struct page_flip_work;
 
 	bool ignore_digit_sync_lost;
 };
 
+struct omap_framebuffer_unpin {
+	struct list_head list;
+	struct drm_framebuffer *fb;
+};
+
 /* -----------------------------------------------------------------------------
  * Helper Functions
  */
@@ -142,7 +141,7 @@ static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
-/* Called only from CRTC pre_apply and suspend/resume handlers. */
+/* Called only from omap_crtc_setup and suspend/resume handlers. */
 static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 {
 	struct drm_device *dev = crtc->dev;
@@ -261,7 +260,7 @@ static const struct dss_mgr_ops mgr_ops = {
 };
 
 /* -----------------------------------------------------------------------------
- * Apply Logic
+ * Setup and Flush
  */
 
 static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -278,121 +277,93 @@ static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_crtc->name, irqstatus);
 }
 
-static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 {
 	struct omap_crtc *omap_crtc =
-			container_of(irq, struct omap_crtc, apply_irq);
-	struct drm_crtc *crtc = &omap_crtc->base;
+			container_of(irq, struct omap_crtc, vblank_irq);
+	struct drm_device *dev = omap_crtc->base.dev;
+	unsigned long flags;
 
-	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
-		struct omap_drm_private *priv =
-				crtc->dev->dev_private;
-		DBG("%s: apply done", omap_crtc->name);
-		__omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
-		queue_work(priv->wq, &omap_crtc->apply_work);
-	}
+	if (dispc_mgr_go_busy(omap_crtc->channel))
+		return;
+
+	DBG("%s: apply done", omap_crtc->name);
+	__omap_irq_unregister(dev, &omap_crtc->vblank_irq);
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+
+	/* wakeup userspace */
+	if (omap_crtc->event)
+		drm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);
+
+	omap_crtc->event = NULL;
+	omap_crtc->old_fb = NULL;
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	complete(&omap_crtc->completion);
 }
 
-static void apply_worker(struct work_struct *work)
+int omap_crtc_flush(struct drm_crtc *crtc)
 {
-	struct omap_crtc *omap_crtc =
-			container_of(work, struct omap_crtc, apply_work);
-	struct drm_crtc *crtc = &omap_crtc->base;
-	struct drm_device *dev = crtc->dev;
-	struct omap_drm_apply *apply, *n;
-	bool need_apply;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_framebuffer_unpin *fb, *next;
 
-	/*
-	 * Synchronize everything on mode_config.mutex, to keep
-	 * the callbacks and list modification all serialized
-	 * with respect to modesetting ioctls from userspace.
-	 */
-	drm_modeset_lock(&crtc->mutex, NULL);
-	dispc_runtime_get();
+	DBG("%s: GO", omap_crtc->name);
 
-	/*
-	 * If we are still pending a previous update, wait.. when the
-	 * pending update completes, we get kicked again.
-	 */
-	if (omap_crtc->apply_irq.registered)
-		goto out;
-
-	/* finish up previous apply's: */
-	list_for_each_entry_safe(apply, n,
-			&omap_crtc->pending_applies, pending_node) {
-		apply->post_apply(apply);
-		list_del(&apply->pending_node);
-	}
+	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
+	WARN_ON(omap_crtc->vblank_irq.registered);
 
-	need_apply = !list_empty(&omap_crtc->queued_applies);
+	dispc_runtime_get();
 
-	/* then handle the next round of of queued apply's: */
-	list_for_each_entry_safe(apply, n,
-			&omap_crtc->queued_applies, queued_node) {
-		apply->pre_apply(apply);
-		list_del(&apply->queued_node);
-		apply->queued = false;
-		list_add_tail(&apply->pending_node,
-				&omap_crtc->pending_applies);
-	}
+	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
+		dispc_mgr_go(omap_crtc->channel);
+		omap_irq_register(crtc->dev, &omap_crtc->vblank_irq);
 
-	if (need_apply) {
-		enum omap_channel channel = omap_crtc->channel;
+		WARN_ON(!wait_for_completion_timeout(&omap_crtc->completion,
+						     msecs_to_jiffies(100)));
+		reinit_completion(&omap_crtc->completion);
+	}
 
-		DBG("%s: GO", omap_crtc->name);
+	dispc_runtime_put();
 
-		if (dispc_mgr_is_enabled(channel)) {
-			dispc_mgr_go(channel);
-			omap_irq_register(dev, &omap_crtc->apply_irq);
-		} else {
-			struct omap_drm_private *priv = dev->dev_private;
-			queue_work(priv->wq, &omap_crtc->apply_work);
-		}
+	/* Unpin and unreference pending framebuffers. */
+	list_for_each_entry_safe(fb, next, &omap_crtc->pending_unpins, list) {
+		omap_framebuffer_unpin(fb->fb);
+		drm_framebuffer_unreference(fb->fb);
+		list_del(&fb->list);
+		kfree(fb);
 	}
 
-out:
-	dispc_runtime_put();
-	drm_modeset_unlock(&crtc->mutex);
+	return 0;
 }
 
-int omap_crtc_apply(struct drm_crtc *crtc,
-		struct omap_drm_apply *apply)
+int omap_crtc_queue_unpin(struct drm_crtc *crtc, struct drm_framebuffer *fb)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_framebuffer_unpin *unpin;
 
-	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
-
-	/* no need to queue it again if it is already queued: */
-	if (apply->queued)
-		return 0;
-
-	apply->queued = true;
-	list_add_tail(&apply->queued_node, &omap_crtc->queued_applies);
+	unpin = kzalloc(sizeof(*unpin), GFP_KERNEL);
+	if (!unpin)
+		return -ENOMEM;
 
-	/*
-	 * If there are no currently pending updates, then go ahead and
-	 * kick the worker immediately, otherwise it will run again when
-	 * the current update finishes.
-	 */
-	if (list_empty(&omap_crtc->pending_applies)) {
-		struct omap_drm_private *priv = crtc->dev->dev_private;
-		queue_work(priv->wq, &omap_crtc->apply_work);
-	}
+	unpin->fb = fb;
+	list_add_tail(&unpin->list, &omap_crtc->pending_unpins);
 
 	return 0;
 }
 
-static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
+static void omap_crtc_setup(struct drm_crtc *crtc)
 {
-	struct omap_crtc *omap_crtc =
-			container_of(apply, struct omap_crtc, apply);
-	struct drm_crtc *crtc = &omap_crtc->base;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct drm_encoder *encoder = NULL;
 	unsigned int i;
 
 	DBG("%s: enabled=%d", omap_crtc->name, omap_crtc->enabled);
 
+	dispc_runtime_get();
+
 	for (i = 0; i < priv->num_encoders; i++) {
 		if (priv->encoders[i]->crtc == crtc) {
 			encoder = priv->encoders[i];
@@ -416,30 +387,8 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 			omap_encoder_set_enabled(encoder, true);
 		}
 	}
-}
-
-static void omap_crtc_post_apply(struct omap_drm_apply *apply)
-{
-	/* nothing needed for post-apply */
-}
 
-void omap_crtc_flush(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	int loops = 0;
-
-	while (!list_empty(&omap_crtc->pending_applies) ||
-		!list_empty(&omap_crtc->queued_applies) ||
-		omap_crtc->event || omap_crtc->old_fb) {
-
-		if (++loops > 10) {
-			dev_err(crtc->dev->dev,
-				"omap_crtc_flush() timeout\n");
-			break;
-		}
-
-		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
-	}
+	dispc_runtime_put();
 }
 
 /* -----------------------------------------------------------------------------
@@ -452,7 +401,7 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 
 	DBG("%s", omap_crtc->name);
 
-	WARN_ON(omap_crtc->apply_irq.registered);
+	WARN_ON(omap_crtc->vblank_irq.registered);
 	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 
 	drm_crtc_cleanup(crtc);
@@ -469,17 +418,21 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 
 	DBG("%s: %d", omap_crtc->name, mode);
 
-	if (enabled != omap_crtc->enabled) {
-		omap_crtc->enabled = enabled;
-		omap_crtc_apply(crtc, &omap_crtc->apply);
+	if (enabled == omap_crtc->enabled)
+		return;
 
-		/* Enable/disable all planes associated with the CRTC. */
-		for (i = 0; i < priv->num_planes; i++) {
-			struct drm_plane *plane = priv->planes[i];
-			if (plane->crtc == crtc)
-				WARN_ON(omap_plane_set_enable(plane, enabled));
-		}
+	/* Enable/disable all planes associated with the CRTC. */
+	for (i = 0; i < priv->num_planes; i++) {
+		struct drm_plane *plane = priv->planes[i];
+
+		if (plane->crtc == crtc)
+			WARN_ON(omap_plane_set_enable(plane, enabled));
 	}
+
+	omap_crtc->enabled = enabled;
+
+	omap_crtc_setup(crtc);
+	omap_crtc_flush(crtc);
 }
 
 static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
@@ -518,8 +471,7 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 
 	return omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
 				   0, 0, mode->hdisplay, mode->vdisplay,
-				   x, y, mode->hdisplay, mode->vdisplay,
-				   NULL, NULL);
+				   x, y, mode->hdisplay, mode->vdisplay);
 }
 
 static void omap_crtc_prepare(struct drm_crtc *crtc)
@@ -541,36 +493,15 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 {
 	struct drm_plane *plane = crtc->primary;
 	struct drm_display_mode *mode = &crtc->mode;
+	int ret;
 
-	return omap_plane_mode_set(plane, crtc, crtc->primary->fb,
-				   0, 0, mode->hdisplay, mode->vdisplay,
-				   x, y, mode->hdisplay, mode->vdisplay,
-				   NULL, NULL);
-}
-
-static void vblank_cb(void *arg)
-{
-	struct drm_crtc *crtc = arg;
-	struct drm_device *dev = crtc->dev;
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	unsigned long flags;
-	struct drm_framebuffer *fb;
-
-	spin_lock_irqsave(&dev->event_lock, flags);
-
-	/* wakeup userspace */
-	if (omap_crtc->event)
-		drm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);
-
-	fb = omap_crtc->old_fb;
-
-	omap_crtc->event = NULL;
-	omap_crtc->old_fb = NULL;
-
-	spin_unlock_irqrestore(&dev->event_lock, flags);
+	ret = omap_plane_mode_set(plane, crtc, crtc->primary->fb,
+				  0, 0, mode->hdisplay, mode->vdisplay,
+				  x, y, mode->hdisplay, mode->vdisplay);
+	if (ret < 0)
+		return ret;
 
-	if (fb)
-		drm_framebuffer_unreference(fb);
+	return omap_crtc_flush(crtc);
 }
 
 static void page_flip_worker(struct work_struct *work)
@@ -584,12 +515,13 @@ static void page_flip_worker(struct work_struct *work)
 	drm_modeset_lock(&crtc->mutex, NULL);
 	omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
 			    0, 0, mode->hdisplay, mode->vdisplay,
-			    crtc->x, crtc->y, mode->hdisplay, mode->vdisplay,
-			    vblank_cb, crtc);
+			    crtc->x, crtc->y, mode->hdisplay, mode->vdisplay);
+	omap_crtc_flush(crtc);
 	drm_modeset_unlock(&crtc->mutex);
 
 	bo = omap_framebuffer_bo(crtc->primary->fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
+	drm_framebuffer_unreference(crtc->primary->fb);
 }
 
 static void page_flip_cb(void *arg)
@@ -709,20 +641,17 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	crtc = &omap_crtc->base;
 
 	INIT_WORK(&omap_crtc->page_flip_work, page_flip_worker);
-	INIT_WORK(&omap_crtc->apply_work, apply_worker);
 
-	INIT_LIST_HEAD(&omap_crtc->pending_applies);
-	INIT_LIST_HEAD(&omap_crtc->queued_applies);
+	INIT_LIST_HEAD(&omap_crtc->pending_unpins);
 
-	omap_crtc->apply.pre_apply  = omap_crtc_pre_apply;
-	omap_crtc->apply.post_apply = omap_crtc_post_apply;
+	init_completion(&omap_crtc->completion);
 
 	omap_crtc->channel = channel;
 	omap_crtc->name = channel_names[channel];
 	omap_crtc->pipe = id;
 
-	omap_crtc->apply_irq.irqmask = pipe2vbl(crtc);
-	omap_crtc->apply_irq.irq = omap_crtc_apply_irq;
+	omap_crtc->vblank_irq.irqmask = pipe2vbl(crtc);
+	omap_crtc->vblank_irq.irq = omap_crtc_vblank_irq;
 
 	omap_crtc->error_irq.irqmask =
 			dispc_mgr_get_sync_lost_irq(channel);

commit e2cd09b202c5d32804f72bc28a9ed5a7d8a34452
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 17:16:43 2015 +0200

    drm: omapdrm: Store the rotation property in dev->mode_config
    
    Rotation is a standard property, store it in
    dev->mode_config.rotation_property. While at it, extract the properties
    initialization code to a separate function instead of running it for
    every plane.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f456544bf300..7a64765d0537 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -646,9 +646,7 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 static int omap_crtc_set_property(struct drm_crtc *crtc,
 		struct drm_property *property, uint64_t val)
 {
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-
-	if (property == priv->rotation_prop) {
+	if (property == crtc->dev->mode_config.rotation_property) {
 		crtc->invert_dimensions =
 				!!(val & ((1LL << DRM_ROTATE_90) | (1LL << DRM_ROTATE_270)));
 	}

commit 223bfd6911a0129d819b4dadb0eec93da014a9d9
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Feb 10 14:15:52 2015 +0200

    drm/omap: keep ref to old_fb
    
    We store the fb being page-flipped to 'old_fb' field, but we don't
    increase the ref count of the fb when doing that. While I am not
    sure if it can cause problem in practice, it's still safer to keep a ref
    when storing a pointer to a fb.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7b93880a4577..f456544bf300 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -554,6 +554,7 @@ static void vblank_cb(void *arg)
 	struct drm_device *dev = crtc->dev;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	unsigned long flags;
+	struct drm_framebuffer *fb;
 
 	spin_lock_irqsave(&dev->event_lock, flags);
 
@@ -561,10 +562,15 @@ static void vblank_cb(void *arg)
 	if (omap_crtc->event)
 		drm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);
 
+	fb = omap_crtc->old_fb;
+
 	omap_crtc->event = NULL;
 	omap_crtc->old_fb = NULL;
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	if (fb)
+		drm_framebuffer_unreference(fb);
 }
 
 static void page_flip_worker(struct work_struct *work)
@@ -620,6 +626,7 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 
 	omap_crtc->event = event;
 	omap_crtc->old_fb = primary->fb = fb;
+	drm_framebuffer_reference(omap_crtc->old_fb);
 
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 

commit ef4222838846fdecb6f1eae5671d9c462fd34852
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 26 15:20:25 2015 +0200

    drm/omap: only ignore DIGIT SYNC LOST for TV output
    
    We need to ignore DIGIT SYNC LOST error when enabling/disabling TV
    output. The code does that, but it ignores the DIGI SYNC LOST when
    enabling any output. Normally this does no harm, but it could make us
    miss DIGIT SYNC LOST on some rare occasions.
    
    Fix the code to only ignore DIGIT SYNC LOST when enabling/disabling TV.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c5c21776131a..7b93880a4577 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -155,11 +155,13 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	if (dispc_mgr_is_enabled(channel) == enable)
 		return;
 
-	/*
-	 * Digit output produces some sync lost interrupts during the first
-	 * frame when enabling, so we need to ignore those.
-	 */
-	omap_crtc->ignore_digit_sync_lost = true;
+	if (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {
+		/*
+		 * Digit output produces some sync lost interrupts during the
+		 * first frame when enabling, so we need to ignore those.
+		 */
+		omap_crtc->ignore_digit_sync_lost = true;
+	}
 
 	framedone_irq = dispc_mgr_get_framedone_irq(channel);
 	vsync_irq = dispc_mgr_get_vsync_irq(channel);
@@ -190,9 +192,11 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 				omap_crtc->name, enable ? "enable" : "disable");
 	}
 
-	omap_crtc->ignore_digit_sync_lost = false;
-	/* make sure the irq handler sees the value above */
-	mb();
+	if (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {
+		omap_crtc->ignore_digit_sync_lost = false;
+		/* make sure the irq handler sees the value above */
+		mb();
+	}
 }
 
 

commit a36af73f5e825c4c5ae5b11580c24fa7841bd5e2
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 26 15:20:24 2015 +0200

    drm/omap: fix race with error_irq
    
    omapdrm tries to avoid error floods by unregistering the error irq when
    an error happens, and then registering the error irq again later.
    However, the code is racy, as it sometimes tries to unregister the error
    irq when it's already unregistered, leading to WARN().
    
    Also, the code only registers the error irq again when something is done
    on that particular output, i.e. if only TV is used to flip the buffers,
    and LCD is showing a same buffer, an error on LCD will cause the LCD
    error irq to be unregistered and never registered again.
    
    To fix this, let's keep the error irqs always enabled and trust the
    DRM_ERROR_RATELIMITED to limit the flood.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e91687fe41be..c5c21776131a 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -72,6 +72,8 @@ struct omap_crtc {
 	 * XXX maybe fold into apply_work??
 	 */
 	struct work_struct page_flip_work;
+
+	bool ignore_digit_sync_lost;
 };
 
 /* -----------------------------------------------------------------------------
@@ -157,7 +159,7 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 	 * Digit output produces some sync lost interrupts during the first
 	 * frame when enabling, so we need to ignore those.
 	 */
-	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+	omap_crtc->ignore_digit_sync_lost = true;
 
 	framedone_irq = dispc_mgr_get_framedone_irq(channel);
 	vsync_irq = dispc_mgr_get_vsync_irq(channel);
@@ -188,7 +190,9 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 				omap_crtc->name, enable ? "enable" : "disable");
 	}
 
-	omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+	omap_crtc->ignore_digit_sync_lost = false;
+	/* make sure the irq handler sees the value above */
+	mb();
 }
 
 
@@ -260,10 +264,14 @@ static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 {
 	struct omap_crtc *omap_crtc =
 			container_of(irq, struct omap_crtc, error_irq);
-	struct drm_crtc *crtc = &omap_crtc->base;
+
+	if (omap_crtc->ignore_digit_sync_lost) {
+		irqstatus &= ~DISPC_IRQ_SYNC_LOST_DIGIT;
+		if (!irqstatus)
+			return;
+	}
+
 	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_crtc->name, irqstatus);
-	/* avoid getting in a flood, unregister the irq until next vblank */
-	__omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 }
 
 static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -272,9 +280,6 @@ static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 			container_of(irq, struct omap_crtc, apply_irq);
 	struct drm_crtc *crtc = &omap_crtc->base;
 
-	if (!omap_crtc->error_irq.registered)
-		__omap_irq_register(crtc->dev, &omap_crtc->error_irq);
-
 	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
 		struct omap_drm_private *priv =
 				crtc->dev->dev_private;

commit 3b143fc80c077be54f8f7859d00f2db79250c884
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 19 12:50:13 2014 +0200

    drm/omap: use DRM_ERROR_RATELIMITED() for error irqs
    
    omapdrm uses normal DRM_ERROR() print when the HW reports an error. As
    we sometimes may get a flood of errors, let's rather use
    DRM_ERROR_RATELIMITED().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index a4d6f5ec627e..e91687fe41be 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -261,7 +261,7 @@ static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	struct omap_crtc *omap_crtc =
 			container_of(irq, struct omap_crtc, error_irq);
 	struct drm_crtc *crtc = &omap_crtc->base;
-	DRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);
+	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_crtc->name, irqstatus);
 	/* avoid getting in a flood, unregister the irq until next vblank */
 	__omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 }

commit 549a75498151370214f86eacc788a5832ac01e59
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Sep 3 19:25:50 2014 +0000

    drm/omap: page_flip: return -EBUSY if flip pending
    
    The DRM documentation says:
    
    "If a page flip is already pending, the page_flip operation must return
    -EBUSY."
    
    Currently omapdrm returns -EINVAL instead. Fix omapdrm by returning
    -EBUSY.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 5cd10cf57985..a4d6f5ec627e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -606,7 +606,7 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 	if (omap_crtc->old_fb) {
 		spin_unlock_irqrestore(&dev->event_lock, flags);
 		dev_err(dev->dev, "already a pending flip\n");
-		return -EINVAL;
+		return -EBUSY;
 	}
 
 	omap_crtc->event = event;

commit 971fb3e55feeafe5182c283a39f1f39d0d705b99
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 18 01:12:59 2015 +0200

    drm: omapdrm: Reorder CRTC functions
    
    The next commit will need functions to be reordered. Do it separately to
    help review.
    
    This only moves functions without any change to the code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 105eab7cb830..5cd10cf57985 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -74,6 +74,10 @@ struct omap_crtc {
 	struct work_struct page_flip_work;
 };
 
+/* -----------------------------------------------------------------------------
+ * Helper Functions
+ */
+
 uint32_t pipe2vbl(struct drm_crtc *crtc)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
@@ -81,6 +85,22 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
 	return dispc_mgr_get_vsync_irq(omap_crtc->channel);
 }
 
+const struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	return &omap_crtc->timings;
+}
+
+enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	return omap_crtc->channel;
+}
+
+/* -----------------------------------------------------------------------------
+ * DSS Manager Functions
+ */
+
 /*
  * Manager-ops, callbacks from output when they need to configure
  * the upstream part of the video pipe.
@@ -232,8 +252,189 @@ static const struct dss_mgr_ops mgr_ops = {
 	.unregister_framedone_handler = omap_crtc_unregister_framedone_handler,
 };
 
-/*
- * CRTC funcs:
+/* -----------------------------------------------------------------------------
+ * Apply Logic
+ */
+
+static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(irq, struct omap_crtc, error_irq);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	DRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);
+	/* avoid getting in a flood, unregister the irq until next vblank */
+	__omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+}
+
+static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(irq, struct omap_crtc, apply_irq);
+	struct drm_crtc *crtc = &omap_crtc->base;
+
+	if (!omap_crtc->error_irq.registered)
+		__omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+
+	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
+		struct omap_drm_private *priv =
+				crtc->dev->dev_private;
+		DBG("%s: apply done", omap_crtc->name);
+		__omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
+		queue_work(priv->wq, &omap_crtc->apply_work);
+	}
+}
+
+static void apply_worker(struct work_struct *work)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(work, struct omap_crtc, apply_work);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	struct drm_device *dev = crtc->dev;
+	struct omap_drm_apply *apply, *n;
+	bool need_apply;
+
+	/*
+	 * Synchronize everything on mode_config.mutex, to keep
+	 * the callbacks and list modification all serialized
+	 * with respect to modesetting ioctls from userspace.
+	 */
+	drm_modeset_lock(&crtc->mutex, NULL);
+	dispc_runtime_get();
+
+	/*
+	 * If we are still pending a previous update, wait.. when the
+	 * pending update completes, we get kicked again.
+	 */
+	if (omap_crtc->apply_irq.registered)
+		goto out;
+
+	/* finish up previous apply's: */
+	list_for_each_entry_safe(apply, n,
+			&omap_crtc->pending_applies, pending_node) {
+		apply->post_apply(apply);
+		list_del(&apply->pending_node);
+	}
+
+	need_apply = !list_empty(&omap_crtc->queued_applies);
+
+	/* then handle the next round of of queued apply's: */
+	list_for_each_entry_safe(apply, n,
+			&omap_crtc->queued_applies, queued_node) {
+		apply->pre_apply(apply);
+		list_del(&apply->queued_node);
+		apply->queued = false;
+		list_add_tail(&apply->pending_node,
+				&omap_crtc->pending_applies);
+	}
+
+	if (need_apply) {
+		enum omap_channel channel = omap_crtc->channel;
+
+		DBG("%s: GO", omap_crtc->name);
+
+		if (dispc_mgr_is_enabled(channel)) {
+			dispc_mgr_go(channel);
+			omap_irq_register(dev, &omap_crtc->apply_irq);
+		} else {
+			struct omap_drm_private *priv = dev->dev_private;
+			queue_work(priv->wq, &omap_crtc->apply_work);
+		}
+	}
+
+out:
+	dispc_runtime_put();
+	drm_modeset_unlock(&crtc->mutex);
+}
+
+int omap_crtc_apply(struct drm_crtc *crtc,
+		struct omap_drm_apply *apply)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
+
+	/* no need to queue it again if it is already queued: */
+	if (apply->queued)
+		return 0;
+
+	apply->queued = true;
+	list_add_tail(&apply->queued_node, &omap_crtc->queued_applies);
+
+	/*
+	 * If there are no currently pending updates, then go ahead and
+	 * kick the worker immediately, otherwise it will run again when
+	 * the current update finishes.
+	 */
+	if (list_empty(&omap_crtc->pending_applies)) {
+		struct omap_drm_private *priv = crtc->dev->dev_private;
+		queue_work(priv->wq, &omap_crtc->apply_work);
+	}
+
+	return 0;
+}
+
+static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(apply, struct omap_crtc, apply);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct drm_encoder *encoder = NULL;
+	unsigned int i;
+
+	DBG("%s: enabled=%d", omap_crtc->name, omap_crtc->enabled);
+
+	for (i = 0; i < priv->num_encoders; i++) {
+		if (priv->encoders[i]->crtc == crtc) {
+			encoder = priv->encoders[i];
+			break;
+		}
+	}
+
+	if (omap_crtc->current_encoder && encoder != omap_crtc->current_encoder)
+		omap_encoder_set_enabled(omap_crtc->current_encoder, false);
+
+	omap_crtc->current_encoder = encoder;
+
+	if (!omap_crtc->enabled) {
+		if (encoder)
+			omap_encoder_set_enabled(encoder, false);
+	} else {
+		if (encoder) {
+			omap_encoder_set_enabled(encoder, false);
+			omap_encoder_update(encoder, omap_crtc->mgr,
+					&omap_crtc->timings);
+			omap_encoder_set_enabled(encoder, true);
+		}
+	}
+}
+
+static void omap_crtc_post_apply(struct omap_drm_apply *apply)
+{
+	/* nothing needed for post-apply */
+}
+
+void omap_crtc_flush(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	int loops = 0;
+
+	while (!list_empty(&omap_crtc->pending_applies) ||
+		!list_empty(&omap_crtc->queued_applies) ||
+		omap_crtc->event || omap_crtc->old_fb) {
+
+		if (++loops > 10) {
+			dev_err(crtc->dev->dev,
+				"omap_crtc_flush() timeout\n");
+			break;
+		}
+
+		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
+	}
+}
+
+/* -----------------------------------------------------------------------------
+ * CRTC Functions
  */
 
 static void omap_crtc_destroy(struct drm_crtc *crtc)
@@ -455,194 +656,9 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.mode_set_base = omap_crtc_mode_set_base,
 };
 
-const struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	return &omap_crtc->timings;
-}
-
-enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	return omap_crtc->channel;
-}
-
-static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
-{
-	struct omap_crtc *omap_crtc =
-			container_of(irq, struct omap_crtc, error_irq);
-	struct drm_crtc *crtc = &omap_crtc->base;
-	DRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);
-	/* avoid getting in a flood, unregister the irq until next vblank */
-	__omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
-}
-
-static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
-{
-	struct omap_crtc *omap_crtc =
-			container_of(irq, struct omap_crtc, apply_irq);
-	struct drm_crtc *crtc = &omap_crtc->base;
-
-	if (!omap_crtc->error_irq.registered)
-		__omap_irq_register(crtc->dev, &omap_crtc->error_irq);
-
-	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
-		struct omap_drm_private *priv =
-				crtc->dev->dev_private;
-		DBG("%s: apply done", omap_crtc->name);
-		__omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
-		queue_work(priv->wq, &omap_crtc->apply_work);
-	}
-}
-
-static void apply_worker(struct work_struct *work)
-{
-	struct omap_crtc *omap_crtc =
-			container_of(work, struct omap_crtc, apply_work);
-	struct drm_crtc *crtc = &omap_crtc->base;
-	struct drm_device *dev = crtc->dev;
-	struct omap_drm_apply *apply, *n;
-	bool need_apply;
-
-	/*
-	 * Synchronize everything on mode_config.mutex, to keep
-	 * the callbacks and list modification all serialized
-	 * with respect to modesetting ioctls from userspace.
-	 */
-	drm_modeset_lock(&crtc->mutex, NULL);
-	dispc_runtime_get();
-
-	/*
-	 * If we are still pending a previous update, wait.. when the
-	 * pending update completes, we get kicked again.
-	 */
-	if (omap_crtc->apply_irq.registered)
-		goto out;
-
-	/* finish up previous apply's: */
-	list_for_each_entry_safe(apply, n,
-			&omap_crtc->pending_applies, pending_node) {
-		apply->post_apply(apply);
-		list_del(&apply->pending_node);
-	}
-
-	need_apply = !list_empty(&omap_crtc->queued_applies);
-
-	/* then handle the next round of of queued apply's: */
-	list_for_each_entry_safe(apply, n,
-			&omap_crtc->queued_applies, queued_node) {
-		apply->pre_apply(apply);
-		list_del(&apply->queued_node);
-		apply->queued = false;
-		list_add_tail(&apply->pending_node,
-				&omap_crtc->pending_applies);
-	}
-
-	if (need_apply) {
-		enum omap_channel channel = omap_crtc->channel;
-
-		DBG("%s: GO", omap_crtc->name);
-
-		if (dispc_mgr_is_enabled(channel)) {
-			dispc_mgr_go(channel);
-			omap_irq_register(dev, &omap_crtc->apply_irq);
-		} else {
-			struct omap_drm_private *priv = dev->dev_private;
-			queue_work(priv->wq, &omap_crtc->apply_work);
-		}
-	}
-
-out:
-	dispc_runtime_put();
-	drm_modeset_unlock(&crtc->mutex);
-}
-
-int omap_crtc_apply(struct drm_crtc *crtc,
-		struct omap_drm_apply *apply)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-
-	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
-
-	/* no need to queue it again if it is already queued: */
-	if (apply->queued)
-		return 0;
-
-	apply->queued = true;
-	list_add_tail(&apply->queued_node, &omap_crtc->queued_applies);
-
-	/*
-	 * If there are no currently pending updates, then go ahead and
-	 * kick the worker immediately, otherwise it will run again when
-	 * the current update finishes.
-	 */
-	if (list_empty(&omap_crtc->pending_applies)) {
-		struct omap_drm_private *priv = crtc->dev->dev_private;
-		queue_work(priv->wq, &omap_crtc->apply_work);
-	}
-
-	return 0;
-}
-
-static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
-{
-	struct omap_crtc *omap_crtc =
-			container_of(apply, struct omap_crtc, apply);
-	struct drm_crtc *crtc = &omap_crtc->base;
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-	struct drm_encoder *encoder = NULL;
-	unsigned int i;
-
-	DBG("%s: enabled=%d", omap_crtc->name, omap_crtc->enabled);
-
-	for (i = 0; i < priv->num_encoders; i++) {
-		if (priv->encoders[i]->crtc == crtc) {
-			encoder = priv->encoders[i];
-			break;
-		}
-	}
-
-	if (omap_crtc->current_encoder && encoder != omap_crtc->current_encoder)
-		omap_encoder_set_enabled(omap_crtc->current_encoder, false);
-
-	omap_crtc->current_encoder = encoder;
-
-	if (!omap_crtc->enabled) {
-		if (encoder)
-			omap_encoder_set_enabled(encoder, false);
-	} else {
-		if (encoder) {
-			omap_encoder_set_enabled(encoder, false);
-			omap_encoder_update(encoder, omap_crtc->mgr,
-					&omap_crtc->timings);
-			omap_encoder_set_enabled(encoder, true);
-		}
-	}
-}
-
-static void omap_crtc_post_apply(struct omap_drm_apply *apply)
-{
-	/* nothing needed for post-apply */
-}
-
-void omap_crtc_flush(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	int loops = 0;
-
-	while (!list_empty(&omap_crtc->pending_applies) ||
-		!list_empty(&omap_crtc->queued_applies) ||
-		omap_crtc->event || omap_crtc->old_fb) {
-
-		if (++loops > 10) {
-			dev_err(crtc->dev->dev,
-				"omap_crtc_flush() timeout\n");
-			break;
-		}
-
-		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
-	}
-}
+/* -----------------------------------------------------------------------------
+ * Init and Cleanup
+ */
 
 static const char *channel_names[] = {
 	[OMAP_DSS_CHANNEL_LCD] = "lcd",

commit a350da8be4d91e733ec8cb225e5edefa8b085167
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 22:31:42 2015 +0200

    drm: omapdrm: Pass integer source coordinates to omap_plane_mode_set()
    
    The function will convert the Q16 source coordinates to integers, avoid
    converting integers to Q16 first and perform the opposite conversion.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 1ef3e0146c68..105eab7cb830 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -307,10 +307,9 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 	crtc->primary->crtc = crtc;
 
 	return omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
-			0, 0, mode->hdisplay, mode->vdisplay,
-			x << 16, y << 16,
-			mode->hdisplay << 16, mode->vdisplay << 16,
-			NULL, NULL);
+				   0, 0, mode->hdisplay, mode->vdisplay,
+				   x, y, mode->hdisplay, mode->vdisplay,
+				   NULL, NULL);
 }
 
 static void omap_crtc_prepare(struct drm_crtc *crtc)
@@ -334,10 +333,9 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 	struct drm_display_mode *mode = &crtc->mode;
 
 	return omap_plane_mode_set(plane, crtc, crtc->primary->fb,
-			0, 0, mode->hdisplay, mode->vdisplay,
-			x << 16, y << 16,
-			mode->hdisplay << 16, mode->vdisplay << 16,
-			NULL, NULL);
+				   0, 0, mode->hdisplay, mode->vdisplay,
+				   x, y, mode->hdisplay, mode->vdisplay,
+				   NULL, NULL);
 }
 
 static void vblank_cb(void *arg)
@@ -369,10 +367,9 @@ static void page_flip_worker(struct work_struct *work)
 
 	drm_modeset_lock(&crtc->mutex, NULL);
 	omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
-			0, 0, mode->hdisplay, mode->vdisplay,
-			crtc->x << 16, crtc->y << 16,
-			mode->hdisplay << 16, mode->vdisplay << 16,
-			vblank_cb, crtc);
+			    0, 0, mode->hdisplay, mode->vdisplay,
+			    crtc->x, crtc->y, mode->hdisplay, mode->vdisplay,
+			    vblank_cb, crtc);
 	drm_modeset_unlock(&crtc->mutex);
 
 	bo = omap_framebuffer_bo(crtc->primary->fb, 0);

commit 8472b5708ebaabf4568fe53672db7567e94c4c65
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jan 15 00:45:17 2015 +0200

    drm: omapdrm: Avoid function forward declaration in omap_crtc.c
    
    Move the set_enabled function to avoid the forward declaration. While at
    it prefix it with omap_crtc_ like most other functions in the file, and
    fix the comment stating in which contexts the function is called.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e04782489224..1ef3e0146c68 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -120,7 +120,57 @@ static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
-static void set_enabled(struct drm_crtc *crtc, bool enable);
+/* Called only from CRTC pre_apply and suspend/resume handlers. */
+static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
+{
+	struct drm_device *dev = crtc->dev;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	enum omap_channel channel = omap_crtc->channel;
+	struct omap_irq_wait *wait;
+	u32 framedone_irq, vsync_irq;
+	int ret;
+
+	if (dispc_mgr_is_enabled(channel) == enable)
+		return;
+
+	/*
+	 * Digit output produces some sync lost interrupts during the first
+	 * frame when enabling, so we need to ignore those.
+	 */
+	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+
+	framedone_irq = dispc_mgr_get_framedone_irq(channel);
+	vsync_irq = dispc_mgr_get_vsync_irq(channel);
+
+	if (enable) {
+		wait = omap_irq_wait_init(dev, vsync_irq, 1);
+	} else {
+		/*
+		 * When we disable the digit output, we need to wait for
+		 * FRAMEDONE to know that DISPC has finished with the output.
+		 *
+		 * OMAP2/3 does not have FRAMEDONE irq for digit output, and in
+		 * that case we need to use vsync interrupt, and wait for both
+		 * even and odd frames.
+		 */
+
+		if (framedone_irq)
+			wait = omap_irq_wait_init(dev, framedone_irq, 1);
+		else
+			wait = omap_irq_wait_init(dev, vsync_irq, 2);
+	}
+
+	dispc_mgr_enable(channel, enable);
+
+	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
+	if (ret) {
+		dev_err(dev->dev, "%s: timeout waiting for %s\n",
+				omap_crtc->name, enable ? "enable" : "disable");
+	}
+
+	omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+}
+
 
 static int omap_crtc_enable(struct omap_overlay_manager *mgr)
 {
@@ -129,7 +179,7 @@ static int omap_crtc_enable(struct omap_overlay_manager *mgr)
 	dispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);
 	dispc_mgr_set_timings(omap_crtc->channel,
 			&omap_crtc->timings);
-	set_enabled(&omap_crtc->base, true);
+	omap_crtc_set_enabled(&omap_crtc->base, true);
 
 	return 0;
 }
@@ -138,7 +188,7 @@ static void omap_crtc_disable(struct omap_overlay_manager *mgr)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 
-	set_enabled(&omap_crtc->base, false);
+	omap_crtc_set_enabled(&omap_crtc->base, false);
 }
 
 static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
@@ -537,57 +587,6 @@ int omap_crtc_apply(struct drm_crtc *crtc,
 	return 0;
 }
 
-/* called only from apply */
-static void set_enabled(struct drm_crtc *crtc, bool enable)
-{
-	struct drm_device *dev = crtc->dev;
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	enum omap_channel channel = omap_crtc->channel;
-	struct omap_irq_wait *wait;
-	u32 framedone_irq, vsync_irq;
-	int ret;
-
-	if (dispc_mgr_is_enabled(channel) == enable)
-		return;
-
-	/*
-	 * Digit output produces some sync lost interrupts during the first
-	 * frame when enabling, so we need to ignore those.
-	 */
-	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
-
-	framedone_irq = dispc_mgr_get_framedone_irq(channel);
-	vsync_irq = dispc_mgr_get_vsync_irq(channel);
-
-	if (enable) {
-		wait = omap_irq_wait_init(dev, vsync_irq, 1);
-	} else {
-		/*
-		 * When we disable the digit output, we need to wait for
-		 * FRAMEDONE to know that DISPC has finished with the output.
-		 *
-		 * OMAP2/3 does not have FRAMEDONE irq for digit output, and in
-		 * that case we need to use vsync interrupt, and wait for both
-		 * even and odd frames.
-		 */
-
-		if (framedone_irq)
-			wait = omap_irq_wait_init(dev, framedone_irq, 1);
-		else
-			wait = omap_irq_wait_init(dev, vsync_irq, 2);
-	}
-
-	dispc_mgr_enable(channel, enable);
-
-	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
-	if (ret) {
-		dev_err(dev->dev, "%s: timeout waiting for %s\n",
-				omap_crtc->name, enable ? "enable" : "disable");
-	}
-
-	omap_irq_register(crtc->dev, &omap_crtc->error_irq);
-}
-
 static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 {
 	struct omap_crtc *omap_crtc =

commit 297767b68146f2355dfb10cb57185bef7769dfd9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jan 15 00:31:11 2015 +0200

    drm: omapdrm: Remove omap_crtc->full_update field
    
    The full_update field is always set to true before calling
    omap_crtc_appy(), resulting in its value always being true in the single
    location where it is tested, in omap_crtc_pre_apply(). Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 3f811186c891..e04782489224 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -45,7 +45,6 @@ struct omap_crtc {
 
 	struct omap_video_timings timings;
 	bool enabled;
-	bool full_update;
 
 	struct omap_drm_apply apply;
 
@@ -148,7 +147,6 @@ static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 	DBG("%s", omap_crtc->name);
 	omap_crtc->timings = *timings;
-	omap_crtc->full_update = true;
 }
 
 static void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,
@@ -213,7 +211,6 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 
 	if (enabled != omap_crtc->enabled) {
 		omap_crtc->enabled = enabled;
-		omap_crtc->full_update = true;
 		omap_crtc_apply(crtc, &omap_crtc->apply);
 
 		/* Enable/disable all planes associated with the CRTC. */
@@ -252,7 +249,6 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 			mode->type, mode->flags);
 
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
-	omap_crtc->full_update = true;
 
 	/*
 	 * The primary plane CRTC can be reset if the plane is disabled directly
@@ -597,19 +593,16 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 	struct omap_crtc *omap_crtc =
 			container_of(apply, struct omap_crtc, apply);
 	struct drm_crtc *crtc = &omap_crtc->base;
+	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct drm_encoder *encoder = NULL;
+	unsigned int i;
 
-	DBG("%s: enabled=%d, full=%d", omap_crtc->name,
-			omap_crtc->enabled, omap_crtc->full_update);
+	DBG("%s: enabled=%d", omap_crtc->name, omap_crtc->enabled);
 
-	if (omap_crtc->full_update) {
-		struct omap_drm_private *priv = crtc->dev->dev_private;
-		int i;
-		for (i = 0; i < priv->num_encoders; i++) {
-			if (priv->encoders[i]->crtc == crtc) {
-				encoder = priv->encoders[i];
-				break;
-			}
+	for (i = 0; i < priv->num_encoders; i++) {
+		if (priv->encoders[i]->crtc == crtc) {
+			encoder = priv->encoders[i];
+			break;
 		}
 	}
 
@@ -629,8 +622,6 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 			omap_encoder_set_enabled(encoder, true);
 		}
 	}
-
-	omap_crtc->full_update = false;
 }
 
 static void omap_crtc_post_apply(struct omap_drm_apply *apply)

commit 5dbe44336811a7e8ef4c958c6ac054772ee47637
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jan 13 09:14:53 2015 +0200

    drm: omapdrm: Fix race condition between GO and vblank IRQ
    
    The vblank interrupt is used by the driver as a completion signal when
    applying new settings.
    
    A race condition exist between enabling the vblank interrupt and
    applying new settings to the hardware by setting the GO bit. If a vblank
    interrupt occurs in-between, the driver will incorrectly consider the
    new settings to be applied. Fix this by enabling the interrupt after
    setting the GO bit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c7d3e1eec6cb..3f811186c891 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -501,8 +501,8 @@ static void apply_worker(struct work_struct *work)
 		DBG("%s: GO", omap_crtc->name);
 
 		if (dispc_mgr_is_enabled(channel)) {
-			omap_irq_register(dev, &omap_crtc->apply_irq);
 			dispc_mgr_go(channel);
+			omap_irq_register(dev, &omap_crtc->apply_irq);
 		} else {
 			struct omap_drm_private *priv = dev->dev_private;
 			queue_work(priv->wq, &omap_crtc->apply_work);

commit 2debab97a515374c01d50068de00c95f9befd260
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 12 22:38:16 2015 +0200

    drm: omapdrm: Rename omap_plane_dpms() to omap_plane_set_enable()
    
    The planes don't care about DPMS states, don't propagate it
    unnecessarily to the plane functions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 7570db59a9ea..c7d3e1eec6cb 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -220,7 +220,7 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 		for (i = 0; i < priv->num_planes; i++) {
 			struct drm_plane *plane = priv->planes[i];
 			if (plane->crtc == crtc)
-				WARN_ON(omap_plane_dpms(plane, mode));
+				WARN_ON(omap_plane_set_enable(plane, enabled));
 		}
 	}
 }

commit ef6b0e0275387f79e6ad848d61dfcb1a4f962fc7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 11 00:11:18 2015 +0200

    drm: omapdrm: Switch to the universal plane API
    
    Remove the CRTC private planes by switching to the universal plane API.
    This results in a merge of the CRTC private plane created by the driver
    (omap_crtc->plane) and the CRTC primary plane created by the DRM core
    (crtc->primary).
    
    Reference counting of the framebuffers in the update plane operation is
    thus simplified as no reference needs to be stored in the private plane
    anymore.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index b9c3d8f830e8..7570db59a9ea 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -28,7 +28,6 @@
 
 struct omap_crtc {
 	struct drm_crtc base;
-	struct drm_plane *plane;
 
 	const char *name;
 	int pipe;
@@ -217,10 +216,7 @@ static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
 		omap_crtc->full_update = true;
 		omap_crtc_apply(crtc, &omap_crtc->apply);
 
-		/* also enable our private plane: */
-		WARN_ON(omap_plane_dpms(omap_crtc->plane, mode));
-
-		/* and any attached overlay planes: */
+		/* Enable/disable all planes associated with the CRTC. */
 		for (i = 0; i < priv->num_planes; i++) {
 			struct drm_plane *plane = priv->planes[i];
 			if (plane->crtc == crtc)
@@ -258,7 +254,13 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
 	omap_crtc->full_update = true;
 
-	return omap_plane_mode_set(omap_crtc->plane, crtc, crtc->primary->fb,
+	/*
+	 * The primary plane CRTC can be reset if the plane is disabled directly
+	 * through the universal plane API. Set it again here.
+	 */
+	crtc->primary->crtc = crtc;
+
+	return omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			x << 16, y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
@@ -282,8 +284,7 @@ static void omap_crtc_commit(struct drm_crtc *crtc)
 static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 		struct drm_framebuffer *old_fb)
 {
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_plane *plane = omap_crtc->plane;
+	struct drm_plane *plane = crtc->primary;
 	struct drm_display_mode *mode = &crtc->mode;
 
 	return omap_plane_mode_set(plane, crtc, crtc->primary->fb,
@@ -321,7 +322,7 @@ static void page_flip_worker(struct work_struct *work)
 	struct drm_gem_object *bo;
 
 	drm_modeset_lock(&crtc->mutex, NULL);
-	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->primary->fb,
+	omap_plane_mode_set(crtc->primary, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			crtc->x << 16, crtc->y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
@@ -385,7 +386,6 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 static int omap_crtc_set_property(struct drm_crtc *crtc,
 		struct drm_property *property, uint64_t val)
 {
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 
 	if (property == priv->rotation_prop) {
@@ -393,7 +393,7 @@ static int omap_crtc_set_property(struct drm_crtc *crtc,
 				!!(val & ((1LL << DRM_ROTATE_90) | (1LL << DRM_ROTATE_270)));
 	}
 
-	return omap_plane_set_property(omap_crtc->plane, property, val);
+	return omap_plane_set_property(crtc->primary, property, val);
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
@@ -681,12 +681,13 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	struct drm_crtc *crtc = NULL;
 	struct omap_crtc *omap_crtc;
 	struct omap_overlay_manager_info *info;
+	int ret;
 
 	DBG("%s", channel_names[channel]);
 
 	omap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);
 	if (!omap_crtc)
-		goto fail;
+		return NULL;
 
 	crtc = &omap_crtc->base;
 
@@ -700,8 +701,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->apply.post_apply = omap_crtc_post_apply;
 
 	omap_crtc->channel = channel;
-	omap_crtc->plane = plane;
-	omap_crtc->plane->crtc = crtc;
 	omap_crtc->name = channel_names[channel];
 	omap_crtc->pipe = id;
 
@@ -723,18 +722,18 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	info->trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
 	info->trans_enabled = false;
 
-	drm_crtc_init(dev, crtc, &omap_crtc_funcs);
+	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
+					&omap_crtc_funcs);
+	if (ret < 0) {
+		kfree(omap_crtc);
+		return NULL;
+	}
+
 	drm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);
 
-	omap_plane_install_properties(omap_crtc->plane, &crtc->base);
+	omap_plane_install_properties(crtc->primary, &crtc->base);
 
 	omap_crtcs[channel] = omap_crtc;
 
 	return crtc;
-
-fail:
-	if (crtc)
-		omap_crtc_destroy(crtc);
-
-	return NULL;
 }

commit 222025e42d7f77133b8c3a2355d20a6004096c4b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 11 00:02:07 2015 +0200

    drm: omapdrm: Fix indentation of structure and array initializers
    
    Indenting by one tab is enough.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index b0566a1ca28f..b9c3d8f830e8 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -174,15 +174,15 @@ static void omap_crtc_unregister_framedone_handler(
 }
 
 static const struct dss_mgr_ops mgr_ops = {
-		.connect = omap_crtc_connect,
-		.disconnect = omap_crtc_disconnect,
-		.start_update = omap_crtc_start_update,
-		.enable = omap_crtc_enable,
-		.disable = omap_crtc_disable,
-		.set_timings = omap_crtc_set_timings,
-		.set_lcd_config = omap_crtc_set_lcd_config,
-		.register_framedone_handler = omap_crtc_register_framedone_handler,
-		.unregister_framedone_handler = omap_crtc_unregister_framedone_handler,
+	.connect = omap_crtc_connect,
+	.disconnect = omap_crtc_disconnect,
+	.start_update = omap_crtc_start_update,
+	.enable = omap_crtc_enable,
+	.disable = omap_crtc_disable,
+	.set_timings = omap_crtc_set_timings,
+	.set_lcd_config = omap_crtc_set_lcd_config,
+	.register_framedone_handler = omap_crtc_register_framedone_handler,
+	.unregister_framedone_handler = omap_crtc_unregister_framedone_handler,
 };
 
 /*
@@ -658,10 +658,10 @@ void omap_crtc_flush(struct drm_crtc *crtc)
 }
 
 static const char *channel_names[] = {
-		[OMAP_DSS_CHANNEL_LCD] = "lcd",
-		[OMAP_DSS_CHANNEL_DIGIT] = "tv",
-		[OMAP_DSS_CHANNEL_LCD2] = "lcd2",
-		[OMAP_DSS_CHANNEL_LCD3] = "lcd3",
+	[OMAP_DSS_CHANNEL_LCD] = "lcd",
+	[OMAP_DSS_CHANNEL_DIGIT] = "tv",
+	[OMAP_DSS_CHANNEL_LCD2] = "lcd2",
+	[OMAP_DSS_CHANNEL_LCD3] = "lcd3",
 };
 
 void omap_crtc_pre_init(void)

commit 3cb9ae4fd82ebc9759bc59998c88c385d35496fe
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 29 10:03:57 2014 +0100

    drm: Move drm_crtc_init from drm_crtc.h to drm_plane_helper.h
    
    Just a bit of OCD cleanup on headers - this function isn't the core
    interface any more but just a helper for drivers who haven't yet
    transitioned to universal planes. Put the declaration at the right
    spot and sprinkle necessary #includes over all drivers.
    
    Maybe this helps to encourage driver maintainers to do the switch.
    
    v2: Fix #include ordering for tegra, reported by 0-day builder.
    
    v3: Include required headers, reported by Thierry.
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2d28dc337cfb..b0566a1ca28f 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -20,6 +20,7 @@
 #include "omap_drv.h"
 
 #include <drm/drm_mode.h>
+#include <drm/drm_plane_helper.h>
 #include "drm_crtc.h"
 #include "drm_crtc_helper.h"
 

commit 51fd371bbaf94018a1223b4e2cf20b9880fd92d4
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 19 12:10:12 2013 -0500

    drm: convert crtc and connection_mutex to ww_mutex (v5)
    
    For atomic, it will be quite necessary to not need to care so much
    about locking order.  And 'state' gives us a convenient place to stash a
    ww_ctx for any sort of update that needs to grab multiple crtc locks.
    
    Because we will want to eventually make locking even more fine grained
    (giving locks to planes, connectors, etc), split out drm_modeset_lock
    and drm_modeset_acquire_ctx to track acquired locks.
    
    Atomic will use this to keep track of which locks have been acquired
    in a transaction.
    
    v1: original
    v2: remove a few things not needed until atomic, for now
    v3: update for v3 of connection_mutex patch..
    v4: squash in docbook
    v5: doc tweaks/fixes
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e3c47a8005ff..2d28dc337cfb 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -319,13 +319,13 @@ static void page_flip_worker(struct work_struct *work)
 	struct drm_display_mode *mode = &crtc->mode;
 	struct drm_gem_object *bo;
 
-	mutex_lock(&crtc->mutex);
+	drm_modeset_lock(&crtc->mutex, NULL);
 	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			crtc->x << 16, crtc->y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
 			vblank_cb, crtc);
-	mutex_unlock(&crtc->mutex);
+	drm_modeset_unlock(&crtc->mutex);
 
 	bo = omap_framebuffer_bo(crtc->primary->fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
@@ -465,7 +465,7 @@ static void apply_worker(struct work_struct *work)
 	 * the callbacks and list modification all serialized
 	 * with respect to modesetting ioctls from userspace.
 	 */
-	mutex_lock(&crtc->mutex);
+	drm_modeset_lock(&crtc->mutex, NULL);
 	dispc_runtime_get();
 
 	/*
@@ -510,7 +510,7 @@ static void apply_worker(struct work_struct *work)
 
 out:
 	dispc_runtime_put();
-	mutex_unlock(&crtc->mutex);
+	drm_modeset_unlock(&crtc->mutex);
 }
 
 int omap_crtc_apply(struct drm_crtc *crtc,
@@ -518,7 +518,7 @@ int omap_crtc_apply(struct drm_crtc *crtc,
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 
-	WARN_ON(!mutex_is_locked(&crtc->mutex));
+	WARN_ON(!drm_modeset_is_locked(&crtc->mutex));
 
 	/* no need to queue it again if it is already queued: */
 	if (apply->queued)

commit 38e5597a03d2d1499a785230031c4f48e1d9c6b7
Author: Archit Taneja <archit@ti.com>
Date:   Fri Apr 11 12:53:35 2014 +0530

    drm/omap: protect omap_crtc's event with event_lock spinlock
    
    The vblank_cb callback and the page_flip ioctl can occur together in different
    CPU contexts. vblank_cb uses takes tje drm device's event_lock spinlock when
    sending the vblank event and updating omap_crtc->event and omap_crtc->od_fb.
    
    Use the same spinlock in page_flip, to make sure the above omap_crtc parameters
    are configured sequentially.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 00798247190b..e3c47a8005ff 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -350,11 +350,15 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	struct drm_plane *primary = crtc->primary;
 	struct drm_gem_object *bo;
+	unsigned long flags;
 
 	DBG("%d -> %d (event=%p)", primary->fb ? primary->fb->base.id : -1,
 			fb->base.id, event);
 
+	spin_lock_irqsave(&dev->event_lock, flags);
+
 	if (omap_crtc->old_fb) {
+		spin_unlock_irqrestore(&dev->event_lock, flags);
 		dev_err(dev->dev, "already a pending flip\n");
 		return -EINVAL;
 	}
@@ -362,6 +366,8 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 	omap_crtc->event = event;
 	omap_crtc->old_fb = primary->fb = fb;
 
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
 	/*
 	 * Hold a reference temporarily until the crtc is updated
 	 * and takes the reference to the bo.  This avoids it

commit bc905aced30e48a39af7c452bf46228d7c6188b9
Author: Archit Taneja <archit@ti.com>
Date:   Fri Apr 11 12:53:34 2014 +0530

    drm/omap: Use old_fb to synchronize between successive page flips
    
    omap_crtc->old_fb is used to check whether the previous page flip has completed
    or not. However, it's never initialized to anything, so it's always NULL. This
    results in the check to always succeed, and the page_flip to proceed.
    
    Initialize old_fb to the fb that we intend to flip to through page_flip, and
    therefore prevent a future page flip to proceed if the last one didn't
    complete.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 46f8e1e40e88..00798247190b 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -360,7 +360,7 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 	}
 
 	omap_crtc->event = event;
-	primary->fb = fb;
+	omap_crtc->old_fb = primary->fb = fb;
 
 	/*
 	 * Hold a reference temporarily until the crtc is updated

commit 71b6667765c7019f3fd5ea5e0c02f65f7331f3e1
Author: Archit Taneja <archit@ti.com>
Date:   Fri Apr 11 12:53:32 2014 +0530

    drm/omap: Fix crash when using LCD3 overlay manager
    
    The channel_names list didn't have a string populated for LCD3 manager, this
    results in a crash when the display's output is connected to LCD3. Add an entry
    for LCD3.
    
    Reported-by: Somnath Mukherjee <somnath@ti.com>
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index b3a7529845b9..46f8e1e40e88 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -654,6 +654,7 @@ static const char *channel_names[] = {
 		[OMAP_DSS_CHANNEL_LCD] = "lcd",
 		[OMAP_DSS_CHANNEL_DIGIT] = "tv",
 		[OMAP_DSS_CHANNEL_LCD2] = "lcd2",
+		[OMAP_DSS_CHANNEL_LCD3] = "lcd3",
 };
 
 void omap_crtc_pre_init(void)

commit 772cdc9777403f10c4229c49645024a502dfd783
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Apr 9 14:51:01 2014 +0300

    drm/omap: remove extra plane->destroy from crtc destroy
    
    All the planes, including primary planes, are now destroyed by the drm
    framework. Thus we no longer need the explicit call to plane->destroy
    from the crtc's destroy function.
    
    This patch removes the call, thus fixing the crash caused by double
    freeing the plane.
    
    remove omap_crtc->plane->funcs->destroy(omap_crtc->plane)
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index f59ef9359e66..b3a7529845b9 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -197,7 +197,6 @@ static void omap_crtc_destroy(struct drm_crtc *crtc)
 	WARN_ON(omap_crtc->apply_irq.registered);
 	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 
-	omap_crtc->plane->funcs->destroy(omap_crtc->plane);
 	drm_crtc_cleanup(crtc);
 
 	kfree(omap_crtc);

commit 506096a113832239ce763d20fab8e94f76d56266
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Apr 3 13:11:54 2014 +0300

    drm/omap: fix enabling/disabling of video pipeline
    
    At the moment the omap_crtc_pre_apply() handles the enabling, disabling
    and configuring of encoders and panels separately from the CRTC (i.e.
    the overlay manager).
    
    However, this doesn't work correctly. The encoder driver has to be in
    control of its video input (i.e. the crtc) for correct operation.
    
    This problem causes bugs with (at least) HDMI: the HDMI encoder supplies
    pixel clock for DISPC, and DISPC supplies video stream for HDMI. The
    current code first enables the HDMI encoder, and CRTC after that.
    However, the encoder expects the video stream to start during the
    encoder's enable, and if it doesn't, there will be sync lost errors.
    
    The encoder enables its video source by calling src->enable(), and this
    call goes to omapdrm (omap_crtc_enable), but omapdrm doesn't do anything
    in that function. Similarly for disable, which goes to
    omap_crtc_disable().
    
    This patch moves the code to setup and enable/disable the crtc to
    omap_crtc_enable. and omap_crtc_disable().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 61d1c4897a45..f59ef9359e66 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -121,13 +121,25 @@ static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
 {
 }
 
+static void set_enabled(struct drm_crtc *crtc, bool enable);
+
 static int omap_crtc_enable(struct omap_overlay_manager *mgr)
 {
+	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+
+	dispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);
+	dispc_mgr_set_timings(omap_crtc->channel,
+			&omap_crtc->timings);
+	set_enabled(&omap_crtc->base, true);
+
 	return 0;
 }
 
 static void omap_crtc_disable(struct omap_overlay_manager *mgr)
 {
+	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+
+	set_enabled(&omap_crtc->base, false);
 }
 
 static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
@@ -601,7 +613,6 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 	omap_crtc->current_encoder = encoder;
 
 	if (!omap_crtc->enabled) {
-		set_enabled(&omap_crtc->base, false);
 		if (encoder)
 			omap_encoder_set_enabled(encoder, false);
 	} else {
@@ -610,13 +621,7 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 			omap_encoder_update(encoder, omap_crtc->mgr,
 					&omap_crtc->timings);
 			omap_encoder_set_enabled(encoder, true);
-			omap_crtc->full_update = false;
 		}
-
-		dispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);
-		dispc_mgr_set_timings(omap_crtc->channel,
-				&omap_crtc->timings);
-		set_enabled(&omap_crtc->base, true);
 	}
 
 	omap_crtc->full_update = false;

commit c7aef12f344459961eb1e0ba10d184816ed42d99
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Apr 3 16:30:03 2014 +0300

    drm/omap: fix missing disable for unused encoder
    
    When an encoder is no longer connected to a crtc, the driver will leave
    the encoder enabled.
    
    This patch adds code to track the encoder used for a crtc, and when the
    encoder changes, the old one is disabled.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 161a74a3ac5e..61d1c4897a45 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -33,6 +33,7 @@ struct omap_crtc {
 	int pipe;
 	enum omap_channel channel;
 	struct omap_overlay_manager_info info;
+	struct drm_encoder *current_encoder;
 
 	/*
 	 * Temporary: eventually this will go away, but it is needed
@@ -594,6 +595,11 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 		}
 	}
 
+	if (omap_crtc->current_encoder && encoder != omap_crtc->current_encoder)
+		omap_encoder_set_enabled(omap_crtc->current_encoder, false);
+
+	omap_crtc->current_encoder = encoder;
+
 	if (!omap_crtc->enabled) {
 		set_enabled(&omap_crtc->base, false);
 		if (encoder)

commit e2f8fd74ec1bf15cb2abc1b11f7d9fa09581024e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Apr 2 14:31:57 2014 +0300

    drm/omap: fix race issue when unloading omapdrm
    
    At module unload, omap_fbdev_free() gets called which releases the
    framebuffers. However, the framebuffers are still used by crtcs, and
    will be released only later at vsync. The driver doesn't wait for this,
    and goes on to release the rest of the resources, which often
    causes a crash.
    
    This patchs adds a omap_crtc_flush() function which waits until the crtc
    has finished with its apply queue and page flips.
    
    The function utilizes a simple polling while-loop, as the performance is
    not an issue here.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 0acbe62901d9..161a74a3ac5e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -621,6 +621,25 @@ static void omap_crtc_post_apply(struct omap_drm_apply *apply)
 	/* nothing needed for post-apply */
 }
 
+void omap_crtc_flush(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	int loops = 0;
+
+	while (!list_empty(&omap_crtc->pending_applies) ||
+		!list_empty(&omap_crtc->queued_applies) ||
+		omap_crtc->event || omap_crtc->old_fb) {
+
+		if (++loops > 10) {
+			dev_err(crtc->dev->dev,
+				"omap_crtc_flush() timeout\n");
+			break;
+		}
+
+		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
+	}
+}
+
 static const char *channel_names[] = {
 		[OMAP_DSS_CHANNEL_LCD] = "lcd",
 		[OMAP_DSS_CHANNEL_DIGIT] = "tv",

commit 2ec8e3787ae6957f738bb133e755213b9d7c066e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Apr 2 11:37:06 2014 +0300

    drm/omap: fix output enable/disable sequence
    
    At the moment it's quite easy to get the following errors when the HDMI
    output is enabled or disabled:
    
    [drm:omap_crtc_error_irq] *ERROR* tv: errors: 00008000
    
    The reason for the errors is that the omapdrm driver doesn't properly
    handle the sync-lost irqs that happen when enabling the DIGIT crtc,
    which is used for HDMI and analog TV. The driver does disable the
    sync-lost irq properly, but it fails to wait until the output has been
    fully enabled (i.e. the first vsync), so the sync-lost errors are still
    seen occasionally.
    
    This patch makes the omapdrm act the same way as the omapfb does:
    
    - When enabling a display, we'll wait for the first vsync.
    - When disabling a display, we'll wait for framedone if available, or
      odd and even vsyncs.
    
    These changes make sure the output is fully enabled or disabled at the
    end of the function.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reported-by: Sanjay Singh Rawat <sanjay.rawat@linaro.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 355157e4f78d..0acbe62901d9 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -528,38 +528,46 @@ static void set_enabled(struct drm_crtc *crtc, bool enable)
 	struct drm_device *dev = crtc->dev;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
 	enum omap_channel channel = omap_crtc->channel;
-	struct omap_irq_wait *wait = NULL;
+	struct omap_irq_wait *wait;
+	u32 framedone_irq, vsync_irq;
+	int ret;
 
 	if (dispc_mgr_is_enabled(channel) == enable)
 		return;
 
-	/* ignore sync-lost irqs during enable/disable */
+	/*
+	 * Digit output produces some sync lost interrupts during the first
+	 * frame when enabling, so we need to ignore those.
+	 */
 	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 
-	if (dispc_mgr_get_framedone_irq(channel)) {
-		if (!enable) {
-			wait = omap_irq_wait_init(dev,
-					dispc_mgr_get_framedone_irq(channel), 1);
-		}
+	framedone_irq = dispc_mgr_get_framedone_irq(channel);
+	vsync_irq = dispc_mgr_get_vsync_irq(channel);
+
+	if (enable) {
+		wait = omap_irq_wait_init(dev, vsync_irq, 1);
 	} else {
 		/*
-		 * When we disable digit output, we need to wait until fields
-		 * are done.  Otherwise the DSS is still working, and turning
-		 * off the clocks prevents DSS from going to OFF mode. And when
-		 * enabling, we need to wait for the extra sync losts
+		 * When we disable the digit output, we need to wait for
+		 * FRAMEDONE to know that DISPC has finished with the output.
+		 *
+		 * OMAP2/3 does not have FRAMEDONE irq for digit output, and in
+		 * that case we need to use vsync interrupt, and wait for both
+		 * even and odd frames.
 		 */
-		wait = omap_irq_wait_init(dev,
-				dispc_mgr_get_vsync_irq(channel), 2);
+
+		if (framedone_irq)
+			wait = omap_irq_wait_init(dev, framedone_irq, 1);
+		else
+			wait = omap_irq_wait_init(dev, vsync_irq, 2);
 	}
 
 	dispc_mgr_enable(channel, enable);
 
-	if (wait) {
-		int ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
-		if (ret) {
-			dev_err(dev->dev, "%s: timeout waiting for %s\n",
-					omap_crtc->name, enable ? "enable" : "disable");
-		}
+	ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
+	if (ret) {
+		dev_err(dev->dev, "%s: timeout waiting for %s\n",
+				omap_crtc->name, enable ? "enable" : "disable");
 	}
 
 	omap_irq_register(crtc->dev, &omap_crtc->error_irq);

commit f4510a2752b75ad5847b7935b68c233cab497f97
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:40 2014 -0700

    drm: Replace crtc fb with primary plane fb (v3)
    
    Now that CRTC's have a primary plane, there's no need to track the
    framebuffer in the CRTC.  Replace all references to the CRTC fb with the
    primary plane's fb.
    
    This patch was generated by the Coccinelle semantic patching tool using
    the following rules:
    
            @@ struct drm_crtc C; @@
            -   (C).fb
            +   C.primary->fb
    
            @@ struct drm_crtc *C; @@
            -   (C)->fb
            +   C->primary->fb
    
    v3: Generate patch via coccinelle.  Actual removal of crtc->fb has been
        moved to a subsequent patch.
    
    v2: Fixup several lingering crtc->fb instances that were missed in the
        first patch iteration.  [Rob Clark]
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 4313bb0a49a6..355157e4f78d 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -245,7 +245,7 @@ static int omap_crtc_mode_set(struct drm_crtc *crtc,
 	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
 	omap_crtc->full_update = true;
 
-	return omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,
+	return omap_plane_mode_set(omap_crtc->plane, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			x << 16, y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
@@ -273,7 +273,7 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 	struct drm_plane *plane = omap_crtc->plane;
 	struct drm_display_mode *mode = &crtc->mode;
 
-	return omap_plane_mode_set(plane, crtc, crtc->fb,
+	return omap_plane_mode_set(plane, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			x << 16, y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
@@ -308,14 +308,14 @@ static void page_flip_worker(struct work_struct *work)
 	struct drm_gem_object *bo;
 
 	mutex_lock(&crtc->mutex);
-	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,
+	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->primary->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			crtc->x << 16, crtc->y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
 			vblank_cb, crtc);
 	mutex_unlock(&crtc->mutex);
 
-	bo = omap_framebuffer_bo(crtc->fb, 0);
+	bo = omap_framebuffer_bo(crtc->primary->fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
 }
 
@@ -336,9 +336,10 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 {
 	struct drm_device *dev = crtc->dev;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_plane *primary = crtc->primary;
 	struct drm_gem_object *bo;
 
-	DBG("%d -> %d (event=%p)", crtc->fb ? crtc->fb->base.id : -1,
+	DBG("%d -> %d (event=%p)", primary->fb ? primary->fb->base.id : -1,
 			fb->base.id, event);
 
 	if (omap_crtc->old_fb) {
@@ -347,7 +348,7 @@ static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 	}
 
 	omap_crtc->event = event;
-	crtc->fb = fb;
+	primary->fb = fb;
 
 	/*
 	 * Hold a reference temporarily until the crtc is updated

commit 3a01ab255637fdc2fbc97cf356f1b971c3fc0c64
Author: Archit Taneja <archit@ti.com>
Date:   Thu Jan 2 14:49:51 2014 +0530

    drm/omap: fix: Defer probe if an omapdss device requests for it at connect
    
    With the omapdss device model changes. omapdrm is required to call dssdriver's
    connect() op to register a panel. This is currently done in omap_modeset_init()
    
    A call to connect() can fail if the omapdss panels or the encoders(HDMI/DPI)
    they connect to have some resource(like regulators, I2C adapter) missing. If
    this happens, the correct approach is to defer omapdrm's probe.
    
    omapdrm currently ignores those panels which return a non zero value when
    connected. This could result in omapdrm ignoring all panels on an omap board.
    
    The right approach would be for omapdrm to request for probe deferral when a
    panel's connect op returns -EPROBE_DEFER.
    
    In order to do this, we need to call connect() much earlier during omapdrm's
    probe to prevent too many things are already done by then. We now connect the
    panels during pdev_probe(), before anything else is initialized, so that we
    don't need to undo too many things if a defer was requested.
    
    Now when we enter omap_modeset_init(), we have a set of panels that have been
    connected. We now proceed with registering only those panels that are already
    connected.
    
    A special case has to be considered when no panels are available to connect when
    omapdrm probes. In this case too, we defer probe and expect that a panel will be
    available to connect the next time.
    
    Checking whether the panel has a driver or whether it has get_timing/read_edid
    ops in omap_modeset_init() are redundant with the new display model. These can
    be removed since a dssdev device will always have a driver associated with it,
    and all dssdev drivers have a get_timings op.
    
    This will mainly fix cases when omapdrm is built-in the kernel, since that's
    generally where resources like regulators or I2C are unavailable because of
    probe order dependencies.
    
    In particular this fixes boot with omapdrm built-in on an omap4 panda ES board.
    The regulators used by HDMI(provided by I2C based TWL regulators) aren't
    initialized because I2C isn't initialized, I2C isn't initialized as it's pins
    are not configured because pinctrl is yet to probe.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index e6241c2b8b26..4313bb0a49a6 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -623,6 +623,11 @@ void omap_crtc_pre_init(void)
 	dss_install_mgr_ops(&mgr_ops);
 }
 
+void omap_crtc_pre_uninit(void)
+{
+	dss_uninstall_mgr_ops();
+}
+
 /* initialize crtc */
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 		struct drm_plane *plane, enum omap_channel channel, int id)

commit 6da9f89172b94411896130c6e1acf159da3dc760
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Oct 24 09:50:50 2013 +0300

    drm/omap: fix (un)registering irqs inside an irq handler
    
    omapdrm (un)registers irqs inside an irq handler. The problem is that
    the (un)register function uses dispc_runtime_get/put() to enable the
    clocks, and those functions are not irq safe by default.
    
    This was kind of fixed in 48664b21aeeffb40c5fa06843f18052e2c4ec9ef
    (OMAPDSS: DISPC: set irq_safe for runtime PM), which makes dispc's
    runtime calls irq-safe.
    
    However, using pm_runtime_irq_safe in dispc makes the parent of dispc,
    dss, always enabled, effectively preventing PM for the whole DSS module.
    
    This patch makes omapdrm behave better by adding new irq (un)register
    functions that do not use dispc_runtime_get/put, and using those
    functions in interrupt context. Thus we can make dispc again
    non-irq-safe, allowing proper PM.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 0fd2eb139f6e..e6241c2b8b26 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -411,7 +411,7 @@ static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	struct drm_crtc *crtc = &omap_crtc->base;
 	DRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);
 	/* avoid getting in a flood, unregister the irq until next vblank */
-	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+	__omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
 }
 
 static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -421,13 +421,13 @@ static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	struct drm_crtc *crtc = &omap_crtc->base;
 
 	if (!omap_crtc->error_irq.registered)
-		omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+		__omap_irq_register(crtc->dev, &omap_crtc->error_irq);
 
 	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
 		struct omap_drm_private *priv =
 				crtc->dev->dev_private;
 		DBG("%s: apply done", omap_crtc->name);
-		omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
+		__omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
 		queue_work(priv->wq, &omap_crtc->apply_work);
 	}
 }

commit ed8d19756e80ec63003a93aa4d70406e6ba61522
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Jul 22 18:49:58 2013 -0700

    drm: Pass page flip ioctl flags to driver
    
    This lets drivers see the flags requested by the application
    
    [airlied: fixup for rcar/imx/msm]
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 11a5263a5e9f..0fd2eb139f6e 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -331,7 +331,8 @@ static void page_flip_cb(void *arg)
 
 static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
 		 struct drm_framebuffer *fb,
-		 struct drm_pending_vblank_event *event)
+		 struct drm_pending_vblank_event *event,
+		 uint32_t page_flip_flags)
 {
 	struct drm_device *dev = crtc->dev;
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);

commit 2e17c5a97e231f3cb426f4b7895eab5be5c5442e
Merge: 5f097cd249f0 774d8e34e465
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 16:04:31 2013 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Okay this is the big one, I was stalled on the fbdev pull req as I
      stupidly let fbdev guys merge a patch I required to fix a warning with
      some patches I had, they ended up merging the patch from the wrong
      place, but the warning should be fixed.  In future I'll just take the
      patch myself!
    
      Outside drm:
    
      There are some snd changes for the HDMI audio interactions on haswell,
      they've been acked for inclusion via my tree.  This relies on the
      wound/wait tree from Ingo which is already merged.
    
      Major changes:
    
      AMD finally released the dynamic power management code for all their
      GPUs from r600->present day, this is great, off by default for now but
      also a huge amount of code, in fact it is most of this pull request.
    
      Since it landed there has been a lot of community testing and Alex has
      sent a lot of fixes for any bugs found so far.  I suspect radeon might
      now be the biggest kernel driver ever :-P p.s.  radeon.dpm=1 to enable
      dynamic powermanagement for anyone.
    
      New drivers:
    
      Renesas r-car display unit.
    
      Other highlights:
    
       - core: GEM CMA prime support, use new w/w mutexs for TTM
         reservations, cursor hotspot, doc updates
       - dvo chips: chrontel 7010B support
       - i915: Haswell (fbc, ips, vecs, watermarks, audio powerwell),
         Valleyview (enabled by default, rc6), lots of pll reworking, 30bpp
         support (this time for sure)
       - nouveau: async buffer object deletion, context/register init
         updates, kernel vp2 engine support, GF117 support, GK110 accel
         support (with external nvidia ucode), context cleanups.
       - exynos: memory leak fixes, Add S3C64XX SoC series support, device
         tree updates, common clock framework support,
       - qxl: cursor hotspot support, multi-monitor support, suspend/resume
         support
       - mgag200: hw cursor support, g200 mode limiting
       - shmobile: prime support
       - tegra: fixes mostly
    
      I've been banging on this quite a lot due to the size of it, and it
      seems to okay on everything I've tested it on."
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (811 commits)
      drm/radeon/dpm: implement vblank_too_short callback for si
      drm/radeon/dpm: implement vblank_too_short callback for cayman
      drm/radeon/dpm: implement vblank_too_short callback for btc
      drm/radeon/dpm: implement vblank_too_short callback for evergreen
      drm/radeon/dpm: implement vblank_too_short callback for 7xx
      drm/radeon/dpm: add checks against vblank time
      drm/radeon/dpm: add helper to calculate vblank time
      drm/radeon: remove stray line in old pm code
      drm/radeon/dpm: fix display_gap programming on rv7xx
      drm/nvc0/gr: fix gpc firmware regression
      drm/nouveau: fix minor thinko causing bo moves to not be async on kepler
      drm/radeon/dpm: implement force performance level for TN
      drm/radeon/dpm: implement force performance level for ON/LN
      drm/radeon/dpm: implement force performance level for SI
      drm/radeon/dpm: implement force performance level for cayman
      drm/radeon/dpm: implement force performance levels for 7xx/eg/btc
      drm/radeon/dpm: add infrastructure to force performance levels
      drm/radeon: fix surface setup on r1xx
      drm/radeon: add support for 3d perf states on older asics
      drm/radeon: set default clocks for SI when DPM is disabled
      ...

commit 1f68d9c4b660487c5878c4800ff5a402abc6c005
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Apr 19 15:09:34 2013 +0300

    OMAPDSS: combine omap_dss_output into omap_dss_device
    
    We currently have omap_dss_device, which represents an external display
    device, sometimes an external encoder, sometimes a panel. Then we have
    omap_dss_output, which represents DSS's output encoder.
    
    In the future with new display device model, we construct a video
    pipeline from the display blocks. To accomplish this, all the blocks
    need to be presented by the same entity.
    
    Thus, this patch combines omap_dss_output into omap_dss_device. Some of
    the fields in omap_dss_output are already found in omap_dss_device, but
    some are not. This means we'll have DSS output specific fields in
    omap_dss_device, which is not very nice. However, it is easier to just
    keep those output specific fields there for now, and after transition to
    new display device model is made, they can be cleaned up easier than
    could be done now.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index b2ab2f5d3cb9..4cec678dba94 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -95,7 +95,7 @@ static struct omap_crtc *omap_crtcs[8];
 
 /* we can probably ignore these until we support command-mode panels: */
 static int omap_crtc_connect(struct omap_overlay_manager *mgr,
-		struct omap_dss_output *dst)
+		struct omap_dss_device *dst)
 {
 	if (mgr->output)
 		return -EINVAL;
@@ -110,7 +110,7 @@ static int omap_crtc_connect(struct omap_overlay_manager *mgr,
 }
 
 static void omap_crtc_disconnect(struct omap_overlay_manager *mgr,
-		struct omap_dss_output *dst)
+		struct omap_dss_device *dst)
 {
 	mgr->output->manager = NULL;
 	mgr->output = NULL;

commit a7e71e7f9fc7924921081aa55ceafca00d2c9f49
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 8 16:23:32 2013 +0300

    OMAPDSS: Implement display (dis)connect support
    
    We currently have two steps in panel initialization and startup: probing
    and enabling. After the panel has been probed, it's ready and can be
    configured and later enabled.
    
    This model is not enough with more complex display pipelines, where we
    may have, for example, two panels, of which only one can be used at a
    time, connected to the same video output.
    
    To support that kind of scenarios, we need to add new step to the
    initialization: connect.
    
    This patch adds support for connecting and disconnecting panels. After
    probe, but before connect, no panel ops should be called. When the
    connect is called, a proper video pipeline is established, and the panel
    is ready for use. If some part in the video pipeline is already
    connected (by some other panel), the connect call fails.
    
    One key difference with the old style setup is that connect() handles
    also connecting to the overlay manager. This means that the omapfb (or
    omapdrm) no longer needs to figure out which overlay manager to use, but
    it can just call connect() on the panel, and the proper overlay manager
    is connected by omapdss.
    
    This also allows us to add back the support for dynamic switching
    between two exclusive panels. However, the current panel device model is
    not changed to support this, as the new device model is implemented in
    the following patches and the old model will be removed. The new device
    model supports dynamic switching.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 02075bfcd8fd..b2ab2f5d3cb9 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -94,6 +94,28 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
 static struct omap_crtc *omap_crtcs[8];
 
 /* we can probably ignore these until we support command-mode panels: */
+static int omap_crtc_connect(struct omap_overlay_manager *mgr,
+		struct omap_dss_output *dst)
+{
+	if (mgr->output)
+		return -EINVAL;
+
+	if ((mgr->supported_outputs & dst->id) == 0)
+		return -EINVAL;
+
+	dst->manager = mgr;
+	mgr->output = dst;
+
+	return 0;
+}
+
+static void omap_crtc_disconnect(struct omap_overlay_manager *mgr,
+		struct omap_dss_output *dst)
+{
+	mgr->output->manager = NULL;
+	mgr->output = NULL;
+}
+
 static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
 {
 }
@@ -138,6 +160,8 @@ static void omap_crtc_unregister_framedone_handler(
 }
 
 static const struct dss_mgr_ops mgr_ops = {
+		.connect = omap_crtc_connect,
+		.disconnect = omap_crtc_disconnect,
 		.start_update = omap_crtc_start_update,
 		.enable = omap_crtc_enable,
 		.disable = omap_crtc_disable,

commit 04b1fc0291674666110fffd09b30d8304aaa4602
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 14 10:55:19 2013 +0300

    OMAPDRM: fix overlay manager handling
    
    Currently omapdrm creates crtcs, which map directly to DSS overlay
    managers, only on demand at init time. This would make it difficult to
    manage connecting the display entities in the future, as the code cannot
    just search for a suitable overlay manager.
    
    We cannot fix this the sane way, which would be to create crtcs for each
    overlay manager, because we need an overlay for each crtc. With limited
    number of overlays, that's not possible.
    
    So the solution for now is to detach the overlay manager from the crtc.
    crtcs are still created on demand at init time, but all overlay managers
    are always initialized by the omapdss.
    
    This way we can create and connect whole display pipelines from the
    overlay manager to the display, regardless of which crtcs omapdrm would
    create.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 79b200aee18a..02075bfcd8fd 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -40,7 +40,7 @@ struct omap_crtc {
 	 * mgr->id.)  Eventually this will be replaced w/ something
 	 * more common-panel-framework-y
 	 */
-	struct omap_overlay_manager mgr;
+	struct omap_overlay_manager *mgr;
 
 	struct omap_video_timings timings;
 	bool enabled;
@@ -90,6 +90,9 @@ uint32_t pipe2vbl(struct drm_crtc *crtc)
  * job of sequencing the setup of the video pipe in the proper order
  */
 
+/* ovl-mgr-id -> crtc */
+static struct omap_crtc *omap_crtcs[8];
+
 /* we can probably ignore these until we support command-mode panels: */
 static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
 {
@@ -107,7 +110,7 @@ static void omap_crtc_disable(struct omap_overlay_manager *mgr)
 static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
 		const struct omap_video_timings *timings)
 {
-	struct omap_crtc *omap_crtc = container_of(mgr, struct omap_crtc, mgr);
+	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 	DBG("%s", omap_crtc->name);
 	omap_crtc->timings = *timings;
 	omap_crtc->full_update = true;
@@ -116,7 +119,7 @@ static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
 static void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,
 		const struct dss_lcd_mgr_config *config)
 {
-	struct omap_crtc *omap_crtc = container_of(mgr, struct omap_crtc, mgr);
+	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
 	DBG("%s", omap_crtc->name);
 	dispc_mgr_set_lcd_config(omap_crtc->channel, config);
 }
@@ -569,7 +572,7 @@ static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
 	} else {
 		if (encoder) {
 			omap_encoder_set_enabled(encoder, false);
-			omap_encoder_update(encoder, &omap_crtc->mgr,
+			omap_encoder_update(encoder, omap_crtc->mgr,
 					&omap_crtc->timings);
 			omap_encoder_set_enabled(encoder, true);
 			omap_crtc->full_update = false;
@@ -595,6 +598,11 @@ static const char *channel_names[] = {
 		[OMAP_DSS_CHANNEL_LCD2] = "lcd2",
 };
 
+void omap_crtc_pre_init(void)
+{
+	dss_install_mgr_ops(&mgr_ops);
+}
+
 /* initialize crtc */
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 		struct drm_plane *plane, enum omap_channel channel, int id)
@@ -635,9 +643,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_irq_register(dev, &omap_crtc->error_irq);
 
 	/* temporary: */
-	omap_crtc->mgr.id = channel;
-
-	dss_install_mgr_ops(&mgr_ops);
+	omap_crtc->mgr = omap_dss_get_overlay_manager(channel);
 
 	/* TODO: fix hard-coded setup.. add properties! */
 	info = &omap_crtc->info;
@@ -651,6 +657,8 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	omap_plane_install_properties(omap_crtc->plane, &crtc->base);
 
+	omap_crtcs[channel] = omap_crtc;
+
 	return crtc;
 
 fail:

commit fb85ac4da8d202f89e0635e4ac2ac680d662be98
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon May 27 20:19:58 2013 +0300

    drm: Drop all the stub gamma_get, gamma_set, load_lut functions from drivers
    
    Many of the drivers didn't implement palette/gamma handling, but were forced
    to provide stubs for the hooks to avoid drm_fb_helper from oopsing. Now that
    the hooks are optional, we can eliminate all the stubs.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 79b200aee18a..ef161ea982e6 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -253,10 +253,6 @@ static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 			NULL, NULL);
 }
 
-static void omap_crtc_load_lut(struct drm_crtc *crtc)
-{
-}
-
 static void vblank_cb(void *arg)
 {
 	struct drm_crtc *crtc = arg;
@@ -366,7 +362,6 @@ static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
 	.prepare = omap_crtc_prepare,
 	.commit = omap_crtc_commit,
 	.mode_set_base = omap_crtc_mode_set_base,
-	.load_lut = omap_crtc_load_lut,
 };
 
 const struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)

commit 0d8f371f5a0cfdad946b5dd0ba9c77d2fbd5b2d3
Author: Archit Taneja <archit@ti.com>
Date:   Tue Mar 26 19:15:19 2013 +0530

    drm/omap: Fix and improve crtc and overlay manager correlation
    
    The omapdrm driver currently takes a config/module arg to figure out the number
    of crtcs it needs to create. We could create as many crtcs as there are overlay
    managers in the DSS hardware, but we don't do that because each crtc eats up
    one DSS overlay, and that reduces the number of planes we can attach to a single
    crtc.
    
    Since the number of crtcs may be lesser than the number of hardware overlay
    managers, we need to figure out which overlay managers to use for our crtcs. The
    current approach is to use pipe2chan(), which returns a higher numbered manager
    for the crtc.
    
    The problem with this approach is that it assumes that the overlay managers we
    choose will connect to the encoders the platform's panels are going to use,
    this isn't true, an overlay manager connects only to a few outputs/encoders, and
    choosing any overlay manager for our crtc might lead to a situation where the
    encoder cannot connect to any of the crtcs we have chosen. For example, an
    omap5-panda board has just one hdmi output. If num_crtc is set to 1, with the
    current approach, pipe2chan will pick up the LCD2 overlay manager, which cannot
    connect to the hdmi encoder at all. The only manager that could have connected
    to hdmi was the TV overlay manager.
    
    Therefore, there is a need to choose our overlay managers keeping in mind the
    panels we have on that platform. The new approach iterates through all the
    available panels, creates encoders and connectors for them, and then tries to
    get a suitable overlay manager to create a crtc which can connect to the
    encoders.
    
    We use the dispc_channel field in omap_dss_output to retrieve the desired
    overlay manager's channel number, we then check whether the manager had already
    been assigned to a crtc or not. If it was already assigned to a crtc, we assume
    that out of all the encoders which intend use this crtc, only one will run at a
    time. If the overlay manager wan't assigned to a crtc till then, we create a
    new crtc and link it with the overlay manager.
    
    This approach just looks for the best dispc_channel for each encoder. On DSS HW,
    some encoders can connect to multiple overlay managers. Since we don't try
    looking for alternate overlay managers, there is a greater possibility that 2
    or more encoders end up asking for the same crtc, causing only one encoder to
    run at a time.
    
    Also, this approach isn't the most optimal one, it can do either good or bad
    depending on the sequence in which the panels/outputs are parsed. The optimal
    way would be some sort of back tracking approach, where we improve the set of
    managers we use as we iterate through the list of panels/encoders. That's
    something left for later.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index bec66a490b8f..79b200aee18a 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -74,6 +74,13 @@ struct omap_crtc {
 	struct work_struct page_flip_work;
 };
 
+uint32_t pipe2vbl(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	return dispc_mgr_get_vsync_irq(omap_crtc->channel);
+}
+
 /*
  * Manager-ops, callbacks from output when they need to configure
  * the upstream part of the video pipe.
@@ -613,7 +620,13 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->apply.pre_apply  = omap_crtc_pre_apply;
 	omap_crtc->apply.post_apply = omap_crtc_post_apply;
 
-	omap_crtc->apply_irq.irqmask = pipe2vbl(id);
+	omap_crtc->channel = channel;
+	omap_crtc->plane = plane;
+	omap_crtc->plane->crtc = crtc;
+	omap_crtc->name = channel_names[channel];
+	omap_crtc->pipe = id;
+
+	omap_crtc->apply_irq.irqmask = pipe2vbl(crtc);
 	omap_crtc->apply_irq.irq = omap_crtc_apply_irq;
 
 	omap_crtc->error_irq.irqmask =
@@ -621,12 +634,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 	omap_crtc->error_irq.irq = omap_crtc_error_irq;
 	omap_irq_register(dev, &omap_crtc->error_irq);
 
-	omap_crtc->channel = channel;
-	omap_crtc->plane = plane;
-	omap_crtc->plane->crtc = crtc;
-	omap_crtc->name = channel_names[channel];
-	omap_crtc->pipe = id;
-
 	/* temporary: */
 	omap_crtc->mgr.id = channel;
 

commit fffddfd6c8e0c10c42c6e2cc54ba880fcc36ebbb
Merge: 69086a78bdc9 be88298b0a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:46:44 2013 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge from Dave Airlie:
     "Highlights:
    
       - TI LCD controller KMS driver
    
       - TI OMAP KMS driver merged from staging
    
       - drop gma500 stub driver
    
       - the fbcon locking fixes
    
       - the vgacon dirty like zebra fix.
    
       - open firmware videomode and hdmi common code helpers
    
       - major locking rework for kms object handling - pageflip/cursor
         won't block on polling anymore!
    
       - fbcon helper and prime helper cleanups
    
       - i915: all over the map, haswell power well enhancements, valleyview
         macro horrors cleaned up, killing lots of legacy GTT code,
    
       - radeon: CS ioctl unification, deprecated UMS support, gpu reset
         rework, VM fixes
    
       - nouveau: reworked thermal code, external dp/tmds encoder support
         (anx9805), fences sleep instead of polling,
    
       - exynos: all over the driver fixes."
    
    Lovely conflict in radeon/evergreen_cs.c between commit de0babd60d8d
    ("drm/radeon: enforce use of radeon_get_ib_value when reading user cmd")
    and the new changes that modified that evergreen_dma_cs_parse()
    function.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (508 commits)
      drm/tilcdc: only build on arm
      drm/i915: Revert hdmi HDP pin checks
      drm/tegra: Add list of framebuffers to debugfs
      drm/tegra: Fix color expansion
      drm/tegra: Split DC_CMD_STATE_CONTROL register write
      drm/tegra: Implement page-flipping support
      drm/tegra: Implement VBLANK support
      drm/tegra: Implement .mode_set_base()
      drm/tegra: Add plane support
      drm/tegra: Remove bogus tegra_framebuffer structure
      drm: Add consistency check for page-flipping
      drm/radeon: Use generic HDMI infoframe helpers
      drm/tegra: Use generic HDMI infoframe helpers
      drm: Add EDID helper documentation
      drm: Add HDMI infoframe helpers
      video: Add generic HDMI infoframe helpers
      drm: Add some missing forward declarations
      drm: Move mode tables to drm_edid.c
      drm: Remove duplicate drm_mode_cea_vic()
      gma500: Fix n, m1 and m2 clock limits for sdvo and lvds
      ...

commit 16ef3dfe460616f14120973f78fe640e79862654
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 24 17:20:33 2013 +0100

    omapdrm: only take crtc->mutex in crtc callbacks
    
    Omapdrm doesn't do anything nefarious with crtc load detection or has
    any shared resources, so this is enough. We also need to adjust the
    WARN_ON.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2b97cf90071b..ac2258f59805 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -274,17 +274,16 @@ static void page_flip_worker(struct work_struct *work)
 	struct omap_crtc *omap_crtc =
 			container_of(work, struct omap_crtc, page_flip_work);
 	struct drm_crtc *crtc = &omap_crtc->base;
-	struct drm_device *dev = crtc->dev;
 	struct drm_display_mode *mode = &crtc->mode;
 	struct drm_gem_object *bo;
 
-	drm_modeset_lock_all(dev);
+	mutex_lock(&crtc->mutex);
 	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,
 			0, 0, mode->hdisplay, mode->vdisplay,
 			crtc->x << 16, crtc->y << 16,
 			mode->hdisplay << 16, mode->vdisplay << 16,
 			vblank_cb, crtc);
-	drm_modeset_unlock_all(dev);
+	mutex_unlock(&crtc->mutex);
 
 	bo = omap_framebuffer_bo(crtc->fb, 0);
 	drm_gem_object_unreference_unlocked(bo);
@@ -417,7 +416,7 @@ static void apply_worker(struct work_struct *work)
 	 * the callbacks and list modification all serialized
 	 * with respect to modesetting ioctls from userspace.
 	 */
-	drm_modeset_lock_all(dev);
+	mutex_lock(&crtc->mutex);
 	dispc_runtime_get();
 
 	/*
@@ -462,16 +461,15 @@ static void apply_worker(struct work_struct *work)
 
 out:
 	dispc_runtime_put();
-	drm_modeset_unlock_all(dev);
+	mutex_unlock(&crtc->mutex);
 }
 
 int omap_crtc_apply(struct drm_crtc *crtc,
 		struct omap_drm_apply *apply)
 {
 	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct drm_device *dev = crtc->dev;
 
-	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
+	WARN_ON(!mutex_is_locked(&crtc->mutex));
 
 	/* no need to queue it again if it is already queued: */
 	if (apply->queued)

commit 8bb0daffb0b8e45188066255b4203446eae181f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Feb 11 12:43:09 2013 -0500

    drm/omap: move out of staging
    
    Now that the omapdss interface has been reworked so that omapdrm can use
    dispc directly, we have been able to fix the remaining functional kms
    issues with omapdrm.  And in the mean time the PM sequencing and many
    other of that open issues have been solved.  So I think it makes sense
    to finally move omapdrm out of staging.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
new file mode 100644
index 000000000000..2b97cf90071b
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -0,0 +1,659 @@
+/*
+ * drivers/gpu/drm/omapdrm/omap_crtc.c
+ *
+ * Copyright (C) 2011 Texas Instruments
+ * Author: Rob Clark <rob@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "omap_drv.h"
+
+#include <drm/drm_mode.h>
+#include "drm_crtc.h"
+#include "drm_crtc_helper.h"
+
+#define to_omap_crtc(x) container_of(x, struct omap_crtc, base)
+
+struct omap_crtc {
+	struct drm_crtc base;
+	struct drm_plane *plane;
+
+	const char *name;
+	int pipe;
+	enum omap_channel channel;
+	struct omap_overlay_manager_info info;
+
+	/*
+	 * Temporary: eventually this will go away, but it is needed
+	 * for now to keep the output's happy.  (They only need
+	 * mgr->id.)  Eventually this will be replaced w/ something
+	 * more common-panel-framework-y
+	 */
+	struct omap_overlay_manager mgr;
+
+	struct omap_video_timings timings;
+	bool enabled;
+	bool full_update;
+
+	struct omap_drm_apply apply;
+
+	struct omap_drm_irq apply_irq;
+	struct omap_drm_irq error_irq;
+
+	/* list of in-progress apply's: */
+	struct list_head pending_applies;
+
+	/* list of queued apply's: */
+	struct list_head queued_applies;
+
+	/* for handling queued and in-progress applies: */
+	struct work_struct apply_work;
+
+	/* if there is a pending flip, these will be non-null: */
+	struct drm_pending_vblank_event *event;
+	struct drm_framebuffer *old_fb;
+
+	/* for handling page flips without caring about what
+	 * the callback is called from.  Possibly we should just
+	 * make omap_gem always call the cb from the worker so
+	 * we don't have to care about this..
+	 *
+	 * XXX maybe fold into apply_work??
+	 */
+	struct work_struct page_flip_work;
+};
+
+/*
+ * Manager-ops, callbacks from output when they need to configure
+ * the upstream part of the video pipe.
+ *
+ * Most of these we can ignore until we add support for command-mode
+ * panels.. for video-mode the crtc-helpers already do an adequate
+ * job of sequencing the setup of the video pipe in the proper order
+ */
+
+/* we can probably ignore these until we support command-mode panels: */
+static void omap_crtc_start_update(struct omap_overlay_manager *mgr)
+{
+}
+
+static int omap_crtc_enable(struct omap_overlay_manager *mgr)
+{
+	return 0;
+}
+
+static void omap_crtc_disable(struct omap_overlay_manager *mgr)
+{
+}
+
+static void omap_crtc_set_timings(struct omap_overlay_manager *mgr,
+		const struct omap_video_timings *timings)
+{
+	struct omap_crtc *omap_crtc = container_of(mgr, struct omap_crtc, mgr);
+	DBG("%s", omap_crtc->name);
+	omap_crtc->timings = *timings;
+	omap_crtc->full_update = true;
+}
+
+static void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,
+		const struct dss_lcd_mgr_config *config)
+{
+	struct omap_crtc *omap_crtc = container_of(mgr, struct omap_crtc, mgr);
+	DBG("%s", omap_crtc->name);
+	dispc_mgr_set_lcd_config(omap_crtc->channel, config);
+}
+
+static int omap_crtc_register_framedone_handler(
+		struct omap_overlay_manager *mgr,
+		void (*handler)(void *), void *data)
+{
+	return 0;
+}
+
+static void omap_crtc_unregister_framedone_handler(
+		struct omap_overlay_manager *mgr,
+		void (*handler)(void *), void *data)
+{
+}
+
+static const struct dss_mgr_ops mgr_ops = {
+		.start_update = omap_crtc_start_update,
+		.enable = omap_crtc_enable,
+		.disable = omap_crtc_disable,
+		.set_timings = omap_crtc_set_timings,
+		.set_lcd_config = omap_crtc_set_lcd_config,
+		.register_framedone_handler = omap_crtc_register_framedone_handler,
+		.unregister_framedone_handler = omap_crtc_unregister_framedone_handler,
+};
+
+/*
+ * CRTC funcs:
+ */
+
+static void omap_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	DBG("%s", omap_crtc->name);
+
+	WARN_ON(omap_crtc->apply_irq.registered);
+	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+
+	omap_crtc->plane->funcs->destroy(omap_crtc->plane);
+	drm_crtc_cleanup(crtc);
+
+	kfree(omap_crtc);
+}
+
+static void omap_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	bool enabled = (mode == DRM_MODE_DPMS_ON);
+	int i;
+
+	DBG("%s: %d", omap_crtc->name, mode);
+
+	if (enabled != omap_crtc->enabled) {
+		omap_crtc->enabled = enabled;
+		omap_crtc->full_update = true;
+		omap_crtc_apply(crtc, &omap_crtc->apply);
+
+		/* also enable our private plane: */
+		WARN_ON(omap_plane_dpms(omap_crtc->plane, mode));
+
+		/* and any attached overlay planes: */
+		for (i = 0; i < priv->num_planes; i++) {
+			struct drm_plane *plane = priv->planes[i];
+			if (plane->crtc == crtc)
+				WARN_ON(omap_plane_dpms(plane, mode));
+		}
+	}
+}
+
+static bool omap_crtc_mode_fixup(struct drm_crtc *crtc,
+		const struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static int omap_crtc_mode_set(struct drm_crtc *crtc,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode,
+		int x, int y,
+		struct drm_framebuffer *old_fb)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+
+	mode = adjusted_mode;
+
+	DBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",
+			omap_crtc->name, mode->base.id, mode->name,
+			mode->vrefresh, mode->clock,
+			mode->hdisplay, mode->hsync_start,
+			mode->hsync_end, mode->htotal,
+			mode->vdisplay, mode->vsync_start,
+			mode->vsync_end, mode->vtotal,
+			mode->type, mode->flags);
+
+	copy_timings_drm_to_omap(&omap_crtc->timings, mode);
+	omap_crtc->full_update = true;
+
+	return omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,
+			0, 0, mode->hdisplay, mode->vdisplay,
+			x << 16, y << 16,
+			mode->hdisplay << 16, mode->vdisplay << 16,
+			NULL, NULL);
+}
+
+static void omap_crtc_prepare(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	DBG("%s", omap_crtc->name);
+	omap_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);
+}
+
+static void omap_crtc_commit(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	DBG("%s", omap_crtc->name);
+	omap_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
+}
+
+static int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+		struct drm_framebuffer *old_fb)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_plane *plane = omap_crtc->plane;
+	struct drm_display_mode *mode = &crtc->mode;
+
+	return omap_plane_mode_set(plane, crtc, crtc->fb,
+			0, 0, mode->hdisplay, mode->vdisplay,
+			x << 16, y << 16,
+			mode->hdisplay << 16, mode->vdisplay << 16,
+			NULL, NULL);
+}
+
+static void omap_crtc_load_lut(struct drm_crtc *crtc)
+{
+}
+
+static void vblank_cb(void *arg)
+{
+	struct drm_crtc *crtc = arg;
+	struct drm_device *dev = crtc->dev;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+
+	/* wakeup userspace */
+	if (omap_crtc->event)
+		drm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);
+
+	omap_crtc->event = NULL;
+	omap_crtc->old_fb = NULL;
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
+static void page_flip_worker(struct work_struct *work)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(work, struct omap_crtc, page_flip_work);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	struct drm_device *dev = crtc->dev;
+	struct drm_display_mode *mode = &crtc->mode;
+	struct drm_gem_object *bo;
+
+	drm_modeset_lock_all(dev);
+	omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,
+			0, 0, mode->hdisplay, mode->vdisplay,
+			crtc->x << 16, crtc->y << 16,
+			mode->hdisplay << 16, mode->vdisplay << 16,
+			vblank_cb, crtc);
+	drm_modeset_unlock_all(dev);
+
+	bo = omap_framebuffer_bo(crtc->fb, 0);
+	drm_gem_object_unreference_unlocked(bo);
+}
+
+static void page_flip_cb(void *arg)
+{
+	struct drm_crtc *crtc = arg;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+
+	/* avoid assumptions about what ctxt we are called from: */
+	queue_work(priv->wq, &omap_crtc->page_flip_work);
+}
+
+static int omap_crtc_page_flip_locked(struct drm_crtc *crtc,
+		 struct drm_framebuffer *fb,
+		 struct drm_pending_vblank_event *event)
+{
+	struct drm_device *dev = crtc->dev;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_gem_object *bo;
+
+	DBG("%d -> %d (event=%p)", crtc->fb ? crtc->fb->base.id : -1,
+			fb->base.id, event);
+
+	if (omap_crtc->old_fb) {
+		dev_err(dev->dev, "already a pending flip\n");
+		return -EINVAL;
+	}
+
+	omap_crtc->event = event;
+	crtc->fb = fb;
+
+	/*
+	 * Hold a reference temporarily until the crtc is updated
+	 * and takes the reference to the bo.  This avoids it
+	 * getting freed from under us:
+	 */
+	bo = omap_framebuffer_bo(fb, 0);
+	drm_gem_object_reference(bo);
+
+	omap_gem_op_async(bo, OMAP_GEM_READ, page_flip_cb, crtc);
+
+	return 0;
+}
+
+static int omap_crtc_set_property(struct drm_crtc *crtc,
+		struct drm_property *property, uint64_t val)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct omap_drm_private *priv = crtc->dev->dev_private;
+
+	if (property == priv->rotation_prop) {
+		crtc->invert_dimensions =
+				!!(val & ((1LL << DRM_ROTATE_90) | (1LL << DRM_ROTATE_270)));
+	}
+
+	return omap_plane_set_property(omap_crtc->plane, property, val);
+}
+
+static const struct drm_crtc_funcs omap_crtc_funcs = {
+	.set_config = drm_crtc_helper_set_config,
+	.destroy = omap_crtc_destroy,
+	.page_flip = omap_crtc_page_flip_locked,
+	.set_property = omap_crtc_set_property,
+};
+
+static const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {
+	.dpms = omap_crtc_dpms,
+	.mode_fixup = omap_crtc_mode_fixup,
+	.mode_set = omap_crtc_mode_set,
+	.prepare = omap_crtc_prepare,
+	.commit = omap_crtc_commit,
+	.mode_set_base = omap_crtc_mode_set_base,
+	.load_lut = omap_crtc_load_lut,
+};
+
+const struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	return &omap_crtc->timings;
+}
+
+enum omap_channel omap_crtc_channel(struct drm_crtc *crtc)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	return omap_crtc->channel;
+}
+
+static void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(irq, struct omap_crtc, error_irq);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	DRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);
+	/* avoid getting in a flood, unregister the irq until next vblank */
+	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+}
+
+static void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(irq, struct omap_crtc, apply_irq);
+	struct drm_crtc *crtc = &omap_crtc->base;
+
+	if (!omap_crtc->error_irq.registered)
+		omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+
+	if (!dispc_mgr_go_busy(omap_crtc->channel)) {
+		struct omap_drm_private *priv =
+				crtc->dev->dev_private;
+		DBG("%s: apply done", omap_crtc->name);
+		omap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);
+		queue_work(priv->wq, &omap_crtc->apply_work);
+	}
+}
+
+static void apply_worker(struct work_struct *work)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(work, struct omap_crtc, apply_work);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	struct drm_device *dev = crtc->dev;
+	struct omap_drm_apply *apply, *n;
+	bool need_apply;
+
+	/*
+	 * Synchronize everything on mode_config.mutex, to keep
+	 * the callbacks and list modification all serialized
+	 * with respect to modesetting ioctls from userspace.
+	 */
+	drm_modeset_lock_all(dev);
+	dispc_runtime_get();
+
+	/*
+	 * If we are still pending a previous update, wait.. when the
+	 * pending update completes, we get kicked again.
+	 */
+	if (omap_crtc->apply_irq.registered)
+		goto out;
+
+	/* finish up previous apply's: */
+	list_for_each_entry_safe(apply, n,
+			&omap_crtc->pending_applies, pending_node) {
+		apply->post_apply(apply);
+		list_del(&apply->pending_node);
+	}
+
+	need_apply = !list_empty(&omap_crtc->queued_applies);
+
+	/* then handle the next round of of queued apply's: */
+	list_for_each_entry_safe(apply, n,
+			&omap_crtc->queued_applies, queued_node) {
+		apply->pre_apply(apply);
+		list_del(&apply->queued_node);
+		apply->queued = false;
+		list_add_tail(&apply->pending_node,
+				&omap_crtc->pending_applies);
+	}
+
+	if (need_apply) {
+		enum omap_channel channel = omap_crtc->channel;
+
+		DBG("%s: GO", omap_crtc->name);
+
+		if (dispc_mgr_is_enabled(channel)) {
+			omap_irq_register(dev, &omap_crtc->apply_irq);
+			dispc_mgr_go(channel);
+		} else {
+			struct omap_drm_private *priv = dev->dev_private;
+			queue_work(priv->wq, &omap_crtc->apply_work);
+		}
+	}
+
+out:
+	dispc_runtime_put();
+	drm_modeset_unlock_all(dev);
+}
+
+int omap_crtc_apply(struct drm_crtc *crtc,
+		struct omap_drm_apply *apply)
+{
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+
+	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
+
+	/* no need to queue it again if it is already queued: */
+	if (apply->queued)
+		return 0;
+
+	apply->queued = true;
+	list_add_tail(&apply->queued_node, &omap_crtc->queued_applies);
+
+	/*
+	 * If there are no currently pending updates, then go ahead and
+	 * kick the worker immediately, otherwise it will run again when
+	 * the current update finishes.
+	 */
+	if (list_empty(&omap_crtc->pending_applies)) {
+		struct omap_drm_private *priv = crtc->dev->dev_private;
+		queue_work(priv->wq, &omap_crtc->apply_work);
+	}
+
+	return 0;
+}
+
+/* called only from apply */
+static void set_enabled(struct drm_crtc *crtc, bool enable)
+{
+	struct drm_device *dev = crtc->dev;
+	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
+	enum omap_channel channel = omap_crtc->channel;
+	struct omap_irq_wait *wait = NULL;
+
+	if (dispc_mgr_is_enabled(channel) == enable)
+		return;
+
+	/* ignore sync-lost irqs during enable/disable */
+	omap_irq_unregister(crtc->dev, &omap_crtc->error_irq);
+
+	if (dispc_mgr_get_framedone_irq(channel)) {
+		if (!enable) {
+			wait = omap_irq_wait_init(dev,
+					dispc_mgr_get_framedone_irq(channel), 1);
+		}
+	} else {
+		/*
+		 * When we disable digit output, we need to wait until fields
+		 * are done.  Otherwise the DSS is still working, and turning
+		 * off the clocks prevents DSS from going to OFF mode. And when
+		 * enabling, we need to wait for the extra sync losts
+		 */
+		wait = omap_irq_wait_init(dev,
+				dispc_mgr_get_vsync_irq(channel), 2);
+	}
+
+	dispc_mgr_enable(channel, enable);
+
+	if (wait) {
+		int ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));
+		if (ret) {
+			dev_err(dev->dev, "%s: timeout waiting for %s\n",
+					omap_crtc->name, enable ? "enable" : "disable");
+		}
+	}
+
+	omap_irq_register(crtc->dev, &omap_crtc->error_irq);
+}
+
+static void omap_crtc_pre_apply(struct omap_drm_apply *apply)
+{
+	struct omap_crtc *omap_crtc =
+			container_of(apply, struct omap_crtc, apply);
+	struct drm_crtc *crtc = &omap_crtc->base;
+	struct drm_encoder *encoder = NULL;
+
+	DBG("%s: enabled=%d, full=%d", omap_crtc->name,
+			omap_crtc->enabled, omap_crtc->full_update);
+
+	if (omap_crtc->full_update) {
+		struct omap_drm_private *priv = crtc->dev->dev_private;
+		int i;
+		for (i = 0; i < priv->num_encoders; i++) {
+			if (priv->encoders[i]->crtc == crtc) {
+				encoder = priv->encoders[i];
+				break;
+			}
+		}
+	}
+
+	if (!omap_crtc->enabled) {
+		set_enabled(&omap_crtc->base, false);
+		if (encoder)
+			omap_encoder_set_enabled(encoder, false);
+	} else {
+		if (encoder) {
+			omap_encoder_set_enabled(encoder, false);
+			omap_encoder_update(encoder, &omap_crtc->mgr,
+					&omap_crtc->timings);
+			omap_encoder_set_enabled(encoder, true);
+			omap_crtc->full_update = false;
+		}
+
+		dispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);
+		dispc_mgr_set_timings(omap_crtc->channel,
+				&omap_crtc->timings);
+		set_enabled(&omap_crtc->base, true);
+	}
+
+	omap_crtc->full_update = false;
+}
+
+static void omap_crtc_post_apply(struct omap_drm_apply *apply)
+{
+	/* nothing needed for post-apply */
+}
+
+static const char *channel_names[] = {
+		[OMAP_DSS_CHANNEL_LCD] = "lcd",
+		[OMAP_DSS_CHANNEL_DIGIT] = "tv",
+		[OMAP_DSS_CHANNEL_LCD2] = "lcd2",
+};
+
+/* initialize crtc */
+struct drm_crtc *omap_crtc_init(struct drm_device *dev,
+		struct drm_plane *plane, enum omap_channel channel, int id)
+{
+	struct drm_crtc *crtc = NULL;
+	struct omap_crtc *omap_crtc;
+	struct omap_overlay_manager_info *info;
+
+	DBG("%s", channel_names[channel]);
+
+	omap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);
+
+	if (!omap_crtc) {
+		dev_err(dev->dev, "could not allocate CRTC\n");
+		goto fail;
+	}
+
+	crtc = &omap_crtc->base;
+
+	INIT_WORK(&omap_crtc->page_flip_work, page_flip_worker);
+	INIT_WORK(&omap_crtc->apply_work, apply_worker);
+
+	INIT_LIST_HEAD(&omap_crtc->pending_applies);
+	INIT_LIST_HEAD(&omap_crtc->queued_applies);
+
+	omap_crtc->apply.pre_apply  = omap_crtc_pre_apply;
+	omap_crtc->apply.post_apply = omap_crtc_post_apply;
+
+	omap_crtc->apply_irq.irqmask = pipe2vbl(id);
+	omap_crtc->apply_irq.irq = omap_crtc_apply_irq;
+
+	omap_crtc->error_irq.irqmask =
+			dispc_mgr_get_sync_lost_irq(channel);
+	omap_crtc->error_irq.irq = omap_crtc_error_irq;
+	omap_irq_register(dev, &omap_crtc->error_irq);
+
+	omap_crtc->channel = channel;
+	omap_crtc->plane = plane;
+	omap_crtc->plane->crtc = crtc;
+	omap_crtc->name = channel_names[channel];
+	omap_crtc->pipe = id;
+
+	/* temporary: */
+	omap_crtc->mgr.id = channel;
+
+	dss_install_mgr_ops(&mgr_ops);
+
+	/* TODO: fix hard-coded setup.. add properties! */
+	info = &omap_crtc->info;
+	info->default_color = 0x00000000;
+	info->trans_key = 0x00000000;
+	info->trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
+	info->trans_enabled = false;
+
+	drm_crtc_init(dev, crtc, &omap_crtc_funcs);
+	drm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);
+
+	omap_plane_install_properties(omap_crtc->plane, &crtc->base);
+
+	return crtc;
+
+fail:
+	if (crtc)
+		omap_crtc_destroy(crtc);
+
+	return NULL;
+}
