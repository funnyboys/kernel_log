commit e086558ae923adc71c9718140ee0f6ba9508ec30
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:14 2020 +0200

    drm/omap: dss: Remove unused omap_dss_device operations
    
    The omap_dss_device .pre_enable(), .post_disable() and .set_timings()
    are not used anymore. Remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-55-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 455b410f7401..c7650a7c155d 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -234,18 +234,6 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 
-void omapdss_device_pre_enable(struct omap_dss_device *dssdev)
-{
-	if (!dssdev)
-		return;
-
-	omapdss_device_pre_enable(dssdev->next);
-
-	if (dssdev->ops && dssdev->ops->pre_enable)
-		dssdev->ops->pre_enable(dssdev);
-}
-EXPORT_SYMBOL_GPL(omapdss_device_pre_enable);
-
 void omapdss_device_enable(struct omap_dss_device *dssdev)
 {
 	if (!dssdev)
@@ -272,20 +260,6 @@ void omapdss_device_disable(struct omap_dss_device *dssdev)
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disable);
 
-void omapdss_device_post_disable(struct omap_dss_device *dssdev)
-{
-	if (!dssdev)
-		return;
-
-	if (dssdev->ops && dssdev->ops->post_disable)
-		dssdev->ops->post_disable(dssdev);
-
-	omapdss_device_post_disable(dssdev->next);
-
-	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
-}
-EXPORT_SYMBOL_GPL(omapdss_device_post_disable);
-
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit 5d79598ba8444fffaf04b93dfb696fdb6eb24c06
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:11 2020 +0200

    drm/omap: Hardcode omap_connector type to DSI
    
    The omap_connector implementation is now used for DSI only. Hardcode its
    type and drop unused code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-52-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 2db3bd2f19db..455b410f7401 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -286,29 +286,6 @@ void omapdss_device_post_disable(struct omap_dss_device *dssdev)
 }
 EXPORT_SYMBOL_GPL(omapdss_device_post_disable);
 
-unsigned int omapdss_device_connector_type(enum omap_display_type type)
-{
-	switch (type) {
-	case OMAP_DISPLAY_TYPE_HDMI:
-		return DRM_MODE_CONNECTOR_HDMIA;
-	case OMAP_DISPLAY_TYPE_DVI:
-		return DRM_MODE_CONNECTOR_DVID;
-	case OMAP_DISPLAY_TYPE_DSI:
-		return DRM_MODE_CONNECTOR_DSI;
-	case OMAP_DISPLAY_TYPE_DPI:
-	case OMAP_DISPLAY_TYPE_DBI:
-		return DRM_MODE_CONNECTOR_DPI;
-	case OMAP_DISPLAY_TYPE_VENC:
-		/* TODO: This could also be composite */
-		return DRM_MODE_CONNECTOR_SVIDEO;
-	case OMAP_DISPLAY_TYPE_SDI:
-		return DRM_MODE_CONNECTOR_LVDS;
-	default:
-		return DRM_MODE_CONNECTOR_Unknown;
-	}
-}
-EXPORT_SYMBOL_GPL(omapdss_device_connector_type);
-
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit db0fefd1b90d7d2a23090e9178ce742fe1b0aadd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:47 2020 +0200

    drm/omap: dss: Make omap_dss_device_ops optional
    
    As part of the move to drm_bridge ops, the dssdev ops will become empty
    for some of the internal encoders. Make them optional in the driver to
    allow them to be removed completely, easing the transition.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-28-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 80d48936d177..2db3bd2f19db 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -195,10 +195,12 @@ int omapdss_device_connect(struct dss_device *dss,
 
 	dst->dss = dss;
 
-	ret = dst->ops->connect(src, dst);
-	if (ret < 0) {
-		dst->dss = NULL;
-		return ret;
+	if (dst->ops && dst->ops->connect) {
+		ret = dst->ops->connect(src, dst);
+		if (ret < 0) {
+			dst->dss = NULL;
+			return ret;
+		}
 	}
 
 	return 0;
@@ -226,7 +228,8 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 
 	WARN_ON(dst->state != OMAP_DSS_DISPLAY_DISABLED);
 
-	dst->ops->disconnect(src, dst);
+	if (dst->ops && dst->ops->disconnect)
+		dst->ops->disconnect(src, dst);
 	dst->dss = NULL;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
@@ -238,7 +241,7 @@ void omapdss_device_pre_enable(struct omap_dss_device *dssdev)
 
 	omapdss_device_pre_enable(dssdev->next);
 
-	if (dssdev->ops->pre_enable)
+	if (dssdev->ops && dssdev->ops->pre_enable)
 		dssdev->ops->pre_enable(dssdev);
 }
 EXPORT_SYMBOL_GPL(omapdss_device_pre_enable);
@@ -248,7 +251,7 @@ void omapdss_device_enable(struct omap_dss_device *dssdev)
 	if (!dssdev)
 		return;
 
-	if (dssdev->ops->enable)
+	if (dssdev->ops && dssdev->ops->enable)
 		dssdev->ops->enable(dssdev);
 
 	omapdss_device_enable(dssdev->next);
@@ -264,7 +267,7 @@ void omapdss_device_disable(struct omap_dss_device *dssdev)
 
 	omapdss_device_disable(dssdev->next);
 
-	if (dssdev->ops->disable)
+	if (dssdev->ops && dssdev->ops->disable)
 		dssdev->ops->disable(dssdev);
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disable);
@@ -274,7 +277,7 @@ void omapdss_device_post_disable(struct omap_dss_device *dssdev)
 	if (!dssdev)
 		return;
 
-	if (dssdev->ops->post_disable)
+	if (dssdev->ops && dssdev->ops->post_disable)
 		dssdev->ops->post_disable(dssdev);
 
 	omapdss_device_post_disable(dssdev->next);

commit a779618b4a07d90fd332b6dbb4e836678d0a1d43
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:44 2020 +0200

    drm/omap: Use the drm_panel_bridge API
    
    Replace the manual panel handling code by a drm_panel_bridge. This
    simplifies the driver and allows all components in the display pipeline
    to be treated as bridges, paving the way to generic connector handling.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-25-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index cae5687822e2..80d48936d177 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -149,8 +149,7 @@ struct omap_dss_device *omapdss_device_next_output(struct omap_dss_device *from)
 			goto done;
 		}
 
-		if (dssdev->id &&
-		    (dssdev->next || dssdev->bridge || dssdev->panel))
+		if (dssdev->id && (dssdev->next || dssdev->bridge))
 			goto done;
 	}
 
@@ -185,11 +184,10 @@ int omapdss_device_connect(struct dss_device *dss,
 	if (!dst) {
 		/*
 		 * The destination is NULL when the source is connected to a
-		 * bridge or panel instead of a DSS device. Stop here, we will
-		 * attach the bridge or panel later when we will have a DRM
-		 * encoder.
+		 * bridge instead of a DSS device. Stop here, we will attach
+		 * the bridge later when we will have a DRM encoder.
 		 */
-		return src && (src->bridge || src->panel) ? 0 : -EINVAL;
+		return src && src->bridge ? 0 : -EINVAL;
 	}
 
 	if (omapdss_device_is_connected(dst))
@@ -217,7 +215,7 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		dst ? dev_name(dst->dev) : "NULL");
 
 	if (!dst) {
-		WARN_ON(!src->bridge && !src->panel);
+		WARN_ON(!src->bridge);
 		return;
 	}
 

commit 514fc91083f6c7e6faac17614361a39beeff615b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:43 2020 +0200

    drm/omap: Factor out display type to connector type conversion
    
    Move the code that computes the DRM connector type for the
    omapdss_device display type to a new omapdss_device_connector_type()
    function for later reuse.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-24-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index a1970b9db6ab..cae5687822e2 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -285,6 +285,29 @@ void omapdss_device_post_disable(struct omap_dss_device *dssdev)
 }
 EXPORT_SYMBOL_GPL(omapdss_device_post_disable);
 
+unsigned int omapdss_device_connector_type(enum omap_display_type type)
+{
+	switch (type) {
+	case OMAP_DISPLAY_TYPE_HDMI:
+		return DRM_MODE_CONNECTOR_HDMIA;
+	case OMAP_DISPLAY_TYPE_DVI:
+		return DRM_MODE_CONNECTOR_DVID;
+	case OMAP_DISPLAY_TYPE_DSI:
+		return DRM_MODE_CONNECTOR_DSI;
+	case OMAP_DISPLAY_TYPE_DPI:
+	case OMAP_DISPLAY_TYPE_DBI:
+		return DRM_MODE_CONNECTOR_DPI;
+	case OMAP_DISPLAY_TYPE_VENC:
+		/* TODO: This could also be composite */
+		return DRM_MODE_CONNECTOR_SVIDEO;
+	case OMAP_DISPLAY_TYPE_SDI:
+		return DRM_MODE_CONNECTOR_LVDS;
+	default:
+		return DRM_MODE_CONNECTOR_Unknown;
+	}
+}
+EXPORT_SYMBOL_GPL(omapdss_device_connector_type);
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index f8dad99013e8..a1970b9db6ab 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP Display Subsystem Base
  *
  * Copyright (C) 2015-2017 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit 4e17763c321f085e40e1fabef9677628d0fb84fe
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Sep 23 15:05:10 2018 +0300

    drm/omap: Whitelist DT nodes to fixup with omapdss, prefix
    
    The omapdss driver patches DT at runtime to prepend an "omapdss," prefix
    to the compatible string of all encoders, panels and connectors. This
    mechanism ensures they get bound to the omapdss-specific drivers instead
    of generic drivers.
    
    Now that we have drm_bridge support in omapdrm, we need to selectively
    disable this mechanism. Add a whitelist of compatible strings to patch,
    and fill it with all the devices we support. They will be removed one by
    one once corresponding drm_bridge drivers become available and get
    successfully tested with omapdrm.
    
    The omapdss components load check code is updated accordingly to ignore
    devices managed by external bridge drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 3c088cd2ceab..f8dad99013e8 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -303,6 +303,7 @@ struct omapdss_comp_node {
 	struct list_head list;
 	struct device_node *node;
 	bool dss_core_component;
+	const char *compat;
 };
 
 static bool omapdss_list_contains(const struct device_node *node)
@@ -320,13 +321,20 @@ static bool omapdss_list_contains(const struct device_node *node)
 static void omapdss_walk_device(struct device *dev, struct device_node *node,
 				bool dss_core)
 {
+	struct omapdss_comp_node *comp;
 	struct device_node *n;
-	struct omapdss_comp_node *comp = devm_kzalloc(dev, sizeof(*comp),
-						      GFP_KERNEL);
+	const char *compat;
+	int ret;
+
+	ret = of_property_read_string(node, "compatible", &compat);
+	if (ret < 0)
+		return;
 
+	comp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);
 	if (comp) {
 		comp->node = node;
 		comp->dss_core_component = dss_core;
+		comp->compat = compat;
 		list_add(&comp->list, &omapdss_comp_list);
 	}
 
@@ -366,12 +374,8 @@ void omapdss_gather_components(struct device *dev)
 
 	omapdss_walk_device(dev, dev->of_node, true);
 
-	for_each_available_child_of_node(dev->of_node, child) {
-		if (!of_find_property(child, "compatible", NULL))
-			continue;
-
+	for_each_available_child_of_node(dev->of_node, child)
 		omapdss_walk_device(dev, child, true);
-	}
 }
 EXPORT_SYMBOL(omapdss_gather_components);
 
@@ -379,6 +383,8 @@ static bool omapdss_component_is_loaded(struct omapdss_comp_node *comp)
 {
 	if (comp->dss_core_component)
 		return true;
+	if (!strstarts(comp->compat, "omapdss,"))
+		return true;
 	if (omapdss_device_is_registered(comp->node))
 		return true;
 

commit 30b71761957c541cd9dfd6cd10e3feb21a8ddca1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Dec 7 23:08:35 2018 +0200

    drm/omap: Add support for drm_panel
    
    Hook up drm_panel support in the omapdrm driver. The change is
    relatively simply as the way has been paved by drm_bridge support
    already. In addition to looking up, attaching to and detaching from the
    panel, we only need to add panel support in the connector .get_modes()
    handler, take connector bus flags (set by the panel) into account, and
    enable/disable the panel in the encoder enable/disable operations
    handlers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 09c9f2971aa2..3c088cd2ceab 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -157,7 +157,8 @@ struct omap_dss_device *omapdss_device_next_output(struct omap_dss_device *from)
 			goto done;
 		}
 
-		if (dssdev->id && (dssdev->next || dssdev->bridge))
+		if (dssdev->id &&
+		    (dssdev->next || dssdev->bridge || dssdev->panel))
 			goto done;
 	}
 
@@ -192,10 +193,11 @@ int omapdss_device_connect(struct dss_device *dss,
 	if (!dst) {
 		/*
 		 * The destination is NULL when the source is connected to a
-		 * bridge instead of a DSS device. Stop here, we will attach the
-		 * bridge later when we will have a DRM encoder.
+		 * bridge or panel instead of a DSS device. Stop here, we will
+		 * attach the bridge or panel later when we will have a DRM
+		 * encoder.
 		 */
-		return src && src->bridge ? 0 : -EINVAL;
+		return src && (src->bridge || src->panel) ? 0 : -EINVAL;
 	}
 
 	if (omapdss_device_is_connected(dst))
@@ -223,7 +225,7 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		dst ? dev_name(dst->dev) : "NULL");
 
 	if (!dst) {
-		WARN_ON(!src->bridge);
+		WARN_ON(!src->bridge && !src->panel);
 		return;
 	}
 

commit 79107f274b2fc6bce13f687de33c8d0b70994558
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Sep 23 12:58:15 2018 +0300

    drm/omap: Add support for drm_bridge
    
    Hook up drm_bridge support in the omapdrm driver. Despite the recent
    extensive preparation work, this is a rather intrusive change, as the
    management of outputs needs to be adapted through the driver to handle
    both omap_dss_device and drm_bridge.
    
    Connector creation is skipped when using a drm_bridge, as the bridge
    creates the connector internally. This creates issues with systems that
    split connector operations (such as modes retrieval and hot-plug
    detection) across different bridges. These systems can't be supported
    using drm_bridge for now (their support through the omap_dss_device
    infrastructure is not affected), this will be fixed in subsequent
    changes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 81ea0f55cd75..09c9f2971aa2 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -19,6 +19,7 @@
 #include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/of_graph.h>
+#include <linux/platform_device.h>
 
 #include "dss.h"
 #include "omapdss.h"
@@ -156,7 +157,7 @@ struct omap_dss_device *omapdss_device_next_output(struct omap_dss_device *from)
 			goto done;
 		}
 
-		if (dssdev->id && dssdev->next)
+		if (dssdev->id && (dssdev->next || dssdev->bridge))
 			goto done;
 	}
 
@@ -184,7 +185,18 @@ int omapdss_device_connect(struct dss_device *dss,
 {
 	int ret;
 
-	dev_dbg(dst->dev, "connect\n");
+	dev_dbg(&dss->pdev->dev, "connect(%s, %s)\n",
+		src ? dev_name(src->dev) : "NULL",
+		dst ? dev_name(dst->dev) : "NULL");
+
+	if (!dst) {
+		/*
+		 * The destination is NULL when the source is connected to a
+		 * bridge instead of a DSS device. Stop here, we will attach the
+		 * bridge later when we will have a DRM encoder.
+		 */
+		return src && src->bridge ? 0 : -EINVAL;
+	}
 
 	if (omapdss_device_is_connected(dst))
 		return -EBUSY;
@@ -204,7 +216,16 @@ EXPORT_SYMBOL_GPL(omapdss_device_connect);
 void omapdss_device_disconnect(struct omap_dss_device *src,
 			       struct omap_dss_device *dst)
 {
-	dev_dbg(dst->dev, "disconnect\n");
+	struct dss_device *dss = src ? src->dss : dst->dss;
+
+	dev_dbg(&dss->pdev->dev, "disconnect(%s, %s)\n",
+		src ? dev_name(src->dev) : "NULL",
+		dst ? dev_name(dst->dev) : "NULL");
+
+	if (!dst) {
+		WARN_ON(!src->bridge);
+		return;
+	}
 
 	if (!dst->id && !omapdss_device_is_connected(dst)) {
 		WARN_ON(!dst->display);

commit 0dbfc396672025d3ef8bacc934b80a5463e75c6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 10 14:00:38 2018 +0200

    drm/omap: Merge omap_dss_device type and output_type fields
    
    The omap_dss_device type and output_type fields differ mostly for
    historical reasons. The output_type field is required for all devices
    but the display at the end of the pipeline, and must be set to
    OMAP_DISPLAY_TYPE_NONE for the latter. The type field is required for
    all devices but the internal encoder, for which it is ignored.
    
    The only reason why the output_type field must be set to
    OMAP_DISPLAY_TYPE_NONE for the display at the end of the pipeline is to
    identify omap_dss_device instances corresponding to displays. This is
    not documented and confusing.
    
    Clean the code by adding a new display field to the omap_dss_device
    structure to identify displays, and merge the type and output_type
    fields.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index d14abde3c5f0..81ea0f55cd75 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -207,7 +207,7 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 	dev_dbg(dst->dev, "disconnect\n");
 
 	if (!dst->id && !omapdss_device_is_connected(dst)) {
-		WARN_ON(dst->output_type);
+		WARN_ON(!dst->display);
 		return;
 	}
 

commit ce69aac84fe322ab5e1f91224dc15d1957ded75c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 23:32:58 2018 +0300

    drm/omap: Simplify OF lookup of DSS devices
    
    Now that the direction of OF graph walk has been reversed, there's no
    need to lookup devices by port as we have no sink device connected
    through multiple sink ports. Simplify OF lookup of the DSS devices to
    look them up by node only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 62ccbeb99a84..d14abde3c5f0 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -112,13 +112,12 @@ void omapdss_device_put(struct omap_dss_device *dssdev)
 }
 EXPORT_SYMBOL(omapdss_device_put);
 
-struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
-						    unsigned int port)
+struct omap_dss_device *omapdss_find_device_by_node(struct device_node *node)
 {
 	struct omap_dss_device *dssdev;
 
 	list_for_each_entry(dssdev, &omapdss_devices_list, list) {
-		if (dssdev->dev->of_node == src && dssdev->of_ports & BIT(port))
+		if (dssdev->dev->of_node == node)
 			return omapdss_device_get(dssdev);
 	}
 

commit df6682b43533e4c59c3d14b56de838c035a8bb9a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 13 03:48:02 2018 +0300

    drm/omap: Remove src field from omap_dss_device structure
    
    The field is only used to check whether the device is connected, and we
    can do so by checking the dss field instead. Remove the src field.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 76470ba45660..62ccbeb99a84 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -176,7 +176,7 @@ EXPORT_SYMBOL(omapdss_device_next_output);
 
 static bool omapdss_device_is_connected(struct omap_dss_device *dssdev)
 {
-	return dssdev->src;
+	return dssdev->dss;
 }
 
 int omapdss_device_connect(struct dss_device *dss,
@@ -198,11 +198,6 @@ int omapdss_device_connect(struct dss_device *dss,
 		return ret;
 	}
 
-	if (src) {
-		WARN_ON(dst->src);
-		dst->src = src;
-	}
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_connect);
@@ -217,13 +212,6 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		return;
 	}
 
-	if (src) {
-		if (WARN_ON(dst->src != src))
-			return;
-
-		dst->src = NULL;
-	}
-
 	WARN_ON(dst->state != OMAP_DSS_DISPLAY_DISABLED);
 
 	dst->ops->disconnect(src, dst);

commit 56c9818d5c89b2655c6b4c65b99829faf5b4f544
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 12 19:05:18 2018 +0300

    drm/omap: Remove omap_dss_device dst field
    
    The field is only used in a safety check during device
    connection/disconnection, where the src field can be easily used
    instead. Remove it and use src.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 916225d62cc2..76470ba45660 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -199,9 +199,8 @@ int omapdss_device_connect(struct dss_device *dss,
 	}
 
 	if (src) {
-		WARN_ON(src->dst);
+		WARN_ON(dst->src);
 		dst->src = src;
-		src->dst = dst;
 	}
 
 	return 0;
@@ -219,11 +218,10 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 	}
 
 	if (src) {
-		if (WARN_ON(dst != src->dst))
+		if (WARN_ON(dst->src != src))
 			return;
 
 		dst->src = NULL;
-		src->dst = NULL;
 	}
 
 	WARN_ON(dst->state != OMAP_DSS_DISPLAY_DISABLED);

commit 19b4200d8f4b90b5a41592f9021b52153ac2b6b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 24 19:38:07 2018 +0300

    drm/omap: Reverse direction of the DSS device enable/disable operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    Reconcile the omapdrm and omapdss drivers with the DRM bridge and panel
    model by reversing the direction of the DSS device .enable() and
    .disable() operations. This completes the move to the DRM bridge model,
    with the notable exception of the DSI pipelines that will require more
    work.
    
    We also adapt the omapdss shutdown handler dss_shutdown() to shut down
    all active pipelines starting from the pipeline output device instead of
    the display device.
    
    As a consequence the for_each_dss_display() macro isn't used and can be
    removed, and the omapdss_device_get_next() function underlying the macro
    can be simplified to search for output devices only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 787157b00694..916225d62cc2 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -126,13 +126,10 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 }
 
 /*
- * Search for the next device starting at @from. The type argument specfies
- * which device types to consider when searching. Searching for multiple types
- * is supported by and'ing their type flags. Release the reference to the @from
- * device, and acquire a reference to the returned device if found.
+ * Search for the next output device starting at @from. Release the reference to
+ * the @from device, and acquire a reference to the returned device if found.
  */
-struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
-						enum omap_dss_device_type type)
+struct omap_dss_device *omapdss_device_next_output(struct omap_dss_device *from)
 {
 	struct omap_dss_device *dssdev;
 	struct list_head *list;
@@ -160,15 +157,7 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 			goto done;
 		}
 
-		/*
-		 * Accept display entities if the display type is requested,
-		 * and output entities if the output type is requested.
-		 */
-		if ((type & OMAP_DSS_DEVICE_TYPE_DISPLAY) &&
-		    !dssdev->output_type)
-			goto done;
-		if ((type & OMAP_DSS_DEVICE_TYPE_OUTPUT) && dssdev->id &&
-		    dssdev->next)
+		if (dssdev->id && dssdev->next)
 			goto done;
 	}
 
@@ -183,7 +172,7 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 	mutex_unlock(&omapdss_devices_lock);
 	return dssdev;
 }
-EXPORT_SYMBOL(omapdss_device_get_next);
+EXPORT_SYMBOL(omapdss_device_next_output);
 
 static bool omapdss_device_is_connected(struct omap_dss_device *dssdev)
 {
@@ -244,6 +233,58 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 
+void omapdss_device_pre_enable(struct omap_dss_device *dssdev)
+{
+	if (!dssdev)
+		return;
+
+	omapdss_device_pre_enable(dssdev->next);
+
+	if (dssdev->ops->pre_enable)
+		dssdev->ops->pre_enable(dssdev);
+}
+EXPORT_SYMBOL_GPL(omapdss_device_pre_enable);
+
+void omapdss_device_enable(struct omap_dss_device *dssdev)
+{
+	if (!dssdev)
+		return;
+
+	if (dssdev->ops->enable)
+		dssdev->ops->enable(dssdev);
+
+	omapdss_device_enable(dssdev->next);
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+}
+EXPORT_SYMBOL_GPL(omapdss_device_enable);
+
+void omapdss_device_disable(struct omap_dss_device *dssdev)
+{
+	if (!dssdev)
+		return;
+
+	omapdss_device_disable(dssdev->next);
+
+	if (dssdev->ops->disable)
+		dssdev->ops->disable(dssdev);
+}
+EXPORT_SYMBOL_GPL(omapdss_device_disable);
+
+void omapdss_device_post_disable(struct omap_dss_device *dssdev)
+{
+	if (!dssdev)
+		return;
+
+	if (dssdev->ops->post_disable)
+		dssdev->ops->post_disable(dssdev);
+
+	omapdss_device_post_disable(dssdev->next);
+
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+}
+EXPORT_SYMBOL_GPL(omapdss_device_post_disable);
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit b49a2139ba67da43915a483a2a7e8490ba6c2b57
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 4 23:53:34 2018 +0300

    drm/omap: Remove connection checks from display .enable() and .remove()
    
    The displays (connectors, panels and encoders) return an error from
    their .enable() handler when the dss device is not connected. They also
    disconnect the dss device explicitly from their .remove() handler if it
    is still connected.
    
    Those safety checks are not needed:
    
    - The .enable() handler is called from code paths that access the dss
      devices chain from the display device, which is set to NULL when the
      device isn't connected.
    
    - The .remove() handler can only be called when unloading the module as
      the driver has the suppress_bind_attrs attribute set, and a reference
      to the module is taken when constructing the dss devices chain, so the
      module can only be unloaded when the dss device is disconnected.
    
    Remove the safety checks.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 472f56e3de70..787157b00694 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -185,6 +185,11 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 }
 EXPORT_SYMBOL(omapdss_device_get_next);
 
+static bool omapdss_device_is_connected(struct omap_dss_device *dssdev)
+{
+	return dssdev->src;
+}
+
 int omapdss_device_connect(struct dss_device *dss,
 			   struct omap_dss_device *src,
 			   struct omap_dss_device *dst)

commit 83910ad3f51fbc0e6546b60aafa90697b5127a8a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 1 19:45:01 2018 +0300

    drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops
    
    omap_dss_device instances have two ops structures, omap_dss_driver and
    omap_dss_device_ops. The former is used for devices at the end of the
    pipeline (a.k.a. display devices), and the latter for intermediate
    devices.
    
    Having two sets of operations isn't convenient as code that iterates
    over omap_dss_device instances need to take them both into account.
    There's currently a reasonably small amount of such code, but more will
    be introduced to move the driver away from recursive operations. To
    simplify current and future code, move all operations that are not
    specific to the display device to the omap_dss_device_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 614331b7d702..472f56e3de70 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -198,11 +198,7 @@ int omapdss_device_connect(struct dss_device *dss,
 
 	dst->dss = dss;
 
-	if (dst->driver)
-		ret = dst->driver->connect(src, dst);
-	else
-		ret = dst->ops->connect(src, dst);
-
+	ret = dst->ops->connect(src, dst);
 	if (ret < 0) {
 		dst->dss = NULL;
 		return ret;
@@ -238,11 +234,7 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 
 	WARN_ON(dst->state != OMAP_DSS_DISPLAY_DISABLED);
 
-	if (dst->driver)
-		dst->driver->disconnect(src, dst);
-	else
-		dst->ops->disconnect(src, dst);
-
+	dst->ops->disconnect(src, dst);
 	dst->dss = NULL;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);

commit 1298977f0c8a06743dad0bf64d9a9e5a1e863fa3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 27 22:01:24 2018 +0300

    drm/omap: Check omap_dss_device type based on the output_type field
    
    Various functions that need to differentiate between omap_dss_device
    instances corresponding to displays and to internal encoders use the
    omap_dss_device.driver field, which is only set for display instances.
    This gets in the way of the omap_dss_device operations refactoring.
    Replace that with a check based on the output_type field which is set
    for all omap_dss_device instances but displays.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 2051bab30484..614331b7d702 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -164,7 +164,8 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 		 * Accept display entities if the display type is requested,
 		 * and output entities if the output type is requested.
 		 */
-		if ((type & OMAP_DSS_DEVICE_TYPE_DISPLAY) && dssdev->driver)
+		if ((type & OMAP_DSS_DEVICE_TYPE_DISPLAY) &&
+		    !dssdev->output_type)
 			goto done;
 		if ((type & OMAP_DSS_DEVICE_TYPE_OUTPUT) && dssdev->id &&
 		    dssdev->next)
@@ -223,7 +224,7 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 	dev_dbg(dst->dev, "disconnect\n");
 
 	if (!dst->id && !omapdss_device_is_connected(dst)) {
-		WARN_ON(!dst->driver);
+		WARN_ON(dst->output_type);
 		return;
 	}
 

commit 00b30e794ffc3bd8f4c6dc357fe7e881ae6e5373
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:37:25 2018 +0200

    drm/omap: Pass pipe pointer to omap_crtc_init()
    
    Replace the dss display device pointer by a pipe pointer that will allow
    the omap_crtc_init() function to access both the display and the DSS
    output. As a result we can remove the omapdss_device_get_dispc_channel()
    function that is now unneeded.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 89472715ee8f..2051bab30484 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -246,15 +246,6 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 
-enum omap_channel omapdss_device_get_dispc_channel(struct omap_dss_device *dssdev)
-{
-	while (dssdev->src)
-		dssdev = dssdev->src;
-
-	return dssdev->dispc_channel;
-}
-EXPORT_SYMBOL(omapdss_device_get_dispc_channel);
-
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit 3be0f15bd6e94aa17a571020704bde413342e8eb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 01:51:31 2018 +0200

    drm/omap: dss: Merge two disconnection helpers
    
    To simplify the pipeline disconnection handling merge the
    omapdss_device_disconnect() and omapdss_output_unset_device() functions.
    The device state check is now called for every device in the pipeline,
    extending this sanity check coverage.
    
    There is no need to return an error from omapdss_device_disconnect()
    when the check fails, as omapdss_output_unset_device() used to do, given
    that we can't prevent disconnection due to device unbinding (the return
    value of omapdss_output_unset_device() is never checked in the current
    code for that reason).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 02c6ed97d632..89472715ee8f 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -235,6 +235,8 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		src->dst = NULL;
 	}
 
+	WARN_ON(dst->state != OMAP_DSS_DISPLAY_DISABLED);
+
 	if (dst->driver)
 		dst->driver->disconnect(src, dst);
 	else

commit 79ddb2f0c348e991edca106a0e5ab414a822ccfc
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat May 26 20:25:10 2018 +0300

    drm/omap: dss: Move connection checks to omapdss_device_(dis)connect
    
    When a DSS output is (dis)connected the omapdss_output_(un)set_device()
    function performs a sanity check to ensure that the output isn't already
    (dis)connected. The check is unnecessary as those situations should
    never happen, but can nonetheless be useful to catch driver bugs. To
    prepare for removal of the omapdss_output_(un)set_device() functions
    move the connection check to the omapdss_device_connect() function. The
    omapdss_device_disconnect() already contains a corresponding check.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index c3e451440d4b..02c6ed97d632 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -208,6 +208,7 @@ int omapdss_device_connect(struct dss_device *dss,
 	}
 
 	if (src) {
+		WARN_ON(src->dst);
 		dst->src = src;
 		src->dst = dst;
 	}

commit 511afb44d72aa7b6b871fa71f829afaaa27e84f0
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 23:42:36 2018 +0200

    drm/omap: Reverse direction of DSS device (dis)connect operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    To reconcile the omapdrm and omapdss drivers with the DRM bridge and
    panel model, we need to reverse the direction of the DSS device
    operations. Start with the connect and disconnect operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 1dbd08e6e029..c3e451440d4b 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -190,24 +190,24 @@ int omapdss_device_connect(struct dss_device *dss,
 {
 	int ret;
 
-	dev_dbg(src->dev, "connect\n");
+	dev_dbg(dst->dev, "connect\n");
 
-	if (omapdss_device_is_connected(src))
+	if (omapdss_device_is_connected(dst))
 		return -EBUSY;
 
-	src->dss = dss;
+	dst->dss = dss;
 
-	if (src->driver)
-		ret = src->driver->connect(src);
+	if (dst->driver)
+		ret = dst->driver->connect(src, dst);
 	else
-		ret = src->ops->connect(src, dst);
+		ret = dst->ops->connect(src, dst);
 
 	if (ret < 0) {
-		src->dss = NULL;
+		dst->dss = NULL;
 		return ret;
 	}
 
-	if (dst) {
+	if (src) {
 		dst->src = src;
 		src->dst = dst;
 	}
@@ -219,14 +219,14 @@ EXPORT_SYMBOL_GPL(omapdss_device_connect);
 void omapdss_device_disconnect(struct omap_dss_device *src,
 			       struct omap_dss_device *dst)
 {
-	dev_dbg(src->dev, "disconnect\n");
+	dev_dbg(dst->dev, "disconnect\n");
 
-	if (!src->id && !omapdss_device_is_connected(src)) {
-		WARN_ON(!src->driver);
+	if (!dst->id && !omapdss_device_is_connected(dst)) {
+		WARN_ON(!dst->driver);
 		return;
 	}
 
-	if (dst) {
+	if (src) {
 		if (WARN_ON(dst != src->dst))
 			return;
 
@@ -234,12 +234,12 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		src->dst = NULL;
 	}
 
-	if (src->driver)
-		src->driver->disconnect(src);
+	if (dst->driver)
+		dst->driver->disconnect(src, dst);
 	else
-		src->ops->disconnect(src, dst);
+		dst->ops->disconnect(src, dst);
 
-	src->dss = NULL;
+	dst->dss = NULL;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 

commit f7e376aece4636afb0c4da5ce54d5e805ce47a76
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 22:28:25 2018 +0200

    drm/omap: dss: Add for_each_dss_output() macro
    
    Similarly to for_each_dss_display(), the for_each_dss_output() macro
    iterates over all the DSS connected outputs.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 67086cbb3e24..1dbd08e6e029 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -126,12 +126,13 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 }
 
 /*
- * Search for the next device starting at @from. If display_only is true, skip
- * non-display devices. Release the reference to the @from device, and acquire
- * a reference to the returned device if found.
+ * Search for the next device starting at @from. The type argument specfies
+ * which device types to consider when searching. Searching for multiple types
+ * is supported by and'ing their type flags. Release the reference to the @from
+ * device, and acquire a reference to the returned device if found.
  */
 struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
-						bool display_only)
+						enum omap_dss_device_type type)
 {
 	struct omap_dss_device *dssdev;
 	struct list_head *list;
@@ -159,8 +160,14 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 			goto done;
 		}
 
-		/* Filter out non-display entries if display_only is set. */
-		if (!display_only || dssdev->driver)
+		/*
+		 * Accept display entities if the display type is requested,
+		 * and output entities if the output type is requested.
+		 */
+		if ((type & OMAP_DSS_DEVICE_TYPE_DISPLAY) && dssdev->driver)
+			goto done;
+		if ((type & OMAP_DSS_DEVICE_TYPE_OUTPUT) && dssdev->id &&
+		    dssdev->next)
 			goto done;
 	}
 

commit 4e20bda68e01f723d7fcc4e7d55a4afc78223fb7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 21:49:28 2018 +0200

    drm/omap: dss: Replace omap_dss_device port number with bitmask
    
    The omap_dss_device port_num field stores the DT port number associated
    with the device. The field is used in different ways depending on the
    device type:
    
    - For DPI outputs, the port number is used as an identifier of the DPI
    instance
    
    - For sources, the port number is used to look up the omap_dss_device by
    DT port node
    
    As omap_dss_device instances are only looked up as sources by sinks,
    setting the field to the number of the source port works for both use
    cases.
    
    However, to enable looking up sinks, we need to record all the ports
    associated with an omap_dss_device. Do so by turning the port_num field
    into an of_ports bitmask. For DPI outputs the port number is
    additionally stored in the dpi_data structure as the output ID.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 272858972496..67086cbb3e24 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -118,7 +118,7 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 	struct omap_dss_device *dssdev;
 
 	list_for_each_entry(dssdev, &omapdss_devices_list, list) {
-		if (dssdev->dev->of_node == src && dssdev->port_num == port)
+		if (dssdev->dev->of_node == src && dssdev->of_ports & BIT(port))
 			return omapdss_device_get(dssdev);
 	}
 

commit 5c718e015a0f1280440f90ebf1c18e2b98a102e4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 03:11:49 2018 +0200

    drm/omap: dss: Modify omapdss_find_output_from_display() to return channel
    
    The omapdss_find_output_from_display() function is only used to retrieve
    the dispc channel corresponding to the display. Return the dispc channel
    directly, and rename the function to omapdss_device_get_dispc_channel()
    to match its new purpose.
    
    The dssdev->id check is removed as the dssdev is guaranteed to be an
    output and have a non-zero id, as proved by the lack of crash despite
    the caller never checking the returned pointer before dereferencing it.
    
    As the function is not specific to outputs anymore, move it from
    output.c to base.c.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 991c424960c7..272858972496 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -236,6 +236,15 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 
+enum omap_channel omapdss_device_get_dispc_channel(struct omap_dss_device *dssdev)
+{
+	while (dssdev->src)
+		dssdev = dssdev->src;
+
+	return dssdev->dispc_channel;
+}
+EXPORT_SYMBOL(omapdss_device_get_dispc_channel);
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit f324b2798c871511c64ea4232405e6f248e20d52
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 02:54:16 2018 +0200

    drm/omap: dss: Store dss_device pointer in omap_dss_device
    
    Storing the dss_device pointer in the omap_dss_device structure will
    allow accessing the dss_device from the dss_mgr API functions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 08846eea5a53..991c424960c7 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -177,7 +177,8 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 }
 EXPORT_SYMBOL(omapdss_device_get_next);
 
-int omapdss_device_connect(struct omap_dss_device *src,
+int omapdss_device_connect(struct dss_device *dss,
+			   struct omap_dss_device *src,
 			   struct omap_dss_device *dst)
 {
 	int ret;
@@ -187,13 +188,17 @@ int omapdss_device_connect(struct omap_dss_device *src,
 	if (omapdss_device_is_connected(src))
 		return -EBUSY;
 
+	src->dss = dss;
+
 	if (src->driver)
 		ret = src->driver->connect(src);
 	else
 		ret = src->ops->connect(src, dst);
 
-	if (ret < 0)
+	if (ret < 0) {
+		src->dss = NULL;
 		return ret;
+	}
 
 	if (dst) {
 		dst->src = src;
@@ -226,6 +231,8 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		src->driver->disconnect(src);
 	else
 		src->ops->disconnect(src, dst);
+
+	src->dss = NULL;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
 

commit c1dfe721e0966947019c43b65f2837c591fdcb3c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 02:43:45 2018 +0200

    drm/omap: dss: Move and rename omap_dss_(get|put)_device()
    
    The functions operate on any omap_dss_device, move them from display.c
    to base.c. While at it rename them to match the naming of the other
    functions operating on struct omap_dss_device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 9f01a4f28145..08846eea5a53 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -91,6 +91,27 @@ static bool omapdss_device_is_registered(struct device_node *node)
 	return found;
 }
 
+struct omap_dss_device *omapdss_device_get(struct omap_dss_device *dssdev)
+{
+	if (!try_module_get(dssdev->owner))
+		return NULL;
+
+	if (get_device(dssdev->dev) == NULL) {
+		module_put(dssdev->owner);
+		return NULL;
+	}
+
+	return dssdev;
+}
+EXPORT_SYMBOL(omapdss_device_get);
+
+void omapdss_device_put(struct omap_dss_device *dssdev)
+{
+	put_device(dssdev->dev);
+	module_put(dssdev->owner);
+}
+EXPORT_SYMBOL(omapdss_device_put);
+
 struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 						    unsigned int port)
 {
@@ -98,7 +119,7 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 
 	list_for_each_entry(dssdev, &omapdss_devices_list, list) {
 		if (dssdev->dev->of_node == src && dssdev->port_num == port)
-			return omap_dss_get_device(dssdev);
+			return omapdss_device_get(dssdev);
 	}
 
 	return NULL;
@@ -147,9 +168,9 @@ struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
 
 done:
 	if (from)
-		omap_dss_put_device(from);
+		omapdss_device_put(from);
 	if (dssdev)
-		omap_dss_get_device(dssdev);
+		omapdss_device_get(dssdev);
 
 	mutex_unlock(&omapdss_devices_lock);
 	return dssdev;

commit b9f4d2ebf641d157be89a68227a5feb00c961d10
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 02:07:34 2018 +0200

    drm/omap: dss: Make omap_dss_get_next_device() more generic
    
    Despite its name, the omap_dss_get_next_device() function operates on
    display devices only. Make it more generic by allowing operation on all
    devices, with a parameter to specify the device type.
    
    While at it rename the function to omapdss_device_get_next() to match
    the naming of the other functions operating on struct omap_dss_device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 8fac816ca481..9f01a4f28145 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -104,6 +104,58 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 	return NULL;
 }
 
+/*
+ * Search for the next device starting at @from. If display_only is true, skip
+ * non-display devices. Release the reference to the @from device, and acquire
+ * a reference to the returned device if found.
+ */
+struct omap_dss_device *omapdss_device_get_next(struct omap_dss_device *from,
+						bool display_only)
+{
+	struct omap_dss_device *dssdev;
+	struct list_head *list;
+
+	mutex_lock(&omapdss_devices_lock);
+
+	if (list_empty(&omapdss_devices_list)) {
+		dssdev = NULL;
+		goto done;
+	}
+
+	/*
+	 * Start from the from entry if given or from omapdss_devices_list
+	 * otherwise.
+	 */
+	list = from ? &from->list : &omapdss_devices_list;
+
+	list_for_each_entry(dssdev, list, list) {
+		/*
+		 * Stop if we reach the omapdss_devices_list, that's the end of
+		 * the list.
+		 */
+		if (&dssdev->list == &omapdss_devices_list) {
+			dssdev = NULL;
+			goto done;
+		}
+
+		/* Filter out non-display entries if display_only is set. */
+		if (!display_only || dssdev->driver)
+			goto done;
+	}
+
+	dssdev = NULL;
+
+done:
+	if (from)
+		omap_dss_put_device(from);
+	if (dssdev)
+		omap_dss_get_device(dssdev);
+
+	mutex_unlock(&omapdss_devices_lock);
+	return dssdev;
+}
+EXPORT_SYMBOL(omapdss_device_get_next);
+
 int omapdss_device_connect(struct omap_dss_device *src,
 			   struct omap_dss_device *dst)
 {

commit de57e9dbc1454704a54190cb3b544b841c34301a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 01:25:32 2018 +0200

    drm/omap: dss: Remove output devices list
    
    The output devices list isn't used anymore, all output devices are
    accessed through the global devices list. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 22d3818208d7..8fac816ca481 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -63,6 +63,7 @@ void omapdss_device_register(struct omap_dss_device *dssdev)
 	list_add_tail(&dssdev->list, &omapdss_devices_list);
 	mutex_unlock(&omapdss_devices_lock);
 }
+EXPORT_SYMBOL_GPL(omapdss_device_register);
 
 void omapdss_device_unregister(struct omap_dss_device *dssdev)
 {
@@ -70,6 +71,7 @@ void omapdss_device_unregister(struct omap_dss_device *dssdev)
 	list_del(&dssdev->list);
 	mutex_unlock(&omapdss_devices_lock);
 }
+EXPORT_SYMBOL_GPL(omapdss_device_unregister);
 
 static bool omapdss_device_is_registered(struct device_node *node)
 {

commit fb5571717c24c264518aaaf1ab4ec4df73e4cebd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 17:30:30 2018 +0200

    drm/omap: dss: Move src and dst check and set to connection handlers
    
    The encoders duplicate the same omap_dss_device src and dst fields set
    and checks in their connect and disconnect handlers. Move the code to
    the connect and disconnect wrappers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 599ef628736b..22d3818208d7 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -105,15 +105,27 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 int omapdss_device_connect(struct omap_dss_device *src,
 			   struct omap_dss_device *dst)
 {
+	int ret;
+
 	dev_dbg(src->dev, "connect\n");
 
 	if (omapdss_device_is_connected(src))
 		return -EBUSY;
 
 	if (src->driver)
-		return src->driver->connect(src);
+		ret = src->driver->connect(src);
 	else
-		return src->ops->connect(src, dst);
+		ret = src->ops->connect(src, dst);
+
+	if (ret < 0)
+		return ret;
+
+	if (dst) {
+		dst->src = src;
+		src->dst = dst;
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(omapdss_device_connect);
 
@@ -127,6 +139,14 @@ void omapdss_device_disconnect(struct omap_dss_device *src,
 		return;
 	}
 
+	if (dst) {
+		if (WARN_ON(dst != src->dst))
+			return;
+
+		dst->src = NULL;
+		src->dst = NULL;
+	}
+
 	if (src->driver)
 		src->driver->disconnect(src);
 	else

commit 1f507968c30b0e86a307164a212ef11def1e5899
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 17:30:30 2018 +0200

    drm/omap: dss: Move debug message and checks to connection handlers
    
    The connectors, encoders and display duplicate the same debug messages
    and connection checks in their omap_dss_device connect and disconnect
    handlers. Move the code to the connect and disconnect wrappers.
    
    To simplify the code the connect function returns -EBUSY unconditionally
    if the device is already connected. This doesn't cause any change in
    practice: the connect handler of displays is never called on a connected
    device as it is only invoked during omapdrm initialization.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 576fd3d13259..599ef628736b 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -105,6 +105,11 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 int omapdss_device_connect(struct omap_dss_device *src,
 			   struct omap_dss_device *dst)
 {
+	dev_dbg(src->dev, "connect\n");
+
+	if (omapdss_device_is_connected(src))
+		return -EBUSY;
+
 	if (src->driver)
 		return src->driver->connect(src);
 	else
@@ -115,6 +120,13 @@ EXPORT_SYMBOL_GPL(omapdss_device_connect);
 void omapdss_device_disconnect(struct omap_dss_device *src,
 			       struct omap_dss_device *dst)
 {
+	dev_dbg(src->dev, "disconnect\n");
+
+	if (!src->id && !omapdss_device_is_connected(src)) {
+		WARN_ON(!src->driver);
+		return;
+	}
+
 	if (src->driver)
 		src->driver->disconnect(src);
 	else

commit ec727e3f61845d6d64b3c5eba464096d6cc7f8e9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 17:30:30 2018 +0200

    drm/omap: dss: Add functions to connect and disconnect devices
    
    The omap_dss_device objects model display components and are connected
    at runtime to create display pipelines. The connect and disconnect
    operations implemented by each component contain lots of duplicate code.
    As a first step towards fixing this, create new functions to wrap the
    direct calls to those operations and use them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index df6cb1ac43c8..576fd3d13259 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -102,6 +102,26 @@ struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
 	return NULL;
 }
 
+int omapdss_device_connect(struct omap_dss_device *src,
+			   struct omap_dss_device *dst)
+{
+	if (src->driver)
+		return src->driver->connect(src);
+	else
+		return src->ops->connect(src, dst);
+}
+EXPORT_SYMBOL_GPL(omapdss_device_connect);
+
+void omapdss_device_disconnect(struct omap_dss_device *src,
+			       struct omap_dss_device *dst)
+{
+	if (src->driver)
+		src->driver->disconnect(src);
+	else
+		src->ops->disconnect(src, dst);
+}
+EXPORT_SYMBOL_GPL(omapdss_device_disconnect);
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit e10bd354ad79d2772842300c85ffd1a49722cfae
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 1 23:35:55 2018 +0200

    drm/omap: dss: Allow looking up any device by port
    
    The omap_dss_find_output_by_port() function looks up an omap_dss_device
    by port from the list of devices registered as outputs. In preparation
    for looking up sinks in addition to sources, allow the function to look
    up any registered device. Rename it to omap_dss_find_device_by_port() to
    match its new purpose.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 63fe0a717884..df6cb1ac43c8 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -89,6 +89,19 @@ static bool omapdss_device_is_registered(struct device_node *node)
 	return found;
 }
 
+struct omap_dss_device *omapdss_find_device_by_port(struct device_node *src,
+						    unsigned int port)
+{
+	struct omap_dss_device *dssdev;
+
+	list_for_each_entry(dssdev, &omapdss_devices_list, list) {
+		if (dssdev->dev->of_node == src && dssdev->port_num == port)
+			return omap_dss_get_device(dssdev);
+	}
+
+	return NULL;
+}
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */

commit 9184f8d94c389c4712b4f393cca4a09c9e770514
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 23:53:16 2018 +0200

    drm/omap: dss: Create and use omapdss_device_is_registered()
    
    The omapdss_component_is_loaded() function test whether a component is
    loaded by checking whether it is present in the displays list or the
    outputs list. Simplify the implementation by checking for the component
    in the global omap_dss_device list.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 18b72d7c717a..63fe0a717884 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -71,6 +71,24 @@ void omapdss_device_unregister(struct omap_dss_device *dssdev)
 	mutex_unlock(&omapdss_devices_lock);
 }
 
+static bool omapdss_device_is_registered(struct device_node *node)
+{
+	struct omap_dss_device *dssdev;
+	bool found = false;
+
+	mutex_lock(&omapdss_devices_lock);
+
+	list_for_each_entry(dssdev, &omapdss_devices_list, list) {
+		if (dssdev->dev->of_node == node) {
+			found = true;
+			break;
+		}
+	}
+
+	mutex_unlock(&omapdss_devices_lock);
+	return found;
+}
+
 /* -----------------------------------------------------------------------------
  * Components Handling
  */
@@ -157,9 +175,7 @@ static bool omapdss_component_is_loaded(struct omapdss_comp_node *comp)
 {
 	if (comp->dss_core_component)
 		return true;
-	if (omapdss_component_is_display(comp->node))
-		return true;
-	if (omapdss_component_is_output(comp->node))
+	if (omapdss_device_is_registered(comp->node))
 		return true;
 
 	return false;

commit 6a7c5a2200ad10a23912d3f40ef104f0d0543de4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 23:49:24 2018 +0200

    drm/omap: dss: Create global list of all omap_dss_device instances
    
    The omap_dss_device instances are stored in two separate lists,
    depending on whether they are panels or outputs. Create a third list
    that stores all omap_dss_device instances to allow generic code to
    operate on all instances.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 99e8cb8dc65b..18b72d7c717a 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -14,24 +14,17 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/list.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/of_graph.h>
-#include <linux/list.h>
 
 #include "dss.h"
 #include "omapdss.h"
 
 static struct dss_device *dss_device;
 
-static struct list_head omapdss_comp_list;
-
-struct omapdss_comp_node {
-	struct list_head list;
-	struct device_node *node;
-	bool dss_core_component;
-};
-
 struct dss_device *omapdss_get_dss(void)
 {
 	return dss_device;
@@ -56,6 +49,40 @@ const struct dispc_ops *dispc_get_ops(struct dss_device *dss)
 }
 EXPORT_SYMBOL(dispc_get_ops);
 
+
+/* -----------------------------------------------------------------------------
+ * OMAP DSS Devices Handling
+ */
+
+static LIST_HEAD(omapdss_devices_list);
+static DEFINE_MUTEX(omapdss_devices_lock);
+
+void omapdss_device_register(struct omap_dss_device *dssdev)
+{
+	mutex_lock(&omapdss_devices_lock);
+	list_add_tail(&dssdev->list, &omapdss_devices_list);
+	mutex_unlock(&omapdss_devices_lock);
+}
+
+void omapdss_device_unregister(struct omap_dss_device *dssdev)
+{
+	mutex_lock(&omapdss_devices_lock);
+	list_del(&dssdev->list);
+	mutex_unlock(&omapdss_devices_lock);
+}
+
+/* -----------------------------------------------------------------------------
+ * Components Handling
+ */
+
+static struct list_head omapdss_comp_list;
+
+struct omapdss_comp_node {
+	struct list_head list;
+	struct device_node *node;
+	bool dss_core_component;
+};
+
 static bool omapdss_list_contains(const struct device_node *node)
 {
 	struct omapdss_comp_node *comp;

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index c248c3c31904..99e8cb8dc65b 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -44,6 +44,12 @@ void omapdss_set_dss(struct dss_device *dss)
 }
 EXPORT_SYMBOL(omapdss_set_dss);
 
+struct dispc_device *dispc_get_dispc(struct dss_device *dss)
+{
+	return dss->dispc;
+}
+EXPORT_SYMBOL(dispc_get_dispc);
+
 const struct dispc_ops *dispc_get_ops(struct dss_device *dss)
 {
 	return dss->dispc_ops;

commit d3541ca81dbddeefa0c42df448211a9dbaef0843
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:41 2018 +0200

    drm: omapdrm: dss: Store dispc ops in dss_device structure
    
    Remove the global dispc ops variable by storing it in the dss_device
    structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 6346bc967a77..c248c3c31904 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -18,10 +18,11 @@
 #include <linux/of.h>
 #include <linux/of_graph.h>
 #include <linux/list.h>
+
+#include "dss.h"
 #include "omapdss.h"
 
 static struct dss_device *dss_device;
-static const struct dispc_ops *ops;
 
 static struct list_head omapdss_comp_list;
 
@@ -43,15 +44,9 @@ void omapdss_set_dss(struct dss_device *dss)
 }
 EXPORT_SYMBOL(omapdss_set_dss);
 
-void dispc_set_ops(const struct dispc_ops *o)
-{
-	ops = o;
-}
-EXPORT_SYMBOL(dispc_set_ops);
-
-const struct dispc_ops *dispc_get_ops(void)
+const struct dispc_ops *dispc_get_ops(struct dss_device *dss)
 {
-	return ops;
+	return dss->dispc_ops;
 }
 EXPORT_SYMBOL(dispc_get_ops);
 

commit 72877cf38b4b78fbb3a852f2288d7f2a7af0db22
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:40 2018 +0200

    drm: omapdrm: dss: Store DSS device pointer in the omapdrm private data
    
    The dss_device is the top-level component in the omapdss driver. Give
    the omapdrm driver access to the dss_device pointer in order to obtain
    pointers to all other components from it. This requires a new global
    variable in the omapdss driver that will be removed when merging the
    omapdrm and omapdss drivers, but will already allow removal of several
    other global variables.
    
    As this partly duplicates the omapdss_is_initialized() API, reimplement
    it as an inline function wrapping omapdss_get_dss().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 67cc87a4f1f6..6346bc967a77 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -20,7 +20,7 @@
 #include <linux/list.h>
 #include "omapdss.h"
 
-static bool dss_initialized;
+static struct dss_device *dss_device;
 static const struct dispc_ops *ops;
 
 static struct list_head omapdss_comp_list;
@@ -31,17 +31,17 @@ struct omapdss_comp_node {
 	bool dss_core_component;
 };
 
-void omapdss_set_is_initialized(bool set)
+struct dss_device *omapdss_get_dss(void)
 {
-	dss_initialized = set;
+	return dss_device;
 }
-EXPORT_SYMBOL(omapdss_set_is_initialized);
+EXPORT_SYMBOL(omapdss_get_dss);
 
-bool omapdss_is_initialized(void)
+void omapdss_set_dss(struct dss_device *dss)
 {
-	return dss_initialized;
+	dss_device = dss;
 }
-EXPORT_SYMBOL(omapdss_is_initialized);
+EXPORT_SYMBOL(omapdss_set_dss);
 
 void dispc_set_ops(const struct dispc_ops *o)
 {

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 13e91faaf7a6..67cc87a4f1f6 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -1,3 +1,18 @@
+/*
+ * OMAP Display Subsystem Base
+ *
+ * Copyright (C) 2015-2017 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of.h>

commit 1e08c822689c39bd86d2154490f89265329e9c58
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue May 3 22:07:10 2016 +0300

    drm/omap: dss: Support for detecting display stack readiness
    
    When omapdss is loaded (all core components are in place) create a list of
    devices used in the display graph. This list later can be used by omapdrm
    via the omapdss_stack_is_ready() function to check that these components
    are loaded. Based on this information, omapdrm can defer probe in case when
    the omapdss stack is not ready yet.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 7dd447e6c4d7..13e91faaf7a6 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -1,9 +1,21 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/list.h>
+#include "omapdss.h"
 
 static bool dss_initialized;
 static const struct dispc_ops *ops;
 
+static struct list_head omapdss_comp_list;
+
+struct omapdss_comp_node {
+	struct list_head list;
+	struct device_node *node;
+	bool dss_core_component;
+};
+
 void omapdss_set_is_initialized(bool set)
 {
 	dss_initialized = set;
@@ -28,6 +40,101 @@ const struct dispc_ops *dispc_get_ops(void)
 }
 EXPORT_SYMBOL(dispc_get_ops);
 
+static bool omapdss_list_contains(const struct device_node *node)
+{
+	struct omapdss_comp_node *comp;
+
+	list_for_each_entry(comp, &omapdss_comp_list, list) {
+		if (comp->node == node)
+			return true;
+	}
+
+	return false;
+}
+
+static void omapdss_walk_device(struct device *dev, struct device_node *node,
+				bool dss_core)
+{
+	struct device_node *n;
+	struct omapdss_comp_node *comp = devm_kzalloc(dev, sizeof(*comp),
+						      GFP_KERNEL);
+
+	if (comp) {
+		comp->node = node;
+		comp->dss_core_component = dss_core;
+		list_add(&comp->list, &omapdss_comp_list);
+	}
+
+	/*
+	 * of_graph_get_remote_port_parent() prints an error if there is no
+	 * port/ports node. To avoid that, check first that there's the node.
+	 */
+	n = of_get_child_by_name(node, "ports");
+	if (!n)
+		n = of_get_child_by_name(node, "port");
+	if (!n)
+		return;
+
+	of_node_put(n);
+
+	n = NULL;
+	while ((n = of_graph_get_next_endpoint(node, n)) != NULL) {
+		struct device_node *pn = of_graph_get_remote_port_parent(n);
+
+		if (!pn)
+			continue;
+
+		if (!of_device_is_available(pn) || omapdss_list_contains(pn)) {
+			of_node_put(pn);
+			continue;
+		}
+
+		omapdss_walk_device(dev, pn, false);
+	}
+}
+
+void omapdss_gather_components(struct device *dev)
+{
+	struct device_node *child;
+
+	INIT_LIST_HEAD(&omapdss_comp_list);
+
+	omapdss_walk_device(dev, dev->of_node, true);
+
+	for_each_available_child_of_node(dev->of_node, child) {
+		if (!of_find_property(child, "compatible", NULL))
+			continue;
+
+		omapdss_walk_device(dev, child, true);
+	}
+}
+EXPORT_SYMBOL(omapdss_gather_components);
+
+static bool omapdss_component_is_loaded(struct omapdss_comp_node *comp)
+{
+	if (comp->dss_core_component)
+		return true;
+	if (omapdss_component_is_display(comp->node))
+		return true;
+	if (omapdss_component_is_output(comp->node))
+		return true;
+
+	return false;
+}
+
+bool omapdss_stack_is_ready(void)
+{
+	struct omapdss_comp_node *comp;
+
+	list_for_each_entry(comp, &omapdss_comp_list, list) {
+		if (!omapdss_component_is_loaded(comp))
+			return false;
+	}
+
+	return true;
+}
+EXPORT_SYMBOL(omapdss_stack_is_ready);
+
 MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
 MODULE_DESCRIPTION("OMAP Display Subsystem Base");
 MODULE_LICENSE("GPL v2");

commit 8a13398c3f01bc14369b879e9158391c0d447dcc
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 19:36:02 2015 +0200

    drm/omap: add dispc_ops
    
    We want to change the dispc API from plain functions to a struct with
    functions pointers, so that omapdrm can call either omapdss or omapdss6
    depending on the platform.
    
    This patch adds 'struct dispc_ops' and adds functions to omapdss-base
    to set and get the ops.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 03942097b9f1..7dd447e6c4d7 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -2,6 +2,7 @@
 #include <linux/module.h>
 
 static bool dss_initialized;
+static const struct dispc_ops *ops;
 
 void omapdss_set_is_initialized(bool set)
 {
@@ -15,6 +16,18 @@ bool omapdss_is_initialized(void)
 }
 EXPORT_SYMBOL(omapdss_is_initialized);
 
+void dispc_set_ops(const struct dispc_ops *o)
+{
+	ops = o;
+}
+EXPORT_SYMBOL(dispc_set_ops);
+
+const struct dispc_ops *dispc_get_ops(void)
+{
+	return ops;
+}
+EXPORT_SYMBOL(dispc_get_ops);
+
 MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
 MODULE_DESCRIPTION("OMAP Display Subsystem Base");
 MODULE_LICENSE("GPL v2");

commit 7c299716297c9a90b31d1f627f003a0de9c48318
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 17:23:14 2015 +0200

    drm/omap: move dss_initialized to omapdss-base
    
    omapdss_is_initialized() is used to find out if omapdss has been probed
    successfully. This patch moves the related code to the common
    omapdss-base module, so that the same support will be there for both
    omapdss and omapdss6.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
index 943030a7523c..03942097b9f1 100644
--- a/drivers/gpu/drm/omapdrm/dss/base.c
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -1,6 +1,20 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 
+static bool dss_initialized;
+
+void omapdss_set_is_initialized(bool set)
+{
+	dss_initialized = set;
+}
+EXPORT_SYMBOL(omapdss_set_is_initialized);
+
+bool omapdss_is_initialized(void)
+{
+	return dss_initialized;
+}
+EXPORT_SYMBOL(omapdss_is_initialized);
+
 MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
 MODULE_DESCRIPTION("OMAP Display Subsystem Base");
 MODULE_LICENSE("GPL v2");

commit a99ac0d9f6fd5f50ebf5cdab84ab9f855c46cdb2
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 17:19:32 2015 +0200

    drm/omap: add omapdss-base.ko
    
    We are working towards enabling omapdss6, which will consists of a new
    dss, dispc and dpi drivers. omapdss6 will be a new module. The panel,
    encoder and omapdrm will need to use either the current omapdss driver
    or the new omapdss6 driver, depending on the platform.
    
    This will be implemented with a common base module and function
    pointers.
    
    This patch adds a skeleton omapdss-base.ko module, to which we'll be
    moving common dss functionality like registration of the panels.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/base.c b/drivers/gpu/drm/omapdrm/dss/base.c
new file mode 100644
index 000000000000..943030a7523c
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/dss/base.c
@@ -0,0 +1,6 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
+MODULE_DESCRIPTION("OMAP Display Subsystem Base");
+MODULE_LICENSE("GPL v2");
