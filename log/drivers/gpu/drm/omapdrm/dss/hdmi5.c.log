commit b6067da4ebf9db5e4b026220b13dce3528032b88
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:04 2020 +0200

    drm/omap: hdmi5: Simplify EDID read
    
    Now that the omap_dss_device EDID read operation has been removed,
    simplify the bridge-based EDID access by merging multiple functions
    together.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-45-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 6cb709c775d6..4d4c1fabd0a1 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -307,50 +307,6 @@ static void hdmi_core_disable(struct omap_hdmi *hdmi)
 	mutex_unlock(&hdmi->lock);
 }
 
-static struct edid *
-hdmi_do_read_edid(struct omap_hdmi *hdmi,
-		  struct edid *(*read)(struct omap_hdmi *hdmi,
-				       struct drm_connector *connector),
-		  struct drm_connector *connector)
-{
-	struct edid *edid;
-	bool need_enable;
-	int idlemode;
-	int r;
-
-	need_enable = hdmi->core_enabled == false;
-
-	if (need_enable) {
-		r = hdmi_core_enable(hdmi);
-		if (r)
-			return NULL;
-	}
-
-	mutex_lock(&hdmi->lock);
-	r = hdmi_runtime_get(hdmi);
-	BUG_ON(r);
-
-	idlemode = REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
-	/* No-idle mode */
-	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
-
-	hdmi5_core_ddc_init(&hdmi->core);
-
-	edid = read(hdmi, connector);
-
-	hdmi5_core_ddc_uninit(&hdmi->core);
-
-	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
-
-	hdmi_runtime_put(hdmi);
-	mutex_unlock(&hdmi->lock);
-
-	if (need_enable)
-		hdmi_core_disable(hdmi);
-
-	return (struct edid *)edid;
-}
-
 /* -----------------------------------------------------------------------------
  * DRM Bridge Operations
  */
@@ -469,18 +425,46 @@ static void hdmi5_bridge_disable(struct drm_bridge *bridge,
 	mutex_unlock(&hdmi->lock);
 }
 
-static struct edid *hdmi5_bridge_read_edid(struct omap_hdmi *hdmi,
-					   struct drm_connector *connector)
-{
-	return drm_do_get_edid(connector, hdmi5_core_ddc_read, &hdmi->core);
-}
-
 static struct edid *hdmi5_bridge_get_edid(struct drm_bridge *bridge,
 					  struct drm_connector *connector)
 {
 	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+	struct edid *edid;
+	bool need_enable;
+	int idlemode;
+	int r;
+
+	need_enable = hdmi->core_enabled == false;
+
+	if (need_enable) {
+		r = hdmi_core_enable(hdmi);
+		if (r)
+			return NULL;
+	}
+
+	mutex_lock(&hdmi->lock);
+	r = hdmi_runtime_get(hdmi);
+	BUG_ON(r);
 
-	return hdmi_do_read_edid(hdmi, hdmi5_bridge_read_edid, connector);
+	idlemode = REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	/* No-idle mode */
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+
+	hdmi5_core_ddc_init(&hdmi->core);
+
+	edid = drm_do_get_edid(connector, hdmi5_core_ddc_read, &hdmi->core);
+
+	hdmi5_core_ddc_uninit(&hdmi->core);
+
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
+
+	hdmi_runtime_put(hdmi);
+	mutex_unlock(&hdmi->lock);
+
+	if (need_enable)
+		hdmi_core_disable(hdmi);
+
+	return (struct edid *)edid;
 }
 
 static const struct drm_bridge_funcs hdmi5_bridge_funcs = {

commit a559b4407d2bc559a8149056f44c780b92c7526a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:01 2020 +0200

    drm/omap: hdmi: Remove omap_dss_device operations
    
    Now that the HDMI outputs are driven fully through the drm_bridge API
    their omap_dss_device operations are not used anymore. Remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-42-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index effe4a9401ff..6cb709c775d6 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -307,18 +307,6 @@ static void hdmi_core_disable(struct omap_hdmi *hdmi)
 	mutex_unlock(&hdmi->lock);
 }
 
-static int hdmi_connect(struct omap_dss_device *src,
-			struct omap_dss_device *dst)
-{
-	return omapdss_device_connect(dst->dss, dst, dst->next);
-}
-
-static void hdmi_disconnect(struct omap_dss_device *src,
-			    struct omap_dss_device *dst)
-{
-	omapdss_device_disconnect(dst, dst->next);
-}
-
 static struct edid *
 hdmi_do_read_edid(struct omap_hdmi *hdmi,
 		  struct edid *(*read)(struct omap_hdmi *hdmi,
@@ -363,11 +351,6 @@ hdmi_do_read_edid(struct omap_hdmi *hdmi,
 	return (struct edid *)edid;
 }
 
-static const struct omap_dss_device_ops hdmi_ops = {
-	.connect		= hdmi_connect,
-	.disconnect		= hdmi_disconnect,
-};
-
 /* -----------------------------------------------------------------------------
  * DRM Bridge Operations
  */
@@ -715,7 +698,6 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->type = OMAP_DISPLAY_TYPE_HDMI;
 	out->name = "hdmi.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
-	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
 	out->of_port = 0;
 

commit 75fb968b83d0530e2be2cb51e90b7bc849dd433b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:00 2020 +0200

    drm/omap: Remove HPD, detect and EDID omapdss operations
    
    Due to the removal of several omapdrm display drivers, the omapdss HPD,
    detected and EDID operations are not used anymore. Remove them and all
    related code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-41-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index f07fd5c6dc39..effe4a9401ff 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -319,43 +319,6 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 	omapdss_device_disconnect(dst, dst->next);
 }
 
-#define MAX_EDID	512
-
-static struct edid *hdmi_read_edid_data(struct omap_hdmi *hdmi,
-					struct drm_connector *connector)
-{
-	struct hdmi_core_data *core = &hdmi->core;
-	int max_ext_blocks = 3;
-	int r, n, i;
-	u8 *edid;
-
-	edid = kzalloc(MAX_EDID, GFP_KERNEL);
-	if (!edid)
-		return NULL;
-
-	r = hdmi5_core_ddc_read(core, edid, 0, EDID_LENGTH);
-	if (r)
-		goto error;
-
-	n = edid[0x7e];
-
-	if (n > max_ext_blocks)
-		n = max_ext_blocks;
-
-	for (i = 1; i <= n; i++) {
-		r = hdmi5_core_ddc_read(core, edid + i * EDID_LENGTH, i,
-					EDID_LENGTH);
-		if (r)
-			goto error;
-	}
-
-	return (struct edid *)edid;
-
-error:
-	kfree(edid);
-	return NULL;
-}
-
 static struct edid *
 hdmi_do_read_edid(struct omap_hdmi *hdmi,
 		  struct edid *(*read)(struct omap_hdmi *hdmi,
@@ -400,17 +363,9 @@ hdmi_do_read_edid(struct omap_hdmi *hdmi,
 	return (struct edid *)edid;
 }
 
-static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
-{
-	return hdmi_do_read_edid(dssdev_to_hdmi(dssdev), hdmi_read_edid_data,
-				 NULL);
-}
-
 static const struct omap_dss_device_ops hdmi_ops = {
 	.connect		= hdmi_connect,
 	.disconnect		= hdmi_disconnect,
-
-	.read_edid		= hdmi_read_edid,
 };
 
 /* -----------------------------------------------------------------------------
@@ -763,7 +718,6 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
 	out->of_port = 0;
-	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
 	r = omapdss_device_init_output(out, &hdmi->bridge);
 	if (r < 0) {

commit e7e67d9a2f1dd2f938adcc219b3769f5cc3f0df7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:59 2020 +0200

    drm/omap: Switch the HDMI and VENC outputs to drm_bridge
    
    The TPD12S015, OPA362 and analog and HDMI connectors are now supported
    by DRM bridge drivers, and the omapdrm HDMI and VENC outputs can be
    handled through the drm_bridge API. Switch the outputs to drm_bridge by
    making the next bridge mandatory and removing the related
    omapdrm-specific display drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-40-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 52184797c858..f07fd5c6dc39 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -422,8 +422,8 @@ static int hdmi5_bridge_attach(struct drm_bridge *bridge,
 {
 	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
 
-	if (!hdmi->output.next_bridge)
-		return 0;
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))
+		return -EINVAL;
 
 	return drm_bridge_attach(bridge->encoder, hdmi->output.next_bridge,
 				 bridge, flags);

commit 615de6ceb6b6a227a242059939b2ed54e54b4db8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:54 2020 +0200

    drm/omap: hdmi5: Move mode set, enable and disable operations to bridge
    
    Move the omap_dss_device .set_timings(), .enable() and .disable()
    operations to the drm_bridge functions. As the drm_bridge for the HDMI
    encoder is unconditionally registered and attached, those operations
    will be called at the appropriate time.
    
    The omapdss device .set_infoframe() and .set_hdmi_mode() operations have
    no equivalent in drm_bridge. Thir content is thus moved to the bridge
    .enable() operation as the data they store is not needed before the HDMI
    encoder gets enabled.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-35-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index e7fe2a24a3e1..52184797c858 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -31,6 +31,9 @@
 #include <linux/of_graph.h>
 #include <sound/omap-hdmi-audio.h>
 
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_state_helper.h>
+
 #include "omapdss.h"
 #include "hdmi5_core.h"
 #include "dss.h"
@@ -236,20 +239,6 @@ static void hdmi_power_off_full(struct omap_hdmi *hdmi)
 	hdmi_power_off_core(hdmi);
 }
 
-static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
-				     const struct drm_display_mode *mode)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
-	mutex_lock(&hdmi->lock);
-
-	drm_display_mode_to_videomode(mode, &hdmi->cfg.vm);
-
-	dispc_set_tv_pclk(hdmi->dss->dispc, mode->clock * 1000);
-
-	mutex_unlock(&hdmi->lock);
-}
-
 static int hdmi_dump_regs(struct seq_file *s, void *p)
 {
 	struct omap_hdmi *hdmi = s->private;
@@ -285,62 +274,6 @@ static void hdmi_stop_audio_stream(struct omap_hdmi *hd)
 	REG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, hd->wp_idlemode, 3, 2);
 }
 
-static void hdmi_display_enable(struct omap_dss_device *dssdev)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-	unsigned long flags;
-	int r;
-
-	DSSDBG("ENTER hdmi_display_enable\n");
-
-	mutex_lock(&hdmi->lock);
-
-	r = hdmi_power_on_full(hdmi);
-	if (r) {
-		DSSERR("failed to power on device\n");
-		goto done;
-	}
-
-	if (hdmi->audio_configured) {
-		r = hdmi5_audio_config(&hdmi->core, &hdmi->wp,
-				       &hdmi->audio_config,
-				       hdmi->cfg.vm.pixelclock);
-		if (r) {
-			DSSERR("Error restoring audio configuration: %d", r);
-			hdmi->audio_abort_cb(&hdmi->pdev->dev);
-			hdmi->audio_configured = false;
-		}
-	}
-
-	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
-	if (hdmi->audio_configured && hdmi->audio_playing)
-		hdmi_start_audio_stream(hdmi);
-	hdmi->display_enabled = true;
-	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
-
-done:
-	mutex_unlock(&hdmi->lock);
-}
-
-static void hdmi_display_disable(struct omap_dss_device *dssdev)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-	unsigned long flags;
-
-	DSSDBG("Enter hdmi_display_disable\n");
-
-	mutex_lock(&hdmi->lock);
-
-	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
-	hdmi_stop_audio_stream(hdmi);
-	hdmi->display_enabled = false;
-	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
-
-	hdmi_power_off_full(hdmi);
-
-	mutex_unlock(&hdmi->lock);
-}
-
 static int hdmi_core_enable(struct omap_hdmi *hdmi)
 {
 	int r = 0;
@@ -473,39 +406,11 @@ static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
 				 NULL);
 }
 
-static int hdmi_set_infoframe(struct omap_dss_device *dssdev,
-		const struct hdmi_avi_infoframe *avi)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
-	hdmi->cfg.infoframe = *avi;
-	return 0;
-}
-
-static int hdmi_set_hdmi_mode(struct omap_dss_device *dssdev,
-		bool hdmi_mode)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
-	hdmi->cfg.hdmi_dvi_mode = hdmi_mode ? HDMI_HDMI : HDMI_DVI;
-	return 0;
-}
-
 static const struct omap_dss_device_ops hdmi_ops = {
 	.connect		= hdmi_connect,
 	.disconnect		= hdmi_disconnect,
 
-	.enable			= hdmi_display_enable,
-	.disable		= hdmi_display_disable,
-
-	.set_timings		= hdmi_display_set_timings,
-
 	.read_edid		= hdmi_read_edid,
-
-	.hdmi = {
-		.set_infoframe		= hdmi_set_infoframe,
-		.set_hdmi_mode		= hdmi_set_hdmi_mode,
-	},
 };
 
 /* -----------------------------------------------------------------------------
@@ -524,6 +429,108 @@ static int hdmi5_bridge_attach(struct drm_bridge *bridge,
 				 bridge, flags);
 }
 
+static void hdmi5_bridge_mode_set(struct drm_bridge *bridge,
+				  const struct drm_display_mode *mode,
+				  const struct drm_display_mode *adjusted_mode)
+{
+	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+
+	mutex_lock(&hdmi->lock);
+
+	drm_display_mode_to_videomode(adjusted_mode, &hdmi->cfg.vm);
+
+	dispc_set_tv_pclk(hdmi->dss->dispc, adjusted_mode->clock * 1000);
+
+	mutex_unlock(&hdmi->lock);
+}
+
+static void hdmi5_bridge_enable(struct drm_bridge *bridge,
+				struct drm_bridge_state *bridge_state)
+{
+	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	struct drm_connector_state *conn_state;
+	struct drm_connector *connector;
+	struct drm_crtc_state *crtc_state;
+	unsigned long flags;
+	int ret;
+
+	/*
+	 * None of these should fail, as the bridge can't be enabled without a
+	 * valid CRTC to connector path with fully populated new states.
+	 */
+	connector = drm_atomic_get_new_connector_for_encoder(state,
+							     bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	hdmi->cfg.hdmi_dvi_mode = connector->display_info.is_hdmi
+				? HDMI_HDMI : HDMI_DVI;
+
+	if (connector->display_info.is_hdmi) {
+		const struct drm_display_mode *mode;
+		struct hdmi_avi_infoframe avi;
+
+		mode = &crtc_state->adjusted_mode;
+		ret = drm_hdmi_avi_infoframe_from_display_mode(&avi, connector,
+							       mode);
+		if (ret == 0)
+			hdmi->cfg.infoframe = avi;
+	}
+
+	mutex_lock(&hdmi->lock);
+
+	ret = hdmi_power_on_full(hdmi);
+	if (ret) {
+		DSSERR("failed to power on device\n");
+		goto done;
+	}
+
+	if (hdmi->audio_configured) {
+		ret = hdmi5_audio_config(&hdmi->core, &hdmi->wp,
+					 &hdmi->audio_config,
+					 hdmi->cfg.vm.pixelclock);
+		if (ret) {
+			DSSERR("Error restoring audio configuration: %d", ret);
+			hdmi->audio_abort_cb(&hdmi->pdev->dev);
+			hdmi->audio_configured = false;
+		}
+	}
+
+	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
+	if (hdmi->audio_configured && hdmi->audio_playing)
+		hdmi_start_audio_stream(hdmi);
+	hdmi->display_enabled = true;
+	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
+
+done:
+	mutex_unlock(&hdmi->lock);
+}
+
+static void hdmi5_bridge_disable(struct drm_bridge *bridge,
+				 struct drm_bridge_state *bridge_state)
+{
+	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+	unsigned long flags;
+
+	mutex_lock(&hdmi->lock);
+
+	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
+	hdmi_stop_audio_stream(hdmi);
+	hdmi->display_enabled = false;
+	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
+
+	hdmi_power_off_full(hdmi);
+
+	mutex_unlock(&hdmi->lock);
+}
+
 static struct edid *hdmi5_bridge_read_edid(struct omap_hdmi *hdmi,
 					   struct drm_connector *connector)
 {
@@ -540,6 +547,12 @@ static struct edid *hdmi5_bridge_get_edid(struct drm_bridge *bridge,
 
 static const struct drm_bridge_funcs hdmi5_bridge_funcs = {
 	.attach = hdmi5_bridge_attach,
+	.mode_set = hdmi5_bridge_mode_set,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+	.atomic_enable = hdmi5_bridge_enable,
+	.atomic_disable = hdmi5_bridge_disable,
 	.get_edid = hdmi5_bridge_get_edid,
 };
 

commit 6c623d6bf3e36f9ba1ac116e2ea552091af221a5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:52 2020 +0200

    drm/omap: hdmi5: Register a drm_bridge for EDID read
    
    In order to integrate with a chain of drm_bridge, the internal HDMI5
    encoder has to expose the EDID read operation through the drm_bridge
    API. Register a bridge at initialisation time to do so.
    
    For the time being make the next bridge in the chain optional as the
    HDMI output is still based on omap_dss_device. The create_connector
    argument to the bridge attach function is also ignored for the same
    reason. This will be changed later when removing the related
    omapdrm-specific display drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-33-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 2b02b0a11696..e7fe2a24a3e1 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -388,8 +388,10 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 
 #define MAX_EDID	512
 
-static struct edid *hdmi_read_edid_data(struct hdmi_core_data *core)
+static struct edid *hdmi_read_edid_data(struct omap_hdmi *hdmi,
+					struct drm_connector *connector)
 {
+	struct hdmi_core_data *core = &hdmi->core;
 	int max_ext_blocks = 3;
 	int r, n, i;
 	u8 *edid;
@@ -421,9 +423,12 @@ static struct edid *hdmi_read_edid_data(struct hdmi_core_data *core)
 	return NULL;
 }
 
-static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
+static struct edid *
+hdmi_do_read_edid(struct omap_hdmi *hdmi,
+		  struct edid *(*read)(struct omap_hdmi *hdmi,
+				       struct drm_connector *connector),
+		  struct drm_connector *connector)
 {
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	struct edid *edid;
 	bool need_enable;
 	int idlemode;
@@ -447,7 +452,7 @@ static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
 
 	hdmi5_core_ddc_init(&hdmi->core);
 
-	edid = hdmi_read_edid_data(&hdmi->core);
+	edid = read(hdmi, connector);
 
 	hdmi5_core_ddc_uninit(&hdmi->core);
 
@@ -462,6 +467,12 @@ static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
 	return (struct edid *)edid;
 }
 
+static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
+{
+	return hdmi_do_read_edid(dssdev_to_hdmi(dssdev), hdmi_read_edid_data,
+				 NULL);
+}
+
 static int hdmi_set_infoframe(struct omap_dss_device *dssdev,
 		const struct hdmi_avi_infoframe *avi)
 {
@@ -497,6 +508,56 @@ static const struct omap_dss_device_ops hdmi_ops = {
 	},
 };
 
+/* -----------------------------------------------------------------------------
+ * DRM Bridge Operations
+ */
+
+static int hdmi5_bridge_attach(struct drm_bridge *bridge,
+			       enum drm_bridge_attach_flags flags)
+{
+	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+
+	if (!hdmi->output.next_bridge)
+		return 0;
+
+	return drm_bridge_attach(bridge->encoder, hdmi->output.next_bridge,
+				 bridge, flags);
+}
+
+static struct edid *hdmi5_bridge_read_edid(struct omap_hdmi *hdmi,
+					   struct drm_connector *connector)
+{
+	return drm_do_get_edid(connector, hdmi5_core_ddc_read, &hdmi->core);
+}
+
+static struct edid *hdmi5_bridge_get_edid(struct drm_bridge *bridge,
+					  struct drm_connector *connector)
+{
+	struct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);
+
+	return hdmi_do_read_edid(hdmi, hdmi5_bridge_read_edid, connector);
+}
+
+static const struct drm_bridge_funcs hdmi5_bridge_funcs = {
+	.attach = hdmi5_bridge_attach,
+	.get_edid = hdmi5_bridge_get_edid,
+};
+
+static void hdmi5_bridge_init(struct omap_hdmi *hdmi)
+{
+	hdmi->bridge.funcs = &hdmi5_bridge_funcs;
+	hdmi->bridge.of_node = hdmi->pdev->dev.of_node;
+	hdmi->bridge.ops = DRM_BRIDGE_OP_EDID;
+	hdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+
+	drm_bridge_add(&hdmi->bridge);
+}
+
+static void hdmi5_bridge_cleanup(struct omap_hdmi *hdmi)
+{
+	drm_bridge_remove(&hdmi->bridge);
+}
+
 /* -----------------------------------------------------------------------------
  * Audio Callbacks
  */
@@ -679,6 +740,8 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	struct omap_dss_device *out = &hdmi->output;
 	int r;
 
+	hdmi5_bridge_init(hdmi);
+
 	out->dev = &hdmi->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_HDMI;
 	out->type = OMAP_DISPLAY_TYPE_HDMI;
@@ -689,9 +752,11 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
-	r = omapdss_device_init_output(out, NULL);
-	if (r < 0)
+	r = omapdss_device_init_output(out, &hdmi->bridge);
+	if (r < 0) {
+		hdmi5_bridge_cleanup(hdmi);
 		return r;
+	}
 
 	omapdss_device_register(out);
 
@@ -704,6 +769,8 @@ static void hdmi5_uninit_output(struct omap_hdmi *hdmi)
 
 	omapdss_device_unregister(out);
 	omapdss_device_cleanup_output(out);
+
+	hdmi5_bridge_cleanup(hdmi);
 }
 
 static int hdmi5_probe_of(struct omap_hdmi *hdmi)

commit 1edc1a1cbe7f5b5692267cdcf227528c2f39f198
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:50 2020 +0200

    drm/omap: hdmi5: Rework EDID read to isolate data read
    
    In preparation of adding DRM bridge support to the hdmi5 encoder code,
    rework the EDID read to isolate data read.
    
    The hdmi_read_edid() function is the main entry point. It performs all
    initialisation steps required prior to reading the EDID (such as
    ensuring the device is powered on), as well as corresponding cleanup
    steps afterwards. EDID read itself is handled by hdmi_read_edid_data()
    that calls the hdmi5_core_ddc_read() function to read individual blocks.
    
    This new code architecture will allow reusing hdmi_read_edid() and
    hdmi5_core_ddc_read() for the drm_bridge EDID read implementation, while
    swapping out hdmi_read_edid_data() for the DRM drm_do_get_edid()
    function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-31-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 99720dfc5769..2b02b0a11696 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -271,30 +271,6 @@ static int hdmi_dump_regs(struct seq_file *s, void *p)
 	return 0;
 }
 
-static int read_edid(struct omap_hdmi *hdmi, u8 *buf, int len)
-{
-	int r;
-	int idlemode;
-
-	mutex_lock(&hdmi->lock);
-
-	r = hdmi_runtime_get(hdmi);
-	BUG_ON(r);
-
-	idlemode = REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
-	/* No-idle mode */
-	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
-
-	r = hdmi5_read_edid(&hdmi->core,  buf, len);
-
-	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
-
-	hdmi_runtime_put(hdmi);
-	mutex_unlock(&hdmi->lock);
-
-	return r;
-}
-
 static void hdmi_start_audio_stream(struct omap_hdmi *hd)
 {
 	REG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
@@ -412,32 +388,73 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 
 #define MAX_EDID	512
 
-static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
+static struct edid *hdmi_read_edid_data(struct hdmi_core_data *core)
 {
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-	bool need_enable;
+	int max_ext_blocks = 3;
+	int r, n, i;
 	u8 *edid;
-	int r;
 
 	edid = kzalloc(MAX_EDID, GFP_KERNEL);
 	if (!edid)
 		return NULL;
 
+	r = hdmi5_core_ddc_read(core, edid, 0, EDID_LENGTH);
+	if (r)
+		goto error;
+
+	n = edid[0x7e];
+
+	if (n > max_ext_blocks)
+		n = max_ext_blocks;
+
+	for (i = 1; i <= n; i++) {
+		r = hdmi5_core_ddc_read(core, edid + i * EDID_LENGTH, i,
+					EDID_LENGTH);
+		if (r)
+			goto error;
+	}
+
+	return (struct edid *)edid;
+
+error:
+	kfree(edid);
+	return NULL;
+}
+
+static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
+{
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+	struct edid *edid;
+	bool need_enable;
+	int idlemode;
+	int r;
+
 	need_enable = hdmi->core_enabled == false;
 
 	if (need_enable) {
 		r = hdmi_core_enable(hdmi);
-		if (r) {
-			kfree(edid);
+		if (r)
 			return NULL;
-		}
 	}
 
-	r = read_edid(hdmi, edid, MAX_EDID);
-	if (r < 0) {
-		kfree(edid);
-		edid = NULL;
-	}
+	mutex_lock(&hdmi->lock);
+	r = hdmi_runtime_get(hdmi);
+	BUG_ON(r);
+
+	idlemode = REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	/* No-idle mode */
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+
+	hdmi5_core_ddc_init(&hdmi->core);
+
+	edid = hdmi_read_edid_data(&hdmi->core);
+
+	hdmi5_core_ddc_uninit(&hdmi->core);
+
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
+
+	hdmi_runtime_put(hdmi);
+	mutex_unlock(&hdmi->lock);
 
 	if (need_enable)
 		hdmi_core_disable(hdmi);

commit 0fe37173ce0ec7ca23232a1a242059db73c0ff16
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:48 2020 +0200

    drm/omap: hdmi: Allocate EDID in the .read_edid() operation
    
    Bring the omapdss-specific .read_edid() operation in sync with the
    drm_bridge .get_edid() operation to ease code reuse.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-29-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 8e3790dd8b98..99720dfc5769 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -410,27 +410,39 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 	omapdss_device_disconnect(dst, dst->next);
 }
 
-static int hdmi_read_edid(struct omap_dss_device *dssdev,
-		u8 *edid, int len)
+#define MAX_EDID	512
+
+static struct edid *hdmi_read_edid(struct omap_dss_device *dssdev)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	bool need_enable;
+	u8 *edid;
 	int r;
 
+	edid = kzalloc(MAX_EDID, GFP_KERNEL);
+	if (!edid)
+		return NULL;
+
 	need_enable = hdmi->core_enabled == false;
 
 	if (need_enable) {
 		r = hdmi_core_enable(hdmi);
-		if (r)
-			return r;
+		if (r) {
+			kfree(edid);
+			return NULL;
+		}
 	}
 
-	r = read_edid(hdmi, edid, len);
+	r = read_edid(hdmi, edid, MAX_EDID);
+	if (r < 0) {
+		kfree(edid);
+		edid = NULL;
+	}
 
 	if (need_enable)
 		hdmi_core_disable(hdmi);
 
-	return r;
+	return (struct edid *)edid;
 }
 
 static int hdmi_set_infoframe(struct omap_dss_device *dssdev,

commit 326a1166ca0826e2fdccc2b9174a8f7802bd5100
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:46 2020 +0200

    drm/omap: Add infrastructure to support drm_bridge local to DSS outputs
    
    In order to support drm_bridge-based pipeline, the internal HDMI
    encoders will need to expose the EDID read operation through the
    drm_bridge API, and thus to expose a drm_bridge instance corresponding
    to the encoder. The HDMI encoders are however handled as omap_dss_device
    instances, which conflicts with this requirement.
    
    In order to move forward with the drm_bridge transition, add support for
    creating drm_bridge instances local to DSS outputs. If a local bridge is
    passed to the omapdss_device_init_output() function, it is used as the
    first bridge in the chain, and the omap_dss_device.next_bridge field is
    set to the next bridge for the use of the internal encoders' bridges.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-27-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 1b5bd44ee09d..8e3790dd8b98 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -660,7 +660,7 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
-	r = omapdss_device_init_output(out);
+	r = omapdss_device_init_output(out, NULL);
 	if (r < 0)
 		return r;
 

commit c83fefd738344cf5bf22e1e1442e6f746b85c1d4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:45 2020 +0200

    drm/omap: dss: Fix output next device lookup in DT
    
    The DSS core looks up the next device connected to an output by
    traversing the OF graph. It currently hardcodes the local port number to
    0, which breaks any output with a different port number (SDI on OMAP3
    and any DPI output but the first one). Fix this by repurposing the
    currently unused of_ports bitmask in omap_dss_device with an of_port
    output port number, and use it to traverse the OF graph.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-26-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d9463b332554..1b5bd44ee09d 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -657,7 +657,7 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
-	out->of_ports = BIT(0);
+	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
 	r = omapdss_device_init_output(out);

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 2955bbad13bb..d9463b332554 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * HDMI driver for OMAP5
  *
@@ -8,18 +9,6 @@
  *	Mythri pk
  *	Archit Taneja <archit@ti.com>
  *	Tomi Valkeinen <tomi.valkeinen@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define DSS_SUBSYS_NAME "HDMI"

commit 0dbfc396672025d3ef8bacc934b80a5463e75c6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 10 14:00:38 2018 +0200

    drm/omap: Merge omap_dss_device type and output_type fields
    
    The omap_dss_device type and output_type fields differ mostly for
    historical reasons. The output_type field is required for all devices
    but the display at the end of the pipeline, and must be set to
    OMAP_DISPLAY_TYPE_NONE for the latter. The type field is required for
    all devices but the internal encoder, for which it is ignored.
    
    The only reason why the output_type field must be set to
    OMAP_DISPLAY_TYPE_NONE for the display at the end of the pipeline is to
    identify omap_dss_device instances corresponding to displays. This is
    not documented and confusing.
    
    Clean the code by adding a new display field to the omap_dss_device
    structure to identify displays, and merge the type and output_type
    fields.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b94f884c5c1a..2955bbad13bb 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -663,7 +663,7 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 
 	out->dev = &hdmi->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_HDMI;
-	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
+	out->type = OMAP_DISPLAY_TYPE_HDMI;
 	out->name = "hdmi.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &hdmi_ops;

commit 41322aa691950431ccef115e85b2d6bba654bd70
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 17:00:29 2018 +0300

    drm/omap: Pass drm_display_mode to .check_timings() and .set_timings()
    
    The omap_dss_device .check_timings() and .set_timings() operations
    operate on struct videomode, while the DRM API operates on struct
    drm_display_mode. This forces conversion from to videomode in the
    callers. While that's not a problem per se, it creates a difference with
    the drm_bridge API.
    
    Replace the videomode parameter to the .check_timings() and
    .set_timings() operations with a drm_display_mode. This pushed the
    conversion to videomode down to the DSS devices in some cases. If needed
    they will be converted to operate on drm_display_mode natively.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d7d33b4d2bed..b94f884c5c1a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -248,15 +248,15 @@ static void hdmi_power_off_full(struct omap_hdmi *hdmi)
 }
 
 static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
-				     const struct videomode *vm)
+				     const struct drm_display_mode *mode)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 
 	mutex_lock(&hdmi->lock);
 
-	hdmi->cfg.vm = *vm;
+	drm_display_mode_to_videomode(mode, &hdmi->cfg.vm);
 
-	dispc_set_tv_pclk(hdmi->dss->dispc, vm->pixelclock);
+	dispc_set_tv_pclk(hdmi->dss->dispc, mode->clock * 1000);
 
 	mutex_unlock(&hdmi->lock);
 }

commit d17eb4537a7eb16da9eafbfd5717e12b45b77251
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 12 19:41:31 2018 +0300

    drm/omap: Factor out common init/cleanup code for output devices
    
    All the internal encoders share common init and cleanup code. Factor it
    out to separate functions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 28cf1c32b158..d7d33b4d2bed 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -671,19 +671,9 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->of_ports = BIT(0);
 	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
-	out->next = omapdss_of_find_connected_device(out->dev->of_node, 0);
-	if (IS_ERR(out->next)) {
-		if (PTR_ERR(out->next) != -EPROBE_DEFER)
-			dev_err(out->dev, "failed to find video sink\n");
-		return PTR_ERR(out->next);
-	}
-
-	r = omapdss_output_validate(out);
-	if (r) {
-		omapdss_device_put(out->next);
-		out->next = NULL;
+	r = omapdss_device_init_output(out);
+	if (r < 0)
 		return r;
-	}
 
 	omapdss_device_register(out);
 
@@ -694,9 +684,8 @@ static void hdmi5_uninit_output(struct omap_hdmi *hdmi)
 {
 	struct omap_dss_device *out = &hdmi->output;
 
-	if (out->next)
-		omapdss_device_put(out->next);
 	omapdss_device_unregister(out);
+	omapdss_device_cleanup_output(out);
 }
 
 static int hdmi5_probe_of(struct omap_hdmi *hdmi)

commit 19b4200d8f4b90b5a41592f9021b52153ac2b6b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 24 19:38:07 2018 +0300

    drm/omap: Reverse direction of the DSS device enable/disable operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    Reconcile the omapdrm and omapdss drivers with the DRM bridge and panel
    model by reversing the direction of the DSS device .enable() and
    .disable() operations. This completes the move to the DRM bridge model,
    with the notable exception of the DSI pipelines that will require more
    work.
    
    We also adapt the omapdss shutdown handler dss_shutdown() to shut down
    all active pipelines starting from the pipeline output device instead of
    the display device.
    
    As a consequence the for_each_dss_display() macro isn't used and can be
    removed, and the omapdss_device_get_next() function underlying the macro
    can be simplified to search for output devices only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index beef25703eab..28cf1c32b158 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -320,11 +320,11 @@ static void hdmi_stop_audio_stream(struct omap_hdmi *hd)
 	REG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, hd->wp_idlemode, 3, 2);
 }
 
-static int hdmi_display_enable(struct omap_dss_device *dssdev)
+static void hdmi_display_enable(struct omap_dss_device *dssdev)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	unsigned long flags;
-	int r = 0;
+	int r;
 
 	DSSDBG("ENTER hdmi_display_enable\n");
 
@@ -333,7 +333,7 @@ static int hdmi_display_enable(struct omap_dss_device *dssdev)
 	r = hdmi_power_on_full(hdmi);
 	if (r) {
 		DSSERR("failed to power on device\n");
-		goto err0;
+		goto done;
 	}
 
 	if (hdmi->audio_configured) {
@@ -353,12 +353,8 @@ static int hdmi_display_enable(struct omap_dss_device *dssdev)
 	hdmi->display_enabled = true;
 	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
 
+done:
 	mutex_unlock(&hdmi->lock);
-	return 0;
-
-err0:
-	mutex_unlock(&hdmi->lock);
-	return r;
 }
 
 static void hdmi_display_disable(struct omap_dss_device *dssdev)

commit f8a8eabb273b6810d0eb7546896e5da7974189a5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 4 23:53:34 2018 +0300

    drm/omap: Remove connection checks from internal encoders .enable()
    
    The internal encoders return an error from their .enable() handler when
    their are not connected to a dss manager. As the flag used is set and
    cleared in the connect and disconnect handlers, this effectively checks
    whether the omap_dss_device is connected.
    
    The .enable() handler is called from code paths that access the dss
    devices chain from the display device, which is set to NULL when the
    device isn't connected, making it impossible to access the device in
    that case.
    
    The safety check is thus not needed, remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 9e8556f67a29..beef25703eab 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -330,12 +330,6 @@ static int hdmi_display_enable(struct omap_dss_device *dssdev)
 
 	mutex_lock(&hdmi->lock);
 
-	if (!dssdev->dispc_channel_connected) {
-		DSSERR("failed to enable display: no output/manager\n");
-		r = -ENODEV;
-		goto err0;
-	}
-
 	r = hdmi_power_on_full(hdmi);
 	if (r) {
 		DSSERR("failed to power on device\n");
@@ -422,21 +416,12 @@ static void hdmi_core_disable(struct omap_hdmi *hdmi)
 static int hdmi_connect(struct omap_dss_device *src,
 			struct omap_dss_device *dst)
 {
-	int r;
-
-	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r)
-		return r;
-
-	dst->dispc_channel_connected = true;
-	return 0;
+	return omapdss_device_connect(dst->dss, dst, dst->next);
 }
 
 static void hdmi_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
-	dst->dispc_channel_connected = false;
-
 	omapdss_device_disconnect(dst, dst->next);
 }
 

commit 24ec84e854c68ceda59a26027114eb7f260f9411
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Nov 10 13:16:54 2018 +0200

    drm/omap: Move DISPC runtime PM handling to omapdrm
    
    The internal encoders (DSI, HDMI4, HDMI5 and VENC) runtime PM handlers
    attempt to manage the runtime PM state of the connected DISPC, based on
    the rationale that the DISPC providing data to the encoders requires
    ensuring that the display is active whenever the encoders are active.
    
    While the DISPC provides data to the encoders, it doesn't as such
    constitute a resource that encoders require in order to be taken out
    of suspend, contrary to for instance a functional clock or a power
    supply. Encoders registers can be accessed without the DISPC being
    active, and while the encoders will not output any video stream without
    being fed by the DISPC, the DISPC PM state doesn't influence the
    encoders PM state.
    
    For this reason the DISPC PM state is better managed from the omapdrm
    driver, in the CRTC enable and disable operations. This allows the
    encoders PM state to be handled separately from the DISPC, and in
    particular at times when the DISPC may not be available (for instance at
    probe due to the DSS probe being deferred, or at remove time du to the
    DISPC being already removed).
    
    Fixes: edb715dffdee ("drm/omap: dss: dsi: Move initialization code from bind to probe")
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181110111654.4387-5-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b0e4a7463f8c..9e8556f67a29 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -825,32 +825,6 @@ static int hdmi5_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int hdmi_runtime_suspend(struct device *dev)
-{
-	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
-
-	dispc_runtime_put(hdmi->dss->dispc);
-
-	return 0;
-}
-
-static int hdmi_runtime_resume(struct device *dev)
-{
-	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
-	int r;
-
-	r = dispc_runtime_get(hdmi->dss->dispc);
-	if (r < 0)
-		return r;
-
-	return 0;
-}
-
-static const struct dev_pm_ops hdmi_pm_ops = {
-	.runtime_suspend = hdmi_runtime_suspend,
-	.runtime_resume = hdmi_runtime_resume,
-};
-
 static const struct of_device_id hdmi_of_match[] = {
 	{ .compatible = "ti,omap5-hdmi", },
 	{ .compatible = "ti,dra7-hdmi", },
@@ -862,7 +836,6 @@ struct platform_driver omapdss_hdmi5hw_driver = {
 	.remove		= hdmi5_remove,
 	.driver         = {
 		.name   = "omapdss_hdmi5",
-		.pm	= &hdmi_pm_ops,
 		.of_match_table = hdmi_of_match,
 		.suppress_bind_attrs = true,
 	},

commit 6ea48430952323091194100d48c5610b9cd286b4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 19:55:04 2018 +0300

    drm/omap: Don't call .set_timings() operation recursively
    
    Instead of calling the .set_timings() operation recursively from the
    display device backwards, iterate over the devices manually in the DRM
    encoder code. This moves the complexity to a single central location and
    simplifies the logic in omap_dss_device drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index cb212e5e790f..b0e4a7463f8c 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -258,8 +258,6 @@ static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
 
 	dispc_set_tv_pclk(hdmi->dss->dispc, vm->pixelclock);
 
-	dss_mgr_set_timings(&hdmi->output, vm);
-
 	mutex_unlock(&hdmi->lock);
 }
 

commit d8dbe79143764b86bd04c63c044431565582a22d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 8 16:53:37 2018 +0300

    drm/omap: Store CRTC timings in .set_timings() operation
    
    The video timings are stored in the CRTC structure by the
    omap_crtc_dss_set_timings() function, called by dss_mgr_set_timings()
    from the .enable() operation of the internal encoders. This instead
    belongs to the .set_timings() code paths. Move the
    omap_crtc_dss_set_timings() calls accordingly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 147c3550df51..cb212e5e790f 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -206,9 +206,6 @@ static int hdmi_power_on_full(struct omap_hdmi *hdmi)
 
 	hdmi5_configure(&hdmi->core, &hdmi->wp, &hdmi->cfg);
 
-	/* tv size */
-	dss_mgr_set_timings(&hdmi->output, vm);
-
 	r = dss_mgr_enable(&hdmi->output);
 	if (r)
 		goto err_mgr_enable;
@@ -261,6 +258,8 @@ static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
 
 	dispc_set_tv_pclk(hdmi->dss->dispc, vm->pixelclock);
 
+	dss_mgr_set_timings(&hdmi->output, vm);
+
 	mutex_unlock(&hdmi->lock);
 }
 

commit 95e472da1094dfe41b7d1d3fb2d04486cf863a42
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 8 16:39:27 2018 +0300

    drm/omap: hdmi: Constify video mode and related pointers
    
    Constify many pointers to struct videomode, as well as pointers to
    container structures, to ensure the video mode isn't modified after
    the .check_timings() operation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index c02e08299155..147c3550df51 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -153,7 +153,7 @@ static void hdmi_power_off_core(struct omap_hdmi *hdmi)
 static int hdmi_power_on_full(struct omap_hdmi *hdmi)
 {
 	int r;
-	struct videomode *vm;
+	const struct videomode *vm;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned int pc;
 

commit 7c27fa57ef31debf62c5529725d4fa096b336a99
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 5 01:57:09 2018 +0300

    drm/omap: Call dispc timings check operation directly
    
    Instead of call the dispc timings check function dispc_mgr_timings_ok()
    from the internal encoders .check_timings() operation, expose it through
    the dispc ops (after renaming it to check_timings) and call it directly
    from omapdrm. This allows removal of now empty omap_dss_device
    .check_timings() operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d63831c9eacf..c02e08299155 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -250,17 +250,6 @@ static void hdmi_power_off_full(struct omap_hdmi *hdmi)
 	hdmi_power_off_core(hdmi);
 }
 
-static int hdmi_display_check_timings(struct omap_dss_device *dssdev,
-				      struct videomode *vm)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
-	if (!dispc_mgr_timings_ok(hdmi->dss->dispc, dssdev->dispc_channel, vm))
-		return -EINVAL;
-
-	return 0;
-}
-
 static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
 				     const struct videomode *vm)
 {
@@ -502,7 +491,6 @@ static const struct omap_dss_device_ops hdmi_ops = {
 	.enable			= hdmi_display_enable,
 	.disable		= hdmi_display_disable,
 
-	.check_timings		= hdmi_display_check_timings,
 	.set_timings		= hdmi_display_set_timings,
 
 	.read_edid		= hdmi_read_edid,

commit 8fe1d36100c84ab1b501771252755d75ddcb6bff
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jun 4 18:29:01 2018 +0300

    drm/omap: Make the video_mode pointer to .set_timings() const
    
    The .set_timings() operations of the omap_dss_device instances don't
    need to modify the passed timings. Make the pointer const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 259cd39d0c1d..d63831c9eacf 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -262,7 +262,7 @@ static int hdmi_display_check_timings(struct omap_dss_device *dssdev,
 }
 
 static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
-				     struct videomode *vm)
+				     const struct videomode *vm)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 

commit ec68cd5a18e16318969e0e59a7d99513dcfa2d02
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jun 4 18:26:00 2018 +0300

    drm/omap: dss: hdmi: Rename hdmi_display_(set|check)_timing() functions
    
    The two functions implement the .set_timings() and .check_timings()
    operations. Rename them to hdmi_disply_set_timings() and
    hdmi_display_check_timings() respectively to match the operations names
    and make searching the source code easier.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 2aaa8ee61662..259cd39d0c1d 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -250,8 +250,8 @@ static void hdmi_power_off_full(struct omap_hdmi *hdmi)
 	hdmi_power_off_core(hdmi);
 }
 
-static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
-				     struct videomode *vm)
+static int hdmi_display_check_timings(struct omap_dss_device *dssdev,
+				      struct videomode *vm)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 
@@ -261,8 +261,8 @@ static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 	return 0;
 }
 
-static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
-				    struct videomode *vm)
+static void hdmi_display_set_timings(struct omap_dss_device *dssdev,
+				     struct videomode *vm)
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 
@@ -502,8 +502,8 @@ static const struct omap_dss_device_ops hdmi_ops = {
 	.enable			= hdmi_display_enable,
 	.disable		= hdmi_display_disable,
 
-	.check_timings		= hdmi_display_check_timing,
-	.set_timings		= hdmi_display_set_timing,
+	.check_timings		= hdmi_display_check_timings,
+	.set_timings		= hdmi_display_set_timings,
 
 	.read_edid		= hdmi_read_edid,
 

commit 90279e9518da8488982e9d5704b890fe0e34ad30
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 31 22:09:14 2018 +0300

    drm/omap: Don't call EDID read operation recursively
    
    Instead of calling the EDID read operation (.read_edid()) recursively
    from the display device back to the first device that provides EDID read
    support, iterate over the devices manually in the DRM connector code.
    This moves the complexity to a single central location and simplifies
    the logic in omap_dss_device drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 7c07e0208107..2aaa8ee61662 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -703,6 +703,7 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
 	out->of_ports = BIT(0);
+	out->ops_flags = OMAP_DSS_DEVICE_OP_EDID;
 
 	out->next = omapdss_of_find_connected_device(out->dev->of_node, 0);
 	if (IS_ERR(out->next)) {

commit 83910ad3f51fbc0e6546b60aafa90697b5127a8a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 1 19:45:01 2018 +0300

    drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops
    
    omap_dss_device instances have two ops structures, omap_dss_driver and
    omap_dss_device_ops. The former is used for devices at the end of the
    pipeline (a.k.a. display devices), and the latter for intermediate
    devices.
    
    Having two sets of operations isn't convenient as code that iterates
    over omap_dss_device instances need to take them both into account.
    There's currently a reasonably small amount of such code, but more will
    be introduced to move the driver away from recursive operations. To
    simplify current and future code, move all operations that are not
    specific to the display device to the omap_dss_device_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 889c31745492..7c07e0208107 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -505,8 +505,9 @@ static const struct omap_dss_device_ops hdmi_ops = {
 	.check_timings		= hdmi_display_check_timing,
 	.set_timings		= hdmi_display_set_timing,
 
+	.read_edid		= hdmi_read_edid,
+
 	.hdmi = {
-		.read_edid		= hdmi_read_edid,
 		.set_infoframe		= hdmi_set_infoframe,
 		.set_hdmi_mode		= hdmi_set_hdmi_mode,
 	},

commit 43f7078f6b6f8fed8edfbbdeff83e276306e5e6e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:34:53 2018 +0200

    drm/omap: dss: Remove the dss_mgr_(dis)connect() operations
    
    The dss_mgr .connect() and .disconnect() are implemented as no-op in
    omapdrm. The operations are unneeded, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d5860438ddd9..889c31745492 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -438,15 +438,9 @@ static int hdmi_connect(struct omap_dss_device *src,
 {
 	int r;
 
-	r = dss_mgr_connect(dst);
-	if (r)
-		return r;
-
 	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r) {
-		dss_mgr_disconnect(dst);
+	if (r)
 		return r;
-	}
 
 	dst->dispc_channel_connected = true;
 	return 0;
@@ -458,8 +452,6 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 	dst->dispc_channel_connected = false;
 
 	omapdss_device_disconnect(dst, dst->next);
-
-	dss_mgr_disconnect(dst);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 0f37938c7c432c7737d85940475bcbd3c362447e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:28:18 2018 +0200

    drm/omap: Set dispc_channel_connect from DSS output connect handlers
    
    The omap_dss_device.dispc_channel_connect field is used by DSS outputs
    to fail the .enable() operation if they're not connected. Set the field
    directly from the (dis)connect handlers of the DSS outputs instead of
    going through the CRTC dss_mgr operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index f7e15edc05fc..d5860438ddd9 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -448,12 +448,15 @@ static int hdmi_connect(struct omap_dss_device *src,
 		return r;
 	}
 
+	dst->dispc_channel_connected = true;
 	return 0;
 }
 
 static void hdmi_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
+	dst->dispc_channel_connected = false;
+
 	omapdss_device_disconnect(dst, dst->next);
 
 	dss_mgr_disconnect(dst);

commit 3be0f15bd6e94aa17a571020704bde413342e8eb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 01:51:31 2018 +0200

    drm/omap: dss: Merge two disconnection helpers
    
    To simplify the pipeline disconnection handling merge the
    omapdss_device_disconnect() and omapdss_output_unset_device() functions.
    The device state check is now called for every device in the pipeline,
    extending this sanity check coverage.
    
    There is no need to return an error from omapdss_device_disconnect()
    when the check fails, as omapdss_output_unset_device() used to do, given
    that we can't prevent disconnection due to device unbinding (the return
    value of omapdss_output_unset_device() is never checked in the current
    code for that reason).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d8592d02a58d..f7e15edc05fc 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -455,7 +455,6 @@ static void hdmi_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
 	omapdss_device_disconnect(dst, dst->next);
-	omapdss_output_unset_device(dst);
 
 	dss_mgr_disconnect(dst);
 }

commit 713165561b7e372cd21f34bfeb82188361569f74
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 01:25:13 2018 +0200

    drm/omap: dss: Move display type validation to initialization time
    
    The display type is validated when the display is connected to the DSS
    output. We already have all the information we need for validation when
    initializing the outputs. Move validation to output initialization to
    simplify pipeline connection handling.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index beb70b1fab94..d8592d02a58d 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -442,24 +442,13 @@ static int hdmi_connect(struct omap_dss_device *src,
 	if (r)
 		return r;
 
-	r = omapdss_output_set_device(dst, dst->next);
+	r = omapdss_device_connect(dst->dss, dst, dst->next);
 	if (r) {
-		DSSERR("failed to connect output to new device: %s\n",
-				dst->name);
-		goto err_mgr_disconnect;
+		dss_mgr_disconnect(dst);
+		return r;
 	}
 
-	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r)
-		goto err_output_unset;
-
 	return 0;
-
-err_output_unset:
-	omapdss_output_unset_device(dst);
-err_mgr_disconnect:
-	dss_mgr_disconnect(dst);
-	return r;
 }
 
 static void hdmi_disconnect(struct omap_dss_device *src,
@@ -709,6 +698,7 @@ static const struct component_ops hdmi5_component_ops = {
 static int hdmi5_init_output(struct omap_hdmi *hdmi)
 {
 	struct omap_dss_device *out = &hdmi->output;
+	int r;
 
 	out->dev = &hdmi->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_HDMI;
@@ -726,6 +716,13 @@ static int hdmi5_init_output(struct omap_hdmi *hdmi)
 		return PTR_ERR(out->next);
 	}
 
+	r = omapdss_output_validate(out);
+	if (r) {
+		omapdss_device_put(out->next);
+		out->next = NULL;
+		return r;
+	}
+
 	omapdss_device_register(out);
 
 	return 0;

commit 511afb44d72aa7b6b871fa71f829afaaa27e84f0
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 23:42:36 2018 +0200

    drm/omap: Reverse direction of DSS device (dis)connect operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    To reconcile the omapdrm and omapdss drivers with the DRM bridge and
    panel model, we need to reverse the direction of the DSS device
    operations. Start with the connect and disconnect operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index db20a578091b..beb70b1fab94 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -433,32 +433,42 @@ static void hdmi_core_disable(struct omap_hdmi *hdmi)
 	mutex_unlock(&hdmi->lock);
 }
 
-static int hdmi_connect(struct omap_dss_device *dssdev,
-		struct omap_dss_device *dst)
+static int hdmi_connect(struct omap_dss_device *src,
+			struct omap_dss_device *dst)
 {
 	int r;
 
-	r = dss_mgr_connect(dssdev);
+	r = dss_mgr_connect(dst);
 	if (r)
 		return r;
 
-	r = omapdss_output_set_device(dssdev, dst);
+	r = omapdss_output_set_device(dst, dst->next);
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(dssdev);
-		return r;
+		goto err_mgr_disconnect;
 	}
 
+	r = omapdss_device_connect(dst->dss, dst, dst->next);
+	if (r)
+		goto err_output_unset;
+
 	return 0;
+
+err_output_unset:
+	omapdss_output_unset_device(dst);
+err_mgr_disconnect:
+	dss_mgr_disconnect(dst);
+	return r;
 }
 
-static void hdmi_disconnect(struct omap_dss_device *dssdev,
-		struct omap_dss_device *dst)
+static void hdmi_disconnect(struct omap_dss_device *src,
+			    struct omap_dss_device *dst)
 {
-	omapdss_output_unset_device(dssdev);
+	omapdss_device_disconnect(dst, dst->next);
+	omapdss_output_unset_device(dst);
 
-	dss_mgr_disconnect(dssdev);
+	dss_mgr_disconnect(dst);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 8a36357ae3b2d1b4647d20bc806d524c21132572
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Mar 5 00:10:55 2018 +0200

    drm/omap: dss: Get regulators at probe time
    
    Regulators for the DPI, DSI, HDMI, SDI and VENC outputs are all looked
    up when connecting the output omap_dss_device. There's no need to delay
    regulator handling to that time, get the regulators at probe time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 363bc5843e0f..db20a578091b 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -117,24 +117,6 @@ static irqreturn_t hdmi_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int hdmi_init_regulator(struct omap_hdmi *hdmi)
-{
-	struct regulator *reg;
-
-	if (hdmi->vdda_reg != NULL)
-		return 0;
-
-	reg = devm_regulator_get(&hdmi->pdev->dev, "vdda");
-	if (IS_ERR(reg)) {
-		DSSERR("can't get VDDA regulator\n");
-		return PTR_ERR(reg);
-	}
-
-	hdmi->vdda_reg = reg;
-
-	return 0;
-}
-
 static int hdmi_power_on_core(struct omap_hdmi *hdmi)
 {
 	int r;
@@ -454,13 +436,8 @@ static void hdmi_core_disable(struct omap_hdmi *hdmi)
 static int hdmi_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	int r;
 
-	r = hdmi_init_regulator(hdmi);
-	if (r)
-		return r;
-
 	r = dss_mgr_connect(dssdev);
 	if (r)
 		return r;
@@ -817,6 +794,14 @@ static int hdmi5_probe(struct platform_device *pdev)
 		goto err_free;
 	}
 
+	hdmi->vdda_reg = devm_regulator_get(&pdev->dev, "vdda");
+	if (IS_ERR(hdmi->vdda_reg)) {
+		r = PTR_ERR(hdmi->vdda_reg);
+		if (r != -EPROBE_DEFER)
+			DSSERR("can't get VDDA regulator\n");
+		goto err_free;
+	}
+
 	pm_runtime_enable(&pdev->dev);
 
 	r = hdmi5_init_output(hdmi);

commit a48bc6ac2c6cd85bc079fc859ab14ea844e812cd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 23:55:56 2018 +0200

    drm/omap: dss: Remove duplicated parameter to dss_mgr_(dis)connect()
    
    The dss_mgr_connect() and dss_mgr_disconnect() functions take two
    omap_dss_device pointers as parameters, which are always set to the same
    value by all callers. Remove the duplicated pointer.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 7af60ca4e7b2..363bc5843e0f 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -461,7 +461,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(&hdmi->output, dssdev);
+	r = dss_mgr_connect(dssdev);
 	if (r)
 		return r;
 
@@ -469,7 +469,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(&hdmi->output, dssdev);
+		dss_mgr_disconnect(dssdev);
 		return r;
 	}
 
@@ -479,11 +479,9 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 static void hdmi_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(&hdmi->output, dssdev);
+	dss_mgr_disconnect(dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 27d624527d99265c2df999af3615ff71c29d06f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 22:13:06 2018 +0200

    drm/omap: dss: Acquire next dssdev at probe time
    
    Look up the next dssdev at probe time based on device tree links for all
    DSS outputs and encoders. This will be used to reverse the order of the
    dssdev connect and disconnect call chains.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 64b45a612439..7af60ca4e7b2 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -721,7 +721,7 @@ static const struct component_ops hdmi5_component_ops = {
  * Probe & Remove, Suspend & Resume
  */
 
-static void hdmi5_init_output(struct omap_hdmi *hdmi)
+static int hdmi5_init_output(struct omap_hdmi *hdmi)
 {
 	struct omap_dss_device *out = &hdmi->output;
 
@@ -734,13 +734,24 @@ static void hdmi5_init_output(struct omap_hdmi *hdmi)
 	out->owner = THIS_MODULE;
 	out->of_ports = BIT(0);
 
+	out->next = omapdss_of_find_connected_device(out->dev->of_node, 0);
+	if (IS_ERR(out->next)) {
+		if (PTR_ERR(out->next) != -EPROBE_DEFER)
+			dev_err(out->dev, "failed to find video sink\n");
+		return PTR_ERR(out->next);
+	}
+
 	omapdss_device_register(out);
+
+	return 0;
 }
 
 static void hdmi5_uninit_output(struct omap_hdmi *hdmi)
 {
 	struct omap_dss_device *out = &hdmi->output;
 
+	if (out->next)
+		omapdss_device_put(out->next);
 	omapdss_device_unregister(out);
 }
 
@@ -810,7 +821,9 @@ static int hdmi5_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
-	hdmi5_init_output(hdmi);
+	r = hdmi5_init_output(hdmi);
+	if (r)
+		goto err_pm_disable;
 
 	r = component_add(&pdev->dev, &hdmi5_component_ops);
 	if (r)
@@ -820,6 +833,7 @@ static int hdmi5_probe(struct platform_device *pdev)
 
 err_uninit_output:
 	hdmi5_uninit_output(hdmi);
+err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
 err_free:
 	kfree(hdmi);

commit 5f031b4717349849e4d88edd09c9ec06a4729cfb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 3 18:52:59 2018 +0200

    drm/omap: dss: hdmi5: Move initialization code from bind to probe
    
    There's no reason to delay initialization of most of the driver (such as
    mapping memory I/O or enabling runtime PM) to the component bind
    handler. Perform as much of the initialization as possible at probe
    time, initializing at bind time only the parts that depends on the DSS.
    The cleanup code is moved from unbind to remove in a similar way.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 92ae561bf974..64b45a612439 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -544,53 +544,10 @@ static const struct omap_dss_device_ops hdmi_ops = {
 	},
 };
 
-static void hdmi_init_output(struct omap_hdmi *hdmi)
-{
-	struct omap_dss_device *out = &hdmi->output;
-
-	out->dev = &hdmi->pdev->dev;
-	out->id = OMAP_DSS_OUTPUT_HDMI;
-	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
-	out->name = "hdmi.0";
-	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
-	out->ops = &hdmi_ops;
-	out->owner = THIS_MODULE;
-	out->of_ports = BIT(0);
-
-	omapdss_device_register(out);
-}
-
-static void hdmi_uninit_output(struct omap_hdmi *hdmi)
-{
-	struct omap_dss_device *out = &hdmi->output;
-
-	omapdss_device_unregister(out);
-}
-
-static int hdmi_probe_of(struct omap_hdmi *hdmi)
-{
-	struct platform_device *pdev = hdmi->pdev;
-	struct device_node *node = pdev->dev.of_node;
-	struct device_node *ep;
-	int r;
-
-	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
-	if (!ep)
-		return 0;
-
-	r = hdmi_parse_lanes_of(pdev, ep, &hdmi->phy);
-	if (r)
-		goto err;
-
-	of_node_put(ep);
-	return 0;
-
-err:
-	of_node_put(ep);
-	return r;
-}
+/* -----------------------------------------------------------------------------
+ * Audio Callbacks
+ */
 
-/* Audio callbacks */
 static int hdmi_audio_startup(struct device *dev,
 			      void (*abort_cb)(struct device *dev))
 {
@@ -711,27 +668,116 @@ static int hdmi_audio_register(struct omap_hdmi *hdmi)
 	return 0;
 }
 
-/* HDMI HW IP initialisation */
+/* -----------------------------------------------------------------------------
+ * Component Bind & Unbind
+ */
+
 static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 {
-	struct platform_device *pdev = to_platform_device(dev);
 	struct dss_device *dss = dss_get_device(master);
-	struct omap_hdmi *hdmi;
+	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
 	int r;
+
+	hdmi->dss = dss;
+
+	r = hdmi_pll_init(dss, hdmi->pdev, &hdmi->pll, &hdmi->wp);
+	if (r)
+		return r;
+
+	r = hdmi_audio_register(hdmi);
+	if (r) {
+		DSSERR("Registering HDMI audio failed %d\n", r);
+		goto err_pll_uninit;
+	}
+
+	hdmi->debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
+						hdmi);
+
+	return 0;
+
+err_pll_uninit:
+	hdmi_pll_uninit(&hdmi->pll);
+	return r;
+}
+
+static void hdmi5_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
+
+	dss_debugfs_remove_file(hdmi->debugfs);
+
+	if (hdmi->audio_pdev)
+		platform_device_unregister(hdmi->audio_pdev);
+
+	hdmi_pll_uninit(&hdmi->pll);
+}
+
+static const struct component_ops hdmi5_component_ops = {
+	.bind	= hdmi5_bind,
+	.unbind	= hdmi5_unbind,
+};
+
+/* -----------------------------------------------------------------------------
+ * Probe & Remove, Suspend & Resume
+ */
+
+static void hdmi5_init_output(struct omap_hdmi *hdmi)
+{
+	struct omap_dss_device *out = &hdmi->output;
+
+	out->dev = &hdmi->pdev->dev;
+	out->id = OMAP_DSS_OUTPUT_HDMI;
+	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
+	out->name = "hdmi.0";
+	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
+	out->ops = &hdmi_ops;
+	out->owner = THIS_MODULE;
+	out->of_ports = BIT(0);
+
+	omapdss_device_register(out);
+}
+
+static void hdmi5_uninit_output(struct omap_hdmi *hdmi)
+{
+	struct omap_dss_device *out = &hdmi->output;
+
+	omapdss_device_unregister(out);
+}
+
+static int hdmi5_probe_of(struct omap_hdmi *hdmi)
+{
+	struct platform_device *pdev = hdmi->pdev;
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *ep;
+	int r;
+
+	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
+	if (!ep)
+		return 0;
+
+	r = hdmi_parse_lanes_of(pdev, ep, &hdmi->phy);
+	of_node_put(ep);
+	return r;
+}
+
+static int hdmi5_probe(struct platform_device *pdev)
+{
+	struct omap_hdmi *hdmi;
 	int irq;
+	int r;
 
 	hdmi = kzalloc(sizeof(*hdmi), GFP_KERNEL);
 	if (!hdmi)
 		return -ENOMEM;
 
 	hdmi->pdev = pdev;
-	hdmi->dss = dss;
+
 	dev_set_drvdata(&pdev->dev, hdmi);
 
 	mutex_init(&hdmi->lock);
 	spin_lock_init(&hdmi->audio_playing_lock);
 
-	r = hdmi_probe_of(hdmi);
+	r = hdmi5_probe_of(hdmi);
 	if (r)
 		goto err_free;
 
@@ -739,23 +785,19 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		goto err_free;
 
-	r = hdmi_pll_init(dss, pdev, &hdmi->pll, &hdmi->wp);
-	if (r)
-		goto err_free;
-
 	r = hdmi_phy_init(pdev, &hdmi->phy, 5);
 	if (r)
-		goto err_pll;
+		goto err_free;
 
 	r = hdmi5_core_init(pdev, &hdmi->core);
 	if (r)
-		goto err_pll;
+		goto err_free;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		DSSERR("platform_get_irq failed\n");
 		r = -ENODEV;
-		goto err_pll;
+		goto err_free;
 	}
 
 	r = devm_request_threaded_irq(&pdev->dev, irq,
@@ -763,65 +805,38 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 			IRQF_ONESHOT, "OMAP HDMI", hdmi);
 	if (r) {
 		DSSERR("HDMI IRQ request failed\n");
-		goto err_pll;
+		goto err_free;
 	}
 
 	pm_runtime_enable(&pdev->dev);
 
-	hdmi_init_output(hdmi);
+	hdmi5_init_output(hdmi);
 
-	r = hdmi_audio_register(hdmi);
-	if (r) {
-		DSSERR("Registering HDMI audio failed %d\n", r);
+	r = component_add(&pdev->dev, &hdmi5_component_ops);
+	if (r)
 		goto err_uninit_output;
-	}
-
-	hdmi->debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
-						hdmi);
 
 	return 0;
 
 err_uninit_output:
-	hdmi_uninit_output(hdmi);
+	hdmi5_uninit_output(hdmi);
 	pm_runtime_disable(&pdev->dev);
-err_pll:
-	hdmi_pll_uninit(&hdmi->pll);
 err_free:
 	kfree(hdmi);
 	return r;
 }
 
-static void hdmi5_unbind(struct device *dev, struct device *master, void *data)
+static int hdmi5_remove(struct platform_device *pdev)
 {
-	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
-
-	dss_debugfs_remove_file(hdmi->debugfs);
+	struct omap_hdmi *hdmi = platform_get_drvdata(pdev);
 
-	if (hdmi->audio_pdev)
-		platform_device_unregister(hdmi->audio_pdev);
-
-	hdmi_uninit_output(hdmi);
+	component_del(&pdev->dev, &hdmi5_component_ops);
 
-	hdmi_pll_uninit(&hdmi->pll);
+	hdmi5_uninit_output(hdmi);
 
-	pm_runtime_disable(dev);
+	pm_runtime_disable(&pdev->dev);
 
 	kfree(hdmi);
-}
-
-static const struct component_ops hdmi5_component_ops = {
-	.bind	= hdmi5_bind,
-	.unbind	= hdmi5_unbind,
-};
-
-static int hdmi5_probe(struct platform_device *pdev)
-{
-	return component_add(&pdev->dev, &hdmi5_component_ops);
-}
-
-static int hdmi5_remove(struct platform_device *pdev)
-{
-	component_del(&pdev->dev, &hdmi5_component_ops);
 	return 0;
 }
 

commit 66aacfe22d53137eab511b3f4d674ddd40a7b1ac
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 21:38:21 2018 +0200

    drm/omap: dss: Cleanup error paths in output init functions
    
    Rename the jump labels according to the cleanup they perform, not the
    location they're accessed from, and move functions from error checks to
    cleanup paths, and move reference handling to simplify cleanup.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index e5d23dd19f99..92ae561bf974 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -773,9 +773,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	r = hdmi_audio_register(hdmi);
 	if (r) {
 		DSSERR("Registering HDMI audio failed %d\n", r);
-		hdmi_uninit_output(hdmi);
-		pm_runtime_disable(&pdev->dev);
-		return r;
+		goto err_uninit_output;
 	}
 
 	hdmi->debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
@@ -783,6 +781,9 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 
 	return 0;
 
+err_uninit_output:
+	hdmi_uninit_output(hdmi);
+	pm_runtime_disable(&pdev->dev);
 err_pll:
 	hdmi_pll_uninit(&hdmi->pll);
 err_free:

commit 4e20bda68e01f723d7fcc4e7d55a4afc78223fb7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 21:49:28 2018 +0200

    drm/omap: dss: Replace omap_dss_device port number with bitmask
    
    The omap_dss_device port_num field stores the DT port number associated
    with the device. The field is used in different ways depending on the
    device type:
    
    - For DPI outputs, the port number is used as an identifier of the DPI
    instance
    
    - For sources, the port number is used to look up the omap_dss_device by
    DT port node
    
    As omap_dss_device instances are only looked up as sources by sinks,
    setting the field to the number of the source port works for both use
    cases.
    
    However, to enable looking up sinks, we need to record all the ports
    associated with an omap_dss_device. Do so by turning the port_num field
    into an of_ports bitmask. For DPI outputs the port number is
    additionally stored in the dpi_data structure as the output ID.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index ef4a48f397d2..e5d23dd19f99 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -555,6 +555,7 @@ static void hdmi_init_output(struct omap_hdmi *hdmi)
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
+	out->of_ports = BIT(0);
 
 	omapdss_device_register(out);
 }

commit de57e9dbc1454704a54190cb3b544b841c34301a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 01:25:32 2018 +0200

    drm/omap: dss: Remove output devices list
    
    The output devices list isn't used anymore, all output devices are
    accessed through the global devices list. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 86b18ccb8d24..ef4a48f397d2 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -556,14 +556,14 @@ static void hdmi_init_output(struct omap_hdmi *hdmi)
 	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
 
-	omapdss_register_output(out);
+	omapdss_device_register(out);
 }
 
 static void hdmi_uninit_output(struct omap_hdmi *hdmi)
 {
 	struct omap_dss_device *out = &hdmi->output;
 
-	omapdss_unregister_output(out);
+	omapdss_device_unregister(out);
 }
 
 static int hdmi_probe_of(struct omap_hdmi *hdmi)

commit fb5571717c24c264518aaaf1ab4ec4df73e4cebd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 17:30:30 2018 +0200

    drm/omap: dss: Move src and dst check and set to connection handlers
    
    The encoders duplicate the same omap_dss_device src and dst fields set
    and checks in their connect and disconnect handlers. Move the code to
    the connect and disconnect wrappers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 45d2eacedb2a..86b18ccb8d24 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -481,11 +481,6 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 {
 	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 
-	WARN_ON(dst != dssdev->dst);
-
-	if (dst != dssdev->dst)
-		return;
-
 	omapdss_output_unset_device(dssdev);
 
 	dss_mgr_disconnect(&hdmi->output, dssdev);

commit b93109d7dc9e15649e1cf18281f02d8b4a102584
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 15:58:13 2018 +0200

    drm/omap: dss: Move common device operations to common structure
    
    The various types of omapdss_*_ops structures define multiple operations
    that are not specific to a bus type. To simplify the code and remove
    dependencies on specific bus types move those operations to a common
    structure. Operations that are specific to a bus type are kept in the
    specialized ops structures.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 8e9b3a24b2ab..45d2eacedb2a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -532,7 +532,7 @@ static int hdmi_set_hdmi_mode(struct omap_dss_device *dssdev,
 	return 0;
 }
 
-static const struct omapdss_hdmi_ops hdmi_ops = {
+static const struct omap_dss_device_ops hdmi_ops = {
 	.connect		= hdmi_connect,
 	.disconnect		= hdmi_disconnect,
 
@@ -542,9 +542,11 @@ static const struct omapdss_hdmi_ops hdmi_ops = {
 	.check_timings		= hdmi_display_check_timing,
 	.set_timings		= hdmi_display_set_timing,
 
-	.read_edid		= hdmi_read_edid,
-	.set_infoframe		= hdmi_set_infoframe,
-	.set_hdmi_mode		= hdmi_set_hdmi_mode,
+	.hdmi = {
+		.read_edid		= hdmi_read_edid,
+		.set_infoframe		= hdmi_set_infoframe,
+		.set_hdmi_mode		= hdmi_set_hdmi_mode,
+	},
 };
 
 static void hdmi_init_output(struct omap_hdmi *hdmi)
@@ -556,7 +558,7 @@ static void hdmi_init_output(struct omap_hdmi *hdmi)
 	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
 	out->name = "hdmi.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
-	out->ops.hdmi = &hdmi_ops;
+	out->ops = &hdmi_ops;
 	out->owner = THIS_MODULE;
 
 	omapdss_register_output(out);

commit 9976782f331b0d54710fddd89848b9b6e22746d4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 27 20:29:21 2018 +0200

    drm/omap: dss: Remove DSS encoders get_timings operation
    
    The get_timings operation from DSS encoders (not to be confused with the
    identically named operation in omap_dss_driver) is never called. Remove
    it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index ae1a001d1b83..8e9b3a24b2ab 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -293,14 +293,6 @@ static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
 	mutex_unlock(&hdmi->lock);
 }
 
-static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
-				     struct videomode *vm)
-{
-	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
-
-	*vm = hdmi->cfg.vm;
-}
-
 static int hdmi_dump_regs(struct seq_file *s, void *p)
 {
 	struct omap_hdmi *hdmi = s->private;
@@ -549,7 +541,6 @@ static const struct omapdss_hdmi_ops hdmi_ops = {
 
 	.check_timings		= hdmi_display_check_timing,
 	.set_timings		= hdmi_display_set_timing,
-	.get_timings		= hdmi_display_get_timings,
 
 	.read_edid		= hdmi_read_edid,
 	.set_infoframe		= hdmi_set_infoframe,

commit 77eeac24b10fc84d3ffd5b11a897dff88dde244d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Mar 29 13:40:36 2018 +0300

    drm/omap: fix uninitialized ret variable
    
    audio_config function for both HDMI4 and HDMI5 return uninitialized
    value as the error code if the display is not currently enabled. For
    some reason this has not caused any issues.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180329104038.29154-1-tomi.valkeinen@ti.com
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d28da9ac3e90..ae1a001d1b83 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -671,7 +671,7 @@ static int hdmi_audio_config(struct device *dev,
 			     struct omap_dss_audio *dss_audio)
 {
 	struct omap_hdmi *hd = dev_get_drvdata(dev);
-	int ret;
+	int ret = 0;
 
 	mutex_lock(&hd->lock);
 

commit c1899cb368c1d280af48661c6edaa975cf653533
Author: Jyri Sarha <jsarha@ti.com>
Date:   Thu Mar 16 12:05:04 2017 +0200

    drm/omap: Allow HDMI audio setup even if we do not have video configured
    
    Allow HDMI audio setup even if we do not have video configured. Audio
    will get configured at the same time with video if the video is
    configured soon enough. If it is not the audio DMA will timeout in
    couple of seconds and audio playback will be aborted.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 4a0178ab8016..d28da9ac3e90 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -606,21 +606,16 @@ static int hdmi_audio_startup(struct device *dev,
 			      void (*abort_cb)(struct device *dev))
 {
 	struct omap_hdmi *hd = dev_get_drvdata(dev);
-	int ret = 0;
 
 	mutex_lock(&hd->lock);
 
-	if (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {
-		ret = -EPERM;
-		goto out;
-	}
+	WARN_ON(hd->audio_abort_cb != NULL);
 
 	hd->audio_abort_cb = abort_cb;
 
-out:
 	mutex_unlock(&hd->lock);
 
-	return ret;
+	return 0;
 }
 
 static int hdmi_audio_shutdown(struct device *dev)
@@ -641,12 +636,14 @@ static int hdmi_audio_start(struct device *dev)
 	struct omap_hdmi *hd = dev_get_drvdata(dev);
 	unsigned long flags;
 
-	WARN_ON(!hdmi_mode_has_audio(&hd->cfg));
-
 	spin_lock_irqsave(&hd->audio_playing_lock, flags);
 
-	if (hd->display_enabled)
+	if (hd->display_enabled) {
+		if (!hdmi_mode_has_audio(&hd->cfg))
+			DSSERR("%s: Video mode does not support audio\n",
+			       __func__);
 		hdmi_start_audio_stream(hd);
+	}
 	hd->audio_playing = true;
 
 	spin_unlock_irqrestore(&hd->audio_playing_lock, flags);
@@ -658,7 +655,8 @@ static void hdmi_audio_stop(struct device *dev)
 	struct omap_hdmi *hd = dev_get_drvdata(dev);
 	unsigned long flags;
 
-	WARN_ON(!hdmi_mode_has_audio(&hd->cfg));
+	if (!hdmi_mode_has_audio(&hd->cfg))
+		DSSERR("%s: Video mode does not support audio\n", __func__);
 
 	spin_lock_irqsave(&hd->audio_playing_lock, flags);
 
@@ -677,18 +675,15 @@ static int hdmi_audio_config(struct device *dev,
 
 	mutex_lock(&hd->lock);
 
-	if (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {
-		ret = -EPERM;
-		goto out;
+	if (hd->display_enabled) {
+		ret = hdmi5_audio_config(&hd->core, &hd->wp, dss_audio,
+					 hd->cfg.vm.pixelclock);
+		if (ret)
+			goto out;
 	}
 
-	ret = hdmi5_audio_config(&hd->core, &hd->wp, dss_audio,
-				 hd->cfg.vm.pixelclock);
-
-	if (!ret) {
-		hd->audio_configured = true;
-		hd->audio_config = *dss_audio;
-	}
+	hd->audio_configured = true;
+	hd->audio_config = *dss_audio;
 out:
 	mutex_unlock(&hd->lock);
 

commit c44991ce21bef5831b28b36f1da87dceb85bef75
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:46 2018 +0200

    drm: omapdrm: hdmi5: Allocate the omap_hdmi data structure dynamically
    
    The omap_hdmi private data structure is currently stored as a global
    variable. While no platform with multiple HDMI5 encoders currently
    exists nor is planned, this doesn't comply with the kernel device model
    and should thus be fixed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a83d70144f85..4a0178ab8016 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -46,15 +46,13 @@
 #include "hdmi5_core.h"
 #include "dss.h"
 
-static struct omap_hdmi hdmi;
-
-static int hdmi_runtime_get(void)
+static int hdmi_runtime_get(struct omap_hdmi *hdmi)
 {
 	int r;
 
 	DSSDBG("hdmi_runtime_get\n");
 
-	r = pm_runtime_get_sync(&hdmi.pdev->dev);
+	r = pm_runtime_get_sync(&hdmi->pdev->dev);
 	WARN_ON(r < 0);
 	if (r < 0)
 		return r;
@@ -62,19 +60,20 @@ static int hdmi_runtime_get(void)
 	return 0;
 }
 
-static void hdmi_runtime_put(void)
+static void hdmi_runtime_put(struct omap_hdmi *hdmi)
 {
 	int r;
 
 	DSSDBG("hdmi_runtime_put\n");
 
-	r = pm_runtime_put_sync(&hdmi.pdev->dev);
+	r = pm_runtime_put_sync(&hdmi->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
 static irqreturn_t hdmi_irq_handler(int irq, void *data)
 {
-	struct hdmi_wp_data *wp = data;
+	struct omap_hdmi *hdmi = data;
+	struct hdmi_wp_data *wp = &hdmi->wp;
 	u32 irqstatus;
 
 	irqstatus = hdmi_wp_get_irqstatus(wp);
@@ -97,17 +96,17 @@ static irqreturn_t hdmi_irq_handler(int irq, void *data)
 		 * setting the PHY to LDOON. To ignore those, we force the RXDET
 		 * line to 0 until the PHY power state has been changed.
 		 */
-		v = hdmi_read_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL);
+		v = hdmi_read_reg(hdmi->phy.base, HDMI_TXPHY_PAD_CFG_CTRL);
 		v = FLD_MOD(v, 1, 15, 15); /* FORCE_RXDET_HIGH */
 		v = FLD_MOD(v, 0, 14, 7); /* RXDET_LINE */
-		hdmi_write_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, v);
+		hdmi_write_reg(hdmi->phy.base, HDMI_TXPHY_PAD_CFG_CTRL, v);
 
 		hdmi_wp_set_irqstatus(wp, HDMI_IRQ_LINK_CONNECT |
 				HDMI_IRQ_LINK_DISCONNECT);
 
 		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);
 
-		REG_FLD_MOD(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, 0, 15, 15);
+		REG_FLD_MOD(hdmi->phy.base, HDMI_TXPHY_PAD_CFG_CTRL, 0, 15, 15);
 
 	} else if (irqstatus & HDMI_IRQ_LINK_CONNECT) {
 		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_TXON);
@@ -118,69 +117,69 @@ static irqreturn_t hdmi_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int hdmi_init_regulator(void)
+static int hdmi_init_regulator(struct omap_hdmi *hdmi)
 {
 	struct regulator *reg;
 
-	if (hdmi.vdda_reg != NULL)
+	if (hdmi->vdda_reg != NULL)
 		return 0;
 
-	reg = devm_regulator_get(&hdmi.pdev->dev, "vdda");
+	reg = devm_regulator_get(&hdmi->pdev->dev, "vdda");
 	if (IS_ERR(reg)) {
 		DSSERR("can't get VDDA regulator\n");
 		return PTR_ERR(reg);
 	}
 
-	hdmi.vdda_reg = reg;
+	hdmi->vdda_reg = reg;
 
 	return 0;
 }
 
-static int hdmi_power_on_core(struct omap_dss_device *dssdev)
+static int hdmi_power_on_core(struct omap_hdmi *hdmi)
 {
 	int r;
 
-	r = regulator_enable(hdmi.vdda_reg);
+	r = regulator_enable(hdmi->vdda_reg);
 	if (r)
 		return r;
 
-	r = hdmi_runtime_get();
+	r = hdmi_runtime_get(hdmi);
 	if (r)
 		goto err_runtime_get;
 
 	/* Make selection of HDMI in DSS */
-	dss_select_hdmi_venc_clk_source(hdmi.dss, DSS_HDMI_M_PCLK);
+	dss_select_hdmi_venc_clk_source(hdmi->dss, DSS_HDMI_M_PCLK);
 
-	hdmi.core_enabled = true;
+	hdmi->core_enabled = true;
 
 	return 0;
 
 err_runtime_get:
-	regulator_disable(hdmi.vdda_reg);
+	regulator_disable(hdmi->vdda_reg);
 
 	return r;
 }
 
-static void hdmi_power_off_core(struct omap_dss_device *dssdev)
+static void hdmi_power_off_core(struct omap_hdmi *hdmi)
 {
-	hdmi.core_enabled = false;
+	hdmi->core_enabled = false;
 
-	hdmi_runtime_put();
-	regulator_disable(hdmi.vdda_reg);
+	hdmi_runtime_put(hdmi);
+	regulator_disable(hdmi->vdda_reg);
 }
 
-static int hdmi_power_on_full(struct omap_dss_device *dssdev)
+static int hdmi_power_on_full(struct omap_hdmi *hdmi)
 {
 	int r;
 	struct videomode *vm;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned int pc;
 
-	r = hdmi_power_on_core(dssdev);
+	r = hdmi_power_on_core(hdmi);
 	if (r)
 		return r;
 
-	vm = &hdmi.cfg.vm;
+	vm = &hdmi->cfg.vm;
 
 	DSSDBG("hdmi_power_on hactive= %d vactive = %d\n", vm->hactive,
 	       vm->vactive);
@@ -192,87 +191,89 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	/* DSS_HDMI_TCLK is bitclk / 10 */
 	pc *= 10;
 
-	dss_pll_calc_b(&hdmi.pll.pll, clk_get_rate(hdmi.pll.pll.clkin),
+	dss_pll_calc_b(&hdmi->pll.pll, clk_get_rate(hdmi->pll.pll.clkin),
 		pc, &hdmi_cinfo);
 
 	/* disable and clear irqs */
-	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
-	hdmi_wp_set_irqstatus(&hdmi.wp,
-			hdmi_wp_get_irqstatus(&hdmi.wp));
+	hdmi_wp_clear_irqenable(&hdmi->wp, 0xffffffff);
+	hdmi_wp_set_irqstatus(&hdmi->wp,
+			hdmi_wp_get_irqstatus(&hdmi->wp));
 
-	r = dss_pll_enable(&hdmi.pll.pll);
+	r = dss_pll_enable(&hdmi->pll.pll);
 	if (r) {
 		DSSERR("Failed to enable PLL\n");
 		goto err_pll_enable;
 	}
 
-	r = dss_pll_set_config(&hdmi.pll.pll, &hdmi_cinfo);
+	r = dss_pll_set_config(&hdmi->pll.pll, &hdmi_cinfo);
 	if (r) {
 		DSSERR("Failed to configure PLL\n");
 		goto err_pll_cfg;
 	}
 
-	r = hdmi_phy_configure(&hdmi.phy, hdmi_cinfo.clkdco,
+	r = hdmi_phy_configure(&hdmi->phy, hdmi_cinfo.clkdco,
 		hdmi_cinfo.clkout[0]);
 	if (r) {
 		DSSDBG("Failed to start PHY\n");
 		goto err_phy_cfg;
 	}
 
-	r = hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_LDOON);
+	r = hdmi_wp_set_phy_pwr(&hdmi->wp, HDMI_PHYPWRCMD_LDOON);
 	if (r)
 		goto err_phy_pwr;
 
-	hdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);
+	hdmi5_configure(&hdmi->core, &hdmi->wp, &hdmi->cfg);
 
 	/* tv size */
-	dss_mgr_set_timings(&hdmi.output, vm);
+	dss_mgr_set_timings(&hdmi->output, vm);
 
-	r = dss_mgr_enable(&hdmi.output);
+	r = dss_mgr_enable(&hdmi->output);
 	if (r)
 		goto err_mgr_enable;
 
-	r = hdmi_wp_video_start(&hdmi.wp);
+	r = hdmi_wp_video_start(&hdmi->wp);
 	if (r)
 		goto err_vid_enable;
 
-	hdmi_wp_set_irqenable(&hdmi.wp,
+	hdmi_wp_set_irqenable(&hdmi->wp,
 			HDMI_IRQ_LINK_CONNECT | HDMI_IRQ_LINK_DISCONNECT);
 
 	return 0;
 
 err_vid_enable:
-	dss_mgr_disable(&hdmi.output);
+	dss_mgr_disable(&hdmi->output);
 err_mgr_enable:
-	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
+	hdmi_wp_set_phy_pwr(&hdmi->wp, HDMI_PHYPWRCMD_OFF);
 err_phy_pwr:
 err_phy_cfg:
 err_pll_cfg:
-	dss_pll_disable(&hdmi.pll.pll);
+	dss_pll_disable(&hdmi->pll.pll);
 err_pll_enable:
-	hdmi_power_off_core(dssdev);
+	hdmi_power_off_core(hdmi);
 	return -EIO;
 }
 
-static void hdmi_power_off_full(struct omap_dss_device *dssdev)
+static void hdmi_power_off_full(struct omap_hdmi *hdmi)
 {
-	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
+	hdmi_wp_clear_irqenable(&hdmi->wp, 0xffffffff);
 
-	hdmi_wp_video_stop(&hdmi.wp);
+	hdmi_wp_video_stop(&hdmi->wp);
 
-	dss_mgr_disable(&hdmi.output);
+	dss_mgr_disable(&hdmi->output);
 
-	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
+	hdmi_wp_set_phy_pwr(&hdmi->wp, HDMI_PHYPWRCMD_OFF);
 
-	dss_pll_disable(&hdmi.pll.pll);
+	dss_pll_disable(&hdmi->pll.pll);
 
-	hdmi_power_off_core(dssdev);
+	hdmi_power_off_core(hdmi);
 }
 
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 				     struct videomode *vm)
 {
-	if (!dispc_mgr_timings_ok(hdmi.dss->dispc, dssdev->dispc_channel, vm))
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
+	if (!dispc_mgr_timings_ok(hdmi->dss->dispc, dssdev->dispc_channel, vm))
 		return -EINVAL;
 
 	return 0;
@@ -281,67 +282,73 @@ static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
 				    struct videomode *vm)
 {
-	mutex_lock(&hdmi.lock);
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
+	mutex_lock(&hdmi->lock);
 
-	hdmi.cfg.vm = *vm;
+	hdmi->cfg.vm = *vm;
 
-	dispc_set_tv_pclk(hdmi.dss->dispc, vm->pixelclock);
+	dispc_set_tv_pclk(hdmi->dss->dispc, vm->pixelclock);
 
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 }
 
 static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
 				     struct videomode *vm)
 {
-	*vm = hdmi.cfg.vm;
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
+	*vm = hdmi->cfg.vm;
 }
 
 static int hdmi_dump_regs(struct seq_file *s, void *p)
 {
-	mutex_lock(&hdmi.lock);
+	struct omap_hdmi *hdmi = s->private;
+
+	mutex_lock(&hdmi->lock);
 
-	if (hdmi_runtime_get()) {
-		mutex_unlock(&hdmi.lock);
+	if (hdmi_runtime_get(hdmi)) {
+		mutex_unlock(&hdmi->lock);
 		return 0;
 	}
 
-	hdmi_wp_dump(&hdmi.wp, s);
-	hdmi_pll_dump(&hdmi.pll, s);
-	hdmi_phy_dump(&hdmi.phy, s);
-	hdmi5_core_dump(&hdmi.core, s);
+	hdmi_wp_dump(&hdmi->wp, s);
+	hdmi_pll_dump(&hdmi->pll, s);
+	hdmi_phy_dump(&hdmi->phy, s);
+	hdmi5_core_dump(&hdmi->core, s);
 
-	hdmi_runtime_put();
-	mutex_unlock(&hdmi.lock);
+	hdmi_runtime_put(hdmi);
+	mutex_unlock(&hdmi->lock);
 	return 0;
 }
 
-static int read_edid(u8 *buf, int len)
+static int read_edid(struct omap_hdmi *hdmi, u8 *buf, int len)
 {
 	int r;
 	int idlemode;
 
-	mutex_lock(&hdmi.lock);
+	mutex_lock(&hdmi->lock);
 
-	r = hdmi_runtime_get();
+	r = hdmi_runtime_get(hdmi);
 	BUG_ON(r);
 
-	idlemode = REG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	idlemode = REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
 	/* No-idle mode */
-	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
 
-	r = hdmi5_read_edid(&hdmi.core,  buf, len);
+	r = hdmi5_read_edid(&hdmi->core,  buf, len);
 
-	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
+	REG_FLD_MOD(hdmi->wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
 
-	hdmi_runtime_put();
-	mutex_unlock(&hdmi.lock);
+	hdmi_runtime_put(hdmi);
+	mutex_unlock(&hdmi->lock);
 
 	return r;
 }
 
 static void hdmi_start_audio_stream(struct omap_hdmi *hd)
 {
-	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+	REG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
 	hdmi_wp_audio_enable(&hd->wp, true);
 	hdmi_wp_audio_core_req_enable(&hd->wp, true);
 }
@@ -355,111 +362,114 @@ static void hdmi_stop_audio_stream(struct omap_hdmi *hd)
 
 static int hdmi_display_enable(struct omap_dss_device *dssdev)
 {
-	struct omap_dss_device *out = &hdmi.output;
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	unsigned long flags;
 	int r = 0;
 
 	DSSDBG("ENTER hdmi_display_enable\n");
 
-	mutex_lock(&hdmi.lock);
+	mutex_lock(&hdmi->lock);
 
-	if (!out->dispc_channel_connected) {
+	if (!dssdev->dispc_channel_connected) {
 		DSSERR("failed to enable display: no output/manager\n");
 		r = -ENODEV;
 		goto err0;
 	}
 
-	r = hdmi_power_on_full(dssdev);
+	r = hdmi_power_on_full(hdmi);
 	if (r) {
 		DSSERR("failed to power on device\n");
 		goto err0;
 	}
 
-	if (hdmi.audio_configured) {
-		r = hdmi5_audio_config(&hdmi.core, &hdmi.wp, &hdmi.audio_config,
-				       hdmi.cfg.vm.pixelclock);
+	if (hdmi->audio_configured) {
+		r = hdmi5_audio_config(&hdmi->core, &hdmi->wp,
+				       &hdmi->audio_config,
+				       hdmi->cfg.vm.pixelclock);
 		if (r) {
 			DSSERR("Error restoring audio configuration: %d", r);
-			hdmi.audio_abort_cb(&hdmi.pdev->dev);
-			hdmi.audio_configured = false;
+			hdmi->audio_abort_cb(&hdmi->pdev->dev);
+			hdmi->audio_configured = false;
 		}
 	}
 
-	spin_lock_irqsave(&hdmi.audio_playing_lock, flags);
-	if (hdmi.audio_configured && hdmi.audio_playing)
-		hdmi_start_audio_stream(&hdmi);
-	hdmi.display_enabled = true;
-	spin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);
+	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
+	if (hdmi->audio_configured && hdmi->audio_playing)
+		hdmi_start_audio_stream(hdmi);
+	hdmi->display_enabled = true;
+	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
 
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 	return 0;
 
 err0:
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 	return r;
 }
 
 static void hdmi_display_disable(struct omap_dss_device *dssdev)
 {
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	unsigned long flags;
 
 	DSSDBG("Enter hdmi_display_disable\n");
 
-	mutex_lock(&hdmi.lock);
+	mutex_lock(&hdmi->lock);
 
-	spin_lock_irqsave(&hdmi.audio_playing_lock, flags);
-	hdmi_stop_audio_stream(&hdmi);
-	hdmi.display_enabled = false;
-	spin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);
+	spin_lock_irqsave(&hdmi->audio_playing_lock, flags);
+	hdmi_stop_audio_stream(hdmi);
+	hdmi->display_enabled = false;
+	spin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);
 
-	hdmi_power_off_full(dssdev);
+	hdmi_power_off_full(hdmi);
 
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 }
 
-static int hdmi_core_enable(struct omap_dss_device *dssdev)
+static int hdmi_core_enable(struct omap_hdmi *hdmi)
 {
 	int r = 0;
 
 	DSSDBG("ENTER omapdss_hdmi_core_enable\n");
 
-	mutex_lock(&hdmi.lock);
+	mutex_lock(&hdmi->lock);
 
-	r = hdmi_power_on_core(dssdev);
+	r = hdmi_power_on_core(hdmi);
 	if (r) {
 		DSSERR("failed to power on device\n");
 		goto err0;
 	}
 
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 	return 0;
 
 err0:
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 	return r;
 }
 
-static void hdmi_core_disable(struct omap_dss_device *dssdev)
+static void hdmi_core_disable(struct omap_hdmi *hdmi)
 {
 	DSSDBG("Enter omapdss_hdmi_core_disable\n");
 
-	mutex_lock(&hdmi.lock);
+	mutex_lock(&hdmi->lock);
 
-	hdmi_power_off_core(dssdev);
+	hdmi_power_off_core(hdmi);
 
-	mutex_unlock(&hdmi.lock);
+	mutex_unlock(&hdmi->lock);
 }
 
 static int hdmi_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	int r;
 
-	r = hdmi_init_regulator();
+	r = hdmi_init_regulator(hdmi);
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(&hdmi.output, dssdev);
+	r = dss_mgr_connect(&hdmi->output, dssdev);
 	if (r)
 		return r;
 
@@ -467,7 +477,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(&hdmi.output, dssdev);
+		dss_mgr_disconnect(&hdmi->output, dssdev);
 		return r;
 	}
 
@@ -477,6 +487,8 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 static void hdmi_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -484,27 +496,28 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(&hdmi.output, dssdev);
+	dss_mgr_disconnect(&hdmi->output, dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,
 		u8 *edid, int len)
 {
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
 	bool need_enable;
 	int r;
 
-	need_enable = hdmi.core_enabled == false;
+	need_enable = hdmi->core_enabled == false;
 
 	if (need_enable) {
-		r = hdmi_core_enable(dssdev);
+		r = hdmi_core_enable(hdmi);
 		if (r)
 			return r;
 	}
 
-	r = read_edid(edid, len);
+	r = read_edid(hdmi, edid, len);
 
 	if (need_enable)
-		hdmi_core_disable(dssdev);
+		hdmi_core_disable(hdmi);
 
 	return r;
 }
@@ -512,14 +525,18 @@ static int hdmi_read_edid(struct omap_dss_device *dssdev,
 static int hdmi_set_infoframe(struct omap_dss_device *dssdev,
 		const struct hdmi_avi_infoframe *avi)
 {
-	hdmi.cfg.infoframe = *avi;
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
+	hdmi->cfg.infoframe = *avi;
 	return 0;
 }
 
 static int hdmi_set_hdmi_mode(struct omap_dss_device *dssdev,
 		bool hdmi_mode)
 {
-	hdmi.cfg.hdmi_dvi_mode = hdmi_mode ? HDMI_HDMI : HDMI_DVI;
+	struct omap_hdmi *hdmi = dssdev_to_hdmi(dssdev);
+
+	hdmi->cfg.hdmi_dvi_mode = hdmi_mode ? HDMI_HDMI : HDMI_DVI;
 	return 0;
 }
 
@@ -539,11 +556,11 @@ static const struct omapdss_hdmi_ops hdmi_ops = {
 	.set_hdmi_mode		= hdmi_set_hdmi_mode,
 };
 
-static void hdmi_init_output(struct platform_device *pdev)
+static void hdmi_init_output(struct omap_hdmi *hdmi)
 {
-	struct omap_dss_device *out = &hdmi.output;
+	struct omap_dss_device *out = &hdmi->output;
 
-	out->dev = &pdev->dev;
+	out->dev = &hdmi->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_HDMI;
 	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
 	out->name = "hdmi.0";
@@ -554,15 +571,16 @@ static void hdmi_init_output(struct platform_device *pdev)
 	omapdss_register_output(out);
 }
 
-static void hdmi_uninit_output(struct platform_device *pdev)
+static void hdmi_uninit_output(struct omap_hdmi *hdmi)
 {
-	struct omap_dss_device *out = &hdmi.output;
+	struct omap_dss_device *out = &hdmi->output;
 
 	omapdss_unregister_output(out);
 }
 
-static int hdmi_probe_of(struct platform_device *pdev)
+static int hdmi_probe_of(struct omap_hdmi *hdmi)
 {
+	struct platform_device *pdev = hdmi->pdev;
 	struct device_node *node = pdev->dev.of_node;
 	struct device_node *ep;
 	int r;
@@ -571,7 +589,7 @@ static int hdmi_probe_of(struct platform_device *pdev)
 	if (!ep)
 		return 0;
 
-	r = hdmi_parse_lanes_of(pdev, ep, &hdmi.phy);
+	r = hdmi_parse_lanes_of(pdev, ep, &hdmi->phy);
 	if (r)
 		goto err;
 
@@ -685,26 +703,26 @@ static const struct omap_hdmi_audio_ops hdmi_audio_ops = {
 	.audio_config = hdmi_audio_config,
 };
 
-static int hdmi_audio_register(struct device *dev)
+static int hdmi_audio_register(struct omap_hdmi *hdmi)
 {
 	struct omap_hdmi_audio_pdata pdata = {
-		.dev = dev,
+		.dev = &hdmi->pdev->dev,
 		.version = 5,
-		.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi.wp),
+		.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi->wp),
 		.ops = &hdmi_audio_ops,
 	};
 
-	hdmi.audio_pdev = platform_device_register_data(
-		dev, "omap-hdmi-audio", PLATFORM_DEVID_AUTO,
+	hdmi->audio_pdev = platform_device_register_data(
+		&hdmi->pdev->dev, "omap-hdmi-audio", PLATFORM_DEVID_AUTO,
 		&pdata, sizeof(pdata));
 
-	if (IS_ERR(hdmi.audio_pdev))
-		return PTR_ERR(hdmi.audio_pdev);
+	if (IS_ERR(hdmi->audio_pdev))
+		return PTR_ERR(hdmi->audio_pdev);
 
-	hdmi_runtime_get();
-	hdmi.wp_idlemode =
-		REG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);
-	hdmi_runtime_put();
+	hdmi_runtime_get(hdmi);
+	hdmi->wp_idlemode =
+		REG_GET(hdmi->wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	hdmi_runtime_put(hdmi);
 
 	return 0;
 }
@@ -714,86 +732,96 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dss_device *dss = dss_get_device(master);
+	struct omap_hdmi *hdmi;
 	int r;
 	int irq;
 
-	hdmi.pdev = pdev;
-	hdmi.dss = dss;
-	dev_set_drvdata(&pdev->dev, &hdmi);
+	hdmi = kzalloc(sizeof(*hdmi), GFP_KERNEL);
+	if (!hdmi)
+		return -ENOMEM;
+
+	hdmi->pdev = pdev;
+	hdmi->dss = dss;
+	dev_set_drvdata(&pdev->dev, hdmi);
 
-	mutex_init(&hdmi.lock);
-	spin_lock_init(&hdmi.audio_playing_lock);
+	mutex_init(&hdmi->lock);
+	spin_lock_init(&hdmi->audio_playing_lock);
 
-	r = hdmi_probe_of(pdev);
+	r = hdmi_probe_of(hdmi);
 	if (r)
-		return r;
+		goto err_free;
 
-	r = hdmi_wp_init(pdev, &hdmi.wp, 5);
+	r = hdmi_wp_init(pdev, &hdmi->wp, 5);
 	if (r)
-		return r;
+		goto err_free;
 
-	r = hdmi_pll_init(dss, pdev, &hdmi.pll, &hdmi.wp);
+	r = hdmi_pll_init(dss, pdev, &hdmi->pll, &hdmi->wp);
 	if (r)
-		return r;
+		goto err_free;
 
-	r = hdmi_phy_init(pdev, &hdmi.phy, 5);
+	r = hdmi_phy_init(pdev, &hdmi->phy, 5);
 	if (r)
-		goto err;
+		goto err_pll;
 
-	r = hdmi5_core_init(pdev, &hdmi.core);
+	r = hdmi5_core_init(pdev, &hdmi->core);
 	if (r)
-		goto err;
+		goto err_pll;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		DSSERR("platform_get_irq failed\n");
 		r = -ENODEV;
-		goto err;
+		goto err_pll;
 	}
 
 	r = devm_request_threaded_irq(&pdev->dev, irq,
 			NULL, hdmi_irq_handler,
-			IRQF_ONESHOT, "OMAP HDMI", &hdmi.wp);
+			IRQF_ONESHOT, "OMAP HDMI", hdmi);
 	if (r) {
 		DSSERR("HDMI IRQ request failed\n");
-		goto err;
+		goto err_pll;
 	}
 
 	pm_runtime_enable(&pdev->dev);
 
-	hdmi_init_output(pdev);
+	hdmi_init_output(hdmi);
 
-	r = hdmi_audio_register(&pdev->dev);
+	r = hdmi_audio_register(hdmi);
 	if (r) {
 		DSSERR("Registering HDMI audio failed %d\n", r);
-		hdmi_uninit_output(pdev);
+		hdmi_uninit_output(hdmi);
 		pm_runtime_disable(&pdev->dev);
 		return r;
 	}
 
-	hdmi.debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
-					       &hdmi);
+	hdmi->debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
+						hdmi);
 
 	return 0;
-err:
-	hdmi_pll_uninit(&hdmi.pll);
+
+err_pll:
+	hdmi_pll_uninit(&hdmi->pll);
+err_free:
+	kfree(hdmi);
 	return r;
 }
 
 static void hdmi5_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct platform_device *pdev = to_platform_device(dev);
+	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
+
+	dss_debugfs_remove_file(hdmi->debugfs);
 
-	dss_debugfs_remove_file(hdmi.debugfs);
+	if (hdmi->audio_pdev)
+		platform_device_unregister(hdmi->audio_pdev);
 
-	if (hdmi.audio_pdev)
-		platform_device_unregister(hdmi.audio_pdev);
+	hdmi_uninit_output(hdmi);
 
-	hdmi_uninit_output(pdev);
+	hdmi_pll_uninit(&hdmi->pll);
 
-	hdmi_pll_uninit(&hdmi.pll);
+	pm_runtime_disable(dev);
 
-	pm_runtime_disable(&pdev->dev);
+	kfree(hdmi);
 }
 
 static const struct component_ops hdmi5_component_ops = {

commit 8a7eda7686675b73d74c22c0d5b83059f9d783f6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:43 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to remaining dispc API functions
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index e896f63480f1..a83d70144f85 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -272,7 +272,7 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 				     struct videomode *vm)
 {
-	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, vm))
+	if (!dispc_mgr_timings_ok(hdmi.dss->dispc, dssdev->dispc_channel, vm))
 		return -EINVAL;
 
 	return 0;
@@ -285,7 +285,7 @@ static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
 
 	hdmi.cfg.vm = *vm;
 
-	dispc_set_tv_pclk(vm->pixelclock);
+	dispc_set_tv_pclk(hdmi.dss->dispc, vm->pixelclock);
 
 	mutex_unlock(&hdmi.lock);
 }

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 597baebd959c..e896f63480f1 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -814,16 +814,19 @@ static int hdmi5_remove(struct platform_device *pdev)
 
 static int hdmi_runtime_suspend(struct device *dev)
 {
-	dispc_runtime_put();
+	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
+
+	dispc_runtime_put(hdmi->dss->dispc);
 
 	return 0;
 }
 
 static int hdmi_runtime_resume(struct device *dev)
 {
+	struct omap_hdmi *hdmi = dev_get_drvdata(dev);
 	int r;
 
-	r = dispc_runtime_get();
+	r = dispc_runtime_get(hdmi->dss->dispc);
 	if (r < 0)
 		return r;
 

commit 28d79f3e56b2c1d5ff0fd363da3229be0962cc85
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:38 2018 +0200

    drm: omapdrm: dss: Pass omap_dss_device pointer to dss_mgr_*() functions
    
    The dss_mgr_*() functions take a channel argument to identify the
    channel they operate on. This prevents the functions from accessing
    driver data structures without resorting to global variables. In an
    effort to remove global variables, pass the omap_dss_device pointer
    associated with the channel instead. This will be used to look up the
    omap_drm_private data structure to pass to the dss_mgr_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 8ede19c3d8e7..597baebd959c 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -173,7 +173,6 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 {
 	int r;
 	struct videomode *vm;
-	enum omap_channel channel = dssdev->dispc_channel;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned int pc;
 
@@ -227,9 +226,9 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	hdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);
 
 	/* tv size */
-	dss_mgr_set_timings(channel, vm);
+	dss_mgr_set_timings(&hdmi.output, vm);
 
-	r = dss_mgr_enable(channel);
+	r = dss_mgr_enable(&hdmi.output);
 	if (r)
 		goto err_mgr_enable;
 
@@ -243,7 +242,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	return 0;
 
 err_vid_enable:
-	dss_mgr_disable(channel);
+	dss_mgr_disable(&hdmi.output);
 err_mgr_enable:
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 err_phy_pwr:
@@ -257,13 +256,11 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
-
 	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
 
 	hdmi_wp_video_stop(&hdmi.wp);
 
-	dss_mgr_disable(channel);
+	dss_mgr_disable(&hdmi.output);
 
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 
@@ -456,14 +453,13 @@ static void hdmi_core_disable(struct omap_dss_device *dssdev)
 static int hdmi_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
 	int r;
 
 	r = hdmi_init_regulator();
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(channel, dssdev);
+	r = dss_mgr_connect(&hdmi.output, dssdev);
 	if (r)
 		return r;
 
@@ -471,7 +467,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(channel, dssdev);
+		dss_mgr_disconnect(&hdmi.output, dssdev);
 		return r;
 	}
 
@@ -481,8 +477,6 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 static void hdmi_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
-
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -490,7 +484,7 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(channel, dssdev);
+	dss_mgr_disconnect(&hdmi.output, dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 1c4b92ee00734766967f5aa425767923c747f9c6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:31 2018 +0200

    drm: omapdrm: dss: Store the debugfs root directory in struct dss_device
    
    As part of an effort to remove the usage of global variables in the
    driver, store the debugfs root directory in the dss_device structure
    instead of a global variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b3b9d17eb0e2..8ede19c3d8e7 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -777,7 +777,8 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 		return r;
 	}
 
-	hdmi.debugfs = dss_debugfs_create_file("hdmi", hdmi_dump_regs, &hdmi);
+	hdmi.debugfs = dss_debugfs_create_file(dss, "hdmi", hdmi_dump_regs,
+					       &hdmi);
 
 	return 0;
 err:

commit f33656e1fe5aba0ac0d35e18d90121dd894611ca
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:29 2018 +0200

    drm: omapdrm: dss: Support passing private data to debugfs show handlers
    
    To simplify implementation of debugfs seq_file show handlers, the driver
    passes the pointer to the show function through the debugfs_create_file
    data pointer. This prevents using the pointer to pass driver private
    data to the show handler, and requires all handlers to use global
    variables to access private data.
    
    To prepare for the removal of global private data in the driver, rework
    the debugfs infrastructure to allow passing a private data pointer to
    show handlers.
    
    The price to pay is explicit removal of debugfs files to free the
    internally allocated memory. This is desirable anyway as debugfs entries
    should be removed when a component driver is unbound, otherwise crashes
    will occur due to access to freed memory when the components will be
    dynamically allocated instead of stored in global variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index e7a71012b1cd..b3b9d17eb0e2 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -299,13 +299,13 @@ static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
 	*vm = hdmi.cfg.vm;
 }
 
-static void hdmi_dump_regs(struct seq_file *s)
+static int hdmi_dump_regs(struct seq_file *s, void *p)
 {
 	mutex_lock(&hdmi.lock);
 
 	if (hdmi_runtime_get()) {
 		mutex_unlock(&hdmi.lock);
-		return;
+		return 0;
 	}
 
 	hdmi_wp_dump(&hdmi.wp, s);
@@ -315,6 +315,7 @@ static void hdmi_dump_regs(struct seq_file *s)
 
 	hdmi_runtime_put();
 	mutex_unlock(&hdmi.lock);
+	return 0;
 }
 
 static int read_edid(u8 *buf, int len)
@@ -776,7 +777,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 		return r;
 	}
 
-	dss_debugfs_create_file("hdmi", hdmi_dump_regs);
+	hdmi.debugfs = dss_debugfs_create_file("hdmi", hdmi_dump_regs, &hdmi);
 
 	return 0;
 err:
@@ -788,6 +789,8 @@ static void hdmi5_unbind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 
+	dss_debugfs_remove_file(hdmi.debugfs);
+
 	if (hdmi.audio_pdev)
 		platform_device_unregister(hdmi.audio_pdev);
 

commit 8aea8e6a79e77f4c4af4edc45db744f28f6fe008
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:24 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss_ops operations
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 72cf8635caf5..e7a71012b1cd 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -149,7 +149,7 @@ static int hdmi_power_on_core(struct omap_dss_device *dssdev)
 		goto err_runtime_get;
 
 	/* Make selection of HDMI in DSS */
-	dss_select_hdmi_venc_clk_source(DSS_HDMI_M_PCLK);
+	dss_select_hdmi_venc_clk_source(hdmi.dss, DSS_HDMI_M_PCLK);
 
 	hdmi.core_enabled = true;
 
@@ -723,6 +723,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	int irq;
 
 	hdmi.pdev = pdev;
+	hdmi.dss = dss;
 	dev_set_drvdata(&pdev->dev, &hdmi);
 
 	mutex_init(&hdmi.lock);

commit 7b295257a13d827dac8c71af70e633c7ba722cfe
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:21 2018 +0200

    drm: omapdrm: dss: Pass DSS private structure to runtime PM functions
    
    To prepare for the removal of the global variable storing DSS private
    data, pass its pointer to the dss_runtime_{get,put}() functions.
    
    As this requires getting hold of the dss_device structure in the
    callers, we add a new dss_get_device() function to retrieve it. The
    function currently returns a pointer to the global data structure, and
    will later be updated to get the pointer from device driver data when
    the DSS private structure will be allocated dynamically.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 9571be938d81..72cf8635caf5 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -718,6 +718,7 @@ static int hdmi_audio_register(struct device *dev)
 static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	struct dss_device *dss = dss_get_device(master);
 	int r;
 	int irq;
 
@@ -735,7 +736,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		return r;
 
-	r = hdmi_pll_init(pdev, &hdmi.pll, &hdmi.wp);
+	r = hdmi_pll_init(dss, pdev, &hdmi.pll, &hdmi.wp);
 	if (r)
 		return r;
 

commit d11e5c827a4dbbb4174087669e3c7d231570985b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:34 2018 +0200

    drm: omapdrm: Use unsigned int type
    
    The kernel favours 'unsigned int' over plain 'unsigned'. Replace all
    occurences of the latter by the former. This avoid lots of checkpatch
    complaints in patches that touch lines where a plain 'unsigned' is used.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 689cda41858b..9571be938d81 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -175,7 +175,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	struct videomode *vm;
 	enum omap_channel channel = dssdev->dispc_channel;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
-	unsigned pc;
+	unsigned int pc;
 
 	r = hdmi_power_on_core(dssdev);
 	if (r)

commit d66c36a3ee79747e300ac68276ca1496b567df68
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:32 2017 -0600

    drm: omapdrm: Simplify platform registration
    
    Currently, calls into each file are used to register the various
    platform drivers. Change this to a table of pointers to platform_driver
    structs to allow using platform_register_drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 7091197da940..689cda41858b 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -841,7 +841,7 @@ static const struct of_device_id hdmi_of_match[] = {
 	{},
 };
 
-static struct platform_driver omapdss_hdmihw_driver = {
+struct platform_driver omapdss_hdmi5hw_driver = {
 	.probe		= hdmi5_probe,
 	.remove		= hdmi5_remove,
 	.driver         = {
@@ -851,13 +851,3 @@ static struct platform_driver omapdss_hdmihw_driver = {
 		.suppress_bind_attrs = true,
 	},
 };
-
-int __init hdmi5_init_platform_driver(void)
-{
-	return platform_driver_register(&omapdss_hdmihw_driver);
-}
-
-void hdmi5_uninit_platform_driver(void)
-{
-	platform_driver_unregister(&omapdss_hdmihw_driver);
-}

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b3221ca5bcd8..7091197da940 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -1,7 +1,7 @@
 /*
  * HDMI driver for OMAP5
  *
- * Copyright (C) 2014 Texas Instruments Incorporated
+ * Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com/
  *
  * Authors:
  *	Yong Zhi

commit 37ea27b97b6a5ef073e71169dbc95d89f4daa288
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 11 16:49:06 2017 +0300

    drm: omapdrm: hdmi: Configure the PHY from the HDMI core version
    
    The OMAP4 and OMAP5 HDMI PHYs have different properties that require
    specific handling in the HDMI PHY driver. This needs knowledge of the
    PHY version, which is currently inferred from the DSS version. As part
    of the effort to remove usage of the DSS version, use the HDMI
    controller version instead.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a6adddeee5bb..b3221ca5bcd8 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -739,7 +739,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		return r;
 
-	r = hdmi_phy_init(pdev, &hdmi.phy);
+	r = hdmi_phy_init(pdev, &hdmi.phy, 5);
 	if (r)
 		goto err;
 

commit d20fa5a06d7bddb7823d14255982148fefb72950
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 11 16:49:04 2017 +0300

    drm: omapdrm: hdmi: Pass HDMI core version as integer to HDMI audio
    
    The HDMI audio driver only needs to know which generation of HDMI
    transmitter it deals with, not the detailed SoC model. Pass the version
    number as an integer to prepare for removal of the OMAP SoC version from
    the omapdrm driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 8ab76b50662a..a6adddeee5bb 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -694,7 +694,7 @@ static int hdmi_audio_register(struct device *dev)
 {
 	struct omap_hdmi_audio_pdata pdata = {
 		.dev = dev,
-		.dss_version = omapdss_get_version(),
+		.version = 5,
 		.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi.wp),
 		.ops = &hdmi_audio_ops,
 	};

commit fe16bc51324a8305f802b9c30328b0a924800caf
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 11 16:49:03 2017 +0300

    drm: omapdrm: hdmi: Replace OMAP SoC model check with HDMI xmit version
    
    The HDMI wrapper code only needs to differentiate between major OMAP
    revisions, which can be obtained from the HDMI transmitter compatible
    string. Replace the OMAP SoC model checks to prepare for removal of the
    OMAP SoC version platform data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 5f5b0a06800d..8ab76b50662a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -731,7 +731,7 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		return r;
 
-	r = hdmi_wp_init(pdev, &hdmi.wp);
+	r = hdmi_wp_init(pdev, &hdmi.wp, 5);
 	if (r)
 		return r;
 

commit d874b3a7c44ca48c0e57b8744c1eed2a6d299ba1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:19 2017 +0300

    drm: omapdrm: Remove dss_features.h
    
    The header file only contains four macros, two of which are never used.
    Move the other two to dss.h and remove dss_features.h.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 441e1999d86a..5f5b0a06800d 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -45,7 +45,6 @@
 #include "omapdss.h"
 #include "hdmi5_core.h"
 #include "dss.h"
-#include "dss_features.h"
 
 static struct omap_hdmi hdmi;
 

commit 1dff212ce62bb31c4eb7fc86c996b988663e9ec3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 7 00:42:26 2017 +0300

    drm: omapdrm: Drop support for non-DT devices
    
    All OMAP platforms use DT nowadays, drop support for non-DT devices.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d13dce7e8079..441e1999d86a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -728,11 +728,9 @@ static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 	mutex_init(&hdmi.lock);
 	spin_lock_init(&hdmi.audio_playing_lock);
 
-	if (pdev->dev.of_node) {
-		r = hdmi_probe_of(pdev);
-		if (r)
-			return r;
-	}
+	r = hdmi_probe_of(pdev);
+	if (r)
+		return r;
 
 	r = hdmi_wp_init(pdev, &hdmi.wp);
 	if (r)

commit 09bffa6e519256c6fa1552d6ba1f5d594337a464
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 08:26:08 2017 -0500

    drm: omap: use common OF graph helpers
    
    The OMAP driver has its own OF graph helpers that are similar to the
    common helpers. This commit replaces most of the calls with the common
    helpers. There's still a couple of custom helpers left, but the driver
    needs more extensive changes to get rid of them.
    
    In dss_init_ports, we invert the loop, looping through the known ports
    and matching them to DT nodes rather than looping thru DT nodes and
    matching them to the ports.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 678dfb02764a..d13dce7e8079 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -39,6 +39,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/component.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <sound/omap-hdmi-audio.h>
 
 #include "omapdss.h"
@@ -572,7 +573,7 @@ static int hdmi_probe_of(struct platform_device *pdev)
 	struct device_node *ep;
 	int r;
 
-	ep = omapdss_of_get_first_endpoint(node);
+	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
 	if (!ep)
 		return 0;
 

commit da11bbbb10a964c293c2e2e702ea62ad6cba48b4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:04 2016 +0300

    drm/omap: Use consistent name for struct videomode
    
    Use 'vm' to refer to a struct videomode instead of 'p', 't', 'timings' or
    something else.
    
    The code will be easier to follow if we use consistent names.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 880f67ae6e9b..678dfb02764a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -172,7 +172,7 @@ static void hdmi_power_off_core(struct omap_dss_device *dssdev)
 static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 {
 	int r;
-	struct videomode *p;
+	struct videomode *vm;
 	enum omap_channel channel = dssdev->dispc_channel;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned pc;
@@ -181,13 +181,13 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	if (r)
 		return r;
 
-	p = &hdmi.cfg.timings;
+	vm = &hdmi.cfg.vm;
 
-	DSSDBG("hdmi_power_on hactive= %d vactive = %d\n", p->hactive,
-	       p->vactive);
+	DSSDBG("hdmi_power_on hactive= %d vactive = %d\n", vm->hactive,
+	       vm->vactive);
 
-	pc = p->pixelclock;
-	if (p->flags & DISPLAY_FLAGS_DOUBLECLK)
+	pc = vm->pixelclock;
+	if (vm->flags & DISPLAY_FLAGS_DOUBLECLK)
 		pc *= 2;
 
 	/* DSS_HDMI_TCLK is bitclk / 10 */
@@ -227,7 +227,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	hdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);
 
 	/* tv size */
-	dss_mgr_set_timings(channel, p);
+	dss_mgr_set_timings(channel, vm);
 
 	r = dss_mgr_enable(channel);
 	if (r)
@@ -273,30 +273,30 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 }
 
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
-					struct videomode *timings)
+				     struct videomode *vm)
 {
-	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, timings))
+	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, vm))
 		return -EINVAL;
 
 	return 0;
 }
 
 static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
-		struct videomode *timings)
+				    struct videomode *vm)
 {
 	mutex_lock(&hdmi.lock);
 
-	hdmi.cfg.timings = *timings;
+	hdmi.cfg.vm = *vm;
 
-	dispc_set_tv_pclk(timings->pixelclock);
+	dispc_set_tv_pclk(vm->pixelclock);
 
 	mutex_unlock(&hdmi.lock);
 }
 
 static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
-		struct videomode *timings)
+				     struct videomode *vm)
 {
-	*timings = hdmi.cfg.timings;
+	*vm = hdmi.cfg.vm;
 }
 
 static void hdmi_dump_regs(struct seq_file *s)
@@ -379,7 +379,7 @@ static int hdmi_display_enable(struct omap_dss_device *dssdev)
 
 	if (hdmi.audio_configured) {
 		r = hdmi5_audio_config(&hdmi.core, &hdmi.wp, &hdmi.audio_config,
-				       hdmi.cfg.timings.pixelclock);
+				       hdmi.cfg.vm.pixelclock);
 		if (r) {
 			DSSERR("Error restoring audio configuration: %d", r);
 			hdmi.audio_abort_cb(&hdmi.pdev->dev);
@@ -670,7 +670,7 @@ static int hdmi_audio_config(struct device *dev,
 	}
 
 	ret = hdmi5_audio_config(&hd->core, &hd->wp, dss_audio,
-				 hd->cfg.timings.pixelclock);
+				 hd->cfg.vm.pixelclock);
 
 	if (!ret) {
 		hd->audio_configured = true;

commit 4520ff28aaa1e7f1b45f3abc0c45429ea9e93817
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:03 2016 +0300

    drm/omap: Replace struct omap_video_timings with videomode
    
    omap_video_timings can be replaced with the generic videomode in omapdrm
    and the omap_video_timings can be removed.
    
    This patch will replace the omap_video_timings with videomode.
    With the change we no longer need the functions to convert to/from
    videomode and drm_display_mode to omap_video_timings, these can be removed
    as well.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 8206ef69caf1..880f67ae6e9b 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -172,7 +172,7 @@ static void hdmi_power_off_core(struct omap_dss_device *dssdev)
 static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 {
 	int r;
-	struct omap_video_timings *p;
+	struct videomode *p;
 	enum omap_channel channel = dssdev->dispc_channel;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned pc;
@@ -273,7 +273,7 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 }
 
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
-					struct omap_video_timings *timings)
+					struct videomode *timings)
 {
 	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, timings))
 		return -EINVAL;
@@ -282,7 +282,7 @@ static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 }
 
 static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	mutex_lock(&hdmi.lock);
 
@@ -294,7 +294,7 @@ static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
 }
 
 static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	*timings = hdmi.cfg.timings;
 }

commit 531efb380c6d11025e1afe8ef7300c26f0f1b226
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:59 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for double_pixel mode
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for double_pixel mode.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 45f445523a4f..8206ef69caf1 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -187,7 +187,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	       p->vactive);
 
 	pc = p->pixelclock;
-	if (p->double_pixel)
+	if (p->flags & DISPLAY_FLAGS_DOUBLECLK)
 		pc *= 2;
 
 	/* DSS_HDMI_TCLK is bitclk / 10 */

commit fb7f3c4399ffa75bc31aaaaeab45238ea60c3d1a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:47 2016 +0300

    drm/omap: omap_display_timings: rename y_res to vactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the y_res member to vactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 829d22253972..45f445523a4f 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -183,7 +183,8 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 	p = &hdmi.cfg.timings;
 
-	DSSDBG("hdmi_power_on hactive= %d y_res = %d\n", p->hactive, p->y_res);
+	DSSDBG("hdmi_power_on hactive= %d vactive = %d\n", p->hactive,
+	       p->vactive);
 
 	pc = p->pixelclock;
 	if (p->double_pixel)

commit 81899060de35d80f17020d322e77311f1b255885
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:46 2016 +0300

    drm/omap: omap_display_timings: rename x_res to hactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the x_res member to hactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 0c0a5139a301..829d22253972 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -183,7 +183,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 	p = &hdmi.cfg.timings;
 
-	DSSDBG("hdmi_power_on x_res= %d y_res = %d\n", p->x_res, p->y_res);
+	DSSDBG("hdmi_power_on hactive= %d y_res = %d\n", p->hactive, p->y_res);
 
 	pc = p->pixelclock;
 	if (p->double_pixel)

commit 542d972221e024681b502033154f917c1455469f
Merge: 583fa4e02775 4c2e07c6a29e
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Jul 2 15:56:01 2016 +1000

    Back-merge tag 'v4.7-rc5' into drm-next
    
    Linux 4.7-rc5
    
    The fsl-dcu pull needs -rc3 so go to -rc5 for now.

commit 85332739628fe4beafecdb713438c7cb1454c2f5
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jun 3 14:27:03 2016 +0300

    drm/omap: fix unused variable warning in dsi & hdmi
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index e129245eb8a9..9255c0e1e4a7 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -120,7 +120,6 @@ static irqreturn_t hdmi_irq_handler(int irq, void *data)
 
 static int hdmi_init_regulator(void)
 {
-	int r;
 	struct regulator *reg;
 
 	if (hdmi.vdda_reg != NULL)

commit acc3a231d3d145b23d1f975b9be89b7cfb09885b
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 7 15:09:15 2016 +0300

    drm/omapdrm: Add gamma table support to DSS dispc
    
    Add gamma table support to DSS dispc.
    
    DSS driver initializes the default gamma table at component bind time
    and holds a copy of all gamma tables in its internal data structure.
    
    Each call to dispc_mgr_set_gamma() updates the internal table and
    triggers write to the HW, if it is enabled. The tables are restored to
    HW in PM resume callback. The drivers internal data structure match
    the HW tables in size and in number of significant bits per color
    component. The dispc_mgr_set_gamma() converts the size of any given
    table for the internal data structure using linear interpolation.
    Default gamma table is restored if NULL is given in place of gamma
    lut.
    
    dispc_mgr_gamma_size() gives HW gamma table size for the channel and
    returns 0 if gamma table is not supported by the HW or the DSS driver.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index d4892d84424e..061f9bab4c9b 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -226,9 +226,6 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 	hdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);
 
-	/* bypass TV gamma table */
-	dispc_enable_gamma_table(0);
-
 	/* tv size */
 	dss_mgr_set_timings(channel, p);
 

commit a1dec226a686077a9822013e601327b189f419df
Merge: ecf140dfc3fe 26038aad2511
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jun 7 09:00:25 2016 +0300

    Merge omapdss header refactoring
    
    Merge omapdss public header refactoring, which separates the public
    header into omapdrm and omapfb parts.

commit ecf140dfc3fe169aaff8f5561d345f6b96d7b476
Merge: 449c5e9c33fd 31dca077056a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Jun 6 10:16:51 2016 +0300

    Merge branch '4.8/omapdrm-pll' (omapdrm PLL work)
    
    Merge omapdrm PLL work, which makes it possible to use the DSS PLLs in a
    versatile manner, for example, HDMI PLL can be used for LCDs.

commit 32043da7dcf2af3510d0410b0cacfbcde95e5d26
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 27 14:40:49 2016 +0300

    drm/omap: Do not include video/omapdss.h directly in drivers
    
    All drivers to include the omapdrm/dss/omapdss.h header file. This header
    includes the <video/omapdss.h>
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a43f7b10e113..15145163be13 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -38,9 +38,9 @@
 #include <linux/gpio.h>
 #include <linux/regulator/consumer.h>
 #include <linux/component.h>
-#include <video/omapdss.h>
 #include <sound/omap-hdmi-audio.h>
 
+#include "omapdss.h"
 #include "hdmi5_core.h"
 #include "dss.h"
 #include "dss_features.h"

commit 973999aa0140481e590e791c320009d25a88d377
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Apr 28 15:42:18 2016 +0300

    drm/omap: Remove regulator API abuse
    
    regulator_can_change_voltage() is deprecated and it's use is not necessary
    as commit:
    6a0028b3dd67b regulator: Deprecate regulator_can_change_voltage()
    describers it clearly.
    
    Also, regulator_set_voltage() is misused in the driver, as it is
    supposed to be used only in cases where the regulator voltage needs to
    be changed dynamically at runtime. In DSS's case, we always want a fixed
    voltage, set in the .dts files.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 417dff5eb7cb..e129245eb8a9 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -132,15 +132,6 @@ static int hdmi_init_regulator(void)
 		return PTR_ERR(reg);
 	}
 
-	if (regulator_can_change_voltage(reg)) {
-		r = regulator_set_voltage(reg, 1800000, 1800000);
-		if (r) {
-			devm_regulator_put(reg);
-			DSSWARN("can't set the regulator voltage\n");
-			return r;
-		}
-	}
-
 	hdmi.vdda_reg = reg;
 
 	return 0;

commit d9e32ecda41bb6b6301fd2a0945003bb8f4e2ba1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Mar 18 09:02:18 2016 +0200

    drm/omap: Fix missing includes
    
    With certain kernel config options many omapdrm files fail to compile
    due to missing include of linux/gpio/consumer.h and linux/of.h.
    
    This patch adds those includes.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reported-by: Dan Murphy <dmurphy@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a43f7b10e113..417dff5eb7cb 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -38,6 +38,7 @@
 #include <linux/gpio.h>
 #include <linux/regulator/consumer.h>
 #include <linux/component.h>
+#include <linux/of.h>
 #include <video/omapdss.h>
 #include <sound/omap-hdmi-audio.h>
 

commit c107751d12cf40a5288d47edda53b2c4de2ff21c
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 18 11:15:21 2016 +0300

    drm/omap: generalize dss_pll_calc_b()
    
    dss_pll_calc_b() takes HDMI TMDS clock rate as a parameter. To make
    dss_pll_calc_b() usable for non-HDMI users, change the function to take
    clkout rate as parameter, and also change the current users of
    dss_pll_calc_b() to accommodate that.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 435061475c30..33998f7f51ab 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -198,6 +198,9 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	if (p->double_pixel)
 		pc *= 2;
 
+	/* DSS_HDMI_TCLK is bitclk / 10 */
+	pc *= 10;
+
 	dss_pll_calc_b(&hdmi.pll.pll, clk_get_rate(hdmi.pll.pll.clkin),
 		pc, &hdmi_cinfo);
 

commit c17dc0e3a1e053936c1e08bcbfc771843beabff1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 18 10:45:20 2016 +0300

    drm/omap: move HDMI PLL calc function to pll.c
    
    Move hdmi_pll_compute(), used to calculate the config for HDMI PLL, from
    hdmi_pll.c to pll.c, with the name of dss_pll_calc_b(), to make it
    available to non-HDMI users.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a43f7b10e113..435061475c30 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -198,7 +198,8 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	if (p->double_pixel)
 		pc *= 2;
 
-	hdmi_pll_compute(&hdmi.pll, pc, &hdmi_cinfo);
+	dss_pll_calc_b(&hdmi.pll.pll, clk_get_rate(hdmi.pll.pll.clkin),
+		pc, &hdmi_cinfo);
 
 	/* disable and clear irqs */
 	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);

commit 86e95f92f9f85ae3207382cca7ba4fc86fd2ddd0
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:55:01 2015 +0200

    drm/omap: HDMI5: remove uses of omap_overlay_manager
    
    We are removing the uses of 'struct omap_overlay_manager'. This patch
    changes HDMI5 driver to use 'omap_channel' instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 33cda9bcf952..a43f7b10e113 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -182,7 +182,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 {
 	int r;
 	struct omap_video_timings *p;
-	struct omap_overlay_manager *mgr = hdmi.output.manager;
+	enum omap_channel channel = dssdev->dispc_channel;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
 	unsigned pc;
 
@@ -234,9 +234,9 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	dispc_enable_gamma_table(0);
 
 	/* tv size */
-	dss_mgr_set_timings(mgr->id, p);
+	dss_mgr_set_timings(channel, p);
 
-	r = dss_mgr_enable(mgr->id);
+	r = dss_mgr_enable(channel);
 	if (r)
 		goto err_mgr_enable;
 
@@ -250,7 +250,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	return 0;
 
 err_vid_enable:
-	dss_mgr_disable(mgr->id);
+	dss_mgr_disable(channel);
 err_mgr_enable:
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 err_phy_pwr:
@@ -264,13 +264,13 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 {
-	struct omap_overlay_manager *mgr = hdmi.output.manager;
+	enum omap_channel channel = dssdev->dispc_channel;
 
 	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
 
 	hdmi_wp_video_stop(&hdmi.wp);
 
-	dss_mgr_disable(mgr->id);
+	dss_mgr_disable(channel);
 
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 
@@ -282,9 +282,7 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 					struct omap_video_timings *timings)
 {
-	struct omap_dss_device *out = &hdmi.output;
-
-	if (!dispc_mgr_timings_ok(out->dispc_channel, timings))
+	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, timings))
 		return -EINVAL;
 
 	return 0;
@@ -464,18 +462,14 @@ static void hdmi_core_disable(struct omap_dss_device *dssdev)
 static int hdmi_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct omap_overlay_manager *mgr;
+	enum omap_channel channel = dssdev->dispc_channel;
 	int r;
 
 	r = hdmi_init_regulator();
 	if (r)
 		return r;
 
-	mgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);
-	if (!mgr)
-		return -ENODEV;
-
-	r = dss_mgr_connect(mgr->id, dssdev);
+	r = dss_mgr_connect(channel, dssdev);
 	if (r)
 		return r;
 
@@ -483,7 +477,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(mgr->id, dssdev);
+		dss_mgr_disconnect(channel, dssdev);
 		return r;
 	}
 
@@ -493,6 +487,8 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 static void hdmi_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	enum omap_channel channel = dssdev->dispc_channel;
+
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -500,7 +496,7 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(dssdev->manager->id, dssdev);
+	dss_mgr_disconnect(channel, dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit a0e53bfe9f41689d337955814bdc2e5c0f373009
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:44:53 2015 +0200

    drm/omap: remove extra manager checks on disconnect
    
    The DSS output drivers check 'dssdev->manager' in disconnect()
    functions. This check is not needed as the manager must always be set if
    the output device was connected. Remove the check.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b75f15e15797..33cda9bcf952 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -500,8 +500,7 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	if (dssdev->manager)
-		dss_mgr_disconnect(dssdev->manager->id, dssdev);
+	dss_mgr_disconnect(dssdev->manager->id, dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 705fd454a909ab652954c04352bc9f2753523d7b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:28:45 2015 +0200

    drm/omap: convert dss_mgr_disable to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_disable() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 7ae447382ea5..b75f15e15797 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -250,7 +250,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	return 0;
 
 err_vid_enable:
-	dss_mgr_disable(mgr);
+	dss_mgr_disable(mgr->id);
 err_mgr_enable:
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 err_phy_pwr:
@@ -270,7 +270,7 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 
 	hdmi_wp_video_stop(&hdmi.wp);
 
-	dss_mgr_disable(mgr);
+	dss_mgr_disable(mgr->id);
 
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 

commit 85a8c62250d7e31ded7a45c312b6860fb87e1a13
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:27:31 2015 +0200

    drm/omap: convert dss_mgr_enable to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_enable() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 7a299eb5a87a..7ae447382ea5 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -236,7 +236,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	/* tv size */
 	dss_mgr_set_timings(mgr->id, p);
 
-	r = dss_mgr_enable(mgr);
+	r = dss_mgr_enable(mgr->id);
 	if (r)
 		goto err_mgr_enable;
 

commit 5c6ff3cd4546dea0a7a70cef6c9b656b8b022217
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:25:05 2015 +0200

    drm/omap: convert dss_mgr_set_timings to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_set_timings() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 9501de473916..7a299eb5a87a 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -234,7 +234,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	dispc_enable_gamma_table(0);
 
 	/* tv size */
-	dss_mgr_set_timings(mgr, p);
+	dss_mgr_set_timings(mgr->id, p);
 
 	r = dss_mgr_enable(mgr);
 	if (r)

commit bdac3bb946f1bb9a38eb15df755b579b6dc56834
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:23:37 2015 +0200

    drm/omap: convert dss_mgr_disconnect to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_disconnect() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 0b4105e89350..9501de473916 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -483,7 +483,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(mgr, dssdev);
+		dss_mgr_disconnect(mgr->id, dssdev);
 		return r;
 	}
 
@@ -501,7 +501,7 @@ static void hdmi_disconnect(struct omap_dss_device *dssdev,
 	omapdss_output_unset_device(dssdev);
 
 	if (dssdev->manager)
-		dss_mgr_disconnect(dssdev->manager, dssdev);
+		dss_mgr_disconnect(dssdev->manager->id, dssdev);
 }
 
 static int hdmi_read_edid(struct omap_dss_device *dssdev,

commit 1b07b0664aa9f36e5a79c82cff46722e587ab647
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:21:48 2015 +0200

    drm/omap: convert dss_mgr_connect to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_connect() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 24a14029112d..0b4105e89350 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -475,7 +475,7 @@ static int hdmi_connect(struct omap_dss_device *dssdev,
 	if (!mgr)
 		return -ENODEV;
 
-	r = dss_mgr_connect(mgr, dssdev);
+	r = dss_mgr_connect(mgr->id, dssdev);
 	if (r)
 		return r;
 

commit f1504ad00daeeb301936f8695be28edb61613b76
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:34:51 2015 +0200

    drm/omap: use dispc_channel_connected in output drivers
    
    Use 'out->dispc_channel_connected' to check if the device is connected
    to an overlay manager or not, instead of using 'out->manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index b2dd4c9f20d5..24a14029112d 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -374,7 +374,7 @@ static int hdmi_display_enable(struct omap_dss_device *dssdev)
 
 	mutex_lock(&hdmi.lock);
 
-	if (out->manager == NULL) {
+	if (!out->dispc_channel_connected) {
 		DSSERR("failed to enable display: no output/manager\n");
 		r = -ENODEV;
 		goto err0;

commit d31966ffd123e4bc3426af26855f77c2d3a70d2b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jan 13 18:41:40 2016 +0200

    drm/omap: HDMI5: allow interlace
    
    Now that interlace support has been added, we can remove the check that
    prevents interlace.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 34174ea85a54..b2dd4c9f20d5 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -284,10 +284,6 @@ static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 {
 	struct omap_dss_device *out = &hdmi.output;
 
-	/* TODO: proper interlace support */
-	if (timings->interlace)
-		return -EINVAL;
-
 	if (!dispc_mgr_timings_ok(out->dispc_channel, timings))
 		return -EINVAL;
 

commit 67d8ffdd688e4ddc4fac25e338f748000128b3ce
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jan 13 18:41:33 2016 +0200

    drm/omap: HDMI: support double-pixel pixel clock
    
    We need double-pixel mode (pixel repetition) for interlace modes. This
    patch adds the necessary support to HDMI to double the pixel clock when
    double-pixel mode is used.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index 4485a1c37bd8..34174ea85a54 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -184,6 +184,7 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	struct omap_video_timings *p;
 	struct omap_overlay_manager *mgr = hdmi.output.manager;
 	struct dss_pll_clock_info hdmi_cinfo = { 0 };
+	unsigned pc;
 
 	r = hdmi_power_on_core(dssdev);
 	if (r)
@@ -193,7 +194,11 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 
 	DSSDBG("hdmi_power_on x_res= %d y_res = %d\n", p->x_res, p->y_res);
 
-	hdmi_pll_compute(&hdmi.pll, p->pixelclock, &hdmi_cinfo);
+	pc = p->pixelclock;
+	if (p->double_pixel)
+		pc *= 2;
+
+	hdmi_pll_compute(&hdmi.pll, pc, &hdmi_cinfo);
 
 	/* disable and clear irqs */
 	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);

commit 4e4b53ceb59301b2a1dbf3a9f74ce5e17f64287d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Mar 24 15:46:35 2015 +0200

    drm/omap: HDMI: change enable/disable to avoid sync-losts
    
    We occasionally see DISPC sync-lost errors when enabling and disabling
    HDMI. Sometimes we get only a few, which get handled (ignored) by the
    driver, but sometimes there's a flood of the errors which doesn't seem
    to stop.
    
    The HW team has root caused this to the order in which HDMI and DISPC
    are enabled/disabled. Currently we enable HDMI first, and then DISPC,
    and vice versa when disabling. HW team's suggestion is to do it the
    other way around.
    
    This patch changes the order, but this has two side effects as the pixel
    clock is produced by HDMI, and the clock is not running when we
    enable/disable DISPC:
    
    * When enabling DISPC first, we don't get vertical sync events
    * When disabling DISPC last, we don't get FRAMEDONE event
    
    At the moment we use both of those to verify that DISPC has been
    enabled/disabled properly. Thus this patch also needs to change the
    omapdrm and omapdss which handle the DISPC side.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
index a955a2c4c061..4485a1c37bd8 100644
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -231,22 +231,22 @@ static int hdmi_power_on_full(struct omap_dss_device *dssdev)
 	/* tv size */
 	dss_mgr_set_timings(mgr, p);
 
-	r = hdmi_wp_video_start(&hdmi.wp);
-	if (r)
-		goto err_vid_enable;
-
 	r = dss_mgr_enable(mgr);
 	if (r)
 		goto err_mgr_enable;
 
+	r = hdmi_wp_video_start(&hdmi.wp);
+	if (r)
+		goto err_vid_enable;
+
 	hdmi_wp_set_irqenable(&hdmi.wp,
 			HDMI_IRQ_LINK_CONNECT | HDMI_IRQ_LINK_DISCONNECT);
 
 	return 0;
 
-err_mgr_enable:
-	hdmi_wp_video_stop(&hdmi.wp);
 err_vid_enable:
+	dss_mgr_disable(mgr);
+err_mgr_enable:
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 err_phy_pwr:
 err_phy_cfg:
@@ -263,10 +263,10 @@ static void hdmi_power_off_full(struct omap_dss_device *dssdev)
 
 	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
 
-	dss_mgr_disable(mgr);
-
 	hdmi_wp_video_stop(&hdmi.wp);
 
+	dss_mgr_disable(mgr);
+
 	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
 
 	dss_pll_disable(&hdmi.pll.pll);

commit 9960aa7cb58caadef8edf3a2582e30664a6b68dd
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Dec 9 20:26:00 2015 +0200

    drm/omap: move omapdss & displays under omapdrm
    
    Now that omapfb has its own copy of omapdss and display drivers, we can
    move omapdss and display drivers which omapdrm uses to omapdrm's
    directory.
    
    We also need to change the main drm Makefile so that omapdrm directory
    is always entered, because omapdss has a file that can't be built as a
    module.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Acked-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi5.c b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
new file mode 100644
index 000000000000..a955a2c4c061
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -0,0 +1,876 @@
+/*
+ * HDMI driver for OMAP5
+ *
+ * Copyright (C) 2014 Texas Instruments Incorporated
+ *
+ * Authors:
+ *	Yong Zhi
+ *	Mythri pk
+ *	Archit Taneja <archit@ti.com>
+ *	Tomi Valkeinen <tomi.valkeinen@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DSS_SUBSYS_NAME "HDMI"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/component.h>
+#include <video/omapdss.h>
+#include <sound/omap-hdmi-audio.h>
+
+#include "hdmi5_core.h"
+#include "dss.h"
+#include "dss_features.h"
+
+static struct omap_hdmi hdmi;
+
+static int hdmi_runtime_get(void)
+{
+	int r;
+
+	DSSDBG("hdmi_runtime_get\n");
+
+	r = pm_runtime_get_sync(&hdmi.pdev->dev);
+	WARN_ON(r < 0);
+	if (r < 0)
+		return r;
+
+	return 0;
+}
+
+static void hdmi_runtime_put(void)
+{
+	int r;
+
+	DSSDBG("hdmi_runtime_put\n");
+
+	r = pm_runtime_put_sync(&hdmi.pdev->dev);
+	WARN_ON(r < 0 && r != -ENOSYS);
+}
+
+static irqreturn_t hdmi_irq_handler(int irq, void *data)
+{
+	struct hdmi_wp_data *wp = data;
+	u32 irqstatus;
+
+	irqstatus = hdmi_wp_get_irqstatus(wp);
+	hdmi_wp_set_irqstatus(wp, irqstatus);
+
+	if ((irqstatus & HDMI_IRQ_LINK_CONNECT) &&
+			irqstatus & HDMI_IRQ_LINK_DISCONNECT) {
+		u32 v;
+		/*
+		 * If we get both connect and disconnect interrupts at the same
+		 * time, turn off the PHY, clear interrupts, and restart, which
+		 * raises connect interrupt if a cable is connected, or nothing
+		 * if cable is not connected.
+		 */
+
+		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_OFF);
+
+		/*
+		 * We always get bogus CONNECT & DISCONNECT interrupts when
+		 * setting the PHY to LDOON. To ignore those, we force the RXDET
+		 * line to 0 until the PHY power state has been changed.
+		 */
+		v = hdmi_read_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL);
+		v = FLD_MOD(v, 1, 15, 15); /* FORCE_RXDET_HIGH */
+		v = FLD_MOD(v, 0, 14, 7); /* RXDET_LINE */
+		hdmi_write_reg(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, v);
+
+		hdmi_wp_set_irqstatus(wp, HDMI_IRQ_LINK_CONNECT |
+				HDMI_IRQ_LINK_DISCONNECT);
+
+		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);
+
+		REG_FLD_MOD(hdmi.phy.base, HDMI_TXPHY_PAD_CFG_CTRL, 0, 15, 15);
+
+	} else if (irqstatus & HDMI_IRQ_LINK_CONNECT) {
+		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_TXON);
+	} else if (irqstatus & HDMI_IRQ_LINK_DISCONNECT) {
+		hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int hdmi_init_regulator(void)
+{
+	int r;
+	struct regulator *reg;
+
+	if (hdmi.vdda_reg != NULL)
+		return 0;
+
+	reg = devm_regulator_get(&hdmi.pdev->dev, "vdda");
+	if (IS_ERR(reg)) {
+		DSSERR("can't get VDDA regulator\n");
+		return PTR_ERR(reg);
+	}
+
+	if (regulator_can_change_voltage(reg)) {
+		r = regulator_set_voltage(reg, 1800000, 1800000);
+		if (r) {
+			devm_regulator_put(reg);
+			DSSWARN("can't set the regulator voltage\n");
+			return r;
+		}
+	}
+
+	hdmi.vdda_reg = reg;
+
+	return 0;
+}
+
+static int hdmi_power_on_core(struct omap_dss_device *dssdev)
+{
+	int r;
+
+	r = regulator_enable(hdmi.vdda_reg);
+	if (r)
+		return r;
+
+	r = hdmi_runtime_get();
+	if (r)
+		goto err_runtime_get;
+
+	/* Make selection of HDMI in DSS */
+	dss_select_hdmi_venc_clk_source(DSS_HDMI_M_PCLK);
+
+	hdmi.core_enabled = true;
+
+	return 0;
+
+err_runtime_get:
+	regulator_disable(hdmi.vdda_reg);
+
+	return r;
+}
+
+static void hdmi_power_off_core(struct omap_dss_device *dssdev)
+{
+	hdmi.core_enabled = false;
+
+	hdmi_runtime_put();
+	regulator_disable(hdmi.vdda_reg);
+}
+
+static int hdmi_power_on_full(struct omap_dss_device *dssdev)
+{
+	int r;
+	struct omap_video_timings *p;
+	struct omap_overlay_manager *mgr = hdmi.output.manager;
+	struct dss_pll_clock_info hdmi_cinfo = { 0 };
+
+	r = hdmi_power_on_core(dssdev);
+	if (r)
+		return r;
+
+	p = &hdmi.cfg.timings;
+
+	DSSDBG("hdmi_power_on x_res= %d y_res = %d\n", p->x_res, p->y_res);
+
+	hdmi_pll_compute(&hdmi.pll, p->pixelclock, &hdmi_cinfo);
+
+	/* disable and clear irqs */
+	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
+	hdmi_wp_set_irqstatus(&hdmi.wp,
+			hdmi_wp_get_irqstatus(&hdmi.wp));
+
+	r = dss_pll_enable(&hdmi.pll.pll);
+	if (r) {
+		DSSERR("Failed to enable PLL\n");
+		goto err_pll_enable;
+	}
+
+	r = dss_pll_set_config(&hdmi.pll.pll, &hdmi_cinfo);
+	if (r) {
+		DSSERR("Failed to configure PLL\n");
+		goto err_pll_cfg;
+	}
+
+	r = hdmi_phy_configure(&hdmi.phy, hdmi_cinfo.clkdco,
+		hdmi_cinfo.clkout[0]);
+	if (r) {
+		DSSDBG("Failed to start PHY\n");
+		goto err_phy_cfg;
+	}
+
+	r = hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_LDOON);
+	if (r)
+		goto err_phy_pwr;
+
+	hdmi5_configure(&hdmi.core, &hdmi.wp, &hdmi.cfg);
+
+	/* bypass TV gamma table */
+	dispc_enable_gamma_table(0);
+
+	/* tv size */
+	dss_mgr_set_timings(mgr, p);
+
+	r = hdmi_wp_video_start(&hdmi.wp);
+	if (r)
+		goto err_vid_enable;
+
+	r = dss_mgr_enable(mgr);
+	if (r)
+		goto err_mgr_enable;
+
+	hdmi_wp_set_irqenable(&hdmi.wp,
+			HDMI_IRQ_LINK_CONNECT | HDMI_IRQ_LINK_DISCONNECT);
+
+	return 0;
+
+err_mgr_enable:
+	hdmi_wp_video_stop(&hdmi.wp);
+err_vid_enable:
+	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
+err_phy_pwr:
+err_phy_cfg:
+err_pll_cfg:
+	dss_pll_disable(&hdmi.pll.pll);
+err_pll_enable:
+	hdmi_power_off_core(dssdev);
+	return -EIO;
+}
+
+static void hdmi_power_off_full(struct omap_dss_device *dssdev)
+{
+	struct omap_overlay_manager *mgr = hdmi.output.manager;
+
+	hdmi_wp_clear_irqenable(&hdmi.wp, 0xffffffff);
+
+	dss_mgr_disable(mgr);
+
+	hdmi_wp_video_stop(&hdmi.wp);
+
+	hdmi_wp_set_phy_pwr(&hdmi.wp, HDMI_PHYPWRCMD_OFF);
+
+	dss_pll_disable(&hdmi.pll.pll);
+
+	hdmi_power_off_core(dssdev);
+}
+
+static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
+					struct omap_video_timings *timings)
+{
+	struct omap_dss_device *out = &hdmi.output;
+
+	/* TODO: proper interlace support */
+	if (timings->interlace)
+		return -EINVAL;
+
+	if (!dispc_mgr_timings_ok(out->dispc_channel, timings))
+		return -EINVAL;
+
+	return 0;
+}
+
+static void hdmi_display_set_timing(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	mutex_lock(&hdmi.lock);
+
+	hdmi.cfg.timings = *timings;
+
+	dispc_set_tv_pclk(timings->pixelclock);
+
+	mutex_unlock(&hdmi.lock);
+}
+
+static void hdmi_display_get_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	*timings = hdmi.cfg.timings;
+}
+
+static void hdmi_dump_regs(struct seq_file *s)
+{
+	mutex_lock(&hdmi.lock);
+
+	if (hdmi_runtime_get()) {
+		mutex_unlock(&hdmi.lock);
+		return;
+	}
+
+	hdmi_wp_dump(&hdmi.wp, s);
+	hdmi_pll_dump(&hdmi.pll, s);
+	hdmi_phy_dump(&hdmi.phy, s);
+	hdmi5_core_dump(&hdmi.core, s);
+
+	hdmi_runtime_put();
+	mutex_unlock(&hdmi.lock);
+}
+
+static int read_edid(u8 *buf, int len)
+{
+	int r;
+	int idlemode;
+
+	mutex_lock(&hdmi.lock);
+
+	r = hdmi_runtime_get();
+	BUG_ON(r);
+
+	idlemode = REG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	/* No-idle mode */
+	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+
+	r = hdmi5_read_edid(&hdmi.core,  buf, len);
+
+	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, idlemode, 3, 2);
+
+	hdmi_runtime_put();
+	mutex_unlock(&hdmi.lock);
+
+	return r;
+}
+
+static void hdmi_start_audio_stream(struct omap_hdmi *hd)
+{
+	REG_FLD_MOD(hdmi.wp.base, HDMI_WP_SYSCONFIG, 1, 3, 2);
+	hdmi_wp_audio_enable(&hd->wp, true);
+	hdmi_wp_audio_core_req_enable(&hd->wp, true);
+}
+
+static void hdmi_stop_audio_stream(struct omap_hdmi *hd)
+{
+	hdmi_wp_audio_core_req_enable(&hd->wp, false);
+	hdmi_wp_audio_enable(&hd->wp, false);
+	REG_FLD_MOD(hd->wp.base, HDMI_WP_SYSCONFIG, hd->wp_idlemode, 3, 2);
+}
+
+static int hdmi_display_enable(struct omap_dss_device *dssdev)
+{
+	struct omap_dss_device *out = &hdmi.output;
+	unsigned long flags;
+	int r = 0;
+
+	DSSDBG("ENTER hdmi_display_enable\n");
+
+	mutex_lock(&hdmi.lock);
+
+	if (out->manager == NULL) {
+		DSSERR("failed to enable display: no output/manager\n");
+		r = -ENODEV;
+		goto err0;
+	}
+
+	r = hdmi_power_on_full(dssdev);
+	if (r) {
+		DSSERR("failed to power on device\n");
+		goto err0;
+	}
+
+	if (hdmi.audio_configured) {
+		r = hdmi5_audio_config(&hdmi.core, &hdmi.wp, &hdmi.audio_config,
+				       hdmi.cfg.timings.pixelclock);
+		if (r) {
+			DSSERR("Error restoring audio configuration: %d", r);
+			hdmi.audio_abort_cb(&hdmi.pdev->dev);
+			hdmi.audio_configured = false;
+		}
+	}
+
+	spin_lock_irqsave(&hdmi.audio_playing_lock, flags);
+	if (hdmi.audio_configured && hdmi.audio_playing)
+		hdmi_start_audio_stream(&hdmi);
+	hdmi.display_enabled = true;
+	spin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);
+
+	mutex_unlock(&hdmi.lock);
+	return 0;
+
+err0:
+	mutex_unlock(&hdmi.lock);
+	return r;
+}
+
+static void hdmi_display_disable(struct omap_dss_device *dssdev)
+{
+	unsigned long flags;
+
+	DSSDBG("Enter hdmi_display_disable\n");
+
+	mutex_lock(&hdmi.lock);
+
+	spin_lock_irqsave(&hdmi.audio_playing_lock, flags);
+	hdmi_stop_audio_stream(&hdmi);
+	hdmi.display_enabled = false;
+	spin_unlock_irqrestore(&hdmi.audio_playing_lock, flags);
+
+	hdmi_power_off_full(dssdev);
+
+	mutex_unlock(&hdmi.lock);
+}
+
+static int hdmi_core_enable(struct omap_dss_device *dssdev)
+{
+	int r = 0;
+
+	DSSDBG("ENTER omapdss_hdmi_core_enable\n");
+
+	mutex_lock(&hdmi.lock);
+
+	r = hdmi_power_on_core(dssdev);
+	if (r) {
+		DSSERR("failed to power on device\n");
+		goto err0;
+	}
+
+	mutex_unlock(&hdmi.lock);
+	return 0;
+
+err0:
+	mutex_unlock(&hdmi.lock);
+	return r;
+}
+
+static void hdmi_core_disable(struct omap_dss_device *dssdev)
+{
+	DSSDBG("Enter omapdss_hdmi_core_disable\n");
+
+	mutex_lock(&hdmi.lock);
+
+	hdmi_power_off_core(dssdev);
+
+	mutex_unlock(&hdmi.lock);
+}
+
+static int hdmi_connect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	struct omap_overlay_manager *mgr;
+	int r;
+
+	r = hdmi_init_regulator();
+	if (r)
+		return r;
+
+	mgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);
+	if (!mgr)
+		return -ENODEV;
+
+	r = dss_mgr_connect(mgr, dssdev);
+	if (r)
+		return r;
+
+	r = omapdss_output_set_device(dssdev, dst);
+	if (r) {
+		DSSERR("failed to connect output to new device: %s\n",
+				dst->name);
+		dss_mgr_disconnect(mgr, dssdev);
+		return r;
+	}
+
+	return 0;
+}
+
+static void hdmi_disconnect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	WARN_ON(dst != dssdev->dst);
+
+	if (dst != dssdev->dst)
+		return;
+
+	omapdss_output_unset_device(dssdev);
+
+	if (dssdev->manager)
+		dss_mgr_disconnect(dssdev->manager, dssdev);
+}
+
+static int hdmi_read_edid(struct omap_dss_device *dssdev,
+		u8 *edid, int len)
+{
+	bool need_enable;
+	int r;
+
+	need_enable = hdmi.core_enabled == false;
+
+	if (need_enable) {
+		r = hdmi_core_enable(dssdev);
+		if (r)
+			return r;
+	}
+
+	r = read_edid(edid, len);
+
+	if (need_enable)
+		hdmi_core_disable(dssdev);
+
+	return r;
+}
+
+static int hdmi_set_infoframe(struct omap_dss_device *dssdev,
+		const struct hdmi_avi_infoframe *avi)
+{
+	hdmi.cfg.infoframe = *avi;
+	return 0;
+}
+
+static int hdmi_set_hdmi_mode(struct omap_dss_device *dssdev,
+		bool hdmi_mode)
+{
+	hdmi.cfg.hdmi_dvi_mode = hdmi_mode ? HDMI_HDMI : HDMI_DVI;
+	return 0;
+}
+
+static const struct omapdss_hdmi_ops hdmi_ops = {
+	.connect		= hdmi_connect,
+	.disconnect		= hdmi_disconnect,
+
+	.enable			= hdmi_display_enable,
+	.disable		= hdmi_display_disable,
+
+	.check_timings		= hdmi_display_check_timing,
+	.set_timings		= hdmi_display_set_timing,
+	.get_timings		= hdmi_display_get_timings,
+
+	.read_edid		= hdmi_read_edid,
+	.set_infoframe		= hdmi_set_infoframe,
+	.set_hdmi_mode		= hdmi_set_hdmi_mode,
+};
+
+static void hdmi_init_output(struct platform_device *pdev)
+{
+	struct omap_dss_device *out = &hdmi.output;
+
+	out->dev = &pdev->dev;
+	out->id = OMAP_DSS_OUTPUT_HDMI;
+	out->output_type = OMAP_DISPLAY_TYPE_HDMI;
+	out->name = "hdmi.0";
+	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
+	out->ops.hdmi = &hdmi_ops;
+	out->owner = THIS_MODULE;
+
+	omapdss_register_output(out);
+}
+
+static void hdmi_uninit_output(struct platform_device *pdev)
+{
+	struct omap_dss_device *out = &hdmi.output;
+
+	omapdss_unregister_output(out);
+}
+
+static int hdmi_probe_of(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *ep;
+	int r;
+
+	ep = omapdss_of_get_first_endpoint(node);
+	if (!ep)
+		return 0;
+
+	r = hdmi_parse_lanes_of(pdev, ep, &hdmi.phy);
+	if (r)
+		goto err;
+
+	of_node_put(ep);
+	return 0;
+
+err:
+	of_node_put(ep);
+	return r;
+}
+
+/* Audio callbacks */
+static int hdmi_audio_startup(struct device *dev,
+			      void (*abort_cb)(struct device *dev))
+{
+	struct omap_hdmi *hd = dev_get_drvdata(dev);
+	int ret = 0;
+
+	mutex_lock(&hd->lock);
+
+	if (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	hd->audio_abort_cb = abort_cb;
+
+out:
+	mutex_unlock(&hd->lock);
+
+	return ret;
+}
+
+static int hdmi_audio_shutdown(struct device *dev)
+{
+	struct omap_hdmi *hd = dev_get_drvdata(dev);
+
+	mutex_lock(&hd->lock);
+	hd->audio_abort_cb = NULL;
+	hd->audio_configured = false;
+	hd->audio_playing = false;
+	mutex_unlock(&hd->lock);
+
+	return 0;
+}
+
+static int hdmi_audio_start(struct device *dev)
+{
+	struct omap_hdmi *hd = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	WARN_ON(!hdmi_mode_has_audio(&hd->cfg));
+
+	spin_lock_irqsave(&hd->audio_playing_lock, flags);
+
+	if (hd->display_enabled)
+		hdmi_start_audio_stream(hd);
+	hd->audio_playing = true;
+
+	spin_unlock_irqrestore(&hd->audio_playing_lock, flags);
+	return 0;
+}
+
+static void hdmi_audio_stop(struct device *dev)
+{
+	struct omap_hdmi *hd = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	WARN_ON(!hdmi_mode_has_audio(&hd->cfg));
+
+	spin_lock_irqsave(&hd->audio_playing_lock, flags);
+
+	if (hd->display_enabled)
+		hdmi_stop_audio_stream(hd);
+	hd->audio_playing = false;
+
+	spin_unlock_irqrestore(&hd->audio_playing_lock, flags);
+}
+
+static int hdmi_audio_config(struct device *dev,
+			     struct omap_dss_audio *dss_audio)
+{
+	struct omap_hdmi *hd = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&hd->lock);
+
+	if (!hdmi_mode_has_audio(&hd->cfg) || !hd->display_enabled) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	ret = hdmi5_audio_config(&hd->core, &hd->wp, dss_audio,
+				 hd->cfg.timings.pixelclock);
+
+	if (!ret) {
+		hd->audio_configured = true;
+		hd->audio_config = *dss_audio;
+	}
+out:
+	mutex_unlock(&hd->lock);
+
+	return ret;
+}
+
+static const struct omap_hdmi_audio_ops hdmi_audio_ops = {
+	.audio_startup = hdmi_audio_startup,
+	.audio_shutdown = hdmi_audio_shutdown,
+	.audio_start = hdmi_audio_start,
+	.audio_stop = hdmi_audio_stop,
+	.audio_config = hdmi_audio_config,
+};
+
+static int hdmi_audio_register(struct device *dev)
+{
+	struct omap_hdmi_audio_pdata pdata = {
+		.dev = dev,
+		.dss_version = omapdss_get_version(),
+		.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi.wp),
+		.ops = &hdmi_audio_ops,
+	};
+
+	hdmi.audio_pdev = platform_device_register_data(
+		dev, "omap-hdmi-audio", PLATFORM_DEVID_AUTO,
+		&pdata, sizeof(pdata));
+
+	if (IS_ERR(hdmi.audio_pdev))
+		return PTR_ERR(hdmi.audio_pdev);
+
+	hdmi_runtime_get();
+	hdmi.wp_idlemode =
+		REG_GET(hdmi.wp.base, HDMI_WP_SYSCONFIG, 3, 2);
+	hdmi_runtime_put();
+
+	return 0;
+}
+
+/* HDMI HW IP initialisation */
+static int hdmi5_bind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int r;
+	int irq;
+
+	hdmi.pdev = pdev;
+	dev_set_drvdata(&pdev->dev, &hdmi);
+
+	mutex_init(&hdmi.lock);
+	spin_lock_init(&hdmi.audio_playing_lock);
+
+	if (pdev->dev.of_node) {
+		r = hdmi_probe_of(pdev);
+		if (r)
+			return r;
+	}
+
+	r = hdmi_wp_init(pdev, &hdmi.wp);
+	if (r)
+		return r;
+
+	r = hdmi_pll_init(pdev, &hdmi.pll, &hdmi.wp);
+	if (r)
+		return r;
+
+	r = hdmi_phy_init(pdev, &hdmi.phy);
+	if (r)
+		goto err;
+
+	r = hdmi5_core_init(pdev, &hdmi.core);
+	if (r)
+		goto err;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		DSSERR("platform_get_irq failed\n");
+		r = -ENODEV;
+		goto err;
+	}
+
+	r = devm_request_threaded_irq(&pdev->dev, irq,
+			NULL, hdmi_irq_handler,
+			IRQF_ONESHOT, "OMAP HDMI", &hdmi.wp);
+	if (r) {
+		DSSERR("HDMI IRQ request failed\n");
+		goto err;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	hdmi_init_output(pdev);
+
+	r = hdmi_audio_register(&pdev->dev);
+	if (r) {
+		DSSERR("Registering HDMI audio failed %d\n", r);
+		hdmi_uninit_output(pdev);
+		pm_runtime_disable(&pdev->dev);
+		return r;
+	}
+
+	dss_debugfs_create_file("hdmi", hdmi_dump_regs);
+
+	return 0;
+err:
+	hdmi_pll_uninit(&hdmi.pll);
+	return r;
+}
+
+static void hdmi5_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	if (hdmi.audio_pdev)
+		platform_device_unregister(hdmi.audio_pdev);
+
+	hdmi_uninit_output(pdev);
+
+	hdmi_pll_uninit(&hdmi.pll);
+
+	pm_runtime_disable(&pdev->dev);
+}
+
+static const struct component_ops hdmi5_component_ops = {
+	.bind	= hdmi5_bind,
+	.unbind	= hdmi5_unbind,
+};
+
+static int hdmi5_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &hdmi5_component_ops);
+}
+
+static int hdmi5_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &hdmi5_component_ops);
+	return 0;
+}
+
+static int hdmi_runtime_suspend(struct device *dev)
+{
+	dispc_runtime_put();
+
+	return 0;
+}
+
+static int hdmi_runtime_resume(struct device *dev)
+{
+	int r;
+
+	r = dispc_runtime_get();
+	if (r < 0)
+		return r;
+
+	return 0;
+}
+
+static const struct dev_pm_ops hdmi_pm_ops = {
+	.runtime_suspend = hdmi_runtime_suspend,
+	.runtime_resume = hdmi_runtime_resume,
+};
+
+static const struct of_device_id hdmi_of_match[] = {
+	{ .compatible = "ti,omap5-hdmi", },
+	{ .compatible = "ti,dra7-hdmi", },
+	{},
+};
+
+static struct platform_driver omapdss_hdmihw_driver = {
+	.probe		= hdmi5_probe,
+	.remove		= hdmi5_remove,
+	.driver         = {
+		.name   = "omapdss_hdmi5",
+		.pm	= &hdmi_pm_ops,
+		.of_match_table = hdmi_of_match,
+		.suppress_bind_attrs = true,
+	},
+};
+
+int __init hdmi5_init_platform_driver(void)
+{
+	return platform_driver_register(&omapdss_hdmihw_driver);
+}
+
+void hdmi5_uninit_platform_driver(void)
+{
+	platform_driver_unregister(&omapdss_hdmihw_driver);
+}
