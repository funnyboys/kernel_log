commit 44dd0eef4a24bc4020f6c7b7aa855e341eb4bad2
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Apr 15 21:21:05 2020 +0800

    drm/omap: venc: remove unused variable 'venc_config_pal_bdghi'
    
    drivers/gpu/drm/omapdrm/dss/venc.c:211:33:
     warning: 'venc_config_pal_bdghi' defined but not used [-Wunused-const-variable=]
     static const struct venc_config venc_config_pal_bdghi = {
                                     ^~~~~~~~~~~~~~~~~~~~~
    
    It is never used, remove it.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415132105.43636-1-yuehaibing@huawei.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 766553bb2f87..9701843ccf09 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -208,49 +208,6 @@ static const struct venc_config venc_config_ntsc_trm = {
 	.gen_ctrl				= 0x00F90000,
 };
 
-static const struct venc_config venc_config_pal_bdghi = {
-	.f_control				= 0,
-	.vidout_ctrl				= 0,
-	.sync_ctrl				= 0,
-	.hfltr_ctrl				= 0,
-	.x_color				= 0,
-	.line21					= 0,
-	.ln_sel					= 21,
-	.htrigger_vtrigger			= 0,
-	.tvdetgp_int_start_stop_x		= 0x00140001,
-	.tvdetgp_int_start_stop_y		= 0x00010001,
-	.gen_ctrl				= 0x00FB0000,
-
-	.llen					= 864-1,
-	.flens					= 625-1,
-	.cc_carr_wss_carr			= 0x2F7625ED,
-	.c_phase				= 0xDF,
-	.gain_u					= 0x111,
-	.gain_v					= 0x181,
-	.gain_y					= 0x140,
-	.black_level				= 0x3e,
-	.blank_level				= 0x3e,
-	.m_control				= 0<<2 | 1<<1,
-	.bstamp_wss_data			= 0x42,
-	.s_carr					= 0x2a098acb,
-	.l21__wc_ctl				= 0<<13 | 0x16<<8 | 0<<0,
-	.savid__eavid				= 0x06A70108,
-	.flen__fal				= 23<<16 | 624<<0,
-	.lal__phase_reset			= 2<<17 | 310<<0,
-	.hs_int_start_stop_x			= 0x00920358,
-	.hs_ext_start_stop_x			= 0x000F035F,
-	.vs_int_start_x				= 0x1a7<<16,
-	.vs_int_stop_x__vs_int_start_y		= 0x000601A7,
-	.vs_int_stop_y__vs_ext_start_x		= 0x01AF0036,
-	.vs_ext_stop_x__vs_ext_start_y		= 0x27101af,
-	.vs_ext_stop_y				= 0x05,
-	.avid_start_stop_x			= 0x03530082,
-	.avid_start_stop_y			= 0x0270002E,
-	.fid_int_start_x__fid_int_start_y	= 0x0005008A,
-	.fid_int_offset_y__fid_ext_start_x	= 0x002E0138,
-	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
-};
-
 enum venc_videomode {
 	VENC_MODE_UNKNOWN,
 	VENC_MODE_PAL,

commit 96b0a34d27333e9df724a3efe95daeb68097b2ca
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:25:02 2020 +0200

    drm/omap: venc: Remove omap_dss_device operations
    
    Now that the VENC output is driven fully through the drm_bridge API its
    omap_dss_device operations are not used anymore. Remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-43-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index c8c19967a42f..766553bb2f87 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -306,7 +306,6 @@ struct venc_device {
 	struct drm_bridge bridge;
 };
 
-#define dssdev_to_venc(dssdev) container_of(dssdev, struct venc_device, output)
 #define drm_bridge_to_venc(b) container_of(b, struct venc_device, bridge)
 
 static inline void venc_write_reg(struct venc_device *venc, int idx, u32 val)
@@ -479,30 +478,6 @@ static void venc_power_off(struct venc_device *venc)
 	venc_runtime_put(venc);
 }
 
-static int venc_get_modes(struct omap_dss_device *dssdev,
-			  struct drm_connector *connector)
-{
-	static const struct drm_display_mode *modes[] = {
-		&omap_dss_pal_mode,
-		&omap_dss_ntsc_mode,
-	};
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
-		struct drm_display_mode *mode;
-
-		mode = drm_mode_duplicate(connector->dev, modes[i]);
-		if (!mode)
-			return i;
-
-		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
-		drm_mode_set_name(mode);
-		drm_mode_probed_add(connector, mode);
-	}
-
-	return ARRAY_SIZE(modes);
-}
-
 static enum venc_videomode venc_get_videomode(const struct drm_display_mode *mode)
 {
 	if (!(mode->flags & DRM_MODE_FLAG_INTERLACE))
@@ -598,25 +573,6 @@ static int venc_get_clocks(struct venc_device *venc)
 	return 0;
 }
 
-static int venc_connect(struct omap_dss_device *src,
-			struct omap_dss_device *dst)
-{
-	return omapdss_device_connect(dst->dss, dst, dst->next);
-}
-
-static void venc_disconnect(struct omap_dss_device *src,
-			    struct omap_dss_device *dst)
-{
-	omapdss_device_disconnect(dst, dst->next);
-}
-
-static const struct omap_dss_device_ops venc_ops = {
-	.connect = venc_connect,
-	.disconnect = venc_disconnect,
-
-	.get_modes = venc_get_modes,
-};
-
 /* -----------------------------------------------------------------------------
  * DRM Bridge Operations
  */
@@ -816,7 +772,6 @@ static int venc_init_output(struct venc_device *venc)
 	out->type = OMAP_DISPLAY_TYPE_VENC;
 	out->name = "venc.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
-	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
 	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_MODES;

commit e7e67d9a2f1dd2f938adcc219b3769f5cc3f0df7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:59 2020 +0200

    drm/omap: Switch the HDMI and VENC outputs to drm_bridge
    
    The TPD12S015, OPA362 and analog and HDMI connectors are now supported
    by DRM bridge drivers, and the omapdrm HDMI and VENC outputs can be
    handled through the drm_bridge API. Switch the outputs to drm_bridge by
    making the next bridge mandatory and removing the related
    omapdrm-specific display drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-40-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index cb9a689ed612..c8c19967a42f 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -626,8 +626,8 @@ static int venc_bridge_attach(struct drm_bridge *bridge,
 {
 	struct venc_device *venc = drm_bridge_to_venc(bridge);
 
-	if (venc->output.next_bridge)
-		return 0;
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))
+		return -EINVAL;
 
 	return drm_bridge_attach(bridge->encoder, venc->output.next_bridge,
 				 bridge, flags);

commit 2f004792adadcf017fde50339b432a26039fff0c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:57 2020 +0200

    drm/omap: venc: Register a drm_bridge
    
    In order to integrate with a chain of drm_bridge, the internal VENC
    encoder has to expose the mode valid, fixup and set, the enable and
    disable and the get modes operations through the drm_bridge API.
    Register a bridge at initialisation time to do so.
    
    Most of those operations are removed from the omap_dss_device as they
    are now called through the drm_bridge API by the DRM atomic helpers. The
    only exception is the .get_modes() operation that is still invoked
    through the omap_dss_device-based pipeline.
    
    For the time being make the next bridge in the chain optional as the
    VENC output is still based on omap_dss_device. The create_connector
    argument to the bridge attach function is also ignored for the same
    reason. This will be changed later when removing the related
    omapdrm-specific display drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-38-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 977d8d525b43..cb9a689ed612 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -13,7 +13,6 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/io.h>
-#include <linux/mutex.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/string.h>
@@ -26,6 +25,8 @@
 #include <linux/component.h>
 #include <linux/sys_soc.h>
 
+#include <drm/drm_bridge.h>
+
 #include "omapdss.h"
 #include "dss.h"
 
@@ -289,7 +290,6 @@ static const struct drm_display_mode omap_dss_ntsc_mode = {
 struct venc_device {
 	struct platform_device *pdev;
 	void __iomem *base;
-	struct mutex venc_lock;
 	struct regulator *vdda_dac_reg;
 	struct dss_device *dss;
 
@@ -303,9 +303,11 @@ struct venc_device {
 	bool requires_tv_dac_clk;
 
 	struct omap_dss_device output;
+	struct drm_bridge bridge;
 };
 
 #define dssdev_to_venc(dssdev) container_of(dssdev, struct venc_device, output)
+#define drm_bridge_to_venc(b) container_of(b, struct venc_device, bridge)
 
 static inline void venc_write_reg(struct venc_device *venc, int idx, u32 val)
 {
@@ -477,32 +479,6 @@ static void venc_power_off(struct venc_device *venc)
 	venc_runtime_put(venc);
 }
 
-static void venc_display_enable(struct omap_dss_device *dssdev)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-
-	DSSDBG("venc_display_enable\n");
-
-	mutex_lock(&venc->venc_lock);
-
-	venc_power_on(venc);
-
-	mutex_unlock(&venc->venc_lock);
-}
-
-static void venc_display_disable(struct omap_dss_device *dssdev)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-
-	DSSDBG("venc_display_disable\n");
-
-	mutex_lock(&venc->venc_lock);
-
-	venc_power_off(venc);
-
-	mutex_unlock(&venc->venc_lock);
-}
-
 static int venc_get_modes(struct omap_dss_device *dssdev,
 			  struct drm_connector *connector)
 {
@@ -545,57 +521,6 @@ static enum venc_videomode venc_get_videomode(const struct drm_display_mode *mod
 	return VENC_MODE_UNKNOWN;
 }
 
-static void venc_set_timings(struct omap_dss_device *dssdev,
-			     const struct drm_display_mode *mode)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-	enum venc_videomode venc_mode = venc_get_videomode(mode);
-
-	DSSDBG("venc_set_timings\n");
-
-	mutex_lock(&venc->venc_lock);
-
-	switch (venc_mode) {
-	default:
-		WARN_ON_ONCE(1);
-		/* Fall-through */
-	case VENC_MODE_PAL:
-		venc->config = &venc_config_pal_trm;
-		break;
-
-	case VENC_MODE_NTSC:
-		venc->config = &venc_config_ntsc_trm;
-		break;
-	}
-
-	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
-
-	mutex_unlock(&venc->venc_lock);
-}
-
-static int venc_check_timings(struct omap_dss_device *dssdev,
-			      struct drm_display_mode *mode)
-{
-	DSSDBG("venc_check_timings\n");
-
-	switch (venc_get_videomode(mode)) {
-	case VENC_MODE_PAL:
-		drm_mode_copy(mode, &omap_dss_pal_mode);
-		break;
-
-	case VENC_MODE_NTSC:
-		drm_mode_copy(mode, &omap_dss_ntsc_mode);
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
-	drm_mode_set_name(mode);
-	return 0;
-}
-
 static int venc_dump_regs(struct seq_file *s, void *p)
 {
 	struct venc_device *venc = s->private;
@@ -689,15 +614,152 @@ static const struct omap_dss_device_ops venc_ops = {
 	.connect = venc_connect,
 	.disconnect = venc_disconnect,
 
-	.enable = venc_display_enable,
-	.disable = venc_display_disable,
+	.get_modes = venc_get_modes,
+};
 
-	.check_timings = venc_check_timings,
-	.set_timings = venc_set_timings,
+/* -----------------------------------------------------------------------------
+ * DRM Bridge Operations
+ */
 
-	.get_modes = venc_get_modes,
+static int venc_bridge_attach(struct drm_bridge *bridge,
+			      enum drm_bridge_attach_flags flags)
+{
+	struct venc_device *venc = drm_bridge_to_venc(bridge);
+
+	if (venc->output.next_bridge)
+		return 0;
+
+	return drm_bridge_attach(bridge->encoder, venc->output.next_bridge,
+				 bridge, flags);
+}
+
+static enum drm_mode_status
+venc_bridge_mode_valid(struct drm_bridge *bridge,
+		       const struct drm_display_mode *mode)
+{
+	switch (venc_get_videomode(mode)) {
+	case VENC_MODE_PAL:
+	case VENC_MODE_NTSC:
+		return MODE_OK;
+
+	default:
+		return MODE_BAD;
+	}
+}
+
+static bool venc_bridge_mode_fixup(struct drm_bridge *bridge,
+				   const struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	const struct drm_display_mode *venc_mode;
+
+	switch (venc_get_videomode(adjusted_mode)) {
+	case VENC_MODE_PAL:
+		venc_mode = &omap_dss_pal_mode;
+		break;
+
+	case VENC_MODE_NTSC:
+		venc_mode = &omap_dss_ntsc_mode;
+		break;
+
+	default:
+		return false;
+	}
+
+	drm_mode_copy(adjusted_mode, venc_mode);
+	drm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);
+	drm_mode_set_name(adjusted_mode);
+
+	return true;
+}
+
+static void venc_bridge_mode_set(struct drm_bridge *bridge,
+				 const struct drm_display_mode *mode,
+				 const struct drm_display_mode *adjusted_mode)
+{
+	struct venc_device *venc = drm_bridge_to_venc(bridge);
+	enum venc_videomode venc_mode = venc_get_videomode(adjusted_mode);
+
+	switch (venc_mode) {
+	default:
+		WARN_ON_ONCE(1);
+		/* Fall-through */
+	case VENC_MODE_PAL:
+		venc->config = &venc_config_pal_trm;
+		break;
+
+	case VENC_MODE_NTSC:
+		venc->config = &venc_config_ntsc_trm;
+		break;
+	}
+
+	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
+}
+
+static void venc_bridge_enable(struct drm_bridge *bridge)
+{
+	struct venc_device *venc = drm_bridge_to_venc(bridge);
+
+	venc_power_on(venc);
+}
+
+static void venc_bridge_disable(struct drm_bridge *bridge)
+{
+	struct venc_device *venc = drm_bridge_to_venc(bridge);
+
+	venc_power_off(venc);
+}
+
+static int venc_bridge_get_modes(struct drm_bridge *bridge,
+				 struct drm_connector *connector)
+{
+	static const struct drm_display_mode *modes[] = {
+		&omap_dss_pal_mode,
+		&omap_dss_ntsc_mode,
+	};
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+		struct drm_display_mode *mode;
+
+		mode = drm_mode_duplicate(connector->dev, modes[i]);
+		if (!mode)
+			return i;
+
+		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+		drm_mode_set_name(mode);
+		drm_mode_probed_add(connector, mode);
+	}
+
+	return ARRAY_SIZE(modes);
+}
+
+static const struct drm_bridge_funcs venc_bridge_funcs = {
+	.attach = venc_bridge_attach,
+	.mode_valid = venc_bridge_mode_valid,
+	.mode_fixup = venc_bridge_mode_fixup,
+	.mode_set = venc_bridge_mode_set,
+	.enable = venc_bridge_enable,
+	.disable = venc_bridge_disable,
+	.get_modes = venc_bridge_get_modes,
 };
 
+static void venc_bridge_init(struct venc_device *venc)
+{
+	venc->bridge.funcs = &venc_bridge_funcs;
+	venc->bridge.of_node = venc->pdev->dev.of_node;
+	venc->bridge.ops = DRM_BRIDGE_OP_MODES;
+	venc->bridge.type = DRM_MODE_CONNECTOR_SVIDEO;
+	venc->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&venc->bridge);
+}
+
+static void venc_bridge_cleanup(struct venc_device *venc)
+{
+	drm_bridge_remove(&venc->bridge);
+}
+
 /* -----------------------------------------------------------------------------
  * Component Bind & Unbind
  */
@@ -747,6 +809,8 @@ static int venc_init_output(struct venc_device *venc)
 	struct omap_dss_device *out = &venc->output;
 	int r;
 
+	venc_bridge_init(venc);
+
 	out->dev = &venc->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_VENC;
 	out->type = OMAP_DISPLAY_TYPE_VENC;
@@ -757,9 +821,11 @@ static int venc_init_output(struct venc_device *venc)
 	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
 
-	r = omapdss_device_init_output(out, NULL);
-	if (r < 0)
+	r = omapdss_device_init_output(out, &venc->bridge);
+	if (r < 0) {
+		venc_bridge_cleanup(venc);
 		return r;
+	}
 
 	omapdss_device_register(out);
 
@@ -770,6 +836,8 @@ static void venc_uninit_output(struct venc_device *venc)
 {
 	omapdss_device_unregister(&venc->output);
 	omapdss_device_cleanup_output(&venc->output);
+
+	venc_bridge_cleanup(venc);
 }
 
 static int venc_probe_of(struct venc_device *venc)
@@ -839,8 +907,6 @@ static int venc_probe(struct platform_device *pdev)
 	if (soc_device_match(venc_soc_devices))
 		venc->requires_tv_dac_clk = true;
 
-	mutex_init(&venc->venc_lock);
-
 	venc->config = &venc_config_pal_trm;
 
 	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);

commit 326a1166ca0826e2fdccc2b9174a8f7802bd5100
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:46 2020 +0200

    drm/omap: Add infrastructure to support drm_bridge local to DSS outputs
    
    In order to support drm_bridge-based pipeline, the internal HDMI
    encoders will need to expose the EDID read operation through the
    drm_bridge API, and thus to expose a drm_bridge instance corresponding
    to the encoder. The HDMI encoders are however handled as omap_dss_device
    instances, which conflicts with this requirement.
    
    In order to move forward with the drm_bridge transition, add support for
    creating drm_bridge instances local to DSS outputs. If a local bridge is
    passed to the omapdss_device_init_output() function, it is used as the
    first bridge in the chain, and the omap_dss_device.next_bridge field is
    set to the next bridge for the use of the internal encoders' bridges.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-27-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index e2f480f689b8..977d8d525b43 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -757,7 +757,7 @@ static int venc_init_output(struct venc_device *venc)
 	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
 
-	r = omapdss_device_init_output(out);
+	r = omapdss_device_init_output(out, NULL);
 	if (r < 0)
 		return r;
 

commit c83fefd738344cf5bf22e1e1442e6f746b85c1d4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:45 2020 +0200

    drm/omap: dss: Fix output next device lookup in DT
    
    The DSS core looks up the next device connected to an output by
    traversing the OF graph. It currently hardcodes the local port number to
    0, which breaks any output with a different port number (SDI on OMAP3
    and any DPI output but the first one). Fix this by repurposing the
    currently unused of_ports bitmask in omap_dss_device with an of_port
    output port number, and use it to traverse the OF graph.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-26-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 596a297d5813..e2f480f689b8 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -754,7 +754,7 @@ static int venc_init_output(struct venc_device *venc)
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
-	out->of_ports = BIT(0);
+	out->of_port = 0;
 	out->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
 
 	r = omapdss_device_init_output(out);

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index da43b865d973..596a297d5813 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * VENC settings from TI's DSS driver
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define DSS_SUBSYS_NAME "VENC"

commit 0dbfc396672025d3ef8bacc934b80a5463e75c6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 10 14:00:38 2018 +0200

    drm/omap: Merge omap_dss_device type and output_type fields
    
    The omap_dss_device type and output_type fields differ mostly for
    historical reasons. The output_type field is required for all devices
    but the display at the end of the pipeline, and must be set to
    OMAP_DISPLAY_TYPE_NONE for the latter. The type field is required for
    all devices but the internal encoder, for which it is ignored.
    
    The only reason why the output_type field must be set to
    OMAP_DISPLAY_TYPE_NONE for the display at the end of the pipeline is to
    identify omap_dss_device instances corresponding to displays. This is
    not documented and confusing.
    
    Clean the code by adding a new display field to the omap_dss_device
    structure to identify displays, and merge the type and output_type
    fields.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index f2cbecfd05b5..da43b865d973 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -760,7 +760,7 @@ static int venc_init_output(struct venc_device *venc)
 
 	out->dev = &venc->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_VENC;
-	out->output_type = OMAP_DISPLAY_TYPE_VENC;
+	out->type = OMAP_DISPLAY_TYPE_VENC;
 	out->name = "venc.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &venc_ops;

commit b08644a235a4f2d3ba5b86ba02ea404e5edad695
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 18:11:15 2018 +0300

    drm/omap: venc: Use drm_display_mode natively
    
    Replace internal usage of struct videomode with struct drm_display_mode
    in order to avoid converting needlessly between the data structures.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 7bce5898654a..f2cbecfd05b5 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -267,38 +267,34 @@ enum venc_videomode {
 	VENC_MODE_NTSC,
 };
 
-static const struct videomode omap_dss_pal_vm = {
-	.hactive	= 720,
-	.vactive	= 574,
-	.pixelclock	= 13500000,
-	.hsync_len	= 64,
-	.hfront_porch	= 12,
-	.hback_porch	= 68,
-	.vsync_len	= 5,
-	.vfront_porch	= 5,
-	.vback_porch	= 41,
-
-	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
-			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
-			  DISPLAY_FLAGS_SYNC_NEGEDGE,
+static const struct drm_display_mode omap_dss_pal_mode = {
+	.hdisplay	= 720,
+	.hsync_start	= 732,
+	.hsync_end	= 796,
+	.htotal		= 864,
+	.vdisplay	= 574,
+	.vsync_start	= 579,
+	.vsync_end	= 584,
+	.vtotal		= 625,
+	.clock		= 13500,
+
+	.flags		= DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_NHSYNC |
+			  DRM_MODE_FLAG_NVSYNC,
 };
 
-static const struct videomode omap_dss_ntsc_vm = {
-	.hactive	= 720,
-	.vactive	= 482,
-	.pixelclock	= 13500000,
-	.hsync_len	= 64,
-	.hfront_porch	= 16,
-	.hback_porch	= 58,
-	.vsync_len	= 6,
-	.vfront_porch	= 6,
-	.vback_porch	= 31,
-
-	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
-			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
-			  DISPLAY_FLAGS_SYNC_NEGEDGE,
+static const struct drm_display_mode omap_dss_ntsc_mode = {
+	.hdisplay	= 720,
+	.hsync_start	= 736,
+	.hsync_end	= 800,
+	.htotal		= 858,
+	.vdisplay	= 482,
+	.vsync_start	= 488,
+	.vsync_end	= 494,
+	.vtotal		= 525,
+	.clock		= 13500,
+
+	.flags		= DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_NHSYNC |
+			  DRM_MODE_FLAG_NVSYNC,
 };
 
 struct venc_device {
@@ -521,21 +517,19 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 static int venc_get_modes(struct omap_dss_device *dssdev,
 			  struct drm_connector *connector)
 {
-	static const struct videomode *modes[] = {
-		&omap_dss_pal_vm,
-		&omap_dss_ntsc_vm,
+	static const struct drm_display_mode *modes[] = {
+		&omap_dss_pal_mode,
+		&omap_dss_ntsc_mode,
 	};
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
 		struct drm_display_mode *mode;
 
-		mode = drm_mode_create(connector->dev);
+		mode = drm_mode_duplicate(connector->dev, modes[i]);
 		if (!mode)
 			return i;
 
-		drm_display_mode_from_videomode(modes[i], mode);
-
 		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
 		drm_mode_set_name(mode);
 		drm_mode_probed_add(connector, mode);
@@ -549,14 +543,14 @@ static enum venc_videomode venc_get_videomode(const struct drm_display_mode *mod
 	if (!(mode->flags & DRM_MODE_FLAG_INTERLACE))
 		return VENC_MODE_UNKNOWN;
 
-	if (mode->clock == omap_dss_pal_vm.pixelclock / 1000 &&
-	    mode->hdisplay == omap_dss_pal_vm.hactive &&
-	    mode->vdisplay == omap_dss_pal_vm.vactive)
+	if (mode->clock == omap_dss_pal_mode.clock &&
+	    mode->hdisplay == omap_dss_pal_mode.hdisplay &&
+	    mode->vdisplay == omap_dss_pal_mode.vdisplay)
 		return VENC_MODE_PAL;
 
-	if (mode->clock == omap_dss_ntsc_vm.pixelclock / 1000 &&
-	    mode->hdisplay == omap_dss_ntsc_vm.hactive &&
-	    mode->vdisplay == omap_dss_ntsc_vm.vactive)
+	if (mode->clock == omap_dss_ntsc_mode.clock &&
+	    mode->hdisplay == omap_dss_ntsc_mode.hdisplay &&
+	    mode->vdisplay == omap_dss_ntsc_mode.vdisplay)
 		return VENC_MODE_NTSC;
 
 	return VENC_MODE_UNKNOWN;
@@ -597,16 +591,20 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 
 	switch (venc_get_videomode(mode)) {
 	case VENC_MODE_PAL:
-		drm_display_mode_from_videomode(&omap_dss_pal_vm, mode);
-		return 0;
+		drm_mode_copy(mode, &omap_dss_pal_mode);
+		break;
 
 	case VENC_MODE_NTSC:
-		drm_display_mode_from_videomode(&omap_dss_ntsc_vm, mode);
-		return 0;
+		drm_mode_copy(mode, &omap_dss_ntsc_mode);
+		break;
 
 	default:
 		return -EINVAL;
 	}
+
+	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+	drm_mode_set_name(mode);
+	return 0;
 }
 
 static int venc_dump_regs(struct seq_file *s, void *p)

commit 41322aa691950431ccef115e85b2d6bba654bd70
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Sep 21 17:00:29 2018 +0300

    drm/omap: Pass drm_display_mode to .check_timings() and .set_timings()
    
    The omap_dss_device .check_timings() and .set_timings() operations
    operate on struct videomode, while the DRM API operates on struct
    drm_display_mode. This forces conversion from to videomode in the
    callers. While that's not a problem per se, it creates a difference with
    the drm_bridge API.
    
    Replace the videomode parameter to the .check_timings() and
    .set_timings() operations with a drm_display_mode. This pushed the
    conversion to videomode down to the DSS devices in some cases. If needed
    they will be converted to operate on drm_display_mode natively.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 6cb708e1944e..7bce5898654a 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -544,29 +544,29 @@ static int venc_get_modes(struct omap_dss_device *dssdev,
 	return ARRAY_SIZE(modes);
 }
 
-static enum venc_videomode venc_get_videomode(const struct videomode *vm)
+static enum venc_videomode venc_get_videomode(const struct drm_display_mode *mode)
 {
-	if (!(vm->flags & DISPLAY_FLAGS_INTERLACED))
+	if (!(mode->flags & DRM_MODE_FLAG_INTERLACE))
 		return VENC_MODE_UNKNOWN;
 
-	if (vm->pixelclock == omap_dss_pal_vm.pixelclock &&
-	    vm->hactive == omap_dss_pal_vm.hactive &&
-	    vm->vactive == omap_dss_pal_vm.vactive)
+	if (mode->clock == omap_dss_pal_vm.pixelclock / 1000 &&
+	    mode->hdisplay == omap_dss_pal_vm.hactive &&
+	    mode->vdisplay == omap_dss_pal_vm.vactive)
 		return VENC_MODE_PAL;
 
-	if (vm->pixelclock == omap_dss_ntsc_vm.pixelclock &&
-	    vm->hactive == omap_dss_ntsc_vm.hactive &&
-	    vm->vactive == omap_dss_ntsc_vm.vactive)
+	if (mode->clock == omap_dss_ntsc_vm.pixelclock / 1000 &&
+	    mode->hdisplay == omap_dss_ntsc_vm.hactive &&
+	    mode->vdisplay == omap_dss_ntsc_vm.vactive)
 		return VENC_MODE_NTSC;
 
 	return VENC_MODE_UNKNOWN;
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
-			     const struct videomode *vm)
+			     const struct drm_display_mode *mode)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
-	enum venc_videomode venc_mode = venc_get_videomode(vm);
+	enum venc_videomode venc_mode = venc_get_videomode(mode);
 
 	DSSDBG("venc_set_timings\n");
 
@@ -591,17 +591,17 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 }
 
 static int venc_check_timings(struct omap_dss_device *dssdev,
-			      struct videomode *vm)
+			      struct drm_display_mode *mode)
 {
 	DSSDBG("venc_check_timings\n");
 
-	switch (venc_get_videomode(vm)) {
+	switch (venc_get_videomode(mode)) {
 	case VENC_MODE_PAL:
-		*vm = omap_dss_pal_vm;
+		drm_display_mode_from_videomode(&omap_dss_pal_vm, mode);
 		return 0;
 
 	case VENC_MODE_NTSC:
-		*vm = omap_dss_ntsc_vm;
+		drm_display_mode_from_videomode(&omap_dss_ntsc_vm, mode);
 		return 0;
 
 	default:

commit d60dfaba4225d72e54ec887c5e307dd9fc0aa1db
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 20 01:47:17 2018 +0300

    drm/omap: venc: Simplify mode setting by caching configuration
    
    The mode setting handler of the VENC stores the video mode internally,
    to then convert it to a configuration when programming the hardware. The
    stored mode is otherwise unused. Cache the configuration directly
    instead.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 638cfd69ccf6..6cb708e1944e 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -301,24 +301,6 @@ static const struct videomode omap_dss_ntsc_vm = {
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
 
-static enum venc_videomode venc_get_videomode(const struct videomode *vm)
-{
-	if (!(vm->flags & DISPLAY_FLAGS_INTERLACED))
-		return VENC_MODE_UNKNOWN;
-
-	if (vm->pixelclock == omap_dss_pal_vm.pixelclock &&
-	    vm->hactive == omap_dss_pal_vm.hactive &&
-	    vm->vactive == omap_dss_pal_vm.vactive)
-		return VENC_MODE_PAL;
-
-	if (vm->pixelclock == omap_dss_ntsc_vm.pixelclock &&
-	    vm->hactive == omap_dss_ntsc_vm.hactive &&
-	    vm->vactive == omap_dss_ntsc_vm.vactive)
-		return VENC_MODE_NTSC;
-
-	return VENC_MODE_UNKNOWN;
-}
-
 struct venc_device {
 	struct platform_device *pdev;
 	void __iomem *base;
@@ -330,7 +312,7 @@ struct venc_device {
 
 	struct clk	*tv_dac_clk;
 
-	struct videomode vm;
+	const struct venc_config *config;
 	enum omap_dss_venc_type type;
 	bool invert_polarity;
 	bool requires_tv_dac_clk;
@@ -450,18 +432,6 @@ static void venc_runtime_put(struct venc_device *venc)
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
-static const struct venc_config *venc_timings_to_config(const struct videomode *vm)
-{
-	switch (venc_get_videomode(vm)) {
-	default:
-		WARN_ON_ONCE(1);
-	case VENC_MODE_PAL:
-		return &venc_config_pal_trm;
-	case VENC_MODE_NTSC:
-		return &venc_config_ntsc_trm;
-	}
-}
-
 static int venc_power_on(struct venc_device *venc)
 {
 	u32 l;
@@ -472,7 +442,7 @@ static int venc_power_on(struct venc_device *venc)
 		goto err0;
 
 	venc_reset(venc);
-	venc_write_config(venc, venc_timings_to_config(&venc->vm));
+	venc_write_config(venc, venc->config);
 
 	dss_set_venc_output(venc->dss, venc->type);
 	dss_set_dac_pwrdn_bgz(venc->dss, 1);
@@ -574,16 +544,46 @@ static int venc_get_modes(struct omap_dss_device *dssdev,
 	return ARRAY_SIZE(modes);
 }
 
+static enum venc_videomode venc_get_videomode(const struct videomode *vm)
+{
+	if (!(vm->flags & DISPLAY_FLAGS_INTERLACED))
+		return VENC_MODE_UNKNOWN;
+
+	if (vm->pixelclock == omap_dss_pal_vm.pixelclock &&
+	    vm->hactive == omap_dss_pal_vm.hactive &&
+	    vm->vactive == omap_dss_pal_vm.vactive)
+		return VENC_MODE_PAL;
+
+	if (vm->pixelclock == omap_dss_ntsc_vm.pixelclock &&
+	    vm->hactive == omap_dss_ntsc_vm.hactive &&
+	    vm->vactive == omap_dss_ntsc_vm.vactive)
+		return VENC_MODE_NTSC;
+
+	return VENC_MODE_UNKNOWN;
+}
+
 static void venc_set_timings(struct omap_dss_device *dssdev,
 			     const struct videomode *vm)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
+	enum venc_videomode venc_mode = venc_get_videomode(vm);
 
 	DSSDBG("venc_set_timings\n");
 
 	mutex_lock(&venc->venc_lock);
 
-	venc->vm = *vm;
+	switch (venc_mode) {
+	default:
+		WARN_ON_ONCE(1);
+		/* Fall-through */
+	case VENC_MODE_PAL:
+		venc->config = &venc_config_pal_trm;
+		break;
+
+	case VENC_MODE_NTSC:
+		venc->config = &venc_config_ntsc_trm;
+		break;
+	}
 
 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
@@ -854,7 +854,7 @@ static int venc_probe(struct platform_device *pdev)
 
 	mutex_init(&venc->venc_lock);
 
-	venc->vm = omap_dss_pal_vm;
+	venc->config = &venc_config_pal_trm;
 
 	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);
 	venc->base = devm_ioremap_resource(&pdev->dev, venc_mem);

commit 40e5f937d50fce297db3ee5c75e30bf4e1518f3b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 13 00:39:01 2018 +0300

    drm/omap: venc: List both PAL and NTSC modes
    
    The TV encoder supports both PAL and NTSC modes, but when queried for
    the list of modes it supports, only the currently selected mode is
    reported. Fix it and report the two modes unconditionally.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index f1abb4195a76..638cfd69ccf6 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -551,14 +551,27 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 static int venc_get_modes(struct omap_dss_device *dssdev,
 			  struct drm_connector *connector)
 {
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-	int r;
+	static const struct videomode *modes[] = {
+		&omap_dss_pal_vm,
+		&omap_dss_ntsc_vm,
+	};
+	unsigned int i;
 
-	mutex_lock(&venc->venc_lock);
-	r = omapdss_display_get_modes(connector, &venc->vm);
-	mutex_unlock(&venc->venc_lock);
+	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+		struct drm_display_mode *mode;
 
-	return r;
+		mode = drm_mode_create(connector->dev);
+		if (!mode)
+			return i;
+
+		drm_display_mode_from_videomode(modes[i], mode);
+
+		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+		drm_mode_set_name(mode);
+		drm_mode_probed_add(connector, mode);
+	}
+
+	return ARRAY_SIZE(modes);
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,

commit 46b3847d7f680d51a29384a5ee9e1d54e6739f5d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 13 00:37:35 2018 +0300

    drm/omap: Add a dss device operation flag for .get_modes()
    
    Instead of manually iterating over the dss devices in the pipeline to
    find the first one that implements the .get_modes() operation, add a new
    operation flag for .get_modes() and use the omap_connector_find_device()
    helper function to locate the right dss device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index cefefe6d6fcb..f1abb4195a76 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -755,6 +755,7 @@ static int venc_init_output(struct venc_device *venc)
 	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
 	out->of_ports = BIT(0);
+	out->ops_flags = OMAP_DSS_DEVICE_OP_MODES;
 
 	r = omapdss_device_init_output(out);
 	if (r < 0)

commit 870e19d59f8a2e13750861d8f8f49e93188634ec
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 13 00:17:01 2018 +0300

    drm/omap: Expose DRM modes instead of timings in display devices
    
    omap_dss_device operations expose fixed video timings through a
    .get_timings() operation that return a single timing for the device. To
    prepare for the move to drm_bridge, modify the API to instead add DRM
    modes directly to the connector.
    
    As this puts more burden on display devices, we also create a helper
    function for panels to add a single DRM mode from the panel video
    timings.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 3fc776c45c4f..cefefe6d6fcb 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -548,14 +548,17 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 	mutex_unlock(&venc->venc_lock);
 }
 
-static void venc_get_timings(struct omap_dss_device *dssdev,
-			     struct videomode *vm)
+static int venc_get_modes(struct omap_dss_device *dssdev,
+			  struct drm_connector *connector)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
+	int r;
 
 	mutex_lock(&venc->venc_lock);
-	*vm = venc->vm;
+	r = omapdss_display_get_modes(connector, &venc->vm);
 	mutex_unlock(&venc->venc_lock);
+
+	return r;
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
@@ -690,8 +693,9 @@ static const struct omap_dss_device_ops venc_ops = {
 	.disable = venc_display_disable,
 
 	.check_timings = venc_check_timings,
-	.get_timings = venc_get_timings,
 	.set_timings = venc_set_timings,
+
+	.get_modes = venc_get_modes,
 };
 
 /* -----------------------------------------------------------------------------

commit d17eb4537a7eb16da9eafbfd5717e12b45b77251
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Sep 12 19:41:31 2018 +0300

    drm/omap: Factor out common init/cleanup code for output devices
    
    All the internal encoders share common init and cleanup code. Factor it
    out to separate functions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index dc4133718875..3fc776c45c4f 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -752,19 +752,9 @@ static int venc_init_output(struct venc_device *venc)
 	out->owner = THIS_MODULE;
 	out->of_ports = BIT(0);
 
-	out->next = omapdss_of_find_connected_device(out->dev->of_node, 0);
-	if (IS_ERR(out->next)) {
-		if (PTR_ERR(out->next) != -EPROBE_DEFER)
-			dev_err(out->dev, "failed to find video sink\n");
-		return PTR_ERR(out->next);
-	}
-
-	r = omapdss_output_validate(out);
-	if (r) {
-		omapdss_device_put(out->next);
-		out->next = NULL;
+	r = omapdss_device_init_output(out);
+	if (r < 0)
 		return r;
-	}
 
 	omapdss_device_register(out);
 
@@ -773,9 +763,8 @@ static int venc_init_output(struct venc_device *venc)
 
 static void venc_uninit_output(struct venc_device *venc)
 {
-	if (venc->output.next)
-		omapdss_device_put(venc->output.next);
 	omapdss_device_unregister(&venc->output);
+	omapdss_device_cleanup_output(&venc->output);
 }
 
 static int venc_probe_of(struct venc_device *venc)

commit 19b4200d8f4b90b5a41592f9021b52153ac2b6b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 24 19:38:07 2018 +0300

    drm/omap: Reverse direction of the DSS device enable/disable operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    Reconcile the omapdrm and omapdss drivers with the DRM bridge and panel
    model by reversing the direction of the DSS device .enable() and
    .disable() operations. This completes the move to the DRM bridge model,
    with the notable exception of the DSI pipelines that will require more
    work.
    
    We also adapt the omapdss shutdown handler dss_shutdown() to shut down
    all active pipelines starting from the pipeline output device instead of
    the display device.
    
    As a consequence the for_each_dss_display() macro isn't used and can be
    removed, and the omapdss_device_get_next() function underlying the macro
    can be simplified to search for output devices only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index bc9a3d52f34d..dc4133718875 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -522,25 +522,17 @@ static void venc_power_off(struct venc_device *venc)
 	venc_runtime_put(venc);
 }
 
-static int venc_display_enable(struct omap_dss_device *dssdev)
+static void venc_display_enable(struct omap_dss_device *dssdev)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
-	int r;
 
 	DSSDBG("venc_display_enable\n");
 
 	mutex_lock(&venc->venc_lock);
 
-	r = venc_power_on(venc);
-	if (r)
-		goto err0;
-
-	mutex_unlock(&venc->venc_lock);
+	venc_power_on(venc);
 
-	return 0;
-err0:
 	mutex_unlock(&venc->venc_lock);
-	return r;
 }
 
 static void venc_display_disable(struct omap_dss_device *dssdev)

commit f8a8eabb273b6810d0eb7546896e5da7974189a5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 4 23:53:34 2018 +0300

    drm/omap: Remove connection checks from internal encoders .enable()
    
    The internal encoders return an error from their .enable() handler when
    their are not connected to a dss manager. As the flag used is set and
    cleared in the connect and disconnect handlers, this effectively checks
    whether the omap_dss_device is connected.
    
    The .enable() handler is called from code paths that access the dss
    devices chain from the display device, which is set to NULL when the
    device isn't connected, making it impossible to access the device in
    that case.
    
    The safety check is thus not needed, remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index fbe9d42dbdb6..bc9a3d52f34d 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -531,12 +531,6 @@ static int venc_display_enable(struct omap_dss_device *dssdev)
 
 	mutex_lock(&venc->venc_lock);
 
-	if (!dssdev->dispc_channel_connected) {
-		DSSERR("Failed to enable display: no output/manager\n");
-		r = -ENODEV;
-		goto err0;
-	}
-
 	r = venc_power_on(venc);
 	if (r)
 		goto err0;
@@ -687,21 +681,12 @@ static int venc_get_clocks(struct venc_device *venc)
 static int venc_connect(struct omap_dss_device *src,
 			struct omap_dss_device *dst)
 {
-	int r;
-
-	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r)
-		return r;
-
-	dst->dispc_channel_connected = true;
-	return 0;
+	return omapdss_device_connect(dst->dss, dst, dst->next);
 }
 
 static void venc_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
-	dst->dispc_channel_connected = false;
-
 	omapdss_device_disconnect(dst, dst->next);
 }
 

commit d79bd6b445a2f38726a4e4c406a0f9a25d85e340
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Sep 20 01:19:32 2018 +0300

    drm/omap: venc: Remove wss_data field from venc_device structure
    
    The venc_device structure wss_data field is set to 0 and never otherwise
    modified, remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index b5f52727f8b1..fbe9d42dbdb6 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -323,7 +323,6 @@ struct venc_device {
 	struct platform_device *pdev;
 	void __iomem *base;
 	struct mutex venc_lock;
-	u32 wss_data;
 	struct regulator *vdda_dac_reg;
 	struct dss_device *dss;
 
@@ -367,8 +366,7 @@ static void venc_write_config(struct venc_device *venc,
 	venc_write_reg(venc, VENC_BLACK_LEVEL, config->black_level);
 	venc_write_reg(venc, VENC_BLANK_LEVEL, config->blank_level);
 	venc_write_reg(venc, VENC_M_CONTROL, config->m_control);
-	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-		       venc->wss_data);
+	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data);
 	venc_write_reg(venc, VENC_S_CARR, config->s_carr);
 	venc_write_reg(venc, VENC_L21__WC_CTL, config->l21__wc_ctl);
 	venc_write_reg(venc, VENC_SAVID__EAVID, config->savid__eavid);
@@ -543,8 +541,6 @@ static int venc_display_enable(struct omap_dss_device *dssdev)
 	if (r)
 		goto err0;
 
-	venc->wss_data = 0;
-
 	mutex_unlock(&venc->venc_lock);
 
 	return 0;
@@ -585,10 +581,6 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 
 	mutex_lock(&venc->venc_lock);
 
-	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc->vm, vm, sizeof(*vm)))
-		venc->wss_data = 0;
-
 	venc->vm = *vm;
 
 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
@@ -878,7 +870,6 @@ static int venc_probe(struct platform_device *pdev)
 
 	mutex_init(&venc->venc_lock);
 
-	venc->wss_data = 0;
 	venc->vm = omap_dss_pal_vm;
 
 	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);

commit 24ec84e854c68ceda59a26027114eb7f260f9411
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Nov 10 13:16:54 2018 +0200

    drm/omap: Move DISPC runtime PM handling to omapdrm
    
    The internal encoders (DSI, HDMI4, HDMI5 and VENC) runtime PM handlers
    attempt to manage the runtime PM state of the connected DISPC, based on
    the rationale that the DISPC providing data to the encoders requires
    ensuring that the display is active whenever the encoders are active.
    
    While the DISPC provides data to the encoders, it doesn't as such
    constitute a resource that encoders require in order to be taken out
    of suspend, contrary to for instance a functional clock or a power
    supply. Encoders registers can be accessed without the DISPC being
    active, and while the encoders will not output any video stream without
    being fed by the DISPC, the DISPC PM state doesn't influence the
    encoders PM state.
    
    For this reason the DISPC PM state is better managed from the omapdrm
    driver, in the CRTC enable and disable operations. This allows the
    encoders PM state to be handled separately from the DISPC, and in
    particular at times when the DISPC may not be available (for instance at
    probe due to the DSS probe being deferred, or at remove time du to the
    DISPC being already removed).
    
    Fixes: edb715dffdee ("drm/omap: dss: dsi: Move initialization code from bind to probe")
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181110111654.4387-5-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index ff0b18c8e4ac..b5f52727f8b1 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -946,19 +946,12 @@ static int venc_runtime_suspend(struct device *dev)
 	if (venc->tv_dac_clk)
 		clk_disable_unprepare(venc->tv_dac_clk);
 
-	dispc_runtime_put(venc->dss->dispc);
-
 	return 0;
 }
 
 static int venc_runtime_resume(struct device *dev)
 {
 	struct venc_device *venc = dev_get_drvdata(dev);
-	int r;
-
-	r = dispc_runtime_get(venc->dss->dispc);
-	if (r < 0)
-		return r;
 
 	if (venc->tv_dac_clk)
 		clk_prepare_enable(venc->tv_dac_clk);

commit 6ea48430952323091194100d48c5610b9cd286b4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 7 19:55:04 2018 +0300

    drm/omap: Don't call .set_timings() operation recursively
    
    Instead of calling the .set_timings() operation recursively from the
    display device backwards, iterate over the devices manually in the DRM
    encoder code. This moves the complexity to a single central location and
    simplifies the logic in omap_dss_device drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 39e3c43c54c1..ff0b18c8e4ac 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -593,8 +593,6 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 
 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
-	dss_mgr_set_timings(&venc->output, vm);
-
 	mutex_unlock(&venc->venc_lock);
 }
 

commit d8dbe79143764b86bd04c63c044431565582a22d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 8 16:53:37 2018 +0300

    drm/omap: Store CRTC timings in .set_timings() operation
    
    The video timings are stored in the CRTC structure by the
    omap_crtc_dss_set_timings() function, called by dss_mgr_set_timings()
    from the .enable() operation of the internal encoders. This instead
    belongs to the .set_timings() code paths. Move the
    omap_crtc_dss_set_timings() calls accordingly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 126efbf89898..39e3c43c54c1 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -491,8 +491,6 @@ static int venc_power_on(struct venc_device *venc)
 
 	venc_write_reg(venc, VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(&venc->output, &venc->vm);
-
 	r = regulator_enable(venc->vdda_dac_reg);
 	if (r)
 		goto err1;
@@ -595,6 +593,8 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 
 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
+	dss_mgr_set_timings(&venc->output, vm);
+
 	mutex_unlock(&venc->venc_lock);
 }
 

commit a730ce996ce4da09979bac884ddb62daf413b79e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 8 15:59:31 2018 +0300

    drm/omap: venc: Fixup video mode in .check_timings() operation
    
    The VENC encoder modifies the requested video mode to match the NTSC or
    PAL timings (or reject the video mode completely) in the .set_timings()
    operation. This should be performed in the .check_timings() operation
    instead. Move the fixup.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 09ec8b0eafee..126efbf89898 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -452,7 +452,7 @@ static void venc_runtime_put(struct venc_device *venc)
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
-static const struct venc_config *venc_timings_to_config(struct videomode *vm)
+static const struct venc_config *venc_timings_to_config(const struct videomode *vm)
 {
 	switch (venc_get_videomode(vm)) {
 	default:
@@ -582,28 +582,16 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 			     const struct videomode *vm)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
-	struct videomode actual_vm;
 
 	DSSDBG("venc_set_timings\n");
 
 	mutex_lock(&venc->venc_lock);
 
-	switch (venc_get_videomode(vm)) {
-	default:
-		WARN_ON_ONCE(1);
-	case VENC_MODE_PAL:
-		actual_vm = omap_dss_pal_vm;
-		break;
-	case VENC_MODE_NTSC:
-		actual_vm = omap_dss_ntsc_vm;
-		break;
-	}
-
 	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc->vm, &actual_vm, sizeof(actual_vm)))
+	if (memcmp(&venc->vm, vm, sizeof(*vm)))
 		venc->wss_data = 0;
 
-	venc->vm = actual_vm;
+	venc->vm = *vm;
 
 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
@@ -617,8 +605,13 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 
 	switch (venc_get_videomode(vm)) {
 	case VENC_MODE_PAL:
+		*vm = omap_dss_pal_vm;
+		return 0;
+
 	case VENC_MODE_NTSC:
+		*vm = omap_dss_ntsc_vm;
 		return 0;
+
 	default:
 		return -EINVAL;
 	}

commit 35d944cbee2199312c6832a4acd0201a921545f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jun 6 17:49:37 2018 +0300

    drm/omap: Query timing information from analog TV encoder
    
    Timings for the TV output are currently reported by the analog TV
    connector. This has the disadvantage of having to handle timing-related
    operations in a connector omap_dss_device that has, at the hardware
    level, no knowledge of any timing information.
    
    Implement the .get_timings() operation in the venc driver, and get
    timings from the first component in the pipeline that implements the
    operatation. This switches the duty of reporting analog TV timings from
    the connector to the encoder.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 255bf2cd8afc..09ec8b0eafee 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -568,6 +568,16 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 	mutex_unlock(&venc->venc_lock);
 }
 
+static void venc_get_timings(struct omap_dss_device *dssdev,
+			     struct videomode *vm)
+{
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
+	mutex_lock(&venc->venc_lock);
+	*vm = venc->vm;
+	mutex_unlock(&venc->venc_lock);
+}
+
 static void venc_set_timings(struct omap_dss_device *dssdev,
 			     const struct videomode *vm)
 {
@@ -720,6 +730,7 @@ static const struct omap_dss_device_ops venc_ops = {
 	.disable = venc_display_disable,
 
 	.check_timings = venc_check_timings,
+	.get_timings = venc_get_timings,
 	.set_timings = venc_set_timings,
 };
 
@@ -877,6 +888,7 @@ static int venc_probe(struct platform_device *pdev)
 	mutex_init(&venc->venc_lock);
 
 	venc->wss_data = 0;
+	venc->vm = omap_dss_pal_vm;
 
 	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);
 	venc->base = devm_ioremap_resource(&pdev->dev, venc_mem);

commit 8fe1d36100c84ab1b501771252755d75ddcb6bff
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jun 4 18:29:01 2018 +0300

    drm/omap: Make the video_mode pointer to .set_timings() const
    
    The .set_timings() operations of the omap_dss_device instances don't
    need to modify the passed timings. Make the pointer const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 100a02a9447f..255bf2cd8afc 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -569,7 +569,7 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
-			     struct videomode *vm)
+			     const struct videomode *vm)
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
 	struct videomode actual_vm;

commit 43f7078f6b6f8fed8edfbbdeff83e276306e5e6e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 23:34:53 2018 +0200

    drm/omap: dss: Remove the dss_mgr_(dis)connect() operations
    
    The dss_mgr .connect() and .disconnect() are implemented as no-op in
    omapdrm. The operations are unneeded, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 00421e2a8eb6..100a02a9447f 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -696,15 +696,9 @@ static int venc_connect(struct omap_dss_device *src,
 {
 	int r;
 
-	r = dss_mgr_connect(dst);
-	if (r)
-		return r;
-
 	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r) {
-		dss_mgr_disconnect(dst);
+	if (r)
 		return r;
-	}
 
 	dst->dispc_channel_connected = true;
 	return 0;
@@ -716,8 +710,6 @@ static void venc_disconnect(struct omap_dss_device *src,
 	dst->dispc_channel_connected = false;
 
 	omapdss_device_disconnect(dst, dst->next);
-
-	dss_mgr_disconnect(dst);
 }
 
 static const struct omap_dss_device_ops venc_ops = {

commit 0f37938c7c432c7737d85940475bcbd3c362447e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:28:18 2018 +0200

    drm/omap: Set dispc_channel_connect from DSS output connect handlers
    
    The omap_dss_device.dispc_channel_connect field is used by DSS outputs
    to fail the .enable() operation if they're not connected. Set the field
    directly from the (dis)connect handlers of the DSS outputs instead of
    going through the CRTC dss_mgr operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index c2811c425195..00421e2a8eb6 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -706,12 +706,15 @@ static int venc_connect(struct omap_dss_device *src,
 		return r;
 	}
 
+	dst->dispc_channel_connected = true;
 	return 0;
 }
 
 static void venc_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
+	dst->dispc_channel_connected = false;
+
 	omapdss_device_disconnect(dst, dst->next);
 
 	dss_mgr_disconnect(dst);

commit 3be0f15bd6e94aa17a571020704bde413342e8eb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 01:51:31 2018 +0200

    drm/omap: dss: Merge two disconnection helpers
    
    To simplify the pipeline disconnection handling merge the
    omapdss_device_disconnect() and omapdss_output_unset_device() functions.
    The device state check is now called for every device in the pipeline,
    extending this sanity check coverage.
    
    There is no need to return an error from omapdss_device_disconnect()
    when the check fails, as omapdss_output_unset_device() used to do, given
    that we can't prevent disconnection due to device unbinding (the return
    value of omapdss_output_unset_device() is never checked in the current
    code for that reason).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index e673f3e78c69..c2811c425195 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -713,7 +713,6 @@ static void venc_disconnect(struct omap_dss_device *src,
 			    struct omap_dss_device *dst)
 {
 	omapdss_device_disconnect(dst, dst->next);
-	omapdss_output_unset_device(dst);
 
 	dss_mgr_disconnect(dst);
 }

commit 713165561b7e372cd21f34bfeb82188361569f74
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Mar 6 01:25:13 2018 +0200

    drm/omap: dss: Move display type validation to initialization time
    
    The display type is validated when the display is connected to the DSS
    output. We already have all the information we need for validation when
    initializing the outputs. Move validation to output initialization to
    simplify pipeline connection handling.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index db0aa8f1ff7c..e673f3e78c69 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -700,24 +700,13 @@ static int venc_connect(struct omap_dss_device *src,
 	if (r)
 		return r;
 
-	r = omapdss_output_set_device(dst, dst->next);
+	r = omapdss_device_connect(dst->dss, dst, dst->next);
 	if (r) {
-		DSSERR("failed to connect output to new device: %s\n",
-				dst->name);
-		goto err_mgr_disconnect;
+		dss_mgr_disconnect(dst);
+		return r;
 	}
 
-	r = omapdss_device_connect(dst->dss, dst, dst->next);
-	if (r)
-		goto err_output_unset;
-
 	return 0;
-
-err_output_unset:
-	omapdss_output_unset_device(dst);
-err_mgr_disconnect:
-	dss_mgr_disconnect(dst);
-	return r;
 }
 
 static void venc_disconnect(struct omap_dss_device *src,
@@ -787,6 +776,7 @@ static const struct component_ops venc_component_ops = {
 static int venc_init_output(struct venc_device *venc)
 {
 	struct omap_dss_device *out = &venc->output;
+	int r;
 
 	out->dev = &venc->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_VENC;
@@ -804,6 +794,13 @@ static int venc_init_output(struct venc_device *venc)
 		return PTR_ERR(out->next);
 	}
 
+	r = omapdss_output_validate(out);
+	if (r) {
+		omapdss_device_put(out->next);
+		out->next = NULL;
+		return r;
+	}
+
 	omapdss_device_register(out);
 
 	return 0;

commit 511afb44d72aa7b6b871fa71f829afaaa27e84f0
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 23:42:36 2018 +0200

    drm/omap: Reverse direction of DSS device (dis)connect operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    To reconcile the omapdrm and omapdss drivers with the DRM bridge and
    panel model, we need to reverse the direction of the DSS device
    operations. Start with the connect and disconnect operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 7aa06b796481..db0aa8f1ff7c 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -691,32 +691,42 @@ static int venc_get_clocks(struct venc_device *venc)
 	return 0;
 }
 
-static int venc_connect(struct omap_dss_device *dssdev,
-		struct omap_dss_device *dst)
+static int venc_connect(struct omap_dss_device *src,
+			struct omap_dss_device *dst)
 {
 	int r;
 
-	r = dss_mgr_connect(dssdev);
+	r = dss_mgr_connect(dst);
 	if (r)
 		return r;
 
-	r = omapdss_output_set_device(dssdev, dst);
+	r = omapdss_output_set_device(dst, dst->next);
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(dssdev);
-		return r;
+		goto err_mgr_disconnect;
 	}
 
+	r = omapdss_device_connect(dst->dss, dst, dst->next);
+	if (r)
+		goto err_output_unset;
+
 	return 0;
+
+err_output_unset:
+	omapdss_output_unset_device(dst);
+err_mgr_disconnect:
+	dss_mgr_disconnect(dst);
+	return r;
 }
 
-static void venc_disconnect(struct omap_dss_device *dssdev,
-		struct omap_dss_device *dst)
+static void venc_disconnect(struct omap_dss_device *src,
+			    struct omap_dss_device *dst)
 {
-	omapdss_output_unset_device(dssdev);
+	omapdss_device_disconnect(dst, dst->next);
+	omapdss_output_unset_device(dst);
 
-	dss_mgr_disconnect(dssdev);
+	dss_mgr_disconnect(dst);
 }
 
 static const struct omap_dss_device_ops venc_ops = {

commit 8a36357ae3b2d1b4647d20bc806d524c21132572
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Mar 5 00:10:55 2018 +0200

    drm/omap: dss: Get regulators at probe time
    
    Regulators for the DPI, DSI, HDMI, SDI and VENC outputs are all looked
    up when connecting the output omap_dss_device. There's no need to delay
    regulator handling to that time, get the regulators at probe time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 24a2b9a41864..7aa06b796481 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -614,25 +614,6 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 	}
 }
 
-static int venc_init_regulator(struct venc_device *venc)
-{
-	struct regulator *vdda_dac;
-
-	if (venc->vdda_dac_reg != NULL)
-		return 0;
-
-	vdda_dac = devm_regulator_get(&venc->pdev->dev, "vdda");
-	if (IS_ERR(vdda_dac)) {
-		if (PTR_ERR(vdda_dac) != -EPROBE_DEFER)
-			DSSERR("can't get VDDA_DAC regulator\n");
-		return PTR_ERR(vdda_dac);
-	}
-
-	venc->vdda_dac_reg = vdda_dac;
-
-	return 0;
-}
-
 static int venc_dump_regs(struct seq_file *s, void *p)
 {
 	struct venc_device *venc = s->private;
@@ -713,13 +694,8 @@ static int venc_get_clocks(struct venc_device *venc)
 static int venc_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct venc_device *venc = dssdev_to_venc(dssdev);
 	int r;
 
-	r = venc_init_regulator(venc);
-	if (r)
-		return r;
-
 	r = dss_mgr_connect(dssdev);
 	if (r)
 		return r;
@@ -908,6 +884,14 @@ static int venc_probe(struct platform_device *pdev)
 		goto err_free;
 	}
 
+	venc->vdda_dac_reg = devm_regulator_get(&pdev->dev, "vdda");
+	if (IS_ERR(venc->vdda_dac_reg)) {
+		r = PTR_ERR(venc->vdda_dac_reg);
+		if (r != -EPROBE_DEFER)
+			DSSERR("can't get VDDA_DAC regulator\n");
+		goto err_free;
+	}
+
 	r = venc_get_clocks(venc);
 	if (r)
 		goto err_free;

commit a48bc6ac2c6cd85bc079fc859ab14ea844e812cd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 23:55:56 2018 +0200

    drm/omap: dss: Remove duplicated parameter to dss_mgr_(dis)connect()
    
    The dss_mgr_connect() and dss_mgr_disconnect() functions take two
    omap_dss_device pointers as parameters, which are always set to the same
    value by all callers. Remove the duplicated pointer.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 298e86cc9e14..24a2b9a41864 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -720,7 +720,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(&venc->output, dssdev);
+	r = dss_mgr_connect(dssdev);
 	if (r)
 		return r;
 
@@ -728,7 +728,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(&venc->output, dssdev);
+		dss_mgr_disconnect(dssdev);
 		return r;
 	}
 
@@ -738,11 +738,9 @@ static int venc_connect(struct omap_dss_device *dssdev,
 static void venc_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(&venc->output, dssdev);
+	dss_mgr_disconnect(dssdev);
 }
 
 static const struct omap_dss_device_ops venc_ops = {

commit 27d624527d99265c2df999af3615ff71c29d06f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 22:13:06 2018 +0200

    drm/omap: dss: Acquire next dssdev at probe time
    
    Look up the next dssdev at probe time based on device tree links for all
    DSS outputs and encoders. This will be used to reverse the order of the
    dssdev connect and disconnect call chains.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 5adf8510d67b..298e86cc9e14 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -800,7 +800,7 @@ static const struct component_ops venc_component_ops = {
  * Probe & Remove, Suspend & Resume
  */
 
-static void venc_init_output(struct venc_device *venc)
+static int venc_init_output(struct venc_device *venc)
 {
 	struct omap_dss_device *out = &venc->output;
 
@@ -813,11 +813,22 @@ static void venc_init_output(struct venc_device *venc)
 	out->owner = THIS_MODULE;
 	out->of_ports = BIT(0);
 
+	out->next = omapdss_of_find_connected_device(out->dev->of_node, 0);
+	if (IS_ERR(out->next)) {
+		if (PTR_ERR(out->next) != -EPROBE_DEFER)
+			dev_err(out->dev, "failed to find video sink\n");
+		return PTR_ERR(out->next);
+	}
+
 	omapdss_device_register(out);
+
+	return 0;
 }
 
 static void venc_uninit_output(struct venc_device *venc)
 {
+	if (venc->output.next)
+		omapdss_device_put(venc->output.next);
 	omapdss_device_unregister(&venc->output);
 }
 
@@ -909,7 +920,9 @@ static int venc_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
-	venc_init_output(venc);
+	r = venc_init_output(venc);
+	if (r)
+		goto err_pm_disable;
 
 	r = component_add(&pdev->dev, &venc_component_ops);
 	if (r)
@@ -919,6 +932,7 @@ static int venc_probe(struct platform_device *pdev)
 
 err_uninit_output:
 	venc_uninit_output(venc);
+err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
 err_free:
 	kfree(venc);

commit c87193267d247c58f4517081d9cd04c8dc6302b8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Mar 3 18:52:59 2018 +0200

    drm/omap: dss: venc: Move initialization code from bind to probe
    
    There's no reason to delay initialization of most of the driver (such as
    mapping memory I/O or enabling runtime PM) to the component bind
    handler. Perform as much of the initialization as possible at probe
    time, initializing at bind time only the parts that depends on the DSS.
    The cleanup code is moved from unbind to remove in a similar way.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 93c3e5250a63..5adf8510d67b 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -756,6 +756,50 @@ static const struct omap_dss_device_ops venc_ops = {
 	.set_timings = venc_set_timings,
 };
 
+/* -----------------------------------------------------------------------------
+ * Component Bind & Unbind
+ */
+
+static int venc_bind(struct device *dev, struct device *master, void *data)
+{
+	struct dss_device *dss = dss_get_device(master);
+	struct venc_device *venc = dev_get_drvdata(dev);
+	u8 rev_id;
+	int r;
+
+	venc->dss = dss;
+
+	r = venc_runtime_get(venc);
+	if (r)
+		return r;
+
+	rev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);
+	dev_dbg(dev, "OMAP VENC rev %d\n", rev_id);
+
+	venc_runtime_put(venc);
+
+	venc->debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
+						venc);
+
+	return 0;
+}
+
+static void venc_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct venc_device *venc = dev_get_drvdata(dev);
+
+	dss_debugfs_remove_file(venc->debugfs);
+}
+
+static const struct component_ops venc_component_ops = {
+	.bind	= venc_bind,
+	.unbind	= venc_unbind,
+};
+
+/* -----------------------------------------------------------------------------
+ * Probe & Remove, Suspend & Resume
+ */
+
 static void venc_init_output(struct venc_device *venc)
 {
 	struct omap_dss_device *out = &venc->output;
@@ -820,19 +864,15 @@ static int venc_probe_of(struct venc_device *venc)
 	return r;
 }
 
-/* VENC HW IP initialisation */
 static const struct soc_device_attribute venc_soc_devices[] = {
 	{ .machine = "OMAP3[45]*" },
 	{ .machine = "AM35*" },
 	{ /* sentinel */ }
 };
 
-static int venc_bind(struct device *dev, struct device *master, void *data)
+static int venc_probe(struct platform_device *pdev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dss_device *dss = dss_get_device(master);
 	struct venc_device *venc;
-	u8 rev_id;
 	struct resource *venc_mem;
 	int r;
 
@@ -841,8 +881,8 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 		return -ENOMEM;
 
 	venc->pdev = pdev;
-	venc->dss = dss;
-	dev_set_drvdata(dev, venc);
+
+	platform_set_drvdata(pdev, venc);
 
 	/* The OMAP34xx, OMAP35xx and AM35xx VENC require the TV DAC clock. */
 	if (soc_device_match(venc_soc_devices))
@@ -863,63 +903,39 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		goto err_free;
 
-	pm_runtime_enable(&pdev->dev);
-
-	r = venc_runtime_get(venc);
-	if (r)
-		goto err_pm_disable;
-
-	rev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);
-	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
-
-	venc_runtime_put(venc);
-
 	r = venc_probe_of(venc);
-	if (r) {
-		DSSERR("Invalid DT data\n");
-		goto err_pm_disable;
-	}
+	if (r)
+		goto err_free;
 
-	venc->debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
-						venc);
+	pm_runtime_enable(&pdev->dev);
 
 	venc_init_output(venc);
 
+	r = component_add(&pdev->dev, &venc_component_ops);
+	if (r)
+		goto err_uninit_output;
+
 	return 0;
 
-err_pm_disable:
+err_uninit_output:
+	venc_uninit_output(venc);
 	pm_runtime_disable(&pdev->dev);
 err_free:
 	kfree(venc);
 	return r;
 }
 
-static void venc_unbind(struct device *dev, struct device *master, void *data)
+static int venc_remove(struct platform_device *pdev)
 {
-	struct venc_device *venc = dev_get_drvdata(dev);
+	struct venc_device *venc = platform_get_drvdata(pdev);
 
-	dss_debugfs_remove_file(venc->debugfs);
+	component_del(&pdev->dev, &venc_component_ops);
 
 	venc_uninit_output(venc);
 
-	pm_runtime_disable(dev);
+	pm_runtime_disable(&pdev->dev);
 
 	kfree(venc);
-}
-
-static const struct component_ops venc_component_ops = {
-	.bind	= venc_bind,
-	.unbind	= venc_unbind,
-};
-
-static int venc_probe(struct platform_device *pdev)
-{
-	return component_add(&pdev->dev, &venc_component_ops);
-}
-
-static int venc_remove(struct platform_device *pdev)
-{
-	component_del(&pdev->dev, &venc_component_ops);
 	return 0;
 }
 

commit 66aacfe22d53137eab511b3f4d674ddd40a7b1ac
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 21:38:21 2018 +0200

    drm/omap: dss: Cleanup error paths in output init functions
    
    Rename the jump labels according to the cleanup they perform, not the
    location they're accessed from, and move functions from error checks to
    cleanup paths, and move reference handling to simplify cleanup.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index dd9af335dba0..93c3e5250a63 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -867,7 +867,7 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 
 	r = venc_runtime_get(venc);
 	if (r)
-		goto err_runtime_get;
+		goto err_pm_disable;
 
 	rev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);
 	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
@@ -877,7 +877,7 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 	r = venc_probe_of(venc);
 	if (r) {
 		DSSERR("Invalid DT data\n");
-		goto err_probe_of;
+		goto err_pm_disable;
 	}
 
 	venc->debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
@@ -887,8 +887,7 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 
 	return 0;
 
-err_probe_of:
-err_runtime_get:
+err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
 err_free:
 	kfree(venc);

commit 4e20bda68e01f723d7fcc4e7d55a4afc78223fb7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 4 21:49:28 2018 +0200

    drm/omap: dss: Replace omap_dss_device port number with bitmask
    
    The omap_dss_device port_num field stores the DT port number associated
    with the device. The field is used in different ways depending on the
    device type:
    
    - For DPI outputs, the port number is used as an identifier of the DPI
    instance
    
    - For sources, the port number is used to look up the omap_dss_device by
    DT port node
    
    As omap_dss_device instances are only looked up as sources by sinks,
    setting the field to the number of the source port works for both use
    cases.
    
    However, to enable looking up sinks, we need to record all the ports
    associated with an omap_dss_device. Do so by turning the port_num field
    into an of_ports bitmask. For DPI outputs the port number is
    additionally stored in the dpi_data structure as the output ID.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 70418cf4eea2..dd9af335dba0 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -767,6 +767,7 @@ static void venc_init_output(struct venc_device *venc)
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
 	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
+	out->of_ports = BIT(0);
 
 	omapdss_device_register(out);
 }

commit de57e9dbc1454704a54190cb3b544b841c34301a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 01:25:32 2018 +0200

    drm/omap: dss: Remove output devices list
    
    The output devices list isn't used anymore, all output devices are
    accessed through the global devices list. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 17668da8ac5a..70418cf4eea2 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -768,12 +768,12 @@ static void venc_init_output(struct venc_device *venc)
 	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
 
-	omapdss_register_output(out);
+	omapdss_device_register(out);
 }
 
 static void venc_uninit_output(struct venc_device *venc)
 {
-	omapdss_unregister_output(&venc->output);
+	omapdss_device_unregister(&venc->output);
 }
 
 static int venc_probe_of(struct venc_device *venc)

commit fb5571717c24c264518aaaf1ab4ec4df73e4cebd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 17:30:30 2018 +0200

    drm/omap: dss: Move src and dst check and set to connection handlers
    
    The encoders duplicate the same omap_dss_device src and dst fields set
    and checks in their connect and disconnect handlers. Move the code to
    the connect and disconnect wrappers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 4cae03f24e1b..17668da8ac5a 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -740,11 +740,6 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 {
 	struct venc_device *venc = dssdev_to_venc(dssdev);
 
-	WARN_ON(dst != dssdev->dst);
-
-	if (dst != dssdev->dst)
-		return;
-
 	omapdss_output_unset_device(dssdev);
 
 	dss_mgr_disconnect(&venc->output, dssdev);

commit b93109d7dc9e15649e1cf18281f02d8b4a102584
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 28 15:58:13 2018 +0200

    drm/omap: dss: Move common device operations to common structure
    
    The various types of omapdss_*_ops structures define multiple operations
    that are not specific to a bus type. To simplify the code and remove
    dependencies on specific bus types move those operations to a common
    structure. Operations that are specific to a bus type are kept in the
    specialized ops structures.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index ab0eeec38db0..4cae03f24e1b 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -750,7 +750,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 	dss_mgr_disconnect(&venc->output, dssdev);
 }
 
-static const struct omapdss_atv_ops venc_ops = {
+static const struct omap_dss_device_ops venc_ops = {
 	.connect = venc_connect,
 	.disconnect = venc_disconnect,
 
@@ -770,7 +770,7 @@ static void venc_init_output(struct venc_device *venc)
 	out->output_type = OMAP_DISPLAY_TYPE_VENC;
 	out->name = "venc.0";
 	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
-	out->ops.atv = &venc_ops;
+	out->ops = &venc_ops;
 	out->owner = THIS_MODULE;
 
 	omapdss_register_output(out);

commit 9976782f331b0d54710fddd89848b9b6e22746d4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 27 20:29:21 2018 +0200

    drm/omap: dss: Remove DSS encoders get_timings operation
    
    The get_timings operation from DSS encoders (not to be confused with the
    identically named operation in omap_dss_driver) is never called. Remove
    it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index c573254df766..ab0eeec38db0 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -614,18 +614,6 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 	}
 }
 
-static void venc_get_timings(struct omap_dss_device *dssdev,
-			     struct videomode *vm)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-
-	mutex_lock(&venc->venc_lock);
-
-	*vm = venc->vm;
-
-	mutex_unlock(&venc->venc_lock);
-}
-
 static int venc_init_regulator(struct venc_device *venc)
 {
 	struct regulator *vdda_dac;
@@ -771,7 +759,6 @@ static const struct omapdss_atv_ops venc_ops = {
 
 	.check_timings = venc_check_timings,
 	.set_timings = venc_set_timings,
-	.get_timings = venc_get_timings,
 };
 
 static void venc_init_output(struct venc_device *venc)

commit 52dd898a30e0cc0354e34ee3955cec0ca60a80d5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 14 02:22:42 2018 +0200

    drm/omap: dss: Remove omapdss_atv_ops get_wss and set_wss operations
    
    The operations are never used, remove them. If the need to set wide
    screen signaling data arises later, it should be implemented by
    extending the DRM bridge API.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index ac01907dcc34..c573254df766 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -626,44 +626,6 @@ static void venc_get_timings(struct omap_dss_device *dssdev,
 	mutex_unlock(&venc->venc_lock);
 }
 
-static u32 venc_get_wss(struct omap_dss_device *dssdev)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-
-	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	return (venc->wss_data >> 8) ^ 0xfffff;
-}
-
-static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
-{
-	struct venc_device *venc = dssdev_to_venc(dssdev);
-	const struct venc_config *config;
-	int r;
-
-	DSSDBG("venc_set_wss\n");
-
-	mutex_lock(&venc->venc_lock);
-
-	config = venc_timings_to_config(&venc->vm);
-
-	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	venc->wss_data = (wss ^ 0xfffff) << 8;
-
-	r = venc_runtime_get(venc);
-	if (r)
-		goto err;
-
-	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-		       venc->wss_data);
-
-	venc_runtime_put(venc);
-
-err:
-	mutex_unlock(&venc->venc_lock);
-
-	return r;
-}
-
 static int venc_init_regulator(struct venc_device *venc)
 {
 	struct regulator *vdda_dac;
@@ -810,9 +772,6 @@ static const struct omapdss_atv_ops venc_ops = {
 	.check_timings = venc_check_timings,
 	.set_timings = venc_set_timings,
 	.get_timings = venc_get_timings,
-
-	.set_wss = venc_set_wss,
-	.get_wss = venc_get_wss,
 };
 
 static void venc_init_output(struct venc_device *venc)

commit 6505d75cd23291565ca668dd1e66f4e38b5c8f38
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 24 14:46:19 2018 +0300

    drm/omap: fix email address
    
    Change tomi.valkeinen@nokia.com to tomi.valkeinen@ti.com.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 24d1ced210bd..ac01907dcc34 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2009 Nokia Corporation
- * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * VENC settings from TI's DSS driver
  *

commit 663ac57b285d0176cacb85899b7f79d83f825353
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:48 2018 +0200

    drm: omapdrm: venc: Allocate the venc private data structure dynamically
    
    The venc private data structure is currently stored as a global
    variable. While no platform with multiple VENC encoders currently exists
    nor is planned, this doesn't comply with the kernel device model and
    should thus be fixed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 12a0ac4e1eb1..24d1ced210bd 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -319,7 +319,7 @@ static enum venc_videomode venc_get_videomode(const struct videomode *vm)
 	return VENC_MODE_UNKNOWN;
 }
 
-static struct {
+struct venc_device {
 	struct platform_device *pdev;
 	void __iomem *base;
 	struct mutex venc_lock;
@@ -337,81 +337,87 @@ static struct {
 	bool requires_tv_dac_clk;
 
 	struct omap_dss_device output;
-} venc;
+};
+
+#define dssdev_to_venc(dssdev) container_of(dssdev, struct venc_device, output)
 
-static inline void venc_write_reg(int idx, u32 val)
+static inline void venc_write_reg(struct venc_device *venc, int idx, u32 val)
 {
-	__raw_writel(val, venc.base + idx);
+	__raw_writel(val, venc->base + idx);
 }
 
-static inline u32 venc_read_reg(int idx)
+static inline u32 venc_read_reg(struct venc_device *venc, int idx)
 {
-	u32 l = __raw_readl(venc.base + idx);
+	u32 l = __raw_readl(venc->base + idx);
 	return l;
 }
 
-static void venc_write_config(const struct venc_config *config)
+static void venc_write_config(struct venc_device *venc,
+			      const struct venc_config *config)
 {
 	DSSDBG("write venc conf\n");
 
-	venc_write_reg(VENC_LLEN, config->llen);
-	venc_write_reg(VENC_FLENS, config->flens);
-	venc_write_reg(VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);
-	venc_write_reg(VENC_C_PHASE, config->c_phase);
-	venc_write_reg(VENC_GAIN_U, config->gain_u);
-	venc_write_reg(VENC_GAIN_V, config->gain_v);
-	venc_write_reg(VENC_GAIN_Y, config->gain_y);
-	venc_write_reg(VENC_BLACK_LEVEL, config->black_level);
-	venc_write_reg(VENC_BLANK_LEVEL, config->blank_level);
-	venc_write_reg(VENC_M_CONTROL, config->m_control);
-	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-			venc.wss_data);
-	venc_write_reg(VENC_S_CARR, config->s_carr);
-	venc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);
-	venc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);
-	venc_write_reg(VENC_FLEN__FAL, config->flen__fal);
-	venc_write_reg(VENC_LAL__PHASE_RESET, config->lal__phase_reset);
-	venc_write_reg(VENC_HS_INT_START_STOP_X, config->hs_int_start_stop_x);
-	venc_write_reg(VENC_HS_EXT_START_STOP_X, config->hs_ext_start_stop_x);
-	venc_write_reg(VENC_VS_INT_START_X, config->vs_int_start_x);
-	venc_write_reg(VENC_VS_INT_STOP_X__VS_INT_START_Y,
+	venc_write_reg(venc, VENC_LLEN, config->llen);
+	venc_write_reg(venc, VENC_FLENS, config->flens);
+	venc_write_reg(venc, VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);
+	venc_write_reg(venc, VENC_C_PHASE, config->c_phase);
+	venc_write_reg(venc, VENC_GAIN_U, config->gain_u);
+	venc_write_reg(venc, VENC_GAIN_V, config->gain_v);
+	venc_write_reg(venc, VENC_GAIN_Y, config->gain_y);
+	venc_write_reg(venc, VENC_BLACK_LEVEL, config->black_level);
+	venc_write_reg(venc, VENC_BLANK_LEVEL, config->blank_level);
+	venc_write_reg(venc, VENC_M_CONTROL, config->m_control);
+	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+		       venc->wss_data);
+	venc_write_reg(venc, VENC_S_CARR, config->s_carr);
+	venc_write_reg(venc, VENC_L21__WC_CTL, config->l21__wc_ctl);
+	venc_write_reg(venc, VENC_SAVID__EAVID, config->savid__eavid);
+	venc_write_reg(venc, VENC_FLEN__FAL, config->flen__fal);
+	venc_write_reg(venc, VENC_LAL__PHASE_RESET, config->lal__phase_reset);
+	venc_write_reg(venc, VENC_HS_INT_START_STOP_X,
+		       config->hs_int_start_stop_x);
+	venc_write_reg(venc, VENC_HS_EXT_START_STOP_X,
+		       config->hs_ext_start_stop_x);
+	venc_write_reg(venc, VENC_VS_INT_START_X, config->vs_int_start_x);
+	venc_write_reg(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y,
 		       config->vs_int_stop_x__vs_int_start_y);
-	venc_write_reg(VENC_VS_INT_STOP_Y__VS_EXT_START_X,
+	venc_write_reg(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X,
 		       config->vs_int_stop_y__vs_ext_start_x);
-	venc_write_reg(VENC_VS_EXT_STOP_X__VS_EXT_START_Y,
+	venc_write_reg(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y,
 		       config->vs_ext_stop_x__vs_ext_start_y);
-	venc_write_reg(VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);
-	venc_write_reg(VENC_AVID_START_STOP_X, config->avid_start_stop_x);
-	venc_write_reg(VENC_AVID_START_STOP_Y, config->avid_start_stop_y);
-	venc_write_reg(VENC_FID_INT_START_X__FID_INT_START_Y,
+	venc_write_reg(venc, VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);
+	venc_write_reg(venc, VENC_AVID_START_STOP_X, config->avid_start_stop_x);
+	venc_write_reg(venc, VENC_AVID_START_STOP_Y, config->avid_start_stop_y);
+	venc_write_reg(venc, VENC_FID_INT_START_X__FID_INT_START_Y,
 		       config->fid_int_start_x__fid_int_start_y);
-	venc_write_reg(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,
+	venc_write_reg(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,
 		       config->fid_int_offset_y__fid_ext_start_x);
-	venc_write_reg(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,
+	venc_write_reg(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,
 		       config->fid_ext_start_y__fid_ext_offset_y);
 
-	venc_write_reg(VENC_DAC_B__DAC_C,  venc_read_reg(VENC_DAC_B__DAC_C));
-	venc_write_reg(VENC_VIDOUT_CTRL, config->vidout_ctrl);
-	venc_write_reg(VENC_HFLTR_CTRL, config->hfltr_ctrl);
-	venc_write_reg(VENC_X_COLOR, config->x_color);
-	venc_write_reg(VENC_LINE21, config->line21);
-	venc_write_reg(VENC_LN_SEL, config->ln_sel);
-	venc_write_reg(VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);
-	venc_write_reg(VENC_TVDETGP_INT_START_STOP_X,
+	venc_write_reg(venc, VENC_DAC_B__DAC_C,
+		       venc_read_reg(venc, VENC_DAC_B__DAC_C));
+	venc_write_reg(venc, VENC_VIDOUT_CTRL, config->vidout_ctrl);
+	venc_write_reg(venc, VENC_HFLTR_CTRL, config->hfltr_ctrl);
+	venc_write_reg(venc, VENC_X_COLOR, config->x_color);
+	venc_write_reg(venc, VENC_LINE21, config->line21);
+	venc_write_reg(venc, VENC_LN_SEL, config->ln_sel);
+	venc_write_reg(venc, VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);
+	venc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_X,
 		       config->tvdetgp_int_start_stop_x);
-	venc_write_reg(VENC_TVDETGP_INT_START_STOP_Y,
+	venc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_Y,
 		       config->tvdetgp_int_start_stop_y);
-	venc_write_reg(VENC_GEN_CTRL, config->gen_ctrl);
-	venc_write_reg(VENC_F_CONTROL, config->f_control);
-	venc_write_reg(VENC_SYNC_CTRL, config->sync_ctrl);
+	venc_write_reg(venc, VENC_GEN_CTRL, config->gen_ctrl);
+	venc_write_reg(venc, VENC_F_CONTROL, config->f_control);
+	venc_write_reg(venc, VENC_SYNC_CTRL, config->sync_ctrl);
 }
 
-static void venc_reset(void)
+static void venc_reset(struct venc_device *venc)
 {
 	int t = 1000;
 
-	venc_write_reg(VENC_F_CONTROL, 1<<8);
-	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
+	venc_write_reg(venc, VENC_F_CONTROL, 1<<8);
+	while (venc_read_reg(venc, VENC_F_CONTROL) & (1<<8)) {
 		if (--t == 0) {
 			DSSERR("Failed to reset venc\n");
 			return;
@@ -425,24 +431,24 @@ static void venc_reset(void)
 #endif
 }
 
-static int venc_runtime_get(void)
+static int venc_runtime_get(struct venc_device *venc)
 {
 	int r;
 
 	DSSDBG("venc_runtime_get\n");
 
-	r = pm_runtime_get_sync(&venc.pdev->dev);
+	r = pm_runtime_get_sync(&venc->pdev->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
 
-static void venc_runtime_put(void)
+static void venc_runtime_put(struct venc_device *venc)
 {
 	int r;
 
 	DSSDBG("venc_runtime_put\n");
 
-	r = pm_runtime_put_sync(&venc.pdev->dev);
+	r = pm_runtime_put_sync(&venc->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
@@ -458,116 +464,119 @@ static const struct venc_config *venc_timings_to_config(struct videomode *vm)
 	}
 }
 
-static int venc_power_on(struct omap_dss_device *dssdev)
+static int venc_power_on(struct venc_device *venc)
 {
 	u32 l;
 	int r;
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err0;
 
-	venc_reset();
-	venc_write_config(venc_timings_to_config(&venc.vm));
+	venc_reset(venc);
+	venc_write_config(venc, venc_timings_to_config(&venc->vm));
 
-	dss_set_venc_output(venc.dss, venc.type);
-	dss_set_dac_pwrdn_bgz(venc.dss, 1);
+	dss_set_venc_output(venc->dss, venc->type);
+	dss_set_dac_pwrdn_bgz(venc->dss, 1);
 
 	l = 0;
 
-	if (venc.type == OMAP_DSS_VENC_TYPE_COMPOSITE)
+	if (venc->type == OMAP_DSS_VENC_TYPE_COMPOSITE)
 		l |= 1 << 1;
 	else /* S-Video */
 		l |= (1 << 0) | (1 << 2);
 
-	if (venc.invert_polarity == false)
+	if (venc->invert_polarity == false)
 		l |= 1 << 3;
 
-	venc_write_reg(VENC_OUTPUT_CONTROL, l);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(&venc.output, &venc.vm);
+	dss_mgr_set_timings(&venc->output, &venc->vm);
 
-	r = regulator_enable(venc.vdda_dac_reg);
+	r = regulator_enable(venc->vdda_dac_reg);
 	if (r)
 		goto err1;
 
-	r = dss_mgr_enable(&venc.output);
+	r = dss_mgr_enable(&venc->output);
 	if (r)
 		goto err2;
 
 	return 0;
 
 err2:
-	regulator_disable(venc.vdda_dac_reg);
+	regulator_disable(venc->vdda_dac_reg);
 err1:
-	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(venc.dss, 0);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(venc->dss, 0);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 err0:
 	return r;
 }
 
-static void venc_power_off(struct omap_dss_device *dssdev)
+static void venc_power_off(struct venc_device *venc)
 {
-	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(venc.dss, 0);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(venc->dss, 0);
 
-	dss_mgr_disable(&venc.output);
+	dss_mgr_disable(&venc->output);
 
-	regulator_disable(venc.vdda_dac_reg);
+	regulator_disable(venc->vdda_dac_reg);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 }
 
 static int venc_display_enable(struct omap_dss_device *dssdev)
 {
-	struct omap_dss_device *out = &venc.output;
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	int r;
 
 	DSSDBG("venc_display_enable\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	if (!out->dispc_channel_connected) {
+	if (!dssdev->dispc_channel_connected) {
 		DSSERR("Failed to enable display: no output/manager\n");
 		r = -ENODEV;
 		goto err0;
 	}
 
-	r = venc_power_on(dssdev);
+	r = venc_power_on(venc);
 	if (r)
 		goto err0;
 
-	venc.wss_data = 0;
+	venc->wss_data = 0;
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 
 	return 0;
 err0:
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 	return r;
 }
 
 static void venc_display_disable(struct omap_dss_device *dssdev)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	DSSDBG("venc_display_disable\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	venc_power_off(dssdev);
+	venc_power_off(venc);
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
 			     struct videomode *vm)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	struct videomode actual_vm;
 
 	DSSDBG("venc_set_timings\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
 	switch (venc_get_videomode(vm)) {
 	default:
@@ -581,14 +590,14 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 	}
 
 	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc.vm, &actual_vm, sizeof(actual_vm)))
-		venc.wss_data = 0;
+	if (memcmp(&venc->vm, &actual_vm, sizeof(actual_vm)))
+		venc->wss_data = 0;
 
-	venc.vm = actual_vm;
+	venc->vm = actual_vm;
 
-	dispc_set_tv_pclk(venc.dss->dispc, 13500000);
+	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static int venc_check_timings(struct omap_dss_device *dssdev,
@@ -608,128 +617,136 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 static void venc_get_timings(struct omap_dss_device *dssdev,
 			     struct videomode *vm)
 {
-	mutex_lock(&venc.venc_lock);
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
+	mutex_lock(&venc->venc_lock);
 
-	*vm = venc.vm;
+	*vm = venc->vm;
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static u32 venc_get_wss(struct omap_dss_device *dssdev)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	return (venc.wss_data >> 8) ^ 0xfffff;
+	return (venc->wss_data >> 8) ^ 0xfffff;
 }
 
 static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	const struct venc_config *config;
 	int r;
 
 	DSSDBG("venc_set_wss\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	config = venc_timings_to_config(&venc.vm);
+	config = venc_timings_to_config(&venc->vm);
 
 	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	venc.wss_data = (wss ^ 0xfffff) << 8;
+	venc->wss_data = (wss ^ 0xfffff) << 8;
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err;
 
-	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-			venc.wss_data);
+	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+		       venc->wss_data);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 
 err:
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 
 	return r;
 }
 
-static int venc_init_regulator(void)
+static int venc_init_regulator(struct venc_device *venc)
 {
 	struct regulator *vdda_dac;
 
-	if (venc.vdda_dac_reg != NULL)
+	if (venc->vdda_dac_reg != NULL)
 		return 0;
 
-	vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");
+	vdda_dac = devm_regulator_get(&venc->pdev->dev, "vdda");
 	if (IS_ERR(vdda_dac)) {
 		if (PTR_ERR(vdda_dac) != -EPROBE_DEFER)
 			DSSERR("can't get VDDA_DAC regulator\n");
 		return PTR_ERR(vdda_dac);
 	}
 
-	venc.vdda_dac_reg = vdda_dac;
+	venc->vdda_dac_reg = vdda_dac;
 
 	return 0;
 }
 
 static int venc_dump_regs(struct seq_file *s, void *p)
 {
-#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(r))
+	struct venc_device *venc = s->private;
+
+#define DUMPREG(venc, r) \
+	seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(venc, r))
 
-	if (venc_runtime_get())
+	if (venc_runtime_get(venc))
 		return 0;
 
-	DUMPREG(VENC_F_CONTROL);
-	DUMPREG(VENC_VIDOUT_CTRL);
-	DUMPREG(VENC_SYNC_CTRL);
-	DUMPREG(VENC_LLEN);
-	DUMPREG(VENC_FLENS);
-	DUMPREG(VENC_HFLTR_CTRL);
-	DUMPREG(VENC_CC_CARR_WSS_CARR);
-	DUMPREG(VENC_C_PHASE);
-	DUMPREG(VENC_GAIN_U);
-	DUMPREG(VENC_GAIN_V);
-	DUMPREG(VENC_GAIN_Y);
-	DUMPREG(VENC_BLACK_LEVEL);
-	DUMPREG(VENC_BLANK_LEVEL);
-	DUMPREG(VENC_X_COLOR);
-	DUMPREG(VENC_M_CONTROL);
-	DUMPREG(VENC_BSTAMP_WSS_DATA);
-	DUMPREG(VENC_S_CARR);
-	DUMPREG(VENC_LINE21);
-	DUMPREG(VENC_LN_SEL);
-	DUMPREG(VENC_L21__WC_CTL);
-	DUMPREG(VENC_HTRIGGER_VTRIGGER);
-	DUMPREG(VENC_SAVID__EAVID);
-	DUMPREG(VENC_FLEN__FAL);
-	DUMPREG(VENC_LAL__PHASE_RESET);
-	DUMPREG(VENC_HS_INT_START_STOP_X);
-	DUMPREG(VENC_HS_EXT_START_STOP_X);
-	DUMPREG(VENC_VS_INT_START_X);
-	DUMPREG(VENC_VS_INT_STOP_X__VS_INT_START_Y);
-	DUMPREG(VENC_VS_INT_STOP_Y__VS_EXT_START_X);
-	DUMPREG(VENC_VS_EXT_STOP_X__VS_EXT_START_Y);
-	DUMPREG(VENC_VS_EXT_STOP_Y);
-	DUMPREG(VENC_AVID_START_STOP_X);
-	DUMPREG(VENC_AVID_START_STOP_Y);
-	DUMPREG(VENC_FID_INT_START_X__FID_INT_START_Y);
-	DUMPREG(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);
-	DUMPREG(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);
-	DUMPREG(VENC_TVDETGP_INT_START_STOP_X);
-	DUMPREG(VENC_TVDETGP_INT_START_STOP_Y);
-	DUMPREG(VENC_GEN_CTRL);
-	DUMPREG(VENC_OUTPUT_CONTROL);
-	DUMPREG(VENC_OUTPUT_TEST);
-
-	venc_runtime_put();
+	DUMPREG(venc, VENC_F_CONTROL);
+	DUMPREG(venc, VENC_VIDOUT_CTRL);
+	DUMPREG(venc, VENC_SYNC_CTRL);
+	DUMPREG(venc, VENC_LLEN);
+	DUMPREG(venc, VENC_FLENS);
+	DUMPREG(venc, VENC_HFLTR_CTRL);
+	DUMPREG(venc, VENC_CC_CARR_WSS_CARR);
+	DUMPREG(venc, VENC_C_PHASE);
+	DUMPREG(venc, VENC_GAIN_U);
+	DUMPREG(venc, VENC_GAIN_V);
+	DUMPREG(venc, VENC_GAIN_Y);
+	DUMPREG(venc, VENC_BLACK_LEVEL);
+	DUMPREG(venc, VENC_BLANK_LEVEL);
+	DUMPREG(venc, VENC_X_COLOR);
+	DUMPREG(venc, VENC_M_CONTROL);
+	DUMPREG(venc, VENC_BSTAMP_WSS_DATA);
+	DUMPREG(venc, VENC_S_CARR);
+	DUMPREG(venc, VENC_LINE21);
+	DUMPREG(venc, VENC_LN_SEL);
+	DUMPREG(venc, VENC_L21__WC_CTL);
+	DUMPREG(venc, VENC_HTRIGGER_VTRIGGER);
+	DUMPREG(venc, VENC_SAVID__EAVID);
+	DUMPREG(venc, VENC_FLEN__FAL);
+	DUMPREG(venc, VENC_LAL__PHASE_RESET);
+	DUMPREG(venc, VENC_HS_INT_START_STOP_X);
+	DUMPREG(venc, VENC_HS_EXT_START_STOP_X);
+	DUMPREG(venc, VENC_VS_INT_START_X);
+	DUMPREG(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y);
+	DUMPREG(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X);
+	DUMPREG(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y);
+	DUMPREG(venc, VENC_VS_EXT_STOP_Y);
+	DUMPREG(venc, VENC_AVID_START_STOP_X);
+	DUMPREG(venc, VENC_AVID_START_STOP_Y);
+	DUMPREG(venc, VENC_FID_INT_START_X__FID_INT_START_Y);
+	DUMPREG(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);
+	DUMPREG(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);
+	DUMPREG(venc, VENC_TVDETGP_INT_START_STOP_X);
+	DUMPREG(venc, VENC_TVDETGP_INT_START_STOP_Y);
+	DUMPREG(venc, VENC_GEN_CTRL);
+	DUMPREG(venc, VENC_OUTPUT_CONTROL);
+	DUMPREG(venc, VENC_OUTPUT_TEST);
+
+	venc_runtime_put(venc);
 
 #undef DUMPREG
 	return 0;
 }
 
-static int venc_get_clocks(struct platform_device *pdev)
+static int venc_get_clocks(struct venc_device *venc)
 {
 	struct clk *clk;
 
-	if (venc.requires_tv_dac_clk) {
-		clk = devm_clk_get(&pdev->dev, "tv_dac_clk");
+	if (venc->requires_tv_dac_clk) {
+		clk = devm_clk_get(&venc->pdev->dev, "tv_dac_clk");
 		if (IS_ERR(clk)) {
 			DSSERR("can't get tv_dac_clk\n");
 			return PTR_ERR(clk);
@@ -738,7 +755,7 @@ static int venc_get_clocks(struct platform_device *pdev)
 		clk = NULL;
 	}
 
-	venc.tv_dac_clk = clk;
+	venc->tv_dac_clk = clk;
 
 	return 0;
 }
@@ -746,13 +763,14 @@ static int venc_get_clocks(struct platform_device *pdev)
 static int venc_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	int r;
 
-	r = venc_init_regulator();
+	r = venc_init_regulator(venc);
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(&venc.output, dssdev);
+	r = dss_mgr_connect(&venc->output, dssdev);
 	if (r)
 		return r;
 
@@ -760,7 +778,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(&venc.output, dssdev);
+		dss_mgr_disconnect(&venc->output, dssdev);
 		return r;
 	}
 
@@ -770,6 +788,8 @@ static int venc_connect(struct omap_dss_device *dssdev,
 static void venc_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -777,7 +797,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(&venc.output, dssdev);
+	dss_mgr_disconnect(&venc->output, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {
@@ -795,11 +815,11 @@ static const struct omapdss_atv_ops venc_ops = {
 	.get_wss = venc_get_wss,
 };
 
-static void venc_init_output(struct platform_device *pdev)
+static void venc_init_output(struct venc_device *venc)
 {
-	struct omap_dss_device *out = &venc.output;
+	struct omap_dss_device *out = &venc->output;
 
-	out->dev = &pdev->dev;
+	out->dev = &venc->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_VENC;
 	out->output_type = OMAP_DISPLAY_TYPE_VENC;
 	out->name = "venc.0";
@@ -810,16 +830,14 @@ static void venc_init_output(struct platform_device *pdev)
 	omapdss_register_output(out);
 }
 
-static void venc_uninit_output(struct platform_device *pdev)
+static void venc_uninit_output(struct venc_device *venc)
 {
-	struct omap_dss_device *out = &venc.output;
-
-	omapdss_unregister_output(out);
+	omapdss_unregister_output(&venc->output);
 }
 
-static int venc_probe_of(struct platform_device *pdev)
+static int venc_probe_of(struct venc_device *venc)
 {
-	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node = venc->pdev->dev.of_node;
 	struct device_node *ep;
 	u32 channels;
 	int r;
@@ -828,24 +846,25 @@ static int venc_probe_of(struct platform_device *pdev)
 	if (!ep)
 		return 0;
 
-	venc.invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");
+	venc->invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");
 
 	r = of_property_read_u32(ep, "ti,channels", &channels);
 	if (r) {
-		dev_err(&pdev->dev,
+		dev_err(&venc->pdev->dev,
 			"failed to read property 'ti,channels': %d\n", r);
 		goto err;
 	}
 
 	switch (channels) {
 	case 1:
-		venc.type = OMAP_DSS_VENC_TYPE_COMPOSITE;
+		venc->type = OMAP_DSS_VENC_TYPE_COMPOSITE;
 		break;
 	case 2:
-		venc.type = OMAP_DSS_VENC_TYPE_SVIDEO;
+		venc->type = OMAP_DSS_VENC_TYPE_SVIDEO;
 		break;
 	default:
-		dev_err(&pdev->dev, "bad channel propert '%d'\n", channels);
+		dev_err(&venc->pdev->dev, "bad channel propert '%d'\n",
+			channels);
 		r = -EINVAL;
 		goto err;
 	}
@@ -870,69 +889,81 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dss_device *dss = dss_get_device(master);
+	struct venc_device *venc;
 	u8 rev_id;
 	struct resource *venc_mem;
 	int r;
 
-	venc.pdev = pdev;
-	venc.dss = dss;
+	venc = kzalloc(sizeof(*venc), GFP_KERNEL);
+	if (!venc)
+		return -ENOMEM;
+
+	venc->pdev = pdev;
+	venc->dss = dss;
+	dev_set_drvdata(dev, venc);
 
 	/* The OMAP34xx, OMAP35xx and AM35xx VENC require the TV DAC clock. */
 	if (soc_device_match(venc_soc_devices))
-		venc.requires_tv_dac_clk = true;
+		venc->requires_tv_dac_clk = true;
 
-	mutex_init(&venc.venc_lock);
+	mutex_init(&venc->venc_lock);
 
-	venc.wss_data = 0;
+	venc->wss_data = 0;
 
-	venc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);
-	venc.base = devm_ioremap_resource(&pdev->dev, venc_mem);
-	if (IS_ERR(venc.base))
-		return PTR_ERR(venc.base);
+	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);
+	venc->base = devm_ioremap_resource(&pdev->dev, venc_mem);
+	if (IS_ERR(venc->base)) {
+		r = PTR_ERR(venc->base);
+		goto err_free;
+	}
 
-	r = venc_get_clocks(pdev);
+	r = venc_get_clocks(venc);
 	if (r)
-		return r;
+		goto err_free;
 
 	pm_runtime_enable(&pdev->dev);
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err_runtime_get;
 
-	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
+	rev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);
 	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 
-	r = venc_probe_of(pdev);
+	r = venc_probe_of(venc);
 	if (r) {
 		DSSERR("Invalid DT data\n");
 		goto err_probe_of;
 	}
 
-	venc.debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
-						&venc);
+	venc->debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
+						venc);
 
-	venc_init_output(pdev);
+	venc_init_output(venc);
 
 	return 0;
 
 err_probe_of:
 err_runtime_get:
 	pm_runtime_disable(&pdev->dev);
+err_free:
+	kfree(venc);
 	return r;
 }
 
 static void venc_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct platform_device *pdev = to_platform_device(dev);
+	struct venc_device *venc = dev_get_drvdata(dev);
 
-	dss_debugfs_remove_file(venc.debugfs);
+	dss_debugfs_remove_file(venc->debugfs);
 
-	venc_uninit_output(pdev);
+	venc_uninit_output(venc);
 
-	pm_runtime_disable(&pdev->dev);
+	pm_runtime_disable(dev);
+
+	kfree(venc);
 }
 
 static const struct component_ops venc_component_ops = {
@@ -953,24 +984,27 @@ static int venc_remove(struct platform_device *pdev)
 
 static int venc_runtime_suspend(struct device *dev)
 {
-	if (venc.tv_dac_clk)
-		clk_disable_unprepare(venc.tv_dac_clk);
+	struct venc_device *venc = dev_get_drvdata(dev);
+
+	if (venc->tv_dac_clk)
+		clk_disable_unprepare(venc->tv_dac_clk);
 
-	dispc_runtime_put(venc.dss->dispc);
+	dispc_runtime_put(venc->dss->dispc);
 
 	return 0;
 }
 
 static int venc_runtime_resume(struct device *dev)
 {
+	struct venc_device *venc = dev_get_drvdata(dev);
 	int r;
 
-	r = dispc_runtime_get(venc.dss->dispc);
+	r = dispc_runtime_get(venc->dss->dispc);
 	if (r < 0)
 		return r;
 
-	if (venc.tv_dac_clk)
-		clk_prepare_enable(venc.tv_dac_clk);
+	if (venc->tv_dac_clk)
+		clk_prepare_enable(venc->tv_dac_clk);
 
 	return 0;
 }

commit 8a7eda7686675b73d74c22c0d5b83059f9d783f6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:43 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to remaining dispc API functions
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 546271389189..12a0ac4e1eb1 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -586,7 +586,7 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 
 	venc.vm = actual_vm;
 
-	dispc_set_tv_pclk(13500000);
+	dispc_set_tv_pclk(venc.dss->dispc, 13500000);
 
 	mutex_unlock(&venc.venc_lock);
 }

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index bed3b54b70b2..546271389189 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -956,7 +956,7 @@ static int venc_runtime_suspend(struct device *dev)
 	if (venc.tv_dac_clk)
 		clk_disable_unprepare(venc.tv_dac_clk);
 
-	dispc_runtime_put();
+	dispc_runtime_put(venc.dss->dispc);
 
 	return 0;
 }
@@ -965,7 +965,7 @@ static int venc_runtime_resume(struct device *dev)
 {
 	int r;
 
-	r = dispc_runtime_get();
+	r = dispc_runtime_get(venc.dss->dispc);
 	if (r < 0)
 		return r;
 

commit 28d79f3e56b2c1d5ff0fd363da3229be0962cc85
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:38 2018 +0200

    drm: omapdrm: dss: Pass omap_dss_device pointer to dss_mgr_*() functions
    
    The dss_mgr_*() functions take a channel argument to identify the
    channel they operate on. This prevents the functions from accessing
    driver data structures without resorting to global variables. In an
    effort to remove global variables, pass the omap_dss_device pointer
    associated with the channel instead. This will be used to look up the
    omap_drm_private data structure to pass to the dss_mgr_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index ed756d4c7210..bed3b54b70b2 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -460,7 +460,6 @@ static const struct venc_config *venc_timings_to_config(struct videomode *vm)
 
 static int venc_power_on(struct omap_dss_device *dssdev)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
 	u32 l;
 	int r;
 
@@ -486,13 +485,13 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(channel, &venc.vm);
+	dss_mgr_set_timings(&venc.output, &venc.vm);
 
 	r = regulator_enable(venc.vdda_dac_reg);
 	if (r)
 		goto err1;
 
-	r = dss_mgr_enable(channel);
+	r = dss_mgr_enable(&venc.output);
 	if (r)
 		goto err2;
 
@@ -511,12 +510,10 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 static void venc_power_off(struct omap_dss_device *dssdev)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
-
 	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
 	dss_set_dac_pwrdn_bgz(venc.dss, 0);
 
-	dss_mgr_disable(channel);
+	dss_mgr_disable(&venc.output);
 
 	regulator_disable(venc.vdda_dac_reg);
 
@@ -749,14 +746,13 @@ static int venc_get_clocks(struct platform_device *pdev)
 static int venc_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
 	int r;
 
 	r = venc_init_regulator();
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(channel, dssdev);
+	r = dss_mgr_connect(&venc.output, dssdev);
 	if (r)
 		return r;
 
@@ -764,7 +760,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(channel, dssdev);
+		dss_mgr_disconnect(&venc.output, dssdev);
 		return r;
 	}
 
@@ -774,8 +770,6 @@ static int venc_connect(struct omap_dss_device *dssdev,
 static void venc_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	enum omap_channel channel = dssdev->dispc_channel;
-
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -783,7 +777,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(channel, dssdev);
+	dss_mgr_disconnect(&venc.output, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {

commit 1c4b92ee00734766967f5aa425767923c747f9c6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:31 2018 +0200

    drm: omapdrm: dss: Store the debugfs root directory in struct dss_device
    
    As part of an effort to remove the usage of global variables in the
    driver, store the debugfs root directory in the dss_device structure
    instead of a global variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 967a192e1789..ed756d4c7210 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -917,7 +917,8 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 		goto err_probe_of;
 	}
 
-	venc.debugfs = dss_debugfs_create_file("venc", venc_dump_regs, &venc);
+	venc.debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
+						&venc);
 
 	venc_init_output(pdev);
 

commit f33656e1fe5aba0ac0d35e18d90121dd894611ca
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:29 2018 +0200

    drm: omapdrm: dss: Support passing private data to debugfs show handlers
    
    To simplify implementation of debugfs seq_file show handlers, the driver
    passes the pointer to the show function through the debugfs_create_file
    data pointer. This prevents using the pointer to pass driver private
    data to the show handler, and requires all handlers to use global
    variables to access private data.
    
    To prepare for the removal of global private data in the driver, rework
    the debugfs infrastructure to allow passing a private data pointer to
    show handlers.
    
    The price to pay is explicit removal of debugfs files to free the
    internally allocated memory. This is desirable anyway as debugfs entries
    should be removed when a component driver is unbound, otherwise crashes
    will occur due to access to freed memory when the components will be
    dynamically allocated instead of stored in global variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 08bae18be188..967a192e1789 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -327,6 +327,8 @@ static struct {
 	struct regulator *vdda_dac_reg;
 	struct dss_device *dss;
 
+	struct dss_debugfs_entry *debugfs;
+
 	struct clk	*tv_dac_clk;
 
 	struct videomode vm;
@@ -670,12 +672,12 @@ static int venc_init_regulator(void)
 	return 0;
 }
 
-static void venc_dump_regs(struct seq_file *s)
+static int venc_dump_regs(struct seq_file *s, void *p)
 {
 #define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(r))
 
 	if (venc_runtime_get())
-		return;
+		return 0;
 
 	DUMPREG(VENC_F_CONTROL);
 	DUMPREG(VENC_VIDOUT_CTRL);
@@ -722,6 +724,7 @@ static void venc_dump_regs(struct seq_file *s)
 	venc_runtime_put();
 
 #undef DUMPREG
+	return 0;
 }
 
 static int venc_get_clocks(struct platform_device *pdev)
@@ -914,7 +917,7 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 		goto err_probe_of;
 	}
 
-	dss_debugfs_create_file("venc", venc_dump_regs);
+	venc.debugfs = dss_debugfs_create_file("venc", venc_dump_regs, &venc);
 
 	venc_init_output(pdev);
 
@@ -930,6 +933,8 @@ static void venc_unbind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 
+	dss_debugfs_remove_file(venc.debugfs);
+
 	venc_uninit_output(pdev);
 
 	pm_runtime_disable(&pdev->dev);

commit 1ef904e1e4f05d32331783d413e341c6353ae9aa
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:27 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to remaining dss functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 6de9d734ddb9..08bae18be188 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -325,6 +325,7 @@ static struct {
 	struct mutex venc_lock;
 	u32 wss_data;
 	struct regulator *vdda_dac_reg;
+	struct dss_device *dss;
 
 	struct clk	*tv_dac_clk;
 
@@ -468,8 +469,8 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 	venc_reset();
 	venc_write_config(venc_timings_to_config(&venc.vm));
 
-	dss_set_venc_output(venc.type);
-	dss_set_dac_pwrdn_bgz(1);
+	dss_set_venc_output(venc.dss, venc.type);
+	dss_set_dac_pwrdn_bgz(venc.dss, 1);
 
 	l = 0;
 
@@ -499,7 +500,7 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 	regulator_disable(venc.vdda_dac_reg);
 err1:
 	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(0);
+	dss_set_dac_pwrdn_bgz(venc.dss, 0);
 
 	venc_runtime_put();
 err0:
@@ -511,7 +512,7 @@ static void venc_power_off(struct omap_dss_device *dssdev)
 	enum omap_channel channel = dssdev->dispc_channel;
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(0);
+	dss_set_dac_pwrdn_bgz(venc.dss, 0);
 
 	dss_mgr_disable(channel);
 
@@ -871,11 +872,13 @@ static const struct soc_device_attribute venc_soc_devices[] = {
 static int venc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	struct dss_device *dss = dss_get_device(master);
 	u8 rev_id;
 	struct resource *venc_mem;
 	int r;
 
 	venc.pdev = pdev;
+	venc.dss = dss;
 
 	/* The OMAP34xx, OMAP35xx and AM35xx VENC require the TV DAC clock. */
 	if (soc_device_match(venc_soc_devices))

commit d66c36a3ee79747e300ac68276ca1496b567df68
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:32 2017 -0600

    drm: omapdrm: Simplify platform registration
    
    Currently, calls into each file are used to register the various
    platform drivers. Change this to a table of pointers to platform_driver
    structs to allow using platform_register_drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index b3e0e5fba24d..6de9d734ddb9 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -984,7 +984,7 @@ static const struct of_device_id venc_of_match[] = {
 	{},
 };
 
-static struct platform_driver omap_venchw_driver = {
+struct platform_driver omap_venchw_driver = {
 	.probe		= venc_probe,
 	.remove		= venc_remove,
 	.driver         = {
@@ -994,13 +994,3 @@ static struct platform_driver omap_venchw_driver = {
 		.suppress_bind_attrs = true,
 	},
 };
-
-int __init venc_init_platform_driver(void)
-{
-	return platform_driver_register(&omap_venchw_driver);
-}
-
-void venc_uninit_platform_driver(void)
-{
-	platform_driver_unregister(&omap_venchw_driver);
-}

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 1b0fa952b494..b3e0e5fba24d 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -1,6 +1,4 @@
 /*
- * linux/drivers/video/omap2/dss/venc.c
- *
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
  *

commit 18cbe723a6236ff1fb98ddd927831ac2a32ef46e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Oct 13 17:59:04 2017 +0300

    drm: omapdrm: venc: Return error code on OF parsing failure
    
    The venc_probe_of() function has an error cleanup path that returns
    success instead of an error code. Fix it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index d58da6f32693..1b0fa952b494 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -857,10 +857,10 @@ static int venc_probe_of(struct platform_device *pdev)
 	of_node_put(ep);
 
 	return 0;
+
 err:
 	of_node_put(ep);
-
-	return 0;
+	return r;
 }
 
 /* VENC HW IP initialisation */

commit beea6214d1cc5bb08ce25ffe06b57fb948445bed
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jun 13 12:02:09 2017 +0300

    drm/omap: fix analog tv-out modecheck
    
    omapdrm rejects all venc (analog tv-out) videomodes, due to somewhat
    strict checking of the values, making tv-out unusable.
    
    We only support two videomodes, one for PAL and one for NTSC, so instead
    of trying to check every field in the videomode struct, this patch makes
    the driver check only the pixel clock and the size of the display.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 5bd7788357b2..d58da6f32693 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -263,6 +263,12 @@ static const struct venc_config venc_config_pal_bdghi = {
 	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
 };
 
+enum venc_videomode {
+	VENC_MODE_UNKNOWN,
+	VENC_MODE_PAL,
+	VENC_MODE_NTSC,
+};
+
 static const struct videomode omap_dss_pal_vm = {
 	.hactive	= 720,
 	.vactive	= 574,
@@ -297,6 +303,24 @@ static const struct videomode omap_dss_ntsc_vm = {
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
 
+static enum venc_videomode venc_get_videomode(const struct videomode *vm)
+{
+	if (!(vm->flags & DISPLAY_FLAGS_INTERLACED))
+		return VENC_MODE_UNKNOWN;
+
+	if (vm->pixelclock == omap_dss_pal_vm.pixelclock &&
+	    vm->hactive == omap_dss_pal_vm.hactive &&
+	    vm->vactive == omap_dss_pal_vm.vactive)
+		return VENC_MODE_PAL;
+
+	if (vm->pixelclock == omap_dss_ntsc_vm.pixelclock &&
+	    vm->hactive == omap_dss_ntsc_vm.hactive &&
+	    vm->vactive == omap_dss_ntsc_vm.vactive)
+		return VENC_MODE_NTSC;
+
+	return VENC_MODE_UNKNOWN;
+}
+
 static struct {
 	struct platform_device *pdev;
 	void __iomem *base;
@@ -423,14 +447,14 @@ static void venc_runtime_put(void)
 
 static const struct venc_config *venc_timings_to_config(struct videomode *vm)
 {
-	if (memcmp(&omap_dss_pal_vm, vm, sizeof(*vm)) == 0)
+	switch (venc_get_videomode(vm)) {
+	default:
+		WARN_ON_ONCE(1);
+	case VENC_MODE_PAL:
 		return &venc_config_pal_trm;
-
-	if (memcmp(&omap_dss_ntsc_vm, vm, sizeof(*vm)) == 0)
+	case VENC_MODE_NTSC:
 		return &venc_config_ntsc_trm;
-
-	BUG();
-	return NULL;
+	}
 }
 
 static int venc_power_on(struct omap_dss_device *dssdev)
@@ -541,15 +565,28 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 static void venc_set_timings(struct omap_dss_device *dssdev,
 			     struct videomode *vm)
 {
+	struct videomode actual_vm;
+
 	DSSDBG("venc_set_timings\n");
 
 	mutex_lock(&venc.venc_lock);
 
+	switch (venc_get_videomode(vm)) {
+	default:
+		WARN_ON_ONCE(1);
+	case VENC_MODE_PAL:
+		actual_vm = omap_dss_pal_vm;
+		break;
+	case VENC_MODE_NTSC:
+		actual_vm = omap_dss_ntsc_vm;
+		break;
+	}
+
 	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc.vm, vm, sizeof(*vm)))
+	if (memcmp(&venc.vm, &actual_vm, sizeof(actual_vm)))
 		venc.wss_data = 0;
 
-	venc.vm = *vm;
+	venc.vm = actual_vm;
 
 	dispc_set_tv_pclk(13500000);
 
@@ -561,13 +598,13 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 {
 	DSSDBG("venc_check_timings\n");
 
-	if (memcmp(&omap_dss_pal_vm, vm, sizeof(*vm)) == 0)
+	switch (venc_get_videomode(vm)) {
+	case VENC_MODE_PAL:
+	case VENC_MODE_NTSC:
 		return 0;
-
-	if (memcmp(&omap_dss_ntsc_vm, vm, sizeof(*vm)) == 0)
-		return 0;
-
-	return -EINVAL;
+	default:
+		return -EINVAL;
+	}
 }
 
 static void venc_get_timings(struct omap_dss_device *dssdev,

commit d874b3a7c44ca48c0e57b8744c1eed2a6d299ba1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:19 2017 +0300

    drm: omapdrm: Remove dss_features.h
    
    The header file only contains four macros, two of which are never used.
    Move the other two to dss.h and remove dss_features.h.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index b0a85b10fa38..5bd7788357b2 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -41,7 +41,6 @@
 
 #include "omapdss.h"
 #include "dss.h"
-#include "dss_features.h"
 
 /* Venc registers */
 #define VENC_REV_ID				0x00

commit 34dfb85f03957f5f396058e2f3c15686e77c28ba
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:09 2017 +0300

    drm: omapdrm: Move FEAT_VENC_REQUIRES_TV_DAC_CLK to venc driver
    
    The FEAT_VENC_REQUIRES_TV_DAC_CLK is specific to the VENC, move it from
    the omap_dss_features structure to the venc driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 9e4fc000e961..b0a85b10fa38 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -37,6 +37,7 @@
 #include <linux/of.h>
 #include <linux/of_graph.h>
 #include <linux/component.h>
+#include <linux/sys_soc.h>
 
 #include "omapdss.h"
 #include "dss.h"
@@ -309,6 +310,7 @@ static struct {
 	struct videomode vm;
 	enum omap_dss_venc_type type;
 	bool invert_polarity;
+	bool requires_tv_dac_clk;
 
 	struct omap_dss_device output;
 } venc;
@@ -691,7 +693,7 @@ static int venc_get_clocks(struct platform_device *pdev)
 {
 	struct clk *clk;
 
-	if (dss_has_feature(FEAT_VENC_REQUIRES_TV_DAC_CLK)) {
+	if (venc.requires_tv_dac_clk) {
 		clk = devm_clk_get(&pdev->dev, "tv_dac_clk");
 		if (IS_ERR(clk)) {
 			DSSERR("can't get tv_dac_clk\n");
@@ -826,6 +828,12 @@ static int venc_probe_of(struct platform_device *pdev)
 }
 
 /* VENC HW IP initialisation */
+static const struct soc_device_attribute venc_soc_devices[] = {
+	{ .machine = "OMAP3[45]*" },
+	{ .machine = "AM35*" },
+	{ /* sentinel */ }
+};
+
 static int venc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -835,6 +843,10 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 
 	venc.pdev = pdev;
 
+	/* The OMAP34xx, OMAP35xx and AM35xx VENC require the TV DAC clock. */
+	if (soc_device_match(venc_soc_devices))
+		venc.requires_tv_dac_clk = true;
+
 	mutex_init(&venc.venc_lock);
 
 	venc.wss_data = 0;

commit d696430758a8f5be1c26334c61f0338993657d06
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:50 2017 +0300

    drm: omapdrm: venc: Don't export omap_dss_pal_vm and omap_dss_ntsc_vm
    
    The two variables are never used outside of their compilation unit, make
    them static.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index a6bfb3918b8d..9e4fc000e961 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -263,7 +263,7 @@ static const struct venc_config venc_config_pal_bdghi = {
 	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
 };
 
-const struct videomode omap_dss_pal_vm = {
+static const struct videomode omap_dss_pal_vm = {
 	.hactive	= 720,
 	.vactive	= 574,
 	.pixelclock	= 13500000,
@@ -279,9 +279,8 @@ const struct videomode omap_dss_pal_vm = {
 			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
-EXPORT_SYMBOL(omap_dss_pal_vm);
 
-const struct videomode omap_dss_ntsc_vm = {
+static const struct videomode omap_dss_ntsc_vm = {
 	.hactive	= 720,
 	.vactive	= 482,
 	.pixelclock	= 13500000,
@@ -297,7 +296,6 @@ const struct videomode omap_dss_ntsc_vm = {
 			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
-EXPORT_SYMBOL(omap_dss_ntsc_vm);
 
 static struct {
 	struct platform_device *pdev;

commit f2214bc845552f280039f69f0c4cd43807019292
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri May 12 12:40:55 2017 +0300

    drm/omap: venc: remove set_type & invert_vid_out_polarity
    
    Non-DT booting is no longer supported, so remove legacy code.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 8e836fddc390..a6bfb3918b8d 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -616,26 +616,6 @@ static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
 	return r;
 }
 
-static void venc_set_type(struct omap_dss_device *dssdev,
-		enum omap_dss_venc_type type)
-{
-	mutex_lock(&venc.venc_lock);
-
-	venc.type = type;
-
-	mutex_unlock(&venc.venc_lock);
-}
-
-static void venc_invert_vid_out_polarity(struct omap_dss_device *dssdev,
-		bool invert_polarity)
-{
-	mutex_lock(&venc.venc_lock);
-
-	venc.invert_polarity = invert_polarity;
-
-	mutex_unlock(&venc.venc_lock);
-}
-
 static int venc_init_regulator(void)
 {
 	struct regulator *vdda_dac;
@@ -779,9 +759,6 @@ static const struct omapdss_atv_ops venc_ops = {
 	.set_timings = venc_set_timings,
 	.get_timings = venc_get_timings,
 
-	.set_type = venc_set_type,
-	.invert_vid_out_polarity = venc_invert_vid_out_polarity,
-
 	.set_wss = venc_set_wss,
 	.get_wss = venc_get_wss,
 };

commit 1dff212ce62bb31c4eb7fc86c996b988663e9ec3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 7 00:42:26 2017 +0300

    drm: omapdrm: Drop support for non-DT devices
    
    All OMAP platforms use DT nowadays, drop support for non-DT devices.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index fbdc838586f9..8e836fddc390 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -643,11 +643,7 @@ static int venc_init_regulator(void)
 	if (venc.vdda_dac_reg != NULL)
 		return 0;
 
-	if (venc.pdev->dev.of_node)
-		vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");
-	else
-		vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda_dac");
-
+	vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");
 	if (IS_ERR(vdda_dac)) {
 		if (PTR_ERR(vdda_dac) != -EPROBE_DEFER)
 			DSSERR("can't get VDDA_DAC regulator\n");
@@ -888,12 +884,10 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 
 	venc_runtime_put();
 
-	if (pdev->dev.of_node) {
-		r = venc_probe_of(pdev);
-		if (r) {
-			DSSERR("Invalid DT data\n");
-			goto err_probe_of;
-		}
+	r = venc_probe_of(pdev);
+	if (r) {
+		DSSERR("Invalid DT data\n");
+		goto err_probe_of;
 	}
 
 	dss_debugfs_create_file("venc", venc_dump_regs);

commit b22622f0cba3a6ee780787abd84b3b0c1ad09b26
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 7 00:29:09 2017 +0300

    drm: omapdrm: Remove duplicate error messages when mapping memory
    
    The devm_ioremap_resource() call can handle being given a NULL resource,
    and prints an error message when mapping fails. Switch the remaining
    devm_ioremap() calls to devm_ioremap_resource() and remove all
    extraneous resource NULL checks and error messages printed manually by
    the driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 19d14957f566..fbdc838586f9 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -869,17 +869,9 @@ static int venc_bind(struct device *dev, struct device *master, void *data)
 	venc.wss_data = 0;
 
 	venc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);
-	if (!venc_mem) {
-		DSSERR("can't get IORESOURCE_MEM VENC\n");
-		return -EINVAL;
-	}
-
-	venc.base = devm_ioremap(&pdev->dev, venc_mem->start,
-				 resource_size(venc_mem));
-	if (!venc.base) {
-		DSSERR("can't ioremap VENC\n");
-		return -ENOMEM;
-	}
+	venc.base = devm_ioremap_resource(&pdev->dev, venc_mem);
+	if (IS_ERR(venc.base))
+		return PTR_ERR(venc.base);
 
 	r = venc_get_clocks(pdev);
 	if (r)

commit 09bffa6e519256c6fa1552d6ba1f5d594337a464
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 08:26:08 2017 -0500

    drm: omap: use common OF graph helpers
    
    The OMAP driver has its own OF graph helpers that are similar to the
    common helpers. This commit replaces most of the calls with the common
    helpers. There's still a couple of custom helpers left, but the driver
    needs more extensive changes to get rid of them.
    
    In dss_init_ports, we invert the loop, looping through the known ports
    and matching them to DT nodes rather than looping thru DT nodes and
    matching them to the ports.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index d74f7fcc2e46..19d14957f566 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -35,6 +35,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <linux/component.h>
 
 #include "omapdss.h"
@@ -818,7 +819,7 @@ static int venc_probe_of(struct platform_device *pdev)
 	u32 channels;
 	int r;
 
-	ep = omapdss_of_get_first_endpoint(node);
+	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
 	if (!ep)
 		return 0;
 

commit da11bbbb10a964c293c2e2e702ea62ad6cba48b4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:04 2016 +0300

    drm/omap: Use consistent name for struct videomode
    
    Use 'vm' to refer to a struct videomode instead of 'p', 't', 'timings' or
    something else.
    
    The code will be easier to follow if we use consistent names.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 68a04a8753b0..d74f7fcc2e46 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -262,7 +262,7 @@ static const struct venc_config venc_config_pal_bdghi = {
 	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
 };
 
-const struct videomode omap_dss_pal_timings = {
+const struct videomode omap_dss_pal_vm = {
 	.hactive	= 720,
 	.vactive	= 574,
 	.pixelclock	= 13500000,
@@ -278,9 +278,9 @@ const struct videomode omap_dss_pal_timings = {
 			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
-EXPORT_SYMBOL(omap_dss_pal_timings);
+EXPORT_SYMBOL(omap_dss_pal_vm);
 
-const struct videomode omap_dss_ntsc_timings = {
+const struct videomode omap_dss_ntsc_vm = {
 	.hactive	= 720,
 	.vactive	= 482,
 	.pixelclock	= 13500000,
@@ -296,7 +296,7 @@ const struct videomode omap_dss_ntsc_timings = {
 			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
 			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
-EXPORT_SYMBOL(omap_dss_ntsc_timings);
+EXPORT_SYMBOL(omap_dss_ntsc_vm);
 
 static struct {
 	struct platform_device *pdev;
@@ -307,7 +307,7 @@ static struct {
 
 	struct clk	*tv_dac_clk;
 
-	struct videomode timings;
+	struct videomode vm;
 	enum omap_dss_venc_type type;
 	bool invert_polarity;
 
@@ -421,13 +421,12 @@ static void venc_runtime_put(void)
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
-static const struct venc_config *venc_timings_to_config(
-		struct videomode *timings)
+static const struct venc_config *venc_timings_to_config(struct videomode *vm)
 {
-	if (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)
+	if (memcmp(&omap_dss_pal_vm, vm, sizeof(*vm)) == 0)
 		return &venc_config_pal_trm;
 
-	if (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)
+	if (memcmp(&omap_dss_ntsc_vm, vm, sizeof(*vm)) == 0)
 		return &venc_config_ntsc_trm;
 
 	BUG();
@@ -445,7 +444,7 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 		goto err0;
 
 	venc_reset();
-	venc_write_config(venc_timings_to_config(&venc.timings));
+	venc_write_config(venc_timings_to_config(&venc.vm));
 
 	dss_set_venc_output(venc.type);
 	dss_set_dac_pwrdn_bgz(1);
@@ -462,7 +461,7 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(channel, &venc.timings);
+	dss_mgr_set_timings(channel, &venc.vm);
 
 	r = regulator_enable(venc.vdda_dac_reg);
 	if (r)
@@ -540,17 +539,17 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
-		struct videomode *timings)
+			     struct videomode *vm)
 {
 	DSSDBG("venc_set_timings\n");
 
 	mutex_lock(&venc.venc_lock);
 
 	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc.timings, timings, sizeof(*timings)))
+	if (memcmp(&venc.vm, vm, sizeof(*vm)))
 		venc.wss_data = 0;
 
-	venc.timings = *timings;
+	venc.vm = *vm;
 
 	dispc_set_tv_pclk(13500000);
 
@@ -558,25 +557,25 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 }
 
 static int venc_check_timings(struct omap_dss_device *dssdev,
-		struct videomode *timings)
+			      struct videomode *vm)
 {
 	DSSDBG("venc_check_timings\n");
 
-	if (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)
+	if (memcmp(&omap_dss_pal_vm, vm, sizeof(*vm)) == 0)
 		return 0;
 
-	if (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)
+	if (memcmp(&omap_dss_ntsc_vm, vm, sizeof(*vm)) == 0)
 		return 0;
 
 	return -EINVAL;
 }
 
 static void venc_get_timings(struct omap_dss_device *dssdev,
-		struct videomode *timings)
+			     struct videomode *vm)
 {
 	mutex_lock(&venc.venc_lock);
 
-	*timings = venc.timings;
+	*vm = venc.vm;
 
 	mutex_unlock(&venc.venc_lock);
 }
@@ -596,7 +595,7 @@ static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
 
 	mutex_lock(&venc.venc_lock);
 
-	config = venc_timings_to_config(&venc.timings);
+	config = venc_timings_to_config(&venc.vm);
 
 	/* Invert due to VENC_L21_WC_CTL:INV=1 */
 	venc.wss_data = (wss ^ 0xfffff) << 8;

commit 4520ff28aaa1e7f1b45f3abc0c45429ea9e93817
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:03 2016 +0300

    drm/omap: Replace struct omap_video_timings with videomode
    
    omap_video_timings can be replaced with the generic videomode in omapdrm
    and the omap_video_timings can be removed.
    
    This patch will replace the omap_video_timings with videomode.
    With the change we no longer need the functions to convert to/from
    videomode and drm_display_mode to omap_video_timings, these can be removed
    as well.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 43f98547e9fc..68a04a8753b0 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -262,7 +262,7 @@ static const struct venc_config venc_config_pal_bdghi = {
 	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
 };
 
-const struct omap_video_timings omap_dss_pal_timings = {
+const struct videomode omap_dss_pal_timings = {
 	.hactive	= 720,
 	.vactive	= 574,
 	.pixelclock	= 13500000,
@@ -280,7 +280,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
-const struct omap_video_timings omap_dss_ntsc_timings = {
+const struct videomode omap_dss_ntsc_timings = {
 	.hactive	= 720,
 	.vactive	= 482,
 	.pixelclock	= 13500000,
@@ -307,7 +307,7 @@ static struct {
 
 	struct clk	*tv_dac_clk;
 
-	struct omap_video_timings timings;
+	struct videomode timings;
 	enum omap_dss_venc_type type;
 	bool invert_polarity;
 
@@ -422,7 +422,7 @@ static void venc_runtime_put(void)
 }
 
 static const struct venc_config *venc_timings_to_config(
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	if (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)
 		return &venc_config_pal_trm;
@@ -540,7 +540,7 @@ static void venc_display_disable(struct omap_dss_device *dssdev)
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	DSSDBG("venc_set_timings\n");
 
@@ -558,7 +558,7 @@ static void venc_set_timings(struct omap_dss_device *dssdev,
 }
 
 static int venc_check_timings(struct omap_dss_device *dssdev,
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	DSSDBG("venc_check_timings\n");
 
@@ -572,7 +572,7 @@ static int venc_check_timings(struct omap_dss_device *dssdev,
 }
 
 static void venc_get_timings(struct omap_dss_device *dssdev,
-		struct omap_video_timings *timings)
+		struct videomode *timings)
 {
 	mutex_lock(&venc.venc_lock);
 

commit d34afb73c3e8906e558c272229e78c8b265196ba
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:01 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for sync edge
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for sync edge.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 82d0cda9a499..43f98547e9fc 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -273,11 +273,10 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vfront_porch	= 5,
 	.vback_porch	= 41,
 
-	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
-
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
 			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
-			  DISPLAY_FLAGS_PIXDATA_POSEDGE,
+			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
+			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
@@ -292,11 +291,10 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vfront_porch	= 6,
 	.vback_porch	= 31,
 
-	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
-
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
 			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
-			  DISPLAY_FLAGS_PIXDATA_POSEDGE,
+			  DISPLAY_FLAGS_PIXDATA_POSEDGE |
+			  DISPLAY_FLAGS_SYNC_NEGEDGE,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 

commit f149e17a7bf904c55f69e2aef5a0fc5915e40e04
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:00 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for pixel data edge
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for pixel data edge.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 8657e3c09e32..82d0cda9a499 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -273,11 +273,11 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vfront_porch	= 5,
 	.vback_porch	= 41,
 
-	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH,
+			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
+			  DISPLAY_FLAGS_PIXDATA_POSEDGE,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
@@ -292,11 +292,11 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vfront_porch	= 6,
 	.vback_porch	= 31,
 
-	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH,
+			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH |
+			  DISPLAY_FLAGS_PIXDATA_POSEDGE,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 

commit 3fa3ab4a881b9c464cb3168b476825ae5a02bfa6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:58 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for DE level
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for DE level.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index e80ec809f0c7..8657e3c09e32 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -274,11 +274,10 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vback_porch	= 41,
 
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
-	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW,
+			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
@@ -294,11 +293,10 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vback_porch	= 31,
 
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
-	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
 	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
-			  DISPLAY_FLAGS_VSYNC_LOW,
+			  DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_DE_HIGH,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 

commit 6b44cd2748d6efa09a83fe97a2d35fb90f80e489
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:57 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for h/vsync level
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for h/vsync level.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index e271c75ef632..e80ec809f0c7 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -273,13 +273,12 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vfront_porch	= 5,
 	.vback_porch	= 41,
 
-	.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
-	.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
-	.flags		= DISPLAY_FLAGS_INTERLACED,
+	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
+			  DISPLAY_FLAGS_VSYNC_LOW,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
@@ -294,13 +293,12 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vfront_porch	= 6,
 	.vback_porch	= 31,
 
-	.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
-	.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
 
-	.flags		= DISPLAY_FLAGS_INTERLACED,
+	.flags		= DISPLAY_FLAGS_INTERLACED | DISPLAY_FLAGS_HSYNC_LOW |
+			  DISPLAY_FLAGS_VSYNC_LOW,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 

commit 530582998acef0a6f9aafed7c82a2bb11b4405f6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:55 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for interlace mode
    
    Remove the interlace member and add display_flags to omap_video_timings to
    configure the interlace mode.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 411eea6bc99f..e271c75ef632 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -273,13 +273,13 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vfront_porch	= 5,
 	.vback_porch	= 41,
 
-	.interlace	= true,
-
 	.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
+
+	.flags		= DISPLAY_FLAGS_INTERLACED,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
@@ -294,13 +294,13 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vfront_porch	= 6,
 	.vback_porch	= 31,
 
-	.interlace	= true,
-
 	.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 	.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 	.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 	.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE,
+
+	.flags		= DISPLAY_FLAGS_INTERLACED,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 

commit 458540c606757a4b52476f8e4d937a36ed94c577
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:53 2016 +0300

    drm/omap: omap_display_timings: rename vbp to vback_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vbp member to vback_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 77d4c826b2e5..411eea6bc99f 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -271,7 +271,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.hback_porch	= 68,
 	.vsync_len	= 5,
 	.vfront_porch	= 5,
-	.vbp		= 41,
+	.vback_porch	= 41,
 
 	.interlace	= true,
 
@@ -292,7 +292,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.hback_porch	= 58,
 	.vsync_len	= 6,
 	.vfront_porch	= 6,
-	.vbp		= 31,
+	.vback_porch	= 31,
 
 	.interlace	= true,
 

commit 0996c68e1bf7364ca7f02ac06048c12abb56c37a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:52 2016 +0300

    drm/omap: omap_display_timings: rename vfp to vfront_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vfp member to vfront_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 5e8ea7e00b68..77d4c826b2e5 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -270,7 +270,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.hfront_porch	= 12,
 	.hback_porch	= 68,
 	.vsync_len	= 5,
-	.vfp		= 5,
+	.vfront_porch	= 5,
 	.vbp		= 41,
 
 	.interlace	= true,
@@ -291,7 +291,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.hfront_porch	= 16,
 	.hback_porch	= 58,
 	.vsync_len	= 6,
-	.vfp		= 6,
+	.vfront_porch	= 6,
 	.vbp		= 31,
 
 	.interlace	= true,

commit d5bcf0aa3f6fb396fc8099a4e5960f9274b0dae9
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:51 2016 +0300

    drm/omap: omap_display_timings: rename vsw to vsync_len
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vsw member to vsync_len.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index f192368bec60..5e8ea7e00b68 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -269,7 +269,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.hsync_len	= 64,
 	.hfront_porch	= 12,
 	.hback_porch	= 68,
-	.vsw		= 5,
+	.vsync_len	= 5,
 	.vfp		= 5,
 	.vbp		= 41,
 
@@ -290,7 +290,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.hsync_len	= 64,
 	.hfront_porch	= 16,
 	.hback_porch	= 58,
-	.vsw		= 6,
+	.vsync_len	= 6,
 	.vfp		= 6,
 	.vbp		= 31,
 

commit a85f4a80784b34362568a0ff1f34aaa3357462a0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:50 2016 +0300

    drm/omap: omap_display_timings: rename hbp to hback_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hbp member to hback_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 92dbcab2d72a..f192368bec60 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -268,7 +268,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.pixelclock	= 13500000,
 	.hsync_len	= 64,
 	.hfront_porch	= 12,
-	.hbp		= 68,
+	.hback_porch	= 68,
 	.vsw		= 5,
 	.vfp		= 5,
 	.vbp		= 41,
@@ -289,7 +289,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.pixelclock	= 13500000,
 	.hsync_len	= 64,
 	.hfront_porch	= 16,
-	.hbp		= 58,
+	.hback_porch	= 58,
 	.vsw		= 6,
 	.vfp		= 6,
 	.vbp		= 31,

commit 0a30e150f053e609f7820d81efebde28802035f3
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:49 2016 +0300

    drm/omap: omap_display_timings: rename hfp to hfront_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hfp member to hfront_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 9f53e9a21706..92dbcab2d72a 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -267,7 +267,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.vactive	= 574,
 	.pixelclock	= 13500000,
 	.hsync_len	= 64,
-	.hfp		= 12,
+	.hfront_porch	= 12,
 	.hbp		= 68,
 	.vsw		= 5,
 	.vfp		= 5,
@@ -288,7 +288,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.vactive	= 482,
 	.pixelclock	= 13500000,
 	.hsync_len	= 64,
-	.hfp		= 16,
+	.hfront_porch	= 16,
 	.hbp		= 58,
 	.vsw		= 6,
 	.vfp		= 6,

commit 4dc2250d7d9e816b986d656cde90f55c096012ed
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:48 2016 +0300

    drm/omap: omap_display_timings: rename hsw to hsync_len
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hsw member to hsync_len.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 463dc4e27f7a..9f53e9a21706 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -266,7 +266,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 	.hactive	= 720,
 	.vactive	= 574,
 	.pixelclock	= 13500000,
-	.hsw		= 64,
+	.hsync_len	= 64,
 	.hfp		= 12,
 	.hbp		= 68,
 	.vsw		= 5,
@@ -287,7 +287,7 @@ const struct omap_video_timings omap_dss_ntsc_timings = {
 	.hactive	= 720,
 	.vactive	= 482,
 	.pixelclock	= 13500000,
-	.hsw		= 64,
+	.hsync_len	= 64,
 	.hfp		= 16,
 	.hbp		= 58,
 	.vsw		= 6,

commit fb7f3c4399ffa75bc31aaaaeab45238ea60c3d1a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:47 2016 +0300

    drm/omap: omap_display_timings: rename y_res to vactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the y_res member to vactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 970c3cb97a8c..463dc4e27f7a 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -264,7 +264,7 @@ static const struct venc_config venc_config_pal_bdghi = {
 
 const struct omap_video_timings omap_dss_pal_timings = {
 	.hactive	= 720,
-	.y_res		= 574,
+	.vactive	= 574,
 	.pixelclock	= 13500000,
 	.hsw		= 64,
 	.hfp		= 12,
@@ -285,7 +285,7 @@ EXPORT_SYMBOL(omap_dss_pal_timings);
 
 const struct omap_video_timings omap_dss_ntsc_timings = {
 	.hactive	= 720,
-	.y_res		= 482,
+	.vactive	= 482,
 	.pixelclock	= 13500000,
 	.hsw		= 64,
 	.hfp		= 16,

commit 81899060de35d80f17020d322e77311f1b255885
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:46 2016 +0300

    drm/omap: omap_display_timings: rename x_res to hactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the x_res member to hactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 6eedf2118708..970c3cb97a8c 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -263,7 +263,7 @@ static const struct venc_config venc_config_pal_bdghi = {
 };
 
 const struct omap_video_timings omap_dss_pal_timings = {
-	.x_res		= 720,
+	.hactive	= 720,
 	.y_res		= 574,
 	.pixelclock	= 13500000,
 	.hsw		= 64,
@@ -284,7 +284,7 @@ const struct omap_video_timings omap_dss_pal_timings = {
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
 const struct omap_video_timings omap_dss_ntsc_timings = {
-	.x_res		= 720,
+	.hactive	= 720,
 	.y_res		= 482,
 	.pixelclock	= 13500000,
 	.hsw		= 64,

commit 32043da7dcf2af3510d0410b0cacfbcde95e5d26
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 27 14:40:49 2016 +0300

    drm/omap: Do not include video/omapdss.h directly in drivers
    
    All drivers to include the omapdrm/dss/omapdss.h header file. This header
    includes the <video/omapdss.h>
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 08a2cc778ba9..6eedf2118708 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -37,8 +37,7 @@
 #include <linux/of.h>
 #include <linux/component.h>
 
-#include <video/omapdss.h>
-
+#include "omapdss.h"
 #include "dss.h"
 #include "dss_features.h"
 

commit 532a2cba7a7c23c87b4407f889b949a61816b3d1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:57:35 2015 +0200

    drm/omap: VENC: remove uses of omap_overlay_manager
    
    We are removing the uses of 'struct omap_overlay_manager'. This patch
    changes VENC driver to use 'omap_channel' instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index d514c9878ae2..08a2cc778ba9 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -443,7 +443,7 @@ static const struct venc_config *venc_timings_to_config(
 
 static int venc_power_on(struct omap_dss_device *dssdev)
 {
-	struct omap_overlay_manager *mgr = venc.output.manager;
+	enum omap_channel channel = dssdev->dispc_channel;
 	u32 l;
 	int r;
 
@@ -469,13 +469,13 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(mgr->id, &venc.timings);
+	dss_mgr_set_timings(channel, &venc.timings);
 
 	r = regulator_enable(venc.vdda_dac_reg);
 	if (r)
 		goto err1;
 
-	r = dss_mgr_enable(mgr->id);
+	r = dss_mgr_enable(channel);
 	if (r)
 		goto err2;
 
@@ -494,12 +494,12 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 static void venc_power_off(struct omap_dss_device *dssdev)
 {
-	struct omap_overlay_manager *mgr = venc.output.manager;
+	enum omap_channel channel = dssdev->dispc_channel;
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
 	dss_set_dac_pwrdn_bgz(0);
 
-	dss_mgr_disable(mgr->id);
+	dss_mgr_disable(channel);
 
 	regulator_disable(venc.vdda_dac_reg);
 
@@ -742,18 +742,14 @@ static int venc_get_clocks(struct platform_device *pdev)
 static int venc_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
-	struct omap_overlay_manager *mgr;
+	enum omap_channel channel = dssdev->dispc_channel;
 	int r;
 
 	r = venc_init_regulator();
 	if (r)
 		return r;
 
-	mgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);
-	if (!mgr)
-		return -ENODEV;
-
-	r = dss_mgr_connect(mgr->id, dssdev);
+	r = dss_mgr_connect(channel, dssdev);
 	if (r)
 		return r;
 
@@ -761,7 +757,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(mgr->id, dssdev);
+		dss_mgr_disconnect(channel, dssdev);
 		return r;
 	}
 
@@ -771,6 +767,8 @@ static int venc_connect(struct omap_dss_device *dssdev,
 static void venc_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	enum omap_channel channel = dssdev->dispc_channel;
+
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -778,7 +776,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(dssdev->manager->id, dssdev);
+	dss_mgr_disconnect(channel, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {

commit a0e53bfe9f41689d337955814bdc2e5c0f373009
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:44:53 2015 +0200

    drm/omap: remove extra manager checks on disconnect
    
    The DSS output drivers check 'dssdev->manager' in disconnect()
    functions. This check is not needed as the manager must always be set if
    the output device was connected. Remove the check.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 401c477242b1..d514c9878ae2 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -778,8 +778,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 
 	omapdss_output_unset_device(dssdev);
 
-	if (dssdev->manager)
-		dss_mgr_disconnect(dssdev->manager->id, dssdev);
+	dss_mgr_disconnect(dssdev->manager->id, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {

commit 705fd454a909ab652954c04352bc9f2753523d7b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:28:45 2015 +0200

    drm/omap: convert dss_mgr_disable to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_disable() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index aae4cd0ae5ce..401c477242b1 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -499,7 +499,7 @@ static void venc_power_off(struct omap_dss_device *dssdev)
 	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
 	dss_set_dac_pwrdn_bgz(0);
 
-	dss_mgr_disable(mgr);
+	dss_mgr_disable(mgr->id);
 
 	regulator_disable(venc.vdda_dac_reg);
 

commit 85a8c62250d7e31ded7a45c312b6860fb87e1a13
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:27:31 2015 +0200

    drm/omap: convert dss_mgr_enable to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_enable() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index af760ec7f5dd..aae4cd0ae5ce 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -475,7 +475,7 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 	if (r)
 		goto err1;
 
-	r = dss_mgr_enable(mgr);
+	r = dss_mgr_enable(mgr->id);
 	if (r)
 		goto err2;
 

commit 5c6ff3cd4546dea0a7a70cef6c9b656b8b022217
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:25:05 2015 +0200

    drm/omap: convert dss_mgr_set_timings to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_set_timings() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 2a4bd2537040..af760ec7f5dd 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -469,7 +469,7 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 
 	venc_write_reg(VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(mgr, &venc.timings);
+	dss_mgr_set_timings(mgr->id, &venc.timings);
 
 	r = regulator_enable(venc.vdda_dac_reg);
 	if (r)

commit bdac3bb946f1bb9a38eb15df755b579b6dc56834
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:23:37 2015 +0200

    drm/omap: convert dss_mgr_disconnect to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_disconnect() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index afc97891d476..2a4bd2537040 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -761,7 +761,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(mgr, dssdev);
+		dss_mgr_disconnect(mgr->id, dssdev);
 		return r;
 	}
 
@@ -779,7 +779,7 @@ static void venc_disconnect(struct omap_dss_device *dssdev,
 	omapdss_output_unset_device(dssdev);
 
 	if (dssdev->manager)
-		dss_mgr_disconnect(dssdev->manager, dssdev);
+		dss_mgr_disconnect(dssdev->manager->id, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {

commit 1b07b0664aa9f36e5a79c82cff46722e587ab647
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 20:21:48 2015 +0200

    drm/omap: convert dss_mgr_connect to accept omap_channel
    
    We are removing uses of 'struct omap_overlay_manager'. This patch
    changes dss_mgr_connect() to accept 'enum omap_channel' instead of
    'struct omap_overlay_manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 037c5b4e2ed6..afc97891d476 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -753,7 +753,7 @@ static int venc_connect(struct omap_dss_device *dssdev,
 	if (!mgr)
 		return -ENODEV;
 
-	r = dss_mgr_connect(mgr, dssdev);
+	r = dss_mgr_connect(mgr->id, dssdev);
 	if (r)
 		return r;
 

commit f1504ad00daeeb301936f8695be28edb61613b76
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 09:34:51 2015 +0200

    drm/omap: use dispc_channel_connected in output drivers
    
    Use 'out->dispc_channel_connected' to check if the device is connected
    to an overlay manager or not, instead of using 'out->manager'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
index 08f9def76e27..037c5b4e2ed6 100644
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -515,7 +515,7 @@ static int venc_display_enable(struct omap_dss_device *dssdev)
 
 	mutex_lock(&venc.venc_lock);
 
-	if (out->manager == NULL) {
+	if (!out->dispc_channel_connected) {
 		DSSERR("Failed to enable display: no output/manager\n");
 		r = -ENODEV;
 		goto err0;

commit d43fb9f3c5dff281dd72bea5cd2e91386fdc33a8
Merge: 5807fcaa9bf7 6f6abd360603
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 18 11:58:31 2016 -0800

    Merge tag 'fbdev-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux
    
    Pull fbdev updates from Tomi Valkeinen:
     "Summary:
    
       - pxafb: device-tree support
       - An unsafe kernel parameter 'lockless_register_fb' for debugging
         problems happening while inside the console lock
       - Small miscellaneous fixes & cleanups
       - omapdss: add writeback support functions
       - Separation of omapfb and omapdrm (see below)
    
      About the separation of omapfb and omapdrm, see
    
        http://permalink.gmane.org/gmane.comp.video.dri.devel/143151
    
      for longer story.  The short version:
    
      omapfb and omapdrm have shared low level drivers (omapdss and panel
      drivers), making further development of omapdrm difficult.  After
      these patches omapfb and omapdrm have their own versions of the
      drivers, which are more or less direct copies for now but will diverge
      soon.
    
      This also means that omapfb (everything under drivers/video/fbdev/omap2/)
      is now in maintenance mode, and all new development will be done for
      omapdrm (drivers/gpu/drm/omapdrm/)"
    
    * tag 'fbdev-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (49 commits)
      video: fbdev: pxafb: fix out of memory error path
      drm/omap: make omapdrm select OMAP2_DSS
      drm/omap: move omapdss & displays under omapdrm
      omapfb: move vrfb into omapfb
      omapfb: take omapfb's private omapdss into use
      omapfb/displays: change CONFIG_DISPLAY_* to CONFIG_FB_OMAP2_*
      omapfb/dss: change CONFIG_OMAP* to CONFIG_FB_OMAP*
      omapdss: remove CONFIG_OMAP2_DSS_VENC from omapdss.h
      omapfb: copy omapdss & displays for omapfb
      omapfb: allow compilation only if DRM_OMAP is disabled
      fbdev: omap2: panel-dpi: simplify gpio setting
      fbdev: omap2: panel-dpi: in .disable first disable backlight then display
      OMAPDSS: DSS: fix a warning message
      video: omapdss: delete unneeded of_node_put
      OMAPDSS: DISPC: Remove boolean comparisons
      OMAPDSS: DSI: cleanup DSI_IRQ_ERROR_MASK define
      OMAPDSS: remove extra out == NULL checks
      OMAPDSS: change internal dispc functions to static
      OMAPDSS: make a two dss feat funcs internal to omapdss
      OMAPDSS: remove extra EXPORT_SYMBOLs
      ...

commit 9960aa7cb58caadef8edf3a2582e30664a6b68dd
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Dec 9 20:26:00 2015 +0200

    drm/omap: move omapdss & displays under omapdrm
    
    Now that omapfb has its own copy of omapdss and display drivers, we can
    move omapdss and display drivers which omapdrm uses to omapdrm's
    directory.
    
    We also need to change the main drm Makefile so that omapdrm directory
    is always entered, because omapdss has a file that can't be built as a
    module.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Acked-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/venc.c b/drivers/gpu/drm/omapdrm/dss/venc.c
new file mode 100644
index 000000000000..c9260a451ca6
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -0,0 +1,997 @@
+/*
+ * linux/drivers/video/omap2/dss/venc.c
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * VENC settings from TI's DSS driver
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DSS_SUBSYS_NAME "VENC"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/seq_file.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/component.h>
+
+#include <video/omapdss.h>
+
+#include "dss.h"
+#include "dss_features.h"
+
+/* Venc registers */
+#define VENC_REV_ID				0x00
+#define VENC_STATUS				0x04
+#define VENC_F_CONTROL				0x08
+#define VENC_VIDOUT_CTRL			0x10
+#define VENC_SYNC_CTRL				0x14
+#define VENC_LLEN				0x1C
+#define VENC_FLENS				0x20
+#define VENC_HFLTR_CTRL				0x24
+#define VENC_CC_CARR_WSS_CARR			0x28
+#define VENC_C_PHASE				0x2C
+#define VENC_GAIN_U				0x30
+#define VENC_GAIN_V				0x34
+#define VENC_GAIN_Y				0x38
+#define VENC_BLACK_LEVEL			0x3C
+#define VENC_BLANK_LEVEL			0x40
+#define VENC_X_COLOR				0x44
+#define VENC_M_CONTROL				0x48
+#define VENC_BSTAMP_WSS_DATA			0x4C
+#define VENC_S_CARR				0x50
+#define VENC_LINE21				0x54
+#define VENC_LN_SEL				0x58
+#define VENC_L21__WC_CTL			0x5C
+#define VENC_HTRIGGER_VTRIGGER			0x60
+#define VENC_SAVID__EAVID			0x64
+#define VENC_FLEN__FAL				0x68
+#define VENC_LAL__PHASE_RESET			0x6C
+#define VENC_HS_INT_START_STOP_X		0x70
+#define VENC_HS_EXT_START_STOP_X		0x74
+#define VENC_VS_INT_START_X			0x78
+#define VENC_VS_INT_STOP_X__VS_INT_START_Y	0x7C
+#define VENC_VS_INT_STOP_Y__VS_EXT_START_X	0x80
+#define VENC_VS_EXT_STOP_X__VS_EXT_START_Y	0x84
+#define VENC_VS_EXT_STOP_Y			0x88
+#define VENC_AVID_START_STOP_X			0x90
+#define VENC_AVID_START_STOP_Y			0x94
+#define VENC_FID_INT_START_X__FID_INT_START_Y	0xA0
+#define VENC_FID_INT_OFFSET_Y__FID_EXT_START_X	0xA4
+#define VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y	0xA8
+#define VENC_TVDETGP_INT_START_STOP_X		0xB0
+#define VENC_TVDETGP_INT_START_STOP_Y		0xB4
+#define VENC_GEN_CTRL				0xB8
+#define VENC_OUTPUT_CONTROL			0xC4
+#define VENC_OUTPUT_TEST			0xC8
+#define VENC_DAC_B__DAC_C			0xC8
+
+struct venc_config {
+	u32 f_control;
+	u32 vidout_ctrl;
+	u32 sync_ctrl;
+	u32 llen;
+	u32 flens;
+	u32 hfltr_ctrl;
+	u32 cc_carr_wss_carr;
+	u32 c_phase;
+	u32 gain_u;
+	u32 gain_v;
+	u32 gain_y;
+	u32 black_level;
+	u32 blank_level;
+	u32 x_color;
+	u32 m_control;
+	u32 bstamp_wss_data;
+	u32 s_carr;
+	u32 line21;
+	u32 ln_sel;
+	u32 l21__wc_ctl;
+	u32 htrigger_vtrigger;
+	u32 savid__eavid;
+	u32 flen__fal;
+	u32 lal__phase_reset;
+	u32 hs_int_start_stop_x;
+	u32 hs_ext_start_stop_x;
+	u32 vs_int_start_x;
+	u32 vs_int_stop_x__vs_int_start_y;
+	u32 vs_int_stop_y__vs_ext_start_x;
+	u32 vs_ext_stop_x__vs_ext_start_y;
+	u32 vs_ext_stop_y;
+	u32 avid_start_stop_x;
+	u32 avid_start_stop_y;
+	u32 fid_int_start_x__fid_int_start_y;
+	u32 fid_int_offset_y__fid_ext_start_x;
+	u32 fid_ext_start_y__fid_ext_offset_y;
+	u32 tvdetgp_int_start_stop_x;
+	u32 tvdetgp_int_start_stop_y;
+	u32 gen_ctrl;
+};
+
+/* from TRM */
+static const struct venc_config venc_config_pal_trm = {
+	.f_control				= 0,
+	.vidout_ctrl				= 1,
+	.sync_ctrl				= 0x40,
+	.llen					= 0x35F, /* 863 */
+	.flens					= 0x270, /* 624 */
+	.hfltr_ctrl				= 0,
+	.cc_carr_wss_carr			= 0x2F7225ED,
+	.c_phase				= 0,
+	.gain_u					= 0x111,
+	.gain_v					= 0x181,
+	.gain_y					= 0x140,
+	.black_level				= 0x3B,
+	.blank_level				= 0x3B,
+	.x_color				= 0x7,
+	.m_control				= 0x2,
+	.bstamp_wss_data			= 0x3F,
+	.s_carr					= 0x2A098ACB,
+	.line21					= 0,
+	.ln_sel					= 0x01290015,
+	.l21__wc_ctl				= 0x0000F603,
+	.htrigger_vtrigger			= 0,
+
+	.savid__eavid				= 0x06A70108,
+	.flen__fal				= 0x00180270,
+	.lal__phase_reset			= 0x00040135,
+	.hs_int_start_stop_x			= 0x00880358,
+	.hs_ext_start_stop_x			= 0x000F035F,
+	.vs_int_start_x				= 0x01A70000,
+	.vs_int_stop_x__vs_int_start_y		= 0x000001A7,
+	.vs_int_stop_y__vs_ext_start_x		= 0x01AF0000,
+	.vs_ext_stop_x__vs_ext_start_y		= 0x000101AF,
+	.vs_ext_stop_y				= 0x00000025,
+	.avid_start_stop_x			= 0x03530083,
+	.avid_start_stop_y			= 0x026C002E,
+	.fid_int_start_x__fid_int_start_y	= 0x0001008A,
+	.fid_int_offset_y__fid_ext_start_x	= 0x002E0138,
+	.fid_ext_start_y__fid_ext_offset_y	= 0x01380001,
+
+	.tvdetgp_int_start_stop_x		= 0x00140001,
+	.tvdetgp_int_start_stop_y		= 0x00010001,
+	.gen_ctrl				= 0x00FF0000,
+};
+
+/* from TRM */
+static const struct venc_config venc_config_ntsc_trm = {
+	.f_control				= 0,
+	.vidout_ctrl				= 1,
+	.sync_ctrl				= 0x8040,
+	.llen					= 0x359,
+	.flens					= 0x20C,
+	.hfltr_ctrl				= 0,
+	.cc_carr_wss_carr			= 0x043F2631,
+	.c_phase				= 0,
+	.gain_u					= 0x102,
+	.gain_v					= 0x16C,
+	.gain_y					= 0x12F,
+	.black_level				= 0x43,
+	.blank_level				= 0x38,
+	.x_color				= 0x7,
+	.m_control				= 0x1,
+	.bstamp_wss_data			= 0x38,
+	.s_carr					= 0x21F07C1F,
+	.line21					= 0,
+	.ln_sel					= 0x01310011,
+	.l21__wc_ctl				= 0x0000F003,
+	.htrigger_vtrigger			= 0,
+
+	.savid__eavid				= 0x069300F4,
+	.flen__fal				= 0x0016020C,
+	.lal__phase_reset			= 0x00060107,
+	.hs_int_start_stop_x			= 0x008E0350,
+	.hs_ext_start_stop_x			= 0x000F0359,
+	.vs_int_start_x				= 0x01A00000,
+	.vs_int_stop_x__vs_int_start_y		= 0x020701A0,
+	.vs_int_stop_y__vs_ext_start_x		= 0x01AC0024,
+	.vs_ext_stop_x__vs_ext_start_y		= 0x020D01AC,
+	.vs_ext_stop_y				= 0x00000006,
+	.avid_start_stop_x			= 0x03480078,
+	.avid_start_stop_y			= 0x02060024,
+	.fid_int_start_x__fid_int_start_y	= 0x0001008A,
+	.fid_int_offset_y__fid_ext_start_x	= 0x01AC0106,
+	.fid_ext_start_y__fid_ext_offset_y	= 0x01060006,
+
+	.tvdetgp_int_start_stop_x		= 0x00140001,
+	.tvdetgp_int_start_stop_y		= 0x00010001,
+	.gen_ctrl				= 0x00F90000,
+};
+
+static const struct venc_config venc_config_pal_bdghi = {
+	.f_control				= 0,
+	.vidout_ctrl				= 0,
+	.sync_ctrl				= 0,
+	.hfltr_ctrl				= 0,
+	.x_color				= 0,
+	.line21					= 0,
+	.ln_sel					= 21,
+	.htrigger_vtrigger			= 0,
+	.tvdetgp_int_start_stop_x		= 0x00140001,
+	.tvdetgp_int_start_stop_y		= 0x00010001,
+	.gen_ctrl				= 0x00FB0000,
+
+	.llen					= 864-1,
+	.flens					= 625-1,
+	.cc_carr_wss_carr			= 0x2F7625ED,
+	.c_phase				= 0xDF,
+	.gain_u					= 0x111,
+	.gain_v					= 0x181,
+	.gain_y					= 0x140,
+	.black_level				= 0x3e,
+	.blank_level				= 0x3e,
+	.m_control				= 0<<2 | 1<<1,
+	.bstamp_wss_data			= 0x42,
+	.s_carr					= 0x2a098acb,
+	.l21__wc_ctl				= 0<<13 | 0x16<<8 | 0<<0,
+	.savid__eavid				= 0x06A70108,
+	.flen__fal				= 23<<16 | 624<<0,
+	.lal__phase_reset			= 2<<17 | 310<<0,
+	.hs_int_start_stop_x			= 0x00920358,
+	.hs_ext_start_stop_x			= 0x000F035F,
+	.vs_int_start_x				= 0x1a7<<16,
+	.vs_int_stop_x__vs_int_start_y		= 0x000601A7,
+	.vs_int_stop_y__vs_ext_start_x		= 0x01AF0036,
+	.vs_ext_stop_x__vs_ext_start_y		= 0x27101af,
+	.vs_ext_stop_y				= 0x05,
+	.avid_start_stop_x			= 0x03530082,
+	.avid_start_stop_y			= 0x0270002E,
+	.fid_int_start_x__fid_int_start_y	= 0x0005008A,
+	.fid_int_offset_y__fid_ext_start_x	= 0x002E0138,
+	.fid_ext_start_y__fid_ext_offset_y	= 0x01380005,
+};
+
+const struct omap_video_timings omap_dss_pal_timings = {
+	.x_res		= 720,
+	.y_res		= 574,
+	.pixelclock	= 13500000,
+	.hsw		= 64,
+	.hfp		= 12,
+	.hbp		= 68,
+	.vsw		= 5,
+	.vfp		= 5,
+	.vbp		= 41,
+
+	.interlace	= true,
+};
+EXPORT_SYMBOL(omap_dss_pal_timings);
+
+const struct omap_video_timings omap_dss_ntsc_timings = {
+	.x_res		= 720,
+	.y_res		= 482,
+	.pixelclock	= 13500000,
+	.hsw		= 64,
+	.hfp		= 16,
+	.hbp		= 58,
+	.vsw		= 6,
+	.vfp		= 6,
+	.vbp		= 31,
+
+	.interlace	= true,
+};
+EXPORT_SYMBOL(omap_dss_ntsc_timings);
+
+static struct {
+	struct platform_device *pdev;
+	void __iomem *base;
+	struct mutex venc_lock;
+	u32 wss_data;
+	struct regulator *vdda_dac_reg;
+
+	struct clk	*tv_dac_clk;
+
+	struct omap_video_timings timings;
+	enum omap_dss_venc_type type;
+	bool invert_polarity;
+
+	struct omap_dss_device output;
+} venc;
+
+static inline void venc_write_reg(int idx, u32 val)
+{
+	__raw_writel(val, venc.base + idx);
+}
+
+static inline u32 venc_read_reg(int idx)
+{
+	u32 l = __raw_readl(venc.base + idx);
+	return l;
+}
+
+static void venc_write_config(const struct venc_config *config)
+{
+	DSSDBG("write venc conf\n");
+
+	venc_write_reg(VENC_LLEN, config->llen);
+	venc_write_reg(VENC_FLENS, config->flens);
+	venc_write_reg(VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);
+	venc_write_reg(VENC_C_PHASE, config->c_phase);
+	venc_write_reg(VENC_GAIN_U, config->gain_u);
+	venc_write_reg(VENC_GAIN_V, config->gain_v);
+	venc_write_reg(VENC_GAIN_Y, config->gain_y);
+	venc_write_reg(VENC_BLACK_LEVEL, config->black_level);
+	venc_write_reg(VENC_BLANK_LEVEL, config->blank_level);
+	venc_write_reg(VENC_M_CONTROL, config->m_control);
+	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+			venc.wss_data);
+	venc_write_reg(VENC_S_CARR, config->s_carr);
+	venc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);
+	venc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);
+	venc_write_reg(VENC_FLEN__FAL, config->flen__fal);
+	venc_write_reg(VENC_LAL__PHASE_RESET, config->lal__phase_reset);
+	venc_write_reg(VENC_HS_INT_START_STOP_X, config->hs_int_start_stop_x);
+	venc_write_reg(VENC_HS_EXT_START_STOP_X, config->hs_ext_start_stop_x);
+	venc_write_reg(VENC_VS_INT_START_X, config->vs_int_start_x);
+	venc_write_reg(VENC_VS_INT_STOP_X__VS_INT_START_Y,
+		       config->vs_int_stop_x__vs_int_start_y);
+	venc_write_reg(VENC_VS_INT_STOP_Y__VS_EXT_START_X,
+		       config->vs_int_stop_y__vs_ext_start_x);
+	venc_write_reg(VENC_VS_EXT_STOP_X__VS_EXT_START_Y,
+		       config->vs_ext_stop_x__vs_ext_start_y);
+	venc_write_reg(VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);
+	venc_write_reg(VENC_AVID_START_STOP_X, config->avid_start_stop_x);
+	venc_write_reg(VENC_AVID_START_STOP_Y, config->avid_start_stop_y);
+	venc_write_reg(VENC_FID_INT_START_X__FID_INT_START_Y,
+		       config->fid_int_start_x__fid_int_start_y);
+	venc_write_reg(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,
+		       config->fid_int_offset_y__fid_ext_start_x);
+	venc_write_reg(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,
+		       config->fid_ext_start_y__fid_ext_offset_y);
+
+	venc_write_reg(VENC_DAC_B__DAC_C,  venc_read_reg(VENC_DAC_B__DAC_C));
+	venc_write_reg(VENC_VIDOUT_CTRL, config->vidout_ctrl);
+	venc_write_reg(VENC_HFLTR_CTRL, config->hfltr_ctrl);
+	venc_write_reg(VENC_X_COLOR, config->x_color);
+	venc_write_reg(VENC_LINE21, config->line21);
+	venc_write_reg(VENC_LN_SEL, config->ln_sel);
+	venc_write_reg(VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);
+	venc_write_reg(VENC_TVDETGP_INT_START_STOP_X,
+		       config->tvdetgp_int_start_stop_x);
+	venc_write_reg(VENC_TVDETGP_INT_START_STOP_Y,
+		       config->tvdetgp_int_start_stop_y);
+	venc_write_reg(VENC_GEN_CTRL, config->gen_ctrl);
+	venc_write_reg(VENC_F_CONTROL, config->f_control);
+	venc_write_reg(VENC_SYNC_CTRL, config->sync_ctrl);
+}
+
+static void venc_reset(void)
+{
+	int t = 1000;
+
+	venc_write_reg(VENC_F_CONTROL, 1<<8);
+	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
+		if (--t == 0) {
+			DSSERR("Failed to reset venc\n");
+			return;
+		}
+	}
+
+#ifdef CONFIG_OMAP2_DSS_SLEEP_AFTER_VENC_RESET
+	/* the magical sleep that makes things work */
+	/* XXX more info? What bug this circumvents? */
+	msleep(20);
+#endif
+}
+
+static int venc_runtime_get(void)
+{
+	int r;
+
+	DSSDBG("venc_runtime_get\n");
+
+	r = pm_runtime_get_sync(&venc.pdev->dev);
+	WARN_ON(r < 0);
+	return r < 0 ? r : 0;
+}
+
+static void venc_runtime_put(void)
+{
+	int r;
+
+	DSSDBG("venc_runtime_put\n");
+
+	r = pm_runtime_put_sync(&venc.pdev->dev);
+	WARN_ON(r < 0 && r != -ENOSYS);
+}
+
+static const struct venc_config *venc_timings_to_config(
+		struct omap_video_timings *timings)
+{
+	if (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)
+		return &venc_config_pal_trm;
+
+	if (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)
+		return &venc_config_ntsc_trm;
+
+	BUG();
+	return NULL;
+}
+
+static int venc_power_on(struct omap_dss_device *dssdev)
+{
+	struct omap_overlay_manager *mgr = venc.output.manager;
+	u32 l;
+	int r;
+
+	r = venc_runtime_get();
+	if (r)
+		goto err0;
+
+	venc_reset();
+	venc_write_config(venc_timings_to_config(&venc.timings));
+
+	dss_set_venc_output(venc.type);
+	dss_set_dac_pwrdn_bgz(1);
+
+	l = 0;
+
+	if (venc.type == OMAP_DSS_VENC_TYPE_COMPOSITE)
+		l |= 1 << 1;
+	else /* S-Video */
+		l |= (1 << 0) | (1 << 2);
+
+	if (venc.invert_polarity == false)
+		l |= 1 << 3;
+
+	venc_write_reg(VENC_OUTPUT_CONTROL, l);
+
+	dss_mgr_set_timings(mgr, &venc.timings);
+
+	r = regulator_enable(venc.vdda_dac_reg);
+	if (r)
+		goto err1;
+
+	r = dss_mgr_enable(mgr);
+	if (r)
+		goto err2;
+
+	return 0;
+
+err2:
+	regulator_disable(venc.vdda_dac_reg);
+err1:
+	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(0);
+
+	venc_runtime_put();
+err0:
+	return r;
+}
+
+static void venc_power_off(struct omap_dss_device *dssdev)
+{
+	struct omap_overlay_manager *mgr = venc.output.manager;
+
+	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(0);
+
+	dss_mgr_disable(mgr);
+
+	regulator_disable(venc.vdda_dac_reg);
+
+	venc_runtime_put();
+}
+
+static int venc_display_enable(struct omap_dss_device *dssdev)
+{
+	struct omap_dss_device *out = &venc.output;
+	int r;
+
+	DSSDBG("venc_display_enable\n");
+
+	mutex_lock(&venc.venc_lock);
+
+	if (out->manager == NULL) {
+		DSSERR("Failed to enable display: no output/manager\n");
+		r = -ENODEV;
+		goto err0;
+	}
+
+	r = venc_power_on(dssdev);
+	if (r)
+		goto err0;
+
+	venc.wss_data = 0;
+
+	mutex_unlock(&venc.venc_lock);
+
+	return 0;
+err0:
+	mutex_unlock(&venc.venc_lock);
+	return r;
+}
+
+static void venc_display_disable(struct omap_dss_device *dssdev)
+{
+	DSSDBG("venc_display_disable\n");
+
+	mutex_lock(&venc.venc_lock);
+
+	venc_power_off(dssdev);
+
+	mutex_unlock(&venc.venc_lock);
+}
+
+static void venc_set_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	DSSDBG("venc_set_timings\n");
+
+	mutex_lock(&venc.venc_lock);
+
+	/* Reset WSS data when the TV standard changes. */
+	if (memcmp(&venc.timings, timings, sizeof(*timings)))
+		venc.wss_data = 0;
+
+	venc.timings = *timings;
+
+	dispc_set_tv_pclk(13500000);
+
+	mutex_unlock(&venc.venc_lock);
+}
+
+static int venc_check_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	DSSDBG("venc_check_timings\n");
+
+	if (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)
+		return 0;
+
+	if (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)
+		return 0;
+
+	return -EINVAL;
+}
+
+static void venc_get_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	mutex_lock(&venc.venc_lock);
+
+	*timings = venc.timings;
+
+	mutex_unlock(&venc.venc_lock);
+}
+
+static u32 venc_get_wss(struct omap_dss_device *dssdev)
+{
+	/* Invert due to VENC_L21_WC_CTL:INV=1 */
+	return (venc.wss_data >> 8) ^ 0xfffff;
+}
+
+static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
+{
+	const struct venc_config *config;
+	int r;
+
+	DSSDBG("venc_set_wss\n");
+
+	mutex_lock(&venc.venc_lock);
+
+	config = venc_timings_to_config(&venc.timings);
+
+	/* Invert due to VENC_L21_WC_CTL:INV=1 */
+	venc.wss_data = (wss ^ 0xfffff) << 8;
+
+	r = venc_runtime_get();
+	if (r)
+		goto err;
+
+	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+			venc.wss_data);
+
+	venc_runtime_put();
+
+err:
+	mutex_unlock(&venc.venc_lock);
+
+	return r;
+}
+
+static void venc_set_type(struct omap_dss_device *dssdev,
+		enum omap_dss_venc_type type)
+{
+	mutex_lock(&venc.venc_lock);
+
+	venc.type = type;
+
+	mutex_unlock(&venc.venc_lock);
+}
+
+static void venc_invert_vid_out_polarity(struct omap_dss_device *dssdev,
+		bool invert_polarity)
+{
+	mutex_lock(&venc.venc_lock);
+
+	venc.invert_polarity = invert_polarity;
+
+	mutex_unlock(&venc.venc_lock);
+}
+
+static int venc_init_regulator(void)
+{
+	struct regulator *vdda_dac;
+
+	if (venc.vdda_dac_reg != NULL)
+		return 0;
+
+	if (venc.pdev->dev.of_node)
+		vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");
+	else
+		vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda_dac");
+
+	if (IS_ERR(vdda_dac)) {
+		if (PTR_ERR(vdda_dac) != -EPROBE_DEFER)
+			DSSERR("can't get VDDA_DAC regulator\n");
+		return PTR_ERR(vdda_dac);
+	}
+
+	venc.vdda_dac_reg = vdda_dac;
+
+	return 0;
+}
+
+static void venc_dump_regs(struct seq_file *s)
+{
+#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(r))
+
+	if (venc_runtime_get())
+		return;
+
+	DUMPREG(VENC_F_CONTROL);
+	DUMPREG(VENC_VIDOUT_CTRL);
+	DUMPREG(VENC_SYNC_CTRL);
+	DUMPREG(VENC_LLEN);
+	DUMPREG(VENC_FLENS);
+	DUMPREG(VENC_HFLTR_CTRL);
+	DUMPREG(VENC_CC_CARR_WSS_CARR);
+	DUMPREG(VENC_C_PHASE);
+	DUMPREG(VENC_GAIN_U);
+	DUMPREG(VENC_GAIN_V);
+	DUMPREG(VENC_GAIN_Y);
+	DUMPREG(VENC_BLACK_LEVEL);
+	DUMPREG(VENC_BLANK_LEVEL);
+	DUMPREG(VENC_X_COLOR);
+	DUMPREG(VENC_M_CONTROL);
+	DUMPREG(VENC_BSTAMP_WSS_DATA);
+	DUMPREG(VENC_S_CARR);
+	DUMPREG(VENC_LINE21);
+	DUMPREG(VENC_LN_SEL);
+	DUMPREG(VENC_L21__WC_CTL);
+	DUMPREG(VENC_HTRIGGER_VTRIGGER);
+	DUMPREG(VENC_SAVID__EAVID);
+	DUMPREG(VENC_FLEN__FAL);
+	DUMPREG(VENC_LAL__PHASE_RESET);
+	DUMPREG(VENC_HS_INT_START_STOP_X);
+	DUMPREG(VENC_HS_EXT_START_STOP_X);
+	DUMPREG(VENC_VS_INT_START_X);
+	DUMPREG(VENC_VS_INT_STOP_X__VS_INT_START_Y);
+	DUMPREG(VENC_VS_INT_STOP_Y__VS_EXT_START_X);
+	DUMPREG(VENC_VS_EXT_STOP_X__VS_EXT_START_Y);
+	DUMPREG(VENC_VS_EXT_STOP_Y);
+	DUMPREG(VENC_AVID_START_STOP_X);
+	DUMPREG(VENC_AVID_START_STOP_Y);
+	DUMPREG(VENC_FID_INT_START_X__FID_INT_START_Y);
+	DUMPREG(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);
+	DUMPREG(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);
+	DUMPREG(VENC_TVDETGP_INT_START_STOP_X);
+	DUMPREG(VENC_TVDETGP_INT_START_STOP_Y);
+	DUMPREG(VENC_GEN_CTRL);
+	DUMPREG(VENC_OUTPUT_CONTROL);
+	DUMPREG(VENC_OUTPUT_TEST);
+
+	venc_runtime_put();
+
+#undef DUMPREG
+}
+
+static int venc_get_clocks(struct platform_device *pdev)
+{
+	struct clk *clk;
+
+	if (dss_has_feature(FEAT_VENC_REQUIRES_TV_DAC_CLK)) {
+		clk = devm_clk_get(&pdev->dev, "tv_dac_clk");
+		if (IS_ERR(clk)) {
+			DSSERR("can't get tv_dac_clk\n");
+			return PTR_ERR(clk);
+		}
+	} else {
+		clk = NULL;
+	}
+
+	venc.tv_dac_clk = clk;
+
+	return 0;
+}
+
+static int venc_connect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	struct omap_overlay_manager *mgr;
+	int r;
+
+	r = venc_init_regulator();
+	if (r)
+		return r;
+
+	mgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);
+	if (!mgr)
+		return -ENODEV;
+
+	r = dss_mgr_connect(mgr, dssdev);
+	if (r)
+		return r;
+
+	r = omapdss_output_set_device(dssdev, dst);
+	if (r) {
+		DSSERR("failed to connect output to new device: %s\n",
+				dst->name);
+		dss_mgr_disconnect(mgr, dssdev);
+		return r;
+	}
+
+	return 0;
+}
+
+static void venc_disconnect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	WARN_ON(dst != dssdev->dst);
+
+	if (dst != dssdev->dst)
+		return;
+
+	omapdss_output_unset_device(dssdev);
+
+	if (dssdev->manager)
+		dss_mgr_disconnect(dssdev->manager, dssdev);
+}
+
+static const struct omapdss_atv_ops venc_ops = {
+	.connect = venc_connect,
+	.disconnect = venc_disconnect,
+
+	.enable = venc_display_enable,
+	.disable = venc_display_disable,
+
+	.check_timings = venc_check_timings,
+	.set_timings = venc_set_timings,
+	.get_timings = venc_get_timings,
+
+	.set_type = venc_set_type,
+	.invert_vid_out_polarity = venc_invert_vid_out_polarity,
+
+	.set_wss = venc_set_wss,
+	.get_wss = venc_get_wss,
+};
+
+static void venc_init_output(struct platform_device *pdev)
+{
+	struct omap_dss_device *out = &venc.output;
+
+	out->dev = &pdev->dev;
+	out->id = OMAP_DSS_OUTPUT_VENC;
+	out->output_type = OMAP_DISPLAY_TYPE_VENC;
+	out->name = "venc.0";
+	out->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;
+	out->ops.atv = &venc_ops;
+	out->owner = THIS_MODULE;
+
+	omapdss_register_output(out);
+}
+
+static void venc_uninit_output(struct platform_device *pdev)
+{
+	struct omap_dss_device *out = &venc.output;
+
+	omapdss_unregister_output(out);
+}
+
+static int venc_probe_of(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *ep;
+	u32 channels;
+	int r;
+
+	ep = omapdss_of_get_first_endpoint(node);
+	if (!ep)
+		return 0;
+
+	venc.invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");
+
+	r = of_property_read_u32(ep, "ti,channels", &channels);
+	if (r) {
+		dev_err(&pdev->dev,
+			"failed to read property 'ti,channels': %d\n", r);
+		goto err;
+	}
+
+	switch (channels) {
+	case 1:
+		venc.type = OMAP_DSS_VENC_TYPE_COMPOSITE;
+		break;
+	case 2:
+		venc.type = OMAP_DSS_VENC_TYPE_SVIDEO;
+		break;
+	default:
+		dev_err(&pdev->dev, "bad channel propert '%d'\n", channels);
+		r = -EINVAL;
+		goto err;
+	}
+
+	of_node_put(ep);
+
+	return 0;
+err:
+	of_node_put(ep);
+
+	return 0;
+}
+
+/* VENC HW IP initialisation */
+static int venc_bind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	u8 rev_id;
+	struct resource *venc_mem;
+	int r;
+
+	venc.pdev = pdev;
+
+	mutex_init(&venc.venc_lock);
+
+	venc.wss_data = 0;
+
+	venc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);
+	if (!venc_mem) {
+		DSSERR("can't get IORESOURCE_MEM VENC\n");
+		return -EINVAL;
+	}
+
+	venc.base = devm_ioremap(&pdev->dev, venc_mem->start,
+				 resource_size(venc_mem));
+	if (!venc.base) {
+		DSSERR("can't ioremap VENC\n");
+		return -ENOMEM;
+	}
+
+	r = venc_get_clocks(pdev);
+	if (r)
+		return r;
+
+	pm_runtime_enable(&pdev->dev);
+
+	r = venc_runtime_get();
+	if (r)
+		goto err_runtime_get;
+
+	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
+	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
+
+	venc_runtime_put();
+
+	if (pdev->dev.of_node) {
+		r = venc_probe_of(pdev);
+		if (r) {
+			DSSERR("Invalid DT data\n");
+			goto err_probe_of;
+		}
+	}
+
+	dss_debugfs_create_file("venc", venc_dump_regs);
+
+	venc_init_output(pdev);
+
+	return 0;
+
+err_probe_of:
+err_runtime_get:
+	pm_runtime_disable(&pdev->dev);
+	return r;
+}
+
+static void venc_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	venc_uninit_output(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+}
+
+static const struct component_ops venc_component_ops = {
+	.bind	= venc_bind,
+	.unbind	= venc_unbind,
+};
+
+static int venc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &venc_component_ops);
+}
+
+static int venc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &venc_component_ops);
+	return 0;
+}
+
+static int venc_runtime_suspend(struct device *dev)
+{
+	if (venc.tv_dac_clk)
+		clk_disable_unprepare(venc.tv_dac_clk);
+
+	dispc_runtime_put();
+
+	return 0;
+}
+
+static int venc_runtime_resume(struct device *dev)
+{
+	int r;
+
+	r = dispc_runtime_get();
+	if (r < 0)
+		return r;
+
+	if (venc.tv_dac_clk)
+		clk_prepare_enable(venc.tv_dac_clk);
+
+	return 0;
+}
+
+static const struct dev_pm_ops venc_pm_ops = {
+	.runtime_suspend = venc_runtime_suspend,
+	.runtime_resume = venc_runtime_resume,
+};
+
+static const struct of_device_id venc_of_match[] = {
+	{ .compatible = "ti,omap2-venc", },
+	{ .compatible = "ti,omap3-venc", },
+	{ .compatible = "ti,omap4-venc", },
+	{},
+};
+
+static struct platform_driver omap_venchw_driver = {
+	.probe		= venc_probe,
+	.remove		= venc_remove,
+	.driver         = {
+		.name   = "omapdss_venc",
+		.pm	= &venc_pm_ops,
+		.of_match_table = venc_of_match,
+		.suppress_bind_attrs = true,
+	},
+};
+
+int __init venc_init_platform_driver(void)
+{
+	return platform_driver_register(&omap_venchw_driver);
+}
+
+void venc_uninit_platform_driver(void)
+{
+	platform_driver_unregister(&omap_venchw_driver);
+}
