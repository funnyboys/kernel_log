commit 9cd39de4db54062ad60f8004362c293c0c950456
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Apr 17 14:41:51 2020 +0300

    drm/omap: change default signal polarities and drives
    
    If the given videomode does not specify DISPLAY_FLAG_* for the specific
    signal property, the driver used a default value. These defaults were
    never thought through, as the expectation was that all the DISPLAY_FLAGS
    are always set explicitly.
    
    With DRM bridge and panel drivers this is not the case, and while that
    issue should be resolved in the future, it's still good to have sane
    signal defaults.
    
    This patch changes the defaults to what the hardware has as reset
    defaults. Also, based on my experience, I think they make sense and are
    more likely correct than the defaults without this patch.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200417114151.25843-1-tomi.valkeinen@ti.com
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index dbb90f2d2ccd..6639ee9b05d3 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3137,33 +3137,12 @@ static void _dispc_mgr_set_lcd_timings(struct dispc_device *dispc,
 	dispc_write_reg(dispc, DISPC_TIMING_H(channel), timing_h);
 	dispc_write_reg(dispc, DISPC_TIMING_V(channel), timing_v);
 
-	if (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		vs = false;
-	else
-		vs = true;
-
-	if (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		hs = false;
-	else
-		hs = true;
-
-	if (vm->flags & DISPLAY_FLAGS_DE_HIGH)
-		de = false;
-	else
-		de = true;
-
-	if (vm->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
-		ipc = false;
-	else
-		ipc = true;
-
-	/* always use the 'rf' setting */
-	onoff = true;
-
-	if (vm->flags & DISPLAY_FLAGS_SYNC_POSEDGE)
-		rf = true;
-	else
-		rf = false;
+	vs = !!(vm->flags & DISPLAY_FLAGS_VSYNC_LOW);
+	hs = !!(vm->flags & DISPLAY_FLAGS_HSYNC_LOW);
+	de = !!(vm->flags & DISPLAY_FLAGS_DE_LOW);
+	ipc = !!(vm->flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE);
+	onoff = true; /* always use the 'rf' setting */
+	rf = !!(vm->flags & DISPLAY_FLAGS_SYNC_POSEDGE);
 
 	l = FLD_VAL(onoff, 17, 17) |
 		FLD_VAL(rf, 16, 16) |

commit 8b185cf7ebaa1f390ba25368ce9ae387eb1a8b63
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Thu Jan 2 12:55:15 2020 +0300

    drm/omapdrm: use BUG_ON macro for error debugging.
    
    Since the if statement only checks for the value of the `id` variable,
    it can be replaced by the more concise BUG_ON() macro for error
    reporting.
    Issue found using coccinelle.
    
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200102095515.7106-1-wambui.karugax@gmail.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 413dbdd1771e..dbb90f2d2ccd 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -393,8 +393,7 @@ static void dispc_get_reg_field(struct dispc_device *dispc,
 				enum dispc_feat_reg_field id,
 				u8 *start, u8 *end)
 {
-	if (id >= dispc->feat->num_reg_fields)
-		BUG();
+	BUG_ON(id >= dispc->feat->num_reg_fields);
 
 	*start = dispc->feat->reg_fields[id].start;
 	*end = dispc->feat->reg_fields[id].end;

commit f5b1fae153d9d9b719cc390eb3fb490996a09d2d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Sep 30 13:38:37 2019 +0300

    drm/omap: fix missing scaler pixel fmt limitations
    
    OMAP2 and OMAP3/AM4 have limitations with the scaler:
    - OMAP2 can only scale XRGB8888
    - OMAP3/AM4 can only scale XRGB8888, RGB565, YUYV and UYVY
    
    The driver doesn't check these limitations, which leads to sync-lost
    floods.
    
    This patch adds a check for the pixel formats when scaling.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190930103840.18970-5-tomi.valkeinen@ti.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 29e58cf19cc5..413dbdd1771e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -114,6 +114,7 @@ struct dispc_features {
 	const unsigned int num_reg_fields;
 	const enum omap_overlay_caps *overlay_caps;
 	const u32 **supported_color_modes;
+	const u32 *supported_scaler_color_modes;
 	unsigned int num_mgrs;
 	unsigned int num_ovls;
 	unsigned int buffer_size_unit;
@@ -2499,6 +2500,19 @@ static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
 	if (width == out_width && height == out_height)
 		return 0;
 
+	if (dispc->feat->supported_scaler_color_modes) {
+		const u32 *modes = dispc->feat->supported_scaler_color_modes;
+		unsigned int i;
+
+		for (i = 0; modes[i]; ++i) {
+			if (modes[i] == fourcc)
+				break;
+		}
+
+		if (modes[i] == 0)
+			return -EINVAL;
+	}
+
 	if (plane == OMAP_DSS_WB) {
 		switch (fourcc) {
 		case DRM_FORMAT_NV12:
@@ -4214,6 +4228,12 @@ static const u32 *omap4_dispc_supported_color_modes[] = {
 	DRM_FORMAT_RGBX8888),
 };
 
+static const u32 omap3_dispc_supported_scaler_color_modes[] = {
+	DRM_FORMAT_XRGB8888, DRM_FORMAT_RGB565, DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY,
+	0,
+};
+
 static const struct dispc_features omap24xx_dispc_feats = {
 	.sw_start		=	5,
 	.fp_start		=	15,
@@ -4242,6 +4262,7 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.num_reg_fields		=	ARRAY_SIZE(omap2_dispc_reg_fields),
 	.overlay_caps		=	omap2_dispc_overlay_caps,
 	.supported_color_modes	=	omap2_dispc_supported_color_modes,
+	.supported_scaler_color_modes = COLOR_ARRAY(DRM_FORMAT_XRGB8888),
 	.num_mgrs		=	2,
 	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
@@ -4276,6 +4297,7 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,
 	.num_mgrs		=	2,
 	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
@@ -4310,6 +4332,7 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,
 	.num_mgrs		=	2,
 	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
@@ -4344,6 +4367,7 @@ static const struct dispc_features omap36xx_dispc_feats = {
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3630_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,
 	.num_mgrs		=	2,
 	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
@@ -4378,6 +4402,7 @@ static const struct dispc_features am43xx_dispc_feats = {
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,
 	.num_mgrs		=	1,
 	.num_ovls		=	3,
 	.buffer_size_unit	=	1,

commit 6e366c28e6b146d4906e616a500ad1e6199cd3ee
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Sep 30 13:38:35 2019 +0300

    drm/omap: avoid copy in mgr_fld_read/write
    
    Avoid unnecessary copy in mgr_fld_read/write by taking a pointer to the
    reg_resc and using that.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190930103840.18970-3-tomi.valkeinen@ti.com
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 4f23ff81d147..29e58cf19cc5 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -365,17 +365,17 @@ static inline u32 dispc_read_reg(struct dispc_device *dispc, u16 idx)
 static u32 mgr_fld_read(struct dispc_device *dispc, enum omap_channel channel,
 			enum mgr_reg_fields regfld)
 {
-	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
+	const struct dispc_reg_field *rfld = &mgr_desc[channel].reg_desc[regfld];
 
-	return REG_GET(dispc, rfld.reg, rfld.high, rfld.low);
+	return REG_GET(dispc, rfld->reg, rfld->high, rfld->low);
 }
 
 static void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,
 			  enum mgr_reg_fields regfld, int val)
 {
-	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
+	const struct dispc_reg_field *rfld = &mgr_desc[channel].reg_desc[regfld];
 
-	REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
+	REG_FLD_MOD(dispc, rfld->reg, val, rfld->high, rfld->low);
 }
 
 static int dispc_get_num_ovls(struct dispc_device *dispc)

commit a9c4fbd544f967afbc19245e1e40800ca83dfc45
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Sep 30 13:38:34 2019 +0300

    drm/omap: drop unneeded locking from mgr_fld_write()
    
    Commit d49cd15550d9d4495f6187425318c245d58cb63f ("OMAPDSS: DISPC: lock
    access to DISPC_CONTROL & DISPC_CONFIG") added locking to
    mgr_fld_write(). This was needed in omapfb times due to lack of good
    locking, especially in the case of both V4L2 and fbdev layers using the
    DSS driver.
    
    This is not needed for omapdrm, so we can remove the locking.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190930103840.18970-2-tomi.valkeinen@ti.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ed0ccbeed70f..4f23ff81d147 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -184,9 +184,6 @@ struct dispc_device {
 
 	struct regmap *syscon_pol;
 	u32 syscon_pol_offset;
-
-	/* DISPC_CONTROL & DISPC_CONFIG lock*/
-	spinlock_t control_lock;
 };
 
 enum omap_color_component {
@@ -377,16 +374,8 @@ static void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,
 			  enum mgr_reg_fields regfld, int val)
 {
 	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
-	const bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;
-	unsigned long flags;
 
-	if (need_lock) {
-		spin_lock_irqsave(&dispc->control_lock, flags);
-		REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
-		spin_unlock_irqrestore(&dispc->control_lock, flags);
-	} else {
-		REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
-	}
+	REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
 }
 
 static int dispc_get_num_ovls(struct dispc_device *dispc)
@@ -4768,8 +4757,6 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	platform_set_drvdata(pdev, dispc);
 	dispc->dss = dss;
 
-	spin_lock_init(&dispc->control_lock);
-
 	/*
 	 * The OMAP3-based models can't be told apart using the compatible
 	 * string, use SoC device matching.

commit 212836a9929f0c91214a8a1879e6e41be0e26a6f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jul 26 08:58:36 2019 +0200

    dma-mapping: remove dma_{alloc,free,mmap}_writecombine
    
    We can already use DMA_ATTR_WRITE_COMBINE or the _wc prefixed version,
    so remove the third way of doing things.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 785c5546067a..ed0ccbeed70f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4609,11 +4609,10 @@ static int dispc_errata_i734_wa_init(struct dispc_device *dispc)
 	i734_buf.size = i734.ovli.width * i734.ovli.height *
 		color_mode_to_bpp(i734.ovli.fourcc) / 8;
 
-	i734_buf.vaddr = dma_alloc_writecombine(&dispc->pdev->dev,
-						i734_buf.size, &i734_buf.paddr,
-						GFP_KERNEL);
+	i734_buf.vaddr = dma_alloc_wc(&dispc->pdev->dev, i734_buf.size,
+				      &i734_buf.paddr, GFP_KERNEL);
 	if (!i734_buf.vaddr) {
-		dev_err(&dispc->pdev->dev, "%s: dma_alloc_writecombine failed\n",
+		dev_err(&dispc->pdev->dev, "%s: dma_alloc_wc failed\n",
 			__func__);
 		return -ENOMEM;
 	}
@@ -4626,8 +4625,8 @@ static void dispc_errata_i734_wa_fini(struct dispc_device *dispc)
 	if (!dispc->feat->has_gamma_i734_bug)
 		return;
 
-	dma_free_writecombine(&dispc->pdev->dev, i734_buf.size, i734_buf.vaddr,
-			      i734_buf.paddr);
+	dma_free_wc(&dispc->pdev->dev, i734_buf.size, i734_buf.vaddr,
+		    i734_buf.paddr);
 }
 
 static void dispc_errata_i734_wa(struct dispc_device *dispc)

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ba82d916719c..785c5546067a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1,21 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * Some code and ideas taken from drivers/video/omap/ driver
  * by Imre Deak.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define DSS_SUBSYS_NAME "DISPC"

commit e58febe1d99c6557bc7a4397426e9d470cc7f430
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue Jul 17 18:13:45 2018 +0100

    drm/omap: Substitute format_is_yuv() with format->is_yuv
    
    drm_format_info table has a field 'is_yuv' to denote if the format
    is yuv or not. The driver is expected to use this instead of
    having a function for the same purpose.
    
    Signed-off-by: Ayan Kumar halder <ayan.halder@arm.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7c23f23137e9..ba82d916719c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1140,18 +1140,6 @@ static void dispc_ovl_set_color_mode(struct dispc_device *dispc,
 	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
-static bool format_is_yuv(u32 fourcc)
-{
-	switch (fourcc) {
-	case DRM_FORMAT_YUYV:
-	case DRM_FORMAT_UYVY:
-	case DRM_FORMAT_NV12:
-		return true;
-	default:
-		return false;
-	}
-}
-
 static void dispc_ovl_configure_burst_type(struct dispc_device *dispc,
 					   enum omap_plane_id plane,
 					   enum omap_dss_rotation_type rotation)
@@ -1910,11 +1898,14 @@ static void dispc_ovl_set_scaling_uv(struct dispc_device *dispc,
 	int scale_x = out_width != orig_width;
 	int scale_y = out_height != orig_height;
 	bool chroma_upscale = plane != OMAP_DSS_WB;
+	const struct drm_format_info *info;
+
+	info = drm_format_info(fourcc);
 
 	if (!dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE))
 		return;
 
-	if (!format_is_yuv(fourcc)) {
+	if (!info->is_yuv) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
 			REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),
@@ -2632,6 +2623,9 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	bool ilace = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);
 	unsigned long pclk = dispc_plane_pclk_rate(dispc, plane);
 	unsigned long lclk = dispc_plane_lclk_rate(dispc, plane);
+	const struct drm_format_info *info;
+
+	info = drm_format_info(fourcc);
 
 	/* when setting up WB, dispc_plane_pclk_rate() returns 0 */
 	if (plane == OMAP_DSS_WB)
@@ -2640,7 +2634,7 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 
-	if (format_is_yuv(fourcc) && (in_width & 1)) {
+	if (info->is_yuv && (in_width & 1)) {
 		DSSERR("input width %d is not even for YUV format\n", in_width);
 		return -EINVAL;
 	}
@@ -2680,7 +2674,7 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
 			x_predecim, y_predecim, in_width, in_height);
 
-	if (format_is_yuv(fourcc) && (in_width & 1)) {
+	if (info->is_yuv && (in_width & 1)) {
 		DSSDBG("predecimated input width is not even for YUV format\n");
 		DSSDBG("adjusting input width %d -> %d\n",
 			in_width, in_width & ~1);
@@ -2688,7 +2682,7 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 		in_width &= ~1;
 	}
 
-	if (format_is_yuv(fourcc))
+	if (info->is_yuv)
 		cconv = 1;
 
 	if (ilace && !fieldmode) {

commit 3a75010cecc93d299aec56caae8516ea40287a98
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Sep 11 12:00:53 2018 +0000

    drm/omap: remove set but not used variable 'frame_height'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/omapdrm/dss/dispc.c: In function 'dispc_ovl_setup_common':
    drivers/gpu/drm/omapdrm/dss/dispc.c:2627:19: warning:
     variable 'frame_height' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index e61a9592a650..7c23f23137e9 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2624,7 +2624,7 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	unsigned int offset0, offset1;
 	s32 row_inc;
 	s32 pix_inc;
-	u16 frame_width, frame_height;
+	u16 frame_width;
 	unsigned int field_offset = 0;
 	u16 in_height = height;
 	u16 in_width = width;
@@ -2714,13 +2714,10 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	row_inc = 0;
 	pix_inc = 0;
 
-	if (plane == OMAP_DSS_WB) {
+	if (plane == OMAP_DSS_WB)
 		frame_width = out_width;
-		frame_height = out_height;
-	} else {
+	else
 		frame_width = in_width;
-		frame_height = height;
-	}
 
 	calc_offset(screen_width, frame_width,
 			fourcc, fieldmode, field_offset,

commit 7c27fa57ef31debf62c5529725d4fa096b336a99
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 5 01:57:09 2018 +0300

    drm/omap: Call dispc timings check operation directly
    
    Instead of call the dispc timings check function dispc_mgr_timings_ok()
    from the internal encoders .check_timings() operation, expose it through
    the dispc ops (after renaming it to check_timings) and call it directly
    from omapdrm. This allows removal of now empty omap_dss_device
    .check_timings() operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index da95dbfdf790..e61a9592a650 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3113,28 +3113,29 @@ static bool _dispc_mgr_pclk_ok(struct dispc_device *dispc,
 		return pclk <= dispc->feat->max_tv_pclk;
 }
 
-bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
-			  const struct videomode *vm)
+static int dispc_mgr_check_timings(struct dispc_device *dispc,
+				   enum omap_channel channel,
+				   const struct videomode *vm)
 {
 	if (!_dispc_mgr_size_ok(dispc, vm->hactive, vm->vactive))
-		return false;
+		return MODE_BAD;
 
 	if (!_dispc_mgr_pclk_ok(dispc, channel, vm->pixelclock))
-		return false;
+		return MODE_BAD;
 
 	if (dss_mgr_is_lcd(channel)) {
 		/* TODO: OMAP4+ supports interlace for LCD outputs */
 		if (vm->flags & DISPLAY_FLAGS_INTERLACED)
-			return false;
+			return MODE_BAD;
 
 		if (!_dispc_lcd_timings_ok(dispc, vm->hsync_len,
 				vm->hfront_porch, vm->hback_porch,
 				vm->vsync_len, vm->vfront_porch,
 				vm->vback_porch))
-			return false;
+			return MODE_BAD;
 	}
 
-	return true;
+	return MODE_OK;
 }
 
 static void _dispc_mgr_set_lcd_timings(struct dispc_device *dispc,
@@ -3236,7 +3237,7 @@ static void dispc_mgr_set_timings(struct dispc_device *dispc,
 
 	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
-	if (!dispc_mgr_timings_ok(dispc, channel, &t)) {
+	if (dispc_mgr_check_timings(dispc, channel, &t)) {
 		BUG();
 		return;
 	}
@@ -4733,6 +4734,7 @@ static const struct dispc_ops dispc_ops = {
 	.mgr_go_busy = dispc_mgr_go_busy,
 	.mgr_go = dispc_mgr_go,
 	.mgr_set_lcd_config = dispc_mgr_set_lcd_config,
+	.mgr_check_timings = dispc_mgr_check_timings,
 	.mgr_set_timings = dispc_mgr_set_timings,
 	.mgr_setup = dispc_mgr_setup,
 	.mgr_gamma_size = dispc_mgr_gamma_size,

commit d25a7d67465faa28062323d46a1d755d3ae6abc6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:22:10 2018 +0200

    drm/omap: Remove supported output check in CRTC connect handler
    
    The CRTC connect handler checks whether the DSS output supports the
    DISPC channel assigned to it. As the channel is assigned to the output
    by the output driver a failure there could only result from a driver
    bug. All the output drivers have been verified and they are always
    assigned a DISPC channel that is supported on the SoC they run on. The
    check can thus be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 84f274c4a4cb..da95dbfdf790 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2904,13 +2904,6 @@ static int dispc_ovl_enable(struct dispc_device *dispc,
 	return 0;
 }
 
-static enum omap_dss_output_id
-dispc_mgr_get_supported_outputs(struct dispc_device *dispc,
-				enum omap_channel channel)
-{
-	return dss_get_supported_outputs(dispc->dss, channel);
-}
-
 static void dispc_lcd_enable_signal_polarity(struct dispc_device *dispc,
 					     bool act_high)
 {
@@ -4742,7 +4735,6 @@ static const struct dispc_ops dispc_ops = {
 	.mgr_set_lcd_config = dispc_mgr_set_lcd_config,
 	.mgr_set_timings = dispc_mgr_set_timings,
 	.mgr_setup = dispc_mgr_setup,
-	.mgr_get_supported_outputs = dispc_mgr_get_supported_outputs,
 	.mgr_gamma_size = dispc_mgr_gamma_size,
 	.mgr_set_gamma = dispc_mgr_set_gamma,
 

commit 6505d75cd23291565ca668dd1e66f4e38b5c8f38
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 24 14:46:19 2018 +0300

    drm/omap: fix email address
    
    Change tomi.valkeinen@nokia.com to tomi.valkeinen@ti.com.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7f3ac6b13b56..84f274c4a4cb 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2009 Nokia Corporation
- * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * Some code and ideas taken from drivers/video/omap/ driver
  * by Imre Deak.

commit 7f26eee572167926806b6fcb703bb5f8e452c398
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 2 12:11:58 2018 +0300

    drm/omap: add missing linefeeds to prints
    
    A bunch of debug and error prints are missing linefeeds. Add those.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180502091159.7071-4-tomi.valkeinen@ti.com
    Reviewed-by: Benoit Parrot <bparrot@ti.com>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index b8fdb63e5bb3..7f3ac6b13b56 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2348,7 +2348,7 @@ static int dispc_ovl_calc_scaling_24xx(struct dispc_device *dispc,
 	}
 
 	if (in_width > maxsinglelinewidth) {
-		DSSERR("Cannot scale max input width exceeded");
+		DSSERR("Cannot scale max input width exceeded\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -2430,13 +2430,13 @@ static int dispc_ovl_calc_scaling_34xx(struct dispc_device *dispc,
 	}
 
 	if (in_width > (maxsinglelinewidth * 2)) {
-		DSSERR("Cannot setup scaling");
-		DSSERR("width exceeds maximum width possible");
+		DSSERR("Cannot setup scaling\n");
+		DSSERR("width exceeds maximum width possible\n");
 		return -EINVAL;
 	}
 
 	if (in_width > maxsinglelinewidth && *five_taps) {
-		DSSERR("cannot setup scaling with five taps");
+		DSSERR("cannot setup scaling with five taps\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -2478,7 +2478,7 @@ static int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,
 			in_width > maxsinglelinewidth && ++*decim_x);
 
 	if (in_width > maxsinglelinewidth) {
-		DSSERR("Cannot scale width exceeds max line width");
+		DSSERR("Cannot scale width exceeds max line width\n");
 		return -EINVAL;
 	}
 
@@ -2496,7 +2496,7 @@ static int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,
 		 * bandwidth. Despite what theory says this appears to
 		 * be true also for 16-bit color formats.
 		 */
-		DSSERR("Not enough bandwidth, too much downscaling (x-decimation factor %d > 4)", *decim_x);
+		DSSERR("Not enough bandwidth, too much downscaling (x-decimation factor %d > 4)\n", *decim_x);
 
 		return -EINVAL;
 	}
@@ -4639,7 +4639,7 @@ static int dispc_errata_i734_wa_init(struct dispc_device *dispc)
 						i734_buf.size, &i734_buf.paddr,
 						GFP_KERNEL);
 	if (!i734_buf.vaddr) {
-		dev_err(&dispc->pdev->dev, "%s: dma_alloc_writecombine failed",
+		dev_err(&dispc->pdev->dev, "%s: dma_alloc_writecombine failed\n",
 			__func__);
 		return -ENOMEM;
 	}

commit e1cdab6e5f9a52e0bdf34363ec0fdab0e2328ba9
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 2 12:11:57 2018 +0300

    drm/omap: handle error if scale coefs are not found
    
    If get_scale_coef functions fail, they return NULL, but we never check
    the return value and could do a NULL deref. This should not happen as we
    ought to validate the amount of scaling already earlier, but to be safe,
    add the necessary check.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180502091159.7071-3-tomi.valkeinen@ti.com
    Reviewed-by: Benoit Parrot <bparrot@ti.com>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5e2e65e88847..b8fdb63e5bb3 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -828,6 +828,12 @@ static void dispc_ovl_set_scale_coef(struct dispc_device *dispc,
 	h_coef = dispc_ovl_get_scale_coef(fir_hinc, true);
 	v_coef = dispc_ovl_get_scale_coef(fir_vinc, five_taps);
 
+	if (!h_coef || !v_coef) {
+		dev_err(&dispc->pdev->dev, "%s: failed to find scale coefs\n",
+			__func__);
+		return;
+	}
+
 	for (i = 0; i < 8; i++) {
 		u32 h, hv;
 

commit 4cba7071b70de271415a4d9e8bfb1e420d5942b1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Sep 12 10:00:15 2016 +0300

    drm/omap: cleanup color space conversion
    
    The setup code for color space conversion is a bit messy. This patch
    cleans it up.
    
    For some reason the TRM uses values in YCrCb order, which is also used
    in the current driver, whereas everywhere else it's YCbCr (which also
    matches YUV order). This patch changes the tables to use the common
    order to avoid confusion.
    
    The tables are split into separate lines, and comments added for
    clarity.
    
    WB color conversion registers are similar but different than non-WB, but
    the same function was used to write both. It worked fine because the
    coef table was adjusted accordingly, but that was rather confusing. This
    patch adds a separate function to write the WB values so that the coef
    table can be written in an understandable way.
    
    Recalculation also showed that 'bcb' value in yuv-to-rgb conversion had
    been rounded wrongly, and it should be 516 instead of 517.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 57960df1517a..5e2e65e88847 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -352,11 +352,6 @@ static const struct {
 	},
 };
 
-struct color_conv_coef {
-	int ry, rcr, rcb, gy, gcr, gcb, by, bcr, bcb;
-	int full_range;
-};
-
 static unsigned long dispc_fclk_rate(struct dispc_device *dispc);
 static unsigned long dispc_core_clk_rate(struct dispc_device *dispc);
 static unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,
@@ -868,10 +863,19 @@ static void dispc_ovl_set_scale_coef(struct dispc_device *dispc,
 	}
 }
 
+struct csc_coef_yuv2rgb {
+	int ry, rcb, rcr, gy, gcb, gcr, by, bcb, bcr;
+	bool full_range;
+};
+
+struct csc_coef_rgb2yuv {
+	int yr, yg, yb, cbr, cbg, cbb, crr, crg, crb;
+	bool full_range;
+};
 
 static void dispc_ovl_write_color_conv_coef(struct dispc_device *dispc,
 					    enum omap_plane_id plane,
-					    const struct color_conv_coef *ct)
+					    const struct csc_coef_yuv2rgb *ct)
 {
 #define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
 
@@ -886,25 +890,50 @@ static void dispc_ovl_write_color_conv_coef(struct dispc_device *dispc,
 #undef CVAL
 }
 
+static void dispc_wb_write_color_conv_coef(struct dispc_device *dispc,
+					   const struct csc_coef_rgb2yuv *ct)
+{
+	const enum omap_plane_id plane = OMAP_DSS_WB;
+
+#define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
+
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->yg,  ct->yr));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->crr, ct->yb));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->crb, ct->crg));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->cbg, ct->cbr));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->cbb));
+
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
+
+#undef CVAL
+}
+
 static void dispc_setup_color_conv_coef(struct dispc_device *dispc)
 {
 	int i;
 	int num_ovl = dispc_get_num_ovls(dispc);
-	const struct color_conv_coef ctbl_bt601_5_ovl = {
-		/* YUV -> RGB */
-		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
+
+	/* YUV -> RGB, ITU-R BT.601, limited range */
+	const struct csc_coef_yuv2rgb coefs_yuv2rgb_bt601_lim = {
+		298,    0,  409,	/* ry, rcb, rcr */
+		298, -100, -208,	/* gy, gcb, gcr */
+		298,  516,    0,	/* by, bcb, bcr */
+		false,			/* limited range */
 	};
-	const struct color_conv_coef ctbl_bt601_5_wb = {
-		/* RGB -> YUV */
-		66, 129, 25, 112, -94, -18, -38, -74, 112, 0,
+
+	/* RGB -> YUV, ITU-R BT.601, limited range */
+	const struct csc_coef_rgb2yuv coefs_rgb2yuv_bt601_lim = {
+		 66, 129,  25,		/* yr,   yg,  yb */
+		-38, -74, 112,		/* cbr, cbg, cbb */
+		112, -94, -18,		/* crr, crg, crb */
+		false,			/* limited range */
 	};
 
 	for (i = 1; i < num_ovl; i++)
-		dispc_ovl_write_color_conv_coef(dispc, i, &ctbl_bt601_5_ovl);
+		dispc_ovl_write_color_conv_coef(dispc, i, &coefs_yuv2rgb_bt601_lim);
 
 	if (dispc->feat->has_writeback)
-		dispc_ovl_write_color_conv_coef(dispc, OMAP_DSS_WB,
-						&ctbl_bt601_5_wb);
+		dispc_wb_write_color_conv_coef(dispc, &coefs_rgb2yuv_bt601_lim);
 }
 
 static void dispc_ovl_set_ba0(struct dispc_device *dispc,

commit 7c00985109f95474a7fe31f03022126e23e355ff
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Nov 10 17:59:50 2015 -0600

    drm/omap: add writeback funcs to dispc_ops
    
    Add writeback specific dispc functions to dispc_ops so that omapdrm can
    use them.  Also move 'enum dss_writeback_channel' to the public
    omapdss.h for omapdrm.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 2aa72845f819..57960df1517a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -715,7 +715,7 @@ static u32 dispc_mgr_get_sync_lost_irq(struct dispc_device *dispc,
 	return mgr_desc[channel].sync_lost_irq;
 }
 
-u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)
+static u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)
 {
 	return DISPC_IRQ_FRAMEDONEWB;
 }
@@ -750,12 +750,12 @@ static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
 	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_GO, 1);
 }
 
-bool dispc_wb_go_busy(struct dispc_device *dispc)
+static bool dispc_wb_go_busy(struct dispc_device *dispc)
 {
 	return REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;
 }
 
-void dispc_wb_go(struct dispc_device *dispc)
+static void dispc_wb_go(struct dispc_device *dispc)
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
@@ -2771,7 +2771,7 @@ static int dispc_ovl_setup(struct dispc_device *dispc,
 	return r;
 }
 
-int dispc_wb_setup(struct dispc_device *dispc,
+static int dispc_wb_setup(struct dispc_device *dispc,
 		   const struct omap_dss_writeback_info *wi,
 		   bool mem_to_mem, const struct videomode *vm,
 		   enum dss_writeback_channel channel_in)
@@ -2854,6 +2854,11 @@ int dispc_wb_setup(struct dispc_device *dispc,
 	return 0;
 }
 
+static bool dispc_has_writeback(struct dispc_device *dispc)
+{
+	return dispc->feat->has_writeback;
+}
+
 static int dispc_ovl_enable(struct dispc_device *dispc,
 			    enum omap_plane_id plane, bool enable)
 {
@@ -4709,6 +4714,12 @@ static const struct dispc_ops dispc_ops = {
 	.ovl_enable = dispc_ovl_enable,
 	.ovl_setup = dispc_ovl_setup,
 	.ovl_get_color_modes = dispc_ovl_get_color_modes,
+
+	.wb_get_framedone_irq = dispc_wb_get_framedone_irq,
+	.wb_setup = dispc_wb_setup,
+	.has_writeback = dispc_has_writeback,
+	.wb_go_busy = dispc_wb_go_busy,
+	.wb_go = dispc_wb_go,
 };
 
 /* DISPC HW IP initialisation */

commit 13bb1601c721f395d272d58438c9e747317f7c1a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Dec 22 15:45:20 2015 -0600

    drm/omap: fix scaling limits for WB
    
    WB has additional scaling limits when the output color format is one of
    the YUV formats. These limits are not handled at the moment, causing
    bad scaling and/or NULL dereference crash.
    
    This patchs adds the check so that dispc returns an error for bad
    scaling request.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 72f00e8a1329..2aa72845f819 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2475,6 +2475,7 @@ static int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,
 	((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))
 
 static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
 				  unsigned long pclk, unsigned long lclk,
 				  enum omap_overlay_caps caps,
 				  const struct videomode *vm,
@@ -2485,7 +2486,8 @@ static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
 				  enum omap_dss_rotation_type rotation_type,
 				  bool mem_to_mem)
 {
-	const int maxdownscale = dispc->feat->max_downscale;
+	int maxhdownscale = dispc->feat->max_downscale;
+	int maxvdownscale = dispc->feat->max_downscale;
 	const int max_decim_limit = 16;
 	unsigned long core_clk = 0;
 	int decim_x, decim_y, ret;
@@ -2493,6 +2495,20 @@ static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
 	if (width == out_width && height == out_height)
 		return 0;
 
+	if (plane == OMAP_DSS_WB) {
+		switch (fourcc) {
+		case DRM_FORMAT_NV12:
+			maxhdownscale = maxvdownscale = 2;
+			break;
+		case DRM_FORMAT_YUYV:
+		case DRM_FORMAT_UYVY:
+			maxhdownscale = 2;
+			maxvdownscale = 4;
+			break;
+		default:
+			break;
+		}
+	}
 	if (!mem_to_mem && (pclk == 0 || vm->pixelclock == 0)) {
 		DSSERR("cannot calculate scaling settings: pclk is zero\n");
 		return -EINVAL;
@@ -2510,8 +2526,8 @@ static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
 				2 : max_decim_limit;
 	}
 
-	decim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxdownscale);
-	decim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxdownscale);
+	decim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxhdownscale);
+	decim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxvdownscale);
 
 	if (decim_x > *x_predecim || out_width > width * 8)
 		return -EINVAL;
@@ -2615,7 +2631,7 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	if (!dispc_ovl_color_mode_supported(dispc, plane, fourcc))
 		return -EINVAL;
 
-	r = dispc_ovl_calc_scaling(dispc, pclk, lclk, caps, vm, in_width,
+	r = dispc_ovl_calc_scaling(dispc, plane, pclk, lclk, caps, vm, in_width,
 				   in_height, out_width, out_height, fourcc,
 				   &five_taps, &x_predecim, &y_predecim, pos_x,
 				   rotation_type, mem_to_mem);

commit 1317ef2113a14b631df15c9d09ce1283836c1456
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Oct 26 14:40:13 2017 +0300

    drm/omap: fix WB height with interlace
    
    When using WB capture from interlaced source, we need to halve the
    picture heights correctly.
    
    Unfortunately the current dispc_ovl_setup_common() doesn't deal with
    interlace very neatly, so the end result is a bit messy.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Benoit Parrot <bparrot@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 000a3d4a27bf..72f00e8a1329 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2597,18 +2597,19 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	out_width = out_width == 0 ? width : out_width;
 	out_height = out_height == 0 ? height : out_height;
 
-	if (ilace && height == out_height)
-		fieldmode = true;
-
-	if (ilace) {
-		if (fieldmode)
-			in_height /= 2;
-		pos_y /= 2;
-		out_height /= 2;
-
-		DSSDBG("adjusting for ilace: height %d, pos_y %d, "
-			"out_height %d\n", in_height, pos_y,
-			out_height);
+	if (plane != OMAP_DSS_WB) {
+		if (ilace && height == out_height)
+			fieldmode = true;
+
+		if (ilace) {
+			if (fieldmode)
+				in_height /= 2;
+			pos_y /= 2;
+			out_height /= 2;
+
+			DSSDBG("adjusting for ilace: height %d, pos_y %d, out_height %d\n",
+				in_height, pos_y, out_height);
+		}
 	}
 
 	if (!dispc_ovl_color_mode_supported(dispc, plane, fourcc))
@@ -2771,6 +2772,9 @@ int dispc_wb_setup(struct dispc_device *dispc,
 	enum omap_overlay_caps caps =
 		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
 
+	if (vm->flags & DISPLAY_FLAGS_INTERLACED)
+		in_height /= 2;
+
 	DSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "
 		"rot %d\n", wi->paddr, wi->p_uv_addr, in_width,
 		in_height, wi->width, wi->height, wi->fourcc, wi->rotation);

commit b994e53c2c6437689873af4ff61803bef78a2330
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Oct 26 14:40:12 2017 +0300

    drm/omap: fix WBDELAYCOUNT with interlace
    
    Vertical blanking needs to be halved on interlace modes. WBDELAYCOUNT
    was calculated without such halving, resulting in WBUNCOMPLETE errors.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Benoit Parrot <bparrot@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7398039954a5..000a3d4a27bf 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2814,14 +2814,18 @@ int dispc_wb_setup(struct dispc_device *dispc,
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
 	} else {
-		int wbdelay;
+		u32 wbdelay;
 
 		if (channel_in == DSS_WB_TV_MGR)
-			wbdelay = min(vm->vsync_len + vm->vback_porch,
-				(u32)255);
+			wbdelay = vm->vsync_len + vm->vback_porch;
 		else
-			wbdelay = min(vm->vfront_porch +
-				vm->vsync_len + vm->vback_porch, (u32)255);
+			wbdelay = vm->vfront_porch + vm->vsync_len +
+				vm->vback_porch;
+
+		if (vm->flags & DISPLAY_FLAGS_INTERLACED)
+			wbdelay /= 2;
+
+		wbdelay = min(wbdelay, 255u);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);

commit 46a930418544a5c28abec8dc3e0899d53381814a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jun 3 13:29:59 2016 +0300

    drm/omap: fix WBDELAYCOUNT for HDMI
    
    For HDMI, WBDELAYCOUNT starts counting at the start of vsync, not at the
    start of vfp.
    
    This patch adjusts the wbdelay for HDMI accordingly.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ccfafce1ea89..7398039954a5 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2816,8 +2816,12 @@ int dispc_wb_setup(struct dispc_device *dispc,
 	} else {
 		int wbdelay;
 
-		wbdelay = min(vm->vfront_porch +
-			      vm->vsync_len + vm->vback_porch, (u32)255);
+		if (channel_in == DSS_WB_TV_MGR)
+			wbdelay = min(vm->vsync_len + vm->vback_porch,
+				(u32)255);
+		else
+			wbdelay = min(vm->vfront_porch +
+				vm->vsync_len + vm->vback_porch, (u32)255);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);

commit 9f7853ae751849f50486759197d86993551663c2
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jan 9 15:36:47 2018 +0200

    drm/omap: set WB channel-in in wb_setup()
    
    We need to know the WB channel-in in wb_setup() to be able to configure
    WB properly for capture mode. At the moment channel-in is set
    separately.
    
    This patch moves channel-in to wb_setup().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 3ad56b30c90a..ccfafce1ea89 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1234,14 +1234,6 @@ static enum omap_channel dispc_ovl_get_channel_out(struct dispc_device *dispc,
 	}
 }
 
-void dispc_wb_set_channel_in(struct dispc_device *dispc,
-			     enum dss_writeback_channel channel)
-{
-	enum omap_plane_id plane = OMAP_DSS_WB;
-
-	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
-}
-
 static void dispc_ovl_set_burst_size(struct dispc_device *dispc,
 				     enum omap_plane_id plane,
 				     enum omap_burst_size burst_size)
@@ -2764,7 +2756,8 @@ static int dispc_ovl_setup(struct dispc_device *dispc,
 
 int dispc_wb_setup(struct dispc_device *dispc,
 		   const struct omap_dss_writeback_info *wi,
-		   bool mem_to_mem, const struct videomode *vm)
+		   bool mem_to_mem, const struct videomode *vm,
+		   enum dss_writeback_channel channel_in)
 {
 	int r;
 	u32 l;
@@ -2809,6 +2802,7 @@ int dispc_wb_setup(struct dispc_device *dispc,
 	/* setup extra DISPC_WB_ATTRIBUTES */
 	l = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 	l = FLD_MOD(l, truncation, 10, 10);	/* TRUNCATIONENABLE */
+	l = FLD_MOD(l, channel_in, 18, 16);	/* CHANNELIN */
 	l = FLD_MOD(l, mem_to_mem, 19, 19);	/* WRITEBACKMODE */
 	if (mem_to_mem)
 		l = FLD_MOD(l, 1, 26, 24);	/* CAPTUREMODE */

commit 9deb5ad3c47ead2b3c63e44435e9eff0f6f38835
Author: Benoit Parrot <bparrot@ti.com>
Date:   Mon May 16 16:42:50 2016 -0500

    drm/omap: Add pclk setting case when channel is DSS_WB
    
    In dispc_set_ovl_common() we need to initialize pclk to a valid
    value when we use WB in capture mode (i.e. mem_2_mem is false).
    Otherwise dispc_ovl_calc_scaling() fails.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f0f729fc4ca2..3ad56b30c90a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2590,6 +2590,10 @@ static int dispc_ovl_setup_common(struct dispc_device *dispc,
 	unsigned long pclk = dispc_plane_pclk_rate(dispc, plane);
 	unsigned long lclk = dispc_plane_lclk_rate(dispc, plane);
 
+	/* when setting up WB, dispc_plane_pclk_rate() returns 0 */
+	if (plane == OMAP_DSS_WB)
+		pclk = vm->pixelclock;
+
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 

commit b5d025eff5206300be0f59bfe10c5b9e1c895af4
Author: Benoit Parrot <bparrot@ti.com>
Date:   Wed Jun 22 12:59:50 2016 -0500

    drm/omap: dispc: disp_wb_setup to check return code
    
    When dispc_wb_setup() calls dispc_ovl_setup_common() it does not
    check for failure but instead keeps on partially setting up WB.
    This causes the WB H/W to be partially initialized and yield
    unexpected behavior.
    
    Make sure return code is successful before proceeding.
    
    Signed-off-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index d2d95c76a313..f0f729fc4ca2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2783,6 +2783,8 @@ int dispc_wb_setup(struct dispc_device *dispc,
 		wi->height, wi->fourcc, wi->rotation, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
 		replication, vm, mem_to_mem);
+	if (r)
+		return r;
 
 	switch (wi->fourcc) {
 	case DRM_FORMAT_RGB565:
@@ -2823,7 +2825,7 @@ int dispc_wb_setup(struct dispc_device *dispc,
 		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
 	}
 
-	return r;
+	return 0;
 }
 
 static int dispc_ovl_enable(struct dispc_device *dispc,

commit fe6b503910e9d794d64e6dd311f4d5c80514069f
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Feb 12 09:16:08 2018 +0200

    drm/omap: reorganize locking in mgr_fld_write
    
    Fix sparse warning:
    
    drivers/gpu/drm/omapdrm/dss/dispc.c:387:9: warning: context imbalance in 'mgr_fld_write' - different lock contexts for basic block
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ce470b51e326..d2d95c76a313 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -396,13 +396,13 @@ static void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,
 	const bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;
 	unsigned long flags;
 
-	if (need_lock)
+	if (need_lock) {
 		spin_lock_irqsave(&dispc->control_lock, flags);
-
-	REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
-
-	if (need_lock)
+		REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
 		spin_unlock_irqrestore(&dispc->control_lock, flags);
+	} else {
+		REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
+	}
 }
 
 static int dispc_get_num_ovls(struct dispc_device *dispc)

commit 1f6b6b6267ebe6f36f3640bccb93d54e9699c131
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:44 2018 +0200

    drm: omapdrm: dispc: Allocate the dispc private data structure dynamically
    
    The dispc private data structure is currently stored as a global
    variable. While no platform with multiple DISPC currently exists
    nor is planned, this doesn't comply with the kernel device model and
    should thus be fixed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index bd014bfc1cb6..ce470b51e326 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -47,6 +47,8 @@
 #include "dss.h"
 #include "dispc.h"
 
+struct dispc_device;
+
 /* DISPC */
 #define DISPC_SZ_REGS			SZ_4K
 
@@ -56,11 +58,12 @@ enum omap_burst_size {
 	BURST_SIZE_X8 = 2,
 };
 
-#define REG_GET(idx, start, end) \
-	FLD_GET(dispc_read_reg(idx), start, end)
+#define REG_GET(dispc, idx, start, end) \
+	FLD_GET(dispc_read_reg(dispc, idx), start, end)
 
-#define REG_FLD_MOD(idx, val, start, end)				\
-	dispc_write_reg(idx, FLD_MOD(dispc_read_reg(idx), val, start, end))
+#define REG_FLD_MOD(dispc, idx, val, start, end)			\
+	dispc_write_reg(dispc, idx, \
+			FLD_MOD(dispc_read_reg(dispc, idx), val, start, end))
 
 /* DISPC has feature id */
 enum dispc_feature_id {
@@ -105,7 +108,8 @@ struct dispc_features {
 	unsigned int max_downscale;
 	unsigned int max_line_width;
 	unsigned int min_pcd;
-	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
+	int (*calc_scaling)(struct dispc_device *dispc,
+		unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		u32 fourcc, bool *five_taps,
@@ -196,8 +200,6 @@ struct dispc_device {
 	spinlock_t control_lock;
 };
 
-static struct dispc_device dispc;
-
 enum omap_color_component {
 	/* used for all color formats for OMAP3 and earlier
 	 * and for RGB and Y color component on OMAP4
@@ -355,45 +357,52 @@ struct color_conv_coef {
 	int full_range;
 };
 
-static unsigned long dispc_fclk_rate(void);
-static unsigned long dispc_core_clk_rate(void);
-static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel);
-static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
+static unsigned long dispc_fclk_rate(struct dispc_device *dispc);
+static unsigned long dispc_core_clk_rate(struct dispc_device *dispc);
+static unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel);
+static unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel);
 
-static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane);
-static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane);
+static unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane);
+static unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane);
 
 static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask);
 
-static inline void dispc_write_reg(const u16 idx, u32 val)
+static inline void dispc_write_reg(struct dispc_device *dispc, u16 idx, u32 val)
 {
-	__raw_writel(val, dispc.base + idx);
+	__raw_writel(val, dispc->base + idx);
 }
 
-static inline u32 dispc_read_reg(const u16 idx)
+static inline u32 dispc_read_reg(struct dispc_device *dispc, u16 idx)
 {
-	return __raw_readl(dispc.base + idx);
+	return __raw_readl(dispc->base + idx);
 }
 
-static u32 mgr_fld_read(enum omap_channel channel, enum mgr_reg_fields regfld)
+static u32 mgr_fld_read(struct dispc_device *dispc, enum omap_channel channel,
+			enum mgr_reg_fields regfld)
 {
 	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
-	return REG_GET(rfld.reg, rfld.high, rfld.low);
+
+	return REG_GET(dispc, rfld.reg, rfld.high, rfld.low);
 }
 
-static void mgr_fld_write(enum omap_channel channel,
-					enum mgr_reg_fields regfld, int val) {
+static void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,
+			  enum mgr_reg_fields regfld, int val)
+{
 	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
 	const bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;
 	unsigned long flags;
 
 	if (need_lock)
-		spin_lock_irqsave(&dispc.control_lock, flags);
+		spin_lock_irqsave(&dispc->control_lock, flags);
 
-	REG_FLD_MOD(rfld.reg, val, rfld.high, rfld.low);
+	REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
 
 	if (need_lock)
-		spin_unlock_irqrestore(&dispc.control_lock, flags);
+		spin_unlock_irqrestore(&dispc->control_lock, flags);
 }
 
 static int dispc_get_num_ovls(struct dispc_device *dispc)
@@ -406,255 +415,257 @@ static int dispc_get_num_mgrs(struct dispc_device *dispc)
 	return dispc->feat->num_mgrs;
 }
 
-static void dispc_get_reg_field(enum dispc_feat_reg_field id,
+static void dispc_get_reg_field(struct dispc_device *dispc,
+				enum dispc_feat_reg_field id,
 				u8 *start, u8 *end)
 {
-	if (id >= dispc.feat->num_reg_fields)
+	if (id >= dispc->feat->num_reg_fields)
 		BUG();
 
-	*start = dispc.feat->reg_fields[id].start;
-	*end = dispc.feat->reg_fields[id].end;
+	*start = dispc->feat->reg_fields[id].start;
+	*end = dispc->feat->reg_fields[id].end;
 }
 
-static bool dispc_has_feature(enum dispc_feature_id id)
+static bool dispc_has_feature(struct dispc_device *dispc,
+			      enum dispc_feature_id id)
 {
 	unsigned int i;
 
-	for (i = 0; i < dispc.feat->num_features; i++) {
-		if (dispc.feat->features[i] == id)
+	for (i = 0; i < dispc->feat->num_features; i++) {
+		if (dispc->feat->features[i] == id)
 			return true;
 	}
 
 	return false;
 }
 
-#define SR(reg) \
-	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
-#define RR(reg) \
-	dispc_write_reg(DISPC_##reg, dispc.ctx[DISPC_##reg / sizeof(u32)])
+#define SR(dispc, reg) \
+	dispc->ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(dispc, DISPC_##reg)
+#define RR(dispc, reg) \
+	dispc_write_reg(dispc, DISPC_##reg, dispc->ctx[DISPC_##reg / sizeof(u32)])
 
-static void dispc_save_context(void)
+static void dispc_save_context(struct dispc_device *dispc)
 {
 	int i, j;
 
 	DSSDBG("dispc_save_context\n");
 
-	SR(IRQENABLE);
-	SR(CONTROL);
-	SR(CONFIG);
-	SR(LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		SR(GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
-		SR(CONTROL2);
-		SR(CONFIG2);
+	SR(dispc, IRQENABLE);
+	SR(dispc, CONTROL);
+	SR(dispc, CONFIG);
+	SR(dispc, LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		SR(dispc, GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
+		SR(dispc, CONTROL2);
+		SR(dispc, CONFIG2);
 	}
-	if (dispc_has_feature(FEAT_MGR_LCD3)) {
-		SR(CONTROL3);
-		SR(CONFIG3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
+		SR(dispc, CONTROL3);
+		SR(dispc, CONFIG3);
 	}
 
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		SR(DEFAULT_COLOR(i));
-		SR(TRANS_COLOR(i));
-		SR(SIZE_MGR(i));
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		SR(dispc, DEFAULT_COLOR(i));
+		SR(dispc, TRANS_COLOR(i));
+		SR(dispc, SIZE_MGR(i));
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
-		SR(TIMING_H(i));
-		SR(TIMING_V(i));
-		SR(POL_FREQ(i));
-		SR(DIVISORo(i));
-
-		SR(DATA_CYCLE1(i));
-		SR(DATA_CYCLE2(i));
-		SR(DATA_CYCLE3(i));
-
-		if (dispc_has_feature(FEAT_CPR)) {
-			SR(CPR_COEF_R(i));
-			SR(CPR_COEF_G(i));
-			SR(CPR_COEF_B(i));
+		SR(dispc, TIMING_H(i));
+		SR(dispc, TIMING_V(i));
+		SR(dispc, POL_FREQ(i));
+		SR(dispc, DIVISORo(i));
+
+		SR(dispc, DATA_CYCLE1(i));
+		SR(dispc, DATA_CYCLE2(i));
+		SR(dispc, DATA_CYCLE3(i));
+
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			SR(dispc, CPR_COEF_R(i));
+			SR(dispc, CPR_COEF_G(i));
+			SR(dispc, CPR_COEF_B(i));
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		SR(OVL_BA0(i));
-		SR(OVL_BA1(i));
-		SR(OVL_POSITION(i));
-		SR(OVL_SIZE(i));
-		SR(OVL_ATTRIBUTES(i));
-		SR(OVL_FIFO_THRESHOLD(i));
-		SR(OVL_ROW_INC(i));
-		SR(OVL_PIXEL_INC(i));
-		if (dispc_has_feature(FEAT_PRELOAD))
-			SR(OVL_PRELOAD(i));
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		SR(dispc, OVL_BA0(i));
+		SR(dispc, OVL_BA1(i));
+		SR(dispc, OVL_POSITION(i));
+		SR(dispc, OVL_SIZE(i));
+		SR(dispc, OVL_ATTRIBUTES(i));
+		SR(dispc, OVL_FIFO_THRESHOLD(i));
+		SR(dispc, OVL_ROW_INC(i));
+		SR(dispc, OVL_PIXEL_INC(i));
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			SR(dispc, OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
-			SR(OVL_WINDOW_SKIP(i));
-			SR(OVL_TABLE_BA(i));
+			SR(dispc, OVL_WINDOW_SKIP(i));
+			SR(dispc, OVL_TABLE_BA(i));
 			continue;
 		}
-		SR(OVL_FIR(i));
-		SR(OVL_PICTURE_SIZE(i));
-		SR(OVL_ACCU0(i));
-		SR(OVL_ACCU1(i));
+		SR(dispc, OVL_FIR(i));
+		SR(dispc, OVL_PICTURE_SIZE(i));
+		SR(dispc, OVL_ACCU0(i));
+		SR(dispc, OVL_ACCU1(i));
 
 		for (j = 0; j < 8; j++)
-			SR(OVL_FIR_COEF_H(i, j));
+			SR(dispc, OVL_FIR_COEF_H(i, j));
 
 		for (j = 0; j < 8; j++)
-			SR(OVL_FIR_COEF_HV(i, j));
+			SR(dispc, OVL_FIR_COEF_HV(i, j));
 
 		for (j = 0; j < 5; j++)
-			SR(OVL_CONV_COEF(i, j));
+			SR(dispc, OVL_CONV_COEF(i, j));
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_V(i, j));
+				SR(dispc, OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			SR(OVL_BA0_UV(i));
-			SR(OVL_BA1_UV(i));
-			SR(OVL_FIR2(i));
-			SR(OVL_ACCU2_0(i));
-			SR(OVL_ACCU2_1(i));
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			SR(dispc, OVL_BA0_UV(i));
+			SR(dispc, OVL_BA1_UV(i));
+			SR(dispc, OVL_FIR2(i));
+			SR(dispc, OVL_ACCU2_0(i));
+			SR(dispc, OVL_ACCU2_1(i));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_H2(i, j));
+				SR(dispc, OVL_FIR_COEF_H2(i, j));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_HV2(i, j));
+				SR(dispc, OVL_FIR_COEF_HV2(i, j));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_V2(i, j));
+				SR(dispc, OVL_FIR_COEF_V2(i, j));
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			SR(OVL_ATTRIBUTES2(i));
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			SR(dispc, OVL_ATTRIBUTES2(i));
 	}
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-		SR(DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+		SR(dispc, DIVISOR);
 
-	dispc.ctx_valid = true;
+	dispc->ctx_valid = true;
 
 	DSSDBG("context saved\n");
 }
 
-static void dispc_restore_context(void)
+static void dispc_restore_context(struct dispc_device *dispc)
 {
 	int i, j;
 
 	DSSDBG("dispc_restore_context\n");
 
-	if (!dispc.ctx_valid)
+	if (!dispc->ctx_valid)
 		return;
 
-	/*RR(IRQENABLE);*/
-	/*RR(CONTROL);*/
-	RR(CONFIG);
-	RR(LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		RR(GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		RR(CONFIG2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		RR(CONFIG3);
-
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		RR(DEFAULT_COLOR(i));
-		RR(TRANS_COLOR(i));
-		RR(SIZE_MGR(i));
+	/*RR(dispc, IRQENABLE);*/
+	/*RR(dispc, CONTROL);*/
+	RR(dispc, CONFIG);
+	RR(dispc, LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		RR(dispc, GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		RR(dispc, CONFIG2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		RR(dispc, CONFIG3);
+
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		RR(dispc, DEFAULT_COLOR(i));
+		RR(dispc, TRANS_COLOR(i));
+		RR(dispc, SIZE_MGR(i));
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
-		RR(TIMING_H(i));
-		RR(TIMING_V(i));
-		RR(POL_FREQ(i));
-		RR(DIVISORo(i));
-
-		RR(DATA_CYCLE1(i));
-		RR(DATA_CYCLE2(i));
-		RR(DATA_CYCLE3(i));
-
-		if (dispc_has_feature(FEAT_CPR)) {
-			RR(CPR_COEF_R(i));
-			RR(CPR_COEF_G(i));
-			RR(CPR_COEF_B(i));
+		RR(dispc, TIMING_H(i));
+		RR(dispc, TIMING_V(i));
+		RR(dispc, POL_FREQ(i));
+		RR(dispc, DIVISORo(i));
+
+		RR(dispc, DATA_CYCLE1(i));
+		RR(dispc, DATA_CYCLE2(i));
+		RR(dispc, DATA_CYCLE3(i));
+
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			RR(dispc, CPR_COEF_R(i));
+			RR(dispc, CPR_COEF_G(i));
+			RR(dispc, CPR_COEF_B(i));
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		RR(OVL_BA0(i));
-		RR(OVL_BA1(i));
-		RR(OVL_POSITION(i));
-		RR(OVL_SIZE(i));
-		RR(OVL_ATTRIBUTES(i));
-		RR(OVL_FIFO_THRESHOLD(i));
-		RR(OVL_ROW_INC(i));
-		RR(OVL_PIXEL_INC(i));
-		if (dispc_has_feature(FEAT_PRELOAD))
-			RR(OVL_PRELOAD(i));
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		RR(dispc, OVL_BA0(i));
+		RR(dispc, OVL_BA1(i));
+		RR(dispc, OVL_POSITION(i));
+		RR(dispc, OVL_SIZE(i));
+		RR(dispc, OVL_ATTRIBUTES(i));
+		RR(dispc, OVL_FIFO_THRESHOLD(i));
+		RR(dispc, OVL_ROW_INC(i));
+		RR(dispc, OVL_PIXEL_INC(i));
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			RR(dispc, OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
-			RR(OVL_WINDOW_SKIP(i));
-			RR(OVL_TABLE_BA(i));
+			RR(dispc, OVL_WINDOW_SKIP(i));
+			RR(dispc, OVL_TABLE_BA(i));
 			continue;
 		}
-		RR(OVL_FIR(i));
-		RR(OVL_PICTURE_SIZE(i));
-		RR(OVL_ACCU0(i));
-		RR(OVL_ACCU1(i));
+		RR(dispc, OVL_FIR(i));
+		RR(dispc, OVL_PICTURE_SIZE(i));
+		RR(dispc, OVL_ACCU0(i));
+		RR(dispc, OVL_ACCU1(i));
 
 		for (j = 0; j < 8; j++)
-			RR(OVL_FIR_COEF_H(i, j));
+			RR(dispc, OVL_FIR_COEF_H(i, j));
 
 		for (j = 0; j < 8; j++)
-			RR(OVL_FIR_COEF_HV(i, j));
+			RR(dispc, OVL_FIR_COEF_HV(i, j));
 
 		for (j = 0; j < 5; j++)
-			RR(OVL_CONV_COEF(i, j));
+			RR(dispc, OVL_CONV_COEF(i, j));
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_V(i, j));
+				RR(dispc, OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			RR(OVL_BA0_UV(i));
-			RR(OVL_BA1_UV(i));
-			RR(OVL_FIR2(i));
-			RR(OVL_ACCU2_0(i));
-			RR(OVL_ACCU2_1(i));
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			RR(dispc, OVL_BA0_UV(i));
+			RR(dispc, OVL_BA1_UV(i));
+			RR(dispc, OVL_FIR2(i));
+			RR(dispc, OVL_ACCU2_0(i));
+			RR(dispc, OVL_ACCU2_1(i));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_H2(i, j));
+				RR(dispc, OVL_FIR_COEF_H2(i, j));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_HV2(i, j));
+				RR(dispc, OVL_FIR_COEF_HV2(i, j));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_V2(i, j));
+				RR(dispc, OVL_FIR_COEF_V2(i, j));
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			RR(OVL_ATTRIBUTES2(i));
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			RR(dispc, OVL_ATTRIBUTES2(i));
 	}
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-		RR(DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+		RR(dispc, DIVISOR);
 
 	/* enable last, because LCD & DIGIT enable are here */
-	RR(CONTROL);
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		RR(CONTROL2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		RR(CONTROL3);
+	RR(dispc, CONTROL);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		RR(dispc, CONTROL2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		RR(dispc, CONTROL3);
 	/* clear spurious SYNC_LOST_DIGIT interrupts */
-	dispc_clear_irqstatus(&dispc, DISPC_IRQ_SYNC_LOST_DIGIT);
+	dispc_clear_irqstatus(dispc, DISPC_IRQ_SYNC_LOST_DIGIT);
 
 	/*
 	 * enable last so IRQs won't trigger before
 	 * the context is fully restored
 	 */
-	RR(IRQENABLE);
+	RR(dispc, IRQENABLE);
 
 	DSSDBG("context restored\n");
 }
@@ -712,21 +723,21 @@ u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)
 static void dispc_mgr_enable(struct dispc_device *dispc,
 			     enum omap_channel channel, bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_ENABLE, enable);
 	/* flush posted write */
-	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+	mgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);
 }
 
 static bool dispc_mgr_is_enabled(struct dispc_device *dispc,
 				 enum omap_channel channel)
 {
-	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+	return !!mgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);
 }
 
 static bool dispc_mgr_go_busy(struct dispc_device *dispc,
 			      enum omap_channel channel)
 {
-	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
+	return mgr_fld_read(dispc, channel, DISPC_MGR_FLD_GO) == 1;
 }
 
 static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
@@ -736,12 +747,12 @@ static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
 
 	DSSDBG("GO %s\n", mgr_desc[channel].name);
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_GO, 1);
 }
 
 bool dispc_wb_go_busy(struct dispc_device *dispc)
 {
-	return REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+	return REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;
 }
 
 void dispc_wb_go(struct dispc_device *dispc)
@@ -749,65 +760,72 @@ void dispc_wb_go(struct dispc_device *dispc)
 	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
 
-	enable = REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
+	enable = REG_GET(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
 
 	if (!enable)
 		return;
 
-	go = REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+	go = REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;
 	if (go) {
 		DSSERR("GO bit not down for WB\n");
 		return;
 	}
 
-	REG_FLD_MOD(DISPC_CONTROL2, 1, 6, 6);
+	REG_FLD_MOD(dispc, DISPC_CONTROL2, 1, 6, 6);
 }
 
-static void dispc_ovl_write_firh_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firh_reg(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int reg,
 				     u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firhv_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firv_reg(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int reg,
 				     u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V(plane, reg), value);
 }
 
-static void dispc_ovl_write_firh2_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firh2_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv2_reg(enum omap_plane_id plane, int reg,
-		u32 value)
+static void dispc_ovl_write_firhv2_reg(struct dispc_device *dispc,
+				       enum omap_plane_id plane, int reg,
+				       u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv2_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firv2_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V2(plane, reg), value);
 }
 
-static void dispc_ovl_set_scale_coef(enum omap_plane_id plane, int fir_hinc,
-				int fir_vinc, int five_taps,
-				enum omap_color_component color_comp)
+static void dispc_ovl_set_scale_coef(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int fir_hinc,
+				     int fir_vinc, int five_taps,
+				     enum omap_color_component color_comp)
 {
 	const struct dispc_coef *h_coef, *v_coef;
 	int i;
@@ -828,11 +846,11 @@ static void dispc_ovl_set_scale_coef(enum omap_plane_id plane, int fir_hinc,
 			| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);
 
 		if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
-			dispc_ovl_write_firh_reg(plane, i, h);
-			dispc_ovl_write_firhv_reg(plane, i, hv);
+			dispc_ovl_write_firh_reg(dispc, plane, i, h);
+			dispc_ovl_write_firhv_reg(dispc, plane, i, hv);
 		} else {
-			dispc_ovl_write_firh2_reg(plane, i, h);
-			dispc_ovl_write_firhv2_reg(plane, i, hv);
+			dispc_ovl_write_firh2_reg(dispc, plane, i, h);
+			dispc_ovl_write_firhv2_reg(dispc, plane, i, hv);
 		}
 
 	}
@@ -843,34 +861,35 @@ static void dispc_ovl_set_scale_coef(enum omap_plane_id plane, int fir_hinc,
 			v = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)
 				| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);
 			if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)
-				dispc_ovl_write_firv_reg(plane, i, v);
+				dispc_ovl_write_firv_reg(dispc, plane, i, v);
 			else
-				dispc_ovl_write_firv2_reg(plane, i, v);
+				dispc_ovl_write_firv2_reg(dispc, plane, i, v);
 		}
 	}
 }
 
 
-static void dispc_ovl_write_color_conv_coef(enum omap_plane_id plane,
-		const struct color_conv_coef *ct)
+static void dispc_ovl_write_color_conv_coef(struct dispc_device *dispc,
+					    enum omap_plane_id plane,
+					    const struct color_conv_coef *ct)
 {
 #define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
 
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
 
 #undef CVAL
 }
 
-static void dispc_setup_color_conv_coef(void)
+static void dispc_setup_color_conv_coef(struct dispc_device *dispc)
 {
 	int i;
-	int num_ovl = dispc_get_num_ovls(&dispc);
+	int num_ovl = dispc_get_num_ovls(dispc);
 	const struct color_conv_coef ctbl_bt601_5_ovl = {
 		/* YUV -> RGB */
 		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
@@ -881,34 +900,40 @@ static void dispc_setup_color_conv_coef(void)
 	};
 
 	for (i = 1; i < num_ovl; i++)
-		dispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_ovl);
+		dispc_ovl_write_color_conv_coef(dispc, i, &ctbl_bt601_5_ovl);
 
-	if (dispc.feat->has_writeback)
-		dispc_ovl_write_color_conv_coef(OMAP_DSS_WB, &ctbl_bt601_5_wb);
+	if (dispc->feat->has_writeback)
+		dispc_ovl_write_color_conv_coef(dispc, OMAP_DSS_WB,
+						&ctbl_bt601_5_wb);
 }
 
-static void dispc_ovl_set_ba0(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba0(struct dispc_device *dispc,
+			      enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA0(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA0(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba1(struct dispc_device *dispc,
+			      enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA1(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA1(plane), paddr);
 }
 
-static void dispc_ovl_set_ba0_uv(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba0_uv(struct dispc_device *dispc,
+				 enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA0_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1_uv(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba1_uv(struct dispc_device *dispc,
+				 enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA1_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_pos(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, int x, int y)
+static void dispc_ovl_set_pos(struct dispc_device *dispc,
+			      enum omap_plane_id plane,
+			      enum omap_overlay_caps caps, int x, int y)
 {
 	u32 val;
 
@@ -917,22 +942,24 @@ static void dispc_ovl_set_pos(enum omap_plane_id plane,
 
 	val = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);
 
-	dispc_write_reg(DISPC_OVL_POSITION(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_POSITION(plane), val);
 }
 
-static void dispc_ovl_set_input_size(enum omap_plane_id plane, int width,
-		int height)
+static void dispc_ovl_set_input_size(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int width,
+				     int height)
 {
 	u32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
 
 	if (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);
 	else
-		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_output_size(enum omap_plane_id plane, int width,
-		int height)
+static void dispc_ovl_set_output_size(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int width,
+				      int height)
 {
 	u32 val;
 
@@ -941,42 +968,47 @@ static void dispc_ovl_set_output_size(enum omap_plane_id plane, int width,
 	val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
 
 	if (plane == OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);
 	else
-		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_zorder(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u8 zorder)
+static void dispc_ovl_set_zorder(struct dispc_device *dispc,
+				 enum omap_plane_id plane,
+				 enum omap_overlay_caps caps, u8 zorder)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)
 		return;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);
 }
 
-static void dispc_ovl_enable_zorder_planes(void)
+static void dispc_ovl_enable_zorder_planes(struct dispc_device *dispc)
 {
 	int i;
 
-	if (!dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (!dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
 		return;
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++)
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
 }
 
-static void dispc_ovl_set_pre_mult_alpha(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, bool enable)
+static void dispc_ovl_set_pre_mult_alpha(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 bool enable)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)
 		return;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
 }
 
-static void dispc_ovl_setup_global_alpha(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u8 global_alpha)
+static void dispc_ovl_setup_global_alpha(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 u8 global_alpha)
 {
 	static const unsigned int shifts[] = { 0, 8, 16, 24, };
 	int shift;
@@ -985,20 +1017,23 @@ static void dispc_ovl_setup_global_alpha(enum omap_plane_id plane,
 		return;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
+	REG_FLD_MOD(dispc, DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
 }
 
-static void dispc_ovl_set_pix_inc(enum omap_plane_id plane, s32 inc)
+static void dispc_ovl_set_pix_inc(struct dispc_device *dispc,
+				  enum omap_plane_id plane, s32 inc)
 {
-	dispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);
+	dispc_write_reg(dispc, DISPC_OVL_PIXEL_INC(plane), inc);
 }
 
-static void dispc_ovl_set_row_inc(enum omap_plane_id plane, s32 inc)
+static void dispc_ovl_set_row_inc(struct dispc_device *dispc,
+				  enum omap_plane_id plane, s32 inc)
 {
-	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
+	dispc_write_reg(dispc, DISPC_OVL_ROW_INC(plane), inc);
 }
 
-static void dispc_ovl_set_color_mode(enum omap_plane_id plane, u32 fourcc)
+static void dispc_ovl_set_color_mode(struct dispc_device *dispc,
+				     enum omap_plane_id plane, u32 fourcc)
 {
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
@@ -1067,7 +1102,7 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane, u32 fourcc)
 		}
 	}
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
 static bool format_is_yuv(u32 fourcc)
@@ -1082,19 +1117,21 @@ static bool format_is_yuv(u32 fourcc)
 	}
 }
 
-static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
-		enum omap_dss_rotation_type rotation_type)
+static void dispc_ovl_configure_burst_type(struct dispc_device *dispc,
+					   enum omap_plane_id plane,
+					   enum omap_dss_rotation_type rotation)
 {
-	if (dispc_has_feature(FEAT_BURST_2D) == 0)
+	if (dispc_has_feature(dispc, FEAT_BURST_2D) == 0)
 		return;
 
-	if (rotation_type == OMAP_DSS_ROT_TILER)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);
+	if (rotation == OMAP_DSS_ROT_TILER)
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);
 	else
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
 }
 
-static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
+static void dispc_ovl_set_channel_out(struct dispc_device *dispc,
+				      enum omap_plane_id plane,
 				      enum omap_channel channel)
 {
 	int shift;
@@ -1115,8 +1152,8 @@ static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
 		return;
 	}
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
 		switch (channel) {
 		case OMAP_DSS_CHANNEL_LCD:
 			chan = 0;
@@ -1131,7 +1168,7 @@ static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
 			chan2 = 1;
 			break;
 		case OMAP_DSS_CHANNEL_LCD3:
-			if (dispc_has_feature(FEAT_MGR_LCD3)) {
+			if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
 				chan = 0;
 				chan2 = 2;
 			} else {
@@ -1153,10 +1190,11 @@ static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
 	} else {
 		val = FLD_MOD(val, channel, shift, shift);
 	}
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
+static enum omap_channel dispc_ovl_get_channel_out(struct dispc_device *dispc,
+						   enum omap_plane_id plane)
 {
 	int shift;
 	u32 val;
@@ -1175,12 +1213,12 @@ static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
 		return 0;
 	}
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 
 	if (FLD_GET(val, shift, shift) == 1)
 		return OMAP_DSS_CHANNEL_DIGIT;
 
-	if (!dispc_has_feature(FEAT_MGR_LCD2))
+	if (!dispc_has_feature(dispc, FEAT_MGR_LCD2))
 		return OMAP_DSS_CHANNEL_LCD;
 
 	switch (FLD_GET(val, 31, 30)) {
@@ -1201,43 +1239,47 @@ void dispc_wb_set_channel_in(struct dispc_device *dispc,
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
 }
 
-static void dispc_ovl_set_burst_size(enum omap_plane_id plane,
-		enum omap_burst_size burst_size)
+static void dispc_ovl_set_burst_size(struct dispc_device *dispc,
+				     enum omap_plane_id plane,
+				     enum omap_burst_size burst_size)
 {
 	static const unsigned int shifts[] = { 6, 14, 14, 14, 14, };
 	int shift;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), burst_size, shift + 1, shift);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), burst_size,
+		    shift + 1, shift);
 }
 
-static void dispc_configure_burst_sizes(void)
+static void dispc_configure_burst_sizes(struct dispc_device *dispc)
 {
 	int i;
 	const int burst_size = BURST_SIZE_X8;
 
 	/* Configure burst size always to maximum size */
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
-		dispc_ovl_set_burst_size(i, burst_size);
-	if (dispc.feat->has_writeback)
-		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
+		dispc_ovl_set_burst_size(dispc, i, burst_size);
+	if (dispc->feat->has_writeback)
+		dispc_ovl_set_burst_size(dispc, OMAP_DSS_WB, burst_size);
 }
 
-static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
+static u32 dispc_ovl_get_burst_size(struct dispc_device *dispc,
+				    enum omap_plane_id plane)
 {
 	/* burst multiplier is always x8 (see dispc_configure_burst_sizes()) */
-	return dispc.feat->burst_size_unit * 8;
+	return dispc->feat->burst_size_unit * 8;
 }
 
-static bool dispc_ovl_color_mode_supported(enum omap_plane_id plane, u32 fourcc)
+static bool dispc_ovl_color_mode_supported(struct dispc_device *dispc,
+					   enum omap_plane_id plane, u32 fourcc)
 {
 	const u32 *modes;
 	unsigned int i;
 
-	modes = dispc.feat->supported_color_modes[plane];
+	modes = dispc->feat->supported_color_modes[plane];
 
 	for (i = 0; modes[i]; ++i) {
 		if (modes[i] == fourcc)
@@ -1253,16 +1295,18 @@ static const u32 *dispc_ovl_get_color_modes(struct dispc_device *dispc,
 	return dispc->feat->supported_color_modes[plane];
 }
 
-static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_cpr(struct dispc_device *dispc,
+				 enum omap_channel channel, bool enable)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT)
 		return;
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_CPR, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_CPR, enable);
 }
 
-static void dispc_mgr_set_cpr_coef(enum omap_channel channel,
-		const struct omap_dss_cpr_coefs *coefs)
+static void dispc_mgr_set_cpr_coef(struct dispc_device *dispc,
+				   enum omap_channel channel,
+				   const struct omap_dss_cpr_coefs *coefs)
 {
 	u32 coef_r, coef_g, coef_b;
 
@@ -1276,25 +1320,27 @@ static void dispc_mgr_set_cpr_coef(enum omap_channel channel,
 	coef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |
 		FLD_VAL(coefs->bb, 9, 0);
 
-	dispc_write_reg(DISPC_CPR_COEF_R(channel), coef_r);
-	dispc_write_reg(DISPC_CPR_COEF_G(channel), coef_g);
-	dispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_R(channel), coef_r);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_G(channel), coef_g);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_B(channel), coef_b);
 }
 
-static void dispc_ovl_set_vid_color_conv(enum omap_plane_id plane,
-					 bool enable)
+static void dispc_ovl_set_vid_color_conv(struct dispc_device *dispc,
+					 enum omap_plane_id plane, bool enable)
 {
 	u32 val;
 
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 	val = FLD_MOD(val, enable, 9, 9);
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static void dispc_ovl_enable_replication(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, bool enable)
+static void dispc_ovl_enable_replication(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 bool enable)
 {
 	static const unsigned int shifts[] = { 5, 10, 10, 10 };
 	int shift;
@@ -1303,21 +1349,21 @@ static void dispc_ovl_enable_replication(enum omap_plane_id plane,
 		return;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);
 }
 
-static void dispc_mgr_set_size(enum omap_channel channel, u16 width,
-		u16 height)
+static void dispc_mgr_set_size(struct dispc_device *dispc,
+			       enum omap_channel channel, u16 width, u16 height)
 {
 	u32 val;
 
-	val = FLD_VAL(height - 1, dispc.feat->mgr_height_start, 16) |
-		FLD_VAL(width - 1, dispc.feat->mgr_width_start, 0);
+	val = FLD_VAL(height - 1, dispc->feat->mgr_height_start, 16) |
+		FLD_VAL(width - 1, dispc->feat->mgr_width_start, 0);
 
-	dispc_write_reg(DISPC_SIZE_MGR(channel), val);
+	dispc_write_reg(dispc, DISPC_SIZE_MGR(channel), val);
 }
 
-static void dispc_init_fifos(void)
+static void dispc_init_fifos(struct dispc_device *dispc)
 {
 	u32 size;
 	int fifo;
@@ -1325,20 +1371,21 @@ static void dispc_init_fifos(void)
 	u32 unit;
 	int i;
 
-	unit = dispc.feat->buffer_size_unit;
+	unit = dispc->feat->buffer_size_unit;
 
-	dispc_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOSIZE, &start, &end);
 
-	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
-		size = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);
+	for (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {
+		size = REG_GET(dispc, DISPC_OVL_FIFO_SIZE_STATUS(fifo),
+			       start, end);
 		size *= unit;
-		dispc.fifo_size[fifo] = size;
+		dispc->fifo_size[fifo] = size;
 
 		/*
 		 * By default fifos are mapped directly to overlays, fifo 0 to
 		 * ovl 0, fifo 1 to ovl 1, etc.
 		 */
-		dispc.fifo_assignment[fifo] = fifo;
+		dispc->fifo_assignment[fifo] = fifo;
 	}
 
 	/*
@@ -1348,57 +1395,58 @@ static void dispc_init_fifos(void)
 	 * giving GFX plane a larger fifo. WB but should work fine with a
 	 * smaller fifo.
 	 */
-	if (dispc.feat->gfx_fifo_workaround) {
+	if (dispc->feat->gfx_fifo_workaround) {
 		u32 v;
 
-		v = dispc_read_reg(DISPC_GLOBAL_BUFFER);
+		v = dispc_read_reg(dispc, DISPC_GLOBAL_BUFFER);
 
 		v = FLD_MOD(v, 4, 2, 0); /* GFX BUF top to WB */
 		v = FLD_MOD(v, 4, 5, 3); /* GFX BUF bottom to WB */
 		v = FLD_MOD(v, 0, 26, 24); /* WB BUF top to GFX */
 		v = FLD_MOD(v, 0, 29, 27); /* WB BUF bottom to GFX */
 
-		dispc_write_reg(DISPC_GLOBAL_BUFFER, v);
+		dispc_write_reg(dispc, DISPC_GLOBAL_BUFFER, v);
 
-		dispc.fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;
-		dispc.fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;
+		dispc->fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;
+		dispc->fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;
 	}
 
 	/*
 	 * Setup default fifo thresholds.
 	 */
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(&dispc, i, &low, &high,
-			use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(dispc, i, &low, &high,
+						  use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(&dispc, i, low, high);
+		dispc_ovl_set_fifo_threshold(dispc, i, low, high);
 	}
 
-	if (dispc.feat->has_writeback) {
+	if (dispc->feat->has_writeback) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(&dispc, OMAP_DSS_WB,
-						  &low, &high,
-						  use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(dispc, OMAP_DSS_WB,
+						  &low, &high, use_fifomerge,
+						  manual_update);
 
-		dispc_ovl_set_fifo_threshold(&dispc, OMAP_DSS_WB, low, high);
+		dispc_ovl_set_fifo_threshold(dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
-static u32 dispc_ovl_get_fifo_size(enum omap_plane_id plane)
+static u32 dispc_ovl_get_fifo_size(struct dispc_device *dispc,
+				   enum omap_plane_id plane)
 {
 	int fifo;
 	u32 size = 0;
 
-	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
-		if (dispc.fifo_assignment[fifo] == plane)
-			size += dispc.fifo_size[fifo];
+	for (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {
+		if (dispc->fifo_assignment[fifo] == plane)
+			size += dispc->fifo_size[fifo];
 	}
 
 	return size;
@@ -1419,18 +1467,20 @@ void dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,
 	low /= unit;
 	high /= unit;
 
-	dispc_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);
-	dispc_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOHIGHTHRESHOLD,
+			    &hi_start, &hi_end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOLOWTHRESHOLD,
+			    &lo_start, &lo_end);
 
 	DSSDBG("fifo(%d) threshold (bytes), old %u/%u, new %u/%u\n",
 			plane,
-			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+			REG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 				lo_start, lo_end) * unit,
-			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+			REG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 				hi_start, hi_end) * unit,
 			low * unit, high * unit);
 
-	dispc_write_reg(DISPC_OVL_FIFO_THRESHOLD(plane),
+	dispc_write_reg(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 			FLD_VAL(high, hi_start, hi_end) |
 			FLD_VAL(low, lo_start, lo_end));
 
@@ -1439,20 +1489,21 @@ void dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,
 	 * large for the preload field, set the threshold to the maximum value
 	 * that can be held by the preload register
 	 */
-	if (dispc_has_feature(FEAT_PRELOAD) && dispc->feat->set_max_preload &&
-			plane != OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
+	if (dispc_has_feature(dispc, FEAT_PRELOAD) &&
+	    dispc->feat->set_max_preload && plane != OMAP_DSS_WB)
+		dispc_write_reg(dispc, DISPC_OVL_PRELOAD(plane),
+				min(high, 0xfffu));
 }
 
 void dispc_enable_fifomerge(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_FIFO_MERGE)) {
+	if (!dispc_has_feature(dispc, FEAT_FIFO_MERGE)) {
 		WARN_ON(enable);
 		return;
 	}
 
 	DSSDBG("FIFO merge %s\n", enable ? "enabled" : "disabled");
-	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, enable ? 1 : 0, 14, 14);
 }
 
 void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
@@ -1468,13 +1519,13 @@ void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
 	unsigned int ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
-	burst_size = dispc_ovl_get_burst_size(plane);
-	ovl_fifo_size = dispc_ovl_get_fifo_size(plane);
+	burst_size = dispc_ovl_get_burst_size(dispc, plane);
+	ovl_fifo_size = dispc_ovl_get_fifo_size(dispc, plane);
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
 		for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
-			total_fifo_size += dispc_ovl_get_fifo_size(i);
+			total_fifo_size += dispc_ovl_get_fifo_size(dispc, i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
 	}
@@ -1485,7 +1536,7 @@ void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
 	 * combined fifo size
 	 */
 
-	if (manual_update && dispc_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {
+	if (manual_update && dispc_has_feature(dispc, FEAT_OMAP3_DSI_FIFO_BUG)) {
 		*fifo_low = ovl_fifo_size - burst_size * 2;
 		*fifo_high = total_fifo_size - burst_size;
 	} else if (plane == OMAP_DSS_WB) {
@@ -1502,7 +1553,8 @@ void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
 	}
 }
 
-static void dispc_ovl_set_mflag(enum omap_plane_id plane, bool enable)
+static void dispc_ovl_set_mflag(struct dispc_device *dispc,
+				enum omap_plane_id plane, bool enable)
 {
 	int bit;
 
@@ -1511,17 +1563,18 @@ static void dispc_ovl_set_mflag(enum omap_plane_id plane, bool enable)
 	else
 		bit = 23;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
 }
 
-static void dispc_ovl_set_mflag_threshold(enum omap_plane_id plane,
-	int low, int high)
+static void dispc_ovl_set_mflag_threshold(struct dispc_device *dispc,
+					  enum omap_plane_id plane,
+					  int low, int high)
 {
-	dispc_write_reg(DISPC_OVL_MFLAG_THRESHOLD(plane),
+	dispc_write_reg(dispc, DISPC_OVL_MFLAG_THRESHOLD(plane),
 		FLD_VAL(high, 31, 16) |	FLD_VAL(low, 15, 0));
 }
 
-static void dispc_init_mflag(void)
+static void dispc_init_mflag(struct dispc_device *dispc)
 {
 	int i;
 
@@ -1535,16 +1588,16 @@ static void dispc_init_mflag(void)
 	 *
 	 * As a work-around, set force MFLAG to always on.
 	 */
-	dispc_write_reg(DISPC_GLOBAL_MFLAG_ATTRIBUTE,
+	dispc_write_reg(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE,
 		(1 << 0) |	/* MFLAG_CTRL = force always on */
 		(0 << 2));	/* MFLAG_START = disable */
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
-		u32 size = dispc_ovl_get_fifo_size(i);
-		u32 unit = dispc.feat->buffer_size_unit;
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i) {
+		u32 size = dispc_ovl_get_fifo_size(dispc, i);
+		u32 unit = dispc->feat->buffer_size_unit;
 		u32 low, high;
 
-		dispc_ovl_set_mflag(i, true);
+		dispc_ovl_set_mflag(dispc, i, true);
 
 		/*
 		 * Simulation team suggests below thesholds:
@@ -1555,15 +1608,15 @@ static void dispc_init_mflag(void)
 		low = size * 4 / 8 / unit;
 		high = size * 5 / 8 / unit;
 
-		dispc_ovl_set_mflag_threshold(i, low, high);
+		dispc_ovl_set_mflag_threshold(dispc, i, low, high);
 	}
 
-	if (dispc.feat->has_writeback) {
-		u32 size = dispc_ovl_get_fifo_size(OMAP_DSS_WB);
-		u32 unit = dispc.feat->buffer_size_unit;
+	if (dispc->feat->has_writeback) {
+		u32 size = dispc_ovl_get_fifo_size(dispc, OMAP_DSS_WB);
+		u32 unit = dispc->feat->buffer_size_unit;
 		u32 low, high;
 
-		dispc_ovl_set_mflag(OMAP_DSS_WB, true);
+		dispc_ovl_set_mflag(dispc, OMAP_DSS_WB, true);
 
 		/*
 		 * Simulation team suggests below thesholds:
@@ -1574,98 +1627,112 @@ static void dispc_init_mflag(void)
 		low = size * 4 / 8 / unit;
 		high = size * 5 / 8 / unit;
 
-		dispc_ovl_set_mflag_threshold(OMAP_DSS_WB, low, high);
+		dispc_ovl_set_mflag_threshold(dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
-static void dispc_ovl_set_fir(enum omap_plane_id plane,
-				int hinc, int vinc,
-				enum omap_color_component color_comp)
+static void dispc_ovl_set_fir(struct dispc_device *dispc,
+			      enum omap_plane_id plane,
+			      int hinc, int vinc,
+			      enum omap_color_component color_comp)
 {
 	u32 val;
 
 	if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
 		u8 hinc_start, hinc_end, vinc_start, vinc_end;
 
-		dispc_get_reg_field(FEAT_REG_FIRHINC, &hinc_start, &hinc_end);
-		dispc_get_reg_field(FEAT_REG_FIRVINC, &vinc_start, &vinc_end);
+		dispc_get_reg_field(dispc, FEAT_REG_FIRHINC,
+				    &hinc_start, &hinc_end);
+		dispc_get_reg_field(dispc, FEAT_REG_FIRVINC,
+				    &vinc_start, &vinc_end);
 		val = FLD_VAL(vinc, vinc_start, vinc_end) |
 				FLD_VAL(hinc, hinc_start, hinc_end);
 
-		dispc_write_reg(DISPC_OVL_FIR(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_FIR(plane), val);
 	} else {
 		val = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);
-		dispc_write_reg(DISPC_OVL_FIR2(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_FIR2(plane), val);
 	}
 }
 
-static void dispc_ovl_set_vid_accu0(enum omap_plane_id plane, int haccu,
+static void dispc_ovl_set_vid_accu0(struct dispc_device *dispc,
+				    enum omap_plane_id plane, int haccu,
 				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,
+			    &hor_start, &hor_end);
+	dispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,
+			    &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
 
-	dispc_write_reg(DISPC_OVL_ACCU0(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu1(enum omap_plane_id plane, int haccu,
+static void dispc_ovl_set_vid_accu1(struct dispc_device *dispc,
+				    enum omap_plane_id plane, int haccu,
 				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,
+			    &hor_start, &hor_end);
+	dispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,
+			    &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
 
-	dispc_write_reg(DISPC_OVL_ACCU1(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU1(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_0(enum omap_plane_id plane, int haccu,
-		int vaccu)
+static void dispc_ovl_set_vid_accu2_0(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int haccu,
+				      int vaccu)
 {
 	u32 val;
 
 	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
-	dispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU2_0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_1(enum omap_plane_id plane, int haccu,
-		int vaccu)
+static void dispc_ovl_set_vid_accu2_1(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int haccu,
+				      int vaccu)
 {
 	u32 val;
 
 	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
-	dispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU2_1(plane), val);
 }
 
-static void dispc_ovl_set_scale_param(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool five_taps, u8 rotation,
-		enum omap_color_component color_comp)
+static void dispc_ovl_set_scale_param(struct dispc_device *dispc,
+				      enum omap_plane_id plane,
+				      u16 orig_width, u16 orig_height,
+				      u16 out_width, u16 out_height,
+				      bool five_taps, u8 rotation,
+				      enum omap_color_component color_comp)
 {
 	int fir_hinc, fir_vinc;
 
 	fir_hinc = 1024 * orig_width / out_width;
 	fir_vinc = 1024 * orig_height / out_height;
 
-	dispc_ovl_set_scale_coef(plane, fir_hinc, fir_vinc, five_taps,
-				color_comp);
-	dispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);
+	dispc_ovl_set_scale_coef(dispc, plane, fir_hinc, fir_vinc, five_taps,
+				 color_comp);
+	dispc_ovl_set_fir(dispc, plane, fir_hinc, fir_vinc, color_comp);
 }
 
-static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
-		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
-		bool ilace, u32 fourcc, u8 rotation)
+static void dispc_ovl_set_accu_uv(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u16 orig_width, u16 orig_height,
+				  u16 out_width, u16 out_height,
+				  bool ilace, u32 fourcc, u8 rotation)
 {
 	int h_accu2_0, h_accu2_1;
 	int v_accu2_0, v_accu2_1;
@@ -1746,25 +1813,26 @@ static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 	v_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;
 	v_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;
 
-	dispc_ovl_set_vid_accu2_0(plane, h_accu2_0, v_accu2_0);
-	dispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);
+	dispc_ovl_set_vid_accu2_0(dispc, plane, h_accu2_0, v_accu2_0);
+	dispc_ovl_set_vid_accu2_1(dispc, plane, h_accu2_1, v_accu2_1);
 }
 
-static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling_common(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 u16 orig_width, u16 orig_height,
+					 u16 out_width, u16 out_height,
+					 bool ilace, bool five_taps,
+					 bool fieldmode, u32 fourcc,
+					 u8 rotation)
 {
 	int accu0 = 0;
 	int accu1 = 0;
 	u32 l;
 
-	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
-				out_width, out_height, five_taps,
-				rotation, DISPC_COLOR_COMPONENT_RGB_Y);
-	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	dispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,
+				  out_width, out_height, five_taps,
+				  rotation, DISPC_COLOR_COMPONENT_RGB_Y);
+	l = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 
 	/* RESIZEENABLE and VERTICALTAPS */
 	l &= ~((0x3 << 5) | (0x1 << 21));
@@ -1773,19 +1841,19 @@ static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 	l |= five_taps ? (1 << 21) : 0;
 
 	/* VRESIZECONF and HRESIZECONF */
-	if (dispc_has_feature(FEAT_RESIZECONF)) {
+	if (dispc_has_feature(dispc, FEAT_RESIZECONF)) {
 		l &= ~(0x3 << 7);
 		l |= (orig_width <= out_width) ? 0 : (1 << 7);
 		l |= (orig_height <= out_height) ? 0 : (1 << 8);
 	}
 
 	/* LINEBUFFERSPLIT */
-	if (dispc_has_feature(FEAT_LINEBUFFERSPLIT)) {
+	if (dispc_has_feature(dispc, FEAT_LINEBUFFERSPLIT)) {
 		l &= ~(0x1 << 22);
 		l |= five_taps ? (1 << 22) : 0;
 	}
 
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);
 
 	/*
 	 * field 0 = even field = bottom field
@@ -1800,33 +1868,35 @@ static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 		}
 	}
 
-	dispc_ovl_set_vid_accu0(plane, 0, accu0);
-	dispc_ovl_set_vid_accu1(plane, 0, accu1);
+	dispc_ovl_set_vid_accu0(dispc, plane, 0, accu0);
+	dispc_ovl_set_vid_accu1(dispc, plane, 0, accu1);
 }
 
-static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling_uv(struct dispc_device *dispc,
+				     enum omap_plane_id plane,
+				     u16 orig_width, u16 orig_height,
+				     u16 out_width, u16 out_height,
+				     bool ilace, bool five_taps,
+				     bool fieldmode, u32 fourcc,
+				     u8 rotation)
 {
 	int scale_x = out_width != orig_width;
 	int scale_y = out_height != orig_height;
 	bool chroma_upscale = plane != OMAP_DSS_WB;
 
-	if (!dispc_has_feature(FEAT_HANDLE_UV_SEPARATE))
+	if (!dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE))
 		return;
 
 	if (!format_is_yuv(fourcc)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
-			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
+			REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),
+				    0, 8, 8);
 		return;
 	}
 
-	dispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,
-			out_height, ilace, fourcc, rotation);
+	dispc_ovl_set_accu_uv(dispc, plane, orig_width, orig_height, out_width,
+			      out_height, ilace, fourcc, rotation);
 
 	switch (fourcc) {
 	case DRM_FORMAT_NV12:
@@ -1868,46 +1938,43 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 	if (out_height != orig_height)
 		scale_y = true;
 
-	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
-			out_width, out_height, five_taps,
-				rotation, DISPC_COLOR_COMPONENT_UV);
+	dispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,
+				  out_width, out_height, five_taps,
+				  rotation, DISPC_COLOR_COMPONENT_UV);
 
 	if (plane != OMAP_DSS_WB)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane),
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),
 			(scale_x || scale_y) ? 1 : 0, 8, 8);
 
 	/* set H scaling */
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);
 	/* set V scaling */
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
 }
 
-static void dispc_ovl_set_scaling(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u16 orig_width, u16 orig_height,
+				  u16 out_width, u16 out_height,
+				  bool ilace, bool five_taps,
+				  bool fieldmode, u32 fourcc,
+				  u8 rotation)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_ovl_set_scaling_common(plane,
-			orig_width, orig_height,
-			out_width, out_height,
-			ilace, five_taps,
-			fieldmode, fourcc,
-			rotation);
+	dispc_ovl_set_scaling_common(dispc, plane, orig_width, orig_height,
+				     out_width, out_height, ilace, five_taps,
+				     fieldmode, fourcc, rotation);
 
-	dispc_ovl_set_scaling_uv(plane,
-		orig_width, orig_height,
-		out_width, out_height,
-		ilace, five_taps,
-		fieldmode, fourcc,
-		rotation);
+	dispc_ovl_set_scaling_uv(dispc, plane, orig_width, orig_height,
+				 out_width, out_height, ilace, five_taps,
+				 fieldmode, fourcc, rotation);
 }
 
-static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
-		enum omap_dss_rotation_type rotation_type, u32 fourcc)
+static void dispc_ovl_set_rotation_attrs(struct dispc_device *dispc,
+					 enum omap_plane_id plane, u8 rotation,
+					 enum omap_dss_rotation_type rotation_type,
+					 u32 fourcc)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
@@ -1961,19 +2028,20 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	if (fourcc == DRM_FORMAT_NV12 && rotation_type != OMAP_DSS_ROT_TILER)
 		vidrot = 1;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
-	if (dispc_has_feature(FEAT_ROWREPEATENABLE))
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
+	if (dispc_has_feature(dispc, FEAT_ROWREPEATENABLE))
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
-	if (dispc_ovl_color_mode_supported(plane, DRM_FORMAT_NV12)) {
+	if (dispc_ovl_color_mode_supported(dispc, plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
 			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
 			!drm_rotation_90_or_270(rotation);
 
 		/* DOUBLESTRIDE */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),
+			    doublestride, 22, 22);
 	}
 }
 
@@ -2210,27 +2278,31 @@ static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
 		return pclk;
 }
 
-static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_24xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	int error;
 	u16 in_width, in_height;
 	int min_factor = min(*decim_x, *decim_y);
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
 
 	*five_taps = false;
 
 	do {
 		in_height = height / *decim_y;
 		in_width = width / *decim_x;
-		*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+		*core_clk = dispc->feat->calc_core_clk(pclk, in_width,
 				in_height, out_width, out_height, mem_to_mem);
 		error = (in_width > maxsinglelinewidth || !*core_clk ||
-			*core_clk > dispc_core_clk_rate());
+			*core_clk > dispc_core_clk_rate(dispc));
 		if (error) {
 			if (*decim_x == *decim_y) {
 				*decim_x = min_factor;
@@ -2255,16 +2327,20 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 	return 0;
 }
 
-static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_34xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	int error;
 	u16 in_width, in_height;
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
 
 	do {
 		in_height = height / *decim_y;
@@ -2281,7 +2357,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 						in_width, in_height, out_width,
 						out_height, fourcc);
 		else
-			*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+			*core_clk = dispc->feat->calc_core_clk(pclk, in_width,
 					in_height, out_width, out_height,
 					mem_to_mem);
 
@@ -2295,7 +2371,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 
 		error = (error || in_width > maxsinglelinewidth * 2 ||
 			(in_width > maxsinglelinewidth && *five_taps) ||
-			!*core_clk || *core_clk > dispc_core_clk_rate());
+			!*core_clk || *core_clk > dispc_core_clk_rate(dispc));
 
 		if (!error) {
 			/* verify that we're inside the limits of scaler */
@@ -2339,24 +2415,28 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 	return 0;
 }
 
-static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	u16 in_width, in_width_max;
 	int decim_x_min = *decim_x;
 	u16 in_height = height / *decim_y;
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
-	const int maxdownscale = dispc.feat->max_downscale;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
+	const int maxdownscale = dispc->feat->max_downscale;
 
 	if (mem_to_mem) {
 		in_width_max = out_width * maxdownscale;
 	} else {
-		in_width_max = dispc_core_clk_rate() /
-					DIV_ROUND_UP(pclk, out_width);
+		in_width_max = dispc_core_clk_rate(dispc)
+			     / DIV_ROUND_UP(pclk, out_width);
 	}
 
 	*decim_x = DIV_ROUND_UP(width, in_width_max);
@@ -2394,7 +2474,7 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 	}
 
-	*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,
+	*core_clk = dispc->feat->calc_core_clk(pclk, in_width, in_height,
 				out_width, out_height, mem_to_mem);
 	return 0;
 }
@@ -2402,15 +2482,18 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 #define DIV_FRAC(dividend, divisor) \
 	((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))
 
-static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
-		enum omap_overlay_caps caps,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, u16 pos_x,
-		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
-{
-	const int maxdownscale = dispc.feat->max_downscale;
+static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
+				  unsigned long pclk, unsigned long lclk,
+				  enum omap_overlay_caps caps,
+				  const struct videomode *vm,
+				  u16 width, u16 height,
+				  u16 out_width, u16 out_height,
+				  u32 fourcc, bool *five_taps,
+				  int *x_predecim, int *y_predecim, u16 pos_x,
+				  enum omap_dss_rotation_type rotation_type,
+				  bool mem_to_mem)
+{
+	const int maxdownscale = dispc->feat->max_downscale;
 	const int max_decim_limit = 16;
 	unsigned long core_clk = 0;
 	int decim_x, decim_y, ret;
@@ -2431,7 +2514,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	} else {
 		*x_predecim = max_decim_limit;
 		*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&
-				dispc_has_feature(FEAT_BURST_2D)) ?
+				dispc_has_feature(dispc, FEAT_BURST_2D)) ?
 				2 : max_decim_limit;
 	}
 
@@ -2444,10 +2527,11 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	if (decim_y > *y_predecim || out_height > height * 8)
 		return -EINVAL;
 
-	ret = dispc.feat->calc_scaling(pclk, lclk, vm, width, height,
-		out_width, out_height, fourcc, five_taps,
-		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
-		mem_to_mem);
+	ret = dispc->feat->calc_scaling(dispc, pclk, lclk, vm, width, height,
+					out_width, out_height, fourcc,
+					five_taps, x_predecim, y_predecim,
+					&decim_x, &decim_y, pos_x, &core_clk,
+					mem_to_mem);
 	if (ret)
 		return ret;
 
@@ -2463,13 +2547,13 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		out_height / (height / decim_y), DIV_FRAC(out_height, height / decim_y),
 
 		*five_taps ? 5 : 3,
-		core_clk, dispc_core_clk_rate());
+		core_clk, dispc_core_clk_rate(dispc));
 
-	if (!core_clk || core_clk > dispc_core_clk_rate()) {
+	if (!core_clk || core_clk > dispc_core_clk_rate(dispc)) {
 		DSSERR("failed to set up scaling, "
 			"required core clk rate = %lu Hz, "
 			"current core clk rate = %lu Hz\n",
-			core_clk, dispc_core_clk_rate());
+			core_clk, dispc_core_clk_rate(dispc));
 		return -EINVAL;
 	}
 
@@ -2478,14 +2562,18 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	return 0;
 }
 
-static int dispc_ovl_setup_common(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
-		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
-		u16 out_width, u16 out_height, u32 fourcc,
-		u8 rotation, u8 zorder, u8 pre_mult_alpha,
-		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
-		bool replication, const struct videomode *vm,
-		bool mem_to_mem)
+static int dispc_ovl_setup_common(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  enum omap_overlay_caps caps,
+				  u32 paddr, u32 p_uv_addr,
+				  u16 screen_width, int pos_x, int pos_y,
+				  u16 width, u16 height,
+				  u16 out_width, u16 out_height,
+				  u32 fourcc, u8 rotation, u8 zorder,
+				  u8 pre_mult_alpha, u8 global_alpha,
+				  enum omap_dss_rotation_type rotation_type,
+				  bool replication, const struct videomode *vm,
+				  bool mem_to_mem)
 {
 	bool five_taps = true;
 	bool fieldmode = false;
@@ -2499,8 +2587,8 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	u16 in_width = width;
 	int x_predecim = 1, y_predecim = 1;
 	bool ilace = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);
-	unsigned long pclk = dispc_plane_pclk_rate(plane);
-	unsigned long lclk = dispc_plane_lclk_rate(plane);
+	unsigned long pclk = dispc_plane_pclk_rate(dispc, plane);
+	unsigned long lclk = dispc_plane_lclk_rate(dispc, plane);
 
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
@@ -2527,13 +2615,13 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 			out_height);
 	}
 
-	if (!dispc_ovl_color_mode_supported(plane, fourcc))
+	if (!dispc_ovl_color_mode_supported(dispc, plane, fourcc))
 		return -EINVAL;
 
-	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
-			in_height, out_width, out_height, fourcc,
-			&five_taps, &x_predecim, &y_predecim, pos_x,
-			rotation_type, mem_to_mem);
+	r = dispc_ovl_calc_scaling(dispc, pclk, lclk, caps, vm, in_width,
+				   in_height, out_width, out_height, fourcc,
+				   &five_taps, &x_predecim, &y_predecim, pos_x,
+				   rotation_type, mem_to_mem);
 	if (r)
 		return r;
 
@@ -2595,49 +2683,50 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
 
-	dispc_ovl_set_color_mode(plane, fourcc);
+	dispc_ovl_set_color_mode(dispc, plane, fourcc);
 
-	dispc_ovl_configure_burst_type(plane, rotation_type);
+	dispc_ovl_configure_burst_type(dispc, plane, rotation_type);
 
-	if (dispc.feat->reverse_ilace_field_order)
+	if (dispc->feat->reverse_ilace_field_order)
 		swap(offset0, offset1);
 
-	dispc_ovl_set_ba0(plane, paddr + offset0);
-	dispc_ovl_set_ba1(plane, paddr + offset1);
+	dispc_ovl_set_ba0(dispc, plane, paddr + offset0);
+	dispc_ovl_set_ba1(dispc, plane, paddr + offset1);
 
 	if (fourcc == DRM_FORMAT_NV12) {
-		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
-		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
+		dispc_ovl_set_ba0_uv(dispc, plane, p_uv_addr + offset0);
+		dispc_ovl_set_ba1_uv(dispc, plane, p_uv_addr + offset1);
 	}
 
-	if (dispc.feat->last_pixel_inc_missing)
+	if (dispc->feat->last_pixel_inc_missing)
 		row_inc += pix_inc - 1;
 
-	dispc_ovl_set_row_inc(plane, row_inc);
-	dispc_ovl_set_pix_inc(plane, pix_inc);
+	dispc_ovl_set_row_inc(dispc, plane, row_inc);
+	dispc_ovl_set_pix_inc(dispc, plane, pix_inc);
 
 	DSSDBG("%d,%d %dx%d -> %dx%d\n", pos_x, pos_y, in_width,
 			in_height, out_width, out_height);
 
-	dispc_ovl_set_pos(plane, caps, pos_x, pos_y);
+	dispc_ovl_set_pos(dispc, plane, caps, pos_x, pos_y);
 
-	dispc_ovl_set_input_size(plane, in_width, in_height);
+	dispc_ovl_set_input_size(dispc, plane, in_width, in_height);
 
 	if (caps & OMAP_DSS_OVL_CAP_SCALE) {
-		dispc_ovl_set_scaling(plane, in_width, in_height, out_width,
-				   out_height, ilace, five_taps, fieldmode,
-				   fourcc, rotation);
-		dispc_ovl_set_output_size(plane, out_width, out_height);
-		dispc_ovl_set_vid_color_conv(plane, cconv);
+		dispc_ovl_set_scaling(dispc, plane, in_width, in_height,
+				      out_width, out_height, ilace, five_taps,
+				      fieldmode, fourcc, rotation);
+		dispc_ovl_set_output_size(dispc, plane, out_width, out_height);
+		dispc_ovl_set_vid_color_conv(dispc, plane, cconv);
 	}
 
-	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, fourcc);
+	dispc_ovl_set_rotation_attrs(dispc, plane, rotation, rotation_type,
+				     fourcc);
 
-	dispc_ovl_set_zorder(plane, caps, zorder);
-	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
-	dispc_ovl_setup_global_alpha(plane, caps, global_alpha);
+	dispc_ovl_set_zorder(dispc, plane, caps, zorder);
+	dispc_ovl_set_pre_mult_alpha(dispc, plane, caps, pre_mult_alpha);
+	dispc_ovl_setup_global_alpha(dispc, plane, caps, global_alpha);
 
-	dispc_ovl_enable_replication(plane, caps, replication);
+	dispc_ovl_enable_replication(dispc, plane, caps, replication);
 
 	return 0;
 }
@@ -2658,9 +2747,9 @@ static int dispc_ovl_setup(struct dispc_device *dispc,
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
 		oi->fourcc, oi->rotation, channel, replication);
 
-	dispc_ovl_set_channel_out(plane, channel);
+	dispc_ovl_set_channel_out(dispc, plane, channel);
 
-	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
+	r = dispc_ovl_setup_common(dispc, plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
 		oi->out_width, oi->out_height, oi->fourcc, oi->rotation,
 		oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
@@ -2689,7 +2778,7 @@ int dispc_wb_setup(struct dispc_device *dispc,
 		"rot %d\n", wi->paddr, wi->p_uv_addr, in_width,
 		in_height, wi->width, wi->height, wi->fourcc, wi->rotation);
 
-	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
+	r = dispc_ovl_setup_common(dispc, plane, caps, wi->paddr, wi->p_uv_addr,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
 		wi->height, wi->fourcc, wi->rotation, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
@@ -2712,18 +2801,18 @@ int dispc_wb_setup(struct dispc_device *dispc,
 	}
 
 	/* setup extra DISPC_WB_ATTRIBUTES */
-	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	l = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 	l = FLD_MOD(l, truncation, 10, 10);	/* TRUNCATIONENABLE */
 	l = FLD_MOD(l, mem_to_mem, 19, 19);	/* WRITEBACKMODE */
 	if (mem_to_mem)
 		l = FLD_MOD(l, 1, 26, 24);	/* CAPTUREMODE */
 	else
 		l = FLD_MOD(l, 0, 26, 24);	/* CAPTUREMODE */
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);
 
 	if (mem_to_mem) {
 		/* WBDELAYCOUNT */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
 	} else {
 		int wbdelay;
 
@@ -2731,7 +2820,7 @@ int dispc_wb_setup(struct dispc_device *dispc,
 			      vm->vsync_len + vm->vback_porch, (u32)255);
 
 		/* WBDELAYCOUNT */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
 	}
 
 	return r;
@@ -2742,7 +2831,7 @@ static int dispc_ovl_enable(struct dispc_device *dispc,
 {
 	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);
 
 	return 0;
 }
@@ -2754,94 +2843,106 @@ dispc_mgr_get_supported_outputs(struct dispc_device *dispc,
 	return dss_get_supported_outputs(dispc->dss, channel);
 }
 
-static void dispc_lcd_enable_signal_polarity(bool act_high)
+static void dispc_lcd_enable_signal_polarity(struct dispc_device *dispc,
+					     bool act_high)
 {
-	if (!dispc_has_feature(FEAT_LCDENABLEPOL))
+	if (!dispc_has_feature(dispc, FEAT_LCDENABLEPOL))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
 }
 
 void dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_LCDENABLESIGNAL))
+	if (!dispc_has_feature(dispc, FEAT_LCDENABLESIGNAL))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 28, 28);
 }
 
 void dispc_pck_free_enable(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_PCKFREEENABLE))
+	if (!dispc_has_feature(dispc, FEAT_PCKFREEENABLE))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 27, 27);
 }
 
-static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_fifohandcheck(struct dispc_device *dispc,
+					   enum omap_channel channel,
+					   bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
 }
 
 
-static void dispc_mgr_set_lcd_type_tft(enum omap_channel channel)
+static void dispc_mgr_set_lcd_type_tft(struct dispc_device *dispc,
+				       enum omap_channel channel)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_STNTFT, 1);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_STNTFT, 1);
 }
 
-static void dispc_set_loadmode(enum omap_dss_load_mode mode)
+static void dispc_set_loadmode(struct dispc_device *dispc,
+			       enum omap_dss_load_mode mode)
 {
-	REG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, mode, 2, 1);
 }
 
 
-static void dispc_mgr_set_default_color(enum omap_channel channel, u32 color)
+static void dispc_mgr_set_default_color(struct dispc_device *dispc,
+					enum omap_channel channel, u32 color)
 {
-	dispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);
+	dispc_write_reg(dispc, DISPC_DEFAULT_COLOR(channel), color);
 }
 
-static void dispc_mgr_set_trans_key(enum omap_channel ch,
-		enum omap_dss_trans_key_type type,
-		u32 trans_key)
+static void dispc_mgr_set_trans_key(struct dispc_device *dispc,
+				    enum omap_channel ch,
+				    enum omap_dss_trans_key_type type,
+				    u32 trans_key)
 {
-	mgr_fld_write(ch, DISPC_MGR_FLD_TCKSELECTION, type);
+	mgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKSELECTION, type);
 
-	dispc_write_reg(DISPC_TRANS_COLOR(ch), trans_key);
+	dispc_write_reg(dispc, DISPC_TRANS_COLOR(ch), trans_key);
 }
 
-static void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)
+static void dispc_mgr_enable_trans_key(struct dispc_device *dispc,
+				       enum omap_channel ch, bool enable)
 {
-	mgr_fld_write(ch, DISPC_MGR_FLD_TCKENABLE, enable);
+	mgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKENABLE, enable);
 }
 
-static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
-		bool enable)
+static void dispc_mgr_enable_alpha_fixed_zorder(struct dispc_device *dispc,
+						enum omap_channel ch,
+						bool enable)
 {
-	if (!dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER))
+	if (!dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER))
 		return;
 
 	if (ch == OMAP_DSS_CHANNEL_LCD)
-		REG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);
+		REG_FLD_MOD(dispc, DISPC_CONFIG, enable, 18, 18);
 	else if (ch == OMAP_DSS_CHANNEL_DIGIT)
-		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
+		REG_FLD_MOD(dispc, DISPC_CONFIG, enable, 19, 19);
 }
 
 static void dispc_mgr_setup(struct dispc_device *dispc,
 			    enum omap_channel channel,
 			    const struct omap_overlay_manager_info *info)
 {
-	dispc_mgr_set_default_color(channel, info->default_color);
-	dispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);
-	dispc_mgr_enable_trans_key(channel, info->trans_enabled);
-	dispc_mgr_enable_alpha_fixed_zorder(channel,
+	dispc_mgr_set_default_color(dispc, channel, info->default_color);
+	dispc_mgr_set_trans_key(dispc, channel, info->trans_key_type,
+				info->trans_key);
+	dispc_mgr_enable_trans_key(dispc, channel, info->trans_enabled);
+	dispc_mgr_enable_alpha_fixed_zorder(dispc, channel,
 			info->partial_alpha_enabled);
-	if (dispc_has_feature(FEAT_CPR)) {
-		dispc_mgr_enable_cpr(channel, info->cpr_enable);
-		dispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);
+	if (dispc_has_feature(dispc, FEAT_CPR)) {
+		dispc_mgr_enable_cpr(dispc, channel, info->cpr_enable);
+		dispc_mgr_set_cpr_coef(dispc, channel, &info->cpr_coefs);
 	}
 }
 
-static void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)
+static void dispc_mgr_set_tft_data_lines(struct dispc_device *dispc,
+					 enum omap_channel channel,
+					 u8 data_lines)
 {
 	int code;
 
@@ -2863,10 +2964,11 @@ static void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_line
 		return;
 	}
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_TFTDATALINES, code);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_TFTDATALINES, code);
 }
 
-static void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)
+static void dispc_mgr_set_io_pad_mode(struct dispc_device *dispc,
+				      enum dss_io_pad_mode mode)
 {
 	u32 l;
 	int gpout0, gpout1;
@@ -2889,70 +2991,74 @@ static void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)
 		return;
 	}
 
-	l = dispc_read_reg(DISPC_CONTROL);
+	l = dispc_read_reg(dispc, DISPC_CONTROL);
 	l = FLD_MOD(l, gpout0, 15, 15);
 	l = FLD_MOD(l, gpout1, 16, 16);
-	dispc_write_reg(DISPC_CONTROL, l);
+	dispc_write_reg(dispc, DISPC_CONTROL, l);
 }
 
-static void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_stallmode(struct dispc_device *dispc,
+				       enum omap_channel channel, bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_STALLMODE, enable);
 }
 
 static void dispc_mgr_set_lcd_config(struct dispc_device *dispc,
 				     enum omap_channel channel,
 				     const struct dss_lcd_mgr_config *config)
 {
-	dispc_mgr_set_io_pad_mode(config->io_pad_mode);
+	dispc_mgr_set_io_pad_mode(dispc, config->io_pad_mode);
 
-	dispc_mgr_enable_stallmode(channel, config->stallmode);
-	dispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);
+	dispc_mgr_enable_stallmode(dispc, channel, config->stallmode);
+	dispc_mgr_enable_fifohandcheck(dispc, channel, config->fifohandcheck);
 
 	dispc_mgr_set_clock_div(dispc, channel, &config->clock_info);
 
-	dispc_mgr_set_tft_data_lines(channel, config->video_port_width);
+	dispc_mgr_set_tft_data_lines(dispc, channel, config->video_port_width);
 
-	dispc_lcd_enable_signal_polarity(config->lcden_sig_polarity);
+	dispc_lcd_enable_signal_polarity(dispc, config->lcden_sig_polarity);
 
-	dispc_mgr_set_lcd_type_tft(channel);
+	dispc_mgr_set_lcd_type_tft(dispc, channel);
 }
 
-static bool _dispc_mgr_size_ok(u16 width, u16 height)
+static bool _dispc_mgr_size_ok(struct dispc_device *dispc,
+			       u16 width, u16 height)
 {
-	return width <= dispc.feat->mgr_width_max &&
-		height <= dispc.feat->mgr_height_max;
+	return width <= dispc->feat->mgr_width_max &&
+		height <= dispc->feat->mgr_height_max;
 }
 
-static bool _dispc_lcd_timings_ok(int hsync_len, int hfp, int hbp,
-		int vsw, int vfp, int vbp)
+static bool _dispc_lcd_timings_ok(struct dispc_device *dispc,
+				  int hsync_len, int hfp, int hbp,
+				  int vsw, int vfp, int vbp)
 {
-	if (hsync_len < 1 || hsync_len > dispc.feat->sw_max ||
-			hfp < 1 || hfp > dispc.feat->hp_max ||
-			hbp < 1 || hbp > dispc.feat->hp_max ||
-			vsw < 1 || vsw > dispc.feat->sw_max ||
-			vfp < 0 || vfp > dispc.feat->vp_max ||
-			vbp < 0 || vbp > dispc.feat->vp_max)
+	if (hsync_len < 1 || hsync_len > dispc->feat->sw_max ||
+	    hfp < 1 || hfp > dispc->feat->hp_max ||
+	    hbp < 1 || hbp > dispc->feat->hp_max ||
+	    vsw < 1 || vsw > dispc->feat->sw_max ||
+	    vfp < 0 || vfp > dispc->feat->vp_max ||
+	    vbp < 0 || vbp > dispc->feat->vp_max)
 		return false;
 	return true;
 }
 
-static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
-		unsigned long pclk)
+static bool _dispc_mgr_pclk_ok(struct dispc_device *dispc,
+			       enum omap_channel channel,
+			       unsigned long pclk)
 {
 	if (dss_mgr_is_lcd(channel))
-		return pclk <= dispc.feat->max_lcd_pclk;
+		return pclk <= dispc->feat->max_lcd_pclk;
 	else
-		return pclk <= dispc.feat->max_tv_pclk;
+		return pclk <= dispc->feat->max_tv_pclk;
 }
 
 bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
 			  const struct videomode *vm)
 {
-	if (!_dispc_mgr_size_ok(vm->hactive, vm->vactive))
+	if (!_dispc_mgr_size_ok(dispc, vm->hactive, vm->vactive))
 		return false;
 
-	if (!_dispc_mgr_pclk_ok(channel, vm->pixelclock))
+	if (!_dispc_mgr_pclk_ok(dispc, channel, vm->pixelclock))
 		return false;
 
 	if (dss_mgr_is_lcd(channel)) {
@@ -2960,7 +3066,7 @@ bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
 		if (vm->flags & DISPLAY_FLAGS_INTERLACED)
 			return false;
 
-		if (!_dispc_lcd_timings_ok(vm->hsync_len,
+		if (!_dispc_lcd_timings_ok(dispc, vm->hsync_len,
 				vm->hfront_porch, vm->hback_porch,
 				vm->vsync_len, vm->vfront_porch,
 				vm->vback_porch))
@@ -2970,21 +3076,22 @@ bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
 	return true;
 }
 
-static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
+static void _dispc_mgr_set_lcd_timings(struct dispc_device *dispc,
+				       enum omap_channel channel,
 				       const struct videomode *vm)
 {
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
 
-	timing_h = FLD_VAL(vm->hsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(vm->hfront_porch - 1, dispc.feat->fp_start, 8) |
-		   FLD_VAL(vm->hback_porch - 1, dispc.feat->bp_start, 20);
-	timing_v = FLD_VAL(vm->vsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(vm->vfront_porch, dispc.feat->fp_start, 8) |
-		   FLD_VAL(vm->vback_porch, dispc.feat->bp_start, 20);
+	timing_h = FLD_VAL(vm->hsync_len - 1, dispc->feat->sw_start, 0) |
+		   FLD_VAL(vm->hfront_porch - 1, dispc->feat->fp_start, 8) |
+		   FLD_VAL(vm->hback_porch - 1, dispc->feat->bp_start, 20);
+	timing_v = FLD_VAL(vm->vsync_len - 1, dispc->feat->sw_start, 0) |
+		   FLD_VAL(vm->vfront_porch, dispc->feat->fp_start, 8) |
+		   FLD_VAL(vm->vback_porch, dispc->feat->bp_start, 20);
 
-	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
-	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
+	dispc_write_reg(dispc, DISPC_TIMING_H(channel), timing_h);
+	dispc_write_reg(dispc, DISPC_TIMING_V(channel), timing_v);
 
 	if (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)
 		vs = false;
@@ -3022,12 +3129,12 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 		FLD_VAL(vs, 12, 12);
 
 	/* always set ALIGN bit when available */
-	if (dispc.feat->supports_sync_align)
+	if (dispc->feat->supports_sync_align)
 		l |= (1 << 18);
 
-	dispc_write_reg(DISPC_POL_FREQ(channel), l);
+	dispc_write_reg(dispc, DISPC_POL_FREQ(channel), l);
 
-	if (dispc.syscon_pol) {
+	if (dispc->syscon_pol) {
 		const int shifts[] = {
 			[OMAP_DSS_CHANNEL_LCD] = 0,
 			[OMAP_DSS_CHANNEL_LCD2] = 1,
@@ -3042,8 +3149,8 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 		mask <<= 16 + shifts[channel];
 		val <<= 16 + shifts[channel];
 
-		regmap_update_bits(dispc.syscon_pol, dispc.syscon_pol_offset,
-			mask, val);
+		regmap_update_bits(dispc->syscon_pol, dispc->syscon_pol_offset,
+				   mask, val);
 	}
 }
 
@@ -3074,7 +3181,7 @@ static void dispc_mgr_set_timings(struct dispc_device *dispc,
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel, &t);
+		_dispc_mgr_set_lcd_timings(dispc, channel, &t);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
 		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;
@@ -3099,51 +3206,53 @@ static void dispc_mgr_set_timings(struct dispc_device *dispc,
 			t.vactive /= 2;
 
 		if (dispc->feat->supports_double_pixel)
-			REG_FLD_MOD(DISPC_CONTROL,
+			REG_FLD_MOD(dispc, DISPC_CONTROL,
 				    !!(t.flags & DISPLAY_FLAGS_DOUBLECLK),
 				    19, 17);
 	}
 
-	dispc_mgr_set_size(channel, t.hactive, t.vactive);
+	dispc_mgr_set_size(dispc, channel, t.hactive, t.vactive);
 }
 
-static void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,
-		u16 pck_div)
+static void dispc_mgr_set_lcd_divisor(struct dispc_device *dispc,
+				      enum omap_channel channel, u16 lck_div,
+				      u16 pck_div)
 {
 	BUG_ON(lck_div < 1);
 	BUG_ON(pck_div < 1);
 
-	dispc_write_reg(DISPC_DIVISORo(channel),
+	dispc_write_reg(dispc, DISPC_DIVISORo(channel),
 			FLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));
 
-	if (!dispc_has_feature(FEAT_CORE_CLK_DIV) &&
+	if (!dispc_has_feature(dispc, FEAT_CORE_CLK_DIV) &&
 			channel == OMAP_DSS_CHANNEL_LCD)
-		dispc.core_clk_rate = dispc_fclk_rate() / lck_div;
+		dispc->core_clk_rate = dispc_fclk_rate(dispc) / lck_div;
 }
 
-static void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,
-		int *pck_div)
+static void dispc_mgr_get_lcd_divisor(struct dispc_device *dispc,
+				      enum omap_channel channel, int *lck_div,
+				      int *pck_div)
 {
 	u32 l;
-	l = dispc_read_reg(DISPC_DIVISORo(channel));
+	l = dispc_read_reg(dispc, DISPC_DIVISORo(channel));
 	*lck_div = FLD_GET(l, 23, 16);
 	*pck_div = FLD_GET(l, 7, 0);
 }
 
-static unsigned long dispc_fclk_rate(void)
+static unsigned long dispc_fclk_rate(struct dispc_device *dispc)
 {
 	unsigned long r;
 	enum dss_clk_source src;
 
-	src = dss_get_dispc_clk_source(dispc.dss);
+	src = dss_get_dispc_clk_source(dispc->dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate(dispc.dss);
+		r = dss_get_dispc_clk_rate(dispc->dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(dispc.dss, src);
+		pll = dss_pll_find_by_src(dispc->dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];
@@ -3152,7 +3261,8 @@ static unsigned long dispc_fclk_rate(void)
 	return r;
 }
 
-static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
+static unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel)
 {
 	int lcd;
 	unsigned long r;
@@ -3160,28 +3270,29 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 
 	/* for TV, LCLK rate is the FCLK rate */
 	if (!dss_mgr_is_lcd(channel))
-		return dispc_fclk_rate();
+		return dispc_fclk_rate(dispc);
 
-	src = dss_get_lcd_clk_source(dispc.dss, channel);
+	src = dss_get_lcd_clk_source(dispc->dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate(dispc.dss);
+		r = dss_get_dispc_clk_rate(dispc->dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(dispc.dss, src);
+		pll = dss_pll_find_by_src(dispc->dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];
 	}
 
-	lcd = REG_GET(DISPC_DIVISORo(channel), 23, 16);
+	lcd = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);
 
 	return r / lcd;
 }
 
-static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)
+static unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel)
 {
 	unsigned long r;
 
@@ -3189,15 +3300,15 @@ static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)
 		int pcd;
 		u32 l;
 
-		l = dispc_read_reg(DISPC_DIVISORo(channel));
+		l = dispc_read_reg(dispc, DISPC_DIVISORo(channel));
 
 		pcd = FLD_GET(l, 7, 0);
 
-		r = dispc_mgr_lclk_rate(channel);
+		r = dispc_mgr_lclk_rate(dispc, channel);
 
 		return r / pcd;
 	} else {
-		return dispc.tv_pclk_rate;
+		return dispc->tv_pclk_rate;
 	}
 }
 
@@ -3206,53 +3317,57 @@ void dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk)
 	dispc->tv_pclk_rate = pclk;
 }
 
-static unsigned long dispc_core_clk_rate(void)
+static unsigned long dispc_core_clk_rate(struct dispc_device *dispc)
 {
-	return dispc.core_clk_rate;
+	return dispc->core_clk_rate;
 }
 
-static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane)
+static unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 
 	if (plane == OMAP_DSS_WB)
 		return 0;
 
-	channel = dispc_ovl_get_channel_out(plane);
+	channel = dispc_ovl_get_channel_out(dispc, plane);
 
-	return dispc_mgr_pclk_rate(channel);
+	return dispc_mgr_pclk_rate(dispc, channel);
 }
 
-static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane)
+static unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 
 	if (plane == OMAP_DSS_WB)
 		return 0;
 
-	channel	= dispc_ovl_get_channel_out(plane);
+	channel	= dispc_ovl_get_channel_out(dispc, plane);
 
-	return dispc_mgr_lclk_rate(channel);
+	return dispc_mgr_lclk_rate(dispc, channel);
 }
 
-static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)
+static void dispc_dump_clocks_channel(struct dispc_device *dispc,
+				      struct seq_file *s,
+				      enum omap_channel channel)
 {
 	int lcd, pcd;
 	enum dss_clk_source lcd_clk_src;
 
 	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
 
-	lcd_clk_src = dss_get_lcd_clk_source(dispc.dss, channel);
+	lcd_clk_src = dss_get_lcd_clk_source(dispc->dss, channel);
 
 	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
 		dss_get_clk_source_name(lcd_clk_src));
 
-	dispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);
+	dispc_mgr_get_lcd_divisor(dispc, channel, &lcd, &pcd);
 
 	seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
-		dispc_mgr_lclk_rate(channel), lcd);
+		dispc_mgr_lclk_rate(dispc, channel), lcd);
 	seq_printf(s, "pck\t\t%-16lupck div\t%u\n",
-		dispc_mgr_pclk_rate(channel), pcd);
+		dispc_mgr_pclk_rate(dispc, channel), pcd);
 }
 
 void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)
@@ -3270,29 +3385,30 @@ void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)
 	seq_printf(s, "dispc fclk source = %s\n",
 			dss_get_clk_source_name(dispc_clk_src));
 
-	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
+	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate(dispc));
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {
 		seq_printf(s, "- DISPC-CORE-CLK -\n");
-		l = dispc_read_reg(DISPC_DIVISOR);
+		l = dispc_read_reg(dispc, DISPC_DIVISOR);
 		lcd = FLD_GET(l, 23, 16);
 
 		seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
-				(dispc_fclk_rate()/lcd), lcd);
+				(dispc_fclk_rate(dispc)/lcd), lcd);
 	}
 
-	dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);
+	dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD);
 
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD3);
 
 	dispc_runtime_put(dispc);
 }
 
 static int dispc_dump_regs(struct seq_file *s, void *p)
 {
+	struct dispc_device *dispc = s->private;
 	int i, j;
 	const char *mgr_names[] = {
 		[OMAP_DSS_CHANNEL_LCD]		= "LCD",
@@ -3309,178 +3425,179 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 	};
 	const char **p_names;
 
-#define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))
+#define DUMPREG(dispc, r) \
+	seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(dispc, r))
 
-	if (dispc_runtime_get(&dispc))
+	if (dispc_runtime_get(dispc))
 		return 0;
 
 	/* DISPC common registers */
-	DUMPREG(DISPC_REVISION);
-	DUMPREG(DISPC_SYSCONFIG);
-	DUMPREG(DISPC_SYSSTATUS);
-	DUMPREG(DISPC_IRQSTATUS);
-	DUMPREG(DISPC_IRQENABLE);
-	DUMPREG(DISPC_CONTROL);
-	DUMPREG(DISPC_CONFIG);
-	DUMPREG(DISPC_CAPABLE);
-	DUMPREG(DISPC_LINE_STATUS);
-	DUMPREG(DISPC_LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		DUMPREG(DISPC_GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
-		DUMPREG(DISPC_CONTROL2);
-		DUMPREG(DISPC_CONFIG2);
+	DUMPREG(dispc, DISPC_REVISION);
+	DUMPREG(dispc, DISPC_SYSCONFIG);
+	DUMPREG(dispc, DISPC_SYSSTATUS);
+	DUMPREG(dispc, DISPC_IRQSTATUS);
+	DUMPREG(dispc, DISPC_IRQENABLE);
+	DUMPREG(dispc, DISPC_CONTROL);
+	DUMPREG(dispc, DISPC_CONFIG);
+	DUMPREG(dispc, DISPC_CAPABLE);
+	DUMPREG(dispc, DISPC_LINE_STATUS);
+	DUMPREG(dispc, DISPC_LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		DUMPREG(dispc, DISPC_GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
+		DUMPREG(dispc, DISPC_CONTROL2);
+		DUMPREG(dispc, DISPC_CONFIG2);
 	}
-	if (dispc_has_feature(FEAT_MGR_LCD3)) {
-		DUMPREG(DISPC_CONTROL3);
-		DUMPREG(DISPC_CONFIG3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
+		DUMPREG(dispc, DISPC_CONTROL3);
+		DUMPREG(dispc, DISPC_CONFIG3);
 	}
-	if (dispc_has_feature(FEAT_MFLAG))
-		DUMPREG(DISPC_GLOBAL_MFLAG_ATTRIBUTE);
+	if (dispc_has_feature(dispc, FEAT_MFLAG))
+		DUMPREG(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE);
 
 #undef DUMPREG
 
 #define DISPC_REG(i, name) name(i)
-#define DUMPREG(i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \
+#define DUMPREG(dispc, i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \
 	(int)(48 - strlen(#r) - strlen(p_names[i])), " ", \
-	dispc_read_reg(DISPC_REG(i, r)))
+	dispc_read_reg(dispc, DISPC_REG(i, r)))
 
 	p_names = mgr_names;
 
 	/* DISPC channel specific registers */
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		DUMPREG(i, DISPC_DEFAULT_COLOR);
-		DUMPREG(i, DISPC_TRANS_COLOR);
-		DUMPREG(i, DISPC_SIZE_MGR);
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		DUMPREG(dispc, i, DISPC_DEFAULT_COLOR);
+		DUMPREG(dispc, i, DISPC_TRANS_COLOR);
+		DUMPREG(dispc, i, DISPC_SIZE_MGR);
 
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
 
-		DUMPREG(i, DISPC_TIMING_H);
-		DUMPREG(i, DISPC_TIMING_V);
-		DUMPREG(i, DISPC_POL_FREQ);
-		DUMPREG(i, DISPC_DIVISORo);
+		DUMPREG(dispc, i, DISPC_TIMING_H);
+		DUMPREG(dispc, i, DISPC_TIMING_V);
+		DUMPREG(dispc, i, DISPC_POL_FREQ);
+		DUMPREG(dispc, i, DISPC_DIVISORo);
 
-		DUMPREG(i, DISPC_DATA_CYCLE1);
-		DUMPREG(i, DISPC_DATA_CYCLE2);
-		DUMPREG(i, DISPC_DATA_CYCLE3);
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE1);
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE2);
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE3);
 
-		if (dispc_has_feature(FEAT_CPR)) {
-			DUMPREG(i, DISPC_CPR_COEF_R);
-			DUMPREG(i, DISPC_CPR_COEF_G);
-			DUMPREG(i, DISPC_CPR_COEF_B);
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			DUMPREG(dispc, i, DISPC_CPR_COEF_R);
+			DUMPREG(dispc, i, DISPC_CPR_COEF_G);
+			DUMPREG(dispc, i, DISPC_CPR_COEF_B);
 		}
 	}
 
 	p_names = ovl_names;
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		DUMPREG(i, DISPC_OVL_BA0);
-		DUMPREG(i, DISPC_OVL_BA1);
-		DUMPREG(i, DISPC_OVL_POSITION);
-		DUMPREG(i, DISPC_OVL_SIZE);
-		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
-		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
-		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
-		DUMPREG(i, DISPC_OVL_ROW_INC);
-		DUMPREG(i, DISPC_OVL_PIXEL_INC);
-
-		if (dispc_has_feature(FEAT_PRELOAD))
-			DUMPREG(i, DISPC_OVL_PRELOAD);
-		if (dispc_has_feature(FEAT_MFLAG))
-			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		DUMPREG(dispc, i, DISPC_OVL_BA0);
+		DUMPREG(dispc, i, DISPC_OVL_BA1);
+		DUMPREG(dispc, i, DISPC_OVL_POSITION);
+		DUMPREG(dispc, i, DISPC_OVL_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(dispc, i, DISPC_OVL_ROW_INC);
+		DUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);
+
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			DUMPREG(dispc, i, DISPC_OVL_PRELOAD);
+		if (dispc_has_feature(dispc, FEAT_MFLAG))
+			DUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);
 
 		if (i == OMAP_DSS_GFX) {
-			DUMPREG(i, DISPC_OVL_WINDOW_SKIP);
-			DUMPREG(i, DISPC_OVL_TABLE_BA);
+			DUMPREG(dispc, i, DISPC_OVL_WINDOW_SKIP);
+			DUMPREG(dispc, i, DISPC_OVL_TABLE_BA);
 			continue;
 		}
 
-		DUMPREG(i, DISPC_OVL_FIR);
-		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
-		DUMPREG(i, DISPC_OVL_ACCU0);
-		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			DUMPREG(i, DISPC_OVL_BA0_UV);
-			DUMPREG(i, DISPC_OVL_BA1_UV);
-			DUMPREG(i, DISPC_OVL_FIR2);
-			DUMPREG(i, DISPC_OVL_ACCU2_0);
-			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		DUMPREG(dispc, i, DISPC_OVL_FIR);
+		DUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU0);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU1);
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(dispc, i, DISPC_OVL_BA0_UV);
+			DUMPREG(dispc, i, DISPC_OVL_BA1_UV);
+			DUMPREG(dispc, i, DISPC_OVL_FIR2);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_0);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_1);
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);
 	}
 
-	if (dispc.feat->has_writeback) {
+	if (dispc->feat->has_writeback) {
 		i = OMAP_DSS_WB;
-		DUMPREG(i, DISPC_OVL_BA0);
-		DUMPREG(i, DISPC_OVL_BA1);
-		DUMPREG(i, DISPC_OVL_SIZE);
-		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
-		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
-		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
-		DUMPREG(i, DISPC_OVL_ROW_INC);
-		DUMPREG(i, DISPC_OVL_PIXEL_INC);
-
-		if (dispc_has_feature(FEAT_MFLAG))
-			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
-
-		DUMPREG(i, DISPC_OVL_FIR);
-		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
-		DUMPREG(i, DISPC_OVL_ACCU0);
-		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			DUMPREG(i, DISPC_OVL_BA0_UV);
-			DUMPREG(i, DISPC_OVL_BA1_UV);
-			DUMPREG(i, DISPC_OVL_FIR2);
-			DUMPREG(i, DISPC_OVL_ACCU2_0);
-			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		DUMPREG(dispc, i, DISPC_OVL_BA0);
+		DUMPREG(dispc, i, DISPC_OVL_BA1);
+		DUMPREG(dispc, i, DISPC_OVL_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(dispc, i, DISPC_OVL_ROW_INC);
+		DUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);
+
+		if (dispc_has_feature(dispc, FEAT_MFLAG))
+			DUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);
+
+		DUMPREG(dispc, i, DISPC_OVL_FIR);
+		DUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU0);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU1);
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(dispc, i, DISPC_OVL_BA0_UV);
+			DUMPREG(dispc, i, DISPC_OVL_BA1_UV);
+			DUMPREG(dispc, i, DISPC_OVL_FIR2);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_0);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_1);
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);
 	}
 
 #undef DISPC_REG
 #undef DUMPREG
 
 #define DISPC_REG(plane, name, i) name(plane, i)
-#define DUMPREG(plane, name, i) \
+#define DUMPREG(dispc, plane, name, i) \
 	seq_printf(s, "%s_%d(%s)%*s %08x\n", #name, i, p_names[plane], \
 	(int)(46 - strlen(#name) - strlen(p_names[plane])), " ", \
-	dispc_read_reg(DISPC_REG(plane, name, i)))
+	dispc_read_reg(dispc, DISPC_REG(plane, name, i)))
 
 	/* Video pipeline coefficient registers */
 
 	/* start from OMAP_DSS_VIDEO1 */
-	for (i = 1; i < dispc_get_num_ovls(&dispc); i++) {
+	for (i = 1; i < dispc_get_num_ovls(dispc); i++) {
 		for (j = 0; j < 8; j++)
-			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
+			DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H, j);
 
 		for (j = 0; j < 8; j++)
-			DUMPREG(i, DISPC_OVL_FIR_COEF_HV, j);
+			DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV, j);
 
 		for (j = 0; j < 5; j++)
-			DUMPREG(i, DISPC_OVL_CONV_COEF, j);
+			DUMPREG(dispc, i, DISPC_OVL_CONV_COEF, j);
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_V, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V, j);
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H2, j);
 
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_HV2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV2, j);
 
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V2, j);
 		}
 	}
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 
 #undef DISPC_REG
 #undef DUMPREG
@@ -3548,8 +3665,8 @@ bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,
 			 * also. Thus we need to use the calculated lck. For
 			 * OMAP4+ the DISPC fclk is a separate clock.
 			 */
-			if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-				fck = dispc_core_clk_rate();
+			if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+				fck = dispc_core_clk_rate(dispc);
 			else
 				fck = lck;
 
@@ -3571,7 +3688,8 @@ void dispc_mgr_set_clock_div(struct dispc_device *dispc,
 	DSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);
 	DSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);
 
-	dispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);
+	dispc_mgr_set_lcd_divisor(dispc, channel, cinfo->lck_div,
+				  cinfo->pck_div);
 }
 
 int dispc_mgr_get_clock_div(struct dispc_device *dispc,
@@ -3580,10 +3698,10 @@ int dispc_mgr_get_clock_div(struct dispc_device *dispc,
 {
 	unsigned long fck;
 
-	fck = dispc_fclk_rate();
+	fck = dispc_fclk_rate(dispc);
 
-	cinfo->lck_div = REG_GET(DISPC_DIVISORo(channel), 23, 16);
-	cinfo->pck_div = REG_GET(DISPC_DIVISORo(channel), 7, 0);
+	cinfo->lck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);
+	cinfo->pck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 7, 0);
 
 	cinfo->lck = fck / cinfo->lck_div;
 	cinfo->pck = cinfo->lck / cinfo->pck_div;
@@ -3593,35 +3711,36 @@ int dispc_mgr_get_clock_div(struct dispc_device *dispc,
 
 static u32 dispc_read_irqstatus(struct dispc_device *dispc)
 {
-	return dispc_read_reg(DISPC_IRQSTATUS);
+	return dispc_read_reg(dispc, DISPC_IRQSTATUS);
 }
 
 static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask)
 {
-	dispc_write_reg(DISPC_IRQSTATUS, mask);
+	dispc_write_reg(dispc, DISPC_IRQSTATUS, mask);
 }
 
 static void dispc_write_irqenable(struct dispc_device *dispc, u32 mask)
 {
-	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
+	u32 old_mask = dispc_read_reg(dispc, DISPC_IRQENABLE);
 
 	/* clear the irqstatus for newly enabled irqs */
 	dispc_clear_irqstatus(dispc, (mask ^ old_mask) & mask);
 
-	dispc_write_reg(DISPC_IRQENABLE, mask);
+	dispc_write_reg(dispc, DISPC_IRQENABLE, mask);
 
 	/* flush posted write */
-	dispc_read_reg(DISPC_IRQENABLE);
+	dispc_read_reg(dispc, DISPC_IRQENABLE);
 }
 
 void dispc_enable_sidle(struct dispc_device *dispc)
 {
-	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
+	/* SIDLEMODE: smart idle */
+	REG_FLD_MOD(dispc, DISPC_SYSCONFIG, 2, 4, 3);
 }
 
 void dispc_disable_sidle(struct dispc_device *dispc)
 {
-	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
+	REG_FLD_MOD(dispc, DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
 static u32 dispc_mgr_gamma_size(struct dispc_device *dispc,
@@ -3635,10 +3754,11 @@ static u32 dispc_mgr_gamma_size(struct dispc_device *dispc,
 	return gdesc->len;
 }
 
-static void dispc_mgr_write_gamma_table(enum omap_channel channel)
+static void dispc_mgr_write_gamma_table(struct dispc_device *dispc,
+					enum omap_channel channel)
 {
 	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
-	u32 *table = dispc.gamma_table[channel];
+	u32 *table = dispc->gamma_table[channel];
 	unsigned int i;
 
 	DSSDBG("%s: channel %d\n", __func__, channel);
@@ -3651,26 +3771,26 @@ static void dispc_mgr_write_gamma_table(enum omap_channel channel)
 		else if (i == 0)
 			v |= 1 << 31;
 
-		dispc_write_reg(gdesc->reg, v);
+		dispc_write_reg(dispc, gdesc->reg, v);
 	}
 }
 
-static void dispc_restore_gamma_tables(void)
+static void dispc_restore_gamma_tables(struct dispc_device *dispc)
 {
 	DSSDBG("%s()\n", __func__);
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return;
 
-	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD);
+	dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD);
 
-	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_DIGIT);
+	dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_DIGIT);
 
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD2);
 
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD3);
 }
 
 static const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {
@@ -3723,81 +3843,82 @@ static void dispc_mgr_set_gamma(struct dispc_device *dispc,
 	}
 
 	if (dispc->is_enabled)
-		dispc_mgr_write_gamma_table(channel);
+		dispc_mgr_write_gamma_table(dispc, channel);
 }
 
-static int dispc_init_gamma_tables(void)
+static int dispc_init_gamma_tables(struct dispc_device *dispc)
 {
 	int channel;
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return 0;
 
-	for (channel = 0; channel < ARRAY_SIZE(dispc.gamma_table); channel++) {
+	for (channel = 0; channel < ARRAY_SIZE(dispc->gamma_table); channel++) {
 		const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
 		u32 *gt;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD2 &&
-		    !dispc_has_feature(FEAT_MGR_LCD2))
+		    !dispc_has_feature(dispc, FEAT_MGR_LCD2))
 			continue;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD3 &&
-		    !dispc_has_feature(FEAT_MGR_LCD3))
+		    !dispc_has_feature(dispc, FEAT_MGR_LCD3))
 			continue;
 
-		gt = devm_kmalloc_array(&dispc.pdev->dev, gdesc->len,
-					   sizeof(u32), GFP_KERNEL);
+		gt = devm_kmalloc_array(&dispc->pdev->dev, gdesc->len,
+					sizeof(u32), GFP_KERNEL);
 		if (!gt)
 			return -ENOMEM;
 
-		dispc.gamma_table[channel] = gt;
+		dispc->gamma_table[channel] = gt;
 
-		dispc_mgr_set_gamma(&dispc, channel, NULL, 0);
+		dispc_mgr_set_gamma(dispc, channel, NULL, 0);
 	}
 	return 0;
 }
 
-static void _omap_dispc_initial_config(void)
+static void _omap_dispc_initial_config(struct dispc_device *dispc)
 {
 	u32 l;
 
 	/* Exclusively enable DISPC_CORE_CLK and set divider to 1 */
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
-		l = dispc_read_reg(DISPC_DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {
+		l = dispc_read_reg(dispc, DISPC_DIVISOR);
 		/* Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */
 		l = FLD_MOD(l, 1, 0, 0);
 		l = FLD_MOD(l, 1, 23, 16);
-		dispc_write_reg(DISPC_DIVISOR, l);
+		dispc_write_reg(dispc, DISPC_DIVISOR, l);
 
-		dispc.core_clk_rate = dispc_fclk_rate();
+		dispc->core_clk_rate = dispc_fclk_rate(dispc);
 	}
 
 	/* Use gamma table mode, instead of palette mode */
-	if (dispc.feat->has_gamma_table)
-		REG_FLD_MOD(DISPC_CONFIG, 1, 3, 3);
+	if (dispc->feat->has_gamma_table)
+		REG_FLD_MOD(dispc, DISPC_CONFIG, 1, 3, 3);
 
 	/* For older DSS versions (FEAT_FUNCGATED) this enables
 	 * func-clock auto-gating. For newer versions
-	 * (dispc.feat->has_gamma_table) this enables tv-out gamma tables.
+	 * (dispc->feat->has_gamma_table) this enables tv-out gamma tables.
 	 */
-	if (dispc_has_feature(FEAT_FUNCGATED) || dispc.feat->has_gamma_table)
-		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
+	if (dispc_has_feature(dispc, FEAT_FUNCGATED) ||
+	    dispc->feat->has_gamma_table)
+		REG_FLD_MOD(dispc, DISPC_CONFIG, 1, 9, 9);
 
-	dispc_setup_color_conv_coef();
+	dispc_setup_color_conv_coef(dispc);
 
-	dispc_set_loadmode(OMAP_DSS_LOAD_FRAME_ONLY);
+	dispc_set_loadmode(dispc, OMAP_DSS_LOAD_FRAME_ONLY);
 
-	dispc_init_fifos();
+	dispc_init_fifos(dispc);
 
-	dispc_configure_burst_sizes();
+	dispc_configure_burst_sizes(dispc);
 
-	dispc_ovl_enable_zorder_planes();
+	dispc_ovl_enable_zorder_planes(dispc);
 
-	if (dispc.feat->mstandby_workaround)
-		REG_FLD_MOD(DISPC_MSTANDBY_CTRL, 1, 0, 0);
+	if (dispc->feat->mstandby_workaround)
+		REG_FLD_MOD(dispc, DISPC_MSTANDBY_CTRL, 1, 0, 0);
 
-	if (dispc_has_feature(FEAT_MFLAG))
-		dispc_init_mflag();
+	if (dispc_has_feature(dispc, FEAT_MFLAG))
+		dispc_init_mflag(dispc);
 }
 
 static const enum dispc_feature_id omap2_dispc_features_list[] = {
@@ -4316,10 +4437,12 @@ static const struct dispc_features omap54xx_dispc_feats = {
 
 static irqreturn_t dispc_irq_handler(int irq, void *arg)
 {
-	if (!dispc.is_enabled)
+	struct dispc_device *dispc = arg;
+
+	if (!dispc->is_enabled)
 		return IRQ_NONE;
 
-	return dispc.user_handler(irq, dispc.user_data);
+	return dispc->user_handler(irq, dispc->user_data);
 }
 
 static int dispc_request_irq(struct dispc_device *dispc, irq_handler_t handler,
@@ -4436,18 +4559,19 @@ static struct i734_buf {
 	void *vaddr;
 } i734_buf;
 
-static int dispc_errata_i734_wa_init(void)
+static int dispc_errata_i734_wa_init(struct dispc_device *dispc)
 {
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return 0;
 
 	i734_buf.size = i734.ovli.width * i734.ovli.height *
 		color_mode_to_bpp(i734.ovli.fourcc) / 8;
 
-	i734_buf.vaddr = dma_alloc_writecombine(&dispc.pdev->dev, i734_buf.size,
-						&i734_buf.paddr, GFP_KERNEL);
+	i734_buf.vaddr = dma_alloc_writecombine(&dispc->pdev->dev,
+						i734_buf.size, &i734_buf.paddr,
+						GFP_KERNEL);
 	if (!i734_buf.vaddr) {
-		dev_err(&dispc.pdev->dev, "%s: dma_alloc_writecombine failed",
+		dev_err(&dispc->pdev->dev, "%s: dma_alloc_writecombine failed",
 			__func__);
 		return -ENOMEM;
 	}
@@ -4455,73 +4579,73 @@ static int dispc_errata_i734_wa_init(void)
 	return 0;
 }
 
-static void dispc_errata_i734_wa_fini(void)
+static void dispc_errata_i734_wa_fini(struct dispc_device *dispc)
 {
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return;
 
-	dma_free_writecombine(&dispc.pdev->dev, i734_buf.size, i734_buf.vaddr,
+	dma_free_writecombine(&dispc->pdev->dev, i734_buf.size, i734_buf.vaddr,
 			      i734_buf.paddr);
 }
 
-static void dispc_errata_i734_wa(void)
+static void dispc_errata_i734_wa(struct dispc_device *dispc)
 {
-	u32 framedone_irq = dispc_mgr_get_framedone_irq(&dispc,
+	u32 framedone_irq = dispc_mgr_get_framedone_irq(dispc,
 							OMAP_DSS_CHANNEL_LCD);
 	struct omap_overlay_info ovli;
 	struct dss_lcd_mgr_config lcd_conf;
 	u32 gatestate;
 	unsigned int count;
 
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return;
 
-	gatestate = REG_GET(DISPC_CONFIG, 8, 4);
+	gatestate = REG_GET(dispc, DISPC_CONFIG, 8, 4);
 
 	ovli = i734.ovli;
 	ovli.paddr = i734_buf.paddr;
 	lcd_conf = i734.lcd_conf;
 
 	/* Gate all LCD1 outputs */
-	REG_FLD_MOD(DISPC_CONFIG, 0x1f, 8, 4);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, 0x1f, 8, 4);
 
 	/* Setup and enable GFX plane */
-	dispc_ovl_setup(&dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,
+	dispc_ovl_setup(dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,
 			OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, true);
+	dispc_ovl_enable(dispc, OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */
-	dispc_mgr_setup(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(&dispc, dss_get_dispc_clk_rate(dispc.dss),
+	dispc_mgr_setup(dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
+	dispc_calc_clock_rates(dispc, dss_get_dispc_clk_rate(dispc->dss),
 			       &lcd_conf.clock_info);
-	dispc_mgr_set_lcd_config(&dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
-	dispc_mgr_set_timings(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
+	dispc_mgr_set_lcd_config(dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
+	dispc_mgr_set_timings(dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
 
-	dispc_clear_irqstatus(&dispc, framedone_irq);
+	dispc_clear_irqstatus(dispc, framedone_irq);
 
 	/* Enable and shut the channel to produce just one frame */
-	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, true);
-	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, false);
+	dispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, true);
+	dispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, false);
 
 	/* Busy wait for framedone. We can't fiddle with irq handlers
 	 * in PM resume. Typically the loop runs less than 5 times and
 	 * waits less than a micro second.
 	 */
 	count = 0;
-	while (!(dispc_read_irqstatus(&dispc) & framedone_irq)) {
+	while (!(dispc_read_irqstatus(dispc) & framedone_irq)) {
 		if (count++ > 10000) {
-			dev_err(&dispc.pdev->dev, "%s: framedone timeout\n",
+			dev_err(&dispc->pdev->dev, "%s: framedone timeout\n",
 				__func__);
 			break;
 		}
 	}
-	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, false);
+	dispc_ovl_enable(dispc, OMAP_DSS_GFX, false);
 
 	/* Clear all irq bits before continuing */
-	dispc_clear_irqstatus(&dispc, 0xffffffff);
+	dispc_clear_irqstatus(dispc, 0xffffffff);
 
 	/* Restore the original state to LCD1 output gates */
-	REG_FLD_MOD(DISPC_CONFIG, gatestate, 8, 4);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, gatestate, 8, 4);
 }
 
 static const struct dispc_ops dispc_ops = {
@@ -4583,15 +4707,21 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	struct platform_device *pdev = to_platform_device(dev);
 	const struct soc_device_attribute *soc;
 	struct dss_device *dss = dss_get_device(master);
+	struct dispc_device *dispc;
 	u32 rev;
 	int r = 0;
 	struct resource *dispc_mem;
 	struct device_node *np = pdev->dev.of_node;
 
-	dispc.pdev = pdev;
-	dispc.dss = dss;
+	dispc = kzalloc(sizeof(*dispc), GFP_KERNEL);
+	if (!dispc)
+		return -ENOMEM;
+
+	dispc->pdev = pdev;
+	platform_set_drvdata(pdev, dispc);
+	dispc->dss = dss;
 
-	spin_lock_init(&dispc.control_lock);
+	spin_lock_init(&dispc->control_lock);
 
 	/*
 	 * The OMAP3-based models can't be told apart using the compatible
@@ -4599,82 +4729,92 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	 */
 	soc = soc_device_match(dispc_soc_devices);
 	if (soc)
-		dispc.feat = soc->data;
+		dispc->feat = soc->data;
 	else
-		dispc.feat = of_match_device(dispc_of_match, &pdev->dev)->data;
+		dispc->feat = of_match_device(dispc_of_match, &pdev->dev)->data;
 
-	r = dispc_errata_i734_wa_init();
+	r = dispc_errata_i734_wa_init(dispc);
 	if (r)
-		return r;
+		goto err_free;
 
-	dispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);
-	dispc.base = devm_ioremap_resource(&pdev->dev, dispc_mem);
-	if (IS_ERR(dispc.base))
-		return PTR_ERR(dispc.base);
+	dispc_mem = platform_get_resource(dispc->pdev, IORESOURCE_MEM, 0);
+	dispc->base = devm_ioremap_resource(&pdev->dev, dispc_mem);
+	if (IS_ERR(dispc->base)) {
+		r = PTR_ERR(dispc->base);
+		goto err_free;
+	}
 
-	dispc.irq = platform_get_irq(dispc.pdev, 0);
-	if (dispc.irq < 0) {
+	dispc->irq = platform_get_irq(dispc->pdev, 0);
+	if (dispc->irq < 0) {
 		DSSERR("platform_get_irq failed\n");
-		return -ENODEV;
+		r = -ENODEV;
+		goto err_free;
 	}
 
 	if (np && of_property_read_bool(np, "syscon-pol")) {
-		dispc.syscon_pol = syscon_regmap_lookup_by_phandle(np, "syscon-pol");
-		if (IS_ERR(dispc.syscon_pol)) {
+		dispc->syscon_pol = syscon_regmap_lookup_by_phandle(np, "syscon-pol");
+		if (IS_ERR(dispc->syscon_pol)) {
 			dev_err(&pdev->dev, "failed to get syscon-pol regmap\n");
-			return PTR_ERR(dispc.syscon_pol);
+			r = PTR_ERR(dispc->syscon_pol);
+			goto err_free;
 		}
 
 		if (of_property_read_u32_index(np, "syscon-pol", 1,
-				&dispc.syscon_pol_offset)) {
+				&dispc->syscon_pol_offset)) {
 			dev_err(&pdev->dev, "failed to get syscon-pol offset\n");
-			return -EINVAL;
+			r = -EINVAL;
+			goto err_free;
 		}
 	}
 
-	r = dispc_init_gamma_tables();
+	r = dispc_init_gamma_tables(dispc);
 	if (r)
-		return r;
+		goto err_free;
 
 	pm_runtime_enable(&pdev->dev);
 
-	r = dispc_runtime_get(&dispc);
+	r = dispc_runtime_get(dispc);
 	if (r)
 		goto err_runtime_get;
 
-	_omap_dispc_initial_config();
+	_omap_dispc_initial_config(dispc);
 
-	rev = dispc_read_reg(DISPC_REVISION);
+	rev = dispc_read_reg(dispc, DISPC_REVISION);
 	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
 	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 
-	dss->dispc = &dispc;
+	dss->dispc = dispc;
 	dss->dispc_ops = &dispc_ops;
 
-	dispc.debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
-						&dispc);
+	dispc->debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
+						 dispc);
 
 	return 0;
 
 err_runtime_get:
 	pm_runtime_disable(&pdev->dev);
+err_free:
+	kfree(dispc);
 	return r;
 }
 
 static void dispc_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct dss_device *dss = dispc.dss;
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+	struct dss_device *dss = dispc->dss;
 
-	dss_debugfs_remove_file(dispc.debugfs);
+	dss_debugfs_remove_file(dispc->debugfs);
 
 	dss->dispc = NULL;
 	dss->dispc_ops = NULL;
 
 	pm_runtime_disable(dev);
 
-	dispc_errata_i734_wa_fini();
+	dispc_errata_i734_wa_fini(dispc);
+
+	kfree(dispc);
 }
 
 static const struct component_ops dispc_component_ops = {
@@ -4695,36 +4835,40 @@ static int dispc_remove(struct platform_device *pdev)
 
 static int dispc_runtime_suspend(struct device *dev)
 {
-	dispc.is_enabled = false;
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+
+	dispc->is_enabled = false;
 	/* ensure the dispc_irq_handler sees the is_enabled value */
 	smp_wmb();
 	/* wait for current handler to finish before turning the DISPC off */
-	synchronize_irq(dispc.irq);
+	synchronize_irq(dispc->irq);
 
-	dispc_save_context();
+	dispc_save_context(dispc);
 
 	return 0;
 }
 
 static int dispc_runtime_resume(struct device *dev)
 {
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+
 	/*
 	 * The reset value for load mode is 0 (OMAP_DSS_LOAD_CLUT_AND_FRAME)
 	 * but we always initialize it to 2 (OMAP_DSS_LOAD_FRAME_ONLY) in
 	 * _omap_dispc_initial_config(). We can thus use it to detect if
 	 * we have lost register context.
 	 */
-	if (REG_GET(DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
-		_omap_dispc_initial_config();
+	if (REG_GET(dispc, DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
+		_omap_dispc_initial_config(dispc);
 
-		dispc_errata_i734_wa();
+		dispc_errata_i734_wa(dispc);
 
-		dispc_restore_context();
+		dispc_restore_context(dispc);
 
-		dispc_restore_gamma_tables();
+		dispc_restore_gamma_tables(dispc);
 	}
 
-	dispc.is_enabled = true;
+	dispc->is_enabled = true;
 	/* ensure the dispc_irq_handler sees the is_enabled value */
 	smp_wmb();
 

commit 8a7eda7686675b73d74c22c0d5b83059f9d783f6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:43 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to remaining dispc API functions
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 6d8228f976f9..bd014bfc1cb6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -704,7 +704,7 @@ static u32 dispc_mgr_get_sync_lost_irq(struct dispc_device *dispc,
 	return mgr_desc[channel].sync_lost_irq;
 }
 
-u32 dispc_wb_get_framedone_irq(void)
+u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)
 {
 	return DISPC_IRQ_FRAMEDONEWB;
 }
@@ -739,12 +739,12 @@ static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
 	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
 }
 
-bool dispc_wb_go_busy(void)
+bool dispc_wb_go_busy(struct dispc_device *dispc)
 {
 	return REG_GET(DISPC_CONTROL2, 6, 6) == 1;
 }
 
-void dispc_wb_go(void)
+void dispc_wb_go(struct dispc_device *dispc)
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
@@ -1196,7 +1196,8 @@ static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
 	}
 }
 
-void dispc_wb_set_channel_in(enum dss_writeback_channel channel)
+void dispc_wb_set_channel_in(struct dispc_device *dispc,
+			     enum dss_writeback_channel channel)
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 
@@ -1371,10 +1372,10 @@ static void dispc_init_fifos(void)
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(i, &low, &high,
+		dispc_ovl_compute_fifo_thresholds(&dispc, i, &low, &high,
 			use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(i, low, high);
+		dispc_ovl_set_fifo_threshold(&dispc, i, low, high);
 	}
 
 	if (dispc.feat->has_writeback) {
@@ -1382,10 +1383,11 @@ static void dispc_init_fifos(void)
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(OMAP_DSS_WB, &low, &high,
-			use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(&dispc, OMAP_DSS_WB,
+						  &low, &high,
+						  use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(OMAP_DSS_WB, low, high);
+		dispc_ovl_set_fifo_threshold(&dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
@@ -1402,13 +1404,14 @@ static u32 dispc_ovl_get_fifo_size(enum omap_plane_id plane)
 	return size;
 }
 
-void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
-				  u32 high)
+void dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u32 low, u32 high)
 {
 	u8 hi_start, hi_end, lo_start, lo_end;
 	u32 unit;
 
-	unit = dispc.feat->buffer_size_unit;
+	unit = dispc->feat->buffer_size_unit;
 
 	WARN_ON(low % unit != 0);
 	WARN_ON(high % unit != 0);
@@ -1436,12 +1439,12 @@ void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
 	 * large for the preload field, set the threshold to the maximum value
 	 * that can be held by the preload register
 	 */
-	if (dispc_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&
+	if (dispc_has_feature(FEAT_PRELOAD) && dispc->feat->set_max_preload &&
 			plane != OMAP_DSS_WB)
 		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
 }
 
-void dispc_enable_fifomerge(bool enable)
+void dispc_enable_fifomerge(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_FIFO_MERGE)) {
 		WARN_ON(enable);
@@ -1452,15 +1455,16 @@ void dispc_enable_fifomerge(bool enable)
 	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
 }
 
-void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
-		u32 *fifo_low, u32 *fifo_high, bool use_fifomerge,
-		bool manual_update)
+void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
+				       enum omap_plane_id plane,
+				       u32 *fifo_low, u32 *fifo_high,
+				       bool use_fifomerge, bool manual_update)
 {
 	/*
 	 * All sizes are in bytes. Both the buffer and burst are made of
 	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.
 	 */
-	unsigned int buf_unit = dispc.feat->buffer_size_unit;
+	unsigned int buf_unit = dispc->feat->buffer_size_unit;
 	unsigned int ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
@@ -1469,7 +1473,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
-		for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
+		for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
 			total_fifo_size += dispc_ovl_get_fifo_size(i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
@@ -2665,8 +2669,9 @@ static int dispc_ovl_setup(struct dispc_device *dispc,
 	return r;
 }
 
-int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
-		bool mem_to_mem, const struct videomode *vm)
+int dispc_wb_setup(struct dispc_device *dispc,
+		   const struct omap_dss_writeback_info *wi,
+		   bool mem_to_mem, const struct videomode *vm)
 {
 	int r;
 	u32 l;
@@ -2757,7 +2762,7 @@ static void dispc_lcd_enable_signal_polarity(bool act_high)
 	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
 }
 
-void dispc_lcd_enable_signal(bool enable)
+void dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_LCDENABLESIGNAL))
 		return;
@@ -2765,7 +2770,7 @@ void dispc_lcd_enable_signal(bool enable)
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
 }
 
-void dispc_pck_free_enable(bool enable)
+void dispc_pck_free_enable(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_PCKFREEENABLE))
 		return;
@@ -2904,7 +2909,7 @@ static void dispc_mgr_set_lcd_config(struct dispc_device *dispc,
 	dispc_mgr_enable_stallmode(channel, config->stallmode);
 	dispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);
 
-	dispc_mgr_set_clock_div(channel, &config->clock_info);
+	dispc_mgr_set_clock_div(dispc, channel, &config->clock_info);
 
 	dispc_mgr_set_tft_data_lines(channel, config->video_port_width);
 
@@ -2941,7 +2946,8 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 		return pclk <= dispc.feat->max_tv_pclk;
 }
 
-bool dispc_mgr_timings_ok(enum omap_channel channel, const struct videomode *vm)
+bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
+			  const struct videomode *vm)
 {
 	if (!_dispc_mgr_size_ok(vm->hactive, vm->vactive))
 		return false;
@@ -3062,7 +3068,7 @@ static void dispc_mgr_set_timings(struct dispc_device *dispc,
 
 	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
-	if (!dispc_mgr_timings_ok(channel, &t)) {
+	if (!dispc_mgr_timings_ok(dispc, channel, &t)) {
 		BUG();
 		return;
 	}
@@ -3195,9 +3201,9 @@ static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)
 	}
 }
 
-void dispc_set_tv_pclk(unsigned long pclk)
+void dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk)
 {
-	dispc.tv_pclk_rate = pclk;
+	dispc->tv_pclk_rate = pclk;
 }
 
 static unsigned long dispc_core_clk_rate(void)
@@ -3249,17 +3255,18 @@ static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel chan
 		dispc_mgr_pclk_rate(channel), pcd);
 }
 
-void dispc_dump_clocks(struct seq_file *s)
+void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)
 {
+	enum dss_clk_source dispc_clk_src;
 	int lcd;
 	u32 l;
-	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source(dispc.dss);
 
-	if (dispc_runtime_get(&dispc))
+	if (dispc_runtime_get(dispc))
 		return;
 
 	seq_printf(s, "- DISPC -\n");
 
+	dispc_clk_src = dss_get_dispc_clk_source(dispc->dss);
 	seq_printf(s, "dispc fclk source = %s\n",
 			dss_get_clk_source_name(dispc_clk_src));
 
@@ -3281,7 +3288,7 @@ void dispc_dump_clocks(struct seq_file *s)
 	if (dispc_has_feature(FEAT_MGR_LCD3))
 		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 }
 
 static int dispc_dump_regs(struct seq_file *s, void *p)
@@ -3482,8 +3489,9 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 }
 
 /* calculate clock rates using dividers in cinfo */
-int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
-		struct dispc_clock_info *cinfo)
+int dispc_calc_clock_rates(struct dispc_device *dispc,
+			   unsigned long dispc_fclk_rate,
+			   struct dispc_clock_info *cinfo)
 {
 	if (cinfo->lck_div > 255 || cinfo->lck_div == 0)
 		return -EINVAL;
@@ -3496,9 +3504,9 @@ int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
 	return 0;
 }
 
-bool dispc_div_calc(unsigned long dispc_freq,
-		unsigned long pck_min, unsigned long pck_max,
-		dispc_div_calc_func func, void *data)
+bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,
+		    unsigned long pck_min, unsigned long pck_max,
+		    dispc_div_calc_func func, void *data)
 {
 	int lckd, lckd_start, lckd_stop;
 	int pckd, pckd_start, pckd_stop;
@@ -3514,10 +3522,10 @@ bool dispc_div_calc(unsigned long dispc_freq,
 	min_fck_per_pck = 0;
 #endif
 
-	pckd_hw_min = dispc.feat->min_pcd;
+	pckd_hw_min = dispc->feat->min_pcd;
 	pckd_hw_max = 255;
 
-	lck_max = dss_get_max_fck_rate(dispc.dss);
+	lck_max = dss_get_max_fck_rate(dispc->dss);
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;
@@ -3556,8 +3564,9 @@ bool dispc_div_calc(unsigned long dispc_freq,
 	return false;
 }
 
-void dispc_mgr_set_clock_div(enum omap_channel channel,
-		const struct dispc_clock_info *cinfo)
+void dispc_mgr_set_clock_div(struct dispc_device *dispc,
+			     enum omap_channel channel,
+			     const struct dispc_clock_info *cinfo)
 {
 	DSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);
 	DSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);
@@ -3565,8 +3574,9 @@ void dispc_mgr_set_clock_div(enum omap_channel channel,
 	dispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);
 }
 
-int dispc_mgr_get_clock_div(enum omap_channel channel,
-		struct dispc_clock_info *cinfo)
+int dispc_mgr_get_clock_div(struct dispc_device *dispc,
+			    enum omap_channel channel,
+			    struct dispc_clock_info *cinfo)
 {
 	unsigned long fck;
 
@@ -3604,12 +3614,12 @@ static void dispc_write_irqenable(struct dispc_device *dispc, u32 mask)
 	dispc_read_reg(DISPC_IRQENABLE);
 }
 
-void dispc_enable_sidle(void)
+void dispc_enable_sidle(struct dispc_device *dispc)
 {
 	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
 }
 
-void dispc_disable_sidle(void)
+void dispc_disable_sidle(struct dispc_device *dispc)
 {
 	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
@@ -4482,7 +4492,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Set up and enable display manager for LCD1 */
 	dispc_mgr_setup(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(dss_get_dispc_clk_rate(dispc.dss),
+	dispc_calc_clock_rates(&dispc, dss_get_dispc_clk_rate(dispc.dss),
 			       &lcd_conf.clock_info);
 	dispc_mgr_set_lcd_config(&dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
 	dispc_mgr_set_timings(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index aae6037f499f..6d8228f976f9 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -162,7 +162,7 @@ struct dispc_features {
 #define DISPC_MAX_NR_FIFOS 5
 #define DISPC_MAX_CHANNEL_GAMMA 4
 
-static struct {
+struct dispc_device {
 	struct platform_device *pdev;
 	void __iomem    *base;
 	struct dss_device *dss;
@@ -194,7 +194,9 @@ static struct {
 
 	/* DISPC_CONTROL & DISPC_CONFIG lock*/
 	spinlock_t control_lock;
-} dispc;
+};
+
+static struct dispc_device dispc;
 
 enum omap_color_component {
 	/* used for all color formats for OMAP3 and earlier
@@ -361,9 +363,7 @@ static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
 static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane);
 static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane);
 
-static void dispc_clear_irqstatus(u32 mask);
-static bool dispc_mgr_is_enabled(enum omap_channel channel);
-static void dispc_clear_irqstatus(u32 mask);
+static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask);
 
 static inline void dispc_write_reg(const u16 idx, u32 val)
 {
@@ -396,14 +396,14 @@ static void mgr_fld_write(enum omap_channel channel,
 		spin_unlock_irqrestore(&dispc.control_lock, flags);
 }
 
-static int dispc_get_num_ovls(void)
+static int dispc_get_num_ovls(struct dispc_device *dispc)
 {
-	return dispc.feat->num_ovls;
+	return dispc->feat->num_ovls;
 }
 
-static int dispc_get_num_mgrs(void)
+static int dispc_get_num_mgrs(struct dispc_device *dispc)
 {
-	return dispc.feat->num_mgrs;
+	return dispc->feat->num_mgrs;
 }
 
 static void dispc_get_reg_field(enum dispc_feat_reg_field id,
@@ -455,7 +455,7 @@ static void dispc_save_context(void)
 		SR(CONFIG3);
 	}
 
-	for (i = 0; i < dispc_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
 		SR(DEFAULT_COLOR(i));
 		SR(TRANS_COLOR(i));
 		SR(SIZE_MGR(i));
@@ -477,7 +477,7 @@ static void dispc_save_context(void)
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
 		SR(OVL_BA0(i));
 		SR(OVL_BA1(i));
 		SR(OVL_POSITION(i));
@@ -561,7 +561,7 @@ static void dispc_restore_context(void)
 	if (dispc_has_feature(FEAT_MGR_LCD3))
 		RR(CONFIG3);
 
-	for (i = 0; i < dispc_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
 		RR(DEFAULT_COLOR(i));
 		RR(TRANS_COLOR(i));
 		RR(SIZE_MGR(i));
@@ -583,7 +583,7 @@ static void dispc_restore_context(void)
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
 		RR(OVL_BA0(i));
 		RR(OVL_BA1(i));
 		RR(OVL_POSITION(i));
@@ -648,7 +648,7 @@ static void dispc_restore_context(void)
 	if (dispc_has_feature(FEAT_MGR_LCD3))
 		RR(CONTROL3);
 	/* clear spurious SYNC_LOST_DIGIT interrupts */
-	dispc_clear_irqstatus(DISPC_IRQ_SYNC_LOST_DIGIT);
+	dispc_clear_irqstatus(&dispc, DISPC_IRQ_SYNC_LOST_DIGIT);
 
 	/*
 	 * enable last so IRQs won't trigger before
@@ -662,41 +662,44 @@ static void dispc_restore_context(void)
 #undef SR
 #undef RR
 
-int dispc_runtime_get(void)
+int dispc_runtime_get(struct dispc_device *dispc)
 {
 	int r;
 
 	DSSDBG("dispc_runtime_get\n");
 
-	r = pm_runtime_get_sync(&dispc.pdev->dev);
+	r = pm_runtime_get_sync(&dispc->pdev->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
 
-void dispc_runtime_put(void)
+void dispc_runtime_put(struct dispc_device *dispc)
 {
 	int r;
 
 	DSSDBG("dispc_runtime_put\n");
 
-	r = pm_runtime_put_sync(&dispc.pdev->dev);
+	r = pm_runtime_put_sync(&dispc->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
-static u32 dispc_mgr_get_vsync_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_vsync_irq(struct dispc_device *dispc,
+				   enum omap_channel channel)
 {
 	return mgr_desc[channel].vsync_irq;
 }
 
-static u32 dispc_mgr_get_framedone_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_framedone_irq(struct dispc_device *dispc,
+				       enum omap_channel channel)
 {
-	if (channel == OMAP_DSS_CHANNEL_DIGIT && dispc.feat->no_framedone_tv)
+	if (channel == OMAP_DSS_CHANNEL_DIGIT && dispc->feat->no_framedone_tv)
 		return 0;
 
 	return mgr_desc[channel].framedone_irq;
 }
 
-static u32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_sync_lost_irq(struct dispc_device *dispc,
+				       enum omap_channel channel)
 {
 	return mgr_desc[channel].sync_lost_irq;
 }
@@ -706,27 +709,30 @@ u32 dispc_wb_get_framedone_irq(void)
 	return DISPC_IRQ_FRAMEDONEWB;
 }
 
-static void dispc_mgr_enable(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable(struct dispc_device *dispc,
+			     enum omap_channel channel, bool enable)
 {
 	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
 	/* flush posted write */
 	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
 }
 
-static bool dispc_mgr_is_enabled(enum omap_channel channel)
+static bool dispc_mgr_is_enabled(struct dispc_device *dispc,
+				 enum omap_channel channel)
 {
 	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
 }
 
-static bool dispc_mgr_go_busy(enum omap_channel channel)
+static bool dispc_mgr_go_busy(struct dispc_device *dispc,
+			      enum omap_channel channel)
 {
 	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
 }
 
-static void dispc_mgr_go(enum omap_channel channel)
+static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
 {
-	WARN_ON(!dispc_mgr_is_enabled(channel));
-	WARN_ON(dispc_mgr_go_busy(channel));
+	WARN_ON(!dispc_mgr_is_enabled(dispc, channel));
+	WARN_ON(dispc_mgr_go_busy(dispc, channel));
 
 	DSSDBG("GO %s\n", mgr_desc[channel].name);
 
@@ -864,7 +870,7 @@ static void dispc_ovl_write_color_conv_coef(enum omap_plane_id plane,
 static void dispc_setup_color_conv_coef(void)
 {
 	int i;
-	int num_ovl = dispc_get_num_ovls();
+	int num_ovl = dispc_get_num_ovls(&dispc);
 	const struct color_conv_coef ctbl_bt601_5_ovl = {
 		/* YUV -> RGB */
 		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
@@ -956,7 +962,7 @@ static void dispc_ovl_enable_zorder_planes(void)
 	if (!dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		return;
 
-	for (i = 0; i < dispc_get_num_ovls(); i++)
+	for (i = 0; i < dispc_get_num_ovls(&dispc); i++)
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
 }
 
@@ -1213,7 +1219,7 @@ static void dispc_configure_burst_sizes(void)
 	const int burst_size = BURST_SIZE_X8;
 
 	/* Configure burst size always to maximum size */
-	for (i = 0; i < dispc_get_num_ovls(); ++i)
+	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
 		dispc_ovl_set_burst_size(i, burst_size);
 	if (dispc.feat->has_writeback)
 		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
@@ -1240,9 +1246,10 @@ static bool dispc_ovl_color_mode_supported(enum omap_plane_id plane, u32 fourcc)
 	return false;
 }
 
-static const u32 *dispc_ovl_get_color_modes(enum omap_plane_id plane)
+static const u32 *dispc_ovl_get_color_modes(struct dispc_device *dispc,
+					    enum omap_plane_id plane)
 {
-	return dispc.feat->supported_color_modes[plane];
+	return dispc->feat->supported_color_modes[plane];
 }
 
 static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
@@ -1359,7 +1366,7 @@ static void dispc_init_fifos(void)
 	/*
 	 * Setup default fifo thresholds.
 	 */
-	for (i = 0; i < dispc_get_num_ovls(); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
@@ -1462,7 +1469,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
-		for (i = 0; i < dispc_get_num_ovls(); ++i)
+		for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
 			total_fifo_size += dispc_ovl_get_fifo_size(i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
@@ -1528,7 +1535,7 @@ static void dispc_init_mflag(void)
 		(1 << 0) |	/* MFLAG_CTRL = force always on */
 		(0 << 2));	/* MFLAG_START = disable */
 
-	for (i = 0; i < dispc_get_num_ovls(); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
 		u32 size = dispc_ovl_get_fifo_size(i);
 		u32 unit = dispc.feat->buffer_size_unit;
 		u32 low, high;
@@ -2631,13 +2638,14 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	return 0;
 }
 
-static int dispc_ovl_setup(enum omap_plane_id plane,
-		const struct omap_overlay_info *oi,
-		const struct videomode *vm, bool mem_to_mem,
-		enum omap_channel channel)
+static int dispc_ovl_setup(struct dispc_device *dispc,
+			   enum omap_plane_id plane,
+			   const struct omap_overlay_info *oi,
+			   const struct videomode *vm, bool mem_to_mem,
+			   enum omap_channel channel)
 {
 	int r;
-	enum omap_overlay_caps caps = dispc.feat->overlay_caps[plane];
+	enum omap_overlay_caps caps = dispc->feat->overlay_caps[plane];
 	const bool replication = true;
 
 	DSSDBG("dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->"
@@ -2724,7 +2732,8 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	return r;
 }
 
-static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
+static int dispc_ovl_enable(struct dispc_device *dispc,
+			    enum omap_plane_id plane, bool enable)
 {
 	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
 
@@ -2733,9 +2742,11 @@ static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
 	return 0;
 }
 
-static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
+static enum omap_dss_output_id
+dispc_mgr_get_supported_outputs(struct dispc_device *dispc,
+				enum omap_channel channel)
 {
-	return dss_get_supported_outputs(dispc.dss, channel);
+	return dss_get_supported_outputs(dispc->dss, channel);
 }
 
 static void dispc_lcd_enable_signal_polarity(bool act_high)
@@ -2810,8 +2821,9 @@ static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
 		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
 }
 
-static void dispc_mgr_setup(enum omap_channel channel,
-		const struct omap_overlay_manager_info *info)
+static void dispc_mgr_setup(struct dispc_device *dispc,
+			    enum omap_channel channel,
+			    const struct omap_overlay_manager_info *info)
 {
 	dispc_mgr_set_default_color(channel, info->default_color);
 	dispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);
@@ -2883,8 +2895,9 @@ static void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)
 	mgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);
 }
 
-static void dispc_mgr_set_lcd_config(enum omap_channel channel,
-		const struct dss_lcd_mgr_config *config)
+static void dispc_mgr_set_lcd_config(struct dispc_device *dispc,
+				     enum omap_channel channel,
+				     const struct dss_lcd_mgr_config *config)
 {
 	dispc_mgr_set_io_pad_mode(config->io_pad_mode);
 
@@ -3039,8 +3052,9 @@ static int vm_flag_to_int(enum display_flags flags, enum display_flags high,
 }
 
 /* change name to mode? */
-static void dispc_mgr_set_timings(enum omap_channel channel,
-			   const struct videomode *vm)
+static void dispc_mgr_set_timings(struct dispc_device *dispc,
+				  enum omap_channel channel,
+				  const struct videomode *vm)
 {
 	unsigned int xtot, ytot;
 	unsigned long ht, vt;
@@ -3078,7 +3092,7 @@ static void dispc_mgr_set_timings(enum omap_channel channel,
 		if (t.flags & DISPLAY_FLAGS_INTERLACED)
 			t.vactive /= 2;
 
-		if (dispc.feat->supports_double_pixel)
+		if (dispc->feat->supports_double_pixel)
 			REG_FLD_MOD(DISPC_CONTROL,
 				    !!(t.flags & DISPLAY_FLAGS_DOUBLECLK),
 				    19, 17);
@@ -3241,7 +3255,7 @@ void dispc_dump_clocks(struct seq_file *s)
 	u32 l;
 	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source(dispc.dss);
 
-	if (dispc_runtime_get())
+	if (dispc_runtime_get(&dispc))
 		return;
 
 	seq_printf(s, "- DISPC -\n");
@@ -3267,7 +3281,7 @@ void dispc_dump_clocks(struct seq_file *s)
 	if (dispc_has_feature(FEAT_MGR_LCD3))
 		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
 
-	dispc_runtime_put();
+	dispc_runtime_put(&dispc);
 }
 
 static int dispc_dump_regs(struct seq_file *s, void *p)
@@ -3290,7 +3304,7 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 
 #define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))
 
-	if (dispc_runtime_get())
+	if (dispc_runtime_get(&dispc))
 		return 0;
 
 	/* DISPC common registers */
@@ -3328,7 +3342,7 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 	p_names = mgr_names;
 
 	/* DISPC channel specific registers */
-	for (i = 0; i < dispc_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
 		DUMPREG(i, DISPC_DEFAULT_COLOR);
 		DUMPREG(i, DISPC_TRANS_COLOR);
 		DUMPREG(i, DISPC_SIZE_MGR);
@@ -3354,7 +3368,7 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 
 	p_names = ovl_names;
 
-	for (i = 0; i < dispc_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
 		DUMPREG(i, DISPC_OVL_BA0);
 		DUMPREG(i, DISPC_OVL_BA1);
 		DUMPREG(i, DISPC_OVL_POSITION);
@@ -3432,7 +3446,7 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 	/* Video pipeline coefficient registers */
 
 	/* start from OMAP_DSS_VIDEO1 */
-	for (i = 1; i < dispc_get_num_ovls(); i++) {
+	for (i = 1; i < dispc_get_num_ovls(&dispc); i++) {
 		for (j = 0; j < 8; j++)
 			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
 
@@ -3459,7 +3473,7 @@ static int dispc_dump_regs(struct seq_file *s, void *p)
 		}
 	}
 
-	dispc_runtime_put();
+	dispc_runtime_put(&dispc);
 
 #undef DISPC_REG
 #undef DUMPREG
@@ -3567,22 +3581,22 @@ int dispc_mgr_get_clock_div(enum omap_channel channel,
 	return 0;
 }
 
-static u32 dispc_read_irqstatus(void)
+static u32 dispc_read_irqstatus(struct dispc_device *dispc)
 {
 	return dispc_read_reg(DISPC_IRQSTATUS);
 }
 
-static void dispc_clear_irqstatus(u32 mask)
+static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask)
 {
 	dispc_write_reg(DISPC_IRQSTATUS, mask);
 }
 
-static void dispc_write_irqenable(u32 mask)
+static void dispc_write_irqenable(struct dispc_device *dispc, u32 mask)
 {
 	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
 
 	/* clear the irqstatus for newly enabled irqs */
-	dispc_clear_irqstatus((mask ^ old_mask) & mask);
+	dispc_clear_irqstatus(dispc, (mask ^ old_mask) & mask);
 
 	dispc_write_reg(DISPC_IRQENABLE, mask);
 
@@ -3600,11 +3614,12 @@ void dispc_disable_sidle(void)
 	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
-static u32 dispc_mgr_gamma_size(enum omap_channel channel)
+static u32 dispc_mgr_gamma_size(struct dispc_device *dispc,
+				enum omap_channel channel)
 {
 	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return 0;
 
 	return gdesc->len;
@@ -3653,18 +3668,19 @@ static const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {
 	{ .red = U16_MAX, .green = U16_MAX, .blue = U16_MAX, },
 };
 
-static void dispc_mgr_set_gamma(enum omap_channel channel,
-			 const struct drm_color_lut *lut,
-			 unsigned int length)
+static void dispc_mgr_set_gamma(struct dispc_device *dispc,
+				enum omap_channel channel,
+				const struct drm_color_lut *lut,
+				unsigned int length)
 {
 	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
-	u32 *table = dispc.gamma_table[channel];
+	u32 *table = dispc->gamma_table[channel];
 	uint i;
 
 	DSSDBG("%s: channel %d, lut len %u, hw len %u\n", __func__,
 	       channel, length, gdesc->len);
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return;
 
 	if (lut == NULL || length < 2) {
@@ -3696,7 +3712,7 @@ static void dispc_mgr_set_gamma(enum omap_channel channel,
 		}
 	}
 
-	if (dispc.is_enabled)
+	if (dispc->is_enabled)
 		dispc_mgr_write_gamma_table(channel);
 }
 
@@ -3726,7 +3742,7 @@ static int dispc_init_gamma_tables(void)
 
 		dispc.gamma_table[channel] = gt;
 
-		dispc_mgr_set_gamma(channel, NULL, 0);
+		dispc_mgr_set_gamma(&dispc, channel, NULL, 0);
 	}
 	return 0;
 }
@@ -4296,43 +4312,44 @@ static irqreturn_t dispc_irq_handler(int irq, void *arg)
 	return dispc.user_handler(irq, dispc.user_data);
 }
 
-static int dispc_request_irq(irq_handler_t handler, void *dev_id)
+static int dispc_request_irq(struct dispc_device *dispc, irq_handler_t handler,
+			     void *dev_id)
 {
 	int r;
 
-	if (dispc.user_handler != NULL)
+	if (dispc->user_handler != NULL)
 		return -EBUSY;
 
-	dispc.user_handler = handler;
-	dispc.user_data = dev_id;
+	dispc->user_handler = handler;
+	dispc->user_data = dev_id;
 
 	/* ensure the dispc_irq_handler sees the values above */
 	smp_wmb();
 
-	r = devm_request_irq(&dispc.pdev->dev, dispc.irq, dispc_irq_handler,
-			     IRQF_SHARED, "OMAP DISPC", &dispc);
+	r = devm_request_irq(&dispc->pdev->dev, dispc->irq, dispc_irq_handler,
+			     IRQF_SHARED, "OMAP DISPC", dispc);
 	if (r) {
-		dispc.user_handler = NULL;
-		dispc.user_data = NULL;
+		dispc->user_handler = NULL;
+		dispc->user_data = NULL;
 	}
 
 	return r;
 }
 
-static void dispc_free_irq(void *dev_id)
+static void dispc_free_irq(struct dispc_device *dispc, void *dev_id)
 {
-	devm_free_irq(&dispc.pdev->dev, dispc.irq, &dispc);
+	devm_free_irq(&dispc->pdev->dev, dispc->irq, dispc);
 
-	dispc.user_handler = NULL;
-	dispc.user_data = NULL;
+	dispc->user_handler = NULL;
+	dispc->user_data = NULL;
 }
 
-static u32 dispc_get_memory_bandwidth_limit(void)
+static u32 dispc_get_memory_bandwidth_limit(struct dispc_device *dispc)
 {
 	u32 limit = 0;
 
 	/* Optional maximum memory bandwidth */
-	of_property_read_u32(dispc.pdev->dev.of_node, "max-memory-bandwidth",
+	of_property_read_u32(dispc->pdev->dev.of_node, "max-memory-bandwidth",
 			     &limit);
 
 	return limit;
@@ -4439,7 +4456,8 @@ static void dispc_errata_i734_wa_fini(void)
 
 static void dispc_errata_i734_wa(void)
 {
-	u32 framedone_irq = dispc_mgr_get_framedone_irq(OMAP_DSS_CHANNEL_LCD);
+	u32 framedone_irq = dispc_mgr_get_framedone_irq(&dispc,
+							OMAP_DSS_CHANNEL_LCD);
 	struct omap_overlay_info ovli;
 	struct dss_lcd_mgr_config lcd_conf;
 	u32 gatestate;
@@ -4458,39 +4476,39 @@ static void dispc_errata_i734_wa(void)
 	REG_FLD_MOD(DISPC_CONFIG, 0x1f, 8, 4);
 
 	/* Setup and enable GFX plane */
-	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, &i734.vm, false,
-		OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_enable(OMAP_DSS_GFX, true);
+	dispc_ovl_setup(&dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,
+			OMAP_DSS_CHANNEL_LCD);
+	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */
-	dispc_mgr_setup(OMAP_DSS_CHANNEL_LCD, &i734.mgri);
+	dispc_mgr_setup(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
 	dispc_calc_clock_rates(dss_get_dispc_clk_rate(dispc.dss),
 			       &lcd_conf.clock_info);
-	dispc_mgr_set_lcd_config(OMAP_DSS_CHANNEL_LCD, &lcd_conf);
-	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.vm);
+	dispc_mgr_set_lcd_config(&dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
+	dispc_mgr_set_timings(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
 
-	dispc_clear_irqstatus(framedone_irq);
+	dispc_clear_irqstatus(&dispc, framedone_irq);
 
 	/* Enable and shut the channel to produce just one frame */
-	dispc_mgr_enable(OMAP_DSS_CHANNEL_LCD, true);
-	dispc_mgr_enable(OMAP_DSS_CHANNEL_LCD, false);
+	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, true);
+	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, false);
 
 	/* Busy wait for framedone. We can't fiddle with irq handlers
 	 * in PM resume. Typically the loop runs less than 5 times and
 	 * waits less than a micro second.
 	 */
 	count = 0;
-	while (!(dispc_read_irqstatus() & framedone_irq)) {
+	while (!(dispc_read_irqstatus(&dispc) & framedone_irq)) {
 		if (count++ > 10000) {
 			dev_err(&dispc.pdev->dev, "%s: framedone timeout\n",
 				__func__);
 			break;
 		}
 	}
-	dispc_ovl_enable(OMAP_DSS_GFX, false);
+	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, false);
 
 	/* Clear all irq bits before continuing */
-	dispc_clear_irqstatus(0xffffffff);
+	dispc_clear_irqstatus(&dispc, 0xffffffff);
 
 	/* Restore the original state to LCD1 output gates */
 	REG_FLD_MOD(DISPC_CONFIG, gatestate, 8, 4);
@@ -4610,7 +4628,7 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	pm_runtime_enable(&pdev->dev);
 
-	r = dispc_runtime_get();
+	r = dispc_runtime_get(&dispc);
 	if (r)
 		goto err_runtime_get;
 
@@ -4620,8 +4638,9 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
 	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
-	dispc_runtime_put();
+	dispc_runtime_put(&dispc);
 
+	dss->dispc = &dispc;
 	dss->dispc_ops = &dispc_ops;
 
 	dispc.debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
@@ -4634,13 +4653,13 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	return r;
 }
 
-static void dispc_unbind(struct device *dev, struct device *master,
-			       void *data)
+static void dispc_unbind(struct device *dev, struct device *master, void *data)
 {
 	struct dss_device *dss = dispc.dss;
 
 	dss_debugfs_remove_file(dispc.debugfs);
 
+	dss->dispc = NULL;
 	dss->dispc_ops = NULL;
 
 	pm_runtime_disable(dev);

commit d3541ca81dbddeefa0c42df448211a9dbaef0843
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:41 2018 +0200

    drm: omapdrm: dss: Store dispc ops in dss_device structure
    
    Remove the global dispc ops variable by storing it in the dss_device
    structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 8019cc9f4f97..aae6037f499f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4622,7 +4622,7 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	dispc_runtime_put();
 
-	dispc_set_ops(&dispc_ops);
+	dss->dispc_ops = &dispc_ops;
 
 	dispc.debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
 						&dispc);
@@ -4637,9 +4637,11 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 static void dispc_unbind(struct device *dev, struct device *master,
 			       void *data)
 {
+	struct dss_device *dss = dispc.dss;
+
 	dss_debugfs_remove_file(dispc.debugfs);
 
-	dispc_set_ops(NULL);
+	dss->dispc_ops = NULL;
 
 	pm_runtime_disable(dev);
 

commit 1c4b92ee00734766967f5aa425767923c747f9c6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:31 2018 +0200

    drm: omapdrm: dss: Store the debugfs root directory in struct dss_device
    
    As part of an effort to remove the usage of global variables in the
    driver, store the debugfs root directory in the dss_device structure
    instead of a global variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 285d297db229..8019cc9f4f97 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4624,7 +4624,7 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	dispc_set_ops(&dispc_ops);
 
-	dispc.debugfs = dss_debugfs_create_file("dispc", dispc_dump_regs,
+	dispc.debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
 						&dispc);
 
 	return 0;

commit 798957aedbde21c6418c419708b765b102b341c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:30 2018 +0200

    drm: omapdrm: dss: Store the registered plls array in struct dss_device
    
    As part of an effort to remove the usage of global variables in the
    driver, store the registered plls array in the dss_device structure
    instead of a global variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 3428ffea70ee..285d297db229 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3123,7 +3123,7 @@ static unsigned long dispc_fclk_rate(void)
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(src);
+		pll = dss_pll_find_by_src(dispc.dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];
@@ -3150,7 +3150,7 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(src);
+		pll = dss_pll_find_by_src(dispc.dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];

commit f33656e1fe5aba0ac0d35e18d90121dd894611ca
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:29 2018 +0200

    drm: omapdrm: dss: Support passing private data to debugfs show handlers
    
    To simplify implementation of debugfs seq_file show handlers, the driver
    passes the pointer to the show function through the debugfs_create_file
    data pointer. This prevents using the pointer to pass driver private
    data to the show handler, and requires all handlers to use global
    variables to access private data.
    
    To prepare for the removal of global private data in the driver, rework
    the debugfs infrastructure to allow passing a private data pointer to
    show handlers.
    
    The price to pay is explicit removal of debugfs files to free the
    internally allocated memory. This is desirable anyway as debugfs entries
    should be removed when a component driver is unbound, otherwise crashes
    will occur due to access to freed memory when the components will be
    dynamically allocated instead of stored in global variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 867887151565..3428ffea70ee 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -167,6 +167,8 @@ static struct {
 	void __iomem    *base;
 	struct dss_device *dss;
 
+	struct dss_debugfs_entry *debugfs;
+
 	int irq;
 	irq_handler_t user_handler;
 	void *user_data;
@@ -3268,7 +3270,7 @@ void dispc_dump_clocks(struct seq_file *s)
 	dispc_runtime_put();
 }
 
-static void dispc_dump_regs(struct seq_file *s)
+static int dispc_dump_regs(struct seq_file *s, void *p)
 {
 	int i, j;
 	const char *mgr_names[] = {
@@ -3289,7 +3291,7 @@ static void dispc_dump_regs(struct seq_file *s)
 #define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))
 
 	if (dispc_runtime_get())
-		return;
+		return 0;
 
 	/* DISPC common registers */
 	DUMPREG(DISPC_REVISION);
@@ -3461,6 +3463,8 @@ static void dispc_dump_regs(struct seq_file *s)
 
 #undef DISPC_REG
 #undef DUMPREG
+
+	return 0;
 }
 
 /* calculate clock rates using dividers in cinfo */
@@ -4620,7 +4624,8 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	dispc_set_ops(&dispc_ops);
 
-	dss_debugfs_create_file("dispc", dispc_dump_regs);
+	dispc.debugfs = dss_debugfs_create_file("dispc", dispc_dump_regs,
+						&dispc);
 
 	return 0;
 
@@ -4632,6 +4637,8 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 static void dispc_unbind(struct device *dev, struct device *master,
 			       void *data)
 {
+	dss_debugfs_remove_file(dispc.debugfs);
+
 	dispc_set_ops(NULL);
 
 	pm_runtime_disable(dev);

commit 1ef904e1e4f05d32331783d413e341c6353ae9aa
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:27 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to remaining dss functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 8d0de1b790b7..867887151565 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2733,7 +2733,7 @@ static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
 
 static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
 {
-	return dss_get_supported_outputs(channel);
+	return dss_get_supported_outputs(dispc.dss, channel);
 }
 
 static void dispc_lcd_enable_signal_polarity(bool act_high)

commit 60f9c59fc1e2ced4a02e91088c367395edacc7fe
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:26 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss clock functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 048b2e4d1f40..8d0de1b790b7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3116,7 +3116,7 @@ static unsigned long dispc_fclk_rate(void)
 	src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate();
+		r = dss_get_dispc_clk_rate(dispc.dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
@@ -3143,7 +3143,7 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 	src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate();
+		r = dss_get_dispc_clk_rate(dispc.dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
@@ -3499,7 +3499,7 @@ bool dispc_div_calc(unsigned long dispc_freq,
 	pckd_hw_min = dispc.feat->min_pcd;
 	pckd_hw_max = 255;
 
-	lck_max = dss_get_max_fck_rate();
+	lck_max = dss_get_max_fck_rate(dispc.dss);
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;
@@ -4460,7 +4460,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Set up and enable display manager for LCD1 */
 	dispc_mgr_setup(OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(dss_get_dispc_clk_rate(),
+	dispc_calc_clock_rates(dss_get_dispc_clk_rate(dispc.dss),
 			       &lcd_conf.clock_info);
 	dispc_mgr_set_lcd_config(OMAP_DSS_CHANNEL_LCD, &lcd_conf);
 	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.vm);

commit 3cc62aadf414102785adbfc3dd2f2f3be85d60db
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:25 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss_get_*_clk_source()
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 86d18f2d48ba..048b2e4d1f40 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -165,6 +165,7 @@ struct dispc_features {
 static struct {
 	struct platform_device *pdev;
 	void __iomem    *base;
+	struct dss_device *dss;
 
 	int irq;
 	irq_handler_t user_handler;
@@ -3112,7 +3113,7 @@ static unsigned long dispc_fclk_rate(void)
 	unsigned long r;
 	enum dss_clk_source src;
 
-	src = dss_get_dispc_clk_source();
+	src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
 		r = dss_get_dispc_clk_rate();
@@ -3139,7 +3140,7 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 	if (!dss_mgr_is_lcd(channel))
 		return dispc_fclk_rate();
 
-	src = dss_get_lcd_clk_source(channel);
+	src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
 		r = dss_get_dispc_clk_rate();
@@ -3219,7 +3220,7 @@ static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel chan
 
 	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
 
-	lcd_clk_src = dss_get_lcd_clk_source(channel);
+	lcd_clk_src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
 		dss_get_clk_source_name(lcd_clk_src));
@@ -3236,7 +3237,7 @@ void dispc_dump_clocks(struct seq_file *s)
 {
 	int lcd;
 	u32 l;
-	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
+	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (dispc_runtime_get())
 		return;
@@ -4549,12 +4550,14 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	const struct soc_device_attribute *soc;
+	struct dss_device *dss = dss_get_device(master);
 	u32 rev;
 	int r = 0;
 	struct resource *dispc_mem;
 	struct device_node *np = pdev->dev.of_node;
 
 	dispc.pdev = pdev;
+	dispc.dss = dss;
 
 	spin_lock_init(&dispc.control_lock);
 

commit d11e5c827a4dbbb4174087669e3c7d231570985b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:34 2018 +0200

    drm: omapdrm: Use unsigned int type
    
    The kernel favours 'unsigned int' over plain 'unsigned'. Replace all
    occurences of the latter by the former. This avoid lots of checkpatch
    complaints in patches that touch lines where a plain 'unsigned' is used.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 4e8f68efd169..86d18f2d48ba 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -969,7 +969,7 @@ static void dispc_ovl_set_pre_mult_alpha(enum omap_plane_id plane,
 static void dispc_ovl_setup_global_alpha(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u8 global_alpha)
 {
-	static const unsigned shifts[] = { 0, 8, 16, 24, };
+	static const unsigned int shifts[] = { 0, 8, 16, 24, };
 	int shift;
 
 	if ((caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)
@@ -1197,7 +1197,7 @@ void dispc_wb_set_channel_in(enum dss_writeback_channel channel)
 static void dispc_ovl_set_burst_size(enum omap_plane_id plane,
 		enum omap_burst_size burst_size)
 {
-	static const unsigned shifts[] = { 6, 14, 14, 14, 14, };
+	static const unsigned int shifts[] = { 6, 14, 14, 14, 14, };
 	int shift;
 
 	shift = shifts[plane];
@@ -1285,7 +1285,7 @@ static void dispc_ovl_set_vid_color_conv(enum omap_plane_id plane,
 static void dispc_ovl_enable_replication(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, bool enable)
 {
-	static const unsigned shifts[] = { 5, 10, 10, 10 };
+	static const unsigned int shifts[] = { 5, 10, 10, 10 };
 	int shift;
 
 	if ((caps & OMAP_DSS_OVL_CAP_REPLICATION) == 0)
@@ -1450,9 +1450,8 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 	 * All sizes are in bytes. Both the buffer and burst are made of
 	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.
 	 */
-
-	unsigned buf_unit = dispc.feat->buffer_size_unit;
-	unsigned ovl_fifo_size, total_fifo_size, burst_size;
+	unsigned int buf_unit = dispc.feat->buffer_size_unit;
+	unsigned int ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
 	burst_size = dispc_ovl_get_burst_size(plane);
@@ -2006,8 +2005,8 @@ static s32 pixinc(int pixels, u8 ps)
 }
 
 static void calc_offset(u16 screen_width, u16 width,
-		u32 fourcc, bool fieldmode,
-		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
+		u32 fourcc, bool fieldmode, unsigned int field_offset,
+		unsigned int *offset0, unsigned int *offset1,
 		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim,
 		enum omap_dss_rotation_type rotation_type, u8 rotation)
 {
@@ -2477,7 +2476,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	bool five_taps = true;
 	bool fieldmode = false;
 	int r, cconv = 0;
-	unsigned offset0, offset1;
+	unsigned int offset0, offset1;
 	s32 row_inc;
 	s32 pix_inc;
 	u16 frame_width, frame_height;
@@ -3040,7 +3039,7 @@ static int vm_flag_to_int(enum display_flags flags, enum display_flags high,
 static void dispc_mgr_set_timings(enum omap_channel channel,
 			   const struct videomode *vm)
 {
-	unsigned xtot, ytot;
+	unsigned int xtot, ytot;
 	unsigned long ht, vt;
 	struct videomode t = *vm;
 
@@ -3119,7 +3118,7 @@ static unsigned long dispc_fclk_rate(void)
 		r = dss_get_dispc_clk_rate();
 	} else {
 		struct dss_pll *pll;
-		unsigned clkout_idx;
+		unsigned int clkout_idx;
 
 		pll = dss_pll_find_by_src(src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
@@ -3146,7 +3145,7 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 		r = dss_get_dispc_clk_rate();
 	} else {
 		struct dss_pll *pll;
-		unsigned clkout_idx;
+		unsigned int clkout_idx;
 
 		pll = dss_pll_find_by_src(src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
@@ -3487,7 +3486,7 @@ bool dispc_div_calc(unsigned long dispc_freq,
 	unsigned long pck, lck;
 	unsigned long lck_max;
 	unsigned long pckd_hw_min, pckd_hw_max;
-	unsigned min_fck_per_pck;
+	unsigned int min_fck_per_pck;
 	unsigned long fck;
 
 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK

commit d66c36a3ee79747e300ac68276ca1496b567df68
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:32 2017 -0600

    drm: omapdrm: Simplify platform registration
    
    Currently, calls into each file are used to register the various
    platform drivers. Change this to a table of pointers to platform_driver
    structs to allow using platform_register_drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 34b4555d1223..4e8f68efd169 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4696,7 +4696,7 @@ static const struct dev_pm_ops dispc_pm_ops = {
 	.runtime_resume = dispc_runtime_resume,
 };
 
-static struct platform_driver omap_dispchw_driver = {
+struct platform_driver omap_dispchw_driver = {
 	.probe		= dispc_probe,
 	.remove         = dispc_remove,
 	.driver         = {
@@ -4706,13 +4706,3 @@ static struct platform_driver omap_dispchw_driver = {
 		.suppress_bind_attrs = true,
 	},
 };
-
-int __init dispc_init_platform_driver(void)
-{
-	return platform_driver_register(&omap_dispchw_driver);
-}
-
-void dispc_uninit_platform_driver(void)
-{
-	platform_driver_unregister(&omap_dispchw_driver);
-}

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 90f9ad89af0d..34b4555d1223 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1,6 +1,4 @@
 /*
- * linux/drivers/video/omap2/dss/dispc.c
- *
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
  *

commit 867d7e0212170a24f0889e940a5b05ee34551e27
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Nov 30 14:12:36 2017 +0200

    drm/omap: dss: Add support for reporting memory bandwidth limitation
    
    The get_memory_bandwidth_limit() in dispc_ops can be used to query the
    memory bandwidth limit of dispc by upper layers.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 0f4fdb221498..90f9ad89af0d 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4325,6 +4325,17 @@ static void dispc_free_irq(void *dev_id)
 	dispc.user_data = NULL;
 }
 
+static u32 dispc_get_memory_bandwidth_limit(void)
+{
+	u32 limit = 0;
+
+	/* Optional maximum memory bandwidth */
+	of_property_read_u32(dispc.pdev->dev.of_node, "max-memory-bandwidth",
+			     &limit);
+
+	return limit;
+}
+
 /*
  * Workaround for errata i734 in DSS dispc
  *  - LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
@@ -4497,6 +4508,8 @@ static const struct dispc_ops dispc_ops = {
 	.get_num_ovls = dispc_get_num_ovls,
 	.get_num_mgrs = dispc_get_num_mgrs,
 
+	.get_memory_bandwidth_limit = dispc_get_memory_bandwidth_limit,
+
 	.mgr_enable = dispc_mgr_enable,
 	.mgr_is_enabled = dispc_mgr_is_enabled,
 	.mgr_get_vsync_irq = dispc_mgr_get_vsync_irq,

commit d874b3a7c44ca48c0e57b8744c1eed2a6d299ba1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:19 2017 +0300

    drm: omapdrm: Remove dss_features.h
    
    The header file only contains four macros, two of which are never used.
    Move the other two to dss.h and remove dss_features.h.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 4160d11e0930..0f4fdb221498 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -47,7 +47,6 @@
 
 #include "omapdss.h"
 #include "dss.h"
-#include "dss_features.h"
 #include "dispc.h"
 
 /* DISPC */

commit 51919572c89a0c5dcf0cfff4ba4b36e175f091c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:18 2017 +0300

    drm: omapdrm: Move supported outputs feature to dss driver
    
    The supported outputs feature is specific to the DSS, move it from the
    omap_dss_features structure to the dss driver.
    
    The omap_dss_features structure is now empty and can be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 39a10665a91f..4160d11e0930 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2736,7 +2736,7 @@ static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
 
 static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
 {
-	return dss_feat_get_supported_outputs(channel);
+	return dss_get_supported_outputs(channel);
 }
 
 static void dispc_lcd_enable_signal_polarity(bool act_high)

commit 9f0fbaea5cd6b6a0a75a53f99e5c6b3049dd0ce1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:17 2017 +0300

    drm: omapdrm: Move DSS_FCK feature to dss driver
    
    The FEAT_PARAM_DSS_FCK feature is specific to the DSS, move it from the
    omap_dss_features structure to the dss driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 49c9c46428f9..39a10665a91f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3502,7 +3502,7 @@ bool dispc_div_calc(unsigned long dispc_freq,
 	pckd_hw_min = dispc.feat->min_pcd;
 	pckd_hw_max = 255;
 
-	lck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+	lck_max = dss_get_max_fck_rate();
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;

commit c4ff6ea60eb13953df58d786ffadce47e0c90ceb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:16 2017 +0300

    drm: omapdrm: Move PCD, LINEWIDTH and DOWNSCALE features to dispc driver
    
    The FEAT_PARAM_DSS_PCD, FEAT_PARAM_LINEWIDTH and FEAT_PARAM_DOWNSCALE
    features are specific to the DISPC, move them from the omap_dss_features
    structure to the dispc driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 23f887ce4936..49c9c46428f9 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -105,6 +105,9 @@ struct dispc_features {
 	u16 mgr_height_max;
 	unsigned long max_lcd_pclk;
 	unsigned long max_tv_pclk;
+	unsigned int max_downscale;
+	unsigned int max_line_width;
+	unsigned int min_pcd;
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
@@ -2207,8 +2210,7 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 	int error;
 	u16 in_width, in_height;
 	int min_factor = min(*decim_x, *decim_y);
-	const int maxsinglelinewidth =
-			dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
+	const int maxsinglelinewidth = dispc.feat->max_line_width;
 
 	*five_taps = false;
 
@@ -2252,8 +2254,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 {
 	int error;
 	u16 in_width, in_height;
-	const int maxsinglelinewidth =
-			dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
+	const int maxsinglelinewidth = dispc.feat->max_line_width;
 
 	do {
 		in_height = height / *decim_y;
@@ -2338,9 +2339,8 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 	u16 in_width, in_width_max;
 	int decim_x_min = *decim_x;
 	u16 in_height = height / *decim_y;
-	const int maxsinglelinewidth =
-				dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
-	const int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);
+	const int maxsinglelinewidth = dispc.feat->max_line_width;
+	const int maxdownscale = dispc.feat->max_downscale;
 
 	if (mem_to_mem) {
 		in_width_max = out_width * maxdownscale;
@@ -2400,7 +2400,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		int *x_predecim, int *y_predecim, u16 pos_x,
 		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
 {
-	const int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);
+	const int maxdownscale = dispc.feat->max_downscale;
 	const int max_decim_limit = 16;
 	unsigned long core_clk = 0;
 	int decim_x, decim_y, ret;
@@ -3481,7 +3481,7 @@ int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
 	return 0;
 }
 
-bool dispc_div_calc(unsigned long dispc,
+bool dispc_div_calc(unsigned long dispc_freq,
 		unsigned long pck_min, unsigned long pck_max,
 		dispc_div_calc_func func, void *data)
 {
@@ -3499,19 +3499,19 @@ bool dispc_div_calc(unsigned long dispc,
 	min_fck_per_pck = 0;
 #endif
 
-	pckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);
-	pckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);
+	pckd_hw_min = dispc.feat->min_pcd;
+	pckd_hw_max = 255;
 
 	lck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;
 
-	lckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);
-	lckd_stop = min(dispc / pck_min, 255ul);
+	lckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);
+	lckd_stop = min(dispc_freq / pck_min, 255ul);
 
 	for (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {
-		lck = dispc / lckd;
+		lck = dispc_freq / lckd;
 
 		pckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);
 		pckd_stop = min(lck / pck_min, pckd_hw_max);
@@ -4047,6 +4047,13 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.mgr_width_max		=	2048,
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	66500000,
+	.max_downscale		=	2,
+	/*
+	 * Assume the line width buffer to be 768 pixels as OMAP2 DISPC scaler
+	 * cannot scale an image width larger than 768.
+	 */
+	.max_line_width		=	768,
+	.min_pcd		=	2,
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
@@ -4078,6 +4085,9 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	173000000,
 	.max_tv_pclk		=	59000000,
+	.max_downscale		=	4,
+	.max_line_width		=	1024,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
@@ -4109,6 +4119,9 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	173000000,
 	.max_tv_pclk		=	59000000,
+	.max_downscale		=	4,
+	.max_line_width		=	1024,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
@@ -4140,6 +4153,9 @@ static const struct dispc_features omap36xx_dispc_feats = {
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	173000000,
 	.max_tv_pclk		=	59000000,
+	.max_downscale		=	4,
+	.max_line_width		=	1024,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
@@ -4171,6 +4187,9 @@ static const struct dispc_features am43xx_dispc_feats = {
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	173000000,
 	.max_tv_pclk		=	59000000,
+	.max_downscale		=	4,
+	.max_line_width		=	1024,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
@@ -4202,6 +4221,9 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.mgr_height_max		=	2048,
 	.max_lcd_pclk		=	170000000,
 	.max_tv_pclk		=	185625000,
+	.max_downscale		=	4,
+	.max_line_width		=	2048,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
@@ -4238,6 +4260,9 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.mgr_height_max		=	4096,
 	.max_lcd_pclk		=	170000000,
 	.max_tv_pclk		=	186000000,
+	.max_downscale		=	4,
+	.max_line_width		=	2048,
+	.min_pcd		=	1,
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,

commit 1ac0c894032692d3cb25583e33ceaea78cc8ab4b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:14 2017 +0300

    drm: omapdrm: Move FEAT_* features to dispc driver
    
    All the remaining FEAT_* features are specific to the DISPC, move them
    from the omap_dss_features structure to the dispc driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 3ad52c04a299..23f887ce4936 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -65,6 +65,33 @@ enum omap_burst_size {
 #define REG_FLD_MOD(idx, val, start, end)				\
 	dispc_write_reg(idx, FLD_MOD(dispc_read_reg(idx), val, start, end))
 
+/* DISPC has feature id */
+enum dispc_feature_id {
+	FEAT_LCDENABLEPOL,
+	FEAT_LCDENABLESIGNAL,
+	FEAT_PCKFREEENABLE,
+	FEAT_FUNCGATED,
+	FEAT_MGR_LCD2,
+	FEAT_MGR_LCD3,
+	FEAT_LINEBUFFERSPLIT,
+	FEAT_ROWREPEATENABLE,
+	FEAT_RESIZECONF,
+	/* Independent core clk divider */
+	FEAT_CORE_CLK_DIV,
+	FEAT_HANDLE_UV_SEPARATE,
+	FEAT_ATTR2,
+	FEAT_CPR,
+	FEAT_PRELOAD,
+	FEAT_FIR_COEF_V,
+	FEAT_ALPHA_FIXED_ZORDER,
+	FEAT_ALPHA_FREE_ZORDER,
+	FEAT_FIFO_MERGE,
+	/* An unknown HW bug causing the normal FIFO thresholds not to work */
+	FEAT_OMAP3_DSI_FIFO_BUG,
+	FEAT_BURST_2D,
+	FEAT_MFLAG,
+};
+
 struct dispc_features {
 	u8 sw_start;
 	u8 fp_start;
@@ -88,6 +115,8 @@ struct dispc_features {
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool mem_to_mem);
 	u8 num_fifos;
+	const enum dispc_feature_id *features;
+	unsigned int num_features;
 	const struct dss_reg_field *reg_fields;
 	const unsigned int num_reg_fields;
 	const enum omap_overlay_caps *overlay_caps;
@@ -384,6 +413,18 @@ static void dispc_get_reg_field(enum dispc_feat_reg_field id,
 	*end = dispc.feat->reg_fields[id].end;
 }
 
+static bool dispc_has_feature(enum dispc_feature_id id)
+{
+	unsigned int i;
+
+	for (i = 0; i < dispc.feat->num_features; i++) {
+		if (dispc.feat->features[i] == id)
+			return true;
+	}
+
+	return false;
+}
+
 #define SR(reg) \
 	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
 #define RR(reg) \
@@ -399,14 +440,14 @@ static void dispc_save_context(void)
 	SR(CONTROL);
 	SR(CONFIG);
 	SR(LINE_NUMBER);
-	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		SR(GLOBAL_ALPHA);
-	if (dss_has_feature(FEAT_MGR_LCD2)) {
+	if (dispc_has_feature(FEAT_MGR_LCD2)) {
 		SR(CONTROL2);
 		SR(CONFIG2);
 	}
-	if (dss_has_feature(FEAT_MGR_LCD3)) {
+	if (dispc_has_feature(FEAT_MGR_LCD3)) {
 		SR(CONTROL3);
 		SR(CONFIG3);
 	}
@@ -426,7 +467,7 @@ static void dispc_save_context(void)
 		SR(DATA_CYCLE2(i));
 		SR(DATA_CYCLE3(i));
 
-		if (dss_has_feature(FEAT_CPR)) {
+		if (dispc_has_feature(FEAT_CPR)) {
 			SR(CPR_COEF_R(i));
 			SR(CPR_COEF_G(i));
 			SR(CPR_COEF_B(i));
@@ -442,7 +483,7 @@ static void dispc_save_context(void)
 		SR(OVL_FIFO_THRESHOLD(i));
 		SR(OVL_ROW_INC(i));
 		SR(OVL_PIXEL_INC(i));
-		if (dss_has_feature(FEAT_PRELOAD))
+		if (dispc_has_feature(FEAT_PRELOAD))
 			SR(OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
 			SR(OVL_WINDOW_SKIP(i));
@@ -463,12 +504,12 @@ static void dispc_save_context(void)
 		for (j = 0; j < 5; j++)
 			SR(OVL_CONV_COEF(i, j));
 
-		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
 				SR(OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
 			SR(OVL_BA0_UV(i));
 			SR(OVL_BA1_UV(i));
 			SR(OVL_FIR2(i));
@@ -484,11 +525,11 @@ static void dispc_save_context(void)
 			for (j = 0; j < 8; j++)
 				SR(OVL_FIR_COEF_V2(i, j));
 		}
-		if (dss_has_feature(FEAT_ATTR2))
+		if (dispc_has_feature(FEAT_ATTR2))
 			SR(OVL_ATTRIBUTES2(i));
 	}
 
-	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
 		SR(DIVISOR);
 
 	dispc.ctx_valid = true;
@@ -509,12 +550,12 @@ static void dispc_restore_context(void)
 	/*RR(CONTROL);*/
 	RR(CONFIG);
 	RR(LINE_NUMBER);
-	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		RR(GLOBAL_ALPHA);
-	if (dss_has_feature(FEAT_MGR_LCD2))
+	if (dispc_has_feature(FEAT_MGR_LCD2))
 		RR(CONFIG2);
-	if (dss_has_feature(FEAT_MGR_LCD3))
+	if (dispc_has_feature(FEAT_MGR_LCD3))
 		RR(CONFIG3);
 
 	for (i = 0; i < dispc_get_num_mgrs(); i++) {
@@ -532,7 +573,7 @@ static void dispc_restore_context(void)
 		RR(DATA_CYCLE2(i));
 		RR(DATA_CYCLE3(i));
 
-		if (dss_has_feature(FEAT_CPR)) {
+		if (dispc_has_feature(FEAT_CPR)) {
 			RR(CPR_COEF_R(i));
 			RR(CPR_COEF_G(i));
 			RR(CPR_COEF_B(i));
@@ -548,7 +589,7 @@ static void dispc_restore_context(void)
 		RR(OVL_FIFO_THRESHOLD(i));
 		RR(OVL_ROW_INC(i));
 		RR(OVL_PIXEL_INC(i));
-		if (dss_has_feature(FEAT_PRELOAD))
+		if (dispc_has_feature(FEAT_PRELOAD))
 			RR(OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
 			RR(OVL_WINDOW_SKIP(i));
@@ -569,12 +610,12 @@ static void dispc_restore_context(void)
 		for (j = 0; j < 5; j++)
 			RR(OVL_CONV_COEF(i, j));
 
-		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
 				RR(OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
 			RR(OVL_BA0_UV(i));
 			RR(OVL_BA1_UV(i));
 			RR(OVL_FIR2(i));
@@ -590,18 +631,18 @@ static void dispc_restore_context(void)
 			for (j = 0; j < 8; j++)
 				RR(OVL_FIR_COEF_V2(i, j));
 		}
-		if (dss_has_feature(FEAT_ATTR2))
+		if (dispc_has_feature(FEAT_ATTR2))
 			RR(OVL_ATTRIBUTES2(i));
 	}
 
-	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
 		RR(DIVISOR);
 
 	/* enable last, because LCD & DIGIT enable are here */
 	RR(CONTROL);
-	if (dss_has_feature(FEAT_MGR_LCD2))
+	if (dispc_has_feature(FEAT_MGR_LCD2))
 		RR(CONTROL2);
-	if (dss_has_feature(FEAT_MGR_LCD3))
+	if (dispc_has_feature(FEAT_MGR_LCD3))
 		RR(CONTROL3);
 	/* clear spurious SYNC_LOST_DIGIT interrupts */
 	dispc_clear_irqstatus(DISPC_IRQ_SYNC_LOST_DIGIT);
@@ -909,7 +950,7 @@ static void dispc_ovl_enable_zorder_planes(void)
 {
 	int i;
 
-	if (!dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (!dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		return;
 
 	for (i = 0; i < dispc_get_num_ovls(); i++)
@@ -1035,7 +1076,7 @@ static bool format_is_yuv(u32 fourcc)
 static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
 		enum omap_dss_rotation_type rotation_type)
 {
-	if (dss_has_feature(FEAT_BURST_2D) == 0)
+	if (dispc_has_feature(FEAT_BURST_2D) == 0)
 		return;
 
 	if (rotation_type == OMAP_DSS_ROT_TILER)
@@ -1066,7 +1107,7 @@ static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
 	}
 
 	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
-	if (dss_has_feature(FEAT_MGR_LCD2)) {
+	if (dispc_has_feature(FEAT_MGR_LCD2)) {
 		switch (channel) {
 		case OMAP_DSS_CHANNEL_LCD:
 			chan = 0;
@@ -1081,7 +1122,7 @@ static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
 			chan2 = 1;
 			break;
 		case OMAP_DSS_CHANNEL_LCD3:
-			if (dss_has_feature(FEAT_MGR_LCD3)) {
+			if (dispc_has_feature(FEAT_MGR_LCD3)) {
 				chan = 0;
 				chan2 = 2;
 			} else {
@@ -1130,7 +1171,7 @@ static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
 	if (FLD_GET(val, shift, shift) == 1)
 		return OMAP_DSS_CHANNEL_DIGIT;
 
-	if (!dss_has_feature(FEAT_MGR_LCD2))
+	if (!dispc_has_feature(FEAT_MGR_LCD2))
 		return OMAP_DSS_CHANNEL_LCD;
 
 	switch (FLD_GET(val, 31, 30)) {
@@ -1385,14 +1426,14 @@ void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
 	 * large for the preload field, set the threshold to the maximum value
 	 * that can be held by the preload register
 	 */
-	if (dss_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&
+	if (dispc_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&
 			plane != OMAP_DSS_WB)
 		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
 }
 
 void dispc_enable_fifomerge(bool enable)
 {
-	if (!dss_has_feature(FEAT_FIFO_MERGE)) {
+	if (!dispc_has_feature(FEAT_FIFO_MERGE)) {
 		WARN_ON(enable);
 		return;
 	}
@@ -1431,7 +1472,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 	 * combined fifo size
 	 */
 
-	if (manual_update && dss_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {
+	if (manual_update && dispc_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {
 		*fifo_low = ovl_fifo_size - burst_size * 2;
 		*fifo_high = total_fifo_size - burst_size;
 	} else if (plane == OMAP_DSS_WB) {
@@ -1719,14 +1760,14 @@ static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 	l |= five_taps ? (1 << 21) : 0;
 
 	/* VRESIZECONF and HRESIZECONF */
-	if (dss_has_feature(FEAT_RESIZECONF)) {
+	if (dispc_has_feature(FEAT_RESIZECONF)) {
 		l &= ~(0x3 << 7);
 		l |= (orig_width <= out_width) ? 0 : (1 << 7);
 		l |= (orig_height <= out_height) ? 0 : (1 << 8);
 	}
 
 	/* LINEBUFFERSPLIT */
-	if (dss_has_feature(FEAT_LINEBUFFERSPLIT)) {
+	if (dispc_has_feature(FEAT_LINEBUFFERSPLIT)) {
 		l &= ~(0x1 << 22);
 		l |= five_taps ? (1 << 22) : 0;
 	}
@@ -1761,7 +1802,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 	int scale_y = out_height != orig_height;
 	bool chroma_upscale = plane != OMAP_DSS_WB;
 
-	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
+	if (!dispc_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
 
 	if (!format_is_yuv(fourcc)) {
@@ -1908,7 +1949,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		vidrot = 1;
 
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
-	if (dss_has_feature(FEAT_ROWREPEATENABLE))
+	if (dispc_has_feature(FEAT_ROWREPEATENABLE))
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
@@ -2380,7 +2421,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	} else {
 		*x_predecim = max_decim_limit;
 		*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&
-				dss_has_feature(FEAT_BURST_2D)) ?
+				dispc_has_feature(FEAT_BURST_2D)) ?
 				2 : max_decim_limit;
 	}
 
@@ -2700,7 +2741,7 @@ static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel
 
 static void dispc_lcd_enable_signal_polarity(bool act_high)
 {
-	if (!dss_has_feature(FEAT_LCDENABLEPOL))
+	if (!dispc_has_feature(FEAT_LCDENABLEPOL))
 		return;
 
 	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
@@ -2708,7 +2749,7 @@ static void dispc_lcd_enable_signal_polarity(bool act_high)
 
 void dispc_lcd_enable_signal(bool enable)
 {
-	if (!dss_has_feature(FEAT_LCDENABLESIGNAL))
+	if (!dispc_has_feature(FEAT_LCDENABLESIGNAL))
 		return;
 
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
@@ -2716,7 +2757,7 @@ void dispc_lcd_enable_signal(bool enable)
 
 void dispc_pck_free_enable(bool enable)
 {
-	if (!dss_has_feature(FEAT_PCKFREEENABLE))
+	if (!dispc_has_feature(FEAT_PCKFREEENABLE))
 		return;
 
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
@@ -2761,7 +2802,7 @@ static void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)
 static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
 		bool enable)
 {
-	if (!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))
+	if (!dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER))
 		return;
 
 	if (ch == OMAP_DSS_CHANNEL_LCD)
@@ -2778,7 +2819,7 @@ static void dispc_mgr_setup(enum omap_channel channel,
 	dispc_mgr_enable_trans_key(channel, info->trans_enabled);
 	dispc_mgr_enable_alpha_fixed_zorder(channel,
 			info->partial_alpha_enabled);
-	if (dss_has_feature(FEAT_CPR)) {
+	if (dispc_has_feature(FEAT_CPR)) {
 		dispc_mgr_enable_cpr(channel, info->cpr_enable);
 		dispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);
 	}
@@ -3056,7 +3097,7 @@ static void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,
 	dispc_write_reg(DISPC_DIVISORo(channel),
 			FLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));
 
-	if (!dss_has_feature(FEAT_CORE_CLK_DIV) &&
+	if (!dispc_has_feature(FEAT_CORE_CLK_DIV) &&
 			channel == OMAP_DSS_CHANNEL_LCD)
 		dispc.core_clk_rate = dispc_fclk_rate() / lck_div;
 }
@@ -3211,7 +3252,7 @@ void dispc_dump_clocks(struct seq_file *s)
 
 	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
 
-	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
 		seq_printf(s, "- DISPC-CORE-CLK -\n");
 		l = dispc_read_reg(DISPC_DIVISOR);
 		lcd = FLD_GET(l, 23, 16);
@@ -3222,9 +3263,9 @@ void dispc_dump_clocks(struct seq_file *s)
 
 	dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);
 
-	if (dss_has_feature(FEAT_MGR_LCD2))
+	if (dispc_has_feature(FEAT_MGR_LCD2))
 		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);
-	if (dss_has_feature(FEAT_MGR_LCD3))
+	if (dispc_has_feature(FEAT_MGR_LCD3))
 		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
 
 	dispc_runtime_put();
@@ -3264,18 +3305,18 @@ static void dispc_dump_regs(struct seq_file *s)
 	DUMPREG(DISPC_CAPABLE);
 	DUMPREG(DISPC_LINE_STATUS);
 	DUMPREG(DISPC_LINE_NUMBER);
-	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		DUMPREG(DISPC_GLOBAL_ALPHA);
-	if (dss_has_feature(FEAT_MGR_LCD2)) {
+	if (dispc_has_feature(FEAT_MGR_LCD2)) {
 		DUMPREG(DISPC_CONTROL2);
 		DUMPREG(DISPC_CONFIG2);
 	}
-	if (dss_has_feature(FEAT_MGR_LCD3)) {
+	if (dispc_has_feature(FEAT_MGR_LCD3)) {
 		DUMPREG(DISPC_CONTROL3);
 		DUMPREG(DISPC_CONFIG3);
 	}
-	if (dss_has_feature(FEAT_MFLAG))
+	if (dispc_has_feature(FEAT_MFLAG))
 		DUMPREG(DISPC_GLOBAL_MFLAG_ATTRIBUTE);
 
 #undef DUMPREG
@@ -3305,7 +3346,7 @@ static void dispc_dump_regs(struct seq_file *s)
 		DUMPREG(i, DISPC_DATA_CYCLE2);
 		DUMPREG(i, DISPC_DATA_CYCLE3);
 
-		if (dss_has_feature(FEAT_CPR)) {
+		if (dispc_has_feature(FEAT_CPR)) {
 			DUMPREG(i, DISPC_CPR_COEF_R);
 			DUMPREG(i, DISPC_CPR_COEF_G);
 			DUMPREG(i, DISPC_CPR_COEF_B);
@@ -3325,9 +3366,9 @@ static void dispc_dump_regs(struct seq_file *s)
 		DUMPREG(i, DISPC_OVL_ROW_INC);
 		DUMPREG(i, DISPC_OVL_PIXEL_INC);
 
-		if (dss_has_feature(FEAT_PRELOAD))
+		if (dispc_has_feature(FEAT_PRELOAD))
 			DUMPREG(i, DISPC_OVL_PRELOAD);
-		if (dss_has_feature(FEAT_MFLAG))
+		if (dispc_has_feature(FEAT_MFLAG))
 			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
 
 		if (i == OMAP_DSS_GFX) {
@@ -3340,14 +3381,14 @@ static void dispc_dump_regs(struct seq_file *s)
 		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
 		DUMPREG(i, DISPC_OVL_ACCU0);
 		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
 			DUMPREG(i, DISPC_OVL_BA0_UV);
 			DUMPREG(i, DISPC_OVL_BA1_UV);
 			DUMPREG(i, DISPC_OVL_FIR2);
 			DUMPREG(i, DISPC_OVL_ACCU2_0);
 			DUMPREG(i, DISPC_OVL_ACCU2_1);
 		}
-		if (dss_has_feature(FEAT_ATTR2))
+		if (dispc_has_feature(FEAT_ATTR2))
 			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
 	}
 
@@ -3362,21 +3403,21 @@ static void dispc_dump_regs(struct seq_file *s)
 		DUMPREG(i, DISPC_OVL_ROW_INC);
 		DUMPREG(i, DISPC_OVL_PIXEL_INC);
 
-		if (dss_has_feature(FEAT_MFLAG))
+		if (dispc_has_feature(FEAT_MFLAG))
 			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
 
 		DUMPREG(i, DISPC_OVL_FIR);
 		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
 		DUMPREG(i, DISPC_OVL_ACCU0);
 		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
 			DUMPREG(i, DISPC_OVL_BA0_UV);
 			DUMPREG(i, DISPC_OVL_BA1_UV);
 			DUMPREG(i, DISPC_OVL_FIR2);
 			DUMPREG(i, DISPC_OVL_ACCU2_0);
 			DUMPREG(i, DISPC_OVL_ACCU2_1);
 		}
-		if (dss_has_feature(FEAT_ATTR2))
+		if (dispc_has_feature(FEAT_ATTR2))
 			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
 	}
 
@@ -3402,12 +3443,12 @@ static void dispc_dump_regs(struct seq_file *s)
 		for (j = 0; j < 5; j++)
 			DUMPREG(i, DISPC_OVL_CONV_COEF, j);
 
-		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
 				DUMPREG(i, DISPC_OVL_FIR_COEF_V, j);
 		}
 
-		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
 			for (j = 0; j < 8; j++)
 				DUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);
 
@@ -3484,7 +3525,7 @@ bool dispc_div_calc(unsigned long dispc,
 			 * also. Thus we need to use the calculated lck. For
 			 * OMAP4+ the DISPC fclk is a separate clock.
 			 */
-			if (dss_has_feature(FEAT_CORE_CLK_DIV))
+			if (dispc_has_feature(FEAT_CORE_CLK_DIV))
 				fck = dispc_core_clk_rate();
 			else
 				fck = lck;
@@ -3599,10 +3640,10 @@ static void dispc_restore_gamma_tables(void)
 
 	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_DIGIT);
 
-	if (dss_has_feature(FEAT_MGR_LCD2))
+	if (dispc_has_feature(FEAT_MGR_LCD2))
 		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD2);
 
-	if (dss_has_feature(FEAT_MGR_LCD3))
+	if (dispc_has_feature(FEAT_MGR_LCD3))
 		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD3);
 }
 
@@ -3670,11 +3711,11 @@ static int dispc_init_gamma_tables(void)
 		u32 *gt;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD2 &&
-		    !dss_has_feature(FEAT_MGR_LCD2))
+		    !dispc_has_feature(FEAT_MGR_LCD2))
 			continue;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD3 &&
-		    !dss_has_feature(FEAT_MGR_LCD3))
+		    !dispc_has_feature(FEAT_MGR_LCD3))
 			continue;
 
 		gt = devm_kmalloc_array(&dispc.pdev->dev, gdesc->len,
@@ -3694,7 +3735,7 @@ static void _omap_dispc_initial_config(void)
 	u32 l;
 
 	/* Exclusively enable DISPC_CORE_CLK and set divider to 1 */
-	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
 		l = dispc_read_reg(DISPC_DIVISOR);
 		/* Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */
 		l = FLD_MOD(l, 1, 0, 0);
@@ -3712,7 +3753,7 @@ static void _omap_dispc_initial_config(void)
 	 * func-clock auto-gating. For newer versions
 	 * (dispc.feat->has_gamma_table) this enables tv-out gamma tables.
 	 */
-	if (dss_has_feature(FEAT_FUNCGATED) || dispc.feat->has_gamma_table)
+	if (dispc_has_feature(FEAT_FUNCGATED) || dispc.feat->has_gamma_table)
 		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
 
 	dispc_setup_color_conv_coef();
@@ -3728,10 +3769,78 @@ static void _omap_dispc_initial_config(void)
 	if (dispc.feat->mstandby_workaround)
 		REG_FLD_MOD(DISPC_MSTANDBY_CTRL, 1, 0, 0);
 
-	if (dss_has_feature(FEAT_MFLAG))
+	if (dispc_has_feature(FEAT_MFLAG))
 		dispc_init_mflag();
 }
 
+static const enum dispc_feature_id omap2_dispc_features_list[] = {
+	FEAT_LCDENABLEPOL,
+	FEAT_LCDENABLESIGNAL,
+	FEAT_PCKFREEENABLE,
+	FEAT_FUNCGATED,
+	FEAT_ROWREPEATENABLE,
+	FEAT_RESIZECONF,
+};
+
+static const enum dispc_feature_id omap3_dispc_features_list[] = {
+	FEAT_LCDENABLEPOL,
+	FEAT_LCDENABLESIGNAL,
+	FEAT_PCKFREEENABLE,
+	FEAT_FUNCGATED,
+	FEAT_LINEBUFFERSPLIT,
+	FEAT_ROWREPEATENABLE,
+	FEAT_RESIZECONF,
+	FEAT_CPR,
+	FEAT_PRELOAD,
+	FEAT_FIR_COEF_V,
+	FEAT_ALPHA_FIXED_ZORDER,
+	FEAT_FIFO_MERGE,
+	FEAT_OMAP3_DSI_FIFO_BUG,
+};
+
+static const enum dispc_feature_id am43xx_dispc_features_list[] = {
+	FEAT_LCDENABLEPOL,
+	FEAT_LCDENABLESIGNAL,
+	FEAT_PCKFREEENABLE,
+	FEAT_FUNCGATED,
+	FEAT_LINEBUFFERSPLIT,
+	FEAT_ROWREPEATENABLE,
+	FEAT_RESIZECONF,
+	FEAT_CPR,
+	FEAT_PRELOAD,
+	FEAT_FIR_COEF_V,
+	FEAT_ALPHA_FIXED_ZORDER,
+	FEAT_FIFO_MERGE,
+};
+
+static const enum dispc_feature_id omap4_dispc_features_list[] = {
+	FEAT_MGR_LCD2,
+	FEAT_CORE_CLK_DIV,
+	FEAT_HANDLE_UV_SEPARATE,
+	FEAT_ATTR2,
+	FEAT_CPR,
+	FEAT_PRELOAD,
+	FEAT_FIR_COEF_V,
+	FEAT_ALPHA_FREE_ZORDER,
+	FEAT_FIFO_MERGE,
+	FEAT_BURST_2D,
+};
+
+static const enum dispc_feature_id omap5_dispc_features_list[] = {
+	FEAT_MGR_LCD2,
+	FEAT_MGR_LCD3,
+	FEAT_CORE_CLK_DIV,
+	FEAT_HANDLE_UV_SEPARATE,
+	FEAT_ATTR2,
+	FEAT_CPR,
+	FEAT_PRELOAD,
+	FEAT_FIR_COEF_V,
+	FEAT_ALPHA_FREE_ZORDER,
+	FEAT_FIFO_MERGE,
+	FEAT_BURST_2D,
+	FEAT_MFLAG,
+};
+
 static const struct dss_reg_field omap2_dispc_reg_fields[] = {
 	[FEAT_REG_FIRHINC]			= { 11, 0 },
 	[FEAT_REG_FIRVINC]			= { 27, 16 },
@@ -3941,6 +4050,8 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
+	.features		=	omap2_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap2_dispc_features_list),
 	.reg_fields		=	omap2_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap2_dispc_reg_fields),
 	.overlay_caps		=	omap2_dispc_overlay_caps,
@@ -3970,6 +4081,8 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.features		=	omap3_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap3_dispc_features_list),
 	.reg_fields		=	omap3_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
@@ -3999,6 +4112,8 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.features		=	omap3_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap3_dispc_features_list),
 	.reg_fields		=	omap3_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
@@ -4028,6 +4143,8 @@ static const struct dispc_features omap36xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.features		=	omap3_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap3_dispc_features_list),
 	.reg_fields		=	omap3_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3630_dispc_overlay_caps,
@@ -4057,6 +4174,8 @@ static const struct dispc_features am43xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.features		=	am43xx_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(am43xx_dispc_features_list),
 	.reg_fields		=	omap3_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
@@ -4086,6 +4205,8 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.features		=	omap4_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap4_dispc_features_list),
 	.reg_fields		=	omap4_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap4_dispc_reg_fields),
 	.overlay_caps		=	omap4_dispc_overlay_caps,
@@ -4120,6 +4241,8 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.features		=	omap5_dispc_features_list,
+	.num_features		=	ARRAY_SIZE(omap5_dispc_features_list),
 	.reg_fields		=	omap4_dispc_reg_fields,
 	.num_reg_fields		=	ARRAY_SIZE(omap4_dispc_reg_fields),
 	.overlay_caps		=	omap4_dispc_overlay_caps,

commit 38dc07039c8bc4bf5f61a127143c2cfec2d7c36a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:08 2017 +0300

    drm: omapdrm: Move reg_fields to dispc_features structure
    
    The reg_fields feature describes DISPC registers only. Move it from the
    omap_dss_features structure to the dispc_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 839425ad8a75..3ad52c04a299 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -88,6 +88,8 @@ struct dispc_features {
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool mem_to_mem);
 	u8 num_fifos;
+	const struct dss_reg_field *reg_fields;
+	const unsigned int num_reg_fields;
 	const enum omap_overlay_caps *overlay_caps;
 	const u32 **supported_color_modes;
 	unsigned int num_mgrs;
@@ -188,6 +190,17 @@ enum mgr_reg_fields {
 	DISPC_MGR_FLD_NUM,
 };
 
+/* DISPC register field id */
+enum dispc_feat_reg_field {
+	FEAT_REG_FIRHINC,
+	FEAT_REG_FIRVINC,
+	FEAT_REG_FIFOHIGHTHRESHOLD,
+	FEAT_REG_FIFOLOWTHRESHOLD,
+	FEAT_REG_FIFOSIZE,
+	FEAT_REG_HORIZONTALACCU,
+	FEAT_REG_VERTICALACCU,
+};
+
 struct dispc_reg_field {
 	u16 reg;
 	u8 high;
@@ -361,6 +374,16 @@ static int dispc_get_num_mgrs(void)
 	return dispc.feat->num_mgrs;
 }
 
+static void dispc_get_reg_field(enum dispc_feat_reg_field id,
+				u8 *start, u8 *end)
+{
+	if (id >= dispc.feat->num_reg_fields)
+		BUG();
+
+	*start = dispc.feat->reg_fields[id].start;
+	*end = dispc.feat->reg_fields[id].end;
+}
+
 #define SR(reg) \
 	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
 #define RR(reg) \
@@ -1252,7 +1275,7 @@ static void dispc_init_fifos(void)
 
 	unit = dispc.feat->buffer_size_unit;
 
-	dss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
+	dispc_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
 
 	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
 		size = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);
@@ -1342,8 +1365,8 @@ void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
 	low /= unit;
 	high /= unit;
 
-	dss_feat_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);
-	dss_feat_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);
+	dispc_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);
+	dispc_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);
 
 	DSSDBG("fifo(%d) threshold (bytes), old %u/%u, new %u/%u\n",
 			plane,
@@ -1510,10 +1533,8 @@ static void dispc_ovl_set_fir(enum omap_plane_id plane,
 	if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
 		u8 hinc_start, hinc_end, vinc_start, vinc_end;
 
-		dss_feat_get_reg_field(FEAT_REG_FIRHINC,
-					&hinc_start, &hinc_end);
-		dss_feat_get_reg_field(FEAT_REG_FIRVINC,
-					&vinc_start, &vinc_end);
+		dispc_get_reg_field(FEAT_REG_FIRHINC, &hinc_start, &hinc_end);
+		dispc_get_reg_field(FEAT_REG_FIRVINC, &vinc_start, &vinc_end);
 		val = FLD_VAL(vinc, vinc_start, vinc_end) |
 				FLD_VAL(hinc, hinc_start, hinc_end);
 
@@ -1530,8 +1551,8 @@ static void dispc_ovl_set_vid_accu0(enum omap_plane_id plane, int haccu,
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
+	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
@@ -1545,8 +1566,8 @@ static void dispc_ovl_set_vid_accu1(enum omap_plane_id plane, int haccu,
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
+	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
@@ -3711,6 +3732,36 @@ static void _omap_dispc_initial_config(void)
 		dispc_init_mflag();
 }
 
+static const struct dss_reg_field omap2_dispc_reg_fields[] = {
+	[FEAT_REG_FIRHINC]			= { 11, 0 },
+	[FEAT_REG_FIRVINC]			= { 27, 16 },
+	[FEAT_REG_FIFOLOWTHRESHOLD]		= { 8, 0 },
+	[FEAT_REG_FIFOHIGHTHRESHOLD]		= { 24, 16 },
+	[FEAT_REG_FIFOSIZE]			= { 8, 0 },
+	[FEAT_REG_HORIZONTALACCU]		= { 9, 0 },
+	[FEAT_REG_VERTICALACCU]			= { 25, 16 },
+};
+
+static const struct dss_reg_field omap3_dispc_reg_fields[] = {
+	[FEAT_REG_FIRHINC]			= { 12, 0 },
+	[FEAT_REG_FIRVINC]			= { 28, 16 },
+	[FEAT_REG_FIFOLOWTHRESHOLD]		= { 11, 0 },
+	[FEAT_REG_FIFOHIGHTHRESHOLD]		= { 27, 16 },
+	[FEAT_REG_FIFOSIZE]			= { 10, 0 },
+	[FEAT_REG_HORIZONTALACCU]		= { 9, 0 },
+	[FEAT_REG_VERTICALACCU]			= { 25, 16 },
+};
+
+static const struct dss_reg_field omap4_dispc_reg_fields[] = {
+	[FEAT_REG_FIRHINC]			= { 12, 0 },
+	[FEAT_REG_FIRVINC]			= { 28, 16 },
+	[FEAT_REG_FIFOLOWTHRESHOLD]		= { 15, 0 },
+	[FEAT_REG_FIFOHIGHTHRESHOLD]		= { 31, 16 },
+	[FEAT_REG_FIFOSIZE]			= { 15, 0 },
+	[FEAT_REG_HORIZONTALACCU]		= { 10, 0 },
+	[FEAT_REG_VERTICALACCU]			= { 26, 16 },
+};
+
 static const enum omap_overlay_caps omap2_dispc_overlay_caps[] = {
 	/* OMAP_DSS_GFX */
 	OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
@@ -3890,6 +3941,8 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
+	.reg_fields		=	omap2_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap2_dispc_reg_fields),
 	.overlay_caps		=	omap2_dispc_overlay_caps,
 	.supported_color_modes	=	omap2_dispc_supported_color_modes,
 	.num_mgrs		=	2,
@@ -3917,6 +3970,8 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.reg_fields		=	omap3_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.num_mgrs		=	2,
@@ -3944,6 +3999,8 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.reg_fields		=	omap3_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.num_mgrs		=	2,
@@ -3971,6 +4028,8 @@ static const struct dispc_features omap36xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.reg_fields		=	omap3_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3630_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.num_mgrs		=	2,
@@ -3998,6 +4057,8 @@ static const struct dispc_features am43xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.reg_fields		=	omap3_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap3_dispc_reg_fields),
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.num_mgrs		=	1,
@@ -4025,6 +4086,8 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.reg_fields		=	omap4_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap4_dispc_reg_fields),
 	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.num_mgrs		=	3,
@@ -4057,6 +4120,8 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.reg_fields		=	omap4_dispc_reg_fields,
+	.num_reg_fields		=	ARRAY_SIZE(omap4_dispc_reg_fields),
 	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.num_mgrs		=	4,

commit acf591c6aa1ef27b80da36e9f707b0efe003a03f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:06 2017 +0300

    drm: omapdrm: Move num_ovls and num_mgrs to dispc_features structure
    
    The num_ovls and num_mgrs are dispc features. Move them from the
    omap_dss_features structure to the dispc_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index c013bfd66865..839425ad8a75 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -90,6 +90,8 @@ struct dispc_features {
 	u8 num_fifos;
 	const enum omap_overlay_caps *overlay_caps;
 	const u32 **supported_color_modes;
+	unsigned int num_mgrs;
+	unsigned int num_ovls;
 	unsigned int buffer_size_unit;
 	unsigned int burst_size_unit;
 
@@ -349,6 +351,16 @@ static void mgr_fld_write(enum omap_channel channel,
 		spin_unlock_irqrestore(&dispc.control_lock, flags);
 }
 
+static int dispc_get_num_ovls(void)
+{
+	return dispc.feat->num_ovls;
+}
+
+static int dispc_get_num_mgrs(void)
+{
+	return dispc.feat->num_mgrs;
+}
+
 #define SR(reg) \
 	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
 #define RR(reg) \
@@ -376,7 +388,7 @@ static void dispc_save_context(void)
 		SR(CONFIG3);
 	}
 
-	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(); i++) {
 		SR(DEFAULT_COLOR(i));
 		SR(TRANS_COLOR(i));
 		SR(SIZE_MGR(i));
@@ -398,7 +410,7 @@ static void dispc_save_context(void)
 		}
 	}
 
-	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(); i++) {
 		SR(OVL_BA0(i));
 		SR(OVL_BA1(i));
 		SR(OVL_POSITION(i));
@@ -482,7 +494,7 @@ static void dispc_restore_context(void)
 	if (dss_has_feature(FEAT_MGR_LCD3))
 		RR(CONFIG3);
 
-	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(); i++) {
 		RR(DEFAULT_COLOR(i));
 		RR(TRANS_COLOR(i));
 		RR(SIZE_MGR(i));
@@ -504,7 +516,7 @@ static void dispc_restore_context(void)
 		}
 	}
 
-	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(); i++) {
 		RR(OVL_BA0(i));
 		RR(OVL_BA1(i));
 		RR(OVL_POSITION(i));
@@ -785,7 +797,7 @@ static void dispc_ovl_write_color_conv_coef(enum omap_plane_id plane,
 static void dispc_setup_color_conv_coef(void)
 {
 	int i;
-	int num_ovl = dss_feat_get_num_ovls();
+	int num_ovl = dispc_get_num_ovls();
 	const struct color_conv_coef ctbl_bt601_5_ovl = {
 		/* YUV -> RGB */
 		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
@@ -877,7 +889,7 @@ static void dispc_ovl_enable_zorder_planes(void)
 	if (!dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
 		return;
 
-	for (i = 0; i < dss_feat_get_num_ovls(); i++)
+	for (i = 0; i < dispc_get_num_ovls(); i++)
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
 }
 
@@ -1134,7 +1146,7 @@ static void dispc_configure_burst_sizes(void)
 	const int burst_size = BURST_SIZE_X8;
 
 	/* Configure burst size always to maximum size */
-	for (i = 0; i < dss_feat_get_num_ovls(); ++i)
+	for (i = 0; i < dispc_get_num_ovls(); ++i)
 		dispc_ovl_set_burst_size(i, burst_size);
 	if (dispc.feat->has_writeback)
 		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
@@ -1166,11 +1178,6 @@ static const u32 *dispc_ovl_get_color_modes(enum omap_plane_id plane)
 	return dispc.feat->supported_color_modes[plane];
 }
 
-static int dispc_get_num_ovls(void)
-{
-	return dss_feat_get_num_ovls();
-}
-
 static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT)
@@ -1285,7 +1292,7 @@ static void dispc_init_fifos(void)
 	/*
 	 * Setup default fifo thresholds.
 	 */
-	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(); ++i) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
@@ -1389,7 +1396,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
-		for (i = 0; i < dss_feat_get_num_ovls(); ++i)
+		for (i = 0; i < dispc_get_num_ovls(); ++i)
 			total_fifo_size += dispc_ovl_get_fifo_size(i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
@@ -1455,7 +1462,7 @@ static void dispc_init_mflag(void)
 		(1 << 0) |	/* MFLAG_CTRL = force always on */
 		(0 << 2));	/* MFLAG_START = disable */
 
-	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(); ++i) {
 		u32 size = dispc_ovl_get_fifo_size(i);
 		u32 unit = dispc.feat->buffer_size_unit;
 		u32 low, high;
@@ -2694,11 +2701,6 @@ void dispc_pck_free_enable(bool enable)
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
 }
 
-static int dispc_get_num_mgrs(void)
-{
-	return dss_feat_get_num_mgrs();
-}
-
 static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
 {
 	mgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
@@ -3265,7 +3267,7 @@ static void dispc_dump_regs(struct seq_file *s)
 	p_names = mgr_names;
 
 	/* DISPC channel specific registers */
-	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+	for (i = 0; i < dispc_get_num_mgrs(); i++) {
 		DUMPREG(i, DISPC_DEFAULT_COLOR);
 		DUMPREG(i, DISPC_TRANS_COLOR);
 		DUMPREG(i, DISPC_SIZE_MGR);
@@ -3291,7 +3293,7 @@ static void dispc_dump_regs(struct seq_file *s)
 
 	p_names = ovl_names;
 
-	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+	for (i = 0; i < dispc_get_num_ovls(); i++) {
 		DUMPREG(i, DISPC_OVL_BA0);
 		DUMPREG(i, DISPC_OVL_BA1);
 		DUMPREG(i, DISPC_OVL_POSITION);
@@ -3369,7 +3371,7 @@ static void dispc_dump_regs(struct seq_file *s)
 	/* Video pipeline coefficient registers */
 
 	/* start from OMAP_DSS_VIDEO1 */
-	for (i = 1; i < dss_feat_get_num_ovls(); i++) {
+	for (i = 1; i < dispc_get_num_ovls(); i++) {
 		for (j = 0; j < 8; j++)
 			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
 
@@ -3890,6 +3892,8 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.num_fifos		=	3,
 	.overlay_caps		=	omap2_dispc_overlay_caps,
 	.supported_color_modes	=	omap2_dispc_supported_color_modes,
+	.num_mgrs		=	2,
+	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3915,6 +3919,8 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.num_fifos		=	3,
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.num_mgrs		=	2,
+	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3940,6 +3946,8 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.num_fifos		=	3,
 	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.num_mgrs		=	2,
+	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3965,6 +3973,35 @@ static const struct dispc_features omap36xx_dispc_feats = {
 	.num_fifos		=	3,
 	.overlay_caps		=	omap3630_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.num_mgrs		=	2,
+	.num_ovls		=	3,
+	.buffer_size_unit	=	1,
+	.burst_size_unit	=	8,
+	.no_framedone_tv	=	true,
+	.set_max_preload	=	false,
+	.last_pixel_inc_missing	=	true,
+};
+
+static const struct dispc_features am43xx_dispc_feats = {
+	.sw_start		=	7,
+	.fp_start		=	19,
+	.bp_start		=	31,
+	.sw_max			=	256,
+	.vp_max			=	4095,
+	.hp_max			=	4096,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	173000000,
+	.max_tv_pclk		=	59000000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
+	.calc_core_clk		=	calc_core_clk_34xx,
+	.num_fifos		=	3,
+	.overlay_caps		=	omap3430_dispc_overlay_caps,
+	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.num_mgrs		=	1,
+	.num_ovls		=	3,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3990,6 +4027,8 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.num_fifos		=	5,
 	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
+	.num_mgrs		=	3,
+	.num_ovls		=	4,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,
@@ -4020,6 +4059,8 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.num_fifos		=	5,
 	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
+	.num_mgrs		=	4,
+	.num_ovls		=	4,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,
@@ -4278,7 +4319,7 @@ static const struct soc_device_attribute dispc_soc_devices[] = {
 	  .revision = "ES[12].?",	.data = &omap34xx_rev1_0_dispc_feats },
 	{ .machine = "OMAP3[45]*",	.data = &omap34xx_rev3_0_dispc_feats },
 	{ .machine = "AM35*",		.data = &omap34xx_rev3_0_dispc_feats },
-	{ .machine = "AM43*",		.data = &omap34xx_rev3_0_dispc_feats },
+	{ .machine = "AM43*",		.data = &am43xx_dispc_feats },
 	{ /* sentinel */ }
 };
 
@@ -4296,7 +4337,7 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	spin_lock_init(&dispc.control_lock);
 
 	/*
-	 * The OMAP34xx and OMAP36xx can't be told apart using the compatible
+	 * The OMAP3-based models can't be told apart using the compatible
 	 * string, use SoC device matching.
 	 */
 	soc = soc_device_match(dispc_soc_devices);

commit fcd4188894dab2f08d74174edd214d7a82521167
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:05 2017 +0300

    drm: omapdrm: Move overlay caps features to dispc_features structure
    
    The overlay_caps is a dispc feature. Move it from the omap_dss_features
    structure to the dispc_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f3ae7f16e65c..c013bfd66865 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -88,6 +88,7 @@ struct dispc_features {
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool mem_to_mem);
 	u8 num_fifos;
+	const enum omap_overlay_caps *overlay_caps;
 	const u32 **supported_color_modes;
 	unsigned int buffer_size_unit;
 	unsigned int burst_size_unit;
@@ -2568,7 +2569,7 @@ static int dispc_ovl_setup(enum omap_plane_id plane,
 		enum omap_channel channel)
 {
 	int r;
-	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
+	enum omap_overlay_caps caps = dispc.feat->overlay_caps[plane];
 	const bool replication = true;
 
 	DSSDBG("dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->"
@@ -3708,6 +3709,70 @@ static void _omap_dispc_initial_config(void)
 		dispc_init_mflag();
 }
 
+static const enum omap_overlay_caps omap2_dispc_overlay_caps[] = {
+	/* OMAP_DSS_GFX */
+	OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO1 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO2 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+};
+
+static const enum omap_overlay_caps omap3430_dispc_overlay_caps[] = {
+	/* OMAP_DSS_GFX */
+	OMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO1 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO2 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |
+		OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+};
+
+static const enum omap_overlay_caps omap3630_dispc_overlay_caps[] = {
+	/* OMAP_DSS_GFX */
+	OMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA |
+		OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO1 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO2 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |
+		OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+};
+
+static const enum omap_overlay_caps omap4_dispc_overlay_caps[] = {
+	/* OMAP_DSS_GFX */
+	OMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA |
+		OMAP_DSS_OVL_CAP_ZORDER | OMAP_DSS_OVL_CAP_POS |
+		OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO1 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |
+		OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |
+		OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO2 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |
+		OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |
+		OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+
+	/* OMAP_DSS_VIDEO3 */
+	OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |
+		OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |
+		OMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,
+};
+
 #define COLOR_ARRAY(arr...) (const u32[]) { arr, 0 }
 
 static const u32 *omap2_dispc_supported_color_modes[] = {
@@ -3823,6 +3888,7 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
+	.overlay_caps		=	omap2_dispc_overlay_caps,
 	.supported_color_modes	=	omap2_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
@@ -3847,6 +3913,7 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.overlay_caps		=	omap3430_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
@@ -3871,6 +3938,32 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.overlay_caps		=	omap3430_dispc_overlay_caps,
+	.supported_color_modes	=	omap3_dispc_supported_color_modes,
+	.buffer_size_unit	=	1,
+	.burst_size_unit	=	8,
+	.no_framedone_tv	=	true,
+	.set_max_preload	=	false,
+	.last_pixel_inc_missing	=	true,
+};
+
+static const struct dispc_features omap36xx_dispc_feats = {
+	.sw_start		=	7,
+	.fp_start		=	19,
+	.bp_start		=	31,
+	.sw_max			=	256,
+	.vp_max			=	4095,
+	.hp_max			=	4096,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	173000000,
+	.max_tv_pclk		=	59000000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
+	.calc_core_clk		=	calc_core_clk_34xx,
+	.num_fifos		=	3,
+	.overlay_caps		=	omap3630_dispc_overlay_caps,
 	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
@@ -3895,6 +3988,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
@@ -3924,6 +4018,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.overlay_caps		=	omap4_dispc_overlay_caps,
 	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
@@ -4171,7 +4266,7 @@ static const struct dispc_ops dispc_ops = {
 /* DISPC HW IP initialisation */
 static const struct of_device_id dispc_of_match[] = {
 	{ .compatible = "ti,omap2-dispc", .data = &omap24xx_dispc_feats },
-	{ .compatible = "ti,omap3-dispc", .data = &omap34xx_rev3_0_dispc_feats },
+	{ .compatible = "ti,omap3-dispc", .data = &omap36xx_dispc_feats },
 	{ .compatible = "ti,omap4-dispc", .data = &omap44xx_dispc_feats },
 	{ .compatible = "ti,omap5-dispc", .data = &omap54xx_dispc_feats },
 	{ .compatible = "ti,dra7-dispc",  .data = &omap54xx_dispc_feats },
@@ -4181,6 +4276,9 @@ static const struct of_device_id dispc_of_match[] = {
 static const struct soc_device_attribute dispc_soc_devices[] = {
 	{ .machine = "OMAP3[45]*",
 	  .revision = "ES[12].?",	.data = &omap34xx_rev1_0_dispc_feats },
+	{ .machine = "OMAP3[45]*",	.data = &omap34xx_rev3_0_dispc_feats },
+	{ .machine = "AM35*",		.data = &omap34xx_rev3_0_dispc_feats },
+	{ .machine = "AM43*",		.data = &omap34xx_rev3_0_dispc_feats },
 	{ /* sentinel */ }
 };
 
@@ -4198,8 +4296,8 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	spin_lock_init(&dispc.control_lock);
 
 	/*
-	 * The OMAP34xx ES1.x and ES2.x can't be identified through the
-	 * compatible string, use SoC device matching.
+	 * The OMAP34xx and OMAP36xx can't be told apart using the compatible
+	 * string, use SoC device matching.
 	 */
 	soc = soc_device_match(dispc_soc_devices);
 	if (soc)

commit 94f96ad7c7372dcba74d296de7251f8c6079a2e0
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:04 2017 +0300

    drm: omapdrm: Move color modes feature to dispc_features structure
    
    The supported_color_modes is a dispc feature. Move it from the
    omap_dss_features structure to the dispc_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 99a308446283..f3ae7f16e65c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -88,6 +88,7 @@ struct dispc_features {
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool mem_to_mem);
 	u8 num_fifos;
+	const u32 **supported_color_modes;
 	unsigned int buffer_size_unit;
 	unsigned int burst_size_unit;
 
@@ -1144,9 +1145,24 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
 	return dispc.feat->burst_size_unit * 8;
 }
 
+static bool dispc_ovl_color_mode_supported(enum omap_plane_id plane, u32 fourcc)
+{
+	const u32 *modes;
+	unsigned int i;
+
+	modes = dispc.feat->supported_color_modes[plane];
+
+	for (i = 0; modes[i]; ++i) {
+		if (modes[i] == fourcc)
+			return true;
+	}
+
+	return false;
+}
+
 static const u32 *dispc_ovl_get_color_modes(enum omap_plane_id plane)
 {
-	return dss_feat_get_supported_color_modes(plane);
+	return dispc.feat->supported_color_modes[plane];
 }
 
 static int dispc_get_num_ovls(void)
@@ -1867,7 +1883,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
-	if (dss_feat_color_mode_supported(plane, DRM_FORMAT_NV12)) {
+	if (dispc_ovl_color_mode_supported(plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
 			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
@@ -2431,7 +2447,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 			out_height);
 	}
 
-	if (!dss_feat_color_mode_supported(plane, fourcc))
+	if (!dispc_ovl_color_mode_supported(plane, fourcc))
 		return -EINVAL;
 
 	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
@@ -3692,6 +3708,106 @@ static void _omap_dispc_initial_config(void)
 		dispc_init_mflag();
 }
 
+#define COLOR_ARRAY(arr...) (const u32[]) { arr, 0 }
+
+static const u32 *omap2_dispc_supported_color_modes[] = {
+
+	/* OMAP_DSS_GFX */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGBX4444, DRM_FORMAT_RGB565,
+	DRM_FORMAT_XRGB8888, DRM_FORMAT_RGB888),
+
+	/* OMAP_DSS_VIDEO1 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY),
+
+	/* OMAP_DSS_VIDEO2 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY),
+};
+
+static const u32 *omap3_dispc_supported_color_modes[] = {
+	/* OMAP_DSS_GFX */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888),
+
+	/* OMAP_DSS_VIDEO1 */
+	COLOR_ARRAY(
+	DRM_FORMAT_XRGB8888, DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGBX4444, DRM_FORMAT_RGB565,
+	DRM_FORMAT_YUYV, DRM_FORMAT_UYVY),
+
+	/* OMAP_DSS_VIDEO2 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY, DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888),
+};
+
+static const u32 *omap4_dispc_supported_color_modes[] = {
+	/* OMAP_DSS_GFX */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_ARGB1555, DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB1555),
+
+	/* OMAP_DSS_VIDEO1 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,
+	DRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_UYVY,
+	DRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_RGBX8888),
+
+       /* OMAP_DSS_VIDEO2 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,
+	DRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_UYVY,
+	DRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_RGBX8888),
+
+	/* OMAP_DSS_VIDEO3 */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,
+	DRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_UYVY,
+	DRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_RGBX8888),
+
+	/* OMAP_DSS_WB */
+	COLOR_ARRAY(
+	DRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,
+	DRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888, DRM_FORMAT_UYVY,
+	DRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,
+	DRM_FORMAT_RGBX8888),
+};
+
 static const struct dispc_features omap24xx_dispc_feats = {
 	.sw_start		=	5,
 	.fp_start		=	15,
@@ -3707,6 +3823,7 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
+	.supported_color_modes	=	omap2_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3730,6 +3847,7 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3753,6 +3871,7 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.supported_color_modes	=	omap3_dispc_supported_color_modes,
 	.buffer_size_unit	=	1,
 	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
@@ -3776,6 +3895,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,
@@ -3804,6 +3924,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.supported_color_modes	=	omap4_dispc_supported_color_modes,
 	.buffer_size_unit	=	16,
 	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,

commit 28550474747853d701173ead5722c2215112a84e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:03 2017 +0300

    drm: omapdrm: Move size unit features to dispc_features structure
    
    The buffer_size_unit and burst_size_unit are dispc features. Move them
    from the omap_dss_features structure to the dispc_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7053e3fdc9e2..99a308446283 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -88,6 +88,8 @@ struct dispc_features {
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool mem_to_mem);
 	u8 num_fifos;
+	unsigned int buffer_size_unit;
+	unsigned int burst_size_unit;
 
 	/* swap GFX & WB fifos */
 	bool gfx_fifo_workaround:1;
@@ -1138,9 +1140,8 @@ static void dispc_configure_burst_sizes(void)
 
 static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
 {
-	unsigned unit = dss_feat_get_burst_size_unit();
 	/* burst multiplier is always x8 (see dispc_configure_burst_sizes()) */
-	return unit * 8;
+	return dispc.feat->burst_size_unit * 8;
 }
 
 static const u32 *dispc_ovl_get_color_modes(enum omap_plane_id plane)
@@ -1225,7 +1226,7 @@ static void dispc_init_fifos(void)
 	u32 unit;
 	int i;
 
-	unit = dss_feat_get_buffer_size_unit();
+	unit = dispc.feat->buffer_size_unit;
 
 	dss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
 
@@ -1309,7 +1310,7 @@ void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
 	u8 hi_start, hi_end, lo_start, lo_end;
 	u32 unit;
 
-	unit = dss_feat_get_buffer_size_unit();
+	unit = dispc.feat->buffer_size_unit;
 
 	WARN_ON(low % unit != 0);
 	WARN_ON(high % unit != 0);
@@ -1362,7 +1363,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.
 	 */
 
-	unsigned buf_unit = dss_feat_get_buffer_size_unit();
+	unsigned buf_unit = dispc.feat->buffer_size_unit;
 	unsigned ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
@@ -1439,7 +1440,7 @@ static void dispc_init_mflag(void)
 
 	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
 		u32 size = dispc_ovl_get_fifo_size(i);
-		u32 unit = dss_feat_get_buffer_size_unit();
+		u32 unit = dispc.feat->buffer_size_unit;
 		u32 low, high;
 
 		dispc_ovl_set_mflag(i, true);
@@ -1458,7 +1459,7 @@ static void dispc_init_mflag(void)
 
 	if (dispc.feat->has_writeback) {
 		u32 size = dispc_ovl_get_fifo_size(OMAP_DSS_WB);
-		u32 unit = dss_feat_get_buffer_size_unit();
+		u32 unit = dispc.feat->buffer_size_unit;
 		u32 low, high;
 
 		dispc_ovl_set_mflag(OMAP_DSS_WB, true);
@@ -3706,6 +3707,8 @@ static const struct dispc_features omap24xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
 	.calc_core_clk		=	calc_core_clk_24xx,
 	.num_fifos		=	3,
+	.buffer_size_unit	=	1,
+	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
 	.set_max_preload	=	false,
 	.last_pixel_inc_missing	=	true,
@@ -3727,6 +3730,8 @@ static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.buffer_size_unit	=	1,
+	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
 	.set_max_preload	=	false,
 	.last_pixel_inc_missing	=	true,
@@ -3748,6 +3753,8 @@ static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
 	.calc_core_clk		=	calc_core_clk_34xx,
 	.num_fifos		=	3,
+	.buffer_size_unit	=	1,
+	.burst_size_unit	=	8,
 	.no_framedone_tv	=	true,
 	.set_max_preload	=	false,
 	.last_pixel_inc_missing	=	true,
@@ -3769,6 +3776,8 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.buffer_size_unit	=	16,
+	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,
 	.set_max_preload	=	true,
 	.supports_sync_align	=	true,
@@ -3795,6 +3804,8 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
 	.calc_core_clk		=	calc_core_clk_44xx,
 	.num_fifos		=	5,
+	.buffer_size_unit	=	16,
+	.burst_size_unit	=	16,
 	.gfx_fifo_workaround	=	true,
 	.mstandby_workaround	=	true,
 	.set_max_preload	=	true,

commit 7a143a4b116db223d661500f819cfef9b4bbdefa
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:55 2017 +0300

    drm: omapdrm: dispc: Select features based on compatible string
    
    Use the compatible string instead of the OMAP SoC revision to determine
    device features. On OMAP34xx the features depend on the ES revision that
    can not be determined from the compatible string. Use soc_device_match()
    in that case.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index fd7504b37e3b..7053e3fdc9e2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -39,7 +39,9 @@
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/component.h>
+#include <linux/sys_soc.h>
 #include <drm/drm_fourcc.h>
 #include <drm/drm_blend.h>
 
@@ -3804,54 +3806,6 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.has_gamma_i734_bug	=	true,
 };
 
-static int dispc_init_features(struct platform_device *pdev)
-{
-	const struct dispc_features *src;
-	struct dispc_features *dst;
-
-	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
-	if (!dst) {
-		dev_err(&pdev->dev, "Failed to allocate DISPC Features\n");
-		return -ENOMEM;
-	}
-
-	switch (omapdss_get_version()) {
-	case OMAPDSS_VER_OMAP24xx:
-		src = &omap24xx_dispc_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP34xx_ES1:
-		src = &omap34xx_rev1_0_dispc_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP34xx_ES3:
-	case OMAPDSS_VER_OMAP3630:
-	case OMAPDSS_VER_AM35xx:
-	case OMAPDSS_VER_AM43xx:
-		src = &omap34xx_rev3_0_dispc_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP4430_ES1:
-	case OMAPDSS_VER_OMAP4430_ES2:
-	case OMAPDSS_VER_OMAP4:
-		src = &omap44xx_dispc_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP5:
-	case OMAPDSS_VER_DRA7xx:
-		src = &omap54xx_dispc_feats;
-		break;
-
-	default:
-		return -ENODEV;
-	}
-
-	memcpy(dst, src, sizeof(*dst));
-	dispc.feat = dst;
-
-	return 0;
-}
-
 static irqreturn_t dispc_irq_handler(int irq, void *arg)
 {
 	if (!dispc.is_enabled)
@@ -4083,9 +4037,25 @@ static const struct dispc_ops dispc_ops = {
 };
 
 /* DISPC HW IP initialisation */
+static const struct of_device_id dispc_of_match[] = {
+	{ .compatible = "ti,omap2-dispc", .data = &omap24xx_dispc_feats },
+	{ .compatible = "ti,omap3-dispc", .data = &omap34xx_rev3_0_dispc_feats },
+	{ .compatible = "ti,omap4-dispc", .data = &omap44xx_dispc_feats },
+	{ .compatible = "ti,omap5-dispc", .data = &omap54xx_dispc_feats },
+	{ .compatible = "ti,dra7-dispc",  .data = &omap54xx_dispc_feats },
+	{},
+};
+
+static const struct soc_device_attribute dispc_soc_devices[] = {
+	{ .machine = "OMAP3[45]*",
+	  .revision = "ES[12].?",	.data = &omap34xx_rev1_0_dispc_feats },
+	{ /* sentinel */ }
+};
+
 static int dispc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	const struct soc_device_attribute *soc;
 	u32 rev;
 	int r = 0;
 	struct resource *dispc_mem;
@@ -4095,9 +4065,15 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	spin_lock_init(&dispc.control_lock);
 
-	r = dispc_init_features(dispc.pdev);
-	if (r)
-		return r;
+	/*
+	 * The OMAP34xx ES1.x and ES2.x can't be identified through the
+	 * compatible string, use SoC device matching.
+	 */
+	soc = soc_device_match(dispc_soc_devices);
+	if (soc)
+		dispc.feat = soc->data;
+	else
+		dispc.feat = of_match_device(dispc_of_match, &pdev->dev)->data;
 
 	r = dispc_errata_i734_wa_init();
 	if (r)
@@ -4226,15 +4202,6 @@ static const struct dev_pm_ops dispc_pm_ops = {
 	.runtime_resume = dispc_runtime_resume,
 };
 
-static const struct of_device_id dispc_of_match[] = {
-	{ .compatible = "ti,omap2-dispc", },
-	{ .compatible = "ti,omap3-dispc", },
-	{ .compatible = "ti,omap4-dispc", },
-	{ .compatible = "ti,omap5-dispc", },
-	{ .compatible = "ti,dra7-dispc", },
-	{},
-};
-
 static struct platform_driver omap_dispchw_driver = {
 	.probe		= dispc_probe,
 	.remove         = dispc_remove,

commit 2add8d1310eb5b1094e02a7261b6e35df5e65bf3
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 15:25:45 2017 +0300

    drm/omap: fix YUV422 90/270 rotation with mirroring
    
    When rotating 90/270 + mirroring with YUV422, the end result will have
    adjacent pixels swapped. The problem is that
    dispc_ovl_set_rotation_attrs() has wrong rotation values for these
    cases.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 18e9dff2f1b2..fd7504b37e3b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1819,13 +1819,13 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 				vidrot = 2;
 				break;
 			case DRM_MODE_ROTATE_90:
-				vidrot = 3;
+				vidrot = 1;
 				break;
 			case DRM_MODE_ROTATE_180:
 				vidrot = 0;
 				break;
 			case DRM_MODE_ROTATE_270:
-				vidrot = 1;
+				vidrot = 3;
 				break;
 			}
 		} else {

commit c4df6e4277503f0d05e261c3cae0c282fdca4437
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon May 15 11:09:25 2017 +0300

    drm/omap: fix YUV422 rotation with TILER
    
    TILER rotation with YUV422 pixelformats does not work at the moment. All
    other pixel formats work, because the pixelformat's pixel size is equal
    to tiler unit size (e.g. XR24's pixel size is 32 bits, and the TILER
    unit size that has to be used is 32 bits).
    
    For YUV422 formats this is not the case, as the TILER unit size has to
    be 32 bits, but the pixel size is 16 bits. The end result is OCP errors
    and sync losts.
    
    This patch adds the code to adjust the variables for YUV422 formats.
    
    We could make the code more generic by passing around the pixel format,
    rotation type, angle and the tiler unit size, which would allow us to do
    calculations without special case for YUV422. However, this would make
    the code more complex, and at least for now this is much more easier to
    handle with these two special cases for YUV422.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 53e2c93a5455..18e9dff2f1b2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1919,7 +1919,8 @@ static s32 pixinc(int pixels, u8 ps)
 static void calc_offset(u16 screen_width, u16 width,
 		u32 fourcc, bool fieldmode,
 		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
-		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
+		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim,
+		enum omap_dss_rotation_type rotation_type, u8 rotation)
 {
 	u8 ps;
 
@@ -1927,6 +1928,20 @@ static void calc_offset(u16 screen_width, u16 width,
 
 	DSSDBG("scrw %d, width %d\n", screen_width, width);
 
+	if (rotation_type == OMAP_DSS_ROT_TILER &&
+	    (fourcc == DRM_FORMAT_UYVY || fourcc == DRM_FORMAT_YUYV) &&
+	    drm_rotation_90_or_270(rotation)) {
+		/*
+		 * HACK: ROW_INC needs to be calculated with TILER units.
+		 * We get such 'screen_width' that multiplying it with the
+		 * YUV422 pixel size gives the correct TILER container width.
+		 * However, 'width' is in pixels and multiplying it with YUV422
+		 * pixel size gives incorrect result. We thus multiply it here
+		 * with 2 to match the 32 bit TILER unit size.
+		 */
+		width *= 2;
+	}
+
 	/*
 	 * field 0 = even field = bottom field
 	 * field 1 = odd field = top field
@@ -2475,7 +2490,8 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	calc_offset(screen_width, frame_width,
 			fourcc, fieldmode, field_offset,
 			&offset0, &offset1, &row_inc, &pix_inc,
-			x_predecim, y_predecim);
+			x_predecim, y_predecim,
+			rotation_type, rotation);
 
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);

commit 4eebb80e2465be3f5ec471547c455494c050ebd1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 12:05:24 2017 +0300

    drm/omap: DRM_MODE_REFLECT_* instead of mirror boolean
    
    Change dispc driver to use the DRM_MODE_REFLECT flags instead of a mirror
    boolean.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 34c6a2aca014..53e2c93a5455 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1805,8 +1805,7 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 }
 
 static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
-		enum omap_dss_rotation_type rotation_type,
-		bool mirroring, u32 fourcc)
+		enum omap_dss_rotation_type rotation_type, u32 fourcc)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
@@ -1814,7 +1813,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	/* Note: DSS HW rotates clockwise, DRM_MODE_ROTATE_* counter-clockwise */
 	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {
 
-		if (mirroring) {
+		if (rotation & DRM_MODE_REFLECT_X) {
 			switch (rotation & DRM_MODE_ROTATE_MASK) {
 			case DRM_MODE_ROTATE_0:
 				vidrot = 2;
@@ -2369,7 +2368,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
 		u16 out_width, u16 out_height, u32 fourcc,
-		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
+		u8 rotation, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
 		bool replication, const struct videomode *vm,
 		bool mem_to_mem)
@@ -2517,8 +2516,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		dispc_ovl_set_vid_color_conv(plane, cconv);
 	}
 
-	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, mirror,
-			fourcc);
+	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, fourcc);
 
 	dispc_ovl_set_zorder(plane, caps, zorder);
 	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
@@ -2539,17 +2537,17 @@ static int dispc_ovl_setup(enum omap_plane_id plane,
 	const bool replication = true;
 
 	DSSDBG("dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->"
-		" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",
+		" %dx%d, cmode %x, rot %d, chan %d repl %d\n",
 		plane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
-		oi->fourcc, oi->rotation, oi->mirror, channel, replication);
+		oi->fourcc, oi->rotation, channel, replication);
 
 	dispc_ovl_set_channel_out(plane, channel);
 
 	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
 		oi->out_width, oi->out_height, oi->fourcc, oi->rotation,
-		oi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
+		oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
 		oi->rotation_type, replication, vm, mem_to_mem);
 
 	return r;
@@ -2571,13 +2569,12 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
 
 	DSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "
-		"rot %d, mir %d\n", wi->paddr, wi->p_uv_addr, in_width,
-		in_height, wi->width, wi->height, wi->fourcc, wi->rotation,
-		wi->mirror);
+		"rot %d\n", wi->paddr, wi->p_uv_addr, in_width,
+		in_height, wi->width, wi->height, wi->fourcc, wi->rotation);
 
 	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
-		wi->height, wi->fourcc, wi->rotation, wi->mirror, zorder,
+		wi->height, wi->fourcc, wi->rotation, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
 		replication, vm, mem_to_mem);
 
@@ -3918,7 +3915,6 @@ static const struct dispc_errata_i734_data {
 		.fourcc = DRM_FORMAT_XRGB8888,
 		.rotation = DRM_MODE_ROTATE_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
-		.mirror = 0,
 		.pos_x = 0, .pos_y = 0,
 		.out_width = 0, .out_height = 0,
 		.global_alpha = 0xff,

commit 0bd97c42d975a1e0849105bb8f23a68490683aab
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 11:05:09 2017 +0300

    drm/omap: use DRM_MODE_ROTATE_* instead of OMAP_DSS_ROT_*
    
    At the moment the dispc driver uses a custom enum for rotation. Change
    it to use the DRM's DRM_MODE_ROTATE_*.
    
    Note that mirroring is at the moment handled as a separate boolean in
    the dispc driver, so we only use the DRM_MODE_ROTATE_* values.
    
    Note, DSS HW uses clockwise rotation, DRM counter-clockwise.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7ccbcfc1d011..34c6a2aca014 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -41,6 +41,7 @@
 #include <linux/of.h>
 #include <linux/component.h>
 #include <drm/drm_fourcc.h>
+#include <drm/drm_blend.h>
 
 #include "omapdss.h"
 #include "dss.h"
@@ -1600,22 +1601,21 @@ static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		{  0, 1, 0, 1, -1, 1, 0, 1 },
 	};
 
-	switch (rotation) {
-	case OMAP_DSS_ROT_0:
+	/* Note: DSS HW rotates clockwise, DRM_MODE_ROTATE_* counter-clockwise */
+	switch (rotation & DRM_MODE_ROTATE_MASK) {
+	default:
+	case DRM_MODE_ROTATE_0:
 		idx = 0;
 		break;
-	case OMAP_DSS_ROT_90:
-		idx = 1;
+	case DRM_MODE_ROTATE_90:
+		idx = 3;
 		break;
-	case OMAP_DSS_ROT_180:
+	case DRM_MODE_ROTATE_180:
 		idx = 2;
 		break;
-	case OMAP_DSS_ROT_270:
-		idx = 3;
+	case DRM_MODE_ROTATE_270:
+		idx = 1;
 		break;
-	default:
-		BUG();
-		return;
 	}
 
 	switch (fourcc) {
@@ -1742,8 +1742,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_UYVY:
 		/* For YUV422 with 90/270 rotation, we don't upsample chroma */
-		if (rotation == OMAP_DSS_ROT_0 ||
-				rotation == OMAP_DSS_ROT_180) {
+		if (!drm_rotation_90_or_270(rotation)) {
 			if (chroma_upscale)
 				/* UV is subsampled by 2 horizontally */
 				orig_width >>= 1;
@@ -1753,7 +1752,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 		}
 
 		/* must use FIR for YUV422 if rotated */
-		if (rotation != OMAP_DSS_ROT_0)
+		if ((rotation & DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_0)
 			scale_x = scale_y = true;
 
 		break;
@@ -1812,41 +1811,42 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	bool row_repeat = false;
 	int vidrot = 0;
 
+	/* Note: DSS HW rotates clockwise, DRM_MODE_ROTATE_* counter-clockwise */
 	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {
 
 		if (mirroring) {
-			switch (rotation) {
-			case OMAP_DSS_ROT_0:
+			switch (rotation & DRM_MODE_ROTATE_MASK) {
+			case DRM_MODE_ROTATE_0:
 				vidrot = 2;
 				break;
-			case OMAP_DSS_ROT_90:
-				vidrot = 1;
+			case DRM_MODE_ROTATE_90:
+				vidrot = 3;
 				break;
-			case OMAP_DSS_ROT_180:
+			case DRM_MODE_ROTATE_180:
 				vidrot = 0;
 				break;
-			case OMAP_DSS_ROT_270:
-				vidrot = 3;
+			case DRM_MODE_ROTATE_270:
+				vidrot = 1;
 				break;
 			}
 		} else {
-			switch (rotation) {
-			case OMAP_DSS_ROT_0:
+			switch (rotation & DRM_MODE_ROTATE_MASK) {
+			case DRM_MODE_ROTATE_0:
 				vidrot = 0;
 				break;
-			case OMAP_DSS_ROT_90:
-				vidrot = 1;
+			case DRM_MODE_ROTATE_90:
+				vidrot = 3;
 				break;
-			case OMAP_DSS_ROT_180:
+			case DRM_MODE_ROTATE_180:
 				vidrot = 2;
 				break;
-			case OMAP_DSS_ROT_270:
-				vidrot = 3;
+			case DRM_MODE_ROTATE_270:
+				vidrot = 1;
 				break;
 			}
 		}
 
-		if (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)
+		if (drm_rotation_90_or_270(rotation))
 			row_repeat = true;
 		else
 			row_repeat = false;
@@ -1869,7 +1869,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		bool doublestride =
 			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
-			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
+			!drm_rotation_90_or_270(rotation);
 
 		/* DOUBLESTRIDE */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
@@ -3916,7 +3916,7 @@ static const struct dispc_errata_i734_data {
 		.screen_width = 1,
 		.width = 1, .height = 1,
 		.fourcc = DRM_FORMAT_XRGB8888,
-		.rotation = OMAP_DSS_ROT_0,
+		.rotation = DRM_MODE_ROTATE_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,
 		.pos_x = 0, .pos_y = 0,

commit 41aff42ae6e3e9dbb800640fe3bb62383d4aa6e3
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:31:56 2017 +0300

    drm/omap: rename color_mode to fourcc
    
    Now that we use fourccs, we can also rename the 'color_mode' variables
    to 'fourcc'.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 59af4dfc22da..7ccbcfc1d011 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -78,7 +78,7 @@ struct dispc_features {
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem);
 	unsigned long (*calc_core_clk) (unsigned long pclk,
@@ -906,12 +906,11 @@ static void dispc_ovl_set_row_inc(enum omap_plane_id plane, s32 inc)
 	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
 }
 
-static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
-		u32 color_mode)
+static void dispc_ovl_set_color_mode(enum omap_plane_id plane, u32 fourcc)
 {
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
-		switch (color_mode) {
+		switch (fourcc) {
 		case DRM_FORMAT_NV12:
 			m = 0x0; break;
 		case DRM_FORMAT_XRGB4444:
@@ -946,7 +945,7 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 			BUG(); return;
 		}
 	} else {
-		switch (color_mode) {
+		switch (fourcc) {
 		case DRM_FORMAT_RGBX4444:
 			m = 0x4; break;
 		case DRM_FORMAT_ARGB4444:
@@ -979,9 +978,9 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
-static bool format_is_yuv(u32 color_mode)
+static bool format_is_yuv(u32 fourcc)
 {
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_UYVY:
 	case DRM_FORMAT_NV12:
@@ -1563,7 +1562,7 @@ static void dispc_ovl_set_scale_param(enum omap_plane_id plane,
 
 static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
-		bool ilace, u32 color_mode, u8 rotation)
+		bool ilace, u32 fourcc, u8 rotation)
 {
 	int h_accu2_0, h_accu2_1;
 	int v_accu2_0, v_accu2_1;
@@ -1619,7 +1618,7 @@ static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		return;
 	}
 
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		if (ilace)
 			accu_table = accu_nv12_ilace;
@@ -1653,7 +1652,7 @@ static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	int accu0 = 0;
@@ -1707,7 +1706,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	int scale_x = out_width != orig_width;
@@ -1717,7 +1716,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
 
-	if (!format_is_yuv(color_mode)) {
+	if (!format_is_yuv(fourcc)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
 			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
@@ -1725,9 +1724,9 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 	}
 
 	dispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,
-			out_height, ilace, color_mode, rotation);
+			out_height, ilace, fourcc, rotation);
 
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		if (chroma_upscale) {
 			/* UV is subsampled by 2 horizontally and vertically */
@@ -1786,7 +1785,7 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
@@ -1795,26 +1794,25 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 			orig_width, orig_height,
 			out_width, out_height,
 			ilace, five_taps,
-			fieldmode, color_mode,
+			fieldmode, fourcc,
 			rotation);
 
 	dispc_ovl_set_scaling_uv(plane,
 		orig_width, orig_height,
 		out_width, out_height,
 		ilace, five_taps,
-		fieldmode, color_mode,
+		fieldmode, fourcc,
 		rotation);
 }
 
 static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		enum omap_dss_rotation_type rotation_type,
-		bool mirroring, u32 color_mode)
+		bool mirroring, u32 fourcc)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
 
-	if (color_mode == DRM_FORMAT_YUYV ||
-			color_mode == DRM_FORMAT_UYVY) {
+	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {
 
 		if (mirroring) {
 			switch (rotation) {
@@ -1859,8 +1857,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	 * NV12 in 1D mode must use ROTATION=1. Otherwise DSS will fetch extra
 	 * rows beyond the framebuffer, which may cause OCP error.
 	 */
-	if (color_mode == DRM_FORMAT_NV12 &&
-			rotation_type != OMAP_DSS_ROT_TILER)
+	if (fourcc == DRM_FORMAT_NV12 && rotation_type != OMAP_DSS_ROT_TILER)
 		vidrot = 1;
 
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
@@ -1870,7 +1867,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 
 	if (dss_feat_color_mode_supported(plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
-			color_mode == DRM_FORMAT_NV12 &&
+			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
 			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
 
@@ -1879,9 +1876,9 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	}
 }
 
-static int color_mode_to_bpp(u32 color_mode)
+static int color_mode_to_bpp(u32 fourcc)
 {
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		return 8;
 	case DRM_FORMAT_RGBX4444:
@@ -1921,13 +1918,13 @@ static s32 pixinc(int pixels, u8 ps)
 }
 
 static void calc_offset(u16 screen_width, u16 width,
-		u32 color_mode, bool fieldmode,
+		u32 fourcc, bool fieldmode,
 		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
 		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
 {
 	u8 ps;
 
-	ps = color_mode_to_bpp(color_mode) / 8;
+	ps = color_mode_to_bpp(fourcc) / 8;
 
 	DSSDBG("scrw %d, width %d\n", screen_width, width);
 
@@ -1940,8 +1937,7 @@ static void calc_offset(u16 screen_width, u16 width,
 
 	*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +
 			(fieldmode ? screen_width : 0), ps);
-	if (color_mode == DRM_FORMAT_YUYV ||
-		color_mode == DRM_FORMAT_UYVY)
+	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY)
 		*pix_inc = pixinc(x_predecim, 2 * ps);
 	else
 		*pix_inc = pixinc(x_predecim, ps);
@@ -2008,7 +2004,7 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		const struct videomode *vm, u16 width,
 		u16 height, u16 out_width, u16 out_height,
-		u32 color_mode)
+		u32 fourcc)
 {
 	u32 core_clk = 0;
 	u64 tmp;
@@ -2038,7 +2034,7 @@ static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		do_div(tmp, out_width);
 		core_clk = max_t(u32, core_clk, tmp);
 
-		if (color_mode == DRM_FORMAT_XRGB8888)
+		if (fourcc == DRM_FORMAT_XRGB8888)
 			core_clk <<= 1;
 	}
 
@@ -2101,7 +2097,7 @@ static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
 static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2147,7 +2143,7 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2169,7 +2165,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 		if (*five_taps)
 			*core_clk = calc_core_clk_five_taps(pclk, vm,
 						in_width, in_height, out_width,
-						out_height, color_mode);
+						out_height, fourcc);
 		else
 			*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
 					in_height, out_width, out_height,
@@ -2232,7 +2228,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2266,7 +2262,7 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 	}
 
-	if (*decim_x > 4 && color_mode != DRM_FORMAT_NV12) {
+	if (*decim_x > 4 && fourcc != DRM_FORMAT_NV12) {
 		/*
 		 * Let's disable all scaling that requires horizontal
 		 * decimation with higher factor than 4, until we have
@@ -2297,7 +2293,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		enum omap_overlay_caps caps,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, u16 pos_x,
 		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
 {
@@ -2336,7 +2332,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 
 	ret = dispc.feat->calc_scaling(pclk, lclk, vm, width, height,
-		out_width, out_height, color_mode, five_taps,
+		out_width, out_height, fourcc, five_taps,
 		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
 		mem_to_mem);
 	if (ret)
@@ -2372,7 +2368,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
-		u16 out_width, u16 out_height, u32 color_mode,
+		u16 out_width, u16 out_height, u32 fourcc,
 		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
 		bool replication, const struct videomode *vm,
@@ -2396,7 +2392,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 
-	if (format_is_yuv(color_mode) && (in_width & 1)) {
+	if (format_is_yuv(fourcc) && (in_width & 1)) {
 		DSSERR("input width %d is not even for YUV format\n", in_width);
 		return -EINVAL;
 	}
@@ -2418,11 +2414,11 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 			out_height);
 	}
 
-	if (!dss_feat_color_mode_supported(plane, color_mode))
+	if (!dss_feat_color_mode_supported(plane, fourcc))
 		return -EINVAL;
 
 	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
-			in_height, out_width, out_height, color_mode,
+			in_height, out_width, out_height, fourcc,
 			&five_taps, &x_predecim, &y_predecim, pos_x,
 			rotation_type, mem_to_mem);
 	if (r)
@@ -2435,7 +2431,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
 			x_predecim, y_predecim, in_width, in_height);
 
-	if (format_is_yuv(color_mode) && (in_width & 1)) {
+	if (format_is_yuv(fourcc) && (in_width & 1)) {
 		DSSDBG("predecimated input width is not even for YUV format\n");
 		DSSDBG("adjusting input width %d -> %d\n",
 			in_width, in_width & ~1);
@@ -2443,7 +2439,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		in_width &= ~1;
 	}
 
-	if (format_is_yuv(color_mode))
+	if (format_is_yuv(fourcc))
 		cconv = 1;
 
 	if (ilace && !fieldmode) {
@@ -2478,14 +2474,14 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	}
 
 	calc_offset(screen_width, frame_width,
-			color_mode, fieldmode, field_offset,
+			fourcc, fieldmode, field_offset,
 			&offset0, &offset1, &row_inc, &pix_inc,
 			x_predecim, y_predecim);
 
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
 
-	dispc_ovl_set_color_mode(plane, color_mode);
+	dispc_ovl_set_color_mode(plane, fourcc);
 
 	dispc_ovl_configure_burst_type(plane, rotation_type);
 
@@ -2495,7 +2491,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	dispc_ovl_set_ba0(plane, paddr + offset0);
 	dispc_ovl_set_ba1(plane, paddr + offset1);
 
-	if (color_mode == DRM_FORMAT_NV12) {
+	if (fourcc == DRM_FORMAT_NV12) {
 		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
 		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
 	}
@@ -2516,13 +2512,13 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	if (caps & OMAP_DSS_OVL_CAP_SCALE) {
 		dispc_ovl_set_scaling(plane, in_width, in_height, out_width,
 				   out_height, ilace, five_taps, fieldmode,
-				   color_mode, rotation);
+				   fourcc, rotation);
 		dispc_ovl_set_output_size(plane, out_width, out_height);
 		dispc_ovl_set_vid_color_conv(plane, cconv);
 	}
 
 	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, mirror,
-			color_mode);
+			fourcc);
 
 	dispc_ovl_set_zorder(plane, caps, zorder);
 	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
@@ -2546,13 +2542,13 @@ static int dispc_ovl_setup(enum omap_plane_id plane,
 		" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",
 		plane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
-		oi->color_mode, oi->rotation, oi->mirror, channel, replication);
+		oi->fourcc, oi->rotation, oi->mirror, channel, replication);
 
 	dispc_ovl_set_channel_out(plane, channel);
 
 	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
-		oi->out_width, oi->out_height, oi->color_mode, oi->rotation,
+		oi->out_width, oi->out_height, oi->fourcc, oi->rotation,
 		oi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
 		oi->rotation_type, replication, vm, mem_to_mem);
 
@@ -2576,16 +2572,16 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 
 	DSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "
 		"rot %d, mir %d\n", wi->paddr, wi->p_uv_addr, in_width,
-		in_height, wi->width, wi->height, wi->color_mode, wi->rotation,
+		in_height, wi->width, wi->height, wi->fourcc, wi->rotation,
 		wi->mirror);
 
 	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
-		wi->height, wi->color_mode, wi->rotation, wi->mirror, zorder,
+		wi->height, wi->fourcc, wi->rotation, wi->mirror, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
 		replication, vm, mem_to_mem);
 
-	switch (wi->color_mode) {
+	switch (wi->fourcc) {
 	case DRM_FORMAT_RGB565:
 	case DRM_FORMAT_RGB888:
 	case DRM_FORMAT_ARGB4444:
@@ -3919,7 +3915,7 @@ static const struct dispc_errata_i734_data {
 	.ovli = {
 		.screen_width = 1,
 		.width = 1, .height = 1,
-		.color_mode = DRM_FORMAT_XRGB8888,
+		.fourcc = DRM_FORMAT_XRGB8888,
 		.rotation = OMAP_DSS_ROT_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,
@@ -3960,7 +3956,7 @@ static int dispc_errata_i734_wa_init(void)
 		return 0;
 
 	i734_buf.size = i734.ovli.width * i734.ovli.height *
-		color_mode_to_bpp(i734.ovli.color_mode) / 8;
+		color_mode_to_bpp(i734.ovli.fourcc) / 8;
 
 	i734_buf.vaddr = dma_alloc_writecombine(&dispc.pdev->dev, i734_buf.size,
 						&i734_buf.paddr, GFP_KERNEL);

commit 3e1d65cdf84f88affa718396a392f9f9a0d8a5f6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 10:40:46 2017 +0300

    drm/omap: use DRM_FORMAT_* instead of OMAP_DSS_COLOR_*
    
    This patch changes omapdrm to use DRM_FORMAT_* values instead of
    OMAP_DSS_COLOR_* enum.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index c935a83bbe89..59af4dfc22da 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -40,6 +40,7 @@
 #include <linux/regmap.h>
 #include <linux/of.h>
 #include <linux/component.h>
+#include <drm/drm_fourcc.h>
 
 #include "omapdss.h"
 #include "dss.h"
@@ -158,7 +159,7 @@ enum omap_color_component {
 	 */
 	DISPC_COLOR_COMPONENT_RGB_Y		= 1 << 0,
 	/* used for UV component for
-	 * OMAP_DSS_COLOR_YUV2, OMAP_DSS_COLOR_UYVY, OMAP_DSS_COLOR_NV12
+	 * DRM_FORMAT_YUYV, DRM_FORMAT_UYVY, DRM_FORMAT_NV12
 	 * color formats on OMAP4
 	 */
 	DISPC_COLOR_COMPONENT_UV		= 1 << 1,
@@ -911,64 +912,64 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
 		switch (color_mode) {
-		case OMAP_DSS_COLOR_NV12:
+		case DRM_FORMAT_NV12:
 			m = 0x0; break;
-		case OMAP_DSS_COLOR_RGBX16:
+		case DRM_FORMAT_XRGB4444:
 			m = 0x1; break;
-		case OMAP_DSS_COLOR_RGBA16:
+		case DRM_FORMAT_RGBA4444:
 			m = 0x2; break;
-		case OMAP_DSS_COLOR_RGB12U:
+		case DRM_FORMAT_RGBX4444:
 			m = 0x4; break;
-		case OMAP_DSS_COLOR_ARGB16:
+		case DRM_FORMAT_ARGB4444:
 			m = 0x5; break;
-		case OMAP_DSS_COLOR_RGB16:
+		case DRM_FORMAT_RGB565:
 			m = 0x6; break;
-		case OMAP_DSS_COLOR_ARGB16_1555:
+		case DRM_FORMAT_ARGB1555:
 			m = 0x7; break;
-		case OMAP_DSS_COLOR_RGB24U:
+		case DRM_FORMAT_XRGB8888:
 			m = 0x8; break;
-		case OMAP_DSS_COLOR_RGB24P:
+		case DRM_FORMAT_RGB888:
 			m = 0x9; break;
-		case OMAP_DSS_COLOR_YUV2:
+		case DRM_FORMAT_YUYV:
 			m = 0xa; break;
-		case OMAP_DSS_COLOR_UYVY:
+		case DRM_FORMAT_UYVY:
 			m = 0xb; break;
-		case OMAP_DSS_COLOR_ARGB32:
+		case DRM_FORMAT_ARGB8888:
 			m = 0xc; break;
-		case OMAP_DSS_COLOR_RGBA32:
+		case DRM_FORMAT_RGBA8888:
 			m = 0xd; break;
-		case OMAP_DSS_COLOR_RGBX32:
+		case DRM_FORMAT_RGBX8888:
 			m = 0xe; break;
-		case OMAP_DSS_COLOR_XRGB16_1555:
+		case DRM_FORMAT_XRGB1555:
 			m = 0xf; break;
 		default:
 			BUG(); return;
 		}
 	} else {
 		switch (color_mode) {
-		case OMAP_DSS_COLOR_RGB12U:
+		case DRM_FORMAT_RGBX4444:
 			m = 0x4; break;
-		case OMAP_DSS_COLOR_ARGB16:
+		case DRM_FORMAT_ARGB4444:
 			m = 0x5; break;
-		case OMAP_DSS_COLOR_RGB16:
+		case DRM_FORMAT_RGB565:
 			m = 0x6; break;
-		case OMAP_DSS_COLOR_ARGB16_1555:
+		case DRM_FORMAT_ARGB1555:
 			m = 0x7; break;
-		case OMAP_DSS_COLOR_RGB24U:
+		case DRM_FORMAT_XRGB8888:
 			m = 0x8; break;
-		case OMAP_DSS_COLOR_RGB24P:
+		case DRM_FORMAT_RGB888:
 			m = 0x9; break;
-		case OMAP_DSS_COLOR_RGBX16:
+		case DRM_FORMAT_XRGB4444:
 			m = 0xa; break;
-		case OMAP_DSS_COLOR_RGBA16:
+		case DRM_FORMAT_RGBA4444:
 			m = 0xb; break;
-		case OMAP_DSS_COLOR_ARGB32:
+		case DRM_FORMAT_ARGB8888:
 			m = 0xc; break;
-		case OMAP_DSS_COLOR_RGBA32:
+		case DRM_FORMAT_RGBA8888:
 			m = 0xd; break;
-		case OMAP_DSS_COLOR_RGBX32:
+		case DRM_FORMAT_RGBX8888:
 			m = 0xe; break;
-		case OMAP_DSS_COLOR_XRGB16_1555:
+		case DRM_FORMAT_XRGB1555:
 			m = 0xf; break;
 		default:
 			BUG(); return;
@@ -981,9 +982,9 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 static bool format_is_yuv(u32 color_mode)
 {
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_NV12:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_NV12:
 		return true;
 	default:
 		return false;
@@ -1619,14 +1620,14 @@ static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 	}
 
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_NV12:
+	case DRM_FORMAT_NV12:
 		if (ilace)
 			accu_table = accu_nv12_ilace;
 		else
 			accu_table = accu_nv12;
 		break;
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
 		accu_table = accu_yuv;
 		break;
 	default:
@@ -1727,7 +1728,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 			out_height, ilace, color_mode, rotation);
 
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_NV12:
+	case DRM_FORMAT_NV12:
 		if (chroma_upscale) {
 			/* UV is subsampled by 2 horizontally and vertically */
 			orig_height >>= 1;
@@ -1739,8 +1740,8 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 		}
 
 		break;
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
 		/* For YUV422 with 90/270 rotation, we don't upsample chroma */
 		if (rotation == OMAP_DSS_ROT_0 ||
 				rotation == OMAP_DSS_ROT_180) {
@@ -1812,8 +1813,8 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	bool row_repeat = false;
 	int vidrot = 0;
 
-	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY) {
+	if (color_mode == DRM_FORMAT_YUYV ||
+			color_mode == DRM_FORMAT_UYVY) {
 
 		if (mirroring) {
 			switch (rotation) {
@@ -1858,7 +1859,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	 * NV12 in 1D mode must use ROTATION=1. Otherwise DSS will fetch extra
 	 * rows beyond the framebuffer, which may cause OCP error.
 	 */
-	if (color_mode == OMAP_DSS_COLOR_NV12 &&
+	if (color_mode == DRM_FORMAT_NV12 &&
 			rotation_type != OMAP_DSS_ROT_TILER)
 		vidrot = 1;
 
@@ -1867,9 +1868,9 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
-	if (dss_feat_color_mode_supported(plane, OMAP_DSS_COLOR_NV12)) {
+	if (dss_feat_color_mode_supported(plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
-			color_mode == OMAP_DSS_COLOR_NV12 &&
+			color_mode == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
 			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
 
@@ -1881,24 +1882,24 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 static int color_mode_to_bpp(u32 color_mode)
 {
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_NV12:
+	case DRM_FORMAT_NV12:
 		return 8;
-	case OMAP_DSS_COLOR_RGB12U:
-	case OMAP_DSS_COLOR_RGB16:
-	case OMAP_DSS_COLOR_ARGB16:
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_RGBA16:
-	case OMAP_DSS_COLOR_RGBX16:
-	case OMAP_DSS_COLOR_ARGB16_1555:
-	case OMAP_DSS_COLOR_XRGB16_1555:
+	case DRM_FORMAT_RGBX4444:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_ARGB4444:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_RGBA4444:
+	case DRM_FORMAT_XRGB4444:
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_XRGB1555:
 		return 16;
-	case OMAP_DSS_COLOR_RGB24P:
+	case DRM_FORMAT_RGB888:
 		return 24;
-	case OMAP_DSS_COLOR_RGB24U:
-	case OMAP_DSS_COLOR_ARGB32:
-	case OMAP_DSS_COLOR_RGBA32:
-	case OMAP_DSS_COLOR_RGBX32:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_RGBX8888:
 		return 32;
 	default:
 		BUG();
@@ -1939,8 +1940,8 @@ static void calc_offset(u16 screen_width, u16 width,
 
 	*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +
 			(fieldmode ? screen_width : 0), ps);
-	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-		color_mode == OMAP_DSS_COLOR_UYVY)
+	if (color_mode == DRM_FORMAT_YUYV ||
+		color_mode == DRM_FORMAT_UYVY)
 		*pix_inc = pixinc(x_predecim, 2 * ps);
 	else
 		*pix_inc = pixinc(x_predecim, ps);
@@ -2037,7 +2038,7 @@ static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		do_div(tmp, out_width);
 		core_clk = max_t(u32, core_clk, tmp);
 
-		if (color_mode == OMAP_DSS_COLOR_RGB24U)
+		if (color_mode == DRM_FORMAT_XRGB8888)
 			core_clk <<= 1;
 	}
 
@@ -2265,7 +2266,7 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 	}
 
-	if (*decim_x > 4 && color_mode != OMAP_DSS_COLOR_NV12) {
+	if (*decim_x > 4 && color_mode != DRM_FORMAT_NV12) {
 		/*
 		 * Let's disable all scaling that requires horizontal
 		 * decimation with higher factor than 4, until we have
@@ -2494,7 +2495,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	dispc_ovl_set_ba0(plane, paddr + offset0);
 	dispc_ovl_set_ba1(plane, paddr + offset1);
 
-	if (OMAP_DSS_COLOR_NV12 == color_mode) {
+	if (color_mode == DRM_FORMAT_NV12) {
 		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
 		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
 	}
@@ -2585,14 +2586,14 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		replication, vm, mem_to_mem);
 
 	switch (wi->color_mode) {
-	case OMAP_DSS_COLOR_RGB16:
-	case OMAP_DSS_COLOR_RGB24P:
-	case OMAP_DSS_COLOR_ARGB16:
-	case OMAP_DSS_COLOR_RGBA16:
-	case OMAP_DSS_COLOR_RGB12U:
-	case OMAP_DSS_COLOR_ARGB16_1555:
-	case OMAP_DSS_COLOR_XRGB16_1555:
-	case OMAP_DSS_COLOR_RGBX16:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_ARGB4444:
+	case DRM_FORMAT_RGBA4444:
+	case DRM_FORMAT_RGBX4444:
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_XRGB1555:
+	case DRM_FORMAT_XRGB4444:
 		truncation = true;
 		break;
 	default:
@@ -3918,7 +3919,7 @@ static const struct dispc_errata_i734_data {
 	.ovli = {
 		.screen_width = 1,
 		.width = 1, .height = 1,
-		.color_mode = OMAP_DSS_COLOR_RGB24U,
+		.color_mode = DRM_FORMAT_XRGB8888,
 		.rotation = OMAP_DSS_ROT_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,

commit 9c39d17e0614d18d809ccf2c3858994feb4fcdaa
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:19:12 2017 +0300

    drm/omap: use u32 instead of enum omap_color_mode
    
    In this step we drop 'enum omap_color_mode', and use u32 instead.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5836756a23a9..c935a83bbe89 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -77,7 +77,7 @@ struct dispc_features {
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool *five_taps,
+		u32 color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem);
 	unsigned long (*calc_core_clk) (unsigned long pclk,
@@ -906,7 +906,7 @@ static void dispc_ovl_set_row_inc(enum omap_plane_id plane, s32 inc)
 }
 
 static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
-		enum omap_color_mode color_mode)
+		u32 color_mode)
 {
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
@@ -978,7 +978,7 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
-static bool format_is_yuv(enum omap_color_mode color_mode)
+static bool format_is_yuv(u32 color_mode)
 {
 	switch (color_mode) {
 	case OMAP_DSS_COLOR_YUV2:
@@ -1140,7 +1140,7 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
 	return unit * 8;
 }
 
-static const enum omap_color_mode *dispc_ovl_get_color_modes(enum omap_plane_id plane)
+static const u32 *dispc_ovl_get_color_modes(enum omap_plane_id plane)
 {
 	return dss_feat_get_supported_color_modes(plane);
 }
@@ -1562,7 +1562,7 @@ static void dispc_ovl_set_scale_param(enum omap_plane_id plane,
 
 static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
-		bool ilace, enum omap_color_mode color_mode, u8 rotation)
+		bool ilace, u32 color_mode, u8 rotation)
 {
 	int h_accu2_0, h_accu2_1;
 	int v_accu2_0, v_accu2_1;
@@ -1652,7 +1652,7 @@ static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, enum omap_color_mode color_mode,
+		bool fieldmode, u32 color_mode,
 		u8 rotation)
 {
 	int accu0 = 0;
@@ -1706,7 +1706,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, enum omap_color_mode color_mode,
+		bool fieldmode, u32 color_mode,
 		u8 rotation)
 {
 	int scale_x = out_width != orig_width;
@@ -1785,7 +1785,7 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, enum omap_color_mode color_mode,
+		bool fieldmode, u32 color_mode,
 		u8 rotation)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
@@ -1807,7 +1807,7 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 
 static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		enum omap_dss_rotation_type rotation_type,
-		bool mirroring, enum omap_color_mode color_mode)
+		bool mirroring, u32 color_mode)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
@@ -1878,7 +1878,7 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 	}
 }
 
-static int color_mode_to_bpp(enum omap_color_mode color_mode)
+static int color_mode_to_bpp(u32 color_mode)
 {
 	switch (color_mode) {
 	case OMAP_DSS_COLOR_NV12:
@@ -1920,7 +1920,7 @@ static s32 pixinc(int pixels, u8 ps)
 }
 
 static void calc_offset(u16 screen_width, u16 width,
-		enum omap_color_mode color_mode, bool fieldmode,
+		u32 color_mode, bool fieldmode,
 		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
 		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
 {
@@ -2007,7 +2007,7 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		const struct videomode *vm, u16 width,
 		u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode)
+		u32 color_mode)
 {
 	u32 core_clk = 0;
 	u64 tmp;
@@ -2100,7 +2100,7 @@ static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
 static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool *five_taps,
+		u32 color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2146,7 +2146,7 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool *five_taps,
+		u32 color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2231,7 +2231,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool *five_taps,
+		u32 color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2296,7 +2296,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		enum omap_overlay_caps caps,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool *five_taps,
+		u32 color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, u16 pos_x,
 		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
 {
@@ -2371,7 +2371,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
-		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
+		u16 out_width, u16 out_height, u32 color_mode,
 		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
 		bool replication, const struct videomode *vm,

commit 18c0d6217a4898b9cae1b999e0dd37f8239ba0ae
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 10:27:53 2017 +0300

    drm/omap: change supported_modes to an array
    
    enum omap_color_mode is a bitmask, so at the moment we present the
    supported color modes as mask. To be able to move to fourccs, we need to
    use an array to present the supported color modes.
    
    As a first step towards fourccs, this patch changes the code to use an
    array to store the enums.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ee874129b202..5836756a23a9 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1140,7 +1140,7 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
 	return unit * 8;
 }
 
-static enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane_id plane)
+static const enum omap_color_mode *dispc_ovl_get_color_modes(enum omap_plane_id plane)
 {
 	return dss_feat_get_supported_color_modes(plane);
 }

commit 5edec14c73553941ea80f3527f3be02c071caac6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 09:13:32 2017 +0300

    drm/omap: add format_is_yuv() helper
    
    In a few places the dispc driver needs to know whether the pixel format
    is an YUV format. Add a helper to figure that out.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5c4288f44573..ee874129b202 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -978,6 +978,18 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
+static bool format_is_yuv(enum omap_color_mode color_mode)
+{
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_NV12:
+		return true;
+	default:
+		return false;
+	}
+}
+
 static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
 		enum omap_dss_rotation_type rotation_type)
 {
@@ -1703,9 +1715,8 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 
 	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
-	if ((color_mode != OMAP_DSS_COLOR_YUV2 &&
-			color_mode != OMAP_DSS_COLOR_UYVY &&
-			color_mode != OMAP_DSS_COLOR_NV12)) {
+
+	if (!format_is_yuv(color_mode)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
 			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
@@ -2384,19 +2395,9 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_NV12:
-		if (in_width & 1) {
-			DSSERR("input width %d is not even for YUV format\n",
-				in_width);
-			return -EINVAL;
-		}
-		break;
-
-	default:
-		break;
+	if (format_is_yuv(color_mode) && (in_width & 1)) {
+		DSSERR("input width %d is not even for YUV format\n", in_width);
+		return -EINVAL;
 	}
 
 	out_width = out_width == 0 ? width : out_width;
@@ -2433,26 +2434,15 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
 			x_predecim, y_predecim, in_width, in_height);
 
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_NV12:
-		if (in_width & 1) {
-			DSSDBG("predecimated input width is not even for YUV format\n");
-			DSSDBG("adjusting input width %d -> %d\n",
-				in_width, in_width & ~1);
-
-			in_width &= ~1;
-		}
-		break;
+	if (format_is_yuv(color_mode) && (in_width & 1)) {
+		DSSDBG("predecimated input width is not even for YUV format\n");
+		DSSDBG("adjusting input width %d -> %d\n",
+			in_width, in_width & ~1);
 
-	default:
-		break;
+		in_width &= ~1;
 	}
 
-	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY ||
-			color_mode == OMAP_DSS_COLOR_NV12)
+	if (format_is_yuv(color_mode))
 		cconv = 1;
 
 	if (ilace && !fieldmode) {

commit 185e23e1f63aa3f2a7ad77f9315b5f8d84002bb0
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 3 15:01:10 2017 +0300

    drm/omap: cleanup offset calculation
    
    The code to calculate offset in dispc's calc_offset() is overly complex.
    Simplify it.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 77d10bf9285f..5c4288f44573 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1923,11 +1923,9 @@ static void calc_offset(u16 screen_width, u16 width,
 	 * field 0 = even field = bottom field
 	 * field 1 = odd field = top field
 	 */
+	*offset0 = field_offset * screen_width * ps;
 	*offset1 = 0;
-	if (field_offset)
-		*offset0 = *offset1 + field_offset * screen_width * ps;
-	else
-		*offset0 = *offset1;
+
 	*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +
 			(fieldmode ? screen_width : 0), ps);
 	if (color_mode == OMAP_DSS_COLOR_YUV2 ||

commit 517a8a9564c0dea98e6d4e2c7f0fe4cbb9b8c9ba
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 3 14:14:27 2017 +0300

    drm/omap: remove dma & vrfb rotation
    
    We have three rotation methods supported by the SoCs with DSS: DMA,
    VRFB and TILER.
    
    DMA rotation works in theory on all DSS platforms, but in practice it's
    unusable due to the huge amount of memory bandwidth it uses, and has
    never really been used.
    
    VRFB is available on OMAP3, but is not supported by omapdrm, even though
    we have some code for it in the dispc driver.
    
    TILER is supported on OMAP4/OMAP5/DRA7/AM5 platforms, but has some
    driver bugs.
    
    To clean up the driver to help fixing the TILER issues, this patch drops
    the DMA and VRFB rotation support, leaving only TILER rotation.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 802d3e72843b..77d10bf9285f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1908,230 +1908,7 @@ static s32 pixinc(int pixels, u8 ps)
 		return 0;
 }
 
-static void calc_vrfb_rotation_offset(u8 rotation, bool mirror,
-		u16 screen_width,
-		u16 width, u16 height,
-		enum omap_color_mode color_mode, bool fieldmode,
-		unsigned int field_offset,
-		unsigned *offset0, unsigned *offset1,
-		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
-{
-	u8 ps;
-
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-		ps = 4;
-		break;
-	default:
-		ps = color_mode_to_bpp(color_mode) / 8;
-		break;
-	}
-
-	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
-			width, height);
-
-	/*
-	 * field 0 = even field = bottom field
-	 * field 1 = odd field = top field
-	 */
-	switch (rotation + mirror * 4) {
-	case OMAP_DSS_ROT_0:
-	case OMAP_DSS_ROT_180:
-		/*
-		 * If the pixel format is YUV or UYVY divide the width
-		 * of the image by 2 for 0 and 180 degree rotation.
-		 */
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			width = width >> 1;
-	case OMAP_DSS_ROT_90:
-	case OMAP_DSS_ROT_270:
-		*offset1 = 0;
-		if (field_offset)
-			*offset0 = field_offset * screen_width * ps;
-		else
-			*offset0 = 0;
-
-		*row_inc = pixinc(1 +
-			(y_predecim * screen_width - x_predecim * width) +
-			(fieldmode ? screen_width : 0), ps);
-		*pix_inc = pixinc(x_predecim, ps);
-		break;
-
-	case OMAP_DSS_ROT_0 + 4:
-	case OMAP_DSS_ROT_180 + 4:
-		/* If the pixel format is YUV or UYVY divide the width
-		 * of the image by 2  for 0 degree and 180 degree
-		 */
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			width = width >> 1;
-	case OMAP_DSS_ROT_90 + 4:
-	case OMAP_DSS_ROT_270 + 4:
-		*offset1 = 0;
-		if (field_offset)
-			*offset0 = field_offset * screen_width * ps;
-		else
-			*offset0 = 0;
-		*row_inc = pixinc(1 -
-			(y_predecim * screen_width + x_predecim * width) -
-			(fieldmode ? screen_width : 0), ps);
-		*pix_inc = pixinc(x_predecim, ps);
-		break;
-
-	default:
-		BUG();
-		return;
-	}
-}
-
-static void calc_dma_rotation_offset(u8 rotation, bool mirror,
-		u16 screen_width,
-		u16 width, u16 height,
-		enum omap_color_mode color_mode, bool fieldmode,
-		unsigned int field_offset,
-		unsigned *offset0, unsigned *offset1,
-		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
-{
-	u8 ps;
-	u16 fbw, fbh;
-
-	ps = color_mode_to_bpp(color_mode) / 8;
-
-	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
-			width, height);
-
-	/* width & height are overlay sizes, convert to fb sizes */
-
-	if (rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180) {
-		fbw = width;
-		fbh = height;
-	} else {
-		fbw = height;
-		fbh = width;
-	}
-
-	/*
-	 * field 0 = even field = bottom field
-	 * field 1 = odd field = top field
-	 */
-	switch (rotation + mirror * 4) {
-	case OMAP_DSS_ROT_0:
-		*offset1 = 0;
-		if (field_offset)
-			*offset0 = *offset1 + field_offset * screen_width * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(1 +
-			(y_predecim * screen_width - fbw * x_predecim) +
-			(fieldmode ? screen_width : 0),	ps);
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			*pix_inc = pixinc(x_predecim, 2 * ps);
-		else
-			*pix_inc = pixinc(x_predecim, ps);
-		break;
-	case OMAP_DSS_ROT_90:
-		*offset1 = screen_width * (fbh - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 + field_offset * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) +
-				y_predecim + (fieldmode ? 1 : 0), ps);
-		*pix_inc = pixinc(-x_predecim * screen_width, ps);
-		break;
-	case OMAP_DSS_ROT_180:
-		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 - field_offset * screen_width * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(-1 -
-			(y_predecim * screen_width - fbw * x_predecim) -
-			(fieldmode ? screen_width : 0),	ps);
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			*pix_inc = pixinc(-x_predecim, 2 * ps);
-		else
-			*pix_inc = pixinc(-x_predecim, ps);
-		break;
-	case OMAP_DSS_ROT_270:
-		*offset1 = (fbw - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 - field_offset * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) -
-				y_predecim - (fieldmode ? 1 : 0), ps);
-		*pix_inc = pixinc(x_predecim * screen_width, ps);
-		break;
-
-	/* mirroring */
-	case OMAP_DSS_ROT_0 + 4:
-		*offset1 = (fbw - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 + field_offset * screen_width * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(y_predecim * screen_width * 2 - 1 +
-				(fieldmode ? screen_width : 0),
-				ps);
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			*pix_inc = pixinc(-x_predecim, 2 * ps);
-		else
-			*pix_inc = pixinc(-x_predecim, ps);
-		break;
-
-	case OMAP_DSS_ROT_90 + 4:
-		*offset1 = 0;
-		if (field_offset)
-			*offset0 = *offset1 + field_offset * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) +
-				y_predecim + (fieldmode ? 1 : 0),
-				ps);
-		*pix_inc = pixinc(x_predecim * screen_width, ps);
-		break;
-
-	case OMAP_DSS_ROT_180 + 4:
-		*offset1 = screen_width * (fbh - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 - field_offset * screen_width * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(1 - y_predecim * screen_width * 2 -
-				(fieldmode ? screen_width : 0),
-				ps);
-		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY)
-			*pix_inc = pixinc(x_predecim, 2 * ps);
-		else
-			*pix_inc = pixinc(x_predecim, ps);
-		break;
-
-	case OMAP_DSS_ROT_270 + 4:
-		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
-		if (field_offset)
-			*offset0 = *offset1 - field_offset * ps;
-		else
-			*offset0 = *offset1;
-		*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) -
-				y_predecim - (fieldmode ? 1 : 0),
-				ps);
-		*pix_inc = pixinc(-x_predecim * screen_width, ps);
-		break;
-
-	default:
-		BUG();
-		return;
-	}
-}
-
-static void calc_tiler_rotation_offset(u16 screen_width, u16 width,
+static void calc_offset(u16 screen_width, u16 width,
 		enum omap_color_mode color_mode, bool fieldmode,
 		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
 		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
@@ -2711,23 +2488,10 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		frame_height = height;
 	}
 
-	if (rotation_type == OMAP_DSS_ROT_TILER)
-		calc_tiler_rotation_offset(screen_width, frame_width,
-				color_mode, fieldmode, field_offset,
-				&offset0, &offset1, &row_inc, &pix_inc,
-				x_predecim, y_predecim);
-	else if (rotation_type == OMAP_DSS_ROT_DMA)
-		calc_dma_rotation_offset(rotation, mirror, screen_width,
-				frame_width, frame_height,
-				color_mode, fieldmode, field_offset,
-				&offset0, &offset1, &row_inc, &pix_inc,
-				x_predecim, y_predecim);
-	else
-		calc_vrfb_rotation_offset(rotation, mirror,
-				screen_width, frame_width, frame_height,
-				color_mode, fieldmode, field_offset,
-				&offset0, &offset1, &row_inc, &pix_inc,
-				x_predecim, y_predecim);
+	calc_offset(screen_width, frame_width,
+			color_mode, fieldmode, field_offset,
+			&offset0, &offset1, &row_inc, &pix_inc,
+			x_predecim, y_predecim);
 
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
@@ -4168,7 +3932,7 @@ static const struct dispc_errata_i734_data {
 		.width = 1, .height = 1,
 		.color_mode = OMAP_DSS_COLOR_RGB24U,
 		.rotation = OMAP_DSS_ROT_0,
-		.rotation_type = OMAP_DSS_ROT_DMA,
+		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,
 		.pos_x = 0, .pos_y = 0,
 		.out_width = 0, .out_height = 0,

commit 4b9cdd96e7ea3dc2cd0edac67835f6f38c4f14c9
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Mar 10 10:32:30 2017 +0200

    drm/omap: remove CLUT
    
    DSS IP versions 2 and 3 support CLUT modes (color lookup table), but the
    driver has never supported those. We still have had some code for CLUT
    modes. As the newer DSS IP versions have dropped CLUT support, we might
    as well clean up the driver by removing the CLUT related code.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index afefdcfdde6c..802d3e72843b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -946,14 +946,6 @@ static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 		}
 	} else {
 		switch (color_mode) {
-		case OMAP_DSS_COLOR_CLUT1:
-			m = 0x0; break;
-		case OMAP_DSS_COLOR_CLUT2:
-			m = 0x1; break;
-		case OMAP_DSS_COLOR_CLUT4:
-			m = 0x2; break;
-		case OMAP_DSS_COLOR_CLUT8:
-			m = 0x3; break;
 		case OMAP_DSS_COLOR_RGB12U:
 			m = 0x4; break;
 		case OMAP_DSS_COLOR_ARGB16:
@@ -1878,13 +1870,6 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 static int color_mode_to_bpp(enum omap_color_mode color_mode)
 {
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_CLUT1:
-		return 1;
-	case OMAP_DSS_COLOR_CLUT2:
-		return 2;
-	case OMAP_DSS_COLOR_CLUT4:
-		return 4;
-	case OMAP_DSS_COLOR_CLUT8:
 	case OMAP_DSS_COLOR_NV12:
 		return 8;
 	case OMAP_DSS_COLOR_RGB12U:
@@ -1933,14 +1918,7 @@ static void calc_vrfb_rotation_offset(u8 rotation, bool mirror,
 {
 	u8 ps;
 
-	/* FIXME CLUT formats */
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_CLUT1:
-	case OMAP_DSS_COLOR_CLUT2:
-	case OMAP_DSS_COLOR_CLUT4:
-	case OMAP_DSS_COLOR_CLUT8:
-		BUG();
-		return;
 	case OMAP_DSS_COLOR_YUV2:
 	case OMAP_DSS_COLOR_UYVY:
 		ps = 4;
@@ -2019,18 +1997,7 @@ static void calc_dma_rotation_offset(u8 rotation, bool mirror,
 	u8 ps;
 	u16 fbw, fbh;
 
-	/* FIXME CLUT formats */
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_CLUT1:
-	case OMAP_DSS_COLOR_CLUT2:
-	case OMAP_DSS_COLOR_CLUT4:
-	case OMAP_DSS_COLOR_CLUT8:
-		BUG();
-		return;
-	default:
-		ps = color_mode_to_bpp(color_mode) / 8;
-		break;
-	}
+	ps = color_mode_to_bpp(color_mode) / 8;
 
 	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
 			width, height);
@@ -2171,17 +2138,7 @@ static void calc_tiler_rotation_offset(u16 screen_width, u16 width,
 {
 	u8 ps;
 
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_CLUT1:
-	case OMAP_DSS_COLOR_CLUT2:
-	case OMAP_DSS_COLOR_CLUT4:
-	case OMAP_DSS_COLOR_CLUT8:
-		BUG();
-		return;
-	default:
-		ps = color_mode_to_bpp(color_mode) / 8;
-		break;
-	}
+	ps = color_mode_to_bpp(color_mode) / 8;
 
 	DSSDBG("scrw %d, width %d\n", screen_width, width);
 
@@ -2582,16 +2539,6 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 				2 : max_decim_limit;
 	}
 
-	if (color_mode == OMAP_DSS_COLOR_CLUT1 ||
-	    color_mode == OMAP_DSS_COLOR_CLUT2 ||
-	    color_mode == OMAP_DSS_COLOR_CLUT4 ||
-	    color_mode == OMAP_DSS_COLOR_CLUT8) {
-		*x_predecim = 1;
-		*y_predecim = 1;
-		*five_taps = false;
-		return 0;
-	}
-
 	decim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxdownscale);
 	decim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxdownscale);
 

commit 6d86278c9ddb2026727a6a9ba5a4550561aea940
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Aug 29 11:15:49 2016 +0300

    drm/omap: fix setting & clearing DOUBLESTRIDE
    
    The code that sets and clears DOUBLESTRIDE is only ran when using NV12.
    This is not correct, as we might first set the bith when using NV12, but
    never clear it when using other formats.
    
    Fix it so that when the bit is available (when the HW supports NV12) we
    always either set or clear the bit.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ac8ca605e314..afefdcfdde6c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1864,14 +1864,15 @@ static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
-	if (color_mode == OMAP_DSS_COLOR_NV12) {
-		bool doublestride = (rotation_type == OMAP_DSS_ROT_TILER) &&
-					(rotation == OMAP_DSS_ROT_0 ||
-					rotation == OMAP_DSS_ROT_180);
+	if (dss_feat_color_mode_supported(plane, OMAP_DSS_COLOR_NV12)) {
+		bool doublestride =
+			color_mode == OMAP_DSS_COLOR_NV12 &&
+			rotation_type == OMAP_DSS_ROT_TILER &&
+			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
+
 		/* DOUBLESTRIDE */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
 	}
-
 }
 
 static int color_mode_to_bpp(enum omap_color_mode color_mode)

commit 2e953d83a6797e4f1c6fe48c08fc9a8fcb50db78
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Feb 20 13:18:38 2017 +0200

    drm/omap: remove read_irqenable()
    
    We only use read_irqenable() to flush posted write. Instead of having a
    separate function for this, do the flush implicitly in write_irqenable().
    Thus we can remove read_irqenable().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 05436eaad3ef..ac8ca605e314 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3782,11 +3782,6 @@ static void dispc_clear_irqstatus(u32 mask)
 	dispc_write_reg(DISPC_IRQSTATUS, mask);
 }
 
-static u32 dispc_read_irqenable(void)
-{
-	return dispc_read_reg(DISPC_IRQENABLE);
-}
-
 static void dispc_write_irqenable(u32 mask)
 {
 	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
@@ -3795,6 +3790,9 @@ static void dispc_write_irqenable(u32 mask)
 	dispc_clear_irqstatus((mask ^ old_mask) & mask);
 
 	dispc_write_reg(DISPC_IRQENABLE, mask);
+
+	/* flush posted write */
+	dispc_read_reg(DISPC_IRQENABLE);
 }
 
 void dispc_enable_sidle(void)
@@ -4345,7 +4343,6 @@ static void dispc_errata_i734_wa(void)
 static const struct dispc_ops dispc_ops = {
 	.read_irqstatus = dispc_read_irqstatus,
 	.clear_irqstatus = dispc_clear_irqstatus,
-	.read_irqenable = dispc_read_irqenable,
 	.write_irqenable = dispc_write_irqenable,
 
 	.request_irq = dispc_request_irq,

commit 49a3057a5a2fa06264b0756cf417f75b56b7063b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Feb 17 12:30:07 2017 +0200

    drm/omap: remove ovl_set_channel_out
    
    At the moment we have ovl_set_channel_out() to configure the output
    channel of an overlay. It makes sense to have this configuration as part
    of the rest of overlay configuration, and in DSS6+ we need the output
    channel when doing the other overlay configuration.
    
    This patch adds a 'channel' parameter to ovl_setup(), so that all
    overlay configuration is done via the same function, and removes the
    ovl_set_channel_out().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 198d41056447..05436eaad3ef 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2834,21 +2834,21 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 
 static int dispc_ovl_setup(enum omap_plane_id plane,
 		const struct omap_overlay_info *oi,
-		const struct videomode *vm, bool mem_to_mem)
+		const struct videomode *vm, bool mem_to_mem,
+		enum omap_channel channel)
 {
 	int r;
 	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
-	enum omap_channel channel;
 	const bool replication = true;
 
-	channel = dispc_ovl_get_channel_out(plane);
-
 	DSSDBG("dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->"
 		" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",
 		plane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
 		oi->color_mode, oi->rotation, oi->mirror, channel, replication);
 
+	dispc_ovl_set_channel_out(plane, channel);
+
 	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
 		oi->out_width, oi->out_height, oi->color_mode, oi->rotation,
@@ -4304,8 +4304,8 @@ static void dispc_errata_i734_wa(void)
 	REG_FLD_MOD(DISPC_CONFIG, 0x1f, 8, 4);
 
 	/* Setup and enable GFX plane */
-	dispc_ovl_set_channel_out(OMAP_DSS_GFX, OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, &i734.vm, false);
+	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, &i734.vm, false,
+		OMAP_DSS_CHANNEL_LCD);
 	dispc_ovl_enable(OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */
@@ -4372,7 +4372,6 @@ static const struct dispc_ops dispc_ops = {
 	.mgr_set_gamma = dispc_mgr_set_gamma,
 
 	.ovl_enable = dispc_ovl_enable,
-	.ovl_set_channel_out = dispc_ovl_set_channel_out,
 	.ovl_setup = dispc_ovl_setup,
 	.ovl_get_color_modes = dispc_ovl_get_color_modes,
 };

commit 5806bce107d777a150cacb9082f7f6399102cacc
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Feb 17 12:20:16 2017 +0200

    drm/omap: remove unused ovl_enabled()
    
    ovl_enabled() is not used anywhere, so remove it.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 4d5b77f9797c..198d41056447 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2935,11 +2935,6 @@ static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
 	return 0;
 }
 
-static bool dispc_ovl_enabled(enum omap_plane_id plane)
-{
-	return REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);
-}
-
 static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
 {
 	return dss_feat_get_supported_outputs(channel);
@@ -4377,7 +4372,6 @@ static const struct dispc_ops dispc_ops = {
 	.mgr_set_gamma = dispc_mgr_set_gamma,
 
 	.ovl_enable = dispc_ovl_enable,
-	.ovl_enabled = dispc_ovl_enabled,
 	.ovl_set_channel_out = dispc_ovl_set_channel_out,
 	.ovl_setup = dispc_ovl_setup,
 	.ovl_get_color_modes = dispc_ovl_get_color_modes,

commit b22622f0cba3a6ee780787abd84b3b0c1ad09b26
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 7 00:29:09 2017 +0300

    drm: omapdrm: Remove duplicate error messages when mapping memory
    
    The devm_ioremap_resource() call can handle being given a NULL resource,
    and prints an error message when mapping fails. Switch the remaining
    devm_ioremap() calls to devm_ioremap_resource() and remove all
    extraneous resource NULL checks and error messages printed manually by
    the driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5ac0145fbae6..4d5b77f9797c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4405,17 +4405,9 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 		return r;
 
 	dispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);
-	if (!dispc_mem) {
-		DSSERR("can't get IORESOURCE_MEM DISPC\n");
-		return -EINVAL;
-	}
-
-	dispc.base = devm_ioremap(&pdev->dev, dispc_mem->start,
-				  resource_size(dispc_mem));
-	if (!dispc.base) {
-		DSSERR("can't ioremap DISPC\n");
-		return -ENOMEM;
-	}
+	dispc.base = devm_ioremap_resource(&pdev->dev, dispc_mem);
+	if (IS_ERR(dispc.base))
+		return PTR_ERR(dispc.base);
 
 	dispc.irq = platform_get_irq(dispc.pdev, 0);
 	if (dispc.irq < 0) {

commit 273ffeaf8c90c4afc88bc48189d9e8c20106fac7
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Mar 24 16:47:53 2017 +0200

    drm/omap: Fix one ugly indentation style break left by coccinelle
    
    Fix one ugly indentation style break left by the previous coccilnelle
    patch.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 8100fec2ca7b..5ac0145fbae6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1802,8 +1802,7 @@ static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 		rotation);
 }
 
-static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane,
-					 u8 rotation,
+static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		enum omap_dss_rotation_type rotation_type,
 		bool mirroring, enum omap_color_mode color_mode)
 {
@@ -2834,7 +2833,7 @@ static int dispc_ovl_setup_common(enum omap_plane_id plane,
 }
 
 static int dispc_ovl_setup(enum omap_plane_id plane,
-			   const struct omap_overlay_info *oi,
+		const struct omap_overlay_info *oi,
 		const struct videomode *vm, bool mem_to_mem)
 {
 	int r;

commit 864050c78e1c5d619da3c1b0a891d474dfd336bf
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Mar 24 16:47:52 2017 +0200

    drm/omap: Rename enum omap_plane to enum omap_plane_id
    
    The enum omap_plane conflicted with the same struct name for omapdrm
    plane private data. This rename should solve the conflict.
    
    The rename was implement with this very simple coccinelle patch:
    ------------------------
    @@
    @@
    enum
    -omap_plane
    +omap_plane_id
    ------------------------
    The patch was applied like this:
    spatch --sp-file <cocci_file> --all-includes --in-place --dir drivers/gpu/drm/omapdrm
    
    The above patch did not rename the actual enum definition. That was
    added manually on top of the spatch changes.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 2e6a71dbc25d..8100fec2ca7b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -303,8 +303,8 @@ static unsigned long dispc_core_clk_rate(void);
 static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel);
 static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
 
-static unsigned long dispc_plane_pclk_rate(enum omap_plane plane);
-static unsigned long dispc_plane_lclk_rate(enum omap_plane plane);
+static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane);
+static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane);
 
 static void dispc_clear_irqstatus(u32 mask);
 static bool dispc_mgr_is_enabled(enum omap_channel channel);
@@ -653,7 +653,7 @@ bool dispc_wb_go_busy(void)
 
 void dispc_wb_go(void)
 {
-	enum omap_plane plane = OMAP_DSS_WB;
+	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
 
 	enable = REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
@@ -670,29 +670,33 @@ void dispc_wb_go(void)
 	REG_FLD_MOD(DISPC_CONTROL2, 1, 6, 6);
 }
 
-static void dispc_ovl_write_firh_reg(enum omap_plane plane, int reg, u32 value)
+static void dispc_ovl_write_firh_reg(enum omap_plane_id plane, int reg,
+				     u32 value)
 {
 	dispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv_reg(enum omap_plane plane, int reg, u32 value)
+static void dispc_ovl_write_firhv_reg(enum omap_plane_id plane, int reg,
+				      u32 value)
 {
 	dispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv_reg(enum omap_plane plane, int reg, u32 value)
+static void dispc_ovl_write_firv_reg(enum omap_plane_id plane, int reg,
+				     u32 value)
 {
 	dispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);
 }
 
-static void dispc_ovl_write_firh2_reg(enum omap_plane plane, int reg, u32 value)
+static void dispc_ovl_write_firh2_reg(enum omap_plane_id plane, int reg,
+				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
 	dispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv2_reg(enum omap_plane plane, int reg,
+static void dispc_ovl_write_firhv2_reg(enum omap_plane_id plane, int reg,
 		u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
@@ -700,14 +704,15 @@ static void dispc_ovl_write_firhv2_reg(enum omap_plane plane, int reg,
 	dispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv2_reg(enum omap_plane plane, int reg, u32 value)
+static void dispc_ovl_write_firv2_reg(enum omap_plane_id plane, int reg,
+				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
 	dispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);
 }
 
-static void dispc_ovl_set_scale_coef(enum omap_plane plane, int fir_hinc,
+static void dispc_ovl_set_scale_coef(enum omap_plane_id plane, int fir_hinc,
 				int fir_vinc, int five_taps,
 				enum omap_color_component color_comp)
 {
@@ -753,7 +758,7 @@ static void dispc_ovl_set_scale_coef(enum omap_plane plane, int fir_hinc,
 }
 
 
-static void dispc_ovl_write_color_conv_coef(enum omap_plane plane,
+static void dispc_ovl_write_color_conv_coef(enum omap_plane_id plane,
 		const struct color_conv_coef *ct)
 {
 #define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
@@ -789,27 +794,27 @@ static void dispc_setup_color_conv_coef(void)
 		dispc_ovl_write_color_conv_coef(OMAP_DSS_WB, &ctbl_bt601_5_wb);
 }
 
-static void dispc_ovl_set_ba0(enum omap_plane plane, u32 paddr)
+static void dispc_ovl_set_ba0(enum omap_plane_id plane, u32 paddr)
 {
 	dispc_write_reg(DISPC_OVL_BA0(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1(enum omap_plane plane, u32 paddr)
+static void dispc_ovl_set_ba1(enum omap_plane_id plane, u32 paddr)
 {
 	dispc_write_reg(DISPC_OVL_BA1(plane), paddr);
 }
 
-static void dispc_ovl_set_ba0_uv(enum omap_plane plane, u32 paddr)
+static void dispc_ovl_set_ba0_uv(enum omap_plane_id plane, u32 paddr)
 {
 	dispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1_uv(enum omap_plane plane, u32 paddr)
+static void dispc_ovl_set_ba1_uv(enum omap_plane_id plane, u32 paddr)
 {
 	dispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_pos(enum omap_plane plane,
+static void dispc_ovl_set_pos(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, int x, int y)
 {
 	u32 val;
@@ -822,7 +827,7 @@ static void dispc_ovl_set_pos(enum omap_plane plane,
 	dispc_write_reg(DISPC_OVL_POSITION(plane), val);
 }
 
-static void dispc_ovl_set_input_size(enum omap_plane plane, int width,
+static void dispc_ovl_set_input_size(enum omap_plane_id plane, int width,
 		int height)
 {
 	u32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
@@ -833,7 +838,7 @@ static void dispc_ovl_set_input_size(enum omap_plane plane, int width,
 		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_output_size(enum omap_plane plane, int width,
+static void dispc_ovl_set_output_size(enum omap_plane_id plane, int width,
 		int height)
 {
 	u32 val;
@@ -848,7 +853,7 @@ static void dispc_ovl_set_output_size(enum omap_plane plane, int width,
 		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_zorder(enum omap_plane plane,
+static void dispc_ovl_set_zorder(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u8 zorder)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)
@@ -868,7 +873,7 @@ static void dispc_ovl_enable_zorder_planes(void)
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
 }
 
-static void dispc_ovl_set_pre_mult_alpha(enum omap_plane plane,
+static void dispc_ovl_set_pre_mult_alpha(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, bool enable)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)
@@ -877,7 +882,7 @@ static void dispc_ovl_set_pre_mult_alpha(enum omap_plane plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
 }
 
-static void dispc_ovl_setup_global_alpha(enum omap_plane plane,
+static void dispc_ovl_setup_global_alpha(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u8 global_alpha)
 {
 	static const unsigned shifts[] = { 0, 8, 16, 24, };
@@ -890,17 +895,17 @@ static void dispc_ovl_setup_global_alpha(enum omap_plane plane,
 	REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
 }
 
-static void dispc_ovl_set_pix_inc(enum omap_plane plane, s32 inc)
+static void dispc_ovl_set_pix_inc(enum omap_plane_id plane, s32 inc)
 {
 	dispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);
 }
 
-static void dispc_ovl_set_row_inc(enum omap_plane plane, s32 inc)
+static void dispc_ovl_set_row_inc(enum omap_plane_id plane, s32 inc)
 {
 	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
 }
 
-static void dispc_ovl_set_color_mode(enum omap_plane plane,
+static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
 		enum omap_color_mode color_mode)
 {
 	u32 m = 0;
@@ -981,7 +986,7 @@ static void dispc_ovl_set_color_mode(enum omap_plane plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
-static void dispc_ovl_configure_burst_type(enum omap_plane plane,
+static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
 		enum omap_dss_rotation_type rotation_type)
 {
 	if (dss_has_feature(FEAT_BURST_2D) == 0)
@@ -993,7 +998,8 @@ static void dispc_ovl_configure_burst_type(enum omap_plane plane,
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
 }
 
-static void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)
+static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
+				      enum omap_channel channel)
 {
 	int shift;
 	u32 val;
@@ -1054,7 +1060,7 @@ static void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel c
 	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)
+static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
 {
 	int shift;
 	u32 val;
@@ -1096,12 +1102,12 @@ static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)
 
 void dispc_wb_set_channel_in(enum dss_writeback_channel channel)
 {
-	enum omap_plane plane = OMAP_DSS_WB;
+	enum omap_plane_id plane = OMAP_DSS_WB;
 
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
 }
 
-static void dispc_ovl_set_burst_size(enum omap_plane plane,
+static void dispc_ovl_set_burst_size(enum omap_plane_id plane,
 		enum omap_burst_size burst_size)
 {
 	static const unsigned shifts[] = { 6, 14, 14, 14, 14, };
@@ -1123,14 +1129,14 @@ static void dispc_configure_burst_sizes(void)
 		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
 }
 
-static u32 dispc_ovl_get_burst_size(enum omap_plane plane)
+static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
 {
 	unsigned unit = dss_feat_get_burst_size_unit();
 	/* burst multiplier is always x8 (see dispc_configure_burst_sizes()) */
 	return unit * 8;
 }
 
-static enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane plane)
+static enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane_id plane)
 {
 	return dss_feat_get_supported_color_modes(plane);
 }
@@ -1168,7 +1174,8 @@ static void dispc_mgr_set_cpr_coef(enum omap_channel channel,
 	dispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);
 }
 
-static void dispc_ovl_set_vid_color_conv(enum omap_plane plane, bool enable)
+static void dispc_ovl_set_vid_color_conv(enum omap_plane_id plane,
+					 bool enable)
 {
 	u32 val;
 
@@ -1179,7 +1186,7 @@ static void dispc_ovl_set_vid_color_conv(enum omap_plane plane, bool enable)
 	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static void dispc_ovl_enable_replication(enum omap_plane plane,
+static void dispc_ovl_enable_replication(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, bool enable)
 {
 	static const unsigned shifts[] = { 5, 10, 10, 10 };
@@ -1276,7 +1283,7 @@ static void dispc_init_fifos(void)
 	}
 }
 
-static u32 dispc_ovl_get_fifo_size(enum omap_plane plane)
+static u32 dispc_ovl_get_fifo_size(enum omap_plane_id plane)
 {
 	int fifo;
 	u32 size = 0;
@@ -1289,7 +1296,8 @@ static u32 dispc_ovl_get_fifo_size(enum omap_plane plane)
 	return size;
 }
 
-void dispc_ovl_set_fifo_threshold(enum omap_plane plane, u32 low, u32 high)
+void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
+				  u32 high)
 {
 	u8 hi_start, hi_end, lo_start, lo_end;
 	u32 unit;
@@ -1338,7 +1346,7 @@ void dispc_enable_fifomerge(bool enable)
 	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
 }
 
-void dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,
+void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
 		u32 *fifo_low, u32 *fifo_high, bool use_fifomerge,
 		bool manual_update)
 {
@@ -1385,7 +1393,7 @@ void dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,
 	}
 }
 
-static void dispc_ovl_set_mflag(enum omap_plane plane, bool enable)
+static void dispc_ovl_set_mflag(enum omap_plane_id plane, bool enable)
 {
 	int bit;
 
@@ -1397,7 +1405,7 @@ static void dispc_ovl_set_mflag(enum omap_plane plane, bool enable)
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
 }
 
-static void dispc_ovl_set_mflag_threshold(enum omap_plane plane,
+static void dispc_ovl_set_mflag_threshold(enum omap_plane_id plane,
 	int low, int high)
 {
 	dispc_write_reg(DISPC_OVL_MFLAG_THRESHOLD(plane),
@@ -1461,7 +1469,7 @@ static void dispc_init_mflag(void)
 	}
 }
 
-static void dispc_ovl_set_fir(enum omap_plane plane,
+static void dispc_ovl_set_fir(enum omap_plane_id plane,
 				int hinc, int vinc,
 				enum omap_color_component color_comp)
 {
@@ -1484,7 +1492,8 @@ static void dispc_ovl_set_fir(enum omap_plane plane,
 	}
 }
 
-static void dispc_ovl_set_vid_accu0(enum omap_plane plane, int haccu, int vaccu)
+static void dispc_ovl_set_vid_accu0(enum omap_plane_id plane, int haccu,
+				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
@@ -1498,7 +1507,8 @@ static void dispc_ovl_set_vid_accu0(enum omap_plane plane, int haccu, int vaccu)
 	dispc_write_reg(DISPC_OVL_ACCU0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)
+static void dispc_ovl_set_vid_accu1(enum omap_plane_id plane, int haccu,
+				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
@@ -1512,7 +1522,7 @@ static void dispc_ovl_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)
 	dispc_write_reg(DISPC_OVL_ACCU1(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_0(enum omap_plane plane, int haccu,
+static void dispc_ovl_set_vid_accu2_0(enum omap_plane_id plane, int haccu,
 		int vaccu)
 {
 	u32 val;
@@ -1521,7 +1531,7 @@ static void dispc_ovl_set_vid_accu2_0(enum omap_plane plane, int haccu,
 	dispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_1(enum omap_plane plane, int haccu,
+static void dispc_ovl_set_vid_accu2_1(enum omap_plane_id plane, int haccu,
 		int vaccu)
 {
 	u32 val;
@@ -1530,7 +1540,7 @@ static void dispc_ovl_set_vid_accu2_1(enum omap_plane plane, int haccu,
 	dispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);
 }
 
-static void dispc_ovl_set_scale_param(enum omap_plane plane,
+static void dispc_ovl_set_scale_param(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool five_taps, u8 rotation,
@@ -1546,7 +1556,7 @@ static void dispc_ovl_set_scale_param(enum omap_plane plane,
 	dispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);
 }
 
-static void dispc_ovl_set_accu_uv(enum omap_plane plane,
+static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
 		bool ilace, enum omap_color_mode color_mode, u8 rotation)
 {
@@ -1634,7 +1644,7 @@ static void dispc_ovl_set_accu_uv(enum omap_plane plane,
 	dispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);
 }
 
-static void dispc_ovl_set_scaling_common(enum omap_plane plane,
+static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
@@ -1688,7 +1698,7 @@ static void dispc_ovl_set_scaling_common(enum omap_plane plane,
 	dispc_ovl_set_vid_accu1(plane, 0, accu1);
 }
 
-static void dispc_ovl_set_scaling_uv(enum omap_plane plane,
+static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
@@ -1768,7 +1778,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane plane,
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
 }
 
-static void dispc_ovl_set_scaling(enum omap_plane plane,
+static void dispc_ovl_set_scaling(enum omap_plane_id plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
@@ -1792,7 +1802,8 @@ static void dispc_ovl_set_scaling(enum omap_plane plane,
 		rotation);
 }
 
-static void dispc_ovl_set_rotation_attrs(enum omap_plane plane, u8 rotation,
+static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane,
+					 u8 rotation,
 		enum omap_dss_rotation_type rotation_type,
 		bool mirroring, enum omap_color_mode color_mode)
 {
@@ -2624,7 +2635,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	return 0;
 }
 
-static int dispc_ovl_setup_common(enum omap_plane plane,
+static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
 		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
@@ -2822,7 +2833,8 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 	return 0;
 }
 
-static int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
+static int dispc_ovl_setup(enum omap_plane_id plane,
+			   const struct omap_overlay_info *oi,
 		const struct videomode *vm, bool mem_to_mem)
 {
 	int r;
@@ -2852,7 +2864,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 {
 	int r;
 	u32 l;
-	enum omap_plane plane = OMAP_DSS_WB;
+	enum omap_plane_id plane = OMAP_DSS_WB;
 	const int pos_x = 0, pos_y = 0;
 	const u8 zorder = 0, global_alpha = 0;
 	const bool replication = true;
@@ -2915,7 +2927,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	return r;
 }
 
-static int dispc_ovl_enable(enum omap_plane plane, bool enable)
+static int dispc_ovl_enable(enum omap_plane_id plane, bool enable)
 {
 	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
 
@@ -2924,7 +2936,7 @@ static int dispc_ovl_enable(enum omap_plane plane, bool enable)
 	return 0;
 }
 
-static bool dispc_ovl_enabled(enum omap_plane plane)
+static bool dispc_ovl_enabled(enum omap_plane_id plane)
 {
 	return REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);
 }
@@ -3392,7 +3404,7 @@ static unsigned long dispc_core_clk_rate(void)
 	return dispc.core_clk_rate;
 }
 
-static unsigned long dispc_plane_pclk_rate(enum omap_plane plane)
+static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 
@@ -3404,7 +3416,7 @@ static unsigned long dispc_plane_pclk_rate(enum omap_plane plane)
 	return dispc_mgr_pclk_rate(channel);
 }
 
-static unsigned long dispc_plane_lclk_rate(enum omap_plane plane)
+static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 

commit 956d4f9308d027119282330b54859cf20d222710
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 23 13:23:42 2016 +0200

    drm/omap: dispc: improve debug print of display flags
    
    Instead of printing 0/1 for display flags like vsync high/low, use a
    tri-state print (-1/0/1) to indicate the "undefined" state.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 83241052df6b..2e6a71dbc25d 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3229,6 +3229,16 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	}
 }
 
+static int vm_flag_to_int(enum display_flags flags, enum display_flags high,
+	enum display_flags low)
+{
+	if (flags & high)
+		return 1;
+	if (flags & low)
+		return -1;
+	return 0;
+}
+
 /* change name to mode? */
 static void dispc_mgr_set_timings(enum omap_channel channel,
 			   const struct videomode *vm)
@@ -3258,11 +3268,11 @@ static void dispc_mgr_set_timings(enum omap_channel channel,
 			t.hsync_len, t.hfront_porch, t.hback_porch,
 			t.vsync_len, t.vfront_porch, t.vback_porch);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
-			!!(t.flags & DISPLAY_FLAGS_VSYNC_HIGH),
-			!!(t.flags & DISPLAY_FLAGS_HSYNC_HIGH),
-			!!(t.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE),
-			!!(t.flags & DISPLAY_FLAGS_DE_HIGH),
-			!!(t.flags & DISPLAY_FLAGS_SYNC_POSEDGE));
+			vm_flag_to_int(t.flags, DISPLAY_FLAGS_VSYNC_HIGH, DISPLAY_FLAGS_VSYNC_LOW),
+			vm_flag_to_int(t.flags, DISPLAY_FLAGS_HSYNC_HIGH, DISPLAY_FLAGS_HSYNC_LOW),
+			vm_flag_to_int(t.flags, DISPLAY_FLAGS_PIXDATA_POSEDGE, DISPLAY_FLAGS_PIXDATA_NEGEDGE),
+			vm_flag_to_int(t.flags, DISPLAY_FLAGS_DE_HIGH, DISPLAY_FLAGS_DE_LOW),
+			vm_flag_to_int(t.flags, DISPLAY_FLAGS_SYNC_POSEDGE, DISPLAY_FLAGS_SYNC_NEGEDGE));
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {

commit be2d68c69e5c5a54cd2179aa6971d42cc3a49375
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Aug 29 13:15:02 2016 +0300

    drm/omap: fix replication logic
    
    DSS uses "replication logic" to convert color components from smaller
    bit widths to bigger bit widths. Without replication logic, the color
    component would be shifted and the least significant bits would be left
    at 0, whereas with replication logic, the least significat bits will be
    filled with the most significant bit.
    
    For some reason omapdrm leaves replication logic always to off, which,
    in the most common case, means that showing 16-bit RGB colors on 24-bit
    display gives a bit darker colors than expected.
    
    The reset value of the replication logic bit is enabled, and it should
    always be set, as there's no practical reason to disable it. This patch
    removes the option to disable it from omapdrm, and always sets it to
    enabled in dispc.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index e9d98046a97f..83241052df6b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2823,11 +2823,12 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 }
 
 static int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
-		bool replication, const struct videomode *vm, bool mem_to_mem)
+		const struct videomode *vm, bool mem_to_mem)
 {
 	int r;
 	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
 	enum omap_channel channel;
+	const bool replication = true;
 
 	channel = dispc_ovl_get_channel_out(plane);
 
@@ -2854,7 +2855,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	enum omap_plane plane = OMAP_DSS_WB;
 	const int pos_x = 0, pos_y = 0;
 	const u8 zorder = 0, global_alpha = 0;
-	const bool replication = false;
+	const bool replication = true;
 	bool truncation;
 	int in_width = vm->hactive;
 	int in_height = vm->vactive;
@@ -4288,7 +4289,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Setup and enable GFX plane */
 	dispc_ovl_set_channel_out(OMAP_DSS_GFX, OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, false, &i734.vm, false);
+	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, &i734.vm, false);
 	dispc_ovl_enable(OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */

commit b8480cab36ecc99dc3a1c5c50d8c7d7b19e0011a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Nov 10 17:59:49 2015 -0600

    drm/omap: remove unused dispc_wb_enable & dispc_wb_is_enabled
    
    Remove two unused WB functions.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 7104cffde176..e9d98046a97f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2933,16 +2933,6 @@ static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel
 	return dss_feat_get_supported_outputs(channel);
 }
 
-void dispc_wb_enable(bool enable)
-{
-	dispc_ovl_enable(OMAP_DSS_WB, enable);
-}
-
-bool dispc_wb_is_enabled(void)
-{
-	return dispc_ovl_enabled(OMAP_DSS_WB);
-}
-
 static void dispc_lcd_enable_signal_polarity(bool act_high)
 {
 	if (!dss_has_feature(FEAT_LCDENABLEPOL))

commit 5034b1fa0511e515c848dfb1bc54b4aaa8e12d38
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 20:06:06 2015 +0200

    drm/omap: remove all EXPORT_SYMBOLs from dispc.c
    
    omapdrm now uses dispc_ops instead of direct function calls so we can
    remove all EXPORT_SYMBOLs from dispc. Most of the functions can also be
    made static, but a few are used outside dispc.c.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f871f69dab1a..7104cffde176 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -306,6 +306,10 @@ static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
 static unsigned long dispc_plane_pclk_rate(enum omap_plane plane);
 static unsigned long dispc_plane_lclk_rate(enum omap_plane plane);
 
+static void dispc_clear_irqstatus(u32 mask);
+static bool dispc_mgr_is_enabled(enum omap_channel channel);
+static void dispc_clear_irqstatus(u32 mask);
+
 static inline void dispc_write_reg(const u16 idx, u32 val)
 {
 	__raw_writel(val, dispc.base + idx);
@@ -581,7 +585,6 @@ int dispc_runtime_get(void)
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
-EXPORT_SYMBOL(dispc_runtime_get);
 
 void dispc_runtime_put(void)
 {
@@ -592,54 +595,48 @@ void dispc_runtime_put(void)
 	r = pm_runtime_put_sync(&dispc.pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
-EXPORT_SYMBOL(dispc_runtime_put);
 
-u32 dispc_mgr_get_vsync_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_vsync_irq(enum omap_channel channel)
 {
 	return mgr_desc[channel].vsync_irq;
 }
-EXPORT_SYMBOL(dispc_mgr_get_vsync_irq);
 
-u32 dispc_mgr_get_framedone_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_framedone_irq(enum omap_channel channel)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT && dispc.feat->no_framedone_tv)
 		return 0;
 
 	return mgr_desc[channel].framedone_irq;
 }
-EXPORT_SYMBOL(dispc_mgr_get_framedone_irq);
 
-u32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)
+static u32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)
 {
 	return mgr_desc[channel].sync_lost_irq;
 }
-EXPORT_SYMBOL(dispc_mgr_get_sync_lost_irq);
 
 u32 dispc_wb_get_framedone_irq(void)
 {
 	return DISPC_IRQ_FRAMEDONEWB;
 }
 
-void dispc_mgr_enable(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable(enum omap_channel channel, bool enable)
 {
 	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
 	/* flush posted write */
 	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
 }
-EXPORT_SYMBOL(dispc_mgr_enable);
 
 static bool dispc_mgr_is_enabled(enum omap_channel channel)
 {
 	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
 }
 
-bool dispc_mgr_go_busy(enum omap_channel channel)
+static bool dispc_mgr_go_busy(enum omap_channel channel)
 {
 	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
 }
-EXPORT_SYMBOL(dispc_mgr_go_busy);
 
-void dispc_mgr_go(enum omap_channel channel)
+static void dispc_mgr_go(enum omap_channel channel)
 {
 	WARN_ON(!dispc_mgr_is_enabled(channel));
 	WARN_ON(dispc_mgr_go_busy(channel));
@@ -648,7 +645,6 @@ void dispc_mgr_go(enum omap_channel channel)
 
 	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
 }
-EXPORT_SYMBOL(dispc_mgr_go);
 
 bool dispc_wb_go_busy(void)
 {
@@ -997,7 +993,7 @@ static void dispc_ovl_configure_burst_type(enum omap_plane plane,
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
 }
 
-void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)
+static void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)
 {
 	int shift;
 	u32 val;
@@ -1057,7 +1053,6 @@ void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)
 	}
 	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
 }
-EXPORT_SYMBOL(dispc_ovl_set_channel_out);
 
 static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)
 {
@@ -1135,17 +1130,15 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane plane)
 	return unit * 8;
 }
 
-enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane plane)
+static enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane plane)
 {
 	return dss_feat_get_supported_color_modes(plane);
 }
-EXPORT_SYMBOL(dispc_ovl_get_color_modes);
 
-int dispc_get_num_ovls(void)
+static int dispc_get_num_ovls(void)
 {
 	return dss_feat_get_num_ovls();
 }
-EXPORT_SYMBOL(dispc_get_num_ovls);
 
 static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
 {
@@ -2829,9 +2822,8 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 	return 0;
 }
 
-int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
-		bool replication, const struct videomode *vm,
-		bool mem_to_mem)
+static int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
+		bool replication, const struct videomode *vm, bool mem_to_mem)
 {
 	int r;
 	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
@@ -2853,7 +2845,6 @@ int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
 
 	return r;
 }
-EXPORT_SYMBOL(dispc_ovl_setup);
 
 int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		bool mem_to_mem, const struct videomode *vm)
@@ -2923,7 +2914,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	return r;
 }
 
-int dispc_ovl_enable(enum omap_plane plane, bool enable)
+static int dispc_ovl_enable(enum omap_plane plane, bool enable)
 {
 	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
 
@@ -2931,19 +2922,16 @@ int dispc_ovl_enable(enum omap_plane plane, bool enable)
 
 	return 0;
 }
-EXPORT_SYMBOL(dispc_ovl_enable);
 
-bool dispc_ovl_enabled(enum omap_plane plane)
+static bool dispc_ovl_enabled(enum omap_plane plane)
 {
 	return REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);
 }
-EXPORT_SYMBOL(dispc_ovl_enabled);
 
-enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
+static enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
 {
 	return dss_feat_get_supported_outputs(channel);
 }
-EXPORT_SYMBOL(dispc_mgr_get_supported_outputs);
 
 void dispc_wb_enable(bool enable)
 {
@@ -2979,11 +2967,10 @@ void dispc_pck_free_enable(bool enable)
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
 }
 
-int dispc_get_num_mgrs(void)
+static int dispc_get_num_mgrs(void)
 {
 	return dss_feat_get_num_mgrs();
 }
-EXPORT_SYMBOL(dispc_get_num_mgrs);
 
 static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
 {
@@ -3033,7 +3020,7 @@ static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
 		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
 }
 
-void dispc_mgr_setup(enum omap_channel channel,
+static void dispc_mgr_setup(enum omap_channel channel,
 		const struct omap_overlay_manager_info *info)
 {
 	dispc_mgr_set_default_color(channel, info->default_color);
@@ -3046,7 +3033,6 @@ void dispc_mgr_setup(enum omap_channel channel,
 		dispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);
 	}
 }
-EXPORT_SYMBOL(dispc_mgr_setup);
 
 static void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)
 {
@@ -3107,7 +3093,7 @@ static void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)
 	mgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);
 }
 
-void dispc_mgr_set_lcd_config(enum omap_channel channel,
+static void dispc_mgr_set_lcd_config(enum omap_channel channel,
 		const struct dss_lcd_mgr_config *config)
 {
 	dispc_mgr_set_io_pad_mode(config->io_pad_mode);
@@ -3123,7 +3109,6 @@ void dispc_mgr_set_lcd_config(enum omap_channel channel,
 
 	dispc_mgr_set_lcd_type_tft(channel);
 }
-EXPORT_SYMBOL(dispc_mgr_set_lcd_config);
 
 static bool _dispc_mgr_size_ok(u16 width, u16 height)
 {
@@ -3254,7 +3239,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 }
 
 /* change name to mode? */
-void dispc_mgr_set_timings(enum omap_channel channel,
+static void dispc_mgr_set_timings(enum omap_channel channel,
 			   const struct videomode *vm)
 {
 	unsigned xtot, ytot;
@@ -3301,7 +3286,6 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 	dispc_mgr_set_size(channel, t.hactive, t.vactive);
 }
-EXPORT_SYMBOL(dispc_mgr_set_timings);
 
 static void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,
 		u16 pck_div)
@@ -3781,25 +3765,22 @@ int dispc_mgr_get_clock_div(enum omap_channel channel,
 	return 0;
 }
 
-u32 dispc_read_irqstatus(void)
+static u32 dispc_read_irqstatus(void)
 {
 	return dispc_read_reg(DISPC_IRQSTATUS);
 }
-EXPORT_SYMBOL(dispc_read_irqstatus);
 
-void dispc_clear_irqstatus(u32 mask)
+static void dispc_clear_irqstatus(u32 mask)
 {
 	dispc_write_reg(DISPC_IRQSTATUS, mask);
 }
-EXPORT_SYMBOL(dispc_clear_irqstatus);
 
-u32 dispc_read_irqenable(void)
+static u32 dispc_read_irqenable(void)
 {
 	return dispc_read_reg(DISPC_IRQENABLE);
 }
-EXPORT_SYMBOL(dispc_read_irqenable);
 
-void dispc_write_irqenable(u32 mask)
+static void dispc_write_irqenable(u32 mask)
 {
 	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
 
@@ -3808,7 +3789,6 @@ void dispc_write_irqenable(u32 mask)
 
 	dispc_write_reg(DISPC_IRQENABLE, mask);
 }
-EXPORT_SYMBOL(dispc_write_irqenable);
 
 void dispc_enable_sidle(void)
 {
@@ -3820,7 +3800,7 @@ void dispc_disable_sidle(void)
 	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
-u32 dispc_mgr_gamma_size(enum omap_channel channel)
+static u32 dispc_mgr_gamma_size(enum omap_channel channel)
 {
 	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
 
@@ -3829,7 +3809,6 @@ u32 dispc_mgr_gamma_size(enum omap_channel channel)
 
 	return gdesc->len;
 }
-EXPORT_SYMBOL(dispc_mgr_gamma_size);
 
 static void dispc_mgr_write_gamma_table(enum omap_channel channel)
 {
@@ -3874,7 +3853,7 @@ static const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {
 	{ .red = U16_MAX, .green = U16_MAX, .blue = U16_MAX, },
 };
 
-void dispc_mgr_set_gamma(enum omap_channel channel,
+static void dispc_mgr_set_gamma(enum omap_channel channel,
 			 const struct drm_color_lut *lut,
 			 unsigned int length)
 {
@@ -3920,7 +3899,6 @@ void dispc_mgr_set_gamma(enum omap_channel channel,
 	if (dispc.is_enabled)
 		dispc_mgr_write_gamma_table(channel);
 }
-EXPORT_SYMBOL(dispc_mgr_set_gamma);
 
 static int dispc_init_gamma_tables(void)
 {
@@ -4167,7 +4145,7 @@ static irqreturn_t dispc_irq_handler(int irq, void *arg)
 	return dispc.user_handler(irq, dispc.user_data);
 }
 
-int dispc_request_irq(irq_handler_t handler, void *dev_id)
+static int dispc_request_irq(irq_handler_t handler, void *dev_id)
 {
 	int r;
 
@@ -4189,16 +4167,14 @@ int dispc_request_irq(irq_handler_t handler, void *dev_id)
 
 	return r;
 }
-EXPORT_SYMBOL(dispc_request_irq);
 
-void dispc_free_irq(void *dev_id)
+static void dispc_free_irq(void *dev_id)
 {
 	devm_free_irq(&dispc.pdev->dev, dispc.irq, &dispc);
 
 	dispc.user_handler = NULL;
 	dispc.user_data = NULL;
 }
-EXPORT_SYMBOL(dispc_free_irq);
 
 /*
  * Workaround for errata i734 in DSS dispc

commit a1a37647d240ffb0b6480c2ecd1b02a4c21f6926
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 19:44:38 2015 +0200

    drm/omap: fill dispc_ops
    
    This patch changes the current omapdss driver to fill a dispc_ops struct
    and set it to omapdss-base.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 53d08dc4ef5a..f871f69dab1a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4359,6 +4359,42 @@ static void dispc_errata_i734_wa(void)
 	REG_FLD_MOD(DISPC_CONFIG, gatestate, 8, 4);
 }
 
+static const struct dispc_ops dispc_ops = {
+	.read_irqstatus = dispc_read_irqstatus,
+	.clear_irqstatus = dispc_clear_irqstatus,
+	.read_irqenable = dispc_read_irqenable,
+	.write_irqenable = dispc_write_irqenable,
+
+	.request_irq = dispc_request_irq,
+	.free_irq = dispc_free_irq,
+
+	.runtime_get = dispc_runtime_get,
+	.runtime_put = dispc_runtime_put,
+
+	.get_num_ovls = dispc_get_num_ovls,
+	.get_num_mgrs = dispc_get_num_mgrs,
+
+	.mgr_enable = dispc_mgr_enable,
+	.mgr_is_enabled = dispc_mgr_is_enabled,
+	.mgr_get_vsync_irq = dispc_mgr_get_vsync_irq,
+	.mgr_get_framedone_irq = dispc_mgr_get_framedone_irq,
+	.mgr_get_sync_lost_irq = dispc_mgr_get_sync_lost_irq,
+	.mgr_go_busy = dispc_mgr_go_busy,
+	.mgr_go = dispc_mgr_go,
+	.mgr_set_lcd_config = dispc_mgr_set_lcd_config,
+	.mgr_set_timings = dispc_mgr_set_timings,
+	.mgr_setup = dispc_mgr_setup,
+	.mgr_get_supported_outputs = dispc_mgr_get_supported_outputs,
+	.mgr_gamma_size = dispc_mgr_gamma_size,
+	.mgr_set_gamma = dispc_mgr_set_gamma,
+
+	.ovl_enable = dispc_ovl_enable,
+	.ovl_enabled = dispc_ovl_enabled,
+	.ovl_set_channel_out = dispc_ovl_set_channel_out,
+	.ovl_setup = dispc_ovl_setup,
+	.ovl_get_color_modes = dispc_ovl_get_color_modes,
+};
+
 /* DISPC HW IP initialisation */
 static int dispc_bind(struct device *dev, struct device *master, void *data)
 {
@@ -4431,6 +4467,8 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	dispc_runtime_put();
 
+	dispc_set_ops(&dispc_ops);
+
 	dss_debugfs_create_file("dispc", dispc_dump_regs);
 
 	return 0;
@@ -4443,6 +4481,8 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 static void dispc_unbind(struct device *dev, struct device *master,
 			       void *data)
 {
+	dispc_set_ops(NULL);
+
 	pm_runtime_disable(dev);
 
 	dispc_errata_i734_wa_fini();

commit c283400aa5898279dbae0fe00a2ce8e0f61eb22c
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 19:54:33 2015 +0200

    drm/omap: move dispc related dss-feat funcs to dispc
    
    omapdrm still uses a few non-dispc functions: dss_feat_get_num_mgrs(),
    dss_feat_get_num_ovls() and  dss_feat_get_supported_color_modes(). We
    want to provide omapdrm a single dispc_ops function pointer struct so
    that omapdrm will use either the current omapdss or the new omapdss6
    driver depending on the platform.
    
    Those three functions are really dispc functions, but are located in the
    dss_features.c for legacy reasons.
    
    This patch adds similar functionss to the dispc, and changes omapdrm to
    use those new functions. Underneath the functions still call the
    functions from dss_feature.c.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index d956e6266368..53d08dc4ef5a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1135,6 +1135,18 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane plane)
 	return unit * 8;
 }
 
+enum omap_color_mode dispc_ovl_get_color_modes(enum omap_plane plane)
+{
+	return dss_feat_get_supported_color_modes(plane);
+}
+EXPORT_SYMBOL(dispc_ovl_get_color_modes);
+
+int dispc_get_num_ovls(void)
+{
+	return dss_feat_get_num_ovls();
+}
+EXPORT_SYMBOL(dispc_get_num_ovls);
+
 static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT)
@@ -2967,6 +2979,12 @@ void dispc_pck_free_enable(bool enable)
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
 }
 
+int dispc_get_num_mgrs(void)
+{
+	return dss_feat_get_num_mgrs();
+}
+EXPORT_SYMBOL(dispc_get_num_mgrs);
+
 static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
 {
 	mgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);

commit 1b30ab0c40a99da347c1ab83c30b485e03fe9f64
Author: Jyri Sarha <jsarha@ti.com>
Date:   Wed Feb 8 16:08:06 2017 +0200

    drm/omapdrm: dispc: Refuse x-decimation above 4 for all but 8-bit formats
    
    Let's disable all scaling that requires horizontal decimation with
    higher factor than 4, until we have better estimates of what we can
    and can not do. However, NV12 color format appears to work Ok with
    all decimation factors.
    
    When decimating horizontally by more that 4 the dss is not able to
    fetch the data in burst mode. When this happens it is hard to tell if
    there enough bandwidth. Despite what theory says this appears to be
    true also for 16-bit color formats.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5554b72cf56a..d956e6266368 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2506,6 +2506,25 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 	}
 
+	if (*decim_x > 4 && color_mode != OMAP_DSS_COLOR_NV12) {
+		/*
+		 * Let's disable all scaling that requires horizontal
+		 * decimation with higher factor than 4, until we have
+		 * better estimates of what we can and can not
+		 * do. However, NV12 color format appears to work Ok
+		 * with all decimation factors.
+		 *
+		 * When decimating horizontally by more that 4 the dss
+		 * is not able to fetch the data in burst mode. When
+		 * this happens it is hard to tell if there enough
+		 * bandwidth. Despite what theory says this appears to
+		 * be true also for 16-bit color formats.
+		 */
+		DSSERR("Not enough bandwidth, too much downscaling (x-decimation factor %d > 4)", *decim_x);
+
+		return -EINVAL;
+	}
+
 	*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,
 				out_width, out_height, mem_to_mem);
 	return 0;

commit 03af8157aac6db1d0a84747dec64b9f5a241ed62
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Apr 18 03:09:48 2016 +0300

    drm: omapdrm: Check the CRTC software state at enable/disable time
    
    The omapdrm DSS manager enable/disable operations check the DSS manager
    state to avoid double enabling/disabling. Check the CRTC software state
    instead to decrease the dependency of the DRM layer to the DSS layer.
    The dispc_mgr_is_enabled() function then be turned into a static
    function, but needs to be moved up in its compilation unit to avoid a
    forward declaration.
    
    Add a WARN_ON to catch double enable or disable that should be prevented
    by the DRM core and would be a clear sign of a bug. The warning should
    eventually be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index c839f6456db2..5554b72cf56a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -620,6 +620,19 @@ u32 dispc_wb_get_framedone_irq(void)
 	return DISPC_IRQ_FRAMEDONEWB;
 }
 
+void dispc_mgr_enable(enum omap_channel channel, bool enable)
+{
+	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
+	/* flush posted write */
+	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+}
+EXPORT_SYMBOL(dispc_mgr_enable);
+
+static bool dispc_mgr_is_enabled(enum omap_channel channel)
+{
+	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+}
+
 bool dispc_mgr_go_busy(enum omap_channel channel)
 {
 	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
@@ -2901,20 +2914,6 @@ enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channe
 }
 EXPORT_SYMBOL(dispc_mgr_get_supported_outputs);
 
-void dispc_mgr_enable(enum omap_channel channel, bool enable)
-{
-	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
-	/* flush posted write */
-	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
-}
-EXPORT_SYMBOL(dispc_mgr_enable);
-
-bool dispc_mgr_is_enabled(enum omap_channel channel)
-{
-	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
-}
-EXPORT_SYMBOL(dispc_mgr_is_enabled);
-
 void dispc_wb_enable(bool enable)
 {
 	dispc_ovl_enable(OMAP_DSS_WB, enable);

commit da11bbbb10a964c293c2e2e702ea62ad6cba48b4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:04 2016 +0300

    drm/omap: Use consistent name for struct videomode
    
    Use 'vm' to refer to a struct videomode instead of 'p', 't', 'timings' or
    something else.
    
    The code will be easier to follow if we use consistent names.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index a5b7488a5cfb..c839f6456db2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -75,7 +75,7 @@ struct dispc_features {
 	unsigned long max_lcd_pclk;
 	unsigned long max_tv_pclk;
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
-		const struct videomode *mgr_timings,
+		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2179,7 +2179,7 @@ static void calc_tiler_rotation_offset(u16 screen_width, u16 width,
  * undocumented horizontal position and timing related limitations.
  */
 static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
-		const struct videomode *t, u16 pos_x,
+		const struct videomode *vm, u16 pos_x,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool five_taps)
 {
@@ -2189,15 +2189,15 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 	u64 val, blank;
 	int i;
 
-	nonactive = t->hactive + t->hfront_porch + t->hsync_len +
-		    t->hback_porch - out_width;
+	nonactive = vm->hactive + vm->hfront_porch + vm->hsync_len +
+		    vm->hback_porch - out_width;
 
 	i = 0;
 	if (out_height < height)
 		i++;
 	if (out_width < width)
 		i++;
-	blank = div_u64((u64)(t->hback_porch + t->hsync_len + t->hfront_porch) *
+	blank = div_u64((u64)(vm->hback_porch + vm->hsync_len + vm->hfront_porch) *
 			lclk, pclk);
 	DSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);
 	if (blank <= limits[i])
@@ -2233,7 +2233,7 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 }
 
 static unsigned long calc_core_clk_five_taps(unsigned long pclk,
-		const struct videomode *mgr_timings, u16 width,
+		const struct videomode *vm, u16 width,
 		u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode)
 {
@@ -2244,7 +2244,7 @@ static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		return (unsigned long) pclk;
 
 	if (height > out_height) {
-		unsigned int ppl = mgr_timings->hactive;
+		unsigned int ppl = vm->hactive;
 
 		tmp = (u64)pclk * height * out_width;
 		do_div(tmp, 2 * out_height * ppl);
@@ -2326,7 +2326,7 @@ static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
 }
 
 static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *mgr_timings,
+		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2372,7 +2372,7 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 }
 
 static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *mgr_timings,
+		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2394,7 +2394,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 				*five_taps = false;
 again:
 		if (*five_taps)
-			*core_clk = calc_core_clk_five_taps(pclk, mgr_timings,
+			*core_clk = calc_core_clk_five_taps(pclk, vm,
 						in_width, in_height, out_width,
 						out_height, color_mode);
 		else
@@ -2402,7 +2402,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 					in_height, out_width, out_height,
 					mem_to_mem);
 
-		error = check_horiz_timing_omap3(pclk, lclk, mgr_timings,
+		error = check_horiz_timing_omap3(pclk, lclk, vm,
 				pos_x, in_width, in_height, out_width,
 				out_height, *five_taps);
 		if (error && *five_taps) {
@@ -2437,7 +2437,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 		return -EINVAL;
 	}
 
-	if (check_horiz_timing_omap3(pclk, lclk, mgr_timings, pos_x, in_width,
+	if (check_horiz_timing_omap3(pclk, lclk, vm, pos_x, in_width,
 				in_height, out_width, out_height, *five_taps)) {
 			DSSERR("horizontal timing too tight\n");
 			return -EINVAL;
@@ -2457,7 +2457,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 }
 
 static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *mgr_timings,
+		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2503,7 +2503,7 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 
 static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		enum omap_overlay_caps caps,
-		const struct videomode *mgr_timings,
+		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, u16 pos_x,
@@ -2517,7 +2517,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	if (width == out_width && height == out_height)
 		return 0;
 
-	if (!mem_to_mem && (pclk == 0 || mgr_timings->pixelclock == 0)) {
+	if (!mem_to_mem && (pclk == 0 || vm->pixelclock == 0)) {
 		DSSERR("cannot calculate scaling settings: pclk is zero\n");
 		return -EINVAL;
 	}
@@ -2553,7 +2553,7 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	if (decim_y > *y_predecim || out_height > height * 8)
 		return -EINVAL;
 
-	ret = dispc.feat->calc_scaling(pclk, lclk, mgr_timings, width, height,
+	ret = dispc.feat->calc_scaling(pclk, lclk, vm, width, height,
 		out_width, out_height, color_mode, five_taps,
 		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
 		mem_to_mem);
@@ -2593,7 +2593,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
 		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
-		bool replication, const struct videomode *mgr_timings,
+		bool replication, const struct videomode *vm,
 		bool mem_to_mem)
 {
 	bool five_taps = true;
@@ -2607,7 +2607,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 	u16 in_height = height;
 	u16 in_width = width;
 	int x_predecim = 1, y_predecim = 1;
-	bool ilace = !!(mgr_timings->flags & DISPLAY_FLAGS_INTERLACED);
+	bool ilace = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);
 	unsigned long pclk = dispc_plane_pclk_rate(plane);
 	unsigned long lclk = dispc_plane_lclk_rate(plane);
 
@@ -2649,7 +2649,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 	if (!dss_feat_color_mode_supported(plane, color_mode))
 		return -EINVAL;
 
-	r = dispc_ovl_calc_scaling(pclk, lclk, caps, mgr_timings, in_width,
+	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
 			in_height, out_width, out_height, color_mode,
 			&five_taps, &x_predecim, &y_predecim, pos_x,
 			rotation_type, mem_to_mem);
@@ -2786,7 +2786,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 }
 
 int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
-		bool replication, const struct videomode *mgr_timings,
+		bool replication, const struct videomode *vm,
 		bool mem_to_mem)
 {
 	int r;
@@ -2805,14 +2805,14 @@ int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
 		oi->out_width, oi->out_height, oi->color_mode, oi->rotation,
 		oi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
-		oi->rotation_type, replication, mgr_timings, mem_to_mem);
+		oi->rotation_type, replication, vm, mem_to_mem);
 
 	return r;
 }
 EXPORT_SYMBOL(dispc_ovl_setup);
 
 int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
-		bool mem_to_mem, const struct videomode *mgr_timings)
+		bool mem_to_mem, const struct videomode *vm)
 {
 	int r;
 	u32 l;
@@ -2821,8 +2821,8 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	const u8 zorder = 0, global_alpha = 0;
 	const bool replication = false;
 	bool truncation;
-	int in_width = mgr_timings->hactive;
-	int in_height = mgr_timings->vactive;
+	int in_width = vm->hactive;
+	int in_height = vm->vactive;
 	enum omap_overlay_caps caps =
 		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
 
@@ -2835,7 +2835,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
 		wi->height, wi->color_mode, wi->rotation, wi->mirror, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
-		replication, mgr_timings, mem_to_mem);
+		replication, vm, mem_to_mem);
 
 	switch (wi->color_mode) {
 	case OMAP_DSS_COLOR_RGB16:
@@ -2869,9 +2869,8 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	} else {
 		int wbdelay;
 
-		wbdelay = min(mgr_timings->vfront_porch +
-			      mgr_timings->vsync_len + mgr_timings->vback_porch,
-			      (u32)255);
+		wbdelay = min(vm->vfront_porch +
+			      vm->vsync_len + vm->vback_porch, (u32)255);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
@@ -3118,24 +3117,23 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 		return pclk <= dispc.feat->max_tv_pclk;
 }
 
-bool dispc_mgr_timings_ok(enum omap_channel channel,
-		const struct videomode *timings)
+bool dispc_mgr_timings_ok(enum omap_channel channel, const struct videomode *vm)
 {
-	if (!_dispc_mgr_size_ok(timings->hactive, timings->vactive))
+	if (!_dispc_mgr_size_ok(vm->hactive, vm->vactive))
 		return false;
 
-	if (!_dispc_mgr_pclk_ok(channel, timings->pixelclock))
+	if (!_dispc_mgr_pclk_ok(channel, vm->pixelclock))
 		return false;
 
 	if (dss_mgr_is_lcd(channel)) {
 		/* TODO: OMAP4+ supports interlace for LCD outputs */
-		if (timings->flags & DISPLAY_FLAGS_INTERLACED)
+		if (vm->flags & DISPLAY_FLAGS_INTERLACED)
 			return false;
 
-		if (!_dispc_lcd_timings_ok(timings->hsync_len,
-				timings->hfront_porch, timings->hback_porch,
-				timings->vsync_len, timings->vfront_porch,
-				timings->vback_porch))
+		if (!_dispc_lcd_timings_ok(vm->hsync_len,
+				vm->hfront_porch, vm->hback_porch,
+				vm->vsync_len, vm->vfront_porch,
+				vm->vback_porch))
 			return false;
 	}
 
@@ -3143,37 +3141,37 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 }
 
 static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
-				       const struct videomode *ovt)
+				       const struct videomode *vm)
 {
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
 
-	timing_h = FLD_VAL(ovt->hsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(ovt->hfront_porch - 1, dispc.feat->fp_start, 8) |
-		   FLD_VAL(ovt->hback_porch - 1, dispc.feat->bp_start, 20);
-	timing_v = FLD_VAL(ovt->vsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(ovt->vfront_porch, dispc.feat->fp_start, 8) |
-		   FLD_VAL(ovt->vback_porch, dispc.feat->bp_start, 20);
+	timing_h = FLD_VAL(vm->hsync_len - 1, dispc.feat->sw_start, 0) |
+		   FLD_VAL(vm->hfront_porch - 1, dispc.feat->fp_start, 8) |
+		   FLD_VAL(vm->hback_porch - 1, dispc.feat->bp_start, 20);
+	timing_v = FLD_VAL(vm->vsync_len - 1, dispc.feat->sw_start, 0) |
+		   FLD_VAL(vm->vfront_porch, dispc.feat->fp_start, 8) |
+		   FLD_VAL(vm->vback_porch, dispc.feat->bp_start, 20);
 
 	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
 	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
 
-	if (ovt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
+	if (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)
 		vs = false;
 	else
 		vs = true;
 
-	if (ovt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
+	if (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)
 		hs = false;
 	else
 		hs = true;
 
-	if (ovt->flags & DISPLAY_FLAGS_DE_HIGH)
+	if (vm->flags & DISPLAY_FLAGS_DE_HIGH)
 		de = false;
 	else
 		de = true;
 
-	if (ovt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+	if (vm->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
 		ipc = false;
 	else
 		ipc = true;
@@ -3181,7 +3179,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	/* always use the 'rf' setting */
 	onoff = true;
 
-	if (ovt->flags & DISPLAY_FLAGS_SYNC_POSEDGE)
+	if (vm->flags & DISPLAY_FLAGS_SYNC_POSEDGE)
 		rf = true;
 	else
 		rf = false;
@@ -3221,11 +3219,11 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 
 /* change name to mode? */
 void dispc_mgr_set_timings(enum omap_channel channel,
-		const struct videomode *timings)
+			   const struct videomode *vm)
 {
 	unsigned xtot, ytot;
 	unsigned long ht, vt;
-	struct videomode t = *timings;
+	struct videomode t = *vm;
 
 	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
@@ -3240,10 +3238,10 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
 		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;
 
-		ht = timings->pixelclock / xtot;
-		vt = timings->pixelclock / xtot / ytot;
+		ht = vm->pixelclock / xtot;
+		vt = vm->pixelclock / xtot / ytot;
 
-		DSSDBG("pck %lu\n", timings->pixelclock);
+		DSSDBG("pck %lu\n", vm->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
 			t.hsync_len, t.hfront_porch, t.hback_porch,
 			t.vsync_len, t.vfront_porch, t.vback_porch);
@@ -4185,12 +4183,12 @@ EXPORT_SYMBOL(dispc_free_irq);
  */
 
 static const struct dispc_errata_i734_data {
-	struct videomode timings;
+	struct videomode vm;
 	struct omap_overlay_info ovli;
 	struct omap_overlay_manager_info mgri;
 	struct dss_lcd_mgr_config lcd_conf;
 } i734 = {
-	.timings = {
+	.vm = {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
@@ -4288,7 +4286,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Setup and enable GFX plane */
 	dispc_ovl_set_channel_out(OMAP_DSS_GFX, OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, false, &i734.timings, false);
+	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, false, &i734.vm, false);
 	dispc_ovl_enable(OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */
@@ -4296,7 +4294,7 @@ static void dispc_errata_i734_wa(void)
 	dispc_calc_clock_rates(dss_get_dispc_clk_rate(),
 			       &lcd_conf.clock_info);
 	dispc_mgr_set_lcd_config(OMAP_DSS_CHANNEL_LCD, &lcd_conf);
-	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.timings);
+	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.vm);
 
 	dispc_clear_irqstatus(framedone_irq);
 

commit 4520ff28aaa1e7f1b45f3abc0c45429ea9e93817
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:03 2016 +0300

    drm/omap: Replace struct omap_video_timings with videomode
    
    omap_video_timings can be replaced with the generic videomode in omapdrm
    and the omap_video_timings can be removed.
    
    This patch will replace the omap_video_timings with videomode.
    With the change we no longer need the functions to convert to/from
    videomode and drm_display_mode to omap_video_timings, these can be removed
    as well.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 63d3dc44913c..a5b7488a5cfb 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -75,7 +75,7 @@ struct dispc_features {
 	unsigned long max_lcd_pclk;
 	unsigned long max_tv_pclk;
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
-		const struct omap_video_timings *mgr_timings,
+		const struct videomode *mgr_timings,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2179,7 +2179,7 @@ static void calc_tiler_rotation_offset(u16 screen_width, u16 width,
  * undocumented horizontal position and timing related limitations.
  */
 static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
-		const struct omap_video_timings *t, u16 pos_x,
+		const struct videomode *t, u16 pos_x,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		bool five_taps)
 {
@@ -2233,7 +2233,7 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 }
 
 static unsigned long calc_core_clk_five_taps(unsigned long pclk,
-		const struct omap_video_timings *mgr_timings, u16 width,
+		const struct videomode *mgr_timings, u16 width,
 		u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode)
 {
@@ -2326,7 +2326,7 @@ static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
 }
 
 static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
-		const struct omap_video_timings *mgr_timings,
+		const struct videomode *mgr_timings,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2372,7 +2372,7 @@ static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 }
 
 static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
-		const struct omap_video_timings *mgr_timings,
+		const struct videomode *mgr_timings,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2457,7 +2457,7 @@ static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 }
 
 static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
-		const struct omap_video_timings *mgr_timings,
+		const struct videomode *mgr_timings,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
@@ -2503,7 +2503,7 @@ static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 
 static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 		enum omap_overlay_caps caps,
-		const struct omap_video_timings *mgr_timings,
+		const struct videomode *mgr_timings,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode, bool *five_taps,
 		int *x_predecim, int *y_predecim, u16 pos_x,
@@ -2593,7 +2593,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
 		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
-		bool replication, const struct omap_video_timings *mgr_timings,
+		bool replication, const struct videomode *mgr_timings,
 		bool mem_to_mem)
 {
 	bool five_taps = true;
@@ -2786,7 +2786,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 }
 
 int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
-		bool replication, const struct omap_video_timings *mgr_timings,
+		bool replication, const struct videomode *mgr_timings,
 		bool mem_to_mem)
 {
 	int r;
@@ -2812,7 +2812,7 @@ int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
 EXPORT_SYMBOL(dispc_ovl_setup);
 
 int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
-		bool mem_to_mem, const struct omap_video_timings *mgr_timings)
+		bool mem_to_mem, const struct videomode *mgr_timings)
 {
 	int r;
 	u32 l;
@@ -3119,7 +3119,7 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 }
 
 bool dispc_mgr_timings_ok(enum omap_channel channel,
-		const struct omap_video_timings *timings)
+		const struct videomode *timings)
 {
 	if (!_dispc_mgr_size_ok(timings->hactive, timings->vactive))
 		return false;
@@ -3143,7 +3143,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 }
 
 static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
-				       const struct omap_video_timings *ovt)
+				       const struct videomode *ovt)
 {
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
@@ -3221,11 +3221,11 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 
 /* change name to mode? */
 void dispc_mgr_set_timings(enum omap_channel channel,
-		const struct omap_video_timings *timings)
+		const struct videomode *timings)
 {
 	unsigned xtot, ytot;
 	unsigned long ht, vt;
-	struct omap_video_timings t = *timings;
+	struct videomode t = *timings;
 
 	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
@@ -4185,7 +4185,7 @@ EXPORT_SYMBOL(dispc_free_irq);
  */
 
 static const struct dispc_errata_i734_data {
-	struct omap_video_timings timings;
+	struct videomode timings;
 	struct omap_overlay_info ovli;
 	struct omap_overlay_manager_info mgri;
 	struct dss_lcd_mgr_config lcd_conf;

commit 7aa91e76aec9dda35ae643c572a8d1b1d596d27b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:02 2016 +0300

    drm/omap: Change the types of struct omap_video_timings members
    
    omap_video_timings struct have the same members as struct videomode, but
    their types are different. As first step change the types of the
    omap_video_timings struct members to match their counterpart in
    struct videomode to catch any type cast related issues.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 83b7a7a2a9e7..63d3dc44913c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2870,7 +2870,8 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		int wbdelay;
 
 		wbdelay = min(mgr_timings->vfront_porch +
-			      mgr_timings->vsync_len + mgr_timings->vback_porch, 255);
+			      mgr_timings->vsync_len + mgr_timings->vback_porch,
+			      (u32)255);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
@@ -3242,7 +3243,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
 
-		DSSDBG("pck %u\n", timings->pixelclock);
+		DSSDBG("pck %lu\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
 			t.hsync_len, t.hfront_porch, t.hback_porch,
 			t.vsync_len, t.vfront_porch, t.vback_porch);

commit d34afb73c3e8906e558c272229e78c8b265196ba
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:01 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for sync edge
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for sync edge.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 6b017e1f9245..83b7a7a2a9e7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3180,16 +3180,10 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	/* always use the 'rf' setting */
 	onoff = true;
 
-	switch (ovt->sync_pclk_edge) {
-	case OMAPDSS_DRIVE_SIG_FALLING_EDGE:
-		rf = false;
-		break;
-	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
+	if (ovt->flags & DISPLAY_FLAGS_SYNC_POSEDGE)
 		rf = true;
-		break;
-	default:
-		BUG();
-	}
+	else
+		rf = false;
 
 	l = FLD_VAL(onoff, 17, 17) |
 		FLD_VAL(rf, 16, 16) |
@@ -3257,7 +3251,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 			!!(t.flags & DISPLAY_FLAGS_HSYNC_HIGH),
 			!!(t.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE),
 			!!(t.flags & DISPLAY_FLAGS_DE_HIGH),
-			t.sync_pclk_edge);
+			!!(t.flags & DISPLAY_FLAGS_SYNC_POSEDGE));
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {
@@ -4200,10 +4194,10 @@ static const struct dispc_errata_i734_data {
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
-		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 
 		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |
-			 DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_PIXDATA_POSEDGE,
+			 DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_SYNC_POSEDGE |
+			 DISPLAY_FLAGS_PIXDATA_POSEDGE,
 	},
 	.ovli = {
 		.screen_width = 1,

commit f149e17a7bf904c55f69e2aef5a0fc5915e40e04
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:07:00 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for pixel data edge
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for pixel data edge.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index cedec84429f5..6b017e1f9245 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3172,16 +3172,10 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	else
 		de = true;
 
-	switch (ovt->data_pclk_edge) {
-	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
+	if (ovt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
 		ipc = false;
-		break;
-	case OMAPDSS_DRIVE_SIG_FALLING_EDGE:
+	else
 		ipc = true;
-		break;
-	default:
-		BUG();
-	}
 
 	/* always use the 'rf' setting */
 	onoff = true;
@@ -3261,7 +3255,8 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			!!(t.flags & DISPLAY_FLAGS_VSYNC_HIGH),
 			!!(t.flags & DISPLAY_FLAGS_HSYNC_HIGH),
-			t.data_pclk_edge, !!(t.flags & DISPLAY_FLAGS_DE_HIGH),
+			!!(t.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE),
+			!!(t.flags & DISPLAY_FLAGS_DE_HIGH),
 			t.sync_pclk_edge);
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
@@ -4205,11 +4200,10 @@ static const struct dispc_errata_i734_data {
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
-		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 
 		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |
-			 DISPLAY_FLAGS_DE_HIGH,
+			 DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_PIXDATA_POSEDGE,
 	},
 	.ovli = {
 		.screen_width = 1,

commit 531efb380c6d11025e1afe8ef7300c26f0f1b226
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:59 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for double_pixel mode
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for double_pixel mode.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 5f88b7848415..cedec84429f5 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3270,8 +3270,9 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 			t.vactive /= 2;
 
 		if (dispc.feat->supports_double_pixel)
-			REG_FLD_MOD(DISPC_CONTROL, t.double_pixel ? 1 : 0,
-				19, 17);
+			REG_FLD_MOD(DISPC_CONTROL,
+				    !!(t.flags & DISPLAY_FLAGS_DOUBLECLK),
+				    19, 17);
 	}
 
 	dispc_mgr_set_size(channel, t.hactive, t.vactive);
@@ -4206,7 +4207,6 @@ static const struct dispc_errata_i734_data {
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
 		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
-		.double_pixel = false,
 
 		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |
 			 DISPLAY_FLAGS_DE_HIGH,

commit 3fa3ab4a881b9c464cb3168b476825ae5a02bfa6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:58 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for DE level
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for DE level.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 6acdd2194122..5f88b7848415 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3167,16 +3167,10 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	else
 		hs = true;
 
-	switch (ovt->de_level) {
-	case OMAPDSS_SIG_ACTIVE_LOW:
-		de = true;
-		break;
-	case OMAPDSS_SIG_ACTIVE_HIGH:
+	if (ovt->flags & DISPLAY_FLAGS_DE_HIGH)
 		de = false;
-		break;
-	default:
-		BUG();
-	}
+	else
+		de = true;
 
 	switch (ovt->data_pclk_edge) {
 	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
@@ -3267,7 +3261,8 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			!!(t.flags & DISPLAY_FLAGS_VSYNC_HIGH),
 			!!(t.flags & DISPLAY_FLAGS_HSYNC_HIGH),
-			t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
+			t.data_pclk_edge, !!(t.flags & DISPLAY_FLAGS_DE_HIGH),
+			t.sync_pclk_edge);
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {
@@ -4210,11 +4205,11 @@ static const struct dispc_errata_i734_data {
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
 		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
-		.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.double_pixel = false,
 
-		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
+		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |
+			 DISPLAY_FLAGS_DE_HIGH,
 	},
 	.ovli = {
 		.screen_width = 1,

commit 6b44cd2748d6efa09a83fe97a2d35fb90f80e489
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:57 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for h/vsync level
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information use display_flags for h/vsync level.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 6a0c13d97cc1..6acdd2194122 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3157,27 +3157,15 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
 	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
 	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
 
-	switch (ovt->vsync_level) {
-	case OMAPDSS_SIG_ACTIVE_LOW:
-		vs = true;
-		break;
-	case OMAPDSS_SIG_ACTIVE_HIGH:
+	if (ovt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
 		vs = false;
-		break;
-	default:
-		BUG();
-	}
+	else
+		vs = true;
 
-	switch (ovt->hsync_level) {
-	case OMAPDSS_SIG_ACTIVE_LOW:
-		hs = true;
-		break;
-	case OMAPDSS_SIG_ACTIVE_HIGH:
+	if (ovt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
 		hs = false;
-		break;
-	default:
-		BUG();
-	}
+	else
+		hs = true;
 
 	switch (ovt->de_level) {
 	case OMAPDSS_SIG_ACTIVE_LOW:
@@ -3277,8 +3265,9 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 			t.hsync_len, t.hfront_porch, t.hback_porch,
 			t.vsync_len, t.vfront_porch, t.vback_porch);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
-			t.vsync_level, t.hsync_level, t.data_pclk_edge,
-			t.de_level, t.sync_pclk_edge);
+			!!(t.flags & DISPLAY_FLAGS_VSYNC_HIGH),
+			!!(t.flags & DISPLAY_FLAGS_HSYNC_HIGH),
+			t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {
@@ -4220,12 +4209,12 @@ static const struct dispc_errata_i734_data {
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
-		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
-		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.double_pixel = false,
+
+		.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
 	},
 	.ovli = {
 		.screen_width = 1,

commit 3b592939b7c02db19a50545834d2eeaa7eff6df6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:56 2016 +0300

    drm/omap: dispc: Simplify _dispc_mgr_set_lcd_timings() parameters
    
    Instead of passing the omap_video_timings structure's members individually,
    use the pointer to the struct.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f11bfe5378d1..6a0c13d97cc1 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3141,29 +3141,23 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 	return true;
 }
 
-static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
-		int hfp, int hbp, int vsw, int vfp, int vbp,
-		enum omap_dss_signal_level vsync_level,
-		enum omap_dss_signal_level hsync_level,
-		enum omap_dss_signal_edge data_pclk_edge,
-		enum omap_dss_signal_level de_level,
-		enum omap_dss_signal_edge sync_pclk_edge)
-
+static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
+				       const struct omap_video_timings *ovt)
 {
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
 
-	timing_h = FLD_VAL(hsync_len-1, dispc.feat->sw_start, 0) |
-			FLD_VAL(hfp-1, dispc.feat->fp_start, 8) |
-			FLD_VAL(hbp-1, dispc.feat->bp_start, 20);
-	timing_v = FLD_VAL(vsw-1, dispc.feat->sw_start, 0) |
-			FLD_VAL(vfp, dispc.feat->fp_start, 8) |
-			FLD_VAL(vbp, dispc.feat->bp_start, 20);
+	timing_h = FLD_VAL(ovt->hsync_len - 1, dispc.feat->sw_start, 0) |
+		   FLD_VAL(ovt->hfront_porch - 1, dispc.feat->fp_start, 8) |
+		   FLD_VAL(ovt->hback_porch - 1, dispc.feat->bp_start, 20);
+	timing_v = FLD_VAL(ovt->vsync_len - 1, dispc.feat->sw_start, 0) |
+		   FLD_VAL(ovt->vfront_porch, dispc.feat->fp_start, 8) |
+		   FLD_VAL(ovt->vback_porch, dispc.feat->bp_start, 20);
 
 	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
 	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
 
-	switch (vsync_level) {
+	switch (ovt->vsync_level) {
 	case OMAPDSS_SIG_ACTIVE_LOW:
 		vs = true;
 		break;
@@ -3174,7 +3168,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
 		BUG();
 	}
 
-	switch (hsync_level) {
+	switch (ovt->hsync_level) {
 	case OMAPDSS_SIG_ACTIVE_LOW:
 		hs = true;
 		break;
@@ -3185,7 +3179,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
 		BUG();
 	}
 
-	switch (de_level) {
+	switch (ovt->de_level) {
 	case OMAPDSS_SIG_ACTIVE_LOW:
 		de = true;
 		break;
@@ -3196,7 +3190,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
 		BUG();
 	}
 
-	switch (data_pclk_edge) {
+	switch (ovt->data_pclk_edge) {
 	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
 		ipc = false;
 		break;
@@ -3210,7 +3204,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
 	/* always use the 'rf' setting */
 	onoff = true;
 
-	switch (sync_pclk_edge) {
+	switch (ovt->sync_pclk_edge) {
 	case OMAPDSS_DRIVE_SIG_FALLING_EDGE:
 		rf = false;
 		break;
@@ -3270,11 +3264,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel,
-				t.hsync_len, t.hfront_porch, t.hback_porch,
-				t.vsync_len, t.vfront_porch, t.vback_porch,
-				t.vsync_level, t.hsync_level, t.data_pclk_edge,
-				t.de_level, t.sync_pclk_edge);
+		_dispc_mgr_set_lcd_timings(channel, &t);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
 		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;

commit 530582998acef0a6f9aafed7c82a2bb11b4405f6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:55 2016 +0300

    drm/omap: omap_display_timings: Use display_flags for interlace mode
    
    Remove the interlace member and add display_flags to omap_video_timings to
    configure the interlace mode.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index d46a0a2c6b7b..f11bfe5378d1 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2607,7 +2607,7 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 	u16 in_height = height;
 	u16 in_width = width;
 	int x_predecim = 1, y_predecim = 1;
-	bool ilace = mgr_timings->interlace;
+	bool ilace = !!(mgr_timings->flags & DISPLAY_FLAGS_INTERLACED);
 	unsigned long pclk = dispc_plane_pclk_rate(plane);
 	unsigned long lclk = dispc_plane_lclk_rate(plane);
 
@@ -3128,7 +3128,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 
 	if (dss_mgr_is_lcd(channel)) {
 		/* TODO: OMAP4+ supports interlace for LCD outputs */
-		if (timings->interlace)
+		if (timings->flags & DISPLAY_FLAGS_INTERLACED)
 			return false;
 
 		if (!_dispc_lcd_timings_ok(timings->hsync_len,
@@ -3292,7 +3292,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {
-		if (t.interlace)
+		if (t.flags & DISPLAY_FLAGS_INTERLACED)
 			t.vactive /= 2;
 
 		if (dispc.feat->supports_double_pixel)
@@ -4232,7 +4232,6 @@ static const struct dispc_errata_i734_data {
 		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
-		.interlace = false,
 		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
 		.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
 		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,

commit 458540c606757a4b52476f8e4d937a36ed94c577
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:53 2016 +0300

    drm/omap: omap_display_timings: rename vbp to vback_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vbp member to vback_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index c732d6c70c66..d46a0a2c6b7b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2870,7 +2870,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 		int wbdelay;
 
 		wbdelay = min(mgr_timings->vfront_porch +
-			      mgr_timings->vsync_len + mgr_timings->vbp, 255);
+			      mgr_timings->vsync_len + mgr_timings->vback_porch, 255);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
@@ -3134,7 +3134,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 		if (!_dispc_lcd_timings_ok(timings->hsync_len,
 				timings->hfront_porch, timings->hback_porch,
 				timings->vsync_len, timings->vfront_porch,
-				timings->vbp))
+				timings->vback_porch))
 			return false;
 	}
 
@@ -3270,13 +3270,14 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfront_porch,
-				t.hback_porch, t.vsync_len, t.vfront_porch, t.vbp,
+		_dispc_mgr_set_lcd_timings(channel,
+				t.hsync_len, t.hfront_porch, t.hback_porch,
+				t.vsync_len, t.vfront_porch, t.vback_porch,
 				t.vsync_level, t.hsync_level, t.data_pclk_edge,
 				t.de_level, t.sync_pclk_edge);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
-		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vbp;
+		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;
 
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
@@ -3284,7 +3285,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("pck %u\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
 			t.hsync_len, t.hfront_porch, t.hback_porch,
-			t.vsync_len, t.vfront_porch, t.vbp);
+			t.vsync_len, t.vfront_porch, t.vback_porch);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4228,7 +4229,7 @@ static const struct dispc_errata_i734_data {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
-		.vsync_len = 1, .vfront_porch = 1, .vbp = 1,
+		.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.interlace = false,

commit 0996c68e1bf7364ca7f02ac06048c12abb56c37a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:52 2016 +0300

    drm/omap: omap_display_timings: rename vfp to vfront_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vfp member to vfront_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index ddb9d9d28157..c732d6c70c66 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2869,8 +2869,8 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	} else {
 		int wbdelay;
 
-		wbdelay = min(mgr_timings->vfp + mgr_timings->vsync_len +
-			mgr_timings->vbp, 255);
+		wbdelay = min(mgr_timings->vfront_porch +
+			      mgr_timings->vsync_len + mgr_timings->vbp, 255);
 
 		/* WBDELAYCOUNT */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
@@ -3133,7 +3133,8 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 
 		if (!_dispc_lcd_timings_ok(timings->hsync_len,
 				timings->hfront_porch, timings->hback_porch,
-				timings->vsync_len, timings->vfp, timings->vbp))
+				timings->vsync_len, timings->vfront_porch,
+				timings->vbp))
 			return false;
 	}
 
@@ -3270,12 +3271,12 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 	if (dss_mgr_is_lcd(channel)) {
 		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfront_porch,
-				t.hback_porch, t.vsync_len, t.vfp, t.vbp,
+				t.hback_porch, t.vsync_len, t.vfront_porch, t.vbp,
 				t.vsync_level, t.hsync_level, t.data_pclk_edge,
 				t.de_level, t.sync_pclk_edge);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
-		ytot = t.vactive + t.vfp + t.vsync_len + t.vbp;
+		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vbp;
 
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
@@ -3283,7 +3284,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("pck %u\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
 			t.hsync_len, t.hfront_porch, t.hback_porch,
-			t.vsync_len, t.vfp, t.vbp);
+			t.vsync_len, t.vfront_porch, t.vbp);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4227,7 +4228,7 @@ static const struct dispc_errata_i734_data {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
-		.vsync_len = 1, .vfp = 1, .vbp = 1,
+		.vsync_len = 1, .vfront_porch = 1, .vbp = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.interlace = false,

commit d5bcf0aa3f6fb396fc8099a4e5960f9274b0dae9
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:51 2016 +0300

    drm/omap: omap_display_timings: rename vsw to vsync_len
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the vsw member to vsync_len.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 0d115aa6c86e..ddb9d9d28157 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2869,7 +2869,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	} else {
 		int wbdelay;
 
-		wbdelay = min(mgr_timings->vfp + mgr_timings->vsw +
+		wbdelay = min(mgr_timings->vfp + mgr_timings->vsync_len +
 			mgr_timings->vbp, 255);
 
 		/* WBDELAYCOUNT */
@@ -3133,7 +3133,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 
 		if (!_dispc_lcd_timings_ok(timings->hsync_len,
 				timings->hfront_porch, timings->hback_porch,
-				timings->vsw, timings->vfp, timings->vbp))
+				timings->vsync_len, timings->vfp, timings->vbp))
 			return false;
 	}
 
@@ -3270,12 +3270,12 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 	if (dss_mgr_is_lcd(channel)) {
 		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfront_porch,
-				t.hback_porch, t.vsw, t.vfp, t.vbp,
+				t.hback_porch, t.vsync_len, t.vfp, t.vbp,
 				t.vsync_level, t.hsync_level, t.data_pclk_edge,
 				t.de_level, t.sync_pclk_edge);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
-		ytot = t.vactive + t.vfp + t.vsw + t.vbp;
+		ytot = t.vactive + t.vfp + t.vsync_len + t.vbp;
 
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
@@ -3283,7 +3283,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("pck %u\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
 			t.hsync_len, t.hfront_porch, t.hback_porch,
-			t.vsw, t.vfp, t.vbp);
+			t.vsync_len, t.vfp, t.vbp);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4227,7 +4227,7 @@ static const struct dispc_errata_i734_data {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
 		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
-		.vsw = 1, .vfp = 1, .vbp = 1,
+		.vsync_len = 1, .vfp = 1, .vbp = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.interlace = false,

commit a85f4a80784b34362568a0ff1f34aaa3357462a0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:50 2016 +0300

    drm/omap: omap_display_timings: rename hbp to hback_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hbp member to hback_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 3f5c57fbfa94..0d115aa6c86e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2190,14 +2190,14 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 	int i;
 
 	nonactive = t->hactive + t->hfront_porch + t->hsync_len +
-		    t->hbp - out_width;
+		    t->hback_porch - out_width;
 
 	i = 0;
 	if (out_height < height)
 		i++;
 	if (out_width < width)
 		i++;
-	blank = div_u64((u64)(t->hbp + t->hsync_len + t->hfront_porch) *
+	blank = div_u64((u64)(t->hback_porch + t->hsync_len + t->hfront_porch) *
 			lclk, pclk);
 	DSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);
 	if (blank <= limits[i])
@@ -3132,7 +3132,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 			return false;
 
 		if (!_dispc_lcd_timings_ok(timings->hsync_len,
-				timings->hfront_porch, timings->hbp,
+				timings->hfront_porch, timings->hback_porch,
 				timings->vsw, timings->vfp, timings->vbp))
 			return false;
 	}
@@ -3270,11 +3270,11 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 	if (dss_mgr_is_lcd(channel)) {
 		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfront_porch,
-				t.hbp, t.vsw, t.vfp, t.vbp, t.vsync_level,
-				t.hsync_level, t.data_pclk_edge, t.de_level,
-				t.sync_pclk_edge);
+				t.hback_porch, t.vsw, t.vfp, t.vbp,
+				t.vsync_level, t.hsync_level, t.data_pclk_edge,
+				t.de_level, t.sync_pclk_edge);
 
-		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hbp;
+		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
 		ytot = t.vactive + t.vfp + t.vsw + t.vbp;
 
 		ht = timings->pixelclock / xtot;
@@ -3282,7 +3282,8 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 		DSSDBG("pck %u\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
-			t.hsync_len, t.hfront_porch, t.hbp, t.vsw, t.vfp, t.vbp);
+			t.hsync_len, t.hfront_porch, t.hback_porch,
+			t.vsw, t.vfp, t.vbp);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4225,7 +4226,7 @@ static const struct dispc_errata_i734_data {
 	.timings = {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
-		.hsync_len = 8, .hfront_porch = 4, .hbp = 4,
+		.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,
 		.vsw = 1, .vfp = 1, .vbp = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,

commit 0a30e150f053e609f7820d81efebde28802035f3
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:49 2016 +0300

    drm/omap: omap_display_timings: rename hfp to hfront_porch
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hfp member to hfront_porch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 8f97a11a2e97..3f5c57fbfa94 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2189,14 +2189,16 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 	u64 val, blank;
 	int i;
 
-	nonactive = t->hactive + t->hfp + t->hsync_len + t->hbp - out_width;
+	nonactive = t->hactive + t->hfront_porch + t->hsync_len +
+		    t->hbp - out_width;
 
 	i = 0;
 	if (out_height < height)
 		i++;
 	if (out_width < width)
 		i++;
-	blank = div_u64((u64)(t->hbp + t->hsync_len + t->hfp) * lclk, pclk);
+	blank = div_u64((u64)(t->hbp + t->hsync_len + t->hfront_porch) *
+			lclk, pclk);
 	DSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);
 	if (blank <= limits[i])
 		return -EINVAL;
@@ -3129,9 +3131,9 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 		if (timings->interlace)
 			return false;
 
-		if (!_dispc_lcd_timings_ok(timings->hsync_len, timings->hfp,
-				timings->hbp, timings->vsw, timings->vfp,
-				timings->vbp))
+		if (!_dispc_lcd_timings_ok(timings->hsync_len,
+				timings->hfront_porch, timings->hbp,
+				timings->vsw, timings->vfp, timings->vbp))
 			return false;
 	}
 
@@ -3267,12 +3269,12 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfp, t.hbp,
-				t.vsw, t.vfp, t.vbp, t.vsync_level,
+		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfront_porch,
+				t.hbp, t.vsw, t.vfp, t.vbp, t.vsync_level,
 				t.hsync_level, t.data_pclk_edge, t.de_level,
 				t.sync_pclk_edge);
 
-		xtot = t.hactive + t.hfp + t.hsync_len + t.hbp;
+		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hbp;
 		ytot = t.vactive + t.vfp + t.vsw + t.vbp;
 
 		ht = timings->pixelclock / xtot;
@@ -3280,7 +3282,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 
 		DSSDBG("pck %u\n", timings->pixelclock);
 		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
-			t.hsync_len, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);
+			t.hsync_len, t.hfront_porch, t.hbp, t.vsw, t.vfp, t.vbp);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4223,7 +4225,7 @@ static const struct dispc_errata_i734_data {
 	.timings = {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
-		.hsync_len = 8, .hfp = 4, .hbp = 4,
+		.hsync_len = 8, .hfront_porch = 4, .hbp = 4,
 		.vsw = 1, .vfp = 1, .vbp = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,

commit 4dc2250d7d9e816b986d656cde90f55c096012ed
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:48 2016 +0300

    drm/omap: omap_display_timings: rename hsw to hsync_len
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the hsw member to hsync_len.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 3d208ce67794..8f97a11a2e97 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2189,14 +2189,14 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 	u64 val, blank;
 	int i;
 
-	nonactive = t->hactive + t->hfp + t->hsw + t->hbp - out_width;
+	nonactive = t->hactive + t->hfp + t->hsync_len + t->hbp - out_width;
 
 	i = 0;
 	if (out_height < height)
 		i++;
 	if (out_width < width)
 		i++;
-	blank = div_u64((u64)(t->hbp + t->hsw + t->hfp) * lclk, pclk);
+	blank = div_u64((u64)(t->hbp + t->hsync_len + t->hfp) * lclk, pclk);
 	DSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);
 	if (blank <= limits[i])
 		return -EINVAL;
@@ -3093,10 +3093,10 @@ static bool _dispc_mgr_size_ok(u16 width, u16 height)
 		height <= dispc.feat->mgr_height_max;
 }
 
-static bool _dispc_lcd_timings_ok(int hsw, int hfp, int hbp,
+static bool _dispc_lcd_timings_ok(int hsync_len, int hfp, int hbp,
 		int vsw, int vfp, int vbp)
 {
-	if (hsw < 1 || hsw > dispc.feat->sw_max ||
+	if (hsync_len < 1 || hsync_len > dispc.feat->sw_max ||
 			hfp < 1 || hfp > dispc.feat->hp_max ||
 			hbp < 1 || hbp > dispc.feat->hp_max ||
 			vsw < 1 || vsw > dispc.feat->sw_max ||
@@ -3129,7 +3129,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 		if (timings->interlace)
 			return false;
 
-		if (!_dispc_lcd_timings_ok(timings->hsw, timings->hfp,
+		if (!_dispc_lcd_timings_ok(timings->hsync_len, timings->hfp,
 				timings->hbp, timings->vsw, timings->vfp,
 				timings->vbp))
 			return false;
@@ -3138,7 +3138,7 @@ bool dispc_mgr_timings_ok(enum omap_channel channel,
 	return true;
 }
 
-static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsw,
+static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsync_len,
 		int hfp, int hbp, int vsw, int vfp, int vbp,
 		enum omap_dss_signal_level vsync_level,
 		enum omap_dss_signal_level hsync_level,
@@ -3150,7 +3150,7 @@ static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsw,
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
 
-	timing_h = FLD_VAL(hsw-1, dispc.feat->sw_start, 0) |
+	timing_h = FLD_VAL(hsync_len-1, dispc.feat->sw_start, 0) |
 			FLD_VAL(hfp-1, dispc.feat->fp_start, 8) |
 			FLD_VAL(hbp-1, dispc.feat->bp_start, 20);
 	timing_v = FLD_VAL(vsw-1, dispc.feat->sw_start, 0) |
@@ -3267,19 +3267,20 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel, t.hsw, t.hfp, t.hbp, t.vsw,
-				t.vfp, t.vbp, t.vsync_level, t.hsync_level,
-				t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
+		_dispc_mgr_set_lcd_timings(channel, t.hsync_len, t.hfp, t.hbp,
+				t.vsw, t.vfp, t.vbp, t.vsync_level,
+				t.hsync_level, t.data_pclk_edge, t.de_level,
+				t.sync_pclk_edge);
 
-		xtot = t.hactive + t.hfp + t.hsw + t.hbp;
+		xtot = t.hactive + t.hfp + t.hsync_len + t.hbp;
 		ytot = t.vactive + t.vfp + t.vsw + t.vbp;
 
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
 
 		DSSDBG("pck %u\n", timings->pixelclock);
-		DSSDBG("hsw %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
-			t.hsw, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);
+		DSSDBG("hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
+			t.hsync_len, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);
 		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
 			t.vsync_level, t.hsync_level, t.data_pclk_edge,
 			t.de_level, t.sync_pclk_edge);
@@ -4222,7 +4223,7 @@ static const struct dispc_errata_i734_data {
 	.timings = {
 		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
-		.hsw = 8, .hfp = 4, .hbp = 4,
+		.hsync_len = 8, .hfp = 4, .hbp = 4,
 		.vsw = 1, .vfp = 1, .vbp = 1,
 		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
 		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,

commit fb7f3c4399ffa75bc31aaaaeab45238ea60c3d1a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:47 2016 +0300

    drm/omap: omap_display_timings: rename y_res to vactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the y_res member to vactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index b34ac915a761..3d208ce67794 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2820,7 +2820,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	const bool replication = false;
 	bool truncation;
 	int in_width = mgr_timings->hactive;
-	int in_height = mgr_timings->y_res;
+	int in_height = mgr_timings->vactive;
 	enum omap_overlay_caps caps =
 		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
 
@@ -3118,7 +3118,7 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 bool dispc_mgr_timings_ok(enum omap_channel channel,
 		const struct omap_video_timings *timings)
 {
-	if (!_dispc_mgr_size_ok(timings->hactive, timings->y_res))
+	if (!_dispc_mgr_size_ok(timings->hactive, timings->vactive))
 		return false;
 
 	if (!_dispc_mgr_pclk_ok(channel, timings->pixelclock))
@@ -3259,7 +3259,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	unsigned long ht, vt;
 	struct omap_video_timings t = *timings;
 
-	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.y_res);
+	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
 	if (!dispc_mgr_timings_ok(channel, &t)) {
 		BUG();
@@ -3272,7 +3272,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 				t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
 
 		xtot = t.hactive + t.hfp + t.hsw + t.hbp;
-		ytot = t.y_res + t.vfp + t.vsw + t.vbp;
+		ytot = t.vactive + t.vfp + t.vsw + t.vbp;
 
 		ht = timings->pixelclock / xtot;
 		vt = timings->pixelclock / xtot / ytot;
@@ -3287,14 +3287,14 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
 	} else {
 		if (t.interlace)
-			t.y_res /= 2;
+			t.vactive /= 2;
 
 		if (dispc.feat->supports_double_pixel)
 			REG_FLD_MOD(DISPC_CONTROL, t.double_pixel ? 1 : 0,
 				19, 17);
 	}
 
-	dispc_mgr_set_size(channel, t.hactive, t.y_res);
+	dispc_mgr_set_size(channel, t.hactive, t.vactive);
 }
 EXPORT_SYMBOL(dispc_mgr_set_timings);
 
@@ -4220,7 +4220,7 @@ static const struct dispc_errata_i734_data {
 	struct dss_lcd_mgr_config lcd_conf;
 } i734 = {
 	.timings = {
-		.hactive = 8, .y_res = 1,
+		.hactive = 8, .vactive = 1,
 		.pixelclock = 16000000,
 		.hsw = 8, .hfp = 4, .hbp = 4,
 		.vsw = 1, .vfp = 1, .vbp = 1,

commit 81899060de35d80f17020d322e77311f1b255885
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 14:06:46 2016 +0300

    drm/omap: omap_display_timings: rename x_res to hactive
    
    In preparation to move the stack to use the generic videmode struct for
    display timing information rename the x_res member to hactive.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 818df6be97fa..b34ac915a761 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2189,7 +2189,7 @@ static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
 	u64 val, blank;
 	int i;
 
-	nonactive = t->x_res + t->hfp + t->hsw + t->hbp - out_width;
+	nonactive = t->hactive + t->hfp + t->hsw + t->hbp - out_width;
 
 	i = 0;
 	if (out_height < height)
@@ -2242,7 +2242,7 @@ static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		return (unsigned long) pclk;
 
 	if (height > out_height) {
-		unsigned int ppl = mgr_timings->x_res;
+		unsigned int ppl = mgr_timings->hactive;
 
 		tmp = (u64)pclk * height * out_width;
 		do_div(tmp, 2 * out_height * ppl);
@@ -2819,7 +2819,7 @@ int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
 	const u8 zorder = 0, global_alpha = 0;
 	const bool replication = false;
 	bool truncation;
-	int in_width = mgr_timings->x_res;
+	int in_width = mgr_timings->hactive;
 	int in_height = mgr_timings->y_res;
 	enum omap_overlay_caps caps =
 		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
@@ -3118,7 +3118,7 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 bool dispc_mgr_timings_ok(enum omap_channel channel,
 		const struct omap_video_timings *timings)
 {
-	if (!_dispc_mgr_size_ok(timings->x_res, timings->y_res))
+	if (!_dispc_mgr_size_ok(timings->hactive, timings->y_res))
 		return false;
 
 	if (!_dispc_mgr_pclk_ok(channel, timings->pixelclock))
@@ -3259,7 +3259,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	unsigned long ht, vt;
 	struct omap_video_timings t = *timings;
 
-	DSSDBG("channel %d xres %u yres %u\n", channel, t.x_res, t.y_res);
+	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.y_res);
 
 	if (!dispc_mgr_timings_ok(channel, &t)) {
 		BUG();
@@ -3271,7 +3271,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 				t.vfp, t.vbp, t.vsync_level, t.hsync_level,
 				t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
 
-		xtot = t.x_res + t.hfp + t.hsw + t.hbp;
+		xtot = t.hactive + t.hfp + t.hsw + t.hbp;
 		ytot = t.y_res + t.vfp + t.vsw + t.vbp;
 
 		ht = timings->pixelclock / xtot;
@@ -3294,7 +3294,7 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 				19, 17);
 	}
 
-	dispc_mgr_set_size(channel, t.x_res, t.y_res);
+	dispc_mgr_set_size(channel, t.hactive, t.y_res);
 }
 EXPORT_SYMBOL(dispc_mgr_set_timings);
 
@@ -4220,7 +4220,7 @@ static const struct dispc_errata_i734_data {
 	struct dss_lcd_mgr_config lcd_conf;
 } i734 = {
 	.timings = {
-		.x_res = 8, .y_res = 1,
+		.hactive = 8, .y_res = 1,
 		.pixelclock = 16000000,
 		.hsw = 8, .hfp = 4, .hbp = 4,
 		.vsw = 1, .vfp = 1, .vbp = 1,

commit 0cac5b61ff3c145dcba7f39880f8ca94e848162b
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Jul 1 09:27:21 2016 -0500

    drm/omap: remove unneeded conversions to bool
    
    Found with scripts/coccinelle/misc/boolconv.cocci.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 535240fba671..818df6be97fa 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -1679,7 +1679,7 @@ static void dispc_ovl_set_scaling_uv(enum omap_plane plane,
 {
 	int scale_x = out_width != orig_width;
 	int scale_y = out_height != orig_height;
-	bool chroma_upscale = plane != OMAP_DSS_WB ? true : false;
+	bool chroma_upscale = plane != OMAP_DSS_WB;
 
 	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
@@ -3110,9 +3110,9 @@ static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
 		unsigned long pclk)
 {
 	if (dss_mgr_is_lcd(channel))
-		return pclk <= dispc.feat->max_lcd_pclk ? true : false;
+		return pclk <= dispc.feat->max_lcd_pclk;
 	else
-		return pclk <= dispc.feat->max_tv_pclk ? true : false;
+		return pclk <= dispc.feat->max_tv_pclk;
 }
 
 bool dispc_mgr_timings_ok(enum omap_channel channel,

commit fbff010bd0b4492af4ba85093602d8bd91752453
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 7 15:09:16 2016 +0300

    drm/omapdrm: Workaround for errata i734 (LCD1 Gamma) in DSS dispc
    
    Workaround for errata i734 in DSS dispc
     - LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
    
    For gamma tables to work on LCD1 the GFX plane has to be used at least
    once after DSS HW has come out of reset. The workaround sets up a
    minimal LCD setup with GFX plane and waits for one vertical sync irq
    before disabling the setup and continuing with the context
    restore. The physical outputs are gated during the operation.
    
    For details see:
    OMAP543x Multimedia Device Silicon Revision 2.0 Silicon Errata
    Literature Number: SWPZ037E
    Or some other relevant errata document for the DSS IP version.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index cdd227c8bed3..535240fba671 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -114,6 +114,8 @@ struct dispc_features {
 	bool reverse_ilace_field_order:1;
 
 	bool has_gamma_table:1;
+
+	bool has_gamma_i734_bug:1;
 };
 
 #define DISPC_MAX_NR_FIFOS 5
@@ -4074,6 +4076,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.supports_double_pixel	=	true,
 	.reverse_ilace_field_order =	true,
 	.has_gamma_table	=	true,
+	.has_gamma_i734_bug	=	true,
 };
 
 static const struct dispc_features omap54xx_dispc_feats = {
@@ -4100,6 +4103,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.supports_double_pixel	=	true,
 	.reverse_ilace_field_order =	true,
 	.has_gamma_table	=	true,
+	.has_gamma_i734_bug	=	true,
 };
 
 static int dispc_init_features(struct platform_device *pdev)
@@ -4191,6 +4195,168 @@ void dispc_free_irq(void *dev_id)
 }
 EXPORT_SYMBOL(dispc_free_irq);
 
+/*
+ * Workaround for errata i734 in DSS dispc
+ *  - LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
+ *
+ * For gamma tables to work on LCD1 the GFX plane has to be used at
+ * least once after DSS HW has come out of reset. The workaround
+ * sets up a minimal LCD setup with GFX plane and waits for one
+ * vertical sync irq before disabling the setup and continuing with
+ * the context restore. The physical outputs are gated during the
+ * operation. This workaround requires that gamma table's LOADMODE
+ * is set to 0x2 in DISPC_CONTROL1 register.
+ *
+ * For details see:
+ * OMAP543x Multimedia Device Silicon Revision 2.0 Silicon Errata
+ * Literature Number: SWPZ037E
+ * Or some other relevant errata document for the DSS IP version.
+ */
+
+static const struct dispc_errata_i734_data {
+	struct omap_video_timings timings;
+	struct omap_overlay_info ovli;
+	struct omap_overlay_manager_info mgri;
+	struct dss_lcd_mgr_config lcd_conf;
+} i734 = {
+	.timings = {
+		.x_res = 8, .y_res = 1,
+		.pixelclock = 16000000,
+		.hsw = 8, .hfp = 4, .hbp = 4,
+		.vsw = 1, .vfp = 1, .vbp = 1,
+		.vsync_level = OMAPDSS_SIG_ACTIVE_LOW,
+		.hsync_level = OMAPDSS_SIG_ACTIVE_LOW,
+		.interlace = false,
+		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
+		.de_level = OMAPDSS_SIG_ACTIVE_HIGH,
+		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
+		.double_pixel = false,
+	},
+	.ovli = {
+		.screen_width = 1,
+		.width = 1, .height = 1,
+		.color_mode = OMAP_DSS_COLOR_RGB24U,
+		.rotation = OMAP_DSS_ROT_0,
+		.rotation_type = OMAP_DSS_ROT_DMA,
+		.mirror = 0,
+		.pos_x = 0, .pos_y = 0,
+		.out_width = 0, .out_height = 0,
+		.global_alpha = 0xff,
+		.pre_mult_alpha = 0,
+		.zorder = 0,
+	},
+	.mgri = {
+		.default_color = 0,
+		.trans_enabled = false,
+		.partial_alpha_enabled = false,
+		.cpr_enable = false,
+	},
+	.lcd_conf = {
+		.io_pad_mode = DSS_IO_PAD_MODE_BYPASS,
+		.stallmode = false,
+		.fifohandcheck = false,
+		.clock_info = {
+			.lck_div = 1,
+			.pck_div = 2,
+		},
+		.video_port_width = 24,
+		.lcden_sig_polarity = 0,
+	},
+};
+
+static struct i734_buf {
+	size_t size;
+	dma_addr_t paddr;
+	void *vaddr;
+} i734_buf;
+
+static int dispc_errata_i734_wa_init(void)
+{
+	if (!dispc.feat->has_gamma_i734_bug)
+		return 0;
+
+	i734_buf.size = i734.ovli.width * i734.ovli.height *
+		color_mode_to_bpp(i734.ovli.color_mode) / 8;
+
+	i734_buf.vaddr = dma_alloc_writecombine(&dispc.pdev->dev, i734_buf.size,
+						&i734_buf.paddr, GFP_KERNEL);
+	if (!i734_buf.vaddr) {
+		dev_err(&dispc.pdev->dev, "%s: dma_alloc_writecombine failed",
+			__func__);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void dispc_errata_i734_wa_fini(void)
+{
+	if (!dispc.feat->has_gamma_i734_bug)
+		return;
+
+	dma_free_writecombine(&dispc.pdev->dev, i734_buf.size, i734_buf.vaddr,
+			      i734_buf.paddr);
+}
+
+static void dispc_errata_i734_wa(void)
+{
+	u32 framedone_irq = dispc_mgr_get_framedone_irq(OMAP_DSS_CHANNEL_LCD);
+	struct omap_overlay_info ovli;
+	struct dss_lcd_mgr_config lcd_conf;
+	u32 gatestate;
+	unsigned int count;
+
+	if (!dispc.feat->has_gamma_i734_bug)
+		return;
+
+	gatestate = REG_GET(DISPC_CONFIG, 8, 4);
+
+	ovli = i734.ovli;
+	ovli.paddr = i734_buf.paddr;
+	lcd_conf = i734.lcd_conf;
+
+	/* Gate all LCD1 outputs */
+	REG_FLD_MOD(DISPC_CONFIG, 0x1f, 8, 4);
+
+	/* Setup and enable GFX plane */
+	dispc_ovl_set_channel_out(OMAP_DSS_GFX, OMAP_DSS_CHANNEL_LCD);
+	dispc_ovl_setup(OMAP_DSS_GFX, &ovli, false, &i734.timings, false);
+	dispc_ovl_enable(OMAP_DSS_GFX, true);
+
+	/* Set up and enable display manager for LCD1 */
+	dispc_mgr_setup(OMAP_DSS_CHANNEL_LCD, &i734.mgri);
+	dispc_calc_clock_rates(dss_get_dispc_clk_rate(),
+			       &lcd_conf.clock_info);
+	dispc_mgr_set_lcd_config(OMAP_DSS_CHANNEL_LCD, &lcd_conf);
+	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.timings);
+
+	dispc_clear_irqstatus(framedone_irq);
+
+	/* Enable and shut the channel to produce just one frame */
+	dispc_mgr_enable(OMAP_DSS_CHANNEL_LCD, true);
+	dispc_mgr_enable(OMAP_DSS_CHANNEL_LCD, false);
+
+	/* Busy wait for framedone. We can't fiddle with irq handlers
+	 * in PM resume. Typically the loop runs less than 5 times and
+	 * waits less than a micro second.
+	 */
+	count = 0;
+	while (!(dispc_read_irqstatus() & framedone_irq)) {
+		if (count++ > 10000) {
+			dev_err(&dispc.pdev->dev, "%s: framedone timeout\n",
+				__func__);
+			break;
+		}
+	}
+	dispc_ovl_enable(OMAP_DSS_GFX, false);
+
+	/* Clear all irq bits before continuing */
+	dispc_clear_irqstatus(0xffffffff);
+
+	/* Restore the original state to LCD1 output gates */
+	REG_FLD_MOD(DISPC_CONFIG, gatestate, 8, 4);
+}
+
 /* DISPC HW IP initialisation */
 static int dispc_bind(struct device *dev, struct device *master, void *data)
 {
@@ -4208,6 +4374,10 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 	if (r)
 		return r;
 
+	r = dispc_errata_i734_wa_init();
+	if (r)
+		return r;
+
 	dispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);
 	if (!dispc_mem) {
 		DSSERR("can't get IORESOURCE_MEM DISPC\n");
@@ -4272,6 +4442,8 @@ static void dispc_unbind(struct device *dev, struct device *master,
 			       void *data)
 {
 	pm_runtime_disable(dev);
+
+	dispc_errata_i734_wa_fini();
 }
 
 static const struct component_ops dispc_component_ops = {
@@ -4314,6 +4486,8 @@ static int dispc_runtime_resume(struct device *dev)
 	if (REG_GET(DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
 		_omap_dispc_initial_config();
 
+		dispc_errata_i734_wa();
+
 		dispc_restore_context();
 
 		dispc_restore_gamma_tables();

commit acc3a231d3d145b23d1f975b9be89b7cfb09885b
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 7 15:09:15 2016 +0300

    drm/omapdrm: Add gamma table support to DSS dispc
    
    Add gamma table support to DSS dispc.
    
    DSS driver initializes the default gamma table at component bind time
    and holds a copy of all gamma tables in its internal data structure.
    
    Each call to dispc_mgr_set_gamma() updates the internal table and
    triggers write to the HW, if it is enabled. The tables are restored to
    HW in PM resume callback. The drivers internal data structure match
    the HW tables in size and in number of significant bits per color
    component. The dispc_mgr_set_gamma() converts the size of any given
    table for the internal data structure using linear interpolation.
    Default gamma table is restored if NULL is given in place of gamma
    lut.
    
    dispc_mgr_gamma_size() gives HW gamma table size for the channel and
    returns 0 if gamma table is not supported by the HW or the DSS driver.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 0aecce2c6ba0..cdd227c8bed3 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -112,9 +112,12 @@ struct dispc_features {
 	 * never both, we can just use this flag for now.
 	 */
 	bool reverse_ilace_field_order:1;
+
+	bool has_gamma_table:1;
 };
 
 #define DISPC_MAX_NR_FIFOS 5
+#define DISPC_MAX_CHANNEL_GAMMA 4
 
 static struct {
 	struct platform_device *pdev;
@@ -134,6 +137,8 @@ static struct {
 	bool		ctx_valid;
 	u32		ctx[DISPC_SZ_REGS / sizeof(u32)];
 
+	u32 *gamma_table[DISPC_MAX_CHANNEL_GAMMA];
+
 	const struct dispc_features *feat;
 
 	bool is_enabled;
@@ -177,11 +182,19 @@ struct dispc_reg_field {
 	u8 low;
 };
 
+struct dispc_gamma_desc {
+	u32 len;
+	u32 bits;
+	u16 reg;
+	bool has_index;
+};
+
 static const struct {
 	const char *name;
 	u32 vsync_irq;
 	u32 framedone_irq;
 	u32 sync_lost_irq;
+	struct dispc_gamma_desc gamma;
 	struct dispc_reg_field reg_desc[DISPC_MGR_FLD_NUM];
 } mgr_desc[] = {
 	[OMAP_DSS_CHANNEL_LCD] = {
@@ -189,6 +202,12 @@ static const struct {
 		.vsync_irq	= DISPC_IRQ_VSYNC,
 		.framedone_irq	= DISPC_IRQ_FRAMEDONE,
 		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST,
+		.gamma		= {
+			.len	= 256,
+			.bits	= 8,
+			.reg	= DISPC_GAMMA_TABLE0,
+			.has_index = true,
+		},
 		.reg_desc	= {
 			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL,  0,  0 },
 			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL,  3,  3 },
@@ -206,6 +225,12 @@ static const struct {
 		.vsync_irq	= DISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_EVSYNC_EVEN,
 		.framedone_irq	= DISPC_IRQ_FRAMEDONETV,
 		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST_DIGIT,
+		.gamma		= {
+			.len	= 1024,
+			.bits	= 10,
+			.reg	= DISPC_GAMMA_TABLE2,
+			.has_index = false,
+		},
 		.reg_desc	= {
 			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL,  1,  1 },
 			[DISPC_MGR_FLD_STNTFT]		= { },
@@ -223,6 +248,12 @@ static const struct {
 		.vsync_irq	= DISPC_IRQ_VSYNC2,
 		.framedone_irq	= DISPC_IRQ_FRAMEDONE2,
 		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST2,
+		.gamma		= {
+			.len	= 256,
+			.bits	= 8,
+			.reg	= DISPC_GAMMA_TABLE1,
+			.has_index = true,
+		},
 		.reg_desc	= {
 			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL2,  0,  0 },
 			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL2,  3,  3 },
@@ -240,6 +271,12 @@ static const struct {
 		.vsync_irq	= DISPC_IRQ_VSYNC3,
 		.framedone_irq	= DISPC_IRQ_FRAMEDONE3,
 		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST3,
+		.gamma		= {
+			.len	= 256,
+			.bits	= 8,
+			.reg	= DISPC_GAMMA_TABLE3,
+			.has_index = true,
+		},
 		.reg_desc	= {
 			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL3,  0,  0 },
 			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL3,  3,  3 },
@@ -1083,20 +1120,6 @@ static u32 dispc_ovl_get_burst_size(enum omap_plane plane)
 	return unit * 8;
 }
 
-void dispc_enable_gamma_table(bool enable)
-{
-	/*
-	 * This is partially implemented to support only disabling of
-	 * the gamma table.
-	 */
-	if (enable) {
-		DSSWARN("Gamma table enabling for TV not yet supported");
-		return;
-	}
-
-	REG_FLD_MOD(DISPC_CONFIG, enable, 9, 9);
-}
-
 static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT)
@@ -3790,6 +3813,139 @@ void dispc_disable_sidle(void)
 	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
+u32 dispc_mgr_gamma_size(enum omap_channel channel)
+{
+	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
+
+	if (!dispc.feat->has_gamma_table)
+		return 0;
+
+	return gdesc->len;
+}
+EXPORT_SYMBOL(dispc_mgr_gamma_size);
+
+static void dispc_mgr_write_gamma_table(enum omap_channel channel)
+{
+	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
+	u32 *table = dispc.gamma_table[channel];
+	unsigned int i;
+
+	DSSDBG("%s: channel %d\n", __func__, channel);
+
+	for (i = 0; i < gdesc->len; ++i) {
+		u32 v = table[i];
+
+		if (gdesc->has_index)
+			v |= i << 24;
+		else if (i == 0)
+			v |= 1 << 31;
+
+		dispc_write_reg(gdesc->reg, v);
+	}
+}
+
+static void dispc_restore_gamma_tables(void)
+{
+	DSSDBG("%s()\n", __func__);
+
+	if (!dispc.feat->has_gamma_table)
+		return;
+
+	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD);
+
+	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_DIGIT);
+
+	if (dss_has_feature(FEAT_MGR_LCD2))
+		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD2);
+
+	if (dss_has_feature(FEAT_MGR_LCD3))
+		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD3);
+}
+
+static const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {
+	{ .red = 0, .green = 0, .blue = 0, },
+	{ .red = U16_MAX, .green = U16_MAX, .blue = U16_MAX, },
+};
+
+void dispc_mgr_set_gamma(enum omap_channel channel,
+			 const struct drm_color_lut *lut,
+			 unsigned int length)
+{
+	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
+	u32 *table = dispc.gamma_table[channel];
+	uint i;
+
+	DSSDBG("%s: channel %d, lut len %u, hw len %u\n", __func__,
+	       channel, length, gdesc->len);
+
+	if (!dispc.feat->has_gamma_table)
+		return;
+
+	if (lut == NULL || length < 2) {
+		lut = dispc_mgr_gamma_default_lut;
+		length = ARRAY_SIZE(dispc_mgr_gamma_default_lut);
+	}
+
+	for (i = 0; i < length - 1; ++i) {
+		uint first = i * (gdesc->len - 1) / (length - 1);
+		uint last = (i + 1) * (gdesc->len - 1) / (length - 1);
+		uint w = last - first;
+		u16 r, g, b;
+		uint j;
+
+		if (w == 0)
+			continue;
+
+		for (j = 0; j <= w; j++) {
+			r = (lut[i].red * (w - j) + lut[i+1].red * j) / w;
+			g = (lut[i].green * (w - j) + lut[i+1].green * j) / w;
+			b = (lut[i].blue * (w - j) + lut[i+1].blue * j) / w;
+
+			r >>= 16 - gdesc->bits;
+			g >>= 16 - gdesc->bits;
+			b >>= 16 - gdesc->bits;
+
+			table[first + j] = (r << (gdesc->bits * 2)) |
+				(g << gdesc->bits) | b;
+		}
+	}
+
+	if (dispc.is_enabled)
+		dispc_mgr_write_gamma_table(channel);
+}
+EXPORT_SYMBOL(dispc_mgr_set_gamma);
+
+static int dispc_init_gamma_tables(void)
+{
+	int channel;
+
+	if (!dispc.feat->has_gamma_table)
+		return 0;
+
+	for (channel = 0; channel < ARRAY_SIZE(dispc.gamma_table); channel++) {
+		const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
+		u32 *gt;
+
+		if (channel == OMAP_DSS_CHANNEL_LCD2 &&
+		    !dss_has_feature(FEAT_MGR_LCD2))
+			continue;
+
+		if (channel == OMAP_DSS_CHANNEL_LCD3 &&
+		    !dss_has_feature(FEAT_MGR_LCD3))
+			continue;
+
+		gt = devm_kmalloc_array(&dispc.pdev->dev, gdesc->len,
+					   sizeof(u32), GFP_KERNEL);
+		if (!gt)
+			return -ENOMEM;
+
+		dispc.gamma_table[channel] = gt;
+
+		dispc_mgr_set_gamma(channel, NULL, 0);
+	}
+	return 0;
+}
+
 static void _omap_dispc_initial_config(void)
 {
 	u32 l;
@@ -3805,8 +3961,15 @@ static void _omap_dispc_initial_config(void)
 		dispc.core_clk_rate = dispc_fclk_rate();
 	}
 
-	/* FUNCGATED */
-	if (dss_has_feature(FEAT_FUNCGATED))
+	/* Use gamma table mode, instead of palette mode */
+	if (dispc.feat->has_gamma_table)
+		REG_FLD_MOD(DISPC_CONFIG, 1, 3, 3);
+
+	/* For older DSS versions (FEAT_FUNCGATED) this enables
+	 * func-clock auto-gating. For newer versions
+	 * (dispc.feat->has_gamma_table) this enables tv-out gamma tables.
+	 */
+	if (dss_has_feature(FEAT_FUNCGATED) || dispc.feat->has_gamma_table)
 		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
 
 	dispc_setup_color_conv_coef();
@@ -3910,6 +4073,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.has_writeback		=	true,
 	.supports_double_pixel	=	true,
 	.reverse_ilace_field_order =	true,
+	.has_gamma_table	=	true,
 };
 
 static const struct dispc_features omap54xx_dispc_feats = {
@@ -3935,6 +4099,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.has_writeback		=	true,
 	.supports_double_pixel	=	true,
 	.reverse_ilace_field_order =	true,
+	.has_gamma_table	=	true,
 };
 
 static int dispc_init_features(struct platform_device *pdev)
@@ -4076,6 +4241,10 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 		}
 	}
 
+	r = dispc_init_gamma_tables();
+	if (r)
+		return r;
+
 	pm_runtime_enable(&pdev->dev);
 
 	r = dispc_runtime_get();
@@ -4146,6 +4315,8 @@ static int dispc_runtime_resume(struct device *dev)
 		_omap_dispc_initial_config();
 
 		dispc_restore_context();
+
+		dispc_restore_gamma_tables();
 	}
 
 	dispc.is_enabled = true;

commit a1dec226a686077a9822013e601327b189f419df
Merge: ecf140dfc3fe 26038aad2511
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jun 7 09:00:25 2016 +0300

    Merge omapdss header refactoring
    
    Merge omapdss public header refactoring, which separates the public
    header into omapdrm and omapfb parts.

commit 32043da7dcf2af3510d0410b0cacfbcde95e5d26
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 27 14:40:49 2016 +0300

    drm/omap: Do not include video/omapdss.h directly in drivers
    
    All drivers to include the omapdrm/dss/omapdss.h header file. This header
    includes the <video/omapdss.h>
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f83608b69e68..1fc15b8c769c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -41,8 +41,7 @@
 #include <linux/of.h>
 #include <linux/component.h>
 
-#include <video/omapdss.h>
-
+#include "omapdss.h"
 #include "dss.h"
 #include "dss_features.h"
 #include "dispc.h"

commit ef03b401266b687dab522dcf9a4e411074262898
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 18 13:52:14 2016 +0300

    drm/omap: cleanup dispc_fclk_rate()
    
    With the new PLL helpers, we can clean up the dispc_fclk_rate(). This
    will also make dispc_fclk_rate() support clock sources it didn't support
    earlier.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 01994d012ce4..7b78da6d51cf 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3299,30 +3299,21 @@ static void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,
 
 static unsigned long dispc_fclk_rate(void)
 {
-	struct dss_pll *pll;
-	unsigned long r = 0;
+	unsigned long r;
+	enum dss_clk_source src;
 
-	switch (dss_get_dispc_clk_source()) {
-	case DSS_CLK_SRC_FCK:
+	src = dss_get_dispc_clk_source();
+
+	if (src == DSS_CLK_SRC_FCK) {
 		r = dss_get_dispc_clk_rate();
-		break;
-	case DSS_CLK_SRC_PLL1_1:
-		pll = dss_pll_find("dsi0");
-		if (!pll)
-			pll = dss_pll_find("video0");
+	} else {
+		struct dss_pll *pll;
+		unsigned clkout_idx;
 
-		r = pll->cinfo.clkout[0];
-		break;
-	case DSS_CLK_SRC_PLL2_1:
-		pll = dss_pll_find("dsi1");
-		if (!pll)
-			pll = dss_pll_find("video1");
+		pll = dss_pll_find_by_src(src);
+		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
-		r = pll->cinfo.clkout[0];
-		break;
-	default:
-		BUG();
-		return 0;
+		r = pll->cinfo.clkout[clkout_idx];
 	}
 
 	return r;

commit 01575776e54734eecab390df5aa1e047896ddacb
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 16:08:34 2016 +0300

    drm/omap: cleanup dispc_mgr_lclk_rate()
    
    With the new PLL helpers, we can clean up the dispc_mgr_lclk_rate().
    This will also make dispc_mgr_lclk_rate() support clock sources it
    didn't support earlier.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 333a347f877b..01994d012ce4 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3330,43 +3330,31 @@ static unsigned long dispc_fclk_rate(void)
 
 static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 {
-	struct dss_pll *pll;
 	int lcd;
 	unsigned long r;
-	u32 l;
-
-	if (dss_mgr_is_lcd(channel)) {
-		l = dispc_read_reg(DISPC_DIVISORo(channel));
+	enum dss_clk_source src;
 
-		lcd = FLD_GET(l, 23, 16);
+	/* for TV, LCLK rate is the FCLK rate */
+	if (!dss_mgr_is_lcd(channel))
+		return dispc_fclk_rate();
 
-		switch (dss_get_lcd_clk_source(channel)) {
-		case DSS_CLK_SRC_FCK:
-			r = dss_get_dispc_clk_rate();
-			break;
-		case DSS_CLK_SRC_PLL1_1:
-			pll = dss_pll_find("dsi0");
-			if (!pll)
-				pll = dss_pll_find("video0");
+	src = dss_get_lcd_clk_source(channel);
 
-			r = pll->cinfo.clkout[0];
-			break;
-		case DSS_CLK_SRC_PLL2_1:
-			pll = dss_pll_find("dsi1");
-			if (!pll)
-				pll = dss_pll_find("video1");
+	if (src == DSS_CLK_SRC_FCK) {
+		r = dss_get_dispc_clk_rate();
+	} else {
+		struct dss_pll *pll;
+		unsigned clkout_idx;
 
-			r = pll->cinfo.clkout[0];
-			break;
-		default:
-			BUG();
-			return 0;
-		}
+		pll = dss_pll_find_by_src(src);
+		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
-		return r / lcd;
-	} else {
-		return dispc_fclk_rate();
+		r = pll->cinfo.clkout[clkout_idx];
 	}
+
+	lcd = REG_GET(DISPC_DIVISORo(channel), 23, 16);
+
+	return r / lcd;
 }
 
 static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)

commit 3b63ca75661decc7db44b492cafbbe60adaf3731
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 14:01:10 2016 +0300

    drm/omap: rename dss_clk_source enums
    
    The names of the enum dss_clk_source's values are legacy names, only
    correct for OMAP3 DSS. Rename the names to more generic ones.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index e3eaae945946..333a347f877b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3303,17 +3303,17 @@ static unsigned long dispc_fclk_rate(void)
 	unsigned long r = 0;
 
 	switch (dss_get_dispc_clk_source()) {
-	case OMAP_DSS_CLK_SRC_FCK:
+	case DSS_CLK_SRC_FCK:
 		r = dss_get_dispc_clk_rate();
 		break;
-	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL1_1:
 		pll = dss_pll_find("dsi0");
 		if (!pll)
 			pll = dss_pll_find("video0");
 
 		r = pll->cinfo.clkout[0];
 		break;
-	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL2_1:
 		pll = dss_pll_find("dsi1");
 		if (!pll)
 			pll = dss_pll_find("video1");
@@ -3341,17 +3341,17 @@ static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
 		lcd = FLD_GET(l, 23, 16);
 
 		switch (dss_get_lcd_clk_source(channel)) {
-		case OMAP_DSS_CLK_SRC_FCK:
+		case DSS_CLK_SRC_FCK:
 			r = dss_get_dispc_clk_rate();
 			break;
-		case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+		case DSS_CLK_SRC_PLL1_1:
 			pll = dss_pll_find("dsi0");
 			if (!pll)
 				pll = dss_pll_find("video0");
 
 			r = pll->cinfo.clkout[0];
 			break;
-		case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+		case DSS_CLK_SRC_PLL2_1:
 			pll = dss_pll_find("dsi1");
 			if (!pll)
 				pll = dss_pll_find("video1");

commit 407bd564ed3beec31d82fe10f7c3defcf4f071d8
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:50:55 2016 +0300

    drm/omap: rename dss_get_generic_clk_source_name()
    
    Now that there is no "non-generic" version of the function to get the
    clock source name, lets rename dss_get_generic_clk_source_name() to
    dss_get_clk_source_name().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 398cba588e8e..e3eaae945946 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3433,7 +3433,7 @@ static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel chan
 	lcd_clk_src = dss_get_lcd_clk_source(channel);
 
 	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
-		dss_get_generic_clk_source_name(lcd_clk_src));
+		dss_get_clk_source_name(lcd_clk_src));
 
 	dispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);
 
@@ -3455,7 +3455,7 @@ void dispc_dump_clocks(struct seq_file *s)
 	seq_printf(s, "- DISPC -\n");
 
 	seq_printf(s, "dispc fclk source = %s\n",
-			dss_get_generic_clk_source_name(dispc_clk_src));
+			dss_get_clk_source_name(dispc_clk_src));
 
 	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
 

commit 557a15443d4792195cf299f69f64042a27bba044
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:49:18 2016 +0300

    drm/omap: remove dss_feat_get_clk_source_name()
    
    We have two functions to return a name for clock sources for debugging
    purposes: dss_feat_get_clk_source_name() and
    dss_get_generic_clk_source_name().
    
    The former is supposed to return a DSS IP version specific name for the
    clock source, and the latter is supposed to return a more generic name.
    
    All this seems a bit pointless, so let's remove the former one.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 64c97af03eb4..398cba588e8e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3432,9 +3432,8 @@ static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel chan
 
 	lcd_clk_src = dss_get_lcd_clk_source(channel);
 
-	seq_printf(s, "%s clk source = %s (%s)\n", mgr_desc[channel].name,
-		dss_get_generic_clk_source_name(lcd_clk_src),
-		dss_feat_get_clk_source_name(lcd_clk_src));
+	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
+		dss_get_generic_clk_source_name(lcd_clk_src));
 
 	dispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);
 
@@ -3455,9 +3454,8 @@ void dispc_dump_clocks(struct seq_file *s)
 
 	seq_printf(s, "- DISPC -\n");
 
-	seq_printf(s, "dispc fclk source = %s (%s)\n",
-			dss_get_generic_clk_source_name(dispc_clk_src),
-			dss_feat_get_clk_source_name(dispc_clk_src));
+	seq_printf(s, "dispc fclk source = %s\n",
+			dss_get_generic_clk_source_name(dispc_clk_src));
 
 	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
 

commit dc0352d1bd618f1e452ec3378aacb24a2d2f3669
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:45:09 2016 +0300

    drm/omap: rename omap_dss_clk_source
    
    'enum omap_dss_clk_source' is internal to dss. Let's rename it to
    'dss_clk_source' match our naming convention.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index f83608b69e68..64c97af03eb4 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3426,7 +3426,7 @@ static unsigned long dispc_plane_lclk_rate(enum omap_plane plane)
 static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)
 {
 	int lcd, pcd;
-	enum omap_dss_clk_source lcd_clk_src;
+	enum dss_clk_source lcd_clk_src;
 
 	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
 
@@ -3448,7 +3448,7 @@ void dispc_dump_clocks(struct seq_file *s)
 {
 	int lcd;
 	u32 l;
-	enum omap_dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
+	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
 
 	if (dispc_runtime_get())
 		return;

commit 3bce5f4310dcec379e0b33cd1404456fda6f548e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Feb 22 18:22:30 2016 +0200

    drm/omap: remove dispc_ovl_check()
    
    dispc_ovl_check() is not used anywhere, so it can be removed.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 031451b09922..f83608b69e68 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2561,47 +2561,6 @@ static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
 	return 0;
 }
 
-int dispc_ovl_check(enum omap_plane plane, enum omap_channel channel,
-		const struct omap_overlay_info *oi,
-		const struct omap_video_timings *timings,
-		int *x_predecim, int *y_predecim)
-{
-	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
-	bool five_taps = true;
-	bool fieldmode = false;
-	u16 in_height = oi->height;
-	u16 in_width = oi->width;
-	bool ilace = timings->interlace;
-	u16 out_width, out_height;
-	int pos_x = oi->pos_x;
-	unsigned long pclk = dispc_mgr_pclk_rate(channel);
-	unsigned long lclk = dispc_mgr_lclk_rate(channel);
-
-	out_width = oi->out_width == 0 ? oi->width : oi->out_width;
-	out_height = oi->out_height == 0 ? oi->height : oi->out_height;
-
-	if (ilace && oi->height == out_height)
-		fieldmode = true;
-
-	if (ilace) {
-		if (fieldmode)
-			in_height /= 2;
-		out_height /= 2;
-
-		DSSDBG("adjusting for ilace: height %d, out_height %d\n",
-				in_height, out_height);
-	}
-
-	if (!dss_feat_color_mode_supported(plane, oi->color_mode))
-		return -EINVAL;
-
-	return dispc_ovl_calc_scaling(pclk, lclk, caps, timings, in_width,
-			in_height, out_width, out_height, oi->color_mode,
-			&five_taps, x_predecim, y_predecim, pos_x,
-			oi->rotation_type, false);
-}
-EXPORT_SYMBOL(dispc_ovl_check);
-
 static int dispc_ovl_setup_common(enum omap_plane plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,

commit 9198891b4e1d336a77137a9327de05acc10896e2
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Feb 22 16:11:45 2016 +0200

    drm/omap: remove dss compat code
    
    We have removed all the uses of compat code from omapdrm and the
    non-compat parts of omapdss, so now we can remove all the compat code
    itself.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index a5940892a788..031451b09922 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -4155,8 +4155,6 @@ static int dispc_bind(struct device *dev, struct device *master, void *data)
 
 	dispc_runtime_put();
 
-	dss_init_overlay_managers();
-
 	dss_debugfs_create_file("dispc", dispc_dump_regs);
 
 	return 0;
@@ -4170,8 +4168,6 @@ static void dispc_unbind(struct device *dev, struct device *master,
 			       void *data)
 {
 	pm_runtime_disable(dev);
-
-	dss_uninit_overlay_managers();
 }
 
 static const struct component_ops dispc_component_ops = {

commit 7b9cb5eeb4d0b1db63e198dfd02aadddaf245de4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 4 15:11:25 2015 +0200

    drm/omap: Add dispc_mgr_get_supported_outputs()
    
    We are removing the use of the 'struct omap_overlay_manager' from
    omapdrm, and one part of that is removing the use of
    mgr->supported_outputs field.
    
    This patch adds dispc_mgr_get_supported_outputs() function which can be
    used instead of mgr->supported_outputs. omap_crtc.c is changed to use
    the new function.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index a4274dca384a..a5940892a788 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -2910,6 +2910,12 @@ bool dispc_ovl_enabled(enum omap_plane plane)
 }
 EXPORT_SYMBOL(dispc_ovl_enabled);
 
+enum omap_dss_output_id dispc_mgr_get_supported_outputs(enum omap_channel channel)
+{
+	return dss_feat_get_supported_outputs(channel);
+}
+EXPORT_SYMBOL(dispc_mgr_get_supported_outputs);
+
 void dispc_mgr_enable(enum omap_channel channel, bool enable)
 {
 	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);

commit b7536d674575248fb8a7b09992496cf7110a875b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jan 13 18:41:36 2016 +0200

    drm/omap: DISPC: Fix field order for HDMI
    
    Interlace field order is different between VENC and HDMI. The driver
    currently sets the field order for VENC.
    
    This patch adds the code to set the field order for HDMI.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 1e7f26985bda..a4274dca384a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -106,6 +106,13 @@ struct dispc_features {
 	bool has_writeback:1;
 
 	bool supports_double_pixel:1;
+
+	/*
+	 * Field order for VENC is different than HDMI. We should handle this in
+	 * some intelligent manner, but as the SoCs have either HDMI or VENC,
+	 * never both, we can just use this flag for now.
+	 */
+	bool reverse_ilace_field_order:1;
 };
 
 #define DISPC_MAX_NR_FIFOS 5
@@ -2749,6 +2756,9 @@ static int dispc_ovl_setup_common(enum omap_plane plane,
 
 	dispc_ovl_configure_burst_type(plane, rotation_type);
 
+	if (dispc.feat->reverse_ilace_field_order)
+		swap(offset0, offset1);
+
 	dispc_ovl_set_ba0(plane, paddr + offset0);
 	dispc_ovl_set_ba1(plane, paddr + offset1);
 
@@ -3958,6 +3968,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.supports_sync_align	=	true,
 	.has_writeback		=	true,
 	.supports_double_pixel	=	true,
+	.reverse_ilace_field_order =	true,
 };
 
 static const struct dispc_features omap54xx_dispc_feats = {
@@ -3982,6 +3993,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.supports_sync_align	=	true,
 	.has_writeback		=	true,
 	.supports_double_pixel	=	true,
+	.reverse_ilace_field_order =	true,
 };
 
 static int dispc_init_features(struct platform_device *pdev)

commit 3a38ed53bebd1c14925a711123c911e07dd11adf
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Jan 13 18:41:31 2016 +0200

    drm/omap: DISPC: support double-pixel mode
    
    We need double-pixel mode (pixel repetition) for interlace modes. This
    patch adds the necessary support to DISPC to output double-pixel mode.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
index 6b50476ec669..1e7f26985bda 100644
--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -104,6 +104,8 @@ struct dispc_features {
 	bool supports_sync_align:1;
 
 	bool has_writeback:1;
+
+	bool supports_double_pixel:1;
 };
 
 #define DISPC_MAX_NR_FIFOS 5
@@ -3287,6 +3289,10 @@ void dispc_mgr_set_timings(enum omap_channel channel,
 	} else {
 		if (t.interlace)
 			t.y_res /= 2;
+
+		if (dispc.feat->supports_double_pixel)
+			REG_FLD_MOD(DISPC_CONTROL, t.double_pixel ? 1 : 0,
+				19, 17);
 	}
 
 	dispc_mgr_set_size(channel, t.x_res, t.y_res);
@@ -3951,6 +3957,7 @@ static const struct dispc_features omap44xx_dispc_feats = {
 	.set_max_preload	=	true,
 	.supports_sync_align	=	true,
 	.has_writeback		=	true,
+	.supports_double_pixel	=	true,
 };
 
 static const struct dispc_features omap54xx_dispc_feats = {
@@ -3974,6 +3981,7 @@ static const struct dispc_features omap54xx_dispc_feats = {
 	.set_max_preload	=	true,
 	.supports_sync_align	=	true,
 	.has_writeback		=	true,
+	.supports_double_pixel	=	true,
 };
 
 static int dispc_init_features(struct platform_device *pdev)

commit 9960aa7cb58caadef8edf3a2582e30664a6b68dd
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Dec 9 20:26:00 2015 +0200

    drm/omap: move omapdss & displays under omapdrm
    
    Now that omapfb has its own copy of omapdss and display drivers, we can
    move omapdss and display drivers which omapdrm uses to omapdrm's
    directory.
    
    We also need to change the main drm Makefile so that omapdrm directory
    is always entered, because omapdss has a file that can't be built as a
    module.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Acked-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dispc.c b/drivers/gpu/drm/omapdrm/dss/dispc.c
new file mode 100644
index 000000000000..6b50476ec669
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -0,0 +1,4234 @@
+/*
+ * linux/drivers/video/omap2/dss/dispc.c
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * Some code and ideas taken from drivers/video/omap/ driver
+ * by Imre Deak.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DSS_SUBSYS_NAME "DISPC"
+
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/vmalloc.h>
+#include <linux/export.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/hardirq.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include <linux/component.h>
+
+#include <video/omapdss.h>
+
+#include "dss.h"
+#include "dss_features.h"
+#include "dispc.h"
+
+/* DISPC */
+#define DISPC_SZ_REGS			SZ_4K
+
+enum omap_burst_size {
+	BURST_SIZE_X2 = 0,
+	BURST_SIZE_X4 = 1,
+	BURST_SIZE_X8 = 2,
+};
+
+#define REG_GET(idx, start, end) \
+	FLD_GET(dispc_read_reg(idx), start, end)
+
+#define REG_FLD_MOD(idx, val, start, end)				\
+	dispc_write_reg(idx, FLD_MOD(dispc_read_reg(idx), val, start, end))
+
+struct dispc_features {
+	u8 sw_start;
+	u8 fp_start;
+	u8 bp_start;
+	u16 sw_max;
+	u16 vp_max;
+	u16 hp_max;
+	u8 mgr_width_start;
+	u8 mgr_height_start;
+	u16 mgr_width_max;
+	u16 mgr_height_max;
+	unsigned long max_lcd_pclk;
+	unsigned long max_tv_pclk;
+	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
+		const struct omap_video_timings *mgr_timings,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool *five_taps,
+		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
+		u16 pos_x, unsigned long *core_clk, bool mem_to_mem);
+	unsigned long (*calc_core_clk) (unsigned long pclk,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		bool mem_to_mem);
+	u8 num_fifos;
+
+	/* swap GFX & WB fifos */
+	bool gfx_fifo_workaround:1;
+
+	/* no DISPC_IRQ_FRAMEDONETV on this SoC */
+	bool no_framedone_tv:1;
+
+	/* revert to the OMAP4 mechanism of DISPC Smart Standby operation */
+	bool mstandby_workaround:1;
+
+	bool set_max_preload:1;
+
+	/* PIXEL_INC is not added to the last pixel of a line */
+	bool last_pixel_inc_missing:1;
+
+	/* POL_FREQ has ALIGN bit */
+	bool supports_sync_align:1;
+
+	bool has_writeback:1;
+};
+
+#define DISPC_MAX_NR_FIFOS 5
+
+static struct {
+	struct platform_device *pdev;
+	void __iomem    *base;
+
+	int irq;
+	irq_handler_t user_handler;
+	void *user_data;
+
+	unsigned long core_clk_rate;
+	unsigned long tv_pclk_rate;
+
+	u32 fifo_size[DISPC_MAX_NR_FIFOS];
+	/* maps which plane is using a fifo. fifo-id -> plane-id */
+	int fifo_assignment[DISPC_MAX_NR_FIFOS];
+
+	bool		ctx_valid;
+	u32		ctx[DISPC_SZ_REGS / sizeof(u32)];
+
+	const struct dispc_features *feat;
+
+	bool is_enabled;
+
+	struct regmap *syscon_pol;
+	u32 syscon_pol_offset;
+
+	/* DISPC_CONTROL & DISPC_CONFIG lock*/
+	spinlock_t control_lock;
+} dispc;
+
+enum omap_color_component {
+	/* used for all color formats for OMAP3 and earlier
+	 * and for RGB and Y color component on OMAP4
+	 */
+	DISPC_COLOR_COMPONENT_RGB_Y		= 1 << 0,
+	/* used for UV component for
+	 * OMAP_DSS_COLOR_YUV2, OMAP_DSS_COLOR_UYVY, OMAP_DSS_COLOR_NV12
+	 * color formats on OMAP4
+	 */
+	DISPC_COLOR_COMPONENT_UV		= 1 << 1,
+};
+
+enum mgr_reg_fields {
+	DISPC_MGR_FLD_ENABLE,
+	DISPC_MGR_FLD_STNTFT,
+	DISPC_MGR_FLD_GO,
+	DISPC_MGR_FLD_TFTDATALINES,
+	DISPC_MGR_FLD_STALLMODE,
+	DISPC_MGR_FLD_TCKENABLE,
+	DISPC_MGR_FLD_TCKSELECTION,
+	DISPC_MGR_FLD_CPR,
+	DISPC_MGR_FLD_FIFOHANDCHECK,
+	/* used to maintain a count of the above fields */
+	DISPC_MGR_FLD_NUM,
+};
+
+struct dispc_reg_field {
+	u16 reg;
+	u8 high;
+	u8 low;
+};
+
+static const struct {
+	const char *name;
+	u32 vsync_irq;
+	u32 framedone_irq;
+	u32 sync_lost_irq;
+	struct dispc_reg_field reg_desc[DISPC_MGR_FLD_NUM];
+} mgr_desc[] = {
+	[OMAP_DSS_CHANNEL_LCD] = {
+		.name		= "LCD",
+		.vsync_irq	= DISPC_IRQ_VSYNC,
+		.framedone_irq	= DISPC_IRQ_FRAMEDONE,
+		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST,
+		.reg_desc	= {
+			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL,  0,  0 },
+			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL,  3,  3 },
+			[DISPC_MGR_FLD_GO]		= { DISPC_CONTROL,  5,  5 },
+			[DISPC_MGR_FLD_TFTDATALINES]	= { DISPC_CONTROL,  9,  8 },
+			[DISPC_MGR_FLD_STALLMODE]	= { DISPC_CONTROL, 11, 11 },
+			[DISPC_MGR_FLD_TCKENABLE]	= { DISPC_CONFIG,  10, 10 },
+			[DISPC_MGR_FLD_TCKSELECTION]	= { DISPC_CONFIG,  11, 11 },
+			[DISPC_MGR_FLD_CPR]		= { DISPC_CONFIG,  15, 15 },
+			[DISPC_MGR_FLD_FIFOHANDCHECK]	= { DISPC_CONFIG,  16, 16 },
+		},
+	},
+	[OMAP_DSS_CHANNEL_DIGIT] = {
+		.name		= "DIGIT",
+		.vsync_irq	= DISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_EVSYNC_EVEN,
+		.framedone_irq	= DISPC_IRQ_FRAMEDONETV,
+		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST_DIGIT,
+		.reg_desc	= {
+			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL,  1,  1 },
+			[DISPC_MGR_FLD_STNTFT]		= { },
+			[DISPC_MGR_FLD_GO]		= { DISPC_CONTROL,  6,  6 },
+			[DISPC_MGR_FLD_TFTDATALINES]	= { },
+			[DISPC_MGR_FLD_STALLMODE]	= { },
+			[DISPC_MGR_FLD_TCKENABLE]	= { DISPC_CONFIG,  12, 12 },
+			[DISPC_MGR_FLD_TCKSELECTION]	= { DISPC_CONFIG,  13, 13 },
+			[DISPC_MGR_FLD_CPR]		= { },
+			[DISPC_MGR_FLD_FIFOHANDCHECK]	= { DISPC_CONFIG,  16, 16 },
+		},
+	},
+	[OMAP_DSS_CHANNEL_LCD2] = {
+		.name		= "LCD2",
+		.vsync_irq	= DISPC_IRQ_VSYNC2,
+		.framedone_irq	= DISPC_IRQ_FRAMEDONE2,
+		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST2,
+		.reg_desc	= {
+			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL2,  0,  0 },
+			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL2,  3,  3 },
+			[DISPC_MGR_FLD_GO]		= { DISPC_CONTROL2,  5,  5 },
+			[DISPC_MGR_FLD_TFTDATALINES]	= { DISPC_CONTROL2,  9,  8 },
+			[DISPC_MGR_FLD_STALLMODE]	= { DISPC_CONTROL2, 11, 11 },
+			[DISPC_MGR_FLD_TCKENABLE]	= { DISPC_CONFIG2,  10, 10 },
+			[DISPC_MGR_FLD_TCKSELECTION]	= { DISPC_CONFIG2,  11, 11 },
+			[DISPC_MGR_FLD_CPR]		= { DISPC_CONFIG2,  15, 15 },
+			[DISPC_MGR_FLD_FIFOHANDCHECK]	= { DISPC_CONFIG2,  16, 16 },
+		},
+	},
+	[OMAP_DSS_CHANNEL_LCD3] = {
+		.name		= "LCD3",
+		.vsync_irq	= DISPC_IRQ_VSYNC3,
+		.framedone_irq	= DISPC_IRQ_FRAMEDONE3,
+		.sync_lost_irq	= DISPC_IRQ_SYNC_LOST3,
+		.reg_desc	= {
+			[DISPC_MGR_FLD_ENABLE]		= { DISPC_CONTROL3,  0,  0 },
+			[DISPC_MGR_FLD_STNTFT]		= { DISPC_CONTROL3,  3,  3 },
+			[DISPC_MGR_FLD_GO]		= { DISPC_CONTROL3,  5,  5 },
+			[DISPC_MGR_FLD_TFTDATALINES]	= { DISPC_CONTROL3,  9,  8 },
+			[DISPC_MGR_FLD_STALLMODE]	= { DISPC_CONTROL3, 11, 11 },
+			[DISPC_MGR_FLD_TCKENABLE]	= { DISPC_CONFIG3,  10, 10 },
+			[DISPC_MGR_FLD_TCKSELECTION]	= { DISPC_CONFIG3,  11, 11 },
+			[DISPC_MGR_FLD_CPR]		= { DISPC_CONFIG3,  15, 15 },
+			[DISPC_MGR_FLD_FIFOHANDCHECK]	= { DISPC_CONFIG3,  16, 16 },
+		},
+	},
+};
+
+struct color_conv_coef {
+	int ry, rcr, rcb, gy, gcr, gcb, by, bcr, bcb;
+	int full_range;
+};
+
+static unsigned long dispc_fclk_rate(void);
+static unsigned long dispc_core_clk_rate(void);
+static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel);
+static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
+
+static unsigned long dispc_plane_pclk_rate(enum omap_plane plane);
+static unsigned long dispc_plane_lclk_rate(enum omap_plane plane);
+
+static inline void dispc_write_reg(const u16 idx, u32 val)
+{
+	__raw_writel(val, dispc.base + idx);
+}
+
+static inline u32 dispc_read_reg(const u16 idx)
+{
+	return __raw_readl(dispc.base + idx);
+}
+
+static u32 mgr_fld_read(enum omap_channel channel, enum mgr_reg_fields regfld)
+{
+	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
+	return REG_GET(rfld.reg, rfld.high, rfld.low);
+}
+
+static void mgr_fld_write(enum omap_channel channel,
+					enum mgr_reg_fields regfld, int val) {
+	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
+	const bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;
+	unsigned long flags;
+
+	if (need_lock)
+		spin_lock_irqsave(&dispc.control_lock, flags);
+
+	REG_FLD_MOD(rfld.reg, val, rfld.high, rfld.low);
+
+	if (need_lock)
+		spin_unlock_irqrestore(&dispc.control_lock, flags);
+}
+
+#define SR(reg) \
+	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
+#define RR(reg) \
+	dispc_write_reg(DISPC_##reg, dispc.ctx[DISPC_##reg / sizeof(u32)])
+
+static void dispc_save_context(void)
+{
+	int i, j;
+
+	DSSDBG("dispc_save_context\n");
+
+	SR(IRQENABLE);
+	SR(CONTROL);
+	SR(CONFIG);
+	SR(LINE_NUMBER);
+	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+		SR(GLOBAL_ALPHA);
+	if (dss_has_feature(FEAT_MGR_LCD2)) {
+		SR(CONTROL2);
+		SR(CONFIG2);
+	}
+	if (dss_has_feature(FEAT_MGR_LCD3)) {
+		SR(CONTROL3);
+		SR(CONFIG3);
+	}
+
+	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+		SR(DEFAULT_COLOR(i));
+		SR(TRANS_COLOR(i));
+		SR(SIZE_MGR(i));
+		if (i == OMAP_DSS_CHANNEL_DIGIT)
+			continue;
+		SR(TIMING_H(i));
+		SR(TIMING_V(i));
+		SR(POL_FREQ(i));
+		SR(DIVISORo(i));
+
+		SR(DATA_CYCLE1(i));
+		SR(DATA_CYCLE2(i));
+		SR(DATA_CYCLE3(i));
+
+		if (dss_has_feature(FEAT_CPR)) {
+			SR(CPR_COEF_R(i));
+			SR(CPR_COEF_G(i));
+			SR(CPR_COEF_B(i));
+		}
+	}
+
+	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+		SR(OVL_BA0(i));
+		SR(OVL_BA1(i));
+		SR(OVL_POSITION(i));
+		SR(OVL_SIZE(i));
+		SR(OVL_ATTRIBUTES(i));
+		SR(OVL_FIFO_THRESHOLD(i));
+		SR(OVL_ROW_INC(i));
+		SR(OVL_PIXEL_INC(i));
+		if (dss_has_feature(FEAT_PRELOAD))
+			SR(OVL_PRELOAD(i));
+		if (i == OMAP_DSS_GFX) {
+			SR(OVL_WINDOW_SKIP(i));
+			SR(OVL_TABLE_BA(i));
+			continue;
+		}
+		SR(OVL_FIR(i));
+		SR(OVL_PICTURE_SIZE(i));
+		SR(OVL_ACCU0(i));
+		SR(OVL_ACCU1(i));
+
+		for (j = 0; j < 8; j++)
+			SR(OVL_FIR_COEF_H(i, j));
+
+		for (j = 0; j < 8; j++)
+			SR(OVL_FIR_COEF_HV(i, j));
+
+		for (j = 0; j < 5; j++)
+			SR(OVL_CONV_COEF(i, j));
+
+		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+			for (j = 0; j < 8; j++)
+				SR(OVL_FIR_COEF_V(i, j));
+		}
+
+		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+			SR(OVL_BA0_UV(i));
+			SR(OVL_BA1_UV(i));
+			SR(OVL_FIR2(i));
+			SR(OVL_ACCU2_0(i));
+			SR(OVL_ACCU2_1(i));
+
+			for (j = 0; j < 8; j++)
+				SR(OVL_FIR_COEF_H2(i, j));
+
+			for (j = 0; j < 8; j++)
+				SR(OVL_FIR_COEF_HV2(i, j));
+
+			for (j = 0; j < 8; j++)
+				SR(OVL_FIR_COEF_V2(i, j));
+		}
+		if (dss_has_feature(FEAT_ATTR2))
+			SR(OVL_ATTRIBUTES2(i));
+	}
+
+	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+		SR(DIVISOR);
+
+	dispc.ctx_valid = true;
+
+	DSSDBG("context saved\n");
+}
+
+static void dispc_restore_context(void)
+{
+	int i, j;
+
+	DSSDBG("dispc_restore_context\n");
+
+	if (!dispc.ctx_valid)
+		return;
+
+	/*RR(IRQENABLE);*/
+	/*RR(CONTROL);*/
+	RR(CONFIG);
+	RR(LINE_NUMBER);
+	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+		RR(GLOBAL_ALPHA);
+	if (dss_has_feature(FEAT_MGR_LCD2))
+		RR(CONFIG2);
+	if (dss_has_feature(FEAT_MGR_LCD3))
+		RR(CONFIG3);
+
+	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+		RR(DEFAULT_COLOR(i));
+		RR(TRANS_COLOR(i));
+		RR(SIZE_MGR(i));
+		if (i == OMAP_DSS_CHANNEL_DIGIT)
+			continue;
+		RR(TIMING_H(i));
+		RR(TIMING_V(i));
+		RR(POL_FREQ(i));
+		RR(DIVISORo(i));
+
+		RR(DATA_CYCLE1(i));
+		RR(DATA_CYCLE2(i));
+		RR(DATA_CYCLE3(i));
+
+		if (dss_has_feature(FEAT_CPR)) {
+			RR(CPR_COEF_R(i));
+			RR(CPR_COEF_G(i));
+			RR(CPR_COEF_B(i));
+		}
+	}
+
+	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+		RR(OVL_BA0(i));
+		RR(OVL_BA1(i));
+		RR(OVL_POSITION(i));
+		RR(OVL_SIZE(i));
+		RR(OVL_ATTRIBUTES(i));
+		RR(OVL_FIFO_THRESHOLD(i));
+		RR(OVL_ROW_INC(i));
+		RR(OVL_PIXEL_INC(i));
+		if (dss_has_feature(FEAT_PRELOAD))
+			RR(OVL_PRELOAD(i));
+		if (i == OMAP_DSS_GFX) {
+			RR(OVL_WINDOW_SKIP(i));
+			RR(OVL_TABLE_BA(i));
+			continue;
+		}
+		RR(OVL_FIR(i));
+		RR(OVL_PICTURE_SIZE(i));
+		RR(OVL_ACCU0(i));
+		RR(OVL_ACCU1(i));
+
+		for (j = 0; j < 8; j++)
+			RR(OVL_FIR_COEF_H(i, j));
+
+		for (j = 0; j < 8; j++)
+			RR(OVL_FIR_COEF_HV(i, j));
+
+		for (j = 0; j < 5; j++)
+			RR(OVL_CONV_COEF(i, j));
+
+		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+			for (j = 0; j < 8; j++)
+				RR(OVL_FIR_COEF_V(i, j));
+		}
+
+		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+			RR(OVL_BA0_UV(i));
+			RR(OVL_BA1_UV(i));
+			RR(OVL_FIR2(i));
+			RR(OVL_ACCU2_0(i));
+			RR(OVL_ACCU2_1(i));
+
+			for (j = 0; j < 8; j++)
+				RR(OVL_FIR_COEF_H2(i, j));
+
+			for (j = 0; j < 8; j++)
+				RR(OVL_FIR_COEF_HV2(i, j));
+
+			for (j = 0; j < 8; j++)
+				RR(OVL_FIR_COEF_V2(i, j));
+		}
+		if (dss_has_feature(FEAT_ATTR2))
+			RR(OVL_ATTRIBUTES2(i));
+	}
+
+	if (dss_has_feature(FEAT_CORE_CLK_DIV))
+		RR(DIVISOR);
+
+	/* enable last, because LCD & DIGIT enable are here */
+	RR(CONTROL);
+	if (dss_has_feature(FEAT_MGR_LCD2))
+		RR(CONTROL2);
+	if (dss_has_feature(FEAT_MGR_LCD3))
+		RR(CONTROL3);
+	/* clear spurious SYNC_LOST_DIGIT interrupts */
+	dispc_clear_irqstatus(DISPC_IRQ_SYNC_LOST_DIGIT);
+
+	/*
+	 * enable last so IRQs won't trigger before
+	 * the context is fully restored
+	 */
+	RR(IRQENABLE);
+
+	DSSDBG("context restored\n");
+}
+
+#undef SR
+#undef RR
+
+int dispc_runtime_get(void)
+{
+	int r;
+
+	DSSDBG("dispc_runtime_get\n");
+
+	r = pm_runtime_get_sync(&dispc.pdev->dev);
+	WARN_ON(r < 0);
+	return r < 0 ? r : 0;
+}
+EXPORT_SYMBOL(dispc_runtime_get);
+
+void dispc_runtime_put(void)
+{
+	int r;
+
+	DSSDBG("dispc_runtime_put\n");
+
+	r = pm_runtime_put_sync(&dispc.pdev->dev);
+	WARN_ON(r < 0 && r != -ENOSYS);
+}
+EXPORT_SYMBOL(dispc_runtime_put);
+
+u32 dispc_mgr_get_vsync_irq(enum omap_channel channel)
+{
+	return mgr_desc[channel].vsync_irq;
+}
+EXPORT_SYMBOL(dispc_mgr_get_vsync_irq);
+
+u32 dispc_mgr_get_framedone_irq(enum omap_channel channel)
+{
+	if (channel == OMAP_DSS_CHANNEL_DIGIT && dispc.feat->no_framedone_tv)
+		return 0;
+
+	return mgr_desc[channel].framedone_irq;
+}
+EXPORT_SYMBOL(dispc_mgr_get_framedone_irq);
+
+u32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)
+{
+	return mgr_desc[channel].sync_lost_irq;
+}
+EXPORT_SYMBOL(dispc_mgr_get_sync_lost_irq);
+
+u32 dispc_wb_get_framedone_irq(void)
+{
+	return DISPC_IRQ_FRAMEDONEWB;
+}
+
+bool dispc_mgr_go_busy(enum omap_channel channel)
+{
+	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
+}
+EXPORT_SYMBOL(dispc_mgr_go_busy);
+
+void dispc_mgr_go(enum omap_channel channel)
+{
+	WARN_ON(!dispc_mgr_is_enabled(channel));
+	WARN_ON(dispc_mgr_go_busy(channel));
+
+	DSSDBG("GO %s\n", mgr_desc[channel].name);
+
+	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
+}
+EXPORT_SYMBOL(dispc_mgr_go);
+
+bool dispc_wb_go_busy(void)
+{
+	return REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+}
+
+void dispc_wb_go(void)
+{
+	enum omap_plane plane = OMAP_DSS_WB;
+	bool enable, go;
+
+	enable = REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
+
+	if (!enable)
+		return;
+
+	go = REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+	if (go) {
+		DSSERR("GO bit not down for WB\n");
+		return;
+	}
+
+	REG_FLD_MOD(DISPC_CONTROL2, 1, 6, 6);
+}
+
+static void dispc_ovl_write_firh_reg(enum omap_plane plane, int reg, u32 value)
+{
+	dispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);
+}
+
+static void dispc_ovl_write_firhv_reg(enum omap_plane plane, int reg, u32 value)
+{
+	dispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);
+}
+
+static void dispc_ovl_write_firv_reg(enum omap_plane plane, int reg, u32 value)
+{
+	dispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);
+}
+
+static void dispc_ovl_write_firh2_reg(enum omap_plane plane, int reg, u32 value)
+{
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	dispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);
+}
+
+static void dispc_ovl_write_firhv2_reg(enum omap_plane plane, int reg,
+		u32 value)
+{
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	dispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
+}
+
+static void dispc_ovl_write_firv2_reg(enum omap_plane plane, int reg, u32 value)
+{
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	dispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);
+}
+
+static void dispc_ovl_set_scale_coef(enum omap_plane plane, int fir_hinc,
+				int fir_vinc, int five_taps,
+				enum omap_color_component color_comp)
+{
+	const struct dispc_coef *h_coef, *v_coef;
+	int i;
+
+	h_coef = dispc_ovl_get_scale_coef(fir_hinc, true);
+	v_coef = dispc_ovl_get_scale_coef(fir_vinc, five_taps);
+
+	for (i = 0; i < 8; i++) {
+		u32 h, hv;
+
+		h = FLD_VAL(h_coef[i].hc0_vc00, 7, 0)
+			| FLD_VAL(h_coef[i].hc1_vc0, 15, 8)
+			| FLD_VAL(h_coef[i].hc2_vc1, 23, 16)
+			| FLD_VAL(h_coef[i].hc3_vc2, 31, 24);
+		hv = FLD_VAL(h_coef[i].hc4_vc22, 7, 0)
+			| FLD_VAL(v_coef[i].hc1_vc0, 15, 8)
+			| FLD_VAL(v_coef[i].hc2_vc1, 23, 16)
+			| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);
+
+		if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
+			dispc_ovl_write_firh_reg(plane, i, h);
+			dispc_ovl_write_firhv_reg(plane, i, hv);
+		} else {
+			dispc_ovl_write_firh2_reg(plane, i, h);
+			dispc_ovl_write_firhv2_reg(plane, i, hv);
+		}
+
+	}
+
+	if (five_taps) {
+		for (i = 0; i < 8; i++) {
+			u32 v;
+			v = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)
+				| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);
+			if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)
+				dispc_ovl_write_firv_reg(plane, i, v);
+			else
+				dispc_ovl_write_firv2_reg(plane, i, v);
+		}
+	}
+}
+
+
+static void dispc_ovl_write_color_conv_coef(enum omap_plane plane,
+		const struct color_conv_coef *ct)
+{
+#define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
+
+	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));
+	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));
+	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));
+	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));
+	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
+
+#undef CVAL
+}
+
+static void dispc_setup_color_conv_coef(void)
+{
+	int i;
+	int num_ovl = dss_feat_get_num_ovls();
+	const struct color_conv_coef ctbl_bt601_5_ovl = {
+		/* YUV -> RGB */
+		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
+	};
+	const struct color_conv_coef ctbl_bt601_5_wb = {
+		/* RGB -> YUV */
+		66, 129, 25, 112, -94, -18, -38, -74, 112, 0,
+	};
+
+	for (i = 1; i < num_ovl; i++)
+		dispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_ovl);
+
+	if (dispc.feat->has_writeback)
+		dispc_ovl_write_color_conv_coef(OMAP_DSS_WB, &ctbl_bt601_5_wb);
+}
+
+static void dispc_ovl_set_ba0(enum omap_plane plane, u32 paddr)
+{
+	dispc_write_reg(DISPC_OVL_BA0(plane), paddr);
+}
+
+static void dispc_ovl_set_ba1(enum omap_plane plane, u32 paddr)
+{
+	dispc_write_reg(DISPC_OVL_BA1(plane), paddr);
+}
+
+static void dispc_ovl_set_ba0_uv(enum omap_plane plane, u32 paddr)
+{
+	dispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);
+}
+
+static void dispc_ovl_set_ba1_uv(enum omap_plane plane, u32 paddr)
+{
+	dispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);
+}
+
+static void dispc_ovl_set_pos(enum omap_plane plane,
+		enum omap_overlay_caps caps, int x, int y)
+{
+	u32 val;
+
+	if ((caps & OMAP_DSS_OVL_CAP_POS) == 0)
+		return;
+
+	val = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);
+
+	dispc_write_reg(DISPC_OVL_POSITION(plane), val);
+}
+
+static void dispc_ovl_set_input_size(enum omap_plane plane, int width,
+		int height)
+{
+	u32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
+
+	if (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)
+		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+	else
+		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+}
+
+static void dispc_ovl_set_output_size(enum omap_plane plane, int width,
+		int height)
+{
+	u32 val;
+
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
+
+	if (plane == OMAP_DSS_WB)
+		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+	else
+		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+}
+
+static void dispc_ovl_set_zorder(enum omap_plane plane,
+		enum omap_overlay_caps caps, u8 zorder)
+{
+	if ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)
+		return;
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);
+}
+
+static void dispc_ovl_enable_zorder_planes(void)
+{
+	int i;
+
+	if (!dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+		return;
+
+	for (i = 0; i < dss_feat_get_num_ovls(); i++)
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
+}
+
+static void dispc_ovl_set_pre_mult_alpha(enum omap_plane plane,
+		enum omap_overlay_caps caps, bool enable)
+{
+	if ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)
+		return;
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
+}
+
+static void dispc_ovl_setup_global_alpha(enum omap_plane plane,
+		enum omap_overlay_caps caps, u8 global_alpha)
+{
+	static const unsigned shifts[] = { 0, 8, 16, 24, };
+	int shift;
+
+	if ((caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)
+		return;
+
+	shift = shifts[plane];
+	REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
+}
+
+static void dispc_ovl_set_pix_inc(enum omap_plane plane, s32 inc)
+{
+	dispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);
+}
+
+static void dispc_ovl_set_row_inc(enum omap_plane plane, s32 inc)
+{
+	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
+}
+
+static void dispc_ovl_set_color_mode(enum omap_plane plane,
+		enum omap_color_mode color_mode)
+{
+	u32 m = 0;
+	if (plane != OMAP_DSS_GFX) {
+		switch (color_mode) {
+		case OMAP_DSS_COLOR_NV12:
+			m = 0x0; break;
+		case OMAP_DSS_COLOR_RGBX16:
+			m = 0x1; break;
+		case OMAP_DSS_COLOR_RGBA16:
+			m = 0x2; break;
+		case OMAP_DSS_COLOR_RGB12U:
+			m = 0x4; break;
+		case OMAP_DSS_COLOR_ARGB16:
+			m = 0x5; break;
+		case OMAP_DSS_COLOR_RGB16:
+			m = 0x6; break;
+		case OMAP_DSS_COLOR_ARGB16_1555:
+			m = 0x7; break;
+		case OMAP_DSS_COLOR_RGB24U:
+			m = 0x8; break;
+		case OMAP_DSS_COLOR_RGB24P:
+			m = 0x9; break;
+		case OMAP_DSS_COLOR_YUV2:
+			m = 0xa; break;
+		case OMAP_DSS_COLOR_UYVY:
+			m = 0xb; break;
+		case OMAP_DSS_COLOR_ARGB32:
+			m = 0xc; break;
+		case OMAP_DSS_COLOR_RGBA32:
+			m = 0xd; break;
+		case OMAP_DSS_COLOR_RGBX32:
+			m = 0xe; break;
+		case OMAP_DSS_COLOR_XRGB16_1555:
+			m = 0xf; break;
+		default:
+			BUG(); return;
+		}
+	} else {
+		switch (color_mode) {
+		case OMAP_DSS_COLOR_CLUT1:
+			m = 0x0; break;
+		case OMAP_DSS_COLOR_CLUT2:
+			m = 0x1; break;
+		case OMAP_DSS_COLOR_CLUT4:
+			m = 0x2; break;
+		case OMAP_DSS_COLOR_CLUT8:
+			m = 0x3; break;
+		case OMAP_DSS_COLOR_RGB12U:
+			m = 0x4; break;
+		case OMAP_DSS_COLOR_ARGB16:
+			m = 0x5; break;
+		case OMAP_DSS_COLOR_RGB16:
+			m = 0x6; break;
+		case OMAP_DSS_COLOR_ARGB16_1555:
+			m = 0x7; break;
+		case OMAP_DSS_COLOR_RGB24U:
+			m = 0x8; break;
+		case OMAP_DSS_COLOR_RGB24P:
+			m = 0x9; break;
+		case OMAP_DSS_COLOR_RGBX16:
+			m = 0xa; break;
+		case OMAP_DSS_COLOR_RGBA16:
+			m = 0xb; break;
+		case OMAP_DSS_COLOR_ARGB32:
+			m = 0xc; break;
+		case OMAP_DSS_COLOR_RGBA32:
+			m = 0xd; break;
+		case OMAP_DSS_COLOR_RGBX32:
+			m = 0xe; break;
+		case OMAP_DSS_COLOR_XRGB16_1555:
+			m = 0xf; break;
+		default:
+			BUG(); return;
+		}
+	}
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
+}
+
+static void dispc_ovl_configure_burst_type(enum omap_plane plane,
+		enum omap_dss_rotation_type rotation_type)
+{
+	if (dss_has_feature(FEAT_BURST_2D) == 0)
+		return;
+
+	if (rotation_type == OMAP_DSS_ROT_TILER)
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);
+	else
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
+}
+
+void dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)
+{
+	int shift;
+	u32 val;
+	int chan = 0, chan2 = 0;
+
+	switch (plane) {
+	case OMAP_DSS_GFX:
+		shift = 8;
+		break;
+	case OMAP_DSS_VIDEO1:
+	case OMAP_DSS_VIDEO2:
+	case OMAP_DSS_VIDEO3:
+		shift = 16;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	if (dss_has_feature(FEAT_MGR_LCD2)) {
+		switch (channel) {
+		case OMAP_DSS_CHANNEL_LCD:
+			chan = 0;
+			chan2 = 0;
+			break;
+		case OMAP_DSS_CHANNEL_DIGIT:
+			chan = 1;
+			chan2 = 0;
+			break;
+		case OMAP_DSS_CHANNEL_LCD2:
+			chan = 0;
+			chan2 = 1;
+			break;
+		case OMAP_DSS_CHANNEL_LCD3:
+			if (dss_has_feature(FEAT_MGR_LCD3)) {
+				chan = 0;
+				chan2 = 2;
+			} else {
+				BUG();
+				return;
+			}
+			break;
+		case OMAP_DSS_CHANNEL_WB:
+			chan = 0;
+			chan2 = 3;
+			break;
+		default:
+			BUG();
+			return;
+		}
+
+		val = FLD_MOD(val, chan, shift, shift);
+		val = FLD_MOD(val, chan2, 31, 30);
+	} else {
+		val = FLD_MOD(val, channel, shift, shift);
+	}
+	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+}
+EXPORT_SYMBOL(dispc_ovl_set_channel_out);
+
+static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)
+{
+	int shift;
+	u32 val;
+
+	switch (plane) {
+	case OMAP_DSS_GFX:
+		shift = 8;
+		break;
+	case OMAP_DSS_VIDEO1:
+	case OMAP_DSS_VIDEO2:
+	case OMAP_DSS_VIDEO3:
+		shift = 16;
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+
+	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+
+	if (FLD_GET(val, shift, shift) == 1)
+		return OMAP_DSS_CHANNEL_DIGIT;
+
+	if (!dss_has_feature(FEAT_MGR_LCD2))
+		return OMAP_DSS_CHANNEL_LCD;
+
+	switch (FLD_GET(val, 31, 30)) {
+	case 0:
+	default:
+		return OMAP_DSS_CHANNEL_LCD;
+	case 1:
+		return OMAP_DSS_CHANNEL_LCD2;
+	case 2:
+		return OMAP_DSS_CHANNEL_LCD3;
+	case 3:
+		return OMAP_DSS_CHANNEL_WB;
+	}
+}
+
+void dispc_wb_set_channel_in(enum dss_writeback_channel channel)
+{
+	enum omap_plane plane = OMAP_DSS_WB;
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
+}
+
+static void dispc_ovl_set_burst_size(enum omap_plane plane,
+		enum omap_burst_size burst_size)
+{
+	static const unsigned shifts[] = { 6, 14, 14, 14, 14, };
+	int shift;
+
+	shift = shifts[plane];
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), burst_size, shift + 1, shift);
+}
+
+static void dispc_configure_burst_sizes(void)
+{
+	int i;
+	const int burst_size = BURST_SIZE_X8;
+
+	/* Configure burst size always to maximum size */
+	for (i = 0; i < dss_feat_get_num_ovls(); ++i)
+		dispc_ovl_set_burst_size(i, burst_size);
+	if (dispc.feat->has_writeback)
+		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
+}
+
+static u32 dispc_ovl_get_burst_size(enum omap_plane plane)
+{
+	unsigned unit = dss_feat_get_burst_size_unit();
+	/* burst multiplier is always x8 (see dispc_configure_burst_sizes()) */
+	return unit * 8;
+}
+
+void dispc_enable_gamma_table(bool enable)
+{
+	/*
+	 * This is partially implemented to support only disabling of
+	 * the gamma table.
+	 */
+	if (enable) {
+		DSSWARN("Gamma table enabling for TV not yet supported");
+		return;
+	}
+
+	REG_FLD_MOD(DISPC_CONFIG, enable, 9, 9);
+}
+
+static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
+{
+	if (channel == OMAP_DSS_CHANNEL_DIGIT)
+		return;
+
+	mgr_fld_write(channel, DISPC_MGR_FLD_CPR, enable);
+}
+
+static void dispc_mgr_set_cpr_coef(enum omap_channel channel,
+		const struct omap_dss_cpr_coefs *coefs)
+{
+	u32 coef_r, coef_g, coef_b;
+
+	if (!dss_mgr_is_lcd(channel))
+		return;
+
+	coef_r = FLD_VAL(coefs->rr, 31, 22) | FLD_VAL(coefs->rg, 20, 11) |
+		FLD_VAL(coefs->rb, 9, 0);
+	coef_g = FLD_VAL(coefs->gr, 31, 22) | FLD_VAL(coefs->gg, 20, 11) |
+		FLD_VAL(coefs->gb, 9, 0);
+	coef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |
+		FLD_VAL(coefs->bb, 9, 0);
+
+	dispc_write_reg(DISPC_CPR_COEF_R(channel), coef_r);
+	dispc_write_reg(DISPC_CPR_COEF_G(channel), coef_g);
+	dispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);
+}
+
+static void dispc_ovl_set_vid_color_conv(enum omap_plane plane, bool enable)
+{
+	u32 val;
+
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	val = FLD_MOD(val, enable, 9, 9);
+	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+}
+
+static void dispc_ovl_enable_replication(enum omap_plane plane,
+		enum omap_overlay_caps caps, bool enable)
+{
+	static const unsigned shifts[] = { 5, 10, 10, 10 };
+	int shift;
+
+	if ((caps & OMAP_DSS_OVL_CAP_REPLICATION) == 0)
+		return;
+
+	shift = shifts[plane];
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);
+}
+
+static void dispc_mgr_set_size(enum omap_channel channel, u16 width,
+		u16 height)
+{
+	u32 val;
+
+	val = FLD_VAL(height - 1, dispc.feat->mgr_height_start, 16) |
+		FLD_VAL(width - 1, dispc.feat->mgr_width_start, 0);
+
+	dispc_write_reg(DISPC_SIZE_MGR(channel), val);
+}
+
+static void dispc_init_fifos(void)
+{
+	u32 size;
+	int fifo;
+	u8 start, end;
+	u32 unit;
+	int i;
+
+	unit = dss_feat_get_buffer_size_unit();
+
+	dss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
+
+	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
+		size = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);
+		size *= unit;
+		dispc.fifo_size[fifo] = size;
+
+		/*
+		 * By default fifos are mapped directly to overlays, fifo 0 to
+		 * ovl 0, fifo 1 to ovl 1, etc.
+		 */
+		dispc.fifo_assignment[fifo] = fifo;
+	}
+
+	/*
+	 * The GFX fifo on OMAP4 is smaller than the other fifos. The small fifo
+	 * causes problems with certain use cases, like using the tiler in 2D
+	 * mode. The below hack swaps the fifos of GFX and WB planes, thus
+	 * giving GFX plane a larger fifo. WB but should work fine with a
+	 * smaller fifo.
+	 */
+	if (dispc.feat->gfx_fifo_workaround) {
+		u32 v;
+
+		v = dispc_read_reg(DISPC_GLOBAL_BUFFER);
+
+		v = FLD_MOD(v, 4, 2, 0); /* GFX BUF top to WB */
+		v = FLD_MOD(v, 4, 5, 3); /* GFX BUF bottom to WB */
+		v = FLD_MOD(v, 0, 26, 24); /* WB BUF top to GFX */
+		v = FLD_MOD(v, 0, 29, 27); /* WB BUF bottom to GFX */
+
+		dispc_write_reg(DISPC_GLOBAL_BUFFER, v);
+
+		dispc.fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;
+		dispc.fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;
+	}
+
+	/*
+	 * Setup default fifo thresholds.
+	 */
+	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
+		u32 low, high;
+		const bool use_fifomerge = false;
+		const bool manual_update = false;
+
+		dispc_ovl_compute_fifo_thresholds(i, &low, &high,
+			use_fifomerge, manual_update);
+
+		dispc_ovl_set_fifo_threshold(i, low, high);
+	}
+
+	if (dispc.feat->has_writeback) {
+		u32 low, high;
+		const bool use_fifomerge = false;
+		const bool manual_update = false;
+
+		dispc_ovl_compute_fifo_thresholds(OMAP_DSS_WB, &low, &high,
+			use_fifomerge, manual_update);
+
+		dispc_ovl_set_fifo_threshold(OMAP_DSS_WB, low, high);
+	}
+}
+
+static u32 dispc_ovl_get_fifo_size(enum omap_plane plane)
+{
+	int fifo;
+	u32 size = 0;
+
+	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
+		if (dispc.fifo_assignment[fifo] == plane)
+			size += dispc.fifo_size[fifo];
+	}
+
+	return size;
+}
+
+void dispc_ovl_set_fifo_threshold(enum omap_plane plane, u32 low, u32 high)
+{
+	u8 hi_start, hi_end, lo_start, lo_end;
+	u32 unit;
+
+	unit = dss_feat_get_buffer_size_unit();
+
+	WARN_ON(low % unit != 0);
+	WARN_ON(high % unit != 0);
+
+	low /= unit;
+	high /= unit;
+
+	dss_feat_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);
+	dss_feat_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);
+
+	DSSDBG("fifo(%d) threshold (bytes), old %u/%u, new %u/%u\n",
+			plane,
+			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+				lo_start, lo_end) * unit,
+			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+				hi_start, hi_end) * unit,
+			low * unit, high * unit);
+
+	dispc_write_reg(DISPC_OVL_FIFO_THRESHOLD(plane),
+			FLD_VAL(high, hi_start, hi_end) |
+			FLD_VAL(low, lo_start, lo_end));
+
+	/*
+	 * configure the preload to the pipeline's high threhold, if HT it's too
+	 * large for the preload field, set the threshold to the maximum value
+	 * that can be held by the preload register
+	 */
+	if (dss_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&
+			plane != OMAP_DSS_WB)
+		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
+}
+
+void dispc_enable_fifomerge(bool enable)
+{
+	if (!dss_has_feature(FEAT_FIFO_MERGE)) {
+		WARN_ON(enable);
+		return;
+	}
+
+	DSSDBG("FIFO merge %s\n", enable ? "enabled" : "disabled");
+	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
+}
+
+void dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,
+		u32 *fifo_low, u32 *fifo_high, bool use_fifomerge,
+		bool manual_update)
+{
+	/*
+	 * All sizes are in bytes. Both the buffer and burst are made of
+	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.
+	 */
+
+	unsigned buf_unit = dss_feat_get_buffer_size_unit();
+	unsigned ovl_fifo_size, total_fifo_size, burst_size;
+	int i;
+
+	burst_size = dispc_ovl_get_burst_size(plane);
+	ovl_fifo_size = dispc_ovl_get_fifo_size(plane);
+
+	if (use_fifomerge) {
+		total_fifo_size = 0;
+		for (i = 0; i < dss_feat_get_num_ovls(); ++i)
+			total_fifo_size += dispc_ovl_get_fifo_size(i);
+	} else {
+		total_fifo_size = ovl_fifo_size;
+	}
+
+	/*
+	 * We use the same low threshold for both fifomerge and non-fifomerge
+	 * cases, but for fifomerge we calculate the high threshold using the
+	 * combined fifo size
+	 */
+
+	if (manual_update && dss_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {
+		*fifo_low = ovl_fifo_size - burst_size * 2;
+		*fifo_high = total_fifo_size - burst_size;
+	} else if (plane == OMAP_DSS_WB) {
+		/*
+		 * Most optimal configuration for writeback is to push out data
+		 * to the interconnect the moment writeback pushes enough pixels
+		 * in the FIFO to form a burst
+		 */
+		*fifo_low = 0;
+		*fifo_high = burst_size;
+	} else {
+		*fifo_low = ovl_fifo_size - burst_size;
+		*fifo_high = total_fifo_size - buf_unit;
+	}
+}
+
+static void dispc_ovl_set_mflag(enum omap_plane plane, bool enable)
+{
+	int bit;
+
+	if (plane == OMAP_DSS_GFX)
+		bit = 14;
+	else
+		bit = 23;
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
+}
+
+static void dispc_ovl_set_mflag_threshold(enum omap_plane plane,
+	int low, int high)
+{
+	dispc_write_reg(DISPC_OVL_MFLAG_THRESHOLD(plane),
+		FLD_VAL(high, 31, 16) |	FLD_VAL(low, 15, 0));
+}
+
+static void dispc_init_mflag(void)
+{
+	int i;
+
+	/*
+	 * HACK: NV12 color format and MFLAG seem to have problems working
+	 * together: using two displays, and having an NV12 overlay on one of
+	 * the displays will cause underflows/synclosts when MFLAG_CTRL=2.
+	 * Changing MFLAG thresholds and PRELOAD to certain values seem to
+	 * remove the errors, but there doesn't seem to be a clear logic on
+	 * which values work and which not.
+	 *
+	 * As a work-around, set force MFLAG to always on.
+	 */
+	dispc_write_reg(DISPC_GLOBAL_MFLAG_ATTRIBUTE,
+		(1 << 0) |	/* MFLAG_CTRL = force always on */
+		(0 << 2));	/* MFLAG_START = disable */
+
+	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
+		u32 size = dispc_ovl_get_fifo_size(i);
+		u32 unit = dss_feat_get_buffer_size_unit();
+		u32 low, high;
+
+		dispc_ovl_set_mflag(i, true);
+
+		/*
+		 * Simulation team suggests below thesholds:
+		 * HT = fifosize * 5 / 8;
+		 * LT = fifosize * 4 / 8;
+		 */
+
+		low = size * 4 / 8 / unit;
+		high = size * 5 / 8 / unit;
+
+		dispc_ovl_set_mflag_threshold(i, low, high);
+	}
+
+	if (dispc.feat->has_writeback) {
+		u32 size = dispc_ovl_get_fifo_size(OMAP_DSS_WB);
+		u32 unit = dss_feat_get_buffer_size_unit();
+		u32 low, high;
+
+		dispc_ovl_set_mflag(OMAP_DSS_WB, true);
+
+		/*
+		 * Simulation team suggests below thesholds:
+		 * HT = fifosize * 5 / 8;
+		 * LT = fifosize * 4 / 8;
+		 */
+
+		low = size * 4 / 8 / unit;
+		high = size * 5 / 8 / unit;
+
+		dispc_ovl_set_mflag_threshold(OMAP_DSS_WB, low, high);
+	}
+}
+
+static void dispc_ovl_set_fir(enum omap_plane plane,
+				int hinc, int vinc,
+				enum omap_color_component color_comp)
+{
+	u32 val;
+
+	if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
+		u8 hinc_start, hinc_end, vinc_start, vinc_end;
+
+		dss_feat_get_reg_field(FEAT_REG_FIRHINC,
+					&hinc_start, &hinc_end);
+		dss_feat_get_reg_field(FEAT_REG_FIRVINC,
+					&vinc_start, &vinc_end);
+		val = FLD_VAL(vinc, vinc_start, vinc_end) |
+				FLD_VAL(hinc, hinc_start, hinc_end);
+
+		dispc_write_reg(DISPC_OVL_FIR(plane), val);
+	} else {
+		val = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);
+		dispc_write_reg(DISPC_OVL_FIR2(plane), val);
+	}
+}
+
+static void dispc_ovl_set_vid_accu0(enum omap_plane plane, int haccu, int vaccu)
+{
+	u32 val;
+	u8 hor_start, hor_end, vert_start, vert_end;
+
+	dss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
+	dss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+
+	val = FLD_VAL(vaccu, vert_start, vert_end) |
+			FLD_VAL(haccu, hor_start, hor_end);
+
+	dispc_write_reg(DISPC_OVL_ACCU0(plane), val);
+}
+
+static void dispc_ovl_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)
+{
+	u32 val;
+	u8 hor_start, hor_end, vert_start, vert_end;
+
+	dss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
+	dss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+
+	val = FLD_VAL(vaccu, vert_start, vert_end) |
+			FLD_VAL(haccu, hor_start, hor_end);
+
+	dispc_write_reg(DISPC_OVL_ACCU1(plane), val);
+}
+
+static void dispc_ovl_set_vid_accu2_0(enum omap_plane plane, int haccu,
+		int vaccu)
+{
+	u32 val;
+
+	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
+	dispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);
+}
+
+static void dispc_ovl_set_vid_accu2_1(enum omap_plane plane, int haccu,
+		int vaccu)
+{
+	u32 val;
+
+	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
+	dispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);
+}
+
+static void dispc_ovl_set_scale_param(enum omap_plane plane,
+		u16 orig_width, u16 orig_height,
+		u16 out_width, u16 out_height,
+		bool five_taps, u8 rotation,
+		enum omap_color_component color_comp)
+{
+	int fir_hinc, fir_vinc;
+
+	fir_hinc = 1024 * orig_width / out_width;
+	fir_vinc = 1024 * orig_height / out_height;
+
+	dispc_ovl_set_scale_coef(plane, fir_hinc, fir_vinc, five_taps,
+				color_comp);
+	dispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);
+}
+
+static void dispc_ovl_set_accu_uv(enum omap_plane plane,
+		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
+		bool ilace, enum omap_color_mode color_mode, u8 rotation)
+{
+	int h_accu2_0, h_accu2_1;
+	int v_accu2_0, v_accu2_1;
+	int chroma_hinc, chroma_vinc;
+	int idx;
+
+	struct accu {
+		s8 h0_m, h0_n;
+		s8 h1_m, h1_n;
+		s8 v0_m, v0_n;
+		s8 v1_m, v1_n;
+	};
+
+	const struct accu *accu_table;
+	const struct accu *accu_val;
+
+	static const struct accu accu_nv12[4] = {
+		{  0, 1,  0, 1 , -1, 2, 0, 1 },
+		{  1, 2, -3, 4 ,  0, 1, 0, 1 },
+		{ -1, 1,  0, 1 , -1, 2, 0, 1 },
+		{ -1, 2, -1, 2 , -1, 1, 0, 1 },
+	};
+
+	static const struct accu accu_nv12_ilace[4] = {
+		{  0, 1,  0, 1 , -3, 4, -1, 4 },
+		{ -1, 4, -3, 4 ,  0, 1,  0, 1 },
+		{ -1, 1,  0, 1 , -1, 4, -3, 4 },
+		{ -3, 4, -3, 4 , -1, 1,  0, 1 },
+	};
+
+	static const struct accu accu_yuv[4] = {
+		{  0, 1, 0, 1,  0, 1, 0, 1 },
+		{  0, 1, 0, 1,  0, 1, 0, 1 },
+		{ -1, 1, 0, 1,  0, 1, 0, 1 },
+		{  0, 1, 0, 1, -1, 1, 0, 1 },
+	};
+
+	switch (rotation) {
+	case OMAP_DSS_ROT_0:
+		idx = 0;
+		break;
+	case OMAP_DSS_ROT_90:
+		idx = 1;
+		break;
+	case OMAP_DSS_ROT_180:
+		idx = 2;
+		break;
+	case OMAP_DSS_ROT_270:
+		idx = 3;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_NV12:
+		if (ilace)
+			accu_table = accu_nv12_ilace;
+		else
+			accu_table = accu_nv12;
+		break;
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		accu_table = accu_yuv;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	accu_val = &accu_table[idx];
+
+	chroma_hinc = 1024 * orig_width / out_width;
+	chroma_vinc = 1024 * orig_height / out_height;
+
+	h_accu2_0 = (accu_val->h0_m * chroma_hinc / accu_val->h0_n) % 1024;
+	h_accu2_1 = (accu_val->h1_m * chroma_hinc / accu_val->h1_n) % 1024;
+	v_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;
+	v_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;
+
+	dispc_ovl_set_vid_accu2_0(plane, h_accu2_0, v_accu2_0);
+	dispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);
+}
+
+static void dispc_ovl_set_scaling_common(enum omap_plane plane,
+		u16 orig_width, u16 orig_height,
+		u16 out_width, u16 out_height,
+		bool ilace, bool five_taps,
+		bool fieldmode, enum omap_color_mode color_mode,
+		u8 rotation)
+{
+	int accu0 = 0;
+	int accu1 = 0;
+	u32 l;
+
+	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
+				out_width, out_height, five_taps,
+				rotation, DISPC_COLOR_COMPONENT_RGB_Y);
+	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+
+	/* RESIZEENABLE and VERTICALTAPS */
+	l &= ~((0x3 << 5) | (0x1 << 21));
+	l |= (orig_width != out_width) ? (1 << 5) : 0;
+	l |= (orig_height != out_height) ? (1 << 6) : 0;
+	l |= five_taps ? (1 << 21) : 0;
+
+	/* VRESIZECONF and HRESIZECONF */
+	if (dss_has_feature(FEAT_RESIZECONF)) {
+		l &= ~(0x3 << 7);
+		l |= (orig_width <= out_width) ? 0 : (1 << 7);
+		l |= (orig_height <= out_height) ? 0 : (1 << 8);
+	}
+
+	/* LINEBUFFERSPLIT */
+	if (dss_has_feature(FEAT_LINEBUFFERSPLIT)) {
+		l &= ~(0x1 << 22);
+		l |= five_taps ? (1 << 22) : 0;
+	}
+
+	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	if (ilace && !fieldmode) {
+		accu1 = 0;
+		accu0 = ((1024 * orig_height / out_height) / 2) & 0x3ff;
+		if (accu0 >= 1024/2) {
+			accu1 = 1024/2;
+			accu0 -= accu1;
+		}
+	}
+
+	dispc_ovl_set_vid_accu0(plane, 0, accu0);
+	dispc_ovl_set_vid_accu1(plane, 0, accu1);
+}
+
+static void dispc_ovl_set_scaling_uv(enum omap_plane plane,
+		u16 orig_width, u16 orig_height,
+		u16 out_width, u16 out_height,
+		bool ilace, bool five_taps,
+		bool fieldmode, enum omap_color_mode color_mode,
+		u8 rotation)
+{
+	int scale_x = out_width != orig_width;
+	int scale_y = out_height != orig_height;
+	bool chroma_upscale = plane != OMAP_DSS_WB ? true : false;
+
+	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
+		return;
+	if ((color_mode != OMAP_DSS_COLOR_YUV2 &&
+			color_mode != OMAP_DSS_COLOR_UYVY &&
+			color_mode != OMAP_DSS_COLOR_NV12)) {
+		/* reset chroma resampling for RGB formats  */
+		if (plane != OMAP_DSS_WB)
+			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
+		return;
+	}
+
+	dispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,
+			out_height, ilace, color_mode, rotation);
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_NV12:
+		if (chroma_upscale) {
+			/* UV is subsampled by 2 horizontally and vertically */
+			orig_height >>= 1;
+			orig_width >>= 1;
+		} else {
+			/* UV is downsampled by 2 horizontally and vertically */
+			orig_height <<= 1;
+			orig_width <<= 1;
+		}
+
+		break;
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		/* For YUV422 with 90/270 rotation, we don't upsample chroma */
+		if (rotation == OMAP_DSS_ROT_0 ||
+				rotation == OMAP_DSS_ROT_180) {
+			if (chroma_upscale)
+				/* UV is subsampled by 2 horizontally */
+				orig_width >>= 1;
+			else
+				/* UV is downsampled by 2 horizontally */
+				orig_width <<= 1;
+		}
+
+		/* must use FIR for YUV422 if rotated */
+		if (rotation != OMAP_DSS_ROT_0)
+			scale_x = scale_y = true;
+
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (out_width != orig_width)
+		scale_x = true;
+	if (out_height != orig_height)
+		scale_y = true;
+
+	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
+			out_width, out_height, five_taps,
+				rotation, DISPC_COLOR_COMPONENT_UV);
+
+	if (plane != OMAP_DSS_WB)
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane),
+			(scale_x || scale_y) ? 1 : 0, 8, 8);
+
+	/* set H scaling */
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);
+	/* set V scaling */
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
+}
+
+static void dispc_ovl_set_scaling(enum omap_plane plane,
+		u16 orig_width, u16 orig_height,
+		u16 out_width, u16 out_height,
+		bool ilace, bool five_taps,
+		bool fieldmode, enum omap_color_mode color_mode,
+		u8 rotation)
+{
+	BUG_ON(plane == OMAP_DSS_GFX);
+
+	dispc_ovl_set_scaling_common(plane,
+			orig_width, orig_height,
+			out_width, out_height,
+			ilace, five_taps,
+			fieldmode, color_mode,
+			rotation);
+
+	dispc_ovl_set_scaling_uv(plane,
+		orig_width, orig_height,
+		out_width, out_height,
+		ilace, five_taps,
+		fieldmode, color_mode,
+		rotation);
+}
+
+static void dispc_ovl_set_rotation_attrs(enum omap_plane plane, u8 rotation,
+		enum omap_dss_rotation_type rotation_type,
+		bool mirroring, enum omap_color_mode color_mode)
+{
+	bool row_repeat = false;
+	int vidrot = 0;
+
+	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY) {
+
+		if (mirroring) {
+			switch (rotation) {
+			case OMAP_DSS_ROT_0:
+				vidrot = 2;
+				break;
+			case OMAP_DSS_ROT_90:
+				vidrot = 1;
+				break;
+			case OMAP_DSS_ROT_180:
+				vidrot = 0;
+				break;
+			case OMAP_DSS_ROT_270:
+				vidrot = 3;
+				break;
+			}
+		} else {
+			switch (rotation) {
+			case OMAP_DSS_ROT_0:
+				vidrot = 0;
+				break;
+			case OMAP_DSS_ROT_90:
+				vidrot = 1;
+				break;
+			case OMAP_DSS_ROT_180:
+				vidrot = 2;
+				break;
+			case OMAP_DSS_ROT_270:
+				vidrot = 3;
+				break;
+			}
+		}
+
+		if (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)
+			row_repeat = true;
+		else
+			row_repeat = false;
+	}
+
+	/*
+	 * OMAP4/5 Errata i631:
+	 * NV12 in 1D mode must use ROTATION=1. Otherwise DSS will fetch extra
+	 * rows beyond the framebuffer, which may cause OCP error.
+	 */
+	if (color_mode == OMAP_DSS_COLOR_NV12 &&
+			rotation_type != OMAP_DSS_ROT_TILER)
+		vidrot = 1;
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
+	if (dss_has_feature(FEAT_ROWREPEATENABLE))
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
+			row_repeat ? 1 : 0, 18, 18);
+
+	if (color_mode == OMAP_DSS_COLOR_NV12) {
+		bool doublestride = (rotation_type == OMAP_DSS_ROT_TILER) &&
+					(rotation == OMAP_DSS_ROT_0 ||
+					rotation == OMAP_DSS_ROT_180);
+		/* DOUBLESTRIDE */
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
+	}
+
+}
+
+static int color_mode_to_bpp(enum omap_color_mode color_mode)
+{
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+		return 1;
+	case OMAP_DSS_COLOR_CLUT2:
+		return 2;
+	case OMAP_DSS_COLOR_CLUT4:
+		return 4;
+	case OMAP_DSS_COLOR_CLUT8:
+	case OMAP_DSS_COLOR_NV12:
+		return 8;
+	case OMAP_DSS_COLOR_RGB12U:
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_ARGB16:
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_RGBA16:
+	case OMAP_DSS_COLOR_RGBX16:
+	case OMAP_DSS_COLOR_ARGB16_1555:
+	case OMAP_DSS_COLOR_XRGB16_1555:
+		return 16;
+	case OMAP_DSS_COLOR_RGB24P:
+		return 24;
+	case OMAP_DSS_COLOR_RGB24U:
+	case OMAP_DSS_COLOR_ARGB32:
+	case OMAP_DSS_COLOR_RGBA32:
+	case OMAP_DSS_COLOR_RGBX32:
+		return 32;
+	default:
+		BUG();
+		return 0;
+	}
+}
+
+static s32 pixinc(int pixels, u8 ps)
+{
+	if (pixels == 1)
+		return 1;
+	else if (pixels > 1)
+		return 1 + (pixels - 1) * ps;
+	else if (pixels < 0)
+		return 1 - (-pixels + 1) * ps;
+	else
+		BUG();
+		return 0;
+}
+
+static void calc_vrfb_rotation_offset(u8 rotation, bool mirror,
+		u16 screen_width,
+		u16 width, u16 height,
+		enum omap_color_mode color_mode, bool fieldmode,
+		unsigned int field_offset,
+		unsigned *offset0, unsigned *offset1,
+		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
+{
+	u8 ps;
+
+	/* FIXME CLUT formats */
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+	case OMAP_DSS_COLOR_CLUT2:
+	case OMAP_DSS_COLOR_CLUT4:
+	case OMAP_DSS_COLOR_CLUT8:
+		BUG();
+		return;
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		ps = 4;
+		break;
+	default:
+		ps = color_mode_to_bpp(color_mode) / 8;
+		break;
+	}
+
+	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
+			width, height);
+
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	switch (rotation + mirror * 4) {
+	case OMAP_DSS_ROT_0:
+	case OMAP_DSS_ROT_180:
+		/*
+		 * If the pixel format is YUV or UYVY divide the width
+		 * of the image by 2 for 0 and 180 degree rotation.
+		 */
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			width = width >> 1;
+	case OMAP_DSS_ROT_90:
+	case OMAP_DSS_ROT_270:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = field_offset * screen_width * ps;
+		else
+			*offset0 = 0;
+
+		*row_inc = pixinc(1 +
+			(y_predecim * screen_width - x_predecim * width) +
+			(fieldmode ? screen_width : 0), ps);
+		*pix_inc = pixinc(x_predecim, ps);
+		break;
+
+	case OMAP_DSS_ROT_0 + 4:
+	case OMAP_DSS_ROT_180 + 4:
+		/* If the pixel format is YUV or UYVY divide the width
+		 * of the image by 2  for 0 degree and 180 degree
+		 */
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			width = width >> 1;
+	case OMAP_DSS_ROT_90 + 4:
+	case OMAP_DSS_ROT_270 + 4:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = field_offset * screen_width * ps;
+		else
+			*offset0 = 0;
+		*row_inc = pixinc(1 -
+			(y_predecim * screen_width + x_predecim * width) -
+			(fieldmode ? screen_width : 0), ps);
+		*pix_inc = pixinc(x_predecim, ps);
+		break;
+
+	default:
+		BUG();
+		return;
+	}
+}
+
+static void calc_dma_rotation_offset(u8 rotation, bool mirror,
+		u16 screen_width,
+		u16 width, u16 height,
+		enum omap_color_mode color_mode, bool fieldmode,
+		unsigned int field_offset,
+		unsigned *offset0, unsigned *offset1,
+		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
+{
+	u8 ps;
+	u16 fbw, fbh;
+
+	/* FIXME CLUT formats */
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+	case OMAP_DSS_COLOR_CLUT2:
+	case OMAP_DSS_COLOR_CLUT4:
+	case OMAP_DSS_COLOR_CLUT8:
+		BUG();
+		return;
+	default:
+		ps = color_mode_to_bpp(color_mode) / 8;
+		break;
+	}
+
+	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
+			width, height);
+
+	/* width & height are overlay sizes, convert to fb sizes */
+
+	if (rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180) {
+		fbw = width;
+		fbh = height;
+	} else {
+		fbw = height;
+		fbh = width;
+	}
+
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	switch (rotation + mirror * 4) {
+	case OMAP_DSS_ROT_0:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * screen_width * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(1 +
+			(y_predecim * screen_width - fbw * x_predecim) +
+			(fieldmode ? screen_width : 0),	ps);
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			*pix_inc = pixinc(x_predecim, 2 * ps);
+		else
+			*pix_inc = pixinc(x_predecim, ps);
+		break;
+	case OMAP_DSS_ROT_90:
+		*offset1 = screen_width * (fbh - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) +
+				y_predecim + (fieldmode ? 1 : 0), ps);
+		*pix_inc = pixinc(-x_predecim * screen_width, ps);
+		break;
+	case OMAP_DSS_ROT_180:
+		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * screen_width * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(-1 -
+			(y_predecim * screen_width - fbw * x_predecim) -
+			(fieldmode ? screen_width : 0),	ps);
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			*pix_inc = pixinc(-x_predecim, 2 * ps);
+		else
+			*pix_inc = pixinc(-x_predecim, ps);
+		break;
+	case OMAP_DSS_ROT_270:
+		*offset1 = (fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) -
+				y_predecim - (fieldmode ? 1 : 0), ps);
+		*pix_inc = pixinc(x_predecim * screen_width, ps);
+		break;
+
+	/* mirroring */
+	case OMAP_DSS_ROT_0 + 4:
+		*offset1 = (fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * screen_width * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(y_predecim * screen_width * 2 - 1 +
+				(fieldmode ? screen_width : 0),
+				ps);
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			*pix_inc = pixinc(-x_predecim, 2 * ps);
+		else
+			*pix_inc = pixinc(-x_predecim, ps);
+		break;
+
+	case OMAP_DSS_ROT_90 + 4:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) +
+				y_predecim + (fieldmode ? 1 : 0),
+				ps);
+		*pix_inc = pixinc(x_predecim * screen_width, ps);
+		break;
+
+	case OMAP_DSS_ROT_180 + 4:
+		*offset1 = screen_width * (fbh - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * screen_width * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(1 - y_predecim * screen_width * 2 -
+				(fieldmode ? screen_width : 0),
+				ps);
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			*pix_inc = pixinc(x_predecim, 2 * ps);
+		else
+			*pix_inc = pixinc(x_predecim, ps);
+		break;
+
+	case OMAP_DSS_ROT_270 + 4:
+		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * ps;
+		else
+			*offset0 = *offset1;
+		*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) -
+				y_predecim - (fieldmode ? 1 : 0),
+				ps);
+		*pix_inc = pixinc(-x_predecim * screen_width, ps);
+		break;
+
+	default:
+		BUG();
+		return;
+	}
+}
+
+static void calc_tiler_rotation_offset(u16 screen_width, u16 width,
+		enum omap_color_mode color_mode, bool fieldmode,
+		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
+		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
+{
+	u8 ps;
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+	case OMAP_DSS_COLOR_CLUT2:
+	case OMAP_DSS_COLOR_CLUT4:
+	case OMAP_DSS_COLOR_CLUT8:
+		BUG();
+		return;
+	default:
+		ps = color_mode_to_bpp(color_mode) / 8;
+		break;
+	}
+
+	DSSDBG("scrw %d, width %d\n", screen_width, width);
+
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	*offset1 = 0;
+	if (field_offset)
+		*offset0 = *offset1 + field_offset * screen_width * ps;
+	else
+		*offset0 = *offset1;
+	*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +
+			(fieldmode ? screen_width : 0), ps);
+	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+		color_mode == OMAP_DSS_COLOR_UYVY)
+		*pix_inc = pixinc(x_predecim, 2 * ps);
+	else
+		*pix_inc = pixinc(x_predecim, ps);
+}
+
+/*
+ * This function is used to avoid synclosts in OMAP3, because of some
+ * undocumented horizontal position and timing related limitations.
+ */
+static int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,
+		const struct omap_video_timings *t, u16 pos_x,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		bool five_taps)
+{
+	const int ds = DIV_ROUND_UP(height, out_height);
+	unsigned long nonactive;
+	static const u8 limits[3] = { 8, 10, 20 };
+	u64 val, blank;
+	int i;
+
+	nonactive = t->x_res + t->hfp + t->hsw + t->hbp - out_width;
+
+	i = 0;
+	if (out_height < height)
+		i++;
+	if (out_width < width)
+		i++;
+	blank = div_u64((u64)(t->hbp + t->hsw + t->hfp) * lclk, pclk);
+	DSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);
+	if (blank <= limits[i])
+		return -EINVAL;
+
+	/* FIXME add checks for 3-tap filter once the limitations are known */
+	if (!five_taps)
+		return 0;
+
+	/*
+	 * Pixel data should be prepared before visible display point starts.
+	 * So, atleast DS-2 lines must have already been fetched by DISPC
+	 * during nonactive - pos_x period.
+	 */
+	val = div_u64((u64)(nonactive - pos_x) * lclk, pclk);
+	DSSDBG("(nonactive - pos_x) * pcd = %llu max(0, DS - 2) * width = %d\n",
+		val, max(0, ds - 2) * width);
+	if (val < max(0, ds - 2) * width)
+		return -EINVAL;
+
+	/*
+	 * All lines need to be refilled during the nonactive period of which
+	 * only one line can be loaded during the active period. So, atleast
+	 * DS - 1 lines should be loaded during nonactive period.
+	 */
+	val =  div_u64((u64)nonactive * lclk, pclk);
+	DSSDBG("nonactive * pcd  = %llu, max(0, DS - 1) * width = %d\n",
+		val, max(0, ds - 1) * width);
+	if (val < max(0, ds - 1) * width)
+		return -EINVAL;
+
+	return 0;
+}
+
+static unsigned long calc_core_clk_five_taps(unsigned long pclk,
+		const struct omap_video_timings *mgr_timings, u16 width,
+		u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode)
+{
+	u32 core_clk = 0;
+	u64 tmp;
+
+	if (height <= out_height && width <= out_width)
+		return (unsigned long) pclk;
+
+	if (height > out_height) {
+		unsigned int ppl = mgr_timings->x_res;
+
+		tmp = (u64)pclk * height * out_width;
+		do_div(tmp, 2 * out_height * ppl);
+		core_clk = tmp;
+
+		if (height > 2 * out_height) {
+			if (ppl == out_width)
+				return 0;
+
+			tmp = (u64)pclk * (height - 2 * out_height) * out_width;
+			do_div(tmp, 2 * out_height * (ppl - out_width));
+			core_clk = max_t(u32, core_clk, tmp);
+		}
+	}
+
+	if (width > out_width) {
+		tmp = (u64)pclk * width;
+		do_div(tmp, out_width);
+		core_clk = max_t(u32, core_clk, tmp);
+
+		if (color_mode == OMAP_DSS_COLOR_RGB24U)
+			core_clk <<= 1;
+	}
+
+	return core_clk;
+}
+
+static unsigned long calc_core_clk_24xx(unsigned long pclk, u16 width,
+		u16 height, u16 out_width, u16 out_height, bool mem_to_mem)
+{
+	if (height > out_height && width > out_width)
+		return pclk * 4;
+	else
+		return pclk * 2;
+}
+
+static unsigned long calc_core_clk_34xx(unsigned long pclk, u16 width,
+		u16 height, u16 out_width, u16 out_height, bool mem_to_mem)
+{
+	unsigned int hf, vf;
+
+	/*
+	 * FIXME how to determine the 'A' factor
+	 * for the no downscaling case ?
+	 */
+
+	if (width > 3 * out_width)
+		hf = 4;
+	else if (width > 2 * out_width)
+		hf = 3;
+	else if (width > out_width)
+		hf = 2;
+	else
+		hf = 1;
+	if (height > out_height)
+		vf = 2;
+	else
+		vf = 1;
+
+	return pclk * vf * hf;
+}
+
+static unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,
+		u16 height, u16 out_width, u16 out_height, bool mem_to_mem)
+{
+	/*
+	 * If the overlay/writeback is in mem to mem mode, there are no
+	 * downscaling limitations with respect to pixel clock, return 1 as
+	 * required core clock to represent that we have sufficient enough
+	 * core clock to do maximum downscaling
+	 */
+	if (mem_to_mem)
+		return 1;
+
+	if (width > out_width)
+		return DIV_ROUND_UP(pclk, out_width) * width;
+	else
+		return pclk;
+}
+
+static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
+		const struct omap_video_timings *mgr_timings,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool *five_taps,
+		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
+		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+{
+	int error;
+	u16 in_width, in_height;
+	int min_factor = min(*decim_x, *decim_y);
+	const int maxsinglelinewidth =
+			dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
+
+	*five_taps = false;
+
+	do {
+		in_height = height / *decim_y;
+		in_width = width / *decim_x;
+		*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+				in_height, out_width, out_height, mem_to_mem);
+		error = (in_width > maxsinglelinewidth || !*core_clk ||
+			*core_clk > dispc_core_clk_rate());
+		if (error) {
+			if (*decim_x == *decim_y) {
+				*decim_x = min_factor;
+				++*decim_y;
+			} else {
+				swap(*decim_x, *decim_y);
+				if (*decim_x < *decim_y)
+					++*decim_x;
+			}
+		}
+	} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);
+
+	if (error) {
+		DSSERR("failed to find scaling settings\n");
+		return -EINVAL;
+	}
+
+	if (in_width > maxsinglelinewidth) {
+		DSSERR("Cannot scale max input width exceeded");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
+		const struct omap_video_timings *mgr_timings,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool *five_taps,
+		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
+		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+{
+	int error;
+	u16 in_width, in_height;
+	const int maxsinglelinewidth =
+			dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
+
+	do {
+		in_height = height / *decim_y;
+		in_width = width / *decim_x;
+		*five_taps = in_height > out_height;
+
+		if (in_width > maxsinglelinewidth)
+			if (in_height > out_height &&
+						in_height < out_height * 2)
+				*five_taps = false;
+again:
+		if (*five_taps)
+			*core_clk = calc_core_clk_five_taps(pclk, mgr_timings,
+						in_width, in_height, out_width,
+						out_height, color_mode);
+		else
+			*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+					in_height, out_width, out_height,
+					mem_to_mem);
+
+		error = check_horiz_timing_omap3(pclk, lclk, mgr_timings,
+				pos_x, in_width, in_height, out_width,
+				out_height, *five_taps);
+		if (error && *five_taps) {
+			*five_taps = false;
+			goto again;
+		}
+
+		error = (error || in_width > maxsinglelinewidth * 2 ||
+			(in_width > maxsinglelinewidth && *five_taps) ||
+			!*core_clk || *core_clk > dispc_core_clk_rate());
+
+		if (!error) {
+			/* verify that we're inside the limits of scaler */
+			if (in_width / 4 > out_width)
+					error = 1;
+
+			if (*five_taps) {
+				if (in_height / 4 > out_height)
+					error = 1;
+			} else {
+				if (in_height / 2 > out_height)
+					error = 1;
+			}
+		}
+
+		if (error)
+			++*decim_y;
+	} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);
+
+	if (error) {
+		DSSERR("failed to find scaling settings\n");
+		return -EINVAL;
+	}
+
+	if (check_horiz_timing_omap3(pclk, lclk, mgr_timings, pos_x, in_width,
+				in_height, out_width, out_height, *five_taps)) {
+			DSSERR("horizontal timing too tight\n");
+			return -EINVAL;
+	}
+
+	if (in_width > (maxsinglelinewidth * 2)) {
+		DSSERR("Cannot setup scaling");
+		DSSERR("width exceeds maximum width possible");
+		return -EINVAL;
+	}
+
+	if (in_width > maxsinglelinewidth && *five_taps) {
+		DSSERR("cannot setup scaling with five taps");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
+		const struct omap_video_timings *mgr_timings,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool *five_taps,
+		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
+		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+{
+	u16 in_width, in_width_max;
+	int decim_x_min = *decim_x;
+	u16 in_height = height / *decim_y;
+	const int maxsinglelinewidth =
+				dss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);
+	const int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);
+
+	if (mem_to_mem) {
+		in_width_max = out_width * maxdownscale;
+	} else {
+		in_width_max = dispc_core_clk_rate() /
+					DIV_ROUND_UP(pclk, out_width);
+	}
+
+	*decim_x = DIV_ROUND_UP(width, in_width_max);
+
+	*decim_x = *decim_x > decim_x_min ? *decim_x : decim_x_min;
+	if (*decim_x > *x_predecim)
+		return -EINVAL;
+
+	do {
+		in_width = width / *decim_x;
+	} while (*decim_x <= *x_predecim &&
+			in_width > maxsinglelinewidth && ++*decim_x);
+
+	if (in_width > maxsinglelinewidth) {
+		DSSERR("Cannot scale width exceeds max line width");
+		return -EINVAL;
+	}
+
+	*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,
+				out_width, out_height, mem_to_mem);
+	return 0;
+}
+
+#define DIV_FRAC(dividend, divisor) \
+	((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))
+
+static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
+		enum omap_overlay_caps caps,
+		const struct omap_video_timings *mgr_timings,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool *five_taps,
+		int *x_predecim, int *y_predecim, u16 pos_x,
+		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
+{
+	const int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);
+	const int max_decim_limit = 16;
+	unsigned long core_clk = 0;
+	int decim_x, decim_y, ret;
+
+	if (width == out_width && height == out_height)
+		return 0;
+
+	if (!mem_to_mem && (pclk == 0 || mgr_timings->pixelclock == 0)) {
+		DSSERR("cannot calculate scaling settings: pclk is zero\n");
+		return -EINVAL;
+	}
+
+	if ((caps & OMAP_DSS_OVL_CAP_SCALE) == 0)
+		return -EINVAL;
+
+	if (mem_to_mem) {
+		*x_predecim = *y_predecim = 1;
+	} else {
+		*x_predecim = max_decim_limit;
+		*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&
+				dss_has_feature(FEAT_BURST_2D)) ?
+				2 : max_decim_limit;
+	}
+
+	if (color_mode == OMAP_DSS_COLOR_CLUT1 ||
+	    color_mode == OMAP_DSS_COLOR_CLUT2 ||
+	    color_mode == OMAP_DSS_COLOR_CLUT4 ||
+	    color_mode == OMAP_DSS_COLOR_CLUT8) {
+		*x_predecim = 1;
+		*y_predecim = 1;
+		*five_taps = false;
+		return 0;
+	}
+
+	decim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxdownscale);
+	decim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxdownscale);
+
+	if (decim_x > *x_predecim || out_width > width * 8)
+		return -EINVAL;
+
+	if (decim_y > *y_predecim || out_height > height * 8)
+		return -EINVAL;
+
+	ret = dispc.feat->calc_scaling(pclk, lclk, mgr_timings, width, height,
+		out_width, out_height, color_mode, five_taps,
+		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
+		mem_to_mem);
+	if (ret)
+		return ret;
+
+	DSSDBG("%dx%d -> %dx%d (%d.%02d x %d.%02d), decim %dx%d %dx%d (%d.%02d x %d.%02d), taps %d, req clk %lu, cur clk %lu\n",
+		width, height,
+		out_width, out_height,
+		out_width / width, DIV_FRAC(out_width, width),
+		out_height / height, DIV_FRAC(out_height, height),
+
+		decim_x, decim_y,
+		width / decim_x, height / decim_y,
+		out_width / (width / decim_x), DIV_FRAC(out_width, width / decim_x),
+		out_height / (height / decim_y), DIV_FRAC(out_height, height / decim_y),
+
+		*five_taps ? 5 : 3,
+		core_clk, dispc_core_clk_rate());
+
+	if (!core_clk || core_clk > dispc_core_clk_rate()) {
+		DSSERR("failed to set up scaling, "
+			"required core clk rate = %lu Hz, "
+			"current core clk rate = %lu Hz\n",
+			core_clk, dispc_core_clk_rate());
+		return -EINVAL;
+	}
+
+	*x_predecim = decim_x;
+	*y_predecim = decim_y;
+	return 0;
+}
+
+int dispc_ovl_check(enum omap_plane plane, enum omap_channel channel,
+		const struct omap_overlay_info *oi,
+		const struct omap_video_timings *timings,
+		int *x_predecim, int *y_predecim)
+{
+	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
+	bool five_taps = true;
+	bool fieldmode = false;
+	u16 in_height = oi->height;
+	u16 in_width = oi->width;
+	bool ilace = timings->interlace;
+	u16 out_width, out_height;
+	int pos_x = oi->pos_x;
+	unsigned long pclk = dispc_mgr_pclk_rate(channel);
+	unsigned long lclk = dispc_mgr_lclk_rate(channel);
+
+	out_width = oi->out_width == 0 ? oi->width : oi->out_width;
+	out_height = oi->out_height == 0 ? oi->height : oi->out_height;
+
+	if (ilace && oi->height == out_height)
+		fieldmode = true;
+
+	if (ilace) {
+		if (fieldmode)
+			in_height /= 2;
+		out_height /= 2;
+
+		DSSDBG("adjusting for ilace: height %d, out_height %d\n",
+				in_height, out_height);
+	}
+
+	if (!dss_feat_color_mode_supported(plane, oi->color_mode))
+		return -EINVAL;
+
+	return dispc_ovl_calc_scaling(pclk, lclk, caps, timings, in_width,
+			in_height, out_width, out_height, oi->color_mode,
+			&five_taps, x_predecim, y_predecim, pos_x,
+			oi->rotation_type, false);
+}
+EXPORT_SYMBOL(dispc_ovl_check);
+
+static int dispc_ovl_setup_common(enum omap_plane plane,
+		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
+		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
+		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
+		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
+		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
+		bool replication, const struct omap_video_timings *mgr_timings,
+		bool mem_to_mem)
+{
+	bool five_taps = true;
+	bool fieldmode = false;
+	int r, cconv = 0;
+	unsigned offset0, offset1;
+	s32 row_inc;
+	s32 pix_inc;
+	u16 frame_width, frame_height;
+	unsigned int field_offset = 0;
+	u16 in_height = height;
+	u16 in_width = width;
+	int x_predecim = 1, y_predecim = 1;
+	bool ilace = mgr_timings->interlace;
+	unsigned long pclk = dispc_plane_pclk_rate(plane);
+	unsigned long lclk = dispc_plane_lclk_rate(plane);
+
+	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
+		return -EINVAL;
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_NV12:
+		if (in_width & 1) {
+			DSSERR("input width %d is not even for YUV format\n",
+				in_width);
+			return -EINVAL;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	out_width = out_width == 0 ? width : out_width;
+	out_height = out_height == 0 ? height : out_height;
+
+	if (ilace && height == out_height)
+		fieldmode = true;
+
+	if (ilace) {
+		if (fieldmode)
+			in_height /= 2;
+		pos_y /= 2;
+		out_height /= 2;
+
+		DSSDBG("adjusting for ilace: height %d, pos_y %d, "
+			"out_height %d\n", in_height, pos_y,
+			out_height);
+	}
+
+	if (!dss_feat_color_mode_supported(plane, color_mode))
+		return -EINVAL;
+
+	r = dispc_ovl_calc_scaling(pclk, lclk, caps, mgr_timings, in_width,
+			in_height, out_width, out_height, color_mode,
+			&five_taps, &x_predecim, &y_predecim, pos_x,
+			rotation_type, mem_to_mem);
+	if (r)
+		return r;
+
+	in_width = in_width / x_predecim;
+	in_height = in_height / y_predecim;
+
+	if (x_predecim > 1 || y_predecim > 1)
+		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
+			x_predecim, y_predecim, in_width, in_height);
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_NV12:
+		if (in_width & 1) {
+			DSSDBG("predecimated input width is not even for YUV format\n");
+			DSSDBG("adjusting input width %d -> %d\n",
+				in_width, in_width & ~1);
+
+			in_width &= ~1;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY ||
+			color_mode == OMAP_DSS_COLOR_NV12)
+		cconv = 1;
+
+	if (ilace && !fieldmode) {
+		/*
+		 * when downscaling the bottom field may have to start several
+		 * source lines below the top field. Unfortunately ACCUI
+		 * registers will only hold the fractional part of the offset
+		 * so the integer part must be added to the base address of the
+		 * bottom field.
+		 */
+		if (!in_height || in_height == out_height)
+			field_offset = 0;
+		else
+			field_offset = in_height / out_height / 2;
+	}
+
+	/* Fields are independent but interleaved in memory. */
+	if (fieldmode)
+		field_offset = 1;
+
+	offset0 = 0;
+	offset1 = 0;
+	row_inc = 0;
+	pix_inc = 0;
+
+	if (plane == OMAP_DSS_WB) {
+		frame_width = out_width;
+		frame_height = out_height;
+	} else {
+		frame_width = in_width;
+		frame_height = height;
+	}
+
+	if (rotation_type == OMAP_DSS_ROT_TILER)
+		calc_tiler_rotation_offset(screen_width, frame_width,
+				color_mode, fieldmode, field_offset,
+				&offset0, &offset1, &row_inc, &pix_inc,
+				x_predecim, y_predecim);
+	else if (rotation_type == OMAP_DSS_ROT_DMA)
+		calc_dma_rotation_offset(rotation, mirror, screen_width,
+				frame_width, frame_height,
+				color_mode, fieldmode, field_offset,
+				&offset0, &offset1, &row_inc, &pix_inc,
+				x_predecim, y_predecim);
+	else
+		calc_vrfb_rotation_offset(rotation, mirror,
+				screen_width, frame_width, frame_height,
+				color_mode, fieldmode, field_offset,
+				&offset0, &offset1, &row_inc, &pix_inc,
+				x_predecim, y_predecim);
+
+	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
+			offset0, offset1, row_inc, pix_inc);
+
+	dispc_ovl_set_color_mode(plane, color_mode);
+
+	dispc_ovl_configure_burst_type(plane, rotation_type);
+
+	dispc_ovl_set_ba0(plane, paddr + offset0);
+	dispc_ovl_set_ba1(plane, paddr + offset1);
+
+	if (OMAP_DSS_COLOR_NV12 == color_mode) {
+		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
+		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
+	}
+
+	if (dispc.feat->last_pixel_inc_missing)
+		row_inc += pix_inc - 1;
+
+	dispc_ovl_set_row_inc(plane, row_inc);
+	dispc_ovl_set_pix_inc(plane, pix_inc);
+
+	DSSDBG("%d,%d %dx%d -> %dx%d\n", pos_x, pos_y, in_width,
+			in_height, out_width, out_height);
+
+	dispc_ovl_set_pos(plane, caps, pos_x, pos_y);
+
+	dispc_ovl_set_input_size(plane, in_width, in_height);
+
+	if (caps & OMAP_DSS_OVL_CAP_SCALE) {
+		dispc_ovl_set_scaling(plane, in_width, in_height, out_width,
+				   out_height, ilace, five_taps, fieldmode,
+				   color_mode, rotation);
+		dispc_ovl_set_output_size(plane, out_width, out_height);
+		dispc_ovl_set_vid_color_conv(plane, cconv);
+	}
+
+	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, mirror,
+			color_mode);
+
+	dispc_ovl_set_zorder(plane, caps, zorder);
+	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
+	dispc_ovl_setup_global_alpha(plane, caps, global_alpha);
+
+	dispc_ovl_enable_replication(plane, caps, replication);
+
+	return 0;
+}
+
+int dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,
+		bool replication, const struct omap_video_timings *mgr_timings,
+		bool mem_to_mem)
+{
+	int r;
+	enum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);
+	enum omap_channel channel;
+
+	channel = dispc_ovl_get_channel_out(plane);
+
+	DSSDBG("dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->"
+		" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",
+		plane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,
+		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
+		oi->color_mode, oi->rotation, oi->mirror, channel, replication);
+
+	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
+		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
+		oi->out_width, oi->out_height, oi->color_mode, oi->rotation,
+		oi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
+		oi->rotation_type, replication, mgr_timings, mem_to_mem);
+
+	return r;
+}
+EXPORT_SYMBOL(dispc_ovl_setup);
+
+int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
+		bool mem_to_mem, const struct omap_video_timings *mgr_timings)
+{
+	int r;
+	u32 l;
+	enum omap_plane plane = OMAP_DSS_WB;
+	const int pos_x = 0, pos_y = 0;
+	const u8 zorder = 0, global_alpha = 0;
+	const bool replication = false;
+	bool truncation;
+	int in_width = mgr_timings->x_res;
+	int in_height = mgr_timings->y_res;
+	enum omap_overlay_caps caps =
+		OMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;
+
+	DSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "
+		"rot %d, mir %d\n", wi->paddr, wi->p_uv_addr, in_width,
+		in_height, wi->width, wi->height, wi->color_mode, wi->rotation,
+		wi->mirror);
+
+	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
+		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
+		wi->height, wi->color_mode, wi->rotation, wi->mirror, zorder,
+		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
+		replication, mgr_timings, mem_to_mem);
+
+	switch (wi->color_mode) {
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_RGB24P:
+	case OMAP_DSS_COLOR_ARGB16:
+	case OMAP_DSS_COLOR_RGBA16:
+	case OMAP_DSS_COLOR_RGB12U:
+	case OMAP_DSS_COLOR_ARGB16_1555:
+	case OMAP_DSS_COLOR_XRGB16_1555:
+	case OMAP_DSS_COLOR_RGBX16:
+		truncation = true;
+		break;
+	default:
+		truncation = false;
+		break;
+	}
+
+	/* setup extra DISPC_WB_ATTRIBUTES */
+	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	l = FLD_MOD(l, truncation, 10, 10);	/* TRUNCATIONENABLE */
+	l = FLD_MOD(l, mem_to_mem, 19, 19);	/* WRITEBACKMODE */
+	if (mem_to_mem)
+		l = FLD_MOD(l, 1, 26, 24);	/* CAPTUREMODE */
+	else
+		l = FLD_MOD(l, 0, 26, 24);	/* CAPTUREMODE */
+	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+
+	if (mem_to_mem) {
+		/* WBDELAYCOUNT */
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
+	} else {
+		int wbdelay;
+
+		wbdelay = min(mgr_timings->vfp + mgr_timings->vsw +
+			mgr_timings->vbp, 255);
+
+		/* WBDELAYCOUNT */
+		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
+	}
+
+	return r;
+}
+
+int dispc_ovl_enable(enum omap_plane plane, bool enable)
+{
+	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
+
+	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(dispc_ovl_enable);
+
+bool dispc_ovl_enabled(enum omap_plane plane)
+{
+	return REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);
+}
+EXPORT_SYMBOL(dispc_ovl_enabled);
+
+void dispc_mgr_enable(enum omap_channel channel, bool enable)
+{
+	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
+	/* flush posted write */
+	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+}
+EXPORT_SYMBOL(dispc_mgr_enable);
+
+bool dispc_mgr_is_enabled(enum omap_channel channel)
+{
+	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+}
+EXPORT_SYMBOL(dispc_mgr_is_enabled);
+
+void dispc_wb_enable(bool enable)
+{
+	dispc_ovl_enable(OMAP_DSS_WB, enable);
+}
+
+bool dispc_wb_is_enabled(void)
+{
+	return dispc_ovl_enabled(OMAP_DSS_WB);
+}
+
+static void dispc_lcd_enable_signal_polarity(bool act_high)
+{
+	if (!dss_has_feature(FEAT_LCDENABLEPOL))
+		return;
+
+	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
+}
+
+void dispc_lcd_enable_signal(bool enable)
+{
+	if (!dss_has_feature(FEAT_LCDENABLESIGNAL))
+		return;
+
+	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
+}
+
+void dispc_pck_free_enable(bool enable)
+{
+	if (!dss_has_feature(FEAT_PCKFREEENABLE))
+		return;
+
+	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
+}
+
+static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
+{
+	mgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
+}
+
+
+static void dispc_mgr_set_lcd_type_tft(enum omap_channel channel)
+{
+	mgr_fld_write(channel, DISPC_MGR_FLD_STNTFT, 1);
+}
+
+static void dispc_set_loadmode(enum omap_dss_load_mode mode)
+{
+	REG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);
+}
+
+
+static void dispc_mgr_set_default_color(enum omap_channel channel, u32 color)
+{
+	dispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);
+}
+
+static void dispc_mgr_set_trans_key(enum omap_channel ch,
+		enum omap_dss_trans_key_type type,
+		u32 trans_key)
+{
+	mgr_fld_write(ch, DISPC_MGR_FLD_TCKSELECTION, type);
+
+	dispc_write_reg(DISPC_TRANS_COLOR(ch), trans_key);
+}
+
+static void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)
+{
+	mgr_fld_write(ch, DISPC_MGR_FLD_TCKENABLE, enable);
+}
+
+static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
+		bool enable)
+{
+	if (!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))
+		return;
+
+	if (ch == OMAP_DSS_CHANNEL_LCD)
+		REG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);
+	else if (ch == OMAP_DSS_CHANNEL_DIGIT)
+		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
+}
+
+void dispc_mgr_setup(enum omap_channel channel,
+		const struct omap_overlay_manager_info *info)
+{
+	dispc_mgr_set_default_color(channel, info->default_color);
+	dispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);
+	dispc_mgr_enable_trans_key(channel, info->trans_enabled);
+	dispc_mgr_enable_alpha_fixed_zorder(channel,
+			info->partial_alpha_enabled);
+	if (dss_has_feature(FEAT_CPR)) {
+		dispc_mgr_enable_cpr(channel, info->cpr_enable);
+		dispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);
+	}
+}
+EXPORT_SYMBOL(dispc_mgr_setup);
+
+static void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)
+{
+	int code;
+
+	switch (data_lines) {
+	case 12:
+		code = 0;
+		break;
+	case 16:
+		code = 1;
+		break;
+	case 18:
+		code = 2;
+		break;
+	case 24:
+		code = 3;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	mgr_fld_write(channel, DISPC_MGR_FLD_TFTDATALINES, code);
+}
+
+static void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)
+{
+	u32 l;
+	int gpout0, gpout1;
+
+	switch (mode) {
+	case DSS_IO_PAD_MODE_RESET:
+		gpout0 = 0;
+		gpout1 = 0;
+		break;
+	case DSS_IO_PAD_MODE_RFBI:
+		gpout0 = 1;
+		gpout1 = 0;
+		break;
+	case DSS_IO_PAD_MODE_BYPASS:
+		gpout0 = 1;
+		gpout1 = 1;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	l = dispc_read_reg(DISPC_CONTROL);
+	l = FLD_MOD(l, gpout0, 15, 15);
+	l = FLD_MOD(l, gpout1, 16, 16);
+	dispc_write_reg(DISPC_CONTROL, l);
+}
+
+static void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)
+{
+	mgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);
+}
+
+void dispc_mgr_set_lcd_config(enum omap_channel channel,
+		const struct dss_lcd_mgr_config *config)
+{
+	dispc_mgr_set_io_pad_mode(config->io_pad_mode);
+
+	dispc_mgr_enable_stallmode(channel, config->stallmode);
+	dispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);
+
+	dispc_mgr_set_clock_div(channel, &config->clock_info);
+
+	dispc_mgr_set_tft_data_lines(channel, config->video_port_width);
+
+	dispc_lcd_enable_signal_polarity(config->lcden_sig_polarity);
+
+	dispc_mgr_set_lcd_type_tft(channel);
+}
+EXPORT_SYMBOL(dispc_mgr_set_lcd_config);
+
+static bool _dispc_mgr_size_ok(u16 width, u16 height)
+{
+	return width <= dispc.feat->mgr_width_max &&
+		height <= dispc.feat->mgr_height_max;
+}
+
+static bool _dispc_lcd_timings_ok(int hsw, int hfp, int hbp,
+		int vsw, int vfp, int vbp)
+{
+	if (hsw < 1 || hsw > dispc.feat->sw_max ||
+			hfp < 1 || hfp > dispc.feat->hp_max ||
+			hbp < 1 || hbp > dispc.feat->hp_max ||
+			vsw < 1 || vsw > dispc.feat->sw_max ||
+			vfp < 0 || vfp > dispc.feat->vp_max ||
+			vbp < 0 || vbp > dispc.feat->vp_max)
+		return false;
+	return true;
+}
+
+static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
+		unsigned long pclk)
+{
+	if (dss_mgr_is_lcd(channel))
+		return pclk <= dispc.feat->max_lcd_pclk ? true : false;
+	else
+		return pclk <= dispc.feat->max_tv_pclk ? true : false;
+}
+
+bool dispc_mgr_timings_ok(enum omap_channel channel,
+		const struct omap_video_timings *timings)
+{
+	if (!_dispc_mgr_size_ok(timings->x_res, timings->y_res))
+		return false;
+
+	if (!_dispc_mgr_pclk_ok(channel, timings->pixelclock))
+		return false;
+
+	if (dss_mgr_is_lcd(channel)) {
+		/* TODO: OMAP4+ supports interlace for LCD outputs */
+		if (timings->interlace)
+			return false;
+
+		if (!_dispc_lcd_timings_ok(timings->hsw, timings->hfp,
+				timings->hbp, timings->vsw, timings->vfp,
+				timings->vbp))
+			return false;
+	}
+
+	return true;
+}
+
+static void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsw,
+		int hfp, int hbp, int vsw, int vfp, int vbp,
+		enum omap_dss_signal_level vsync_level,
+		enum omap_dss_signal_level hsync_level,
+		enum omap_dss_signal_edge data_pclk_edge,
+		enum omap_dss_signal_level de_level,
+		enum omap_dss_signal_edge sync_pclk_edge)
+
+{
+	u32 timing_h, timing_v, l;
+	bool onoff, rf, ipc, vs, hs, de;
+
+	timing_h = FLD_VAL(hsw-1, dispc.feat->sw_start, 0) |
+			FLD_VAL(hfp-1, dispc.feat->fp_start, 8) |
+			FLD_VAL(hbp-1, dispc.feat->bp_start, 20);
+	timing_v = FLD_VAL(vsw-1, dispc.feat->sw_start, 0) |
+			FLD_VAL(vfp, dispc.feat->fp_start, 8) |
+			FLD_VAL(vbp, dispc.feat->bp_start, 20);
+
+	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
+	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
+
+	switch (vsync_level) {
+	case OMAPDSS_SIG_ACTIVE_LOW:
+		vs = true;
+		break;
+	case OMAPDSS_SIG_ACTIVE_HIGH:
+		vs = false;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (hsync_level) {
+	case OMAPDSS_SIG_ACTIVE_LOW:
+		hs = true;
+		break;
+	case OMAPDSS_SIG_ACTIVE_HIGH:
+		hs = false;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (de_level) {
+	case OMAPDSS_SIG_ACTIVE_LOW:
+		de = true;
+		break;
+	case OMAPDSS_SIG_ACTIVE_HIGH:
+		de = false;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (data_pclk_edge) {
+	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
+		ipc = false;
+		break;
+	case OMAPDSS_DRIVE_SIG_FALLING_EDGE:
+		ipc = true;
+		break;
+	default:
+		BUG();
+	}
+
+	/* always use the 'rf' setting */
+	onoff = true;
+
+	switch (sync_pclk_edge) {
+	case OMAPDSS_DRIVE_SIG_FALLING_EDGE:
+		rf = false;
+		break;
+	case OMAPDSS_DRIVE_SIG_RISING_EDGE:
+		rf = true;
+		break;
+	default:
+		BUG();
+	}
+
+	l = FLD_VAL(onoff, 17, 17) |
+		FLD_VAL(rf, 16, 16) |
+		FLD_VAL(de, 15, 15) |
+		FLD_VAL(ipc, 14, 14) |
+		FLD_VAL(hs, 13, 13) |
+		FLD_VAL(vs, 12, 12);
+
+	/* always set ALIGN bit when available */
+	if (dispc.feat->supports_sync_align)
+		l |= (1 << 18);
+
+	dispc_write_reg(DISPC_POL_FREQ(channel), l);
+
+	if (dispc.syscon_pol) {
+		const int shifts[] = {
+			[OMAP_DSS_CHANNEL_LCD] = 0,
+			[OMAP_DSS_CHANNEL_LCD2] = 1,
+			[OMAP_DSS_CHANNEL_LCD3] = 2,
+		};
+
+		u32 mask, val;
+
+		mask = (1 << 0) | (1 << 3) | (1 << 6);
+		val = (rf << 0) | (ipc << 3) | (onoff << 6);
+
+		mask <<= 16 + shifts[channel];
+		val <<= 16 + shifts[channel];
+
+		regmap_update_bits(dispc.syscon_pol, dispc.syscon_pol_offset,
+			mask, val);
+	}
+}
+
+/* change name to mode? */
+void dispc_mgr_set_timings(enum omap_channel channel,
+		const struct omap_video_timings *timings)
+{
+	unsigned xtot, ytot;
+	unsigned long ht, vt;
+	struct omap_video_timings t = *timings;
+
+	DSSDBG("channel %d xres %u yres %u\n", channel, t.x_res, t.y_res);
+
+	if (!dispc_mgr_timings_ok(channel, &t)) {
+		BUG();
+		return;
+	}
+
+	if (dss_mgr_is_lcd(channel)) {
+		_dispc_mgr_set_lcd_timings(channel, t.hsw, t.hfp, t.hbp, t.vsw,
+				t.vfp, t.vbp, t.vsync_level, t.hsync_level,
+				t.data_pclk_edge, t.de_level, t.sync_pclk_edge);
+
+		xtot = t.x_res + t.hfp + t.hsw + t.hbp;
+		ytot = t.y_res + t.vfp + t.vsw + t.vbp;
+
+		ht = timings->pixelclock / xtot;
+		vt = timings->pixelclock / xtot / ytot;
+
+		DSSDBG("pck %u\n", timings->pixelclock);
+		DSSDBG("hsw %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",
+			t.hsw, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);
+		DSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",
+			t.vsync_level, t.hsync_level, t.data_pclk_edge,
+			t.de_level, t.sync_pclk_edge);
+
+		DSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);
+	} else {
+		if (t.interlace)
+			t.y_res /= 2;
+	}
+
+	dispc_mgr_set_size(channel, t.x_res, t.y_res);
+}
+EXPORT_SYMBOL(dispc_mgr_set_timings);
+
+static void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,
+		u16 pck_div)
+{
+	BUG_ON(lck_div < 1);
+	BUG_ON(pck_div < 1);
+
+	dispc_write_reg(DISPC_DIVISORo(channel),
+			FLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));
+
+	if (!dss_has_feature(FEAT_CORE_CLK_DIV) &&
+			channel == OMAP_DSS_CHANNEL_LCD)
+		dispc.core_clk_rate = dispc_fclk_rate() / lck_div;
+}
+
+static void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,
+		int *pck_div)
+{
+	u32 l;
+	l = dispc_read_reg(DISPC_DIVISORo(channel));
+	*lck_div = FLD_GET(l, 23, 16);
+	*pck_div = FLD_GET(l, 7, 0);
+}
+
+static unsigned long dispc_fclk_rate(void)
+{
+	struct dss_pll *pll;
+	unsigned long r = 0;
+
+	switch (dss_get_dispc_clk_source()) {
+	case OMAP_DSS_CLK_SRC_FCK:
+		r = dss_get_dispc_clk_rate();
+		break;
+	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+		pll = dss_pll_find("dsi0");
+		if (!pll)
+			pll = dss_pll_find("video0");
+
+		r = pll->cinfo.clkout[0];
+		break;
+	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+		pll = dss_pll_find("dsi1");
+		if (!pll)
+			pll = dss_pll_find("video1");
+
+		r = pll->cinfo.clkout[0];
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+
+	return r;
+}
+
+static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
+{
+	struct dss_pll *pll;
+	int lcd;
+	unsigned long r;
+	u32 l;
+
+	if (dss_mgr_is_lcd(channel)) {
+		l = dispc_read_reg(DISPC_DIVISORo(channel));
+
+		lcd = FLD_GET(l, 23, 16);
+
+		switch (dss_get_lcd_clk_source(channel)) {
+		case OMAP_DSS_CLK_SRC_FCK:
+			r = dss_get_dispc_clk_rate();
+			break;
+		case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+			pll = dss_pll_find("dsi0");
+			if (!pll)
+				pll = dss_pll_find("video0");
+
+			r = pll->cinfo.clkout[0];
+			break;
+		case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+			pll = dss_pll_find("dsi1");
+			if (!pll)
+				pll = dss_pll_find("video1");
+
+			r = pll->cinfo.clkout[0];
+			break;
+		default:
+			BUG();
+			return 0;
+		}
+
+		return r / lcd;
+	} else {
+		return dispc_fclk_rate();
+	}
+}
+
+static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)
+{
+	unsigned long r;
+
+	if (dss_mgr_is_lcd(channel)) {
+		int pcd;
+		u32 l;
+
+		l = dispc_read_reg(DISPC_DIVISORo(channel));
+
+		pcd = FLD_GET(l, 7, 0);
+
+		r = dispc_mgr_lclk_rate(channel);
+
+		return r / pcd;
+	} else {
+		return dispc.tv_pclk_rate;
+	}
+}
+
+void dispc_set_tv_pclk(unsigned long pclk)
+{
+	dispc.tv_pclk_rate = pclk;
+}
+
+static unsigned long dispc_core_clk_rate(void)
+{
+	return dispc.core_clk_rate;
+}
+
+static unsigned long dispc_plane_pclk_rate(enum omap_plane plane)
+{
+	enum omap_channel channel;
+
+	if (plane == OMAP_DSS_WB)
+		return 0;
+
+	channel = dispc_ovl_get_channel_out(plane);
+
+	return dispc_mgr_pclk_rate(channel);
+}
+
+static unsigned long dispc_plane_lclk_rate(enum omap_plane plane)
+{
+	enum omap_channel channel;
+
+	if (plane == OMAP_DSS_WB)
+		return 0;
+
+	channel	= dispc_ovl_get_channel_out(plane);
+
+	return dispc_mgr_lclk_rate(channel);
+}
+
+static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)
+{
+	int lcd, pcd;
+	enum omap_dss_clk_source lcd_clk_src;
+
+	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
+
+	lcd_clk_src = dss_get_lcd_clk_source(channel);
+
+	seq_printf(s, "%s clk source = %s (%s)\n", mgr_desc[channel].name,
+		dss_get_generic_clk_source_name(lcd_clk_src),
+		dss_feat_get_clk_source_name(lcd_clk_src));
+
+	dispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);
+
+	seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
+		dispc_mgr_lclk_rate(channel), lcd);
+	seq_printf(s, "pck\t\t%-16lupck div\t%u\n",
+		dispc_mgr_pclk_rate(channel), pcd);
+}
+
+void dispc_dump_clocks(struct seq_file *s)
+{
+	int lcd;
+	u32 l;
+	enum omap_dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
+
+	if (dispc_runtime_get())
+		return;
+
+	seq_printf(s, "- DISPC -\n");
+
+	seq_printf(s, "dispc fclk source = %s (%s)\n",
+			dss_get_generic_clk_source_name(dispc_clk_src),
+			dss_feat_get_clk_source_name(dispc_clk_src));
+
+	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
+
+	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+		seq_printf(s, "- DISPC-CORE-CLK -\n");
+		l = dispc_read_reg(DISPC_DIVISOR);
+		lcd = FLD_GET(l, 23, 16);
+
+		seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
+				(dispc_fclk_rate()/lcd), lcd);
+	}
+
+	dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);
+
+	if (dss_has_feature(FEAT_MGR_LCD2))
+		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);
+	if (dss_has_feature(FEAT_MGR_LCD3))
+		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
+
+	dispc_runtime_put();
+}
+
+static void dispc_dump_regs(struct seq_file *s)
+{
+	int i, j;
+	const char *mgr_names[] = {
+		[OMAP_DSS_CHANNEL_LCD]		= "LCD",
+		[OMAP_DSS_CHANNEL_DIGIT]	= "TV",
+		[OMAP_DSS_CHANNEL_LCD2]		= "LCD2",
+		[OMAP_DSS_CHANNEL_LCD3]		= "LCD3",
+	};
+	const char *ovl_names[] = {
+		[OMAP_DSS_GFX]		= "GFX",
+		[OMAP_DSS_VIDEO1]	= "VID1",
+		[OMAP_DSS_VIDEO2]	= "VID2",
+		[OMAP_DSS_VIDEO3]	= "VID3",
+		[OMAP_DSS_WB]		= "WB",
+	};
+	const char **p_names;
+
+#define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))
+
+	if (dispc_runtime_get())
+		return;
+
+	/* DISPC common registers */
+	DUMPREG(DISPC_REVISION);
+	DUMPREG(DISPC_SYSCONFIG);
+	DUMPREG(DISPC_SYSSTATUS);
+	DUMPREG(DISPC_IRQSTATUS);
+	DUMPREG(DISPC_IRQENABLE);
+	DUMPREG(DISPC_CONTROL);
+	DUMPREG(DISPC_CONFIG);
+	DUMPREG(DISPC_CAPABLE);
+	DUMPREG(DISPC_LINE_STATUS);
+	DUMPREG(DISPC_LINE_NUMBER);
+	if (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
+			dss_has_feature(FEAT_ALPHA_FREE_ZORDER))
+		DUMPREG(DISPC_GLOBAL_ALPHA);
+	if (dss_has_feature(FEAT_MGR_LCD2)) {
+		DUMPREG(DISPC_CONTROL2);
+		DUMPREG(DISPC_CONFIG2);
+	}
+	if (dss_has_feature(FEAT_MGR_LCD3)) {
+		DUMPREG(DISPC_CONTROL3);
+		DUMPREG(DISPC_CONFIG3);
+	}
+	if (dss_has_feature(FEAT_MFLAG))
+		DUMPREG(DISPC_GLOBAL_MFLAG_ATTRIBUTE);
+
+#undef DUMPREG
+
+#define DISPC_REG(i, name) name(i)
+#define DUMPREG(i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \
+	(int)(48 - strlen(#r) - strlen(p_names[i])), " ", \
+	dispc_read_reg(DISPC_REG(i, r)))
+
+	p_names = mgr_names;
+
+	/* DISPC channel specific registers */
+	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
+		DUMPREG(i, DISPC_DEFAULT_COLOR);
+		DUMPREG(i, DISPC_TRANS_COLOR);
+		DUMPREG(i, DISPC_SIZE_MGR);
+
+		if (i == OMAP_DSS_CHANNEL_DIGIT)
+			continue;
+
+		DUMPREG(i, DISPC_TIMING_H);
+		DUMPREG(i, DISPC_TIMING_V);
+		DUMPREG(i, DISPC_POL_FREQ);
+		DUMPREG(i, DISPC_DIVISORo);
+
+		DUMPREG(i, DISPC_DATA_CYCLE1);
+		DUMPREG(i, DISPC_DATA_CYCLE2);
+		DUMPREG(i, DISPC_DATA_CYCLE3);
+
+		if (dss_has_feature(FEAT_CPR)) {
+			DUMPREG(i, DISPC_CPR_COEF_R);
+			DUMPREG(i, DISPC_CPR_COEF_G);
+			DUMPREG(i, DISPC_CPR_COEF_B);
+		}
+	}
+
+	p_names = ovl_names;
+
+	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
+		DUMPREG(i, DISPC_OVL_BA0);
+		DUMPREG(i, DISPC_OVL_BA1);
+		DUMPREG(i, DISPC_OVL_POSITION);
+		DUMPREG(i, DISPC_OVL_SIZE);
+		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(i, DISPC_OVL_ROW_INC);
+		DUMPREG(i, DISPC_OVL_PIXEL_INC);
+
+		if (dss_has_feature(FEAT_PRELOAD))
+			DUMPREG(i, DISPC_OVL_PRELOAD);
+		if (dss_has_feature(FEAT_MFLAG))
+			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
+
+		if (i == OMAP_DSS_GFX) {
+			DUMPREG(i, DISPC_OVL_WINDOW_SKIP);
+			DUMPREG(i, DISPC_OVL_TABLE_BA);
+			continue;
+		}
+
+		DUMPREG(i, DISPC_OVL_FIR);
+		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(i, DISPC_OVL_ACCU0);
+		DUMPREG(i, DISPC_OVL_ACCU1);
+		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(i, DISPC_OVL_BA0_UV);
+			DUMPREG(i, DISPC_OVL_BA1_UV);
+			DUMPREG(i, DISPC_OVL_FIR2);
+			DUMPREG(i, DISPC_OVL_ACCU2_0);
+			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		}
+		if (dss_has_feature(FEAT_ATTR2))
+			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+	}
+
+	if (dispc.feat->has_writeback) {
+		i = OMAP_DSS_WB;
+		DUMPREG(i, DISPC_OVL_BA0);
+		DUMPREG(i, DISPC_OVL_BA1);
+		DUMPREG(i, DISPC_OVL_SIZE);
+		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(i, DISPC_OVL_ROW_INC);
+		DUMPREG(i, DISPC_OVL_PIXEL_INC);
+
+		if (dss_has_feature(FEAT_MFLAG))
+			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
+
+		DUMPREG(i, DISPC_OVL_FIR);
+		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(i, DISPC_OVL_ACCU0);
+		DUMPREG(i, DISPC_OVL_ACCU1);
+		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(i, DISPC_OVL_BA0_UV);
+			DUMPREG(i, DISPC_OVL_BA1_UV);
+			DUMPREG(i, DISPC_OVL_FIR2);
+			DUMPREG(i, DISPC_OVL_ACCU2_0);
+			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		}
+		if (dss_has_feature(FEAT_ATTR2))
+			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+	}
+
+#undef DISPC_REG
+#undef DUMPREG
+
+#define DISPC_REG(plane, name, i) name(plane, i)
+#define DUMPREG(plane, name, i) \
+	seq_printf(s, "%s_%d(%s)%*s %08x\n", #name, i, p_names[plane], \
+	(int)(46 - strlen(#name) - strlen(p_names[plane])), " ", \
+	dispc_read_reg(DISPC_REG(plane, name, i)))
+
+	/* Video pipeline coefficient registers */
+
+	/* start from OMAP_DSS_VIDEO1 */
+	for (i = 1; i < dss_feat_get_num_ovls(); i++) {
+		for (j = 0; j < 8; j++)
+			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
+
+		for (j = 0; j < 8; j++)
+			DUMPREG(i, DISPC_OVL_FIR_COEF_HV, j);
+
+		for (j = 0; j < 5; j++)
+			DUMPREG(i, DISPC_OVL_CONV_COEF, j);
+
+		if (dss_has_feature(FEAT_FIR_COEF_V)) {
+			for (j = 0; j < 8; j++)
+				DUMPREG(i, DISPC_OVL_FIR_COEF_V, j);
+		}
+
+		if (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+			for (j = 0; j < 8; j++)
+				DUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);
+
+			for (j = 0; j < 8; j++)
+				DUMPREG(i, DISPC_OVL_FIR_COEF_HV2, j);
+
+			for (j = 0; j < 8; j++)
+				DUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);
+		}
+	}
+
+	dispc_runtime_put();
+
+#undef DISPC_REG
+#undef DUMPREG
+}
+
+/* calculate clock rates using dividers in cinfo */
+int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
+		struct dispc_clock_info *cinfo)
+{
+	if (cinfo->lck_div > 255 || cinfo->lck_div == 0)
+		return -EINVAL;
+	if (cinfo->pck_div < 1 || cinfo->pck_div > 255)
+		return -EINVAL;
+
+	cinfo->lck = dispc_fclk_rate / cinfo->lck_div;
+	cinfo->pck = cinfo->lck / cinfo->pck_div;
+
+	return 0;
+}
+
+bool dispc_div_calc(unsigned long dispc,
+		unsigned long pck_min, unsigned long pck_max,
+		dispc_div_calc_func func, void *data)
+{
+	int lckd, lckd_start, lckd_stop;
+	int pckd, pckd_start, pckd_stop;
+	unsigned long pck, lck;
+	unsigned long lck_max;
+	unsigned long pckd_hw_min, pckd_hw_max;
+	unsigned min_fck_per_pck;
+	unsigned long fck;
+
+#ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK
+	min_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;
+#else
+	min_fck_per_pck = 0;
+#endif
+
+	pckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);
+	pckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);
+
+	lck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+
+	pck_min = pck_min ? pck_min : 1;
+	pck_max = pck_max ? pck_max : ULONG_MAX;
+
+	lckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);
+	lckd_stop = min(dispc / pck_min, 255ul);
+
+	for (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {
+		lck = dispc / lckd;
+
+		pckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);
+		pckd_stop = min(lck / pck_min, pckd_hw_max);
+
+		for (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {
+			pck = lck / pckd;
+
+			/*
+			 * For OMAP2/3 the DISPC fclk is the same as LCD's logic
+			 * clock, which means we're configuring DISPC fclk here
+			 * also. Thus we need to use the calculated lck. For
+			 * OMAP4+ the DISPC fclk is a separate clock.
+			 */
+			if (dss_has_feature(FEAT_CORE_CLK_DIV))
+				fck = dispc_core_clk_rate();
+			else
+				fck = lck;
+
+			if (fck < pck * min_fck_per_pck)
+				continue;
+
+			if (func(lckd, pckd, lck, pck, data))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+void dispc_mgr_set_clock_div(enum omap_channel channel,
+		const struct dispc_clock_info *cinfo)
+{
+	DSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);
+	DSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);
+
+	dispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);
+}
+
+int dispc_mgr_get_clock_div(enum omap_channel channel,
+		struct dispc_clock_info *cinfo)
+{
+	unsigned long fck;
+
+	fck = dispc_fclk_rate();
+
+	cinfo->lck_div = REG_GET(DISPC_DIVISORo(channel), 23, 16);
+	cinfo->pck_div = REG_GET(DISPC_DIVISORo(channel), 7, 0);
+
+	cinfo->lck = fck / cinfo->lck_div;
+	cinfo->pck = cinfo->lck / cinfo->pck_div;
+
+	return 0;
+}
+
+u32 dispc_read_irqstatus(void)
+{
+	return dispc_read_reg(DISPC_IRQSTATUS);
+}
+EXPORT_SYMBOL(dispc_read_irqstatus);
+
+void dispc_clear_irqstatus(u32 mask)
+{
+	dispc_write_reg(DISPC_IRQSTATUS, mask);
+}
+EXPORT_SYMBOL(dispc_clear_irqstatus);
+
+u32 dispc_read_irqenable(void)
+{
+	return dispc_read_reg(DISPC_IRQENABLE);
+}
+EXPORT_SYMBOL(dispc_read_irqenable);
+
+void dispc_write_irqenable(u32 mask)
+{
+	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
+
+	/* clear the irqstatus for newly enabled irqs */
+	dispc_clear_irqstatus((mask ^ old_mask) & mask);
+
+	dispc_write_reg(DISPC_IRQENABLE, mask);
+}
+EXPORT_SYMBOL(dispc_write_irqenable);
+
+void dispc_enable_sidle(void)
+{
+	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
+}
+
+void dispc_disable_sidle(void)
+{
+	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
+}
+
+static void _omap_dispc_initial_config(void)
+{
+	u32 l;
+
+	/* Exclusively enable DISPC_CORE_CLK and set divider to 1 */
+	if (dss_has_feature(FEAT_CORE_CLK_DIV)) {
+		l = dispc_read_reg(DISPC_DIVISOR);
+		/* Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */
+		l = FLD_MOD(l, 1, 0, 0);
+		l = FLD_MOD(l, 1, 23, 16);
+		dispc_write_reg(DISPC_DIVISOR, l);
+
+		dispc.core_clk_rate = dispc_fclk_rate();
+	}
+
+	/* FUNCGATED */
+	if (dss_has_feature(FEAT_FUNCGATED))
+		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
+
+	dispc_setup_color_conv_coef();
+
+	dispc_set_loadmode(OMAP_DSS_LOAD_FRAME_ONLY);
+
+	dispc_init_fifos();
+
+	dispc_configure_burst_sizes();
+
+	dispc_ovl_enable_zorder_planes();
+
+	if (dispc.feat->mstandby_workaround)
+		REG_FLD_MOD(DISPC_MSTANDBY_CTRL, 1, 0, 0);
+
+	if (dss_has_feature(FEAT_MFLAG))
+		dispc_init_mflag();
+}
+
+static const struct dispc_features omap24xx_dispc_feats = {
+	.sw_start		=	5,
+	.fp_start		=	15,
+	.bp_start		=	27,
+	.sw_max			=	64,
+	.vp_max			=	255,
+	.hp_max			=	256,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	66500000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_24xx,
+	.calc_core_clk		=	calc_core_clk_24xx,
+	.num_fifos		=	3,
+	.no_framedone_tv	=	true,
+	.set_max_preload	=	false,
+	.last_pixel_inc_missing	=	true,
+};
+
+static const struct dispc_features omap34xx_rev1_0_dispc_feats = {
+	.sw_start		=	5,
+	.fp_start		=	15,
+	.bp_start		=	27,
+	.sw_max			=	64,
+	.vp_max			=	255,
+	.hp_max			=	256,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	173000000,
+	.max_tv_pclk		=	59000000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
+	.calc_core_clk		=	calc_core_clk_34xx,
+	.num_fifos		=	3,
+	.no_framedone_tv	=	true,
+	.set_max_preload	=	false,
+	.last_pixel_inc_missing	=	true,
+};
+
+static const struct dispc_features omap34xx_rev3_0_dispc_feats = {
+	.sw_start		=	7,
+	.fp_start		=	19,
+	.bp_start		=	31,
+	.sw_max			=	256,
+	.vp_max			=	4095,
+	.hp_max			=	4096,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	173000000,
+	.max_tv_pclk		=	59000000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_34xx,
+	.calc_core_clk		=	calc_core_clk_34xx,
+	.num_fifos		=	3,
+	.no_framedone_tv	=	true,
+	.set_max_preload	=	false,
+	.last_pixel_inc_missing	=	true,
+};
+
+static const struct dispc_features omap44xx_dispc_feats = {
+	.sw_start		=	7,
+	.fp_start		=	19,
+	.bp_start		=	31,
+	.sw_max			=	256,
+	.vp_max			=	4095,
+	.hp_max			=	4096,
+	.mgr_width_start	=	10,
+	.mgr_height_start	=	26,
+	.mgr_width_max		=	2048,
+	.mgr_height_max		=	2048,
+	.max_lcd_pclk		=	170000000,
+	.max_tv_pclk		=	185625000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
+	.calc_core_clk		=	calc_core_clk_44xx,
+	.num_fifos		=	5,
+	.gfx_fifo_workaround	=	true,
+	.set_max_preload	=	true,
+	.supports_sync_align	=	true,
+	.has_writeback		=	true,
+};
+
+static const struct dispc_features omap54xx_dispc_feats = {
+	.sw_start		=	7,
+	.fp_start		=	19,
+	.bp_start		=	31,
+	.sw_max			=	256,
+	.vp_max			=	4095,
+	.hp_max			=	4096,
+	.mgr_width_start	=	11,
+	.mgr_height_start	=	27,
+	.mgr_width_max		=	4096,
+	.mgr_height_max		=	4096,
+	.max_lcd_pclk		=	170000000,
+	.max_tv_pclk		=	186000000,
+	.calc_scaling		=	dispc_ovl_calc_scaling_44xx,
+	.calc_core_clk		=	calc_core_clk_44xx,
+	.num_fifos		=	5,
+	.gfx_fifo_workaround	=	true,
+	.mstandby_workaround	=	true,
+	.set_max_preload	=	true,
+	.supports_sync_align	=	true,
+	.has_writeback		=	true,
+};
+
+static int dispc_init_features(struct platform_device *pdev)
+{
+	const struct dispc_features *src;
+	struct dispc_features *dst;
+
+	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
+	if (!dst) {
+		dev_err(&pdev->dev, "Failed to allocate DISPC Features\n");
+		return -ENOMEM;
+	}
+
+	switch (omapdss_get_version()) {
+	case OMAPDSS_VER_OMAP24xx:
+		src = &omap24xx_dispc_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP34xx_ES1:
+		src = &omap34xx_rev1_0_dispc_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP34xx_ES3:
+	case OMAPDSS_VER_OMAP3630:
+	case OMAPDSS_VER_AM35xx:
+	case OMAPDSS_VER_AM43xx:
+		src = &omap34xx_rev3_0_dispc_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP4430_ES1:
+	case OMAPDSS_VER_OMAP4430_ES2:
+	case OMAPDSS_VER_OMAP4:
+		src = &omap44xx_dispc_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP5:
+	case OMAPDSS_VER_DRA7xx:
+		src = &omap54xx_dispc_feats;
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	memcpy(dst, src, sizeof(*dst));
+	dispc.feat = dst;
+
+	return 0;
+}
+
+static irqreturn_t dispc_irq_handler(int irq, void *arg)
+{
+	if (!dispc.is_enabled)
+		return IRQ_NONE;
+
+	return dispc.user_handler(irq, dispc.user_data);
+}
+
+int dispc_request_irq(irq_handler_t handler, void *dev_id)
+{
+	int r;
+
+	if (dispc.user_handler != NULL)
+		return -EBUSY;
+
+	dispc.user_handler = handler;
+	dispc.user_data = dev_id;
+
+	/* ensure the dispc_irq_handler sees the values above */
+	smp_wmb();
+
+	r = devm_request_irq(&dispc.pdev->dev, dispc.irq, dispc_irq_handler,
+			     IRQF_SHARED, "OMAP DISPC", &dispc);
+	if (r) {
+		dispc.user_handler = NULL;
+		dispc.user_data = NULL;
+	}
+
+	return r;
+}
+EXPORT_SYMBOL(dispc_request_irq);
+
+void dispc_free_irq(void *dev_id)
+{
+	devm_free_irq(&dispc.pdev->dev, dispc.irq, &dispc);
+
+	dispc.user_handler = NULL;
+	dispc.user_data = NULL;
+}
+EXPORT_SYMBOL(dispc_free_irq);
+
+/* DISPC HW IP initialisation */
+static int dispc_bind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	u32 rev;
+	int r = 0;
+	struct resource *dispc_mem;
+	struct device_node *np = pdev->dev.of_node;
+
+	dispc.pdev = pdev;
+
+	spin_lock_init(&dispc.control_lock);
+
+	r = dispc_init_features(dispc.pdev);
+	if (r)
+		return r;
+
+	dispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);
+	if (!dispc_mem) {
+		DSSERR("can't get IORESOURCE_MEM DISPC\n");
+		return -EINVAL;
+	}
+
+	dispc.base = devm_ioremap(&pdev->dev, dispc_mem->start,
+				  resource_size(dispc_mem));
+	if (!dispc.base) {
+		DSSERR("can't ioremap DISPC\n");
+		return -ENOMEM;
+	}
+
+	dispc.irq = platform_get_irq(dispc.pdev, 0);
+	if (dispc.irq < 0) {
+		DSSERR("platform_get_irq failed\n");
+		return -ENODEV;
+	}
+
+	if (np && of_property_read_bool(np, "syscon-pol")) {
+		dispc.syscon_pol = syscon_regmap_lookup_by_phandle(np, "syscon-pol");
+		if (IS_ERR(dispc.syscon_pol)) {
+			dev_err(&pdev->dev, "failed to get syscon-pol regmap\n");
+			return PTR_ERR(dispc.syscon_pol);
+		}
+
+		if (of_property_read_u32_index(np, "syscon-pol", 1,
+				&dispc.syscon_pol_offset)) {
+			dev_err(&pdev->dev, "failed to get syscon-pol offset\n");
+			return -EINVAL;
+		}
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	r = dispc_runtime_get();
+	if (r)
+		goto err_runtime_get;
+
+	_omap_dispc_initial_config();
+
+	rev = dispc_read_reg(DISPC_REVISION);
+	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
+	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
+
+	dispc_runtime_put();
+
+	dss_init_overlay_managers();
+
+	dss_debugfs_create_file("dispc", dispc_dump_regs);
+
+	return 0;
+
+err_runtime_get:
+	pm_runtime_disable(&pdev->dev);
+	return r;
+}
+
+static void dispc_unbind(struct device *dev, struct device *master,
+			       void *data)
+{
+	pm_runtime_disable(dev);
+
+	dss_uninit_overlay_managers();
+}
+
+static const struct component_ops dispc_component_ops = {
+	.bind	= dispc_bind,
+	.unbind	= dispc_unbind,
+};
+
+static int dispc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dispc_component_ops);
+}
+
+static int dispc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dispc_component_ops);
+	return 0;
+}
+
+static int dispc_runtime_suspend(struct device *dev)
+{
+	dispc.is_enabled = false;
+	/* ensure the dispc_irq_handler sees the is_enabled value */
+	smp_wmb();
+	/* wait for current handler to finish before turning the DISPC off */
+	synchronize_irq(dispc.irq);
+
+	dispc_save_context();
+
+	return 0;
+}
+
+static int dispc_runtime_resume(struct device *dev)
+{
+	/*
+	 * The reset value for load mode is 0 (OMAP_DSS_LOAD_CLUT_AND_FRAME)
+	 * but we always initialize it to 2 (OMAP_DSS_LOAD_FRAME_ONLY) in
+	 * _omap_dispc_initial_config(). We can thus use it to detect if
+	 * we have lost register context.
+	 */
+	if (REG_GET(DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
+		_omap_dispc_initial_config();
+
+		dispc_restore_context();
+	}
+
+	dispc.is_enabled = true;
+	/* ensure the dispc_irq_handler sees the is_enabled value */
+	smp_wmb();
+
+	return 0;
+}
+
+static const struct dev_pm_ops dispc_pm_ops = {
+	.runtime_suspend = dispc_runtime_suspend,
+	.runtime_resume = dispc_runtime_resume,
+};
+
+static const struct of_device_id dispc_of_match[] = {
+	{ .compatible = "ti,omap2-dispc", },
+	{ .compatible = "ti,omap3-dispc", },
+	{ .compatible = "ti,omap4-dispc", },
+	{ .compatible = "ti,omap5-dispc", },
+	{ .compatible = "ti,dra7-dispc", },
+	{},
+};
+
+static struct platform_driver omap_dispchw_driver = {
+	.probe		= dispc_probe,
+	.remove         = dispc_remove,
+	.driver         = {
+		.name   = "omapdss_dispc",
+		.pm	= &dispc_pm_ops,
+		.of_match_table = dispc_of_match,
+		.suppress_bind_attrs = true,
+	},
+};
+
+int __init dispc_init_platform_driver(void)
+{
+	return platform_driver_register(&omap_dispchw_driver);
+}
+
+void dispc_uninit_platform_driver(void)
+{
+	platform_driver_unregister(&omap_dispchw_driver);
+}
