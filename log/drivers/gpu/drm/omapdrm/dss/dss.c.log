commit d18292dc07dbaaacef040a23a5e5e65c6ea61803
Merge: 0e8fb69f287b cedb414aa8c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 3 15:05:35 2020 -0700

    Merge tag 'arm-drivers-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM driver updates from Arnd Bergmann:
     "These are the usual updates for SoC specific device drivers and
      related subsystems that don't have their own top-level maintainers:
    
       - ARM SCMI/SCPI updates to allow pluggable transport layers
    
       - TEE subsystem cleanups
    
       - A new driver for the Amlogic secure power domain controller
    
       - Various driver updates for the NXP Layerscape DPAA2, NXP i.MX SCU
         and TI OMAP2+ sysc drivers.
    
       - Qualcomm SoC driver updates, including a new library module for
         "protection domain" notifications
    
       - Lots of smaller bugfixes and cleanups in other drivers"
    
    * tag 'arm-drivers-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (70 commits)
      soc: fsl: qe: fix sparse warnings for ucc_slow.c
      soc: fsl: qe: ucc_slow: remove 0 assignment for kzalloc'ed structure
      soc: fsl: qe: fix sparse warnings for ucc_fast.c
      soc: fsl: qe: fix sparse warnings for qe_ic.c
      soc: fsl: qe: fix sparse warnings for ucc.c
      soc: fsl: qe: fix sparse warning for qe_common.c
      soc: fsl: qe: fix sparse warnings for qe.c
      soc: qcom: Fix QCOM_APR dependencies
      soc: qcom: pdr: Avoid uninitialized use of found in pdr_indication_cb
      soc: imx: drop COMPILE_TEST for IMX_SCU_SOC
      firmware: imx: add COMPILE_TEST for IMX_SCU driver
      soc: imx: gpc: fix power up sequencing
      soc: imx: increase build coverage for imx8m soc driver
      soc: qcom: apr: Add avs/audio tracking functionality
      dt-bindings: soc: qcom: apr: Add protection domain bindings
      soc: qcom: Introduce Protection Domain Restart helpers
      devicetree: bindings: firmware: add ipq806x to qcom_scm
      memory: tegra: Correct debugfs clk rate-range on Tegra124
      memory: tegra: Correct debugfs clk rate-range on Tegra30
      memory: tegra: Correct debugfs clk rate-range on Tegra20
      ...

commit cef766300353613aa273791f70b3125d1f0420ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Feb 26 10:02:19 2020 -0800

    drm/omap: Prepare DSS for probing without legacy platform data
    
    In order to probe display subsystem (DSS) components with ti-sysc
    interconnect target module without legacy platform data and using
    devicetree, we need to update dss probing a bit.
    
    In the device tree, we will be defining the data also for the interconnect
    target modules as DSS really is a private interconnect. There is some
    information about that in 4460 TRM in "Figure 10-3. DSS Integration" for
    example where it mentions "32-bit interconnect (SLX)".
    
    The changes we need to make are:
    
    1. Parse also device tree subnodes for the compatible property fixup
    
    2. Update the component code to consider device tree subnodes
    
    Cc: dri-devel@lists.freedesktop.org
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 225ec808b01a..44e8faecedc7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1339,9 +1339,15 @@ static int dss_component_compare(struct device *dev, void *data)
 	return dev == child;
 }
 
+struct dss_component_match_data {
+	struct device *dev;
+	struct component_match **match;
+};
+
 static int dss_add_child_component(struct device *dev, void *data)
 {
-	struct component_match **match = data;
+	struct dss_component_match_data *cmatch = data;
+	struct component_match **match = cmatch->match;
 
 	/*
 	 * HACK
@@ -1352,7 +1358,17 @@ static int dss_add_child_component(struct device *dev, void *data)
 	if (strstr(dev_name(dev), "rfbi"))
 		return 0;
 
-	component_match_add(dev->parent, match, dss_component_compare, dev);
+	/*
+	 * Handle possible interconnect target modules defined within the DSS.
+	 * The DSS components can be children of an interconnect target module
+	 * after the device tree has been updated for the module data.
+	 * See also omapdss_boot_init() for compatible fixup.
+	 */
+	if (strstr(dev_name(dev), "target-module"))
+		return device_for_each_child(dev, cmatch,
+					     dss_add_child_component);
+
+	component_match_add(cmatch->dev, match, dss_component_compare, dev);
 
 	return 0;
 }
@@ -1395,6 +1411,7 @@ static int dss_probe_hardware(struct dss_device *dss)
 static int dss_probe(struct platform_device *pdev)
 {
 	const struct soc_device_attribute *soc;
+	struct dss_component_match_data cmatch;
 	struct component_match *match = NULL;
 	struct resource *dss_mem;
 	struct dss_device *dss;
@@ -1472,7 +1489,9 @@ static int dss_probe(struct platform_device *pdev)
 
 	omapdss_gather_components(&pdev->dev);
 
-	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
+	cmatch.dev = &pdev->dev;
+	cmatch.match = &match;
+	device_for_each_child(&pdev->dev, &cmatch, dss_add_child_component);
 
 	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);
 	if (r)

commit db0fefd1b90d7d2a23090e9178ce742fe1b0aadd
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:47 2020 +0200

    drm/omap: dss: Make omap_dss_device_ops optional
    
    As part of the move to drm_bridge ops, the dssdev ops will become empty
    for some of the internal encoders. Make them optional in the driver to
    allow them to be removed completely, easing the transition.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-28-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 67b92b5d8dd7..b76fc2b56227 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1552,7 +1552,8 @@ static void dss_shutdown(struct platform_device *pdev)
 	DSSDBG("shutdown\n");
 
 	for_each_dss_output(dssdev) {
-		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
+		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE &&
+		    dssdev->ops && dssdev->ops->disable)
 			dssdev->ops->disable(dssdev);
 	}
 }

commit 2a0a3ae17d36fa86dcf7c8e8d7b7f056ebd6c064
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:41 2020 +0200

    drm/omap: dss: Cleanup DSS ports on initialisation failure
    
    When the DSS initialises its output DPI and SDI ports, failures don't
    clean up previous successfully initialised ports. This can lead to
    resource leak or memory corruption. Fix it.
    
    Reported-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-22-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 225ec808b01a..67b92b5d8dd7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1151,46 +1151,38 @@ static const struct dss_features dra7xx_dss_feats = {
 	.has_lcd_clk_src	=	true,
 };
 
-static int dss_init_ports(struct dss_device *dss)
+static void __dss_uninit_ports(struct dss_device *dss, unsigned int num_ports)
 {
 	struct platform_device *pdev = dss->pdev;
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
 	unsigned int i;
-	int r;
 
-	for (i = 0; i < dss->feat->num_ports; i++) {
+	for (i = 0; i < num_ports; i++) {
 		port = of_graph_get_port_by_id(parent, i);
 		if (!port)
 			continue;
 
 		switch (dss->feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			r = dpi_init_port(dss, pdev, port, dss->feat->model);
-			if (r)
-				return r;
+			dpi_uninit_port(port);
 			break;
-
 		case OMAP_DISPLAY_TYPE_SDI:
-			r = sdi_init_port(dss, pdev, port);
-			if (r)
-				return r;
+			sdi_uninit_port(port);
 			break;
-
 		default:
 			break;
 		}
 	}
-
-	return 0;
 }
 
-static void dss_uninit_ports(struct dss_device *dss)
+static int dss_init_ports(struct dss_device *dss)
 {
 	struct platform_device *pdev = dss->pdev;
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
-	int i;
+	unsigned int i;
+	int r;
 
 	for (i = 0; i < dss->feat->num_ports; i++) {
 		port = of_graph_get_port_by_id(parent, i);
@@ -1199,15 +1191,32 @@ static void dss_uninit_ports(struct dss_device *dss)
 
 		switch (dss->feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_uninit_port(port);
+			r = dpi_init_port(dss, pdev, port, dss->feat->model);
+			if (r)
+				goto error;
 			break;
+
 		case OMAP_DISPLAY_TYPE_SDI:
-			sdi_uninit_port(port);
+			r = sdi_init_port(dss, pdev, port);
+			if (r)
+				goto error;
 			break;
+
 		default:
 			break;
 		}
 	}
+
+	return 0;
+
+error:
+	__dss_uninit_ports(dss, i);
+	return r;
+}
+
+static void dss_uninit_ports(struct dss_device *dss)
+{
+	__dss_uninit_ports(dss, dss->feat->num_ports);
 }
 
 static int dss_video_pll_probe(struct dss_device *dss)

commit 7ed093602e0e1b60a0fc074a9692687e7d2b723d
Merge: 97ea56540ffc 354c2d310082
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 09:30:52 2019 +1000

    Merge tag 'drm-misc-next-2019-10-09-2' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.5:
    
    UAPI Changes:
    -Colorspace: Expose different prop values for DP vs. HDMI (Gwan-gyeong Mun)
    -fourcc: Add DRM_FORMAT_MOD_ARM_16X16_BLOCK_U_INTERLEAVED (Raymond)
    -not_actually: s/ENOTSUPP/EOPNOTSUPP/ in drm_edid and drm_mipi_dbi. This should
        not reach userspace, but adding here to specifically call that out (Daniel)
    -i810: Prevent underflow in dispatch ioctls (Dan)
    -komeda: Add ACLK sysfs attribute (Mihail)
    -v3d: Allow userspace to clean up after render jobs (Iago)
    
    Cross-subsystem Changes:
    -MAINTAINERS:
     -Add Alyssa & Steven as panfrost reviewers (Rob)
     -Add Jernej as DE2 reviewer (Maxime)
     -Add Chen-Yu as Allwinner maintainer (Maxime)
    -staging: Make some stack arrays static const (Colin)
    
    Core Changes:
    -ttm: Allow drivers to specify their vma manager (to use gem mgr) (Gerd)
    -docs: Various fixes in connector/encoder/bridge docs (Daniel, Lyude, Laurent)
    -connector: Allow more than 3 possible encoders for a connector (José)
    -dp_cec: Allow a connector to be associated with a cec device (Dariusz)
    -various: Fix some compile/sparse warnings (Ville)
    -mm: Ensure mm node removals are properly serialised (Chris)
    -panel: Specify the type of panel for drm_panels for later use (Laurent)
    -panel: Use drm_panel_init to init device and funcs (Laurent)
    -mst: Refactors and cleanups in anticipation of suspend/resume support (Lyude)
    -vram:
     -Add lazy unmapping for gem bo's (Thomas)
     -Unify and rationalize vram mm and gem vram (Thomas)
     -Expose vmap and vunmap for gem vram objects (Thomas)
     -Allow objects to be pinned at the top of vram to avoid fragmentation (Thomas)
    
    Driver Changes:
    -various: Include drm_bridge.h instead of relying on drm_crtc.h (Boris)
    -ast/mgag200: Refactor show_cursor(), move cursor to top of video mem (Thomas)
    -komeda:
     -Add error event printing (behind CONFIG) and reg dump support (Lowry)
     -Add suspend/resume support (Lowry)
     -Workaround D71 shadow registers not flushing on disable (Lowry)
    -meson: Add suspend/resume support (Neil)
    -omap: Miscellaneous refactors and improvements (Tomi/Jyri)
    -panfrost/shmem: Silence lockdep by using mutex_trylock (Rob)
    -panfrost: Miscellaneous small fixes (Rob/Steven)
    -sti: Fix warnings (Benjamin/Linus)
    -sun4i:
     -Add vcc-dsi regulator to sun6i_mipi_dsi (Jagan)
     -A few patches to figure out the DRQ/start delay calc on dsi (Jagan/Icenowy)
    -virtio:
     -Add module param to switch resource reuse workaround on/off (Gerd)
     -Avoid calling vmexit while holding spinlock (Gerd)
     -Use gem shmem helpers instead of ttm (Gerd)
     -Accommodate command buffer allocations too big for cma (David)
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Maxime Ripard <mripard@kernel.org>
    Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Lyude Paul <lyude@redhat.com>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Cc: Dariusz Marcinkiewicz <darekm@google.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Raymond Smith <raymond.smith@arm.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Mihail Atanassov <Mihail.Atanassov@arm.com>
    Cc: Lowry Li <Lowry.Li@arm.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
    Cc: Steven Price <steven.price@arm.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jagan Teki <jagan@amarulasolutions.com>
    Cc: Icenowy Zheng <icenowy@aosc.io>
    Cc: Iago Toral Quiroga <itoral@igalia.com>
    Cc: David Riley <davidriley@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # gpg: Signature made Thu 10 Oct 2019 01:00:47 AM AEST
    # gpg:                using RSA key 732C002572DCAF79
    # gpg: Can't check signature: public key not found
    
    # Conflicts:
    #       drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
    #       drivers/gpu/drm/i915/i915_drv.c
    #       drivers/gpu/drm/i915/i915_gem.c
    #       drivers/gpu/drm/i915/i915_gem_gtt.c
    #       drivers/gpu/drm/i915/i915_vma.c
    From: Sean Paul <sean@poorly.run>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191009150825.GA227673@art_vandelay

commit 34d71136e0d93667f4697ff9eba87312a3c09dba
Author: Jyri Sarha <jsarha@ti.com>
Date:   Mon Sep 30 13:38:38 2019 +0300

    drm/omap: dss: move platform_register_drivers() to dss.c and remove core.c
    
    The core.c just for registering the drivers is kind of useless. Let's
    get rid of it and register the dss drivers in dss.c.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190930103840.18970-6-tomi.valkeinen@ti.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index e226324adb69..41d495a360d8 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1598,3 +1598,40 @@ struct platform_driver omap_dsshw_driver = {
 		.suppress_bind_attrs = true,
 	},
 };
+
+/* INIT */
+static struct platform_driver * const omap_dss_drivers[] = {
+	&omap_dsshw_driver,
+	&omap_dispchw_driver,
+#ifdef CONFIG_OMAP2_DSS_DSI
+	&omap_dsihw_driver,
+#endif
+#ifdef CONFIG_OMAP2_DSS_VENC
+	&omap_venchw_driver,
+#endif
+#ifdef CONFIG_OMAP4_DSS_HDMI
+	&omapdss_hdmi4hw_driver,
+#endif
+#ifdef CONFIG_OMAP5_DSS_HDMI
+	&omapdss_hdmi5hw_driver,
+#endif
+};
+
+static int __init omap_dss_init(void)
+{
+	return platform_register_drivers(omap_dss_drivers,
+					 ARRAY_SIZE(omap_dss_drivers));
+}
+
+static void __exit omap_dss_exit(void)
+{
+	platform_unregister_drivers(omap_dss_drivers,
+				    ARRAY_SIZE(omap_dss_drivers));
+}
+
+module_init(omap_dss_init);
+module_exit(omap_dss_exit);
+
+MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
+MODULE_DESCRIPTION("OMAP2/3/4/5 Display Subsystem");
+MODULE_LICENSE("GPL v2");

commit 77fdaa091d79c87323a9f3912a25f73e02ea2a01
Merge: e2c4ed148cf3 54ecb8f7028c
Author: Maxime Ripard <mripard@kernel.org>
Date:   Thu Oct 3 09:59:29 2019 +0200

    Merge drm/drm-fixes into drm-misc-fixes
    
    We haven't backmerged for a while, let's start the -rc period by pulling
    rc1.
    
    Signed-off-by: Maxime Ripard <mripard@kernel.org>

commit e2c4ed148cf3ec8669a1d90dc66966028e5fad70
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Oct 2 15:25:42 2019 +0300

    drm/omap: fix max fclk divider for omap36xx
    
    The OMAP36xx and AM/DM37x TRMs say that the maximum divider for DSS fclk
    (in CM_CLKSEL_DSS) is 32. Experimentation shows that this is not
    correct, and using divider of 32 breaks DSS with a flood or underflows
    and sync losts. Dividers up to 31 seem to work fine.
    
    There is another patch to the DT files to limit the divider correctly,
    but as the DSS driver also needs to know the maximum divider to be able
    to iteratively find good rates, we also need to do the fix in the DSS
    driver.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Adam Ford <aford173@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20191002122542.8449-1-tomi.valkeinen@ti.com
    Tested-by: Adam Ford <aford173@gmail.com>
    Reviewed-by: Jyri Sarha <jsarha@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 5711b7a720e6..25b6a79dc385 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1090,7 +1090,7 @@ static const struct dss_features omap34xx_dss_feats = {
 
 static const struct dss_features omap3630_dss_feats = {
 	.model			=	DSS_MODEL_OMAP3,
-	.fck_div_max		=	32,
+	.fck_div_max		=	31,
 	.fck_freq_max		=	173000000,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll4_ck",

commit e26ae7c0432101a924cf745b07470c8592de64cb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 13:57:49 2019 +0200

    omapdrm: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Sebastian Reichel <sebastian.reichel@collabora.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: zhong jiang <zhongjiang@huawei.com>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190613115749.GC26335@kroah.com
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190704023557.4551-1-huangfq.daxian@gmail.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 5711b7a720e6..e226324adb69 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -923,7 +923,6 @@ dss_debugfs_create_file(struct dss_device *dss, const char *name,
 			void *data)
 {
 	struct dss_debugfs_entry *entry;
-	struct dentry *d;
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
@@ -931,15 +930,9 @@ dss_debugfs_create_file(struct dss_device *dss, const char *name,
 
 	entry->show_fn = show_fn;
 	entry->data = data;
+	entry->dentry = debugfs_create_file(name, 0444, dss->debugfs.root,
+					    entry, &dss_debug_fops);
 
-	d = debugfs_create_file(name, 0444, dss->debugfs.root, entry,
-				&dss_debug_fops);
-	if (IS_ERR(d)) {
-		kfree(entry);
-		return ERR_CAST(d);
-	}
-
-	entry->dentry = d;
 	return entry;
 }
 

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 55e68863ef15..5711b7a720e6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1,21 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * Some code and ideas taken from drivers/video/omap/ driver
  * by Imre Deak.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define DSS_SUBSYS_NAME "DSS"

commit 19b4200d8f4b90b5a41592f9021b52153ac2b6b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Aug 24 19:38:07 2018 +0300

    drm/omap: Reverse direction of the DSS device enable/disable operations
    
    The omapdrm and omapdss drivers are architectured based on display
    pipelines made of multiple components handled from sink (display) to
    source (DSS output). This is incompatible with the DRM bridge and panel
    APIs that handle components from source to sink.
    
    Reconcile the omapdrm and omapdss drivers with the DRM bridge and panel
    model by reversing the direction of the DSS device .enable() and
    .disable() operations. This completes the move to the DRM bridge model,
    with the notable exception of the DSI pipelines that will require more
    work.
    
    We also adapt the omapdss shutdown handler dss_shutdown() to shut down
    all active pipelines starting from the pipeline output device instead of
    the display device.
    
    As a consequence the for_each_dss_display() macro isn't used and can be
    removed, and the omapdss_device_get_next() function underlying the macro
    can be simplified to search for output devices only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7553c7fc1c45..55e68863ef15 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1560,7 +1560,7 @@ static void dss_shutdown(struct platform_device *pdev)
 
 	DSSDBG("shutdown\n");
 
-	for_each_dss_display(dssdev) {
+	for_each_dss_output(dssdev) {
 		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
 			dssdev->ops->disable(dssdev);
 	}

commit e0c827aca0730b51f38081aa4e8ecf0912aab55f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Nov 10 13:16:51 2018 +0200

    drm/omap: Populate DSS children in omapdss driver
    
    The DSS DT node contains children that describe the DSS components
    (DISPC and internal encoders). Each of those components is handled by a
    platform driver, and thus needs to be backed by a platform device.
    
    The corresponding platform devices are created in mach-omap2 code by a
    call to of_platform_populate(). While this approach has worked so far,
    it doesn't model the hardware architecture very well, as it creates
    child devices before the parent is ready to handle them. This would be
    akin to creating I2C slaves before the I2C master is available.
    
    The task can be easily performed in the omapdss driver code instead,
    simplifying mach-omap2 code. We however can't remove the mach-omap2 code
    completely as the omap2fb driver still depends on it, but we can move it
    to the omap2fb-specific section, where it can stay until the omap2fb
    driver gets removed.
    
    This has the added benefit of not allowing DSS components to probe
    before the DSS itself, which led to runtime PM issues when the DSS probe
    is deferred.
    
    Fixes: 27d624527d99 ("drm/omap: dss: Acquire next dssdev at probe time")
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181110111654.4387-2-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 1aaf260aa9b8..7553c7fc1c45 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1484,16 +1484,23 @@ static int dss_probe(struct platform_device *pdev)
 						   dss);
 
 	/* Add all the child devices as components. */
+	r = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
+	if (r)
+		goto err_uninit_debugfs;
+
 	omapdss_gather_components(&pdev->dev);
 
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
 
 	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);
 	if (r)
-		goto err_uninit_debugfs;
+		goto err_of_depopulate;
 
 	return 0;
 
+err_of_depopulate:
+	of_platform_depopulate(&pdev->dev);
+
 err_uninit_debugfs:
 	dss_debugfs_remove_file(dss->debugfs.clk);
 	dss_debugfs_remove_file(dss->debugfs.dss);
@@ -1522,6 +1529,8 @@ static int dss_remove(struct platform_device *pdev)
 {
 	struct dss_device *dss = platform_get_drvdata(pdev);
 
+	of_platform_depopulate(&pdev->dev);
+
 	component_master_del(&pdev->dev, &dss_component_ops);
 
 	dss_debugfs_remove_file(dss->debugfs.clk);

commit 993d52e2f71560d539b3f194be2970eb9d8ce9c1
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Tue Sep 11 19:54:35 2018 +0800

    drm/omap: Use ERR_CAST directly instead of ERR_PTR(PTR_ERR())
    
    We prefer to use ERR_CAST to do so.
    The issue is detected with the help of Coccinelle.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 19fc4dfc429e..1aaf260aa9b8 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -947,7 +947,7 @@ dss_debugfs_create_file(struct dss_device *dss, const char *name,
 				&dss_debug_fops);
 	if (IS_ERR(d)) {
 		kfree(entry);
-		return ERR_PTR(PTR_ERR(d));
+		return ERR_CAST(d);
 	}
 
 	entry->dentry = d;

commit 83910ad3f51fbc0e6546b60aafa90697b5127a8a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jun 1 19:45:01 2018 +0300

    drm/omap: Move most omap_dss_driver operations to omap_dss_device_ops
    
    omap_dss_device instances have two ops structures, omap_dss_driver and
    omap_dss_device_ops. The former is used for devices at the end of the
    pipeline (a.k.a. display devices), and the latter for intermediate
    devices.
    
    Having two sets of operations isn't convenient as code that iterates
    over omap_dss_device instances need to take them both into account.
    There's currently a reasonably small amount of such code, but more will
    be introduced to move the driver away from recursive operations. To
    simplify current and future code, move all operations that are not
    specific to the display device to the omap_dss_device_ops.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 14ffe23b5ecf..19fc4dfc429e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1553,7 +1553,7 @@ static void dss_shutdown(struct platform_device *pdev)
 
 	for_each_dss_display(dssdev) {
 		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
-			dssdev->driver->disable(dssdev);
+			dssdev->ops->disable(dssdev);
 	}
 }
 

commit a4e9ecf4bb19f13bbd346fae646e7d9ce33db3b8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 29 14:51:04 2018 +0300

    drm/omap: Remove unnecessary display output sanity checks
    
    The omapdrm driver checks at suspend and resume time whether the
    displays it operates on have their driver operations set. This check is
    unneeded, as all display drivers set the driver operations field at
    probe time and never touch it afterwards. This is furthermore proven by
    the dereferencing of the driver field without checking it first in
    several locations.
    
    The omapdss driver performs a similar check at shutdown time. This is
    unneeded as well, as the for_each_dss_display() macro it uses to iterate
    over displays locates the displays by checking the driver field
    internally.
    
    As those checks are unnecessary, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index b473aff466d7..14ffe23b5ecf 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1552,9 +1552,6 @@ static void dss_shutdown(struct platform_device *pdev)
 	DSSDBG("shutdown\n");
 
 	for_each_dss_display(dssdev) {
-		if (!dssdev->driver)
-			continue;
-
 		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
 			dssdev->driver->disable(dssdev);
 	}

commit d25a7d67465faa28062323d46a1d755d3ae6abc6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 00:22:10 2018 +0200

    drm/omap: Remove supported output check in CRTC connect handler
    
    The CRTC connect handler checks whether the DSS output supports the
    DISPC channel assigned to it. As the channel is assigned to the output
    by the output driver a failure there could only result from a driver
    bug. All the output drivers have been verified and they are always
    assigned a DISPC channel that is supported on the SoC they run on. The
    check can thus be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7245dd3423e6..b473aff466d7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -678,12 +678,6 @@ unsigned long dss_get_max_fck_rate(struct dss_device *dss)
 	return dss->feat->fck_freq_max;
 }
 
-enum omap_dss_output_id dss_get_supported_outputs(struct dss_device *dss,
-						  enum omap_channel channel)
-{
-	return dss->feat->outputs[channel];
-}
-
 static int dss_setup_default_clock(struct dss_device *dss)
 {
 	unsigned long max_dss_fck, prate;

commit 92ce521a4841131acf9af41e5bc772990ada06dc
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 01:40:48 2018 +0200

    drm/omap: dss: Rename for_each_dss_dev macro to for_each_dss_display
    
    The macro iterates over displays only, rename it accordingly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index e93bed8edd7e..7245dd3423e6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1557,7 +1557,7 @@ static void dss_shutdown(struct platform_device *pdev)
 
 	DSSDBG("shutdown\n");
 
-	for_each_dss_dev(dssdev) {
+	for_each_dss_display(dssdev) {
 		if (!dssdev->driver)
 			continue;
 

commit 3ce75d67e44c11c9f84ea0355fe6431a43ce6e94
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 2 00:40:04 2018 +0200

    drm/omap: Move DSI debugfs clocks dump to dsi%u_clks files
    
    The DSI clocks are dumped in the DSS-level debugfs clocks file. This
    complicates the implementation as the DSI private data has to be looked
    up through the outputs list. Simplify it by creating two debugfs files,
    dsi1_clks and dsi2_clks, to dump the DSI clocks.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 55d837983a1e..e93bed8edd7e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -394,9 +394,6 @@ static int dss_debug_dump_clocks(struct seq_file *s, void *p)
 
 	dss_dump_clocks(dss, s);
 	dispc_dump_clocks(dss->dispc, s);
-#ifdef CONFIG_OMAP2_DSS_DSI
-	dsi_dump_clocks(s);
-#endif
 	return 0;
 }
 

commit 8023651bd3d9372779be731a1165058cd33b454e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Mar 7 20:34:42 2018 +0200

    drm/omap: dss: Handle DPI and SDI port initialization failures
    
    The dpi_init_port() and sdi_init_port() functions can return errors but
    their return value is ignored. This prevents both probe failures and
    probe deferral from working correctly. Propagate the errors up the call
    stack.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 64479b209c1f..55d837983a1e 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1183,7 +1183,8 @@ static int dss_init_ports(struct dss_device *dss)
 	struct platform_device *pdev = dss->pdev;
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
-	int i;
+	unsigned int i;
+	int r;
 
 	for (i = 0; i < dss->feat->num_ports; i++) {
 		port = of_graph_get_port_by_id(parent, i);
@@ -1192,11 +1193,17 @@ static int dss_init_ports(struct dss_device *dss)
 
 		switch (dss->feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_port(dss, pdev, port, dss->feat->model);
+			r = dpi_init_port(dss, pdev, port, dss->feat->model);
+			if (r)
+				return r;
 			break;
+
 		case OMAP_DISPLAY_TYPE_SDI:
-			sdi_init_port(dss, pdev, port);
+			r = sdi_init_port(dss, pdev, port);
+			if (r)
+				return r;
 			break;
+
 		default:
 			break;
 		}

commit cc1876ce5791b1c87d0b4dd5d1507e9c80558af2
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Feb 16 13:25:07 2018 +0200

    drm/omap: dss: Move platform_device_register from core.c to dss.c probe
    
    Register the omapdrm device when we know that dss device probe going
    to succeed. This avoids DSS6 and DSS2 omapdrm device registration from
    colliding with each other.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 9af7108dbf5f..64479b209c1f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1315,6 +1315,7 @@ static const struct soc_device_attribute dss_soc_devices[] = {
 static int dss_bind(struct device *dev)
 {
 	struct dss_device *dss = dev_get_drvdata(dev);
+	struct platform_device *drm_pdev;
 	int r;
 
 	r = component_bind_all(dev, NULL);
@@ -1325,11 +1326,23 @@ static int dss_bind(struct device *dev)
 
 	omapdss_set_dss(dss);
 
+	drm_pdev = platform_device_register_simple("omapdrm", 0, NULL, 0);
+	if (IS_ERR(drm_pdev)) {
+		component_unbind_all(dev, NULL);
+		return PTR_ERR(drm_pdev);
+	}
+
+	dss->drm_pdev = drm_pdev;
+
 	return 0;
 }
 
 static void dss_unbind(struct device *dev)
 {
+	struct dss_device *dss = dev_get_drvdata(dev);
+
+	platform_device_unregister(dss->drm_pdev);
+
 	omapdss_set_dss(NULL);
 
 	component_unbind_all(dev, NULL);

commit f13e97cf3e72288b883a29e82a6d0d7cfb9827a4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 1 21:51:43 2018 +0200

    drm/omap: dss: Gather OMAP DSS components at probe time
    
    The omapdss_gather_components() function walks the OF graph to create a
    list of all components part of the display device. There's no need to
    delay this operation until DSS bind time as we have all the information
    we need at probe time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index cb80ddaa19d2..9af7108dbf5f 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1323,7 +1323,6 @@ static int dss_bind(struct device *dev)
 
 	pm_set_vt_switch(0);
 
-	omapdss_gather_components(dev);
 	omapdss_set_dss(dss);
 
 	return 0;
@@ -1474,6 +1473,8 @@ static int dss_probe(struct platform_device *pdev)
 						   dss);
 
 	/* Add all the child devices as components. */
+	omapdss_gather_components(&pdev->dev);
+
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
 
 	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);

commit 6505d75cd23291565ca668dd1e66f4e38b5c8f38
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 24 14:46:19 2018 +0300

    drm/omap: fix email address
    
    Change tomi.valkeinen@nokia.com to tomi.valkeinen@ti.com.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 0b908e9de792..cb80ddaa19d2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2009 Nokia Corporation
- * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  *
  * Some code and ideas taken from drivers/video/omap/ driver
  * by Imre Deak.

commit 83df2d4ed559442cdb5a1364c69aef3e682dceb0
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Mar 14 10:23:52 2018 +0200

    drm/omap: fix compile error when debugfs is disabled
    
    When compiling with CONFIG_OMAP2_DSS_DEBUGFS disabled, build fails due
    to:
    
    drivers/gpu/drm/omapdrm/dss/dss.c:1474:10: error: ‘dss_debug_dump_clocks’ undeclared (first use in this function); did you mean ‘dispc_dump_clocks’?
              dss_debug_dump_clocks, dss);
              ^~~~~~~~~~~~~~~~~~~~~
              dispc_dump_clocks
    
    Fix this by moving the required functions outside #if
    defined(CONFIG_OMAP2_DSS_DEBUGFS).
    
    In the long term, we perhaps want to try to get all the debugfs support
    left out if debugfs is not enabled.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 4a08bd1fc522..0b908e9de792 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -343,7 +343,6 @@ const char *dss_get_clk_source_name(enum dss_clk_source clk_src)
 	return dss_generic_clk_source_names[clk_src];
 }
 
-#if defined(CONFIG_OMAP2_DSS_DEBUGFS)
 static void dss_dump_clocks(struct dss_device *dss, struct seq_file *s)
 {
 	const char *fclk_name;
@@ -363,7 +362,6 @@ static void dss_dump_clocks(struct dss_device *dss, struct seq_file *s)
 
 	dss_runtime_put(dss);
 }
-#endif
 
 static int dss_dump_regs(struct seq_file *s, void *p)
 {
@@ -390,6 +388,18 @@ static int dss_dump_regs(struct seq_file *s, void *p)
 	return 0;
 }
 
+static int dss_debug_dump_clocks(struct seq_file *s, void *p)
+{
+	struct dss_device *dss = s->private;
+
+	dss_dump_clocks(dss, s);
+	dispc_dump_clocks(dss->dispc, s);
+#ifdef CONFIG_OMAP2_DSS_DSI
+	dsi_dump_clocks(s);
+#endif
+	return 0;
+}
+
 static int dss_get_channel_index(enum omap_channel channel)
 {
 	switch (channel) {
@@ -889,18 +899,6 @@ struct dss_device *dss_get_device(struct device *dev)
 
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
-static int dss_debug_dump_clocks(struct seq_file *s, void *p)
-{
-	struct dss_device *dss = s->private;
-
-	dss_dump_clocks(dss, s);
-	dispc_dump_clocks(dss->dispc, s);
-#ifdef CONFIG_OMAP2_DSS_DSI
-	dsi_dump_clocks(s);
-#endif
-	return 0;
-}
-
 static int dss_initialize_debugfs(struct dss_device *dss)
 {
 	struct dentry *dir;

commit 8a7eda7686675b73d74c22c0d5b83059f9d783f6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:43 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to remaining dispc API functions
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index ca2efb937d42..4a08bd1fc522 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -274,7 +274,7 @@ int dss_sdi_enable(struct dss_device *dss)
 {
 	unsigned long timeout;
 
-	dispc_pck_free_enable(1);
+	dispc_pck_free_enable(dss->dispc, 1);
 
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 18, 18); /* SDI_PLL_SYSRESET */
@@ -304,7 +304,7 @@ int dss_sdi_enable(struct dss_device *dss)
 		}
 	}
 
-	dispc_lcd_enable_signal(1);
+	dispc_lcd_enable_signal(dss->dispc, 1);
 
 	/* Waiting for SDI reset to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
@@ -318,21 +318,21 @@ int dss_sdi_enable(struct dss_device *dss)
 	return 0;
 
  err2:
-	dispc_lcd_enable_signal(0);
+	dispc_lcd_enable_signal(dss->dispc, 0);
  err1:
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 
-	dispc_pck_free_enable(0);
+	dispc_pck_free_enable(dss->dispc, 0);
 
 	return -ETIMEDOUT;
 }
 
 void dss_sdi_disable(struct dss_device *dss)
 {
-	dispc_lcd_enable_signal(0);
+	dispc_lcd_enable_signal(dss->dispc, 0);
 
-	dispc_pck_free_enable(0);
+	dispc_pck_free_enable(dss->dispc, 0);
 
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
@@ -894,7 +894,7 @@ static int dss_debug_dump_clocks(struct seq_file *s, void *p)
 	struct dss_device *dss = s->private;
 
 	dss_dump_clocks(dss, s);
-	dispc_dump_clocks(s);
+	dispc_dump_clocks(dss->dispc, s);
 #ifdef CONFIG_OMAP2_DSS_DSI
 	dsi_dump_clocks(s);
 #endif

commit 72877cf38b4b78fbb3a852f2288d7f2a7af0db22
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:40 2018 +0200

    drm: omapdrm: dss: Store DSS device pointer in the omapdrm private data
    
    The dss_device is the top-level component in the omapdss driver. Give
    the omapdrm driver access to the dss_device pointer in order to obtain
    pointers to all other components from it. This requires a new global
    variable in the omapdss driver that will be removed when merging the
    omapdrm and omapdss drivers, but will already allow removal of several
    other global variables.
    
    As this partly duplicates the omapdss_is_initialized() API, reimplement
    it as an inline function wrapping omapdss_get_dss().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 14d2f024eb70..ca2efb937d42 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1316,6 +1316,7 @@ static const struct soc_device_attribute dss_soc_devices[] = {
 
 static int dss_bind(struct device *dev)
 {
+	struct dss_device *dss = dev_get_drvdata(dev);
 	int r;
 
 	r = component_bind_all(dev, NULL);
@@ -1325,14 +1326,14 @@ static int dss_bind(struct device *dev)
 	pm_set_vt_switch(0);
 
 	omapdss_gather_components(dev);
-	omapdss_set_is_initialized(true);
+	omapdss_set_dss(dss);
 
 	return 0;
 }
 
 static void dss_unbind(struct device *dev)
 {
-	omapdss_set_is_initialized(false);
+	omapdss_set_dss(NULL);
 
 	component_unbind_all(dev, NULL);
 }

commit b40d0ed647a2d96da38760d0429450936030fd85
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:32 2018 +0200

    drm: omapdrm: dss: Don't unnecessarily cast to dev to pdev and back
    
    The dss_unbind() function casts the struct device pointer to a struct
    platform_device, only to later use the struct device pointer from
    platform_device. Don't cast at all.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7a5f5f233ad0..14d2f024eb70 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1332,11 +1332,9 @@ static int dss_bind(struct device *dev)
 
 static void dss_unbind(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-
 	omapdss_set_is_initialized(false);
 
-	component_unbind_all(&pdev->dev, NULL);
+	component_unbind_all(dev, NULL);
 }
 
 static const struct component_master_ops dss_component_ops = {

commit 1c4b92ee00734766967f5aa425767923c747f9c6
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:31 2018 +0200

    drm: omapdrm: dss: Store the debugfs root directory in struct dss_device
    
    As part of an effort to remove the usage of global variables in the
    driver, store the debugfs root directory in the dss_device structure
    instead of a global variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 14a86e2c6d83..7a5f5f233ad0 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -901,25 +901,22 @@ static int dss_debug_dump_clocks(struct seq_file *s, void *p)
 	return 0;
 }
 
-static struct dentry *dss_debugfs_dir;
-
 static int dss_initialize_debugfs(struct dss_device *dss)
 {
-	dss_debugfs_dir = debugfs_create_dir("omapdss", NULL);
-	if (IS_ERR(dss_debugfs_dir)) {
-		int err = PTR_ERR(dss_debugfs_dir);
+	struct dentry *dir;
 
-		dss_debugfs_dir = NULL;
-		return err;
-	}
+	dir = debugfs_create_dir("omapdss", NULL);
+	if (IS_ERR(dir))
+		return PTR_ERR(dir);
+
+	dss->debugfs.root = dir;
 
 	return 0;
 }
 
-static void dss_uninitialize_debugfs(void)
+static void dss_uninitialize_debugfs(struct dss_device *dss)
 {
-	if (dss_debugfs_dir)
-		debugfs_remove_recursive(dss_debugfs_dir);
+	debugfs_remove_recursive(dss->debugfs.root);
 }
 
 struct dss_debugfs_entry {
@@ -942,8 +939,10 @@ static const struct file_operations dss_debug_fops = {
 	.release	= single_release,
 };
 
-struct dss_debugfs_entry *dss_debugfs_create_file(const char *name,
-		int (*show_fn)(struct seq_file *s, void *data), void *data)
+struct dss_debugfs_entry *
+dss_debugfs_create_file(struct dss_device *dss, const char *name,
+			int (*show_fn)(struct seq_file *s, void *data),
+			void *data)
 {
 	struct dss_debugfs_entry *entry;
 	struct dentry *d;
@@ -955,7 +954,7 @@ struct dss_debugfs_entry *dss_debugfs_create_file(const char *name,
 	entry->show_fn = show_fn;
 	entry->data = data;
 
-	d = debugfs_create_file(name, 0444, dss_debugfs_dir, entry,
+	d = debugfs_create_file(name, 0444, dss->debugfs.root, entry,
 				&dss_debug_fops);
 	if (IS_ERR(d)) {
 		kfree(entry);
@@ -980,7 +979,7 @@ static inline int dss_initialize_debugfs(struct dss_device *dss)
 {
 	return 0;
 }
-static inline void dss_uninitialize_debugfs(void)
+static inline void dss_uninitialize_debugfs(struct dss_device *dss)
 {
 }
 #endif /* CONFIG_OMAP2_DSS_DEBUGFS */
@@ -1472,9 +1471,10 @@ static int dss_probe(struct platform_device *pdev)
 	if (r)
 		goto err_pm_runtime_disable;
 
-	dss->debugfs.clk = dss_debugfs_create_file("clk", dss_debug_dump_clocks,
+	dss->debugfs.clk = dss_debugfs_create_file(dss, "clk",
+						   dss_debug_dump_clocks, dss);
+	dss->debugfs.dss = dss_debugfs_create_file(dss, "dss", dss_dump_regs,
 						   dss);
-	dss->debugfs.dss = dss_debugfs_create_file("dss", dss_dump_regs, dss);
 
 	/* Add all the child devices as components. */
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
@@ -1488,7 +1488,7 @@ static int dss_probe(struct platform_device *pdev)
 err_uninit_debugfs:
 	dss_debugfs_remove_file(dss->debugfs.clk);
 	dss_debugfs_remove_file(dss->debugfs.dss);
-	dss_uninitialize_debugfs();
+	dss_uninitialize_debugfs(dss);
 
 err_pm_runtime_disable:
 	pm_runtime_disable(&pdev->dev);
@@ -1517,7 +1517,7 @@ static int dss_remove(struct platform_device *pdev)
 
 	dss_debugfs_remove_file(dss->debugfs.clk);
 	dss_debugfs_remove_file(dss->debugfs.dss);
-	dss_uninitialize_debugfs();
+	dss_uninitialize_debugfs(dss);
 
 	pm_runtime_disable(&pdev->dev);
 

commit f33656e1fe5aba0ac0d35e18d90121dd894611ca
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:29 2018 +0200

    drm: omapdrm: dss: Support passing private data to debugfs show handlers
    
    To simplify implementation of debugfs seq_file show handlers, the driver
    passes the pointer to the show function through the debugfs_create_file
    data pointer. This prevents using the pointer to pass driver private
    data to the show handler, and requires all handlers to use global
    variables to access private data.
    
    To prepare for the removal of global private data in the driver, rework
    the debugfs infrastructure to allow passing a private data pointer to
    show handlers.
    
    The price to pay is explicit removal of debugfs files to free the
    internally allocated memory. This is desirable anyway as debugfs entries
    should be removed when a component driver is unbound, otherwise crashes
    will occur due to access to freed memory when the components will be
    dynamically allocated instead of stored in global variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 4b00faa1a8cc..14a86e2c6d83 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -365,14 +365,14 @@ static void dss_dump_clocks(struct dss_device *dss, struct seq_file *s)
 }
 #endif
 
-static void dss_dump_regs(struct seq_file *s)
+static int dss_dump_regs(struct seq_file *s, void *p)
 {
 	struct dss_device *dss = s->private;
 
 #define DUMPREG(dss, r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(dss, r))
 
 	if (dss_runtime_get(dss))
-		return;
+		return 0;
 
 	DUMPREG(dss, DSS_REVISION);
 	DUMPREG(dss, DSS_SYSCONFIG);
@@ -387,6 +387,7 @@ static void dss_dump_regs(struct seq_file *s)
 
 	dss_runtime_put(dss);
 #undef DUMPREG
+	return 0;
 }
 
 static int dss_get_channel_index(enum omap_channel channel)
@@ -888,7 +889,7 @@ struct dss_device *dss_get_device(struct device *dev)
 
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
-static void dss_debug_dump_clocks(struct seq_file *s)
+static int dss_debug_dump_clocks(struct seq_file *s, void *p)
 {
 	struct dss_device *dss = s->private;
 
@@ -897,28 +898,9 @@ static void dss_debug_dump_clocks(struct seq_file *s)
 #ifdef CONFIG_OMAP2_DSS_DSI
 	dsi_dump_clocks(s);
 #endif
-}
-
-static int dss_debug_show(struct seq_file *s, void *unused)
-{
-	void (*func)(struct seq_file *) = s->private;
-
-	func(s);
 	return 0;
 }
 
-static int dss_debug_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, dss_debug_show, inode->i_private);
-}
-
-static const struct file_operations dss_debug_fops = {
-	.open           = dss_debug_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = single_release,
-};
-
 static struct dentry *dss_debugfs_dir;
 
 static int dss_initialize_debugfs(struct dss_device *dss)
@@ -931,9 +913,6 @@ static int dss_initialize_debugfs(struct dss_device *dss)
 		return err;
 	}
 
-	debugfs_create_file("clk", S_IRUGO, dss_debugfs_dir,
-			&dss_debug_dump_clocks, &dss_debug_fops);
-
 	return 0;
 }
 
@@ -943,15 +922,59 @@ static void dss_uninitialize_debugfs(void)
 		debugfs_remove_recursive(dss_debugfs_dir);
 }
 
-int dss_debugfs_create_file(const char *name, void (*write)(struct seq_file *))
+struct dss_debugfs_entry {
+	struct dentry *dentry;
+	int (*show_fn)(struct seq_file *s, void *data);
+	void *data;
+};
+
+static int dss_debug_open(struct inode *inode, struct file *file)
+{
+	struct dss_debugfs_entry *entry = inode->i_private;
+
+	return single_open(file, entry->show_fn, entry->data);
+}
+
+static const struct file_operations dss_debug_fops = {
+	.open		= dss_debug_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+struct dss_debugfs_entry *dss_debugfs_create_file(const char *name,
+		int (*show_fn)(struct seq_file *s, void *data), void *data)
 {
+	struct dss_debugfs_entry *entry;
 	struct dentry *d;
 
-	d = debugfs_create_file(name, S_IRUGO, dss_debugfs_dir,
-			write, &dss_debug_fops);
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return ERR_PTR(-ENOMEM);
+
+	entry->show_fn = show_fn;
+	entry->data = data;
 
-	return PTR_ERR_OR_ZERO(d);
+	d = debugfs_create_file(name, 0444, dss_debugfs_dir, entry,
+				&dss_debug_fops);
+	if (IS_ERR(d)) {
+		kfree(entry);
+		return ERR_PTR(PTR_ERR(d));
+	}
+
+	entry->dentry = d;
+	return entry;
+}
+
+void dss_debugfs_remove_file(struct dss_debugfs_entry *entry)
+{
+	if (IS_ERR_OR_NULL(entry))
+		return;
+
+	debugfs_remove(entry->dentry);
+	kfree(entry);
 }
+
 #else /* CONFIG_OMAP2_DSS_DEBUGFS */
 static inline int dss_initialize_debugfs(struct dss_device *dss)
 {
@@ -1449,7 +1472,9 @@ static int dss_probe(struct platform_device *pdev)
 	if (r)
 		goto err_pm_runtime_disable;
 
-	dss_debugfs_create_file("dss", dss_dump_regs);
+	dss->debugfs.clk = dss_debugfs_create_file("clk", dss_debug_dump_clocks,
+						   dss);
+	dss->debugfs.dss = dss_debugfs_create_file("dss", dss_dump_regs, dss);
 
 	/* Add all the child devices as components. */
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
@@ -1461,6 +1486,8 @@ static int dss_probe(struct platform_device *pdev)
 	return 0;
 
 err_uninit_debugfs:
+	dss_debugfs_remove_file(dss->debugfs.clk);
+	dss_debugfs_remove_file(dss->debugfs.dss);
 	dss_uninitialize_debugfs();
 
 err_pm_runtime_disable:
@@ -1488,6 +1515,8 @@ static int dss_remove(struct platform_device *pdev)
 
 	component_master_del(&pdev->dev, &dss_component_ops);
 
+	dss_debugfs_remove_file(dss->debugfs.clk);
+	dss_debugfs_remove_file(dss->debugfs.dss);
 	dss_uninitialize_debugfs();
 
 	pm_runtime_disable(&pdev->dev);

commit 360c21533ce79981bd9802622dd0b7a0dcd81395
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:28 2018 +0200

    drm: omapdrm: dss: Allocate the DSS private data structure dynamically
    
    The DSS private data structure is currently stored as a global variable.
    While no platform with multiple DSS devices currently exists nor is
    planned, this doesn't comply with the kernel device model and should
    thus be fixed.
    
    Allocate the DSS private data structure dynamically for each DSS
    instance and remove the global variable. All code that need access to
    the structure now retrieves it dynamically so we can remove the global
    variable.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7820b04c43e2..4b00faa1a8cc 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -62,11 +62,12 @@ struct dss_reg {
 #define DSS_PLL_CONTROL			DSS_REG(0x0048)
 #define DSS_SDI_STATUS			DSS_REG(0x005C)
 
-#define REG_GET(idx, start, end) \
-	FLD_GET(dss_read_reg(idx), start, end)
+#define REG_GET(dss, idx, start, end) \
+	FLD_GET(dss_read_reg(dss, idx), start, end)
 
-#define REG_FLD_MOD(idx, val, start, end) \
-	dss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))
+#define REG_FLD_MOD(dss, idx, val, start, end) \
+	dss_write_reg(dss, idx, \
+		      FLD_MOD(dss_read_reg(dss, idx), val, start, end))
 
 struct dss_ops {
 	int (*dpi_select_source)(struct dss_device *dss, int port,
@@ -90,8 +91,6 @@ struct dss_features {
 	bool has_lcd_clk_src;
 };
 
-static struct dss_device dss;
-
 static const char * const dss_generic_clk_source_names[] = {
 	[DSS_CLK_SRC_FCK]	= "FCK",
 	[DSS_CLK_SRC_PLL1_1]	= "PLL1:1",
@@ -103,49 +102,50 @@ static const char * const dss_generic_clk_source_names[] = {
 	[DSS_CLK_SRC_HDMI_PLL]	= "HDMI PLL",
 };
 
-static inline void dss_write_reg(const struct dss_reg idx, u32 val)
+static inline void dss_write_reg(struct dss_device *dss,
+				 const struct dss_reg idx, u32 val)
 {
-	__raw_writel(val, dss.base + idx.idx);
+	__raw_writel(val, dss->base + idx.idx);
 }
 
-static inline u32 dss_read_reg(const struct dss_reg idx)
+static inline u32 dss_read_reg(struct dss_device *dss, const struct dss_reg idx)
 {
-	return __raw_readl(dss.base + idx.idx);
+	return __raw_readl(dss->base + idx.idx);
 }
 
-#define SR(reg) \
-	dss.ctx[(DSS_##reg).idx / sizeof(u32)] = dss_read_reg(DSS_##reg)
-#define RR(reg) \
-	dss_write_reg(DSS_##reg, dss.ctx[(DSS_##reg).idx / sizeof(u32)])
+#define SR(dss, reg) \
+	dss->ctx[(DSS_##reg).idx / sizeof(u32)] = dss_read_reg(dss, DSS_##reg)
+#define RR(dss, reg) \
+	dss_write_reg(dss, DSS_##reg, dss->ctx[(DSS_##reg).idx / sizeof(u32)])
 
-static void dss_save_context(void)
+static void dss_save_context(struct dss_device *dss)
 {
 	DSSDBG("dss_save_context\n");
 
-	SR(CONTROL);
+	SR(dss, CONTROL);
 
-	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
-		SR(SDI_CONTROL);
-		SR(PLL_CONTROL);
+	if (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
+		SR(dss, SDI_CONTROL);
+		SR(dss, PLL_CONTROL);
 	}
 
-	dss.ctx_valid = true;
+	dss->ctx_valid = true;
 
 	DSSDBG("context saved\n");
 }
 
-static void dss_restore_context(void)
+static void dss_restore_context(struct dss_device *dss)
 {
 	DSSDBG("dss_restore_context\n");
 
-	if (!dss.ctx_valid)
+	if (!dss->ctx_valid)
 		return;
 
-	RR(CONTROL);
+	RR(dss, CONTROL);
 
-	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
-		RR(SDI_CONTROL);
-		RR(PLL_CONTROL);
+	if (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
+		RR(dss, SDI_CONTROL);
+		RR(dss, PLL_CONTROL);
 	}
 
 	DSSDBG("context restored\n");
@@ -184,12 +184,13 @@ void dss_ctrl_pll_enable(struct dss_pll *pll, bool enable)
 			   1 << shift, val << shift);
 }
 
-static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,
-	enum omap_channel channel)
+static int dss_ctrl_pll_set_control_mux(struct dss_device *dss,
+					enum dss_clk_source clk_src,
+					enum omap_channel channel)
 {
 	unsigned int shift, val;
 
-	if (!dss.syscon_pll_ctrl)
+	if (!dss->syscon_pll_ctrl)
 		return -EINVAL;
 
 	switch (channel) {
@@ -244,7 +245,7 @@ static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,
 		return -EINVAL;
 	}
 
-	regmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,
+	regmap_update_bits(dss->syscon_pll_ctrl, dss->syscon_pll_ctrl_offset,
 		0x3 << shift, val << shift);
 
 	return 0;
@@ -256,17 +257,17 @@ void dss_sdi_init(struct dss_device *dss, int datapairs)
 
 	BUG_ON(datapairs > 3 || datapairs < 1);
 
-	l = dss_read_reg(DSS_SDI_CONTROL);
+	l = dss_read_reg(dss, DSS_SDI_CONTROL);
 	l = FLD_MOD(l, 0xf, 19, 15);		/* SDI_PDIV */
 	l = FLD_MOD(l, datapairs-1, 3, 2);	/* SDI_PRSEL */
 	l = FLD_MOD(l, 2, 1, 0);		/* SDI_BWSEL */
-	dss_write_reg(DSS_SDI_CONTROL, l);
+	dss_write_reg(dss, DSS_SDI_CONTROL, l);
 
-	l = dss_read_reg(DSS_PLL_CONTROL);
+	l = dss_read_reg(dss, DSS_PLL_CONTROL);
 	l = FLD_MOD(l, 0x7, 25, 22);	/* SDI_PLL_FREQSEL */
 	l = FLD_MOD(l, 0xb, 16, 11);	/* SDI_PLL_REGN */
 	l = FLD_MOD(l, 0xb4, 10, 1);	/* SDI_PLL_REGM */
-	dss_write_reg(DSS_PLL_CONTROL, l);
+	dss_write_reg(dss, DSS_PLL_CONTROL, l);
 }
 
 int dss_sdi_enable(struct dss_device *dss)
@@ -276,15 +277,15 @@ int dss_sdi_enable(struct dss_device *dss)
 	dispc_pck_free_enable(1);
 
 	/* Reset SDI PLL */
-	REG_FLD_MOD(DSS_PLL_CONTROL, 1, 18, 18); /* SDI_PLL_SYSRESET */
+	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 18, 18); /* SDI_PLL_SYSRESET */
 	udelay(1);	/* wait 2x PCLK */
 
 	/* Lock SDI PLL */
-	REG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28); /* SDI_PLL_GOBIT */
+	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 28, 28); /* SDI_PLL_GOBIT */
 
 	/* Waiting for PLL lock request to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
-	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
+	while (dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 6)) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock request timed out\n");
 			goto err1;
@@ -292,11 +293,11 @@ int dss_sdi_enable(struct dss_device *dss)
 	}
 
 	/* Clearing PLL_GO bit */
-	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);
+	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 28, 28);
 
 	/* Waiting for PLL to lock */
 	timeout = jiffies + msecs_to_jiffies(500);
-	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
+	while (!(dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 5))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock timed out\n");
 			goto err1;
@@ -307,7 +308,7 @@ int dss_sdi_enable(struct dss_device *dss)
 
 	/* Waiting for SDI reset to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
-	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
+	while (!(dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 2))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("SDI reset timed out\n");
 			goto err2;
@@ -320,7 +321,7 @@ int dss_sdi_enable(struct dss_device *dss)
 	dispc_lcd_enable_signal(0);
  err1:
 	/* Reset SDI PLL */
-	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
+	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 
 	dispc_pck_free_enable(0);
 
@@ -334,7 +335,7 @@ void dss_sdi_disable(struct dss_device *dss)
 	dispc_pck_free_enable(0);
 
 	/* Reset SDI PLL */
-	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
+	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 }
 
 const char *dss_get_clk_source_name(enum dss_clk_source clk_src)
@@ -343,46 +344,48 @@ const char *dss_get_clk_source_name(enum dss_clk_source clk_src)
 }
 
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
-static void dss_dump_clocks(struct seq_file *s)
+static void dss_dump_clocks(struct dss_device *dss, struct seq_file *s)
 {
 	const char *fclk_name;
 	unsigned long fclk_rate;
 
-	if (dss_runtime_get(&dss))
+	if (dss_runtime_get(dss))
 		return;
 
 	seq_printf(s, "- DSS -\n");
 
 	fclk_name = dss_get_clk_source_name(DSS_CLK_SRC_FCK);
-	fclk_rate = clk_get_rate(dss.dss_clk);
+	fclk_rate = clk_get_rate(dss->dss_clk);
 
 	seq_printf(s, "%s = %lu\n",
 			fclk_name,
 			fclk_rate);
 
-	dss_runtime_put(&dss);
+	dss_runtime_put(dss);
 }
 #endif
 
 static void dss_dump_regs(struct seq_file *s)
 {
-#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))
+	struct dss_device *dss = s->private;
+
+#define DUMPREG(dss, r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(dss, r))
 
-	if (dss_runtime_get(&dss))
+	if (dss_runtime_get(dss))
 		return;
 
-	DUMPREG(DSS_REVISION);
-	DUMPREG(DSS_SYSCONFIG);
-	DUMPREG(DSS_SYSSTATUS);
-	DUMPREG(DSS_CONTROL);
+	DUMPREG(dss, DSS_REVISION);
+	DUMPREG(dss, DSS_SYSCONFIG);
+	DUMPREG(dss, DSS_SYSSTATUS);
+	DUMPREG(dss, DSS_CONTROL);
 
-	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
-		DUMPREG(DSS_SDI_CONTROL);
-		DUMPREG(DSS_PLL_CONTROL);
-		DUMPREG(DSS_SDI_STATUS);
+	if (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
+		DUMPREG(dss, DSS_SDI_CONTROL);
+		DUMPREG(dss, DSS_PLL_CONTROL);
+		DUMPREG(dss, DSS_SDI_STATUS);
 	}
 
-	dss_runtime_put(&dss);
+	dss_runtime_put(dss);
 #undef DUMPREG
 }
 
@@ -401,7 +404,8 @@ static int dss_get_channel_index(enum omap_channel channel)
 	}
 }
 
-static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
+static void dss_select_dispc_clk_source(struct dss_device *dss,
+					enum dss_clk_source clk_src)
 {
 	int b;
 
@@ -409,7 +413,7 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 	 * We always use PRCM clock as the DISPC func clock, except on DSS3,
 	 * where we don't have separate DISPC and LCD clock sources.
 	 */
-	if (WARN_ON(dss.feat->has_lcd_clk_src && clk_src != DSS_CLK_SRC_FCK))
+	if (WARN_ON(dss->feat->has_lcd_clk_src && clk_src != DSS_CLK_SRC_FCK))
 		return;
 
 	switch (clk_src) {
@@ -427,11 +431,11 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 		return;
 	}
 
-	REG_FLD_MOD(DSS_CONTROL, b,			/* DISPC_CLK_SWITCH */
-		    dss.feat->dispc_clk_switch.start,
-		    dss.feat->dispc_clk_switch.end);
+	REG_FLD_MOD(dss, DSS_CONTROL, b,		/* DISPC_CLK_SWITCH */
+		    dss->feat->dispc_clk_switch.start,
+		    dss->feat->dispc_clk_switch.end);
 
-	dss.dispc_clk_source = clk_src;
+	dss->dispc_clk_source = clk_src;
 }
 
 void dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,
@@ -457,7 +461,7 @@ void dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,
 	}
 
 	pos = dsi_module == 0 ? 1 : 10;
-	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* DSIx_CLK_SWITCH */
+	REG_FLD_MOD(dss, DSS_CONTROL, b, pos, pos);	/* DSIx_CLK_SWITCH */
 
 	dss->dsi_clk_source[dsi_module] = clk_src;
 }
@@ -477,15 +481,15 @@ static int dss_lcd_clk_mux_dra7(struct dss_device *dss,
 
 	if (clk_src == DSS_CLK_SRC_FCK) {
 		/* LCDx_CLK_SWITCH */
-		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		REG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
 		return -EINVAL;
 	}
 
-	r = dss_ctrl_pll_set_control_mux(clk_src, channel);
+	r = dss_ctrl_pll_set_control_mux(dss, clk_src, channel);
 	if (r)
 		return r;
 
-	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+	REG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
 
 	return 0;
 }
@@ -509,14 +513,14 @@ static int dss_lcd_clk_mux_omap5(struct dss_device *dss,
 
 	if (clk_src == DSS_CLK_SRC_FCK) {
 		/* LCDx_CLK_SWITCH */
-		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		REG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
 		return -EINVAL;
 	}
 
 	if (WARN_ON(allowed_plls[channel] != clk_src))
 		return -EINVAL;
 
-	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+	REG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
 
 	return 0;
 }
@@ -538,14 +542,14 @@ static int dss_lcd_clk_mux_omap4(struct dss_device *dss,
 
 	if (clk_src == DSS_CLK_SRC_FCK) {
 		/* LCDx_CLK_SWITCH */
-		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		REG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
 		return 0;
 	}
 
 	if (WARN_ON(allowed_plls[channel] != clk_src))
 		return -EINVAL;
 
-	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+	REG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
 
 	return 0;
 }
@@ -558,7 +562,7 @@ void dss_select_lcd_clk_source(struct dss_device *dss,
 	int r;
 
 	if (!dss->feat->has_lcd_clk_src) {
-		dss_select_dispc_clk_source(clk_src);
+		dss_select_dispc_clk_source(dss, clk_src);
 		dss->lcd_clk_source[idx] = clk_src;
 		return;
 	}
@@ -672,26 +676,27 @@ enum omap_dss_output_id dss_get_supported_outputs(struct dss_device *dss,
 	return dss->feat->outputs[channel];
 }
 
-static int dss_setup_default_clock(void)
+static int dss_setup_default_clock(struct dss_device *dss)
 {
 	unsigned long max_dss_fck, prate;
 	unsigned long fck;
 	unsigned int fck_div;
 	int r;
 
-	max_dss_fck = dss.feat->fck_freq_max;
+	max_dss_fck = dss->feat->fck_freq_max;
 
-	if (dss.parent_clk == NULL) {
-		fck = clk_round_rate(dss.dss_clk, max_dss_fck);
+	if (dss->parent_clk == NULL) {
+		fck = clk_round_rate(dss->dss_clk, max_dss_fck);
 	} else {
-		prate = clk_get_rate(dss.parent_clk);
+		prate = clk_get_rate(dss->parent_clk);
 
-		fck_div = DIV_ROUND_UP(prate * dss.feat->dss_fck_multiplier,
+		fck_div = DIV_ROUND_UP(prate * dss->feat->dss_fck_multiplier,
 				max_dss_fck);
-		fck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;
+		fck = DIV_ROUND_UP(prate, fck_div)
+		    * dss->feat->dss_fck_multiplier;
 	}
 
-	r = dss_set_fck_rate(&dss, fck);
+	r = dss_set_fck_rate(dss, fck);
 	if (r)
 		return r;
 
@@ -710,12 +715,13 @@ void dss_set_venc_output(struct dss_device *dss, enum omap_dss_venc_type type)
 		BUG();
 
 	/* venc out selection. 0 = comp, 1 = svideo */
-	REG_FLD_MOD(DSS_CONTROL, l, 6, 6);
+	REG_FLD_MOD(dss, DSS_CONTROL, l, 6, 6);
 }
 
 void dss_set_dac_pwrdn_bgz(struct dss_device *dss, bool enable)
 {
-	REG_FLD_MOD(DSS_CONTROL, enable, 5, 5);	/* DAC Power-Down Control */
+	/* DAC Power-Down Control */
+	REG_FLD_MOD(dss, DSS_CONTROL, enable, 5, 5);
 }
 
 void dss_select_hdmi_venc_clk_source(struct dss_device *dss,
@@ -732,7 +738,8 @@ void dss_select_hdmi_venc_clk_source(struct dss_device *dss,
 	/* Select only if we have options */
 	if ((outputs & OMAP_DSS_OUTPUT_VENC) &&
 	    (outputs & OMAP_DSS_OUTPUT_HDMI))
-		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
+		/* VENC_HDMI_SWITCH */
+		REG_FLD_MOD(dss, DSS_CONTROL, src, 15, 15);
 }
 
 static int dss_dpi_select_source_omap2_omap3(struct dss_device *dss, int port,
@@ -760,7 +767,7 @@ static int dss_dpi_select_source_omap4(struct dss_device *dss, int port,
 		return -EINVAL;
 	}
 
-	REG_FLD_MOD(DSS_CONTROL, val, 17, 17);
+	REG_FLD_MOD(dss, DSS_CONTROL, val, 17, 17);
 
 	return 0;
 }
@@ -787,7 +794,7 @@ static int dss_dpi_select_source_omap5(struct dss_device *dss, int port,
 		return -EINVAL;
 	}
 
-	REG_FLD_MOD(DSS_CONTROL, val, 17, 16);
+	REG_FLD_MOD(dss, DSS_CONTROL, val, 17, 16);
 
 	return 0;
 }
@@ -819,37 +826,38 @@ int dss_dpi_select_source(struct dss_device *dss, int port,
 	return dss->feat->ops->dpi_select_source(dss, port, channel);
 }
 
-static int dss_get_clocks(void)
+static int dss_get_clocks(struct dss_device *dss)
 {
 	struct clk *clk;
 
-	clk = devm_clk_get(&dss.pdev->dev, "fck");
+	clk = devm_clk_get(&dss->pdev->dev, "fck");
 	if (IS_ERR(clk)) {
 		DSSERR("can't get clock fck\n");
 		return PTR_ERR(clk);
 	}
 
-	dss.dss_clk = clk;
+	dss->dss_clk = clk;
 
-	if (dss.feat->parent_clk_name) {
-		clk = clk_get(NULL, dss.feat->parent_clk_name);
+	if (dss->feat->parent_clk_name) {
+		clk = clk_get(NULL, dss->feat->parent_clk_name);
 		if (IS_ERR(clk)) {
-			DSSERR("Failed to get %s\n", dss.feat->parent_clk_name);
+			DSSERR("Failed to get %s\n",
+			       dss->feat->parent_clk_name);
 			return PTR_ERR(clk);
 		}
 	} else {
 		clk = NULL;
 	}
 
-	dss.parent_clk = clk;
+	dss->parent_clk = clk;
 
 	return 0;
 }
 
-static void dss_put_clocks(void)
+static void dss_put_clocks(struct dss_device *dss)
 {
-	if (dss.parent_clk)
-		clk_put(dss.parent_clk);
+	if (dss->parent_clk)
+		clk_put(dss->parent_clk);
 }
 
 int dss_runtime_get(struct dss_device *dss)
@@ -875,14 +883,16 @@ void dss_runtime_put(struct dss_device *dss)
 
 struct dss_device *dss_get_device(struct device *dev)
 {
-	return &dss;
+	return dev_get_drvdata(dev);
 }
 
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
 static void dss_debug_dump_clocks(struct seq_file *s)
 {
-	dss_dump_clocks(s);
+	struct dss_device *dss = s->private;
+
+	dss_dump_clocks(dss, s);
 	dispc_dump_clocks(s);
 #ifdef CONFIG_OMAP2_DSS_DSI
 	dsi_dump_clocks(s);
@@ -911,7 +921,7 @@ static const struct file_operations dss_debug_fops = {
 
 static struct dentry *dss_debugfs_dir;
 
-static int dss_initialize_debugfs(void)
+static int dss_initialize_debugfs(struct dss_device *dss)
 {
 	dss_debugfs_dir = debugfs_create_dir("omapdss", NULL);
 	if (IS_ERR(dss_debugfs_dir)) {
@@ -943,7 +953,7 @@ int dss_debugfs_create_file(const char *name, void (*write)(struct seq_file *))
 	return PTR_ERR_OR_ZERO(d);
 }
 #else /* CONFIG_OMAP2_DSS_DEBUGFS */
-static inline int dss_initialize_debugfs(void)
+static inline int dss_initialize_debugfs(struct dss_device *dss)
 {
 	return 0;
 }
@@ -1148,23 +1158,24 @@ static const struct dss_features dra7xx_dss_feats = {
 	.has_lcd_clk_src	=	true,
 };
 
-static int dss_init_ports(struct platform_device *pdev)
+static int dss_init_ports(struct dss_device *dss)
 {
+	struct platform_device *pdev = dss->pdev;
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
 	int i;
 
-	for (i = 0; i < dss.feat->num_ports; i++) {
+	for (i = 0; i < dss->feat->num_ports; i++) {
 		port = of_graph_get_port_by_id(parent, i);
 		if (!port)
 			continue;
 
-		switch (dss.feat->ports[i]) {
+		switch (dss->feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_port(&dss, pdev, port, dss.feat->model);
+			dpi_init_port(dss, pdev, port, dss->feat->model);
 			break;
 		case OMAP_DISPLAY_TYPE_SDI:
-			sdi_init_port(&dss, pdev, port);
+			sdi_init_port(dss, pdev, port);
 			break;
 		default:
 			break;
@@ -1174,18 +1185,19 @@ static int dss_init_ports(struct platform_device *pdev)
 	return 0;
 }
 
-static void dss_uninit_ports(struct platform_device *pdev)
+static void dss_uninit_ports(struct dss_device *dss)
 {
+	struct platform_device *pdev = dss->pdev;
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
 	int i;
 
-	for (i = 0; i < dss.feat->num_ports; i++) {
+	for (i = 0; i < dss->feat->num_ports; i++) {
 		port = of_graph_get_port_by_id(parent, i);
 		if (!port)
 			continue;
 
-		switch (dss.feat->ports[i]) {
+		switch (dss->feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
 			dpi_uninit_port(port);
 			break;
@@ -1198,8 +1210,9 @@ static void dss_uninit_ports(struct platform_device *pdev)
 	}
 }
 
-static int dss_video_pll_probe(struct platform_device *pdev)
+static int dss_video_pll_probe(struct dss_device *dss)
 {
+	struct platform_device *pdev = dss->pdev;
 	struct device_node *np = pdev->dev.of_node;
 	struct regulator *pll_regulator;
 	int r;
@@ -1208,16 +1221,16 @@ static int dss_video_pll_probe(struct platform_device *pdev)
 		return 0;
 
 	if (of_property_read_bool(np, "syscon-pll-ctrl")) {
-		dss.syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,
+		dss->syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,
 			"syscon-pll-ctrl");
-		if (IS_ERR(dss.syscon_pll_ctrl)) {
+		if (IS_ERR(dss->syscon_pll_ctrl)) {
 			dev_err(&pdev->dev,
 				"failed to get syscon-pll-ctrl regmap\n");
-			return PTR_ERR(dss.syscon_pll_ctrl);
+			return PTR_ERR(dss->syscon_pll_ctrl);
 		}
 
 		if (of_property_read_u32_index(np, "syscon-pll-ctrl", 1,
-				&dss.syscon_pll_ctrl_offset)) {
+				&dss->syscon_pll_ctrl_offset)) {
 			dev_err(&pdev->dev,
 				"failed to get syscon-pll-ctrl offset\n");
 			return -EINVAL;
@@ -1243,18 +1256,18 @@ static int dss_video_pll_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll1") >= 0) {
-		dss.video1_pll = dss_video_pll_init(&dss, pdev, 0,
-						    pll_regulator);
-		if (IS_ERR(dss.video1_pll))
-			return PTR_ERR(dss.video1_pll);
+		dss->video1_pll = dss_video_pll_init(dss, pdev, 0,
+						     pll_regulator);
+		if (IS_ERR(dss->video1_pll))
+			return PTR_ERR(dss->video1_pll);
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll2") >= 0) {
-		dss.video2_pll = dss_video_pll_init(&dss, pdev, 1,
-						    pll_regulator);
-		if (IS_ERR(dss.video2_pll)) {
-			dss_video_pll_uninit(dss.video1_pll);
-			return PTR_ERR(dss.video2_pll);
+		dss->video2_pll = dss_video_pll_init(dss, pdev, 1,
+						     pll_regulator);
+		if (IS_ERR(dss->video2_pll)) {
+			dss_video_pll_uninit(dss->video1_pll);
+			return PTR_ERR(dss->video2_pll);
 		}
 	}
 
@@ -1345,14 +1358,14 @@ static int dss_probe_hardware(struct dss_device *dss)
 	dss->dss_clk_rate = clk_get_rate(dss->dss_clk);
 
 	/* Select DPLL */
-	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
+	REG_FLD_MOD(dss, DSS_CONTROL, 0, 0, 0);
 
-	dss_select_dispc_clk_source(DSS_CLK_SRC_FCK);
+	dss_select_dispc_clk_source(dss, DSS_CLK_SRC_FCK);
 
 #ifdef CONFIG_OMAP2_DSS_VENC
-	REG_FLD_MOD(DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
-	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
-	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
+	REG_FLD_MOD(dss, DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
+	REG_FLD_MOD(dss, DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
+	REG_FLD_MOD(dss, DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
 #endif
 	dss->dsi_clk_source[0] = DSS_CLK_SRC_FCK;
 	dss->dsi_clk_source[1] = DSS_CLK_SRC_FCK;
@@ -1360,7 +1373,7 @@ static int dss_probe_hardware(struct dss_device *dss)
 	dss->lcd_clk_source[0] = DSS_CLK_SRC_FCK;
 	dss->lcd_clk_source[1] = DSS_CLK_SRC_FCK;
 
-	rev = dss_read_reg(DSS_REVISION);
+	rev = dss_read_reg(dss, DSS_REVISION);
 	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
 	dss_runtime_put(dss);
@@ -1373,14 +1386,20 @@ static int dss_probe(struct platform_device *pdev)
 	const struct soc_device_attribute *soc;
 	struct component_match *match = NULL;
 	struct resource *dss_mem;
+	struct dss_device *dss;
 	int r;
 
-	dss.pdev = pdev;
+	dss = kzalloc(sizeof(*dss), GFP_KERNEL);
+	if (!dss)
+		return -ENOMEM;
+
+	dss->pdev = pdev;
+	platform_set_drvdata(pdev, dss);
 
 	r = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 	if (r) {
 		dev_err(&pdev->dev, "Failed to set the DMA mask\n");
-		return r;
+		goto err_free_dss;
 	}
 
 	/*
@@ -1389,42 +1408,44 @@ static int dss_probe(struct platform_device *pdev)
 	 */
 	soc = soc_device_match(dss_soc_devices);
 	if (soc)
-		dss.feat = soc->data;
+		dss->feat = soc->data;
 	else
-		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
+		dss->feat = of_match_device(dss_of_match, &pdev->dev)->data;
 
 	/* Map I/O registers, get and setup clocks. */
 	dss_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
-	if (IS_ERR(dss.base))
-		return PTR_ERR(dss.base);
+	dss->base = devm_ioremap_resource(&pdev->dev, dss_mem);
+	if (IS_ERR(dss->base)) {
+		r = PTR_ERR(dss->base);
+		goto err_free_dss;
+	}
 
-	r = dss_get_clocks();
+	r = dss_get_clocks(dss);
 	if (r)
-		return r;
+		goto err_free_dss;
 
-	r = dss_setup_default_clock();
+	r = dss_setup_default_clock(dss);
 	if (r)
 		goto err_put_clocks;
 
 	/* Setup the video PLLs and the DPI and SDI ports. */
-	r = dss_video_pll_probe(pdev);
+	r = dss_video_pll_probe(dss);
 	if (r)
 		goto err_put_clocks;
 
-	r = dss_init_ports(pdev);
+	r = dss_init_ports(dss);
 	if (r)
 		goto err_uninit_plls;
 
 	/* Enable runtime PM and probe the hardware. */
 	pm_runtime_enable(&pdev->dev);
 
-	r = dss_probe_hardware(&dss);
+	r = dss_probe_hardware(dss);
 	if (r)
 		goto err_pm_runtime_disable;
 
 	/* Initialize debugfs. */
-	r = dss_initialize_debugfs();
+	r = dss_initialize_debugfs(dss);
 	if (r)
 		goto err_pm_runtime_disable;
 
@@ -1444,37 +1465,44 @@ static int dss_probe(struct platform_device *pdev)
 
 err_pm_runtime_disable:
 	pm_runtime_disable(&pdev->dev);
-	dss_uninit_ports(pdev);
+	dss_uninit_ports(dss);
 
 err_uninit_plls:
-	if (dss.video1_pll)
-		dss_video_pll_uninit(dss.video1_pll);
-	if (dss.video2_pll)
-		dss_video_pll_uninit(dss.video2_pll);
+	if (dss->video1_pll)
+		dss_video_pll_uninit(dss->video1_pll);
+	if (dss->video2_pll)
+		dss_video_pll_uninit(dss->video2_pll);
 
 err_put_clocks:
-	dss_put_clocks();
+	dss_put_clocks(dss);
+
+err_free_dss:
+	kfree(dss);
 
 	return r;
 }
 
 static int dss_remove(struct platform_device *pdev)
 {
+	struct dss_device *dss = platform_get_drvdata(pdev);
+
 	component_master_del(&pdev->dev, &dss_component_ops);
 
 	dss_uninitialize_debugfs();
 
 	pm_runtime_disable(&pdev->dev);
 
-	dss_uninit_ports(pdev);
+	dss_uninit_ports(dss);
+
+	if (dss->video1_pll)
+		dss_video_pll_uninit(dss->video1_pll);
 
-	if (dss.video1_pll)
-		dss_video_pll_uninit(dss.video1_pll);
+	if (dss->video2_pll)
+		dss_video_pll_uninit(dss->video2_pll);
 
-	if (dss.video2_pll)
-		dss_video_pll_uninit(dss.video2_pll);
+	dss_put_clocks(dss);
 
-	dss_put_clocks();
+	kfree(dss);
 
 	return 0;
 }
@@ -1496,7 +1524,9 @@ static void dss_shutdown(struct platform_device *pdev)
 
 static int dss_runtime_suspend(struct device *dev)
 {
-	dss_save_context();
+	struct dss_device *dss = dev_get_drvdata(dev);
+
+	dss_save_context(dss);
 	dss_set_min_bus_tput(dev, 0);
 
 	pinctrl_pm_select_sleep_state(dev);
@@ -1506,6 +1536,7 @@ static int dss_runtime_suspend(struct device *dev)
 
 static int dss_runtime_resume(struct device *dev)
 {
+	struct dss_device *dss = dev_get_drvdata(dev);
 	int r;
 
 	pinctrl_pm_select_default_state(dev);
@@ -1521,7 +1552,7 @@ static int dss_runtime_resume(struct device *dev)
 	if (r)
 		return r;
 
-	dss_restore_context();
+	dss_restore_context(dss);
 	return 0;
 }
 

commit 1ef904e1e4f05d32331783d413e341c6353ae9aa
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:27 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to remaining dss functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 0d292da6757d..7820b04c43e2 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -666,9 +666,10 @@ unsigned long dss_get_max_fck_rate(struct dss_device *dss)
 	return dss->feat->fck_freq_max;
 }
 
-enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel)
+enum omap_dss_output_id dss_get_supported_outputs(struct dss_device *dss,
+						  enum omap_channel channel)
 {
-	return dss.feat->outputs[channel];
+	return dss->feat->outputs[channel];
 }
 
 static int dss_setup_default_clock(void)
@@ -697,7 +698,7 @@ static int dss_setup_default_clock(void)
 	return 0;
 }
 
-void dss_set_venc_output(enum omap_dss_venc_type type)
+void dss_set_venc_output(struct dss_device *dss, enum omap_dss_venc_type type)
 {
 	int l = 0;
 
@@ -712,7 +713,7 @@ void dss_set_venc_output(enum omap_dss_venc_type type)
 	REG_FLD_MOD(DSS_CONTROL, l, 6, 6);
 }
 
-void dss_set_dac_pwrdn_bgz(bool enable)
+void dss_set_dac_pwrdn_bgz(struct dss_device *dss, bool enable)
 {
 	REG_FLD_MOD(DSS_CONTROL, enable, 5, 5);	/* DAC Power-Down Control */
 }

commit 60f9c59fc1e2ced4a02e91088c367395edacc7fe
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:26 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss clock functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index bdf8f66002b6..0d292da6757d 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -594,8 +594,8 @@ enum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,
 	}
 }
 
-bool dss_div_calc(unsigned long pck, unsigned long fck_min,
-		dss_div_calc_func func, void *data)
+bool dss_div_calc(struct dss_device *dss, unsigned long pck,
+		  unsigned long fck_min, dss_div_calc_func func, void *data)
 {
 	int fckd, fckd_start, fckd_stop;
 	unsigned long fck;
@@ -604,24 +604,24 @@ bool dss_div_calc(unsigned long pck, unsigned long fck_min,
 	unsigned long prate;
 	unsigned int m;
 
-	fck_hw_max = dss.feat->fck_freq_max;
+	fck_hw_max = dss->feat->fck_freq_max;
 
-	if (dss.parent_clk == NULL) {
+	if (dss->parent_clk == NULL) {
 		unsigned int pckd;
 
 		pckd = fck_hw_max / pck;
 
 		fck = pck * pckd;
 
-		fck = clk_round_rate(dss.dss_clk, fck);
+		fck = clk_round_rate(dss->dss_clk, fck);
 
 		return func(fck, data);
 	}
 
-	fckd_hw_max = dss.feat->fck_div_max;
+	fckd_hw_max = dss->feat->fck_div_max;
 
-	m = dss.feat->dss_fck_multiplier;
-	prate = clk_get_rate(dss.parent_clk);
+	m = dss->feat->dss_fck_multiplier;
+	prate = clk_get_rate(dss->parent_clk);
 
 	fck_min = fck_min ? fck_min : 1;
 
@@ -638,33 +638,32 @@ bool dss_div_calc(unsigned long pck, unsigned long fck_min,
 	return false;
 }
 
-int dss_set_fck_rate(unsigned long rate)
+int dss_set_fck_rate(struct dss_device *dss, unsigned long rate)
 {
 	int r;
 
 	DSSDBG("set fck to %lu\n", rate);
 
-	r = clk_set_rate(dss.dss_clk, rate);
+	r = clk_set_rate(dss->dss_clk, rate);
 	if (r)
 		return r;
 
-	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+	dss->dss_clk_rate = clk_get_rate(dss->dss_clk);
 
-	WARN_ONCE(dss.dss_clk_rate != rate,
-			"clk rate mismatch: %lu != %lu", dss.dss_clk_rate,
-			rate);
+	WARN_ONCE(dss->dss_clk_rate != rate, "clk rate mismatch: %lu != %lu",
+		  dss->dss_clk_rate, rate);
 
 	return 0;
 }
 
-unsigned long dss_get_dispc_clk_rate(void)
+unsigned long dss_get_dispc_clk_rate(struct dss_device *dss)
 {
-	return dss.dss_clk_rate;
+	return dss->dss_clk_rate;
 }
 
-unsigned long dss_get_max_fck_rate(void)
+unsigned long dss_get_max_fck_rate(struct dss_device *dss)
 {
-	return dss.feat->fck_freq_max;
+	return dss->feat->fck_freq_max;
 }
 
 enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel)
@@ -691,7 +690,7 @@ static int dss_setup_default_clock(void)
 		fck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;
 	}
 
-	r = dss_set_fck_rate(fck);
+	r = dss_set_fck_rate(&dss, fck);
 	if (r)
 		return r;
 

commit 3cc62aadf414102785adbfc3dd2f2f3be85d60db
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:25 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss_get_*_clk_source()
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 73698a497e4a..bdf8f66002b6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -570,25 +570,27 @@ void dss_select_lcd_clk_source(struct dss_device *dss,
 	dss->lcd_clk_source[idx] = clk_src;
 }
 
-enum dss_clk_source dss_get_dispc_clk_source(void)
+enum dss_clk_source dss_get_dispc_clk_source(struct dss_device *dss)
 {
-	return dss.dispc_clk_source;
+	return dss->dispc_clk_source;
 }
 
-enum dss_clk_source dss_get_dsi_clk_source(int dsi_module)
+enum dss_clk_source dss_get_dsi_clk_source(struct dss_device *dss,
+					   int dsi_module)
 {
-	return dss.dsi_clk_source[dsi_module];
+	return dss->dsi_clk_source[dsi_module];
 }
 
-enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
+enum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,
+					   enum omap_channel channel)
 {
-	if (dss.feat->has_lcd_clk_src) {
+	if (dss->feat->has_lcd_clk_src) {
 		int idx = dss_get_channel_index(channel);
-		return dss.lcd_clk_source[idx];
+		return dss->lcd_clk_source[idx];
 	} else {
 		/* LCD_CLK source is the same as DISPC_FCLK source for
 		 * OMAP2 and OMAP3 */
-		return dss.dispc_clk_source;
+		return dss->dispc_clk_source;
 	}
 }
 

commit 8aea8e6a79e77f4c4af4edc45db744f28f6fe008
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:24 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss_ops operations
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index c6a0b004b545..73698a497e4a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -69,9 +69,11 @@ struct dss_reg {
 	dss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))
 
 struct dss_ops {
-	int (*dpi_select_source)(int port, enum omap_channel channel);
-	int (*select_lcd_source)(enum omap_channel channel,
-		enum dss_clk_source clk_src);
+	int (*dpi_select_source)(struct dss_device *dss, int port,
+				 enum omap_channel channel);
+	int (*select_lcd_source)(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src);
 };
 
 struct dss_features {
@@ -432,8 +434,8 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 	dss.dispc_clk_source = clk_src;
 }
 
-void dss_select_dsi_clk_source(int dsi_module,
-		enum dss_clk_source clk_src)
+void dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,
+			       enum dss_clk_source clk_src)
 {
 	int b, pos;
 
@@ -457,11 +459,12 @@ void dss_select_dsi_clk_source(int dsi_module,
 	pos = dsi_module == 0 ? 1 : 10;
 	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* DSIx_CLK_SWITCH */
 
-	dss.dsi_clk_source[dsi_module] = clk_src;
+	dss->dsi_clk_source[dsi_module] = clk_src;
 }
 
-static int dss_lcd_clk_mux_dra7(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_dra7(struct dss_device *dss,
+				enum omap_channel channel,
+				enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -487,8 +490,9 @@ static int dss_lcd_clk_mux_dra7(enum omap_channel channel,
 	return 0;
 }
 
-static int dss_lcd_clk_mux_omap5(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_omap5(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -517,8 +521,9 @@ static int dss_lcd_clk_mux_omap5(enum omap_channel channel,
 	return 0;
 }
 
-static int dss_lcd_clk_mux_omap4(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_omap4(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -545,23 +550,24 @@ static int dss_lcd_clk_mux_omap4(enum omap_channel channel,
 	return 0;
 }
 
-void dss_select_lcd_clk_source(enum omap_channel channel,
-		enum dss_clk_source clk_src)
+void dss_select_lcd_clk_source(struct dss_device *dss,
+			       enum omap_channel channel,
+			       enum dss_clk_source clk_src)
 {
 	int idx = dss_get_channel_index(channel);
 	int r;
 
-	if (!dss.feat->has_lcd_clk_src) {
+	if (!dss->feat->has_lcd_clk_src) {
 		dss_select_dispc_clk_source(clk_src);
-		dss.lcd_clk_source[idx] = clk_src;
+		dss->lcd_clk_source[idx] = clk_src;
 		return;
 	}
 
-	r = dss.feat->ops->select_lcd_source(channel, clk_src);
+	r = dss->feat->ops->select_lcd_source(dss, channel, clk_src);
 	if (r)
 		return;
 
-	dss.lcd_clk_source[idx] = clk_src;
+	dss->lcd_clk_source[idx] = clk_src;
 }
 
 enum dss_clk_source dss_get_dispc_clk_source(void)
@@ -710,11 +716,12 @@ void dss_set_dac_pwrdn_bgz(bool enable)
 	REG_FLD_MOD(DSS_CONTROL, enable, 5, 5);	/* DAC Power-Down Control */
 }
 
-void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
+void dss_select_hdmi_venc_clk_source(struct dss_device *dss,
+				     enum dss_hdmi_venc_clk_source_select src)
 {
 	enum omap_dss_output_id outputs;
 
-	outputs = dss.feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
+	outputs = dss->feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
 
 	/* Complain about invalid selections */
 	WARN_ON((src == DSS_VENC_TV_CLK) && !(outputs & OMAP_DSS_OUTPUT_VENC));
@@ -726,7 +733,8 @@ void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
 		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
 }
 
-static int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap2_omap3(struct dss_device *dss, int port,
+					     enum omap_channel channel)
 {
 	if (channel != OMAP_DSS_CHANNEL_LCD)
 		return -EINVAL;
@@ -734,7 +742,8 @@ static int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel
 	return 0;
 }
 
-static int dss_dpi_select_source_omap4(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap4(struct dss_device *dss, int port,
+				       enum omap_channel channel)
 {
 	int val;
 
@@ -754,7 +763,8 @@ static int dss_dpi_select_source_omap4(int port, enum omap_channel channel)
 	return 0;
 }
 
-static int dss_dpi_select_source_omap5(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap5(struct dss_device *dss, int port,
+				       enum omap_channel channel)
 {
 	int val;
 
@@ -780,11 +790,12 @@ static int dss_dpi_select_source_omap5(int port, enum omap_channel channel)
 	return 0;
 }
 
-static int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)
+static int dss_dpi_select_source_dra7xx(struct dss_device *dss, int port,
+					enum omap_channel channel)
 {
 	switch (port) {
 	case 0:
-		return dss_dpi_select_source_omap5(port, channel);
+		return dss_dpi_select_source_omap5(dss, port, channel);
 	case 1:
 		if (channel != OMAP_DSS_CHANNEL_LCD2)
 			return -EINVAL;
@@ -800,9 +811,10 @@ static int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)
 	return 0;
 }
 
-int dss_dpi_select_source(int port, enum omap_channel channel)
+int dss_dpi_select_source(struct dss_device *dss, int port,
+			  enum omap_channel channel)
 {
-	return dss.feat->ops->dpi_select_source(port, channel);
+	return dss->feat->ops->dpi_select_source(dss, port, channel);
 }
 
 static int dss_get_clocks(void)
@@ -1147,7 +1159,7 @@ static int dss_init_ports(struct platform_device *pdev)
 
 		switch (dss.feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_port(pdev, port, dss.feat->model);
+			dpi_init_port(&dss, pdev, port, dss.feat->model);
 			break;
 		case OMAP_DISPLAY_TYPE_SDI:
 			sdi_init_port(&dss, pdev, port);

commit d7157dfe0460fb003d41c1a5c36788de9b639ecb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:23 2018 +0200

    drm: omapdrm: dss: Pass DSS pointer to dss_sdi_*() functions
    
    This removes the need to access the global DSS private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DSS device dynamically).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 29c3a0dba698..c6a0b004b545 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -248,7 +248,7 @@ static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,
 	return 0;
 }
 
-void dss_sdi_init(int datapairs)
+void dss_sdi_init(struct dss_device *dss, int datapairs)
 {
 	u32 l;
 
@@ -267,7 +267,7 @@ void dss_sdi_init(int datapairs)
 	dss_write_reg(DSS_PLL_CONTROL, l);
 }
 
-int dss_sdi_enable(void)
+int dss_sdi_enable(struct dss_device *dss)
 {
 	unsigned long timeout;
 
@@ -325,7 +325,7 @@ int dss_sdi_enable(void)
 	return -ETIMEDOUT;
 }
 
-void dss_sdi_disable(void)
+void dss_sdi_disable(struct dss_device *dss)
 {
 	dispc_lcd_enable_signal(0);
 
@@ -1150,7 +1150,7 @@ static int dss_init_ports(struct platform_device *pdev)
 			dpi_init_port(pdev, port, dss.feat->model);
 			break;
 		case OMAP_DISPLAY_TYPE_SDI:
-			sdi_init_port(pdev, port);
+			sdi_init_port(&dss, pdev, port);
 			break;
 		default:
 			break;

commit 2726099921caab2473dca91c9ddc4f4a108f4c15
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:22 2018 +0200

    drm: omapdrm: dss: Pass PLL pointer to dss_ctrl_pll_enable()
    
    This will allow accessing the PLL data to get the DSS device pointer,
    removing the need to access the global DSS private data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 6c28e13d9ae0..29c3a0dba698 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -152,17 +152,17 @@ static void dss_restore_context(void)
 #undef SR
 #undef RR
 
-void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
+void dss_ctrl_pll_enable(struct dss_pll *pll, bool enable)
 {
 	unsigned int shift;
 	unsigned int val;
 
-	if (!dss.syscon_pll_ctrl)
+	if (!pll->dss->syscon_pll_ctrl)
 		return;
 
 	val = !enable;
 
-	switch (pll_id) {
+	switch (pll->id) {
 	case DSS_PLL_VIDEO1:
 		shift = 0;
 		break;
@@ -173,12 +173,13 @@ void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
 		shift = 2;
 		break;
 	default:
-		DSSERR("illegal DSS PLL ID %d\n", pll_id);
+		DSSERR("illegal DSS PLL ID %d\n", pll->id);
 		return;
 	}
 
-	regmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,
-		1 << shift, val << shift);
+	regmap_update_bits(pll->dss->syscon_pll_ctrl,
+			   pll->dss->syscon_pll_ctrl_offset,
+			   1 << shift, val << shift);
 }
 
 static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,

commit 7b295257a13d827dac8c71af70e633c7ba722cfe
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:21 2018 +0200

    drm: omapdrm: dss: Pass DSS private structure to runtime PM functions
    
    To prepare for the removal of the global variable storing DSS private
    data, pass its pointer to the dss_runtime_{get,put}() functions.
    
    As this requires getting hold of the dss_device structure in the
    callers, we add a new dss_get_device() function to retrieve it. The
    function currently returns a pointer to the global data structure, and
    will later be updated to get the pointer from device driver data when
    the DSS private structure will be allocated dynamically.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 245d8c0ae461..6c28e13d9ae0 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -345,7 +345,7 @@ static void dss_dump_clocks(struct seq_file *s)
 	const char *fclk_name;
 	unsigned long fclk_rate;
 
-	if (dss_runtime_get())
+	if (dss_runtime_get(&dss))
 		return;
 
 	seq_printf(s, "- DSS -\n");
@@ -357,7 +357,7 @@ static void dss_dump_clocks(struct seq_file *s)
 			fclk_name,
 			fclk_rate);
 
-	dss_runtime_put();
+	dss_runtime_put(&dss);
 }
 #endif
 
@@ -365,7 +365,7 @@ static void dss_dump_regs(struct seq_file *s)
 {
 #define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))
 
-	if (dss_runtime_get())
+	if (dss_runtime_get(&dss))
 		return;
 
 	DUMPREG(DSS_REVISION);
@@ -379,7 +379,7 @@ static void dss_dump_regs(struct seq_file *s)
 		DUMPREG(DSS_SDI_STATUS);
 	}
 
-	dss_runtime_put();
+	dss_runtime_put(&dss);
 #undef DUMPREG
 }
 
@@ -837,27 +837,32 @@ static void dss_put_clocks(void)
 		clk_put(dss.parent_clk);
 }
 
-int dss_runtime_get(void)
+int dss_runtime_get(struct dss_device *dss)
 {
 	int r;
 
 	DSSDBG("dss_runtime_get\n");
 
-	r = pm_runtime_get_sync(&dss.pdev->dev);
+	r = pm_runtime_get_sync(&dss->pdev->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
 
-void dss_runtime_put(void)
+void dss_runtime_put(struct dss_device *dss)
 {
 	int r;
 
 	DSSDBG("dss_runtime_put\n");
 
-	r = pm_runtime_put_sync(&dss.pdev->dev);
+	r = pm_runtime_put_sync(&dss->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);
 }
 
+struct dss_device *dss_get_device(struct device *dev)
+{
+	return &dss;
+}
+
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
 static void dss_debug_dump_clocks(struct seq_file *s)
@@ -1223,13 +1228,15 @@ static int dss_video_pll_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll1") >= 0) {
-		dss.video1_pll = dss_video_pll_init(pdev, 0, pll_regulator);
+		dss.video1_pll = dss_video_pll_init(&dss, pdev, 0,
+						    pll_regulator);
 		if (IS_ERR(dss.video1_pll))
 			return PTR_ERR(dss.video1_pll);
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll2") >= 0) {
-		dss.video2_pll = dss_video_pll_init(pdev, 1, pll_regulator);
+		dss.video2_pll = dss_video_pll_init(&dss, pdev, 1,
+						    pll_regulator);
 		if (IS_ERR(dss.video2_pll)) {
 			dss_video_pll_uninit(dss.video1_pll);
 			return PTR_ERR(dss.video2_pll);
@@ -1311,16 +1318,16 @@ static int dss_add_child_component(struct device *dev, void *data)
 	return 0;
 }
 
-static int dss_probe_hardware(void)
+static int dss_probe_hardware(struct dss_device *dss)
 {
 	u32 rev;
 	int r;
 
-	r = dss_runtime_get();
+	r = dss_runtime_get(dss);
 	if (r)
 		return r;
 
-	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+	dss->dss_clk_rate = clk_get_rate(dss->dss_clk);
 
 	/* Select DPLL */
 	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
@@ -1332,16 +1339,16 @@ static int dss_probe_hardware(void)
 	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
 	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
 #endif
-	dss.dsi_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.dsi_clk_source[1] = DSS_CLK_SRC_FCK;
-	dss.dispc_clk_source = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss->dsi_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss->dsi_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss->dispc_clk_source = DSS_CLK_SRC_FCK;
+	dss->lcd_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss->lcd_clk_source[1] = DSS_CLK_SRC_FCK;
 
 	rev = dss_read_reg(DSS_REVISION);
 	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
-	dss_runtime_put();
+	dss_runtime_put(dss);
 
 	return 0;
 }
@@ -1397,7 +1404,7 @@ static int dss_probe(struct platform_device *pdev)
 	/* Enable runtime PM and probe the hardware. */
 	pm_runtime_enable(&pdev->dev);
 
-	r = dss_probe_hardware();
+	r = dss_probe_hardware(&dss);
 	if (r)
 		goto err_pm_runtime_disable;
 

commit 0e546dfd3fa82c0d78cc12d04af9ee8d7cb07c29
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:20 2018 +0200

    drm: omapdrm: dss: Expose DSS data in a dss_device structure
    
    The anoonymous dss structure in dss.c is the top-level component in the
    omapdss driver. As such it should store all internal instance-specific
    data that is currently stored in global variables. This however requires
    both naming the structure to pass it around functions, and accessing it
    from various locations in the omapdss driver. While we could implement
    get and set functions for every field that needs to be accessed outside
    of dss.c, that would introduce overhead and complexity that we could
    avoid by exposing the structure to internal components of the omapdss
    driver. Do so to prepare for removal of global variables.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index d5490336e7c7..245d8c0ae461 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -48,8 +48,6 @@
 #include "omapdss.h"
 #include "dss.h"
 
-#define DSS_SZ_REGS			SZ_512
-
 struct dss_reg {
 	u16 idx;
 };
@@ -90,32 +88,7 @@ struct dss_features {
 	bool has_lcd_clk_src;
 };
 
-static struct {
-	struct platform_device *pdev;
-	void __iomem    *base;
-	struct regmap	*syscon_pll_ctrl;
-	u32		syscon_pll_ctrl_offset;
-
-	struct clk	*parent_clk;
-	struct clk	*dss_clk;
-	unsigned long	dss_clk_rate;
-
-	unsigned long	cache_req_pck;
-	unsigned long	cache_prate;
-	struct dispc_clock_info cache_dispc_cinfo;
-
-	enum dss_clk_source dsi_clk_source[MAX_NUM_DSI];
-	enum dss_clk_source dispc_clk_source;
-	enum dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];
-
-	bool		ctx_valid;
-	u32		ctx[DSS_SZ_REGS / sizeof(u32)];
-
-	const struct dss_features *feat;
-
-	struct dss_pll	*video1_pll;
-	struct dss_pll	*video2_pll;
-} dss;
+static struct dss_device dss;
 
 static const char * const dss_generic_clk_source_names[] = {
 	[DSS_CLK_SRC_FCK]	= "FCK",

commit c581d16fc22d53a44017426399afb4d211d60d16
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:45 2018 +0200

    drm: omapdrm: dss: Remove dss_get_hdmi_venc_clk_source() function
    
    The function is unused, remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index d086189263ef..d5490336e7c7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -752,20 +752,6 @@ void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
 		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
 }
 
-enum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)
-{
-	enum omap_dss_output_id outputs;
-
-	outputs = dss.feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
-	if ((outputs & OMAP_DSS_OUTPUT_HDMI) == 0)
-		return DSS_VENC_TV_CLK;
-
-	if ((outputs & OMAP_DSS_OUTPUT_VENC) == 0)
-		return DSS_HDMI_M_PCLK;
-
-	return REG_GET(DSS_CONTROL, 15, 15);
-}
-
 static int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)
 {
 	if (channel != OMAP_DSS_CHANNEL_LCD)

commit 215003b4ae1d47035092fef73b6a22aa82037091
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:44 2018 +0200

    drm: omapdrm: dss: Move initialization code from component bind to probe
    
    There's no reason to delay initialization of most of the driver (such as
    mapping memory I/O, getting clocks or enabling runtime PM) to the
    component master bind handler.
    
    This additionally fixes a real PM issue caused enabling runtime PM in
    the bind handler.
    
    The bind handler performs the following sequence of PM operations:
    
            pm_runtime_enable(dev);
            pm_runtime_get_sync(dev);
    
            ... (access the hardware to read the device revision) ...
    
            pm_runtime_put_sync(dev);
    
    If a failure occurs at this point, the error path calls
    pm_runtime_disable() to balance the pm_runtime_enable() call.
    
    To understand the problem, it should be noted that the bind handler is
    called when one of the component registers itself, which happens in the
    component's probe handler. Furthermore, as the components are children
    of the DSS, the device core calls pm_runtime_get_sync() on the DSS
    platform device before calling the component's probe handler. This
    increases the DSS power usage count but doesn't runtime resume the
    device, as runtime PM is disabled at that point.
    
    The bind handler is thus called with runtime PM disabled, with the
    device runtime suspended, but with the power usage count larger than 0.
    The pm_runtime_get_sync() call will thus further increase the power
    usage count and runtime resume the device. The pm_runtime_put_sync()
    handler will decrease the power usage count to a non-zero value and will
    thus not suspend the device. Finally, the pm_runtime_disable() call will
    disable runtime PM, preventing the pm_runtime_put() call in the device
    core from runtime suspending the device. The DSS device is thus left
    powered on.
    
    To fix this, move the initialization code from the bind handler to the
    probe handler.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index f1c7ef3a2ec3..d086189263ef 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1300,88 +1300,18 @@ static const struct soc_device_attribute dss_soc_devices[] = {
 
 static int dss_bind(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct resource *dss_mem;
-	u32 rev;
 	int r;
 
-	dss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);
-	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
-	if (IS_ERR(dss.base))
-		return PTR_ERR(dss.base);
-
-	r = dss_get_clocks();
+	r = component_bind_all(dev, NULL);
 	if (r)
 		return r;
 
-	r = dss_setup_default_clock();
-	if (r)
-		goto err_setup_clocks;
-
-	r = dss_video_pll_probe(pdev);
-	if (r)
-		goto err_pll_init;
-
-	r = dss_init_ports(pdev);
-	if (r)
-		goto err_init_ports;
-
-	pm_runtime_enable(&pdev->dev);
-
-	r = dss_runtime_get();
-	if (r)
-		goto err_runtime_get;
-
-	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
-
-	/* Select DPLL */
-	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
-
-	dss_select_dispc_clk_source(DSS_CLK_SRC_FCK);
-
-#ifdef CONFIG_OMAP2_DSS_VENC
-	REG_FLD_MOD(DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
-	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
-	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
-#endif
-	dss.dsi_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.dsi_clk_source[1] = DSS_CLK_SRC_FCK;
-	dss.dispc_clk_source = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
-
-	rev = dss_read_reg(DSS_REVISION);
-	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
-
-	dss_runtime_put();
-
-	r = component_bind_all(&pdev->dev, NULL);
-	if (r)
-		goto err_component;
-
-	dss_debugfs_create_file("dss", dss_dump_regs);
-
 	pm_set_vt_switch(0);
 
 	omapdss_gather_components(dev);
 	omapdss_set_is_initialized(true);
 
 	return 0;
-
-err_component:
-err_runtime_get:
-	pm_runtime_disable(&pdev->dev);
-	dss_uninit_ports(pdev);
-err_init_ports:
-	if (dss.video1_pll)
-		dss_video_pll_uninit(dss.video1_pll);
-
-	if (dss.video2_pll)
-		dss_video_pll_uninit(dss.video2_pll);
-err_pll_init:
-err_setup_clocks:
-	dss_put_clocks();
-	return r;
 }
 
 static void dss_unbind(struct device *dev)
@@ -1391,18 +1321,6 @@ static void dss_unbind(struct device *dev)
 	omapdss_set_is_initialized(false);
 
 	component_unbind_all(&pdev->dev, NULL);
-
-	if (dss.video1_pll)
-		dss_video_pll_uninit(dss.video1_pll);
-
-	if (dss.video2_pll)
-		dss_video_pll_uninit(dss.video2_pll);
-
-	dss_uninit_ports(pdev);
-
-	pm_runtime_disable(&pdev->dev);
-
-	dss_put_clocks();
 }
 
 static const struct component_master_ops dss_component_ops = {
@@ -1434,10 +1352,46 @@ static int dss_add_child_component(struct device *dev, void *data)
 	return 0;
 }
 
+static int dss_probe_hardware(void)
+{
+	u32 rev;
+	int r;
+
+	r = dss_runtime_get();
+	if (r)
+		return r;
+
+	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+
+	/* Select DPLL */
+	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
+
+	dss_select_dispc_clk_source(DSS_CLK_SRC_FCK);
+
+#ifdef CONFIG_OMAP2_DSS_VENC
+	REG_FLD_MOD(DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
+	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
+	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
+#endif
+	dss.dsi_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss.dsi_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss.dispc_clk_source = DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
+
+	rev = dss_read_reg(DSS_REVISION);
+	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
+
+	dss_runtime_put();
+
+	return 0;
+}
+
 static int dss_probe(struct platform_device *pdev)
 {
 	const struct soc_device_attribute *soc;
 	struct component_match *match = NULL;
+	struct resource *dss_mem;
 	int r;
 
 	dss.pdev = pdev;
@@ -1458,20 +1412,69 @@ static int dss_probe(struct platform_device *pdev)
 	else
 		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
 
-	r = dss_initialize_debugfs();
+	/* Map I/O registers, get and setup clocks. */
+	dss_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
+	if (IS_ERR(dss.base))
+		return PTR_ERR(dss.base);
+
+	r = dss_get_clocks();
 	if (r)
 		return r;
 
-	/* add all the child devices as components */
+	r = dss_setup_default_clock();
+	if (r)
+		goto err_put_clocks;
+
+	/* Setup the video PLLs and the DPI and SDI ports. */
+	r = dss_video_pll_probe(pdev);
+	if (r)
+		goto err_put_clocks;
+
+	r = dss_init_ports(pdev);
+	if (r)
+		goto err_uninit_plls;
+
+	/* Enable runtime PM and probe the hardware. */
+	pm_runtime_enable(&pdev->dev);
+
+	r = dss_probe_hardware();
+	if (r)
+		goto err_pm_runtime_disable;
+
+	/* Initialize debugfs. */
+	r = dss_initialize_debugfs();
+	if (r)
+		goto err_pm_runtime_disable;
+
+	dss_debugfs_create_file("dss", dss_dump_regs);
+
+	/* Add all the child devices as components. */
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
 
 	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);
-	if (r) {
-		dss_uninitialize_debugfs();
-		return r;
-	}
+	if (r)
+		goto err_uninit_debugfs;
 
 	return 0;
+
+err_uninit_debugfs:
+	dss_uninitialize_debugfs();
+
+err_pm_runtime_disable:
+	pm_runtime_disable(&pdev->dev);
+	dss_uninit_ports(pdev);
+
+err_uninit_plls:
+	if (dss.video1_pll)
+		dss_video_pll_uninit(dss.video1_pll);
+	if (dss.video2_pll)
+		dss_video_pll_uninit(dss.video2_pll);
+
+err_put_clocks:
+	dss_put_clocks();
+
+	return r;
 }
 
 static int dss_remove(struct platform_device *pdev)
@@ -1480,6 +1483,18 @@ static int dss_remove(struct platform_device *pdev)
 
 	dss_uninitialize_debugfs();
 
+	pm_runtime_disable(&pdev->dev);
+
+	dss_uninit_ports(pdev);
+
+	if (dss.video1_pll)
+		dss_video_pll_uninit(dss.video1_pll);
+
+	if (dss.video2_pll)
+		dss_video_pll_uninit(dss.video2_pll);
+
+	dss_put_clocks();
+
 	return 0;
 }
 

commit d11e5c827a4dbbb4174087669e3c7d231570985b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:34 2018 +0200

    drm: omapdrm: Use unsigned int type
    
    The kernel favours 'unsigned int' over plain 'unsigned'. Replace all
    occurences of the latter by the former. This avoid lots of checkpatch
    complaints in patches that touch lines where a plain 'unsigned' is used.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 04300b2da1b1..f1c7ef3a2ec3 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -181,8 +181,8 @@ static void dss_restore_context(void)
 
 void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
 {
-	unsigned shift;
-	unsigned val;
+	unsigned int shift;
+	unsigned int val;
 
 	if (!dss.syscon_pll_ctrl)
 		return;
@@ -211,7 +211,7 @@ void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
 static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,
 	enum omap_channel channel)
 {
-	unsigned shift, val;
+	unsigned int shift, val;
 
 	if (!dss.syscon_pll_ctrl)
 		return -EINVAL;
@@ -620,12 +620,12 @@ bool dss_div_calc(unsigned long pck, unsigned long fck_min,
 	unsigned long fck_hw_max;
 	unsigned long fckd_hw_max;
 	unsigned long prate;
-	unsigned m;
+	unsigned int m;
 
 	fck_hw_max = dss.feat->fck_freq_max;
 
 	if (dss.parent_clk == NULL) {
-		unsigned pckd;
+		unsigned int pckd;
 
 		pckd = fck_hw_max / pck;
 
@@ -694,7 +694,7 @@ static int dss_setup_default_clock(void)
 {
 	unsigned long max_dss_fck, prate;
 	unsigned long fck;
-	unsigned fck_div;
+	unsigned int fck_div;
 	int r;
 
 	max_dss_fck = dss.feat->fck_freq_max;

commit d66c36a3ee79747e300ac68276ca1496b567df68
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:32 2017 -0600

    drm: omapdrm: Simplify platform registration
    
    Currently, calls into each file are used to register the various
    platform drivers. Change this to a table of pointers to platform_driver
    structs to allow using platform_register_drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 2290792e1adc..04300b2da1b1 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1534,7 +1534,7 @@ static const struct dev_pm_ops dss_pm_ops = {
 	.runtime_resume = dss_runtime_resume,
 };
 
-static struct platform_driver omap_dsshw_driver = {
+struct platform_driver omap_dsshw_driver = {
 	.probe		= dss_probe,
 	.remove		= dss_remove,
 	.shutdown	= dss_shutdown,
@@ -1545,13 +1545,3 @@ static struct platform_driver omap_dsshw_driver = {
 		.suppress_bind_attrs = true,
 	},
 };
-
-int __init dss_init_platform_driver(void)
-{
-	return platform_driver_register(&omap_dsshw_driver);
-}
-
-void dss_uninit_platform_driver(void)
-{
-	platform_driver_unregister(&omap_dsshw_driver);
-}

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 0d447eddf4d6..2290792e1adc 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1,6 +1,4 @@
 /*
- * linux/drivers/video/omap2/dss/dss.c
- *
  * Copyright (C) 2009 Nokia Corporation
  * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
  *

commit 9be9d7efe7a39641ff4728b47e9955fda8cb2f7a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Oct 13 17:59:02 2017 +0300

    drm: omapdrm: dss: Make dss_dump_clocks() function static
    
    The function isn't used outside of its compilation unit, make it static.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 6ce26a4b93b3..0d447eddf4d6 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -368,7 +368,8 @@ const char *dss_get_clk_source_name(enum dss_clk_source clk_src)
 	return dss_generic_clk_source_names[clk_src];
 }
 
-void dss_dump_clocks(struct seq_file *s)
+#if defined(CONFIG_OMAP2_DSS_DEBUGFS)
+static void dss_dump_clocks(struct seq_file *s)
 {
 	const char *fclk_name;
 	unsigned long fclk_rate;
@@ -387,6 +388,7 @@ void dss_dump_clocks(struct seq_file *s)
 
 	dss_runtime_put();
 }
+#endif
 
 static void dss_dump_regs(struct seq_file *s)
 {

commit a921c1a8ed96ecc4257be487cc582440dffe71e1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Oct 13 17:59:01 2017 +0300

    drm: omapdrm: dss: Set the DMA coherent mask
    
    When merging the omapdrm and omapdss drivers the omapdrm virtual
    platform device will disappear, and the omapdss platform device will be
    used for DMA memory allocation. To prepare for that, set the DMA
    coherent mask for the device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index d1755f12236b..6ce26a4b93b3 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -23,6 +23,7 @@
 #define DSS_SUBSYS_NAME "DSS"
 
 #include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/io.h>
@@ -1441,6 +1442,12 @@ static int dss_probe(struct platform_device *pdev)
 
 	dss.pdev = pdev;
 
+	r = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+	if (r) {
+		dev_err(&pdev->dev, "Failed to set the DMA mask\n");
+		return r;
+	}
+
 	/*
 	 * The various OMAP3-based SoCs can't be told apart using the compatible
 	 * string, use SoC device matching.

commit d874b3a7c44ca48c0e57b8744c1eed2a6d299ba1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:19 2017 +0300

    drm: omapdrm: Remove dss_features.h
    
    The header file only contains four macros, two of which are never used.
    Move the other two to dss.h and remove dss_features.h.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index fa686070b6b0..d1755f12236b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -48,7 +48,6 @@
 
 #include "omapdss.h"
 #include "dss.h"
-#include "dss_features.h"
 
 #define DSS_SZ_REGS			SZ_512
 

commit 51919572c89a0c5dcf0cfff4ba4b36e175f091c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:18 2017 +0300

    drm: omapdrm: Move supported outputs feature to dss driver
    
    The supported outputs feature is specific to the DSS, move it from the
    omap_dss_features structure to the dss driver.
    
    The omap_dss_features structure is now empty and can be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 89bb41f42a06..fa686070b6b0 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -86,6 +86,7 @@ struct dss_features {
 	const char *parent_clk_name;
 	const enum omap_display_type *ports;
 	int num_ports;
+	const enum omap_dss_output_id *outputs;
 	const struct dss_ops *ops;
 	struct dss_reg_field dispc_clk_switch;
 	bool has_lcd_clk_src;
@@ -150,8 +151,7 @@ static void dss_save_context(void)
 
 	SR(CONTROL);
 
-	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DSS_OUTPUT_SDI) {
+	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
 		SR(SDI_CONTROL);
 		SR(PLL_CONTROL);
 	}
@@ -170,8 +170,7 @@ static void dss_restore_context(void)
 
 	RR(CONTROL);
 
-	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DSS_OUTPUT_SDI) {
+	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
 		RR(SDI_CONTROL);
 		RR(PLL_CONTROL);
 	}
@@ -401,8 +400,7 @@ static void dss_dump_regs(struct seq_file *s)
 	DUMPREG(DSS_SYSSTATUS);
 	DUMPREG(DSS_CONTROL);
 
-	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DSS_OUTPUT_SDI) {
+	if (dss.feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {
 		DUMPREG(DSS_SDI_CONTROL);
 		DUMPREG(DSS_PLL_CONTROL);
 		DUMPREG(DSS_SDI_STATUS);
@@ -687,6 +685,11 @@ unsigned long dss_get_max_fck_rate(void)
 	return dss.feat->fck_freq_max;
 }
 
+enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel)
+{
+	return dss.feat->outputs[channel];
+}
+
 static int dss_setup_default_clock(void)
 {
 	unsigned long max_dss_fck, prate;
@@ -737,7 +740,7 @@ void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
 {
 	enum omap_dss_output_id outputs;
 
-	outputs = dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_DIGIT);
+	outputs = dss.feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
 
 	/* Complain about invalid selections */
 	WARN_ON((src == DSS_VENC_TV_CLK) && !(outputs & OMAP_DSS_OUTPUT_VENC));
@@ -753,7 +756,7 @@ enum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)
 {
 	enum omap_dss_output_id outputs;
 
-	outputs = dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_DIGIT);
+	outputs = dss.feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
 	if ((outputs & OMAP_DSS_OUTPUT_HDMI) == 0)
 		return DSS_VENC_TV_CLK;
 
@@ -1004,6 +1007,66 @@ static const enum omap_display_type dra7xx_ports[] = {
 	OMAP_DISPLAY_TYPE_DPI,
 };
 
+static const enum omap_dss_output_id omap2_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI,
+
+	/* OMAP_DSS_CHANNEL_DIGIT */
+	OMAP_DSS_OUTPUT_VENC,
+};
+
+static const enum omap_dss_output_id omap3430_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_SDI | OMAP_DSS_OUTPUT_DSI1,
+
+	/* OMAP_DSS_CHANNEL_DIGIT */
+	OMAP_DSS_OUTPUT_VENC,
+};
+
+static const enum omap_dss_output_id omap3630_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_DSI1,
+
+	/* OMAP_DSS_CHANNEL_DIGIT */
+	OMAP_DSS_OUTPUT_VENC,
+};
+
+static const enum omap_dss_output_id am43xx_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI,
+};
+
+static const enum omap_dss_output_id omap4_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DBI | OMAP_DSS_OUTPUT_DSI1,
+
+	/* OMAP_DSS_CHANNEL_DIGIT */
+	OMAP_DSS_OUTPUT_VENC | OMAP_DSS_OUTPUT_HDMI,
+
+	/* OMAP_DSS_CHANNEL_LCD2 */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_DSI2,
+};
+
+static const enum omap_dss_output_id omap5_dss_supported_outputs[] = {
+	/* OMAP_DSS_CHANNEL_LCD */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_DSI1 | OMAP_DSS_OUTPUT_DSI2,
+
+	/* OMAP_DSS_CHANNEL_DIGIT */
+	OMAP_DSS_OUTPUT_HDMI,
+
+	/* OMAP_DSS_CHANNEL_LCD2 */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_DSI1,
+
+	/* OMAP_DSS_CHANNEL_LCD3 */
+	OMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |
+	OMAP_DSS_OUTPUT_DSI2,
+};
+
 static const struct dss_features omap24xx_dss_feats = {
 	.model			=	DSS_MODEL_OMAP2,
 	/*
@@ -1016,6 +1079,7 @@ static const struct dss_features omap24xx_dss_feats = {
 	.parent_clk_name	=	"core_ck",
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.outputs		=	omap2_dss_supported_outputs,
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
 	.has_lcd_clk_src	=	false,
@@ -1028,6 +1092,7 @@ static const struct dss_features omap34xx_dss_feats = {
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"dpll4_ck",
 	.ports			=	omap34xx_ports,
+	.outputs		=	omap3430_dss_supported_outputs,
 	.num_ports		=	ARRAY_SIZE(omap34xx_ports),
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
@@ -1042,6 +1107,7 @@ static const struct dss_features omap3630_dss_feats = {
 	.parent_clk_name	=	"dpll4_ck",
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.outputs		=	omap3630_dss_supported_outputs,
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
 	.has_lcd_clk_src	=	false,
@@ -1055,6 +1121,7 @@ static const struct dss_features omap44xx_dss_feats = {
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.outputs		=	omap4_dss_supported_outputs,
 	.ops			=	&dss_ops_omap4,
 	.dispc_clk_switch	=	{ 9, 8 },
 	.has_lcd_clk_src	=	true,
@@ -1068,6 +1135,7 @@ static const struct dss_features omap54xx_dss_feats = {
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.outputs		=	omap5_dss_supported_outputs,
 	.ops			=	&dss_ops_omap5,
 	.dispc_clk_switch	=	{ 9, 7 },
 	.has_lcd_clk_src	=	true,
@@ -1081,6 +1149,7 @@ static const struct dss_features am43xx_dss_feats = {
 	.parent_clk_name	=	NULL,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.outputs		=	am43xx_dss_supported_outputs,
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
 	.has_lcd_clk_src	=	true,
@@ -1094,6 +1163,7 @@ static const struct dss_features dra7xx_dss_feats = {
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	dra7xx_ports,
 	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
+	.outputs		=	omap5_dss_supported_outputs,
 	.ops			=	&dss_ops_dra7,
 	.dispc_clk_switch	=	{ 9, 7 },
 	.has_lcd_clk_src	=	true,

commit 9f0fbaea5cd6b6a0a75a53f99e5c6b3049dd0ce1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:17 2017 +0300

    drm: omapdrm: Move DSS_FCK feature to dss driver
    
    The FEAT_PARAM_DSS_FCK feature is specific to the DSS, move it from the
    omap_dss_features structure to the dss driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 8bb9f8de46f0..89bb41f42a06 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -81,6 +81,7 @@ struct dss_ops {
 struct dss_features {
 	enum dss_model model;
 	u8 fck_div_max;
+	unsigned int fck_freq_max;
 	u8 dss_fck_multiplier;
 	const char *parent_clk_name;
 	const enum omap_display_type *ports;
@@ -623,7 +624,7 @@ bool dss_div_calc(unsigned long pck, unsigned long fck_min,
 	unsigned long prate;
 	unsigned m;
 
-	fck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+	fck_hw_max = dss.feat->fck_freq_max;
 
 	if (dss.parent_clk == NULL) {
 		unsigned pckd;
@@ -681,6 +682,11 @@ unsigned long dss_get_dispc_clk_rate(void)
 	return dss.dss_clk_rate;
 }
 
+unsigned long dss_get_max_fck_rate(void)
+{
+	return dss.feat->fck_freq_max;
+}
+
 static int dss_setup_default_clock(void)
 {
 	unsigned long max_dss_fck, prate;
@@ -688,7 +694,7 @@ static int dss_setup_default_clock(void)
 	unsigned fck_div;
 	int r;
 
-	max_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+	max_dss_fck = dss.feat->fck_freq_max;
 
 	if (dss.parent_clk == NULL) {
 		fck = clk_round_rate(dss.dss_clk, max_dss_fck);
@@ -1005,6 +1011,7 @@ static const struct dss_features omap24xx_dss_feats = {
 	 * from 1 to 6 has no gaps, so let's use that as a max.
 	 */
 	.fck_div_max		=	6,
+	.fck_freq_max		=	133000000,
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"core_ck",
 	.ports			=	omap2plus_ports,
@@ -1017,6 +1024,7 @@ static const struct dss_features omap24xx_dss_feats = {
 static const struct dss_features omap34xx_dss_feats = {
 	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	16,
+	.fck_freq_max		=	173000000,
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"dpll4_ck",
 	.ports			=	omap34xx_ports,
@@ -1029,6 +1037,7 @@ static const struct dss_features omap34xx_dss_feats = {
 static const struct dss_features omap3630_dss_feats = {
 	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	32,
+	.fck_freq_max		=	173000000,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll4_ck",
 	.ports			=	omap2plus_ports,
@@ -1041,6 +1050,7 @@ static const struct dss_features omap3630_dss_feats = {
 static const struct dss_features omap44xx_dss_feats = {
 	.model			=	DSS_MODEL_OMAP4,
 	.fck_div_max		=	32,
+	.fck_freq_max		=	186000000,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	omap2plus_ports,
@@ -1053,6 +1063,7 @@ static const struct dss_features omap44xx_dss_feats = {
 static const struct dss_features omap54xx_dss_feats = {
 	.model			=	DSS_MODEL_OMAP5,
 	.fck_div_max		=	64,
+	.fck_freq_max		=	209250000,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	omap2plus_ports,
@@ -1065,6 +1076,7 @@ static const struct dss_features omap54xx_dss_feats = {
 static const struct dss_features am43xx_dss_feats = {
 	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	0,
+	.fck_freq_max		=	200000000,
 	.dss_fck_multiplier	=	0,
 	.parent_clk_name	=	NULL,
 	.ports			=	omap2plus_ports,
@@ -1077,6 +1089,7 @@ static const struct dss_features am43xx_dss_feats = {
 static const struct dss_features dra7xx_dss_feats = {
 	.model			=	DSS_MODEL_DRA7,
 	.fck_div_max		=	64,
+	.fck_freq_max		=	209250000,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
 	.ports			=	dra7xx_ports,

commit 4569ab757f09b9b6a3dd4eda2b0b37c7f5535e6d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:13 2017 +0300

    drm: omapdrm: Move FEAT_LCD_CLK_SRC feature to dss_features structure
    
    The FEAT_LCD_CLK_SRC feature is specific to the DSS, move it from the
    omap_dss_features structure to the dss_features structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index d145d9eedfa7..8bb9f8de46f0 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -87,6 +87,7 @@ struct dss_features {
 	int num_ports;
 	const struct dss_ops *ops;
 	struct dss_reg_field dispc_clk_switch;
+	bool has_lcd_clk_src;
 };
 
 static struct {
@@ -433,8 +434,7 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 	 * We always use PRCM clock as the DISPC func clock, except on DSS3,
 	 * where we don't have separate DISPC and LCD clock sources.
 	 */
-	if (WARN_ON(dss_has_feature(FEAT_LCD_CLK_SRC) &&
-		clk_src != DSS_CLK_SRC_FCK))
+	if (WARN_ON(dss.feat->has_lcd_clk_src && clk_src != DSS_CLK_SRC_FCK))
 		return;
 
 	switch (clk_src) {
@@ -578,7 +578,7 @@ void dss_select_lcd_clk_source(enum omap_channel channel,
 	int idx = dss_get_channel_index(channel);
 	int r;
 
-	if (!dss_has_feature(FEAT_LCD_CLK_SRC)) {
+	if (!dss.feat->has_lcd_clk_src) {
 		dss_select_dispc_clk_source(clk_src);
 		dss.lcd_clk_source[idx] = clk_src;
 		return;
@@ -603,7 +603,7 @@ enum dss_clk_source dss_get_dsi_clk_source(int dsi_module)
 
 enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
 {
-	if (dss_has_feature(FEAT_LCD_CLK_SRC)) {
+	if (dss.feat->has_lcd_clk_src) {
 		int idx = dss_get_channel_index(channel);
 		return dss.lcd_clk_source[idx];
 	} else {
@@ -1011,6 +1011,7 @@ static const struct dss_features omap24xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
+	.has_lcd_clk_src	=	false,
 };
 
 static const struct dss_features omap34xx_dss_feats = {
@@ -1022,6 +1023,7 @@ static const struct dss_features omap34xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap34xx_ports),
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
+	.has_lcd_clk_src	=	false,
 };
 
 static const struct dss_features omap3630_dss_feats = {
@@ -1033,6 +1035,7 @@ static const struct dss_features omap3630_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
+	.has_lcd_clk_src	=	false,
 };
 
 static const struct dss_features omap44xx_dss_feats = {
@@ -1044,6 +1047,7 @@ static const struct dss_features omap44xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap4,
 	.dispc_clk_switch	=	{ 9, 8 },
+	.has_lcd_clk_src	=	true,
 };
 
 static const struct dss_features omap54xx_dss_feats = {
@@ -1055,6 +1059,7 @@ static const struct dss_features omap54xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap5,
 	.dispc_clk_switch	=	{ 9, 7 },
+	.has_lcd_clk_src	=	true,
 };
 
 static const struct dss_features am43xx_dss_feats = {
@@ -1066,6 +1071,7 @@ static const struct dss_features am43xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
 	.dispc_clk_switch	=	{ 0, 0 },
+	.has_lcd_clk_src	=	true,
 };
 
 static const struct dss_features dra7xx_dss_feats = {
@@ -1077,6 +1083,7 @@ static const struct dss_features dra7xx_dss_feats = {
 	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
 	.ops			=	&dss_ops_dra7,
 	.dispc_clk_switch	=	{ 9, 7 },
+	.has_lcd_clk_src	=	true,
 };
 
 static int dss_init_ports(struct platform_device *pdev)

commit 6d85d4adb645e5474594c0dc5fafa36c173ecec1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:07 2017 +0300

    drm: omapdrm: Move DISPC_CLK_SWITCH reg feature to struct dss_features
    
    The register belongs to the DSS, move the feature to the dss_features
    structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 3d6b1e8ec0c0..d145d9eedfa7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -86,6 +86,7 @@ struct dss_features {
 	const enum omap_display_type *ports;
 	int num_ports;
 	const struct dss_ops *ops;
+	struct dss_reg_field dispc_clk_switch;
 };
 
 static struct {
@@ -427,7 +428,6 @@ static int dss_get_channel_index(enum omap_channel channel)
 static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 {
 	int b;
-	u8 start, end;
 
 	/*
 	 * We always use PRCM clock as the DISPC func clock, except on DSS3,
@@ -452,9 +452,9 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 		return;
 	}
 
-	dss_feat_get_reg_field(FEAT_REG_DISPC_CLK_SWITCH, &start, &end);
-
-	REG_FLD_MOD(DSS_CONTROL, b, start, end);	/* DISPC_CLK_SWITCH */
+	REG_FLD_MOD(DSS_CONTROL, b,			/* DISPC_CLK_SWITCH */
+		    dss.feat->dispc_clk_switch.start,
+		    dss.feat->dispc_clk_switch.end);
 
 	dss.dispc_clk_source = clk_src;
 }
@@ -1010,6 +1010,7 @@ static const struct dss_features omap24xx_dss_feats = {
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
+	.dispc_clk_switch	=	{ 0, 0 },
 };
 
 static const struct dss_features omap34xx_dss_feats = {
@@ -1020,6 +1021,7 @@ static const struct dss_features omap34xx_dss_feats = {
 	.ports			=	omap34xx_ports,
 	.num_ports		=	ARRAY_SIZE(omap34xx_ports),
 	.ops			=	&dss_ops_omap2_omap3,
+	.dispc_clk_switch	=	{ 0, 0 },
 };
 
 static const struct dss_features omap3630_dss_feats = {
@@ -1030,6 +1032,7 @@ static const struct dss_features omap3630_dss_feats = {
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
+	.dispc_clk_switch	=	{ 0, 0 },
 };
 
 static const struct dss_features omap44xx_dss_feats = {
@@ -1040,6 +1043,7 @@ static const struct dss_features omap44xx_dss_feats = {
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap4,
+	.dispc_clk_switch	=	{ 9, 8 },
 };
 
 static const struct dss_features omap54xx_dss_feats = {
@@ -1050,6 +1054,7 @@ static const struct dss_features omap54xx_dss_feats = {
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap5,
+	.dispc_clk_switch	=	{ 9, 7 },
 };
 
 static const struct dss_features am43xx_dss_feats = {
@@ -1060,6 +1065,7 @@ static const struct dss_features am43xx_dss_feats = {
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
 	.ops			=	&dss_ops_omap2_omap3,
+	.dispc_clk_switch	=	{ 0, 0 },
 };
 
 static const struct dss_features dra7xx_dss_feats = {
@@ -1070,6 +1076,7 @@ static const struct dss_features dra7xx_dss_feats = {
 	.ports			=	dra7xx_ports,
 	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
 	.ops			=	&dss_ops_dra7,
+	.dispc_clk_switch	=	{ 9, 7 },
 };
 
 static int dss_init_ports(struct platform_device *pdev)

commit 74592ee796de3711677c284b322e9c05ac629061
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:02 2017 +0300

    drm: omapdrm: Move shutdown() handler from core to dss
    
    In preparation for removal of the core module, move the shutdown()
    handler from core to dss.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index e44b5077f140..3d6b1e8ec0c0 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1380,6 +1380,21 @@ static int dss_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void dss_shutdown(struct platform_device *pdev)
+{
+	struct omap_dss_device *dssdev = NULL;
+
+	DSSDBG("shutdown\n");
+
+	for_each_dss_dev(dssdev) {
+		if (!dssdev->driver)
+			continue;
+
+		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
+			dssdev->driver->disable(dssdev);
+	}
+}
+
 static int dss_runtime_suspend(struct device *dev)
 {
 	dss_save_context();
@@ -1419,6 +1434,7 @@ static const struct dev_pm_ops dss_pm_ops = {
 static struct platform_driver omap_dsshw_driver = {
 	.probe		= dss_probe,
 	.remove		= dss_remove,
+	.shutdown	= dss_shutdown,
 	.driver         = {
 		.name   = "omapdss_dss",
 		.pm	= &dss_pm_ops,

commit 11765d163c972a68db02b41d7ad107f5baf5f4b1
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:01 2017 +0300

    drm: omapdrm: Move all debugfs code from core to dss
    
    debugfs code is spread between the core and dss drivers. In preparation
    for removal of the core driver, move it all to the dss driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7384e473875b..e44b5077f140 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -22,6 +22,7 @@
 
 #define DSS_SUBSYS_NAME "DSS"
 
+#include <linux/debugfs.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/io.h>
@@ -891,7 +892,7 @@ void dss_runtime_put(void)
 
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
-void dss_debug_dump_clocks(struct seq_file *s)
+static void dss_debug_dump_clocks(struct seq_file *s)
 {
 	dss_dump_clocks(s);
 	dispc_dump_clocks(s);
@@ -899,8 +900,69 @@ void dss_debug_dump_clocks(struct seq_file *s)
 	dsi_dump_clocks(s);
 #endif
 }
-#endif
 
+static int dss_debug_show(struct seq_file *s, void *unused)
+{
+	void (*func)(struct seq_file *) = s->private;
+
+	func(s);
+	return 0;
+}
+
+static int dss_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dss_debug_show, inode->i_private);
+}
+
+static const struct file_operations dss_debug_fops = {
+	.open           = dss_debug_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static struct dentry *dss_debugfs_dir;
+
+static int dss_initialize_debugfs(void)
+{
+	dss_debugfs_dir = debugfs_create_dir("omapdss", NULL);
+	if (IS_ERR(dss_debugfs_dir)) {
+		int err = PTR_ERR(dss_debugfs_dir);
+
+		dss_debugfs_dir = NULL;
+		return err;
+	}
+
+	debugfs_create_file("clk", S_IRUGO, dss_debugfs_dir,
+			&dss_debug_dump_clocks, &dss_debug_fops);
+
+	return 0;
+}
+
+static void dss_uninitialize_debugfs(void)
+{
+	if (dss_debugfs_dir)
+		debugfs_remove_recursive(dss_debugfs_dir);
+}
+
+int dss_debugfs_create_file(const char *name, void (*write)(struct seq_file *))
+{
+	struct dentry *d;
+
+	d = debugfs_create_file(name, S_IRUGO, dss_debugfs_dir,
+			write, &dss_debug_fops);
+
+	return PTR_ERR_OR_ZERO(d);
+}
+#else /* CONFIG_OMAP2_DSS_DEBUGFS */
+static inline int dss_initialize_debugfs(void)
+{
+	return 0;
+}
+static inline void dss_uninitialize_debugfs(void)
+{
+}
+#endif /* CONFIG_OMAP2_DSS_DEBUGFS */
 
 static const struct dss_ops dss_ops_omap2_omap3 = {
 	.dpi_select_source = &dss_dpi_select_source_omap2_omap3,
@@ -1293,12 +1355,18 @@ static int dss_probe(struct platform_device *pdev)
 	else
 		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
 
+	r = dss_initialize_debugfs();
+	if (r)
+		return r;
+
 	/* add all the child devices as components */
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
 
 	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);
-	if (r)
+	if (r) {
+		dss_uninitialize_debugfs();
 		return r;
+	}
 
 	return 0;
 }
@@ -1306,6 +1374,9 @@ static int dss_probe(struct platform_device *pdev)
 static int dss_remove(struct platform_device *pdev)
 {
 	component_master_del(&pdev->dev, &dss_component_ops);
+
+	dss_uninitialize_debugfs();
+
 	return 0;
 }
 

commit 4a9fab3d816447a2a3ea1492c7ba684b07d94970
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:44:00 2017 +0300

    drm: omapdrm: dss: Initialize DSS internal features at probe time
    
    The DSS internal features are derived from the platform device
    compatible string which is available at probe time. Don't delay
    initialization until bind time. This prepares for the merge of the two
    DSS features structures that will be needed before the DSS is bound.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index c3fab0ddcde9..7384e473875b 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1142,23 +1142,10 @@ static const struct soc_device_attribute dss_soc_devices[] = {
 static int dss_bind(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	const struct soc_device_attribute *soc;
 	struct resource *dss_mem;
 	u32 rev;
 	int r;
 
-	dss.pdev = pdev;
-
-	/*
-	 * The various OMAP3-based SoCs can't be told apart using the compatible
-	 * string, use SoC device matching.
-	 */
-	soc = soc_device_match(dss_soc_devices);
-	if (soc)
-		dss.feat = soc->data;
-	else
-		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
-
 	dss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);
 	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
 	if (IS_ERR(dss.base))
@@ -1290,9 +1277,22 @@ static int dss_add_child_component(struct device *dev, void *data)
 
 static int dss_probe(struct platform_device *pdev)
 {
+	const struct soc_device_attribute *soc;
 	struct component_match *match = NULL;
 	int r;
 
+	dss.pdev = pdev;
+
+	/*
+	 * The various OMAP3-based SoCs can't be told apart using the compatible
+	 * string, use SoC device matching.
+	 */
+	soc = soc_device_match(dss_soc_devices);
+	if (soc)
+		dss.feat = soc->data;
+	else
+		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
+
 	/* add all the child devices as components */
 	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
 

commit 24ab1df3665e52eda64508a2bf7c2cc688285ccc
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:59 2017 +0300

    drm: omapdrm: dss: Use supported outputs instead of display types
    
    The dss driver uses the supported display types to check whether the DSS
    has SDI, VENC or HDMI outputs. We can instead use the supported outputs
    the provide the same information. This removes the last use of the
    supported display types, that we can then remove as well.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 06c6e0145703..c3fab0ddcde9 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -146,8 +146,8 @@ static void dss_save_context(void)
 
 	SR(CONTROL);
 
-	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DISPLAY_TYPE_SDI) {
+	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DSS_OUTPUT_SDI) {
 		SR(SDI_CONTROL);
 		SR(PLL_CONTROL);
 	}
@@ -166,8 +166,8 @@ static void dss_restore_context(void)
 
 	RR(CONTROL);
 
-	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DISPLAY_TYPE_SDI) {
+	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DSS_OUTPUT_SDI) {
 		RR(SDI_CONTROL);
 		RR(PLL_CONTROL);
 	}
@@ -397,8 +397,8 @@ static void dss_dump_regs(struct seq_file *s)
 	DUMPREG(DSS_SYSSTATUS);
 	DUMPREG(DSS_CONTROL);
 
-	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
-			OMAP_DISPLAY_TYPE_SDI) {
+	if (dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DSS_OUTPUT_SDI) {
 		DUMPREG(DSS_SDI_CONTROL);
 		DUMPREG(DSS_PLL_CONTROL);
 		DUMPREG(DSS_SDI_STATUS);
@@ -728,27 +728,29 @@ void dss_set_dac_pwrdn_bgz(bool enable)
 
 void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
 {
-	enum omap_display_type dp;
-	dp = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);
+	enum omap_dss_output_id outputs;
+
+	outputs = dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_DIGIT);
 
 	/* Complain about invalid selections */
-	WARN_ON((src == DSS_VENC_TV_CLK) && !(dp & OMAP_DISPLAY_TYPE_VENC));
-	WARN_ON((src == DSS_HDMI_M_PCLK) && !(dp & OMAP_DISPLAY_TYPE_HDMI));
+	WARN_ON((src == DSS_VENC_TV_CLK) && !(outputs & OMAP_DSS_OUTPUT_VENC));
+	WARN_ON((src == DSS_HDMI_M_PCLK) && !(outputs & OMAP_DSS_OUTPUT_HDMI));
 
 	/* Select only if we have options */
-	if ((dp & OMAP_DISPLAY_TYPE_VENC) && (dp & OMAP_DISPLAY_TYPE_HDMI))
+	if ((outputs & OMAP_DSS_OUTPUT_VENC) &&
+	    (outputs & OMAP_DSS_OUTPUT_HDMI))
 		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
 }
 
 enum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)
 {
-	enum omap_display_type displays;
+	enum omap_dss_output_id outputs;
 
-	displays = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);
-	if ((displays & OMAP_DISPLAY_TYPE_HDMI) == 0)
+	outputs = dss_feat_get_supported_outputs(OMAP_DSS_CHANNEL_DIGIT);
+	if ((outputs & OMAP_DSS_OUTPUT_HDMI) == 0)
 		return DSS_VENC_TV_CLK;
 
-	if ((displays & OMAP_DISPLAY_TYPE_VENC) == 0)
+	if ((outputs & OMAP_DSS_OUTPUT_VENC) == 0)
 		return DSS_HDMI_M_PCLK;
 
 	return REG_GET(DSS_CONTROL, 15, 15);

commit 18daeb8e978241ca9fcf874a1c5ad9a628beddd7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:58 2017 +0300

    drm: omapdrm: dss: Select features based on compatible string
    
    Use the compatible string instead of the OMAP SoC revision to determine
    device features. The various OMAP3-based SoCs can't be told apart using
    the compatible string, use soc_device_match() to tell them apart.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7be69b1d535a..06c6e0145703 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -38,10 +38,12 @@
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/regulator/consumer.h>
 #include <linux/suspend.h>
 #include <linux/component.h>
+#include <linux/sys_soc.h>
 
 #include "omapdss.h"
 #include "dss.h"
@@ -1006,60 +1008,6 @@ static const struct dss_features dra7xx_dss_feats = {
 	.ops			=	&dss_ops_dra7,
 };
 
-static int dss_init_features(struct platform_device *pdev)
-{
-	const struct dss_features *src;
-	struct dss_features *dst;
-
-	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
-	if (!dst) {
-		dev_err(&pdev->dev, "Failed to allocate local DSS Features\n");
-		return -ENOMEM;
-	}
-
-	switch (omapdss_get_version()) {
-	case OMAPDSS_VER_OMAP24xx:
-		src = &omap24xx_dss_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP34xx_ES1:
-	case OMAPDSS_VER_OMAP34xx_ES3:
-	case OMAPDSS_VER_AM35xx:
-		src = &omap34xx_dss_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP3630:
-		src = &omap3630_dss_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP4430_ES1:
-	case OMAPDSS_VER_OMAP4430_ES2:
-	case OMAPDSS_VER_OMAP4:
-		src = &omap44xx_dss_feats;
-		break;
-
-	case OMAPDSS_VER_OMAP5:
-		src = &omap54xx_dss_feats;
-		break;
-
-	case OMAPDSS_VER_AM43xx:
-		src = &am43xx_dss_feats;
-		break;
-
-	case OMAPDSS_VER_DRA7xx:
-		src = &dra7xx_dss_feats;
-		break;
-
-	default:
-		return -ENODEV;
-	}
-
-	memcpy(dst, src, sizeof(*dst));
-	dss.feat = dst;
-
-	return 0;
-}
-
 static int dss_init_ports(struct platform_device *pdev)
 {
 	struct device_node *parent = pdev->dev.of_node;
@@ -1172,18 +1120,42 @@ static int dss_video_pll_probe(struct platform_device *pdev)
 }
 
 /* DSS HW IP initialisation */
+static const struct of_device_id dss_of_match[] = {
+	{ .compatible = "ti,omap2-dss", .data = &omap24xx_dss_feats },
+	{ .compatible = "ti,omap3-dss", .data = &omap3630_dss_feats },
+	{ .compatible = "ti,omap4-dss", .data = &omap44xx_dss_feats },
+	{ .compatible = "ti,omap5-dss", .data = &omap54xx_dss_feats },
+	{ .compatible = "ti,dra7-dss",  .data = &dra7xx_dss_feats },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dss_of_match);
+
+static const struct soc_device_attribute dss_soc_devices[] = {
+	{ .machine = "OMAP3430/3530", .data = &omap34xx_dss_feats },
+	{ .machine = "AM35??",        .data = &omap34xx_dss_feats },
+	{ .family  = "AM43xx",        .data = &am43xx_dss_feats },
+	{ /* sentinel */ }
+};
+
 static int dss_bind(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	const struct soc_device_attribute *soc;
 	struct resource *dss_mem;
 	u32 rev;
 	int r;
 
 	dss.pdev = pdev;
 
-	r = dss_init_features(dss.pdev);
-	if (r)
-		return r;
+	/*
+	 * The various OMAP3-based SoCs can't be told apart using the compatible
+	 * string, use SoC device matching.
+	 */
+	soc = soc_device_match(dss_soc_devices);
+	if (soc)
+		dss.feat = soc->data;
+	else
+		dss.feat = of_match_device(dss_of_match, &pdev->dev)->data;
 
 	dss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);
 	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
@@ -1371,17 +1343,6 @@ static const struct dev_pm_ops dss_pm_ops = {
 	.runtime_resume = dss_runtime_resume,
 };
 
-static const struct of_device_id dss_of_match[] = {
-	{ .compatible = "ti,omap2-dss", },
-	{ .compatible = "ti,omap3-dss", },
-	{ .compatible = "ti,omap4-dss", },
-	{ .compatible = "ti,omap5-dss", },
-	{ .compatible = "ti,dra7-dss", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, dss_of_match);
-
 static struct platform_driver omap_dsshw_driver = {
 	.probe		= dss_probe,
 	.remove		= dss_remove,

commit b8dab2bddb5be59e143b41cc4f170ba01a04e117
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:56 2017 +0300

    drm: omapdrm: dpi: Replace OMAP SoC model checks with DSS model
    
    The DPI code only needs to differentiate between major OMAP revisions,
    which can be obtained from the DSS compatible string. Replace the OMAP
    SoC model checks to prepare for removal of the OMAP SoC version platform
    data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index b8a2f92efcba..7be69b1d535a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -76,6 +76,7 @@ struct dss_ops {
 };
 
 struct dss_features {
+	enum dss_model model;
 	u8 fck_div_max;
 	u8 dss_fck_multiplier;
 	const char *parent_clk_name;
@@ -932,6 +933,7 @@ static const enum omap_display_type dra7xx_ports[] = {
 };
 
 static const struct dss_features omap24xx_dss_feats = {
+	.model			=	DSS_MODEL_OMAP2,
 	/*
 	 * fck div max is really 16, but the divider range has gaps. The range
 	 * from 1 to 6 has no gaps, so let's use that as a max.
@@ -945,6 +947,7 @@ static const struct dss_features omap24xx_dss_feats = {
 };
 
 static const struct dss_features omap34xx_dss_feats = {
+	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	16,
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"dpll4_ck",
@@ -954,6 +957,7 @@ static const struct dss_features omap34xx_dss_feats = {
 };
 
 static const struct dss_features omap3630_dss_feats = {
+	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	32,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll4_ck",
@@ -963,6 +967,7 @@ static const struct dss_features omap3630_dss_feats = {
 };
 
 static const struct dss_features omap44xx_dss_feats = {
+	.model			=	DSS_MODEL_OMAP4,
 	.fck_div_max		=	32,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
@@ -972,6 +977,7 @@ static const struct dss_features omap44xx_dss_feats = {
 };
 
 static const struct dss_features omap54xx_dss_feats = {
+	.model			=	DSS_MODEL_OMAP5,
 	.fck_div_max		=	64,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
@@ -981,6 +987,7 @@ static const struct dss_features omap54xx_dss_feats = {
 };
 
 static const struct dss_features am43xx_dss_feats = {
+	.model			=	DSS_MODEL_OMAP3,
 	.fck_div_max		=	0,
 	.dss_fck_multiplier	=	0,
 	.parent_clk_name	=	NULL,
@@ -990,6 +997,7 @@ static const struct dss_features am43xx_dss_feats = {
 };
 
 static const struct dss_features dra7xx_dss_feats = {
+	.model			=	DSS_MODEL_DRA7,
 	.fck_div_max		=	64,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
@@ -1065,7 +1073,7 @@ static int dss_init_ports(struct platform_device *pdev)
 
 		switch (dss.feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_port(pdev, port);
+			dpi_init_port(pdev, port, dss.feat->model);
 			break;
 		case OMAP_DISPLAY_TYPE_SDI:
 			sdi_init_port(pdev, port);

commit fecea2528d4e92db46eb11b23458ed56023301f2
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Aug 5 01:43:52 2017 +0300

    drm: omapdrm: dss: Split operations out of dss_features structure
    
    Move the two function pointers to a new dss_ops structure. This will
    allow merging the dss_features and omap_dss_features structures without
    having to expose the DPI source selection and LCD clock muxing functions
    in header files.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 99e22ca972c7..b8a2f92efcba 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -69,15 +69,19 @@ struct dss_reg {
 #define REG_FLD_MOD(idx, val, start, end) \
 	dss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))
 
+struct dss_ops {
+	int (*dpi_select_source)(int port, enum omap_channel channel);
+	int (*select_lcd_source)(enum omap_channel channel,
+		enum dss_clk_source clk_src);
+};
+
 struct dss_features {
 	u8 fck_div_max;
 	u8 dss_fck_multiplier;
 	const char *parent_clk_name;
 	const enum omap_display_type *ports;
 	int num_ports;
-	int (*dpi_select_source)(int port, enum omap_channel channel);
-	int (*select_lcd_source)(enum omap_channel channel,
-		enum dss_clk_source clk_src);
+	const struct dss_ops *ops;
 };
 
 static struct {
@@ -576,7 +580,7 @@ void dss_select_lcd_clk_source(enum omap_channel channel,
 		return;
 	}
 
-	r = dss.feat->select_lcd_source(channel, clk_src);
+	r = dss.feat->ops->select_lcd_source(channel, clk_src);
 	if (r)
 		return;
 
@@ -823,7 +827,7 @@ static int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)
 
 int dss_dpi_select_source(int port, enum omap_channel channel)
 {
-	return dss.feat->dpi_select_source(port, channel);
+	return dss.feat->ops->dpi_select_source(port, channel);
 }
 
 static int dss_get_clocks(void)
@@ -893,6 +897,25 @@ void dss_debug_dump_clocks(struct seq_file *s)
 #endif
 
 
+static const struct dss_ops dss_ops_omap2_omap3 = {
+	.dpi_select_source = &dss_dpi_select_source_omap2_omap3,
+};
+
+static const struct dss_ops dss_ops_omap4 = {
+	.dpi_select_source = &dss_dpi_select_source_omap4,
+	.select_lcd_source = &dss_lcd_clk_mux_omap4,
+};
+
+static const struct dss_ops dss_ops_omap5 = {
+	.dpi_select_source = &dss_dpi_select_source_omap5,
+	.select_lcd_source = &dss_lcd_clk_mux_omap5,
+};
+
+static const struct dss_ops dss_ops_dra7 = {
+	.dpi_select_source = &dss_dpi_select_source_dra7xx,
+	.select_lcd_source = &dss_lcd_clk_mux_dra7,
+};
+
 static const enum omap_display_type omap2plus_ports[] = {
 	OMAP_DISPLAY_TYPE_DPI,
 };
@@ -916,66 +939,63 @@ static const struct dss_features omap24xx_dss_feats = {
 	.fck_div_max		=	6,
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"core_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.ops			=	&dss_ops_omap2_omap3,
 };
 
 static const struct dss_features omap34xx_dss_feats = {
 	.fck_div_max		=	16,
 	.dss_fck_multiplier	=	2,
 	.parent_clk_name	=	"dpll4_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
 	.ports			=	omap34xx_ports,
 	.num_ports		=	ARRAY_SIZE(omap34xx_ports),
+	.ops			=	&dss_ops_omap2_omap3,
 };
 
 static const struct dss_features omap3630_dss_feats = {
 	.fck_div_max		=	32,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll4_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.ops			=	&dss_ops_omap2_omap3,
 };
 
 static const struct dss_features omap44xx_dss_feats = {
 	.fck_div_max		=	32,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_omap4,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
-	.select_lcd_source	=	&dss_lcd_clk_mux_omap4,
+	.ops			=	&dss_ops_omap4,
 };
 
 static const struct dss_features omap54xx_dss_feats = {
 	.fck_div_max		=	64,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_omap5,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
-	.select_lcd_source	=	&dss_lcd_clk_mux_omap5,
+	.ops			=	&dss_ops_omap5,
 };
 
 static const struct dss_features am43xx_dss_feats = {
 	.fck_div_max		=	0,
 	.dss_fck_multiplier	=	0,
 	.parent_clk_name	=	NULL,
-	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.ops			=	&dss_ops_omap2_omap3,
 };
 
 static const struct dss_features dra7xx_dss_feats = {
 	.fck_div_max		=	64,
 	.dss_fck_multiplier	=	1,
 	.parent_clk_name	=	"dpll_per_x2_ck",
-	.dpi_select_source	=	&dss_dpi_select_source_dra7xx,
 	.ports			=	dra7xx_ports,
 	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
-	.select_lcd_source	=	&dss_lcd_clk_mux_dra7,
+	.ops			=	&dss_ops_dra7,
 };
 
 static int dss_init_features(struct platform_device *pdev)

commit b22622f0cba3a6ee780787abd84b3b0c1ad09b26
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun May 7 00:29:09 2017 +0300

    drm: omapdrm: Remove duplicate error messages when mapping memory
    
    The devm_ioremap_resource() call can handle being given a NULL resource,
    and prints an error message when mapping fails. Switch the remaining
    devm_ioremap() calls to devm_ioremap_resource() and remove all
    extraneous resource NULL checks and error messages printed manually by
    the driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index fa99ec72d832..99e22ca972c7 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1158,17 +1158,9 @@ static int dss_bind(struct device *dev)
 		return r;
 
 	dss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);
-	if (!dss_mem) {
-		DSSERR("can't get IORESOURCE_MEM DSS\n");
-		return -EINVAL;
-	}
-
-	dss.base = devm_ioremap(&pdev->dev, dss_mem->start,
-				resource_size(dss_mem));
-	if (!dss.base) {
-		DSSERR("can't ioremap DSS\n");
-		return -ENOMEM;
-	}
+	dss.base = devm_ioremap_resource(&pdev->dev, dss_mem);
+	if (IS_ERR(dss.base))
+		return PTR_ERR(dss.base);
 
 	r = dss_get_clocks();
 	if (r)

commit 09bffa6e519256c6fa1552d6ba1f5d594337a464
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 08:26:08 2017 -0500

    drm: omap: use common OF graph helpers
    
    The OMAP driver has its own OF graph helpers that are similar to the
    common helpers. This commit replaces most of the calls with the common
    helpers. There's still a couple of custom helpers left, but the driver
    needs more extensive changes to get rid of them.
    
    In dss_init_ports, we invert the loop, looping through the known ports
    and matching them to DT nodes rather than looping thru DT nodes and
    matching them to the ports.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index ceb483650f8c..fa99ec72d832 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -38,6 +38,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <linux/regulator/consumer.h>
 #include <linux/suspend.h>
 #include <linux/component.h>
@@ -1035,32 +1036,14 @@ static int dss_init_ports(struct platform_device *pdev)
 {
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
-	int r;
-
-	if (parent == NULL)
-		return 0;
+	int i;
 
-	port = omapdss_of_get_next_port(parent, NULL);
-	if (!port)
-		return 0;
-
-	if (dss.feat->num_ports == 0)
-		return 0;
-
-	do {
-		enum omap_display_type port_type;
-		u32 reg;
-
-		r = of_property_read_u32(port, "reg", &reg);
-		if (r)
-			reg = 0;
-
-		if (reg >= dss.feat->num_ports)
+	for (i = 0; i < dss.feat->num_ports; i++) {
+		port = of_graph_get_port_by_id(parent, i);
+		if (!port)
 			continue;
 
-		port_type = dss.feat->ports[reg];
-
-		switch (port_type) {
+		switch (dss.feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
 			dpi_init_port(pdev, port);
 			break;
@@ -1070,7 +1053,7 @@ static int dss_init_ports(struct platform_device *pdev)
 		default:
 			break;
 		}
-	} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);
+	}
 
 	return 0;
 }
@@ -1079,32 +1062,14 @@ static void dss_uninit_ports(struct platform_device *pdev)
 {
 	struct device_node *parent = pdev->dev.of_node;
 	struct device_node *port;
+	int i;
 
-	if (parent == NULL)
-		return;
-
-	port = omapdss_of_get_next_port(parent, NULL);
-	if (!port)
-		return;
-
-	if (dss.feat->num_ports == 0)
-		return;
-
-	do {
-		enum omap_display_type port_type;
-		u32 reg;
-		int r;
-
-		r = of_property_read_u32(port, "reg", &reg);
-		if (r)
-			reg = 0;
-
-		if (reg >= dss.feat->num_ports)
+	for (i = 0; i < dss.feat->num_ports; i++) {
+		port = of_graph_get_port_by_id(parent, i);
+		if (!port)
 			continue;
 
-		port_type = dss.feat->ports[reg];
-
-		switch (port_type) {
+		switch (dss.feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
 			dpi_uninit_port(port);
 			break;
@@ -1114,7 +1079,7 @@ static void dss_uninit_ports(struct platform_device *pdev)
 		default:
 			break;
 		}
-	} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);
+	}
 }
 
 static int dss_video_pll_probe(struct platform_device *pdev)

commit 1e08c822689c39bd86d2154490f89265329e9c58
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue May 3 22:07:10 2016 +0300

    drm/omap: dss: Support for detecting display stack readiness
    
    When omapdss is loaded (all core components are in place) create a list of
    devices used in the display graph. This list later can be used by omapdrm
    via the omapdss_stack_is_ready() function to check that these components
    are loaded. Based on this information, omapdrm can defer probe in case when
    the omapdss stack is not ready yet.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 5eb2f1260547..ceb483650f8c 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1258,6 +1258,7 @@ static int dss_bind(struct device *dev)
 
 	pm_set_vt_switch(0);
 
+	omapdss_gather_components(dev);
 	omapdss_set_is_initialized(true);
 
 	return 0;

commit 7c299716297c9a90b31d1f627f003a0de9c48318
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 17:23:14 2015 +0200

    drm/omap: move dss_initialized to omapdss-base
    
    omapdss_is_initialized() is used to find out if omapdss has been probed
    successfully. This patch moves the related code to the common
    omapdss-base module, so that the same support will be there for both
    omapdss and omapdss6.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 4e72d2fefb4d..5eb2f1260547 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -117,14 +117,6 @@ static const char * const dss_generic_clk_source_names[] = {
 	[DSS_CLK_SRC_HDMI_PLL]	= "HDMI PLL",
 };
 
-static bool dss_initialized;
-
-bool omapdss_is_initialized(void)
-{
-	return dss_initialized;
-}
-EXPORT_SYMBOL(omapdss_is_initialized);
-
 static inline void dss_write_reg(const struct dss_reg idx, u32 val)
 {
 	__raw_writel(val, dss.base + idx.idx);
@@ -1266,7 +1258,7 @@ static int dss_bind(struct device *dev)
 
 	pm_set_vt_switch(0);
 
-	dss_initialized = true;
+	omapdss_set_is_initialized(true);
 
 	return 0;
 
@@ -1290,7 +1282,7 @@ static void dss_unbind(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 
-	dss_initialized = false;
+	omapdss_set_is_initialized(false);
 
 	component_unbind_all(&pdev->dev, NULL);
 

commit 8dfe162ac74f56b382d6e3d37365672897422f51
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 28 04:55:54 2017 -0800

    gpu: drm: drivers: Convert printk(KERN_<LEVEL> to pr_<level>
    
    Use a more common logging style.
    
    Miscellanea:
    
    o Coalesce formats and realign arguments
    o Neaten a few macros now using pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Acked-by: Sinclair Yeh <syeh@vmware.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/76355db47b31668bb64d996865ceee53bd66b11f.1488285953.git.joe@perches.com

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 14887d5b02e5..4e72d2fefb4d 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -1254,8 +1254,7 @@ static int dss_bind(struct device *dev)
 	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
 
 	rev = dss_read_reg(DSS_REVISION);
-	printk(KERN_INFO "OMAP DSS rev %d.%d\n",
-			FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
+	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
 	dss_runtime_put();
 

commit a1dec226a686077a9822013e601327b189f419df
Merge: ecf140dfc3fe 26038aad2511
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jun 7 09:00:25 2016 +0300

    Merge omapdss header refactoring
    
    Merge omapdss public header refactoring, which separates the public
    header into omapdrm and omapfb parts.

commit ecf140dfc3fe169aaff8f5561d345f6b96d7b476
Merge: 449c5e9c33fd 31dca077056a
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Jun 6 10:16:51 2016 +0300

    Merge branch '4.8/omapdrm-pll' (omapdrm PLL work)
    
    Merge omapdrm PLL work, which makes it possible to use the DSS PLLs in a
    versatile manner, for example, HDMI PLL can be used for LCDs.

commit 32043da7dcf2af3510d0410b0cacfbcde95e5d26
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 27 14:40:49 2016 +0300

    drm/omap: Do not include video/omapdss.h directly in drivers
    
    All drivers to include the omapdrm/dss/omapdss.h header file. This header
    includes the <video/omapdss.h>
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index f95ff319e68e..68942ba3ec44 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -41,8 +41,7 @@
 #include <linux/suspend.h>
 #include <linux/component.h>
 
-#include <video/omapdss.h>
-
+#include "omapdss.h"
 #include "dss.h"
 #include "dss_features.h"
 

commit 2639d6b9be19e029869158a6b8cbc5d253cd7bbc
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 9 23:51:27 2016 +0200

    drm/omapdrm: include pinctrl/consumer.h where needed
    
    In some configurations, we can build the OMAP dss driver without
    implictly including the pinctrl consumer definitions, causing
    a build error:
    
    gpu/drm/omapdrm/dss/dss.c: In function 'dss_runtime_suspend':
    gpu/drm/omapdrm/dss/dss.c:1268:2: error: implicit declaration of function 'pinctrl_pm_select_sleep_state' [-Werror=implicit-function-declaration]
    
    This adds an explicit #include.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index f95ff319e68e..3303cfad4838 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -30,6 +30,7 @@
 #include <linux/delay.h>
 #include <linux/seq_file.h>
 #include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/gfp.h>

commit c63b1ec0904a074ae311103109b3e9946e38f2fa
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 15:46:19 2016 +0300

    drm/omap: clean up the LCD clk mux code
    
    The code to set the clock muxes for DISPC's LCD clock inputs is very
    confusing. Especially on DRA7, there's an additional clock muxing that
    needs to be done, which at the moment is done in dpi.c using
    dss_ctrl_pll_set_control_mux().
    
    Clean this all up by:
    - Using dss_clk_source instead of dss_pll_id, as dss_pll_id doesn't
      specify the clock source quite correctly.
    - Splitting the dss_select_lcd_clk_source() up into DSS version specific
      helper functions.
    - Using dss_ctrl_pll_set_control_mux() from the helper functions, so
      that dpi.c doesn't have to call it.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 598a51b44e4a..2937a2812690 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -75,6 +75,8 @@ struct dss_features {
 	const enum omap_display_type *ports;
 	int num_ports;
 	int (*dpi_select_source)(int port, enum omap_channel channel);
+	int (*select_lcd_source)(enum omap_channel channel,
+		enum dss_clk_source clk_src);
 };
 
 static struct {
@@ -205,68 +207,70 @@ void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
 		1 << shift, val << shift);
 }
 
-void dss_ctrl_pll_set_control_mux(enum dss_pll_id pll_id,
+static int dss_ctrl_pll_set_control_mux(enum dss_clk_source clk_src,
 	enum omap_channel channel)
 {
 	unsigned shift, val;
 
 	if (!dss.syscon_pll_ctrl)
-		return;
+		return -EINVAL;
 
 	switch (channel) {
 	case OMAP_DSS_CHANNEL_LCD:
 		shift = 3;
 
-		switch (pll_id) {
-		case DSS_PLL_VIDEO1:
+		switch (clk_src) {
+		case DSS_CLK_SRC_PLL1_1:
 			val = 0; break;
-		case DSS_PLL_HDMI:
+		case DSS_CLK_SRC_HDMI_PLL:
 			val = 1; break;
 		default:
 			DSSERR("error in PLL mux config for LCD\n");
-			return;
+			return -EINVAL;
 		}
 
 		break;
 	case OMAP_DSS_CHANNEL_LCD2:
 		shift = 5;
 
-		switch (pll_id) {
-		case DSS_PLL_VIDEO1:
+		switch (clk_src) {
+		case DSS_CLK_SRC_PLL1_3:
 			val = 0; break;
-		case DSS_PLL_VIDEO2:
+		case DSS_CLK_SRC_PLL2_3:
 			val = 1; break;
-		case DSS_PLL_HDMI:
+		case DSS_CLK_SRC_HDMI_PLL:
 			val = 2; break;
 		default:
 			DSSERR("error in PLL mux config for LCD2\n");
-			return;
+			return -EINVAL;
 		}
 
 		break;
 	case OMAP_DSS_CHANNEL_LCD3:
 		shift = 7;
 
-		switch (pll_id) {
-		case DSS_PLL_VIDEO1:
-			val = 1; break;
-		case DSS_PLL_VIDEO2:
+		switch (clk_src) {
+		case DSS_CLK_SRC_PLL2_1:
 			val = 0; break;
-		case DSS_PLL_HDMI:
+		case DSS_CLK_SRC_PLL1_3:
+			val = 1; break;
+		case DSS_CLK_SRC_HDMI_PLL:
 			val = 2; break;
 		default:
 			DSSERR("error in PLL mux config for LCD3\n");
-			return;
+			return -EINVAL;
 		}
 
 		break;
 	default:
 		DSSERR("error in PLL mux config\n");
-		return;
+		return -EINVAL;
 	}
 
 	regmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,
 		0x3 << shift, val << shift);
+
+	return 0;
 }
 
 void dss_sdi_init(int datapairs)
@@ -404,11 +408,34 @@ static void dss_dump_regs(struct seq_file *s)
 #undef DUMPREG
 }
 
+static int dss_get_channel_index(enum omap_channel channel)
+{
+	switch (channel) {
+	case OMAP_DSS_CHANNEL_LCD:
+		return 0;
+	case OMAP_DSS_CHANNEL_LCD2:
+		return 1;
+	case OMAP_DSS_CHANNEL_LCD3:
+		return 2;
+	default:
+		WARN_ON(1);
+		return 0;
+	}
+}
+
 static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 {
 	int b;
 	u8 start, end;
 
+	/*
+	 * We always use PRCM clock as the DISPC func clock, except on DSS3,
+	 * where we don't have separate DISPC and LCD clock sources.
+	 */
+	if (WARN_ON(dss_has_feature(FEAT_LCD_CLK_SRC) &&
+		clk_src != DSS_CLK_SRC_FCK))
+		return;
+
 	switch (clk_src) {
 	case DSS_CLK_SRC_FCK:
 		b = 0;
@@ -459,41 +486,108 @@ void dss_select_dsi_clk_source(int dsi_module,
 	dss.dsi_clk_source[dsi_module] = clk_src;
 }
 
+static int dss_lcd_clk_mux_dra7(enum omap_channel channel,
+	enum dss_clk_source clk_src)
+{
+	const u8 ctrl_bits[] = {
+		[OMAP_DSS_CHANNEL_LCD] = 0,
+		[OMAP_DSS_CHANNEL_LCD2] = 12,
+		[OMAP_DSS_CHANNEL_LCD3] = 19,
+	};
+
+	u8 ctrl_bit = ctrl_bits[channel];
+	int r;
+
+	if (clk_src == DSS_CLK_SRC_FCK) {
+		/* LCDx_CLK_SWITCH */
+		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		return -EINVAL;
+	}
+
+	r = dss_ctrl_pll_set_control_mux(clk_src, channel);
+	if (r)
+		return r;
+
+	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+
+	return 0;
+}
+
+static int dss_lcd_clk_mux_omap5(enum omap_channel channel,
+	enum dss_clk_source clk_src)
+{
+	const u8 ctrl_bits[] = {
+		[OMAP_DSS_CHANNEL_LCD] = 0,
+		[OMAP_DSS_CHANNEL_LCD2] = 12,
+		[OMAP_DSS_CHANNEL_LCD3] = 19,
+	};
+	const enum dss_clk_source allowed_plls[] = {
+		[OMAP_DSS_CHANNEL_LCD] = DSS_CLK_SRC_PLL1_1,
+		[OMAP_DSS_CHANNEL_LCD2] = DSS_CLK_SRC_FCK,
+		[OMAP_DSS_CHANNEL_LCD3] = DSS_CLK_SRC_PLL2_1,
+	};
+
+	u8 ctrl_bit = ctrl_bits[channel];
+
+	if (clk_src == DSS_CLK_SRC_FCK) {
+		/* LCDx_CLK_SWITCH */
+		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		return -EINVAL;
+	}
+
+	if (WARN_ON(allowed_plls[channel] != clk_src))
+		return -EINVAL;
+
+	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+
+	return 0;
+}
+
+static int dss_lcd_clk_mux_omap4(enum omap_channel channel,
+	enum dss_clk_source clk_src)
+{
+	const u8 ctrl_bits[] = {
+		[OMAP_DSS_CHANNEL_LCD] = 0,
+		[OMAP_DSS_CHANNEL_LCD2] = 12,
+	};
+	const enum dss_clk_source allowed_plls[] = {
+		[OMAP_DSS_CHANNEL_LCD] = DSS_CLK_SRC_PLL1_1,
+		[OMAP_DSS_CHANNEL_LCD2] = DSS_CLK_SRC_PLL2_1,
+	};
+
+	u8 ctrl_bit = ctrl_bits[channel];
+
+	if (clk_src == DSS_CLK_SRC_FCK) {
+		/* LCDx_CLK_SWITCH */
+		REG_FLD_MOD(DSS_CONTROL, 0, ctrl_bit, ctrl_bit);
+		return 0;
+	}
+
+	if (WARN_ON(allowed_plls[channel] != clk_src))
+		return -EINVAL;
+
+	REG_FLD_MOD(DSS_CONTROL, 1, ctrl_bit, ctrl_bit);
+
+	return 0;
+}
+
 void dss_select_lcd_clk_source(enum omap_channel channel,
 		enum dss_clk_source clk_src)
 {
-	int b, ix, pos;
+	int idx = dss_get_channel_index(channel);
+	int r;
 
 	if (!dss_has_feature(FEAT_LCD_CLK_SRC)) {
 		dss_select_dispc_clk_source(clk_src);
+		dss.lcd_clk_source[idx] = clk_src;
 		return;
 	}
 
-	switch (clk_src) {
-	case DSS_CLK_SRC_FCK:
-		b = 0;
-		break;
-	case DSS_CLK_SRC_PLL1_1:
-		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD);
-		b = 1;
-		break;
-	case DSS_CLK_SRC_PLL2_1:
-		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&
-		       channel != OMAP_DSS_CHANNEL_LCD3);
-		b = 1;
-		break;
-	default:
-		BUG();
+	r = dss.feat->select_lcd_source(channel, clk_src);
+	if (r)
 		return;
-	}
-
-	pos = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
-	     (channel == OMAP_DSS_CHANNEL_LCD2 ? 12 : 19);
-	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* LCDx_CLK_SWITCH */
 
-	ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
-	    (channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);
-	dss.lcd_clk_source[ix] = clk_src;
+	dss.lcd_clk_source[idx] = clk_src;
 }
 
 enum dss_clk_source dss_get_dispc_clk_source(void)
@@ -509,9 +603,8 @@ enum dss_clk_source dss_get_dsi_clk_source(int dsi_module)
 enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
 {
 	if (dss_has_feature(FEAT_LCD_CLK_SRC)) {
-		int ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
-			(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);
-		return dss.lcd_clk_source[ix];
+		int idx = dss_get_channel_index(channel);
+		return dss.lcd_clk_source[idx];
 	} else {
 		/* LCD_CLK source is the same as DISPC_FCLK source for
 		 * OMAP2 and OMAP3 */
@@ -860,6 +953,7 @@ static const struct dss_features omap44xx_dss_feats = {
 	.dpi_select_source	=	&dss_dpi_select_source_omap4,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.select_lcd_source	=	&dss_lcd_clk_mux_omap4,
 };
 
 static const struct dss_features omap54xx_dss_feats = {
@@ -869,6 +963,7 @@ static const struct dss_features omap54xx_dss_feats = {
 	.dpi_select_source	=	&dss_dpi_select_source_omap5,
 	.ports			=	omap2plus_ports,
 	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+	.select_lcd_source	=	&dss_lcd_clk_mux_omap5,
 };
 
 static const struct dss_features am43xx_dss_feats = {
@@ -887,6 +982,7 @@ static const struct dss_features dra7xx_dss_feats = {
 	.dpi_select_source	=	&dss_dpi_select_source_dra7xx,
 	.ports			=	dra7xx_ports,
 	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
+	.select_lcd_source	=	&dss_lcd_clk_mux_dra7,
 };
 
 static int dss_init_features(struct platform_device *pdev)

commit b5d8c757a64fa7938f965171d2d0f40d5273fb2e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 14:12:35 2016 +0300

    drm/omap: Add missing clock sources
    
    enum dss_clk_source does not have values for all clock sources available
    on OMAP4+ DSS versions. Add the missing clock sources.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 58d20530059a..598a51b44e4a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -108,8 +108,11 @@ static const char * const dss_generic_clk_source_names[] = {
 	[DSS_CLK_SRC_FCK]	= "FCK",
 	[DSS_CLK_SRC_PLL1_1]	= "PLL1:1",
 	[DSS_CLK_SRC_PLL1_2]	= "PLL1:2",
+	[DSS_CLK_SRC_PLL1_3]	= "PLL1:3",
 	[DSS_CLK_SRC_PLL2_1]	= "PLL2:1",
 	[DSS_CLK_SRC_PLL2_2]	= "PLL2:2",
+	[DSS_CLK_SRC_PLL2_3]	= "PLL2:3",
+	[DSS_CLK_SRC_HDMI_PLL]	= "HDMI PLL",
 };
 
 static bool dss_initialized;

commit 3b63ca75661decc7db44b492cafbbe60adaf3731
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 14:01:10 2016 +0300

    drm/omap: rename dss_clk_source enums
    
    The names of the enum dss_clk_source's values are legacy names, only
    correct for OMAP3 DSS. Rename the names to more generic ones.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 9de30ff4f537..58d20530059a 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -105,11 +105,11 @@ static struct {
 } dss;
 
 static const char * const dss_generic_clk_source_names[] = {
-	[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC]	= "DSI_PLL_HSDIV_DISPC",
-	[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI]	= "DSI_PLL_HSDIV_DSI",
-	[OMAP_DSS_CLK_SRC_FCK]			= "DSS_FCK",
-	[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC]	= "DSI_PLL2_HSDIV_DISPC",
-	[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI]	= "DSI_PLL2_HSDIV_DSI",
+	[DSS_CLK_SRC_FCK]	= "FCK",
+	[DSS_CLK_SRC_PLL1_1]	= "PLL1:1",
+	[DSS_CLK_SRC_PLL1_2]	= "PLL1:2",
+	[DSS_CLK_SRC_PLL2_1]	= "PLL2:1",
+	[DSS_CLK_SRC_PLL2_2]	= "PLL2:2",
 };
 
 static bool dss_initialized;
@@ -368,7 +368,7 @@ void dss_dump_clocks(struct seq_file *s)
 
 	seq_printf(s, "- DSS -\n");
 
-	fclk_name = dss_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
+	fclk_name = dss_get_clk_source_name(DSS_CLK_SRC_FCK);
 	fclk_rate = clk_get_rate(dss.dss_clk);
 
 	seq_printf(s, "%s = %lu\n",
@@ -407,13 +407,13 @@ static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 	u8 start, end;
 
 	switch (clk_src) {
-	case OMAP_DSS_CLK_SRC_FCK:
+	case DSS_CLK_SRC_FCK:
 		b = 0;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL1_1:
 		b = 1;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL2_1:
 		b = 2;
 		break;
 	default:
@@ -434,14 +434,14 @@ void dss_select_dsi_clk_source(int dsi_module,
 	int b, pos;
 
 	switch (clk_src) {
-	case OMAP_DSS_CLK_SRC_FCK:
+	case DSS_CLK_SRC_FCK:
 		b = 0;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI:
+	case DSS_CLK_SRC_PLL1_2:
 		BUG_ON(dsi_module != 0);
 		b = 1;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI:
+	case DSS_CLK_SRC_PLL2_2:
 		BUG_ON(dsi_module != 1);
 		b = 1;
 		break;
@@ -467,14 +467,14 @@ void dss_select_lcd_clk_source(enum omap_channel channel,
 	}
 
 	switch (clk_src) {
-	case OMAP_DSS_CLK_SRC_FCK:
+	case DSS_CLK_SRC_FCK:
 		b = 0;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL1_1:
 		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD);
 		b = 1;
 		break;
-	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+	case DSS_CLK_SRC_PLL2_1:
 		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&
 		       channel != OMAP_DSS_CHANNEL_LCD3);
 		b = 1;
@@ -1141,18 +1141,18 @@ static int dss_bind(struct device *dev)
 	/* Select DPLL */
 	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
 
-	dss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);
+	dss_select_dispc_clk_source(DSS_CLK_SRC_FCK);
 
 #ifdef CONFIG_OMAP2_DSS_VENC
 	REG_FLD_MOD(DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
 	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
 	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
 #endif
-	dss.dsi_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;
-	dss.dsi_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;
-	dss.dispc_clk_source = OMAP_DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;
+	dss.dsi_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss.dsi_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss.dispc_clk_source = DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
 
 	rev = dss_read_reg(DSS_REVISION);
 	printk(KERN_INFO "OMAP DSS rev %d.%d\n",

commit 407bd564ed3beec31d82fe10f7c3defcf4f071d8
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:50:55 2016 +0300

    drm/omap: rename dss_get_generic_clk_source_name()
    
    Now that there is no "non-generic" version of the function to get the
    clock source name, lets rename dss_get_generic_clk_source_name() to
    dss_get_clk_source_name().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 7717948e1c4d..9de30ff4f537 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -353,7 +353,7 @@ void dss_sdi_disable(void)
 	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 }
 
-const char *dss_get_generic_clk_source_name(enum dss_clk_source clk_src)
+const char *dss_get_clk_source_name(enum dss_clk_source clk_src)
 {
 	return dss_generic_clk_source_names[clk_src];
 }
@@ -368,7 +368,7 @@ void dss_dump_clocks(struct seq_file *s)
 
 	seq_printf(s, "- DSS -\n");
 
-	fclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
+	fclk_name = dss_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
 	fclk_rate = clk_get_rate(dss.dss_clk);
 
 	seq_printf(s, "%s = %lu\n",

commit 557a15443d4792195cf299f69f64042a27bba044
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:49:18 2016 +0300

    drm/omap: remove dss_feat_get_clk_source_name()
    
    We have two functions to return a name for clock sources for debugging
    purposes: dss_feat_get_clk_source_name() and
    dss_get_generic_clk_source_name().
    
    The former is supposed to return a DSS IP version specific name for the
    clock source, and the latter is supposed to return a more generic name.
    
    All this seems a bit pointless, so let's remove the former one.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index 164a9b047971..7717948e1c4d 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -360,7 +360,7 @@ const char *dss_get_generic_clk_source_name(enum dss_clk_source clk_src)
 
 void dss_dump_clocks(struct seq_file *s)
 {
-	const char *fclk_name, *fclk_real_name;
+	const char *fclk_name;
 	unsigned long fclk_rate;
 
 	if (dss_runtime_get())
@@ -369,11 +369,10 @@ void dss_dump_clocks(struct seq_file *s)
 	seq_printf(s, "- DSS -\n");
 
 	fclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
-	fclk_real_name = dss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
 	fclk_rate = clk_get_rate(dss.dss_clk);
 
-	seq_printf(s, "%s (%s) = %lu\n",
-			fclk_name, fclk_real_name,
+	seq_printf(s, "%s = %lu\n",
+			fclk_name,
 			fclk_rate);
 
 	dss_runtime_put();

commit dc0352d1bd618f1e452ec3378aacb24a2d2f3669
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 17 13:45:09 2016 +0300

    drm/omap: rename omap_dss_clk_source
    
    'enum omap_dss_clk_source' is internal to dss. Let's rename it to
    'dss_clk_source' match our naming convention.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
index f95ff319e68e..164a9b047971 100644
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -91,9 +91,9 @@ static struct {
 	unsigned long	cache_prate;
 	struct dispc_clock_info cache_dispc_cinfo;
 
-	enum omap_dss_clk_source dsi_clk_source[MAX_NUM_DSI];
-	enum omap_dss_clk_source dispc_clk_source;
-	enum omap_dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];
+	enum dss_clk_source dsi_clk_source[MAX_NUM_DSI];
+	enum dss_clk_source dispc_clk_source;
+	enum dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];
 
 	bool		ctx_valid;
 	u32		ctx[DSS_SZ_REGS / sizeof(u32)];
@@ -353,7 +353,7 @@ void dss_sdi_disable(void)
 	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 }
 
-const char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src)
+const char *dss_get_generic_clk_source_name(enum dss_clk_source clk_src)
 {
 	return dss_generic_clk_source_names[clk_src];
 }
@@ -402,7 +402,7 @@ static void dss_dump_regs(struct seq_file *s)
 #undef DUMPREG
 }
 
-static void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)
+static void dss_select_dispc_clk_source(enum dss_clk_source clk_src)
 {
 	int b;
 	u8 start, end;
@@ -430,7 +430,7 @@ static void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)
 }
 
 void dss_select_dsi_clk_source(int dsi_module,
-		enum omap_dss_clk_source clk_src)
+		enum dss_clk_source clk_src)
 {
 	int b, pos;
 
@@ -458,7 +458,7 @@ void dss_select_dsi_clk_source(int dsi_module,
 }
 
 void dss_select_lcd_clk_source(enum omap_channel channel,
-		enum omap_dss_clk_source clk_src)
+		enum dss_clk_source clk_src)
 {
 	int b, ix, pos;
 
@@ -494,17 +494,17 @@ void dss_select_lcd_clk_source(enum omap_channel channel,
 	dss.lcd_clk_source[ix] = clk_src;
 }
 
-enum omap_dss_clk_source dss_get_dispc_clk_source(void)
+enum dss_clk_source dss_get_dispc_clk_source(void)
 {
 	return dss.dispc_clk_source;
 }
 
-enum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module)
+enum dss_clk_source dss_get_dsi_clk_source(int dsi_module)
 {
 	return dss.dsi_clk_source[dsi_module];
 }
 
-enum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
+enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
 {
 	if (dss_has_feature(FEAT_LCD_CLK_SRC)) {
 		int ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :

commit 9960aa7cb58caadef8edf3a2582e30664a6b68dd
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Dec 9 20:26:00 2015 +0200

    drm/omap: move omapdss & displays under omapdrm
    
    Now that omapfb has its own copy of omapdss and display drivers, we can
    move omapdss and display drivers which omapdrm uses to omapdrm's
    directory.
    
    We also need to change the main drm Makefile so that omapdrm directory
    is always entered, because omapdss has a file that can't be built as a
    module.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Acked-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/dss/dss.c b/drivers/gpu/drm/omapdrm/dss/dss.c
new file mode 100644
index 000000000000..f95ff319e68e
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -0,0 +1,1329 @@
+/*
+ * linux/drivers/video/omap2/dss/dss.c
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * Some code and ideas taken from drivers/video/omap/ driver
+ * by Imre Deak.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DSS_SUBSYS_NAME "DSS"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/gfp.h>
+#include <linux/sizes.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include <linux/component.h>
+
+#include <video/omapdss.h>
+
+#include "dss.h"
+#include "dss_features.h"
+
+#define DSS_SZ_REGS			SZ_512
+
+struct dss_reg {
+	u16 idx;
+};
+
+#define DSS_REG(idx)			((const struct dss_reg) { idx })
+
+#define DSS_REVISION			DSS_REG(0x0000)
+#define DSS_SYSCONFIG			DSS_REG(0x0010)
+#define DSS_SYSSTATUS			DSS_REG(0x0014)
+#define DSS_CONTROL			DSS_REG(0x0040)
+#define DSS_SDI_CONTROL			DSS_REG(0x0044)
+#define DSS_PLL_CONTROL			DSS_REG(0x0048)
+#define DSS_SDI_STATUS			DSS_REG(0x005C)
+
+#define REG_GET(idx, start, end) \
+	FLD_GET(dss_read_reg(idx), start, end)
+
+#define REG_FLD_MOD(idx, val, start, end) \
+	dss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))
+
+struct dss_features {
+	u8 fck_div_max;
+	u8 dss_fck_multiplier;
+	const char *parent_clk_name;
+	const enum omap_display_type *ports;
+	int num_ports;
+	int (*dpi_select_source)(int port, enum omap_channel channel);
+};
+
+static struct {
+	struct platform_device *pdev;
+	void __iomem    *base;
+	struct regmap	*syscon_pll_ctrl;
+	u32		syscon_pll_ctrl_offset;
+
+	struct clk	*parent_clk;
+	struct clk	*dss_clk;
+	unsigned long	dss_clk_rate;
+
+	unsigned long	cache_req_pck;
+	unsigned long	cache_prate;
+	struct dispc_clock_info cache_dispc_cinfo;
+
+	enum omap_dss_clk_source dsi_clk_source[MAX_NUM_DSI];
+	enum omap_dss_clk_source dispc_clk_source;
+	enum omap_dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];
+
+	bool		ctx_valid;
+	u32		ctx[DSS_SZ_REGS / sizeof(u32)];
+
+	const struct dss_features *feat;
+
+	struct dss_pll	*video1_pll;
+	struct dss_pll	*video2_pll;
+} dss;
+
+static const char * const dss_generic_clk_source_names[] = {
+	[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC]	= "DSI_PLL_HSDIV_DISPC",
+	[OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI]	= "DSI_PLL_HSDIV_DSI",
+	[OMAP_DSS_CLK_SRC_FCK]			= "DSS_FCK",
+	[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC]	= "DSI_PLL2_HSDIV_DISPC",
+	[OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI]	= "DSI_PLL2_HSDIV_DSI",
+};
+
+static bool dss_initialized;
+
+bool omapdss_is_initialized(void)
+{
+	return dss_initialized;
+}
+EXPORT_SYMBOL(omapdss_is_initialized);
+
+static inline void dss_write_reg(const struct dss_reg idx, u32 val)
+{
+	__raw_writel(val, dss.base + idx.idx);
+}
+
+static inline u32 dss_read_reg(const struct dss_reg idx)
+{
+	return __raw_readl(dss.base + idx.idx);
+}
+
+#define SR(reg) \
+	dss.ctx[(DSS_##reg).idx / sizeof(u32)] = dss_read_reg(DSS_##reg)
+#define RR(reg) \
+	dss_write_reg(DSS_##reg, dss.ctx[(DSS_##reg).idx / sizeof(u32)])
+
+static void dss_save_context(void)
+{
+	DSSDBG("dss_save_context\n");
+
+	SR(CONTROL);
+
+	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DISPLAY_TYPE_SDI) {
+		SR(SDI_CONTROL);
+		SR(PLL_CONTROL);
+	}
+
+	dss.ctx_valid = true;
+
+	DSSDBG("context saved\n");
+}
+
+static void dss_restore_context(void)
+{
+	DSSDBG("dss_restore_context\n");
+
+	if (!dss.ctx_valid)
+		return;
+
+	RR(CONTROL);
+
+	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DISPLAY_TYPE_SDI) {
+		RR(SDI_CONTROL);
+		RR(PLL_CONTROL);
+	}
+
+	DSSDBG("context restored\n");
+}
+
+#undef SR
+#undef RR
+
+void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)
+{
+	unsigned shift;
+	unsigned val;
+
+	if (!dss.syscon_pll_ctrl)
+		return;
+
+	val = !enable;
+
+	switch (pll_id) {
+	case DSS_PLL_VIDEO1:
+		shift = 0;
+		break;
+	case DSS_PLL_VIDEO2:
+		shift = 1;
+		break;
+	case DSS_PLL_HDMI:
+		shift = 2;
+		break;
+	default:
+		DSSERR("illegal DSS PLL ID %d\n", pll_id);
+		return;
+	}
+
+	regmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,
+		1 << shift, val << shift);
+}
+
+void dss_ctrl_pll_set_control_mux(enum dss_pll_id pll_id,
+	enum omap_channel channel)
+{
+	unsigned shift, val;
+
+	if (!dss.syscon_pll_ctrl)
+		return;
+
+	switch (channel) {
+	case OMAP_DSS_CHANNEL_LCD:
+		shift = 3;
+
+		switch (pll_id) {
+		case DSS_PLL_VIDEO1:
+			val = 0; break;
+		case DSS_PLL_HDMI:
+			val = 1; break;
+		default:
+			DSSERR("error in PLL mux config for LCD\n");
+			return;
+		}
+
+		break;
+	case OMAP_DSS_CHANNEL_LCD2:
+		shift = 5;
+
+		switch (pll_id) {
+		case DSS_PLL_VIDEO1:
+			val = 0; break;
+		case DSS_PLL_VIDEO2:
+			val = 1; break;
+		case DSS_PLL_HDMI:
+			val = 2; break;
+		default:
+			DSSERR("error in PLL mux config for LCD2\n");
+			return;
+		}
+
+		break;
+	case OMAP_DSS_CHANNEL_LCD3:
+		shift = 7;
+
+		switch (pll_id) {
+		case DSS_PLL_VIDEO1:
+			val = 1; break;
+		case DSS_PLL_VIDEO2:
+			val = 0; break;
+		case DSS_PLL_HDMI:
+			val = 2; break;
+		default:
+			DSSERR("error in PLL mux config for LCD3\n");
+			return;
+		}
+
+		break;
+	default:
+		DSSERR("error in PLL mux config\n");
+		return;
+	}
+
+	regmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,
+		0x3 << shift, val << shift);
+}
+
+void dss_sdi_init(int datapairs)
+{
+	u32 l;
+
+	BUG_ON(datapairs > 3 || datapairs < 1);
+
+	l = dss_read_reg(DSS_SDI_CONTROL);
+	l = FLD_MOD(l, 0xf, 19, 15);		/* SDI_PDIV */
+	l = FLD_MOD(l, datapairs-1, 3, 2);	/* SDI_PRSEL */
+	l = FLD_MOD(l, 2, 1, 0);		/* SDI_BWSEL */
+	dss_write_reg(DSS_SDI_CONTROL, l);
+
+	l = dss_read_reg(DSS_PLL_CONTROL);
+	l = FLD_MOD(l, 0x7, 25, 22);	/* SDI_PLL_FREQSEL */
+	l = FLD_MOD(l, 0xb, 16, 11);	/* SDI_PLL_REGN */
+	l = FLD_MOD(l, 0xb4, 10, 1);	/* SDI_PLL_REGM */
+	dss_write_reg(DSS_PLL_CONTROL, l);
+}
+
+int dss_sdi_enable(void)
+{
+	unsigned long timeout;
+
+	dispc_pck_free_enable(1);
+
+	/* Reset SDI PLL */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 1, 18, 18); /* SDI_PLL_SYSRESET */
+	udelay(1);	/* wait 2x PCLK */
+
+	/* Lock SDI PLL */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28); /* SDI_PLL_GOBIT */
+
+	/* Waiting for PLL lock request to complete */
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("PLL lock request timed out\n");
+			goto err1;
+		}
+	}
+
+	/* Clearing PLL_GO bit */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);
+
+	/* Waiting for PLL to lock */
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("PLL lock timed out\n");
+			goto err1;
+		}
+	}
+
+	dispc_lcd_enable_signal(1);
+
+	/* Waiting for SDI reset to complete */
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("SDI reset timed out\n");
+			goto err2;
+		}
+	}
+
+	return 0;
+
+ err2:
+	dispc_lcd_enable_signal(0);
+ err1:
+	/* Reset SDI PLL */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
+
+	dispc_pck_free_enable(0);
+
+	return -ETIMEDOUT;
+}
+
+void dss_sdi_disable(void)
+{
+	dispc_lcd_enable_signal(0);
+
+	dispc_pck_free_enable(0);
+
+	/* Reset SDI PLL */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
+}
+
+const char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src)
+{
+	return dss_generic_clk_source_names[clk_src];
+}
+
+void dss_dump_clocks(struct seq_file *s)
+{
+	const char *fclk_name, *fclk_real_name;
+	unsigned long fclk_rate;
+
+	if (dss_runtime_get())
+		return;
+
+	seq_printf(s, "- DSS -\n");
+
+	fclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
+	fclk_real_name = dss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);
+	fclk_rate = clk_get_rate(dss.dss_clk);
+
+	seq_printf(s, "%s (%s) = %lu\n",
+			fclk_name, fclk_real_name,
+			fclk_rate);
+
+	dss_runtime_put();
+}
+
+static void dss_dump_regs(struct seq_file *s)
+{
+#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))
+
+	if (dss_runtime_get())
+		return;
+
+	DUMPREG(DSS_REVISION);
+	DUMPREG(DSS_SYSCONFIG);
+	DUMPREG(DSS_SYSSTATUS);
+	DUMPREG(DSS_CONTROL);
+
+	if (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &
+			OMAP_DISPLAY_TYPE_SDI) {
+		DUMPREG(DSS_SDI_CONTROL);
+		DUMPREG(DSS_PLL_CONTROL);
+		DUMPREG(DSS_SDI_STATUS);
+	}
+
+	dss_runtime_put();
+#undef DUMPREG
+}
+
+static void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)
+{
+	int b;
+	u8 start, end;
+
+	switch (clk_src) {
+	case OMAP_DSS_CLK_SRC_FCK:
+		b = 0;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+		b = 1;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+		b = 2;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	dss_feat_get_reg_field(FEAT_REG_DISPC_CLK_SWITCH, &start, &end);
+
+	REG_FLD_MOD(DSS_CONTROL, b, start, end);	/* DISPC_CLK_SWITCH */
+
+	dss.dispc_clk_source = clk_src;
+}
+
+void dss_select_dsi_clk_source(int dsi_module,
+		enum omap_dss_clk_source clk_src)
+{
+	int b, pos;
+
+	switch (clk_src) {
+	case OMAP_DSS_CLK_SRC_FCK:
+		b = 0;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI:
+		BUG_ON(dsi_module != 0);
+		b = 1;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI:
+		BUG_ON(dsi_module != 1);
+		b = 1;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	pos = dsi_module == 0 ? 1 : 10;
+	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* DSIx_CLK_SWITCH */
+
+	dss.dsi_clk_source[dsi_module] = clk_src;
+}
+
+void dss_select_lcd_clk_source(enum omap_channel channel,
+		enum omap_dss_clk_source clk_src)
+{
+	int b, ix, pos;
+
+	if (!dss_has_feature(FEAT_LCD_CLK_SRC)) {
+		dss_select_dispc_clk_source(clk_src);
+		return;
+	}
+
+	switch (clk_src) {
+	case OMAP_DSS_CLK_SRC_FCK:
+		b = 0;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:
+		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD);
+		b = 1;
+		break;
+	case OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:
+		BUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&
+		       channel != OMAP_DSS_CHANNEL_LCD3);
+		b = 1;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	pos = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
+	     (channel == OMAP_DSS_CHANNEL_LCD2 ? 12 : 19);
+	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* LCDx_CLK_SWITCH */
+
+	ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
+	    (channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);
+	dss.lcd_clk_source[ix] = clk_src;
+}
+
+enum omap_dss_clk_source dss_get_dispc_clk_source(void)
+{
+	return dss.dispc_clk_source;
+}
+
+enum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module)
+{
+	return dss.dsi_clk_source[dsi_module];
+}
+
+enum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
+{
+	if (dss_has_feature(FEAT_LCD_CLK_SRC)) {
+		int ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :
+			(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);
+		return dss.lcd_clk_source[ix];
+	} else {
+		/* LCD_CLK source is the same as DISPC_FCLK source for
+		 * OMAP2 and OMAP3 */
+		return dss.dispc_clk_source;
+	}
+}
+
+bool dss_div_calc(unsigned long pck, unsigned long fck_min,
+		dss_div_calc_func func, void *data)
+{
+	int fckd, fckd_start, fckd_stop;
+	unsigned long fck;
+	unsigned long fck_hw_max;
+	unsigned long fckd_hw_max;
+	unsigned long prate;
+	unsigned m;
+
+	fck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+
+	if (dss.parent_clk == NULL) {
+		unsigned pckd;
+
+		pckd = fck_hw_max / pck;
+
+		fck = pck * pckd;
+
+		fck = clk_round_rate(dss.dss_clk, fck);
+
+		return func(fck, data);
+	}
+
+	fckd_hw_max = dss.feat->fck_div_max;
+
+	m = dss.feat->dss_fck_multiplier;
+	prate = clk_get_rate(dss.parent_clk);
+
+	fck_min = fck_min ? fck_min : 1;
+
+	fckd_start = min(prate * m / fck_min, fckd_hw_max);
+	fckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);
+
+	for (fckd = fckd_start; fckd >= fckd_stop; --fckd) {
+		fck = DIV_ROUND_UP(prate, fckd) * m;
+
+		if (func(fck, data))
+			return true;
+	}
+
+	return false;
+}
+
+int dss_set_fck_rate(unsigned long rate)
+{
+	int r;
+
+	DSSDBG("set fck to %lu\n", rate);
+
+	r = clk_set_rate(dss.dss_clk, rate);
+	if (r)
+		return r;
+
+	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+
+	WARN_ONCE(dss.dss_clk_rate != rate,
+			"clk rate mismatch: %lu != %lu", dss.dss_clk_rate,
+			rate);
+
+	return 0;
+}
+
+unsigned long dss_get_dispc_clk_rate(void)
+{
+	return dss.dss_clk_rate;
+}
+
+static int dss_setup_default_clock(void)
+{
+	unsigned long max_dss_fck, prate;
+	unsigned long fck;
+	unsigned fck_div;
+	int r;
+
+	max_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);
+
+	if (dss.parent_clk == NULL) {
+		fck = clk_round_rate(dss.dss_clk, max_dss_fck);
+	} else {
+		prate = clk_get_rate(dss.parent_clk);
+
+		fck_div = DIV_ROUND_UP(prate * dss.feat->dss_fck_multiplier,
+				max_dss_fck);
+		fck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;
+	}
+
+	r = dss_set_fck_rate(fck);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+void dss_set_venc_output(enum omap_dss_venc_type type)
+{
+	int l = 0;
+
+	if (type == OMAP_DSS_VENC_TYPE_COMPOSITE)
+		l = 0;
+	else if (type == OMAP_DSS_VENC_TYPE_SVIDEO)
+		l = 1;
+	else
+		BUG();
+
+	/* venc out selection. 0 = comp, 1 = svideo */
+	REG_FLD_MOD(DSS_CONTROL, l, 6, 6);
+}
+
+void dss_set_dac_pwrdn_bgz(bool enable)
+{
+	REG_FLD_MOD(DSS_CONTROL, enable, 5, 5);	/* DAC Power-Down Control */
+}
+
+void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
+{
+	enum omap_display_type dp;
+	dp = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);
+
+	/* Complain about invalid selections */
+	WARN_ON((src == DSS_VENC_TV_CLK) && !(dp & OMAP_DISPLAY_TYPE_VENC));
+	WARN_ON((src == DSS_HDMI_M_PCLK) && !(dp & OMAP_DISPLAY_TYPE_HDMI));
+
+	/* Select only if we have options */
+	if ((dp & OMAP_DISPLAY_TYPE_VENC) && (dp & OMAP_DISPLAY_TYPE_HDMI))
+		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
+}
+
+enum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)
+{
+	enum omap_display_type displays;
+
+	displays = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);
+	if ((displays & OMAP_DISPLAY_TYPE_HDMI) == 0)
+		return DSS_VENC_TV_CLK;
+
+	if ((displays & OMAP_DISPLAY_TYPE_VENC) == 0)
+		return DSS_HDMI_M_PCLK;
+
+	return REG_GET(DSS_CONTROL, 15, 15);
+}
+
+static int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)
+{
+	if (channel != OMAP_DSS_CHANNEL_LCD)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int dss_dpi_select_source_omap4(int port, enum omap_channel channel)
+{
+	int val;
+
+	switch (channel) {
+	case OMAP_DSS_CHANNEL_LCD2:
+		val = 0;
+		break;
+	case OMAP_DSS_CHANNEL_DIGIT:
+		val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	REG_FLD_MOD(DSS_CONTROL, val, 17, 17);
+
+	return 0;
+}
+
+static int dss_dpi_select_source_omap5(int port, enum omap_channel channel)
+{
+	int val;
+
+	switch (channel) {
+	case OMAP_DSS_CHANNEL_LCD:
+		val = 1;
+		break;
+	case OMAP_DSS_CHANNEL_LCD2:
+		val = 2;
+		break;
+	case OMAP_DSS_CHANNEL_LCD3:
+		val = 3;
+		break;
+	case OMAP_DSS_CHANNEL_DIGIT:
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	REG_FLD_MOD(DSS_CONTROL, val, 17, 16);
+
+	return 0;
+}
+
+static int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)
+{
+	switch (port) {
+	case 0:
+		return dss_dpi_select_source_omap5(port, channel);
+	case 1:
+		if (channel != OMAP_DSS_CHANNEL_LCD2)
+			return -EINVAL;
+		break;
+	case 2:
+		if (channel != OMAP_DSS_CHANNEL_LCD3)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int dss_dpi_select_source(int port, enum omap_channel channel)
+{
+	return dss.feat->dpi_select_source(port, channel);
+}
+
+static int dss_get_clocks(void)
+{
+	struct clk *clk;
+
+	clk = devm_clk_get(&dss.pdev->dev, "fck");
+	if (IS_ERR(clk)) {
+		DSSERR("can't get clock fck\n");
+		return PTR_ERR(clk);
+	}
+
+	dss.dss_clk = clk;
+
+	if (dss.feat->parent_clk_name) {
+		clk = clk_get(NULL, dss.feat->parent_clk_name);
+		if (IS_ERR(clk)) {
+			DSSERR("Failed to get %s\n", dss.feat->parent_clk_name);
+			return PTR_ERR(clk);
+		}
+	} else {
+		clk = NULL;
+	}
+
+	dss.parent_clk = clk;
+
+	return 0;
+}
+
+static void dss_put_clocks(void)
+{
+	if (dss.parent_clk)
+		clk_put(dss.parent_clk);
+}
+
+int dss_runtime_get(void)
+{
+	int r;
+
+	DSSDBG("dss_runtime_get\n");
+
+	r = pm_runtime_get_sync(&dss.pdev->dev);
+	WARN_ON(r < 0);
+	return r < 0 ? r : 0;
+}
+
+void dss_runtime_put(void)
+{
+	int r;
+
+	DSSDBG("dss_runtime_put\n");
+
+	r = pm_runtime_put_sync(&dss.pdev->dev);
+	WARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);
+}
+
+/* DEBUGFS */
+#if defined(CONFIG_OMAP2_DSS_DEBUGFS)
+void dss_debug_dump_clocks(struct seq_file *s)
+{
+	dss_dump_clocks(s);
+	dispc_dump_clocks(s);
+#ifdef CONFIG_OMAP2_DSS_DSI
+	dsi_dump_clocks(s);
+#endif
+}
+#endif
+
+
+static const enum omap_display_type omap2plus_ports[] = {
+	OMAP_DISPLAY_TYPE_DPI,
+};
+
+static const enum omap_display_type omap34xx_ports[] = {
+	OMAP_DISPLAY_TYPE_DPI,
+	OMAP_DISPLAY_TYPE_SDI,
+};
+
+static const enum omap_display_type dra7xx_ports[] = {
+	OMAP_DISPLAY_TYPE_DPI,
+	OMAP_DISPLAY_TYPE_DPI,
+	OMAP_DISPLAY_TYPE_DPI,
+};
+
+static const struct dss_features omap24xx_dss_feats = {
+	/*
+	 * fck div max is really 16, but the divider range has gaps. The range
+	 * from 1 to 6 has no gaps, so let's use that as a max.
+	 */
+	.fck_div_max		=	6,
+	.dss_fck_multiplier	=	2,
+	.parent_clk_name	=	"core_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
+	.ports			=	omap2plus_ports,
+	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+};
+
+static const struct dss_features omap34xx_dss_feats = {
+	.fck_div_max		=	16,
+	.dss_fck_multiplier	=	2,
+	.parent_clk_name	=	"dpll4_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
+	.ports			=	omap34xx_ports,
+	.num_ports		=	ARRAY_SIZE(omap34xx_ports),
+};
+
+static const struct dss_features omap3630_dss_feats = {
+	.fck_div_max		=	32,
+	.dss_fck_multiplier	=	1,
+	.parent_clk_name	=	"dpll4_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
+	.ports			=	omap2plus_ports,
+	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+};
+
+static const struct dss_features omap44xx_dss_feats = {
+	.fck_div_max		=	32,
+	.dss_fck_multiplier	=	1,
+	.parent_clk_name	=	"dpll_per_x2_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_omap4,
+	.ports			=	omap2plus_ports,
+	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+};
+
+static const struct dss_features omap54xx_dss_feats = {
+	.fck_div_max		=	64,
+	.dss_fck_multiplier	=	1,
+	.parent_clk_name	=	"dpll_per_x2_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_omap5,
+	.ports			=	omap2plus_ports,
+	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+};
+
+static const struct dss_features am43xx_dss_feats = {
+	.fck_div_max		=	0,
+	.dss_fck_multiplier	=	0,
+	.parent_clk_name	=	NULL,
+	.dpi_select_source	=	&dss_dpi_select_source_omap2_omap3,
+	.ports			=	omap2plus_ports,
+	.num_ports		=	ARRAY_SIZE(omap2plus_ports),
+};
+
+static const struct dss_features dra7xx_dss_feats = {
+	.fck_div_max		=	64,
+	.dss_fck_multiplier	=	1,
+	.parent_clk_name	=	"dpll_per_x2_ck",
+	.dpi_select_source	=	&dss_dpi_select_source_dra7xx,
+	.ports			=	dra7xx_ports,
+	.num_ports		=	ARRAY_SIZE(dra7xx_ports),
+};
+
+static int dss_init_features(struct platform_device *pdev)
+{
+	const struct dss_features *src;
+	struct dss_features *dst;
+
+	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
+	if (!dst) {
+		dev_err(&pdev->dev, "Failed to allocate local DSS Features\n");
+		return -ENOMEM;
+	}
+
+	switch (omapdss_get_version()) {
+	case OMAPDSS_VER_OMAP24xx:
+		src = &omap24xx_dss_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP34xx_ES1:
+	case OMAPDSS_VER_OMAP34xx_ES3:
+	case OMAPDSS_VER_AM35xx:
+		src = &omap34xx_dss_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP3630:
+		src = &omap3630_dss_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP4430_ES1:
+	case OMAPDSS_VER_OMAP4430_ES2:
+	case OMAPDSS_VER_OMAP4:
+		src = &omap44xx_dss_feats;
+		break;
+
+	case OMAPDSS_VER_OMAP5:
+		src = &omap54xx_dss_feats;
+		break;
+
+	case OMAPDSS_VER_AM43xx:
+		src = &am43xx_dss_feats;
+		break;
+
+	case OMAPDSS_VER_DRA7xx:
+		src = &dra7xx_dss_feats;
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	memcpy(dst, src, sizeof(*dst));
+	dss.feat = dst;
+
+	return 0;
+}
+
+static int dss_init_ports(struct platform_device *pdev)
+{
+	struct device_node *parent = pdev->dev.of_node;
+	struct device_node *port;
+	int r;
+
+	if (parent == NULL)
+		return 0;
+
+	port = omapdss_of_get_next_port(parent, NULL);
+	if (!port)
+		return 0;
+
+	if (dss.feat->num_ports == 0)
+		return 0;
+
+	do {
+		enum omap_display_type port_type;
+		u32 reg;
+
+		r = of_property_read_u32(port, "reg", &reg);
+		if (r)
+			reg = 0;
+
+		if (reg >= dss.feat->num_ports)
+			continue;
+
+		port_type = dss.feat->ports[reg];
+
+		switch (port_type) {
+		case OMAP_DISPLAY_TYPE_DPI:
+			dpi_init_port(pdev, port);
+			break;
+		case OMAP_DISPLAY_TYPE_SDI:
+			sdi_init_port(pdev, port);
+			break;
+		default:
+			break;
+		}
+	} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);
+
+	return 0;
+}
+
+static void dss_uninit_ports(struct platform_device *pdev)
+{
+	struct device_node *parent = pdev->dev.of_node;
+	struct device_node *port;
+
+	if (parent == NULL)
+		return;
+
+	port = omapdss_of_get_next_port(parent, NULL);
+	if (!port)
+		return;
+
+	if (dss.feat->num_ports == 0)
+		return;
+
+	do {
+		enum omap_display_type port_type;
+		u32 reg;
+		int r;
+
+		r = of_property_read_u32(port, "reg", &reg);
+		if (r)
+			reg = 0;
+
+		if (reg >= dss.feat->num_ports)
+			continue;
+
+		port_type = dss.feat->ports[reg];
+
+		switch (port_type) {
+		case OMAP_DISPLAY_TYPE_DPI:
+			dpi_uninit_port(port);
+			break;
+		case OMAP_DISPLAY_TYPE_SDI:
+			sdi_uninit_port(port);
+			break;
+		default:
+			break;
+		}
+	} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);
+}
+
+static int dss_video_pll_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct regulator *pll_regulator;
+	int r;
+
+	if (!np)
+		return 0;
+
+	if (of_property_read_bool(np, "syscon-pll-ctrl")) {
+		dss.syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,
+			"syscon-pll-ctrl");
+		if (IS_ERR(dss.syscon_pll_ctrl)) {
+			dev_err(&pdev->dev,
+				"failed to get syscon-pll-ctrl regmap\n");
+			return PTR_ERR(dss.syscon_pll_ctrl);
+		}
+
+		if (of_property_read_u32_index(np, "syscon-pll-ctrl", 1,
+				&dss.syscon_pll_ctrl_offset)) {
+			dev_err(&pdev->dev,
+				"failed to get syscon-pll-ctrl offset\n");
+			return -EINVAL;
+		}
+	}
+
+	pll_regulator = devm_regulator_get(&pdev->dev, "vdda_video");
+	if (IS_ERR(pll_regulator)) {
+		r = PTR_ERR(pll_regulator);
+
+		switch (r) {
+		case -ENOENT:
+			pll_regulator = NULL;
+			break;
+
+		case -EPROBE_DEFER:
+			return -EPROBE_DEFER;
+
+		default:
+			DSSERR("can't get DPLL VDDA regulator\n");
+			return r;
+		}
+	}
+
+	if (of_property_match_string(np, "reg-names", "pll1") >= 0) {
+		dss.video1_pll = dss_video_pll_init(pdev, 0, pll_regulator);
+		if (IS_ERR(dss.video1_pll))
+			return PTR_ERR(dss.video1_pll);
+	}
+
+	if (of_property_match_string(np, "reg-names", "pll2") >= 0) {
+		dss.video2_pll = dss_video_pll_init(pdev, 1, pll_regulator);
+		if (IS_ERR(dss.video2_pll)) {
+			dss_video_pll_uninit(dss.video1_pll);
+			return PTR_ERR(dss.video2_pll);
+		}
+	}
+
+	return 0;
+}
+
+/* DSS HW IP initialisation */
+static int dss_bind(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *dss_mem;
+	u32 rev;
+	int r;
+
+	dss.pdev = pdev;
+
+	r = dss_init_features(dss.pdev);
+	if (r)
+		return r;
+
+	dss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);
+	if (!dss_mem) {
+		DSSERR("can't get IORESOURCE_MEM DSS\n");
+		return -EINVAL;
+	}
+
+	dss.base = devm_ioremap(&pdev->dev, dss_mem->start,
+				resource_size(dss_mem));
+	if (!dss.base) {
+		DSSERR("can't ioremap DSS\n");
+		return -ENOMEM;
+	}
+
+	r = dss_get_clocks();
+	if (r)
+		return r;
+
+	r = dss_setup_default_clock();
+	if (r)
+		goto err_setup_clocks;
+
+	r = dss_video_pll_probe(pdev);
+	if (r)
+		goto err_pll_init;
+
+	r = dss_init_ports(pdev);
+	if (r)
+		goto err_init_ports;
+
+	pm_runtime_enable(&pdev->dev);
+
+	r = dss_runtime_get();
+	if (r)
+		goto err_runtime_get;
+
+	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+
+	/* Select DPLL */
+	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
+
+	dss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);
+
+#ifdef CONFIG_OMAP2_DSS_VENC
+	REG_FLD_MOD(DSS_CONTROL, 1, 4, 4);	/* venc dac demen */
+	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
+	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
+#endif
+	dss.dsi_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;
+	dss.dsi_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;
+	dss.dispc_clk_source = OMAP_DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;
+	dss.lcd_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;
+
+	rev = dss_read_reg(DSS_REVISION);
+	printk(KERN_INFO "OMAP DSS rev %d.%d\n",
+			FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
+
+	dss_runtime_put();
+
+	r = component_bind_all(&pdev->dev, NULL);
+	if (r)
+		goto err_component;
+
+	dss_debugfs_create_file("dss", dss_dump_regs);
+
+	pm_set_vt_switch(0);
+
+	dss_initialized = true;
+
+	return 0;
+
+err_component:
+err_runtime_get:
+	pm_runtime_disable(&pdev->dev);
+	dss_uninit_ports(pdev);
+err_init_ports:
+	if (dss.video1_pll)
+		dss_video_pll_uninit(dss.video1_pll);
+
+	if (dss.video2_pll)
+		dss_video_pll_uninit(dss.video2_pll);
+err_pll_init:
+err_setup_clocks:
+	dss_put_clocks();
+	return r;
+}
+
+static void dss_unbind(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	dss_initialized = false;
+
+	component_unbind_all(&pdev->dev, NULL);
+
+	if (dss.video1_pll)
+		dss_video_pll_uninit(dss.video1_pll);
+
+	if (dss.video2_pll)
+		dss_video_pll_uninit(dss.video2_pll);
+
+	dss_uninit_ports(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	dss_put_clocks();
+}
+
+static const struct component_master_ops dss_component_ops = {
+	.bind = dss_bind,
+	.unbind = dss_unbind,
+};
+
+static int dss_component_compare(struct device *dev, void *data)
+{
+	struct device *child = data;
+	return dev == child;
+}
+
+static int dss_add_child_component(struct device *dev, void *data)
+{
+	struct component_match **match = data;
+
+	/*
+	 * HACK
+	 * We don't have a working driver for rfbi, so skip it here always.
+	 * Otherwise dss will never get probed successfully, as it will wait
+	 * for rfbi to get probed.
+	 */
+	if (strstr(dev_name(dev), "rfbi"))
+		return 0;
+
+	component_match_add(dev->parent, match, dss_component_compare, dev);
+
+	return 0;
+}
+
+static int dss_probe(struct platform_device *pdev)
+{
+	struct component_match *match = NULL;
+	int r;
+
+	/* add all the child devices as components */
+	device_for_each_child(&pdev->dev, &match, dss_add_child_component);
+
+	r = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+static int dss_remove(struct platform_device *pdev)
+{
+	component_master_del(&pdev->dev, &dss_component_ops);
+	return 0;
+}
+
+static int dss_runtime_suspend(struct device *dev)
+{
+	dss_save_context();
+	dss_set_min_bus_tput(dev, 0);
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	return 0;
+}
+
+static int dss_runtime_resume(struct device *dev)
+{
+	int r;
+
+	pinctrl_pm_select_default_state(dev);
+
+	/*
+	 * Set an arbitrarily high tput request to ensure OPP100.
+	 * What we should really do is to make a request to stay in OPP100,
+	 * without any tput requirements, but that is not currently possible
+	 * via the PM layer.
+	 */
+
+	r = dss_set_min_bus_tput(dev, 1000000000);
+	if (r)
+		return r;
+
+	dss_restore_context();
+	return 0;
+}
+
+static const struct dev_pm_ops dss_pm_ops = {
+	.runtime_suspend = dss_runtime_suspend,
+	.runtime_resume = dss_runtime_resume,
+};
+
+static const struct of_device_id dss_of_match[] = {
+	{ .compatible = "ti,omap2-dss", },
+	{ .compatible = "ti,omap3-dss", },
+	{ .compatible = "ti,omap4-dss", },
+	{ .compatible = "ti,omap5-dss", },
+	{ .compatible = "ti,dra7-dss", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, dss_of_match);
+
+static struct platform_driver omap_dsshw_driver = {
+	.probe		= dss_probe,
+	.remove		= dss_remove,
+	.driver         = {
+		.name   = "omapdss_dss",
+		.pm	= &dss_pm_ops,
+		.of_match_table = dss_of_match,
+		.suppress_bind_attrs = true,
+	},
+};
+
+int __init dss_init_platform_driver(void)
+{
+	return platform_driver_register(&omap_dsshw_driver);
+}
+
+void dss_uninit_platform_driver(void)
+{
+	platform_driver_unregister(&omap_dsshw_driver);
+}
