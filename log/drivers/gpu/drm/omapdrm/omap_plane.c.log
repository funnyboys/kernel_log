commit 3037e0c5e8af377c33f264f2e146d8b3b82bcb1b
Author: Jean-Jacques Hiblot <jjhiblot@ti.com>
Date:   Thu Jul 11 15:52:19 2019 +0200

    drm/omap: Add 'alpha' and 'pixel blend mode' plane properties
    
    Add the following properties for planes:
    * alpha
    * pixel blend mode. Only "Pre-multiplied" and "Coverage" are supported
    
    Signed-off-by: Jean-Jacques Hiblot <jjhiblot@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190711135219.23402-1-jjhiblot@ti.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 84e1be981cfe..73ec99819a3d 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -53,8 +53,12 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	memset(&info, 0, sizeof(info));
 	info.rotation_type = OMAP_DSS_ROT_NONE;
 	info.rotation = DRM_MODE_ROTATE_0;
-	info.global_alpha = 0xff;
+	info.global_alpha = state->alpha >> 8;
 	info.zorder = state->normalized_zpos;
+	if (state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI)
+		info.pre_mult_alpha = 1;
+	else
+		info.pre_mult_alpha = 0;
 
 	/* update scanout: */
 	omap_framebuffer_update_scanout(state->fb, state, &info);
@@ -285,6 +289,9 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane_install_properties(plane, &plane->base);
 	drm_plane_create_zpos_property(plane, 0, 0, num_planes - 1);
+	drm_plane_create_alpha_property(plane);
+	drm_plane_create_blend_mode_property(plane, BIT(DRM_MODE_BLEND_PREMULTI) |
+					     BIT(DRM_MODE_BLEND_COVERAGE));
 
 	return plane;
 

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 161233cbc9a0..84e1be981cfe 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob.clark@linaro.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <drm/drm_atomic.h>

commit 23936ba940fbccf08f9f61d7c6d39ba0feb383bc
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Mar 21 12:20:29 2018 +0200

    drm/omap: Use normalized zpos for plane placement
    
    Planes with identical zpos value will result undefined behavior:
    disappearing planes, screen flickering and it is not supported by the
    hardware.
    
    Use normalized zpos to make sure that we don't encounter invalid
    configuration.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    CC: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180321102029.15248-7-peter.ujfalusi@ti.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 2899435cad6e..161233cbc9a0 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -65,7 +65,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	info.rotation_type = OMAP_DSS_ROT_NONE;
 	info.rotation = DRM_MODE_ROTATE_0;
 	info.global_alpha = 0xff;
-	info.zorder = state->zpos;
+	info.zorder = state->normalized_zpos;
 
 	/* update scanout: */
 	omap_framebuffer_update_scanout(state->fb, state, &info);

commit 50638ae569dc097a95218eb70140e68aa213b07c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Feb 13 14:00:42 2018 +0200

    drm: omapdrm: dispc: Pass DISPC pointer to dispc_ops operations
    
    This removes the need to access the global DISPC private data in those
    functions (both for the current accesses and the future ones that will
    be introduced when allocating the DISPC private data dynamically).
    
    In order to allow the omapdrm side to call the dispc_ops with a DISPC
    pointer, we also introduce a new function dss_get_dispc() to retrieve
    the DISPC corresponding to the DSS.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 0665ed9fe395..2899435cad6e 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -77,17 +77,17 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 			&info.paddr, &info.p_uv_addr);
 
 	/* and finally, update omapdss: */
-	ret = priv->dispc_ops->ovl_setup(omap_plane->id, &info,
+	ret = priv->dispc_ops->ovl_setup(priv->dispc, omap_plane->id, &info,
 			      omap_crtc_timings(state->crtc), false,
 			      omap_crtc_channel(state->crtc));
 	if (ret) {
 		dev_err(plane->dev->dev, "Failed to setup plane %s\n",
 			omap_plane->name);
-		priv->dispc_ops->ovl_enable(omap_plane->id, false);
+		priv->dispc_ops->ovl_enable(priv->dispc, omap_plane->id, false);
 		return;
 	}
 
-	priv->dispc_ops->ovl_enable(omap_plane->id, true);
+	priv->dispc_ops->ovl_enable(priv->dispc, omap_plane->id, true);
 }
 
 static void omap_plane_atomic_disable(struct drm_plane *plane,
@@ -100,7 +100,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	plane->state->zpos = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
-	priv->dispc_ops->ovl_enable(omap_plane->id, false);
+	priv->dispc_ops->ovl_enable(priv->dispc, omap_plane->id, false);
 }
 
 static int omap_plane_atomic_check(struct drm_plane *plane,
@@ -259,7 +259,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 		u32 possible_crtcs)
 {
 	struct omap_drm_private *priv = dev->dev_private;
-	unsigned int num_planes = priv->dispc_ops->get_num_ovls();
+	unsigned int num_planes = priv->dispc_ops->get_num_ovls(priv->dispc);
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
 	enum omap_plane_id id;
@@ -278,7 +278,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	if (!omap_plane)
 		return ERR_PTR(-ENOMEM);
 
-	formats = priv->dispc_ops->ovl_get_color_modes(id);
+	formats = priv->dispc_ops->ovl_get_color_modes(priv->dispc, id);
 	for (nformats = 0; formats[nformats]; ++nformats)
 		;
 	omap_plane->id = id;

commit dfe9cfccb264889b025e443ca20e2fbb401295c2
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 11 15:07:33 2018 +0200

    drm: omapdrm: Use kernel integer types
    
    The standard kernel integer types are [us]{8,16,32}. Use them instead of
    the u?int{8,16,32}_t types.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7d789d1551a1..0665ed9fe395 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -201,7 +201,7 @@ static void omap_plane_reset(struct drm_plane *plane)
 static int omap_plane_atomic_set_property(struct drm_plane *plane,
 					  struct drm_plane_state *state,
 					  struct drm_property *property,
-					  uint64_t val)
+					  u64 val)
 {
 	struct omap_drm_private *priv = plane->dev->dev_private;
 
@@ -216,7 +216,7 @@ static int omap_plane_atomic_set_property(struct drm_plane *plane,
 static int omap_plane_atomic_get_property(struct drm_plane *plane,
 					  const struct drm_plane_state *state,
 					  struct drm_property *property,
-					  uint64_t *val)
+					  u64 *val)
 {
 	struct omap_drm_private *priv = plane->dev->dev_private;
 

commit bb5cdf8d1c76ea821af0ffa486337386a0ab66e7
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 5 14:29:31 2017 -0600

    drm: omapdrm: Remove filename from header and fix copyright tag
    
    Having the filename in the header serves little purpose and is
    often wrong after renames as it is here in several places, just
    drop it from all omapdrm files.
    
    While we are here unify the copyright tags to the TI recommended style.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 15e5d5d325c6..7d789d1551a1 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -1,7 +1,5 @@
 /*
- * drivers/gpu/drm/omapdrm/omap_plane.c
- *
- * Copyright (C) 2011 Texas Instruments
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  * Author: Rob Clark <rob.clark@linaro.org>
  *
  * This program is free software; you can redistribute it and/or modify it

commit e90271bc07edde70945662aaaad8860d59712234
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:19 2017 +0200

    drm: Nuke drm_atomic_helper_plane_set_property
    
    It's dead code, the core handles all this directly now. This also
    allows us to unexport drm_atomic_plane_set_property.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Yannick Fertre <yannick.fertre@st.com>
    Cc: Philippe Cornu <philippe.cornu@st.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: "Ville Syrjälä" <ville.syrjala@linux.intel.com>
    Cc: Rongrong Zou <zourongrong@gmail.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Eric Engestrom <eric@engestrom.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-6-daniel.vetter@ffwll.ch
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Acked-by: Philippe Cornu <philippe.cornu@st.com>
    Tested-by: Philippe Cornu <philippe.cornu@st.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index b92a8f1d0155..15e5d5d325c6 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -235,7 +235,6 @@ static const struct drm_plane_funcs omap_plane_funcs = {
 	.disable_plane = drm_atomic_helper_disable_plane,
 	.reset = omap_plane_reset,
 	.destroy = omap_plane_destroy,
-	.set_property = drm_atomic_helper_plane_set_property,
 	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
 	.atomic_set_property = omap_plane_atomic_set_property,

commit e6fc3b68558e4c6d8d160b5daf2511b99afa8814
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Sun Jul 23 20:46:38 2017 -0700

    drm: Plumb modifiers through plane init
    
    This is the plumbing for supporting fb modifiers on planes. Modifiers
    have already been introduced to some extent, but this series will extend
    this to allow querying modifiers per plane. Based on this, the client to
    enable optimal modifications for framebuffers.
    
    This patch simply allows the DRM drivers to initialize their list of
    supported modifiers upon initializing the plane.
    
    v2: A minor addition from Daniel
    
    v3:
    * Updated commit message
    * s/INVALID/DRM_FORMAT_MOD_INVALID (Liviu)
    * Remove some excess newlines (Liviu)
    * Update comment for > 64 modifiers (Liviu)
    
    v4: Minor comment adjustments (Liviu)
    
    v5: Some new platforms added due to rebase
    
    v6: Add some missed plane inits (or maybe they're new - who knows at
    this point) (Daniel)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Daniel Stone <daniels@collabora.com> (v2)
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Stone <daniels@collabora.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 2160f64548e0..b92a8f1d0155 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -291,7 +291,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	ret = drm_universal_plane_init(dev, plane, possible_crtcs,
 				       &omap_plane_funcs, formats,
-				       nformats, type, NULL);
+				       nformats, NULL, type, NULL);
 	if (ret < 0)
 		goto error;
 

commit 4eebb80e2465be3f5ec471547c455494c050ebd1
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 12:05:24 2017 +0300

    drm/omap: DRM_MODE_REFLECT_* instead of mirror boolean
    
    Change dispc driver to use the DRM_MODE_REFLECT flags instead of a mirror
    boolean.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 688b358a13e5..2160f64548e0 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -67,7 +67,6 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	info.rotation_type = OMAP_DSS_ROT_NONE;
 	info.rotation = DRM_MODE_ROTATE_0;
 	info.global_alpha = 0xff;
-	info.mirror = 0;
 	info.zorder = state->zpos;
 
 	/* update scanout: */

commit 0bd97c42d975a1e0849105bb8f23a68490683aab
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue May 16 11:05:09 2017 +0300

    drm/omap: use DRM_MODE_ROTATE_* instead of OMAP_DSS_ROT_*
    
    At the moment the dispc driver uses a custom enum for rotation. Change
    it to use the DRM's DRM_MODE_ROTATE_*.
    
    Note that mirroring is at the moment handled as a separate boolean in
    the dispc driver, so we only use the DRM_MODE_ROTATE_* values.
    
    Note, DSS HW uses clockwise rotation, DRM counter-clockwise.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 08a446463afa..688b358a13e5 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -65,7 +65,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 
 	memset(&info, 0, sizeof(info));
 	info.rotation_type = OMAP_DSS_ROT_NONE;
-	info.rotation = OMAP_DSS_ROT_0;
+	info.rotation = DRM_MODE_ROTATE_0;
 	info.global_alpha = 0xff;
 	info.mirror = 0;
 	info.zorder = state->zpos;

commit 218ed5358a4045382674f8feeee0efb526f9431b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon May 15 13:40:08 2017 +0300

    drm/omap: remove omap_drm_win
    
    struct omap_drm_window is only used to pass plane setup data to
    omap_framebuffer_update_scanout(). This can as well be accomplished by
    just passing the DRM state.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 96c15e6d7397..08a446463afa 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -59,7 +59,6 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;
 	struct omap_overlay_info info;
-	struct omap_drm_window win;
 	int ret;
 
 	DBG("%s, crtc=%p fb=%p", omap_plane->name, state->crtc, state->fb);
@@ -71,30 +70,8 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	info.mirror = 0;
 	info.zorder = state->zpos;
 
-	memset(&win, 0, sizeof(win));
-	win.rotation = state->rotation;
-	win.crtc_x = state->crtc_x;
-	win.crtc_y = state->crtc_y;
-	win.crtc_w = state->crtc_w;
-	win.crtc_h = state->crtc_h;
-
-	/*
-	 * src values are in Q16 fixed point, convert to integer.
-	 * omap_framebuffer_update_scanout() takes adjusted src.
-	 */
-	win.src_x = state->src_x >> 16;
-	win.src_y = state->src_y >> 16;
-
-	if (drm_rotation_90_or_270(state->rotation)) {
-		win.src_w = state->src_h >> 16;
-		win.src_h = state->src_w >> 16;
-	} else {
-		win.src_w = state->src_w >> 16;
-		win.src_h = state->src_h >> 16;
-	}
-
 	/* update scanout: */
-	omap_framebuffer_update_scanout(state->fb, &win, &info);
+	omap_framebuffer_update_scanout(state->fb, state, &info);
 
 	DBG("%dx%d -> %dx%d (%d)", info.width, info.height,
 			info.out_width, info.out_height,

commit eecad4371d986f38b66202817e2b461ac3c64139
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 4 11:27:49 2017 +0300

    drm/omap: remove omap_framebuffer_get_formats()
    
    We now get a fourcc array from dispc when asking for a plane's supported
    pixel formats, so we can drop omap_framebuffer_get_formats() which was
    used to convert between DSS and DRM pixel formats.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 40747a625374..96c15e6d7397 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -34,9 +34,6 @@ struct omap_plane {
 	struct drm_plane base;
 	enum omap_plane_id id;
 	const char *name;
-
-	uint32_t nformats;
-	uint32_t formats[32];
 };
 
 static int omap_plane_prepare_fb(struct drm_plane *plane,
@@ -294,6 +291,8 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	struct omap_plane *omap_plane;
 	enum omap_plane_id id;
 	int ret;
+	u32 nformats;
+	const u32 *formats;
 
 	if (WARN_ON(idx >= ARRAY_SIZE(plane_idx_to_id)))
 		return ERR_PTR(-EINVAL);
@@ -306,17 +305,17 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	if (!omap_plane)
 		return ERR_PTR(-ENOMEM);
 
-	omap_plane->nformats = omap_framebuffer_get_formats(
-			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
-			priv->dispc_ops->ovl_get_color_modes(id));
+	formats = priv->dispc_ops->ovl_get_color_modes(id);
+	for (nformats = 0; formats[nformats]; ++nformats)
+		;
 	omap_plane->id = id;
 	omap_plane->name = plane_id_to_name[id];
 
 	plane = &omap_plane->base;
 
 	ret = drm_universal_plane_init(dev, plane, possible_crtcs,
-				       &omap_plane_funcs, omap_plane->formats,
-				       omap_plane->nformats, type, NULL);
+				       &omap_plane_funcs, formats,
+				       nformats, type, NULL);
 	if (ret < 0)
 		goto error;
 

commit 517a8a9564c0dea98e6d4e2c7f0fe4cbb9b8c9ba
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed May 3 14:14:27 2017 +0300

    drm/omap: remove dma & vrfb rotation
    
    We have three rotation methods supported by the SoCs with DSS: DMA,
    VRFB and TILER.
    
    DMA rotation works in theory on all DSS platforms, but in practice it's
    unusable due to the huge amount of memory bandwidth it uses, and has
    never really been used.
    
    VRFB is available on OMAP3, but is not supported by omapdrm, even though
    we have some code for it in the dispc driver.
    
    TILER is supported on OMAP4/OMAP5/DRA7/AM5 platforms, but has some
    driver bugs.
    
    To clean up the driver to help fixing the TILER issues, this patch drops
    the DMA and VRFB rotation support, leaving only TILER rotation.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 8b343aa84098..40747a625374 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -68,7 +68,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	DBG("%s, crtc=%p fb=%p", omap_plane->name, state->crtc, state->fb);
 
 	memset(&info, 0, sizeof(info));
-	info.rotation_type = OMAP_DSS_ROT_DMA;
+	info.rotation_type = OMAP_DSS_ROT_NONE;
 	info.rotation = OMAP_DSS_ROT_0;
 	info.global_alpha = 0xff;
 	info.mirror = 0;

commit 49a3057a5a2fa06264b0756cf417f75b56b7063b
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Feb 17 12:30:07 2017 +0200

    drm/omap: remove ovl_set_channel_out
    
    At the moment we have ovl_set_channel_out() to configure the output
    channel of an overlay. It makes sense to have this configuration as part
    of the rest of overlay configuration, and in DSS6+ we need the output
    channel when doing the other overlay configuration.
    
    This patch adds a 'channel' parameter to ovl_setup(), so that all
    overlay configuration is done via the same function, and removes the
    ovl_set_channel_out().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index a55e7db7e445..8b343aa84098 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -105,12 +105,10 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	DBG("%d,%d %pad %pad", info.pos_x, info.pos_y,
 			&info.paddr, &info.p_uv_addr);
 
-	priv->dispc_ops->ovl_set_channel_out(omap_plane->id,
-				  omap_crtc_channel(state->crtc));
-
 	/* and finally, update omapdss: */
 	ret = priv->dispc_ops->ovl_setup(omap_plane->id, &info,
-			      omap_crtc_timings(state->crtc), false);
+			      omap_crtc_timings(state->crtc), false,
+			      omap_crtc_channel(state->crtc));
 	if (ret) {
 		dev_err(plane->dev->dev, "Failed to setup plane %s\n",
 			omap_plane->name);

commit dff6c24698a4d05d9a90de97612ec520c6fa8bd8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue May 9 01:27:14 2017 +0300

    drm: omapdrm: Add zpos property
    
    Create a standard zpos property for every plane as an alias to the
    omapdrm-specific zorder property. Unlike the zorder property that has to
    be instantiated for both planes and CRTCs due to backward compatibility,
    the zpos property is only instantiated for planes. When userspace will
    have switched to the zpos property the zorder property will be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 334ee431c981..a55e7db7e445 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -291,6 +291,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 		u32 possible_crtcs)
 {
 	struct omap_drm_private *priv = dev->dev_private;
+	unsigned int num_planes = priv->dispc_ops->get_num_ovls();
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
 	enum omap_plane_id id;
@@ -324,6 +325,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	drm_plane_helper_add(plane, &omap_plane_helper_funcs);
 
 	omap_plane_install_properties(plane, &plane->base);
+	drm_plane_create_zpos_property(plane, 0, 0, num_planes - 1);
 
 	return plane;
 

commit d980278bd8fc5b4054d4a7593620ad3ec6e1104a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue May 9 01:27:13 2017 +0300

    drm: omapdrm: Remove custom plane state
    
    The custom plane state only encapsulates the standard plane state with
    adding any custom field. Remove it and use the atomic plane helpers
    directly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 9c2477c7b65b..334ee431c981 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -39,16 +39,6 @@ struct omap_plane {
 	uint32_t formats[32];
 };
 
-struct omap_plane_state {
-	struct drm_plane_state base;
-};
-
-static inline struct omap_plane_state *
-to_omap_plane_state(struct drm_plane_state *state)
-{
-	return container_of(state, struct omap_plane_state, base);
-}
-
 static int omap_plane_prepare_fb(struct drm_plane *plane,
 				 struct drm_plane_state *new_state)
 {
@@ -223,56 +213,20 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	drm_object_attach_property(obj, priv->zorder_prop, 0);
 }
 
-static struct drm_plane_state *
-omap_plane_atomic_duplicate_state(struct drm_plane *plane)
-{
-	struct omap_plane_state *state;
-	struct omap_plane_state *copy;
-
-	if (WARN_ON(!plane->state))
-		return NULL;
-
-	state = to_omap_plane_state(plane->state);
-	copy = kmemdup(state, sizeof(*state), GFP_KERNEL);
-	if (copy == NULL)
-		return NULL;
-
-	__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);
-
-	return &copy->base;
-}
-
-static void omap_plane_atomic_destroy_state(struct drm_plane *plane,
-					    struct drm_plane_state *state)
-{
-	__drm_atomic_helper_plane_destroy_state(state);
-	kfree(to_omap_plane_state(state));
-}
-
 static void omap_plane_reset(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct omap_plane_state *omap_state;
 
-	if (plane->state) {
-		omap_plane_atomic_destroy_state(plane, plane->state);
-		plane->state = NULL;
-	}
-
-	omap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);
-	if (omap_state == NULL)
+	drm_atomic_helper_plane_reset(plane);
+	if (!plane->state)
 		return;
 
 	/*
 	 * Set the zpos default depending on whether we are a primary or overlay
 	 * plane.
 	 */
-	omap_state->base.zpos = plane->type == DRM_PLANE_TYPE_PRIMARY
-			      ? 0 : omap_plane->id;
-	omap_state->base.rotation = DRM_MODE_ROTATE_0;
-
-	plane->state = &omap_state->base;
-	plane->state->plane = plane;
+	plane->state->zpos = plane->type == DRM_PLANE_TYPE_PRIMARY
+			   ? 0 : omap_plane->id;
 }
 
 static int omap_plane_atomic_set_property(struct drm_plane *plane,
@@ -311,8 +265,8 @@ static const struct drm_plane_funcs omap_plane_funcs = {
 	.reset = omap_plane_reset,
 	.destroy = omap_plane_destroy,
 	.set_property = drm_atomic_helper_plane_set_property,
-	.atomic_duplicate_state = omap_plane_atomic_duplicate_state,
-	.atomic_destroy_state = omap_plane_atomic_destroy_state,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
 	.atomic_set_property = omap_plane_atomic_set_property,
 	.atomic_get_property = omap_plane_atomic_get_property,
 };

commit ba527c13644fdeacdb4756fc9dd9aa598a40bce3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue May 9 01:27:12 2017 +0300

    drm: omapdrm: Store the Z order in the plane state zpos field
    
    The DRM core implements a standard "zpos" property to control planes
    ordering. The omapdrm driver implements a similar property named
    "zorder". Although we can't switch to DRM core handling of the "zpos"
    property for backward compatibility reasons, we can store the zorder
    value in the drm_plane_state zpos field, saving us from adding a custom
    field to the plane state.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d3d6818c68f8..9c2477c7b65b 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -41,8 +41,6 @@ struct omap_plane {
 
 struct omap_plane_state {
 	struct drm_plane_state base;
-
-	unsigned int zorder;
 };
 
 static inline struct omap_plane_state *
@@ -73,7 +71,6 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	struct omap_drm_private *priv = plane->dev->dev_private;
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;
-	struct omap_plane_state *omap_state = to_omap_plane_state(state);
 	struct omap_overlay_info info;
 	struct omap_drm_window win;
 	int ret;
@@ -85,7 +82,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	info.rotation = OMAP_DSS_ROT_0;
 	info.global_alpha = 0xff;
 	info.mirror = 0;
-	info.zorder = omap_state->zorder;
+	info.zorder = state->zpos;
 
 	memset(&win, 0, sizeof(win));
 	win.rotation = state->rotation;
@@ -138,11 +135,10 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	struct omap_plane_state *omap_state = to_omap_plane_state(plane->state);
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
 	plane->state->rotation = DRM_MODE_ROTATE_0;
-	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
+	plane->state->zpos = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
 	priv->dispc_ops->ovl_enable(omap_plane->id, false);
@@ -268,11 +264,11 @@ static void omap_plane_reset(struct drm_plane *plane)
 		return;
 
 	/*
-	 * Set defaults depending on whether we are a primary or overlay
+	 * Set the zpos default depending on whether we are a primary or overlay
 	 * plane.
 	 */
-	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
-			   ? 0 : omap_plane->id;
+	omap_state->base.zpos = plane->type == DRM_PLANE_TYPE_PRIMARY
+			      ? 0 : omap_plane->id;
 	omap_state->base.rotation = DRM_MODE_ROTATE_0;
 
 	plane->state = &omap_state->base;
@@ -285,10 +281,9 @@ static int omap_plane_atomic_set_property(struct drm_plane *plane,
 					  uint64_t val)
 {
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	struct omap_plane_state *omap_state = to_omap_plane_state(state);
 
 	if (property == priv->zorder_prop)
-		omap_state->zorder = val;
+		state->zpos = val;
 	else
 		return -EINVAL;
 
@@ -301,11 +296,9 @@ static int omap_plane_atomic_get_property(struct drm_plane *plane,
 					  uint64_t *val)
 {
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	const struct omap_plane_state *omap_state =
-		container_of(state, const struct omap_plane_state, base);
 
 	if (property == priv->zorder_prop)
-		*val = omap_state->zorder;
+		*val = state->zpos;
 	else
 		return -EINVAL;
 

commit c2c446ad29437bb92b157423c632286608ebd3ec
Author: Robert Foss <robert.foss@collabora.com>
Date:   Fri May 19 16:50:17 2017 -0400

    drm: Add DRM_MODE_ROTATE_ and DRM_MODE_REFLECT_ to UAPI
    
    Add DRM_MODE_ROTATE_ and DRM_MODE_REFLECT_ defines to the UAPI
    as a convenience.
    
    Ideally the DRM_ROTATE_ and DRM_REFLECT_ property ids are looked up
    through the atomic API, but realizing that userspace is likely to take
    shortcuts and assume that the enum values are what is sent over the
    wire.
    
    As a result these defines are provided purely as a convenience to
    userspace applications.
    
    Changes since v3:
     - Switched away from past tense in comments
     - Add define name change to previously mis-spelled DRM_REFLECT_X comment
     - Improved the comment for the DRM_MODE_REFLECT_<axis> comment
    
    Changes since v2:
     - Changed define prefix from DRM_MODE_PROP_ to DRM_MODE_
     - Fix compilation errors
     - Changed comment formatting
     - Deduplicated comment lines
     - Clarified DRM_MODE_PROP_REFLECT_ comment
    
    Changes since v1:
     - Moved defines from drm.h to drm_mode.h
     - Changed define prefix from DRM_ to DRM_MODE_PROP_
     - Updated uses of the defines to the new prefix
     - Removed include from drm_rect.c
     - Stopped using the BIT() macro
    
    Signed-off-by: Robert Foss <robert.foss@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170519205017.23307-2-robert.foss@collabora.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 9168154d749e..d3d6818c68f8 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -141,7 +141,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	struct omap_plane_state *omap_state = to_omap_plane_state(plane->state);
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
-	plane->state->rotation = DRM_ROTATE_0;
+	plane->state->rotation = DRM_MODE_ROTATE_0;
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
@@ -177,7 +177,7 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 	if (state->crtc_y + state->crtc_h > crtc_state->adjusted_mode.vdisplay)
 		return -EINVAL;
 
-	if (state->rotation != DRM_ROTATE_0 &&
+	if (state->rotation != DRM_MODE_ROTATE_0 &&
 	    !omap_framebuffer_supports_rotation(state->fb))
 		return -EINVAL;
 
@@ -213,15 +213,15 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	if (priv->has_dmm) {
 		if (!plane->rotation_property)
 			drm_plane_create_rotation_property(plane,
-							   DRM_ROTATE_0,
-							   DRM_ROTATE_0 | DRM_ROTATE_90 |
-							   DRM_ROTATE_180 | DRM_ROTATE_270 |
-							   DRM_REFLECT_X | DRM_REFLECT_Y);
+							   DRM_MODE_ROTATE_0,
+							   DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 |
+							   DRM_MODE_ROTATE_180 | DRM_MODE_ROTATE_270 |
+							   DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y);
 
 		/* Attach the rotation property also to the crtc object */
 		if (plane->rotation_property && obj != &plane->base)
 			drm_object_attach_property(obj, plane->rotation_property,
-						   DRM_ROTATE_0);
+						   DRM_MODE_ROTATE_0);
 	}
 
 	drm_object_attach_property(obj, priv->zorder_prop, 0);
@@ -273,7 +273,7 @@ static void omap_plane_reset(struct drm_plane *plane)
 	 */
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
-	omap_state->base.rotation = DRM_ROTATE_0;
+	omap_state->base.rotation = DRM_MODE_ROTATE_0;
 
 	plane->state = &omap_state->base;
 	plane->state->plane = plane;

commit e8e13b1521678af0df7b07f30745d77e8de1820a
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Mar 24 16:47:55 2017 +0200

    drm/omap: Major omap_modeset_init() cleanup
    
    Cleanup overly complex omap_modeset_init(). The function is trying to
    support many unusual configuration, that have never been tested and
    are not supported by other parts of the dirver.
    
    After cleanup the init function creates exactly one connector,
    encoder, crtc, and primary plane per each connected dss-device. Each
    connector->encoder->crtc chain is expected to be separate and each
    crtc is connect to a single dss-channel. If the configuration does not
    match the expectations or exceeds the available resources, the
    configuration is rejected.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7abb49b7d606..9168154d749e 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -324,24 +324,37 @@ static const struct drm_plane_funcs omap_plane_funcs = {
 	.atomic_get_property = omap_plane_atomic_get_property,
 };
 
-static const char *plane_names[] = {
+static const char *plane_id_to_name[] = {
 	[OMAP_DSS_GFX] = "gfx",
 	[OMAP_DSS_VIDEO1] = "vid1",
 	[OMAP_DSS_VIDEO2] = "vid2",
 	[OMAP_DSS_VIDEO3] = "vid3",
 };
 
+static const enum omap_plane_id plane_idx_to_id[] = {
+	OMAP_DSS_GFX,
+	OMAP_DSS_VIDEO1,
+	OMAP_DSS_VIDEO2,
+	OMAP_DSS_VIDEO3,
+};
+
 /* initialize plane */
 struct drm_plane *omap_plane_init(struct drm_device *dev,
-		int id, enum drm_plane_type type,
+		int idx, enum drm_plane_type type,
 		u32 possible_crtcs)
 {
 	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
+	enum omap_plane_id id;
 	int ret;
 
-	DBG("%s: type=%d", plane_names[id], type);
+	if (WARN_ON(idx >= ARRAY_SIZE(plane_idx_to_id)))
+		return ERR_PTR(-EINVAL);
+
+	id = plane_idx_to_id[idx];
+
+	DBG("%s: type=%d", plane_id_to_name[id], type);
 
 	omap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);
 	if (!omap_plane)
@@ -351,7 +364,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
 			priv->dispc_ops->ovl_get_color_modes(id));
 	omap_plane->id = id;
-	omap_plane->name = plane_names[id];
+	omap_plane->name = plane_id_to_name[id];
 
 	plane = &omap_plane->base;
 
@@ -368,6 +381,9 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	return plane;
 
 error:
+	dev_err(dev->dev, "%s(): could not create plane: %s\n",
+		__func__, plane_id_to_name[id]);
+
 	kfree(omap_plane);
 	return NULL;
 }

commit 694c99cf6f5a13774bbdbf5becdbf59451b955f0
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Mar 24 16:47:54 2017 +0200

    drm/omap: Remove the obsolete #define omap_plane _omap_plane hack
    
    Remove the obsolete "#define omap_plane _omap_plane" hack and other
    related hacks to get around the enum omap_plane colliding with struct
    omap_plane.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 78a92422ede1..7abb49b7d606 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -24,12 +24,6 @@
 #include "omap_dmm_tiler.h"
 #include "omap_drv.h"
 
-/* some hackery because omapdss has an 'enum omap_plane' (which would be
- * better named omap_plane_id).. and compiler seems unhappy about having
- * both a 'struct omap_plane' and 'enum omap_plane'
- */
-#define omap_plane _omap_plane
-
 /*
  * plane funcs
  */
@@ -38,7 +32,7 @@
 
 struct omap_plane {
 	struct drm_plane base;
-	int id;  /* TODO rename omap_plane -> omap_plane_id in omapdss so I can use the enum */
+	enum omap_plane_id id;
 	const char *name;
 
 	uint32_t nformats;

commit be2d68c69e5c5a54cd2179aa6971d42cc3a49375
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Mon Aug 29 13:15:02 2016 +0300

    drm/omap: fix replication logic
    
    DSS uses "replication logic" to convert color components from smaller
    bit widths to bigger bit widths. Without replication logic, the color
    component would be shifted and the least significant bits would be left
    at 0, whereas with replication logic, the least significat bits will be
    filled with the most significant bit.
    
    For some reason omapdrm leaves replication logic always to off, which,
    in the most common case, means that showing 16-bit RGB colors on 24-bit
    display gives a bit darker colors than expected.
    
    The reset value of the replication logic bit is enabled, and it should
    always be set, as there's no practical reason to disable it. This patch
    removes the option to disable it from omapdrm, and always sets it to
    enabled in dispc.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index bdd74692e0cd..78a92422ede1 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -128,7 +128,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 				  omap_crtc_channel(state->crtc));
 
 	/* and finally, update omapdss: */
-	ret = priv->dispc_ops->ovl_setup(omap_plane->id, &info, false,
+	ret = priv->dispc_ops->ovl_setup(omap_plane->id, &info,
 			      omap_crtc_timings(state->crtc), false);
 	if (ret) {
 		dev_err(plane->dev->dev, "Failed to setup plane %s\n",

commit 9f759225e42b00ad0c5a55907f443b388e8960f4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 18:39:52 2015 +0200

    drm/omap: use dispc_ops
    
    Change omapdrm to get dispc_ops and use that to call the dispc functions
    instead or direct function calls.
    
    The change is very straightforward.
    
    The only problem was in omap_crtc_init() which calls pipe2vbl(crtc), and
    at that point of time the crtc->dev link, which is used to get the
    dispc_ops, has not been set up yet. This patch makes omap_crtc_init()
    skip the call to pipe2vbl() and instead calls
    dispc_ops->mgr_get_vsync_irq() directly.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 1067695af401..bdd74692e0cd 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -76,6 +76,7 @@ static void omap_plane_cleanup_fb(struct drm_plane *plane,
 static void omap_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_plane_state *old_state)
 {
+	struct omap_drm_private *priv = plane->dev->dev_private;
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;
 	struct omap_plane_state *omap_state = to_omap_plane_state(state);
@@ -123,25 +124,26 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	DBG("%d,%d %pad %pad", info.pos_x, info.pos_y,
 			&info.paddr, &info.p_uv_addr);
 
-	dispc_ovl_set_channel_out(omap_plane->id,
+	priv->dispc_ops->ovl_set_channel_out(omap_plane->id,
 				  omap_crtc_channel(state->crtc));
 
 	/* and finally, update omapdss: */
-	ret = dispc_ovl_setup(omap_plane->id, &info, false,
+	ret = priv->dispc_ops->ovl_setup(omap_plane->id, &info, false,
 			      omap_crtc_timings(state->crtc), false);
 	if (ret) {
 		dev_err(plane->dev->dev, "Failed to setup plane %s\n",
 			omap_plane->name);
-		dispc_ovl_enable(omap_plane->id, false);
+		priv->dispc_ops->ovl_enable(omap_plane->id, false);
 		return;
 	}
 
-	dispc_ovl_enable(omap_plane->id, true);
+	priv->dispc_ops->ovl_enable(omap_plane->id, true);
 }
 
 static void omap_plane_atomic_disable(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
+	struct omap_drm_private *priv = plane->dev->dev_private;
 	struct omap_plane_state *omap_state = to_omap_plane_state(plane->state);
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
@@ -149,7 +151,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
-	dispc_ovl_enable(omap_plane->id, false);
+	priv->dispc_ops->ovl_enable(omap_plane->id, false);
 }
 
 static int omap_plane_atomic_check(struct drm_plane *plane,
@@ -340,6 +342,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 		int id, enum drm_plane_type type,
 		u32 possible_crtcs)
 {
+	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
 	int ret;
@@ -352,7 +355,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane->nformats = omap_framebuffer_get_formats(
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
-			dispc_ovl_get_color_modes(id));
+			priv->dispc_ops->ovl_get_color_modes(id));
 	omap_plane->id = id;
 	omap_plane->name = plane_names[id];
 

commit c283400aa5898279dbae0fe00a2ce8e0f61eb22c
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Nov 5 19:54:33 2015 +0200

    drm/omap: move dispc related dss-feat funcs to dispc
    
    omapdrm still uses a few non-dispc functions: dss_feat_get_num_mgrs(),
    dss_feat_get_num_ovls() and  dss_feat_get_supported_color_modes(). We
    want to provide omapdrm a single dispc_ops function pointer struct so
    that omapdrm will use either the current omapdss or the new omapdss6
    driver depending on the platform.
    
    Those three functions are really dispc functions, but are located in the
    dss_features.c for legacy reasons.
    
    This patch adds similar functionss to the dispc, and changes omapdrm to
    use those new functions. Underneath the functions still call the
    functions from dss_feature.c.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 386d90af70f7..1067695af401 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -352,7 +352,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane->nformats = omap_framebuffer_get_formats(
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
-			dss_feat_get_supported_color_modes(id));
+			dispc_ovl_get_color_modes(id));
 	omap_plane->id = id;
 	omap_plane->name = plane_names[id];
 

commit 728ae8dd696a483355b593487eba73f4c64f1152
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 28 00:21:29 2015 +0300

    drm: omapdrm: Handle FIFO underflow IRQs internally
    
    As the FIFO underflow IRQ handler just prints an error message to the
    kernel log, simplify the code by not registering one IRQ handler per
    plane but print the messages directly from the main IRQ handler.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 82b2c23d6769..386d90af70f7 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -43,8 +43,6 @@ struct omap_plane {
 
 	uint32_t nformats;
 	uint32_t formats[32];
-
-	struct omap_drm_irq error_irq;
 };
 
 struct omap_plane_state {
@@ -204,8 +202,6 @@ static void omap_plane_destroy(struct drm_plane *plane)
 
 	DBG("%s", omap_plane->name);
 
-	omap_irq_unregister(plane->dev, &omap_plane->error_irq);
-
 	drm_plane_cleanup(plane);
 
 	kfree(omap_plane);
@@ -332,14 +328,6 @@ static const struct drm_plane_funcs omap_plane_funcs = {
 	.atomic_get_property = omap_plane_atomic_get_property,
 };
 
-static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
-{
-	struct omap_plane *omap_plane =
-			container_of(irq, struct omap_plane, error_irq);
-	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_plane->name,
-		irqstatus);
-}
-
 static const char *plane_names[] = {
 	[OMAP_DSS_GFX] = "gfx",
 	[OMAP_DSS_VIDEO1] = "vid1",
@@ -347,13 +335,6 @@ static const char *plane_names[] = {
 	[OMAP_DSS_VIDEO3] = "vid3",
 };
 
-static const uint32_t error_irqs[] = {
-	[OMAP_DSS_GFX] = DISPC_IRQ_GFX_FIFO_UNDERFLOW,
-	[OMAP_DSS_VIDEO1] = DISPC_IRQ_VID1_FIFO_UNDERFLOW,
-	[OMAP_DSS_VIDEO2] = DISPC_IRQ_VID2_FIFO_UNDERFLOW,
-	[OMAP_DSS_VIDEO3] = DISPC_IRQ_VID3_FIFO_UNDERFLOW,
-};
-
 /* initialize plane */
 struct drm_plane *omap_plane_init(struct drm_device *dev,
 		int id, enum drm_plane_type type,
@@ -377,10 +358,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	plane = &omap_plane->base;
 
-	omap_plane->error_irq.irqmask = error_irqs[id];
-	omap_plane->error_irq.irq = omap_plane_error_irq;
-	omap_irq_register(dev, &omap_plane->error_irq);
-
 	ret = drm_universal_plane_init(dev, plane, possible_crtcs,
 				       &omap_plane_funcs, omap_plane->formats,
 				       omap_plane->nformats, type, NULL);
@@ -394,7 +371,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	return plane;
 
 error:
-	omap_irq_unregister(plane->dev, &omap_plane->error_irq);
 	kfree(omap_plane);
 	return NULL;
 }

commit e43f2c3395fd36ec9f8d069af07bcd3eae5fde17
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Dec 2 16:07:11 2016 +0200

    drm/omap: fix primary-plane's possible_crtcs
    
    We set the possible_crtc for all planes to "(1 << priv->num_crtcs) - 1",
    which is fine as the HW planes can be used fro all crtcs. However, when
    we're doing that, we are still incrementing 'num_crtcs', and we'll end
    up with bad possible_crtcs, preventing the use of the primary planes.
    
    This patch passes a possible_crtcs mask to plane init function so that
    we get correct possible_crtc.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 9c43cb481e62..82b2c23d6769 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -356,9 +356,9 @@ static const uint32_t error_irqs[] = {
 
 /* initialize plane */
 struct drm_plane *omap_plane_init(struct drm_device *dev,
-		int id, enum drm_plane_type type)
+		int id, enum drm_plane_type type,
+		u32 possible_crtcs)
 {
-	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
 	int ret;
@@ -381,7 +381,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	omap_plane->error_irq.irq = omap_plane_error_irq;
 	omap_irq_register(dev, &omap_plane->error_irq);
 
-	ret = drm_universal_plane_init(dev, plane, (1 << priv->num_crtcs) - 1,
+	ret = drm_universal_plane_init(dev, plane, possible_crtcs,
 				       &omap_plane_funcs, omap_plane->formats,
 				       omap_plane->nformats, type, NULL);
 	if (ret < 0)

commit cfb73f202dd9952bbcdb12895813ea32008db3c5
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jun 10 12:44:31 2016 +0300

    drm/omap: print error instead of WARN() if plane setup fails
    
    omap_plane_atomic_update() does WARN_ON() if dispc rejects the given
    plane config. Change that to dev_err() to lessen the possible spam.
    
    To fix this correctly, the plane setup needs much more work by creating
    a check function for dispc setup, so that we could reliably check the
    config in atomic_check, instead of only noticing the problem when
    programming dispc.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index adab71b17017..9c43cb481e62 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -131,7 +131,9 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, &info, false,
 			      omap_crtc_timings(state->crtc), false);
-	if (WARN_ON(ret)) {
+	if (ret) {
+		dev_err(plane->dev->dev, "Failed to setup plane %s\n",
+			omap_plane->name);
 		dispc_ovl_enable(omap_plane->id, false);
 		return;
 	}

commit 70dd2a62aa35687ee01c756ea201ea3e970c28ad
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jun 10 12:50:53 2016 +0300

    drm/omap: cleanup omap_plane_atomic_check()
    
    Clean up omap_plane_atomic_check() with:
    
    - Check state->fb first. If no fb, return 0.
    - use drm_atomic_get_existing_crtc_state() instead of
      drm_atomic_get_crtc_state()
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7bd24185f33c..adab71b17017 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -157,12 +157,17 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 {
 	struct drm_crtc_state *crtc_state;
 
-	if (!state->crtc)
+	if (!state->fb)
 		return 0;
 
-	crtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);
-	if (IS_ERR(crtc_state))
-		return PTR_ERR(crtc_state);
+	/* crtc should only be NULL when disabling (i.e., !state->fb) */
+	if (WARN_ON(!state->crtc))
+		return 0;
+
+	crtc_state = drm_atomic_get_existing_crtc_state(state->state, state->crtc);
+	/* we should have a crtc state if the plane is attached to a crtc */
+	if (WARN_ON(!crtc_state))
+		return 0;
 
 	if (!crtc_state->enable)
 		return 0;
@@ -176,11 +181,9 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 	if (state->crtc_y + state->crtc_h > crtc_state->adjusted_mode.vdisplay)
 		return -EINVAL;
 
-	if (state->fb) {
-		if (state->rotation != DRM_ROTATE_0 &&
-		    !omap_framebuffer_supports_rotation(state->fb))
-			return -EINVAL;
-	}
+	if (state->rotation != DRM_ROTATE_0 &&
+	    !omap_framebuffer_supports_rotation(state->fb))
+		return -EINVAL;
 
 	return 0;
 }

commit aaf7642e98917fc95c260cbee98d2f426754b265
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Jun 10 12:50:39 2016 +0300

    drm/omap: fix plane check when crtc is disabled
    
    I sometimes see:
    
    [drm:drm_framebuffer_remove [drm]] *ERROR* failed to reset crtc ed2a6c00
    when fb was deleted: -22
    
    which comes from drm_framebuffer_remove() when it's disabling the crtc
    with zeroed drm_mode_set.
    
    The problem in omap_plane_atomic_check() is that it will use those
    zeroed fields to verify if the setup is correct.
    
    This patch makes omap_plane_atomic_check() return 0 if the crtc is
    disabled.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 0ffd5b930ec0..7bd24185f33c 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -164,6 +164,9 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 	if (IS_ERR(crtc_state))
 		return PTR_ERR(crtc_state);
 
+	if (!crtc_state->enable)
+		return 0;
+
 	if (state->crtc_x < 0 || state->crtc_y < 0)
 		return -EINVAL;
 

commit 0da88db14034e8b309f1c4188123ca1a02f4b354
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 26 19:30:52 2016 +0300

    drm/omap: Use per-plane rotation property
    
    The global mode_config.rotation_property is going away, switch over to
    per-plane rotation_property.
    
    Not sure I got the annoying crtc rotation_property handling right.
    Might work, or migth not.
    
    v2: Drop the BIT()
        Don't create rotation property twice for each primary plane
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    [danvet: Add comment per discussion between Tomi&Ville.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474907460-10717-8-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 6ddaa5ea4b6b..0ffd5b930ec0 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -211,9 +211,17 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	struct omap_drm_private *priv = dev->dev_private;
 
 	if (priv->has_dmm) {
-		struct drm_property *prop = dev->mode_config.rotation_property;
-
-		drm_object_attach_property(obj, prop, DRM_ROTATE_0);
+		if (!plane->rotation_property)
+			drm_plane_create_rotation_property(plane,
+							   DRM_ROTATE_0,
+							   DRM_ROTATE_0 | DRM_ROTATE_90 |
+							   DRM_ROTATE_180 | DRM_ROTATE_270 |
+							   DRM_REFLECT_X | DRM_REFLECT_Y);
+
+		/* Attach the rotation property also to the crtc object */
+		if (plane->rotation_property && obj != &plane->base)
+			drm_object_attach_property(obj, plane->rotation_property,
+						   DRM_ROTATE_0);
 	}
 
 	drm_object_attach_property(obj, priv->zorder_prop, 0);

commit 18391ec0bb4a1ea1ba2b485b8b29ac536d52fa5b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 26 19:30:51 2016 +0300

    drm/omap: Set rotation property initial value to BIT(DRM_ROTATE_0) insted of 0
    
    0 isn't a valid rotation property value, so let's set the initial value
    of the property to BIT(DRM_ROTATE_0) instead.
    
    v2: Drop the BIT()
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474907460-10717-7-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 1549e8393056..6ddaa5ea4b6b 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -213,7 +213,7 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	if (priv->has_dmm) {
 		struct drm_property *prop = dev->mode_config.rotation_property;
 
-		drm_object_attach_property(obj, prop, 0);
+		drm_object_attach_property(obj, prop, DRM_ROTATE_0);
 	}
 
 	drm_object_attach_property(obj, priv->zorder_prop, 0);

commit bd2ef25d921c0d937e4bc4f5a4f98f534424c6aa
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 26 19:30:46 2016 +0300

    drm: Add drm_rotation_90_or_270()
    
    We have intel_rotation_90_or_270() in i915 to check if the rotation is
    90 or 270 degrees. Similar checks are elsewhere in drm, so let's move
    the helper into a central place and use it everwhere.
    
    v2: Drop the BIT()
        Convert all new intel_rotation_90_or_270() calls
        Deal with superfluous code shuffling
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474907460-10717-2-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 66ac8c40db26..1549e8393056 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -108,16 +108,12 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	win.src_x = state->src_x >> 16;
 	win.src_y = state->src_y >> 16;
 
-	switch (state->rotation & DRM_ROTATE_MASK) {
-	case DRM_ROTATE_90:
-	case DRM_ROTATE_270:
+	if (drm_rotation_90_or_270(state->rotation)) {
 		win.src_w = state->src_h >> 16;
 		win.src_h = state->src_w >> 16;
-		break;
-	default:
+	} else {
 		win.src_w = state->src_w >> 16;
 		win.src_h = state->src_h >> 16;
-		break;
 	}
 
 	/* update scanout: */

commit 1832040d010ecf41671104259f51f6368fcfcb5b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 18 19:00:16 2016 +0100

    drm: Allow drivers to modify plane_state in prepare_fb/cleanup_fb
    
    The drivers have to modify the atomic plane state during the prepare_fb
    callback so they track allocations, reservations and dependencies for
    this atomic operation involving this fb. In particular, how else do we
    set the plane->fence from the framebuffer!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160818180017.20508-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 4c7727e6be7c..66ac8c40db26 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -60,7 +60,7 @@ to_omap_plane_state(struct drm_plane_state *state)
 }
 
 static int omap_plane_prepare_fb(struct drm_plane *plane,
-				 const struct drm_plane_state *new_state)
+				 struct drm_plane_state *new_state)
 {
 	if (!new_state->fb)
 		return 0;
@@ -69,7 +69,7 @@ static int omap_plane_prepare_fb(struct drm_plane *plane,
 }
 
 static void omap_plane_cleanup_fb(struct drm_plane *plane,
-				  const struct drm_plane_state *old_state)
+				  struct drm_plane_state *old_state)
 {
 	if (old_state->fb)
 		omap_framebuffer_unpin(old_state->fb);

commit 31ad61e4afa53a7b2e364f7c021546fbc6ce0d85
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Jul 29 08:50:05 2016 +0300

    drm: BIT(DRM_ROTATE_?) -> DRM_ROTATE_?
    
    Only property creation uses the rotation as an index, so convert the
    to figure the index when needed.
    
    v2: Use the new defines to build the _MASK defines (Sean)
    
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: malidp@foss.arm.com
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> (v1)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469771405-17653-1-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 5252ab720e70..4c7727e6be7c 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -109,8 +109,8 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	win.src_y = state->src_y >> 16;
 
 	switch (state->rotation & DRM_ROTATE_MASK) {
-	case BIT(DRM_ROTATE_90):
-	case BIT(DRM_ROTATE_270):
+	case DRM_ROTATE_90:
+	case DRM_ROTATE_270:
 		win.src_w = state->src_h >> 16;
 		win.src_h = state->src_w >> 16;
 		break;
@@ -149,7 +149,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	struct omap_plane_state *omap_state = to_omap_plane_state(plane->state);
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
-	plane->state->rotation = BIT(DRM_ROTATE_0);
+	plane->state->rotation = DRM_ROTATE_0;
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
@@ -178,7 +178,7 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 		return -EINVAL;
 
 	if (state->fb) {
-		if (state->rotation != BIT(DRM_ROTATE_0) &&
+		if (state->rotation != DRM_ROTATE_0 &&
 		    !omap_framebuffer_supports_rotation(state->fb))
 			return -EINVAL;
 	}
@@ -269,7 +269,7 @@ static void omap_plane_reset(struct drm_plane *plane)
 	 */
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
-	omap_state->base.rotation = BIT(DRM_ROTATE_0);
+	omap_state->base.rotation = DRM_ROTATE_0;
 
 	plane->state = &omap_state->base;
 	plane->state->plane = plane;

commit 2f701695fd3a5876cd302662554f6c0ece5197eb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon May 9 16:34:10 2016 +0200

    drm: Drop plane argument from __drm_atomic_helper_plane_destroy_state
    
    It's unused, and really this helper should only look at the state
    structure and nothing else.
    
    v2: Fix commit message (Laurent).
    
    v3: Rebase onto mtk driver merge.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1462804451-15318-2-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 93ee538a99f5..5252ab720e70 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -245,7 +245,7 @@ omap_plane_atomic_duplicate_state(struct drm_plane *plane)
 static void omap_plane_atomic_destroy_state(struct drm_plane *plane,
 					    struct drm_plane_state *state)
 {
-	__drm_atomic_helper_plane_destroy_state(plane, state);
+	__drm_atomic_helper_plane_destroy_state(state);
 	kfree(to_omap_plane_state(state));
 }
 

commit bfeece553335f9b9bf0d4dc9ea8a602a2248dfd6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Aug 27 13:09:22 2015 +0300

    drm/omap: check if rotation is supported before commit
    
    omapdrm is missing a check on the validity of the rotation property.
    This leads to omapdrm possibly trying to use rotation on non-rotateable
    framebuffer, which causes the overlay setup to fail.
    
    This patch adds the necessary check to omap_plane_atomic_check().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d75b197eff46..93ee538a99f5 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -177,6 +177,12 @@ static int omap_plane_atomic_check(struct drm_plane *plane,
 	if (state->crtc_y + state->crtc_h > crtc_state->adjusted_mode.vdisplay)
 		return -EINVAL;
 
+	if (state->fb) {
+		if (state->rotation != BIT(DRM_ROTATE_0) &&
+		    !omap_framebuffer_supports_rotation(state->fb))
+			return -EINVAL;
+	}
+
 	return 0;
 }
 

commit f8ef29ee45664e86805d4359e352a0a9acbd1d13
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 14 22:39:29 2015 +0200

    drm: omapdrm: Fix plane state free in plane reset handler
    
    The plane reset handler frees the plane state and allocates a new
    default state, but when doing so attempt to free the plane state using
    the base plane state pointer instead of casting it to the
    driver-specific state object that has been allocated. Fix it by using
    the omap_plane_atomic_destroy_state() function to destroy the plane
    state instead of duplicating the code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    [tomi.valkeinen@ti.com: move of the func into separate patch]
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index c3f637491a63..d75b197eff46 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -248,11 +248,10 @@ static void omap_plane_reset(struct drm_plane *plane)
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct omap_plane_state *omap_state;
 
-	if (plane->state && plane->state->fb)
-		drm_framebuffer_unreference(plane->state->fb);
-
-	kfree(plane->state);
-	plane->state = NULL;
+	if (plane->state) {
+		omap_plane_atomic_destroy_state(plane, plane->state);
+		plane->state = NULL;
+	}
 
 	omap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);
 	if (omap_state == NULL)

commit e07323cf1bf2f45cf0e237f3d9990370d54fb714
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Dec 15 11:33:23 2015 +0200

    drm: omapdrm: move omap_plane_reset()
    
    Move omap_plane_reset() function to avoid forward declarations in the
    next patch.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d5ecabd6c14c..c3f637491a63 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -188,33 +188,6 @@ static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {
 	.atomic_disable = omap_plane_atomic_disable,
 };
 
-static void omap_plane_reset(struct drm_plane *plane)
-{
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct omap_plane_state *omap_state;
-
-	if (plane->state && plane->state->fb)
-		drm_framebuffer_unreference(plane->state->fb);
-
-	kfree(plane->state);
-	plane->state = NULL;
-
-	omap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);
-	if (omap_state == NULL)
-		return;
-
-	/*
-	 * Set defaults depending on whether we are a primary or overlay
-	 * plane.
-	 */
-	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
-			   ? 0 : omap_plane->id;
-	omap_state->base.rotation = BIT(DRM_ROTATE_0);
-
-	plane->state = &omap_state->base;
-	plane->state->plane = plane;
-}
-
 static void omap_plane_destroy(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
@@ -270,6 +243,33 @@ static void omap_plane_atomic_destroy_state(struct drm_plane *plane,
 	kfree(to_omap_plane_state(state));
 }
 
+static void omap_plane_reset(struct drm_plane *plane)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct omap_plane_state *omap_state;
+
+	if (plane->state && plane->state->fb)
+		drm_framebuffer_unreference(plane->state->fb);
+
+	kfree(plane->state);
+	plane->state = NULL;
+
+	omap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);
+	if (omap_state == NULL)
+		return;
+
+	/*
+	 * Set defaults depending on whether we are a primary or overlay
+	 * plane.
+	 */
+	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
+			   ? 0 : omap_plane->id;
+	omap_state->base.rotation = BIT(DRM_ROTATE_0);
+
+	plane->state = &omap_state->base;
+	plane->state->plane = plane;
+}
+
 static int omap_plane_atomic_set_property(struct drm_plane *plane,
 					  struct drm_plane_state *state,
 					  struct drm_property *property,

commit b0b3b7951114315d65398c27648705ca1c322faa
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:19:55 2015 +0200

    drm: Pass 'name' to drm_universal_plane_init()
    
    Done with coccinelle for the most part. It choked on
    msm/mdp/mdp5/mdp5_plane.c like so:
    "BAD:!!!!!  enum drm_plane_type type;"
    No idea how to deal with that, so I just fixed that up
    by hand.
    
    Also it thinks '...' is part of the semantic patch, so I put an
    'int DOTDOTDOT' placeholder in its place and got rid of it with
    sed afterwards.
    
    I didn't convert drm_plane_init() since passing the varargs through
    would mean either cpp macros or va_list, and I figured we don't
    care about these legacy functions enough to warrant the extra pain.
    
    @@
    typedef uint32_t;
    identifier dev, plane, possible_crtcs, funcs, formats, format_count, type;
    @@
     int drm_universal_plane_init(struct drm_device *dev,
                                  struct drm_plane *plane,
                                  unsigned long possible_crtcs,
                                  const struct drm_plane_funcs *funcs,
                                  const uint32_t *formats,
                                  unsigned int format_count,
                                  enum drm_plane_type type
    +                             ,const char *name, int DOTDOTDOT
                                  )
    { ... }
    
    @@
    identifier dev, plane, possible_crtcs, funcs, formats, format_count, type;
    @@
     int drm_universal_plane_init(struct drm_device *dev,
                                  struct drm_plane *plane,
                                  unsigned long possible_crtcs,
                                  const struct drm_plane_funcs *funcs,
                                  const uint32_t *formats,
                                  unsigned int format_count,
                                  enum drm_plane_type type
    +                             ,const char *name, int DOTDOTDOT
                                  );
    
    @@
    expression E1, E2, E3, E4, E5, E6, E7;
    @@
     drm_universal_plane_init(E1, E2, E3, E4, E5, E6, E7
    +                         ,NULL
                              )
    
    v2: Split crtc and plane changes apart
        Pass NUL for no-name instead of ""
        Leave drm_plane_init() alone
    v3: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670795-2853-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 3054bda72688..d5ecabd6c14c 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -366,7 +366,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	ret = drm_universal_plane_init(dev, plane, (1 << priv->num_crtcs) - 1,
 				       &omap_plane_funcs, omap_plane->formats,
-				       omap_plane->nformats, type);
+				       omap_plane->nformats, type, NULL);
 	if (ret < 0)
 		goto error;
 

commit 14152c8d30bbe5155d0438feb0a1931aee0e5bce
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Oct 1 10:00:58 2015 +0300

    drm: Use DRM_ROTATE_MASK and DRM_REFLECT_MASK
    
    Avoid magic numbers and use the introduced defines.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 09e363bb55f2..3054bda72688 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -108,7 +108,7 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	win.src_x = state->src_x >> 16;
 	win.src_y = state->src_y >> 16;
 
-	switch (state->rotation & 0xf) {
+	switch (state->rotation & DRM_ROTATE_MASK) {
 	case BIT(DRM_ROTATE_90):
 	case BIT(DRM_ROTATE_270):
 		win.src_w = state->src_h >> 16;

commit 844f9111f6f54f88eb2f0fac121b82ce77193866
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Sep 2 10:42:40 2015 +0200

    drm/atomic: Make prepare_fb/cleanup_fb only take state, v3.
    
    This removes the need to separately track fb changes i915.
    That will be done as a separate commit, however.
    
    Changes since v1:
    - Add dri-devel to cc.
    - Fix a check in intel's prepare and cleanup fb to take rotation
      into account.
    Changes since v2:
    - Split out i915 changes to a separate commit.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    [danvet: Squash in msm fixup from Maarten.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 098904696a5c..09e363bb55f2 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -60,17 +60,19 @@ to_omap_plane_state(struct drm_plane_state *state)
 }
 
 static int omap_plane_prepare_fb(struct drm_plane *plane,
-				 struct drm_framebuffer *fb,
 				 const struct drm_plane_state *new_state)
 {
-	return omap_framebuffer_pin(fb);
+	if (!new_state->fb)
+		return 0;
+
+	return omap_framebuffer_pin(new_state->fb);
 }
 
 static void omap_plane_cleanup_fb(struct drm_plane *plane,
-				  struct drm_framebuffer *fb,
 				  const struct drm_plane_state *old_state)
 {
-	omap_framebuffer_unpin(fb);
+	if (old_state->fb)
+		omap_framebuffer_unpin(old_state->fb);
 }
 
 static void omap_plane_atomic_update(struct drm_plane *plane,

commit c423bc85097327fba71f9a831280d09b64bb62b6
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Jun 16 14:54:51 2015 +0300

    drm/omap: check that plane is inside crtc
    
    DRM allows planes to be partially off-screen, but DSS hardware does not.
    This patch adds the necessary check to reject plane configs if the plane
    is not fully inside the crtc.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index cfa8276c4deb..098904696a5c 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -17,6 +17,7 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_plane_helper.h>
 
@@ -153,9 +154,34 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	dispc_ovl_enable(omap_plane->id, false);
 }
 
+static int omap_plane_atomic_check(struct drm_plane *plane,
+				   struct drm_plane_state *state)
+{
+	struct drm_crtc_state *crtc_state;
+
+	if (!state->crtc)
+		return 0;
+
+	crtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	if (state->crtc_x < 0 || state->crtc_y < 0)
+		return -EINVAL;
+
+	if (state->crtc_x + state->crtc_w > crtc_state->adjusted_mode.hdisplay)
+		return -EINVAL;
+
+	if (state->crtc_y + state->crtc_h > crtc_state->adjusted_mode.vdisplay)
+		return -EINVAL;
+
+	return 0;
+}
+
 static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {
 	.prepare_fb = omap_plane_prepare_fb,
 	.cleanup_fb = omap_plane_cleanup_fb,
+	.atomic_check = omap_plane_atomic_check,
 	.atomic_update = omap_plane_atomic_update,
 	.atomic_disable = omap_plane_atomic_disable,
 };

commit 794a65ffba77f63ecfc7d23ca6406cc23deab202
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri May 29 11:06:07 2015 +0300

    drm: omapdrm: if omap_plane_atomic_update fails, disable plane
    
    omap_plane_atomic_update() calls dispc_ovl_setup(), which can fail (but
    shouldn't). To make the code a bit more robust, make sure the plane gets
    disabled if dispc_ovl_setup() fails, as otherwise we might get illegal
    HW configuration leading to error interrupts.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index b13fb2fd4a9a..cfa8276c4deb 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -132,8 +132,10 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, &info, false,
 			      omap_crtc_timings(state->crtc), false);
-	if (WARN_ON(ret))
+	if (WARN_ON(ret)) {
+		dispc_ovl_enable(omap_plane->id, false);
 		return;
+	}
 
 	dispc_ovl_enable(omap_plane->id, true);
 }

commit 11ffd031e3e5b9cc0232aad549bb08eb14612f43
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri May 29 11:05:37 2015 +0300

    drm: omapdrm: inline omap_plane_setup into update/disable
    
    At the moment we have omap_plane_setup() function which handles both
    enabling (and configuring) and disabling the plane. With atomic
    modesetting we have separate hooks for plane enable/config and disable.
    
    This patch moves the code from omap_plane_setup() to
    omap_plane_atomic_update() and omap_plane_atomic_disable().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index a8e617f9f2af..b13fb2fd4a9a 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -58,7 +58,22 @@ to_omap_plane_state(struct drm_plane_state *state)
 	return container_of(state, struct omap_plane_state, base);
 }
 
-static void omap_plane_setup(struct drm_plane *plane)
+static int omap_plane_prepare_fb(struct drm_plane *plane,
+				 struct drm_framebuffer *fb,
+				 const struct drm_plane_state *new_state)
+{
+	return omap_framebuffer_pin(fb);
+}
+
+static void omap_plane_cleanup_fb(struct drm_plane *plane,
+				  struct drm_framebuffer *fb,
+				  const struct drm_plane_state *old_state)
+{
+	omap_framebuffer_unpin(fb);
+}
+
+static void omap_plane_atomic_update(struct drm_plane *plane,
+				     struct drm_plane_state *old_state)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;
@@ -69,11 +84,6 @@ static void omap_plane_setup(struct drm_plane *plane)
 
 	DBG("%s, crtc=%p fb=%p", omap_plane->name, state->crtc, state->fb);
 
-	if (!state->crtc) {
-		dispc_ovl_enable(omap_plane->id, false);
-		return;
-	}
-
 	memset(&info, 0, sizeof(info));
 	info.rotation_type = OMAP_DSS_ROT_DMA;
 	info.rotation = OMAP_DSS_ROT_0;
@@ -128,26 +138,6 @@ static void omap_plane_setup(struct drm_plane *plane)
 	dispc_ovl_enable(omap_plane->id, true);
 }
 
-static int omap_plane_prepare_fb(struct drm_plane *plane,
-				 struct drm_framebuffer *fb,
-				 const struct drm_plane_state *new_state)
-{
-	return omap_framebuffer_pin(fb);
-}
-
-static void omap_plane_cleanup_fb(struct drm_plane *plane,
-				  struct drm_framebuffer *fb,
-				  const struct drm_plane_state *old_state)
-{
-	omap_framebuffer_unpin(fb);
-}
-
-static void omap_plane_atomic_update(struct drm_plane *plane,
-				     struct drm_plane_state *old_state)
-{
-	omap_plane_setup(plane);
-}
-
 static void omap_plane_atomic_disable(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
@@ -158,7 +148,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
-	omap_plane_setup(plane);
+	dispc_ovl_enable(omap_plane->id, false);
 }
 
 static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {

commit d9157dfd045f27f376edeab164203f1a68ba3ba4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri May 29 11:03:15 2015 +0300

    drm: omapdrm: omap_plane_setup() cannot fail, use WARN
    
    With atomic modesetting, omap_plane_setup()'s return value is ignored as
    the functions using it cannot fail. dispc_ovl_setup(), called by
    omap_plane_setup(), can fail (but shouldn't).
    
    Instead of returning an error from omap_plane_setup() which gets
    ignored, return void and use WARN if dispc_ovl_setup() fails.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 448707669690..a8e617f9f2af 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -58,12 +58,11 @@ to_omap_plane_state(struct drm_plane_state *state)
 	return container_of(state, struct omap_plane_state, base);
 }
 
-static int omap_plane_setup(struct drm_plane *plane)
+static void omap_plane_setup(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;
 	struct omap_plane_state *omap_state = to_omap_plane_state(state);
-	struct drm_device *dev = plane->dev;
 	struct omap_overlay_info info;
 	struct omap_drm_window win;
 	int ret;
@@ -72,7 +71,7 @@ static int omap_plane_setup(struct drm_plane *plane)
 
 	if (!state->crtc) {
 		dispc_ovl_enable(omap_plane->id, false);
-		return 0;
+		return;
 	}
 
 	memset(&info, 0, sizeof(info));
@@ -123,14 +122,10 @@ static int omap_plane_setup(struct drm_plane *plane)
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, &info, false,
 			      omap_crtc_timings(state->crtc), false);
-	if (ret) {
-		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
-		return ret;
-	}
+	if (WARN_ON(ret))
+		return;
 
 	dispc_ovl_enable(omap_plane->id, true);
-
-	return 0;
 }
 
 static int omap_plane_prepare_fb(struct drm_plane *plane,

commit 0dce4d75c3fc585387fbfc7ab2126118d86bf0f9
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed May 27 20:53:57 2015 +0300

    drm: omapdrm: Don't setup planes manually from CRTC .enable()/.disable()
    
    Planes setup is handled by the DRM core through the atomic helpers,
    there's no need to duplicate the code in the CRTC .enable() and
    .disable() operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d18fe106e256..448707669690 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -58,7 +58,7 @@ to_omap_plane_state(struct drm_plane_state *state)
 	return container_of(state, struct omap_plane_state, base);
 }
 
-int omap_plane_setup(struct drm_plane *plane)
+static int omap_plane_setup(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_plane_state *state = plane->state;

commit edc725577c52d4abe1dac54ccca1b7bc08672f13
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 19:18:56 2015 +0200

    drm: omapdrm: Remove omap_plane enabled field
    
    The field tracks the plane state to avoid double-enable or -disable.
    This isn't required anymore, as
    
    - the DRM atomic core guarantees that the plane atomic_update and
      atomic_disable functions will never be called on an enabled/disabled
      plane
    
    - the CRTC enable/disable operations that enable/disable the plane are
      already guarded against double enable/disable
    
    We can thus remove the enabled field completely. The
    omap_plane_set_enable() function then becomes a wrapper around
    omap_plane_setup() which can be called directly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 465fd9cafd7b..d18fe106e256 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -40,8 +40,6 @@ struct omap_plane {
 	int id;  /* TODO rename omap_plane -> omap_plane_id in omapdss so I can use the enum */
 	const char *name;
 
-	bool enabled;
-
 	uint32_t nformats;
 	uint32_t formats[32];
 
@@ -60,18 +58,19 @@ to_omap_plane_state(struct drm_plane_state *state)
 	return container_of(state, struct omap_plane_state, base);
 }
 
-static int omap_plane_setup(struct omap_plane *omap_plane)
+int omap_plane_setup(struct drm_plane *plane)
 {
-	struct drm_plane_state *state = omap_plane->base.state;
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct drm_plane_state *state = plane->state;
 	struct omap_plane_state *omap_state = to_omap_plane_state(state);
-	struct drm_device *dev = omap_plane->base.dev;
+	struct drm_device *dev = plane->dev;
 	struct omap_overlay_info info;
 	struct omap_drm_window win;
 	int ret;
 
-	DBG("%s, enabled=%d", omap_plane->name, omap_plane->enabled);
+	DBG("%s, crtc=%p fb=%p", omap_plane->name, state->crtc, state->fb);
 
-	if (!omap_plane->enabled) {
+	if (!state->crtc) {
 		dispc_ovl_enable(omap_plane->id, false);
 		return 0;
 	}
@@ -134,23 +133,6 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 	return 0;
 }
 
-int omap_plane_set_enable(struct drm_plane *plane, bool enable)
-{
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-	int ret;
-
-	if (enable == omap_plane->enabled)
-		return 0;
-
-	omap_plane->enabled = enable;
-
-	dispc_runtime_get();
-	ret = omap_plane_setup(omap_plane);
-	dispc_runtime_put();
-
-	return ret;
-}
-
 static int omap_plane_prepare_fb(struct drm_plane *plane,
 				 struct drm_framebuffer *fb,
 				 const struct drm_plane_state *new_state)
@@ -168,14 +150,7 @@ static void omap_plane_cleanup_fb(struct drm_plane *plane,
 static void omap_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_plane_state *old_state)
 {
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct drm_plane_state *state = plane->state;
-
-	if (!state->fb || !state->crtc)
-		return;
-
-	omap_plane->enabled = true;
-	omap_plane_setup(omap_plane);
+	omap_plane_setup(plane);
 }
 
 static void omap_plane_atomic_disable(struct drm_plane *plane,
@@ -188,11 +163,7 @@ static void omap_plane_atomic_disable(struct drm_plane *plane,
 	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 			   ? 0 : omap_plane->id;
 
-	if (!omap_plane->enabled)
-		return;
-
-	omap_plane->enabled = false;
-	omap_plane_setup(omap_plane);
+	omap_plane_setup(plane);
 }
 
 static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {

commit fb730c9b7097373b30bce0bed326942acdf467de
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 19:00:18 2015 +0200

    drm: omapdrm: Move plane info and win out of the plane structure
    
    The plane info and win structures are only used to setup the plane
    through the DSS API. Move them from the plane structure to local
    variables in omap_plane_setup().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7011cb23d3eb..465fd9cafd7b 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -39,10 +39,7 @@ struct omap_plane {
 	struct drm_plane base;
 	int id;  /* TODO rename omap_plane -> omap_plane_id in omapdss so I can use the enum */
 	const char *name;
-	struct omap_overlay_info info;
 
-	/* position/orientation of scanout within the fb: */
-	struct omap_drm_window win;
 	bool enabled;
 
 	uint32_t nformats;
@@ -67,8 +64,9 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 {
 	struct drm_plane_state *state = omap_plane->base.state;
 	struct omap_plane_state *omap_state = to_omap_plane_state(state);
-	struct omap_overlay_info *info = &omap_plane->info;
 	struct drm_device *dev = omap_plane->base.dev;
+	struct omap_overlay_info info;
+	struct omap_drm_window win;
 	int ret;
 
 	DBG("%s, enabled=%d", omap_plane->name, omap_plane->enabled);
@@ -78,22 +76,53 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 		return 0;
 	}
 
-	info->zorder = omap_state->zorder;
+	memset(&info, 0, sizeof(info));
+	info.rotation_type = OMAP_DSS_ROT_DMA;
+	info.rotation = OMAP_DSS_ROT_0;
+	info.global_alpha = 0xff;
+	info.mirror = 0;
+	info.zorder = omap_state->zorder;
+
+	memset(&win, 0, sizeof(win));
+	win.rotation = state->rotation;
+	win.crtc_x = state->crtc_x;
+	win.crtc_y = state->crtc_y;
+	win.crtc_w = state->crtc_w;
+	win.crtc_h = state->crtc_h;
+
+	/*
+	 * src values are in Q16 fixed point, convert to integer.
+	 * omap_framebuffer_update_scanout() takes adjusted src.
+	 */
+	win.src_x = state->src_x >> 16;
+	win.src_y = state->src_y >> 16;
+
+	switch (state->rotation & 0xf) {
+	case BIT(DRM_ROTATE_90):
+	case BIT(DRM_ROTATE_270):
+		win.src_w = state->src_h >> 16;
+		win.src_h = state->src_w >> 16;
+		break;
+	default:
+		win.src_w = state->src_w >> 16;
+		win.src_h = state->src_h >> 16;
+		break;
+	}
 
 	/* update scanout: */
-	omap_framebuffer_update_scanout(state->fb, &omap_plane->win, info);
+	omap_framebuffer_update_scanout(state->fb, &win, &info);
 
-	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
-			info->out_width, info->out_height,
-			info->screen_width);
-	DBG("%d,%d %pad %pad", info->pos_x, info->pos_y,
-			&info->paddr, &info->p_uv_addr);
+	DBG("%dx%d -> %dx%d (%d)", info.width, info.height,
+			info.out_width, info.out_height,
+			info.screen_width);
+	DBG("%d,%d %pad %pad", info.pos_x, info.pos_y,
+			&info.paddr, &info.p_uv_addr);
 
 	dispc_ovl_set_channel_out(omap_plane->id,
 				  omap_crtc_channel(state->crtc));
 
 	/* and finally, update omapdss: */
-	ret = dispc_ovl_setup(omap_plane->id, info, false,
+	ret = dispc_ovl_setup(omap_plane->id, &info, false,
 			      omap_crtc_timings(state->crtc), false);
 	if (ret) {
 		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
@@ -140,40 +169,11 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_plane_state *old_state)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct omap_drm_window *win = &omap_plane->win;
 	struct drm_plane_state *state = plane->state;
-	uint32_t src_w;
-	uint32_t src_h;
 
 	if (!state->fb || !state->crtc)
 		return;
 
-	win->rotation = state->rotation;
-
-	/* omap_framebuffer_update_scanout() takes adjusted src */
-	switch (state->rotation & 0xf) {
-	case BIT(DRM_ROTATE_90):
-	case BIT(DRM_ROTATE_270):
-		src_w = state->src_h;
-		src_h = state->src_w;
-		break;
-	default:
-		src_w = state->src_w;
-		src_h = state->src_h;
-		break;
-	}
-
-	/* src values are in Q16 fixed point, convert to integer. */
-	win->crtc_x = state->crtc_x;
-	win->crtc_y = state->crtc_y;
-	win->crtc_w = state->crtc_w;
-	win->crtc_h = state->crtc_h;
-
-	win->src_x = state->src_x >> 16;
-	win->src_y = state->src_y >> 16;
-	win->src_w = src_w >> 16;
-	win->src_h = src_h >> 16;
-
 	omap_plane->enabled = true;
 	omap_plane_setup(omap_plane);
 }
@@ -358,7 +358,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	struct omap_drm_private *priv = dev->dev_private;
 	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
-	struct omap_overlay_info *info;
 	int ret;
 
 	DBG("%s: type=%d", plane_names[id], type);
@@ -389,15 +388,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane_install_properties(plane, &plane->base);
 
-	/* get our starting configuration, set defaults for parameters
-	 * we don't currently use, etc:
-	 */
-	info = &omap_plane->info;
-	info->rotation_type = OMAP_DSS_ROT_DMA;
-	info->rotation = OMAP_DSS_ROT_0;
-	info->global_alpha = 0xff;
-	info->mirror = 0;
-
 	return plane;
 
 error:

commit afc34932439fdf134be391581edcee180dd0de80
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 18:35:16 2015 +0200

    drm: omapdrm: Switch crtc and plane set_property to atomic helpers
    
    Allow setting up plane properties atomically using the plane
    set_property atomic helper. The properties are now stored in the plane
    state (requiring subclassing it) and applied when updating the planes.
    
    The CRTC exposes the properties of its primary plane for legacy reason.
    We can't get rid of that API, so simply delegate it to the primary
    plane.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7813e48b6896..7011cb23d3eb 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -51,10 +51,22 @@ struct omap_plane {
 	struct omap_drm_irq error_irq;
 };
 
-static int __omap_plane_setup(struct omap_plane *omap_plane,
-			      struct drm_crtc *crtc,
-			      struct drm_framebuffer *fb)
+struct omap_plane_state {
+	struct drm_plane_state base;
+
+	unsigned int zorder;
+};
+
+static inline struct omap_plane_state *
+to_omap_plane_state(struct drm_plane_state *state)
 {
+	return container_of(state, struct omap_plane_state, base);
+}
+
+static int omap_plane_setup(struct omap_plane *omap_plane)
+{
+	struct drm_plane_state *state = omap_plane->base.state;
+	struct omap_plane_state *omap_state = to_omap_plane_state(state);
 	struct omap_overlay_info *info = &omap_plane->info;
 	struct drm_device *dev = omap_plane->base.dev;
 	int ret;
@@ -66,8 +78,10 @@ static int __omap_plane_setup(struct omap_plane *omap_plane,
 		return 0;
 	}
 
+	info->zorder = omap_state->zorder;
+
 	/* update scanout: */
-	omap_framebuffer_update_scanout(fb, &omap_plane->win, info);
+	omap_framebuffer_update_scanout(state->fb, &omap_plane->win, info);
 
 	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
 			info->out_width, info->out_height,
@@ -76,11 +90,11 @@ static int __omap_plane_setup(struct omap_plane *omap_plane,
 			&info->paddr, &info->p_uv_addr);
 
 	dispc_ovl_set_channel_out(omap_plane->id,
-				  omap_crtc_channel(crtc));
+				  omap_crtc_channel(state->crtc));
 
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, info, false,
-			      omap_crtc_timings(crtc), false);
+			      omap_crtc_timings(state->crtc), false);
 	if (ret) {
 		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
 		return ret;
@@ -91,27 +105,21 @@ static int __omap_plane_setup(struct omap_plane *omap_plane,
 	return 0;
 }
 
-static int omap_plane_setup(struct omap_plane *omap_plane)
-{
-	struct drm_plane *plane = &omap_plane->base;
-	int ret;
-
-	dispc_runtime_get();
-	ret = __omap_plane_setup(omap_plane, plane->crtc, plane->fb);
-	dispc_runtime_put();
-
-	return ret;
-}
-
 int omap_plane_set_enable(struct drm_plane *plane, bool enable)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
+	int ret;
 
 	if (enable == omap_plane->enabled)
 		return 0;
 
 	omap_plane->enabled = enable;
-	return omap_plane_setup(omap_plane);
+
+	dispc_runtime_get();
+	ret = omap_plane_setup(omap_plane);
+	dispc_runtime_put();
+
+	return ret;
 }
 
 static int omap_plane_prepare_fb(struct drm_plane *plane,
@@ -140,8 +148,10 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	if (!state->fb || !state->crtc)
 		return;
 
+	win->rotation = state->rotation;
+
 	/* omap_framebuffer_update_scanout() takes adjusted src */
-	switch (omap_plane->win.rotation & 0xf) {
+	switch (state->rotation & 0xf) {
 	case BIT(DRM_ROTATE_90):
 	case BIT(DRM_ROTATE_270):
 		src_w = state->src_h;
@@ -165,23 +175,24 @@ static void omap_plane_atomic_update(struct drm_plane *plane,
 	win->src_h = src_h >> 16;
 
 	omap_plane->enabled = true;
-	__omap_plane_setup(omap_plane, state->crtc, state->fb);
+	omap_plane_setup(omap_plane);
 }
 
 static void omap_plane_atomic_disable(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
+	struct omap_plane_state *omap_state = to_omap_plane_state(plane->state);
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
-	omap_plane->win.rotation = BIT(DRM_ROTATE_0);
-	omap_plane->info.zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
-				? 0 : omap_plane->id;
+	plane->state->rotation = BIT(DRM_ROTATE_0);
+	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
+			   ? 0 : omap_plane->id;
 
 	if (!omap_plane->enabled)
 		return;
 
 	omap_plane->enabled = false;
-	__omap_plane_setup(omap_plane, NULL, NULL);
+	omap_plane_setup(omap_plane);
 }
 
 static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {
@@ -191,6 +202,33 @@ static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {
 	.atomic_disable = omap_plane_atomic_disable,
 };
 
+static void omap_plane_reset(struct drm_plane *plane)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct omap_plane_state *omap_state;
+
+	if (plane->state && plane->state->fb)
+		drm_framebuffer_unreference(plane->state->fb);
+
+	kfree(plane->state);
+	plane->state = NULL;
+
+	omap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);
+	if (omap_state == NULL)
+		return;
+
+	/*
+	 * Set defaults depending on whether we are a primary or overlay
+	 * plane.
+	 */
+	omap_state->zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
+			   ? 0 : omap_plane->id;
+	omap_state->base.rotation = BIT(DRM_ROTATE_0);
+
+	plane->state = &omap_state->base;
+	plane->state->plane = plane;
+}
+
 static void omap_plane_destroy(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
@@ -220,45 +258,75 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	drm_object_attach_property(obj, priv->zorder_prop, 0);
 }
 
-int omap_plane_set_property(struct drm_plane *plane,
-		struct drm_property *property, uint64_t val)
+static struct drm_plane_state *
+omap_plane_atomic_duplicate_state(struct drm_plane *plane)
+{
+	struct omap_plane_state *state;
+	struct omap_plane_state *copy;
+
+	if (WARN_ON(!plane->state))
+		return NULL;
+
+	state = to_omap_plane_state(plane->state);
+	copy = kmemdup(state, sizeof(*state), GFP_KERNEL);
+	if (copy == NULL)
+		return NULL;
+
+	__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);
+
+	return &copy->base;
+}
+
+static void omap_plane_atomic_destroy_state(struct drm_plane *plane,
+					    struct drm_plane_state *state)
+{
+	__drm_atomic_helper_plane_destroy_state(plane, state);
+	kfree(to_omap_plane_state(state));
+}
+
+static int omap_plane_atomic_set_property(struct drm_plane *plane,
+					  struct drm_plane_state *state,
+					  struct drm_property *property,
+					  uint64_t val)
 {
-	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	int ret;
+	struct omap_plane_state *omap_state = to_omap_plane_state(state);
 
-	if (property == plane->dev->mode_config.rotation_property) {
-		DBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);
-		omap_plane->win.rotation = val;
-	} else if (property == priv->zorder_prop) {
-		DBG("%s: zorder: %02x", omap_plane->name, (uint32_t)val);
-		omap_plane->info.zorder = val;
-	} else {
+	if (property == priv->zorder_prop)
+		omap_state->zorder = val;
+	else
 		return -EINVAL;
-	}
 
-	/*
-	 * We're done if the plane is disabled, properties will be applied the
-	 * next time it becomes enabled.
-	 */
-	if (!omap_plane->enabled)
-		return 0;
+	return 0;
+}
 
-	ret = omap_plane_setup(omap_plane);
-	if (ret < 0)
-		return ret;
+static int omap_plane_atomic_get_property(struct drm_plane *plane,
+					  const struct drm_plane_state *state,
+					  struct drm_property *property,
+					  uint64_t *val)
+{
+	struct omap_drm_private *priv = plane->dev->dev_private;
+	const struct omap_plane_state *omap_state =
+		container_of(state, const struct omap_plane_state, base);
+
+	if (property == priv->zorder_prop)
+		*val = omap_state->zorder;
+	else
+		return -EINVAL;
 
-	return omap_crtc_flush(plane->crtc);
+	return 0;
 }
 
 static const struct drm_plane_funcs omap_plane_funcs = {
 	.update_plane = drm_atomic_helper_update_plane,
 	.disable_plane = drm_atomic_helper_disable_plane,
-	.reset = drm_atomic_helper_plane_reset,
+	.reset = omap_plane_reset,
 	.destroy = omap_plane_destroy,
-	.set_property = omap_plane_set_property,
-	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
-	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+	.set_property = drm_atomic_helper_plane_set_property,
+	.atomic_duplicate_state = omap_plane_atomic_duplicate_state,
+	.atomic_destroy_state = omap_plane_atomic_destroy_state,
+	.atomic_set_property = omap_plane_atomic_set_property,
+	.atomic_get_property = omap_plane_atomic_get_property,
 };
 
 static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -330,16 +398,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	info->global_alpha = 0xff;
 	info->mirror = 0;
 
-	/* Set defaults depending on whether we are a CRTC or overlay
-	 * layer.
-	 * TODO add ioctl to give userspace an API to change this.. this
-	 * will come in a subsequent patch.
-	 */
-	if (type == DRM_PLANE_TYPE_PRIMARY)
-		omap_plane->info.zorder = 0;
-	else
-		omap_plane->info.zorder = id;
-
 	return plane;
 
 error:

commit 9d29c1f2d5510fc7cb95cacc27016fab279fb881
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 18:49:37 2015 +0200

    drm: omapdrm: Drop manual framebuffer pin handling
    
    Since the removal of omap_plane_mode_set(), framebuffers are now pinned
    exclusively through the plane .prepare_fb() and .cleanup_fb() operations
    as the remaining callers of omap_plane_setup() don't modify the
    framebuffer. Remove the manual pin/unpin infrastructure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 117fa37534b6..7813e48b6896 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -45,49 +45,12 @@ struct omap_plane {
 	struct omap_drm_window win;
 	bool enabled;
 
-	/* last fb that we pinned: */
-	struct drm_framebuffer *pinned_fb;
-
 	uint32_t nformats;
 	uint32_t formats[32];
 
 	struct omap_drm_irq error_irq;
 };
 
-/* update which fb (if any) is pinned for scanout */
-static int omap_plane_update_pin(struct drm_plane *plane)
-{
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;
-	struct drm_framebuffer *fb = omap_plane->enabled ? plane->fb : NULL;
-	int ret = 0;
-
-	if (pinned_fb == fb)
-		return 0;
-
-	DBG("%p -> %p", pinned_fb, fb);
-
-	if (fb) {
-		drm_framebuffer_reference(fb);
-		ret = omap_framebuffer_pin(fb);
-	}
-
-	if (pinned_fb)
-		omap_crtc_queue_unpin(plane->crtc, pinned_fb);
-
-	if (ret) {
-		dev_err(plane->dev->dev, "could not swap %p -> %p\n",
-				omap_plane->pinned_fb, fb);
-		drm_framebuffer_unreference(fb);
-		omap_plane->pinned_fb = NULL;
-		return ret;
-	}
-
-	omap_plane->pinned_fb = fb;
-
-	return 0;
-}
-
 static int __omap_plane_setup(struct omap_plane *omap_plane,
 			      struct drm_crtc *crtc,
 			      struct drm_framebuffer *fb)
@@ -133,10 +96,6 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 	struct drm_plane *plane = &omap_plane->base;
 	int ret;
 
-	ret = omap_plane_update_pin(plane);
-	if (ret < 0)
-		return ret;
-
 	dispc_runtime_get();
 	ret = __omap_plane_setup(omap_plane, plane->crtc, plane->fb);
 	dispc_runtime_put();

commit fa16d26289a03c2cf5189a2693c5615644e56ec3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 16:01:53 2015 +0200

    drm: omapdrm: Switch page flip to atomic helpers
    
    The atomic page flip helper implements the page flip operation using
    asynchronous commits.
    
    As the legacy page flip was the last caller of omap_plane_mode_set(),
    remove the function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index fcc5d9603292..117fa37534b6 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -144,29 +144,6 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 	return ret;
 }
 
-int omap_plane_mode_set(struct drm_plane *plane,
-			struct drm_crtc *crtc, struct drm_framebuffer *fb,
-			int crtc_x, int crtc_y,
-			unsigned int crtc_w, unsigned int crtc_h,
-			unsigned int src_x, unsigned int src_y,
-			unsigned int src_w, unsigned int src_h)
-{
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-	struct omap_drm_window *win = &omap_plane->win;
-
-	win->crtc_x = crtc_x;
-	win->crtc_y = crtc_y;
-	win->crtc_w = crtc_w;
-	win->crtc_h = crtc_h;
-
-	win->src_x = src_x;
-	win->src_y = src_y;
-	win->src_w = src_w;
-	win->src_h = src_h;
-
-	return omap_plane_setup(omap_plane);
-}
-
 int omap_plane_set_enable(struct drm_plane *plane, bool enable)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);

commit cef77d40511b9466a8420a9c5cf92056f051cca8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:50:00 2015 +0200

    drm: omapdrm: Switch plane update to atomic helpers
    
    This removes the legacy plane update code. Wire up the default atomic
    check and atomic commit mode config helpers as needed by the plane
    update atomic helpers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 7587bac1b222..fcc5d9603292 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -316,8 +316,8 @@ int omap_plane_set_property(struct drm_plane *plane,
 }
 
 static const struct drm_plane_funcs omap_plane_funcs = {
-	.update_plane = drm_plane_helper_update,
-	.disable_plane = drm_plane_helper_disable,
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
 	.reset = drm_atomic_helper_plane_reset,
 	.destroy = omap_plane_destroy,
 	.set_property = omap_plane_set_property,

commit de8e41000136bf9a0ccf652fc364658f3210b6f4
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 13:39:56 2015 +0200

    drm: omapdrm: Implement planes atomic operations
    
    Implement the CRTC .atomic_begin() and .atomic_flush() operations, the
    plane .atomic_check(), .atomic_update() and operations, and use the
    transitional atomic helpers to implement the plane update and disable
    operations on top of the new atomic operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 533dcc15f03c..7587bac1b222 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -18,6 +18,7 @@
  */
 
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
 
 #include "omap_dmm_tiler.h"
 #include "omap_drv.h"
@@ -87,30 +88,23 @@ static int omap_plane_update_pin(struct drm_plane *plane)
 	return 0;
 }
 
-static int omap_plane_setup(struct omap_plane *omap_plane)
+static int __omap_plane_setup(struct omap_plane *omap_plane,
+			      struct drm_crtc *crtc,
+			      struct drm_framebuffer *fb)
 {
 	struct omap_overlay_info *info = &omap_plane->info;
-	struct drm_plane *plane = &omap_plane->base;
-	struct drm_device *dev = plane->dev;
-	struct drm_crtc *crtc = plane->crtc;
+	struct drm_device *dev = omap_plane->base.dev;
 	int ret;
 
 	DBG("%s, enabled=%d", omap_plane->name, omap_plane->enabled);
 
-	/* if fb has changed, pin new fb: */
-	ret = omap_plane_update_pin(plane);
-	if (ret)
-		return ret;
-
-	dispc_runtime_get();
-
 	if (!omap_plane->enabled) {
 		dispc_ovl_enable(omap_plane->id, false);
-		goto done;
+		return 0;
 	}
 
 	/* update scanout: */
-	omap_framebuffer_update_scanout(plane->fb, &omap_plane->win, info);
+	omap_framebuffer_update_scanout(fb, &omap_plane->win, info);
 
 	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
 			info->out_width, info->out_height,
@@ -126,13 +120,27 @@ static int omap_plane_setup(struct omap_plane *omap_plane)
 			      omap_crtc_timings(crtc), false);
 	if (ret) {
 		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
-		goto done;
+		return ret;
 	}
 
 	dispc_ovl_enable(omap_plane->id, true);
 
-done:
+	return 0;
+}
+
+static int omap_plane_setup(struct omap_plane *omap_plane)
+{
+	struct drm_plane *plane = &omap_plane->base;
+	int ret;
+
+	ret = omap_plane_update_pin(plane);
+	if (ret < 0)
+		return ret;
+
+	dispc_runtime_get();
+	ret = __omap_plane_setup(omap_plane, plane->crtc, plane->fb);
 	dispc_runtime_put();
+
 	return ret;
 }
 
@@ -170,45 +178,62 @@ int omap_plane_set_enable(struct drm_plane *plane, bool enable)
 	return omap_plane_setup(omap_plane);
 }
 
-static int omap_plane_update(struct drm_plane *plane,
-		struct drm_crtc *crtc, struct drm_framebuffer *fb,
-		int crtc_x, int crtc_y,
-		unsigned int crtc_w, unsigned int crtc_h,
-		uint32_t src_x, uint32_t src_y,
-		uint32_t src_w, uint32_t src_h)
+static int omap_plane_prepare_fb(struct drm_plane *plane,
+				 struct drm_framebuffer *fb,
+				 const struct drm_plane_state *new_state)
+{
+	return omap_framebuffer_pin(fb);
+}
+
+static void omap_plane_cleanup_fb(struct drm_plane *plane,
+				  struct drm_framebuffer *fb,
+				  const struct drm_plane_state *old_state)
+{
+	omap_framebuffer_unpin(fb);
+}
+
+static void omap_plane_atomic_update(struct drm_plane *plane,
+				     struct drm_plane_state *old_state)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
-	int ret;
+	struct omap_drm_window *win = &omap_plane->win;
+	struct drm_plane_state *state = plane->state;
+	uint32_t src_w;
+	uint32_t src_h;
 
-	omap_plane->enabled = true;
+	if (!state->fb || !state->crtc)
+		return;
 
-	/* omap_plane_mode_set() takes adjusted src */
+	/* omap_framebuffer_update_scanout() takes adjusted src */
 	switch (omap_plane->win.rotation & 0xf) {
 	case BIT(DRM_ROTATE_90):
 	case BIT(DRM_ROTATE_270):
-		swap(src_w, src_h);
+		src_w = state->src_h;
+		src_h = state->src_w;
+		break;
+	default:
+		src_w = state->src_w;
+		src_h = state->src_h;
 		break;
 	}
 
-	/*
-	 * We don't need to take a reference to the framebuffer as the DRM core
-	 * has already done so for the purpose of setting plane->fb.
-	 */
-	plane->fb = fb;
-	plane->crtc = crtc;
-
-	/* src values are in Q16 fixed point, convert to integer: */
-	ret = omap_plane_mode_set(plane, crtc, fb,
-				  crtc_x, crtc_y, crtc_w, crtc_h,
-				  src_x >> 16, src_y >> 16,
-				  src_w >> 16, src_h >> 16);
-	if (ret < 0)
-		return ret;
+	/* src values are in Q16 fixed point, convert to integer. */
+	win->crtc_x = state->crtc_x;
+	win->crtc_y = state->crtc_y;
+	win->crtc_w = state->crtc_w;
+	win->crtc_h = state->crtc_h;
 
-	return omap_crtc_flush(plane->crtc);
+	win->src_x = state->src_x >> 16;
+	win->src_y = state->src_y >> 16;
+	win->src_w = src_w >> 16;
+	win->src_h = src_h >> 16;
+
+	omap_plane->enabled = true;
+	__omap_plane_setup(omap_plane, state->crtc, state->fb);
 }
 
-static int omap_plane_disable(struct drm_plane *plane)
+static void omap_plane_atomic_disable(struct drm_plane *plane,
+				      struct drm_plane_state *old_state)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
@@ -217,15 +242,19 @@ static int omap_plane_disable(struct drm_plane *plane)
 				? 0 : omap_plane->id;
 
 	if (!omap_plane->enabled)
-		return 0;
+		return;
 
-	/* Disabling a plane never fails. */
 	omap_plane->enabled = false;
-	omap_plane_setup(omap_plane);
-
-	return omap_crtc_flush(plane->crtc);
+	__omap_plane_setup(omap_plane, NULL, NULL);
 }
 
+static const struct drm_plane_helper_funcs omap_plane_helper_funcs = {
+	.prepare_fb = omap_plane_prepare_fb,
+	.cleanup_fb = omap_plane_cleanup_fb,
+	.atomic_update = omap_plane_atomic_update,
+	.atomic_disable = omap_plane_atomic_disable,
+};
+
 static void omap_plane_destroy(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
@@ -287,8 +316,8 @@ int omap_plane_set_property(struct drm_plane *plane,
 }
 
 static const struct drm_plane_funcs omap_plane_funcs = {
-	.update_plane = omap_plane_update,
-	.disable_plane = omap_plane_disable,
+	.update_plane = drm_plane_helper_update,
+	.disable_plane = drm_plane_helper_disable,
 	.reset = drm_atomic_helper_plane_reset,
 	.destroy = omap_plane_destroy,
 	.set_property = omap_plane_set_property,
@@ -352,6 +381,8 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	if (ret < 0)
 		goto error;
 
+	drm_plane_helper_add(plane, &omap_plane_helper_funcs);
+
 	omap_plane_install_properties(plane, &plane->base);
 
 	/* get our starting configuration, set defaults for parameters

commit 69a12263f6f919cd53b10c849e1674e38931e74e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:38:16 2015 +0200

    drm: omapdrm: Wire up atomic state object scaffolding
    
    Hook up the default .reset(), .atomic_duplicate_state() and
    .atomic_free_state() helpers to ensure that state objects are properly
    created and destroyed, and call drm_mode_config_reset() at init time to
    create the initial state objects.
    
    Framebuffer reference count also gets maintained automatically by the
    transitional helpers except for the legacy page flip operation. Maintain
    it explicitly there.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 57d5b035d078..533dcc15f03c 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -17,6 +17,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <drm/drm_atomic_helper.h>
+
 #include "omap_dmm_tiler.h"
 #include "omap_drv.h"
 
@@ -287,8 +289,11 @@ int omap_plane_set_property(struct drm_plane *plane,
 static const struct drm_plane_funcs omap_plane_funcs = {
 	.update_plane = omap_plane_update,
 	.disable_plane = omap_plane_disable,
+	.reset = drm_atomic_helper_plane_reset,
 	.destroy = omap_plane_destroy,
 	.set_property = omap_plane_set_property,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
 };
 
 static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)

commit 2d278f5414ae9cd535a7bdefaba2e2de38e116c7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 21:31:37 2015 +0200

    drm: omapdrm: Clean up #include's
    
    Use the <...> include style instead of "..." for DRM headers and sort
    the headers alphabetically to ease detection of duplicates.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 99663ec011b7..57d5b035d078 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -17,8 +17,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "omap_drv.h"
 #include "omap_dmm_tiler.h"
+#include "omap_drv.h"
 
 /* some hackery because omapdss has an 'enum omap_plane' (which would be
  * better named omap_plane_id).. and compiler seems unhappy about having

commit a42133a780b368f9ed18045a4453f92292db4b18
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 19:09:26 2015 +0200

    drm: omapdrm: Apply settings synchronously
    
    The omapdrm driver implements a mechanism to apply new settings (due to
    plane update, plane disable, plane property set, CRTC mode set or CRTC
    DPMS) asynchronously. While this improves performance, it adds a level
    of complexity that makes transition to the atomic update API close to
    impossible. Furthermore the atomic update API requires part of the apply
    operations to be synchronous (such as pinning the framebuffers), so the
    current implementation needs to be changed.
    
    Simplify the CRTC and plane code by making updates synchronous to
    prepare for the switch to the atomic update API. Asynchronous update
    will be implemented in a second step.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index a1c9c08db345..99663ec011b7 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -17,8 +17,6 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "drm_flip_work.h"
-
 #include "omap_drv.h"
 #include "omap_dmm_tiler.h"
 
@@ -32,11 +30,6 @@
  * plane funcs
  */
 
-struct callback {
-	void (*fxn)(void *);
-	void *arg;
-};
-
 #define to_omap_plane(x) container_of(x, struct omap_plane, base)
 
 struct omap_plane {
@@ -44,7 +37,6 @@ struct omap_plane {
 	int id;  /* TODO rename omap_plane -> omap_plane_id in omapdss so I can use the enum */
 	const char *name;
 	struct omap_overlay_info info;
-	struct omap_drm_apply apply;
 
 	/* position/orientation of scanout within the fb: */
 	struct omap_drm_window win;
@@ -57,91 +49,66 @@ struct omap_plane {
 	uint32_t formats[32];
 
 	struct omap_drm_irq error_irq;
-
-	/* for deferring bo unpin's until next post_apply(): */
-	struct drm_flip_work unpin_work;
-
-	// XXX maybe get rid of this and handle vblank in crtc too?
-	struct callback apply_done_cb;
 };
 
-static void omap_plane_unpin_worker(struct drm_flip_work *work, void *val)
-{
-	struct omap_plane *omap_plane =
-			container_of(work, struct omap_plane, unpin_work);
-	struct drm_device *dev = omap_plane->base.dev;
-
-	/*
-	 * omap_framebuffer_pin/unpin are always called from priv->wq,
-	 * so there's no need for locking here.
-	 */
-	omap_framebuffer_unpin(val);
-	mutex_lock(&dev->mode_config.mutex);
-	drm_framebuffer_unreference(val);
-	mutex_unlock(&dev->mode_config.mutex);
-}
-
 /* update which fb (if any) is pinned for scanout */
-static int omap_plane_update_pin(struct drm_plane *plane,
-				 struct drm_framebuffer *fb)
+static int omap_plane_update_pin(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;
+	struct drm_framebuffer *fb = omap_plane->enabled ? plane->fb : NULL;
+	int ret = 0;
 
-	if (pinned_fb != fb) {
-		int ret = 0;
-
-		DBG("%p -> %p", pinned_fb, fb);
+	if (pinned_fb == fb)
+		return 0;
 
-		if (fb) {
-			drm_framebuffer_reference(fb);
-			ret = omap_framebuffer_pin(fb);
-		}
+	DBG("%p -> %p", pinned_fb, fb);
 
-		if (pinned_fb)
-			drm_flip_work_queue(&omap_plane->unpin_work, pinned_fb);
+	if (fb) {
+		drm_framebuffer_reference(fb);
+		ret = omap_framebuffer_pin(fb);
+	}
 
-		if (ret) {
-			dev_err(plane->dev->dev, "could not swap %p -> %p\n",
-					omap_plane->pinned_fb, fb);
-			drm_framebuffer_unreference(fb);
-			omap_plane->pinned_fb = NULL;
-			return ret;
-		}
+	if (pinned_fb)
+		omap_crtc_queue_unpin(plane->crtc, pinned_fb);
 
-		omap_plane->pinned_fb = fb;
+	if (ret) {
+		dev_err(plane->dev->dev, "could not swap %p -> %p\n",
+				omap_plane->pinned_fb, fb);
+		drm_framebuffer_unreference(fb);
+		omap_plane->pinned_fb = NULL;
+		return ret;
 	}
 
+	omap_plane->pinned_fb = fb;
+
 	return 0;
 }
 
-static void omap_plane_pre_apply(struct omap_drm_apply *apply)
+static int omap_plane_setup(struct omap_plane *omap_plane)
 {
-	struct omap_plane *omap_plane =
-			container_of(apply, struct omap_plane, apply);
-	struct omap_drm_window *win = &omap_plane->win;
+	struct omap_overlay_info *info = &omap_plane->info;
 	struct drm_plane *plane = &omap_plane->base;
 	struct drm_device *dev = plane->dev;
-	struct omap_overlay_info *info = &omap_plane->info;
 	struct drm_crtc *crtc = plane->crtc;
-	enum omap_channel channel;
-	bool enabled = omap_plane->enabled && crtc;
 	int ret;
 
-	DBG("%s, enabled=%d", omap_plane->name, enabled);
+	DBG("%s, enabled=%d", omap_plane->name, omap_plane->enabled);
 
 	/* if fb has changed, pin new fb: */
-	omap_plane_update_pin(plane, enabled ? plane->fb : NULL);
+	ret = omap_plane_update_pin(plane);
+	if (ret)
+		return ret;
+
+	dispc_runtime_get();
 
-	if (!enabled) {
+	if (!omap_plane->enabled) {
 		dispc_ovl_enable(omap_plane->id, false);
-		return;
+		goto done;
 	}
 
-	channel = omap_crtc_channel(crtc);
-
 	/* update scanout: */
-	omap_framebuffer_update_scanout(plane->fb, win, info);
+	omap_framebuffer_update_scanout(plane->fb, &omap_plane->win, info);
 
 	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
 			info->out_width, info->out_height,
@@ -149,43 +116,22 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	DBG("%d,%d %pad %pad", info->pos_x, info->pos_y,
 			&info->paddr, &info->p_uv_addr);
 
-	dispc_ovl_set_channel_out(omap_plane->id, channel);
+	dispc_ovl_set_channel_out(omap_plane->id,
+				  omap_crtc_channel(crtc));
 
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, info, false,
 			      omap_crtc_timings(crtc), false);
 	if (ret) {
 		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
-		return;
+		goto done;
 	}
 
 	dispc_ovl_enable(omap_plane->id, true);
-}
-
-static void omap_plane_post_apply(struct omap_drm_apply *apply)
-{
-	struct omap_plane *omap_plane =
-			container_of(apply, struct omap_plane, apply);
-	struct drm_plane *plane = &omap_plane->base;
-	struct omap_drm_private *priv = plane->dev->dev_private;
-	struct callback cb;
-
-	cb = omap_plane->apply_done_cb;
-	omap_plane->apply_done_cb.fxn = NULL;
-
-	drm_flip_work_commit(&omap_plane->unpin_work, priv->wq);
-
-	if (cb.fxn)
-		cb.fxn(cb.arg);
-}
 
-static int omap_plane_apply(struct drm_plane *plane)
-{
-	if (plane->crtc) {
-		struct omap_plane *omap_plane = to_omap_plane(plane);
-		return omap_crtc_apply(plane->crtc, &omap_plane->apply);
-	}
-	return 0;
+done:
+	dispc_runtime_put();
+	return ret;
 }
 
 int omap_plane_mode_set(struct drm_plane *plane,
@@ -193,8 +139,7 @@ int omap_plane_mode_set(struct drm_plane *plane,
 			int crtc_x, int crtc_y,
 			unsigned int crtc_w, unsigned int crtc_h,
 			unsigned int src_x, unsigned int src_y,
-			unsigned int src_w, unsigned int src_h,
-			void (*fxn)(void *), void *arg)
+			unsigned int src_w, unsigned int src_h)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct omap_drm_window *win = &omap_plane->win;
@@ -209,17 +154,18 @@ int omap_plane_mode_set(struct drm_plane *plane,
 	win->src_w = src_w;
 	win->src_h = src_h;
 
-	if (fxn) {
-		/* omap_crtc should ensure that a new page flip
-		 * isn't permitted while there is one pending:
-		 */
-		BUG_ON(omap_plane->apply_done_cb.fxn);
+	return omap_plane_setup(omap_plane);
+}
 
-		omap_plane->apply_done_cb.fxn = fxn;
-		omap_plane->apply_done_cb.arg = arg;
-	}
+int omap_plane_set_enable(struct drm_plane *plane, bool enable)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
 
-	return omap_plane_apply(plane);
+	if (enable == omap_plane->enabled)
+		return 0;
+
+	omap_plane->enabled = enable;
+	return omap_plane_setup(omap_plane);
 }
 
 static int omap_plane_update(struct drm_plane *plane,
@@ -230,6 +176,8 @@ static int omap_plane_update(struct drm_plane *plane,
 		uint32_t src_w, uint32_t src_h)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
+	int ret;
+
 	omap_plane->enabled = true;
 
 	/* omap_plane_mode_set() takes adjusted src */
@@ -248,10 +196,14 @@ static int omap_plane_update(struct drm_plane *plane,
 	plane->crtc = crtc;
 
 	/* src values are in Q16 fixed point, convert to integer: */
-	return omap_plane_mode_set(plane, crtc, fb,
-			crtc_x, crtc_y, crtc_w, crtc_h,
-			src_x >> 16, src_y >> 16, src_w >> 16, src_h >> 16,
-			NULL, NULL);
+	ret = omap_plane_mode_set(plane, crtc, fb,
+				  crtc_x, crtc_y, crtc_w, crtc_h,
+				  src_x >> 16, src_y >> 16,
+				  src_w >> 16, src_h >> 16);
+	if (ret < 0)
+		return ret;
+
+	return omap_crtc_flush(plane->crtc);
 }
 
 static int omap_plane_disable(struct drm_plane *plane)
@@ -262,7 +214,14 @@ static int omap_plane_disable(struct drm_plane *plane)
 	omap_plane->info.zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
 				? 0 : omap_plane->id;
 
-	return omap_plane_set_enable(plane, false);
+	if (!omap_plane->enabled)
+		return 0;
+
+	/* Disabling a plane never fails. */
+	omap_plane->enabled = false;
+	omap_plane_setup(omap_plane);
+
+	return omap_crtc_flush(plane->crtc);
 }
 
 static void omap_plane_destroy(struct drm_plane *plane)
@@ -275,22 +234,9 @@ static void omap_plane_destroy(struct drm_plane *plane)
 
 	drm_plane_cleanup(plane);
 
-	drm_flip_work_cleanup(&omap_plane->unpin_work);
-
 	kfree(omap_plane);
 }
 
-int omap_plane_set_enable(struct drm_plane *plane, bool enable)
-{
-	struct omap_plane *omap_plane = to_omap_plane(plane);
-
-	if (enable == omap_plane->enabled)
-		return 0;
-
-	omap_plane->enabled = enable;
-	return omap_plane_apply(plane);
-}
-
 /* helper to install properties which are common to planes and crtcs */
 void omap_plane_install_properties(struct drm_plane *plane,
 		struct drm_mode_object *obj)
@@ -312,19 +258,30 @@ int omap_plane_set_property(struct drm_plane *plane,
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	int ret = -EINVAL;
+	int ret;
 
 	if (property == plane->dev->mode_config.rotation_property) {
 		DBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);
 		omap_plane->win.rotation = val;
-		ret = omap_plane_apply(plane);
 	} else if (property == priv->zorder_prop) {
 		DBG("%s: zorder: %02x", omap_plane->name, (uint32_t)val);
 		omap_plane->info.zorder = val;
-		ret = omap_plane_apply(plane);
+	} else {
+		return -EINVAL;
 	}
 
-	return ret;
+	/*
+	 * We're done if the plane is disabled, properties will be applied the
+	 * next time it becomes enabled.
+	 */
+	if (!omap_plane->enabled)
+		return 0;
+
+	ret = omap_plane_setup(omap_plane);
+	if (ret < 0)
+		return ret;
+
+	return omap_crtc_flush(plane->crtc);
 }
 
 static const struct drm_plane_funcs omap_plane_funcs = {
@@ -372,9 +329,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	if (!omap_plane)
 		return ERR_PTR(-ENOMEM);
 
-	drm_flip_work_init(&omap_plane->unpin_work,
-			"unpin", omap_plane_unpin_worker);
-
 	omap_plane->nformats = omap_framebuffer_get_formats(
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
 			dss_feat_get_supported_color_modes(id));
@@ -383,9 +337,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	plane = &omap_plane->base;
 
-	omap_plane->apply.pre_apply  = omap_plane_pre_apply;
-	omap_plane->apply.post_apply = omap_plane_post_apply;
-
 	omap_plane->error_irq.irqmask = error_irqs[id];
 	omap_plane->error_irq.irq = omap_plane_error_irq;
 	omap_irq_register(dev, &omap_plane->error_irq);

commit e2cd09b202c5d32804f72bc28a9ed5a7d8a34452
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Mar 6 17:16:43 2015 +0200

    drm: omapdrm: Store the rotation property in dev->mode_config
    
    Rotation is a standard property, store it in
    dev->mode_config.rotation_property. While at it, extract the properties
    initialization code to a separate function instead of running it for
    every plane.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 1c6b63f39474..a1c9c08db345 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -297,33 +297,14 @@ void omap_plane_install_properties(struct drm_plane *plane,
 {
 	struct drm_device *dev = plane->dev;
 	struct omap_drm_private *priv = dev->dev_private;
-	struct drm_property *prop;
 
 	if (priv->has_dmm) {
-		prop = priv->rotation_prop;
-		if (!prop) {
-			prop = drm_mode_create_rotation_property(dev,
-								 BIT(DRM_ROTATE_0) |
-								 BIT(DRM_ROTATE_90) |
-								 BIT(DRM_ROTATE_180) |
-								 BIT(DRM_ROTATE_270) |
-								 BIT(DRM_REFLECT_X) |
-								 BIT(DRM_REFLECT_Y));
-			if (prop == NULL)
-				return;
-			priv->rotation_prop = prop;
-		}
+		struct drm_property *prop = dev->mode_config.rotation_property;
+
 		drm_object_attach_property(obj, prop, 0);
 	}
 
-	prop = priv->zorder_prop;
-	if (!prop) {
-		prop = drm_property_create_range(dev, 0, "zorder", 0, 3);
-		if (prop == NULL)
-			return;
-		priv->zorder_prop = prop;
-	}
-	drm_object_attach_property(obj, prop, 0);
+	drm_object_attach_property(obj, priv->zorder_prop, 0);
 }
 
 int omap_plane_set_property(struct drm_plane *plane,
@@ -333,7 +314,7 @@ int omap_plane_set_property(struct drm_plane *plane,
 	struct omap_drm_private *priv = plane->dev->dev_private;
 	int ret = -EINVAL;
 
-	if (property == priv->rotation_prop) {
+	if (property == plane->dev->mode_config.rotation_property) {
 		DBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);
 		omap_plane->win.rotation = val;
 		ret = omap_plane_apply(plane);

commit 3b143fc80c077be54f8f7859d00f2db79250c884
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Nov 19 12:50:13 2014 +0200

    drm/omap: use DRM_ERROR_RATELIMITED() for error irqs
    
    omapdrm uses normal DRM_ERROR() print when the HW reports an error. As
    we sometimes may get a flood of errors, let's rather use
    DRM_ERROR_RATELIMITED().
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d52ff0455673..1c6b63f39474 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -357,7 +357,8 @@ static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 {
 	struct omap_plane *omap_plane =
 			container_of(irq, struct omap_plane, error_irq);
-	DRM_ERROR("%s: errors: %08x\n", omap_plane->name, irqstatus);
+	DRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_plane->name,
+		irqstatus);
 }
 
 static const char *plane_names[] = {

commit 2dd3887b503c1cc8a61ef4a4f24462ce03f3ada5
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Fri Oct 3 15:14:08 2014 +0000

    drm/omap: fix plane's channel selection
    
    omap_plane_pre_apply() sets the plane's output channel too late, only
    after the plane has already been otherwise configured and enabled. This
    causes problems, as at the configuration stage we need to make decisions
    based on the output channel.
    
    This may lead to bad plane settings or failing to setup the plane.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 6eedca107376..d52ff0455673 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -149,6 +149,8 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	DBG("%d,%d %pad %pad", info->pos_x, info->pos_y,
 			&info->paddr, &info->p_uv_addr);
 
+	dispc_ovl_set_channel_out(omap_plane->id, channel);
+
 	/* and finally, update omapdss: */
 	ret = dispc_ovl_setup(omap_plane->id, info, false,
 			      omap_crtc_timings(crtc), false);
@@ -158,7 +160,6 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	}
 
 	dispc_ovl_enable(omap_plane->id, true);
-	dispc_ovl_set_channel_out(omap_plane->id, channel);
 }
 
 static void omap_plane_post_apply(struct omap_drm_apply *apply)

commit f7c5f5d9e25dc524f1cdc6cf821400ac29dae486
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Sep 3 19:25:57 2014 +0000

    drm/omap: add a comment why locking is missing
    
    unpin_worker() calls omap_framebuffer_unpin() without any locks, which
    looks very suspicious. However, both pin and unpin are always called via
    the driver's private workqueue, so the access is synchronized that way.
    
    Add a comment to make this clear.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index e03512c86bf8..6eedca107376 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -71,6 +71,10 @@ static void omap_plane_unpin_worker(struct drm_flip_work *work, void *val)
 			container_of(work, struct omap_plane, unpin_work);
 	struct drm_device *dev = omap_plane->base.dev;
 
+	/*
+	 * omap_framebuffer_pin/unpin are always called from priv->wq,
+	 * so there's no need for locking here.
+	 */
 	omap_framebuffer_unpin(val);
 	mutex_lock(&dev->mode_config.mutex);
 	drm_framebuffer_unreference(val);

commit 87bb2ef15b0fbb91e9ea2d56ef5100e47439e11d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 23:12:38 2015 +0200

    drm: omapdrm: Planes are already disabled when destroyed
    
    Planes are destroyed after framebuffers, which has the side effect of
    disabling all planes. There is thus no need to disable planes explicitly
    when destroying them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 29f4371e9e00..e03512c86bf8 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -268,7 +268,6 @@ static void omap_plane_destroy(struct drm_plane *plane)
 
 	omap_irq_unregister(plane->dev, &omap_plane->error_irq);
 
-	omap_plane_disable(plane);
 	drm_plane_cleanup(plane);
 
 	drm_flip_work_cleanup(&omap_plane->unpin_work);

commit a350da8be4d91e733ec8cb225e5edefa8b085167
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 22:31:42 2015 +0200

    drm: omapdrm: Pass integer source coordinates to omap_plane_mode_set()
    
    The function will convert the Q16 source coordinates to integers, avoid
    converting integers to Q16 first and perform the opposite conversion.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 309a2246b6e0..29f4371e9e00 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -184,12 +184,12 @@ static int omap_plane_apply(struct drm_plane *plane)
 }
 
 int omap_plane_mode_set(struct drm_plane *plane,
-		struct drm_crtc *crtc, struct drm_framebuffer *fb,
-		int crtc_x, int crtc_y,
-		unsigned int crtc_w, unsigned int crtc_h,
-		uint32_t src_x, uint32_t src_y,
-		uint32_t src_w, uint32_t src_h,
-		void (*fxn)(void *), void *arg)
+			struct drm_crtc *crtc, struct drm_framebuffer *fb,
+			int crtc_x, int crtc_y,
+			unsigned int crtc_w, unsigned int crtc_h,
+			unsigned int src_x, unsigned int src_y,
+			unsigned int src_w, unsigned int src_h,
+			void (*fxn)(void *), void *arg)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct omap_drm_window *win = &omap_plane->win;
@@ -199,11 +199,10 @@ int omap_plane_mode_set(struct drm_plane *plane,
 	win->crtc_w = crtc_w;
 	win->crtc_h = crtc_h;
 
-	/* src values are in Q16 fixed point, convert to integer: */
-	win->src_x = src_x >> 16;
-	win->src_y = src_y >> 16;
-	win->src_w = src_w >> 16;
-	win->src_h = src_h >> 16;
+	win->src_x = src_x;
+	win->src_y = src_y;
+	win->src_w = src_w;
+	win->src_h = src_h;
 
 	if (fxn) {
 		/* omap_crtc should ensure that a new page flip
@@ -243,9 +242,10 @@ static int omap_plane_update(struct drm_plane *plane,
 	plane->fb = fb;
 	plane->crtc = crtc;
 
+	/* src values are in Q16 fixed point, convert to integer: */
 	return omap_plane_mode_set(plane, crtc, fb,
 			crtc_x, crtc_y, crtc_w, crtc_h,
-			src_x, src_y, src_w, src_h,
+			src_x >> 16, src_y >> 16, src_w >> 16, src_h >> 16,
 			NULL, NULL);
 }
 

commit 2a438c5b4e398e42cdc8aa2d16badc6fbcf8aeb5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Jan 17 18:50:10 2015 +0200

    drm: omapdrm: Prefix all plane functions with omap_plane_
    
    This matches the rest of the file and clarifies the functions' purpose.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 2111d415da96..309a2246b6e0 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -65,7 +65,7 @@ struct omap_plane {
 	struct callback apply_done_cb;
 };
 
-static void unpin_worker(struct drm_flip_work *work, void *val)
+static void omap_plane_unpin_worker(struct drm_flip_work *work, void *val)
 {
 	struct omap_plane *omap_plane =
 			container_of(work, struct omap_plane, unpin_work);
@@ -78,7 +78,8 @@ static void unpin_worker(struct drm_flip_work *work, void *val)
 }
 
 /* update which fb (if any) is pinned for scanout */
-static int update_pin(struct drm_plane *plane, struct drm_framebuffer *fb)
+static int omap_plane_update_pin(struct drm_plane *plane,
+				 struct drm_framebuffer *fb)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	struct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;
@@ -126,7 +127,7 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	DBG("%s, enabled=%d", omap_plane->name, enabled);
 
 	/* if fb has changed, pin new fb: */
-	update_pin(plane, enabled ? plane->fb : NULL);
+	omap_plane_update_pin(plane, enabled ? plane->fb : NULL);
 
 	if (!enabled) {
 		dispc_ovl_enable(omap_plane->id, false);
@@ -173,7 +174,7 @@ static void omap_plane_post_apply(struct omap_drm_apply *apply)
 		cb.fxn(cb.arg);
 }
 
-static int apply(struct drm_plane *plane)
+static int omap_plane_apply(struct drm_plane *plane)
 {
 	if (plane->crtc) {
 		struct omap_plane *omap_plane = to_omap_plane(plane);
@@ -214,7 +215,7 @@ int omap_plane_mode_set(struct drm_plane *plane,
 		omap_plane->apply_done_cb.arg = arg;
 	}
 
-	return apply(plane);
+	return omap_plane_apply(plane);
 }
 
 static int omap_plane_update(struct drm_plane *plane,
@@ -283,7 +284,7 @@ int omap_plane_set_enable(struct drm_plane *plane, bool enable)
 		return 0;
 
 	omap_plane->enabled = enable;
-	return apply(plane);
+	return omap_plane_apply(plane);
 }
 
 /* helper to install properties which are common to planes and crtcs */
@@ -331,11 +332,11 @@ int omap_plane_set_property(struct drm_plane *plane,
 	if (property == priv->rotation_prop) {
 		DBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);
 		omap_plane->win.rotation = val;
-		ret = apply(plane);
+		ret = omap_plane_apply(plane);
 	} else if (property == priv->zorder_prop) {
 		DBG("%s: zorder: %02x", omap_plane->name, (uint32_t)val);
 		omap_plane->info.zorder = val;
-		ret = apply(plane);
+		ret = omap_plane_apply(plane);
 	}
 
 	return ret;
@@ -386,7 +387,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 		return ERR_PTR(-ENOMEM);
 
 	drm_flip_work_init(&omap_plane->unpin_work,
-			"unpin", unpin_worker);
+			"unpin", omap_plane_unpin_worker);
 
 	omap_plane->nformats = omap_framebuffer_get_formats(
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),

commit 5a35876e2830511cb8110667fc426c6a6165a593
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jan 14 17:54:40 2015 +0200

    drm: omapdrm: Remove manual update display support
    
    All the manual update display code implements eventually ends up to just
    calls to omap_connector_flush(), currently implemented as an empty TODO
    stub. Remove it, the code can always be revived and implemented later if
    interest in manual update displays becomes a reality.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index efec4265c2ae..2111d415da96 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -162,7 +162,6 @@ static void omap_plane_post_apply(struct omap_drm_apply *apply)
 			container_of(apply, struct omap_plane, apply);
 	struct drm_plane *plane = &omap_plane->base;
 	struct omap_drm_private *priv = plane->dev->dev_private;
-	struct omap_overlay_info *info = &omap_plane->info;
 	struct callback cb;
 
 	cb = omap_plane->apply_done_cb;
@@ -172,11 +171,6 @@ static void omap_plane_post_apply(struct omap_drm_apply *apply)
 
 	if (cb.fxn)
 		cb.fxn(cb.arg);
-
-	if (omap_plane->enabled) {
-		omap_framebuffer_flush(plane->fb, info->pos_x, info->pos_y,
-				info->out_width, info->out_height);
-	}
 }
 
 static int apply(struct drm_plane *plane)

commit 82e58855bc4f8442145cb2037e164a4b1f5cf854
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 12 23:56:57 2015 +0200

    drm: omapdrm: Reset the zorder property when disabling a plane
    
    Whether to reset plane properties at disable time isn't well-defined in
    DRM, but resetting only part of them is probably as bad as it can get.
    Make the behaviour coherent by resetting the zorder property in addition
    to the rotation property.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 34f5cca5a6c5..efec4265c2ae 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -259,6 +259,9 @@ static int omap_plane_disable(struct drm_plane *plane)
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 
 	omap_plane->win.rotation = BIT(DRM_ROTATE_0);
+	omap_plane->info.zorder = plane->type == DRM_PLANE_TYPE_PRIMARY
+				? 0 : omap_plane->id;
+
 	return omap_plane_set_enable(plane, false);
 }
 

commit 2debab97a515374c01d50068de00c95f9befd260
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 12 22:38:16 2015 +0200

    drm: omapdrm: Rename omap_plane_dpms() to omap_plane_set_enable()
    
    The planes don't care about DPMS states, don't propagate it
    unnecessarily to the plane functions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 32df3e783128..34f5cca5a6c5 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -257,8 +257,9 @@ static int omap_plane_update(struct drm_plane *plane,
 static int omap_plane_disable(struct drm_plane *plane)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
+
 	omap_plane->win.rotation = BIT(DRM_ROTATE_0);
-	return omap_plane_dpms(plane, DRM_MODE_DPMS_OFF);
+	return omap_plane_set_enable(plane, false);
 }
 
 static void omap_plane_destroy(struct drm_plane *plane)
@@ -277,18 +278,15 @@ static void omap_plane_destroy(struct drm_plane *plane)
 	kfree(omap_plane);
 }
 
-int omap_plane_dpms(struct drm_plane *plane, int mode)
+int omap_plane_set_enable(struct drm_plane *plane, bool enable)
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
-	bool enabled = (mode == DRM_MODE_DPMS_ON);
-	int ret = 0;
 
-	if (enabled != omap_plane->enabled) {
-		omap_plane->enabled = enabled;
-		ret = apply(plane);
-	}
+	if (enable == omap_plane->enabled)
+		return 0;
 
-	return ret;
+	omap_plane->enabled = enable;
+	return apply(plane);
 }
 
 /* helper to install properties which are common to planes and crtcs */

commit ef6b0e0275387f79e6ad848d61dfcb1a4f962fc7
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 11 00:11:18 2015 +0200

    drm: omapdrm: Switch to the universal plane API
    
    Remove the CRTC private planes by switching to the universal plane API.
    This results in a merge of the CRTC private plane created by the driver
    (omap_crtc->plane) and the CRTC primary plane created by the DRM core
    (crtc->primary).
    
    Reference counting of the framebuffers in the update plane operation is
    thus simplified as no reference needs to be stored in the private plane
    anymore.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index c17460336fcc..32df3e783128 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -220,14 +220,6 @@ int omap_plane_mode_set(struct drm_plane *plane,
 		omap_plane->apply_done_cb.arg = arg;
 	}
 
-	if (plane->fb)
-		drm_framebuffer_unreference(plane->fb);
-
-	drm_framebuffer_reference(fb);
-
-	plane->fb = fb;
-	plane->crtc = crtc;
-
 	return apply(plane);
 }
 
@@ -249,6 +241,13 @@ static int omap_plane_update(struct drm_plane *plane,
 		break;
 	}
 
+	/*
+	 * We don't need to take a reference to the framebuffer as the DRM core
+	 * has already done so for the purpose of setting plane->fb.
+	 */
+	plane->fb = fb;
+	plane->crtc = crtc;
+
 	return omap_plane_mode_set(plane, crtc, fb,
 			crtc_x, crtc_y, crtc_w, crtc_h,
 			src_x, src_y, src_w, src_h,
@@ -377,14 +376,15 @@ static const uint32_t error_irqs[] = {
 
 /* initialize plane */
 struct drm_plane *omap_plane_init(struct drm_device *dev,
-		int id, bool private_plane)
+		int id, enum drm_plane_type type)
 {
 	struct omap_drm_private *priv = dev->dev_private;
-	struct drm_plane *plane = NULL;
+	struct drm_plane *plane;
 	struct omap_plane *omap_plane;
 	struct omap_overlay_info *info;
+	int ret;
 
-	DBG("%s: priv=%d", plane_names[id], private_plane);
+	DBG("%s: type=%d", plane_names[id], type);
 
 	omap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);
 	if (!omap_plane)
@@ -408,8 +408,11 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	omap_plane->error_irq.irq = omap_plane_error_irq;
 	omap_irq_register(dev, &omap_plane->error_irq);
 
-	drm_plane_init(dev, plane, (1 << priv->num_crtcs) - 1, &omap_plane_funcs,
-			omap_plane->formats, omap_plane->nformats, private_plane);
+	ret = drm_universal_plane_init(dev, plane, (1 << priv->num_crtcs) - 1,
+				       &omap_plane_funcs, omap_plane->formats,
+				       omap_plane->nformats, type);
+	if (ret < 0)
+		goto error;
 
 	omap_plane_install_properties(plane, &plane->base);
 
@@ -427,10 +430,15 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	 * TODO add ioctl to give userspace an API to change this.. this
 	 * will come in a subsequent patch.
 	 */
-	if (private_plane)
+	if (type == DRM_PLANE_TYPE_PRIMARY)
 		omap_plane->info.zorder = 0;
 	else
 		omap_plane->info.zorder = id;
 
 	return plane;
+
+error:
+	omap_irq_unregister(plane->dev, &omap_plane->error_irq);
+	kfree(omap_plane);
+	return NULL;
 }

commit 9c660b7ceb0f104c72c4857e9c3619819d387f1d
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Jan 12 16:44:03 2015 +0200

    drm: omapdrm: Remove unused variables
    
    The ilace variable is unused and the replication variable is assigned to
    false and just passed to a function. Remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 056ded8280f8..c17460336fcc 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -121,7 +121,6 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	struct drm_crtc *crtc = plane->crtc;
 	enum omap_channel channel;
 	bool enabled = omap_plane->enabled && crtc;
-	bool ilace, replication;
 	int ret;
 
 	DBG("%s, enabled=%d", omap_plane->name, enabled);
@@ -145,13 +144,9 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	DBG("%d,%d %pad %pad", info->pos_x, info->pos_y,
 			&info->paddr, &info->p_uv_addr);
 
-	/* TODO: */
-	ilace = false;
-	replication = false;
-
 	/* and finally, update omapdss: */
-	ret = dispc_ovl_setup(omap_plane->id, info,
-			replication, omap_crtc_timings(crtc), false);
+	ret = dispc_ovl_setup(omap_plane->id, info, false,
+			      omap_crtc_timings(crtc), false);
 	if (ret) {
 		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
 		return;

commit fb9a35f89fac2ca97597ce212439d2997f2caf7e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 11 16:30:44 2015 +0200

    drm: omapdrm: Refactor CRTC creation code
    
    Create a omap_modeset_create_crtc() function to avoid duplicating plane
    and CRTC creation code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index a418fa7e5d0e..056ded8280f8 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -393,7 +393,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);
 	if (!omap_plane)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	drm_flip_work_init(&omap_plane->unpin_work,
 			"unpin", unpin_worker);

commit 222025e42d7f77133b8c3a2355d20a6004096c4b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Jan 11 00:02:07 2015 +0200

    drm: omapdrm: Fix indentation of structure and array initializers
    
    Indenting by one tab is enough.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index ee8e2b3a117e..a418fa7e5d0e 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -353,10 +353,10 @@ int omap_plane_set_property(struct drm_plane *plane,
 }
 
 static const struct drm_plane_funcs omap_plane_funcs = {
-		.update_plane = omap_plane_update,
-		.disable_plane = omap_plane_disable,
-		.destroy = omap_plane_destroy,
-		.set_property = omap_plane_set_property,
+	.update_plane = omap_plane_update,
+	.disable_plane = omap_plane_disable,
+	.destroy = omap_plane_destroy,
+	.set_property = omap_plane_set_property,
 };
 
 static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
@@ -367,17 +367,17 @@ static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 }
 
 static const char *plane_names[] = {
-		[OMAP_DSS_GFX] = "gfx",
-		[OMAP_DSS_VIDEO1] = "vid1",
-		[OMAP_DSS_VIDEO2] = "vid2",
-		[OMAP_DSS_VIDEO3] = "vid3",
+	[OMAP_DSS_GFX] = "gfx",
+	[OMAP_DSS_VIDEO1] = "vid1",
+	[OMAP_DSS_VIDEO2] = "vid2",
+	[OMAP_DSS_VIDEO3] = "vid3",
 };
 
 static const uint32_t error_irqs[] = {
-		[OMAP_DSS_GFX] = DISPC_IRQ_GFX_FIFO_UNDERFLOW,
-		[OMAP_DSS_VIDEO1] = DISPC_IRQ_VID1_FIFO_UNDERFLOW,
-		[OMAP_DSS_VIDEO2] = DISPC_IRQ_VID2_FIFO_UNDERFLOW,
-		[OMAP_DSS_VIDEO3] = DISPC_IRQ_VID3_FIFO_UNDERFLOW,
+	[OMAP_DSS_GFX] = DISPC_IRQ_GFX_FIFO_UNDERFLOW,
+	[OMAP_DSS_VIDEO1] = DISPC_IRQ_VID1_FIFO_UNDERFLOW,
+	[OMAP_DSS_VIDEO2] = DISPC_IRQ_VID2_FIFO_UNDERFLOW,
+	[OMAP_DSS_VIDEO3] = DISPC_IRQ_VID3_FIFO_UNDERFLOW,
 };
 
 /* initialize plane */

commit aeb24cc0a31646eb9233a05834440fdf16a713bd
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Nov 17 11:21:08 2014 +0100

    drm: omapdrm: remove unused variable
    
    Commit f9b9faf6d94dd29eab8c128905c7d091f955481d "drm: flip-work: change
    drm_flip_work_init prototype" changed the drm_flip_work_init prototype
    to a void function, which makes 'ret' an unused variable.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 0ad740132ac3..ee8e2b3a117e 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -388,7 +388,6 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	struct drm_plane *plane = NULL;
 	struct omap_plane *omap_plane;
 	struct omap_overlay_info *info;
-	int ret;
 
 	DBG("%s: priv=%d", plane_names[id], private_plane);
 

commit d7f8db5300d1f50b5631796086dbd4efc5b5d707
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Fri Nov 14 19:30:30 2014 +0100

    drm: flip-work: change drm_flip_work_init prototype
    
    Now that we're using lists instead of kfifo to store drm flip-work tasks
    we do not need the size parameter passed to drm_flip_work_init function
    anymore.
    Moreover this function cannot fail anymore, we can thus remove the return
    code.
    
    Modify drm_flip_work_init users to take account of these changes.
    
    [airlied: fixed two unused variable warnings]
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 891a4dc608af..0ad740132ac3 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -394,14 +394,10 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 
 	omap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);
 	if (!omap_plane)
-		goto fail;
+		return NULL;
 
-	ret = drm_flip_work_init(&omap_plane->unpin_work, 16,
+	drm_flip_work_init(&omap_plane->unpin_work,
 			"unpin", unpin_worker);
-	if (ret) {
-		dev_err(dev->dev, "could not allocate unpin FIFO\n");
-		goto fail;
-	}
 
 	omap_plane->nformats = omap_framebuffer_get_formats(
 			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
@@ -443,10 +439,4 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 		omap_plane->info.zorder = id;
 
 	return plane;
-
-fail:
-	if (plane)
-		omap_plane_destroy(plane);
-
-	return NULL;
 }

commit 4dac3edfe68e5e1b3c2216b84ba160572420fa40
Merge: 487777673e35 e05444be705b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 29 20:49:36 2014 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    Pull in drm-next with Dave's DP MST support so that I can merge some
    conflicting patches which also touch the driver load sequencing around
    interrupt handling.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 2d31ca3ad7d5d44c8adc7f253c96ce33f3a2e931
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 12 10:53:41 2014 +0100

    drm: omapdrm: fix compiler errors
    
    Regular randconfig nightly testing has detected problems with omapdrm.
    
    omapdrm fails to build when the kernel is built to support 64-bit DMA
    addresses and/or 64-bit physical addresses due to an assumption about
    the width of these types.
    
    Use %pad to print DMA addresses, rather than %x or %Zx (which is even
    more wrong than %x).  Avoid passing a uint32_t pointer into a function
    which expects dma_addr_t pointer.
    
    drivers/gpu/drm/omapdrm/omap_plane.c: In function 'omap_plane_pre_apply':
    drivers/gpu/drm/omapdrm/omap_plane.c:145:2: error: format '%x' expects argument of type 'unsigned int', but argument 5 has type 'dma_addr_t' [-Werror=format]
    drivers/gpu/drm/omapdrm/omap_plane.c:145:2: error: format '%x' expects argument of type 'unsigned int', but argument 6 has type 'dma_addr_t' [-Werror=format]
    make[5]: *** [drivers/gpu/drm/omapdrm/omap_plane.o] Error 1
    drivers/gpu/drm/omapdrm/omap_gem.c: In function 'omap_gem_get_paddr':
    drivers/gpu/drm/omapdrm/omap_gem.c:794:4: error: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'dma_addr_t' [-Werror=format]
    drivers/gpu/drm/omapdrm/omap_gem.c: In function 'omap_gem_describe':
    drivers/gpu/drm/omapdrm/omap_gem.c:991:4: error: format '%Zx' expects argument of type 'size_t', but argument 7 has type 'dma_addr_t' [-Werror=format]
    drivers/gpu/drm/omapdrm/omap_gem.c: In function 'omap_gem_init':
    drivers/gpu/drm/omapdrm/omap_gem.c:1470:4: error: format '%x' expects argument of type 'unsigned int', but argument 7 has type 'dma_addr_t' [-Werror=format]
    make[5]: *** [drivers/gpu/drm/omapdrm/omap_gem.o] Error 1
    drivers/gpu/drm/omapdrm/omap_dmm_tiler.c: In function 'dmm_txn_append':
    drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:226:2: error: passing argument 3 of 'alloc_dma' from incompatible pointer type [-Werror]
    make[5]: *** [drivers/gpu/drm/omapdrm/omap_dmm_tiler.o] Error 1
    make[5]: Target `__build' not remade because of errors.
    make[4]: *** [drivers/gpu/drm/omapdrm] Error 2
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 3cf31ee59aac..6af3398b5278 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -142,8 +142,8 @@ static void omap_plane_pre_apply(struct omap_drm_apply *apply)
 	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
 			info->out_width, info->out_height,
 			info->screen_width);
-	DBG("%d,%d %08x %08x", info->pos_x, info->pos_y,
-			info->paddr, info->p_uv_addr);
+	DBG("%d,%d %pad %pad", info->pos_x, info->pos_y,
+			&info->paddr, &info->p_uv_addr);
 
 	/* TODO: */
 	ilace = false;

commit a4969dd78735ea61bf67712987e1bd69d32e243c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:54 2014 +0530

    drm/omap: Switch omapdrm over to drm_mode_create_rotation_property()
    
    Use the new drm_mode_create_rotation_property() in omapdrm.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index aff06e7a4e5f..da9d15d214cf 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -308,19 +308,13 @@ void omap_plane_install_properties(struct drm_plane *plane,
 	if (priv->has_dmm) {
 		prop = priv->rotation_prop;
 		if (!prop) {
-			const struct drm_prop_enum_list props[] = {
-					{ DRM_ROTATE_0,   "rotate-0" },
-					{ DRM_ROTATE_90,  "rotate-90" },
-					{ DRM_ROTATE_180, "rotate-180" },
-					{ DRM_ROTATE_270, "rotate-270" },
-					{ DRM_REFLECT_X,  "reflect-x" },
-					{ DRM_REFLECT_Y,  "reflect-y" },
-			};
-			prop = drm_property_create_bitmask(dev, 0, "rotation",
-					props, ARRAY_SIZE(props),
-					BIT(DRM_ROTATE_0) | BIT(DRM_ROTATE_90) |
-					BIT(DRM_ROTATE_180) | BIT(DRM_ROTATE_270) |
-					BIT(DRM_REFLECT_X) | BIT(DRM_REFLECT_Y));
+			prop = drm_mode_create_rotation_property(dev,
+								 BIT(DRM_ROTATE_0) |
+								 BIT(DRM_ROTATE_90) |
+								 BIT(DRM_ROTATE_180) |
+								 BIT(DRM_ROTATE_270) |
+								 BIT(DRM_REFLECT_X) |
+								 BIT(DRM_REFLECT_Y));
 			if (prop == NULL)
 				return;
 			priv->rotation_prop = prop;

commit 7689ffb32fa314cc6f128b433b5a285f2699cb70
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:52 2014 +0530

    drm: Add support_bits parameter to drm_property_create_bitmask()
    
    Make drm_property_create_bitmask() a bit more generic by allowing the
    caller to specify which bits are in fact supported. This allows multiple
    callers to use the same enum list, but still create different versions
    of the same property with different list of supported bits.
    
    v2: Populate values[] array as non-sparse
        Make supported_bits 64bit
        Fix up omapdrm call site (Rob)
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 3cf31ee59aac..aff06e7a4e5f 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -317,7 +317,10 @@ void omap_plane_install_properties(struct drm_plane *plane,
 					{ DRM_REFLECT_Y,  "reflect-y" },
 			};
 			prop = drm_property_create_bitmask(dev, 0, "rotation",
-					props, ARRAY_SIZE(props));
+					props, ARRAY_SIZE(props),
+					BIT(DRM_ROTATE_0) | BIT(DRM_ROTATE_90) |
+					BIT(DRM_ROTATE_180) | BIT(DRM_ROTATE_270) |
+					BIT(DRM_REFLECT_X) | BIT(DRM_REFLECT_Y));
 			if (prop == NULL)
 				return;
 			priv->rotation_prop = prop;

commit f2d022aa421ca903a30f63b04528064b7eceaf5e
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Apr 15 16:26:01 2014 +0300

    drm/omap: fix the handling of fb ref counts
    
    With the recent primary-plane changes for drm, the primary plane's
    framebuffer needs to be ref counted the same way as for
    non-primary-planes. This was not done by the omapdrm driver, which
    caused the ref count to drop to 0 too early, causing problems.
    
    This patch moves the fb unref and ref from omap_plane_update to
    omap_plane_mode_set. This way the fb refs are updated for both primary
    and non-primary cases, as omap_plane_update calls omap_plane_mode_set.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index df1725247cca..3cf31ee59aac 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -225,6 +225,11 @@ int omap_plane_mode_set(struct drm_plane *plane,
 		omap_plane->apply_done_cb.arg = arg;
 	}
 
+	if (plane->fb)
+		drm_framebuffer_unreference(plane->fb);
+
+	drm_framebuffer_reference(fb);
+
 	plane->fb = fb;
 	plane->crtc = crtc;
 
@@ -241,11 +246,6 @@ static int omap_plane_update(struct drm_plane *plane,
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	omap_plane->enabled = true;
 
-	if (plane->fb)
-		drm_framebuffer_unreference(plane->fb);
-
-	drm_framebuffer_reference(fb);
-
 	/* omap_plane_mode_set() takes adjusted src */
 	switch (omap_plane->win.rotation & 0xf) {
 	case BIT(DRM_ROTATE_90):

commit d4586604acbd2e58921e0363533b9797b0235275
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Sat Apr 5 21:33:51 2014 +0300

    drm/omap: fix plane rotation
    
    Plane rotation with omapdrm is currently broken.
    It seems omap_plane_mode_set() expects width and height in screen
    coordinates, so pass it like that.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 046d5e660c04..df1725247cca 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -246,6 +246,14 @@ static int omap_plane_update(struct drm_plane *plane,
 
 	drm_framebuffer_reference(fb);
 
+	/* omap_plane_mode_set() takes adjusted src */
+	switch (omap_plane->win.rotation & 0xf) {
+	case BIT(DRM_ROTATE_90):
+	case BIT(DRM_ROTATE_270):
+		swap(src_w, src_h);
+		break;
+	}
+
 	return omap_plane_mode_set(plane, crtc, fb,
 			crtc_x, crtc_y, crtc_w, crtc_h,
 			src_x, src_y, src_w, src_h,

commit 5833bd2fe1c7d9e2650a11a8785b848bbd0d0188
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Aug 7 13:41:21 2013 -0400

    drm/omap: use flip-work helper
    
    And simplify how we hold a ref+pin to what is being scanned out by using
    fb refcnt'ing.  The previous logic pre-dated fb refcnt, and as a result
    was less straightforward than it could have been.  By holding a ref to
    the fb, we don't have to care about how many plane's there are and
    holding a ref to each color plane's bo.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 8d225d7ff4e3..046d5e660c04 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -17,7 +17,7 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <linux/kfifo.h>
+#include "drm_flip_work.h"
 
 #include "omap_drv.h"
 #include "omap_dmm_tiler.h"
@@ -58,26 +58,23 @@ struct omap_plane {
 
 	struct omap_drm_irq error_irq;
 
-	/* set of bo's pending unpin until next post_apply() */
-	DECLARE_KFIFO_PTR(unpin_fifo, struct drm_gem_object *);
+	/* for deferring bo unpin's until next post_apply(): */
+	struct drm_flip_work unpin_work;
 
 	// XXX maybe get rid of this and handle vblank in crtc too?
 	struct callback apply_done_cb;
 };
 
-static void unpin(void *arg, struct drm_gem_object *bo)
+static void unpin_worker(struct drm_flip_work *work, void *val)
 {
-	struct drm_plane *plane = arg;
-	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct omap_plane *omap_plane =
+			container_of(work, struct omap_plane, unpin_work);
+	struct drm_device *dev = omap_plane->base.dev;
 
-	if (kfifo_put(&omap_plane->unpin_fifo,
-			(const struct drm_gem_object **)&bo)) {
-		/* also hold a ref so it isn't free'd while pinned */
-		drm_gem_object_reference(bo);
-	} else {
-		dev_err(plane->dev->dev, "unpin fifo full!\n");
-		omap_gem_put_paddr(bo);
-	}
+	omap_framebuffer_unpin(val);
+	mutex_lock(&dev->mode_config.mutex);
+	drm_framebuffer_unreference(val);
+	mutex_unlock(&dev->mode_config.mutex);
 }
 
 /* update which fb (if any) is pinned for scanout */
@@ -87,23 +84,22 @@ static int update_pin(struct drm_plane *plane, struct drm_framebuffer *fb)
 	struct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;
 
 	if (pinned_fb != fb) {
-		int ret;
+		int ret = 0;
 
 		DBG("%p -> %p", pinned_fb, fb);
 
-		if (fb)
+		if (fb) {
 			drm_framebuffer_reference(fb);
-
-		ret = omap_framebuffer_replace(pinned_fb, fb, plane, unpin);
+			ret = omap_framebuffer_pin(fb);
+		}
 
 		if (pinned_fb)
-			drm_framebuffer_unreference(pinned_fb);
+			drm_flip_work_queue(&omap_plane->unpin_work, pinned_fb);
 
 		if (ret) {
 			dev_err(plane->dev->dev, "could not swap %p -> %p\n",
 					omap_plane->pinned_fb, fb);
-			if (fb)
-				drm_framebuffer_unreference(fb);
+			drm_framebuffer_unreference(fb);
 			omap_plane->pinned_fb = NULL;
 			return ret;
 		}
@@ -170,17 +166,14 @@ static void omap_plane_post_apply(struct omap_drm_apply *apply)
 	struct omap_plane *omap_plane =
 			container_of(apply, struct omap_plane, apply);
 	struct drm_plane *plane = &omap_plane->base;
+	struct omap_drm_private *priv = plane->dev->dev_private;
 	struct omap_overlay_info *info = &omap_plane->info;
-	struct drm_gem_object *bo = NULL;
 	struct callback cb;
 
 	cb = omap_plane->apply_done_cb;
 	omap_plane->apply_done_cb.fxn = NULL;
 
-	while (kfifo_get(&omap_plane->unpin_fifo, &bo)) {
-		omap_gem_put_paddr(bo);
-		drm_gem_object_unreference_unlocked(bo);
-	}
+	drm_flip_work_commit(&omap_plane->unpin_work, priv->wq);
 
 	if (cb.fxn)
 		cb.fxn(cb.arg);
@@ -277,8 +270,7 @@ static void omap_plane_destroy(struct drm_plane *plane)
 	omap_plane_disable(plane);
 	drm_plane_cleanup(plane);
 
-	WARN_ON(!kfifo_is_empty(&omap_plane->unpin_fifo));
-	kfifo_free(&omap_plane->unpin_fifo);
+	drm_flip_work_cleanup(&omap_plane->unpin_work);
 
 	kfree(omap_plane);
 }
@@ -399,7 +391,8 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,
 	if (!omap_plane)
 		goto fail;
 
-	ret = kfifo_alloc(&omap_plane->unpin_fifo, 16, GFP_KERNEL);
+	ret = drm_flip_work_init(&omap_plane->unpin_work, 16,
+			"unpin", unpin_worker);
 	if (ret) {
 		dev_err(dev->dev, "could not allocate unpin FIFO\n");
 		goto fail;

commit b03e14fd4b9f91d0c6be864bf62c75933fa26cac
Author: Archit Taneja <archit@ti.com>
Date:   Tue Apr 9 15:26:00 2013 +0300

    drm/omap: Take a fb reference in omap_plane_update()
    
    When userspace calls SET_PLANE ioctl, drm core takes a reference of the fb and
    passes control to the update_plane op defined by the drm driver.
    
    In omapdrm, we have a worker thread which queues framebuffers objects received
    from update_plane and displays them at the appropriate time.
    
    It is possible that the framebuffer is destoryed by userspace between the time
    of calling the ioctl and apply-worker being scheduled. If this happens, the
    apply-worker holds a pointer to a framebuffer which is already destroyed.
    
    Take an extra refernece/unreference of the fb in omap_plane_update() to prevent
    this from happening. A reference is taken of the fb passed to update_plane(),
    the previous framebuffer (held by plane->fb) is unreferenced. This will prevent
    drm from destroying the framebuffer till the time it's unreferenced by the
    apply-worker.
    
    This is in addition to the exisitng reference/unreference in update_pin(),
    which is taken for the scanout of the plane's current framebuffer, and an
    unreference the previous framebuffer.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index 2882cda6ea19..8d225d7ff4e3 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -247,6 +247,12 @@ static int omap_plane_update(struct drm_plane *plane,
 {
 	struct omap_plane *omap_plane = to_omap_plane(plane);
 	omap_plane->enabled = true;
+
+	if (plane->fb)
+		drm_framebuffer_unreference(plane->fb);
+
+	drm_framebuffer_reference(fb);
+
 	return omap_plane_mode_set(plane, crtc, fb,
 			crtc_x, crtc_y, crtc_w, crtc_h,
 			src_x, src_y, src_w, src_h,

commit fffddfd6c8e0c10c42c6e2cc54ba880fcc36ebbb
Merge: 69086a78bdc9 be88298b0a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:46:44 2013 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge from Dave Airlie:
     "Highlights:
    
       - TI LCD controller KMS driver
    
       - TI OMAP KMS driver merged from staging
    
       - drop gma500 stub driver
    
       - the fbcon locking fixes
    
       - the vgacon dirty like zebra fix.
    
       - open firmware videomode and hdmi common code helpers
    
       - major locking rework for kms object handling - pageflip/cursor
         won't block on polling anymore!
    
       - fbcon helper and prime helper cleanups
    
       - i915: all over the map, haswell power well enhancements, valleyview
         macro horrors cleaned up, killing lots of legacy GTT code,
    
       - radeon: CS ioctl unification, deprecated UMS support, gpu reset
         rework, VM fixes
    
       - nouveau: reworked thermal code, external dp/tmds encoder support
         (anx9805), fences sleep instead of polling,
    
       - exynos: all over the driver fixes."
    
    Lovely conflict in radeon/evergreen_cs.c between commit de0babd60d8d
    ("drm/radeon: enforce use of radeon_get_ib_value when reading user cmd")
    and the new changes that modified that evergreen_dma_cs_parse()
    function.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (508 commits)
      drm/tilcdc: only build on arm
      drm/i915: Revert hdmi HDP pin checks
      drm/tegra: Add list of framebuffers to debugfs
      drm/tegra: Fix color expansion
      drm/tegra: Split DC_CMD_STATE_CONTROL register write
      drm/tegra: Implement page-flipping support
      drm/tegra: Implement VBLANK support
      drm/tegra: Implement .mode_set_base()
      drm/tegra: Add plane support
      drm/tegra: Remove bogus tegra_framebuffer structure
      drm: Add consistency check for page-flipping
      drm/radeon: Use generic HDMI infoframe helpers
      drm/tegra: Use generic HDMI infoframe helpers
      drm: Add EDID helper documentation
      drm: Add HDMI infoframe helpers
      video: Add generic HDMI infoframe helpers
      drm: Add some missing forward declarations
      drm: Move mode tables to drm_edid.c
      drm: Remove duplicate drm_mode_cea_vic()
      gma500: Fix n, m1 and m2 clock limits for sdvo and lvds
      ...

commit 8bb0daffb0b8e45188066255b4203446eae181f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Feb 11 12:43:09 2013 -0500

    drm/omap: move out of staging
    
    Now that the omapdss interface has been reworked so that omapdrm can use
    dispc directly, we have been able to fix the remaining functional kms
    issues with omapdrm.  And in the mean time the PM sequencing and many
    other of that open issues have been solved.  So I think it makes sense
    to finally move omapdrm out of staging.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
new file mode 100644
index 000000000000..dd68d14ce615
--- /dev/null
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -0,0 +1,450 @@
+/*
+ * drivers/gpu/drm/omapdrm/omap_plane.c
+ *
+ * Copyright (C) 2011 Texas Instruments
+ * Author: Rob Clark <rob.clark@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kfifo.h>
+
+#include "omap_drv.h"
+#include "omap_dmm_tiler.h"
+
+/* some hackery because omapdss has an 'enum omap_plane' (which would be
+ * better named omap_plane_id).. and compiler seems unhappy about having
+ * both a 'struct omap_plane' and 'enum omap_plane'
+ */
+#define omap_plane _omap_plane
+
+/*
+ * plane funcs
+ */
+
+struct callback {
+	void (*fxn)(void *);
+	void *arg;
+};
+
+#define to_omap_plane(x) container_of(x, struct omap_plane, base)
+
+struct omap_plane {
+	struct drm_plane base;
+	int id;  /* TODO rename omap_plane -> omap_plane_id in omapdss so I can use the enum */
+	const char *name;
+	struct omap_overlay_info info;
+	struct omap_drm_apply apply;
+
+	/* position/orientation of scanout within the fb: */
+	struct omap_drm_window win;
+	bool enabled;
+
+	/* last fb that we pinned: */
+	struct drm_framebuffer *pinned_fb;
+
+	uint32_t nformats;
+	uint32_t formats[32];
+
+	struct omap_drm_irq error_irq;
+
+	/* set of bo's pending unpin until next post_apply() */
+	DECLARE_KFIFO_PTR(unpin_fifo, struct drm_gem_object *);
+
+	// XXX maybe get rid of this and handle vblank in crtc too?
+	struct callback apply_done_cb;
+};
+
+static void unpin(void *arg, struct drm_gem_object *bo)
+{
+	struct drm_plane *plane = arg;
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+
+	if (kfifo_put(&omap_plane->unpin_fifo,
+			(const struct drm_gem_object **)&bo)) {
+		/* also hold a ref so it isn't free'd while pinned */
+		drm_gem_object_reference(bo);
+	} else {
+		dev_err(plane->dev->dev, "unpin fifo full!\n");
+		omap_gem_put_paddr(bo);
+	}
+}
+
+/* update which fb (if any) is pinned for scanout */
+static int update_pin(struct drm_plane *plane, struct drm_framebuffer *fb)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;
+
+	if (pinned_fb != fb) {
+		int ret;
+
+		DBG("%p -> %p", pinned_fb, fb);
+
+		if (fb)
+			drm_framebuffer_reference(fb);
+
+		ret = omap_framebuffer_replace(pinned_fb, fb, plane, unpin);
+
+		if (pinned_fb)
+			drm_framebuffer_unreference(pinned_fb);
+
+		if (ret) {
+			dev_err(plane->dev->dev, "could not swap %p -> %p\n",
+					omap_plane->pinned_fb, fb);
+			if (fb)
+				drm_framebuffer_unreference(fb);
+			omap_plane->pinned_fb = NULL;
+			return ret;
+		}
+
+		omap_plane->pinned_fb = fb;
+	}
+
+	return 0;
+}
+
+static void omap_plane_pre_apply(struct omap_drm_apply *apply)
+{
+	struct omap_plane *omap_plane =
+			container_of(apply, struct omap_plane, apply);
+	struct omap_drm_window *win = &omap_plane->win;
+	struct drm_plane *plane = &omap_plane->base;
+	struct drm_device *dev = plane->dev;
+	struct omap_overlay_info *info = &omap_plane->info;
+	struct drm_crtc *crtc = plane->crtc;
+	enum omap_channel channel;
+	bool enabled = omap_plane->enabled && crtc;
+	bool ilace, replication;
+	int ret;
+
+	DBG("%s, enabled=%d", omap_plane->name, enabled);
+
+	/* if fb has changed, pin new fb: */
+	update_pin(plane, enabled ? plane->fb : NULL);
+
+	if (!enabled) {
+		dispc_ovl_enable(omap_plane->id, false);
+		return;
+	}
+
+	channel = omap_crtc_channel(crtc);
+
+	/* update scanout: */
+	omap_framebuffer_update_scanout(plane->fb, win, info);
+
+	DBG("%dx%d -> %dx%d (%d)", info->width, info->height,
+			info->out_width, info->out_height,
+			info->screen_width);
+	DBG("%d,%d %08x %08x", info->pos_x, info->pos_y,
+			info->paddr, info->p_uv_addr);
+
+	/* TODO: */
+	ilace = false;
+	replication = false;
+
+	/* and finally, update omapdss: */
+	ret = dispc_ovl_setup(omap_plane->id, info,
+			replication, omap_crtc_timings(crtc), false);
+	if (ret) {
+		dev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);
+		return;
+	}
+
+	dispc_ovl_enable(omap_plane->id, true);
+	dispc_ovl_set_channel_out(omap_plane->id, channel);
+}
+
+static void omap_plane_post_apply(struct omap_drm_apply *apply)
+{
+	struct omap_plane *omap_plane =
+			container_of(apply, struct omap_plane, apply);
+	struct drm_plane *plane = &omap_plane->base;
+	struct omap_overlay_info *info = &omap_plane->info;
+	struct drm_gem_object *bo = NULL;
+	struct callback cb;
+
+	cb = omap_plane->apply_done_cb;
+	omap_plane->apply_done_cb.fxn = NULL;
+
+	while (kfifo_get(&omap_plane->unpin_fifo, &bo)) {
+		omap_gem_put_paddr(bo);
+		drm_gem_object_unreference_unlocked(bo);
+	}
+
+	if (cb.fxn)
+		cb.fxn(cb.arg);
+
+	if (omap_plane->enabled) {
+		omap_framebuffer_flush(plane->fb, info->pos_x, info->pos_y,
+				info->out_width, info->out_height);
+	}
+}
+
+static int apply(struct drm_plane *plane)
+{
+	if (plane->crtc) {
+		struct omap_plane *omap_plane = to_omap_plane(plane);
+		return omap_crtc_apply(plane->crtc, &omap_plane->apply);
+	}
+	return 0;
+}
+
+int omap_plane_mode_set(struct drm_plane *plane,
+		struct drm_crtc *crtc, struct drm_framebuffer *fb,
+		int crtc_x, int crtc_y,
+		unsigned int crtc_w, unsigned int crtc_h,
+		uint32_t src_x, uint32_t src_y,
+		uint32_t src_w, uint32_t src_h,
+		void (*fxn)(void *), void *arg)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct omap_drm_window *win = &omap_plane->win;
+
+	win->crtc_x = crtc_x;
+	win->crtc_y = crtc_y;
+	win->crtc_w = crtc_w;
+	win->crtc_h = crtc_h;
+
+	/* src values are in Q16 fixed point, convert to integer: */
+	win->src_x = src_x >> 16;
+	win->src_y = src_y >> 16;
+	win->src_w = src_w >> 16;
+	win->src_h = src_h >> 16;
+
+	if (fxn) {
+		/* omap_crtc should ensure that a new page flip
+		 * isn't permitted while there is one pending:
+		 */
+		BUG_ON(omap_plane->apply_done_cb.fxn);
+
+		omap_plane->apply_done_cb.fxn = fxn;
+		omap_plane->apply_done_cb.arg = arg;
+	}
+
+	plane->fb = fb;
+	plane->crtc = crtc;
+
+	return apply(plane);
+}
+
+static int omap_plane_update(struct drm_plane *plane,
+		struct drm_crtc *crtc, struct drm_framebuffer *fb,
+		int crtc_x, int crtc_y,
+		unsigned int crtc_w, unsigned int crtc_h,
+		uint32_t src_x, uint32_t src_y,
+		uint32_t src_w, uint32_t src_h)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	omap_plane->enabled = true;
+	return omap_plane_mode_set(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h,
+			src_x, src_y, src_w, src_h,
+			NULL, NULL);
+}
+
+static int omap_plane_disable(struct drm_plane *plane)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	omap_plane->win.rotation = BIT(DRM_ROTATE_0);
+	return omap_plane_dpms(plane, DRM_MODE_DPMS_OFF);
+}
+
+static void omap_plane_destroy(struct drm_plane *plane)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+
+	DBG("%s", omap_plane->name);
+
+	omap_irq_unregister(plane->dev, &omap_plane->error_irq);
+
+	omap_plane_disable(plane);
+	drm_plane_cleanup(plane);
+
+	WARN_ON(!kfifo_is_empty(&omap_plane->unpin_fifo));
+	kfifo_free(&omap_plane->unpin_fifo);
+
+	kfree(omap_plane);
+}
+
+int omap_plane_dpms(struct drm_plane *plane, int mode)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	bool enabled = (mode == DRM_MODE_DPMS_ON);
+	int ret = 0;
+
+	if (enabled != omap_plane->enabled) {
+		omap_plane->enabled = enabled;
+		ret = apply(plane);
+	}
+
+	return ret;
+}
+
+/* helper to install properties which are common to planes and crtcs */
+void omap_plane_install_properties(struct drm_plane *plane,
+		struct drm_mode_object *obj)
+{
+	struct drm_device *dev = plane->dev;
+	struct omap_drm_private *priv = dev->dev_private;
+	struct drm_property *prop;
+
+	if (priv->has_dmm) {
+		prop = priv->rotation_prop;
+		if (!prop) {
+			const struct drm_prop_enum_list props[] = {
+					{ DRM_ROTATE_0,   "rotate-0" },
+					{ DRM_ROTATE_90,  "rotate-90" },
+					{ DRM_ROTATE_180, "rotate-180" },
+					{ DRM_ROTATE_270, "rotate-270" },
+					{ DRM_REFLECT_X,  "reflect-x" },
+					{ DRM_REFLECT_Y,  "reflect-y" },
+			};
+			prop = drm_property_create_bitmask(dev, 0, "rotation",
+					props, ARRAY_SIZE(props));
+			if (prop == NULL)
+				return;
+			priv->rotation_prop = prop;
+		}
+		drm_object_attach_property(obj, prop, 0);
+	}
+
+	prop = priv->zorder_prop;
+	if (!prop) {
+		prop = drm_property_create_range(dev, 0, "zorder", 0, 3);
+		if (prop == NULL)
+			return;
+		priv->zorder_prop = prop;
+	}
+	drm_object_attach_property(obj, prop, 0);
+}
+
+int omap_plane_set_property(struct drm_plane *plane,
+		struct drm_property *property, uint64_t val)
+{
+	struct omap_plane *omap_plane = to_omap_plane(plane);
+	struct omap_drm_private *priv = plane->dev->dev_private;
+	int ret = -EINVAL;
+
+	if (property == priv->rotation_prop) {
+		DBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);
+		omap_plane->win.rotation = val;
+		ret = apply(plane);
+	} else if (property == priv->zorder_prop) {
+		DBG("%s: zorder: %02x", omap_plane->name, (uint32_t)val);
+		omap_plane->info.zorder = val;
+		ret = apply(plane);
+	}
+
+	return ret;
+}
+
+static const struct drm_plane_funcs omap_plane_funcs = {
+		.update_plane = omap_plane_update,
+		.disable_plane = omap_plane_disable,
+		.destroy = omap_plane_destroy,
+		.set_property = omap_plane_set_property,
+};
+
+static void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
+{
+	struct omap_plane *omap_plane =
+			container_of(irq, struct omap_plane, error_irq);
+	DRM_ERROR("%s: errors: %08x\n", omap_plane->name, irqstatus);
+}
+
+static const char *plane_names[] = {
+		[OMAP_DSS_GFX] = "gfx",
+		[OMAP_DSS_VIDEO1] = "vid1",
+		[OMAP_DSS_VIDEO2] = "vid2",
+		[OMAP_DSS_VIDEO3] = "vid3",
+};
+
+static const uint32_t error_irqs[] = {
+		[OMAP_DSS_GFX] = DISPC_IRQ_GFX_FIFO_UNDERFLOW,
+		[OMAP_DSS_VIDEO1] = DISPC_IRQ_VID1_FIFO_UNDERFLOW,
+		[OMAP_DSS_VIDEO2] = DISPC_IRQ_VID2_FIFO_UNDERFLOW,
+		[OMAP_DSS_VIDEO3] = DISPC_IRQ_VID3_FIFO_UNDERFLOW,
+};
+
+/* initialize plane */
+struct drm_plane *omap_plane_init(struct drm_device *dev,
+		int id, bool private_plane)
+{
+	struct omap_drm_private *priv = dev->dev_private;
+	struct drm_plane *plane = NULL;
+	struct omap_plane *omap_plane;
+	struct omap_overlay_info *info;
+	int ret;
+
+	DBG("%s: priv=%d", plane_names[id], private_plane);
+
+	omap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);
+	if (!omap_plane) {
+		dev_err(dev->dev, "could not allocate plane\n");
+		goto fail;
+	}
+
+	ret = kfifo_alloc(&omap_plane->unpin_fifo, 16, GFP_KERNEL);
+	if (ret) {
+		dev_err(dev->dev, "could not allocate unpin FIFO\n");
+		goto fail;
+	}
+
+	omap_plane->nformats = omap_framebuffer_get_formats(
+			omap_plane->formats, ARRAY_SIZE(omap_plane->formats),
+			dss_feat_get_supported_color_modes(id));
+	omap_plane->id = id;
+	omap_plane->name = plane_names[id];
+
+	plane = &omap_plane->base;
+
+	omap_plane->apply.pre_apply  = omap_plane_pre_apply;
+	omap_plane->apply.post_apply = omap_plane_post_apply;
+
+	omap_plane->error_irq.irqmask = error_irqs[id];
+	omap_plane->error_irq.irq = omap_plane_error_irq;
+	omap_irq_register(dev, &omap_plane->error_irq);
+
+	drm_plane_init(dev, plane, (1 << priv->num_crtcs) - 1, &omap_plane_funcs,
+			omap_plane->formats, omap_plane->nformats, private_plane);
+
+	omap_plane_install_properties(plane, &plane->base);
+
+	/* get our starting configuration, set defaults for parameters
+	 * we don't currently use, etc:
+	 */
+	info = &omap_plane->info;
+	info->rotation_type = OMAP_DSS_ROT_DMA;
+	info->rotation = OMAP_DSS_ROT_0;
+	info->global_alpha = 0xff;
+	info->mirror = 0;
+
+	/* Set defaults depending on whether we are a CRTC or overlay
+	 * layer.
+	 * TODO add ioctl to give userspace an API to change this.. this
+	 * will come in a subsequent patch.
+	 */
+	if (private_plane)
+		omap_plane->info.zorder = 0;
+	else
+		omap_plane->info.zorder = id;
+
+	return plane;
+
+fail:
+	if (plane)
+		omap_plane_destroy(plane);
+
+	return NULL;
+}
