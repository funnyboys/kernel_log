commit 35a61fe9218a9d32a93447bdcca1d0f167cd0433
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Dec 3 15:15:07 2019 +0100

    drm: Stop accessing encoder->bridge directly
    
    We are about to replace the single-linked bridge list by a double-linked
    one based on list.h, leading to the suppression of the encoder->bridge
    field. But before we can do that we must provide a
    drm_bridge_chain_get_first_bridge() bridge helper and patch all drivers
    and core helpers to use it instead of directly accessing encoder->bridge.
    
    Note that we still have 2 drivers (VC4 and Exynos) manipulating the
    encoder->bridge field directly because they need to cut the bridge chain
    in order to control the enable/disable sequence. This is definitely
    not something we want to encourage, so let's keep those 2 oddities
    around until we find a better solution.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191203141515.3597631-4-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index c3ea722065c4..576b4b7dcd89 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -101,6 +101,7 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 
 	/* Step 2: Validate against encoders and crtcs */
 	drm_connector_for_each_possible_encoder(connector, encoder) {
+		struct drm_bridge *bridge;
 		struct drm_crtc *crtc;
 
 		ret = drm_encoder_mode_valid(encoder, mode);
@@ -112,7 +113,8 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 			continue;
 		}
 
-		ret = drm_bridge_chain_mode_valid(encoder->bridge, mode);
+		bridge = drm_bridge_chain_get_first_bridge(encoder);
+		ret = drm_bridge_chain_mode_valid(bridge, mode);
 		if (ret != MODE_OK) {
 			/* There is also no point in continuing for crtc check
 			 * here. */

commit ea099adfdf4bf35903dc1c0f59a0d60175759c70
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Dec 3 15:15:05 2019 +0100

    drm/bridge: Rename bridge helpers targeting a bridge chain
    
    Change the prefix of bridge helpers targeting a bridge chain from
    drm_bridge_ to drm_bridge_chain_ to better reflect the fact that
    the operation will happen on all elements of chain, starting at the
    bridge passed in argument.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191203141515.3597631-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index a7c87abe88d0..c3ea722065c4 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -112,7 +112,7 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 			continue;
 		}
 
-		ret = drm_bridge_mode_valid(encoder->bridge, mode);
+		ret = drm_bridge_chain_mode_valid(encoder->bridge, mode);
 		if (ret != MODE_OK) {
 			/* There is also no point in continuing for crtc check
 			 * here. */

commit 62afb4ad425af2bc6ac6ff6d697825ae47c25211
Author: José Roberto de Souza <jose.souza@intel.com>
Date:   Fri Sep 13 16:28:57 2019 -0700

    drm/connector: Allow max possible encoders to attach to a connector
    
    Currently we restrict the number of encoders that can be linked to
    a connector to 3, increase it to match the maximum number of encoders
    that can be initialized(32).
    
    To more effiently do that lets switch from an array of encoder ids to
    bitmask.
    
    v2: Fixing missed return on amdgpu_dm_connector_to_encoder()
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
    Signed-off-by: Manasi Navare <manasi.d.navare@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190913232857.389834-2-jose.souza@intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 351cbc40f0f8..a7c87abe88d0 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -93,7 +93,6 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 	struct drm_device *dev = connector->dev;
 	enum drm_mode_status ret = MODE_OK;
 	struct drm_encoder *encoder;
-	int i;
 
 	/* Step 1: Validate against connector */
 	ret = drm_connector_mode_valid(connector, mode);
@@ -101,7 +100,7 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 		return ret;
 
 	/* Step 2: Validate against encoders and crtcs */
-	drm_connector_for_each_possible_encoder(connector, encoder, i) {
+	drm_connector_for_each_possible_encoder(connector, encoder) {
 		struct drm_crtc *crtc;
 
 		ret = drm_encoder_mode_valid(encoder, mode);

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index ef2c468205a2..351cbc40f0f8 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -32,6 +32,7 @@
 #include <linux/export.h>
 #include <linux/moduleparam.h>
 
+#include <drm/drm_bridge.h>
 #include <drm/drm_client.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_edid.h>

commit 52d2d44eee8091e740d0d275df1311fb8373c9a9
Merge: 2454fcea338a 9e0babf2c06c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 19 12:04:55 2019 +0200

    Merge v5.2-rc5 into drm-next
    
    Maarten needs -rc4 backmerged so he can pull in the fbcon notifier
    removal topic branch into drm-misc-next.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 48eaeb7664c76139438724d520a1ea4a84a3ed92
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Jun 10 12:30:54 2019 +0300

    drm: add fallback override/firmware EDID modes workaround
    
    We've moved the override and firmware EDID (simply "override EDID" from
    now on) handling to the low level drm_do_get_edid() function in order to
    transparently use the override throughout the stack. The idea is that
    you get the override EDID via the ->get_modes() hook.
    
    Unfortunately, there are scenarios where the DDC probe in drm_get_edid()
    called via ->get_modes() fails, although the preceding ->detect()
    succeeds.
    
    In the case reported by Paul Wise, the ->detect() hook,
    intel_crt_detect(), relies on hotplug detect, bypassing the DDC. In the
    case reported by Ilpo Järvinen, there is no ->detect() hook, which is
    interpreted as connected. The subsequent DDC probe reached via
    ->get_modes() fails, and we don't even look at the override EDID,
    resulting in no modes being added.
    
    Because drm_get_edid() is used via ->detect() all over the place, we
    can't trivially remove the DDC probe, as it leads to override EDID
    effectively meaning connector forcing. The goal is that connector
    forcing and override EDID remain orthogonal.
    
    Generally, the underlying problem here is the conflation of ->detect()
    and ->get_modes() via drm_get_edid(). The former should just detect, and
    the latter should just get the modes, typically via reading the EDID. As
    long as drm_get_edid() is used in ->detect(), it needs to retain the DDC
    probe. Or such users need to have a separate DDC probe step first.
    
    The EDID caching between ->detect() and ->get_modes() done by some
    drivers is a further complication that prevents us from making
    drm_do_get_edid() adapt to the two cases.
    
    Work around the regression by falling back to a separate attempt at
    getting the override EDID at drm_helper_probe_single_connector_modes()
    level. With a working DDC and override EDID, it'll never be called; the
    override EDID will come via ->get_modes(). There will still be a failing
    DDC probe attempt in the cases that require the fallback.
    
    v2:
    - Call drm_connector_update_edid_property (Paul)
    - Update commit message about EDID caching (Daniel)
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=107583
    Reported-by: Paul Wise <pabs3@bonedaddy.net>
    Cc: Paul Wise <pabs3@bonedaddy.net>
    References: http://mid.mail-archive.com/alpine.DEB.2.20.1905262211270.24390@whs-18.cs.helsinki.fi
    Reported-by: Ilpo Järvinen <ilpo.jarvinen@cs.helsinki.fi>
    Cc: Ilpo Järvinen <ilpo.jarvinen@cs.helsinki.fi>
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    References: 15f080f08d48 ("drm/edid: respect connector force for drm_get_edid ddc probe")
    Fixes: 53fd40a90f3c ("drm: handle override and firmware EDID at drm_do_get_edid() level")
    Cc: <stable@vger.kernel.org> # v4.15+ 56a2b7f2a39a drm/edid: abstract override/firmware EDID retrieval
    Cc: <stable@vger.kernel.org> # v4.15+
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Harish Chegondi <harish.chegondi@intel.com>
    Tested-by: Paul Wise <pabs3@bonedaddy.net>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190610093054.28445-1-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6fd08e04b323..dd427c7ff967 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -479,6 +479,13 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	count = (*connector_funcs->get_modes)(connector);
 
+	/*
+	 * Fallback for when DDC probe failed in drm_get_edid() and thus skipped
+	 * override/firmware EDID.
+	 */
+	if (count == 0 && connector->status == connector_status_connected)
+		count = drm_add_override_edid_modes(connector);
+
 	if (count == 0 && connector->status == connector_status_connected)
 		count = drm_add_modes_noedid(connector, 1024, 768);
 	count += drm_helper_probe_add_cmdline_mode(connector);

commit 3b295cb1a411d9c82bbfaa66bc17a8508716ed07
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jun 3 14:58:57 2019 +0100

    drm: Flush output polling on shutdown
    
    We need to mark the output polling as disabled to prevent concurrent
    irqs from queuing new work as shutdown the probe -- causing that work to
    execute after we have freed the structs:
    
    <4> [341.846490] DEBUG_LOCKS_WARN_ON(mutex_is_locked(lock))
    <4> [341.846497] WARNING: CPU: 3 PID: 3300 at kernel/locking/mutex-debug.c:103 mutex_destroy+0x49/0x50
    <4> [341.846508] Modules linked in: i915(-) vgem thunderbolt snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic mei_hdcp x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm mcs7830 btusb usbnet btrtl mii btbcm btintel bluetooth ecdh_generic ecc mei_me mei prime_numbers i2c_hid pinctrl_sunrisepoint pinctrl_intel [last unloaded: i915]
    <4> [341.846546] CPU: 3 PID: 3300 Comm: i915_module_loa Tainted: G     U            5.2.0-rc2-CI-CI_DRM_6175+ #1
    <4> [341.846553] Hardware name: Dell Inc. XPS 13 9360/0823VW, BIOS 2.9.0 07/09/2018
    <4> [341.846560] RIP: 0010:mutex_destroy+0x49/0x50
    <4> [341.846565] Code: 00 00 5b c3 e8 a8 9f 3b 00 85 c0 74 ed 8b 05 3e 55 23 01 85 c0 75 e3 48 c7 c6 00 d0 08 82 48 c7 c7 a8 aa 07 82 e8 e7 08 fa ff <0f> 0b eb cc 0f 1f 00 48 b8 11 11 11 11 11 11 11 11 48 89 76 20 48
    <4> [341.846578] RSP: 0018:ffffc900006cfdb0 EFLAGS: 00010286
    <4> [341.846583] RAX: 0000000000000000 RBX: ffff88826759a168 RCX: 0000000000000000
    <4> [341.846589] RDX: 0000000000000002 RSI: 0000000000000000 RDI: ffffffff8112844c
    <4> [341.846595] RBP: ffff8882708fa548 R08: 0000000000000000 R09: 0000000000039600
    <4> [341.846601] R10: 0000000000000000 R11: 0000000000000ce4 R12: ffffffffa07de1e0
    <4> [341.846607] R13: 0000000000000000 R14: 0000000000000000 R15: ffffffffa07de2d0
    <4> [341.846613] FS:  00007f62b5ae0e40(0000) GS:ffff888276380000(0000) knlGS:0000000000000000
    <4> [341.846620] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    <4> [341.846626] CR2: 000055a4e064f4a0 CR3: 0000000266b16006 CR4: 00000000003606e0
    <4> [341.846632] Call Trace:
    <4> [341.846639]  drm_fb_helper_fini.part.17+0xb3/0x100
    <4> [341.846682]  intel_fbdev_fini+0x20/0x80 [i915]
    <4> [341.846722]  intel_modeset_cleanup+0x9a/0x140 [i915]
    <4> [341.846750]  i915_driver_unload+0xa3/0x100 [i915]
    <4> [341.846778]  i915_pci_remove+0x19/0x30 [i915]
    <4> [341.846784]  pci_device_remove+0x36/0xb0
    <4> [341.846790]  device_release_driver_internal+0xd3/0x1b0
    <4> [341.846795]  driver_detach+0x3f/0x80
    <4> [341.846800]  bus_remove_driver+0x53/0xd0
    <4> [341.846805]  pci_unregister_driver+0x25/0xa0
    <4> [341.846843]  i915_exit+0x16/0x1c [i915]
    <4> [341.846849]  __se_sys_delete_module+0x162/0x210
    <4> [341.846855]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    <4> [341.846859]  ? do_syscall_64+0xd/0x1c0
    <4> [341.846864]  do_syscall_64+0x55/0x1c0
    <4> [341.846869]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    <4> [341.846875] RIP: 0033:0x7f62b51871b7
    <4> [341.846881] Code: 73 01 c3 48 8b 0d d1 8c 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 b8 b0 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a1 8c 2c 00 f7 d8 64 89 01 48
    <4> [341.846897] RSP: 002b:00007ffe7a227138 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0
    <4> [341.846904] RAX: ffffffffffffffda RBX: 00007ffe7a2272b0 RCX: 00007f62b51871b7
    <4> [341.846910] RDX: 0000000000000001 RSI: 0000000000000800 RDI: 0000557cd6b55948
    <4> [341.846916] RBP: 0000557cd6b558e0 R08: 0000557cd6b5594c R09: 00007ffe7a227160
    <4> [341.846922] R10: 00007ffe7a226134 R11: 0000000000000206 R12: 0000000000000000
    <4> [341.846927] R13: 00007ffe7a227820 R14: 0000000000000000 R15: 0000000000000000
    <4> [341.846936] irq event stamp: 3547847
    <4> [341.846940] hardirqs last  enabled at (3547847): [<ffffffff819aad2c>] _raw_spin_unlock_irqrestore+0x4c/0x60
    <4> [341.846949] hardirqs last disabled at (3547846): [<ffffffff819aab9d>] _raw_spin_lock_irqsave+0xd/0x50
    <4> [341.846957] softirqs last  enabled at (3547376): [<ffffffff81c0033a>] __do_softirq+0x33a/0x4b9
    <4> [341.846966] softirqs last disabled at (3547367): [<ffffffff810b6379>] irq_exit+0xa9/0xc0
    <4> [341.846973] WARNING: CPU: 3 PID: 3300 at kernel/locking/mutex-debug.c:103 mutex_destroy+0x49/0x50
    <4> [341.846980] ---[ end trace ba94ca8952ba970e ]---
    <7> [341.866547] [drm:intel_dp_detect [i915]] MST support? port A: no, sink: no, modparam: yes
    <7> [341.890480] [drm:drm_add_display_info] non_desktop set to 0
    <7> [341.890530] [drm:drm_add_edid_modes] ELD: no CEA Extension found
    <7> [341.890537] [drm:drm_add_display_info] non_desktop set to 0
    <7> [341.890578] [drm:drm_helper_probe_single_connector_modes] [CONNECTOR:86:eDP-1] probed modes :
    <7> [341.890589] [drm:drm_mode_debug_printmodeline] Modeline "3200x1800": 60 373250 3200 3248 3280 3360 1800 1803 1808 1852 0x48 0xa
    <7> [341.890602] [drm:drm_mode_debug_printmodeline] Modeline "3200x1800": 48 298600 3200 3248 3280 3360 1800 1803 1808 1852 0x40 0xa
    <4> [341.890628] general protection fault: 0000 [#1] PREEMPT SMP PTI
    <4> [341.890636] CPU: 0 PID: 508 Comm: kworker/0:4 Tainted: G     U  W         5.2.0-rc2-CI-CI_DRM_6175+ #1
    <4> [341.890646] Hardware name: Dell Inc. XPS 13 9360/0823VW, BIOS 2.9.0 07/09/2018
    <4> [341.890655] Workqueue: events output_poll_execute
    <4> [341.890663] RIP: 0010:drm_setup_crtcs+0x13e/0xbe0
    <4> [341.890669] Code: 00 41 8b 44 24 58 85 c0 0f 8e f9 01 00 00 44 8b 6c 24 20 44 8b 74 24 28 31 db 31 ed 49 8b 44 24 60 48 63 d5 44 89 ee 83 c5 01 <48> 8b 04 d0 44 89 f2 48 8b 38 48 8b 87 88 01 00 00 48 8b 40 20 e8
    <4> [341.890686] RSP: 0018:ffffc9000033fd40 EFLAGS: 00010202
    <4> [341.890692] RAX: 6b6b6b6b6b6b6b6b RBX: 0000000000000002 RCX: 0000000000000000
    <4> [341.890700] RDX: 0000000000000001 RSI: 0000000000000c80 RDI: 00000000ffffffff
    <4> [341.890707] RBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000
    <4> [341.890715] R10: 0000000000000c80 R11: 0000000000000000 R12: ffff888267599fe8
    <4> [341.890722] R13: 0000000000000c80 R14: 0000000000000708 R15: 0000000000000007
    <4> [341.890730] FS:  0000000000000000(0000) GS:ffff888276200000(0000) knlGS:0000000000000000
    <4> [341.890739] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    <4> [341.890745] CR2: 000055a4e064f4a0 CR3: 000000026d234003 CR4: 00000000003606f0
    <4> [341.890752] Call Trace:
    <4> [341.890760]  drm_fb_helper_hotplug_event.part.24+0x89/0xb0
    <4> [341.890768]  drm_kms_helper_hotplug_event+0x21/0x30
    <4> [341.890774]  output_poll_execute+0x9d/0x1a0
    <4> [341.890782]  process_one_work+0x245/0x610
    <4> [341.890790]  worker_thread+0x37/0x380
    <4> [341.890796]  ? process_one_work+0x610/0x610
    <4> [341.890802]  kthread+0x119/0x130
    <4> [341.890808]  ? kthread_park+0x80/0x80
    <4> [341.890815]  ret_from_fork+0x3a/0x50
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=109964
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190603135910.15979-2-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 43c85e1b467e..01e243f1ea94 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -575,6 +575,9 @@ static void output_poll_execute(struct work_struct *work)
 	enum drm_connector_status old_status;
 	bool repoll = false, changed;
 
+	if (!dev->mode_config.poll_enabled)
+		return;
+
 	/* Pick up any changes detected by the probe functions. */
 	changed = dev->mode_config.delayed_event;
 	dev->mode_config.delayed_event = false;
@@ -729,7 +732,11 @@ EXPORT_SYMBOL(drm_kms_helper_poll_init);
  */
 void drm_kms_helper_poll_fini(struct drm_device *dev)
 {
-	drm_kms_helper_poll_disable(dev);
+	if (!dev->mode_config.poll_enabled)
+		return;
+
+	dev->mode_config.poll_enabled = false;
+	cancel_delayed_work_sync(&dev->mode_config.output_poll_work);
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_fini);
 

commit 0500c04ea14a4143edf902d087079c4e7b2f0229
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 26 19:35:35 2019 +0200

    drm: drop use of drmP.h in drm/*
    
    The use of the drmP.h header file is deprecated.
    Remove use from all files in drm/*
    so people do not look there and follow a bad example.
    
    Build tested allyesconfig,allmodconfig on x86, arm etc.
    Including alpha that is as always more challenging than
    the rest.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190526173535.32701-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6fd08e04b323..43c85e1b467e 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -32,14 +32,15 @@
 #include <linux/export.h>
 #include <linux/moduleparam.h>
 
-#include <drm/drmP.h>
 #include <drm/drm_client.h>
 #include <drm/drm_crtc.h>
-#include <drm/drm_fourcc.h>
-#include <drm/drm_fb_helper.h>
 #include <drm/drm_edid.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
 #include <drm/drm_modeset_helper_vtables.h>
+#include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
+#include <drm/drm_sysfs.h>
 
 #include "drm_crtc_helper_internal.h"
 

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index a1bb157bfdfa..6fd08e04b323 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -36,10 +36,10 @@
 #include <drm/drm_client.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_fourcc.h>
-#include <drm/drm_crtc_helper.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_modeset_helper_vtables.h>
+#include <drm/drm_probe_helper.h>
 
 #include "drm_crtc_helper_internal.h"
 

commit 97e14fbeb53fe060c5f6a7a07e37fd24c087ed0c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:08 2018 +0200

    drm: drop _mode_ from remaining connector functions
    
    Since there's very few callers of these I've decided to do them all in
    one patch. With this the unecessarily long drm_mode_connector_ prefix
    is gone from the codebase! The only exception being struct
    drm_mode_connector_set_property, which is part of the uapi so can't be
    renamed.
    
    Again done with sed+some manual fixups for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-8-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 3d58e0eb26a4..a1bb157bfdfa 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -360,7 +360,7 @@ EXPORT_SYMBOL(drm_helper_probe_detect);
  *    using the VESA GTF/CVT formulas.
  *
  * 3. Modes are moved from the probed_modes list to the modes list. Potential
- *    duplicates are merged together (see drm_mode_connector_list_update()).
+ *    duplicates are merged together (see drm_connector_list_update()).
  *    After this step the probed_modes list will be empty again.
  *
  * 4. Any non-stale mode on the modes list then undergoes validation
@@ -485,7 +485,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	if (count == 0)
 		goto prune;
 
-	drm_mode_connector_list_update(connector);
+	drm_connector_list_update(connector);
 
 	if (connector->interlace_allowed)
 		mode_flags |= DRM_MODE_FLAG_INTERLACE;

commit c555f02371c338b06752577aebf738dbdb6907bd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:06 2018 +0200

    drm: drop _mode_ from update_edit_property()
    
    Just makes it longer, and for most things in drm_connector.[hc] we
    just use the drm_connector_ prefix. Done with sed + a bit of manual
    fixup for the indenting.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-6-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 34fe2704a31c..3d58e0eb26a4 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -472,7 +472,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	if (connector->status == connector_status_disconnected) {
 		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",
 			connector->base.id, connector->name);
-		drm_mode_connector_update_edid_property(connector, NULL);
+		drm_connector_update_edid_property(connector, NULL);
 		verbose_prune = false;
 		goto prune;
 	}

commit c76f0f7cb546b661b5e0ac769850a5c854927f65
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Tue Jul 3 18:03:47 2018 +0200

    drm: Begin an API for in-kernel clients
    
    This the beginning of an API for in-kernel clients.
    First out is a way to get a framebuffer backed by a dumb buffer.
    
    Only GEM drivers are supported.
    The original idea of using an exported dma-buf was dropped because it
    also creates an anonomous file descriptor which doesn't work when the
    buffer is created from a kernel thread. The easy way out is to use
    drm_driver.gem_prime_vmap to get the virtual address, which requires a
    GEM object. This excludes the vmwgfx driver which is the only non-GEM
    driver apart from the legacy ones. A solution for vmwgfx will have to be
    worked out later if it wants to support the client API which it probably
    will when we have a bootsplash client.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180703160354.59955-2-noralf@tronnes.org

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 1a901fe9e23e..34fe2704a31c 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -33,6 +33,7 @@
 #include <linux/moduleparam.h>
 
 #include <drm/drmP.h>
+#include <drm/drm_client.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_fourcc.h>
 #include <drm/drm_crtc_helper.h>
@@ -559,6 +560,8 @@ void drm_kms_helper_hotplug_event(struct drm_device *dev)
 	drm_sysfs_hotplug_event(dev);
 	if (dev->mode_config.funcs->output_poll_changed)
 		dev->mode_config.funcs->output_poll_changed(dev);
+
+	drm_client_dev_hotplug(dev);
 }
 EXPORT_SYMBOL(drm_kms_helper_hotplug_event);
 

commit 83aefbb887b59df0b3520965c3701e01deacfc52
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jun 28 16:13:09 2018 +0300

    drm: Add drm_connector_for_each_possible_encoder()
    
    Add a convenience macro for iterating connector->encoder_ids[].
    Isolates the users from the implementation details.
    
    Note that we don't seem to pass the file_priv down to drm_encoder_find()
    because encoders apparently don't get leased. No idea why
    drm_encoder_finc() even takes the file_priv actually.
    
    Also use ARRAY_SIZE() when populating the array to avoid spreading
    knowledge about the array size all over.
    
    v2: Hide the drm_encoder_find() in the macro, and
        rename the macro appropriately (Daniel)
    v3: Fix kernel docs (Daniel)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180628131315.14156-4-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 527743394150..1a901fe9e23e 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -88,9 +88,9 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 			    struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
-	uint32_t *ids = connector->encoder_ids;
 	enum drm_mode_status ret = MODE_OK;
-	unsigned int i;
+	struct drm_encoder *encoder;
+	int i;
 
 	/* Step 1: Validate against connector */
 	ret = drm_connector_mode_valid(connector, mode);
@@ -98,13 +98,9 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 		return ret;
 
 	/* Step 2: Validate against encoders and crtcs */
-	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
-		struct drm_encoder *encoder = drm_encoder_find(dev, NULL, ids[i]);
+	drm_connector_for_each_possible_encoder(connector, encoder, i) {
 		struct drm_crtc *crtc;
 
-		if (!encoder)
-			continue;
-
 		ret = drm_encoder_mode_valid(encoder, mode);
 		if (ret != MODE_OK) {
 			/* No point in continuing for crtc check as this encoder

commit 2b4f44eec2be2688511c2b617d0e1b4f94c45ba4
Merge: 33d009cd8894 3eb2ce825ea1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 28 14:30:41 2018 +1000

    Backmerge tag 'v4.16-rc7' into drm-next
    
    Linux 4.16-rc7
    
    This was requested by Daniel, and things were getting
    a bit hard to reconcile, most of the conflicts were
    trivial though.

commit dfe8db22372873d205c78a9fd5370b1b088a2b87
Merge: ccffc9ebfa66 30a3317ddc24
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 22 08:39:26 2018 +1000

    Merge tag 'drm-misc-fixes-2018-02-21' of git://anongit.freedesktop.org/drm/drm-misc into drm-fixes
    
    Fixes for 4.16. I contains fixes for deadlock on runtime suspend on few
    drivers, a memory leak on non-blocking commits, a crash on color-eviction.
    The is also meson and edid fixes, plus a fix for a doc warning.
    
    * tag 'drm-misc-fixes-2018-02-21' of git://anongit.freedesktop.org/drm/drm-misc:
      drm/tve200: fix kernel-doc documentation comment include
      drm/meson: fix vsync buffer update
      drm: Handle unexpected holes in color-eviction
      drm/edid: Add 6 bpc quirk for CPT panel in Asus UX303LA
      drm/amdgpu: Fix deadlock on runtime suspend
      drm/radeon: Fix deadlock on runtime suspend
      drm/nouveau: Fix deadlock on runtime suspend
      drm: Allow determining if current task is output poll worker
      workqueue: Allow retrieval of current task's work struct
      drm/atomic: Fix memleak on ERESTARTSYS during non-blocking commits

commit 25c058ccaf2ebbc3e250ec1e199e161f91fe27d4
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Feb 14 06:41:25 2018 +0100

    drm: Allow determining if current task is output poll worker
    
    Introduce a helper to determine if the current task is an output poll
    worker.
    
    This allows us to fix a long-standing deadlock in several DRM drivers
    wherein the ->runtime_suspend callback waits for the output poll worker
    to finish and the worker in turn calls a ->detect callback which waits
    for runtime suspend to finish.  The ->detect callback is invoked from
    multiple call sites and waiting for runtime suspend to finish is the
    correct thing to do except if it's executing in the context of the
    worker.
    
    v2: Expand kerneldoc to specifically mention deadlock between
        output poll worker and autosuspend worker as use case. (Lyude)
    
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/3549ce32e7f1467102e70d3e9cbf70c46bfe108e.1518593424.git.lukas@wunner.de

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6dc2dde5b672..7a6b2dc08913 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -654,6 +654,26 @@ static void output_poll_execute(struct work_struct *work)
 		schedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);
 }
 
+/**
+ * drm_kms_helper_is_poll_worker - is %current task an output poll worker?
+ *
+ * Determine if %current task is an output poll worker.  This can be used
+ * to select distinct code paths for output polling versus other contexts.
+ *
+ * One use case is to avoid a deadlock between the output poll worker and
+ * the autosuspend worker wherein the latter waits for polling to finish
+ * upon calling drm_kms_helper_poll_disable(), while the former waits for
+ * runtime suspend to finish upon calling pm_runtime_get_sync() in a
+ * connector ->detect hook.
+ */
+bool drm_kms_helper_is_poll_worker(void)
+{
+	struct work_struct *work = current_work();
+
+	return work && work->func == output_poll_execute;
+}
+EXPORT_SYMBOL(drm_kms_helper_is_poll_worker);
+
 /**
  * drm_kms_helper_poll_disable - disable output polling
  * @dev: drm_device

commit 75a655e0a26cf0bfbaaa8df0ff5a9d1807bb1f4e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:57 2017 +0200

    drm/modes: Provide global mode_valid hook
    
    Allow drivers to provide a device wide .mode_valid() hook in addition to
    the already existing crtc/encoder/bridge/connector hooks. This can be
    used to validate device/driver wide constraings without having to add
    those to the other hooks. And since we call this hook also for user
    modes later on in the modeset we don't have to worry about anything the
    hook has already rejected.
    
    I also have some further ideas for this hook. Eg. we could replace the
    drm_mode_set_crtcinfo(HALVE_V) call in drm_mode_convert_umode()/etc.
    with a driver specific variant via this hook. At least on i915 we would
    like to pass CRTC_STEREO_DOUBLE to that function instead, and then
    we could safely use the crtc_ timings in all our .mode_valid() hooks,
    which would allow us to reuse those hooks for validating the
    adjusted_mode during a modeset.
    
    v2: Fix the language fails in the kernel docs (Daniel)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-10-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 555fbe54d6e2..2d1643bdae78 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -499,7 +499,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	list_for_each_entry(mode, &connector->modes, head) {
 		if (mode->status == MODE_OK)
-			mode->status = drm_mode_validate_basic(mode);
+			mode->status = drm_mode_validate_driver(dev, mode);
 
 		if (mode->status == MODE_OK)
 			mode->status = drm_mode_validate_size(mode, maxX, maxY);

commit b66d0f348624101203dbec22e45c74e1c895b881
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Mon Nov 6 20:18:07 2017 +0100

    drm/probe-helper: Fix drm_kms_helper_poll_enable() docs
    
    Fix docs to reflect code and drm_kms_helper_poll_disable() docs by saying
    that calling drm_kms_helper_poll_enable() is fine even if output polling
    is not enabled.
    
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171106191812.38927-2-noralf@tronnes.org

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6dc2dde5b672..555fbe54d6e2 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -216,8 +216,7 @@ enum drm_mode_status drm_connector_mode_valid(struct drm_connector *connector,
  * suspend/resume.
  *
  * Drivers can call this helper from their device resume implementation. It is
- * an error to call this when the output polling support has not yet been set
- * up.
+ * not an error to call this even when output polling isn't enabled.
  *
  * Note that calls to enable and disable polling must be strictly ordered, which
  * is automatically the case when they're only call from suspend/resume

commit 418da17214aca5ef5f0b6f7588905ee7df92f98f
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Mar 14 23:25:07 2017 -0700

    drm: Pass struct drm_file * to __drm_mode_object_find [v2]
    
    This will allow __drm_mode_object_file to be extended to perform
    access control checks based on the file in use.
    
    v2: Also fix up vboxvideo driver in staging
    
    [airlied: merging early as this is an API change]
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 5840aabbf24e..6dc2dde5b672 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -99,7 +99,7 @@ drm_mode_validate_pipeline(struct drm_display_mode *mode,
 
 	/* Step 2: Validate against encoders and crtcs */
 	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
-		struct drm_encoder *encoder = drm_encoder_find(dev, ids[i]);
+		struct drm_encoder *encoder = drm_encoder_find(dev, NULL, ids[i]);
 		struct drm_crtc *crtc;
 
 		if (!encoder)

commit 53fd40a90f3c0bdad86ec266ee5df833f54ace39
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Sep 12 11:19:26 2017 +0300

    drm: handle override and firmware EDID at drm_do_get_edid() level
    
    Handle debugfs override edid and firmware edid at the low level to
    transparently and completely replace the real edid. Previously, we
    practically only used the modes from the override EDID, and none of the
    other data, such as audio parameters.
    
    This change also prevents actual EDID reads when the EDID is to be
    overridden, but retains the DDC probe. This is useful if the reason for
    preferring override EDID are problems with reading the data, or
    corruption of the data.
    
    Move firmware EDID loading from helper to core, as the functionality
    moves to lower level as well. This will result in a change of module
    parameter from drm_kms_helper.edid_firmware to drm.edid_firmware, which
    arguably makes more sense anyway.
    
    Some future work remains related to override and firmware EDID
    validation. Like before, no validation is done for override EDID. The
    firmware EDID is validated separately in the loader. Some unification
    and deduplication would be in order, to validate all of them at the
    drm_do_get_edid() level, like "real" EDIDs.
    
    v2: move firmware loading to core
    
    v3: rebase, commit message refresh
    
    Cc: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1e8a710bcac46e5136c1a7b430074893c81f364a.1505203831.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 904966cde32b..5840aabbf24e 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -353,8 +353,6 @@ EXPORT_SYMBOL(drm_helper_probe_detect);
  *    drm_mode_probed_add(). New modes start their life with status as OK.
  *    Modes are added from a single source using the following priority order.
  *
- *    - debugfs 'override_edid' (used for testing only)
- *    - firmware EDID (drm_load_edid_firmware())
  *    - &drm_connector_helper_funcs.get_modes vfunc
  *    - if the connector status is connector_status_connected, standard
  *      VESA DMT modes up to 1024x768 are automatically added
@@ -483,22 +481,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		goto prune;
 	}
 
-	if (connector->override_edid) {
-		struct edid *edid = (struct edid *) connector->edid_blob_ptr->data;
-
-		count = drm_add_edid_modes(connector, edid);
-		drm_edid_to_eld(connector, edid);
-	} else {
-		struct edid *edid = drm_load_edid_firmware(connector);
-		if (!IS_ERR_OR_NULL(edid)) {
-			drm_mode_connector_update_edid_property(connector, edid);
-			count = drm_add_edid_modes(connector, edid);
-			drm_edid_to_eld(connector, edid);
-			kfree(edid);
-		}
-		if (count == 0)
-			count = (*connector_funcs->get_modes)(connector);
-	}
+	count = (*connector_funcs->get_modes)(connector);
 
 	if (count == 0 && connector->status == connector_status_connected)
 		count = drm_add_modes_noedid(connector, 1024, 768);

commit d85231530b0719e23a62d92ee35712da966e281a
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:11 2017 +0530

    drm: add helper to validate YCBCR420 modes
    
    YCBCR420 modes are supported only on HDMI 2.0 capable sources.
    This patch adds:
    - A drm helper to validate YCBCR420-only mode on a particular
      connector. This function will help pruning the YCBCR420-only
      modes from the connector's modelist.
    - A bool variable (ycbcr_420_allowed) in the drm connector structure.
      While handling the EDID from HDMI 2.0 sinks, its important to know
      if the source is capable of handling YCBCR420 output, so that no
      YCBCR 420 modes will be listed for sources which can't handle it.
      A driver should set this variable if it wants to see YCBCR420 modes
      in the modedb.
    
    V5: Introduced the patch in series.
    V6: Squashed two patches (validate YCBCR420 and add YCBCR420
               identifier)
    V7: Addressed review comments from Vile:
        - Move this patch before we add 420 modes from EDID.
        - No need for drm_valid_cea_vic() check, function back to non-static.
        - Update MODE_STATUS with NO_420 condition.
        - Introduce y420_vdb_modes variable in this patch
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-6-git-send-email-shashank.sharma@intel.com
    [vsyrjala: Drop the now bogus EXPORT_SYMBOL(drm_valid_cea_vic)]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 00e6832a8c1a..904966cde32b 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -528,6 +528,10 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		if (mode->status == MODE_OK)
 			mode->status = drm_mode_validate_pipeline(mode,
 								  connector);
+
+		if (mode->status == MODE_OK)
+			mode->status = drm_mode_validate_ycbcr420(mode,
+								  connector);
 	}
 
 prune:

commit 97f973d652602425f4dc31a13e8605d5841afe25
Author: Jose Abreu <Jose.Abreu@synopsys.com>
Date:   Thu May 25 15:19:15 2017 +0100

    drm: Use new mode_valid() helpers in connector probe helper
    
    This changes the connector probe helper function to use the new
    encoder->mode_valid(), bridge->mode_valid() and crtc->mode_valid()
    helper callbacks to validate the modes.
    
    The new callbacks are optional so the behaviour remains the same
    if they are not implemented. If they are, then the code loops
    through all the connector's encodersXbridgesXcrtcs and calls the
    callback.
    
    If at least a valid encoderXbridgeXcrtc combination is found which
    accepts the mode then the function returns MODE_OK.
    
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Carlos Palminha <palminha@synopsys.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    
    Changes v3->v4:
            - Change function name (Laurent)
    Changes v2->v3:
            - Call also bridge->mode_valid (Daniel)
    Changes v1->v2:
            - Use new helpers suggested by Ville
            - Change documentation (Daniel)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/d4e3ba87d822fa92f1b8773e441b9a02af3bde71.1495720737.git.joabreu@synopsys.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index f01abdc124d2..00e6832a8c1a 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -83,6 +83,61 @@ drm_mode_validate_flag(const struct drm_display_mode *mode,
 	return MODE_OK;
 }
 
+static enum drm_mode_status
+drm_mode_validate_pipeline(struct drm_display_mode *mode,
+			    struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	uint32_t *ids = connector->encoder_ids;
+	enum drm_mode_status ret = MODE_OK;
+	unsigned int i;
+
+	/* Step 1: Validate against connector */
+	ret = drm_connector_mode_valid(connector, mode);
+	if (ret != MODE_OK)
+		return ret;
+
+	/* Step 2: Validate against encoders and crtcs */
+	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
+		struct drm_encoder *encoder = drm_encoder_find(dev, ids[i]);
+		struct drm_crtc *crtc;
+
+		if (!encoder)
+			continue;
+
+		ret = drm_encoder_mode_valid(encoder, mode);
+		if (ret != MODE_OK) {
+			/* No point in continuing for crtc check as this encoder
+			 * will not accept the mode anyway. If all encoders
+			 * reject the mode then, at exit, ret will not be
+			 * MODE_OK. */
+			continue;
+		}
+
+		ret = drm_bridge_mode_valid(encoder->bridge, mode);
+		if (ret != MODE_OK) {
+			/* There is also no point in continuing for crtc check
+			 * here. */
+			continue;
+		}
+
+		drm_for_each_crtc(crtc, dev) {
+			if (!drm_encoder_crtc_ok(encoder, crtc))
+				continue;
+
+			ret = drm_crtc_mode_valid(crtc, mode);
+			if (ret == MODE_OK) {
+				/* If we get to this point there is at least
+				 * one combination of encoder+crtc that works
+				 * for this mode. Lets return now. */
+				return ret;
+			}
+		}
+	}
+
+	return ret;
+}
+
 static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 {
 	struct drm_cmdline_mode *cmdline_mode;
@@ -322,7 +377,11 @@ EXPORT_SYMBOL(drm_helper_probe_detect);
  *    - drm_mode_validate_flag() checks the modes against basic connector
  *      capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)
  *    - the optional &drm_connector_helper_funcs.mode_valid helper can perform
- *      driver and/or hardware specific checks
+ *      driver and/or sink specific checks
+ *    - the optional &drm_crtc_helper_funcs.mode_valid,
+ *      &drm_bridge_funcs.mode_valid and &drm_encoder_helper_funcs.mode_valid
+ *      helpers can perform driver and/or source specific checks which are also
+ *      enforced by the modeset/atomic helpers
  *
  * 5. Any mode whose status is not OK is pruned from the connector's modes list,
  *    accompanied by a debug message indicating the reason for the mode's
@@ -466,9 +525,9 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		if (mode->status == MODE_OK)
 			mode->status = drm_mode_validate_flag(mode, mode_flags);
 
-		if (mode->status == MODE_OK && connector_funcs->mode_valid)
-			mode->status = connector_funcs->mode_valid(connector,
-								   mode);
+		if (mode->status == MODE_OK)
+			mode->status = drm_mode_validate_pipeline(mode,
+								  connector);
 	}
 
 prune:

commit da251bf8f93513519a3c18b2b2290557ea5ba860
Author: Jose Abreu <Jose.Abreu@synopsys.com>
Date:   Thu May 25 15:19:13 2017 +0100

    drm: Add drm_{crtc/encoder/connector}_mode_valid()
    
    Add a new helper to call crtc->mode_valid, connector->mode_valid
    and encoder->mode_valid callbacks.
    
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Carlos Palminha <palminha@synopsys.com>
    Cc: Dave Airlie <airlied@linux.ie>
    
    Changes v2->v3:
            - Move helpers to drm_probe_helper.c (Daniel)
            - Squeeze patches that introduce helpers into a single
            one (Daniel)
    
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    [danvet: Make it compile when CONFIG_DRM_DP_AUX_CHARDEV is selected.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/b55c8bd029da219ff04e39086025c115731a49b1.1495720737.git.joabreu@synopsys.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 1b0c14ab3fff..f01abdc124d2 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -38,6 +38,9 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_edid.h>
+#include <drm/drm_modeset_helper_vtables.h>
+
+#include "drm_crtc_helper_internal.h"
 
 /**
  * DOC: output probing helper overview
@@ -113,6 +116,41 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 	return 1;
 }
 
+enum drm_mode_status drm_crtc_mode_valid(struct drm_crtc *crtc,
+					 const struct drm_display_mode *mode)
+{
+	const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
+
+	if (!crtc_funcs || !crtc_funcs->mode_valid)
+		return MODE_OK;
+
+	return crtc_funcs->mode_valid(crtc, mode);
+}
+
+enum drm_mode_status drm_encoder_mode_valid(struct drm_encoder *encoder,
+					    const struct drm_display_mode *mode)
+{
+	const struct drm_encoder_helper_funcs *encoder_funcs =
+		encoder->helper_private;
+
+	if (!encoder_funcs || !encoder_funcs->mode_valid)
+		return MODE_OK;
+
+	return encoder_funcs->mode_valid(encoder, mode);
+}
+
+enum drm_mode_status drm_connector_mode_valid(struct drm_connector *connector,
+					      struct drm_display_mode *mode)
+{
+	const struct drm_connector_helper_funcs *connector_funcs =
+		connector->helper_private;
+
+	if (!connector_funcs || !connector_funcs->mode_valid)
+		return MODE_OK;
+
+	return connector_funcs->mode_valid(connector, mode);
+}
+
 #define DRM_OUTPUT_POLL_PERIOD (10*HZ)
 /**
  * drm_kms_helper_poll_enable - re-enable output polling.

commit 6c5ed5ae353cdf156f9ac4db17e15db56b4de880
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Apr 6 20:55:20 2017 +0200

    drm/atomic: Acquire connection_mutex lock in drm_helper_probe_single_connector_modes, v4.
    
    mode_valid() called from drm_helper_probe_single_connector_modes()
    may need to look at connector->state because what a valid mode is may
    depend on connector properties being set. For example some HDMI modes
    might be rejected when a connector property forces the connector
    into DVI mode.
    
    Some implementations of detect() already lock all state,
    so we have to pass an acquire_ctx to them to prevent a deadlock.
    
    This means changing the function signature of detect() slightly,
    and passing the acquire_ctx for locking multiple crtc's.
    For the callbacks, it will always be non-zero. To allow callers
    not to worry about this, drm_helper_probe_detect_ctx is added
    which might handle -EDEADLK for you.
    
    Changes since v1:
    - Always set ctx parameter.
    Changes since v2:
    - Always take connection_mutex when probing.
    Changes since v3:
    - Remove the ctx from intel_dp_long_pulse, and add
      WARN_ON(!connection_mutex) (danvet)
    - Update docs to clarify the locking situation. (danvet)
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1491504920-4017-1-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index efb5e5e8ce62..1b0c14ab3fff 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -169,12 +169,73 @@ void drm_kms_helper_poll_enable(struct drm_device *dev)
 EXPORT_SYMBOL(drm_kms_helper_poll_enable);
 
 static enum drm_connector_status
-drm_connector_detect(struct drm_connector *connector, bool force)
+drm_helper_probe_detect_ctx(struct drm_connector *connector, bool force)
 {
-	return connector->funcs->detect ?
-		connector->funcs->detect(connector, force) :
-		connector_status_connected;
+	const struct drm_connector_helper_funcs *funcs = connector->helper_private;
+	struct drm_modeset_acquire_ctx ctx;
+	int ret;
+
+	drm_modeset_acquire_init(&ctx, 0);
+
+retry:
+	ret = drm_modeset_lock(&connector->dev->mode_config.connection_mutex, &ctx);
+	if (!ret) {
+		if (funcs->detect_ctx)
+			ret = funcs->detect_ctx(connector, &ctx, force);
+		else if (connector->funcs->detect)
+			ret = connector->funcs->detect(connector, force);
+		else
+			ret = connector_status_connected;
+	}
+
+	if (ret == -EDEADLK) {
+		drm_modeset_backoff(&ctx);
+		goto retry;
+	}
+
+	if (WARN_ON(ret < 0))
+		ret = connector_status_unknown;
+
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+
+	return ret;
+}
+
+/**
+ * drm_helper_probe_detect - probe connector status
+ * @connector: connector to probe
+ * @ctx: acquire_ctx, or NULL to let this function handle locking.
+ * @force: Whether destructive probe operations should be performed.
+ *
+ * This function calls the detect callbacks of the connector.
+ * This function returns &drm_connector_status, or
+ * if @ctx is set, it might also return -EDEADLK.
+ */
+int
+drm_helper_probe_detect(struct drm_connector *connector,
+			struct drm_modeset_acquire_ctx *ctx,
+			bool force)
+{
+	const struct drm_connector_helper_funcs *funcs = connector->helper_private;
+	struct drm_device *dev = connector->dev;
+	int ret;
+
+	if (!ctx)
+		return drm_helper_probe_detect_ctx(connector, force);
+
+	ret = drm_modeset_lock(&dev->mode_config.connection_mutex, ctx);
+	if (ret)
+		return ret;
+
+	if (funcs->detect_ctx)
+		return funcs->detect_ctx(connector, ctx, force);
+	else if (connector->funcs->detect)
+		return connector->funcs->detect(connector, force);
+	else
+		return connector_status_connected;
 }
+EXPORT_SYMBOL(drm_helper_probe_detect);
 
 /**
  * drm_helper_probe_single_connector_modes - get complete set of display modes
@@ -239,15 +300,27 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	struct drm_display_mode *mode;
 	const struct drm_connector_helper_funcs *connector_funcs =
 		connector->helper_private;
-	int count = 0;
+	int count = 0, ret;
 	int mode_flags = 0;
 	bool verbose_prune = true;
 	enum drm_connector_status old_status;
+	struct drm_modeset_acquire_ctx ctx;
 
 	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
 
+	drm_modeset_acquire_init(&ctx, 0);
+
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
 			connector->name);
+
+retry:
+	ret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);
+	if (ret == -EDEADLK) {
+		drm_modeset_backoff(&ctx);
+		goto retry;
+	} else
+		WARN_ON(ret < 0);
+
 	/* set all old modes to the stale state */
 	list_for_each_entry(mode, &connector->modes, head)
 		mode->status = MODE_STALE;
@@ -263,7 +336,15 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
 	} else {
-		connector->status = drm_connector_detect(connector, true);
+		ret = drm_helper_probe_detect(connector, &ctx, true);
+
+		if (ret == -EDEADLK) {
+			drm_modeset_backoff(&ctx);
+			goto retry;
+		} else if (WARN(ret < 0, "Invalid return value %i for connector detection\n", ret))
+			ret = connector_status_unknown;
+
+		connector->status = ret;
 	}
 
 	/*
@@ -355,6 +436,9 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 prune:
 	drm_mode_prune_invalid(dev, &connector->modes, verbose_prune);
 
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+
 	if (list_empty(&connector->modes))
 		return 0;
 
@@ -440,7 +524,7 @@ static void output_poll_execute(struct work_struct *work)
 
 		repoll = true;
 
-		connector->status = drm_connector_detect(connector, false);
+		connector->status = drm_helper_probe_detect(connector, NULL, false);
 		if (old_status != connector->status) {
 			const char *old, *new;
 
@@ -588,7 +672,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 
 		old_status = connector->status;
 
-		connector->status = drm_connector_detect(connector, false);
+		connector->status = drm_helper_probe_detect(connector, NULL, false);
 		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
 			      connector->base.id,
 			      connector->name,

commit 1bbfe9d1a315bb573d4f10bbf443b68b5ddac473
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 4 11:53:04 2017 +0200

    drm/doc: Small markup fixup
    
    Drive-by cleanup.
    
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170404095304.17599-11-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 85005d57bde6..efb5e5e8ce62 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -44,7 +44,7 @@
  *
  * This library provides some helper code for output probing. It provides an
  * implementation of the core &drm_connector_funcs.fill_modes interface with
- * drm_helper_probe_single_connector_modes.
+ * drm_helper_probe_single_connector_modes().
  *
  * It also provides support for polling connectors with a work item and for
  * generic hotplug interrupt handling where the driver doesn't or cannot keep

commit b70366e5d31788650b2a5cec5cd13ea80ac7e44a
Merge: f42e181935d5 db6ccf23e8ba
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 14 15:07:33 2017 +0100

    Merge tag 'doc-4.11-images' of git://git.lwn.net/linux into drm-misc-next
    
    Pointer for Markus's image conversion work.
    
    We need this so we can merge all the pretty drm graphs for 4.12.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit b982dab1e66d2b998e80a97acb6eaf56518988d3
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 28 15:46:43 2017 +0100

    drm: Rename connector list iterator API
    
    Currently the functions that initialize and tear down a connector
    iterator use the _get() and _put() suffixes. However, these suffixes
    are typically used by reference counting functions.
    
    Make these function names a little more consistent by changing the
    suffixes to _begin() and _end(), which is a fairly common pattern in
    the rest of the Linux kernel.
    
    Suggested-by: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170228144643.5668-8-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 358957118ca9..03d376f91c23 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -140,13 +140,13 @@ void drm_kms_helper_poll_enable(struct drm_device *dev)
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	drm_for_each_connector_iter(connector, &conn_iter) {
 		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
 					 DRM_CONNECTOR_POLL_DISCONNECT))
 			poll = true;
 	}
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 
 	if (dev->mode_config.delayed_event) {
 		/*
@@ -420,7 +420,7 @@ static void output_poll_execute(struct work_struct *work)
 		goto out;
 	}
 
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	drm_for_each_connector_iter(connector, &conn_iter) {
 		/* Ignore forced connectors. */
 		if (connector->force)
@@ -474,7 +474,7 @@ static void output_poll_execute(struct work_struct *work)
 			changed = true;
 		}
 	}
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 
 	mutex_unlock(&dev->mode_config.mutex);
 
@@ -580,7 +580,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		return false;
 
 	mutex_lock(&dev->mode_config.mutex);
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	drm_for_each_connector_iter(connector, &conn_iter) {
 		/* Only handle HPD capable connectors. */
 		if (!(connector->polled & DRM_CONNECTOR_POLL_HPD))
@@ -597,7 +597,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		if (old_status != connector->status)
 			changed = true;
 	}
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 	mutex_unlock(&dev->mode_config.mutex);
 
 	if (changed)

commit 57366a8d0bf24181fea3e9d5b772175059914a3c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 27 14:29:12 2017 -0800

    scripts/spelling.txt: add "againt" pattern and fix typo instances
    
    Fix typos and add the following to the scripts/spelling.txt:
    
      againt||against
    
    While we are here, fix the "capabilites" as well in the touched hunk in
    drivers/gpu/drm/drm_probe_helper.c.
    
    Link: http://lkml.kernel.org/r/1481573103-11329-13-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 93381454bdf7..dc4419ada12c 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -220,8 +220,8 @@ drm_connector_detect(struct drm_connector *connector, bool force)
  *    - drm_mode_validate_basic() performs basic sanity checks
  *    - drm_mode_validate_size() filters out modes larger than @maxX and @maxY
  *      (if specified)
- *    - drm_mode_validate_flag() checks the modes againt basic connector
- *      capabilites (interlace_allowed,doublescan_allowed,stereo_allowed)
+ *    - drm_mode_validate_flag() checks the modes against basic connector
+ *      capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)
  *    - the optional &drm_connector_helper_funcs.mode_valid helper can perform
  *      driver and/or hardware specific checks
  *

commit 07c2b84b9956dd5d0871d47f5f0bbf9388d2d83f
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Feb 17 17:20:51 2017 +0200

    drm: move edid property update and add modes out of edid firmware loader
    
    Make the firmware loader more generic and generally useful.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1487344854-18777-2-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 93381454bdf7..358957118ca9 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -311,7 +311,13 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		count = drm_add_edid_modes(connector, edid);
 		drm_edid_to_eld(connector, edid);
 	} else {
-		count = drm_load_edid_firmware(connector);
+		struct edid *edid = drm_load_edid_firmware(connector);
+		if (!IS_ERR_OR_NULL(edid)) {
+			drm_mode_connector_update_edid_property(connector, edid);
+			count = drm_add_edid_modes(connector, edid);
+			drm_edid_to_eld(connector, edid);
+			kfree(edid);
+		}
 		if (count == 0)
 			count = (*connector_funcs->get_modes)(connector);
 	}

commit 012bbe28c0e3a479ec7ba6f311710cf8409647d4
Merge: bb7e98334157 55d661658536
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Feb 1 08:31:09 2017 +1000

    Merge tag 'drm-misc-next-2017-01-30' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    Another round of -misc stuff:
    - Noralf debugfs cleanup cleanup (not yet everything, some more driver
      patches awaiting acks).
    - More doc work.
    - edid/infoframe fixes from Ville.
    - misc 1-patch fixes all over, as usual
    
    Noralf needs this for his tinydrm pull request.
    
    * tag 'drm-misc-next-2017-01-30' of git://anongit.freedesktop.org/git/drm-misc: (48 commits)
      drm/vc4: Remove vc4_debugfs_cleanup()
      dma/fence: Export enable-signaling tracepoint for emission by drivers
      drm/tilcdc: Remove tilcdc_debugfs_cleanup()
      drm/tegra: Remove tegra_debugfs_cleanup()
      drm/sti: Remove drm_debugfs_remove_files() calls
      drm/radeon: Remove drm_debugfs_remove_files() call
      drm/omap: Remove omap_debugfs_cleanup()
      drm/hdlcd: Remove hdlcd_debugfs_cleanup()
      drm/etnaviv: Remove etnaviv_debugfs_cleanup()
      drm/etnaviv: allow build with COMPILE_TEST
      drm/amd/amdgpu: Remove drm_debugfs_remove_files() call
      drm/prime: Clarify DMA-BUF/GEM Object lifetime
      drm/ttm: Make sure BOs being swapped out are cacheable
      drm/atomic: Remove drm_atomic_debugfs_cleanup()
      drm: drm_minor_register(): Clean up debugfs on failure
      drm: debugfs: Remove all files automatically on cleanup
      drm/fourcc: add vivante tiled layout format modifiers
      drm/edid: Set YQ bits in the AVI infoframe according to CEA-861-F
      drm/edid: Set AVI infoframe Q even when QS=0
      drm/edid: Introduce drm_hdmi_avi_infoframe_quant_range()
      ...

commit c4d79c22015564a9d922715434a0ec09d1deee30
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 27 12:04:08 2017 +1000

    Reinstate "drm/probe-helpers: Drop locking from poll_enable""
    
    This reverts commit 54a07c7bb0da0343734c78212bbe9f3735394962,
    and reinstates the original.
    
    [airlied: this might be a bad plan for git].
    
    commit 3846fd9b86001bea171943cc3bb9222cb6da6b42
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Jan 11 10:01:17 2017 +0100
    
        drm/probe-helpers: Drop locking from poll_enable
    
        It was only needed to protect the connector_list walking, see
    
        commit 8c4ccc4ab6f64e859d4ff8d7c02c2ed2e956e07f
        Author: Daniel Vetter <daniel.vetter@ffwll.ch>
        Date:   Thu Jul 9 23:44:26 2015 +0200
    
            drm/probe-helper: Grab mode_config.mutex in poll_init/enable
    
        Unfortunately the commit message of that patch fails to mention that
        the new locking check was for the connector_list.
    
        But that requirement disappeared in
    
        commit c36a3254f7857f1ad9badbe3578ccc92be541a8e
        Author: Daniel Vetter <daniel.vetter@ffwll.ch>
        Date:   Thu Dec 15 16:58:43 2016 +0100
    
            drm: Convert all helpers to drm_connector_list_iter
    
        and so we can drop this again.
    
        This fixes a locking inversion on nouveau, where the rpm code needs to
        re-enable. But in other places the rpm_get() calls are nested within
        the big modeset locks.
    
        While at it, also improve the kerneldoc for these two functions a
        notch.
    
        v2: Update the kerneldoc even more to explain that these functions
        can't be called concurrently, or bad things happen (Chris).

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 79519e4983c7..041a5504780f 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -115,25 +115,28 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 
 #define DRM_OUTPUT_POLL_PERIOD (10*HZ)
 /**
- * drm_kms_helper_poll_enable_locked - re-enable output polling.
+ * drm_kms_helper_poll_enable - re-enable output polling.
  * @dev: drm_device
  *
- * This function re-enables the output polling work without
- * locking the mode_config mutex.
+ * This function re-enables the output polling work, after it has been
+ * temporarily disabled using drm_kms_helper_poll_disable(), for example over
+ * suspend/resume.
  *
- * This is like drm_kms_helper_poll_enable() however it is to be
- * called from a context where the mode_config mutex is locked
- * already.
+ * Drivers can call this helper from their device resume implementation. It is
+ * an error to call this when the output polling support has not yet been set
+ * up.
+ *
+ * Note that calls to enable and disable polling must be strictly ordered, which
+ * is automatically the case when they're only call from suspend/resume
+ * callbacks.
  */
-void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
+void drm_kms_helper_poll_enable(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
 	struct drm_connector_list_iter conn_iter;
 	unsigned long delay = DRM_OUTPUT_POLL_PERIOD;
 
-	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
-
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
@@ -163,7 +166,7 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 	if (poll)
 		schedule_delayed_work(&dev->mode_config.output_poll_work, delay);
 }
-EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
+EXPORT_SYMBOL(drm_kms_helper_poll_enable);
 
 static enum drm_connector_status
 drm_connector_detect(struct drm_connector *connector, bool force)
@@ -290,7 +293,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	/* Re-enable polling in case the global poll config changed. */
 	if (drm_kms_helper_poll != dev->mode_config.poll_running)
-		drm_kms_helper_poll_enable_locked(dev);
+		drm_kms_helper_poll_enable(dev);
 
 	dev->mode_config.poll_running = drm_kms_helper_poll;
 
@@ -484,8 +487,12 @@ static void output_poll_execute(struct work_struct *work)
  * This function disables the output polling work.
  *
  * Drivers can call this helper from their device suspend implementation. It is
- * not an error to call this even when output polling isn't enabled or arlready
- * disabled.
+ * not an error to call this even when output polling isn't enabled or already
+ * disabled. Polling is re-enabled by calling drm_kms_helper_poll_enable().
+ *
+ * Note that calls to enable and disable polling must be strictly ordered, which
+ * is automatically the case when they're only call from suspend/resume
+ * callbacks.
  */
 void drm_kms_helper_poll_disable(struct drm_device *dev)
 {
@@ -495,24 +502,6 @@ void drm_kms_helper_poll_disable(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_disable);
 
-/**
- * drm_kms_helper_poll_enable - re-enable output polling.
- * @dev: drm_device
- *
- * This function re-enables the output polling work.
- *
- * Drivers can call this helper from their device resume implementation. It is
- * an error to call this when the output polling support has not yet been set
- * up.
- */
-void drm_kms_helper_poll_enable(struct drm_device *dev)
-{
-	mutex_lock(&dev->mode_config.mutex);
-	drm_kms_helper_poll_enable_locked(dev);
-	mutex_unlock(&dev->mode_config.mutex);
-}
-EXPORT_SYMBOL(drm_kms_helper_poll_enable);
-
 /**
  * drm_kms_helper_poll_init - initialize and enable output polling
  * @dev: drm_device

commit b0df0b251b25b0bf89ef3e518330fcac300add86
Merge: f0493e653f96 ff9f8a7cf935
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 27 11:00:42 2017 +1000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux into drm-next
    
    Backmerge Linus master to get the connector locking revert.
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux: (645 commits)
      sysctl: fix proc_doulongvec_ms_jiffies_minmax()
      Revert "drm/probe-helpers: Drop locking from poll_enable"
      MAINTAINERS: add Dan Streetman to zbud maintainers
      MAINTAINERS: add Dan Streetman to zswap maintainers
      mm: do not export ioremap_page_range symbol for external module
      mn10300: fix build error of missing fpu_save()
      romfs: use different way to generate fsid for BLOCK or MTD
      frv: add missing atomic64 operations
      mm, page_alloc: fix premature OOM when racing with cpuset mems update
      mm, page_alloc: move cpuset seqcount checking to slowpath
      mm, page_alloc: fix fast-path race with cpuset update or removal
      mm, page_alloc: fix check for NULL preferred_zone
      kernel/panic.c: add missing \n
      fbdev: color map copying bounds checking
      frv: add atomic64_add_unless()
      mm/mempolicy.c: do not put mempolicy before using its nodemask
      radix-tree: fix private list warnings
      Documentation/filesystems/proc.txt: add VmPin
      mm, memcg: do not retry precharge charges
      proc: add a schedule point in proc_pid_readdir()
      ...

commit 54a07c7bb0da0343734c78212bbe9f3735394962
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 26 06:44:03 2017 +1000

    Revert "drm/probe-helpers: Drop locking from poll_enable"
    
    This reverts commit 3846fd9b86001bea171943cc3bb9222cb6da6b42.
    
    There were some precursor commits missing for this around connector
    locking, we should probably merge Lyude's nouveau avoid the problem patch.

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index b452a7ccd84b..cf8f0128c161 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -115,27 +115,24 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 
 #define DRM_OUTPUT_POLL_PERIOD (10*HZ)
 /**
- * drm_kms_helper_poll_enable - re-enable output polling.
+ * drm_kms_helper_poll_enable_locked - re-enable output polling.
  * @dev: drm_device
  *
- * This function re-enables the output polling work, after it has been
- * temporarily disabled using drm_kms_helper_poll_disable(), for example over
- * suspend/resume.
+ * This function re-enables the output polling work without
+ * locking the mode_config mutex.
  *
- * Drivers can call this helper from their device resume implementation. It is
- * an error to call this when the output polling support has not yet been set
- * up.
- *
- * Note that calls to enable and disable polling must be strictly ordered, which
- * is automatically the case when they're only call from suspend/resume
- * callbacks.
+ * This is like drm_kms_helper_poll_enable() however it is to be
+ * called from a context where the mode_config mutex is locked
+ * already.
  */
-void drm_kms_helper_poll_enable(struct drm_device *dev)
+void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
 	unsigned long delay = DRM_OUTPUT_POLL_PERIOD;
 
+	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
+
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
@@ -163,7 +160,7 @@ void drm_kms_helper_poll_enable(struct drm_device *dev)
 	if (poll)
 		schedule_delayed_work(&dev->mode_config.output_poll_work, delay);
 }
-EXPORT_SYMBOL(drm_kms_helper_poll_enable);
+EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
 
 static enum drm_connector_status
 drm_connector_detect(struct drm_connector *connector, bool force)
@@ -290,7 +287,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	/* Re-enable polling in case the global poll config changed. */
 	if (drm_kms_helper_poll != dev->mode_config.poll_running)
-		drm_kms_helper_poll_enable(dev);
+		drm_kms_helper_poll_enable_locked(dev);
 
 	dev->mode_config.poll_running = drm_kms_helper_poll;
 
@@ -482,12 +479,8 @@ static void output_poll_execute(struct work_struct *work)
  * This function disables the output polling work.
  *
  * Drivers can call this helper from their device suspend implementation. It is
- * not an error to call this even when output polling isn't enabled or already
- * disabled. Polling is re-enabled by calling drm_kms_helper_poll_enable().
- *
- * Note that calls to enable and disable polling must be strictly ordered, which
- * is automatically the case when they're only call from suspend/resume
- * callbacks.
+ * not an error to call this even when output polling isn't enabled or arlready
+ * disabled.
  */
 void drm_kms_helper_poll_disable(struct drm_device *dev)
 {
@@ -497,6 +490,24 @@ void drm_kms_helper_poll_disable(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_disable);
 
+/**
+ * drm_kms_helper_poll_enable - re-enable output polling.
+ * @dev: drm_device
+ *
+ * This function re-enables the output polling work.
+ *
+ * Drivers can call this helper from their device resume implementation. It is
+ * an error to call this when the output polling support has not yet been set
+ * up.
+ */
+void drm_kms_helper_poll_enable(struct drm_device *dev)
+{
+	mutex_lock(&dev->mode_config.mutex);
+	drm_kms_helper_poll_enable_locked(dev);
+	mutex_unlock(&dev->mode_config.mutex);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_enable);
+
 /**
  * drm_kms_helper_poll_init - initialize and enable output polling
  * @dev: drm_device

commit 6806cdf9aa1c822afd89881e48908315aed18451
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:43 2017 +0100

    drm/kms-helpers: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Comments from Gustavo.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Rewiewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 97a32898ef50..060211ac74a1 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -43,7 +43,7 @@
  * DOC: output probing helper overview
  *
  * This library provides some helper code for output probing. It provides an
- * implementation of the core connector->fill_modes interface with
+ * implementation of the core &drm_connector_funcs.fill_modes interface with
  * drm_helper_probe_single_connector_modes.
  *
  * It also provides support for polling connectors with a work item and for
@@ -174,9 +174,9 @@ drm_connector_detect(struct drm_connector *connector, bool force)
  * be added to the connector's probed_modes list, then culled (based on validity
  * and the @maxX, @maxY parameters) and put into the normal modes list.
  *
- * Intended to be used as a generic implementation of the ->fill_modes()
- * @connector vfunc for drivers that use the CRTC helpers for output mode
- * filtering and detection.
+ * Intended to be used as a generic implementation of the
+ * &drm_connector_funcs.fill_modes() vfunc for drivers that use the CRTC helpers
+ * for output mode filtering and detection.
  *
  * The basic procedure is as follows
  *
@@ -188,7 +188,7 @@ drm_connector_detect(struct drm_connector *connector, bool force)
  *
  *    - debugfs 'override_edid' (used for testing only)
  *    - firmware EDID (drm_load_edid_firmware())
- *    - connector helper ->get_modes() vfunc
+ *    - &drm_connector_helper_funcs.get_modes vfunc
  *    - if the connector status is connector_status_connected, standard
  *      VESA DMT modes up to 1024x768 are automatically added
  *      (drm_add_modes_noedid())
@@ -209,8 +209,8 @@ drm_connector_detect(struct drm_connector *connector, bool force)
  *      (if specified)
  *    - drm_mode_validate_flag() checks the modes againt basic connector
  *      capabilites (interlace_allowed,doublescan_allowed,stereo_allowed)
- *    - the optional connector ->mode_valid() helper can perform driver and/or
- *      hardware specific checks
+ *    - the optional &drm_connector_helper_funcs.mode_valid helper can perform
+ *      driver and/or hardware specific checks
  *
  * 5. Any mode whose status is not OK is pruned from the connector's modes list,
  *    accompanied by a debug message indicating the reason for the mode's

commit 3846fd9b86001bea171943cc3bb9222cb6da6b42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 11 10:01:17 2017 +0100

    drm/probe-helpers: Drop locking from poll_enable
    
    It was only needed to protect the connector_list walking, see
    
    commit 8c4ccc4ab6f64e859d4ff8d7c02c2ed2e956e07f
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Jul 9 23:44:26 2015 +0200
    
        drm/probe-helper: Grab mode_config.mutex in poll_init/enable
    
    Unfortunately the commit message of that patch fails to mention that
    the new locking check was for the connector_list.
    
    But that requirement disappeared in
    
    commit c36a3254f7857f1ad9badbe3578ccc92be541a8e
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Dec 15 16:58:43 2016 +0100
    
        drm: Convert all helpers to drm_connector_list_iter
    
    and so we can drop this again.
    
    This fixes a locking inversion on nouveau, where the rpm code needs to
    re-enable. But in other places the rpm_get() calls are nested within
    the big modeset locks.
    
    While at it, also improve the kerneldoc for these two functions a
    notch.
    
    v2: Update the kerneldoc even more to explain that these functions
    can't be called concurrently, or bad things happen (Chris).
    
    Cc: Dave Airlie <airlied@gmail.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Tested-by: Lyude <lyude@redhat.com>
    Reviewed-by: Lyude <lyude@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170111090117.5134-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index cf8f0128c161..b452a7ccd84b 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -115,24 +115,27 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 
 #define DRM_OUTPUT_POLL_PERIOD (10*HZ)
 /**
- * drm_kms_helper_poll_enable_locked - re-enable output polling.
+ * drm_kms_helper_poll_enable - re-enable output polling.
  * @dev: drm_device
  *
- * This function re-enables the output polling work without
- * locking the mode_config mutex.
+ * This function re-enables the output polling work, after it has been
+ * temporarily disabled using drm_kms_helper_poll_disable(), for example over
+ * suspend/resume.
  *
- * This is like drm_kms_helper_poll_enable() however it is to be
- * called from a context where the mode_config mutex is locked
- * already.
+ * Drivers can call this helper from their device resume implementation. It is
+ * an error to call this when the output polling support has not yet been set
+ * up.
+ *
+ * Note that calls to enable and disable polling must be strictly ordered, which
+ * is automatically the case when they're only call from suspend/resume
+ * callbacks.
  */
-void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
+void drm_kms_helper_poll_enable(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
 	unsigned long delay = DRM_OUTPUT_POLL_PERIOD;
 
-	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
-
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
@@ -160,7 +163,7 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 	if (poll)
 		schedule_delayed_work(&dev->mode_config.output_poll_work, delay);
 }
-EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
+EXPORT_SYMBOL(drm_kms_helper_poll_enable);
 
 static enum drm_connector_status
 drm_connector_detect(struct drm_connector *connector, bool force)
@@ -287,7 +290,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	/* Re-enable polling in case the global poll config changed. */
 	if (drm_kms_helper_poll != dev->mode_config.poll_running)
-		drm_kms_helper_poll_enable_locked(dev);
+		drm_kms_helper_poll_enable(dev);
 
 	dev->mode_config.poll_running = drm_kms_helper_poll;
 
@@ -479,8 +482,12 @@ static void output_poll_execute(struct work_struct *work)
  * This function disables the output polling work.
  *
  * Drivers can call this helper from their device suspend implementation. It is
- * not an error to call this even when output polling isn't enabled or arlready
- * disabled.
+ * not an error to call this even when output polling isn't enabled or already
+ * disabled. Polling is re-enabled by calling drm_kms_helper_poll_enable().
+ *
+ * Note that calls to enable and disable polling must be strictly ordered, which
+ * is automatically the case when they're only call from suspend/resume
+ * callbacks.
  */
 void drm_kms_helper_poll_disable(struct drm_device *dev)
 {
@@ -490,24 +497,6 @@ void drm_kms_helper_poll_disable(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_disable);
 
-/**
- * drm_kms_helper_poll_enable - re-enable output polling.
- * @dev: drm_device
- *
- * This function re-enables the output polling work.
- *
- * Drivers can call this helper from their device resume implementation. It is
- * an error to call this when the output polling support has not yet been set
- * up.
- */
-void drm_kms_helper_poll_enable(struct drm_device *dev)
-{
-	mutex_lock(&dev->mode_config.mutex);
-	drm_kms_helper_poll_enable_locked(dev);
-	mutex_unlock(&dev->mode_config.mutex);
-}
-EXPORT_SYMBOL(drm_kms_helper_poll_enable);
-
 /**
  * drm_kms_helper_poll_init - initialize and enable output polling
  * @dev: drm_device

commit 68f458eec7069d618a6c884ca007426e0cea411b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Jan 9 16:31:58 2017 +0200

    drm: Schedule the output_poll_work with 1s delay if we have delayed event
    
    Instead of scheduling the work to handle the initial delayed event, use 1s
    delay.
    
    This delay should not be needed, but Optimus/nouveau will fail in a
    mysterious way if the delayed event is handled as soon as possible like it
    is done in drm_helper_probe_single_connector_modes() in case the poll
    was enabled before.
    
    Reverting 339fd36238dd would give back the 10 sec (!) delay to handle the
    delayed event. Adding 1sec delay to the poll_work is enough to work around
    the issue in Optimus setups and gives shorter response on handling the
    initial delayed event.
    
    Fixes: 339fd36238dd ("drm: drm_probe_helper: Fix output_poll_work scheduling")
    Cc: stable@vger.kernel.org   # v4.9
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    [danvet: Add FIXME to the comment to make it stick out more.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170109143158.21917-1-peter.ujfalusi@ti.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index ac953f037be7..cf8f0128c161 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -143,8 +143,18 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 	}
 
 	if (dev->mode_config.delayed_event) {
+		/*
+		 * FIXME:
+		 *
+		 * Use short (1s) delay to handle the initial delayed event.
+		 * This delay should not be needed, but Optimus/nouveau will
+		 * fail in a mysterious way if the delayed event is handled as
+		 * soon as possible like it is done in
+		 * drm_helper_probe_single_connector_modes() in case the poll
+		 * was enabled before.
+		 */
 		poll = true;
-		delay = 0;
+		delay = HZ;
 	}
 
 	if (poll)

commit ea0dd85a75f15174cc2bf75f805e378391995931
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 29 21:48:26 2016 +0100

    drm/doc: use preferred struct reference in kernel-doc
    
    sed -e 's/\( \* .*\)struct &\([_a-z]*\)/\1\&struct \2/' -i
    
    Originally I wasnt a friend of this style because I thought a
    line-break between the "&struct" and "foo" part would break it. But a
    quick test shows that " * &struct \n * foo\n" works pefectly well with
    current kernel-doc. So time to mass-apply these changes!
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483044517-5770-6-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 7cff91e7497f..97a32898ef50 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -55,7 +55,7 @@
  * handling code to avoid probing unrelated outputs.
  *
  * The probe helpers share the function table structures with other display
- * helper libraries. See struct &drm_connector_helper_funcs for the details.
+ * helper libraries. See &struct drm_connector_helper_funcs for the details.
  */
 
 static bool drm_kms_helper_poll = true;

commit c36a3254f7857f1ad9badbe3578ccc92be541a8e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 15 16:58:43 2016 +0100

    drm: Convert all helpers to drm_connector_list_iter
    
    Mostly nothing special (except making sure that really all error paths
    and friends call iter_put).
    
    v2: Don't forget the raw connector_list walking in
    drm_helper_move_panel_connectors_to_head. That one unfortunately can't
    be converted to the iterator helpers, but since it's just some list
    splicing best to just wrap the entire thing up in one critical
    section.
    
    v3: Bail out after iter_put (Harry).
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161215155843.13408-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index ac953f037be7..7cff91e7497f 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -129,6 +129,7 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 	unsigned long delay = DRM_OUTPUT_POLL_PERIOD;
 
 	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
@@ -136,11 +137,13 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
-	drm_for_each_connector(connector, dev) {
+	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
 					 DRM_CONNECTOR_POLL_DISCONNECT))
 			poll = true;
 	}
+	drm_connector_list_iter_put(&conn_iter);
 
 	if (dev->mode_config.delayed_event) {
 		poll = true;
@@ -382,6 +385,7 @@ static void output_poll_execute(struct work_struct *work)
 	struct delayed_work *delayed_work = to_delayed_work(work);
 	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 	enum drm_connector_status old_status;
 	bool repoll = false, changed;
 
@@ -397,8 +401,8 @@ static void output_poll_execute(struct work_struct *work)
 		goto out;
 	}
 
-	drm_for_each_connector(connector, dev) {
-
+	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		/* Ignore forced connectors. */
 		if (connector->force)
 			continue;
@@ -451,6 +455,7 @@ static void output_poll_execute(struct work_struct *work)
 			changed = true;
 		}
 	}
+	drm_connector_list_iter_put(&conn_iter);
 
 	mutex_unlock(&dev->mode_config.mutex);
 
@@ -562,6 +567,7 @@ EXPORT_SYMBOL(drm_kms_helper_poll_fini);
 bool drm_helper_hpd_irq_event(struct drm_device *dev)
 {
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 	enum drm_connector_status old_status;
 	bool changed = false;
 
@@ -569,8 +575,8 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		return false;
 
 	mutex_lock(&dev->mode_config.mutex);
-	drm_for_each_connector(connector, dev) {
-
+	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		/* Only handle HPD capable connectors. */
 		if (!(connector->polled & DRM_CONNECTOR_POLL_HPD))
 			continue;
@@ -586,7 +592,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		if (old_status != connector->status)
 			changed = true;
 	}
-
+	drm_connector_list_iter_put(&conn_iter);
 	mutex_unlock(&dev->mode_config.mutex);
 
 	if (changed)

commit 1fe7841d892925aff10c3b070937e974d7835d2b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Dec 6 11:37:15 2016 +0000

    drm: Don't block the kworker waiting for mode_config.mutex in output_poll()
    
    If we cannot acquire the mode_config.mutex immediately, just back off and
    queue a new attempt after the poll interval. This is mostly to stop the
    hung task spam when the system is deadlocked, but it will also lessen
    the load (in such extreme cases).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    [danvet:s/lock/mutex/ per Eric's comment.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161206113715.30382-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 078d9703a4fe..ac953f037be7 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -392,7 +392,11 @@ static void output_poll_execute(struct work_struct *work)
 	if (!drm_kms_helper_poll)
 		goto out;
 
-	mutex_lock(&dev->mode_config.mutex);
+	if (!mutex_trylock(&dev->mode_config.mutex)) {
+		repoll = true;
+		goto out;
+	}
+
 	drm_for_each_connector(connector, dev) {
 
 		/* Ignore forced connectors. */

commit 949f08862d662f17b9d2929c6afb2d4e8f5d50cb
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Nov 29 22:56:30 2016 +0200

    drm: Make the connector .detect() callback optional
    
    Many drivers (21 to be exact) create connectors that are always
    connected (for instance to an LVDS or DSI panel). Instead of forcing
    them to implement a dummy .detect() handler, make the callback optional
    and consider the connector as always connected in that case.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    [seanpaul fixed small conflict in rcar-du/rcar_du_lvdscon.c]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index f6b64d7d3528..078d9703a4fe 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -152,6 +152,14 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
 
+static enum drm_connector_status
+drm_connector_detect(struct drm_connector *connector, bool force)
+{
+	return connector->funcs->detect ?
+		connector->funcs->detect(connector, force) :
+		connector_status_connected;
+}
+
 /**
  * drm_helper_probe_single_connector_modes - get complete set of display modes
  * @connector: connector to probe
@@ -239,7 +247,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
 	} else {
-		connector->status = connector->funcs->detect(connector, true);
+		connector->status = drm_connector_detect(connector, true);
 	}
 
 	/*
@@ -405,7 +413,7 @@ static void output_poll_execute(struct work_struct *work)
 
 		repoll = true;
 
-		connector->status = connector->funcs->detect(connector, false);
+		connector->status = drm_connector_detect(connector, false);
 		if (old_status != connector->status) {
 			const char *old, *new;
 
@@ -565,7 +573,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 
 		old_status = connector->status;
 
-		connector->status = connector->funcs->detect(connector, false);
+		connector->status = drm_connector_detect(connector, false);
 		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
 			      connector->base.id,
 			      connector->name,

commit 339fd36238dd3494bc4617d181e7a37922c29ee9
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Aug 31 14:09:05 2016 +0300

    drm: drm_probe_helper: Fix output_poll_work scheduling
    
    drm_kms_helper_poll_enable_locked() should check if we have delayed event
    pending and if we have, schedule the work to run without delay.
    
    Currently the output_poll_work is only scheduled if any of the connectors
    have DRM_CONNECTOR_POLL_CONNECT or DRM_CONNECTOR_POLL_DISCONNECT with
    DRM_OUTPUT_POLL_PERIOD delay. It does not matter if we have delayed event
    already registered to be handled. The detection will be delayd by
    DRM_OUTPUT_POLL_PERIOD in any case.
    Furthermore if none of the connectors are marked as POLL_CONNECT or
    POLL_DISCONNECT because all connectors are either POLL_HPD or they are
    always connected: the output_poll_work will not run at all even if we
    have delayed event marked.
    
    When none of the connectors require polling, their initial status change
    from unknown to connected/disconnected is not going to be handled until
    the first kms application starts or if we have fb console enabled.
    
    Note that in general the output poll work should be enabled already
    when this happens, but at driver load usually the first probe happens
    before the output polling is enabled. This patch fixes this case.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    [danvet: Note when exactly this is an issue, since the probe code
    schedules the poll work itself already.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831110905.31289-1-peter.ujfalusi@ti.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index a0df377d7d1c..f6b64d7d3528 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -129,6 +129,7 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
+	unsigned long delay = DRM_OUTPUT_POLL_PERIOD;
 
 	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
 
@@ -141,8 +142,13 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 			poll = true;
 	}
 
+	if (dev->mode_config.delayed_event) {
+		poll = true;
+		delay = 0;
+	}
+
 	if (poll)
-		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
+		schedule_delayed_work(&dev->mode_config.output_poll_work, delay);
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
 

commit 5f0c3f9987cebe7c87677505a08828dc331ded7f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jun 1 10:50:51 2016 +0100

    drm: Only create a cmdline mode if no probed modes match
    
    The intention of using video=<connector>:<mode> is primarily to select
    the user's preferred resolution at startup. Currently we always create a
    new mode irrespective of whether the monitor has a native mode at the
    desired resolution. This has the issue that we may then select the fake
    mode rather the native mode during fb_helper->inital_config() and so
    if the fake mode is invalid we then end up with a loss of signal. Oops.
    This invalid fake mode would also be exported to userspace, who
    potentially may make the same mistake.
    
    To avoid this issue, we filter out the added command line mode if we
    detect the desired resolution (and clock if specified) amongst the
    probed modes. This fixes the immediate problem of adding a duplicate
    mode, but perhaps more generically we should avoid adding a GTF mode if
    the monitor has an EDID that is not GTF-compatible, or similarly for
    CVT.
    
    Was meant to fix a regression from
    
    commit eaf99c749d43ae74ac7ffece5512f3c73f01dfd2
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Wed Aug 6 10:08:32 2014 +0200
    
        drm: Perform cmdline mode parsing during connector initialisation
    
    but Radek explained that the original bug is no longer reproducible on
    latest kernels.
    
    v2: Explicitly delete our earlier cmdline mode
    v3: Mode pruning should now be sufficient to delete stale cmdline modes
    v4: Compute the vrefresh for the probed mode
    
    Reported-by: Radek Dostál <rd@radekdostal.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Radek Dostál <rd@radekdostal.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Julia Lemire <jlemire@matrox.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: Drop cc: stable since no longer a pressing bugfix, just
    nice-to-have.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464774651-20376-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 0329080d7f7c..a0df377d7d1c 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -82,13 +82,30 @@ drm_mode_validate_flag(const struct drm_display_mode *mode,
 
 static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 {
+	struct drm_cmdline_mode *cmdline_mode;
 	struct drm_display_mode *mode;
 
-	if (!connector->cmdline_mode.specified)
+	cmdline_mode = &connector->cmdline_mode;
+	if (!cmdline_mode->specified)
 		return 0;
 
+	/* Only add a GTF mode if we find no matching probed modes */
+	list_for_each_entry(mode, &connector->probed_modes, head) {
+		if (mode->hdisplay != cmdline_mode->xres ||
+		    mode->vdisplay != cmdline_mode->yres)
+			continue;
+
+		if (cmdline_mode->refresh_specified) {
+			/* The probed mode's vrefresh is set until later */
+			if (drm_mode_vrefresh(mode) != cmdline_mode->refresh)
+				continue;
+		}
+
+		return 0;
+	}
+
 	mode = drm_mode_create_from_cmdline_mode(connector->dev,
-						 &connector->cmdline_mode);
+						 cmdline_mode);
 	if (mode == NULL)
 		return 0;
 

commit ba34d58c5e86c27accb3133fa991cfb6c848c58e
Author: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
Date:   Tue Apr 19 14:40:37 2016 -0300

    drm: probe_helper: Hide ugly ifdef
    
    Push the ifdef to the drm_edid.h and create a stub, for the
    DRM_LOAD_EDID_FIRMWARE=n case. This removes some clutter in
    the code, making it more readable.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461087638-16959-1-git-send-email-ezequiel@vanguardiasur.com.ar

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index e714b5a7955f..0329080d7f7c 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -264,10 +264,8 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		count = drm_add_edid_modes(connector, edid);
 		drm_edid_to_eld(connector, edid);
 	} else {
-#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE
 		count = drm_load_edid_firmware(connector);
 		if (count == 0)
-#endif
 			count = (*connector_funcs->get_modes)(connector);
 	}
 

commit 5dec293b2434783a6924571df5239e10ab5e9331
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 10 23:13:57 2015 +0200

    drm: Expand the drm_helper_probe_single_connector_modes() docs
    
    Describe the procedure that drm_helper_probe_single_connector_modes()
    uses to do it's work in the kernel-doc comment.
    
    Caveat: Looks like crap and trying to reverse engineer the documentation
    tools is not something I want to do.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449782037-19722-3-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 13d178e6981b..e714b5a7955f 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -144,18 +144,43 @@ EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
  * @connector vfunc for drivers that use the CRTC helpers for output mode
  * filtering and detection.
  *
- * If the helper operation returns no mode, and if the connector status is
- * connector_status_connected, standard VESA DMT modes up to 1024x768 are
- * automatically added to the modes list by a call to
- * drm_add_modes_noedid().
- *
- * The function then filters out modes larger than @maxX and maxY if specified.
- * It finally calls the optional connector ->mode_valid() helper operation for each
- * mode in the probed list to check whether the mode is valid for the connector.
- *
- * Compared to drm_helper_probe_single_connector_modes_nomerge() this function
- * merged the mode bits for the preferred mode, as a hack to work around some
- * quirky issues on funky hardware.
+ * The basic procedure is as follows
+ *
+ * 1. All modes currently on the connector's modes list are marked as stale
+ *
+ * 2. New modes are added to the connector's probed_modes list with
+ *    drm_mode_probed_add(). New modes start their life with status as OK.
+ *    Modes are added from a single source using the following priority order.
+ *
+ *    - debugfs 'override_edid' (used for testing only)
+ *    - firmware EDID (drm_load_edid_firmware())
+ *    - connector helper ->get_modes() vfunc
+ *    - if the connector status is connector_status_connected, standard
+ *      VESA DMT modes up to 1024x768 are automatically added
+ *      (drm_add_modes_noedid())
+ *
+ *    Finally modes specified via the kernel command line (video=...) are
+ *    added in addition to what the earlier probes produced
+ *    (drm_helper_probe_add_cmdline_mode()). These modes are generated
+ *    using the VESA GTF/CVT formulas.
+ *
+ * 3. Modes are moved from the probed_modes list to the modes list. Potential
+ *    duplicates are merged together (see drm_mode_connector_list_update()).
+ *    After this step the probed_modes list will be empty again.
+ *
+ * 4. Any non-stale mode on the modes list then undergoes validation
+ *
+ *    - drm_mode_validate_basic() performs basic sanity checks
+ *    - drm_mode_validate_size() filters out modes larger than @maxX and @maxY
+ *      (if specified)
+ *    - drm_mode_validate_flag() checks the modes againt basic connector
+ *      capabilites (interlace_allowed,doublescan_allowed,stereo_allowed)
+ *    - the optional connector ->mode_valid() helper can perform driver and/or
+ *      hardware specific checks
+ *
+ * 5. Any mode whose status is not OK is pruned from the connector's modes list,
+ *    accompanied by a debug message indicating the reason for the mode's
+ *    rejection (see drm_mode_prune_invalid()).
  *
  * Returns:
  * The number of modes found on @connector.

commit 0e8578c996a33c8da9c28f8ed2d1be68694070ee
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 10 23:13:56 2015 +0200

    drm: Allow override_edid to override the firmware EDID
    
    IMO the override_edid should override any default EDID for the
    connector, whether that came in via the connector helper ->get_modes()
    vfunc or via the firmware EDID mechanism.
    
    Cc: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449782037-19722-2-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 483010f680d5..13d178e6981b 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -233,17 +233,16 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		goto prune;
 	}
 
+	if (connector->override_edid) {
+		struct edid *edid = (struct edid *) connector->edid_blob_ptr->data;
+
+		count = drm_add_edid_modes(connector, edid);
+		drm_edid_to_eld(connector, edid);
+	} else {
 #ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE
-	count = drm_load_edid_firmware(connector);
-	if (count == 0)
+		count = drm_load_edid_firmware(connector);
+		if (count == 0)
 #endif
-	{
-		if (connector->override_edid) {
-			struct edid *edid = (struct edid *) connector->edid_blob_ptr->data;
-
-			count = drm_add_edid_modes(connector, edid);
-			drm_edid_to_eld(connector, edid);
-		} else
 			count = (*connector_funcs->get_modes)(connector);
 	}
 

commit 6af3e6561243f167dabc03f732d27ff5365cd4a4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 3 23:14:14 2015 +0200

    drm: Drop drm_helper_probe_single_connector_modes_nomerge()
    
    Now that the mode type bit merge logic is fixed to only merge
    between new probed modes, hopefully we can eliminat the special
    case for qxl and virtio. That is make the merge the mode type
    bits from all matching new probed modes, just like every other
    driver.
    
    qxl and virtio got excluded from the merging in
    commit 3fbd6439e463 ("drm: copy mode type in drm_mode_connector_list_update()")
    commit abce1ec9b08a ("Revert "drm: copy mode type in drm_mode_connector_list_update()"")
    commit b87577b7c768 ("drm: try harder to avoid regression when merging mode bits")
    
    Cc: Marc-André Lureau <marcandre.lureau@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: Resolve conflicts with doc updates.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 3bdc8684fe58..483010f680d5 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -129,9 +129,39 @@ void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
 
-
-static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connector *connector,
-							      uint32_t maxX, uint32_t maxY, bool merge_type_bits)
+/**
+ * drm_helper_probe_single_connector_modes - get complete set of display modes
+ * @connector: connector to probe
+ * @maxX: max width for modes
+ * @maxY: max height for modes
+ *
+ * Based on the helper callbacks implemented by @connector in struct
+ * &drm_connector_helper_funcs try to detect all valid modes.  Modes will first
+ * be added to the connector's probed_modes list, then culled (based on validity
+ * and the @maxX, @maxY parameters) and put into the normal modes list.
+ *
+ * Intended to be used as a generic implementation of the ->fill_modes()
+ * @connector vfunc for drivers that use the CRTC helpers for output mode
+ * filtering and detection.
+ *
+ * If the helper operation returns no mode, and if the connector status is
+ * connector_status_connected, standard VESA DMT modes up to 1024x768 are
+ * automatically added to the modes list by a call to
+ * drm_add_modes_noedid().
+ *
+ * The function then filters out modes larger than @maxX and maxY if specified.
+ * It finally calls the optional connector ->mode_valid() helper operation for each
+ * mode in the probed list to check whether the mode is valid for the connector.
+ *
+ * Compared to drm_helper_probe_single_connector_modes_nomerge() this function
+ * merged the mode bits for the preferred mode, as a hack to work around some
+ * quirky issues on funky hardware.
+ *
+ * Returns:
+ * The number of modes found on @connector.
+ */
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
+					    uint32_t maxX, uint32_t maxY)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_display_mode *mode;
@@ -223,7 +253,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	if (count == 0)
 		goto prune;
 
-	drm_mode_connector_list_update(connector, merge_type_bits);
+	drm_mode_connector_list_update(connector);
 
 	if (connector->interlace_allowed)
 		mode_flags |= DRM_MODE_FLAG_INTERLACE;
@@ -267,64 +297,8 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	return count;
 }
-
-/**
- * drm_helper_probe_single_connector_modes - get complete set of display modes
- * @connector: connector to probe
- * @maxX: max width for modes
- * @maxY: max height for modes
- *
- * Based on the helper callbacks implemented by @connector in struct
- * &drm_connector_helper_funcs try to detect all valid modes.  Modes will first
- * be added to the connector's probed_modes list, then culled (based on validity
- * and the @maxX, @maxY parameters) and put into the normal modes list.
- *
- * Intended to be used as a generic implementation of the ->fill_modes()
- * @connector vfunc for drivers that use the CRTC helpers for output mode
- * filtering and detection.
- *
- * If the helper operation returns no mode, and if the connector status is
- * connector_status_connected, standard VESA DMT modes up to 1024x768 are
- * automatically added to the modes list by a call to
- * drm_add_modes_noedid().
- *
- * The function then filters out modes larger than @maxX and maxY if specified.
- * It finally calls the optional connector ->mode_valid() helper operation for each
- * mode in the probed list to check whether the mode is valid for the connector.
- *
- * Compared to drm_helper_probe_single_connector_modes_nomerge() this function
- * merged the mode bits for the preferred mode, as a hack to work around some
- * quirky issues on funky hardware.
- *
- * Returns:
- * The number of modes found on @connector.
- */
-int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
-					    uint32_t maxX, uint32_t maxY)
-{
-	return drm_helper_probe_single_connector_modes_merge_bits(connector, maxX, maxY, true);
-}
 EXPORT_SYMBOL(drm_helper_probe_single_connector_modes);
 
-/**
- * drm_helper_probe_single_connector_modes_nomerge - get complete set of display modes
- * @connector: connector to probe
- * @maxX: max width for modes
- * @maxY: max height for modes
- *
- * This operates like drm_hehlper_probe_single_connector_modes() except it
- * replaces the mode bits instead of merging them for preferred modes.
- *
- * Returns:
- * The number of modes found on @connector.
- */
-int drm_helper_probe_single_connector_modes_nomerge(struct drm_connector *connector,
-					    uint32_t maxX, uint32_t maxY)
-{
-	return drm_helper_probe_single_connector_modes_merge_bits(connector, maxX, maxY, false);
-}
-EXPORT_SYMBOL(drm_helper_probe_single_connector_modes_nomerge);
-
 /**
  * drm_kms_helper_hotplug_event - fire off KMS hotplug events
  * @dev: drm_device whose connector state changed

commit 5ba894064d98547c82a1efd50eba40a92df777a1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 10 22:39:08 2015 +0200

    drm: Rename MODE_UNVERIFIED to MODE_STALE
    
    MODE_UNVERIFIED actually means that the mode came from a previous probe,
    and if the new probe doesn't produce a matching mode it will get pruned
    from the list. Rename the flag to MODE_STALE to better convey the
    meaning.
    
    v2: Rebased due to conflicts with Daniel's doc stuff
    
    Cc: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449779948-10906-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index b691253aa752..3bdc8684fe58 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -146,9 +146,9 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
 			connector->name);
-	/* set all modes to the unverified state */
+	/* set all old modes to the stale state */
 	list_for_each_entry(mode, &connector->modes, head)
-		mode->status = MODE_UNVERIFIED;
+		mode->status = MODE_STALE;
 
 	old_status = connector->status;
 

commit be8719a610003297c28b140f1ebd4445aef1d613
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 3 23:14:09 2015 +0200

    drm: Don't overwrite UNVERFIED mode status to OK
    
    The way the mode probing works is this:
    1. All modes currently on the mode list are marked as UNVERIFIED
    2. New modes are on the probed_modes list (they start with
       status OK)
    3. Modes are moved from the probed_modes list to the actual
       mode list. If a mode already on the mode list is deemed
       to match one of the probed modes, the duplicate is dropped
       and the mode status updated to OK. After this the
       probed_modes list will be empty.
    4. All modes on the mode list are verified to not violate any
       constraints. Any that do are marked as such.
    5. Any mode left with a non-OK status is pruned from the list,
       with an appropriate debug message.
    
    What all this means is that any mode on the original list that
    didn't have a duplicate on the probed_modes list, should be left
    with status UNVERFIED (or previously could have been left with
    some other status, but never OK).
    
    I broke that in
    commit 05acaec334fc ("drm: Reorganize probed mode validation")
    by always assigning something to the mode->status during the validation
    step. So any mode from the old list that still passed the validation
    would be left on the list with status OK in the end.
    
    Fix this by not doing the basic mode validation unless the mode
    already has status OK (meaning it came from the probed_modes list,
    or at least a duplicate of it was on that list). This way we will
    correctly prune away any mode from the old mode list that didn't
    appear on the probed_modes list.
    
    Cc: stable@vger.kernel.org
    Cc: Adam Jackson <ajax@redhat.com>
    Fixes: 05acaec334fc ("drm: Reorganize probed mode validation")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449177255-9515-2-git-send-email-ville.syrjala@linux.intel.com
    Testcase: igt/kms_force_connector_basic/prune-stale-modes
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=93332
    [danvet: Also applying to drm-misc to avoid too much conflict hell -
    there's a big pile of patches from Ville on top of this one.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index d65def42f4b5..b691253aa752 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -233,7 +233,8 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
 
 	list_for_each_entry(mode, &connector->modes, head) {
-		mode->status = drm_mode_validate_basic(mode);
+		if (mode->status == MODE_OK)
+			mode->status = drm_mode_validate_basic(mode);
 
 		if (mode->status == MODE_OK)
 			mode->status = drm_mode_validate_size(mode, maxX, maxY);

commit 2be94971c759da872efce99fa823ea17cdb7cc8b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:46 2015 +0100

    drm: Merge helper docbook into kerneldoc comments
    
    Duplication is bad, luckily both help texts highlighted different
    issues so the kerneldoc gained quite a bit!
    
    While at it also sprinkle more references to the vtable structs around
    and make it clear that legacy CRTC helpers are deprecated and which
    functions to use instead.
    
    v2: Spelling fixes and polish (Thierry).
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-6-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index b59acad83644..d65def42f4b5 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -273,15 +273,28 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
  * @maxX: max width for modes
  * @maxY: max height for modes
  *
- * Based on the helper callbacks implemented by @connector try to detect all
- * valid modes.  Modes will first be added to the connector's probed_modes list,
- * then culled (based on validity and the @maxX, @maxY parameters) and put into
- * the normal modes list.
+ * Based on the helper callbacks implemented by @connector in struct
+ * &drm_connector_helper_funcs try to detect all valid modes.  Modes will first
+ * be added to the connector's probed_modes list, then culled (based on validity
+ * and the @maxX, @maxY parameters) and put into the normal modes list.
  *
- * Intended to be use as a generic implementation of the ->fill_modes()
- * @connector vfunc for drivers that use the crtc helpers for output mode
+ * Intended to be used as a generic implementation of the ->fill_modes()
+ * @connector vfunc for drivers that use the CRTC helpers for output mode
  * filtering and detection.
  *
+ * If the helper operation returns no mode, and if the connector status is
+ * connector_status_connected, standard VESA DMT modes up to 1024x768 are
+ * automatically added to the modes list by a call to
+ * drm_add_modes_noedid().
+ *
+ * The function then filters out modes larger than @maxX and maxY if specified.
+ * It finally calls the optional connector ->mode_valid() helper operation for each
+ * mode in the probed list to check whether the mode is valid for the connector.
+ *
+ * Compared to drm_helper_probe_single_connector_modes_nomerge() this function
+ * merged the mode bits for the preferred mode, as a hack to work around some
+ * quirky issues on funky hardware.
+ *
  * Returns:
  * The number of modes found on @connector.
  */
@@ -298,8 +311,11 @@ EXPORT_SYMBOL(drm_helper_probe_single_connector_modes);
  * @maxX: max width for modes
  * @maxY: max height for modes
  *
- * This operates like drm_hehlper_probe_single_connector_modes except it
+ * This operates like drm_hehlper_probe_single_connector_modes() except it
  * replaces the mode bits instead of merging them for preferred modes.
+ *
+ * Returns:
+ * The number of modes found on @connector.
  */
 int drm_helper_probe_single_connector_modes_nomerge(struct drm_connector *connector,
 					    uint32_t maxX, uint32_t maxY)

commit 092d01dae09aa6779ed41c3ac637e1e3c835424b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:44 2015 +0100

    drm: Reorganize helper vtables and their docs
    
    Currently we have 4 helper libraries (probe, crtc, plane & atomic)
    that all use the same helper vtables. And that's by necessity since we
    don't want to litter the core structs with one ops pointer per helper
    library. Also often the reuse the same hooks (like atomic does, to
    facilite conversion from existing drivers using crtc and plane
    helpers).
    
    Given all that it doesn't make sense to put the docs for these next to
    specific helpers. Instead extract them into a new header file and
    section in the docbook, and add references to them everywhere.
    
    Unfortunately kernel-doc complains when an include directive doesn't
    find anything (and it does by dumping crap into the output file). We
    have to remove the now empty includes to avoid that, instead of leaving
    them in for future proofing.
    
    v2: More OCD in ordering functions.
    
    v3: Spelling plus collate copyright headers properly.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-4-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index eee3b6f38cfb..b59acad83644 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -53,6 +53,9 @@
  * This helper library can be used independently of the modeset helper library.
  * Drivers can also overwrite different parts e.g. use their own hotplug
  * handling code to avoid probing unrelated outputs.
+ *
+ * The probe helpers share the function table structures with other display
+ * helper libraries. See struct &drm_connector_helper_funcs for the details.
  */
 
 static bool drm_kms_helper_poll = true;

commit 4e15f2a1a056ff2695611c3e8d0b162526e84355
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Dec 3 14:00:03 2015 +0200

    drm: keep connector status change logging human readable
    
    We've had human readable connector status change debug logging since
    
    commit ed7951dc13aad4a14695ec8122e9f0e2ef25d39e
    Author: Lespiau, Damien <damien.lespiau@intel.com>
    Date:   Fri May 10 12:36:42 2013 +0000
    
        drm: Make the HPD status updates debug logs more readable
    
    but
    
    commit 162b6a57ac50eec236530a16c071ffa50e87362a
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Jan 21 08:45:21 2015 +0100
    
        drm/probe-helper: don't lose hotplug event
    
    added a new one with just the numbers. Fix it.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449144003-2877-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 94ba39e34299..eee3b6f38cfb 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -168,10 +168,11 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	 * check here, and if anything changed start the hotplug code.
 	 */
 	if (old_status != connector->status) {
-		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
 			      connector->base.id,
 			      connector->name,
-			      old_status, connector->status);
+			      drm_get_connector_status_name(old_status),
+			      drm_get_connector_status_name(connector->status));
 
 		/*
 		 * The hotplug event code might call into the fb

commit ed293f7754934b26c6f3db0dbc39ec2ed990f286
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 19 17:46:50 2015 +0100

    drm/sysfs: Send out uevent when connector->force changes
    
    To avoid even more code duplication punt this all to the probe worker,
    which needs some slight adjustment to also generate a uevent when the
    status has changed to due connector->force.
    
    v2: Instead of running the output_poll_work (which is kinda the wrong
    thing and a layering violation since it's an internal of the probe
    helpers), or calling ->detect (which is again a layering violation
    since it's used only by probe helpers) just call the official
    ->fill_modes function, like a GET_CONNECTOR ioctl call.
    
    v3: Restore the accidentally removed forced-probe for echo "detect" >
    force.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447951610-12622-22-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index a18164f2f6d2..94ba39e34299 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -147,6 +147,8 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	list_for_each_entry(mode, &connector->modes, head)
 		mode->status = MODE_UNVERIFIED;
 
+	old_status = connector->status;
+
 	if (connector->force) {
 		if (connector->force == DRM_FORCE_ON ||
 		    connector->force == DRM_FORCE_ON_DIGITAL)
@@ -156,33 +158,31 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
 	} else {
-		old_status = connector->status;
-
 		connector->status = connector->funcs->detect(connector, true);
+	}
+
+	/*
+	 * Normally either the driver's hpd code or the poll loop should
+	 * pick up any changes and fire the hotplug event. But if
+	 * userspace sneaks in a probe, we might miss a change. Hence
+	 * check here, and if anything changed start the hotplug code.
+	 */
+	if (old_status != connector->status) {
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
+			      connector->base.id,
+			      connector->name,
+			      old_status, connector->status);
 
 		/*
-		 * Normally either the driver's hpd code or the poll loop should
-		 * pick up any changes and fire the hotplug event. But if
-		 * userspace sneaks in a probe, we might miss a change. Hence
-		 * check here, and if anything changed start the hotplug code.
+		 * The hotplug event code might call into the fb
+		 * helpers, and so expects that we do not hold any
+		 * locks. Fire up the poll struct instead, it will
+		 * disable itself again.
 		 */
-		if (old_status != connector->status) {
-			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
-				      connector->base.id,
-				      connector->name,
-				      old_status, connector->status);
-
-			/*
-			 * The hotplug event code might call into the fb
-			 * helpers, and so expects that we do not hold any
-			 * locks. Fire up the poll struct instead, it will
-			 * disable itself again.
-			 */
-			dev->mode_config.delayed_event = true;
-			if (dev->mode_config.poll_enabled)
-				schedule_delayed_work(&dev->mode_config.output_poll_work,
-						      0);
-		}
+		dev->mode_config.delayed_event = true;
+		if (dev->mode_config.poll_enabled)
+			schedule_delayed_work(&dev->mode_config.output_poll_work,
+					      0);
 	}
 
 	/* Re-enable polling in case the global poll config changed. */

commit 4ad640e99e5e5514d623210bc937e665ffd8f43f
Author: Egbert Eich <eich@suse.de>
Date:   Wed Sep 23 16:13:00 2015 +0200

    drm: Add a non-locking version of drm_kms_helper_poll_enable(), v2
    
    drm_kms_helper_poll_enable() was converted to lock the mode_config
    mutex in commit 8c4ccc4ab6f64e859d4ff8d7c02c2ed2e956e07f
    ("drm/probe-helper: Grab mode_config.mutex in poll_init/enable").
    
    This disregarded the cases where this function is called from a context
    where this mutex is already locked.
    
    Add a non-locking version as well.
    
    Changes since v1:
    - use function name suffix '_locked' for the function that
      is to be called from a locked context.
    
    Signed-off-by: Egbert Eich <eich@suse.de>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index d734780b31c0..a18164f2f6d2 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -94,7 +94,18 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 }
 
 #define DRM_OUTPUT_POLL_PERIOD (10*HZ)
-static void __drm_kms_helper_poll_enable(struct drm_device *dev)
+/**
+ * drm_kms_helper_poll_enable_locked - re-enable output polling.
+ * @dev: drm_device
+ *
+ * This function re-enables the output polling work without
+ * locking the mode_config mutex.
+ *
+ * This is like drm_kms_helper_poll_enable() however it is to be
+ * called from a context where the mode_config mutex is locked
+ * already.
+ */
+void drm_kms_helper_poll_enable_locked(struct drm_device *dev)
 {
 	bool poll = false;
 	struct drm_connector *connector;
@@ -113,6 +124,8 @@ static void __drm_kms_helper_poll_enable(struct drm_device *dev)
 	if (poll)
 		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
 }
+EXPORT_SYMBOL(drm_kms_helper_poll_enable_locked);
+
 
 static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connector *connector,
 							      uint32_t maxX, uint32_t maxY, bool merge_type_bits)
@@ -174,7 +187,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	/* Re-enable polling in case the global poll config changed. */
 	if (drm_kms_helper_poll != dev->mode_config.poll_running)
-		__drm_kms_helper_poll_enable(dev);
+		drm_kms_helper_poll_enable_locked(dev);
 
 	dev->mode_config.poll_running = drm_kms_helper_poll;
 
@@ -428,7 +441,7 @@ EXPORT_SYMBOL(drm_kms_helper_poll_disable);
 void drm_kms_helper_poll_enable(struct drm_device *dev)
 {
 	mutex_lock(&dev->mode_config.mutex);
-	__drm_kms_helper_poll_enable(dev);
+	drm_kms_helper_poll_enable_locked(dev);
 	mutex_unlock(&dev->mode_config.mutex);
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_enable);

commit 8c4ccc4ab6f64e859d4ff8d7c02c2ed2e956e07f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:26 2015 +0200

    drm/probe-helper: Grab mode_config.mutex in poll_init/enable
    
    So on first looks this seems superflous since drivers should ensure
    correct ordering to not make this a problem. Otoh ordering constraints
    between hdp, fbdev load and enabling polling are already tricky on
    some hardware and it helps to be more robust.
    
    But the real goal is to just shut up a locking WARN_ON I'd like to
    add, which means init code gets some additional locks just for
    uniformity.
    
    v2: Also grab the lock for the public poll_enable, not just poll_init
    which is used for resume, with the same justification.
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 64d85c1bd18b..d734780b31c0 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -93,6 +93,27 @@ static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
 	return 1;
 }
 
+#define DRM_OUTPUT_POLL_PERIOD (10*HZ)
+static void __drm_kms_helper_poll_enable(struct drm_device *dev)
+{
+	bool poll = false;
+	struct drm_connector *connector;
+
+	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
+
+	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
+		return;
+
+	drm_for_each_connector(connector, dev) {
+		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
+					 DRM_CONNECTOR_POLL_DISCONNECT))
+			poll = true;
+	}
+
+	if (poll)
+		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
+}
+
 static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connector *connector,
 							      uint32_t maxX, uint32_t maxY, bool merge_type_bits)
 {
@@ -153,7 +174,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	/* Re-enable polling in case the global poll config changed. */
 	if (drm_kms_helper_poll != dev->mode_config.poll_running)
-		drm_kms_helper_poll_enable(dev);
+		__drm_kms_helper_poll_enable(dev);
 
 	dev->mode_config.poll_running = drm_kms_helper_poll;
 
@@ -295,7 +316,6 @@ void drm_kms_helper_hotplug_event(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_kms_helper_hotplug_event);
 
-#define DRM_OUTPUT_POLL_PERIOD (10*HZ)
 static void output_poll_execute(struct work_struct *work)
 {
 	struct delayed_work *delayed_work = to_delayed_work(work);
@@ -407,20 +427,9 @@ EXPORT_SYMBOL(drm_kms_helper_poll_disable);
  */
 void drm_kms_helper_poll_enable(struct drm_device *dev)
 {
-	bool poll = false;
-	struct drm_connector *connector;
-
-	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
-		return;
-
-	drm_for_each_connector(connector, dev) {
-		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
-					 DRM_CONNECTOR_POLL_DISCONNECT))
-			poll = true;
-	}
-
-	if (poll)
-		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
+	mutex_lock(&dev->mode_config.mutex);
+	__drm_kms_helper_poll_enable(dev);
+	mutex_unlock(&dev->mode_config.mutex);
 }
 EXPORT_SYMBOL(drm_kms_helper_poll_enable);
 

commit 6295d607ad34ee4e43aab3f20714c2ef7a6adea1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:25 2015 +0200

    drm: Add modeset object iterators
    
    And roll them out across drm_* files. The point here isn't code
    prettification (it helps with that too) but that some of these lists
    aren't static any more. And having macros will gives us a convenient
    place to put locking checks into.
    
    I didn't add an iterator for props since that's only used by a
    list_for_each_entry_safe in the driver teardown code.
    
    Search&replace was done with the below cocci spatch. Note that there's
    a bunch more places that didn't match and which would need some manual
    changes, but I've intentially left these out for this mostly automated
    patch.
    
    iterator name drm_for_each_crtc;
    struct drm_crtc *crtc;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
    + drm_for_each_crtc (crtc, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_encoder;
    struct drm_encoder *encoder;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
    + drm_for_each_encoder (encoder, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_fb;
    struct drm_framebuffer *fb;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(fb, &dev->mode_config.fb_list, head) {
    + drm_for_each_fb (fb, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_connector;
    struct drm_connector *connector;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
    + drm_for_each_connector (connector, dev) {
    ...
    }
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 04203c0d2ecb..64d85c1bd18b 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -312,7 +312,7 @@ static void output_poll_execute(struct work_struct *work)
 		goto out;
 
 	mutex_lock(&dev->mode_config.mutex);
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	drm_for_each_connector(connector, dev) {
 
 		/* Ignore forced connectors. */
 		if (connector->force)
@@ -413,7 +413,7 @@ void drm_kms_helper_poll_enable(struct drm_device *dev)
 	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
 		return;
 
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	drm_for_each_connector(connector, dev) {
 		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
 					 DRM_CONNECTOR_POLL_DISCONNECT))
 			poll = true;
@@ -495,7 +495,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		return false;
 
 	mutex_lock(&dev->mode_config.mutex);
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	drm_for_each_connector(connector, dev) {
 
 		/* Only handle HPD capable connectors. */
 		if (!(connector->polled & DRM_CONNECTOR_POLL_HPD))

commit 49f897647aab5958ad34a392b82fb22b7c83c01e
Merge: 5ebe6afaf005 4a324d33bfe9
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 7 13:02:39 2015 +1000

    Merge tag 'topic/drm-misc-2015-05-06' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    misc drm core patches.
    
    * tag 'topic/drm-misc-2015-05-06' of git://anongit.freedesktop.org/drm-intel:
      drm: simplify master cleanup
      drm: simplify authentication management
      drm: drop unused 'magicfree' list
      drm: fix a memleak on mutex failure path
      drm/atomic-helper: Really recover pre-atomic plane/cursor behavior
      drm/qxl: Fix qxl_noop_get_vblank_counter()
      drm: Zero out invalid vblank timestamp in drm_update_vblank_count. (v2)
      drm: Prevent invalid use of vblank_disable_immediate. (v2)
      drm/vblank: Fixup and document timestamp update/read barriers
      DRM: Don't re-poll connector for disconnect
      drm: Fix for DP CTS test 4.2.2.5 - I2C DEFER handling
      drm: Fix the 'native defer' message in drm_dp_i2c_do_msg()
      drm/atomic-helper: Don't call atomic_update_plane when it stays off

commit a3c6d686443e912e33cebdf9cd80f94df3ded7b0
Author: Josef Holzmayr <holzmayr@rsi-elektrotechnik.de>
Date:   Thu Apr 16 14:16:29 2015 +0200

    DRM: Don't re-poll connector for disconnect
    
    DRM probe should not repoll a connector if it is already
    connected and the DRM_CONNECTOR_POLL_DISCONNECT flag is not set.
    
    Signed-off-by: Josef Holzmayr <holzmayr@rsi-elektrotechnik.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index d44437fc42b1..2fb2fbe8c2de 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -322,8 +322,6 @@ static void output_poll_execute(struct work_struct *work)
 		if (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)
 			continue;
 
-		repoll = true;
-
 		old_status = connector->status;
 		/* if we are connected and don't want to poll for disconnect
 		   skip it */
@@ -331,6 +329,8 @@ static void output_poll_execute(struct work_struct *work)
 		    !(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))
 			continue;
 
+		repoll = true;
+
 		connector->status = connector->funcs->detect(connector, false);
 		if (old_status != connector->status) {
 			const char *old, *new;

commit 4a11248856933f33ca061ed55470ea7e1783b40b
Merge: 52139bdea155 2b1193d52870
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 16 08:34:24 2015 +1000

    Merge tag 'topic/drm-misc-2015-04-15' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    One more drm-misch pull for 4.1 with mostly simple stuff and boring
    refactoring. Even the cursor fix from Matt is just to make a really anal
    igt happy.
    
    * tag 'topic/drm-misc-2015-04-15' of git://anongit.freedesktop.org/drm-intel:
      drm: fix trivial typo mistake
      drm: Make integer overflow checking cover universal cursor updates (v2)
      drm: make crtc/encoder/connector/plane helper_private a const pointer
      drm/armada: constify struct drm_encoder_helper_funcs pointer
      drm/radeon: constify more struct drm_*_helper funcs pointers
      drm/edid: add #defines for ELD versions
      drm/atomic: Add for_each_{connector,crtc,plane}_in_state helper macros
      drm: Use kref_put_mutex in drm_gem_object_unreference_unlocked
      drm/drm: constify all struct drm_*_helper funcs pointers
      drm/qxl: constify all struct drm_*_helper funcs pointers
      drm/nouveau: constify all struct drm_*_helper funcs pointers
      drm/radeon: constify all struct drm_*_helper funcs pointers
      drm/gma500: constify all struct drm_*_helper funcs pointers
      drm/mgag200: constify all struct drm_*_helper funcs pointers
      drm/exynos: constify all struct drm_*_helper funcs pointers
      drm: Fix some typos

commit be26a66de5f5722388966a62d772df832818bcb9
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Mar 11 11:51:06 2015 +0200

    drm/drm: constify all struct drm_*_helper funcs pointers
    
    They are not to be modified.
    
    Generated using the semantic patch:
    
    @@
    @@
    (
      const struct drm_crtc_helper_funcs *
    |
    - struct drm_crtc_helper_funcs *
    + const struct drm_crtc_helper_funcs *
    )
    
    @@
    @@
    (
      const struct drm_encoder_helper_funcs *
    |
    - struct drm_encoder_helper_funcs *
    + const struct drm_encoder_helper_funcs *
    )
    
    @@
    @@
    (
      const struct drm_connector_helper_funcs *
    |
    - struct drm_connector_helper_funcs *
    + const struct drm_connector_helper_funcs *
    )
    
    @@
    @@
    (
      const struct drm_plane_helper_funcs *
    |
    - struct drm_plane_helper_funcs *
    + const struct drm_plane_helper_funcs *
    )
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6591d48c1b9d..d44437fc42b1 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -98,7 +98,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_display_mode *mode;
-	struct drm_connector_helper_funcs *connector_funcs =
+	const struct drm_connector_helper_funcs *connector_funcs =
 		connector->helper_private;
 	int count = 0;
 	int mode_flags = 0;

commit ad692b46dbf122ef90aadce3b389ef64c90e861d
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Mar 26 10:42:00 2015 +0200

    drm/edid: set ELD for firmware and debugfs override EDIDs
    
    If the user supplies EDID through firmware or debugfs override, the
    driver callbacks are bypassed and the connector ELD does not get
    updated, and audio fails. Set ELD for firmware and debugfs EDIDs too.
    
    There should be no harm in gratuitously doing this for non HDMI/DP
    connectors, as it's still up to the driver to use the ELD, if any.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=82349
    Reference: https://bugs.freedesktop.org/show_bug.cgi?id=80691
    Reported-by: Emil <emilsvennesson@gmail.com>
    Reported-by: Rob Engle <grenoble@gmail.com>
    Tested-by: Jolan Luff <jolan@gormsby.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6591d48c1b9d..3fee587bc284 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -174,6 +174,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 			struct edid *edid = (struct edid *) connector->edid_blob_ptr->data;
 
 			count = drm_add_edid_modes(connector, edid);
+			drm_edid_to_eld(connector, edid);
 		} else
 			count = (*connector_funcs->get_modes)(connector);
 	}

commit b7703726251191cd9f3ef3a80b2d9667901eec95
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 21 08:45:22 2015 +0100

    drm/probe-helper: clamp unknown connector status in the poll work
    
    On some chipset we try to avoid possibly invasive output detection
    methods (like load detect which can cause flickering elsewhere) in the
    output poll work. Drivers could hence return unknown when a previous
    full ->detect call returned a different state.
    
    This change will generate a hotplug event, forcing userspace to do a
    full scan. This in turn updates the connector->status field so that we
    will _again_ get a state change when the hotplug work re-runs in 10
    seconds.
    
    To avoid this ping-pong loop detect this situation and clamp the
    connector state to the old value.
    
    Patch is inspired by a patch from Knut Peterson. Knut's patch
    completely ignored connector state changes if either the old or new
    status was unknown, which seemed to be a bit too agressive to me.
    
    v2: Rebased onto the drm_probe_helper.c extraction.
    
    References: http://lists.freedesktop.org/archives/dri-devel/2012-August/025975.html
    Cc: Knut Petersen <Knut_Petersen@t-online.de>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 33bf550a1d3f..6591d48c1b9d 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -335,6 +335,24 @@ static void output_poll_execute(struct work_struct *work)
 		if (old_status != connector->status) {
 			const char *old, *new;
 
+			/*
+			 * The poll work sets force=false when calling detect so
+			 * that drivers can avoid to do disruptive tests (e.g.
+			 * when load detect cycles could cause flickering on
+			 * other, running displays). This bears the risk that we
+			 * flip-flop between unknown here in the poll work and
+			 * the real state when userspace forces a full detect
+			 * call after receiving a hotplug event due to this
+			 * change.
+			 *
+			 * Hence clamp an unknown detect status to the old
+			 * value.
+			 */
+			if (connector->status == connector_status_unknown) {
+				connector->status = old_status;
+				continue;
+			}
+
 			old = drm_get_connector_status_name(old_status);
 			new = drm_get_connector_status_name(connector->status);
 

commit 162b6a57ac50eec236530a16c071ffa50e87362a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 21 08:45:21 2015 +0100

    drm/probe-helper: don't lose hotplug event
    
    There's a race window (small for hpd, 10s large for polled outputs)
    where userspace could sneak in with an unrelated connnector probe
    ioctl call and eat the hotplug event (since neither the hpd nor the
    poll code see a state change).
    
    To avoid this, check whether the connector state changes in all other
    ->detect calls (in the current helper code that's only probe_single)
    and if that's the case, fire off a hotplug event. Note that we can't
    directly call the hotplug event handler, since that expects that no
    locks are held (due to reentrancy with the fb code to update the kms
    console).
    
    Also, this requires that drivers using the probe_single helper
    function set up the poll work. All current drivers do that already,
    and with the reworked hpd handling there'll be no downside to
    unconditionally setting up the poll work any more.
    
    v2: Review from Rob Clark
    - Don't bail out of the output poll work immediately if it's disabled
      to make sure we deliver the delayed hoptplug events. Instead just
      jump to the tail.
    - Don't scheduel the work when it's not set up. Would be a driver bug
      since using probe helpers for anything dynamic without them
      initialized makes them all noops.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Tested-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 2fbdcca7ca9a..33bf550a1d3f 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -103,6 +103,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	int count = 0;
 	int mode_flags = 0;
 	bool verbose_prune = true;
+	enum drm_connector_status old_status;
 
 	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
 
@@ -121,7 +122,33 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
 	} else {
+		old_status = connector->status;
+
 		connector->status = connector->funcs->detect(connector, true);
+
+		/*
+		 * Normally either the driver's hpd code or the poll loop should
+		 * pick up any changes and fire the hotplug event. But if
+		 * userspace sneaks in a probe, we might miss a change. Hence
+		 * check here, and if anything changed start the hotplug code.
+		 */
+		if (old_status != connector->status) {
+			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
+				      connector->base.id,
+				      connector->name,
+				      old_status, connector->status);
+
+			/*
+			 * The hotplug event code might call into the fb
+			 * helpers, and so expects that we do not hold any
+			 * locks. Fire up the poll struct instead, it will
+			 * disable itself again.
+			 */
+			dev->mode_config.delayed_event = true;
+			if (dev->mode_config.poll_enabled)
+				schedule_delayed_work(&dev->mode_config.output_poll_work,
+						      0);
+		}
 	}
 
 	/* Re-enable polling in case the global poll config changed. */
@@ -274,10 +301,14 @@ static void output_poll_execute(struct work_struct *work)
 	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
 	struct drm_connector *connector;
 	enum drm_connector_status old_status;
-	bool repoll = false, changed = false;
+	bool repoll = false, changed;
+
+	/* Pick up any changes detected by the probe functions. */
+	changed = dev->mode_config.delayed_event;
+	dev->mode_config.delayed_event = false;
 
 	if (!drm_kms_helper_poll)
-		return;
+		goto out;
 
 	mutex_lock(&dev->mode_config.mutex);
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -319,6 +350,7 @@ static void output_poll_execute(struct work_struct *work)
 
 	mutex_unlock(&dev->mode_config.mutex);
 
+out:
 	if (changed)
 		drm_kms_helper_hotplug_event(dev);
 

commit abc0b1447d4974963548777a5ba4a4457c82c426
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 17 13:56:23 2014 +0200

    drm: Perform basic sanity checks on probed modes
    
    Make sure the timings of probed modes at least pass some very basic
    sanity checks.
    
    The checks include:
     - clock,hdisplay,vdisplay are non zero
     - sync pulse fits within the blanking period
     - htotal,vtotal are big enough
    
    I have not checked all the drivers to see if the modes the generate
    might violate these constraints. I'm hoping not, because that would mean
    either abandoning the idea of doing this from the core code, or fixing
    the drivers.
    
    I'm not entirely sure about limiting the sync pulse to the blanking
    period. Intel hardware doesn't support such things, but some other
    hardware might. However at least HDMI doesn't allow having sync pulse
    edges within the active period, so I'm thinking the check is probably
    OK to have in the common code.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 2161d8ed7c65..2fbdcca7ca9a 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -167,7 +167,10 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
 
 	list_for_each_entry(mode, &connector->modes, head) {
-		mode->status = drm_mode_validate_size(mode, maxX, maxY);
+		mode->status = drm_mode_validate_basic(mode);
+
+		if (mode->status == MODE_OK)
+			mode->status = drm_mode_validate_size(mode, maxX, maxY);
 
 		if (mode->status == MODE_OK)
 			mode->status = drm_mode_validate_flag(mode, mode_flags);

commit 05acaec334fcc1132d1e48c5042e044651e0b75b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 17 13:56:22 2014 +0200

    drm: Reorganize probed mode validation
    
    Make drm_mode_validate_size() and drm_mode_validate_flag() deal with a
    single mode instead of having each iterate through the mode list.
    
    The hope is that in the future we might be able to share various mode
    validation functions between modeset and get_modes.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 7483a47de8e4..2161d8ed7c65 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -58,28 +58,23 @@
 static bool drm_kms_helper_poll = true;
 module_param_named(poll, drm_kms_helper_poll, bool, 0600);
 
-static void drm_mode_validate_flag(struct drm_connector *connector,
-				   int flags)
+static enum drm_mode_status
+drm_mode_validate_flag(const struct drm_display_mode *mode,
+		       int flags)
 {
-	struct drm_display_mode *mode;
+	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+	    !(flags & DRM_MODE_FLAG_INTERLACE))
+		return MODE_NO_INTERLACE;
 
-	if (flags == (DRM_MODE_FLAG_DBLSCAN | DRM_MODE_FLAG_INTERLACE |
-		      DRM_MODE_FLAG_3D_MASK))
-		return;
+	if ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&
+	    !(flags & DRM_MODE_FLAG_DBLSCAN))
+		return MODE_NO_DBLESCAN;
 
-	list_for_each_entry(mode, &connector->modes, head) {
-		if ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&
-				!(flags & DRM_MODE_FLAG_INTERLACE))
-			mode->status = MODE_NO_INTERLACE;
-		if ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&
-				!(flags & DRM_MODE_FLAG_DBLSCAN))
-			mode->status = MODE_NO_DBLESCAN;
-		if ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&
-				!(flags & DRM_MODE_FLAG_3D_MASK))
-			mode->status = MODE_NO_STEREO;
-	}
+	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&
+	    !(flags & DRM_MODE_FLAG_3D_MASK))
+		return MODE_NO_STEREO;
 
-	return;
+	return MODE_OK;
 }
 
 static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
@@ -164,18 +159,19 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	drm_mode_connector_list_update(connector, merge_type_bits);
 
-	if (maxX && maxY)
-		drm_mode_validate_size(dev, &connector->modes, maxX, maxY);
-
 	if (connector->interlace_allowed)
 		mode_flags |= DRM_MODE_FLAG_INTERLACE;
 	if (connector->doublescan_allowed)
 		mode_flags |= DRM_MODE_FLAG_DBLSCAN;
 	if (connector->stereo_allowed)
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
-	drm_mode_validate_flag(connector, mode_flags);
 
 	list_for_each_entry(mode, &connector->modes, head) {
+		mode->status = drm_mode_validate_size(mode, maxX, maxY);
+
+		if (mode->status == MODE_OK)
+			mode->status = drm_mode_validate_flag(mode, mode_flags);
+
 		if (mode->status == MODE_OK && connector_funcs->mode_valid)
 			mode->status = connector_funcs->mode_valid(connector,
 								   mode);

commit 2c4cc91b0b43ae364d47b0eec560b8e5bd5af746
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Nov 3 20:51:45 2014 -0500

    drm: Fix DRM_FORCE_ON_DIGITAL use
    
    A connector may be forced on from the command line via video=
    command line setting. The digital output of dual-mode connectors
    can also be specifically selected and forced on; eg., 'video=DVI-I-2:D'.
    However, in this case, the connector->status will be mistakenly set to
    connector_status_disconnected, and the connector will not be mode set.
    
    Fix the connector->status when connector->force is DRM_FORCE_ON_DIGITAL.
    
    Note that this seems to have been broken ever since the introduction
    of the connector forcing support in
    
    commit d50ba256b5f1478e15accfcfda9b72fd7a661364
    Author: Dave Airlie <airlied@linux.ie>
    Date:   Wed Sep 23 14:44:08 2009 +1000
    
        drm/kms: start adding command line interface using fb.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    [danvet: Add note about that this never worked.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 6857e9ad6339..7483a47de8e4 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -118,7 +118,8 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 		mode->status = MODE_UNVERIFIED;
 
 	if (connector->force) {
-		if (connector->force == DRM_FORCE_ON)
+		if (connector->force == DRM_FORCE_ON ||
+		    connector->force == DRM_FORCE_ON_DIGITAL)
 			connector->status = connector_status_connected;
 		else
 			connector->status = connector_status_disconnected;

commit eaf99c749d43ae74ac7ffece5512f3c73f01dfd2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 6 10:08:32 2014 +0200

    drm: Perform cmdline mode parsing during connector initialisation
    
    i915.ko has a custom fbdev initialisation routine that aims to preserve
    the current mode set by the BIOS, unless overruled by the user. The
    user's wishes are determined by what, if any, mode is specified on the
    command line (via the video= parameter). However, that command line mode
    is first parsed by drm_fb_helper_initial_config() which is called after
    i915.ko's custom initial_config() as a fallback method. So in order for
    us to honour it, we need to move the cmdline parser earlier. If we
    perform the connector cmdline parsing as soon as we initialise the
    connector, that cmdline mode and forced status is then available even if
    the fbdev helper is not compiled in or never called.
    
    We also then expose the cmdline user mode in the connector mode lists.
    
    v2: Rebase after connector->name upheaval.
    
    v3: Adapt mga200 to look for the cmdline mode in the new place. Nicely
    simplifies things while at that.
    
    v4: Fix checkpatch.
    
    v5: Select FB_CMDLINE to adapt to the changed fbdev patch.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=73154
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk> (v2)
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org> (v2)
    Cc: dri-devel@lists.freedesktop.org
    Cc: Julia Lemire <jlemire@matrox.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index db7d250f7ac7..6857e9ad6339 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -82,6 +82,22 @@ static void drm_mode_validate_flag(struct drm_connector *connector,
 	return;
 }
 
+static int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	if (!connector->cmdline_mode.specified)
+		return 0;
+
+	mode = drm_mode_create_from_cmdline_mode(connector->dev,
+						 &connector->cmdline_mode);
+	if (mode == NULL)
+		return 0;
+
+	drm_mode_probed_add(connector, mode);
+	return 1;
+}
+
 static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connector *connector,
 							      uint32_t maxX, uint32_t maxY, bool merge_type_bits)
 {
@@ -141,6 +157,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	if (count == 0 && connector->status == connector_status_connected)
 		count = drm_add_modes_noedid(connector, 1024, 768);
+	count += drm_helper_probe_add_cmdline_mode(connector);
 	if (count == 0)
 		goto prune;
 

commit 4cf2b28146713d39f78bd62002a8ab00075c63b7
Author: Thomas Wood <thomas.wood@intel.com>
Date:   Wed Jun 18 17:52:33 2014 +0100

    drm/debugfs: add an "edid_override" file per connector
    
    Add a file to debugfs for each connector to allow the EDID to be
    overridden.
    
    v2: Copy ubuf before accessing it and reject invalid length data. (David
        Herrmann)
        Ensure override_edid is reset when a new EDID value is written.
        (David Herrmann)
        Fix the debugfs file permissions. (David Herrmann)
    
    Signed-off-by: Thomas Wood <thomas.wood@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index d22676b89cbb..db7d250f7ac7 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -130,7 +130,14 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	count = drm_load_edid_firmware(connector);
 	if (count == 0)
 #endif
-		count = (*connector_funcs->get_modes)(connector);
+	{
+		if (connector->override_edid) {
+			struct edid *edid = (struct edid *) connector->edid_blob_ptr->data;
+
+			count = drm_add_edid_modes(connector, edid);
+		} else
+			count = (*connector_funcs->get_modes)(connector);
+	}
 
 	if (count == 0 && connector->status == connector_status_connected)
 		count = drm_add_modes_noedid(connector, 1024, 768);

commit 259338205c428454515a09654be69a9f6c983513
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jun 3 14:56:20 2014 +0300

    drm: replace drm_get_connector_name() with direct name field use
    
    Generated using semantic patch:
    
    @@
    expression E;
    @@
    
    - drm_get_connector_name(E)
    + E->name
    
    [airlied: regenerated]
    
    Acked-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 79f07f2c13d3..d22676b89cbb 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -96,7 +96,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
 
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
-			drm_get_connector_name(connector));
+			connector->name);
 	/* set all modes to the unverified state */
 	list_for_each_entry(mode, &connector->modes, head)
 		mode->status = MODE_UNVERIFIED;
@@ -120,7 +120,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 
 	if (connector->status == connector_status_disconnected) {
 		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",
-			connector->base.id, drm_get_connector_name(connector));
+			connector->base.id, connector->name);
 		drm_mode_connector_update_edid_property(connector, NULL);
 		verbose_prune = false;
 		goto prune;
@@ -168,7 +168,7 @@ static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect
 	drm_mode_sort(&connector->modes);
 
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,
-			drm_get_connector_name(connector));
+			connector->name);
 	list_for_each_entry(mode, &connector->modes, head) {
 		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
 		drm_mode_debug_printmodeline(mode);
@@ -286,7 +286,7 @@ static void output_poll_execute(struct work_struct *work)
 			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] "
 				      "status updated from %s to %s\n",
 				      connector->base.id,
-				      drm_get_connector_name(connector),
+				      connector->name,
 				      old, new);
 
 			changed = true;
@@ -431,7 +431,7 @@ bool drm_helper_hpd_irq_event(struct drm_device *dev)
 		connector->status = connector->funcs->detect(connector, false);
 		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
 			      connector->base.id,
-			      drm_get_connector_name(connector),
+			      connector->name,
 			      drm_get_connector_status_name(old_status),
 			      drm_get_connector_status_name(connector->status));
 		if (old_status != connector->status)

commit 425a9a3ad1e64a00b4dbc827ae58df2aaf10ef43
Merge: ad222799bec3 a74591d781a8
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 16 11:47:13 2014 +1000

    Merge tag 'topic/core-stuff-2014-05-05' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Update pull request with drm core patches. Mostly some polish for the
    primary plane stuff and a pile of patches all over from Thierry. Has
    survived a few days in drm-intel-nightly without causing ill.
    
    I've frobbed my scripts a bit to also tag my topic branches so that you
    have something stable to pull - I've accidentally pushed a bunch more
    patches onto this branch before you've taken the old pull request.
    
    * tag 'topic/core-stuff-2014-05-05' of git://anongit.freedesktop.org/drm-intel:
      drm: Make drm_crtc_helper_disable() return void
      drm: Fix indentation of closing brace
      drm/dp: Fix typo in comment
      drm: Fixup flip-work kerneldoc
      drm/fb: Fix typos
      drm/edid: Cleanup kerneldoc
      drm/edid: Drop revision argument for drm_mode_std()
      drm: Try to acquire modeset lock on panic or sysrq
      drm: remove unused argument from drm_open_helper
      drm: Handle ->disable_plane failures correctly
      drm: Simplify fb refcounting rules around ->update_plane
      drm/crtc-helper: gc usless connector loop in disable_unused_functions
      drm/plane_helper: don't disable plane in destroy function
      drm/plane-helper: Fix primary plane scaling check
      drm: make mode_valid callback optional
      drm/edid: Fill PAR in AVI infoframe based on CEA mode list

commit b87577b7c768683736eea28f70779e8c75b4df62
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 1 09:26:53 2014 +1000

    drm: try harder to avoid regression when merging mode bits
    
    For QXL hw we really want the bits to be replaced as we change
    the preferred mode on the fly, and the same goes for virgl when
    I get to it, however the original fix for this seems to have caused
    a wierd regression on Intel G33 that in a stunning display of failure
    at opposition to his normal self, Daniel failed to diagnose.
    
    So we are left doing this, ugly ugly ugly ugly, Daniel you fixed
    that G33 yet?, ugly, ugly.
    
    Tested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index e70f54d4a581..8afdd0998a8c 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -82,26 +82,8 @@ static void drm_mode_validate_flag(struct drm_connector *connector,
 	return;
 }
 
-/**
- * drm_helper_probe_single_connector_modes - get complete set of display modes
- * @connector: connector to probe
- * @maxX: max width for modes
- * @maxY: max height for modes
- *
- * Based on the helper callbacks implemented by @connector try to detect all
- * valid modes.  Modes will first be added to the connector's probed_modes list,
- * then culled (based on validity and the @maxX, @maxY parameters) and put into
- * the normal modes list.
- *
- * Intended to be use as a generic implementation of the ->fill_modes()
- * @connector vfunc for drivers that use the crtc helpers for output mode
- * filtering and detection.
- *
- * Returns:
- * The number of modes found on @connector.
- */
-int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
-					    uint32_t maxX, uint32_t maxY)
+static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connector *connector,
+							      uint32_t maxX, uint32_t maxY, bool merge_type_bits)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_display_mode *mode;
@@ -155,7 +137,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	if (count == 0)
 		goto prune;
 
-	drm_mode_connector_list_update(connector);
+	drm_mode_connector_list_update(connector, merge_type_bits);
 
 	if (maxX && maxY)
 		drm_mode_validate_size(dev, &connector->modes, maxX, maxY);
@@ -194,8 +176,48 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 
 	return count;
 }
+
+/**
+ * drm_helper_probe_single_connector_modes - get complete set of display modes
+ * @connector: connector to probe
+ * @maxX: max width for modes
+ * @maxY: max height for modes
+ *
+ * Based on the helper callbacks implemented by @connector try to detect all
+ * valid modes.  Modes will first be added to the connector's probed_modes list,
+ * then culled (based on validity and the @maxX, @maxY parameters) and put into
+ * the normal modes list.
+ *
+ * Intended to be use as a generic implementation of the ->fill_modes()
+ * @connector vfunc for drivers that use the crtc helpers for output mode
+ * filtering and detection.
+ *
+ * Returns:
+ * The number of modes found on @connector.
+ */
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
+					    uint32_t maxX, uint32_t maxY)
+{
+	return drm_helper_probe_single_connector_modes_merge_bits(connector, maxX, maxY, true);
+}
 EXPORT_SYMBOL(drm_helper_probe_single_connector_modes);
 
+/**
+ * drm_helper_probe_single_connector_modes_nomerge - get complete set of display modes
+ * @connector: connector to probe
+ * @maxX: max width for modes
+ * @maxY: max height for modes
+ *
+ * This operates like drm_hehlper_probe_single_connector_modes except it
+ * replaces the mode bits instead of merging them for preferred modes.
+ */
+int drm_helper_probe_single_connector_modes_nomerge(struct drm_connector *connector,
+					    uint32_t maxX, uint32_t maxY)
+{
+	return drm_helper_probe_single_connector_modes_merge_bits(connector, maxX, maxY, false);
+}
+EXPORT_SYMBOL(drm_helper_probe_single_connector_modes_nomerge);
+
 /**
  * drm_kms_helper_hotplug_event - fire off KMS hotplug events
  * @dev: drm_device whose connector state changed

commit f9b0e251dfbf2c4da642ec9210db29a7ac63b81a
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Wed Apr 2 12:29:46 2014 +0200

    drm: make mode_valid callback optional
    
    Many drm connectors do not need mode validation.
    The patch makes this callback optional and removes dumb implementations.
    
    v2: Rebase:
    - imx move to a shared (but still dummy) ->mode_valid implementation.
    - probe helpers have been extracted to drm_probe_helper.c
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com> (v1)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index e70f54d4a581..d06340985a72 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -169,7 +169,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	drm_mode_validate_flag(connector, mode_flags);
 
 	list_for_each_entry(mode, &connector->modes, head) {
-		if (mode->status == MODE_OK)
+		if (mode->status == MODE_OK && connector_funcs->mode_valid)
 			mode->status = connector_funcs->mode_valid(connector,
 								   mode);
 	}

commit 8d754544202c0e4ef02e9c1abdf379bcf7ef9384
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Apr 10 10:51:11 2014 +0200

    drm: Split out drm_probe_helper.c from drm_crtc_helper.c
    
    This is leftover stuff from my previous doc round which I kinda wanted
    to do but didn't yet due to rebase hell.
    
    The modeset helpers and the probing helpers a independent and e.g.
    i915 uses the probing stuff but has its own modeset infrastructure. It
    hence makes to split this up. While at it add a DOC: comment for the
    probing libraray.
    
    It would be rather neat to pull some of the DocBook documenting these
    two helpers into in-line DOC: comments. But unfortunately kerneldoc
    doesn't support markdown or something similar to make nice-looking
    documentation, so the current state is better.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
new file mode 100644
index 000000000000..e70f54d4a581
--- /dev/null
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ *
+ * DRM core CRTC related functions
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Keith Packard
+ *	Eric Anholt <eric@anholt.net>
+ *      Dave Airlie <airlied@linux.ie>
+ *      Jesse Barnes <jesse.barnes@intel.com>
+ */
+
+#include <linux/export.h>
+#include <linux/moduleparam.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_edid.h>
+
+/**
+ * DOC: output probing helper overview
+ *
+ * This library provides some helper code for output probing. It provides an
+ * implementation of the core connector->fill_modes interface with
+ * drm_helper_probe_single_connector_modes.
+ *
+ * It also provides support for polling connectors with a work item and for
+ * generic hotplug interrupt handling where the driver doesn't or cannot keep
+ * track of a per-connector hpd interrupt.
+ *
+ * This helper library can be used independently of the modeset helper library.
+ * Drivers can also overwrite different parts e.g. use their own hotplug
+ * handling code to avoid probing unrelated outputs.
+ */
+
+static bool drm_kms_helper_poll = true;
+module_param_named(poll, drm_kms_helper_poll, bool, 0600);
+
+static void drm_mode_validate_flag(struct drm_connector *connector,
+				   int flags)
+{
+	struct drm_display_mode *mode;
+
+	if (flags == (DRM_MODE_FLAG_DBLSCAN | DRM_MODE_FLAG_INTERLACE |
+		      DRM_MODE_FLAG_3D_MASK))
+		return;
+
+	list_for_each_entry(mode, &connector->modes, head) {
+		if ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+				!(flags & DRM_MODE_FLAG_INTERLACE))
+			mode->status = MODE_NO_INTERLACE;
+		if ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&
+				!(flags & DRM_MODE_FLAG_DBLSCAN))
+			mode->status = MODE_NO_DBLESCAN;
+		if ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&
+				!(flags & DRM_MODE_FLAG_3D_MASK))
+			mode->status = MODE_NO_STEREO;
+	}
+
+	return;
+}
+
+/**
+ * drm_helper_probe_single_connector_modes - get complete set of display modes
+ * @connector: connector to probe
+ * @maxX: max width for modes
+ * @maxY: max height for modes
+ *
+ * Based on the helper callbacks implemented by @connector try to detect all
+ * valid modes.  Modes will first be added to the connector's probed_modes list,
+ * then culled (based on validity and the @maxX, @maxY parameters) and put into
+ * the normal modes list.
+ *
+ * Intended to be use as a generic implementation of the ->fill_modes()
+ * @connector vfunc for drivers that use the crtc helpers for output mode
+ * filtering and detection.
+ *
+ * Returns:
+ * The number of modes found on @connector.
+ */
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
+					    uint32_t maxX, uint32_t maxY)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *mode;
+	struct drm_connector_helper_funcs *connector_funcs =
+		connector->helper_private;
+	int count = 0;
+	int mode_flags = 0;
+	bool verbose_prune = true;
+
+	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
+
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
+			drm_get_connector_name(connector));
+	/* set all modes to the unverified state */
+	list_for_each_entry(mode, &connector->modes, head)
+		mode->status = MODE_UNVERIFIED;
+
+	if (connector->force) {
+		if (connector->force == DRM_FORCE_ON)
+			connector->status = connector_status_connected;
+		else
+			connector->status = connector_status_disconnected;
+		if (connector->funcs->force)
+			connector->funcs->force(connector);
+	} else {
+		connector->status = connector->funcs->detect(connector, true);
+	}
+
+	/* Re-enable polling in case the global poll config changed. */
+	if (drm_kms_helper_poll != dev->mode_config.poll_running)
+		drm_kms_helper_poll_enable(dev);
+
+	dev->mode_config.poll_running = drm_kms_helper_poll;
+
+	if (connector->status == connector_status_disconnected) {
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",
+			connector->base.id, drm_get_connector_name(connector));
+		drm_mode_connector_update_edid_property(connector, NULL);
+		verbose_prune = false;
+		goto prune;
+	}
+
+#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE
+	count = drm_load_edid_firmware(connector);
+	if (count == 0)
+#endif
+		count = (*connector_funcs->get_modes)(connector);
+
+	if (count == 0 && connector->status == connector_status_connected)
+		count = drm_add_modes_noedid(connector, 1024, 768);
+	if (count == 0)
+		goto prune;
+
+	drm_mode_connector_list_update(connector);
+
+	if (maxX && maxY)
+		drm_mode_validate_size(dev, &connector->modes, maxX, maxY);
+
+	if (connector->interlace_allowed)
+		mode_flags |= DRM_MODE_FLAG_INTERLACE;
+	if (connector->doublescan_allowed)
+		mode_flags |= DRM_MODE_FLAG_DBLSCAN;
+	if (connector->stereo_allowed)
+		mode_flags |= DRM_MODE_FLAG_3D_MASK;
+	drm_mode_validate_flag(connector, mode_flags);
+
+	list_for_each_entry(mode, &connector->modes, head) {
+		if (mode->status == MODE_OK)
+			mode->status = connector_funcs->mode_valid(connector,
+								   mode);
+	}
+
+prune:
+	drm_mode_prune_invalid(dev, &connector->modes, verbose_prune);
+
+	if (list_empty(&connector->modes))
+		return 0;
+
+	list_for_each_entry(mode, &connector->modes, head)
+		mode->vrefresh = drm_mode_vrefresh(mode);
+
+	drm_mode_sort(&connector->modes);
+
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,
+			drm_get_connector_name(connector));
+	list_for_each_entry(mode, &connector->modes, head) {
+		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+		drm_mode_debug_printmodeline(mode);
+	}
+
+	return count;
+}
+EXPORT_SYMBOL(drm_helper_probe_single_connector_modes);
+
+/**
+ * drm_kms_helper_hotplug_event - fire off KMS hotplug events
+ * @dev: drm_device whose connector state changed
+ *
+ * This function fires off the uevent for userspace and also calls the
+ * output_poll_changed function, which is most commonly used to inform the fbdev
+ * emulation code and allow it to update the fbcon output configuration.
+ *
+ * Drivers should call this from their hotplug handling code when a change is
+ * detected. Note that this function does not do any output detection of its
+ * own, like drm_helper_hpd_irq_event() does - this is assumed to be done by the
+ * driver already.
+ *
+ * This function must be called from process context with no mode
+ * setting locks held.
+ */
+void drm_kms_helper_hotplug_event(struct drm_device *dev)
+{
+	/* send a uevent + call fbdev */
+	drm_sysfs_hotplug_event(dev);
+	if (dev->mode_config.funcs->output_poll_changed)
+		dev->mode_config.funcs->output_poll_changed(dev);
+}
+EXPORT_SYMBOL(drm_kms_helper_hotplug_event);
+
+#define DRM_OUTPUT_POLL_PERIOD (10*HZ)
+static void output_poll_execute(struct work_struct *work)
+{
+	struct delayed_work *delayed_work = to_delayed_work(work);
+	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
+	struct drm_connector *connector;
+	enum drm_connector_status old_status;
+	bool repoll = false, changed = false;
+
+	if (!drm_kms_helper_poll)
+		return;
+
+	mutex_lock(&dev->mode_config.mutex);
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+
+		/* Ignore forced connectors. */
+		if (connector->force)
+			continue;
+
+		/* Ignore HPD capable connectors and connectors where we don't
+		 * want any hotplug detection at all for polling. */
+		if (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)
+			continue;
+
+		repoll = true;
+
+		old_status = connector->status;
+		/* if we are connected and don't want to poll for disconnect
+		   skip it */
+		if (old_status == connector_status_connected &&
+		    !(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))
+			continue;
+
+		connector->status = connector->funcs->detect(connector, false);
+		if (old_status != connector->status) {
+			const char *old, *new;
+
+			old = drm_get_connector_status_name(old_status);
+			new = drm_get_connector_status_name(connector->status);
+
+			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] "
+				      "status updated from %s to %s\n",
+				      connector->base.id,
+				      drm_get_connector_name(connector),
+				      old, new);
+
+			changed = true;
+		}
+	}
+
+	mutex_unlock(&dev->mode_config.mutex);
+
+	if (changed)
+		drm_kms_helper_hotplug_event(dev);
+
+	if (repoll)
+		schedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);
+}
+
+/**
+ * drm_kms_helper_poll_disable - disable output polling
+ * @dev: drm_device
+ *
+ * This function disables the output polling work.
+ *
+ * Drivers can call this helper from their device suspend implementation. It is
+ * not an error to call this even when output polling isn't enabled or arlready
+ * disabled.
+ */
+void drm_kms_helper_poll_disable(struct drm_device *dev)
+{
+	if (!dev->mode_config.poll_enabled)
+		return;
+	cancel_delayed_work_sync(&dev->mode_config.output_poll_work);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_disable);
+
+/**
+ * drm_kms_helper_poll_enable - re-enable output polling.
+ * @dev: drm_device
+ *
+ * This function re-enables the output polling work.
+ *
+ * Drivers can call this helper from their device resume implementation. It is
+ * an error to call this when the output polling support has not yet been set
+ * up.
+ */
+void drm_kms_helper_poll_enable(struct drm_device *dev)
+{
+	bool poll = false;
+	struct drm_connector *connector;
+
+	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
+		return;
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
+					 DRM_CONNECTOR_POLL_DISCONNECT))
+			poll = true;
+	}
+
+	if (poll)
+		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_enable);
+
+/**
+ * drm_kms_helper_poll_init - initialize and enable output polling
+ * @dev: drm_device
+ *
+ * This function intializes and then also enables output polling support for
+ * @dev. Drivers which do not have reliable hotplug support in hardware can use
+ * this helper infrastructure to regularly poll such connectors for changes in
+ * their connection state.
+ *
+ * Drivers can control which connectors are polled by setting the
+ * DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
+ * connectors where probing live outputs can result in visual distortion drivers
+ * should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
+ * Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
+ * completely ignored by the polling logic.
+ *
+ * Note that a connector can be both polled and probed from the hotplug handler,
+ * in case the hotplug interrupt is known to be unreliable.
+ */
+void drm_kms_helper_poll_init(struct drm_device *dev)
+{
+	INIT_DELAYED_WORK(&dev->mode_config.output_poll_work, output_poll_execute);
+	dev->mode_config.poll_enabled = true;
+
+	drm_kms_helper_poll_enable(dev);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_init);
+
+/**
+ * drm_kms_helper_poll_fini - disable output polling and clean it up
+ * @dev: drm_device
+ */
+void drm_kms_helper_poll_fini(struct drm_device *dev)
+{
+	drm_kms_helper_poll_disable(dev);
+}
+EXPORT_SYMBOL(drm_kms_helper_poll_fini);
+
+/**
+ * drm_helper_hpd_irq_event - hotplug processing
+ * @dev: drm_device
+ *
+ * Drivers can use this helper function to run a detect cycle on all connectors
+ * which have the DRM_CONNECTOR_POLL_HPD flag set in their &polled member. All
+ * other connectors are ignored, which is useful to avoid reprobing fixed
+ * panels.
+ *
+ * This helper function is useful for drivers which can't or don't track hotplug
+ * interrupts for each connector.
+ *
+ * Drivers which support hotplug interrupts for each connector individually and
+ * which have a more fine-grained detect logic should bypass this code and
+ * directly call drm_kms_helper_hotplug_event() in case the connector state
+ * changed.
+ *
+ * This function must be called from process context with no mode
+ * setting locks held.
+ *
+ * Note that a connector can be both polled and probed from the hotplug handler,
+ * in case the hotplug interrupt is known to be unreliable.
+ */
+bool drm_helper_hpd_irq_event(struct drm_device *dev)
+{
+	struct drm_connector *connector;
+	enum drm_connector_status old_status;
+	bool changed = false;
+
+	if (!dev->mode_config.poll_enabled)
+		return false;
+
+	mutex_lock(&dev->mode_config.mutex);
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+
+		/* Only handle HPD capable connectors. */
+		if (!(connector->polled & DRM_CONNECTOR_POLL_HPD))
+			continue;
+
+		old_status = connector->status;
+
+		connector->status = connector->funcs->detect(connector, false);
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
+			      connector->base.id,
+			      drm_get_connector_name(connector),
+			      drm_get_connector_status_name(old_status),
+			      drm_get_connector_status_name(connector->status));
+		if (old_status != connector->status)
+			changed = true;
+	}
+
+	mutex_unlock(&dev->mode_config.mutex);
+
+	if (changed)
+		drm_kms_helper_hotplug_event(dev);
+
+	return changed;
+}
+EXPORT_SYMBOL(drm_helper_hpd_irq_event);
