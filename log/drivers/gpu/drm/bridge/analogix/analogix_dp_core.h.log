commit 6c836d965bad5e13803256e3d316b50248531f4e
Author: Sean Paul <seanpaul@chromium.org>
Date:   Tue Jun 11 12:08:22 2019 -0400

    drm/rockchip: Use the helpers for PSR
    
    Instead of rolling our own implementation for tracking when PSR should
    be [in]active, use the new self refresh helpers to do the heavy lifting.
    
    Changes in v2:
    - updated to reflect changes made in the helpers
    Changes in v3:
    - use the new atomic hooks to inspect crtc state instead of needing conn state (Daniel)
    Changes in v4:
    - Use Laurent's get_new_connector_for_encoder helper (Daniel)
    - Exit vop disable early if it's already off
    Changes in v5:
    - Rebase on latest drm-misc-next
    - Resolve conflict with s/edp_vsc_psr/dp_sdp/ rename
    - Resolve conflict with drm_atomic.h header inclusion
    
    Link to v1: https://patchwork.freedesktop.org/patch/msgid/20190228210939.83386-4-sean@poorly.run
    Link to v2: https://patchwork.freedesktop.org/patch/msgid/20190326204509.96515-3-sean@poorly.run
    Link to v3: https://patchwork.freedesktop.org/patch/msgid/20190502194956.218441-9-sean@poorly.run
    Link to v4: https://patchwork.freedesktop.org/patch/msgid/20190508160920.144739-9-sean@poorly.run
    
    Cc: Zain Wang <wzz@rock-chips.com>
    Cc: Tomasz Figa <tfiga@chromium.org>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    [seanpaul resolved some conflicts with drmP.h work and Helen's async fixes]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190611160844.257498-9-sean@poorly.run

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index da058252dcaf..c051502d7fbf 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -171,8 +171,8 @@ struct analogix_dp_device {
 	int			dpms_mode;
 	struct gpio_desc	*hpd_gpiod;
 	bool                    force_hpd;
-	bool			psr_enable;
 	bool			fast_train_enable;
+	bool			psr_supported;
 
 	struct mutex		panel_lock;
 	bool			panel_is_modeset;

commit 52d2d44eee8091e740d0d275df1311fb8373c9a9
Merge: 2454fcea338a 9e0babf2c06c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 19 12:04:55 2019 +0200

    Merge v5.2-rc5 into drm-next
    
    Maarten needs -rc4 backmerged so he can pull in the fbcon notifier
    removal topic branch into drm-misc-next.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 5b038dcf9d0aa0b1e8f2a8f973441b4f66d325f2
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jun 10 01:13:39 2019 +0200

    drm/bridge: analogix_dp: Convert to GPIO descriptors
    
    This converts the Analogix display port to use GPIO descriptors
    instead of DT-extracted numbers.
    
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609231339.22136-1-linus.walleij@linaro.org

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 3e5fe90edf71..e483f5cecd55 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -38,6 +38,8 @@
 #define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
 #define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
 
+struct gpio_desc;
+
 enum link_lane_count_type {
 	LANE_COUNT1 = 1,
 	LANE_COUNT2 = 2,
@@ -171,7 +173,7 @@ struct analogix_dp_device {
 	struct link_train	link_train;
 	struct phy		*phy;
 	int			dpms_mode;
-	int			hpd_gpio;
+	struct gpio_desc	*hpd_gpiod;
 	bool                    force_hpd;
 	bool			psr_enable;
 	bool			fast_train_enable;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 769255dc6e99..8d82f2555880 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -1,13 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Header file for Analogix DP (Display Port) core interface driver.
  *
  * Copyright (C) 2012 Samsung Electronics Co., Ltd.
  * Author: Jingoo Han <jg1.han@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
  */
 
 #ifndef _ANALOGIX_DP_CORE_H

commit 4d432f956d4f3fe5a7082e11ee029d43f6f64457
Author: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Date:   Tue May 21 15:17:17 2019 +0300

    drm: Rename struct edp_vsc_psr to struct dp_sdp
    
    VSC SDP Payload for PSR is one of data block type of SDP (Secondaray Data
    Packet). In order to generalize SDP packet structure name, it renames
    struct edp_vsc_psr to struct dp_sdp. And each SDP data blocks have
    different usages, each SDP type has different reserved data blocks and
    Video_Stream_Configuration Extension VESA SDP might use all of Data Blocks
    as Extended INFORFRAME Data Byte. so it makes Data Block variables as
    array type. And it adds comments of details of DB of VSC SDP Payload
    for Pixel Encoding/Colorimetry Format. This comments follows DP 1.4a spec,
    section 2.2.5.7.5, chapter "VSC SDP Payload for Pixel Encoding/Colorimetry
    Format".
    
    v7: Addressed review comments from Ville.
    
    v9: Rename a member value name DB to db on struct dp_sdp [Laurent]
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521121721.32010-3-gwan-gyeong.mun@intel.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 769255dc6e99..3e5fe90edf71 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -254,7 +254,7 @@ void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);
 int analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
-			     struct edp_vsc_psr *vsc, bool blocking);
+			     struct dp_sdp *vsc, bool blocking);
 ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 			     struct drm_dp_aux_msg *msg);
 

commit 8a335736f94edc9c8c977d931301e6a0326fbc3e
Author: zain wang <wzz@rock-chips.com>
Date:   Mon Apr 23 12:49:40 2018 +0200

    drm/bridge: analogix_dp: Retry bridge enable when it failed
    
    When we enable bridge failed, we have to retry it, otherwise we would get
    the abnormal display.
    
    Cc: Stéphane Marchesin <marcheu@chromium.org>
    Signed-off-by: zain wang <wzz@rock-chips.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180423105003.9004-5-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 403ff853464b..769255dc6e99 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -19,6 +19,7 @@
 #define DP_TIMEOUT_LOOP_COUNT 100
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
+#define MAX_PLL_LOCK_LOOP 5
 
 /* Training takes 22ms if AUX channel comm fails. Use this as retry interval */
 #define DP_TIMEOUT_TRAINING_US			22000
@@ -197,7 +198,7 @@ void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable);
 void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
 				       enum analog_power_block block,
 				       bool enable);
-void analogix_dp_init_analog_func(struct analogix_dp_device *dp);
+int analogix_dp_init_analog_func(struct analogix_dp_device *dp);
 void analogix_dp_init_hpd(struct analogix_dp_device *dp);
 void analogix_dp_force_hpd(struct analogix_dp_device *dp);
 enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp);

commit 7ba8fb5704e958b94b6f0260f20afca58b35a55a
Author: zain wang <wzz@rock-chips.com>
Date:   Mon Apr 23 12:49:39 2018 +0200

    drm/bridge: analogix_dp: Don't use fast link training when panel just powered up
    
    Panel would reset its setting when it powers down. It would forget the last
    succeeded link training setting. So we can't use the last successful link
    training setting to do fast link training. Let's reset fast_train_enable in
    analogix_dp_bridge_disable();
    
    Cc: Stéphane Marchesin <marcheu@chromium.org>
    Signed-off-by: zain wang <wzz@rock-chips.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180423105003.9004-4-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 6a96ef7e6934..403ff853464b 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -173,7 +173,7 @@ struct analogix_dp_device {
 	int			hpd_gpio;
 	bool                    force_hpd;
 	bool			psr_enable;
-	bool			fast_train_support;
+	bool			fast_train_enable;
 
 	struct mutex		panel_lock;
 	bool			panel_is_modeset;

commit ce31ddd5c40c0662ffb9957b868fbd58f6eac5b3
Author: zain wang <wzz@rock-chips.com>
Date:   Fri Mar 9 23:22:57 2018 +0100

    drm/bridge: analogix_dp: Only wait for panel ACK on PSR entry
    
    We currently wait for the panel to mirror our intended PSR state
    before continuing on both PSR enter and PSR exit. This is really
    only important to do when we're entering PSR, since we want to
    be sure the last frame we pushed is being served from the panel's
    internal fb before shutting down the soc blocks (vop/analogix).
    
    This patch changes the behavior such that we only wait for the
    panel to complete the PSR transition when we're entering PSR, and
    to skip verification when we're exiting.
    
    Cc: Stéphane Marchesin <marcheu@chromium.org>
    Cc: Sonny Rao <sonnyrao@chromium.org>
    Signed-off-by: zain wang <wzz@rock-chips.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180309222327.18689-7-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 920607d7eb3e..6a96ef7e6934 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -253,7 +253,7 @@ void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);
 int analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
-			     struct edp_vsc_psr *vsc);
+			     struct edp_vsc_psr *vsc, bool blocking);
 ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 			     struct drm_dp_aux_msg *msg);
 

commit f9d5680596f2dac390918e6aec3e174db03633a3
Author: zain wang <wzz@rock-chips.com>
Date:   Fri Mar 9 23:22:56 2018 +0100

    drm/bridge: analogix_dp: add fast link train for eDP
    
    We would meet a short black screen when exit PSR with the full link
    training, In this case, we should use fast link train instead of full
    link training.
    
    Signed-off-by: zain wang <wzz@rock-chips.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    [dropped header reordering]
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180309222327.18689-6-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index e135a42cb19e..920607d7eb3e 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -20,6 +20,8 @@
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
 
+/* Training takes 22ms if AUX channel comm fails. Use this as retry interval */
+#define DP_TIMEOUT_TRAINING_US			22000
 #define DP_TIMEOUT_PSR_LOOP_MS			300
 
 /* DP_MAX_LANE_COUNT */
@@ -171,6 +173,7 @@ struct analogix_dp_device {
 	int			hpd_gpio;
 	bool                    force_hpd;
 	bool			psr_enable;
+	bool			fast_train_support;
 
 	struct mutex		panel_lock;
 	bool			panel_is_modeset;

commit 243e398aab8dc0ba966dbcfef189b5a616e74a78
Author: zain wang <wzz@rock-chips.com>
Date:   Fri Mar 9 23:22:54 2018 +0100

    drm/bridge: analogix_dp: Don't change psr while bridge is disabled
    
    There is a race between AUX CH bring-up and enabling bridge which will
    cause link training to fail. To avoid hitting it, don't change psr state
    while enabling the bridge.
    
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: zain wang <wzz@rock-chips.com>
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    [seanpaul fixed up the commit message a bit and renamed *_supported to *_enabled]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180309222327.18689-4-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index b039b28d8fcc..e135a42cb19e 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -170,7 +170,7 @@ struct analogix_dp_device {
 	int			dpms_mode;
 	int			hpd_gpio;
 	bool                    force_hpd;
-	bool			psr_support;
+	bool			psr_enable;
 
 	struct mutex		panel_lock;
 	bool			panel_is_modeset;

commit 1d38e421bebd6ca24283dd88c4416378ee89825e
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Fri Mar 9 23:22:52 2018 +0100

    drm/bridge: analogix_dp: detect Sink PSR state after configuring the PSR
    
    Make sure the request PSR state takes effect in analogix_dp_send_psr_spd()
    function, or print the sink PSR error state if we failed to apply the
    requested PSR setting.
    
    Cc: 征增 王 <wzz@rock-chips.com>
    Cc: Stéphane Marchesin <marcheu@chromium.org>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    [seanpaul changed timeout loop to a readx poll]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180309222327.18689-2-enric.balletbo@collabora.com

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 5c6a28806129..b039b28d8fcc 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -20,6 +20,8 @@
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
 
+#define DP_TIMEOUT_PSR_LOOP_MS			300
+
 /* DP_MAX_LANE_COUNT */
 #define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
 #define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
@@ -247,8 +249,8 @@ void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);
 void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);
-void analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
-			      struct edp_vsc_psr *vsc);
+int analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
+			     struct edp_vsc_psr *vsc);
 ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 			     struct drm_dp_aux_msg *msg);
 

commit 0d97ad03f4220ca84f700c5fea988859ea0c3b98
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Wed Aug 24 10:54:41 2016 -0400

    drm/bridge: analogix_dp: Remove duplicated code
    
    Remove code for reading the EDID and DPCD fields and use the helpers
    instead.
    
    Besides the obvious code reduction, other helpers are being added to the
    core that could be used in this driver and will be good to be able to
    use them instead of duplicating them.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Mika Kahola <mika.kahola@intel.com>
    Cc: Yakir Yang <ykk@rock-chips.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Archit Taneja <architt@codeaurora.org>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 473b9802b2d6..5c6a28806129 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -20,15 +20,6 @@
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
 
-/* I2C EDID Chip ID, Slave Address */
-#define I2C_EDID_DEVICE_ADDR			0x50
-#define I2C_E_EDID_DEVICE_ADDR			0x30
-
-#define EDID_BLOCK_LENGTH			0x80
-#define EDID_HEADER_PATTERN			0x00
-#define EDID_EXTENSION_FLAG			0x7e
-#define EDID_CHECKSUM				0x7f
-
 /* DP_MAX_LANE_COUNT */
 #define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
 #define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
@@ -166,6 +157,7 @@ struct analogix_dp_device {
 	struct drm_device	*drm_dev;
 	struct drm_connector	connector;
 	struct drm_bridge	*bridge;
+	struct drm_dp_aux       aux;
 	struct clk		*clock;
 	unsigned int		irq;
 	void __iomem		*reg_base;
@@ -176,7 +168,6 @@ struct analogix_dp_device {
 	int			dpms_mode;
 	int			hpd_gpio;
 	bool                    force_hpd;
-	unsigned char           edid[EDID_BLOCK_LENGTH * 2];
 	bool			psr_support;
 
 	struct mutex		panel_lock;
@@ -210,33 +201,6 @@ void analogix_dp_reset_aux(struct analogix_dp_device *dp);
 void analogix_dp_init_aux(struct analogix_dp_device *dp);
 int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp);
 void analogix_dp_enable_sw_function(struct analogix_dp_device *dp);
-int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp);
-int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
-				   unsigned int reg_addr,
-				   unsigned char data);
-int analogix_dp_read_byte_from_dpcd(struct analogix_dp_device *dp,
-				    unsigned int reg_addr,
-				    unsigned char *data);
-int analogix_dp_write_bytes_to_dpcd(struct analogix_dp_device *dp,
-				    unsigned int reg_addr,
-				    unsigned int count,
-				    unsigned char data[]);
-int analogix_dp_read_bytes_from_dpcd(struct analogix_dp_device *dp,
-				     unsigned int reg_addr,
-				     unsigned int count,
-				     unsigned char data[]);
-int analogix_dp_select_i2c_device(struct analogix_dp_device *dp,
-				  unsigned int device_addr,
-				  unsigned int reg_addr);
-int analogix_dp_read_byte_from_i2c(struct analogix_dp_device *dp,
-				   unsigned int device_addr,
-				   unsigned int reg_addr,
-				   unsigned int *data);
-int analogix_dp_read_bytes_from_i2c(struct analogix_dp_device *dp,
-				    unsigned int device_addr,
-				    unsigned int reg_addr,
-				    unsigned int count,
-				    unsigned char edid[]);
 void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype);
 void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype);
 void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count);
@@ -285,5 +249,7 @@ void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);
 void analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
 			      struct edp_vsc_psr *vsc);
+ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
+			     struct drm_dp_aux_msg *msg);
 
 #endif /* _ANALOGIX_DP_CORE_H */

commit 5b3f84f222b6bb955c5a473ddff707e252be71b4
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Sun Jul 24 14:57:48 2016 +0800

    drm/bridge: analogix_dp: add the PSR function support
    
    The full name of PSR is Panel Self Refresh, panel device could refresh
    itself with the hardware framebuffer in panel, this would make lots of
    sense to save the power consumption.
    
    This patch have exported two symbols for platform driver to implement
    the PSR function in hardware side:
    - analogix_dp_active_psr()
    - analogix_dp_inactive_psr()
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 43108d7df205..473b9802b2d6 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -177,6 +177,7 @@ struct analogix_dp_device {
 	int			hpd_gpio;
 	bool                    force_hpd;
 	unsigned char           edid[EDID_BLOCK_LENGTH * 2];
+	bool			psr_support;
 
 	struct mutex		panel_lock;
 	bool			panel_is_modeset;
@@ -281,4 +282,8 @@ int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);
 void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);
 void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
+void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);
+void analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
+			      struct edp_vsc_psr *vsc);
+
 #endif /* _ANALOGIX_DP_CORE_H */

commit 0b8b059a75b08f85e3db843aa33461a6e0d3bb09
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Aug 8 14:53:18 2016 -0400

    drm/bridge: analogix_dp: Ensure the panel is properly prepared/unprepared
    
    Instead of just preparing the panel on bind, actually prepare/unprepare
    during modeset/disable. The panel must be prepared in order to read hpd
    status and edid, so we need to keep state around the prepares in order
    to ensure we don't accidentally turn the panel off at the wrong time.
    
    Reviewed-by: Yakir Yang <ykk@rock-chips.com>
    Tested-by: Yakir Yang <ykk@rock-chips.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index b45638043ec4..43108d7df205 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -178,6 +178,9 @@ struct analogix_dp_device {
 	bool                    force_hpd;
 	unsigned char           edid[EDID_BLOCK_LENGTH * 2];
 
+	struct mutex		panel_lock;
+	bool			panel_is_modeset;
+
 	struct analogix_dp_plat_data *plat_data;
 };
 

commit 7608a9fb37b02c5cce3199f87eafb0a6c07d6f93
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Wed Jun 29 17:15:47 2016 +0800

    drm/bridge: analogix_dp: fix no drm hpd event when panel plug in
    
    The enum value of DP_IRQ_TYPE_HP_CABLE_IN is zero, but driver only
    send drm hp event when the irq_type and the enum value is true.
    
    if (irq_type & DP_IRQ_TYPE_HP_CABLE_IN || ...)
            drm_helper_hpd_irq_event(dp->drm_dev);
    
    So there would no drm hpd event when cable plug in, to fix that
    just need to assign all hotplug enum with no-zero values.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Stéphane Marchesin <marcheu@chromium.org>
    Reviewed-by: Tomasz Figa <tomasz.figa@chromium.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index f09275d40f70..b45638043ec4 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -127,10 +127,10 @@ enum analog_power_block {
 };
 
 enum dp_irq_type {
-	DP_IRQ_TYPE_HP_CABLE_IN,
-	DP_IRQ_TYPE_HP_CABLE_OUT,
-	DP_IRQ_TYPE_HP_CHANGE,
-	DP_IRQ_TYPE_UNKNOWN,
+	DP_IRQ_TYPE_HP_CABLE_IN  = BIT(0),
+	DP_IRQ_TYPE_HP_CABLE_OUT = BIT(1),
+	DP_IRQ_TYPE_HP_CHANGE    = BIT(2),
+	DP_IRQ_TYPE_UNKNOWN      = BIT(3),
 };
 
 struct video_info {

commit 7b4b7a8db439dca4342a0424b3d99d878a4e5a12
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:11:50 2016 +0800

    drm: bridge: analogix/dp: Fix the possible dead lock in bridge disable time
    
    It may caused a dead lock if we flush the hpd work in bridge disable time.
    
    The normal flow would like:
      IN --> DRM IOCTL
            1. Acquire crtc_ww_class_mutex (DRM IOCTL)
      IN --> analogix_dp_bridge
            2. Acquire hpd work lock (Flush hpd work)
            3. HPD work already in idle, no need to run the work function.
      OUT <-- analogix_dp_bridge
      OUT <-- DRM IOCTL
    
    The dead lock flow would like:
      IN --> DRM IOCTL
            1. Acquire crtc_ww_class_mutex (DRM IOCTL)
      IN --> analogix_dp_bridge
            2. Acquire hpd work lock (Flush hpd work)
      IN --> analogix_dp_hotplug
      IN --> drm_helper_hpd_irq_event
            3. Acquire mode_config lock (This lock already have been acquired in previous step 1)
    ** Dead Lock Now **
    
    It's wrong to flush the hpd work in bridge->disable time, I guess the
    original code just want to ensure the delay work must be finish before
    encoder disabled.
    
    The flush work in bridge disable time is try to ensure the HPD event
    won't be missed before display card disabled, actually we can take a
    fast respond way(interrupt thread) to update DRM HPD event to fix the
    delay update and possible dead lock.
    
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 48b4a8723d42..f09275d40f70 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -172,7 +172,6 @@ struct analogix_dp_device {
 
 	struct video_info	video_info;
 	struct link_train	link_train;
-	struct work_struct	hotplug_work;
 	struct phy		*phy;
 	int			dpms_mode;
 	int			hpd_gpio;
@@ -191,6 +190,8 @@ void analogix_dp_init_interrupt(struct analogix_dp_device *dp);
 void analogix_dp_reset(struct analogix_dp_device *dp);
 void analogix_dp_swreset(struct analogix_dp_device *dp);
 void analogix_dp_config_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp);
 enum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp);
 void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable);
 void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,

commit 398a39953493e859d22ac4bece0f4542a3797053
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:11:29 2016 +0800

    drm: bridge: analogix/dp: add edid modes parse in get_modes method
    
    Display Port monitor could support kinds of mode which indicate
    in monitor edid, not just one single display resolution which
    defined in panel or devivetree property display timing.
    
    Note: Gustavo Padovan try to remove the controller and phy
    power on function in bind time at bellow commit:
            drm/exynos: do not start enabling DP at bind() phase
    
    But for now driver need to read edid message in .get_modes()
    function, so controller must be inited in bind time, so we
    need to add controller init back.
    
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 22aff07c1995..48b4a8723d42 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -20,6 +20,28 @@
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
 
+/* I2C EDID Chip ID, Slave Address */
+#define I2C_EDID_DEVICE_ADDR			0x50
+#define I2C_E_EDID_DEVICE_ADDR			0x30
+
+#define EDID_BLOCK_LENGTH			0x80
+#define EDID_HEADER_PATTERN			0x00
+#define EDID_EXTENSION_FLAG			0x7e
+#define EDID_CHECKSUM				0x7f
+
+/* DP_MAX_LANE_COUNT */
+#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
+#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
+
+/* DP_LANE_COUNT_SET */
+#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
+
+/* DP_TRAINING_LANE0_SET */
+#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
+#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
+#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
+#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
+
 enum link_lane_count_type {
 	LANE_COUNT1 = 1,
 	LANE_COUNT2 = 2,
@@ -155,6 +177,7 @@ struct analogix_dp_device {
 	int			dpms_mode;
 	int			hpd_gpio;
 	bool                    force_hpd;
+	unsigned char           edid[EDID_BLOCK_LENGTH * 2];
 
 	struct analogix_dp_plat_data *plat_data;
 };
@@ -254,27 +277,4 @@ int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);
 void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);
 void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
-
-/* I2C EDID Chip ID, Slave Address */
-#define I2C_EDID_DEVICE_ADDR			0x50
-#define I2C_E_EDID_DEVICE_ADDR			0x30
-
-#define EDID_BLOCK_LENGTH			0x80
-#define EDID_HEADER_PATTERN			0x00
-#define EDID_EXTENSION_FLAG			0x7e
-#define EDID_CHECKSUM				0x7f
-
-/* DP_MAX_LANE_COUNT */
-#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
-#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
-
-/* DP_LANE_COUNT_SET */
-#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
-
-/* DP_TRAINING_LANE0_SET */
-#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
-#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
-#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
-#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
-
 #endif /* _ANALOGIX_DP_CORE_H */

commit 5cff007c58b7103a7d6bb203a74eb3eb416c10e0
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:11:15 2016 +0800

    drm: bridge: analogix/dp: try force hpd after plug in lookup failed
    
    Some edp screen do not have hpd signal, so we can't just return
    failed when hpd plug in detect failed.
    
    This is an hardware property, so we need add a devicetree property
    "analogix,need-force-hpd" to indicate this sutiation.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 02c0ecffa804..22aff07c1995 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -154,6 +154,7 @@ struct analogix_dp_device {
 	struct phy		*phy;
 	int			dpms_mode;
 	int			hpd_gpio;
+	bool                    force_hpd;
 
 	struct analogix_dp_plat_data *plat_data;
 };
@@ -174,6 +175,7 @@ void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
 				       bool enable);
 void analogix_dp_init_analog_func(struct analogix_dp_device *dp);
 void analogix_dp_init_hpd(struct analogix_dp_device *dp);
+void analogix_dp_force_hpd(struct analogix_dp_device *dp);
 enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp);
 void analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp);
 void analogix_dp_reset_aux(struct analogix_dp_device *dp);

commit 0d0abd894ead85d20d7febe603f570d4fdd8111a
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:11:05 2016 +0800

    drm: bridge: analogix/dp: add max link rate and lane count limit for RK3288
    
    There are some IP limit on rk3288 that only support 4 physical lanes
    of 2.7/1.6 Gbps/lane, so seprate them out by device_type flag.
    
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 123030f1ba52..02c0ecffa804 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -123,8 +123,8 @@ struct video_info {
 	enum color_coefficient ycbcr_coeff;
 	enum color_depth color_depth;
 
-	int link_rate;
-	enum link_lane_count_type lane_count;
+	int max_link_rate;
+	enum link_lane_count_type max_lane_count;
 };
 
 struct link_train {

commit 793ce4eb84ea2f2c3ebb97aab1ba8a4ce0561812
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:10:11 2016 +0800

    drm: bridge: analogix/dp: dynamic parse sync_pol & interlace & dynamic_range
    
    Both hsync/vsync polarity and interlace mode can be parsed from
    drm display mode, and dynamic_range and ycbcr_coeff can be judge
    by the video code.
    
    But presumably Exynos still relies on the DT properties, so take
    good use of mode_fixup() in to achieve the compatibility hacks.
    
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index afb0a530177d..123030f1ba52 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -148,7 +148,7 @@ struct analogix_dp_device {
 	unsigned int		irq;
 	void __iomem		*reg_base;
 
-	struct video_info	*video_info;
+	struct video_info	video_info;
 	struct link_train	link_train;
 	struct work_struct	hotplug_work;
 	struct phy		*phy;

commit 40fc7ce7db770e9e05032be5eefc183690afb5b8
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Mon Feb 15 19:10:04 2016 +0800

    drm: bridge: analogix/dp: remove duplicate configuration of link rate and link count
    
    link_rate and lane_count already configured in analogix_dp_set_link_train(),
    so we don't need to config those repeatly after training finished, just
    remove them out.
    
    Beside Display Port 1.2 already support 5.4Gbps link rate, the maximum sets
    would change from {1.62Gbps, 2.7Gbps} to {1.62Gbps, 2.7Gbps, 5.4Gbps}.
    
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index d4c4ae23e28e..afb0a530177d 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -20,11 +20,6 @@
 #define MAX_CR_LOOP 5
 #define MAX_EQ_LOOP 5
 
-enum link_rate_type {
-	LINK_RATE_1_62GBPS = 0x06,
-	LINK_RATE_2_70GBPS = 0x0a
-};
-
 enum link_lane_count_type {
 	LANE_COUNT1 = 1,
 	LANE_COUNT2 = 2,
@@ -128,7 +123,7 @@ struct video_info {
 	enum color_coefficient ycbcr_coeff;
 	enum color_depth color_depth;
 
-	enum link_rate_type link_rate;
+	int link_rate;
 	enum link_lane_count_type lane_count;
 };
 

commit bcbb7033acf9cea100fb9ea6cd9ff5a7a279d16a
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Tue Mar 29 09:57:19 2016 +0800

    drm: bridge: analogix/dp: fix some obvious code style
    
    Fix some obvious alignment problems, like alignment and line
    over 80 characters problems, make this easy to be maintained
    later.
    
    Acked-by: Jingoo Han <jingoohan1@gmail.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
index 0fff7451e3df..d4c4ae23e28e 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -187,50 +187,55 @@ int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp);
 void analogix_dp_enable_sw_function(struct analogix_dp_device *dp);
 int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp);
 int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
-				unsigned int reg_addr,
-				unsigned char data);
+				   unsigned int reg_addr,
+				   unsigned char data);
 int analogix_dp_read_byte_from_dpcd(struct analogix_dp_device *dp,
-				unsigned int reg_addr,
-				unsigned char *data);
+				    unsigned int reg_addr,
+				    unsigned char *data);
 int analogix_dp_write_bytes_to_dpcd(struct analogix_dp_device *dp,
-				unsigned int reg_addr,
-				unsigned int count,
-				unsigned char data[]);
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char data[]);
 int analogix_dp_read_bytes_from_dpcd(struct analogix_dp_device *dp,
-				unsigned int reg_addr,
-				unsigned int count,
-				unsigned char data[]);
+				     unsigned int reg_addr,
+				     unsigned int count,
+				     unsigned char data[]);
 int analogix_dp_select_i2c_device(struct analogix_dp_device *dp,
-				unsigned int device_addr,
-				unsigned int reg_addr);
+				  unsigned int device_addr,
+				  unsigned int reg_addr);
 int analogix_dp_read_byte_from_i2c(struct analogix_dp_device *dp,
-				unsigned int device_addr,
-				unsigned int reg_addr,
-				unsigned int *data);
+				   unsigned int device_addr,
+				   unsigned int reg_addr,
+				   unsigned int *data);
 int analogix_dp_read_bytes_from_i2c(struct analogix_dp_device *dp,
-				unsigned int device_addr,
-				unsigned int reg_addr,
-				unsigned int count,
-				unsigned char edid[]);
+				    unsigned int device_addr,
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char edid[]);
 void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype);
 void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype);
 void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count);
 void analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count);
-void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,
+				      bool enable);
 void analogix_dp_set_training_pattern(struct analogix_dp_device *dp,
-				enum pattern_set pattern);
-void analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp, u32 level);
-void analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp, u32 level);
-void analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp, u32 level);
-void analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp, u32 level);
+				      enum pattern_set pattern);
+void analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp,
+					u32 level);
+void analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp,
+					u32 level);
+void analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp,
+					u32 level);
+void analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp,
+					u32 level);
 void analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,
-				u32 training_lane);
+					 u32 training_lane);
 void analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,
-				u32 training_lane);
+					 u32 training_lane);
 void analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,
-				u32 training_lane);
+					 u32 training_lane);
 void analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,
-				u32 training_lane);
+					 u32 training_lane);
 u32 analogix_dp_get_lane0_link_training(struct analogix_dp_device *dp);
 u32 analogix_dp_get_lane1_link_training(struct analogix_dp_device *dp);
 u32 analogix_dp_get_lane2_link_training(struct analogix_dp_device *dp);
@@ -241,11 +246,12 @@ void analogix_dp_init_video(struct analogix_dp_device *dp);
 void analogix_dp_set_video_color_format(struct analogix_dp_device *dp);
 int analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp);
 void analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,
-			enum clock_recovery_m_value_type type,
-			u32 m_value,
-			u32 n_value);
+				 enum clock_recovery_m_value_type type,
+				 u32 m_value,
+				 u32 n_value);
 void analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type);
-void analogix_dp_enable_video_master(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_enable_video_master(struct analogix_dp_device *dp,
+				     bool enable);
 void analogix_dp_start_video(struct analogix_dp_device *dp);
 int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);
 void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);

commit 3424e3a4f844c0a62128feb388d04ed6b65f6b20
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Tue Mar 29 09:57:03 2016 +0800

    drm: bridge: analogix/dp: split exynos dp driver to bridge directory
    
    Split the dp core driver from exynos directory to bridge directory,
    and rename the core driver to analogix_dp_*, rename the platform
    code to exynos_dp.
    
    Beside the new analogix_dp driver would export six hooks.
    "analogix_dp_bind()" and "analogix_dp_unbind()"
    "analogix_dp_suspned()" and "analogix_dp_resume()"
    "analogix_dp_detect()" and "analogix_dp_get_modes()"
    
    The bind/unbind symbols is used for analogix platform driver to connect
    with analogix_dp core driver. And the detect/get_modes is used for analogix
    platform driver to init the connector.
    
    They reason why connector need register in helper driver is rockchip drm
    haven't implement the atomic API, but Exynos drm have implement it, so
    there would need two different connector helper functions, that's why we
    leave the connector register in helper driver.
    
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
new file mode 100644
index 000000000000..0fff7451e3df
--- /dev/null
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h
@@ -0,0 +1,277 @@
+/*
+ * Header file for Analogix DP (Display Port) core interface driver.
+ *
+ * Copyright (C) 2012 Samsung Electronics Co., Ltd.
+ * Author: Jingoo Han <jg1.han@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef _ANALOGIX_DP_CORE_H
+#define _ANALOGIX_DP_CORE_H
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_dp_helper.h>
+
+#define DP_TIMEOUT_LOOP_COUNT 100
+#define MAX_CR_LOOP 5
+#define MAX_EQ_LOOP 5
+
+enum link_rate_type {
+	LINK_RATE_1_62GBPS = 0x06,
+	LINK_RATE_2_70GBPS = 0x0a
+};
+
+enum link_lane_count_type {
+	LANE_COUNT1 = 1,
+	LANE_COUNT2 = 2,
+	LANE_COUNT4 = 4
+};
+
+enum link_training_state {
+	START,
+	CLOCK_RECOVERY,
+	EQUALIZER_TRAINING,
+	FINISHED,
+	FAILED
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum pattern_set {
+	PRBS7,
+	D10_2,
+	TRAINING_PTN1,
+	TRAINING_PTN2,
+	DP_NONE
+};
+
+enum color_space {
+	COLOR_RGB,
+	COLOR_YCBCR422,
+	COLOR_YCBCR444
+};
+
+enum color_depth {
+	COLOR_6,
+	COLOR_8,
+	COLOR_10,
+	COLOR_12
+};
+
+enum color_coefficient {
+	COLOR_YCBCR601,
+	COLOR_YCBCR709
+};
+
+enum dynamic_range {
+	VESA,
+	CEA
+};
+
+enum pll_status {
+	PLL_UNLOCKED,
+	PLL_LOCKED
+};
+
+enum clock_recovery_m_value_type {
+	CALCULATED_M,
+	REGISTER_M
+};
+
+enum video_timing_recognition_type {
+	VIDEO_TIMING_FROM_CAPTURE,
+	VIDEO_TIMING_FROM_REGISTER
+};
+
+enum analog_power_block {
+	AUX_BLOCK,
+	CH0_BLOCK,
+	CH1_BLOCK,
+	CH2_BLOCK,
+	CH3_BLOCK,
+	ANALOG_TOTAL,
+	POWER_ALL
+};
+
+enum dp_irq_type {
+	DP_IRQ_TYPE_HP_CABLE_IN,
+	DP_IRQ_TYPE_HP_CABLE_OUT,
+	DP_IRQ_TYPE_HP_CHANGE,
+	DP_IRQ_TYPE_UNKNOWN,
+};
+
+struct video_info {
+	char *name;
+
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+
+	enum color_space color_space;
+	enum dynamic_range dynamic_range;
+	enum color_coefficient ycbcr_coeff;
+	enum color_depth color_depth;
+
+	enum link_rate_type link_rate;
+	enum link_lane_count_type lane_count;
+};
+
+struct link_train {
+	int eq_loop;
+	int cr_loop[4];
+
+	u8 link_rate;
+	u8 lane_count;
+	u8 training_lane[4];
+
+	enum link_training_state lt_state;
+};
+
+struct analogix_dp_device {
+	struct drm_encoder	*encoder;
+	struct device		*dev;
+	struct drm_device	*drm_dev;
+	struct drm_connector	connector;
+	struct drm_bridge	*bridge;
+	struct clk		*clock;
+	unsigned int		irq;
+	void __iomem		*reg_base;
+
+	struct video_info	*video_info;
+	struct link_train	link_train;
+	struct work_struct	hotplug_work;
+	struct phy		*phy;
+	int			dpms_mode;
+	int			hpd_gpio;
+
+	struct analogix_dp_plat_data *plat_data;
+};
+
+/* analogix_dp_reg.c */
+void analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_stop_video(struct analogix_dp_device *dp);
+void analogix_dp_lane_swap(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_init_analog_param(struct analogix_dp_device *dp);
+void analogix_dp_init_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_reset(struct analogix_dp_device *dp);
+void analogix_dp_swreset(struct analogix_dp_device *dp);
+void analogix_dp_config_interrupt(struct analogix_dp_device *dp);
+enum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp);
+void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
+				       enum analog_power_block block,
+				       bool enable);
+void analogix_dp_init_analog_func(struct analogix_dp_device *dp);
+void analogix_dp_init_hpd(struct analogix_dp_device *dp);
+enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp);
+void analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp);
+void analogix_dp_reset_aux(struct analogix_dp_device *dp);
+void analogix_dp_init_aux(struct analogix_dp_device *dp);
+int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp);
+void analogix_dp_enable_sw_function(struct analogix_dp_device *dp);
+int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp);
+int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
+				unsigned int reg_addr,
+				unsigned char data);
+int analogix_dp_read_byte_from_dpcd(struct analogix_dp_device *dp,
+				unsigned int reg_addr,
+				unsigned char *data);
+int analogix_dp_write_bytes_to_dpcd(struct analogix_dp_device *dp,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char data[]);
+int analogix_dp_read_bytes_from_dpcd(struct analogix_dp_device *dp,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char data[]);
+int analogix_dp_select_i2c_device(struct analogix_dp_device *dp,
+				unsigned int device_addr,
+				unsigned int reg_addr);
+int analogix_dp_read_byte_from_i2c(struct analogix_dp_device *dp,
+				unsigned int device_addr,
+				unsigned int reg_addr,
+				unsigned int *data);
+int analogix_dp_read_bytes_from_i2c(struct analogix_dp_device *dp,
+				unsigned int device_addr,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char edid[]);
+void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype);
+void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype);
+void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count);
+void analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count);
+void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_set_training_pattern(struct analogix_dp_device *dp,
+				enum pattern_set pattern);
+void analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp, u32 level);
+void analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp, u32 level);
+void analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp, u32 level);
+void analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp, u32 level);
+void analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,
+				u32 training_lane);
+void analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,
+				u32 training_lane);
+void analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,
+				u32 training_lane);
+void analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,
+				u32 training_lane);
+u32 analogix_dp_get_lane0_link_training(struct analogix_dp_device *dp);
+u32 analogix_dp_get_lane1_link_training(struct analogix_dp_device *dp);
+u32 analogix_dp_get_lane2_link_training(struct analogix_dp_device *dp);
+u32 analogix_dp_get_lane3_link_training(struct analogix_dp_device *dp);
+void analogix_dp_reset_macro(struct analogix_dp_device *dp);
+void analogix_dp_init_video(struct analogix_dp_device *dp);
+
+void analogix_dp_set_video_color_format(struct analogix_dp_device *dp);
+int analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp);
+void analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,
+			enum clock_recovery_m_value_type type,
+			u32 m_value,
+			u32 n_value);
+void analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type);
+void analogix_dp_enable_video_master(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_start_video(struct analogix_dp_device *dp);
+int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);
+void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);
+void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
+void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
+
+/* I2C EDID Chip ID, Slave Address */
+#define I2C_EDID_DEVICE_ADDR			0x50
+#define I2C_E_EDID_DEVICE_ADDR			0x30
+
+#define EDID_BLOCK_LENGTH			0x80
+#define EDID_HEADER_PATTERN			0x00
+#define EDID_EXTENSION_FLAG			0x7e
+#define EDID_CHECKSUM				0x7f
+
+/* DP_MAX_LANE_COUNT */
+#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
+#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
+
+/* DP_LANE_COUNT_SET */
+#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
+
+/* DP_TRAINING_LANE0_SET */
+#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
+#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
+#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
+#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
+
+#endif /* _ANALOGIX_DP_CORE_H */
