commit 934bda59f286d0221f1a3ebab7f5156a996cc37d
Author: Daniel Axtens <dja@axtens.net>
Date:   Mon Jun 3 16:56:57 2019 +1000

    powerpc/pseries/hvconsole: Fix stack overread via udbg
    
    While developing KASAN for 64-bit book3s, I hit the following stack
    over-read.
    
    It occurs because the hypercall to put characters onto the terminal
    takes 2 longs (128 bits/16 bytes) of characters at a time, and so
    hvc_put_chars() would unconditionally copy 16 bytes from the argument
    buffer, regardless of supplied length. However, udbg_hvc_putc() can
    call hvc_put_chars() with a single-byte buffer, leading to the error.
    
      ==================================================================
      BUG: KASAN: stack-out-of-bounds in hvc_put_chars+0xdc/0x110
      Read of size 8 at addr c0000000023e7a90 by task swapper/0
    
      CPU: 0 PID: 0 Comm: swapper Not tainted 5.2.0-rc2-next-20190528-02824-g048a6ab4835b #113
      Call Trace:
        dump_stack+0x104/0x154 (unreliable)
        print_address_description+0xa0/0x30c
        __kasan_report+0x20c/0x224
        kasan_report+0x18/0x30
        __asan_report_load8_noabort+0x24/0x40
        hvc_put_chars+0xdc/0x110
        hvterm_raw_put_chars+0x9c/0x110
        udbg_hvc_putc+0x154/0x200
        udbg_write+0xf0/0x240
        console_unlock+0x868/0xd30
        register_console+0x970/0xe90
        register_early_udbg_console+0xf8/0x114
        setup_arch+0x108/0x790
        start_kernel+0x104/0x784
        start_here_common+0x1c/0x534
    
      Memory state around the buggy address:
       c0000000023e7980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
       c0000000023e7a00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1
      >c0000000023e7a80: f1 f1 01 f2 f2 f2 00 00 00 00 00 00 00 00 00 00
                               ^
       c0000000023e7b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
       c0000000023e7b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
      ==================================================================
    
    Document that a 16-byte buffer is requred, and provide it in udbg.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 6de6d4a1a221..7af54d6ed5b8 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -107,6 +107,14 @@ static int hvterm_raw_get_chars(uint32_t vtermno, char *buf, int count)
 	return got;
 }
 
+/**
+ * hvterm_raw_put_chars: send characters to firmware for given vterm adapter
+ * @vtermno: The virtual terminal number.
+ * @buf: The characters to send. Because of the underlying hypercall in
+ *       hvc_put_chars(), this buffer must be at least 16 bytes long, even if
+ *       you are sending fewer chars.
+ * @count: number of chars to send.
+ */
 static int hvterm_raw_put_chars(uint32_t vtermno, const char *buf, int count)
 {
 	struct hvterm_priv *pv = hvterm_privs[vtermno];
@@ -219,6 +227,7 @@ static const struct hv_ops hvterm_hvsi_ops = {
 static void udbg_hvc_putc(char c)
 {
 	int count = -1;
+	unsigned char bounce_buffer[16];
 
 	if (!hvterm_privs[0])
 		return;
@@ -229,7 +238,12 @@ static void udbg_hvc_putc(char c)
 	do {
 		switch(hvterm_privs[0]->proto) {
 		case HV_PROTOCOL_RAW:
-			count = hvterm_raw_put_chars(0, &c, 1);
+			/*
+			 * hvterm_raw_put_chars requires at least a 16-byte
+			 * buffer, so go via the bounce buffer
+			 */
+			bounce_buffer[0] = c;
+			count = hvterm_raw_put_chars(0, bounce_buffer, 1);
 			break;
 		case HV_PROTOCOL_HVSI:
 			count = hvterm_hvsi_put_chars(0, &c, 1);

commit 778ec49c14018730ec177bdd34b17e15e2e748b8
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:43 2018 -0600

    tty: Use of_node_name_{eq,prefix} for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    For hvc, the code can also be simplified by using of_stdout pointer
    instead of searching again for the stdout node.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-serial@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 59eaa620bf13..6de6d4a1a221 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -371,20 +371,11 @@ device_initcall(hvc_vio_init); /* after drivers/tty/hvc/hvc_console.c */
 void __init hvc_vio_init_early(void)
 {
 	const __be32 *termno;
-	const char *name;
 	const struct hv_ops *ops;
 
 	/* find the boot console from /chosen/stdout */
-	if (!of_stdout)
-		return;
-	name = of_get_property(of_stdout, "name", NULL);
-	if (!name) {
-		printk(KERN_WARNING "stdout node missing 'name' property!\n");
-		return;
-	}
-
 	/* Check if it's a virtual terminal */
-	if (strncmp(name, "vty", 3) != 0)
+	if (!of_node_name_prefix(of_stdout, "vty"))
 		return;
 	termno = of_get_property(of_stdout, "reg", NULL);
 	if (termno == NULL)

commit a9f96f014f36cc872d6d235787963ba90e101448
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:53 2017 +0100

    tty: hvc: Remove redundant license text
    
    Now that the SPDX tag is in all tty files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 287ccf682c84..59eaa620bf13 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -15,20 +15,6 @@
  * Additional Author(s):
  *  Ryan S. Arnold <rsa@us.ibm.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * TODO:
  *
  *   - handle error in sending hvsi protocol packets

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-KÃ¶nig" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas FÃ¤rber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "SÃ¶ren Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index a1d272ac82bb..287ccf682c84 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * vio driver interface to hvc_console.c
  *

commit bac65d9d87b383471d8d29128319508d71b74180
Merge: f92e3da18b7d 265601f034df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 10:15:40 2017 -0700

    Merge tag 'powerpc-4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Nothing really major this release, despite quite a lot of activity.
      Just lots of things all over the place.
    
      Some things of note include:
    
       - Access via perf to a new type of PMU (IMC) on Power9, which can
         count both core events as well as nest unit events (Memory
         controller etc).
    
       - Optimisations to the radix MMU TLB flushing, mostly to avoid
         unnecessary Page Walk Cache (PWC) flushes when the structure of the
         tree is not changing.
    
       - Reworks/cleanups of do_page_fault() to modernise it and bring it
         closer to other architectures where possible.
    
       - Rework of our page table walking so that THP updates only need to
         send IPIs to CPUs where the affected mm has run, rather than all
         CPUs.
    
       - The size of our vmalloc area is increased to 56T on 64-bit hash MMU
         systems. This avoids problems with the percpu allocator on systems
         with very sparse NUMA layouts.
    
       - STRICT_KERNEL_RWX support on PPC32.
    
       - A new sched domain topology for Power9, to capture the fact that
         pairs of cores may share an L2 cache.
    
       - Power9 support for VAS, which is a new mechanism for accessing
         coprocessors, and initial support for using it with the NX
         compression accelerator.
    
       - Major work on the instruction emulation support, adding support for
         many new instructions, and reworking it so it can be used to
         implement the emulation needed to fixup alignment faults.
    
       - Support for guests under PowerVM to use the Power9 XIVE interrupt
         controller.
    
      And probably that many things again that are almost as interesting,
      but I had to keep the list short. Plus the usual fixes and cleanups as
      always.
    
      Thanks to: Alexey Kardashevskiy, Alistair Popple, Andreas Schwab,
      Aneesh Kumar K.V, Anju T Sudhakar, Arvind Yadav, Balbir Singh,
      Benjamin Herrenschmidt, Bhumika Goyal, Breno Leitao, Bryant G. Ly,
      Christophe Leroy, CÃ©dric Le Goater, Dan Carpenter, Dou Liyang,
      Frederic Barrat, Gautham R. Shenoy, Geliang Tang, Geoff Levand, Hannes
      Reinecke, Haren Myneni, Ivan Mikhaylov, John Allen, Julia Lawall,
      LABBE Corentin, Laurentiu Tudor, Madhavan Srinivasan, Markus Elfring,
      Masahiro Yamada, Matt Brown, Michael Neuling, Murilo Opsfelder Araujo,
      Nathan Fontenot, Naveen N. Rao, Nicholas Piggin, Oliver O'Halloran,
      Paul Mackerras, Rashmica Gupta, Rob Herring, Rui Teng, Sam Bobroff,
      Santosh Sivaraj, Scott Wood, Shilpasri G Bhat, Sukadev Bhattiprolu,
      Suraj Jitindar Singh, Tobin C. Harding, Victor Aoqui"
    
    * tag 'powerpc-4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (321 commits)
      powerpc/xive: Fix section __init warning
      powerpc: Fix kernel crash in emulation of vector loads and stores
      powerpc/xive: improve debugging macros
      powerpc/xive: add XIVE Exploitation Mode to CAS
      powerpc/xive: introduce H_INT_ESB hcall
      powerpc/xive: add the HW IRQ number under xive_irq_data
      powerpc/xive: introduce xive_esb_write()
      powerpc/xive: rename xive_poke_esb() in xive_esb_read()
      powerpc/xive: guest exploitation of the XIVE interrupt controller
      powerpc/xive: introduce a common routine xive_queue_page_alloc()
      powerpc/sstep: Avoid used uninitialized error
      axonram: Return directly after a failed kzalloc() in axon_ram_probe()
      axonram: Improve a size determination in axon_ram_probe()
      axonram: Delete an error message for a failed memory allocation in axon_ram_probe()
      powerpc/powernv/npu: Move tlb flush before launching ATSD
      powerpc/macintosh: constify wf_sensor_ops structures
      powerpc/iommu: Use permission-specific DEVICE_ATTR variants
      powerpc/eeh: Delete an error out of memory message at init time
      powerpc/mm: Use seq_putc() in two functions
      macintosh: Convert to using %pOF instead of full_name
      ...

commit 7298bd1d7b07b55fe3fe9c84906f2eb065913701
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 17 19:04:22 2017 +0530

    tty: hvc_vio: constify vio_device_id
    
    vio_device_id are not supposed to change at runtime. All functions
    working with vio_device_id provided by <asm/vio.h> work with
    const vio_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 78b003be7f67..653f99271865 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -53,7 +53,7 @@
 
 static const char hvc_driver_name[] = "hvc_console";
 
-static struct vio_device_id hvc_driver_table[] = {
+static const struct vio_device_id hvc_driver_table[] = {
 	{"serial", "hvterm1"},
 #ifndef HVC_OLD_HVSI
 	{"serial", "hvterm-protocol"},

commit 9227f0431435c9d664771b112c230e75ca4f9b52
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Jul 25 00:10:15 2017 +1000

    powerpc/udbg: Reduce the footgun potential of EARLY_DEBUG_LPAR(_HVSI)
    
    For debugging very early boot problems we have CONFIG_PPC_EARLY_DEBUG,
    which allows configuring the kernel such that it unconditionally writes
    to a particular type of console, regardless of whether that console
    exists or not. This is useful sometimes when the kernel crashes before
    it can even determine what platform it's on, and therefore what consoles
    exist.
    
    However if you boot a kernel built this way on a different platform, it
    will generally crash because it writes to a console that doesn't exist.
    
    A particularly nasty instance of this is if you enable the hypervisor
    console early debug, and then boot that kernel on bare metal. The result
    is that the kernel calls "the hypervisor" very early in boot, but the
    kernel *is* the hypervisor, so we jump to the system call handler and
    start executing all sorts of code that isn't ready to be run. This may
    lead to a machine check or check stop depending on how lucky you are.
    
    Luckily there is an easy way to avoid this particular case. We simply
    read the MSR before installing the hooks, and if we see MSR_HV is set
    then we are the hypervisor and we definitely should not use the
    hypervisor console.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index b05dc5086627..6ffbdd8d50c5 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -442,6 +442,14 @@ void __init hvc_vio_init_early(void)
 #ifdef CONFIG_PPC_EARLY_DEBUG_LPAR
 void __init udbg_init_debug_lpar(void)
 {
+	/*
+	 * If we're running as a hypervisor then we definitely can't call the
+	 * hypervisor to print debug output (we *are* the hypervisor), so don't
+	 * register if we detect that MSR_HV=1.
+	 */
+	if (mfmsr() & MSR_HV)
+		return;
+
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = 0;
 	hvterm_priv0.proto = HV_PROTOCOL_RAW;
@@ -455,6 +463,10 @@ void __init udbg_init_debug_lpar(void)
 #ifdef CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI
 void __init udbg_init_debug_lpar_hvsi(void)
 {
+	/* See comment above in udbg_init_debug_lpar() */
+	if (mfmsr() & MSR_HV)
+		return;
+
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;
 	hvterm_priv0.proto = HV_PROTOCOL_HVSI;

commit a73ee8438c6da166589d975fc9c7c4e98ff5e330
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:34 2017 -0500

    tty: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-serial@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index b05dc5086627..78b003be7f67 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -312,12 +312,12 @@ static int hvc_vio_probe(struct vio_dev *vdev,
 		proto = HV_PROTOCOL_HVSI;
 		ops = &hvterm_hvsi_ops;
 	} else {
-		pr_err("hvc_vio: Unknown protocol for %s\n", vdev->dev.of_node->full_name);
+		pr_err("hvc_vio: Unknown protocol for %pOF\n", vdev->dev.of_node);
 		return -ENXIO;
 	}
 
-	pr_devel("hvc_vio_probe() device %s, using %s protocol\n",
-		 vdev->dev.of_node->full_name,
+	pr_devel("hvc_vio_probe() device %pOF, using %s protocol\n",
+		 vdev->dev.of_node,
 		 proto == HV_PROTOCOL_RAW ? "raw" : "hvsi");
 
 	/* Is it our boot one ? */

commit e3c5fc4d47ad2a52924d72e9945e00ec6dd2997b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Oct 18 18:21:14 2015 -0400

    drivers/tty: make hvc/hvc_vio.c explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    drivers/tty/hvc/Kconfig:config HVC_CONSOLE
    drivers/tty/hvc/Kconfig:        bool "pSeries Hypervisor Virtual Console support"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    We explicitly disallow a driver unbind, since that doesn't have a
    sensible use case anyway, and it allows us to drop the ".remove"
    code for non-modular drivers.
    
    We don't replace module.h with init.h since the file already has that.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index f575a9b5ede7..b05dc5086627 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -41,7 +41,6 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/console.h>
-#include <linux/module.h>
 
 #include <asm/hvconsole.h>
 #include <asm/vio.h>
@@ -61,7 +60,6 @@ static struct vio_device_id hvc_driver_table[] = {
 #endif
 	{ "", "" }
 };
-MODULE_DEVICE_TABLE(vio, hvc_driver_table);
 
 typedef enum hv_protocol {
 	HV_PROTOCOL_RAW,
@@ -363,26 +361,13 @@ static int hvc_vio_probe(struct vio_dev *vdev,
 	return 0;
 }
 
-static int hvc_vio_remove(struct vio_dev *vdev)
-{
-	struct hvc_struct *hp = dev_get_drvdata(&vdev->dev);
-	int rc, termno;
-
-	termno = hp->vtermno;
-	rc = hvc_remove(hp);
-	if (rc == 0) {
-		if (hvterm_privs[termno] != &hvterm_priv0)
-			kfree(hvterm_privs[termno]);
-		hvterm_privs[termno] = NULL;
-	}
-	return rc;
-}
-
 static struct vio_driver hvc_vio_driver = {
 	.id_table	= hvc_driver_table,
 	.probe		= hvc_vio_probe,
-	.remove		= hvc_vio_remove,
 	.name		= hvc_driver_name,
+	.driver = {
+		.suppress_bind_attrs	= true,
+	},
 };
 
 static int __init hvc_vio_init(void)
@@ -394,13 +379,7 @@ static int __init hvc_vio_init(void)
 
 	return rc;
 }
-module_init(hvc_vio_init); /* after drivers/char/hvc_console.c */
-
-static void __exit hvc_vio_exit(void)
-{
-	vio_unregister_driver(&hvc_vio_driver);
-}
-module_exit(hvc_vio_exit);
+device_initcall(hvc_vio_init); /* after drivers/tty/hvc/hvc_console.c */
 
 void __init hvc_vio_init_early(void)
 {

commit 3e47d1474c2b4099f0fadd12a6553fdb2e8feaae
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Sep 17 14:39:36 2014 +1000

    powerpc: Remove powerpc specific cmd_line
    
    There is no need for yet another copy of the command line, just
    use boot_command_line like everyone else.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 5618b5fc7500..f575a9b5ede7 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -452,7 +452,7 @@ void __init hvc_vio_init_early(void)
 		return;
 #endif
 	/* Check whether the user has requested a different console. */
-	if (!strstr(cmd_line, "console="))
+	if (!strstr(boot_command_line, "console="))
 		add_preferred_console("hvc", 0, NULL);
 	hvc_instantiate(0, 0, ops);
 }

commit a752ee56ad84bf9a35b8323af1ad22b03c1df2c4
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Mar 28 08:12:18 2014 -0700

    tty: Update hypervisor tty drivers to use core stdout parsing code.
    
    The evh_bytechan, hvc_opal and hvc_vio drivers all open code the parsing
    of the stdout node in the device tree. This patch simplifies the driver
    by removing the duplicated functionality.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index b594abfbf21e..5618b5fc7500 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -404,42 +404,35 @@ module_exit(hvc_vio_exit);
 
 void __init hvc_vio_init_early(void)
 {
-	struct device_node *stdout_node;
 	const __be32 *termno;
 	const char *name;
 	const struct hv_ops *ops;
 
 	/* find the boot console from /chosen/stdout */
-	if (!of_chosen)
+	if (!of_stdout)
 		return;
-	name = of_get_property(of_chosen, "linux,stdout-path", NULL);
-	if (name == NULL)
-		return;
-	stdout_node = of_find_node_by_path(name);
-	if (!stdout_node)
-		return;
-	name = of_get_property(stdout_node, "name", NULL);
+	name = of_get_property(of_stdout, "name", NULL);
 	if (!name) {
 		printk(KERN_WARNING "stdout node missing 'name' property!\n");
-		goto out;
+		return;
 	}
 
 	/* Check if it's a virtual terminal */
 	if (strncmp(name, "vty", 3) != 0)
-		goto out;
-	termno = of_get_property(stdout_node, "reg", NULL);
+		return;
+	termno = of_get_property(of_stdout, "reg", NULL);
 	if (termno == NULL)
-		goto out;
+		return;
 	hvterm_priv0.termno = of_read_number(termno, 1);
 	spin_lock_init(&hvterm_priv0.buf_lock);
 	hvterm_privs[0] = &hvterm_priv0;
 
 	/* Check the protocol */
-	if (of_device_is_compatible(stdout_node, "hvterm1")) {
+	if (of_device_is_compatible(of_stdout, "hvterm1")) {
 		hvterm_priv0.proto = HV_PROTOCOL_RAW;
 		ops = &hvterm_raw_ops;
 	}
-	else if (of_device_is_compatible(stdout_node, "hvterm-protocol")) {
+	else if (of_device_is_compatible(of_stdout, "hvterm-protocol")) {
 		hvterm_priv0.proto = HV_PROTOCOL_HVSI;
 		ops = &hvterm_hvsi_ops;
 		hvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
@@ -447,7 +440,7 @@ void __init hvc_vio_init_early(void)
 		/* HVSI, perform the handshake now */
 		hvsilib_establish(&hvterm_priv0.hvsi);
 	} else
-		goto out;
+		return;
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
@@ -456,14 +449,12 @@ void __init hvc_vio_init_early(void)
 	 * backend for HVSI, only do udbg
 	 */
 	if (hvterm_priv0.proto == HV_PROTOCOL_HVSI)
-		goto out;
+		return;
 #endif
 	/* Check whether the user has requested a different console. */
 	if (!strstr(cmd_line, "console="))
 		add_preferred_console("hvc", 0, NULL);
 	hvc_instantiate(0, 0, ops);
-out:
-	of_node_put(stdout_node);
 }
 
 /* call this from early_init() for a working debug console on

commit 1926d0aeecf0280c67bf7464b2d68fe4e92c566b
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Sep 1 17:24:16 2013 +0100

    hvc_vio: Do not override preferred console set by kernel parameter
    
    The original version of this was done by Bastian Blank, who wrote:
    
    > The problem is the following:
    > - Architecture specific code sets preferred console to something bogus.
    > - Command line handling tries to set preferred console but is overruled
    >   by the old setting.
    >
    > The udbg0 console is a boot console and independant.
    
    References: http://bugs.debian.org/492703
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index c791b18cdd08..b594abfbf21e 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -48,6 +48,7 @@
 #include <asm/prom.h>
 #include <asm/hvsi.h>
 #include <asm/udbg.h>
+#include <asm/machdep.h>
 
 #include "hvc_console.h"
 
@@ -457,7 +458,9 @@ void __init hvc_vio_init_early(void)
 	if (hvterm_priv0.proto == HV_PROTOCOL_HVSI)
 		goto out;
 #endif
-	add_preferred_console("hvc", 0, NULL);
+	/* Check whether the user has requested a different console. */
+	if (!strstr(cmd_line, "console="))
+		add_preferred_console("hvc", 0, NULL);
 	hvc_instantiate(0, 0, ops);
 out:
 	of_node_put(stdout_node);

commit 1502b480e2296359728e4b4e112faf5a5599ca32
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:39 2013 +1000

    powerpc: Make device tree accesses in HVC VIO console endian safe
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 0c629807610e..c791b18cdd08 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -404,7 +404,7 @@ module_exit(hvc_vio_exit);
 void __init hvc_vio_init_early(void)
 {
 	struct device_node *stdout_node;
-	const u32 *termno;
+	const __be32 *termno;
 	const char *name;
 	const struct hv_ops *ops;
 
@@ -429,7 +429,7 @@ void __init hvc_vio_init_early(void)
 	termno = of_get_property(stdout_node, "reg", NULL);
 	if (termno == NULL)
 		goto out;
-	hvterm_priv0.termno = *termno;
+	hvterm_priv0.termno = of_read_number(termno, 1);
 	spin_lock_init(&hvterm_priv0.buf_lock);
 	hvterm_privs[0] = &hvterm_priv0;
 

commit a2013a13e68354e0c8f3696b69701803e13fb737
Merge: dadfab487325 106f9d9337f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:00:02 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial branch from Jiri Kosina:
     "Usual stuff -- comment/printk typo fixes, documentation updates, dead
      code elimination."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      HOWTO: fix double words typo
      x86 mtrr: fix comment typo in mtrr_bp_init
      propagate name change to comments in kernel source
      doc: Update the name of profiling based on sysfs
      treewide: Fix typos in various drivers
      treewide: Fix typos in various Kconfig
      wireless: mwifiex: Fix typo in wireless/mwifiex driver
      messages: i2o: Fix typo in messages/i2o
      scripts/kernel-doc: check that non-void fcts describe their return value
      Kernel-doc: Convention: Use a "Return" section to describe return values
      radeon: Fix typo and copy/paste error in comments
      doc: Remove unnecessary declarations from Documentation/accounting/getdelays.c
      various: Fix spelling of "asynchronous" in comments.
      Fix misspellings of "whether" in comments.
      eisa: Fix spelling of "asynchronous".
      various: Fix spelling of "registered" in comments.
      doc: fix quite a few typos within Documentation
      target: iscsi: fix comment typos in target/iscsi drivers
      treewide: fix typo of "suport" in various comments and Kconfig
      treewide: fix typo of "suppport" in various comments
      ...

commit ae8d8a146725a966bd7c59c94f4d0016dcf7a04f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:18 2012 -0500

    tty: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: David Brown <davidb@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 282d143a6437..ed6f5f1f5a55 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -362,7 +362,7 @@ static int hvc_vio_probe(struct vio_dev *vdev,
 	return 0;
 }
 
-static int __devexit hvc_vio_remove(struct vio_dev *vdev)
+static int hvc_vio_remove(struct vio_dev *vdev)
 {
 	struct hvc_struct *hp = dev_get_drvdata(&vdev->dev);
 	int rc, termno;

commit de88b34042752c03771b779d1d985060909ab44a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:24:32 2012 -0500

    tty: remove use of __devinitdata
    
    CONFIG_HOTPLUG is going away as an option so __devinitdata is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 77bde6c2cfa0..282d143a6437 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -53,7 +53,7 @@
 
 static const char hvc_driver_name[] = "hvc_console";
 
-static struct vio_device_id hvc_driver_table[] __devinitdata = {
+static struct vio_device_id hvc_driver_table[] = {
 	{"serial", "hvterm1"},
 #ifndef HVC_OLD_HVSI
 	{"serial", "hvterm-protocol"},

commit 9671f09921d93e722a28ae9610d478e092ac5466
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:50 2012 -0500

    tty: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 070c0ee68642..77bde6c2cfa0 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -293,7 +293,7 @@ static int udbg_hvc_getc(void)
 	}
 }
 
-static int __devinit hvc_vio_probe(struct vio_dev *vdev,
+static int hvc_vio_probe(struct vio_dev *vdev,
 				   const struct vio_device_id *id)
 {
 	const struct hv_ops *ops;

commit 3bd7bf1f0fe14f591c089ae61bbfa9bd356f178a
Merge: f16f84937d76 e657e078d3df
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sun Oct 28 19:28:52 2012 +0100

    Merge branch 'master' into for-next
    
    Sync up with Linus' tree to be able to apply Cesar's patch
    against newer version of the code.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 46e99c4a1d57dc73e518466bb3a8da9e7094415e
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Oct 24 23:29:41 2012 +0900

    tty: Fix typo in tty drivers
    
    Correct spelling typo in debug messages within tty drivers.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index ee307799271a..56e97258e55a 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -250,7 +250,7 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 		proto = HV_PROTOCOL_HVSI;
 		ops = &hvterm_hvsi_ops;
 	} else {
-		pr_err("hvc_vio: Unkown protocol for %s\n", vdev->dev.of_node->full_name);
+		pr_err("hvc_vio: Unknown protocol for %s\n", vdev->dev.of_node->full_name);
 		return -ENXIO;
 	}
 

commit d1cfc0ce5d3196ccd88b9d868bb7cbcab61e0a31
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 23 21:47:38 2012 +0000

    hvc_vio: Improve registration of udbg backend
    
    The pseries hvterm driver only registers a udbg backend (for xmon and
    other low level debugging mechanisms) when hvc0 is recognized as the
    firmware console at boot time, not if it's detected later on, for
    example because the firmware is using a graphics card.
    
    This can make debugging challenging especially under X11, and there's
    really no good reason for that limitation, so let's hookup udbg
    whenever hvc0 is detected instead.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index ee307799271a..070c0ee68642 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -230,6 +230,69 @@ static const struct hv_ops hvterm_hvsi_ops = {
 	.tiocmset = hvterm_hvsi_tiocmset,
 };
 
+static void udbg_hvc_putc(char c)
+{
+	int count = -1;
+
+	if (!hvterm_privs[0])
+		return;
+
+	if (c == '\n')
+		udbg_hvc_putc('\r');
+
+	do {
+		switch(hvterm_privs[0]->proto) {
+		case HV_PROTOCOL_RAW:
+			count = hvterm_raw_put_chars(0, &c, 1);
+			break;
+		case HV_PROTOCOL_HVSI:
+			count = hvterm_hvsi_put_chars(0, &c, 1);
+			break;
+		}
+	} while(count == 0);
+}
+
+static int udbg_hvc_getc_poll(void)
+{
+	int rc = 0;
+	char c;
+
+	if (!hvterm_privs[0])
+		return -1;
+
+	switch(hvterm_privs[0]->proto) {
+	case HV_PROTOCOL_RAW:
+		rc = hvterm_raw_get_chars(0, &c, 1);
+		break;
+	case HV_PROTOCOL_HVSI:
+		rc = hvterm_hvsi_get_chars(0, &c, 1);
+		break;
+	}
+	if (!rc)
+		return -1;
+	return c;
+}
+
+static int udbg_hvc_getc(void)
+{
+	int ch;
+
+	if (!hvterm_privs[0])
+		return -1;
+
+	for (;;) {
+		ch = udbg_hvc_getc_poll();
+		if (ch == -1) {
+			/* This shouldn't be needed...but... */
+			volatile unsigned long delay;
+			for (delay=0; delay < 2000000; delay++)
+				;
+		} else {
+			return ch;
+		}
+	}
+}
+
 static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 				   const struct vio_device_id *id)
 {
@@ -289,6 +352,13 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 		return PTR_ERR(hp);
 	dev_set_drvdata(&vdev->dev, hp);
 
+	/* register udbg if it's not there already for console 0 */
+	if (hp->index == 0 && !udbg_putc) {
+		udbg_putc = udbg_hvc_putc;
+		udbg_getc = udbg_hvc_getc;
+		udbg_getc_poll = udbg_hvc_getc_poll;
+	}
+
 	return 0;
 }
 
@@ -331,59 +401,6 @@ static void __exit hvc_vio_exit(void)
 }
 module_exit(hvc_vio_exit);
 
-static void udbg_hvc_putc(char c)
-{
-	int count = -1;
-
-	if (c == '\n')
-		udbg_hvc_putc('\r');
-
-	do {
-		switch(hvterm_priv0.proto) {
-		case HV_PROTOCOL_RAW:
-			count = hvterm_raw_put_chars(0, &c, 1);
-			break;
-		case HV_PROTOCOL_HVSI:
-			count = hvterm_hvsi_put_chars(0, &c, 1);
-			break;
-		}
-	} while(count == 0);
-}
-
-static int udbg_hvc_getc_poll(void)
-{
-	int rc = 0;
-	char c;
-
-	switch(hvterm_priv0.proto) {
-	case HV_PROTOCOL_RAW:
-		rc = hvterm_raw_get_chars(0, &c, 1);
-		break;
-	case HV_PROTOCOL_HVSI:
-		rc = hvterm_hvsi_get_chars(0, &c, 1);
-		break;
-	}
-	if (!rc)
-		return -1;
-	return c;
-}
-
-static int udbg_hvc_getc(void)
-{
-	int ch;
-	for (;;) {
-		ch = udbg_hvc_getc_poll();
-		if (ch == -1) {
-			/* This shouldn't be needed...but... */
-			volatile unsigned long delay;
-			for (delay=0; delay < 2000000; delay++)
-				;
-		} else {
-			return ch;
-		}
-	}
-}
-
 void __init hvc_vio_init_early(void)
 {
 	struct device_node *stdout_node;

commit cb52d8970eee65bf2c47d9a91bd4f58b17f595f4
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Mar 26 19:06:30 2012 +0000

    powerpc+sparc/vio: Modernize driver registration
    
    This makes vio_register_driver() get the module owner & name at compile
    time like PCI drivers do, and adds a name pointer directly in struct
    vio_driver to avoid having to explicitly initialize the embedded
    struct device.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 3a0d53d6368f..ee307799271a 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -310,11 +310,8 @@ static int __devexit hvc_vio_remove(struct vio_dev *vdev)
 static struct vio_driver hvc_vio_driver = {
 	.id_table	= hvc_driver_table,
 	.probe		= hvc_vio_probe,
-	.remove		= __devexit_p(hvc_vio_remove),
-	.driver		= {
-		.name	= hvc_driver_name,
-		.owner	= THIS_MODULE,
-	}
+	.remove		= hvc_vio_remove,
+	.name		= hvc_driver_name,
 };
 
 static int __init hvc_vio_init(void)

commit ec86b45af464d2d3c00d1125b220d6c3b6ca93d8
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 15 18:16:54 2012 +0000

    tty/hvc_vio: FW_FEATURE_ISERIES is no longer selectable
    
    so remove the code that tests for it.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index fc3c3ad6c072..3a0d53d6368f 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -46,7 +46,6 @@
 #include <asm/hvconsole.h>
 #include <asm/vio.h>
 #include <asm/prom.h>
-#include <asm/firmware.h>
 #include <asm/hvsi.h>
 #include <asm/udbg.h>
 
@@ -322,9 +321,6 @@ static int __init hvc_vio_init(void)
 {
 	int rc;
 
-	if (firmware_has_feature(FW_FEATURE_ISERIES))
-		return -EIO;
-
 	/* Register as a vio device to receive callbacks */
 	rc = vio_register_driver(&hvc_vio_driver);
 

commit 578b9ce0095ff3dd2c3b94508407c3be8fcce68d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 16:14:23 2011 -0400

    tty: Add module.h to drivers/tty users who just expect it there.
    
    We are cleaning up the issue that means module.h is omnipresent.
    These tty users are the people who implictly are relying on that.
    Fix up the real users to call out the include that they really need.
    
    In the case of jsm_driver.c file, it had moduleparam.h but that
    isn't enough and it needs the full module.h
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 130aace67f31..fc3c3ad6c072 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -41,6 +41,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/console.h>
+#include <linux/module.h>
 
 #include <asm/hvconsole.h>
 #include <asm/vio.h>

commit f7723f0eaf53d51ee54374116b25ac33e0be8542
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Jul 20 18:01:48 2011 +1000

    powerpc/pseries: Fix hvc_vio.c build due to recent changes
    
    For some reason I didn't notice the failure in my test builds,
    probably lacking caffeine or something...
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index ae659a4596b0..130aace67f31 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -461,7 +461,7 @@ void __init udbg_init_debug_lpar(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = 0;
 	hvterm_priv0.proto = HV_PROTOCOL_RAW;
-	spin_lock_init(&hvterm_priv0.buf_lock)
+	spin_lock_init(&hvterm_priv0.buf_lock);
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
@@ -474,7 +474,7 @@ void __init udbg_init_debug_lpar_hvsi(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;
 	hvterm_priv0.proto = HV_PROTOCOL_HVSI;
-	spin_lock_init(&hvterm_priv0.buf_lock)
+	spin_lock_init(&hvterm_priv0.buf_lock);
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;

commit 19df9abdd30a0448e5940c6aa3527096bb69aca7
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Jul 12 19:19:57 2011 +0000

    powerpc/pseries: Fix hvterm_raw_get_chars to accept < 16 chars, fixing xmon
    
    commit 4d2bb3f50036 (powerpc/pseries: Re-implement HVSI as part of
    hvc_vio) changed udbg_getc to be based on hvterm_raw_get_chars.
    Unfortunately hvterm_raw_get_chars returns -EAGAIN if you ask
    for anything less than 16 characters. As a result xmon no longer
    accepts input and prints a stream of junk to the screen.
    
    The recent change highlights a problem that xmon on pseries VIO
    has had all along, that it can drop input characters. The issue
    is the hypervisor call does not take a count argument and can
    return up to 16 characters.
    
    This patch adds a per vterm buffer that we copy input data into
    and give it out as requested.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 710c06ca70f4..ae659a4596b0 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -71,41 +71,53 @@ struct hvterm_priv {
 	u32			termno;	/* HV term number */
 	hv_protocol_t		proto;	/* Raw data or HVSI packets */
 	struct hvsi_priv	hvsi;	/* HVSI specific data */
+	spinlock_t		buf_lock;
+	char			buf[SIZE_VIO_GET_CHARS];
+	int			left;
+	int			offset;
 };
 static struct hvterm_priv *hvterm_privs[MAX_NR_HVC_CONSOLES];
-
 /* For early boot console */
 static struct hvterm_priv hvterm_priv0;
 
 static int hvterm_raw_get_chars(uint32_t vtermno, char *buf, int count)
 {
 	struct hvterm_priv *pv = hvterm_privs[vtermno];
-	unsigned long got, i;
+	unsigned long i;
+	unsigned long flags;
+	int got;
 
 	if (WARN_ON(!pv))
 		return 0;
 
-	/*
-	 * Vio firmware will read up to SIZE_VIO_GET_CHARS at its own discretion
-	 * so we play safe and avoid the situation where got > count which could
-	 * overload the flip buffer.
-	 */
-	if (count < SIZE_VIO_GET_CHARS)
-		return -EAGAIN;
-
-	got = hvc_get_chars(pv->termno, buf, count);
-
-	/*
-	 * Work around a HV bug where it gives us a null
-	 * after every \r.  -- paulus
-	 */
-	for (i = 1; i < got; ++i) {
-		if (buf[i] == 0 && buf[i-1] == '\r') {
-			--got;
-			if (i < got)
-				memmove(&buf[i], &buf[i+1], got - i);
+	spin_lock_irqsave(&pv->buf_lock, flags);
+
+	if (pv->left == 0) {
+		pv->offset = 0;
+		pv->left = hvc_get_chars(pv->termno, pv->buf, count);
+
+		/*
+		 * Work around a HV bug where it gives us a null
+		 * after every \r.  -- paulus
+		 */
+		for (i = 1; i < pv->left; ++i) {
+			if (pv->buf[i] == 0 && pv->buf[i-1] == '\r') {
+				--pv->left;
+				if (i < pv->left) {
+					memmove(&pv->buf[i], &pv->buf[i+1],
+						pv->left - i);
+				}
+			}
 		}
 	}
+
+	got = min(count, pv->left);
+	memcpy(buf, &pv->buf[pv->offset], got);
+	pv->offset += got;
+	pv->left -= got;
+
+	spin_unlock_irqrestore(&pv->buf_lock, flags);
+
 	return got;
 }
 
@@ -266,6 +278,7 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 			return -ENOMEM;
 		pv->termno = vdev->unit_address;
 		pv->proto = proto;
+		spin_lock_init(&pv->buf_lock);
 		hvterm_privs[termno] = pv;
 		hvsilib_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,
 			     pv->termno, 0);
@@ -406,6 +419,7 @@ void __init hvc_vio_init_early(void)
 	if (termno == NULL)
 		goto out;
 	hvterm_priv0.termno = *termno;
+	spin_lock_init(&hvterm_priv0.buf_lock);
 	hvterm_privs[0] = &hvterm_priv0;
 
 	/* Check the protocol */
@@ -447,6 +461,7 @@ void __init udbg_init_debug_lpar(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = 0;
 	hvterm_priv0.proto = HV_PROTOCOL_RAW;
+	spin_lock_init(&hvterm_priv0.buf_lock)
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
@@ -459,6 +474,7 @@ void __init udbg_init_debug_lpar_hvsi(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;
 	hvterm_priv0.proto = HV_PROTOCOL_HVSI;
+	spin_lock_init(&hvterm_priv0.buf_lock)
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;

commit 87fa35dd881fd61a2a8166892366f2c22c34a1fa
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jul 1 13:10:21 2011 +1000

    powerpc/hvsi: Fix conflict with old HVSI driver
    
    A mix of think & mismerge on my side caused a problem where both the
    new hvsi_lib and the old hvsi driver gets compiled and try to define
    symbols with the same name.
    
    This fixes it by renaming the hvsi_lib exported symbols.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index ade73fae816a..710c06ca70f4 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -134,7 +134,7 @@ static int hvterm_hvsi_get_chars(uint32_t vtermno, char *buf, int count)
 	if (WARN_ON(!pv))
 		return 0;
 
-	return hvsi_get_chars(&pv->hvsi, buf, count);
+	return hvsilib_get_chars(&pv->hvsi, buf, count);
 }
 
 static int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)
@@ -144,7 +144,7 @@ static int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)
 	if (WARN_ON(!pv))
 		return 0;
 
-	return hvsi_put_chars(&pv->hvsi, buf, count);
+	return hvsilib_put_chars(&pv->hvsi, buf, count);
 }
 
 static int hvterm_hvsi_open(struct hvc_struct *hp, int data)
@@ -158,7 +158,7 @@ static int hvterm_hvsi_open(struct hvc_struct *hp, int data)
 	if (rc)
 		return rc;
 
-	return hvsi_open(&pv->hvsi, hp);
+	return hvsilib_open(&pv->hvsi, hp);
 }
 
 static void hvterm_hvsi_close(struct hvc_struct *hp, int data)
@@ -167,7 +167,7 @@ static void hvterm_hvsi_close(struct hvc_struct *hp, int data)
 
 	pr_devel("HVSI@%x: do close !\n", pv->termno);
 
-	hvsi_close(&pv->hvsi, hp);
+	hvsilib_close(&pv->hvsi, hp);
 
 	notifier_del_irq(hp, data);
 }
@@ -178,7 +178,7 @@ void hvterm_hvsi_hangup(struct hvc_struct *hp, int data)
 
 	pr_devel("HVSI@%x: do hangup !\n", pv->termno);
 
-	hvsi_close(&pv->hvsi, hp);
+	hvsilib_close(&pv->hvsi, hp);
 
 	notifier_hangup_irq(hp, data);
 }
@@ -201,9 +201,9 @@ static int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,
 		 pv->termno, set, clear);
 
 	if (set & TIOCM_DTR)
-		hvsi_write_mctrl(&pv->hvsi, 1);
+		hvsilib_write_mctrl(&pv->hvsi, 1);
 	else if (clear & TIOCM_DTR)
-		hvsi_write_mctrl(&pv->hvsi, 0);
+		hvsilib_write_mctrl(&pv->hvsi, 0);
 
 	return 0;
 }
@@ -267,8 +267,8 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 		pv->termno = vdev->unit_address;
 		pv->proto = proto;
 		hvterm_privs[termno] = pv;
-		hvsi_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,
-			  pv->termno, 0);
+		hvsilib_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,
+			     pv->termno, 0);
 	}
 
 	hp = hvc_alloc(termno, vdev->irq, ops, MAX_VIO_PUT_CHARS);
@@ -416,10 +416,10 @@ void __init hvc_vio_init_early(void)
 	else if (of_device_is_compatible(stdout_node, "hvterm-protocol")) {
 		hvterm_priv0.proto = HV_PROTOCOL_HVSI;
 		ops = &hvterm_hvsi_ops;
-		hvsi_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
-			  hvterm_priv0.termno, 1);
+		hvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
+			     hvterm_priv0.termno, 1);
 		/* HVSI, perform the handshake now */
-		hvsi_establish(&hvterm_priv0.hvsi);
+		hvsilib_establish(&hvterm_priv0.hvsi);
 	} else
 		goto out;
 	udbg_putc = udbg_hvc_putc;
@@ -462,8 +462,8 @@ void __init udbg_init_debug_lpar_hvsi(void)
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
-	hvsi_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
-		  hvterm_priv0.termno, 1);
-	hvsi_establish(&hvterm_priv0.hvsi);
+	hvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
+		     hvterm_priv0.termno, 1);
+	hvsilib_establish(&hvterm_priv0.hvsi);
 }
 #endif /* CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI */

commit 17bdc6c0e979ae61879806e4dd93ec3b169d0931
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Apr 29 16:44:24 2011 +1000

    powerpc/pseries: Move hvsi support into a library
    
    This will allow a different backend to share it
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index d4e0850e8051..ade73fae816a 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -67,22 +67,10 @@ typedef enum hv_protocol {
 	HV_PROTOCOL_HVSI
 } hv_protocol_t;
 
-#define HV_INBUF_SIZE		255
-
 struct hvterm_priv {
-	u32		termno;		/* HV term number */
-	hv_protocol_t	proto;		/* Raw data or HVSI packets */
-	unsigned int	inbuf_len;	/* Data in input buffer */
-	unsigned char	inbuf[HV_INBUF_SIZE];
-	unsigned int	inbuf_cur;	/* Cursor in input buffer */
-	unsigned int	inbuf_pktlen;	/* HVSI packet lenght from cursor */
-	atomic_t	seqno;		/* HVSI packet sequence number */
-	unsigned int	opened:1;	/* HVSI driver opened */
-	unsigned int	established:1;	/* HVSI protocol established */
-	unsigned int 	is_console:1;	/* Used as a kernel console device */
-	unsigned int	mctrl_update:1;	/* HVSI modem control updated */
-	unsigned short	mctrl;		/* HVSI modem control */
-	struct tty_struct *tty;		/* TTY structure */
+	u32			termno;	/* HV term number */
+	hv_protocol_t		proto;	/* Raw data or HVSI packets */
+	struct hvsi_priv	hvsi;	/* HVSI specific data */
 };
 static struct hvterm_priv *hvterm_privs[MAX_NR_HVC_CONSOLES];
 
@@ -139,348 +127,24 @@ static const struct hv_ops hvterm_raw_ops = {
 	.notifier_hangup = notifier_hangup_irq,
 };
 
-static int hvterm_hvsi_send_packet(struct hvterm_priv *pv, struct hvsi_header *packet)
-{
-	packet->seqno = atomic_inc_return(&pv->seqno);
-
-	/* Assumes that always succeeds, works in practice */
-	return hvc_put_chars(pv->termno, (char *)packet, packet->len);
-}
-
-static void hvterm_hvsi_start_handshake(struct hvterm_priv *pv)
-{
-	struct hvsi_query q;
-
-	/* Reset state */
-	pv->established = 0;
-	atomic_set(&pv->seqno, 0);
-
-	pr_devel("HVSI@%x: Handshaking started\n", pv->termno);
-
-	/* Send version query */
-	q.hdr.type = VS_QUERY_PACKET_HEADER;
-	q.hdr.len = sizeof(struct hvsi_query);
-	q.verb = VSV_SEND_VERSION_NUMBER;
-	hvterm_hvsi_send_packet(pv, &q.hdr);
-}
-
-static int hvterm_hvsi_send_close(struct hvterm_priv *pv)
-{
-	struct hvsi_control ctrl;
-
-	pv->established = 0;
-
-	ctrl.hdr.type = VS_CONTROL_PACKET_HEADER;
-	ctrl.hdr.len = sizeof(struct hvsi_control);
-	ctrl.verb = VSV_CLOSE_PROTOCOL;
-	return hvterm_hvsi_send_packet(pv, &ctrl.hdr);
-}
-
-static void hvterm_cd_change(struct hvterm_priv *pv, int cd)
-{
-	if (cd)
-		pv->mctrl |= TIOCM_CD;
-	else {
-		pv->mctrl &= ~TIOCM_CD;
-
-		/* We copy the existing hvsi driver semantics
-		 * here which are to trigger a hangup when
-		 * we get a carrier loss.
-		 * Closing our connection to the server will
-		 * do just that.
-		 */
-		if (!pv->is_console && pv->opened) {
-			pr_devel("HVSI@%x Carrier lost, hanging up !\n",
-				 pv->termno);
-			hvterm_hvsi_send_close(pv);
-		}
-	}
-}
-
-static void hvterm_hvsi_got_control(struct hvterm_priv *pv)
-{
-	struct hvsi_control *pkt = (struct hvsi_control *)pv->inbuf;
-
-	switch (pkt->verb) {
-	case VSV_CLOSE_PROTOCOL:
-		/* We restart the handshaking */
-		hvterm_hvsi_start_handshake(pv);
-		break;
-	case VSV_MODEM_CTL_UPDATE:
-		/* Transition of carrier detect */
-		hvterm_cd_change(pv, pkt->word & HVSI_TSCD);
-		break;
-	}
-}
-
-static void hvterm_hvsi_got_query(struct hvterm_priv *pv)
-{
-	struct hvsi_query *pkt = (struct hvsi_query *)pv->inbuf;
-	struct hvsi_query_response r;
-
-	/* We only handle version queries */
-	if (pkt->verb != VSV_SEND_VERSION_NUMBER)
-		return;
-
-	pr_devel("HVSI@%x: Got version query, sending response...\n",
-		 pv->termno);
-
-	/* Send version response */
-	r.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;
-	r.hdr.len = sizeof(struct hvsi_query_response);
-	r.verb = VSV_SEND_VERSION_NUMBER;
-	r.u.version = HVSI_VERSION;
-	r.query_seqno = pkt->hdr.seqno;
-	hvterm_hvsi_send_packet(pv, &r.hdr);
-
-	/* Assume protocol is open now */
-	pv->established = 1;
-}
-
-static void hvterm_hvsi_got_response(struct hvterm_priv *pv)
-{
-	struct hvsi_query_response *r = (struct hvsi_query_response *)pv->inbuf;
-
-	switch(r->verb) {
-	case VSV_SEND_MODEM_CTL_STATUS:
-		hvterm_cd_change(pv, r->u.mctrl_word & HVSI_TSCD);
-		pv->mctrl_update = 1;
-		break;
-	}
-}
-
-static int hvterm_hvsi_check_packet(struct hvterm_priv *pv)
-{
-	u8 len, type;
-
-	/* Check header validity. If it's invalid, we ditch
-	 * the whole buffer and hope we eventually resync
-	 */
-	if (pv->inbuf[0] < 0xfc) {
-		pv->inbuf_len = pv->inbuf_pktlen = 0;
-		return 0;
-	}
-	type = pv->inbuf[0];
-	len = pv->inbuf[1];
-
-	/* Packet incomplete ? */
-	if (pv->inbuf_len < len)
-		return 0;
-
-	pr_devel("HVSI@%x: Got packet type %x len %d bytes:\n",
-		 pv->termno, type, len);
-
-	/* We have a packet, yay ! Handle it */
-	switch(type) {
-	case VS_DATA_PACKET_HEADER:
-		pv->inbuf_pktlen = len - 4;
-		pv->inbuf_cur = 4;
-		return 1;
-	case VS_CONTROL_PACKET_HEADER:
-		hvterm_hvsi_got_control(pv);
-		break;
-	case VS_QUERY_PACKET_HEADER:
-		hvterm_hvsi_got_query(pv);
-		break;
-	case VS_QUERY_RESPONSE_PACKET_HEADER:
-		hvterm_hvsi_got_response(pv);
-		break;
-	}
-
-	/* Swallow packet and retry */
-	pv->inbuf_len -= len;
-	memmove(pv->inbuf, &pv->inbuf[len], pv->inbuf_len);
-	return 1;
-}
-
-static int hvterm_hvsi_get_packet(struct hvterm_priv *pv)
-{
-	/* If we have room in the buffer, ask HV for more */
-	if (pv->inbuf_len < HV_INBUF_SIZE)
-		pv->inbuf_len += hvc_get_chars(pv->termno,
-					       &pv->inbuf[pv->inbuf_len],
-					       HV_INBUF_SIZE - pv->inbuf_len);
-	/*
-	 * If we have at least 4 bytes in the buffer, check for
-	 * a full packet and retry
-	 */
-	if (pv->inbuf_len >= 4)
-		return hvterm_hvsi_check_packet(pv);
-	return 0;
-}
-
 static int hvterm_hvsi_get_chars(uint32_t vtermno, char *buf, int count)
 {
 	struct hvterm_priv *pv = hvterm_privs[vtermno];
-	unsigned int tries, read = 0;
 
 	if (WARN_ON(!pv))
 		return 0;
 
-	/* If we aren't open, dont do anything in order to avoid races
-	 * with connection establishment. The hvc core will call this
-	 * before we have returned from notifier_add(), and we need to
-	 * avoid multiple users playing with the receive buffer
-	 */
-	if (!pv->opened)
-		return 0;
-
-	/* We try twice, once with what data we have and once more
-	 * after we try to fetch some more from the hypervisor
-	 */
-	for (tries = 1; count && tries < 2; tries++) {
-		/* Consume existing data packet */
-		if (pv->inbuf_pktlen) {
-			unsigned int l = min(count, (int)pv->inbuf_pktlen);
-			memcpy(&buf[read], &pv->inbuf[pv->inbuf_cur], l);
-			pv->inbuf_cur += l;
-			pv->inbuf_pktlen -= l;
-			count -= l;
-			read += l;
-		}
-		if (count == 0)
-			break;
-
-		/* Data packet fully consumed, move down remaning data */
-		if (pv->inbuf_cur) {
-			pv->inbuf_len -= pv->inbuf_cur;
-			memmove(pv->inbuf, &pv->inbuf[pv->inbuf_cur], pv->inbuf_len);
-			pv->inbuf_cur = 0;
-		}
-
-		/* Try to get another packet */
-		if (hvterm_hvsi_get_packet(pv))
-			tries--;
-	}
-	if (!pv->established) {
-		pr_devel("HVSI@%x: returning -EPIPE\n", pv->termno);
-		return -EPIPE;
-	}
-	return read;
+	return hvsi_get_chars(&pv->hvsi, buf, count);
 }
 
 static int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)
 {
 	struct hvterm_priv *pv = hvterm_privs[vtermno];
-	struct hvsi_data dp;
-	int rc, adjcount = min(count, HVSI_MAX_OUTGOING_DATA);
 
 	if (WARN_ON(!pv))
 		return 0;
 
-	dp.hdr.type = VS_DATA_PACKET_HEADER;
-	dp.hdr.len = adjcount + sizeof(struct hvsi_header);
-	memcpy(dp.data, buf, adjcount);
-	rc = hvterm_hvsi_send_packet(pv, &dp.hdr);
-	if (rc <= 0)
-		return rc;
-	return adjcount;
-}
-
-static void maybe_msleep(unsigned long ms)
-{
-	/* During early boot, IRQs are disabled, use mdelay */
-	if (irqs_disabled())
-		mdelay(ms);
-	else
-		msleep(ms);
-}
-
-static int hvterm_hvsi_read_mctrl(struct hvterm_priv *pv)
-{
-	struct hvsi_query q;
-	int rc, timeout;
-
-	pr_devel("HVSI@%x: Querying modem control status...\n",
-		 pv->termno);
-
-	pv->mctrl_update = 0;
-	q.hdr.type = VS_QUERY_PACKET_HEADER;
-	q.hdr.len = sizeof(struct hvsi_query);
-	q.hdr.seqno = atomic_inc_return(&pv->seqno);
-	q.verb = VSV_SEND_MODEM_CTL_STATUS;
-	rc = hvterm_hvsi_send_packet(pv, &q.hdr);
-	if (rc <= 0) {
-		pr_devel("HVSI@%x: Error %d...\n", pv->termno, rc);
-		return rc;
-	}
-
-	/* Try for up to 1s */
-	for (timeout = 0; timeout < 1000; timeout++) {
-		if (!pv->established)
-			return -ENXIO;
-		if (pv->mctrl_update)
-			return 0;
-		if (!hvterm_hvsi_get_packet(pv))
-			maybe_msleep(1);
-	}
-	return -EIO;
-}
-
-static int hvterm_hvsi_write_mctrl(struct hvterm_priv *pv, int dtr)
-{
-	struct hvsi_control ctrl;
-
-	pr_devel("HVSI@%x: %s DTR...\n", pv->termno,
-		 dtr ? "Setting" : "Clearing");
-
-	ctrl.hdr.type = VS_CONTROL_PACKET_HEADER,
-	ctrl.hdr.len = sizeof(struct hvsi_control);
-	ctrl.verb = VSV_SET_MODEM_CTL;
-	ctrl.mask = HVSI_TSDTR;
-	ctrl.word = dtr ? HVSI_TSDTR : 0;
-	if (dtr)
-		pv->mctrl |= TIOCM_DTR;
-	else
-		pv->mctrl &= ~TIOCM_DTR;
-	return hvterm_hvsi_send_packet(pv, &ctrl.hdr);
-}
-
-static void hvterm_hvsi_establish(struct hvterm_priv *pv)
-{
-	int timeout;
-
-	/* Try for up to 10ms, there can be a packet to
-	 * start the process waiting for us...
-	 */
-	for (timeout = 0; timeout < 10; timeout++) {
-		if (pv->established)
-			goto established;
-		if (!hvterm_hvsi_get_packet(pv))
-			maybe_msleep(1);
-	}
-
-	/* Failed, send a close connection packet just
-	 * in case
-	 */
-	hvterm_hvsi_send_close(pv);
-
-	/* Then restart handshake */
-	hvterm_hvsi_start_handshake(pv);
-
-	/* Try for up to 100ms */
-	for (timeout = 0; timeout < 100; timeout++) {
-		if (pv->established)
-			goto established;
-		if (!hvterm_hvsi_get_packet(pv))
-			maybe_msleep(1);
-	}
-
-	if (!pv->established) {
-		pr_devel("HVSI@%x: Timeout handshaking, giving up !\n",
-			 pv->termno);
-		return;
-	}
- established:
-	/* Query modem control lines */
-	hvterm_hvsi_read_mctrl(pv);
-
-	/* Set our own DTR */
-	hvterm_hvsi_write_mctrl(pv, 1);
-
-	/* Set the opened flag so reads are allowed */
-	wmb();
-	pv->opened = 1;
+	return hvsi_put_chars(&pv->hvsi, buf, count);
 }
 
 static int hvterm_hvsi_open(struct hvc_struct *hp, int data)
@@ -494,46 +158,16 @@ static int hvterm_hvsi_open(struct hvc_struct *hp, int data)
 	if (rc)
 		return rc;
 
-	/* Keep track of the tty data structure */
-	pv->tty = tty_kref_get(hp->tty);
-
-	hvterm_hvsi_establish(pv);
-	return 0;
-}
-
-static void hvterm_hvsi_shutdown(struct hvc_struct *hp, struct hvterm_priv *pv)
-{
-	unsigned long flags;
-
-	if (!pv->is_console) {
-		pr_devel("HVSI@%x: Not a console, tearing down\n",
-			 pv->termno);
-
-		/* Clear opened, synchronize with khvcd */
-		spin_lock_irqsave(&hp->lock, flags);
-		pv->opened = 0;
-		spin_unlock_irqrestore(&hp->lock, flags);
-
-		/* Clear our own DTR */
-		if (!pv->tty || (pv->tty->termios->c_cflag & HUPCL))
-			hvterm_hvsi_write_mctrl(pv, 0);
-
-		/* Tear down the connection */
-		hvterm_hvsi_send_close(pv);
-	}
-
-	if (pv->tty)
-		tty_kref_put(pv->tty);
-	pv->tty = NULL;
+	return hvsi_open(&pv->hvsi, hp);
 }
 
 static void hvterm_hvsi_close(struct hvc_struct *hp, int data)
 {
 	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
 
-	pr_devel("HVSI@%x: close !\n", pv->termno);
+	pr_devel("HVSI@%x: do close !\n", pv->termno);
 
-	hvterm_hvsi_shutdown(hp, pv);
+	hvsi_close(&pv->hvsi, hp);
 
 	notifier_del_irq(hp, data);
 }
@@ -542,9 +176,9 @@ void hvterm_hvsi_hangup(struct hvc_struct *hp, int data)
 {
 	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
 
-	pr_devel("HVSI@%x: hangup !\n", pv->termno);
+	pr_devel("HVSI@%x: do hangup !\n", pv->termno);
 
-	hvterm_hvsi_shutdown(hp, pv);
+	hvsi_close(&pv->hvsi, hp);
 
 	notifier_hangup_irq(hp, data);
 }
@@ -555,7 +189,7 @@ static int hvterm_hvsi_tiocmget(struct hvc_struct *hp)
 
 	if (!pv)
 		return -EINVAL;
-	return pv->mctrl;
+	return pv->hvsi.mctrl;
 }
 
 static int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,
@@ -567,9 +201,9 @@ static int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,
 		 pv->termno, set, clear);
 
 	if (set & TIOCM_DTR)
-		hvterm_hvsi_write_mctrl(pv, 1);
+		hvsi_write_mctrl(&pv->hvsi, 1);
 	else if (clear & TIOCM_DTR)
-		hvterm_hvsi_write_mctrl(pv, 0);
+		hvsi_write_mctrl(&pv->hvsi, 0);
 
 	return 0;
 }
@@ -633,6 +267,8 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 		pv->termno = vdev->unit_address;
 		pv->proto = proto;
 		hvterm_privs[termno] = pv;
+		hvsi_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,
+			  pv->termno, 0);
 	}
 
 	hp = hvc_alloc(termno, vdev->irq, ops, MAX_VIO_PUT_CHARS);
@@ -770,7 +406,6 @@ void __init hvc_vio_init_early(void)
 	if (termno == NULL)
 		goto out;
 	hvterm_priv0.termno = *termno;
-	hvterm_priv0.is_console = 1;
 	hvterm_privs[0] = &hvterm_priv0;
 
 	/* Check the protocol */
@@ -781,8 +416,10 @@ void __init hvc_vio_init_early(void)
 	else if (of_device_is_compatible(stdout_node, "hvterm-protocol")) {
 		hvterm_priv0.proto = HV_PROTOCOL_HVSI;
 		ops = &hvterm_hvsi_ops;
+		hvsi_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
+			  hvterm_priv0.termno, 1);
 		/* HVSI, perform the handshake now */
-		hvterm_hvsi_establish(&hvterm_priv0);
+		hvsi_establish(&hvterm_priv0.hvsi);
 	} else
 		goto out;
 	udbg_putc = udbg_hvc_putc;
@@ -810,7 +447,6 @@ void __init udbg_init_debug_lpar(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = 0;
 	hvterm_priv0.proto = HV_PROTOCOL_RAW;
-	hvterm_priv0.is_console = 1;
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
@@ -823,10 +459,11 @@ void __init udbg_init_debug_lpar_hvsi(void)
 	hvterm_privs[0] = &hvterm_priv0;
 	hvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;
 	hvterm_priv0.proto = HV_PROTOCOL_HVSI;
-	hvterm_priv0.is_console = 1;
 	udbg_putc = udbg_hvc_putc;
 	udbg_getc = udbg_hvc_getc;
 	udbg_getc_poll = udbg_hvc_getc_poll;
-	hvterm_hvsi_establish(&hvterm_priv0);
+	hvsi_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,
+		  hvterm_priv0.termno, 1);
+	hvsi_establish(&hvterm_priv0.hvsi);
 }
 #endif /* CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI */

commit 4d2bb3f5003617cb42b89faefd0009c505c3abd5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu May 12 13:46:38 2011 +1000

    powerpc/pseries: Re-implement HVSI as part of hvc_vio
    
    On pseries machines, consoles are provided by the hypervisor using
    a low level get_chars/put_chars type interface. However, this is
    really just a transport to the service processor which implements
    them either as "raw" console (networked consoles, HMC, ...) or as
    "hvsi" serial ports.
    
    The later is a simple packet protocol on top of the raw character
    interface that is supposed to convey additional "serial port" style
    semantics. In practice however, all it does is provide a way to
    read the CD line and set/clear our DTR line, that's it.
    
    We currently implement the "raw" protocol as an hvc console backend
    (/dev/hvcN) and the "hvsi" protocol using a separate tty driver
    (/dev/hvsi0).
    
    However this is quite impractical. The arbitrary difference between
    the two type of devices has been a major source of user (and distro)
    confusion. Additionally, there's an additional mini -hvsi implementation
    in the pseries platform code for our low level debug console and early
    boot kernel messages, which means code duplication, though that low
    level variant is impractical as it's incapable of doing the initial
    protocol negociation to establish the link to the FSP.
    
    This essentially replaces the dedicated hvsi driver and the platform
    udbg code completely by extending the existing hvc_vio backend used
    in "raw" mode so that:
    
     - It now supports HVSI as well
     - We add support for hvc backend providing tiocm{get,set}
     - It also provides a udbg interface for early debug and boot console
    
    This is overall less code, though this will only be obvious once we
    remove the old "hvsi" driver, which is still available for now. When
    the old driver is enabled, the new code still kicks in for the low
    level udbg console, replacing the old mini implementation in the platform
    code, it just doesn't provide the higher level "hvc" interface.
    
    In addition to producing generally simler code, this has several benefits
    over our current situation:
    
     - The user/distro only has to deal with /dev/hvcN for the hypervisor
    console, avoiding all sort of confusion that has plagued us in the past
    
     - The tty, kernel and low level debug console all use the same code
    base which supports the full protocol establishment process, thus the
    console is now available much earlier than it used to be with the
    old HVSI driver. The kernel console works much earlier and udbg is
    available much earlier too. Hackers can enable a hard coded very-early
    debug console as well that works with HVSI (previously that was only
    supported for the "raw" mode).
    
    I've tried to keep the same semantics as hvsi relative to how I react
    to things like CD changes, with some subtle differences though:
    
     - I clear DTR on close if HUPCL is set
    
     - Current hvsi triggers a hangup if it detects a up->down transition
       on CD (you can still open a console with CD down). My new implementation
       triggers a hangup if the link to the FSP is severed, and severs it upon
       detecting a up->down transition on CD.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index e6eea1485244..d4e0850e8051 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -27,15 +27,27 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * TODO:
+ *
+ *   - handle error in sending hvsi protocol packets
+ *   - retry nego on subsequent sends ?
  */
 
+#undef DEBUG
+
 #include <linux/types.h>
 #include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/console.h>
 
 #include <asm/hvconsole.h>
 #include <asm/vio.h>
 #include <asm/prom.h>
 #include <asm/firmware.h>
+#include <asm/hvsi.h>
+#include <asm/udbg.h>
 
 #include "hvc_console.h"
 
@@ -43,14 +55,47 @@ static const char hvc_driver_name[] = "hvc_console";
 
 static struct vio_device_id hvc_driver_table[] __devinitdata = {
 	{"serial", "hvterm1"},
+#ifndef HVC_OLD_HVSI
+	{"serial", "hvterm-protocol"},
+#endif
 	{ "", "" }
 };
 MODULE_DEVICE_TABLE(vio, hvc_driver_table);
 
-static int filtered_get_chars(uint32_t vtermno, char *buf, int count)
+typedef enum hv_protocol {
+	HV_PROTOCOL_RAW,
+	HV_PROTOCOL_HVSI
+} hv_protocol_t;
+
+#define HV_INBUF_SIZE		255
+
+struct hvterm_priv {
+	u32		termno;		/* HV term number */
+	hv_protocol_t	proto;		/* Raw data or HVSI packets */
+	unsigned int	inbuf_len;	/* Data in input buffer */
+	unsigned char	inbuf[HV_INBUF_SIZE];
+	unsigned int	inbuf_cur;	/* Cursor in input buffer */
+	unsigned int	inbuf_pktlen;	/* HVSI packet lenght from cursor */
+	atomic_t	seqno;		/* HVSI packet sequence number */
+	unsigned int	opened:1;	/* HVSI driver opened */
+	unsigned int	established:1;	/* HVSI protocol established */
+	unsigned int 	is_console:1;	/* Used as a kernel console device */
+	unsigned int	mctrl_update:1;	/* HVSI modem control updated */
+	unsigned short	mctrl;		/* HVSI modem control */
+	struct tty_struct *tty;		/* TTY structure */
+};
+static struct hvterm_priv *hvterm_privs[MAX_NR_HVC_CONSOLES];
+
+/* For early boot console */
+static struct hvterm_priv hvterm_priv0;
+
+static int hvterm_raw_get_chars(uint32_t vtermno, char *buf, int count)
 {
-	unsigned long got;
-	int i;
+	struct hvterm_priv *pv = hvterm_privs[vtermno];
+	unsigned long got, i;
+
+	if (WARN_ON(!pv))
+		return 0;
 
 	/*
 	 * Vio firmware will read up to SIZE_VIO_GET_CHARS at its own discretion
@@ -60,7 +105,7 @@ static int filtered_get_chars(uint32_t vtermno, char *buf, int count)
 	if (count < SIZE_VIO_GET_CHARS)
 		return -EAGAIN;
 
-	got = hvc_get_chars(vtermno, buf, count);
+	got = hvc_get_chars(pv->termno, buf, count);
 
 	/*
 	 * Work around a HV bug where it gives us a null
@@ -70,32 +115,527 @@ static int filtered_get_chars(uint32_t vtermno, char *buf, int count)
 		if (buf[i] == 0 && buf[i-1] == '\r') {
 			--got;
 			if (i < got)
-				memmove(&buf[i], &buf[i+1],
-					got - i);
+				memmove(&buf[i], &buf[i+1], got - i);
 		}
 	}
 	return got;
 }
 
-static const struct hv_ops hvc_get_put_ops = {
-	.get_chars = filtered_get_chars,
-	.put_chars = hvc_put_chars,
+static int hvterm_raw_put_chars(uint32_t vtermno, const char *buf, int count)
+{
+	struct hvterm_priv *pv = hvterm_privs[vtermno];
+
+	if (WARN_ON(!pv))
+		return 0;
+
+	return hvc_put_chars(pv->termno, buf, count);
+}
+
+static const struct hv_ops hvterm_raw_ops = {
+	.get_chars = hvterm_raw_get_chars,
+	.put_chars = hvterm_raw_put_chars,
 	.notifier_add = notifier_add_irq,
 	.notifier_del = notifier_del_irq,
 	.notifier_hangup = notifier_hangup_irq,
 };
 
+static int hvterm_hvsi_send_packet(struct hvterm_priv *pv, struct hvsi_header *packet)
+{
+	packet->seqno = atomic_inc_return(&pv->seqno);
+
+	/* Assumes that always succeeds, works in practice */
+	return hvc_put_chars(pv->termno, (char *)packet, packet->len);
+}
+
+static void hvterm_hvsi_start_handshake(struct hvterm_priv *pv)
+{
+	struct hvsi_query q;
+
+	/* Reset state */
+	pv->established = 0;
+	atomic_set(&pv->seqno, 0);
+
+	pr_devel("HVSI@%x: Handshaking started\n", pv->termno);
+
+	/* Send version query */
+	q.hdr.type = VS_QUERY_PACKET_HEADER;
+	q.hdr.len = sizeof(struct hvsi_query);
+	q.verb = VSV_SEND_VERSION_NUMBER;
+	hvterm_hvsi_send_packet(pv, &q.hdr);
+}
+
+static int hvterm_hvsi_send_close(struct hvterm_priv *pv)
+{
+	struct hvsi_control ctrl;
+
+	pv->established = 0;
+
+	ctrl.hdr.type = VS_CONTROL_PACKET_HEADER;
+	ctrl.hdr.len = sizeof(struct hvsi_control);
+	ctrl.verb = VSV_CLOSE_PROTOCOL;
+	return hvterm_hvsi_send_packet(pv, &ctrl.hdr);
+}
+
+static void hvterm_cd_change(struct hvterm_priv *pv, int cd)
+{
+	if (cd)
+		pv->mctrl |= TIOCM_CD;
+	else {
+		pv->mctrl &= ~TIOCM_CD;
+
+		/* We copy the existing hvsi driver semantics
+		 * here which are to trigger a hangup when
+		 * we get a carrier loss.
+		 * Closing our connection to the server will
+		 * do just that.
+		 */
+		if (!pv->is_console && pv->opened) {
+			pr_devel("HVSI@%x Carrier lost, hanging up !\n",
+				 pv->termno);
+			hvterm_hvsi_send_close(pv);
+		}
+	}
+}
+
+static void hvterm_hvsi_got_control(struct hvterm_priv *pv)
+{
+	struct hvsi_control *pkt = (struct hvsi_control *)pv->inbuf;
+
+	switch (pkt->verb) {
+	case VSV_CLOSE_PROTOCOL:
+		/* We restart the handshaking */
+		hvterm_hvsi_start_handshake(pv);
+		break;
+	case VSV_MODEM_CTL_UPDATE:
+		/* Transition of carrier detect */
+		hvterm_cd_change(pv, pkt->word & HVSI_TSCD);
+		break;
+	}
+}
+
+static void hvterm_hvsi_got_query(struct hvterm_priv *pv)
+{
+	struct hvsi_query *pkt = (struct hvsi_query *)pv->inbuf;
+	struct hvsi_query_response r;
+
+	/* We only handle version queries */
+	if (pkt->verb != VSV_SEND_VERSION_NUMBER)
+		return;
+
+	pr_devel("HVSI@%x: Got version query, sending response...\n",
+		 pv->termno);
+
+	/* Send version response */
+	r.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;
+	r.hdr.len = sizeof(struct hvsi_query_response);
+	r.verb = VSV_SEND_VERSION_NUMBER;
+	r.u.version = HVSI_VERSION;
+	r.query_seqno = pkt->hdr.seqno;
+	hvterm_hvsi_send_packet(pv, &r.hdr);
+
+	/* Assume protocol is open now */
+	pv->established = 1;
+}
+
+static void hvterm_hvsi_got_response(struct hvterm_priv *pv)
+{
+	struct hvsi_query_response *r = (struct hvsi_query_response *)pv->inbuf;
+
+	switch(r->verb) {
+	case VSV_SEND_MODEM_CTL_STATUS:
+		hvterm_cd_change(pv, r->u.mctrl_word & HVSI_TSCD);
+		pv->mctrl_update = 1;
+		break;
+	}
+}
+
+static int hvterm_hvsi_check_packet(struct hvterm_priv *pv)
+{
+	u8 len, type;
+
+	/* Check header validity. If it's invalid, we ditch
+	 * the whole buffer and hope we eventually resync
+	 */
+	if (pv->inbuf[0] < 0xfc) {
+		pv->inbuf_len = pv->inbuf_pktlen = 0;
+		return 0;
+	}
+	type = pv->inbuf[0];
+	len = pv->inbuf[1];
+
+	/* Packet incomplete ? */
+	if (pv->inbuf_len < len)
+		return 0;
+
+	pr_devel("HVSI@%x: Got packet type %x len %d bytes:\n",
+		 pv->termno, type, len);
+
+	/* We have a packet, yay ! Handle it */
+	switch(type) {
+	case VS_DATA_PACKET_HEADER:
+		pv->inbuf_pktlen = len - 4;
+		pv->inbuf_cur = 4;
+		return 1;
+	case VS_CONTROL_PACKET_HEADER:
+		hvterm_hvsi_got_control(pv);
+		break;
+	case VS_QUERY_PACKET_HEADER:
+		hvterm_hvsi_got_query(pv);
+		break;
+	case VS_QUERY_RESPONSE_PACKET_HEADER:
+		hvterm_hvsi_got_response(pv);
+		break;
+	}
+
+	/* Swallow packet and retry */
+	pv->inbuf_len -= len;
+	memmove(pv->inbuf, &pv->inbuf[len], pv->inbuf_len);
+	return 1;
+}
+
+static int hvterm_hvsi_get_packet(struct hvterm_priv *pv)
+{
+	/* If we have room in the buffer, ask HV for more */
+	if (pv->inbuf_len < HV_INBUF_SIZE)
+		pv->inbuf_len += hvc_get_chars(pv->termno,
+					       &pv->inbuf[pv->inbuf_len],
+					       HV_INBUF_SIZE - pv->inbuf_len);
+	/*
+	 * If we have at least 4 bytes in the buffer, check for
+	 * a full packet and retry
+	 */
+	if (pv->inbuf_len >= 4)
+		return hvterm_hvsi_check_packet(pv);
+	return 0;
+}
+
+static int hvterm_hvsi_get_chars(uint32_t vtermno, char *buf, int count)
+{
+	struct hvterm_priv *pv = hvterm_privs[vtermno];
+	unsigned int tries, read = 0;
+
+	if (WARN_ON(!pv))
+		return 0;
+
+	/* If we aren't open, dont do anything in order to avoid races
+	 * with connection establishment. The hvc core will call this
+	 * before we have returned from notifier_add(), and we need to
+	 * avoid multiple users playing with the receive buffer
+	 */
+	if (!pv->opened)
+		return 0;
+
+	/* We try twice, once with what data we have and once more
+	 * after we try to fetch some more from the hypervisor
+	 */
+	for (tries = 1; count && tries < 2; tries++) {
+		/* Consume existing data packet */
+		if (pv->inbuf_pktlen) {
+			unsigned int l = min(count, (int)pv->inbuf_pktlen);
+			memcpy(&buf[read], &pv->inbuf[pv->inbuf_cur], l);
+			pv->inbuf_cur += l;
+			pv->inbuf_pktlen -= l;
+			count -= l;
+			read += l;
+		}
+		if (count == 0)
+			break;
+
+		/* Data packet fully consumed, move down remaning data */
+		if (pv->inbuf_cur) {
+			pv->inbuf_len -= pv->inbuf_cur;
+			memmove(pv->inbuf, &pv->inbuf[pv->inbuf_cur], pv->inbuf_len);
+			pv->inbuf_cur = 0;
+		}
+
+		/* Try to get another packet */
+		if (hvterm_hvsi_get_packet(pv))
+			tries--;
+	}
+	if (!pv->established) {
+		pr_devel("HVSI@%x: returning -EPIPE\n", pv->termno);
+		return -EPIPE;
+	}
+	return read;
+}
+
+static int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)
+{
+	struct hvterm_priv *pv = hvterm_privs[vtermno];
+	struct hvsi_data dp;
+	int rc, adjcount = min(count, HVSI_MAX_OUTGOING_DATA);
+
+	if (WARN_ON(!pv))
+		return 0;
+
+	dp.hdr.type = VS_DATA_PACKET_HEADER;
+	dp.hdr.len = adjcount + sizeof(struct hvsi_header);
+	memcpy(dp.data, buf, adjcount);
+	rc = hvterm_hvsi_send_packet(pv, &dp.hdr);
+	if (rc <= 0)
+		return rc;
+	return adjcount;
+}
+
+static void maybe_msleep(unsigned long ms)
+{
+	/* During early boot, IRQs are disabled, use mdelay */
+	if (irqs_disabled())
+		mdelay(ms);
+	else
+		msleep(ms);
+}
+
+static int hvterm_hvsi_read_mctrl(struct hvterm_priv *pv)
+{
+	struct hvsi_query q;
+	int rc, timeout;
+
+	pr_devel("HVSI@%x: Querying modem control status...\n",
+		 pv->termno);
+
+	pv->mctrl_update = 0;
+	q.hdr.type = VS_QUERY_PACKET_HEADER;
+	q.hdr.len = sizeof(struct hvsi_query);
+	q.hdr.seqno = atomic_inc_return(&pv->seqno);
+	q.verb = VSV_SEND_MODEM_CTL_STATUS;
+	rc = hvterm_hvsi_send_packet(pv, &q.hdr);
+	if (rc <= 0) {
+		pr_devel("HVSI@%x: Error %d...\n", pv->termno, rc);
+		return rc;
+	}
+
+	/* Try for up to 1s */
+	for (timeout = 0; timeout < 1000; timeout++) {
+		if (!pv->established)
+			return -ENXIO;
+		if (pv->mctrl_update)
+			return 0;
+		if (!hvterm_hvsi_get_packet(pv))
+			maybe_msleep(1);
+	}
+	return -EIO;
+}
+
+static int hvterm_hvsi_write_mctrl(struct hvterm_priv *pv, int dtr)
+{
+	struct hvsi_control ctrl;
+
+	pr_devel("HVSI@%x: %s DTR...\n", pv->termno,
+		 dtr ? "Setting" : "Clearing");
+
+	ctrl.hdr.type = VS_CONTROL_PACKET_HEADER,
+	ctrl.hdr.len = sizeof(struct hvsi_control);
+	ctrl.verb = VSV_SET_MODEM_CTL;
+	ctrl.mask = HVSI_TSDTR;
+	ctrl.word = dtr ? HVSI_TSDTR : 0;
+	if (dtr)
+		pv->mctrl |= TIOCM_DTR;
+	else
+		pv->mctrl &= ~TIOCM_DTR;
+	return hvterm_hvsi_send_packet(pv, &ctrl.hdr);
+}
+
+static void hvterm_hvsi_establish(struct hvterm_priv *pv)
+{
+	int timeout;
+
+	/* Try for up to 10ms, there can be a packet to
+	 * start the process waiting for us...
+	 */
+	for (timeout = 0; timeout < 10; timeout++) {
+		if (pv->established)
+			goto established;
+		if (!hvterm_hvsi_get_packet(pv))
+			maybe_msleep(1);
+	}
+
+	/* Failed, send a close connection packet just
+	 * in case
+	 */
+	hvterm_hvsi_send_close(pv);
+
+	/* Then restart handshake */
+	hvterm_hvsi_start_handshake(pv);
+
+	/* Try for up to 100ms */
+	for (timeout = 0; timeout < 100; timeout++) {
+		if (pv->established)
+			goto established;
+		if (!hvterm_hvsi_get_packet(pv))
+			maybe_msleep(1);
+	}
+
+	if (!pv->established) {
+		pr_devel("HVSI@%x: Timeout handshaking, giving up !\n",
+			 pv->termno);
+		return;
+	}
+ established:
+	/* Query modem control lines */
+	hvterm_hvsi_read_mctrl(pv);
+
+	/* Set our own DTR */
+	hvterm_hvsi_write_mctrl(pv, 1);
+
+	/* Set the opened flag so reads are allowed */
+	wmb();
+	pv->opened = 1;
+}
+
+static int hvterm_hvsi_open(struct hvc_struct *hp, int data)
+{
+	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
+	int rc;
+
+	pr_devel("HVSI@%x: open !\n", pv->termno);
+
+	rc = notifier_add_irq(hp, data);
+	if (rc)
+		return rc;
+
+	/* Keep track of the tty data structure */
+	pv->tty = tty_kref_get(hp->tty);
+
+	hvterm_hvsi_establish(pv);
+	return 0;
+}
+
+static void hvterm_hvsi_shutdown(struct hvc_struct *hp, struct hvterm_priv *pv)
+{
+	unsigned long flags;
+
+	if (!pv->is_console) {
+		pr_devel("HVSI@%x: Not a console, tearing down\n",
+			 pv->termno);
+
+		/* Clear opened, synchronize with khvcd */
+		spin_lock_irqsave(&hp->lock, flags);
+		pv->opened = 0;
+		spin_unlock_irqrestore(&hp->lock, flags);
+
+		/* Clear our own DTR */
+		if (!pv->tty || (pv->tty->termios->c_cflag & HUPCL))
+			hvterm_hvsi_write_mctrl(pv, 0);
+
+		/* Tear down the connection */
+		hvterm_hvsi_send_close(pv);
+	}
+
+	if (pv->tty)
+		tty_kref_put(pv->tty);
+	pv->tty = NULL;
+}
+
+static void hvterm_hvsi_close(struct hvc_struct *hp, int data)
+{
+	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
+
+	pr_devel("HVSI@%x: close !\n", pv->termno);
+
+	hvterm_hvsi_shutdown(hp, pv);
+
+	notifier_del_irq(hp, data);
+}
+
+void hvterm_hvsi_hangup(struct hvc_struct *hp, int data)
+{
+	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
+
+	pr_devel("HVSI@%x: hangup !\n", pv->termno);
+
+	hvterm_hvsi_shutdown(hp, pv);
+
+	notifier_hangup_irq(hp, data);
+}
+
+static int hvterm_hvsi_tiocmget(struct hvc_struct *hp)
+{
+	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
+
+	if (!pv)
+		return -EINVAL;
+	return pv->mctrl;
+}
+
+static int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,
+				unsigned int clear)
+{
+	struct hvterm_priv *pv = hvterm_privs[hp->vtermno];
+
+	pr_devel("HVSI@%x: Set modem control, set=%x,clr=%x\n",
+		 pv->termno, set, clear);
+
+	if (set & TIOCM_DTR)
+		hvterm_hvsi_write_mctrl(pv, 1);
+	else if (clear & TIOCM_DTR)
+		hvterm_hvsi_write_mctrl(pv, 0);
+
+	return 0;
+}
+
+static const struct hv_ops hvterm_hvsi_ops = {
+	.get_chars = hvterm_hvsi_get_chars,
+	.put_chars = hvterm_hvsi_put_chars,
+	.notifier_add = hvterm_hvsi_open,
+	.notifier_del = hvterm_hvsi_close,
+	.notifier_hangup = hvterm_hvsi_hangup,
+	.tiocmget = hvterm_hvsi_tiocmget,
+	.tiocmset = hvterm_hvsi_tiocmset,
+};
+
 static int __devinit hvc_vio_probe(struct vio_dev *vdev,
-				const struct vio_device_id *id)
+				   const struct vio_device_id *id)
 {
+	const struct hv_ops *ops;
 	struct hvc_struct *hp;
+	struct hvterm_priv *pv;
+	hv_protocol_t proto;
+	int i, termno = -1;
 
 	/* probed with invalid parameters. */
 	if (!vdev || !id)
 		return -EPERM;
 
-	hp = hvc_alloc(vdev->unit_address, vdev->irq, &hvc_get_put_ops,
-			MAX_VIO_PUT_CHARS);
+	if (of_device_is_compatible(vdev->dev.of_node, "hvterm1")) {
+		proto = HV_PROTOCOL_RAW;
+		ops = &hvterm_raw_ops;
+	} else if (of_device_is_compatible(vdev->dev.of_node, "hvterm-protocol")) {
+		proto = HV_PROTOCOL_HVSI;
+		ops = &hvterm_hvsi_ops;
+	} else {
+		pr_err("hvc_vio: Unkown protocol for %s\n", vdev->dev.of_node->full_name);
+		return -ENXIO;
+	}
+
+	pr_devel("hvc_vio_probe() device %s, using %s protocol\n",
+		 vdev->dev.of_node->full_name,
+		 proto == HV_PROTOCOL_RAW ? "raw" : "hvsi");
+
+	/* Is it our boot one ? */
+	if (hvterm_privs[0] == &hvterm_priv0 &&
+	    vdev->unit_address == hvterm_priv0.termno) {
+		pv = hvterm_privs[0];
+		termno = 0;
+		pr_devel("->boot console, using termno 0\n");
+	}
+	/* nope, allocate a new one */
+	else {
+		for (i = 0; i < MAX_NR_HVC_CONSOLES && termno < 0; i++)
+			if (!hvterm_privs[i])
+				termno = i;
+		pr_devel("->non-boot console, using termno %d\n", termno);
+		if (termno < 0)
+			return -ENODEV;
+		pv = kzalloc(sizeof(struct hvterm_priv), GFP_KERNEL);
+		if (!pv)
+			return -ENOMEM;
+		pv->termno = vdev->unit_address;
+		pv->proto = proto;
+		hvterm_privs[termno] = pv;
+	}
+
+	hp = hvc_alloc(termno, vdev->irq, ops, MAX_VIO_PUT_CHARS);
 	if (IS_ERR(hp))
 		return PTR_ERR(hp);
 	dev_set_drvdata(&vdev->dev, hp);
@@ -106,8 +646,16 @@ static int __devinit hvc_vio_probe(struct vio_dev *vdev,
 static int __devexit hvc_vio_remove(struct vio_dev *vdev)
 {
 	struct hvc_struct *hp = dev_get_drvdata(&vdev->dev);
+	int rc, termno;
 
-	return hvc_remove(hp);
+	termno = hp->vtermno;
+	rc = hvc_remove(hp);
+	if (rc == 0) {
+		if (hvterm_privs[termno] != &hvterm_priv0)
+			kfree(hvterm_privs[termno]);
+		hvterm_privs[termno] = NULL;
+	}
+	return rc;
 }
 
 static struct vio_driver hvc_vio_driver = {
@@ -140,34 +688,145 @@ static void __exit hvc_vio_exit(void)
 }
 module_exit(hvc_vio_exit);
 
-/* the device tree order defines our numbering */
-static int hvc_find_vtys(void)
+static void udbg_hvc_putc(char c)
 {
-	struct device_node *vty;
-	int num_found = 0;
+	int count = -1;
 
-	for (vty = of_find_node_by_name(NULL, "vty"); vty != NULL;
-			vty = of_find_node_by_name(vty, "vty")) {
-		const uint32_t *vtermno;
+	if (c == '\n')
+		udbg_hvc_putc('\r');
 
-		/* We have statically defined space for only a certain number
-		 * of console adapters.
-		 */
-		if (num_found >= MAX_NR_HVC_CONSOLES) {
-			of_node_put(vty);
+	do {
+		switch(hvterm_priv0.proto) {
+		case HV_PROTOCOL_RAW:
+			count = hvterm_raw_put_chars(0, &c, 1);
+			break;
+		case HV_PROTOCOL_HVSI:
+			count = hvterm_hvsi_put_chars(0, &c, 1);
 			break;
 		}
+	} while(count == 0);
+}
+
+static int udbg_hvc_getc_poll(void)
+{
+	int rc = 0;
+	char c;
 
-		vtermno = of_get_property(vty, "reg", NULL);
-		if (!vtermno)
-			continue;
+	switch(hvterm_priv0.proto) {
+	case HV_PROTOCOL_RAW:
+		rc = hvterm_raw_get_chars(0, &c, 1);
+		break;
+	case HV_PROTOCOL_HVSI:
+		rc = hvterm_hvsi_get_chars(0, &c, 1);
+		break;
+	}
+	if (!rc)
+		return -1;
+	return c;
+}
 
-		if (of_device_is_compatible(vty, "hvterm1")) {
-			hvc_instantiate(*vtermno, num_found, &hvc_get_put_ops);
-			++num_found;
+static int udbg_hvc_getc(void)
+{
+	int ch;
+	for (;;) {
+		ch = udbg_hvc_getc_poll();
+		if (ch == -1) {
+			/* This shouldn't be needed...but... */
+			volatile unsigned long delay;
+			for (delay=0; delay < 2000000; delay++)
+				;
+		} else {
+			return ch;
 		}
 	}
+}
+
+void __init hvc_vio_init_early(void)
+{
+	struct device_node *stdout_node;
+	const u32 *termno;
+	const char *name;
+	const struct hv_ops *ops;
+
+	/* find the boot console from /chosen/stdout */
+	if (!of_chosen)
+		return;
+	name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+	if (name == NULL)
+		return;
+	stdout_node = of_find_node_by_path(name);
+	if (!stdout_node)
+		return;
+	name = of_get_property(stdout_node, "name", NULL);
+	if (!name) {
+		printk(KERN_WARNING "stdout node missing 'name' property!\n");
+		goto out;
+	}
+
+	/* Check if it's a virtual terminal */
+	if (strncmp(name, "vty", 3) != 0)
+		goto out;
+	termno = of_get_property(stdout_node, "reg", NULL);
+	if (termno == NULL)
+		goto out;
+	hvterm_priv0.termno = *termno;
+	hvterm_priv0.is_console = 1;
+	hvterm_privs[0] = &hvterm_priv0;
+
+	/* Check the protocol */
+	if (of_device_is_compatible(stdout_node, "hvterm1")) {
+		hvterm_priv0.proto = HV_PROTOCOL_RAW;
+		ops = &hvterm_raw_ops;
+	}
+	else if (of_device_is_compatible(stdout_node, "hvterm-protocol")) {
+		hvterm_priv0.proto = HV_PROTOCOL_HVSI;
+		ops = &hvterm_hvsi_ops;
+		/* HVSI, perform the handshake now */
+		hvterm_hvsi_establish(&hvterm_priv0);
+	} else
+		goto out;
+	udbg_putc = udbg_hvc_putc;
+	udbg_getc = udbg_hvc_getc;
+	udbg_getc_poll = udbg_hvc_getc_poll;
+#ifdef HVC_OLD_HVSI
+	/* When using the old HVSI driver don't register the HVC
+	 * backend for HVSI, only do udbg
+	 */
+	if (hvterm_priv0.proto == HV_PROTOCOL_HVSI)
+		goto out;
+#endif
+	add_preferred_console("hvc", 0, NULL);
+	hvc_instantiate(0, 0, ops);
+out:
+	of_node_put(stdout_node);
+}
+
+/* call this from early_init() for a working debug console on
+ * vterm capable LPAR machines
+ */
+#ifdef CONFIG_PPC_EARLY_DEBUG_LPAR
+void __init udbg_init_debug_lpar(void)
+{
+	hvterm_privs[0] = &hvterm_priv0;
+	hvterm_priv0.termno = 0;
+	hvterm_priv0.proto = HV_PROTOCOL_RAW;
+	hvterm_priv0.is_console = 1;
+	udbg_putc = udbg_hvc_putc;
+	udbg_getc = udbg_hvc_getc;
+	udbg_getc_poll = udbg_hvc_getc_poll;
+}
+#endif /* CONFIG_PPC_EARLY_DEBUG_LPAR */
 
-	return num_found;
+#ifdef CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI
+void __init udbg_init_debug_lpar_hvsi(void)
+{
+	hvterm_privs[0] = &hvterm_priv0;
+	hvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;
+	hvterm_priv0.proto = HV_PROTOCOL_HVSI;
+	hvterm_priv0.is_console = 1;
+	udbg_putc = udbg_hvc_putc;
+	udbg_getc = udbg_hvc_getc;
+	udbg_getc_poll = udbg_hvc_getc_poll;
+	hvterm_hvsi_establish(&hvterm_priv0);
 }
-console_initcall(hvc_find_vtys);
+#endif /* CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 5e2f52b33327..e6eea1485244 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -1,7 +1,7 @@
 /*
  * vio driver interface to hvc_console.c
  *
- * This code was moved here to allow the remaing code to be reused as a
+ * This code was moved here to allow the remaining code to be reused as a
  * generic polling mode with semi-reliable transport driver core to the
  * console and tty subsystems.
  *

commit 728674a7e466628df2aeec6d11a2ae1ef968fb67
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 13 12:03:00 2011 -0800

    tty: move hvc drivers to drivers/tty/hvc/
    
    As requested by Arnd Bergmann, the hvc drivers are now
    moved to the drivers/tty/hvc/ directory.  The virtio_console.c driver
    was also moved, as it required the hvc_console.h file to be able to be
    built, and it really is a hvc driver.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
new file mode 100644
index 000000000000..5e2f52b33327
--- /dev/null
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -0,0 +1,173 @@
+/*
+ * vio driver interface to hvc_console.c
+ *
+ * This code was moved here to allow the remaing code to be reused as a
+ * generic polling mode with semi-reliable transport driver core to the
+ * console and tty subsystems.
+ *
+ *
+ * Copyright (C) 2001 Anton Blanchard <anton@au.ibm.com>, IBM
+ * Copyright (C) 2001 Paul Mackerras <paulus@au.ibm.com>, IBM
+ * Copyright (C) 2004 Benjamin Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ * Copyright (C) 2004 IBM Corporation
+ *
+ * Additional Author(s):
+ *  Ryan S. Arnold <rsa@us.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+
+#include <asm/hvconsole.h>
+#include <asm/vio.h>
+#include <asm/prom.h>
+#include <asm/firmware.h>
+
+#include "hvc_console.h"
+
+static const char hvc_driver_name[] = "hvc_console";
+
+static struct vio_device_id hvc_driver_table[] __devinitdata = {
+	{"serial", "hvterm1"},
+	{ "", "" }
+};
+MODULE_DEVICE_TABLE(vio, hvc_driver_table);
+
+static int filtered_get_chars(uint32_t vtermno, char *buf, int count)
+{
+	unsigned long got;
+	int i;
+
+	/*
+	 * Vio firmware will read up to SIZE_VIO_GET_CHARS at its own discretion
+	 * so we play safe and avoid the situation where got > count which could
+	 * overload the flip buffer.
+	 */
+	if (count < SIZE_VIO_GET_CHARS)
+		return -EAGAIN;
+
+	got = hvc_get_chars(vtermno, buf, count);
+
+	/*
+	 * Work around a HV bug where it gives us a null
+	 * after every \r.  -- paulus
+	 */
+	for (i = 1; i < got; ++i) {
+		if (buf[i] == 0 && buf[i-1] == '\r') {
+			--got;
+			if (i < got)
+				memmove(&buf[i], &buf[i+1],
+					got - i);
+		}
+	}
+	return got;
+}
+
+static const struct hv_ops hvc_get_put_ops = {
+	.get_chars = filtered_get_chars,
+	.put_chars = hvc_put_chars,
+	.notifier_add = notifier_add_irq,
+	.notifier_del = notifier_del_irq,
+	.notifier_hangup = notifier_hangup_irq,
+};
+
+static int __devinit hvc_vio_probe(struct vio_dev *vdev,
+				const struct vio_device_id *id)
+{
+	struct hvc_struct *hp;
+
+	/* probed with invalid parameters. */
+	if (!vdev || !id)
+		return -EPERM;
+
+	hp = hvc_alloc(vdev->unit_address, vdev->irq, &hvc_get_put_ops,
+			MAX_VIO_PUT_CHARS);
+	if (IS_ERR(hp))
+		return PTR_ERR(hp);
+	dev_set_drvdata(&vdev->dev, hp);
+
+	return 0;
+}
+
+static int __devexit hvc_vio_remove(struct vio_dev *vdev)
+{
+	struct hvc_struct *hp = dev_get_drvdata(&vdev->dev);
+
+	return hvc_remove(hp);
+}
+
+static struct vio_driver hvc_vio_driver = {
+	.id_table	= hvc_driver_table,
+	.probe		= hvc_vio_probe,
+	.remove		= __devexit_p(hvc_vio_remove),
+	.driver		= {
+		.name	= hvc_driver_name,
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init hvc_vio_init(void)
+{
+	int rc;
+
+	if (firmware_has_feature(FW_FEATURE_ISERIES))
+		return -EIO;
+
+	/* Register as a vio device to receive callbacks */
+	rc = vio_register_driver(&hvc_vio_driver);
+
+	return rc;
+}
+module_init(hvc_vio_init); /* after drivers/char/hvc_console.c */
+
+static void __exit hvc_vio_exit(void)
+{
+	vio_unregister_driver(&hvc_vio_driver);
+}
+module_exit(hvc_vio_exit);
+
+/* the device tree order defines our numbering */
+static int hvc_find_vtys(void)
+{
+	struct device_node *vty;
+	int num_found = 0;
+
+	for (vty = of_find_node_by_name(NULL, "vty"); vty != NULL;
+			vty = of_find_node_by_name(vty, "vty")) {
+		const uint32_t *vtermno;
+
+		/* We have statically defined space for only a certain number
+		 * of console adapters.
+		 */
+		if (num_found >= MAX_NR_HVC_CONSOLES) {
+			of_node_put(vty);
+			break;
+		}
+
+		vtermno = of_get_property(vty, "reg", NULL);
+		if (!vtermno)
+			continue;
+
+		if (of_device_is_compatible(vty, "hvterm1")) {
+			hvc_instantiate(*vtermno, num_found, &hvc_get_put_ops);
+			++num_found;
+		}
+	}
+
+	return num_found;
+}
+console_initcall(hvc_find_vtys);
