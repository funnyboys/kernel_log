commit 50f45326afab723df529eca54095e2feac24da2d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Sep 12 20:53:46 2018 -0400

    pty: fix compat ioctls
    
    pointer-taking ones need compat_ptr(); int-taking one doesn't.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 678406e0948b..00099a8439d2 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -28,6 +28,7 @@
 #include <linux/mount.h>
 #include <linux/file.h>
 #include <linux/ioctl.h>
+#include <linux/compat.h>
 
 #undef TTY_DEBUG_HANGUP
 #ifdef TTY_DEBUG_HANGUP
@@ -488,6 +489,7 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 	return -ENOIOCTLCMD;
 }
 
+#ifdef CONFIG_COMPAT
 static long pty_bsd_compat_ioctl(struct tty_struct *tty,
 				 unsigned int cmd, unsigned long arg)
 {
@@ -495,8 +497,11 @@ static long pty_bsd_compat_ioctl(struct tty_struct *tty,
 	 * PTY ioctls don't require any special translation between 32-bit and
 	 * 64-bit userspace, they are already compatible.
 	 */
-	return pty_bsd_ioctl(tty, cmd, arg);
+	return pty_bsd_ioctl(tty, cmd, (unsigned long)compat_ptr(arg));
 }
+#else
+#define pty_bsd_compat_ioctl NULL
+#endif
 
 static int legacy_count = CONFIG_LEGACY_PTY_COUNT;
 /*
@@ -676,6 +681,7 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 	return -ENOIOCTLCMD;
 }
 
+#ifdef CONFIG_COMPAT
 static long pty_unix98_compat_ioctl(struct tty_struct *tty,
 				 unsigned int cmd, unsigned long arg)
 {
@@ -683,8 +689,12 @@ static long pty_unix98_compat_ioctl(struct tty_struct *tty,
 	 * PTY ioctls don't require any special translation between 32-bit and
 	 * 64-bit userspace, they are already compatible.
 	 */
-	return pty_unix98_ioctl(tty, cmd, arg);
+	return pty_unix98_ioctl(tty, cmd,
+		cmd == TIOCSIG ? arg : (unsigned long)compat_ptr(arg));
 }
+#else
+#define pty_unix98_compat_ioctl NULL
+#endif
 
 /**
  *	ptm_unix98_lookup	-	find a pty master

commit 36ecc1481dc8d8c52d43ba18c6b642c1d2fde789
Author: Matthijs van Duin <matthijsvanduin@gmail.com>
Date:   Thu Jul 19 10:43:46 2018 +0200

    pty: fix O_CLOEXEC for TIOCGPTPEER
    
    It was being ignored because the flags were not passed to fd allocation.
    
    Fixes: 54ebbfb16034 ("tty: add TIOCGPTPEER ioctl")
    Signed-off-by: Matthijs van Duin <matthijsvanduin@gmail.com>
    Acked-by: Aleksa Sarai <asarai@suse.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b0e2c4847a5d..678406e0948b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -625,7 +625,7 @@ int ptm_open_peer(struct file *master, struct tty_struct *tty, int flags)
 	if (tty->driver != ptm_driver)
 		return -EIO;
 
-	fd = get_unused_fd_flags(0);
+	fd = get_unused_fd_flags(flags);
 	if (fd < 0) {
 		retval = fd;
 		goto err;

commit b6da31b2c07c46f2dcad1d86caa835227a16d9ff
Author: DaeRyong Jeong <threeearcat@gmail.com>
Date:   Tue May 1 00:27:04 2018 +0900

    tty: Fix data race in tty_insert_flip_string_fixed_flag
    
    Unlike normal serials, in pty layer, there is no guarantee that multiple
    threads don't insert input characters at the same time. If it is happened,
    tty_insert_flip_string_fixed_flag can be executed concurrently. This can
    lead slab out-of-bounds write in tty_insert_flip_string_fixed_flag.
    
    Call sequences are as follows.
    CPU0                                    CPU1
    n_tty_ioctl_helper                      n_tty_ioctl_helper
    __start_tty                             tty_send_xchar
    tty_wakeup                              pty_write
    n_hdlc_tty_wakeup                       tty_insert_flip_string
    n_hdlc_send_frames                      tty_insert_flip_string_fixed_flag
    pty_write
    tty_insert_flip_string
    tty_insert_flip_string_fixed_flag
    
    To fix the race, acquire port->lock in pty_write() before it inserts input
    characters to tty buffer. It prevents multiple threads from inserting
    input characters concurrently.
    
    The crash log is as follows:
    BUG: KASAN: slab-out-of-bounds in tty_insert_flip_string_fixed_flag+0xb5/
    0x130 drivers/tty/tty_buffer.c:316 at addr ffff880114fcc121
    Write of size 1792 by task syz-executor0/30017
    CPU: 1 PID: 30017 Comm: syz-executor0 Not tainted 4.8.0 #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
     0000000000000000 ffff88011638f888 ffffffff81694cc3 ffff88007d802140
     ffff880114fcb300 ffff880114fcc300 ffff880114fcb300 ffff88011638f8b0
     ffffffff8130075c ffff88011638f940 ffff88007d802140 ffff880194fcc121
    Call Trace:
     __dump_stack lib/dump_stack.c:15 [inline]
     dump_stack+0xb3/0x110 lib/dump_stack.c:51
     kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
     print_address_description mm/kasan/report.c:194 [inline]
     kasan_report_error+0x1f7/0x4e0 mm/kasan/report.c:283
     kasan_report+0x36/0x40 mm/kasan/report.c:303
     check_memory_region_inline mm/kasan/kasan.c:292 [inline]
     check_memory_region+0x13e/0x1a0 mm/kasan/kasan.c:299
     memcpy+0x37/0x50 mm/kasan/kasan.c:335
     tty_insert_flip_string_fixed_flag+0xb5/0x130 drivers/tty/tty_buffer.c:316
     tty_insert_flip_string include/linux/tty_flip.h:35 [inline]
     pty_write+0x7f/0xc0 drivers/tty/pty.c:115
     n_hdlc_send_frames+0x1d4/0x3b0 drivers/tty/n_hdlc.c:419
     n_hdlc_tty_wakeup+0x73/0xa0 drivers/tty/n_hdlc.c:496
     tty_wakeup+0x92/0xb0 drivers/tty/tty_io.c:601
     __start_tty.part.26+0x66/0x70 drivers/tty/tty_io.c:1018
     __start_tty+0x34/0x40 drivers/tty/tty_io.c:1013
     n_tty_ioctl_helper+0x146/0x1e0 drivers/tty/tty_ioctl.c:1138
     n_hdlc_tty_ioctl+0xb3/0x2b0 drivers/tty/n_hdlc.c:794
     tty_ioctl+0xa85/0x16d0 drivers/tty/tty_io.c:2992
     vfs_ioctl fs/ioctl.c:43 [inline]
     do_vfs_ioctl+0x13e/0xba0 fs/ioctl.c:679
     SYSC_ioctl fs/ioctl.c:694 [inline]
     SyS_ioctl+0x8f/0xc0 fs/ioctl.c:685
     entry_SYSCALL_64_fastpath+0x1f/0xbd
    
    Signed-off-by: DaeRyong Jeong <threeearcat@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 6c7151edd715..b0e2c4847a5d 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -110,16 +110,19 @@ static void pty_unthrottle(struct tty_struct *tty)
 static int pty_write(struct tty_struct *tty, const unsigned char *buf, int c)
 {
 	struct tty_struct *to = tty->link;
+	unsigned long flags;
 
 	if (tty->stopped)
 		return 0;
 
 	if (c > 0) {
+		spin_lock_irqsave(&to->port->lock, flags);
 		/* Stuff the data into the input queue of the other end */
 		c = tty_insert_flip_string(to->port, buf, c);
 		/* And shovel */
 		if (c)
 			tty_flip_buffer_push(to->port);
+		spin_unlock_irqrestore(&to->port->lock, flags);
 	}
 	return c;
 }

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 64338442050e..6c7151edd715 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -344,7 +344,7 @@ static void pty_start(struct tty_struct *tty)
 		tty->ctrl_status &= ~TIOCPKT_STOP;
 		tty->ctrl_status |= TIOCPKT_START;
 		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
-		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
+		wake_up_interruptible_poll(&tty->link->read_wait, EPOLLIN);
 	}
 }
 
@@ -357,7 +357,7 @@ static void pty_stop(struct tty_struct *tty)
 		tty->ctrl_status &= ~TIOCPKT_START;
 		tty->ctrl_status |= TIOCPKT_STOP;
 		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
-		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
+		wake_up_interruptible_poll(&tty->link->read_wait, EPOLLIN);
 	}
 }
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 26dcb3b60fb9..64338442050e 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *

commit e63a94f12b5fc67b2b92a89d4058e7a9021e900e
Merge: 1a3b85ea36d3 3840ed9548f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 10:30:48 2017 -0700

    Merge tag 'tty-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the big tty/serial driver update for 4.14-rc1.
    
      Well, not all that big, just a number of small serial driver fixes,
      and a new serial driver. Also in here are some much needed goldfish
      tty driver (emulator) fixes to try to get that codebase under control.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'tty-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (94 commits)
      tty: goldfish: Implement support for kernel 'earlycon' parameter
      tty: goldfish: Use streaming DMA for r/w operations on Ranchu platforms
      tty: goldfish: Refactor constants to better reflect their nature
      serial: 8250_port: Remove useless NULL checks
      earlycon: initialise baud field of earlycon device structure
      tty: hvcs: make ktermios const
      pty: show associative slave of ptmx in fdinfo
      tty: n_gsm: Add compat_ioctl
      tty: hvcs: constify vio_device_id
      tty: hvc_vio: constify vio_device_id
      tty: mips_ejtag_fdc: constify mips_cdmm_device_id
      Introduce 8250_men_mcb
      mcb: introduce mcb_get_resource()
      serial: imx: Avoid post-PIO cleanup if TX DMA is started
      tty: serial: imx: disable irq after suspend
      serial: 8250_uniphier: add suspend/resume support
      serial: 8250_uniphier: use CHAR register for canary to detect power-off
      serial: 8250_uniphier: fix serial port index in private data
      serial: 8250: of: Add new port type for MediaTek BTIF controller on MT7622/23 SoC
      dt-bindings: serial: 8250: Add MediaTek BTIF controller bindings
      ...

commit d01c3289e7d68162e32bc08c2b65dd1a216a7ef8
Author: Masatake YAMATO <yamato@redhat.com>
Date:   Tue Jul 18 06:27:59 2017 +0900

    pty: show associative slave of ptmx in fdinfo
    
    This patch adds "tty-index" field to /proc/PID/fdinfo/N if N
    specifies /dev/ptmx. The field shows the index of associative
    slave pts.
    
    Though a minor number is given for each pts instance, ptmx is not.
    It means there is no way in user-space to know the association between
    file descriptors for pts/n and ptmx. (n = 0, 1, ...)
    
    This is different from pipe. About pipe such association can be solved
    by inode of pipefs.
    
    Providing the way to know the association between pts/n and ptmx helps
    users understand the status of running system. lsof can utilize this field.
    
    Signed-off-by: Masatake YAMATO <yamato@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 284749fb0f6b..bb672ace562f 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -741,6 +741,11 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 	}
 }
 
+static void pty_show_fdinfo(struct tty_struct *tty, struct seq_file *m)
+{
+	seq_printf(m, "tty-index:\t%d\n", tty->index);
+}
+
 static const struct tty_operations ptm_unix98_ops = {
 	.lookup = ptm_unix98_lookup,
 	.install = pty_unix98_install,
@@ -755,7 +760,8 @@ static const struct tty_operations ptm_unix98_ops = {
 	.ioctl = pty_unix98_ioctl,
 	.compat_ioctl = pty_unix98_compat_ioctl,
 	.resize = pty_resize,
-	.cleanup = pty_cleanup
+	.cleanup = pty_cleanup,
+	.show_fdinfo = pty_show_fdinfo,
 };
 
 static const struct tty_operations pty_unix98_ops = {

commit 311fc65c9fb9c966bca8e6f3ff8132ce57344ab9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Aug 24 15:13:29 2017 -0500

    pty: Repair TIOCGPTPEER
    
    The implementation of TIOCGPTPEER has two issues.
    
    When /dev/ptmx (as opposed to /dev/pts/ptmx) is opened the wrong
    vfsmount is passed to dentry_open.  Which results in the kernel displaying
    the wrong pathname for the peer.
    
    The second is simply by caching the vfsmount and dentry of the peer it leaves
    them open, in a way they were not previously Which because of the inreased
    reference counts can cause unnecessary behaviour differences resulting in
    regressions.
    
    To fix these move the ioctl into tty_io.c at a generic level allowing
    the ioctl to have access to the struct file on which the ioctl is
    being called.  This allows the path of the slave to be derived when
    opening the slave through TIOCGPTPEER instead of requiring the path to
    the slave be cached.  Thus removing the need for caching the path.
    
    A new function devpts_ptmx_path is factored out of devpts_acquire and
    used to implement a function devpts_mntget.   The new function devpts_mntget
    takes a filp to perform the lookup on and fsi so that it can confirm
    that the superblock that is found by devpts_ptmx_path is the proper superblock.
    
    v2: Lots of fixes to make the code actually work
    v3: Suggestions by Linus
        - Removed the unnecessary initialization of filp in ptm_open_peer
        - Simplified devpts_ptmx_path as gotos are no longer required
    
    [ This is the fix for the issue that was reverted in commit
      143c97cc6529, but this time without breaking 'pbuilder' due to
      increased reference counts   - Linus ]
    
    Fixes: 54ebbfb16034 ("tty: add TIOCGPTPEER ioctl")
    Reported-by: Christian Brauner <christian.brauner@canonical.com>
    Reported-and-tested-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 284749fb0f6b..a6d5164c33a9 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -69,13 +69,8 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 #ifdef CONFIG_UNIX98_PTYS
 		if (tty->driver == ptm_driver) {
 			mutex_lock(&devpts_mutex);
-			if (tty->link->driver_data) {
-				struct path *path = tty->link->driver_data;
-
-				devpts_pty_kill(path->dentry);
-				path_put(path);
-				kfree(path);
-			}
+			if (tty->link->driver_data)
+				devpts_pty_kill(tty->link->driver_data);
 			mutex_unlock(&devpts_mutex);
 		}
 #endif
@@ -607,25 +602,24 @@ static inline void legacy_pty_init(void) { }
 static struct cdev ptmx_cdev;
 
 /**
- *	pty_open_peer - open the peer of a pty
- *	@tty: the peer of the pty being opened
+ *	ptm_open_peer - open the peer of a pty
+ *	@master: the open struct file of the ptmx device node
+ *	@tty: the master of the pty being opened
+ *	@flags: the flags for open
  *
- *	Open the cached dentry in tty->link, providing a safe way for userspace
- *	to get the slave end of a pty (where they have the master fd and cannot
- *	access or trust the mount namespace /dev/pts was mounted inside).
+ *	Provide a race free way for userspace to open the slave end of a pty
+ *	(where they have the master fd and cannot access or trust the mount
+ *	namespace /dev/pts was mounted inside).
  */
-static struct file *pty_open_peer(struct tty_struct *tty, int flags)
-{
-	if (tty->driver->subtype != PTY_TYPE_MASTER)
-		return ERR_PTR(-EIO);
-	return dentry_open(tty->link->driver_data, flags, current_cred());
-}
-
-static int pty_get_peer(struct tty_struct *tty, int flags)
+int ptm_open_peer(struct file *master, struct tty_struct *tty, int flags)
 {
 	int fd = -1;
-	struct file *filp = NULL;
+	struct file *filp;
 	int retval = -EINVAL;
+	struct path path;
+
+	if (tty->driver != ptm_driver)
+		return -EIO;
 
 	fd = get_unused_fd_flags(0);
 	if (fd < 0) {
@@ -633,7 +627,16 @@ static int pty_get_peer(struct tty_struct *tty, int flags)
 		goto err;
 	}
 
-	filp = pty_open_peer(tty, flags);
+	/* Compute the slave's path */
+	path.mnt = devpts_mntget(master, tty->driver_data);
+	if (IS_ERR(path.mnt)) {
+		retval = PTR_ERR(path.mnt);
+		goto err_put;
+	}
+	path.dentry = tty->link->driver_data;
+
+	filp = dentry_open(&path, flags, current_cred());
+	mntput(path.mnt);
 	if (IS_ERR(filp)) {
 		retval = PTR_ERR(filp);
 		goto err_put;
@@ -662,8 +665,6 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 		return pty_get_pktmode(tty, (int __user *)arg);
 	case TIOCGPTN: /* Get PT Number */
 		return put_user(tty->index, (unsigned int __user *)arg);
-	case TIOCGPTPEER: /* Open the other end */
-		return pty_get_peer(tty, (int) arg);
 	case TIOCSIG:    /* Send signal to other side of pty */
 		return pty_signal(tty, (int) arg);
 	}
@@ -791,7 +792,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 {
 	struct pts_fs_info *fsi;
 	struct tty_struct *tty;
-	struct path *pts_path;
 	struct dentry *dentry;
 	int retval;
 	int index;
@@ -845,26 +845,16 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		retval = PTR_ERR(dentry);
 		goto err_release;
 	}
-	/* We need to cache a fake path for TIOCGPTPEER. */
-	pts_path = kmalloc(sizeof(struct path), GFP_KERNEL);
-	if (!pts_path)
-		goto err_release;
-	pts_path->mnt = filp->f_path.mnt;
-	pts_path->dentry = dentry;
-	path_get(pts_path);
-	tty->link->driver_data = pts_path;
+	tty->link->driver_data = dentry;
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)
-		goto err_path_put;
+		goto err_release;
 
 	tty_debug_hangup(tty, "opening (count=%d)\n", tty->count);
 
 	tty_unlock(tty);
 	return 0;
-err_path_put:
-	path_put(pts_path);
-	kfree(pts_path);
 err_release:
 	tty_unlock(tty);
 	// This will also put-ref the fsi

commit 143c97cc652949893c8056c679012f0aeccb80e5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 23 18:16:11 2017 -0700

    Revert "pty: fix the cached path of the pty slave file descriptor in the master"
    
    This reverts commit c8c03f1858331e85d397bacccd34ef409aae993c.
    
    It turns out that while fixing the ptmx file descriptor to have the
    correct 'struct path' to the associated slave pty is a really good
    thing, it breaks some user space tools for a very annoying reason.
    
    The problem is that /dev/ptmx and its associated slave pty (/dev/pts/X)
    are on different mounts.  That was what caused us to have the wrong path
    in the first place (we would mix up the vfsmount of the 'ptmx' node,
    with the dentry of the pty slave node), but it also means that now while
    we use the right vfsmount, having the pty master open also keeps the pts
    mount busy.
    
    And it turn sout that that makes 'pbuilder' very unhappy, as noted by
    Stefan Lippers-Hollmann:
    
     "This patch introduces a regression for me when using pbuilder
      0.228.7[2] (a helper to build Debian packages in a chroot and to
      create and update its chroots) when trying to umount /dev/ptmx (inside
      the chroot) on Debian/ unstable (full log and pbuilder configuration
      file[3] attached).
    
      [...]
      Setting up build-essential (12.3) ...
      Processing triggers for libc-bin (2.24-15) ...
      I: unmounting dev/ptmx filesystem
      W: Could not unmount dev/ptmx: umount: /var/cache/pbuilder/build/1340/dev/ptmx: target is busy
              (In some cases useful info about processes that
               use the device is found by lsof(8) or fuser(1).)"
    
    apparently pbuilder tries to unmount the /dev/pts filesystem while still
    holding at least one master node open, which is arguably not very nice,
    but we don't break user space even when fixing other bugs.
    
    So this commit has to be reverted.
    
    I'll try to figure out a way to avoid caching the path to the slave pty
    in the master pty.  The only thing that actually wants that slave pty
    path is the "TIOCGPTPEER" ioctl, and I think we could just recreate the
    path at that time.
    
    Reported-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
    Cc: Eric W Biederman <ebiederm@xmission.com>
    Cc: Christian Brauner <christian.brauner@canonical.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 1fc80ea87c13..284749fb0f6b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -793,7 +793,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	struct tty_struct *tty;
 	struct path *pts_path;
 	struct dentry *dentry;
-	struct vfsmount *mnt;
 	int retval;
 	int index;
 
@@ -806,7 +805,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		return retval;
 
-	fsi = devpts_acquire(filp, &mnt);
+	fsi = devpts_acquire(filp);
 	if (IS_ERR(fsi)) {
 		retval = PTR_ERR(fsi);
 		goto out_free_file;
@@ -850,7 +849,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	pts_path = kmalloc(sizeof(struct path), GFP_KERNEL);
 	if (!pts_path)
 		goto err_release;
-	pts_path->mnt = mnt;
+	pts_path->mnt = filp->f_path.mnt;
 	pts_path->dentry = dentry;
 	path_get(pts_path);
 	tty->link->driver_data = pts_path;
@@ -867,7 +866,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	path_put(pts_path);
 	kfree(pts_path);
 err_release:
-	mntput(mnt);
 	tty_unlock(tty);
 	// This will also put-ref the fsi
 	tty_release(inode, filp);
@@ -876,7 +874,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	devpts_kill_index(fsi, index);
 out_put_fsi:
 	devpts_release(fsi);
-	mntput(mnt);
 out_free_file:
 	tty_free_file(filp);
 	return retval;

commit c8c03f1858331e85d397bacccd34ef409aae993c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 16 17:08:07 2017 -0700

    pty: fix the cached path of the pty slave file descriptor in the master
    
    Christian Brauner reported that if you use the TIOCGPTPEER ioctl() to
    get a slave pty file descriptor, the resulting file descriptor doesn't
    look right in /proc/<pid>/fd/<fd>.  In particular, he wanted to use
    readlink() on /proc/self/fd/<fd> to get the pathname of the slave pty
    (basically implementing "ptsname{_r}()").
    
    The reason for that was that we had generated the wrong 'struct path'
    when we create the pty in ptmx_open().
    
    In particular, the dentry was correct, but the vfsmount pointed to the
    mount of the ptmx node. That _can_ be correct - in case you use
    "/dev/pts/ptmx" to open the master - but usually is not.  The normal
    case is to use /dev/ptmx, which then looks up the pts/ directory, and
    then the vfsmount of the ptmx node is obviously the /dev directory, not
    the /dev/pts/ directory.
    
    We actually did have the right vfsmount available, but in the wrong
    place (it gets looked up in 'devpts_acquire()' when we get a reference
    to the pts filesystem), and so ptmx_open() used the wrong mnt pointer.
    
    The end result of this confusion was that the pty worked fine, but when
    if you did TIOCGPTPEER to get the slave side of the pty, end end result
    would also work, but have that dodgy 'struct path'.
    
    And then when doing "d_path()" on to get the pathname, the vfsmount
    would not match the root of the pts directory, and d_path() would return
    an empty pathname thinking that the entry had escaped a bind mount into
    another mount.
    
    This fixes the problem by making devpts_acquire() return the vfsmount
    for the pts filesystem, allowing ptmx_open() to trivially just use the
    right mount for the pts dentry, and create the proper 'struct path'.
    
    Reported-by: Christian Brauner <christian.brauner@ubuntu.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Eric Biederman <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 284749fb0f6b..1fc80ea87c13 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -793,6 +793,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	struct tty_struct *tty;
 	struct path *pts_path;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	int retval;
 	int index;
 
@@ -805,7 +806,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		return retval;
 
-	fsi = devpts_acquire(filp);
+	fsi = devpts_acquire(filp, &mnt);
 	if (IS_ERR(fsi)) {
 		retval = PTR_ERR(fsi);
 		goto out_free_file;
@@ -849,7 +850,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	pts_path = kmalloc(sizeof(struct path), GFP_KERNEL);
 	if (!pts_path)
 		goto err_release;
-	pts_path->mnt = filp->f_path.mnt;
+	pts_path->mnt = mnt;
 	pts_path->dentry = dentry;
 	path_get(pts_path);
 	tty->link->driver_data = pts_path;
@@ -866,6 +867,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	path_put(pts_path);
 	kfree(pts_path);
 err_release:
+	mntput(mnt);
 	tty_unlock(tty);
 	// This will also put-ref the fsi
 	tty_release(inode, filp);
@@ -874,6 +876,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	devpts_kill_index(fsi, index);
 out_put_fsi:
 	devpts_release(fsi);
+	mntput(mnt);
 out_free_file:
 	tty_free_file(filp);
 	return retval;

commit 6509f3096263ca2714ec938439a832b302a3a65e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 20 22:34:13 2017 +0200

    tty: hide unused pty_get_peer function
    
    TIOCGPTPEER is only used for unix98 PTYs, and we get a warning
    when those are disabled:
    
    drivers/tty/pty.c:466:12: error: 'pty_get_peer' defined but not used [-Werror=unused-function]
    
    This moves the respective functions inside of the existing #ifdef.
    
    Fixes: 54ebbfb16034 ("tty: add TIOCGPTPEER ioctl")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Aleksa Sarai <asarai@suse.de>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d1399aac05a1..284749fb0f6b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -448,48 +448,6 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	return retval;
 }
 
-/**
- *	pty_open_peer - open the peer of a pty
- *	@tty: the peer of the pty being opened
- *
- *	Open the cached dentry in tty->link, providing a safe way for userspace
- *	to get the slave end of a pty (where they have the master fd and cannot
- *	access or trust the mount namespace /dev/pts was mounted inside).
- */
-static struct file *pty_open_peer(struct tty_struct *tty, int flags)
-{
-	if (tty->driver->subtype != PTY_TYPE_MASTER)
-		return ERR_PTR(-EIO);
-	return dentry_open(tty->link->driver_data, flags, current_cred());
-}
-
-static int pty_get_peer(struct tty_struct *tty, int flags)
-{
-	int fd = -1;
-	struct file *filp = NULL;
-	int retval = -EINVAL;
-
-	fd = get_unused_fd_flags(0);
-	if (fd < 0) {
-		retval = fd;
-		goto err;
-	}
-
-	filp = pty_open_peer(tty, flags);
-	if (IS_ERR(filp)) {
-		retval = PTR_ERR(filp);
-		goto err_put;
-	}
-
-	fd_install(fd, filp);
-	return fd;
-
-err_put:
-	put_unused_fd(fd);
-err:
-	return retval;
-}
-
 static void pty_cleanup(struct tty_struct *tty)
 {
 	tty_port_put(tty->port);
@@ -646,9 +604,50 @@ static inline void legacy_pty_init(void) { }
 
 /* Unix98 devices */
 #ifdef CONFIG_UNIX98_PTYS
-
 static struct cdev ptmx_cdev;
 
+/**
+ *	pty_open_peer - open the peer of a pty
+ *	@tty: the peer of the pty being opened
+ *
+ *	Open the cached dentry in tty->link, providing a safe way for userspace
+ *	to get the slave end of a pty (where they have the master fd and cannot
+ *	access or trust the mount namespace /dev/pts was mounted inside).
+ */
+static struct file *pty_open_peer(struct tty_struct *tty, int flags)
+{
+	if (tty->driver->subtype != PTY_TYPE_MASTER)
+		return ERR_PTR(-EIO);
+	return dentry_open(tty->link->driver_data, flags, current_cred());
+}
+
+static int pty_get_peer(struct tty_struct *tty, int flags)
+{
+	int fd = -1;
+	struct file *filp = NULL;
+	int retval = -EINVAL;
+
+	fd = get_unused_fd_flags(0);
+	if (fd < 0) {
+		retval = fd;
+		goto err;
+	}
+
+	filp = pty_open_peer(tty, flags);
+	if (IS_ERR(filp)) {
+		retval = PTR_ERR(filp);
+		goto err_put;
+	}
+
+	fd_install(fd, filp);
+	return fd;
+
+err_put:
+	put_unused_fd(fd);
+err:
+	return retval;
+}
+
 static int pty_unix98_ioctl(struct tty_struct *tty,
 			    unsigned int cmd, unsigned long arg)
 {

commit 54ebbfb1603415d9953c150535850d30609ef077
Author: Aleksa Sarai <asarai@suse.de>
Date:   Sun Jun 4 00:15:15 2017 +1000

    tty: add TIOCGPTPEER ioctl
    
    When opening the slave end of a PTY, it is not possible for userspace to
    safely ensure that /dev/pts/$num is actually a slave (in cases where the
    mount namespace in which devpts was mounted is controlled by an
    untrusted process). In addition, there are several unresolvable
    race conditions if userspace were to attempt to detect attacks through
    stat(2) and other similar methods [in addition it is not clear how
    userspace could detect attacks involving FUSE].
    
    Resolve this by providing an interface for userpace to safely open the
    "peer" end of a PTY file descriptor by using the dentry cached by
    devpts. Since it is not possible to have an open master PTY without
    having its slave exposed in /dev/pts this interface is safe. This
    interface currently does not provide a way to get the master pty (since
    it is not clear whether such an interface is safe or even useful).
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Cc: Valentin Rothberg <vrothberg@suse.com>
    Signed-off-by: Aleksa Sarai <asarai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 2a6bd9ae3f8b..d1399aac05a1 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -24,6 +24,9 @@
 #include <linux/slab.h>
 #include <linux/mutex.h>
 #include <linux/poll.h>
+#include <linux/mount.h>
+#include <linux/file.h>
+#include <linux/ioctl.h>
 
 #undef TTY_DEBUG_HANGUP
 #ifdef TTY_DEBUG_HANGUP
@@ -66,8 +69,13 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 #ifdef CONFIG_UNIX98_PTYS
 		if (tty->driver == ptm_driver) {
 			mutex_lock(&devpts_mutex);
-			if (tty->link->driver_data)
-				devpts_pty_kill(tty->link->driver_data);
+			if (tty->link->driver_data) {
+				struct path *path = tty->link->driver_data;
+
+				devpts_pty_kill(path->dentry);
+				path_put(path);
+				kfree(path);
+			}
 			mutex_unlock(&devpts_mutex);
 		}
 #endif
@@ -440,6 +448,48 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	return retval;
 }
 
+/**
+ *	pty_open_peer - open the peer of a pty
+ *	@tty: the peer of the pty being opened
+ *
+ *	Open the cached dentry in tty->link, providing a safe way for userspace
+ *	to get the slave end of a pty (where they have the master fd and cannot
+ *	access or trust the mount namespace /dev/pts was mounted inside).
+ */
+static struct file *pty_open_peer(struct tty_struct *tty, int flags)
+{
+	if (tty->driver->subtype != PTY_TYPE_MASTER)
+		return ERR_PTR(-EIO);
+	return dentry_open(tty->link->driver_data, flags, current_cred());
+}
+
+static int pty_get_peer(struct tty_struct *tty, int flags)
+{
+	int fd = -1;
+	struct file *filp = NULL;
+	int retval = -EINVAL;
+
+	fd = get_unused_fd_flags(0);
+	if (fd < 0) {
+		retval = fd;
+		goto err;
+	}
+
+	filp = pty_open_peer(tty, flags);
+	if (IS_ERR(filp)) {
+		retval = PTR_ERR(filp);
+		goto err_put;
+	}
+
+	fd_install(fd, filp);
+	return fd;
+
+err_put:
+	put_unused_fd(fd);
+err:
+	return retval;
+}
+
 static void pty_cleanup(struct tty_struct *tty)
 {
 	tty_port_put(tty->port);
@@ -613,6 +663,8 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 		return pty_get_pktmode(tty, (int __user *)arg);
 	case TIOCGPTN: /* Get PT Number */
 		return put_user(tty->index, (unsigned int __user *)arg);
+	case TIOCGPTPEER: /* Open the other end */
+		return pty_get_peer(tty, (int) arg);
 	case TIOCSIG:    /* Send signal to other side of pty */
 		return pty_signal(tty, (int) arg);
 	}
@@ -740,6 +792,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 {
 	struct pts_fs_info *fsi;
 	struct tty_struct *tty;
+	struct path *pts_path;
 	struct dentry *dentry;
 	int retval;
 	int index;
@@ -793,16 +846,26 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		retval = PTR_ERR(dentry);
 		goto err_release;
 	}
-	tty->link->driver_data = dentry;
+	/* We need to cache a fake path for TIOCGPTPEER. */
+	pts_path = kmalloc(sizeof(struct path), GFP_KERNEL);
+	if (!pts_path)
+		goto err_release;
+	pts_path->mnt = filp->f_path.mnt;
+	pts_path->dentry = dentry;
+	path_get(pts_path);
+	tty->link->driver_data = pts_path;
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)
-		goto err_release;
+		goto err_path_put;
 
 	tty_debug_hangup(tty, "opening (count=%d)\n", tty->count);
 
 	tty_unlock(tty);
 	return 0;
+err_path_put:
+	path_put(pts_path);
+	kfree(pts_path);
 err_release:
 	tty_unlock(tty);
 	// This will also put-ref the fsi

commit 5f0f187fd0cc755cfa7d51b50f68a16fca41c813
Author: Aleksa Sarai <asarai@suse.de>
Date:   Sun Jun 4 00:15:14 2017 +1000

    tty: add compat_ioctl callbacks
    
    In order to avoid future diversions between fs/compat_ioctl.c and
    drivers/tty/pty.c, define .compat_ioctl callbacks for the relevant
    tty_operations structs. Since both pty_unix98_ioctl() and
    pty_bsd_ioctl() are compatible between 32-bit and 64-bit userspace no
    special translation is required.
    
    Signed-off-by: Aleksa Sarai <asarai@suse.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 65799575c666..2a6bd9ae3f8b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -481,6 +481,16 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 	return -ENOIOCTLCMD;
 }
 
+static long pty_bsd_compat_ioctl(struct tty_struct *tty,
+				 unsigned int cmd, unsigned long arg)
+{
+	/*
+	 * PTY ioctls don't require any special translation between 32-bit and
+	 * 64-bit userspace, they are already compatible.
+	 */
+	return pty_bsd_ioctl(tty, cmd, arg);
+}
+
 static int legacy_count = CONFIG_LEGACY_PTY_COUNT;
 /*
  * not really modular, but the easiest way to keep compat with existing
@@ -502,6 +512,7 @@ static const struct tty_operations master_pty_ops_bsd = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.ioctl = pty_bsd_ioctl,
+	.compat_ioctl = pty_bsd_compat_ioctl,
 	.cleanup = pty_cleanup,
 	.resize = pty_resize,
 	.remove = pty_remove
@@ -609,6 +620,16 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 	return -ENOIOCTLCMD;
 }
 
+static long pty_unix98_compat_ioctl(struct tty_struct *tty,
+				 unsigned int cmd, unsigned long arg)
+{
+	/*
+	 * PTY ioctls don't require any special translation between 32-bit and
+	 * 64-bit userspace, they are already compatible.
+	 */
+	return pty_unix98_ioctl(tty, cmd, arg);
+}
+
 /**
  *	ptm_unix98_lookup	-	find a pty master
  *	@driver: ptm driver
@@ -681,6 +702,7 @@ static const struct tty_operations ptm_unix98_ops = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.ioctl = pty_unix98_ioctl,
+	.compat_ioctl = pty_unix98_compat_ioctl,
 	.resize = pty_resize,
 	.cleanup = pty_cleanup
 };

commit 77dae6134440420bac334581a3ccee94cee1c054
Author: Wang YanQing <udknight@gmail.com>
Date:   Wed Feb 22 19:37:08 2017 +0800

    tty: pty: Fix ldisc flush after userspace become aware of the data already
    
    While using emacs, cat or others' commands in konsole with recent
    kernels, I have met many times that CTRL-C freeze konsole. After
    konsole freeze I can't type anything, then I have to open a new one,
    it is very annoying.
    
    See bug report:
    https://bugs.kde.org/show_bug.cgi?id=175283
    
    The platform in that bug report is Solaris, but now the pty in linux
    has the same problem or the same behavior as Solaris :)
    
    It has high possibility to trigger the problem follow steps below:
    Note: In my test, BigFile is a text file whose size is bigger than 1G
    1:open konsole
    1:cat BigFile
    2:CTRL-C
    
    After some digging, I find out the reason is that commit 1d1d14da12e7
    ("pty: Fix buffer flush deadlock") changes the behavior of pty_flush_buffer.
    
    Thread A                                 Thread B
    --------                                 --------
    1:n_tty_poll return POLLIN
                                             2:CTRL-C trigger pty_flush_buffer
                                                 tty_buffer_flush
                                                   n_tty_flush_buffer
    3:attempt to check count of chars:
      ioctl(fd, TIOCINQ, &available)
      available is equal to 0
    
    4:read(fd, buffer, avaiable)
      return 0
    
    5:konsole close fd
    
    Yes, I know we could use the same patch included in the BUG report as
    a workaround for linux platform too. But I think the data in ldisc is
    belong to application of another side, we shouldn't clear it when we
    want to flush write buffer of this side in pty_flush_buffer. So I think
    it is better to disable ldisc flush in pty_flush_buffer, because its new
    hehavior bring no benefit except that it mess up the behavior between
    POLLIN, and TIOCINQ or FIONREAD.
    
    Also I find no flush_buffer function in others' tty driver has the
    same behavior as current pty_flush_buffer.
    
    Fixes: 1d1d14da12e7 ("pty: Fix buffer flush deadlock")
    CC: stable@vger.kernel.org # v4.0+
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 66b59a15780d..65799575c666 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -216,16 +216,11 @@ static int pty_signal(struct tty_struct *tty, int sig)
 static void pty_flush_buffer(struct tty_struct *tty)
 {
 	struct tty_struct *to = tty->link;
-	struct tty_ldisc *ld;
 
 	if (!to)
 		return;
 
-	ld = tty_ldisc_ref(to);
-	tty_buffer_flush(to, ld);
-	if (ld)
-		tty_ldisc_deref(ld);
-
+	tty_buffer_flush(to, NULL);
 	if (to->packet) {
 		spin_lock_irq(&tty->ctrl_lock);
 		tty->ctrl_status |= TIOCPKT_FLUSHWRITE;

commit 3f07c0144132e4f59d88055ac8ff3e691a5fa2b8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:30 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/signal.h>
    
    We are going to split <linux/sched/signal.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/signal.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a23fa5ed1d67..66b59a15780d 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -12,7 +12,7 @@
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
 #include <linux/fcntl.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/string.h>
 #include <linux/major.h>
 #include <linux/mm.h>

commit d2ec3f77de8e67b7a3dab3ec827467e0fd797c86
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Sep 8 15:35:59 2016 -0700

    pty: make ptmx file ops read-only after init
    
    The ptmx_fops structure is only changed during init, so mark it as such.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 51e0d32883ba..a23fa5ed1d67 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -800,7 +800,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	return retval;
 }
 
-static struct file_operations ptmx_fops;
+static struct file_operations ptmx_fops __ro_after_init;
 
 static void __init unix98_pty_init(void)
 {

commit 5353ed8deedee9e5acb9f896e9032158f5d998de
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jun 20 15:40:27 2016 +0100

    devpts: fix null pointer dereference on failed memory allocation
    
    An ENOMEM when creating a pair tty in tty_ldisc_setup causes a null
    pointer dereference in devpts_kill_index because tty->link->driver_data
    is NULL.  The oops was triggered with the pty stressor in stress-ng when
    in a low memory condition.
    
    tty_init_dev tries to clean up a tty_ldisc_setup ENOMEM error by calling
    release_tty, however, this ultimately tries to clean up the NULL pair'd
    tty in pty_unix98_remove, triggering the Oops.
    
    Add check to pty_unix98_remove to only clean up fsi if it is not NULL.
    
    Ooops:
    
    [   23.020961] Oops: 0000 [#1] SMP
    [   23.020976] Modules linked in: ppdev snd_hda_codec_generic snd_hda_intel snd_hda_codec parport_pc snd_hda_core snd_hwdep parport snd_pcm input_leds joydev snd_timer serio_raw snd soundcore i2c_piix4 mac_hid ib_iser rdma_cm iw_cm ib_cm ib_core configfs iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi autofs4 btrfs raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear crct10dif_pclmul crc32_pclmul ghash_clmulni_intel aesni_intel qxl aes_x86_64 ttm lrw gf128mul glue_helper ablk_helper drm_kms_helper cryptd syscopyarea sysfillrect psmouse sysimgblt floppy fb_sys_fops drm pata_acpi jitterentropy_rng drbg ansi_cprng
    [   23.020978] CPU: 0 PID: 1452 Comm: stress-ng-pty Not tainted 4.7.0-rc4+ #2
    [   23.020978] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
    [   23.020979] task: ffff88007ba30000 ti: ffff880078ea8000 task.ti: ffff880078ea8000
    [   23.020981] RIP: 0010:[<ffffffff813f11ff>]  [<ffffffff813f11ff>] ida_remove+0x1f/0x120
    [   23.020981] RSP: 0018:ffff880078eabb60  EFLAGS: 00010a03
    [   23.020982] RAX: 4444444444444567 RBX: 0000000000000000 RCX: 000000000000001f
    [   23.020982] RDX: 000000000000014c RSI: 000000000000026f RDI: 0000000000000000
    [   23.020982] RBP: ffff880078eabb70 R08: 0000000000000004 R09: 0000000000000036
    [   23.020983] R10: 000000000000026f R11: 0000000000000000 R12: 000000000000026f
    [   23.020983] R13: 000000000000026f R14: ffff88007c944b40 R15: 000000000000026f
    [   23.020984] FS:  00007f9a2f3cc700(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
    [   23.020984] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   23.020985] CR2: 0000000000000010 CR3: 000000006c81b000 CR4: 00000000001406f0
    [   23.020988] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   23.020988] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [   23.020988] Stack:
    [   23.020989]  0000000000000000 000000000000026f ffff880078eabb90 ffffffff812a5a99
    [   23.020990]  0000000000000000 00000000fffffff4 ffff880078eabba8 ffffffff814f9cbe
    [   23.020991]  ffff88007965c800 ffff880078eabbc8 ffffffff814eef43 fffffffffffffff4
    [   23.020991] Call Trace:
    [   23.021000]  [<ffffffff812a5a99>] devpts_kill_index+0x29/0x50
    [   23.021002]  [<ffffffff814f9cbe>] pty_unix98_remove+0x2e/0x50
    [   23.021006]  [<ffffffff814eef43>] release_tty+0xb3/0x1b0
    [   23.021007]  [<ffffffff814f18d4>] tty_init_dev+0xd4/0x1c0
    [   23.021011]  [<ffffffff814f9fae>] ptmx_open+0xae/0x190
    [   23.021013]  [<ffffffff812254ef>] chrdev_open+0xbf/0x1b0
    [   23.021015]  [<ffffffff8121d973>] do_dentry_open+0x203/0x310
    [   23.021016]  [<ffffffff81225430>] ? cdev_put+0x30/0x30
    [   23.021017]  [<ffffffff8121ee44>] vfs_open+0x54/0x80
    [   23.021018]  [<ffffffff8122b8fc>] ? may_open+0x8c/0x100
    [   23.021019]  [<ffffffff8122f26b>] path_openat+0x2eb/0x1440
    [   23.021020]  [<ffffffff81230534>] ? putname+0x54/0x60
    [   23.021022]  [<ffffffff814f6f97>] ? n_tty_ioctl_helper+0x27/0x100
    [   23.021023]  [<ffffffff81231651>] do_filp_open+0x91/0x100
    [   23.021024]  [<ffffffff81230596>] ? getname_flags+0x56/0x1f0
    [   23.021026]  [<ffffffff8123fc66>] ? __alloc_fd+0x46/0x190
    [   23.021027]  [<ffffffff8121f1e4>] do_sys_open+0x124/0x210
    [   23.021028]  [<ffffffff8121f2ee>] SyS_open+0x1e/0x20
    [   23.021035]  [<ffffffff81845576>] entry_SYSCALL_64_fastpath+0x1e/0xa8
    [   23.021044] Code: 63 28 45 31 e4 eb dd 0f 1f 44 00 00 55 4c 63 d6 48 ba 89 88 88 88 88 88 88 88 4c 89 d0 b9 1f 00 00 00 48 f7 e2 48 89 e5 41 54 53 <8b> 47 10 48 89 fb 8d 3c c5 00 00 00 00 48 c1 ea 09 b8 01 00 00
    [   23.021045] RIP  [<ffffffff813f11ff>] ida_remove+0x1f/0x120
    [   23.021045]  RSP <ffff880078eabb60>
    [   23.021046] CR2: 0000000000000010
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index f856c4544eea..51e0d32883ba 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -667,8 +667,11 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 		fsi = tty->driver_data;
 	else
 		fsi = tty->link->driver_data;
-	devpts_kill_index(fsi, tty->index);
-	devpts_release(fsi);
+
+	if (fsi) {
+		devpts_kill_index(fsi, tty->index);
+		devpts_release(fsi);
+	}
 }
 
 static const struct tty_operations ptm_unix98_ops = {

commit eedf265aa003b4781de24cfed40a655a664457e6
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 2 10:29:47 2016 -0500

    devpts: Make each mount of devpts an independent filesystem.
    
    The /dev/ptmx device node is changed to lookup the directory entry "pts"
    in the same directory as the /dev/ptmx device node was opened in.  If
    there is a "pts" entry and that entry is a devpts filesystem /dev/ptmx
    uses that filesystem.  Otherwise the open of /dev/ptmx fails.
    
    The DEVPTS_MULTIPLE_INSTANCES configuration option is removed, so that
    userspace can now safely depend on each mount of devpts creating a new
    instance of the filesystem.
    
    Each mount of devpts is now a separate and equal filesystem.
    
    Reserved ttys are now available to all instances of devpts where the
    mounter is in the initial mount namespace.
    
    A new vfs helper path_pts is introduced that finds a directory entry
    named "pts" in the directory of the passed in path, and changes the
    passed in path to point to it.  The helper path_pts uses a function
    path_parent_directory that was factored out of follow_dotdot.
    
    In the implementation of devpts:
     - devpts_mnt is killed as it is no longer meaningful if all mounts of
       devpts are equal.
     - pts_sb_from_inode is replaced by just inode->i_sb as all cached
       inodes in the tty layer are now from the devpts filesystem.
     - devpts_add_ref is rolled into the new function devpts_ptmx.  And the
       unnecessary inode hold is removed.
     - devpts_del_ref is renamed devpts_release and reduced to just a
       deacrivate_super.
     - The newinstance mount option continues to be accepted but is now
       ignored.
    
    In devpts_fs.h definitions for when !CONFIG_UNIX98_PTYS are removed as
    they are never used.
    
    Documentation/filesystems/devices.txt is updated to describe the current
    situation.
    
    This has been verified to work properly on openwrt-15.05, centos5,
    centos6, centos7, debian-6.0.2, debian-7.9, debian-8.2, ubuntu-14.04.3,
    ubuntu-15.10, fedora23, magia-5, mint-17.3, opensuse-42.1,
    slackware-14.1, gentoo-20151225 (13.0?), archlinux-2015-12-01.  With the
    caveat that on centos6 and on slackware-14.1 that there wind up being
    two instances of the devpts filesystem mounted on /dev/pts, the lower
    copy does not end up getting used.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Florian Weimer <fw@deneb.enyo.de>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index dd4b8417e7f4..f856c4544eea 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -668,7 +668,7 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 	else
 		fsi = tty->link->driver_data;
 	devpts_kill_index(fsi, tty->index);
-	devpts_put_ref(fsi);
+	devpts_release(fsi);
 }
 
 static const struct tty_operations ptm_unix98_ops = {
@@ -733,10 +733,11 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		return retval;
 
-	fsi = devpts_get_ref(inode, filp);
-	retval = -ENODEV;
-	if (!fsi)
+	fsi = devpts_acquire(filp);
+	if (IS_ERR(fsi)) {
+		retval = PTR_ERR(fsi);
 		goto out_free_file;
+	}
 
 	/* find a device that is not in use. */
 	mutex_lock(&devpts_mutex);
@@ -745,7 +746,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	retval = index;
 	if (index < 0)
-		goto out_put_ref;
+		goto out_put_fsi;
 
 
 	mutex_lock(&tty_mutex);
@@ -789,8 +790,8 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	return retval;
 out:
 	devpts_kill_index(fsi, index);
-out_put_ref:
-	devpts_put_ref(fsi);
+out_put_fsi:
+	devpts_release(fsi);
 out_free_file:
 	tty_free_file(filp);
 	return retval;

commit 10ee08292028d3d22d201a34ba7d24a085818cb3
Merge: 7da4b8b73787 44549e8f5eea
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 9 09:39:13 2016 +0200

    Merge 4.6-rc7 into tty-next
    
    We want the pty fixes in here as well so that patches can build on it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0f40fbbcc34e093255a2b2d70b6b0fb48c3f39aa
Author: Brian Bloniarz <brian.bloniarz@gmail.com>
Date:   Sun Mar 6 13:16:30 2016 -0800

    Fix OpenSSH pty regression on close
    
    OpenSSH expects the (non-blocking) read() of pty master to return
    EAGAIN only if it has received all of the slave-side output after
    it has received SIGCHLD. This used to work on pre-3.12 kernels.
    
    This fix effectively forces non-blocking read() and poll() to
    block for parallel i/o to complete for all ttys. It also unwinds
    these changes:
    
    1) f8747d4a466ab2cafe56112c51b3379f9fdb7a12
       tty: Fix pty master read() after slave closes
    
    2) 52bce7f8d4fc633c9a9d0646eef58ba6ae9a3b73
       pty, n_tty: Simplify input processing on final close
    
    3) 1a48632ffed61352a7810ce089dc5a8bcd505a60
       pty: Fix input race when closing
    
    Inspired by analysis and patch from Marc Aurele La France <tsi@tuyoix.net>
    
    Reported-by: Volth <openssh@volth.com>
    Reported-by: Marc Aurele La France <tsi@tuyoix.net>
    BugLink: https://bugzilla.mindrot.org/show_bug.cgi?id=52
    BugLink: https://bugzilla.mindrot.org/show_bug.cgi?id=2492
    Signed-off-by: Brian Bloniarz <brian.bloniarz@gmail.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a8a292fd564f..ee0e84798399 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -59,7 +59,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	if (!tty->link)
 		return;
 	set_bit(TTY_OTHER_CLOSED, &tty->link->flags);
-	tty_flip_buffer_push(tty->link->port);
+	wake_up_interruptible(&tty->link->read_wait);
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
@@ -247,9 +247,7 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &tty->flags);
-	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */
 	clear_bit(TTY_OTHER_CLOSED, &tty->link->flags);
-	clear_bit(TTY_OTHER_DONE, &tty->link->flags);
 	set_bit(TTY_THROTTLED, &tty->flags);
 	return 0;
 

commit 18900ca65a8553edc608b6c9d518eb31e6c09ba1
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Apr 9 17:06:48 2016 -0700

    tty: Replace TTY_IO_ERROR bit tests with tty_io_error()
    
    Abstract TTY_IO_ERROR status test treewide with tty_io_error().
    NB: tty->flags uses atomic bit ops; replace non-atomic bit test
    with test_bit().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 0058d9fbf931..a8a292fd564f 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -44,7 +44,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	if (tty->driver->subtype == PTY_TYPE_MASTER)
 		WARN_ON(tty->count > 1);
 	else {
-		if (test_bit(TTY_IO_ERROR, &tty->flags))
+		if (tty_io_error(tty))
 			return;
 		if (tty->count > 2)
 			return;

commit 8ead9dd54716d1e05e129959f702fcc1786f82b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 25 20:04:08 2016 -0700

    devpts: more pty driver interface cleanups
    
    This is more prep-work for the upcoming pty changes.  Still just code
    cleanup with no actual semantic changes.
    
    This removes a bunch pointless complexity by just having the slave pty
    side remember the dentry associated with the devpts slave rather than
    the inode.  That allows us to remove all the "look up the dentry" code
    for when we want to remove it again.
    
    Together with moving the tty pointer from "inode->i_private" to
    "dentry->d_fsdata" and getting rid of pointless inode locking, this
    removes about 30 lines of code.  Not only is the end result smaller,
    it's simpler and easier to understand.
    
    The old code, for example, depended on the d_find_alias() to not just
    find the dentry, but also to check that it is still hashed, which in
    turn validated the tty pointer in the inode.
    
    That is a _very_ roundabout way to say "invalidate the cached tty
    pointer when the dentry is removed".
    
    The new code just does
    
            dentry->d_fsdata = NULL;
    
    in devpts_pty_kill() instead, invalidating the tty pointer rather more
    directly and obviously.  Don't do something complex and subtle when the
    obvious straightforward approach will do.
    
    The rest of the patch (ie apart from code deletion and the above tty
    pointer clearing) is just switching the calling convention to pass the
    dentry or file pointer around instead of the inode.
    
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Florian Weimer <fw@deneb.enyo.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 0058d9fbf931..cf0dc51a2690 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -626,7 +626,7 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
  */
 
 static struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,
-		struct inode *ptm_inode, int idx)
+		struct file *file, int idx)
 {
 	/* Master must be open via /dev/ptmx */
 	return ERR_PTR(-EIO);
@@ -642,12 +642,12 @@ static struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,
  */
 
 static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
-		struct inode *pts_inode, int idx)
+		struct file *file, int idx)
 {
 	struct tty_struct *tty;
 
 	mutex_lock(&devpts_mutex);
-	tty = devpts_get_priv(pts_inode);
+	tty = devpts_get_priv(file->f_path.dentry);
 	mutex_unlock(&devpts_mutex);
 	/* Master must be open before slave */
 	if (!tty)
@@ -722,7 +722,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 {
 	struct pts_fs_info *fsi;
 	struct tty_struct *tty;
-	struct inode *slave_inode;
+	struct dentry *dentry;
 	int retval;
 	int index;
 
@@ -769,14 +769,12 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	tty_add_file(tty, filp);
 
-	slave_inode = devpts_pty_new(fsi,
-			MKDEV(UNIX98_PTY_SLAVE_MAJOR, index), index,
-			tty->link);
-	if (IS_ERR(slave_inode)) {
-		retval = PTR_ERR(slave_inode);
+	dentry = devpts_pty_new(fsi, index, tty->link);
+	if (IS_ERR(dentry)) {
+		retval = PTR_ERR(dentry);
 		goto err_release;
 	}
-	tty->link->driver_data = slave_inode;
+	tty->link->driver_data = dentry;
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)

commit 67245ff332064c01b760afa7a384ccda024bfd24
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 16 15:16:07 2016 -0700

    devpts: clean up interface to pty drivers
    
    This gets rid of the horrible notion of having that
    
        struct inode *ptmx_inode
    
    be the linchpin of the interface between the pty code and devpts.
    
    By de-emphasizing the ptmx inode, a lot of things actually get cleaner,
    and we will have a much saner way forward.  In particular, this will
    allow us to associate with any particular devpts instance at open-time,
    and not be artificially tied to one particular ptmx inode.
    
    The patch itself is actually fairly straightforward, and apart from some
    locking and return path cleanups it's pretty mechanical:
    
     - the interfaces that devpts exposes all take "struct pts_fs_info *"
       instead of "struct inode *ptmx_inode" now.
    
       NOTE! The "struct pts_fs_info" thing is a completely opaque structure
       as far as the pty driver is concerned: it's still declared entirely
       internally to devpts. So the pty code can't actually access it in any
       way, just pass it as a "cookie" to the devpts code.
    
     - the "look up the pts fs info" is now a single clear operation, that
       also does the reference count increment on the pts superblock.
    
       So "devpts_add/del_ref()" is gone, and replaced by a "lookup and get
       ref" operation (devpts_get_ref(inode)), along with a "put ref" op
       (devpts_put_ref()).
    
     - the pty master "tty->driver_data" field now contains the pts_fs_info,
       not the ptmx inode.
    
     - because we don't care about the ptmx inode any more as some kind of
       base index, the ref counting can now drop the inode games - it just
       gets the ref on the superblock.
    
     - the pts_fs_info now has a back-pointer to the super_block. That's so
       that we can easily look up the information we actually need. Although
       quite often, the pts fs info was actually all we wanted, and not having
       to look it up based on some magical inode makes things more
       straightforward.
    
    In particular, now that "devpts_get_ref(inode)" operation should really
    be the *only* place we need to look up what devpts instance we're
    associated with, and we do it exactly once, at ptmx_open() time.
    
    The other side of this is that one ptmx node could now be associated
    with multiple different devpts instances - you could have a single
    /dev/ptmx node, and then have multiple mount namespaces with their own
    instances of devpts mounted on /dev/pts/.  And that's all perfectly sane
    in a model where we just look up the pts instance at open time.
    
    This will eventually allow us to get rid of our odd single-vs-multiple
    pts instance model, but this patch in itself changes no semantics, only
    an internal binding model.
    
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Florian Weimer <fw@deneb.enyo.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index e16a49b507ef..0058d9fbf931 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -663,14 +663,14 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 /* this is called once with whichever end is closed last */
 static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
-	struct inode *ptmx_inode;
+	struct pts_fs_info *fsi;
 
 	if (tty->driver->subtype == PTY_TYPE_MASTER)
-		ptmx_inode = tty->driver_data;
+		fsi = tty->driver_data;
 	else
-		ptmx_inode = tty->link->driver_data;
-	devpts_kill_index(ptmx_inode, tty->index);
-	devpts_del_ref(ptmx_inode);
+		fsi = tty->link->driver_data;
+	devpts_kill_index(fsi, tty->index);
+	devpts_put_ref(fsi);
 }
 
 static const struct tty_operations ptm_unix98_ops = {
@@ -720,6 +720,7 @@ static const struct tty_operations pty_unix98_ops = {
 
 static int ptmx_open(struct inode *inode, struct file *filp)
 {
+	struct pts_fs_info *fsi;
 	struct tty_struct *tty;
 	struct inode *slave_inode;
 	int retval;
@@ -734,47 +735,41 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		return retval;
 
+	fsi = devpts_get_ref(inode, filp);
+	retval = -ENODEV;
+	if (!fsi)
+		goto out_free_file;
+
 	/* find a device that is not in use. */
 	mutex_lock(&devpts_mutex);
-	index = devpts_new_index(inode);
-	if (index < 0) {
-		retval = index;
-		mutex_unlock(&devpts_mutex);
-		goto err_file;
-	}
-
+	index = devpts_new_index(fsi);
 	mutex_unlock(&devpts_mutex);
 
-	mutex_lock(&tty_mutex);
-	tty = tty_init_dev(ptm_driver, index);
+	retval = index;
+	if (index < 0)
+		goto out_put_ref;
 
-	if (IS_ERR(tty)) {
-		retval = PTR_ERR(tty);
-		goto out;
-	}
 
+	mutex_lock(&tty_mutex);
+	tty = tty_init_dev(ptm_driver, index);
 	/* The tty returned here is locked so we can safely
 	   drop the mutex */
 	mutex_unlock(&tty_mutex);
 
-	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
-	tty->driver_data = inode;
+	retval = PTR_ERR(tty);
+	if (IS_ERR(tty))
+		goto out;
 
 	/*
-	 * In the case where all references to ptmx inode are dropped and we
-	 * still have /dev/tty opened pointing to the master/slave pair (ptmx
-	 * is closed/released before /dev/tty), we must make sure that the inode
-	 * is still valid when we call the final pty_unix98_shutdown, thus we
-	 * hold an additional reference to the ptmx inode. For the same /dev/tty
-	 * last close case, we also need to make sure the super_block isn't
-	 * destroyed (devpts instance unmounted), before /dev/tty is closed and
-	 * on its release devpts_kill_index is called.
+	 * From here on out, the tty is "live", and the index and
+	 * fsi will be killed/put by the tty_release()
 	 */
-	devpts_add_ref(inode);
+	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
+	tty->driver_data = fsi;
 
 	tty_add_file(tty, filp);
 
-	slave_inode = devpts_pty_new(inode,
+	slave_inode = devpts_pty_new(fsi,
 			MKDEV(UNIX98_PTY_SLAVE_MAJOR, index), index,
 			tty->link);
 	if (IS_ERR(slave_inode)) {
@@ -793,12 +788,14 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	return 0;
 err_release:
 	tty_unlock(tty);
+	// This will also put-ref the fsi
 	tty_release(inode, filp);
 	return retval;
 out:
-	mutex_unlock(&tty_mutex);
-	devpts_kill_index(inode, index);
-err_file:
+	devpts_kill_index(fsi, index);
+out_put_ref:
+	devpts_put_ref(fsi);
+out_free_file:
 	tty_free_file(filp);
 	return retval;
 }

commit 249f3c4fe4fdef159d3f9b3f7a6c41a92103c860
Merge: 54573c4a073f 18558cae0272
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Feb 14 14:36:04 2016 -0800

    Merge 4.5-rc4 into tty-next
    
    We want the fixes in here, and this resolves a merge error in tty_io.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f55c718c290616889c04946864a13ef30f64929
Author: Herton R. Krzesinski <herton@redhat.com>
Date:   Thu Jan 14 17:56:58 2016 -0200

    pty: make sure super_block is still valid in final /dev/tty close
    
    Considering current pty code and multiple devpts instances, it's possible
    to umount a devpts file system while a program still has /dev/tty opened
    pointing to a previosuly closed pty pair in that instance. In the case all
    ptmx and pts/N files are closed, umount can be done. If the program closes
    /dev/tty after umount is done, devpts_kill_index will use now an invalid
    super_block, which was already destroyed in the umount operation after
    running ->kill_sb. This is another "use after free" type of issue, but now
    related to the allocated super_block instance.
    
    To avoid the problem (warning at ida_remove and potential crashes) for
    this specific case, I added two functions in devpts which grabs additional
    references to the super_block, which pty code now uses so it makes sure
    the super block structure is still valid until pty shutdown is done.
    I also moved the additional inode references to the same functions, which
    also covered similar case with inode being freed before /dev/tty final
    close/shutdown.
    
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>
    Cc: stable@vger.kernel.org # 2.6.29+
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 3b5cde833ee5..2348fa613707 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -688,7 +688,7 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 	else
 		ptmx_inode = tty->link->driver_data;
 	devpts_kill_index(ptmx_inode, tty->index);
-	iput(ptmx_inode); /* drop reference we acquired at ptmx_open */
+	devpts_del_ref(ptmx_inode);
 }
 
 static const struct tty_operations ptm_unix98_ops = {
@@ -785,9 +785,12 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	 * still have /dev/tty opened pointing to the master/slave pair (ptmx
 	 * is closed/released before /dev/tty), we must make sure that the inode
 	 * is still valid when we call the final pty_unix98_shutdown, thus we
-	 * hold an additional reference to the ptmx inode
+	 * hold an additional reference to the ptmx inode. For the same /dev/tty
+	 * last close case, we also need to make sure the super_block isn't
+	 * destroyed (devpts instance unmounted), before /dev/tty is closed and
+	 * on its release devpts_kill_index is called.
 	 */
-	ihold(inode);
+	devpts_add_ref(inode);
 
 	tty_add_file(tty, filp);
 

commit 2831c89f42dcde440cfdccb9fee9f42d54bbc1ef
Author: Herton R. Krzesinski <herton@redhat.com>
Date:   Mon Jan 11 12:07:43 2016 -0200

    pty: fix possible use after free of tty->driver_data
    
    This change fixes a bug for a corner case where we have the the last
    release from a pty master/slave coming from a previously opened /dev/tty
    file. When this happens, the tty->driver_data can be stale, due to all
    ptmx or pts/N files having already been closed before (and thus the inode
    related to these files, which tty->driver_data points to, being already
    freed/destroyed).
    
    The fix here is to keep a reference on the opened master ptmx inode.
    We maintain the inode referenced until the final pty_unix98_shutdown,
    and only pass this inode to devpts_kill_index.
    
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>
    Cc: <stable@vger.kernel.org> # 2.6.29+
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b3110040164a..3b5cde833ee5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -681,7 +681,14 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 /* this is called once with whichever end is closed last */
 static void pty_unix98_shutdown(struct tty_struct *tty)
 {
-	devpts_kill_index(tty->driver_data, tty->index);
+	struct inode *ptmx_inode;
+
+	if (tty->driver->subtype == PTY_TYPE_MASTER)
+		ptmx_inode = tty->driver_data;
+	else
+		ptmx_inode = tty->link->driver_data;
+	devpts_kill_index(ptmx_inode, tty->index);
+	iput(ptmx_inode); /* drop reference we acquired at ptmx_open */
 }
 
 static const struct tty_operations ptm_unix98_ops = {
@@ -773,6 +780,15 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 	tty->driver_data = inode;
 
+	/*
+	 * In the case where all references to ptmx inode are dropped and we
+	 * still have /dev/tty opened pointing to the master/slave pair (ptmx
+	 * is closed/released before /dev/tty), we must make sure that the inode
+	 * is still valid when we call the final pty_unix98_shutdown, thus we
+	 * hold an additional reference to the ptmx inode
+	 */
+	ihold(inode);
+
 	tty_add_file(tty, filp);
 
 	slave_inode = devpts_pty_new(inode,

commit 9db276f8f02145068d8c04614bc28c2a4532a8c7
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jan 10 20:36:15 2016 -0800

    tty: Use termios c_*flag macros
    
    Expressions of the form "tty->termios.c_*flag & FLAG"
    are more clearly expressed with the termios flags macros,
    I_FLAG(), C_FLAG(), O_FLAG(), and L_FLAG().
    
    Convert treewide.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index be5020d567ae..78170e7aa3a3 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -263,8 +263,7 @@ static void pty_set_termios(struct tty_struct *tty,
 {
 	/* See if packet mode change of state. */
 	if (tty->link && tty->link->packet) {
-		int extproc = (old_termios->c_lflag & EXTPROC) |
-				(tty->termios.c_lflag & EXTPROC);
+		int extproc = (old_termios->c_lflag & EXTPROC) | L_EXTPROC(tty);
 		int old_flow = ((old_termios->c_iflag & IXON) &&
 				(old_termios->c_cc[VSTOP] == '\023') &&
 				(old_termios->c_cc[VSTART] == '\021'));

commit c1e33af1ed552258405f2e5a72509af039c0441c
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 9 21:13:50 2016 -0800

    pty: Remove pty_unix98_shutdown()
    
    The tty core invokes the optional driver shutdown() just before
    the optional driver remove() (shutdown() has access to the termios
    and remove() does not). Because pty drivers must prevent the default
    remove() action, the Unix98 pty drivers define a dummy remove() function.
    
    Instead, release the slave index in the remove() method and delete the
    optional shutdown() method.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7e885a226f88..be5020d567ae 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -656,20 +656,13 @@ static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
 	return tty;
 }
 
-/* We have no need to install and remove our tty objects as devpts does all
-   the work for us */
-
 static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 {
 	return pty_common_install(driver, tty, false);
 }
 
-static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
-{
-}
-
 /* this is called once with whichever end is closed last */
-static void pty_unix98_shutdown(struct tty_struct *tty)
+static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
 	devpts_kill_index(tty->driver_data, tty->index);
 }
@@ -687,7 +680,6 @@ static const struct tty_operations ptm_unix98_ops = {
 	.unthrottle = pty_unthrottle,
 	.ioctl = pty_unix98_ioctl,
 	.resize = pty_resize,
-	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup
 };
 
@@ -705,7 +697,6 @@ static const struct tty_operations pty_unix98_ops = {
 	.set_termios = pty_set_termios,
 	.start = pty_start,
 	.stop = pty_stop,
-	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup,
 };
 

commit a3123fd0a4a5f9d71afa0ffa82e2086281d81822
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 9 21:13:48 2016 -0800

    tty: Fix tty_init_termios() declaration
    
    tty_init_termios() never returns an error; re-declare as void. Remove
    unnecessary error handling from callers. Remove extern declarations
    of tty_free_termios() and free_tty_struct() and re-declare in file
    scope.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 8cbe802bff1d..7e885a226f88 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -406,13 +406,8 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	if (legacy) {
 		/* We always use new tty termios data so we can do this
 		   the easy way .. */
-		retval = tty_init_termios(tty);
-		if (retval)
-			goto err_free_tty;
-
-		retval = tty_init_termios(o_tty);
-		if (retval)
-			goto err_free_termios;
+		tty_init_termios(tty);
+		tty_init_termios(o_tty);
 
 		driver->other->ttys[idx] = o_tty;
 		driver->ttys[idx] = tty;
@@ -444,11 +439,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	tty->count++;
 	o_tty->count++;
 	return 0;
-err_free_termios:
-	if (legacy)
-		tty_free_termios(tty);
-err_free_tty:
-	free_tty_struct(o_tty);
+
 err_put_module:
 	module_put(driver->other->owner);
 err:

commit c8b710b3e4348119924051551b836c94835331b1
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 9 21:13:46 2016 -0800

    tty: Fix ldisc leak in failed tty_init_dev()
    
    release_tty() leaks the ldisc instance when called directly (rather
    than when releasing the file descriptor from tty_release()).
    
    Since tty_ldisc_release() clears tty->ldisc, releasing the ldisc
    instance at tty teardown if tty->ldisc is non-null is not in danger
    of double-releasing the ldisc.
    
    Remove deinitialize_tty_struct() now that free_tty_struct() always
    performs the tty_ldisc_deinit().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b3110040164a..8cbe802bff1d 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -408,7 +408,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		   the easy way .. */
 		retval = tty_init_termios(tty);
 		if (retval)
-			goto err_deinit_tty;
+			goto err_free_tty;
 
 		retval = tty_init_termios(o_tty);
 		if (retval)
@@ -447,8 +447,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 err_free_termios:
 	if (legacy)
 		tty_free_termios(tty);
-err_deinit_tty:
-	deinitialize_tty_struct(o_tty);
+err_free_tty:
 	free_tty_struct(o_tty);
 err_put_module:
 	module_put(driver->other->owner);

commit d435cefe9cbc9308cac8d4b19069a572e2bd1558
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Nov 8 13:01:19 2015 -0500

    tty: Remove __func__ from tty_debug() macro
    
    Now that tty_debug() macro uses pr_debug(), the function name can
    be printed when using dynamic debug; printing the function name within
    the format string is redundant.
    
    Remove the __func__ parameter and print specifier from the format string.
    Add context to messages for when the function name is not printed by
    dynamic debug, or when dynamic debug is not enabled.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a45660f62db5..b3110040164a 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -788,7 +788,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_debug_hangup(tty, "(tty count=%d)\n", tty->count);
+	tty_debug_hangup(tty, "opening (count=%d)\n", tty->count);
 
 	tty_unlock(tty);
 	return 0;

commit 7154988fec43fe2ed986f3b7dd5b43171fab64d6
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Aug 19 17:48:05 2015 -0400

    drivers/tty: make pty.c slightly more explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    drivers/tty/Kconfig:config LEGACY_PTYS
    drivers/tty/Kconfig:    bool "Legacy (BSD) PTY support"
    
    ...and:
    
    drivers/tty/Kconfig:config UNIX98_PTYS
    drivers/tty/Kconfig:    bool "Unix98 PTY support" if EXPERT
    
    combined with this:
    
    obj-$(CONFIG_LEGACY_PTYS)       += pty.o
    obj-$(CONFIG_UNIX98_PTYS)       += pty.o
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the traces of modularity we can so that when reading the
    driver there is less doubt it is builtin-only.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    We don't delete the module.h include since other parts of the file are
    using content from there.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4d5937c185c1..a45660f62db5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -7,7 +7,6 @@
  */
 
 #include <linux/module.h>
-
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/tty.h>
@@ -501,6 +500,10 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 }
 
 static int legacy_count = CONFIG_LEGACY_PTY_COUNT;
+/*
+ * not really modular, but the easiest way to keep compat with existing
+ * bootargs behaviour is to continue using module_param here.
+ */
 module_param(legacy_count, int, 0);
 
 /*
@@ -877,4 +880,4 @@ static int __init pty_init(void)
 	unix98_pty_init();
 	return 0;
 }
-module_init(pty_init);
+device_initcall(pty_init);

commit d684779335856d8177514b42a801d46088d897b0
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jul 12 22:49:13 2015 -0400

    pty: Add debug message for ptmx open
    
    Opens of /dev/ptmx don't use tty_open() so debug messages are
    not printed for those opens; print a debug message with the
    open count (which must always be 1) if TTY_DEBUG_HANGUP is defined.
    
    NB: Each tty core source file undefs support for debug messages.
    The relevant source file must be patched/edited to enable these
    messages.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4d5e8409769c..4d5937c185c1 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -26,6 +26,12 @@
 #include <linux/mutex.h>
 #include <linux/poll.h>
 
+#undef TTY_DEBUG_HANGUP
+#ifdef TTY_DEBUG_HANGUP
+# define tty_debug_hangup(tty, f, args...)	tty_debug(tty, f, ##args)
+#else
+# define tty_debug_hangup(tty, f, args...)	do {} while (0)
+#endif
 
 #ifdef CONFIG_UNIX98_PTYS
 static struct tty_driver *ptm_driver;
@@ -779,6 +785,8 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
+	tty_debug_hangup(tty, "(tty count=%d)\n", tty->count);
+
 	tty_unlock(tty);
 	return 0;
 err_release:

commit 1a48632ffed61352a7810ce089dc5a8bcd505a60
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Apr 13 13:24:34 2015 -0400

    pty: Fix input race when closing
    
    A read() from a pty master may mistakenly indicate EOF (errno == -EIO)
    after the pty slave has closed, even though input data remains to be read.
    For example,
    
           pty slave       |        input worker        |    pty master
                           |                            |
                           |                            |   n_tty_read()
    pty_write()            |                            |     input avail? no
      add data             |                            |     sleep
      schedule worker  --->|                            |     .
                           |---> flush_to_ldisc()       |     .
    pty_close()            |       fill read buffer     |     .
      wait for worker      |       wakeup reader    --->|     .
                           |       read buffer full?    |---> input avail ? yes
                           |<---   yes - exit worker    |     copy 4096 bytes to user
      TTY_OTHER_CLOSED <---|                            |<--- kick worker
                           |                            |
    
                                    **** New read() before worker starts ****
    
                           |                            |   n_tty_read()
                           |                            |     input avail? no
                           |                            |     TTY_OTHER_CLOSED? yes
                           |                            |     return -EIO
    
    Several conditions are required to trigger this race:
    1. the ldisc read buffer must become full so the input worker exits
    2. the read() count parameter must be >= 4096 so the ldisc read buffer
       is empty
    3. the subsequent read() occurs before the kicked worker has processed
       more input
    
    However, the underlying cause of the race is that data is pipelined, while
    tty state is not; ie., data already written by the pty slave end is not
    yet visible to the pty master end, but state changes by the pty slave end
    are visible to the pty master end immediately.
    
    Pipeline the TTY_OTHER_CLOSED state through input worker to the reader.
    1. Introduce TTY_OTHER_DONE which is set by the input worker when
       TTY_OTHER_CLOSED is set and either the input buffers are flushed or
       input processing has completed. Readers/polls are woken when
       TTY_OTHER_DONE is set.
    2. Reader/poll checks TTY_OTHER_DONE instead of TTY_OTHER_CLOSED.
    3. A new input worker is started from pty_close() after setting
       TTY_OTHER_CLOSED, which ensures the TTY_OTHER_DONE state will be
       set if the last input worker is already finished (or just about to
       exit).
    
    Remove tty_flush_to_ldisc(); no in-tree callers.
    
    Fixes: 52bce7f8d4fc ("pty, n_tty: Simplify input processing on final close")
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=96311
    BugLink: http://bugs.launchpad.net/bugs/1429756
    Cc: <stable@vger.kernel.org> # 3.19+
    Reported-by: Andy Whitcroft <apw@canonical.com>
    Reported-by: H.J. Lu <hjl.tools@gmail.com>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index e72ee629cead..4d5e8409769c 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -53,9 +53,8 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
-	tty_flush_to_ldisc(tty->link);
 	set_bit(TTY_OTHER_CLOSED, &tty->link->flags);
-	wake_up_interruptible(&tty->link->read_wait);
+	tty_flip_buffer_push(tty->link->port);
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
@@ -243,7 +242,9 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &tty->flags);
+	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */
 	clear_bit(TTY_OTHER_CLOSED, &tty->link->flags);
+	clear_bit(TTY_OTHER_DONE, &tty->link->flags);
 	set_bit(TTY_THROTTLED, &tty->flags);
 	return 0;
 

commit d2b6f44779d3be22d32a5697bd30b59367fd2b33
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 17 15:42:06 2015 -0500

    n_tty: Fix signal handling flushes
    
    BRKINT and ISIG requires input and output flush when a signal char
    is received. However, the order of operations is significant since
    parallel i/o may be ongoing.
    
    Merge the signal handling for BRKINT with ISIG handling.
    
    Process the signal first. This ensures any ongoing i/o is aborted;
    without this, a waiting writer may continue writing after the flush
    occurs and after the signal char has been echoed.
    
    Write lock the termios_rwsem, which excludes parallel writers from
    pushing new i/o until after the output buffers are flushed; claiming
    the write lock is necessary anyway to exclude parallel readers while
    the read buffer is flushed.
    
    Subclass the termios_rwsem for ptys since the slave pty performing
    the flush may appear to reorder the termios_rwsem->tty buffer lock
    lock order; adding annotation clarifies that
      slave tty_buffer lock-> slave termios_rwsem -> master tty_buffer lock
    is a valid lock order.
    
    Flush the echo buffer. In this context, the echo buffer is 'output'.
    Otherwise, the output will appear discontinuous because the output buffer
    was cleared which contains older output than the echo buffer.
    
    Open-code the read buffer flush since the input worker does not need
    kicking (this is the input worker).
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 0e273158edac..e72ee629cead 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -395,6 +395,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		goto err_put_module;
 
 	tty_set_lock_subclass(o_tty);
+	lockdep_set_subclass(&o_tty->termios_rwsem, TTY_LOCK_SLAVE);
 
 	if (legacy) {
 		/* We always use new tty termios data so we can do this

commit 1d1d14da12e79a6c05fbe1a975401f0f56c93316
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 17 15:42:05 2015 -0500

    pty: Fix buffer flush deadlock
    
    The pty driver does not clear its write buffer when commanded.
    This is to avoid an apparent deadlock between parallel flushes from
    both pty ends; specifically when handling either BRK or INTR input.
    However, parallel flushes from this source is not possible since
    the pty master can never be set to BRKINT or ISIG. Parallel flushes
    from other sources are possible but these do not threaten deadlocks.
    
    Annotate the tty buffer mutex for lockdep to represent the nested
    tty_buffer locking which occurs when the pty slave is processing input
    (its buffer mutex held) and receives INTR or BRK and acquires the
    linked tty buffer mutex via tty_buffer_flush().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index f882ac81b93a..0e273158edac 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -212,10 +212,16 @@ static int pty_signal(struct tty_struct *tty, int sig)
 static void pty_flush_buffer(struct tty_struct *tty)
 {
 	struct tty_struct *to = tty->link;
+	struct tty_ldisc *ld;
 
 	if (!to)
 		return;
-	/* tty_buffer_flush(to); FIXME */
+
+	ld = tty_ldisc_ref(to);
+	tty_buffer_flush(to, ld);
+	if (ld)
+		tty_ldisc_deref(ld);
+
 	if (to->packet) {
 		spin_lock_irq(&tty->ctrl_lock);
 		tty->ctrl_status |= TIOCPKT_FLUSHWRITE;
@@ -425,6 +431,8 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	tty->port = ports[1];
 	o_tty->port->itty = o_tty;
 
+	tty_buffer_set_lock_subclass(o_tty->port);
+
 	tty_driver_kref_get(driver);
 	tty->count++;
 	o_tty->count++;

commit c81622ac4282b0183e738e192c91fabe4a782715
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Fri Jan 16 15:22:14 2015 -0500

    pty: Fix overlimit memory use
    
    The pty_space() computation is broken; the space already consumed
    in the tty buffer is not accounted for.
    
    Use tty_buffer_set_limit(), which enforces the limit automatically.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 6e1f1505f04e..f882ac81b93a 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -87,19 +87,6 @@ static void pty_unthrottle(struct tty_struct *tty)
 	set_bit(TTY_THROTTLED, &tty->flags);
 }
 
-/**
- *	pty_space	-	report space left for writing
- *	@to: tty we are writing into
- *
- *	Limit the buffer space used by ptys to 8k.
- */
-
-static int pty_space(struct tty_struct *to)
-{
-	int n = tty_buffer_space_avail(to->port);
-	return min(n, 8192);
-}
-
 /**
  *	pty_write		-	write to a pty
  *	@tty: the tty we write from
@@ -141,7 +128,7 @@ static int pty_write_room(struct tty_struct *tty)
 {
 	if (tty->stopped)
 		return 0;
-	return pty_space(tty->link);
+	return tty_buffer_space_avail(tty->link->port);
 }
 
 /**
@@ -432,6 +419,8 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	o_tty->link = tty;
 	tty_port_init(ports[0]);
 	tty_port_init(ports[1]);
+	tty_buffer_set_limit(ports[0], 8192);
+	tty_buffer_set_limit(ports[1], 8192);
 	o_tty->port = ports[0];
 	tty->port = ports[1];
 	o_tty->port->itty = o_tty;

commit 37480a05685ed5b8e1b9bf5e5c53b5810258b149
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Jan 19 13:05:03 2015 -0500

    tty: Prevent untrappable signals from malicious program
    
    Commit 26df6d13406d1a5 ("tty: Add EXTPROC support for LINEMODE")
    allows a process which has opened a pty master to send _any_ signal
    to the process group of the pty slave. Although potentially
    exploitable by a malicious program running a setuid program on
    a pty slave, it's unknown if this exploit currently exists.
    
    Limit to signals actually used.
    
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Howard Chu <hyc@symas.com>
    Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org> # 2.6.36+
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a9d256d6e909..6e1f1505f04e 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -210,6 +210,9 @@ static int pty_signal(struct tty_struct *tty, int sig)
 {
 	struct pid *pgrp;
 
+	if (sig != SIGINT && sig != SIGQUIT && sig != SIGTSTP)
+		return -EINVAL;
+
 	if (tty->link) {
 		pgrp = tty_get_pgrp(tty->link);
 		if (pgrp)

commit 52bce7f8d4fc633c9a9d0646eef58ba6ae9a3b73
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Nov 5 12:13:05 2014 -0500

    pty, n_tty: Simplify input processing on final close
    
    When releasing one end of a pty pair, that end may just have written
    to the other, which the input processing worker, flush_to_ldisc(), is
    still working on but has not completed the copy to the other end's
    read buffer. So input may not appear to be available to a waiting
    reader but yet TTY_OTHER_CLOSED is now observed. The n_tty line
    discipline has worked around this by waiting for input processing
    to complete and then re-checking if input is available before
    exiting with -EIO.
    
    Since the tty/ldisc lock reordering, the wait for input processing
    to complete can now occur during final close before setting
    TTY_OTHER_CLOSED. In this way, a waiting reader is guaranteed to
    see input available (if any) before observing TTY_OTHER_CLOSED.
    
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index bee9776730fd..a9d256d6e909 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -53,6 +53,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
+	tty_flush_to_ldisc(tty->link);
 	set_bit(TTY_OTHER_CLOSED, &tty->link->flags);
 	wake_up_interruptible(&tty->link->read_wait);
 	wake_up_interruptible(&tty->link->write_wait);

commit 1bb954153aa97702db4363c6746794d097d9c707
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Nov 5 12:13:04 2014 -0500

    pty: Don't drop pty master tty lock to hangup slave
    
    With the revised tty lock order and lockdep annotation, claiming
    the pty slave lock is now safe while still holding the pty master lock.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 11db7dc8676b..bee9776730fd 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -66,9 +66,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 			mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock(tty);
 		tty_vhangup(tty->link);
-		tty_lock(tty);
 	}
 }
 

commit 2febdb632bb96235b94b8fccaf882a78f8f4b2bb
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Nov 5 12:13:02 2014 -0500

    tty: Preset lock subclass for nested tty locks
    
    Eliminate the requirement of specifying the tty lock nesting at
    lock time; instead, set the lock subclass for slave ptys at pty
    install (normal ttys and master ptys use subclass 0).
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index bdb8fd1a2026..11db7dc8676b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -399,6 +399,8 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	if (!o_tty)
 		goto err_put_module;
 
+	tty_set_lock_subclass(o_tty);
+
 	if (legacy) {
 		/* We always use new tty termios data so we can do this
 		   the easy way .. */

commit 55199ea3bd2e53007715d544fb9094cbbdda1597
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Nov 5 12:12:49 2014 -0500

    pty: Always return -EIO if slave BSD pty opened first
    
    Opening the slave BSD pty first already returns -EIO from the slave
    pty_open(), which in turn causes the newly installed tty pair to be
    released before returning from tty_open(). However, this can also
    cause a parallel master BSD pty open to fail because the pty pair
    destruction may already been taking place in tty_release().
    
    Failing at driver->install() if the slave pty is opened first ensures
    that a pty master open cannot fail, because the driver tables will
    not have been updated so tty_driver_lookup_tty() won't find the
    master pty (and attempt to "re-open" it).
    
    In turn, this guarantees that any tty with a tty->count == 0 is
    in final close (rather than never opened).
    
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7a1a53819e22..bdb8fd1a2026 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -383,6 +383,10 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	int idx = tty->index;
 	int retval = -ENOMEM;
 
+	/* Opening the slave first has always returned -EIO */
+	if (driver->subtype != PTY_TYPE_MASTER)
+		return -EIO;
+
 	ports[0] = kmalloc(sizeof **ports, GFP_KERNEL);
 	ports[1] = kmalloc(sizeof **ports, GFP_KERNEL);
 	if (!ports[0] || !ports[1])
@@ -419,8 +423,6 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	 * Everything allocated ... set up the o_tty structure.
 	 */
 	tty_driver_kref_get(driver->other);
-	if (driver->subtype == PTY_TYPE_MASTER)
-		o_tty->count++;
 	/* Establish the links in both directions */
 	tty->link   = o_tty;
 	o_tty->link = tty;
@@ -432,6 +434,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 
 	tty_driver_kref_get(driver);
 	tty->count++;
+	o_tty->count++;
 	return 0;
 err_free_termios:
 	if (legacy)

commit 4ed60fc257185dbb0daea7cd3e4289d1658b11f6
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:28 2014 -0400

    pty: Hold ctrl_lock for packet mode updates
    
    Updates to the packet mode enable require holding the ctrl_lock;
    the serialization prevents corruption of adjacent fields.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index bcec4c71a408..7a1a53819e22 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,7 +47,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	set_bit(TTY_IO_ERROR, &tty->flags);
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
+	spin_lock_irq(&tty->ctrl_lock);
 	tty->packet = 0;
+	spin_unlock_irq(&tty->ctrl_lock);
 	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;

commit 2622d73e51acfe1dbeb21bf2299066bdead85163
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:27 2014 -0400

    pty: Fix packet mode setting race
    
    Because pty_set_pktmode() does not claim the slave's ctrl_lock
    to clear ->ctrl_status (to avoid unnecessary lock nesting),
    pty_set_pktmode() may accidentally erase new ->ctrl_status updates.
    For example,
    
    CPU 0                             | CPU 1
    pty_set_pktmode()                 | pty_start()
      spin_lock(master's ctrl_lock)   |
      tty->packet = 1                 |
                                      |   if (tty->link->packet)
                                      |     spin_lock(slave's ctrl_lock)
                                      |     tty->ctrl_status = TIOCPKT_START
      tty->link->ctrl_status = 0      |
    
    Ensure the clear of ->ctrl_status occurs before packet mode is set
    (and observable on another cpu).
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index e554393d5551..bcec4c71a408 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -186,8 +186,9 @@ static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
 	spin_lock_irq(&tty->ctrl_lock);
 	if (pktmode) {
 		if (!tty->packet) {
-			tty->packet = 1;
 			tty->link->ctrl_status = 0;
+			smp_mb();
+			tty->packet = 1;
 		}
 	} else
 		tty->packet = 0;

commit 54e8e5fcaae109f0303f52efb24f29bfac79ca86
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:26 2014 -0400

    pty: Don't claim slave's ctrl_lock for master's packet mode
    
    The slave's ctrl_lock serializes updates to the ctrl_status field
    only, whereas the master's ctrl_lock serializes updates to the
    packet mode enable (ie., the master does not have ctrl_status and
    the slave does not have packet mode). Thus, claiming the slave's
    ctrl_lock to access ->packet is useless.
    
    Unlocked reads of ->packet are already smp-safe.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 29b5eeb01856..e554393d5551 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -339,26 +339,26 @@ static void pty_start(struct tty_struct *tty)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&tty->ctrl_lock, flags);
 	if (tty->link && tty->link->packet) {
+		spin_lock_irqsave(&tty->ctrl_lock, flags);
 		tty->ctrl_status &= ~TIOCPKT_STOP;
 		tty->ctrl_status |= TIOCPKT_START;
+		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
 		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
 	}
-	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
 }
 
 static void pty_stop(struct tty_struct *tty)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&tty->ctrl_lock, flags);
 	if (tty->link && tty->link->packet) {
+		spin_lock_irqsave(&tty->ctrl_lock, flags);
 		tty->ctrl_status &= ~TIOCPKT_START;
 		tty->ctrl_status |= TIOCPKT_STOP;
+		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
 		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
 	}
-	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
 }
 
 /**

commit 6054c16e80318d32ee084a0f5620a863ae8cea33
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:25 2014 -0400

    tty: Use spin_lock_irq() for ctrl_lock when interrupts enabled
    
    Interrupts are enabled in the n_tty_read() loop, ioctl(TIOCPKT)
    and pty driver flush_buffer() routine; no need to save and restore
    local interrupt state.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 394374789292..29b5eeb01856 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -178,13 +178,12 @@ static int pty_get_lock(struct tty_struct *tty, int __user *arg)
 /* Set the packet mode on a pty */
 static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
 {
-	unsigned long flags;
 	int pktmode;
 
 	if (get_user(pktmode, arg))
 		return -EFAULT;
 
-	spin_lock_irqsave(&tty->ctrl_lock, flags);
+	spin_lock_irq(&tty->ctrl_lock);
 	if (pktmode) {
 		if (!tty->packet) {
 			tty->packet = 1;
@@ -192,7 +191,7 @@ static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
 		}
 	} else
 		tty->packet = 0;
-	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+	spin_unlock_irq(&tty->ctrl_lock);
 
 	return 0;
 }
@@ -221,16 +220,15 @@ static int pty_signal(struct tty_struct *tty, int sig)
 static void pty_flush_buffer(struct tty_struct *tty)
 {
 	struct tty_struct *to = tty->link;
-	unsigned long flags;
 
 	if (!to)
 		return;
 	/* tty_buffer_flush(to); FIXME */
 	if (to->packet) {
-		spin_lock_irqsave(&tty->ctrl_lock, flags);
+		spin_lock_irq(&tty->ctrl_lock);
 		tty->ctrl_status |= TIOCPKT_FLUSHWRITE;
 		wake_up_interruptible(&to->read_wait);
-		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+		spin_unlock_irq(&tty->ctrl_lock);
 	}
 }
 

commit 4d8c1dff6a8666a2e18a7d5954c2156be0d5b152
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:24 2014 -0400

    pty: Use spin_lock_irq() for pty_set_termios()
    
    The tty driver's set_termios() method is called with interrupts
    enabled; there is no need to save and restore the local interrupt state.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7f612c524224..394374789292 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -259,8 +259,6 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 static void pty_set_termios(struct tty_struct *tty,
 					struct ktermios *old_termios)
 {
-	unsigned long flags;
-
 	/* See if packet mode change of state. */
 	if (tty->link && tty->link->packet) {
 		int extproc = (old_termios->c_lflag & EXTPROC) |
@@ -272,7 +270,7 @@ static void pty_set_termios(struct tty_struct *tty,
 				STOP_CHAR(tty) == '\023' &&
 				START_CHAR(tty) == '\021');
 		if ((old_flow != new_flow) || extproc) {
-			spin_lock_irqsave(&tty->ctrl_lock, flags);
+			spin_lock_irq(&tty->ctrl_lock);
 			if (old_flow != new_flow) {
 				tty->ctrl_status &= ~(TIOCPKT_DOSTOP | TIOCPKT_NOSTOP);
 				if (new_flow)
@@ -282,7 +280,7 @@ static void pty_set_termios(struct tty_struct *tty,
 			}
 			if (extproc)
 				tty->ctrl_status |= TIOCPKT_IOCTL;
-			spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+			spin_unlock_irq(&tty->ctrl_lock);
 			wake_up_interruptible(&tty->link->read_wait);
 		}
 	}

commit dbfcd851a9ee0bf6952e538be75230b7c071dafb
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:23 2014 -0400

    tty: Move pty-specific set_termios() handling to pty driver
    
    Packet mode is unique to the pty driver; move the packet mode state
    change code from the generic tty ioctl handler to the pty driver.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 6c7602592fe0..7f612c524224 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -259,6 +259,34 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 static void pty_set_termios(struct tty_struct *tty,
 					struct ktermios *old_termios)
 {
+	unsigned long flags;
+
+	/* See if packet mode change of state. */
+	if (tty->link && tty->link->packet) {
+		int extproc = (old_termios->c_lflag & EXTPROC) |
+				(tty->termios.c_lflag & EXTPROC);
+		int old_flow = ((old_termios->c_iflag & IXON) &&
+				(old_termios->c_cc[VSTOP] == '\023') &&
+				(old_termios->c_cc[VSTART] == '\021'));
+		int new_flow = (I_IXON(tty) &&
+				STOP_CHAR(tty) == '\023' &&
+				START_CHAR(tty) == '\021');
+		if ((old_flow != new_flow) || extproc) {
+			spin_lock_irqsave(&tty->ctrl_lock, flags);
+			if (old_flow != new_flow) {
+				tty->ctrl_status &= ~(TIOCPKT_DOSTOP | TIOCPKT_NOSTOP);
+				if (new_flow)
+					tty->ctrl_status |= TIOCPKT_DOSTOP;
+				else
+					tty->ctrl_status |= TIOCPKT_NOSTOP;
+			}
+			if (extproc)
+				tty->ctrl_status |= TIOCPKT_IOCTL;
+			spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+			wake_up_interruptible(&tty->link->read_wait);
+		}
+	}
+
 	tty->termios.c_cflag &= ~(CSIZE | PARENB);
 	tty->termios.c_cflag |= (CS8 | CREAD);
 }

commit 6460fbbf476ad8d4f4196534c00019975b33e1db
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 15:33:22 2014 -0400

    tty: WARN for attempted set_termios() of pty master
    
    The pty master's termios should never be set; currently, all code
    paths which call the driver's set_termios() method ensure that the
    pty slave's termios is being set.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4c0218db85ad..6c7602592fe0 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -477,7 +477,6 @@ static const struct tty_operations master_pty_ops_bsd = {
 	.flush_buffer = pty_flush_buffer,
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
-	.set_termios = pty_set_termios,
 	.ioctl = pty_bsd_ioctl,
 	.cleanup = pty_cleanup,
 	.resize = pty_resize,
@@ -654,7 +653,6 @@ static const struct tty_operations ptm_unix98_ops = {
 	.flush_buffer = pty_flush_buffer,
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
-	.set_termios = pty_set_termios,
 	.ioctl = pty_unix98_ioctl,
 	.resize = pty_resize,
 	.shutdown = pty_unix98_shutdown,

commit 5b239542207d83687489a22e6dd93ffef1ad9eb9
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 14:59:45 2014 -0400

    tty: Replace open-coded tty_get_pgrp()
    
    Replace open-coded instances of tty_get_pgrp().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7c4447a5c0f4..4c0218db85ad 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -207,15 +207,12 @@ static int pty_get_pktmode(struct tty_struct *tty, int __user *arg)
 /* Send a signal to the slave */
 static int pty_signal(struct tty_struct *tty, int sig)
 {
-	unsigned long flags;
 	struct pid *pgrp;
 
 	if (tty->link) {
-		spin_lock_irqsave(&tty->link->ctrl_lock, flags);
-		pgrp = get_pid(tty->link->pgrp);
-		spin_unlock_irqrestore(&tty->link->ctrl_lock, flags);
-
-		kill_pgrp(pgrp, sig, 1);
+		pgrp = tty_get_pgrp(tty->link);
+		if (pgrp)
+			kill_pgrp(pgrp, sig, 1);
 		put_pid(pgrp);
 	}
 	return 0;
@@ -278,7 +275,6 @@ static void pty_set_termios(struct tty_struct *tty,
 static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 {
 	struct pid *pgrp, *rpgrp;
-	unsigned long flags;
 	struct tty_struct *pty = tty->link;
 
 	/* For a PTY we need to lock the tty side */
@@ -286,17 +282,9 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	if (!memcmp(ws, &tty->winsize, sizeof(*ws)))
 		goto done;
 
-	/* Get the PID values and reference them so we can
-	   avoid holding the tty ctrl lock while sending signals.
-	   We need to lock these individually however. */
-
-	spin_lock_irqsave(&tty->ctrl_lock, flags);
-	pgrp = get_pid(tty->pgrp);
-	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
-
-	spin_lock_irqsave(&pty->ctrl_lock, flags);
-	rpgrp = get_pid(pty->pgrp);
-	spin_unlock_irqrestore(&pty->ctrl_lock, flags);
+	/* Signal the foreground process group of both ptys */
+	pgrp = tty_get_pgrp(tty);
+	rpgrp = tty_get_pgrp(pty);
 
 	if (pgrp)
 		kill_pgrp(pgrp, SIGWINCH, 1);

commit 01adc80706f80a583948db6768c5571204cd5f99
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Sep 10 15:06:32 2014 -0400

    tty: Move packet mode flow control notifications to pty driver
    
    When a master pty is set to packet mode, flow control changes to
    the slave pty cause notifications to the master pty via reads and
    polls. However, these tests are occurring for all ttys, not
    just ptys.
    
    Implement flow control packet mode notifications in the pty driver.
    Only the slave side implements the flow control handlers since
    packet mode is asymmetric; the master pty receives notifications
    for slave-side changes, but not vice versa.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 9bbdb1de12e2..7c4447a5c0f4 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -24,6 +24,7 @@
 #include <linux/devpts_fs.h>
 #include <linux/slab.h>
 #include <linux/mutex.h>
+#include <linux/poll.h>
 
 
 #ifdef CONFIG_UNIX98_PTYS
@@ -312,6 +313,42 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	return 0;
 }
 
+/**
+ *	pty_start - start() handler
+ *	pty_stop  - stop() handler
+ *	@tty: tty being flow-controlled
+ *
+ *	Propagates the TIOCPKT status to the master pty.
+ *
+ *	NB: only the master pty can be in packet mode so only the slave
+ *	    needs start()/stop() handlers
+ */
+static void pty_start(struct tty_struct *tty)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tty->ctrl_lock, flags);
+	if (tty->link && tty->link->packet) {
+		tty->ctrl_status &= ~TIOCPKT_STOP;
+		tty->ctrl_status |= TIOCPKT_START;
+		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
+	}
+	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+}
+
+static void pty_stop(struct tty_struct *tty)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tty->ctrl_lock, flags);
+	if (tty->link && tty->link->packet) {
+		tty->ctrl_status &= ~TIOCPKT_START;
+		tty->ctrl_status |= TIOCPKT_STOP;
+		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
+	}
+	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+}
+
 /**
  *	pty_common_install		-	set up the pty pair
  *	@driver: the pty driver
@@ -471,6 +508,8 @@ static const struct tty_operations slave_pty_ops_bsd = {
 	.set_termios = pty_set_termios,
 	.cleanup = pty_cleanup,
 	.resize = pty_resize,
+	.start = pty_start,
+	.stop = pty_stop,
 	.remove = pty_remove
 };
 
@@ -646,6 +685,8 @@ static const struct tty_operations pty_unix98_ops = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
+	.start = pty_start,
+	.stop = pty_stop,
 	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup,
 };

commit 07584d4a356ef52c084e1e4fedc22858ffc2f8b2
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Sun Jul 13 01:44:00 2014 +0200

    drivers: tty: Fix use-after-free in pty_common_install
    
    In 2c964a2f "drivers: tty: Merge alloc_tty_struct and
    initialize_tty_struct", I messed up the refactorization of
    pty_common_install, causing use-after-free and NULL pointer derefs on
    various error paths. This should fix it.
    
    Reported-by: Julia Lawall <julia.lawall@lip6.fr>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index ac723e3c031a..9bbdb1de12e2 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -388,7 +388,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	deinitialize_tty_struct(o_tty);
 	free_tty_struct(o_tty);
 err_put_module:
-	module_put(o_tty->driver->owner);
+	module_put(driver->other->owner);
 err:
 	kfree(ports[0]);
 	kfree(ports[1]);

commit 2c964a2f4191f2229566895f1a0e85f8339f5dd1
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Jul 10 21:01:22 2014 +0200

    drivers: tty: Merge alloc_tty_struct and initialize_tty_struct
    
    The two functions alloc_tty_struct and initialize_tty_struct are
    always called together. Merge them into alloc_tty_struct, updating its
    prototype and the only two callers of these functions.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 25c9bc783722..ac723e3c031a 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -316,7 +316,7 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
  *	pty_common_install		-	set up the pty pair
  *	@driver: the pty driver
  *	@tty: the tty being instantiated
- *	@bool: legacy, true if this is BSD style
+ *	@legacy: true if this is BSD style
  *
  *	Perform the initial set up for the tty/pty pair. Called from the
  *	tty layer when the port is first opened.
@@ -331,18 +331,17 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	int idx = tty->index;
 	int retval = -ENOMEM;
 
-	o_tty = alloc_tty_struct();
-	if (!o_tty)
-		goto err;
 	ports[0] = kmalloc(sizeof **ports, GFP_KERNEL);
 	ports[1] = kmalloc(sizeof **ports, GFP_KERNEL);
 	if (!ports[0] || !ports[1])
-		goto err_free_tty;
+		goto err;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
-		goto err_free_tty;
+		goto err;
 	}
-	initialize_tty_struct(o_tty, driver->other, idx);
+	o_tty = alloc_tty_struct(driver->other, idx);
+	if (!o_tty)
+		goto err_put_module;
 
 	if (legacy) {
 		/* We always use new tty termios data so we can do this
@@ -387,12 +386,12 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		tty_free_termios(tty);
 err_deinit_tty:
 	deinitialize_tty_struct(o_tty);
+	free_tty_struct(o_tty);
+err_put_module:
 	module_put(o_tty->driver->owner);
-err_free_tty:
+err:
 	kfree(ports[0]);
 	kfree(ports[1]);
-	free_tty_struct(o_tty);
-err:
 	return retval;
 }
 

commit dee4a0be69c0e2996188e0c46478eadc280a8954
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jul 24 16:43:51 2013 -0400

    tty: Fix lock order in tty_do_resize()
    
    Commits 6a1c0680cf3ba94356ecd58833e1540c93472a57 and
    9356b535fcb71db494fc434acceb79f56d15bda2, respectively
      'tty: Convert termios_mutex to termios_rwsem' and
      'n_tty: Access termios values safely'
    introduced a circular lock dependency with console_lock and
    termios_rwsem.
    
    The lockdep report [1] shows that n_tty_write() will attempt
    to claim console_lock while holding the termios_rwsem, whereas
    tty_do_resize() may already hold the console_lock while
    claiming the termios_rwsem.
    
    Since n_tty_write() and tty_do_resize() do not contend
    over the same data -- the tty->winsize structure -- correct
    the lock dependency by introducing a new lock which
    specifically serializes access to tty->winsize only.
    
    [1] Lockdep report
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.10.0-0+tip-xeon+lockdep #0+tip Not tainted
    -------------------------------------------------------
    modprobe/277 is trying to acquire lock:
     (&tty->termios_rwsem){++++..}, at: [<ffffffff81452656>] tty_do_resize+0x36/0xe0
    
    but task is already holding lock:
     ((fb_notifier_list).rwsem){.+.+.+}, at: [<ffffffff8107aac6>] __blocking_notifier_call_chain+0x56/0xc0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #2 ((fb_notifier_list).rwsem){.+.+.+}:
           [<ffffffff810b6d62>] lock_acquire+0x92/0x1f0
           [<ffffffff8175b797>] down_read+0x47/0x5c
           [<ffffffff8107aac6>] __blocking_notifier_call_chain+0x56/0xc0
           [<ffffffff8107ab46>] blocking_notifier_call_chain+0x16/0x20
           [<ffffffff813d7c0b>] fb_notifier_call_chain+0x1b/0x20
           [<ffffffff813d95b2>] register_framebuffer+0x1e2/0x320
           [<ffffffffa01043e1>] drm_fb_helper_initial_config+0x371/0x540 [drm_kms_helper]
           [<ffffffffa01bcb05>] nouveau_fbcon_init+0x105/0x140 [nouveau]
           [<ffffffffa01ad0af>] nouveau_drm_load+0x43f/0x610 [nouveau]
           [<ffffffffa008a79e>] drm_get_pci_dev+0x17e/0x2a0 [drm]
           [<ffffffffa01ad4da>] nouveau_drm_probe+0x25a/0x2a0 [nouveau]
           [<ffffffff813b13db>] local_pci_probe+0x4b/0x80
           [<ffffffff813b1701>] pci_device_probe+0x111/0x120
           [<ffffffff814977eb>] driver_probe_device+0x8b/0x3a0
           [<ffffffff81497bab>] __driver_attach+0xab/0xb0
           [<ffffffff814956ad>] bus_for_each_dev+0x5d/0xa0
           [<ffffffff814971fe>] driver_attach+0x1e/0x20
           [<ffffffff81496cc1>] bus_add_driver+0x111/0x290
           [<ffffffff814982b7>] driver_register+0x77/0x170
           [<ffffffff813b0454>] __pci_register_driver+0x64/0x70
           [<ffffffffa008a9da>] drm_pci_init+0x11a/0x130 [drm]
           [<ffffffffa022a04d>] nouveau_drm_init+0x4d/0x1000 [nouveau]
           [<ffffffff810002ea>] do_one_initcall+0xea/0x1a0
           [<ffffffff810c54cb>] load_module+0x123b/0x1bf0
           [<ffffffff810c5f57>] SyS_init_module+0xd7/0x120
           [<ffffffff817677c2>] system_call_fastpath+0x16/0x1b
    
    -> #1 (console_lock){+.+.+.}:
           [<ffffffff810b6d62>] lock_acquire+0x92/0x1f0
           [<ffffffff810430a7>] console_lock+0x77/0x80
           [<ffffffff8146b2a1>] con_flush_chars+0x31/0x50
           [<ffffffff8145780c>] n_tty_write+0x1ec/0x4d0
           [<ffffffff814541b9>] tty_write+0x159/0x2e0
           [<ffffffff814543f5>] redirected_tty_write+0xb5/0xc0
           [<ffffffff811ab9d5>] vfs_write+0xc5/0x1f0
           [<ffffffff811abec5>] SyS_write+0x55/0xa0
           [<ffffffff817677c2>] system_call_fastpath+0x16/0x1b
    
    -> #0 (&tty->termios_rwsem){++++..}:
           [<ffffffff810b65c3>] __lock_acquire+0x1c43/0x1d30
           [<ffffffff810b6d62>] lock_acquire+0x92/0x1f0
           [<ffffffff8175b724>] down_write+0x44/0x70
           [<ffffffff81452656>] tty_do_resize+0x36/0xe0
           [<ffffffff8146c841>] vc_do_resize+0x3e1/0x4c0
           [<ffffffff8146c99f>] vc_resize+0x1f/0x30
           [<ffffffff813e4535>] fbcon_init+0x385/0x5a0
           [<ffffffff8146a4bc>] visual_init+0xbc/0x120
           [<ffffffff8146cd13>] do_bind_con_driver+0x163/0x320
           [<ffffffff8146cfa1>] do_take_over_console+0x61/0x70
           [<ffffffff813e2b93>] do_fbcon_takeover+0x63/0xc0
           [<ffffffff813e67a5>] fbcon_event_notify+0x715/0x820
           [<ffffffff81762f9d>] notifier_call_chain+0x5d/0x110
           [<ffffffff8107aadc>] __blocking_notifier_call_chain+0x6c/0xc0
           [<ffffffff8107ab46>] blocking_notifier_call_chain+0x16/0x20
           [<ffffffff813d7c0b>] fb_notifier_call_chain+0x1b/0x20
           [<ffffffff813d95b2>] register_framebuffer+0x1e2/0x320
           [<ffffffffa01043e1>] drm_fb_helper_initial_config+0x371/0x540 [drm_kms_helper]
           [<ffffffffa01bcb05>] nouveau_fbcon_init+0x105/0x140 [nouveau]
           [<ffffffffa01ad0af>] nouveau_drm_load+0x43f/0x610 [nouveau]
           [<ffffffffa008a79e>] drm_get_pci_dev+0x17e/0x2a0 [drm]
           [<ffffffffa01ad4da>] nouveau_drm_probe+0x25a/0x2a0 [nouveau]
           [<ffffffff813b13db>] local_pci_probe+0x4b/0x80
           [<ffffffff813b1701>] pci_device_probe+0x111/0x120
           [<ffffffff814977eb>] driver_probe_device+0x8b/0x3a0
           [<ffffffff81497bab>] __driver_attach+0xab/0xb0
           [<ffffffff814956ad>] bus_for_each_dev+0x5d/0xa0
           [<ffffffff814971fe>] driver_attach+0x1e/0x20
           [<ffffffff81496cc1>] bus_add_driver+0x111/0x290
           [<ffffffff814982b7>] driver_register+0x77/0x170
           [<ffffffff813b0454>] __pci_register_driver+0x64/0x70
           [<ffffffffa008a9da>] drm_pci_init+0x11a/0x130 [drm]
           [<ffffffffa022a04d>] nouveau_drm_init+0x4d/0x1000 [nouveau]
           [<ffffffff810002ea>] do_one_initcall+0xea/0x1a0
           [<ffffffff810c54cb>] load_module+0x123b/0x1bf0
           [<ffffffff810c5f57>] SyS_init_module+0xd7/0x120
           [<ffffffff817677c2>] system_call_fastpath+0x16/0x1b
    
    other info that might help us debug this:
    
    Chain exists of:
      &tty->termios_rwsem --> console_lock --> (fb_notifier_list).rwsem
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock((fb_notifier_list).rwsem);
                                   lock(console_lock);
                                   lock((fb_notifier_list).rwsem);
      lock(&tty->termios_rwsem);
    
     *** DEADLOCK ***
    
    7 locks held by modprobe/277:
     #0:  (&__lockdep_no_validate__){......}, at: [<ffffffff81497b5b>] __driver_attach+0x5b/0xb0
     #1:  (&__lockdep_no_validate__){......}, at: [<ffffffff81497b69>] __driver_attach+0x69/0xb0
     #2:  (drm_global_mutex){+.+.+.}, at: [<ffffffffa008a6dd>] drm_get_pci_dev+0xbd/0x2a0 [drm]
     #3:  (registration_lock){+.+.+.}, at: [<ffffffff813d93f5>] register_framebuffer+0x25/0x320
     #4:  (&fb_info->lock){+.+.+.}, at: [<ffffffff813d8116>] lock_fb_info+0x26/0x60
     #5:  (console_lock){+.+.+.}, at: [<ffffffff813d95a4>] register_framebuffer+0x1d4/0x320
     #6:  ((fb_notifier_list).rwsem){.+.+.+}, at: [<ffffffff8107aac6>] __blocking_notifier_call_chain+0x56/0xc0
    
    stack backtrace:
    CPU: 0 PID: 277 Comm: modprobe Not tainted 3.10.0-0+tip-xeon+lockdep #0+tip
    Hardware name: Dell Inc. Precision WorkStation T5400  /0RW203, BIOS A11 04/30/2012
     ffffffff8213e5e0 ffff8802aa2fb298 ffffffff81755f19 ffff8802aa2fb2e8
     ffffffff8174f506 ffff8802aa2fa000 ffff8802aa2fb378 ffff8802aa2ea8e8
     ffff8802aa2ea910 ffff8802aa2ea8e8 0000000000000006 0000000000000007
    Call Trace:
     [<ffffffff81755f19>] dump_stack+0x19/0x1b
     [<ffffffff8174f506>] print_circular_bug+0x1fb/0x20c
     [<ffffffff810b65c3>] __lock_acquire+0x1c43/0x1d30
     [<ffffffff810b775e>] ? mark_held_locks+0xae/0x120
     [<ffffffff810b78d5>] ? trace_hardirqs_on_caller+0x105/0x1d0
     [<ffffffff810b6d62>] lock_acquire+0x92/0x1f0
     [<ffffffff81452656>] ? tty_do_resize+0x36/0xe0
     [<ffffffff8175b724>] down_write+0x44/0x70
     [<ffffffff81452656>] ? tty_do_resize+0x36/0xe0
     [<ffffffff81452656>] tty_do_resize+0x36/0xe0
     [<ffffffff8146c841>] vc_do_resize+0x3e1/0x4c0
     [<ffffffff8146c99f>] vc_resize+0x1f/0x30
     [<ffffffff813e4535>] fbcon_init+0x385/0x5a0
     [<ffffffff8146a4bc>] visual_init+0xbc/0x120
     [<ffffffff8146cd13>] do_bind_con_driver+0x163/0x320
     [<ffffffff8146cfa1>] do_take_over_console+0x61/0x70
     [<ffffffff813e2b93>] do_fbcon_takeover+0x63/0xc0
     [<ffffffff813e67a5>] fbcon_event_notify+0x715/0x820
     [<ffffffff81762f9d>] notifier_call_chain+0x5d/0x110
     [<ffffffff8107aadc>] __blocking_notifier_call_chain+0x6c/0xc0
     [<ffffffff8107ab46>] blocking_notifier_call_chain+0x16/0x20
     [<ffffffff813d7c0b>] fb_notifier_call_chain+0x1b/0x20
     [<ffffffff813d95b2>] register_framebuffer+0x1e2/0x320
     [<ffffffffa01043e1>] drm_fb_helper_initial_config+0x371/0x540 [drm_kms_helper]
     [<ffffffff8173cbcb>] ? kmemleak_alloc+0x5b/0xc0
     [<ffffffff81198874>] ? kmem_cache_alloc_trace+0x104/0x290
     [<ffffffffa01035e1>] ? drm_fb_helper_single_add_all_connectors+0x81/0xf0 [drm_kms_helper]
     [<ffffffffa01bcb05>] nouveau_fbcon_init+0x105/0x140 [nouveau]
     [<ffffffffa01ad0af>] nouveau_drm_load+0x43f/0x610 [nouveau]
     [<ffffffffa008a79e>] drm_get_pci_dev+0x17e/0x2a0 [drm]
     [<ffffffffa01ad4da>] nouveau_drm_probe+0x25a/0x2a0 [nouveau]
     [<ffffffff8175f162>] ? _raw_spin_unlock_irqrestore+0x42/0x80
     [<ffffffff813b13db>] local_pci_probe+0x4b/0x80
     [<ffffffff813b1701>] pci_device_probe+0x111/0x120
     [<ffffffff814977eb>] driver_probe_device+0x8b/0x3a0
     [<ffffffff81497bab>] __driver_attach+0xab/0xb0
     [<ffffffff81497b00>] ? driver_probe_device+0x3a0/0x3a0
     [<ffffffff814956ad>] bus_for_each_dev+0x5d/0xa0
     [<ffffffff814971fe>] driver_attach+0x1e/0x20
     [<ffffffff81496cc1>] bus_add_driver+0x111/0x290
     [<ffffffffa022a000>] ? 0xffffffffa0229fff
     [<ffffffff814982b7>] driver_register+0x77/0x170
     [<ffffffffa022a000>] ? 0xffffffffa0229fff
     [<ffffffff813b0454>] __pci_register_driver+0x64/0x70
     [<ffffffffa008a9da>] drm_pci_init+0x11a/0x130 [drm]
     [<ffffffffa022a000>] ? 0xffffffffa0229fff
     [<ffffffffa022a000>] ? 0xffffffffa0229fff
     [<ffffffffa022a04d>] nouveau_drm_init+0x4d/0x1000 [nouveau]
     [<ffffffff810002ea>] do_one_initcall+0xea/0x1a0
     [<ffffffff810c54cb>] load_module+0x123b/0x1bf0
     [<ffffffff81399a50>] ? ddebug_proc_open+0xb0/0xb0
     [<ffffffff813855ae>] ? trace_hardirqs_on_thunk+0x3a/0x3f
     [<ffffffff810c5f57>] SyS_init_module+0xd7/0x120
     [<ffffffff817677c2>] system_call_fastpath+0x16/0x1b
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b940127ba1c8..25c9bc783722 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -281,7 +281,7 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	struct tty_struct *pty = tty->link;
 
 	/* For a PTY we need to lock the tty side */
-	down_write(&tty->termios_rwsem);
+	mutex_lock(&tty->winsize_mutex);
 	if (!memcmp(ws, &tty->winsize, sizeof(*ws)))
 		goto done;
 
@@ -308,7 +308,7 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	tty->winsize = *ws;
 	pty->winsize = *ws;	/* Never used so will go away soon */
 done:
-	up_write(&tty->termios_rwsem);
+	mutex_unlock(&tty->winsize_mutex);
 	return 0;
 }
 

commit 5ede52538ee2b2202d9dff5b06c33bfde421e6e4
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jul 24 08:29:57 2013 -0400

    tty: Remove extra wakeup from pty write() path
    
    Acquiring the write_wait queue spin lock now accounts for the largest
    slice of cpu time on the tty write path. Two factors contribute to
    this situation; a overly-pessimistic line discipline write loop which
    _always_ sets up a wait loop even if i/o will immediately succeed, and
    on ptys, a wakeup storm from reads and writes.
    
    Writer wakeup does not need to be performed by the pty driver.
    Firstly, since the actual i/o is performed within the write, the
    line discipline write loop will continue while space remains in
    the flip buffers. Secondly, when space becomes avail in the
    line discipline receive buffer (and thus also in the flip buffers),
    the pty unthrottle re-wakes the writer (non-flow-controlled line
    disciplines unconditionally unthrottle the driver when data is
    received). Thus, existing in-kernel i/o is guaranteed to advance.
    Finally, writer wakeup occurs at the conclusion of the line discipline
    write (in tty_write_unlock()). This guarantees that any user-space write
    waiters are woken to continue additional i/o.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b38a28bd9511..b940127ba1c8 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -121,10 +121,8 @@ static int pty_write(struct tty_struct *tty, const unsigned char *buf, int c)
 		/* Stuff the data into the input queue of the other end */
 		c = tty_insert_flip_string(to->port, buf, c);
 		/* And shovel */
-		if (c) {
+		if (c)
 			tty_flip_buffer_push(to->port);
-			tty_wakeup(tty);
-		}
 	}
 	return c;
 }

commit 7bfe0b7116be207cf2204ae06335cc89d8f8ee02
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jun 15 09:36:08 2013 -0400

    tty: Track flip buffer memory limit atomically
    
    Lockless flip buffers require atomically updating the bytes-in-use
    watermark.
    
    The pty driver also peeks at the watermark value to limit
    memory consumption to a much lower value than the default; query
    the watermark with new fn, tty_buffer_space_avail().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 1b39dd639ee9..b38a28bd9511 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -89,17 +89,13 @@ static void pty_unthrottle(struct tty_struct *tty)
  *	pty_space	-	report space left for writing
  *	@to: tty we are writing into
  *
- *	The tty buffers allow 64K but we sneak a peak and clip at 8K this
- *	allows a lot of overspill room for echo and other fun messes to
- *	be handled properly
+ *	Limit the buffer space used by ptys to 8k.
  */
 
 static int pty_space(struct tty_struct *to)
 {
-	int n = 8192 - to->port->buf.memory_used;
-	if (n < 0)
-		return 0;
-	return n;
+	int n = tty_buffer_space_avail(to->port);
+	return min(n, 8192);
 }
 
 /**

commit 6a1c0680cf3ba94356ecd58833e1540c93472a57
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jun 15 09:14:23 2013 -0400

    tty: Convert termios_mutex to termios_rwsem
    
    termios is commonly accessed unsafely (especially by N_TTY)
    because the existing mutex forces exclusive access.
    Convert existing usage.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index abfd99089781..1b39dd639ee9 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -287,7 +287,7 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	struct tty_struct *pty = tty->link;
 
 	/* For a PTY we need to lock the tty side */
-	mutex_lock(&tty->termios_mutex);
+	down_write(&tty->termios_rwsem);
 	if (!memcmp(ws, &tty->winsize, sizeof(*ws)))
 		goto done;
 
@@ -314,7 +314,7 @@ static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	tty->winsize = *ws;
 	pty->winsize = *ws;	/* Never used so will go away soon */
 done:
-	mutex_unlock(&tty->termios_mutex);
+	up_write(&tty->termios_rwsem);
 	return 0;
 }
 

commit 7c61c3d8f44d5d822f758754287af644307b4af9
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Jun 13 15:56:37 2013 -0400

    tty: Fix transient pty write() EIO
    
    Commit 699390354da6c258b65bf8fa79cfd5feaede50b6
    ('pty: Ignore slave pty close() if never successfully opened')
    introduced a bug with ptys whereby a write() in parallel with an
    open() on an existing pty could mistakenly indicate an I/O error.
    
    Only indicate an I/O error if the condition on open() actually exists.
    
    Reported-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Cc: stable <stable@vger.kernel.org> # 3.9
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 59bfaecc4e14..abfd99089781 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -244,14 +244,9 @@ static void pty_flush_buffer(struct tty_struct *tty)
 
 static int pty_open(struct tty_struct *tty, struct file *filp)
 {
-	int	retval = -ENODEV;
-
 	if (!tty || !tty->link)
-		goto out;
-
-	set_bit(TTY_IO_ERROR, &tty->flags);
+		return -ENODEV;
 
-	retval = -EIO;
 	if (test_bit(TTY_OTHER_CLOSED, &tty->flags))
 		goto out;
 	if (test_bit(TTY_PTY_LOCK, &tty->link->flags))
@@ -262,9 +257,11 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 	clear_bit(TTY_IO_ERROR, &tty->flags);
 	clear_bit(TTY_OTHER_CLOSED, &tty->link->flags);
 	set_bit(TTY_THROTTLED, &tty->flags);
-	retval = 0;
+	return 0;
+
 out:
-	return retval;
+	set_bit(TTY_IO_ERROR, &tty->flags);
+	return -EIO;
 }
 
 static void pty_set_termios(struct tty_struct *tty,

commit b0b885657b6c8ef63a46bc9299b2a7715d19acde
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 07:32:21 2013 -0700

    tty: fix up atime/mtime mess, take three
    
    We first tried to avoid updating atime/mtime entirely (commit
    b0de59b5733d: "TTY: do not update atime/mtime on read/write"), and then
    limited it to only update it occasionally (commit 37b7f3c76595: "TTY:
    fix atime/mtime regression"), but it turns out that this was both
    insufficient and overkill.
    
    It was insufficient because we let people attach to the shared ptmx node
    to see activity without even reading atime/mtime, and it was overkill
    because the "only once a minute" means that you can't really tell an
    idle person from an active one with 'w'.
    
    So this tries to fix the problem properly.  It marks the shared ptmx
    node as un-notifiable, and it lowers the "only once a minute" to a few
    seconds instead - still long enough that you can't time individual
    keystrokes, but short enough that you can tell whether somebody is
    active or not.
    
    Reported-by: Simon Kirby <sim@hostway.ca>
    Acked-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a62798fcc014..59bfaecc4e14 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -681,6 +681,9 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	nonseekable_open(inode, filp);
 
+	/* We refuse fsnotify events on ptmx, since it's a shared resource */
+	filp->f_mode |= FMODE_NONOTIFY;
+
 	retval = tty_alloc_file(filp);
 	if (retval)
 		return retval;

commit f4b208eb91776b0522b41c78fac6cf08134db78f
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Apr 15 07:52:05 2013 +0200

    TTY: pty, fix compilation warning
    
    When CONFIG_UNIX98_PTYS is unset, we see this warning in pty:
      drivers/tty/pty.c:409:13: warning: pty_unix98_shutdown defined but not used
    
    Fix that by moving the function to a section which depends on that
    config.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reported-by: Toralf Foerster <toralf.foerster@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 71e456aa6367..a62798fcc014 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -405,12 +405,6 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	return retval;
 }
 
-/* this is called once with whichever end is closed last */
-static void pty_unix98_shutdown(struct tty_struct *tty)
-{
-	devpts_kill_index(tty->driver_data, tty->index);
-}
-
 static void pty_cleanup(struct tty_struct *tty)
 {
 	tty_port_put(tty->port);
@@ -626,6 +620,12 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
 }
 
+/* this is called once with whichever end is closed last */
+static void pty_unix98_shutdown(struct tty_struct *tty)
+{
+	devpts_kill_index(tty->driver_data, tty->index);
+}
+
 static const struct tty_operations ptm_unix98_ops = {
 	.lookup = ptm_unix98_lookup,
 	.install = pty_unix98_install,

commit 19ffd68f816878aed456d5e87697f43bd9e3bd2b
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Feb 5 16:08:50 2013 -0500

    pty: Remove redundant itty reset
    
    port->itty has already been reset by release_tty() before
    pty_cleanup() is called.
    
    Call stack:
    release_tty()
      tty_kref_put()
        queue_release_one_tty()
          release_one_tty() : workqueue
            tty->ops->cleanup()
              pty_cleanup()
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index c24b4db243b9..71e456aa6367 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -413,7 +413,6 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 
 static void pty_cleanup(struct tty_struct *tty)
 {
-	tty->port->itty = NULL;
 	tty_port_put(tty->port);
 }
 

commit 80cace72566633bb99da1f022f71d3dac3498b02
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jan 30 12:43:52 2013 -0500

    pty: Ignore slave open count for master pty open
    
    Multiple slave pty opens may be performed in parallel with the
    master open. Of course, all the slave opens will fail because the
    master pty is still locked but during this time the slave pty
    count will be artificially greater than 1. This is should not
    cause the master pty open to fail.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d38455fab4b7..c24b4db243b9 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -256,7 +256,7 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 		goto out;
 	if (test_bit(TTY_PTY_LOCK, &tty->link->flags))
 		goto out;
-	if (tty->link->count != 1)
+	if (tty->driver->subtype == PTY_TYPE_SLAVE && tty->link->count != 1)
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &tty->flags);

commit 699390354da6c258b65bf8fa79cfd5feaede50b6
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jan 30 12:43:50 2013 -0500

    pty: Ignore slave pty close() if never successfully opened
    
    If the master and slave ptys are opened in parallel, the slave open
    fails because the pty is still locked. This is as designed.
    However, pty_close() is still called for the slave pty which sets
    TTY_OTHER_CLOSED in the master pty. This can cause the master open
    to fail as well.
    
    Use a common pattern in other tty drivers by setting TTY_IO_ERROR
    until the open is successful and only closing the pty if not set.
    
    Note: the master pty always closes regardless of whether the open
    was successful, so that proper cleanup can occur.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 96dc6dd31425..d38455fab4b7 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -38,9 +38,12 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	if (tty->driver->subtype == PTY_TYPE_MASTER)
 		WARN_ON(tty->count > 1);
 	else {
+		if (test_bit(TTY_IO_ERROR, &tty->flags))
+			return;
 		if (tty->count > 2)
 			return;
 	}
+	set_bit(TTY_IO_ERROR, &tty->flags);
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
@@ -246,6 +249,8 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 	if (!tty || !tty->link)
 		goto out;
 
+	set_bit(TTY_IO_ERROR, &tty->flags);
+
 	retval = -EIO;
 	if (test_bit(TTY_OTHER_CLOSED, &tty->flags))
 		goto out;
@@ -254,6 +259,7 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 	if (tty->link->count != 1)
 		goto out;
 
+	clear_bit(TTY_IO_ERROR, &tty->flags);
 	clear_bit(TTY_OTHER_CLOSED, &tty->link->flags);
 	set_bit(TTY_THROTTLED, &tty->flags);
 	retval = 0;

commit 7acf6cd80b201f77371a5374a786144153629be8
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jan 30 12:43:49 2013 -0500

    pty: Fix BUG()s when ptmx_open() errors out
    
    If pmtx_open() fails to get a slave inode or fails the pty_open(),
    the tty is released as part of the error cleanup. As evidenced by the
    first BUG stacktrace below, pty_close() assumes that the linked pty has
    a valid, initialized inode* stored in driver_data.
    
    Also, as evidenced by the second BUG stacktrace below, pty_unix98_shutdown()
    assumes that the master pty's driver_data has been initialized.
    
    1) Fix the invalid assumption in pty_close().
    2) Initialize driver_data immediately so proper devpts fs cleanup occurs.
    
    Fixes this BUG:
    
    [  815.868844] BUG: unable to handle kernel NULL pointer dereference at 0000000000000028
    [  815.869018] IP: [<ffffffff81207bcc>] devpts_pty_kill+0x1c/0xa0
    [  815.869190] PGD 7c775067 PUD 79deb067 PMD 0
    [  815.869315] Oops: 0000 [#1] PREEMPT SMP
    [  815.869443] Modules linked in: kvm_intel kvm snd_hda_intel snd_hda_codec snd_hwdep snd_pcm snd_seq_midi microcode snd_rawmidi psmouse serio_raw snd_seq_midi_event snd_seq snd_timer$
    [  815.870025] CPU 0
    [  815.870143] Pid: 27819, comm: stress_test_tty Tainted: G        W    3.8.0-next-20130125+ttypatch-2-xeon #2 Bochs Bochs
    [  815.870386] RIP: 0010:[<ffffffff81207bcc>]  [<ffffffff81207bcc>] devpts_pty_kill+0x1c/0xa0
    [  815.870540] RSP: 0018:ffff88007d3e1ac8  EFLAGS: 00010282
    [  815.870661] RAX: ffff880079c20800 RBX: 0000000000000000 RCX: 0000000000000000
    [  815.870804] RDX: ffff880079c209a8 RSI: 0000000000000286 RDI: 0000000000000000
    [  815.870933] RBP: ffff88007d3e1ae8 R08: 0000000000000000 R09: 0000000000000000
    [  815.871078] R10: 0000000000000000 R11: 0000000000000001 R12: ffff88007bfb7e00
    [  815.871209] R13: 0000000000000005 R14: ffff880079c20c00 R15: ffff880079c20c00
    [  815.871343] FS:  00007f2e86206700(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
    [  815.871495] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  815.871617] CR2: 0000000000000028 CR3: 000000007ae56000 CR4: 00000000000006f0
    [  815.871752] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  815.871902] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  815.872012] Process stress_test_tty (pid: 27819, threadinfo ffff88007d3e0000, task ffff88007c874530)
    [  815.872012] Stack:
    [  815.872012]  ffff88007bfb7e00 ffff880079c20c00 ffff88007bfb7e00 0000000000000005
    [  815.872012]  ffff88007d3e1b08 ffffffff81417be7 ffff88007caa9bd8 ffff880079c20800
    [  815.872012]  ffff88007d3e1bc8 ffffffff8140e5f8 0000000000000000 0000000000000000
    [  815.872012] Call Trace:
    [  815.872012]  [<ffffffff81417be7>] pty_close+0x157/0x170
    [  815.872012]  [<ffffffff8140e5f8>] tty_release+0x138/0x580
    [  815.872012]  [<ffffffff816d29f3>] ? _raw_spin_lock+0x23/0x30
    [  815.872012]  [<ffffffff816d267a>] ? _raw_spin_unlock+0x1a/0x40
    [  815.872012]  [<ffffffff816d0178>] ? __mutex_unlock_slowpath+0x48/0x60
    [  815.872012]  [<ffffffff81417dff>] ptmx_open+0x11f/0x180
    [  815.872012]  [<ffffffff8119394b>] chrdev_open+0x9b/0x1c0
    [  815.872012]  [<ffffffff8118d643>] do_dentry_open+0x203/0x290
    [  815.872012]  [<ffffffff811938b0>] ? cdev_put+0x30/0x30
    [  815.872012]  [<ffffffff8118d705>] finish_open+0x35/0x50
    [  815.872012]  [<ffffffff8119dcce>] do_last+0x6fe/0xe90
    [  815.872012]  [<ffffffff8119a7af>] ? link_path_walk+0x7f/0x880
    [  815.872012]  [<ffffffff810909d5>] ? cpuacct_charge+0x75/0x80
    [  815.872012]  [<ffffffff8119e51c>] path_openat+0xbc/0x4e0
    [  815.872012]  [<ffffffff816d0fd0>] ? __schedule+0x400/0x7f0
    [  815.872012]  [<ffffffff8140e956>] ? tty_release+0x496/0x580
    [  815.872012]  [<ffffffff8119ec11>] do_filp_open+0x41/0xa0
    [  815.872012]  [<ffffffff816d267a>] ? _raw_spin_unlock+0x1a/0x40
    [  815.872012]  [<ffffffff811abe39>] ? __alloc_fd+0xe9/0x140
    [  815.872012]  [<ffffffff8118ea44>] do_sys_open+0xf4/0x1e0
    [  815.872012]  [<ffffffff8118eb51>] sys_open+0x21/0x30
    [  815.872012]  [<ffffffff816da499>] system_call_fastpath+0x16/0x1b
    [  815.872012] Code: 0f 1f 80 00 00 00 00 45 31 e4 eb d7 0f 0b 90 0f 1f 44 00 00 55 48 89 e5 48 83 ec 20 48 89 5d e8 48 89 fb 4c 89 65 f0 4c 89 6d f8 <48> 8b 47 28 48 81 78 58 d1 1c 0$
    [  815.872012] RIP  [<ffffffff81207bcc>] devpts_pty_kill+0x1c/0xa0
    [  815.872012]  RSP <ffff88007d3e1ac8>
    [  815.872012] CR2: 0000000000000028
    [  815.897036] ---[ end trace eadf50b7f34e47d5 ]---
    
    Fixes this BUG also:
    
    [  608.366836] BUG: unable to handle kernel NULL pointer dereference at 0000000000000028
    [  608.366948] IP: [<ffffffff812078d8>] devpts_kill_index+0x18/0x70
    [  608.367050] PGD 7c75b067 PUD 7b919067 PMD 0
    [  608.367135] Oops: 0000 [#1] PREEMPT SMP
    [  608.367201] Modules linked in: kvm_intel kvm snd_hda_intel snd_hda_codec snd_hwdep snd_pcm snd_seq_midi snd_rawmidi snd_seq_midi_event microcode snd_seq psmouse snd_timer snd_seq_device serio_raw snd mac_hid soundcore snd_page_alloc rfcomm virtio_balloon parport_pc bnep bluetooth ppdev i2c_piix4 lp parport floppy
    [  608.367617] CPU 2
    [  608.367669] Pid: 1918, comm: stress_test_tty Tainted: G        W    3.8.0-next-20130125+ttypatch-2-xeon #2 Bochs Bochs
    [  608.367796] RIP: 0010:[<ffffffff812078d8>]  [<ffffffff812078d8>] devpts_kill_index+0x18/0x70
    [  608.367885] RSP: 0018:ffff88007ae41a88  EFLAGS: 00010286
    [  608.367951] RAX: ffffffff81417e80 RBX: ffff880036472400 RCX: 0000000180400028
    [  608.368010] RDX: ffff880036470004 RSI: 0000000000000004 RDI: 0000000000000000
    [  608.368010] RBP: ffff88007ae41a98 R08: 0000000000000000 R09: 0000000000000001
    [  608.368010] R10: ffffea0001f22e40 R11: ffffffff814151d5 R12: 0000000000000004
    [  608.368010] R13: ffff880036470000 R14: 0000000000000004 R15: ffff880036472400
    [  608.368010] FS:  00007ff7a5268700(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
    [  608.368010] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  608.368010] CR2: 0000000000000028 CR3: 000000007a0fd000 CR4: 00000000000006e0
    [  608.368010] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  608.368010] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  608.368010] Process stress_test_tty (pid: 1918, threadinfo ffff88007ae40000, task ffff88003688dc40)
    [  608.368010] Stack:
    [  608.368010]  ffff880036472400 0000000000000001 ffff88007ae41aa8 ffffffff81417e98
    [  608.368010]  ffff88007ae41ac8 ffffffff8140c42b ffff88007ac73100 ffff88007ac73100
    [  608.368010]  ffff88007ae41b98 ffffffff8140ead5 ffff88007ae41b38 ffff88007ca40e40
    [  608.368010] Call Trace:
    [  608.368010]  [<ffffffff81417e98>] pty_unix98_shutdown+0x18/0x20
    [  608.368010]  [<ffffffff8140c42b>] release_tty+0x3b/0xe0
    [  608.368010]  [<ffffffff8140ead5>] __tty_release+0x575/0x5d0
    [  608.368010]  [<ffffffff816d2c63>] ? _raw_spin_lock+0x23/0x30
    [  608.368010]  [<ffffffff816d28ea>] ? _raw_spin_unlock+0x1a/0x40
    [  608.368010]  [<ffffffff816d03e8>] ? __mutex_unlock_slowpath+0x48/0x60
    [  608.368010]  [<ffffffff8140ef79>] tty_open+0x449/0x5f0
    [  608.368010]  [<ffffffff8119394b>] chrdev_open+0x9b/0x1c0
    [  608.368010]  [<ffffffff8118d643>] do_dentry_open+0x203/0x290
    [  608.368010]  [<ffffffff811938b0>] ? cdev_put+0x30/0x30
    [  608.368010]  [<ffffffff8118d705>] finish_open+0x35/0x50
    [  608.368010]  [<ffffffff8119dcce>] do_last+0x6fe/0xe90
    [  608.368010]  [<ffffffff8119a7af>] ? link_path_walk+0x7f/0x880
    [  608.368010]  [<ffffffff8119e51c>] path_openat+0xbc/0x4e0
    [  608.368010]  [<ffffffff8119ec11>] do_filp_open+0x41/0xa0
    [  608.368010]  [<ffffffff816d28ea>] ? _raw_spin_unlock+0x1a/0x40
    [  608.368010]  [<ffffffff811abe39>] ? __alloc_fd+0xe9/0x140
    [  608.368010]  [<ffffffff8118ea44>] do_sys_open+0xf4/0x1e0
    [  608.368010]  [<ffffffff816d2c63>] ? _raw_spin_lock+0x23/0x30
    [  608.368010]  [<ffffffff8118eb51>] sys_open+0x21/0x30
    [  608.368010]  [<ffffffff816da719>] system_call_fastpath+0x16/0x1b
    [  608.368010] Code: ec 48 83 c4 10 5b 41 5c 5d c3 66 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 48 83 ec 10 4c 89 65 f8 41 89 f4 48 89 5d f0 <48> 8b 47 28 48 81 78 58 d1 1c 00 00 74 0b 48 8b 05 4b 66 cf 00
    [  608.368010] RIP  [<ffffffff812078d8>] devpts_kill_index+0x18/0x70
    [  608.368010]  RSP <ffff88007ae41a88>
    [  608.368010] CR2: 0000000000000028
    [  608.394153] ---[ end trace afe83b0fb5fbda93 ]---
    
    Reported-by: Ilya Zykov <ilya@ilyx.ru>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 755600f6120f..96dc6dd31425 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -55,7 +55,8 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 #ifdef CONFIG_UNIX98_PTYS
 		if (tty->driver == ptm_driver) {
 			mutex_lock(&devpts_mutex);
-			devpts_pty_kill(tty->link->driver_data);
+			if (tty->link->driver_data)
+				devpts_pty_kill(tty->link->driver_data);
 			mutex_unlock(&devpts_mutex);
 		}
 #endif
@@ -703,6 +704,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	mutex_unlock(&tty_mutex);
 
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
+	tty->driver_data = inode;
 
 	tty_add_file(tty, filp);
 
@@ -713,14 +715,13 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		retval = PTR_ERR(slave_inode);
 		goto err_release;
 	}
+	tty->link->driver_data = slave_inode;
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)
 		goto err_release;
 
 	tty_unlock(tty);
-	tty->driver_data = inode;
-	tty->link->driver_data = slave_inode;
 	return 0;
 err_release:
 	tty_unlock(tty);

commit 9f9cba810f36d16f4e64477e879a69f6c47b389d
Merge: dbf5bef8da16 949db153b646
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 25 13:27:36 2013 -0800

    Merge 3.8-rc5 into tty-next
    
    This resolves a number of tty driver merge issues found in linux-next
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ded2f295a36d17838fe97e80d7b6ea83381474f8
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri Jan 11 12:06:27 2013 +0100

    pty: return EINVAL for TIOCGPTN for BSD ptys
    
    Commit bbb63c514a3464342967237a51a21ea8f61ab951 (drivers:tty:fix up
    ENOIOCTLCMD error handling) changed the default return value from tty
    ioctl to be ENOTTY and not EINVAL. This is appropriate.
    
    But in case of TIOCGPTN for the old BSD ptys glibc started failing
    because it expects EINVAL to be returned. Only then it continues to
    obtain the pts name the other way around.
    
    So fix this case by explicit return of EINVAL in this case.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reported-by: Florian Westphal <fw@strlen.de>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: stable <stable@vger.kernel.org> # 3.7+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index be6a373601b7..79ff3a5e925d 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -441,6 +441,8 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 		return pty_get_pktmode(tty, (int __user *)arg);
 	case TIOCSIG:    /* Send signal to other side of pty */
 		return pty_signal(tty, (int) arg);
+	case TIOCGPTN: /* TTY returns ENOTTY, but glibc expects EINVAL here */
+		return -EINVAL;
 	}
 	return -ENOIOCTLCMD;
 }

commit b81273a132177edd806476b953f6afeb17b786d5
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Tue Jan 15 23:26:22 2013 +0100

    TTY: do not reset master's packet mode
    
    Now that login from util-linux is forced to drop all references to a
    TTY which it wants to hangup (to reach reference count 1) we are
    seeing issues with telnet. When login closes its last reference to the
    slave PTY, it also resets packet mode on the *master* side. And we
    have a race here.
    
    What telnet does is fork+exec of `login'. Then there are two
    scenarios:
    * `login' closes the slave TTY and resets thus master's packet mode,
      but even now telnet properly sets the mode, or
    * `telnetd' sets packet mode on the master, `login' closes the slave
      TTY and resets master's packet mode.
    
    The former case is OK. However the latter happens in much more cases,
    by the order of magnitude to be precise. So when one tries to login to
    such a messed telnet setup, they see the following:
    inux login:
                ogin incorrect
    
    Note the missing first letters -- telnet thinks it is still in the
    packet mode, so when it receives "linux login" from `login', it
    considers "l" as the type of the packet and strips it.
    
    SuS does not mention how the implementation should behave. Both BSDs I
    checked (Free and Net) do not reset the flag upon the last close.
    
    By this I am resurrecting an old bug, see References. We are hitting
    it regularly now, i.e. with updated util-linux, ergo login.
    
    Here, I am changing a behavior introduced back in 2.1 times. It would
    better have a long time testing before goes upstream.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Bryan Mason <bmason@redhat.com>
    References: https://lkml.org/lkml/2009/11/11/223
    References: https://bugzilla.redhat.com/show_bug.cgi?id=504703
    References: https://bugzilla.novell.com/show_bug.cgi?id=797042
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4ec11f326d6d..40ff2bf68b43 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,7 +47,6 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
-	tty->link->packet = 0;
 	set_bit(TTY_OTHER_CLOSED, &tty->link->flags);
 	wake_up_interruptible(&tty->link->read_wait);
 	wake_up_interruptible(&tty->link->write_wait);

commit b9f8033f28448732612e64046b13087b08dd25f7
Author: Cong Ding <dinggnu@gmail.com>
Date:   Sat Jan 12 05:01:22 2013 +0100

    tty: cleanup checkpatch warning in pty.c
    
    spaces are used for indent in 3 places of tty/pty.c, we change it to tab.
    
    Signed-off-by: Cong Ding <dinggnu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 916825f984a9..4ec11f326d6d 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -55,9 +55,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
 #ifdef CONFIG_UNIX98_PTYS
 		if (tty->driver == ptm_driver) {
-		        mutex_lock(&devpts_mutex);
+			mutex_lock(&devpts_mutex);
 			devpts_pty_kill(tty->link->driver_data);
-		        mutex_unlock(&devpts_mutex);
+			mutex_unlock(&devpts_mutex);
 		}
 #endif
 		tty_unlock(tty);
@@ -661,7 +661,7 @@ static const struct tty_operations pty_unix98_ops = {
  *	Allocate a unix98 pty master device from the ptmx driver.
  *
  *	Locking: tty_mutex protects the init_dev work. tty->count should
- * 		protect the rest.
+ *		protect the rest.
  *		allocated_ptys_lock handles the list of free pty numbers
  */
 

commit 82f8c35f86a878a504f92559d631ea03f0f62152
Author: Cong Ding <dinggnu@gmail.com>
Date:   Sat Jan 12 05:01:21 2013 +0100

    tty: cleanup the panic message
    
    the "\n" in panic message is excess, so we remove it in tty/pty.c as what it
    is used in other places.
    
    Signed-off-by: Cong Ding <dinggnu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 32d027c303aa..916825f984a9 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -795,7 +795,7 @@ static void __init unix98_pty_init(void)
 	cdev_init(&ptmx_cdev, &ptmx_fops);
 	if (cdev_add(&ptmx_cdev, MKDEV(TTYAUX_MAJOR, 2), 1) ||
 	    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, "/dev/ptmx") < 0)
-		panic("Couldn't register /dev/ptmx driver\n");
+		panic("Couldn't register /dev/ptmx driver");
 	device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 2), NULL, "ptmx");
 }
 

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 3c285d398f38..32d027c303aa 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -123,7 +123,7 @@ static int pty_write(struct tty_struct *tty, const unsigned char *buf, int c)
 		c = tty_insert_flip_string(to->port, buf, c);
 		/* And shovel */
 		if (c) {
-			tty_flip_buffer_push(to);
+			tty_flip_buffer_push(to->port);
 			tty_wakeup(tty);
 		}
 	}

commit 05c7cd39907184328f48d3e7899f9cdd653ad336
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:04 2013 +0100

    TTY: switch tty_insert_flip_string
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    tty_insert_flip_string this time.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index be6a373601b7..3c285d398f38 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -120,7 +120,7 @@ static int pty_write(struct tty_struct *tty, const unsigned char *buf, int c)
 
 	if (c > 0) {
 		/* Stuff the data into the input queue of the other end */
-		c = tty_insert_flip_string(to, buf, c);
+		c = tty_insert_flip_string(to->port, buf, c);
 		/* And shovel */
 		if (c) {
 			tty_flip_buffer_push(to);

commit 159a8e92fdf6967cb67e7639832f819fbc607242
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Sun Nov 18 21:27:40 2012 -0800

    pty: Mark pty_resize static
    
    Nothing outside of drivers/tty/pty.c references pty_resize.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a541ec875932..be6a373601b7 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -277,7 +277,7 @@ static void pty_set_termios(struct tty_struct *tty,
  *	peform a terminal resize correctly
  */
 
-int pty_resize(struct tty_struct *tty,  struct winsize *ws)
+static int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 {
 	struct pid *pgrp, *rpgrp;
 	unsigned long flags;

commit 81c79838ca24f48e0e4bb96502d131d6af758ae0
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Nov 15 09:49:49 2012 +0100

    TTY: pty, fix tty buffers leak
    
    After commit "TTY: move tty buffers to tty_port", the tty buffers are
    not freed in some drivers. This is because tty_port_destructor is not
    called whenever a tty_port is freed. This was an assumption I counted
    with but was unfortunately untrue. So fix the drivers to fulfil this
    assumption.
    
    PTY is one of those, here we just need to use tty_port_put instead of
    kfree. (Assuming tty_port_destructor does not need port->ops to be set
    which we change here too.)
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 0ce0b3ec2bb0..a541ec875932 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -408,7 +408,7 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 static void pty_cleanup(struct tty_struct *tty)
 {
 	tty->port->itty = NULL;
-	kfree(tty->port);
+	tty_port_put(tty->port);
 }
 
 /* Traditional BSD devices */

commit 84fd7bdf1266ee6228319903af7e58702745024d
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Wed Oct 24 23:43:22 2012 +0400

    tty: Add get- ioctls to fetch tty status v3
    
    For checkpoint/restore we need to know if tty has
    exclusive or packet mode set, as well as if pty
    is currently locked. Just to be able to restore
    this characteristics.
    
    For this sake the following ioctl codes are introduced
    
     - TIOCGPKT to get packet mode state
     - TIOCGPTLCK to get Pty locked state
     - TIOCGEXCL to get Exclusive mode state
    
    Note this ioctls are a bit unsafe in terms of data
    obtained consistency. The tty characteristics might
    be changed right after ioctl complete. Keep it in
    mind and use this ioctl carefully.
    
    v2:
     - Use TIOC prefix for ioctl codes (by jslaby@)
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    CC: Alan Cox <alan@lxorguk.ukuu.org.uk>
    CC: "H. Peter Anvin" <hpa@zytor.com>
    CC: Pavel Emelyanov <xemul@parallels.com>
    CC: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index df3c64272d21..0ce0b3ec2bb0 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -171,6 +171,12 @@ static int pty_set_lock(struct tty_struct *tty, int __user *arg)
 	return 0;
 }
 
+static int pty_get_lock(struct tty_struct *tty, int __user *arg)
+{
+	int locked = test_bit(TTY_PTY_LOCK, &tty->flags);
+	return put_user(locked, arg);
+}
+
 /* Set the packet mode on a pty */
 static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
 {
@@ -193,6 +199,13 @@ static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
 	return 0;
 }
 
+/* Get the packet mode of a pty */
+static int pty_get_pktmode(struct tty_struct *tty, int __user *arg)
+{
+	int pktmode = tty->packet;
+	return put_user(pktmode, arg);
+}
+
 /* Send a signal to the slave */
 static int pty_signal(struct tty_struct *tty, int sig)
 {
@@ -420,8 +433,12 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 	switch (cmd) {
 	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
 		return pty_set_lock(tty, (int __user *) arg);
+	case TIOCGPTLCK: /* Get PT Lock status */
+		return pty_get_lock(tty, (int __user *)arg);
 	case TIOCPKT: /* Set PT packet mode */
 		return pty_set_pktmode(tty, (int __user *)arg);
+	case TIOCGPKT: /* Get PT packet mode */
+		return pty_get_pktmode(tty, (int __user *)arg);
 	case TIOCSIG:    /* Send signal to other side of pty */
 		return pty_signal(tty, (int) arg);
 	}
@@ -536,8 +553,12 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 	switch (cmd) {
 	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
 		return pty_set_lock(tty, (int __user *)arg);
+	case TIOCGPTLCK: /* Get PT Lock status */
+		return pty_get_lock(tty, (int __user *)arg);
 	case TIOCPKT: /* Set PT packet mode */
 		return pty_set_pktmode(tty, (int __user *)arg);
+	case TIOCGPKT: /* Get PT packet mode */
+		return pty_get_pktmode(tty, (int __user *)arg);
 	case TIOCGPTN: /* Get PT Number */
 		return put_user(tty->index, (unsigned int __user *)arg);
 	case TIOCSIG:    /* Send signal to other side of pty */

commit 06026d911c31dfa602e14e635a3489b8d67cc786
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Wed Oct 24 23:43:20 2012 +0400

    tty: pty - Move TIOCPKT handling into pty.c
    
    Since this ioctl is for pty devices only move it to pty.c.
    
    v2:
     - drop PTY_TYPE_MASTER test since it's master peer
       ioctl anyway (by jslaby@)
    
    Suggested-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    CC: "H. Peter Anvin" <hpa@zytor.com>
    CC: Pavel Emelyanov <xemul@parallels.com>
    CC: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4219f040adb8..df3c64272d21 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -171,6 +171,28 @@ static int pty_set_lock(struct tty_struct *tty, int __user *arg)
 	return 0;
 }
 
+/* Set the packet mode on a pty */
+static int pty_set_pktmode(struct tty_struct *tty, int __user *arg)
+{
+	unsigned long flags;
+	int pktmode;
+
+	if (get_user(pktmode, arg))
+		return -EFAULT;
+
+	spin_lock_irqsave(&tty->ctrl_lock, flags);
+	if (pktmode) {
+		if (!tty->packet) {
+			tty->packet = 1;
+			tty->link->ctrl_status = 0;
+		}
+	} else
+		tty->packet = 0;
+	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+
+	return 0;
+}
+
 /* Send a signal to the slave */
 static int pty_signal(struct tty_struct *tty, int sig)
 {
@@ -398,6 +420,8 @@ static int pty_bsd_ioctl(struct tty_struct *tty,
 	switch (cmd) {
 	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
 		return pty_set_lock(tty, (int __user *) arg);
+	case TIOCPKT: /* Set PT packet mode */
+		return pty_set_pktmode(tty, (int __user *)arg);
 	case TIOCSIG:    /* Send signal to other side of pty */
 		return pty_signal(tty, (int) arg);
 	}
@@ -512,6 +536,8 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 	switch (cmd) {
 	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
 		return pty_set_lock(tty, (int __user *)arg);
+	case TIOCPKT: /* Set PT packet mode */
+		return pty_set_pktmode(tty, (int __user *)arg);
 	case TIOCGPTN: /* Get PT Number */
 		return put_user(tty->index, (unsigned int __user *)arg);
 	case TIOCSIG:    /* Send signal to other side of pty */

commit ecbbfd44a08fa80e0d664814efd4c187721b85f6
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:47 2012 +0200

    TTY: move tty buffers to tty_port
    
    So this is it. The big step why we did all the work over the past
    kernel releases. Now everything is prepared, so nothing protects us
    from doing that big step.
    
               |  |            \  \ nnnn/^l      |  |
               |  |             \  /     /       |  |
               |  '-,.__   =>    \/   ,-`    =>  |  '-,.__
               | O __.)        (  .`           | O __.)
                ~~~   ~~          ``              ~~~   ~~
    The buffers are now in the tty_port structure and we can start
    teaching the buffer helpers (insert char/string, flip etc.) to use
    tty_port instead of tty_struct all around.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index c32690862671..4219f040adb8 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -93,7 +93,7 @@ static void pty_unthrottle(struct tty_struct *tty)
 
 static int pty_space(struct tty_struct *to)
 {
-	int n = 8192 - to->buf.memory_used;
+	int n = 8192 - to->port->buf.memory_used;
 	if (n < 0)
 		return 0;
 	return n;

commit 967fab6916681e5ab131fdef1226327b02454f19
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:46 2012 +0200

    TTY: add port -> tty link
    
    For that purpose we have to temporarily introduce a second tty back
    pointer into tty_port. It is because serial layer, and maybe others,
    still do not use tty_port_tty_set/get. So that we cannot set the
    tty_port->tty to NULL at will now.
    
    Yes, the fix would be to convert whole serial layer and all its users
    to tty_port_tty_set/get. However we are in the process of removing the
    need of tty in most of the call sites, so this would lead to a
    duplicated work.
    
    Instead we have now tty_port->itty (internal tty) which will be used
    only in flush_to_ldisc. For that one it is ensured that itty is valid
    wherever the work is run. IOW, the work is synchronously cancelled
    before we set itty to NULL and also before hangup is processed.
    
    After we need only tty_port and not tty_struct in most code, this
    shall be changed to tty_port_tty_set/get and itty removed completely.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 2728afe52eea..c32690862671 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -345,6 +345,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	tty_port_init(ports[1]);
 	o_tty->port = ports[0];
 	tty->port = ports[1];
+	o_tty->port->itty = o_tty;
 
 	tty_driver_kref_get(driver);
 	tty->count++;
@@ -371,6 +372,7 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 
 static void pty_cleanup(struct tty_struct *tty)
 {
+	tty->port->itty = NULL;
 	kfree(tty->port);
 }
 

commit fa2ecfc5a68d85624bbd84f7d010860776b7e602
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:31 2012 +0200

    TTY: move devpts kill to pty
    
    Now that we have control over tty->driver_data in pty, we can just
    kill the /dev/pts/ in pty code too. Namely, in ->shutdown hook of
    tty. For pty, this is called only once, for whichever end is closed
    last. But we don't care, both driver_data are the inode as it used to
    be till now.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 559e5b27941a..2728afe52eea 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -363,6 +363,12 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	return retval;
 }
 
+/* this is called once with whichever end is closed last */
+static void pty_unix98_shutdown(struct tty_struct *tty)
+{
+	devpts_kill_index(tty->driver_data, tty->index);
+}
+
 static void pty_cleanup(struct tty_struct *tty)
 {
 	kfree(tty->port);
@@ -578,6 +584,7 @@ static const struct tty_operations ptm_unix98_ops = {
 	.set_termios = pty_set_termios,
 	.ioctl = pty_unix98_ioctl,
 	.resize = pty_resize,
+	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup
 };
 
@@ -593,6 +600,7 @@ static const struct tty_operations pty_unix98_ops = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
+	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup,
 };
 
@@ -661,6 +669,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		goto err_release;
 
 	tty_unlock(tty);
+	tty->driver_data = inode;
 	tty->link->driver_data = slave_inode;
 	return 0;
 err_release:

commit f11afb61247016162aa92225a337c1575556c9d9
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:29 2012 +0200

    TTY: devpts, do not set driver_data
    
    The goal is to stop setting and using tty->driver_data in devpts code.
    It should be used solely by the driver's code, pty in this case.
    
    Now driver_data are managed only in the pty driver. devpts_pty_new is
    switched to accept what we used to dig out of tty_struct, i.e. device
    node number and index.
    
    This also removes a note about driver_data being set outside of the
    driver.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 9985b451e937..559e5b27941a 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -4,9 +4,6 @@
  *  Added support for a Unix98-style ptmx device.
  *    -- C. Scott Ananian <cananian@alumni.princeton.edu>, 14-Jan-1998
  *
- *  When reading this code see also fs/devpts. In particular note that the
- *  driver_data field is used by the devpts side as a binding to the devpts
- *  inode.
  */
 
 #include <linux/module.h>
@@ -59,7 +56,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 #ifdef CONFIG_UNIX98_PTYS
 		if (tty->driver == ptm_driver) {
 		        mutex_lock(&devpts_mutex);
-			devpts_pty_kill(tty->link);
+			devpts_pty_kill(tty->link->driver_data);
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
@@ -651,7 +648,9 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	tty_add_file(tty, filp);
 
-	slave_inode = devpts_pty_new(inode, tty->link);
+	slave_inode = devpts_pty_new(inode,
+			MKDEV(UNIX98_PTY_SLAVE_MAJOR, index), index,
+			tty->link);
 	if (IS_ERR(slave_inode)) {
 		retval = PTR_ERR(slave_inode);
 		goto err_release;
@@ -662,6 +661,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		goto err_release;
 
 	tty_unlock(tty);
+	tty->link->driver_data = slave_inode;
 	return 0;
 err_release:
 	tty_unlock(tty);

commit 162b97cfa21f816f39ede1944f2a4220e3cf8969
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:28 2012 +0200

    TTY: devpts, return created inode from devpts_pty_new
    
    The goal is to stop setting and using tty->driver_data in devpts code.
    It should be used solely by the driver's code, pty in this case.
    
    For the cleanup of layering, we will need the inode created in
    devpts_pty_new to be stored into slave's driver_data. So we convert
    devpts_pty_new to return the inode or an ERR_PTR-encoded error in case
    of failure.
    
    The move of 'inode = new_inode(sb);' from declarators to the code is
    only cosmetical, but it makes the code easier to read.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 65f767154d12..9985b451e937 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -614,6 +614,7 @@ static const struct tty_operations pty_unix98_ops = {
 static int ptmx_open(struct inode *inode, struct file *filp)
 {
 	struct tty_struct *tty;
+	struct inode *slave_inode;
 	int retval;
 	int index;
 
@@ -650,9 +651,11 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	tty_add_file(tty, filp);
 
-	retval = devpts_pty_new(inode, tty->link);
-	if (retval)
+	slave_inode = devpts_pty_new(inode, tty->link);
+	if (IS_ERR(slave_inode)) {
+		retval = PTR_ERR(slave_inode);
 		goto err_release;
+	}
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)

commit 8fcbaa2b7f5b70dba9ed1c7f91d0a270ce752e2c
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 18 22:26:27 2012 +0200

    TTY: devpts, don't care about TTY in devpts_get_tty
    
    The goal is to stop setting and using tty->driver_data in devpts code.
    It should be used solely by the driver's code, pty in this case.
    
    First, here we remove TTY from devpts_get_tty and rename it to
    devpts_get_priv. Note we do not remove type safety, we just shift the
    [implicit] (void *) cast one layer up.
    
    index was unused in devpts_get_tty, so remove that from the prototype
    too.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a82b39939a9c..65f767154d12 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -547,7 +547,7 @@ static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
 	struct tty_struct *tty;
 
 	mutex_lock(&devpts_mutex);
-	tty = devpts_get_tty(pts_inode, idx);
+	tty = devpts_get_priv(pts_inode);
 	mutex_unlock(&devpts_mutex);
 	/* Master must be open before slave */
 	if (!tty)

commit 05fb79e45ee28b97a7cb74bd5ea3a88a8d13db1c
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Sep 19 15:34:47 2012 +0100

    pty: Fix locking bug on error path
    
    We end up dropping the mutex twice on some errors. We don't want to do
    that.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 2bace847eb39..a82b39939a9c 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -628,6 +628,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	index = devpts_new_index(inode);
 	if (index < 0) {
 		retval = index;
+		mutex_unlock(&devpts_mutex);
 		goto err_file;
 	}
 
@@ -667,7 +668,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
 err_file:
-        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit c3a6344ae475763b6fb0fb2ec3639004f500d0f1
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Aug 16 16:16:56 2012 +0300

    TTY: tty_alloc_driver() returns error pointers
    
    We changed these from alloc_tty_driver() to tty_alloc_driver() so the
    error handling needs to modified to check for IS_ERR() instead of NULL.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index f5a27c66ff60..2bace847eb39 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -448,14 +448,14 @@ static void __init legacy_pty_init(void)
 			TTY_DRIVER_RESET_TERMIOS |
 			TTY_DRIVER_REAL_RAW |
 			TTY_DRIVER_DYNAMIC_ALLOC);
-	if (!pty_driver)
+	if (IS_ERR(pty_driver))
 		panic("Couldn't allocate pty driver");
 
 	pty_slave_driver = tty_alloc_driver(legacy_count,
 			TTY_DRIVER_RESET_TERMIOS |
 			TTY_DRIVER_REAL_RAW |
 			TTY_DRIVER_DYNAMIC_ALLOC);
-	if (!pty_slave_driver)
+	if (IS_ERR(pty_slave_driver))
 		panic("Couldn't allocate pty slave driver");
 
 	pty_driver->driver_name = "pty_master";
@@ -682,7 +682,7 @@ static void __init unix98_pty_init(void)
 			TTY_DRIVER_DYNAMIC_DEV |
 			TTY_DRIVER_DEVPTS_MEM |
 			TTY_DRIVER_DYNAMIC_ALLOC);
-	if (!ptm_driver)
+	if (IS_ERR(ptm_driver))
 		panic("Couldn't allocate Unix98 ptm driver");
 	pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX,
 			TTY_DRIVER_RESET_TERMIOS |
@@ -690,7 +690,7 @@ static void __init unix98_pty_init(void)
 			TTY_DRIVER_DYNAMIC_DEV |
 			TTY_DRIVER_DEVPTS_MEM |
 			TTY_DRIVER_DYNAMIC_ALLOC);
-	if (!pts_driver)
+	if (IS_ERR(pts_driver))
 		panic("Couldn't allocate Unix98 pts driver");
 
 	ptm_driver->driver_name = "pty_master";

commit 21aca2fa00259f781d228496631b61dbb4274e90
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 8 22:26:41 2012 +0200

    TTY: pty, switch to tty_alloc_driver
    
    Switch to the new driver allocation interface, as this is one of the
    special call-sites. Here, we need TTY_DRIVER_DYNAMIC_ALLOC to not
    allocate tty_driver->ports, cdevs and potentially other structures
    because we reserve too many lines in pty. Instead, it provides the
    tty_port<->tty_struct link in tty->ops->install already.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d9ea9e2c9ec5..f5a27c66ff60 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -444,11 +444,17 @@ static void __init legacy_pty_init(void)
 	if (legacy_count <= 0)
 		return;
 
-	pty_driver = alloc_tty_driver(legacy_count);
+	pty_driver = tty_alloc_driver(legacy_count,
+			TTY_DRIVER_RESET_TERMIOS |
+			TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_ALLOC);
 	if (!pty_driver)
 		panic("Couldn't allocate pty driver");
 
-	pty_slave_driver = alloc_tty_driver(legacy_count);
+	pty_slave_driver = tty_alloc_driver(legacy_count,
+			TTY_DRIVER_RESET_TERMIOS |
+			TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_ALLOC);
 	if (!pty_slave_driver)
 		panic("Couldn't allocate pty slave driver");
 
@@ -465,7 +471,6 @@ static void __init legacy_pty_init(void)
 	pty_driver->init_termios.c_lflag = 0;
 	pty_driver->init_termios.c_ispeed = 38400;
 	pty_driver->init_termios.c_ospeed = 38400;
-	pty_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW;
 	pty_driver->other = pty_slave_driver;
 	tty_set_operations(pty_driver, &master_pty_ops_bsd);
 
@@ -479,8 +484,6 @@ static void __init legacy_pty_init(void)
 	pty_slave_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
 	pty_slave_driver->init_termios.c_ispeed = 38400;
 	pty_slave_driver->init_termios.c_ospeed = 38400;
-	pty_slave_driver->flags = TTY_DRIVER_RESET_TERMIOS |
-					TTY_DRIVER_REAL_RAW;
 	pty_slave_driver->other = pty_driver;
 	tty_set_operations(pty_slave_driver, &slave_pty_ops_bsd);
 
@@ -673,10 +676,20 @@ static struct file_operations ptmx_fops;
 
 static void __init unix98_pty_init(void)
 {
-	ptm_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
+	ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX,
+			TTY_DRIVER_RESET_TERMIOS |
+			TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV |
+			TTY_DRIVER_DEVPTS_MEM |
+			TTY_DRIVER_DYNAMIC_ALLOC);
 	if (!ptm_driver)
 		panic("Couldn't allocate Unix98 ptm driver");
-	pts_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
+	pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX,
+			TTY_DRIVER_RESET_TERMIOS |
+			TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV |
+			TTY_DRIVER_DEVPTS_MEM |
+			TTY_DRIVER_DYNAMIC_ALLOC);
 	if (!pts_driver)
 		panic("Couldn't allocate Unix98 pts driver");
 
@@ -693,8 +706,6 @@ static void __init unix98_pty_init(void)
 	ptm_driver->init_termios.c_lflag = 0;
 	ptm_driver->init_termios.c_ispeed = 38400;
 	ptm_driver->init_termios.c_ospeed = 38400;
-	ptm_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
-		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM;
 	ptm_driver->other = pts_driver;
 	tty_set_operations(ptm_driver, &ptm_unix98_ops);
 
@@ -708,8 +719,6 @@ static void __init unix98_pty_init(void)
 	pts_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
 	pts_driver->init_termios.c_ispeed = 38400;
 	pts_driver->init_termios.c_ospeed = 38400;
-	pts_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
-		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM;
 	pts_driver->other = ptm_driver;
 	tty_set_operations(pts_driver, &pty_unix98_ops);
 

commit 6f9ea7ad7be10dca95e7ca57221c5f81be48d852
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Tue Aug 7 21:47:26 2012 +0200

    TTY: pty, stop passing NULL to free_tty_struct
    
    In case alloc_tty_struct fails in pty_common_install, we pass NULL to
    free_tty_struct. This is invalid as the function is not ready to cope
    with that. And even if it was, it is not nice to do that anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4399f1dbd131..d9ea9e2c9ec5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -303,9 +303,11 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	int retval = -ENOMEM;
 
 	o_tty = alloc_tty_struct();
+	if (!o_tty)
+		goto err;
 	ports[0] = kmalloc(sizeof **ports, GFP_KERNEL);
 	ports[1] = kmalloc(sizeof **ports, GFP_KERNEL);
-	if (!o_tty || !ports[0] || !ports[1])
+	if (!ports[0] || !ports[1])
 		goto err_free_tty;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
@@ -360,6 +362,7 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	kfree(ports[0]);
 	kfree(ports[1]);
 	free_tty_struct(o_tty);
+err:
 	return retval;
 }
 

commit 89c8d91e31f267703e365593f6bfebb9f6d2ad01
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Aug 8 16:30:13 2012 +0100

    tty: localise the lock
    
    The termios and other changes mean the other protections needed on the driver
    tty arrays should be adequate. Turn it all back on.
    
    This contains pieces folded in from the fixes made to the original patches
    
    | From: Geert Uytterhoeven <geert@linux-m68k.org>       (fix m68k)
    | From: Paul Gortmaker <paul.gortmaker@windriver.com>   (fix cris)
    | From: Jiri Kosina <jkosina@suze.cz>                   (lockdep)
    | From: Eric Dumazet <eric.dumazet@gmail.com>           (lockdep)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d6579a9064c4..4399f1dbd131 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,6 +47,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
+	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
 	tty->link->packet = 0;
@@ -62,9 +63,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock();
+		tty_unlock(tty);
 		tty_vhangup(tty->link);
-		tty_lock();
+		tty_lock(tty);
 	}
 }
 
@@ -617,26 +618,27 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	tty_lock();
+	mutex_lock(&devpts_mutex);
 	index = devpts_new_index(inode);
-	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
+	mutex_unlock(&devpts_mutex);
+
 	mutex_lock(&tty_mutex);
-	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
-	mutex_unlock(&devpts_mutex);
-	tty_lock();
-	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
 		goto out;
 	}
 
+	/* The tty returned here is locked so we can safely
+	   drop the mutex */
+	mutex_unlock(&tty_mutex);
+
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
 	tty_add_file(tty, filp);
@@ -649,16 +651,17 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_unlock();
+	tty_unlock(tty);
 	return 0;
 err_release:
-	tty_unlock();
+	tty_unlock(tty);
 	tty_release(inode, filp);
 	return retval;
 out:
+	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
-	tty_unlock();
 err_file:
+        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit d155255a344c417acad74156654295a2964e6b81
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri Jul 27 18:02:54 2012 +0100

    tty: Fix race in tty release
    
    Ian Abbott found that the tty layer would explode with the right set of
    parallel open and close operations. This is because we race in the
    handling of tty->drivers->termios[].
    
    Correct this by
            Making tty_ldisc_release behave like nromal code (takes the lock,
                            does stuff, drops the lock)
            Drop the tty lock earlier in tty_ldisc_release
            Taking the tty mutex around the driver->termios update in all cases
            Adding a WARN_ON to catch future screwups.
    
    I also forgot to clean up the pty resources properly. With a pty pair we
    need to pull both halves out of the tables.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Tested-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 60c08ce83782..d6579a9064c4 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -282,6 +282,17 @@ int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	return 0;
 }
 
+/**
+ *	pty_common_install		-	set up the pty pair
+ *	@driver: the pty driver
+ *	@tty: the tty being instantiated
+ *	@bool: legacy, true if this is BSD style
+ *
+ *	Perform the initial set up for the tty/pty pair. Called from the
+ *	tty layer when the port is first opened.
+ *
+ *	Locking: the caller must hold the tty_mutex
+ */
 static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		bool legacy)
 {
@@ -364,6 +375,14 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	return pty_common_install(driver, tty, true);
 }
 
+static void pty_remove(struct tty_driver *driver, struct tty_struct *tty)
+{
+	struct tty_struct *pair = tty->link;
+	driver->ttys[tty->index] = NULL;
+	if (pair)
+		pair->driver->ttys[pair->index] = NULL;
+}
+
 static int pty_bsd_ioctl(struct tty_struct *tty,
 			 unsigned int cmd, unsigned long arg)
 {
@@ -395,7 +414,8 @@ static const struct tty_operations master_pty_ops_bsd = {
 	.set_termios = pty_set_termios,
 	.ioctl = pty_bsd_ioctl,
 	.cleanup = pty_cleanup,
-	.resize = pty_resize
+	.resize = pty_resize,
+	.remove = pty_remove
 };
 
 static const struct tty_operations slave_pty_ops_bsd = {
@@ -409,7 +429,8 @@ static const struct tty_operations slave_pty_ops_bsd = {
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
 	.cleanup = pty_cleanup,
-	.resize = pty_resize
+	.resize = pty_resize,
+	.remove = pty_remove
 };
 
 static void __init legacy_pty_init(void)

commit 36b3c070d2346c890d690d71f6eab02f8c511137
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Jul 17 17:06:57 2012 +0100

    tty: Move the handling of the tty release logic
    
    Now that we don't have tty->termios tied to drivers->tty we can untangle
    the logic here. In addition we can push the removal logic out of the
    destructor path.
    
    At that point we can think about sorting out tty_port and console and all
    the other ugly hangovers.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 5ad7ccc49f74..60c08ce83782 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -527,12 +527,6 @@ static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
 	return tty;
 }
 
-static void pty_unix98_shutdown(struct tty_struct *tty)
-{
-	tty_driver_remove_tty(tty->driver, tty);
-	/* We have our own method as we don't use the tty index */
-}
-
 /* We have no need to install and remove our tty objects as devpts does all
    the work for us */
 
@@ -558,9 +552,8 @@ static const struct tty_operations ptm_unix98_ops = {
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
 	.ioctl = pty_unix98_ioctl,
-	.shutdown = pty_unix98_shutdown,
-	.cleanup = pty_cleanup,
-	.resize = pty_resize
+	.resize = pty_resize,
+	.cleanup = pty_cleanup
 };
 
 static const struct tty_operations pty_unix98_ops = {
@@ -575,7 +568,6 @@ static const struct tty_operations pty_unix98_ops = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
-	.shutdown = pty_unix98_shutdown,
 	.cleanup = pty_cleanup,
 };
 

commit adc8d746caa67fff4b53ba3e5163a6cbacc3b523
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Jul 14 15:31:47 2012 +0100

    tty: move the termios object into the tty
    
    This will let us sort out a whole pile of tty related races. The
    alternative would be to keep points and refcount the termios objects.
    However
    1. They are tiny anyway
    2. Many devices don't use the stored copies
    3. We can remove a pty special case
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b50fc1c01415..5ad7ccc49f74 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -231,8 +231,8 @@ static int pty_open(struct tty_struct *tty, struct file *filp)
 static void pty_set_termios(struct tty_struct *tty,
 					struct ktermios *old_termios)
 {
-	tty->termios->c_cflag &= ~(CSIZE | PARENB);
-	tty->termios->c_cflag |= (CS8 | CREAD);
+	tty->termios.c_cflag &= ~(CSIZE | PARENB);
+	tty->termios.c_cflag |= (CS8 | CREAD);
 }
 
 /**
@@ -315,18 +315,10 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		driver->other->ttys[idx] = o_tty;
 		driver->ttys[idx] = tty;
 	} else {
-		tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
-		if (tty->termios == NULL)
-			goto err_deinit_tty;
-		*tty->termios = driver->init_termios;
-		tty->termios_locked = tty->termios + 1;
-
-		o_tty->termios = kzalloc(sizeof(struct ktermios[2]),
-				GFP_KERNEL);
-		if (o_tty->termios == NULL)
-			goto err_free_termios;
-		*o_tty->termios = driver->other->init_termios;
-		o_tty->termios_locked = o_tty->termios + 1;
+		memset(&tty->termios_locked, 0, sizeof(tty->termios_locked));
+		tty->termios = driver->init_termios;
+		memset(&o_tty->termios_locked, 0, sizeof(tty->termios_locked));
+		o_tty->termios = driver->other->init_termios;
 	}
 
 	/*
@@ -349,8 +341,6 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 err_free_termios:
 	if (legacy)
 		tty_free_termios(tty);
-	else
-		kfree(tty->termios);
 err_deinit_tty:
 	deinitialize_tty_struct(o_tty);
 	module_put(o_tty->driver->owner);
@@ -541,7 +531,6 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 {
 	tty_driver_remove_tty(tty->driver, tty);
 	/* We have our own method as we don't use the tty index */
-	kfree(tty->termios);
 }
 
 /* We have no need to install and remove our tty objects as devpts does all

commit 6d31a88cb2e01d46c0cb74aa5da529e1f92ae3db
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Jul 14 15:31:27 2012 +0100

    tty: revert incorrectly applied lock patch
    
    I sent GregKH this after the pre-requisites. He dropped the pre-requesites
    for good reason and unfortunately then applied this patch. Without this
    reverted you get random kernel memory corruption which will make bisecting
    anything between it and the properly applied patches a complete sod.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index a0ca0830cbcf..b50fc1c01415 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,7 +47,6 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
-	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
 	tty->link->packet = 0;
@@ -63,9 +62,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock(tty);
+		tty_unlock();
 		tty_vhangup(tty->link);
-		tty_lock(tty);
+		tty_lock();
 	}
 }
 
@@ -616,26 +615,26 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	mutex_lock(&devpts_mutex);
+	tty_lock();
 	index = devpts_new_index(inode);
-	mutex_unlock(&devpts_mutex);
+	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
 	mutex_lock(&tty_mutex);
+	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
+	mutex_unlock(&devpts_mutex);
+	tty_lock();
+	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
 		goto out;
 	}
 
-	/* The tty returned here is locked so we can safely
-	   drop the mutex */
-	mutex_unlock(&tty_mutex);
-
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
 	tty_add_file(tty, filp);
@@ -648,15 +647,15 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_unlock(tty);
+	tty_unlock();
 	return 0;
 err_release:
-	tty_unlock(tty);
+	tty_unlock();
 	tty_release(inode, filp);
 	return retval;
 out:
-	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
+	tty_unlock();
 err_file:
 	tty_free_file(filp);
 	return retval;

commit 79d753209245de3d6f02480535a8f5cf21ad02f7
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jul 11 09:40:40 2012 +0300

    tty: double unlock on error in ptmx_open()
    
    The problem here is that we called mutex_unlock(&devpts_mutex) on the
    error path when we weren't holding the lock.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d8558834ce57..a0ca0830cbcf 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -618,13 +618,12 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	/* find a device that is not in use. */
 	mutex_lock(&devpts_mutex);
 	index = devpts_new_index(inode);
+	mutex_unlock(&devpts_mutex);
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
-	mutex_unlock(&devpts_mutex);
-
 	mutex_lock(&tty_mutex);
 	tty = tty_init_dev(ptm_driver, index);
 
@@ -659,7 +658,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
 err_file:
-        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit f5e3bcc504c3c35cc6e06a9ee42efed7c274066b
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri Jun 29 14:48:36 2012 +0100

    tty: localise the lock
    
    The termios and other changes mean the other protections needed on the driver
    tty arrays should be adequate. Turn it all back on.
    
    This contains pieces folded in from the fixes made to the original patches
    
    | From: Geert Uytterhoeven <geert@linux-m68k.org>       (fix m68k)
    | From: Paul Gortmaker <paul.gortmaker@windriver.com>   (fix cris)
    | From: Jiri Kosina <jkosina@suze.cz>                   (lockdep)
    | From: Eric Dumazet <eric.dumazet@gmail.com>           (lockdep)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b50fc1c01415..d8558834ce57 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,6 +47,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
+	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
 	tty->link->packet = 0;
@@ -62,9 +63,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock();
+		tty_unlock(tty);
 		tty_vhangup(tty->link);
-		tty_lock();
+		tty_lock(tty);
 	}
 }
 
@@ -615,26 +616,27 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	tty_lock();
+	mutex_lock(&devpts_mutex);
 	index = devpts_new_index(inode);
-	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
+	mutex_unlock(&devpts_mutex);
+
 	mutex_lock(&tty_mutex);
-	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
-	mutex_unlock(&devpts_mutex);
-	tty_lock();
-	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
 		goto out;
 	}
 
+	/* The tty returned here is locked so we can safely
+	   drop the mutex */
+	mutex_unlock(&tty_mutex);
+
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
 	tty_add_file(tty, filp);
@@ -647,16 +649,17 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_unlock();
+	tty_unlock(tty);
 	return 0;
 err_release:
-	tty_unlock();
+	tty_unlock(tty);
 	tty_release(inode, filp);
 	return retval;
 out:
+	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
-	tty_unlock();
 err_file:
+        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit d03702a27df017d1807fd4809f03adaa8e37005f
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jun 4 13:35:30 2012 +0200

    PTY: add tty_port
    
    This has *no* function in the PTY driver yet. However as the tty
    buffers will move to the tty_port structure, we will need tty_port for
    all TTYs in the system, PTY inclusive.
    
    For PTYs this is ensured by allocating 2 tty_port's in pty_install,
    i.e. where the tty->link is allocated. Both tty_port's are properly
    assigned to each end of the tty.
    
    Freeing is done at the same place where tty is freed, i.e. in
    tty->ops->cleanup.
    
    This means BTW that tty_port does not outlive TTY in PTY. This might
    be a subject to change in the future if we see some problems.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 881888f0a445..b50fc1c01415 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -286,12 +286,15 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 		bool legacy)
 {
 	struct tty_struct *o_tty;
+	struct tty_port *ports[2];
 	int idx = tty->index;
 	int retval = -ENOMEM;
 
 	o_tty = alloc_tty_struct();
-	if (!o_tty)
-		goto err;
+	ports[0] = kmalloc(sizeof **ports, GFP_KERNEL);
+	ports[1] = kmalloc(sizeof **ports, GFP_KERNEL);
+	if (!o_tty || !ports[0] || !ports[1])
+		goto err_free_tty;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
 		goto err_free_tty;
@@ -335,6 +338,10 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	/* Establish the links in both directions */
 	tty->link   = o_tty;
 	o_tty->link = tty;
+	tty_port_init(ports[0]);
+	tty_port_init(ports[1]);
+	o_tty->port = ports[0];
+	tty->port = ports[1];
 
 	tty_driver_kref_get(driver);
 	tty->count++;
@@ -348,11 +355,17 @@ static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
 	deinitialize_tty_struct(o_tty);
 	module_put(o_tty->driver->owner);
 err_free_tty:
+	kfree(ports[0]);
+	kfree(ports[1]);
 	free_tty_struct(o_tty);
-err:
 	return retval;
 }
 
+static void pty_cleanup(struct tty_struct *tty)
+{
+	kfree(tty->port);
+}
+
 /* Traditional BSD devices */
 #ifdef CONFIG_LEGACY_PTYS
 
@@ -391,6 +404,7 @@ static const struct tty_operations master_pty_ops_bsd = {
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
 	.ioctl = pty_bsd_ioctl,
+	.cleanup = pty_cleanup,
 	.resize = pty_resize
 };
 
@@ -404,6 +418,7 @@ static const struct tty_operations slave_pty_ops_bsd = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
+	.cleanup = pty_cleanup,
 	.resize = pty_resize
 };
 
@@ -555,6 +570,7 @@ static const struct tty_operations ptm_unix98_ops = {
 	.set_termios = pty_set_termios,
 	.ioctl = pty_unix98_ioctl,
 	.shutdown = pty_unix98_shutdown,
+	.cleanup = pty_cleanup,
 	.resize = pty_resize
 };
 
@@ -570,7 +586,8 @@ static const struct tty_operations pty_unix98_ops = {
 	.chars_in_buffer = pty_chars_in_buffer,
 	.unthrottle = pty_unthrottle,
 	.set_termios = pty_set_termios,
-	.shutdown = pty_unix98_shutdown
+	.shutdown = pty_unix98_shutdown,
+	.cleanup = pty_cleanup,
 };
 
 /**

commit 5d249bc6a61e7a434c69e0d0becc77a803c8c5e8
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jun 4 13:35:29 2012 +0200

    PTY: merge pty_install implementations
    
    There are currently two instances of code which handles PTY install.
    One for the legacy BSD PTY's, one for unix98's PTY's. Both of them are
    very similar and differ only in termios allocation and handling.
    
    Since we will need to allocate a tty_port at that place, this would
    require editing two places with the same pattern. Instead, let us move
    the implementation to one common place and call it from both places.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 4bcaf896fac4..881888f0a445 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -282,39 +282,53 @@ int pty_resize(struct tty_struct *tty,  struct winsize *ws)
 	return 0;
 }
 
-/* Traditional BSD devices */
-#ifdef CONFIG_LEGACY_PTYS
-
-static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
+static int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,
+		bool legacy)
 {
 	struct tty_struct *o_tty;
 	int idx = tty->index;
-	int retval;
+	int retval = -ENOMEM;
 
 	o_tty = alloc_tty_struct();
 	if (!o_tty)
-		return -ENOMEM;
+		goto err;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
-		retval = -ENOMEM;
 		goto err_free_tty;
 	}
 	initialize_tty_struct(o_tty, driver->other, idx);
 
-	/* We always use new tty termios data so we can do this
-	   the easy way .. */
-	retval = tty_init_termios(tty);
-	if (retval)
-		goto err_deinit_tty;
-
-	retval = tty_init_termios(o_tty);
-	if (retval)
-		goto err_free_termios;
+	if (legacy) {
+		/* We always use new tty termios data so we can do this
+		   the easy way .. */
+		retval = tty_init_termios(tty);
+		if (retval)
+			goto err_deinit_tty;
+
+		retval = tty_init_termios(o_tty);
+		if (retval)
+			goto err_free_termios;
+
+		driver->other->ttys[idx] = o_tty;
+		driver->ttys[idx] = tty;
+	} else {
+		tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
+		if (tty->termios == NULL)
+			goto err_deinit_tty;
+		*tty->termios = driver->init_termios;
+		tty->termios_locked = tty->termios + 1;
+
+		o_tty->termios = kzalloc(sizeof(struct ktermios[2]),
+				GFP_KERNEL);
+		if (o_tty->termios == NULL)
+			goto err_free_termios;
+		*o_tty->termios = driver->other->init_termios;
+		o_tty->termios_locked = o_tty->termios + 1;
+	}
 
 	/*
 	 * Everything allocated ... set up the o_tty structure.
 	 */
-	driver->other->ttys[idx] = o_tty;
 	tty_driver_kref_get(driver->other);
 	if (driver->subtype == PTY_TYPE_MASTER)
 		o_tty->count++;
@@ -324,18 +338,29 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 
 	tty_driver_kref_get(driver);
 	tty->count++;
-	driver->ttys[idx] = tty;
 	return 0;
 err_free_termios:
-	tty_free_termios(tty);
+	if (legacy)
+		tty_free_termios(tty);
+	else
+		kfree(tty->termios);
 err_deinit_tty:
 	deinitialize_tty_struct(o_tty);
 	module_put(o_tty->driver->owner);
 err_free_tty:
 	free_tty_struct(o_tty);
+err:
 	return retval;
 }
 
+/* Traditional BSD devices */
+#ifdef CONFIG_LEGACY_PTYS
+
+static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	return pty_common_install(driver, tty, true);
+}
+
 static int pty_bsd_ioctl(struct tty_struct *tty,
 			 unsigned int cmd, unsigned long arg)
 {
@@ -509,52 +534,7 @@ static void pty_unix98_shutdown(struct tty_struct *tty)
 
 static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 {
-	struct tty_struct *o_tty;
-	int idx = tty->index;
-
-	o_tty = alloc_tty_struct();
-	if (!o_tty)
-		return -ENOMEM;
-	if (!try_module_get(driver->other->owner)) {
-		/* This cannot in fact currently happen */
-		goto err_free_tty;
-	}
-	initialize_tty_struct(o_tty, driver->other, idx);
-
-	tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
-	if (tty->termios == NULL)
-		goto err_free_mem;
-	*tty->termios = driver->init_termios;
-	tty->termios_locked = tty->termios + 1;
-
-	o_tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
-	if (o_tty->termios == NULL)
-		goto err_free_mem;
-	*o_tty->termios = driver->other->init_termios;
-	o_tty->termios_locked = o_tty->termios + 1;
-
-	tty_driver_kref_get(driver->other);
-	if (driver->subtype == PTY_TYPE_MASTER)
-		o_tty->count++;
-	/* Establish the links in both directions */
-	tty->link   = o_tty;
-	o_tty->link = tty;
-	/*
-	 * All structures have been allocated, so now we install them.
-	 * Failures after this point use release_tty to clean up, so
-	 * there's no need to null out the local pointers.
-	 */
-	tty_driver_kref_get(driver);
-	tty->count++;
-	return 0;
-err_free_mem:
-	deinitialize_tty_struct(o_tty);
-	kfree(o_tty->termios);
-	kfree(tty->termios);
-	module_put(o_tty->driver->owner);
-err_free_tty:
-	free_tty_struct(o_tty);
-	return -ENOMEM;
+	return pty_common_install(driver, tty, false);
 }
 
 static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)

commit 7171604ae7b3bbc738b6a4b7cd0ee73eb0d551d9
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jun 4 13:35:28 2012 +0200

    PTY: remove one empty ops->remove
    
    Currently, there are two as a left-over from previous patches.
    Although we really need to provide an empty handler, we do not need
    two. So remove one of them.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 5505ffc91da4..4bcaf896fac4 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -557,18 +557,14 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	return -ENOMEM;
 }
 
-static void ptm_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
-{
-}
-
-static void pts_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
+static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
 }
 
 static const struct tty_operations ptm_unix98_ops = {
 	.lookup = ptm_unix98_lookup,
 	.install = pty_unix98_install,
-	.remove = ptm_unix98_remove,
+	.remove = pty_unix98_remove,
 	.open = pty_open,
 	.close = pty_close,
 	.write = pty_write,
@@ -585,7 +581,7 @@ static const struct tty_operations ptm_unix98_ops = {
 static const struct tty_operations pty_unix98_ops = {
 	.lookup = pts_unix98_lookup,
 	.install = pty_unix98_install,
-	.remove = pts_unix98_remove,
+	.remove = pty_unix98_remove,
 	.open = pty_open,
 	.close = pty_close,
 	.write = pty_write,

commit f309532bf3e1cc1b787403d84e3039812a7dbe50
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 2 15:21:43 2012 -0700

    tty: Revert the tty locking series, it needs more work
    
    This reverts the tty layer change to use per-tty locking, because it's
    not correct yet, and fixing it will require some more deep surgery.
    
    The main revert is d29f3ef39be4 ("tty_lock: Localise the lock"), but
    there are several smaller commits that built upon it, they also get
    reverted here. The list of reverted commits is:
    
      fde86d310886 - tty: add lockdep annotations
      8f6576ad476b - tty: fix ldisc lock inversion trace
      d3ca8b64b97e - pty: Fix lock inversion
      b1d679afd766 - tty: drop the pty lock during hangup
      abcefe5fc357 - tty/amiserial: Add missing argument for tty_unlock()
      fd11b42e3598 - cris: fix missing tty arg in wait_event_interruptible_tty call
      d29f3ef39be4 - tty_lock: Localise the lock
    
    The revert had a trivial conflict in the 68360serial.c staging driver
    that got removed in the meantime.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 65c7c62c7aae..5505ffc91da4 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,7 +47,6 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
-	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
 	tty->link->packet = 0;
@@ -63,9 +62,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock(tty);
+		tty_unlock();
 		tty_vhangup(tty->link);
-		tty_lock(tty);
+		tty_lock();
 	}
 }
 
@@ -623,27 +622,26 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	mutex_lock(&devpts_mutex);
+	tty_lock();
 	index = devpts_new_index(inode);
+	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
-	mutex_unlock(&devpts_mutex);
-
 	mutex_lock(&tty_mutex);
+	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
+	mutex_unlock(&devpts_mutex);
+	tty_lock();
+	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
 		goto out;
 	}
 
-	/* The tty returned here is locked so we can safely
-	   drop the mutex */
-	mutex_unlock(&tty_mutex);
-
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
 	tty_add_file(tty, filp);
@@ -656,17 +654,16 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_unlock(tty);
+	tty_unlock();
 	return 0;
 err_release:
-	tty_unlock(tty);
+	tty_unlock();
 	tty_release(inode, filp);
 	return retval;
 out:
-	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
+	tty_unlock();
 err_file:
-        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit d3ca8b64b97ef4dc54d7bb0b88bbc01a1fca8cb9
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue May 29 13:45:01 2012 +0100

    pty: Fix lock inversion
    
    The ptmx_open path takes the tty and devpts locks in the wrong order
    because tty_init_dev locks and returns a locked tty.  As far as I can
    tell this is actually safe anyway because the tty being returned is new
    so nobody can get a reference to lock it at this point.
    
    However we don't even need the devpts lock at this point, it's only held
    as a byproduct of the way the locks were pushe down.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 59af3945ea85..65c7c62c7aae 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -633,7 +633,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	mutex_unlock(&devpts_mutex);
 
 	mutex_lock(&tty_mutex);
-	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
 
 	if (IS_ERR(tty)) {
@@ -643,7 +642,6 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	/* The tty returned here is locked so we can safely
 	   drop the mutex */
-	mutex_unlock(&devpts_mutex);
 	mutex_unlock(&tty_mutex);
 
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */

commit b1d679afd766cf425ba1cd2a0fd17451bd212f4a
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed May 9 17:03:19 2012 +0100

    tty: drop the pty lock during hangup
    
    In theory we don't need it, in practice we are hitting some ill understood
    deadlock when we don't drop it. The old code dropped it here so we are not
    undoing anything problematic for pty. If pty could be unloaded it would be
    a problem but it can't.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d6fa8429f3ff..59af3945ea85 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -63,7 +63,9 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
+		tty_unlock(tty);
 		tty_vhangup(tty->link);
+		tty_lock(tty);
 	}
 }
 

commit d29f3ef39be4eec0362b985305fc526d9be318cf
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu May 3 22:24:08 2012 +0100

    tty_lock: Localise the lock
    
    In each remaining case the tty_lock is associated with a specific tty. This
    means we can now lock on a per tty basis. We do need tty_lock_pair() for
    the pty case. Uglier but still a step in the right direction.
    
    [fixed up calls in 3 missing drivers - gregkh]
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 5505ffc91da4..d6fa8429f3ff 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -47,6 +47,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->read_wait);
 	wake_up_interruptible(&tty->write_wait);
 	tty->packet = 0;
+	/* Review - krefs on tty_link ?? */
 	if (!tty->link)
 		return;
 	tty->link->packet = 0;
@@ -62,9 +63,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 		        mutex_unlock(&devpts_mutex);
 		}
 #endif
-		tty_unlock();
 		tty_vhangup(tty->link);
-		tty_lock();
 	}
 }
 
@@ -622,26 +621,29 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	tty_lock();
+	mutex_lock(&devpts_mutex);
 	index = devpts_new_index(inode);
-	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
 	}
 
+	mutex_unlock(&devpts_mutex);
+
 	mutex_lock(&tty_mutex);
 	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
-	mutex_unlock(&devpts_mutex);
-	tty_lock();
-	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
 		goto out;
 	}
 
+	/* The tty returned here is locked so we can safely
+	   drop the mutex */
+	mutex_unlock(&devpts_mutex);
+	mutex_unlock(&tty_mutex);
+
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
 	tty_add_file(tty, filp);
@@ -654,16 +656,17 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto err_release;
 
-	tty_unlock();
+	tty_unlock(tty);
 	return 0;
 err_release:
-	tty_unlock();
+	tty_unlock(tty);
 	tty_release(inode, filp);
 	return retval;
 out:
+	mutex_unlock(&tty_mutex);
 	devpts_kill_index(inode, index);
-	tty_unlock();
 err_file:
+        mutex_unlock(&devpts_mutex);
 	tty_free_file(filp);
 	return retval;
 }

commit d739e65bb21d34f0f5d3bf4048410e534fbec148
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu May 3 22:22:09 2012 +0100

    pty: Lock the devpts bits privately
    
    This is a private pty affair, we don't want to tangle it with the tty_lock
    any more as we know all the other non tty locking is now handled by the vfs
    so we too can move.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index eeae7fafe9a7..5505ffc91da4 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -26,11 +26,13 @@
 #include <linux/bitops.h>
 #include <linux/devpts_fs.h>
 #include <linux/slab.h>
+#include <linux/mutex.h>
 
 
 #ifdef CONFIG_UNIX98_PTYS
 static struct tty_driver *ptm_driver;
 static struct tty_driver *pts_driver;
+static DEFINE_MUTEX(devpts_mutex);
 #endif
 
 static void pty_close(struct tty_struct *tty, struct file *filp)
@@ -54,8 +56,11 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
 #ifdef CONFIG_UNIX98_PTYS
-		if (tty->driver == ptm_driver)
+		if (tty->driver == ptm_driver) {
+		        mutex_lock(&devpts_mutex);
 			devpts_pty_kill(tty->link);
+		        mutex_unlock(&devpts_mutex);
+		}
 #endif
 		tty_unlock();
 		tty_vhangup(tty->link);
@@ -475,13 +480,17 @@ static struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,
  *	@idx: tty index
  *
  *	Look up a pty master device. Called under the tty_mutex for now.
- *	This provides our locking.
+ *	This provides our locking for the tty pointer.
  */
 
 static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
 		struct inode *pts_inode, int idx)
 {
-	struct tty_struct *tty = devpts_get_tty(pts_inode, idx);
+	struct tty_struct *tty;
+
+	mutex_lock(&devpts_mutex);
+	tty = devpts_get_tty(pts_inode, idx);
+	mutex_unlock(&devpts_mutex);
 	/* Master must be open before slave */
 	if (!tty)
 		return ERR_PTR(-EIO);
@@ -622,8 +631,10 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	}
 
 	mutex_lock(&tty_mutex);
-	tty_lock();
+	mutex_lock(&devpts_mutex);
 	tty = tty_init_dev(ptm_driver, index);
+	mutex_unlock(&devpts_mutex);
+	tty_lock();
 	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index f96ecaec24f8..eeae7fafe9a7 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -27,7 +27,6 @@
 #include <linux/devpts_fs.h>
 #include <linux/slab.h>
 
-#include <asm/system.h>
 
 #ifdef CONFIG_UNIX98_PTYS
 static struct tty_driver *ptm_driver;

commit 2f16669d322e05171c9e1cfd94f402f7399bd2a3
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Mar 5 14:51:52 2012 +0100

    TTY: remove re-assignments to tty_driver members
    
    All num, magic and owner are set by alloc_tty_driver. No need to
    re-set them on each allocation site.
    
    pti driver sets something different to what it passes to
    alloc_tty_driver. It is not a bug, since we don't use the lines
    parameter in any way. Anyway this is fixed, and now we do the right
    thing.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d505837b3478..f96ecaec24f8 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -393,7 +393,6 @@ static void __init legacy_pty_init(void)
 	if (!pty_slave_driver)
 		panic("Couldn't allocate pty slave driver");
 
-	pty_driver->owner = THIS_MODULE;
 	pty_driver->driver_name = "pty_master";
 	pty_driver->name = "pty";
 	pty_driver->major = PTY_MASTER_MAJOR;
@@ -411,7 +410,6 @@ static void __init legacy_pty_init(void)
 	pty_driver->other = pty_slave_driver;
 	tty_set_operations(pty_driver, &master_pty_ops_bsd);
 
-	pty_slave_driver->owner = THIS_MODULE;
 	pty_slave_driver->driver_name = "pty_slave";
 	pty_slave_driver->name = "ttyp";
 	pty_slave_driver->major = PTY_SLAVE_MAJOR;
@@ -671,7 +669,6 @@ static void __init unix98_pty_init(void)
 	if (!pts_driver)
 		panic("Couldn't allocate Unix98 pts driver");
 
-	ptm_driver->owner = THIS_MODULE;
 	ptm_driver->driver_name = "pty_master";
 	ptm_driver->name = "ptm";
 	ptm_driver->major = UNIX98_PTY_MASTER_MAJOR;
@@ -690,7 +687,6 @@ static void __init unix98_pty_init(void)
 	ptm_driver->other = pts_driver;
 	tty_set_operations(ptm_driver, &ptm_unix98_ops);
 
-	pts_driver->owner = THIS_MODULE;
 	pts_driver->driver_name = "pty_slave";
 	pts_driver->name = "pts";
 	pts_driver->major = UNIX98_PTY_SLAVE_MAJOR;

commit ce1000ddca01c81684da844be4676eac50a70c2a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Feb 24 13:56:36 2012 -0800

    Revert "TTY: pty, remove superfluous ptm test"
    
    This reverts commit a50f724a432997321cabb6c9e665c28e34850f78.
    
    Sasha reported that this causes problems, so revert it.
    
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index ddec9f3c3396..d505837b3478 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -54,7 +54,10 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
-		devpts_pty_kill(tty->link);
+#ifdef CONFIG_UNIX98_PTYS
+		if (tty->driver == ptm_driver)
+			devpts_pty_kill(tty->link);
+#endif
 		tty_unlock();
 		tty_vhangup(tty->link);
 		tty_lock();

commit 0ef1698e4d6282a1665207c40b115ec78fceda9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Feb 24 13:55:54 2012 -0800

    Revert "TTY: get rid of BTM around devpts_*"
    
    This reverts commit d3bda5298aad98c7a27678bdd0dd9d008ab9e685.
    
    Sasha reported that this causes problems, so revert it.
    
    Cc: Sasha Levin <levinsasha928@gmail.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 39afd045f8ef..ddec9f3c3396 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -54,8 +54,8 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
-		tty_unlock();
 		devpts_pty_kill(tty->link);
+		tty_unlock();
 		tty_vhangup(tty->link);
 		tty_lock();
 	}
@@ -613,7 +613,9 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
+	tty_lock();
 	index = devpts_new_index(inode);
+	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
@@ -648,8 +650,8 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	tty_release(inode, filp);
 	return retval;
 out:
-	tty_unlock();
 	devpts_kill_index(inode, index);
+	tty_unlock();
 err_file:
 	tty_free_file(filp);
 	return retval;

commit d3bda5298aad98c7a27678bdd0dd9d008ab9e685
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jan 30 21:14:32 2012 +0100

    TTY: get rid of BTM around devpts_*
    
    devpts operations are protected by inode mutexes and dentry
    refcounting. There is no need to hold BTM.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index ddec9f3c3396..39afd045f8ef 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -54,8 +54,8 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
-		devpts_pty_kill(tty->link);
 		tty_unlock();
+		devpts_pty_kill(tty->link);
 		tty_vhangup(tty->link);
 		tty_lock();
 	}
@@ -613,9 +613,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 		return retval;
 
 	/* find a device that is not in use. */
-	tty_lock();
 	index = devpts_new_index(inode);
-	tty_unlock();
 	if (index < 0) {
 		retval = index;
 		goto err_file;
@@ -650,8 +648,8 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	tty_release(inode, filp);
 	return retval;
 out:
-	devpts_kill_index(inode, index);
 	tty_unlock();
+	devpts_kill_index(inode, index);
 err_file:
 	tty_free_file(filp);
 	return retval;

commit a50f724a432997321cabb6c9e665c28e34850f78
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jan 30 21:14:31 2012 +0100

    TTY: pty, remove superfluous ptm test
    
    The code looks like:
    if (tty->driver->subtype == PTY_TYPE_MASTER) {
      ...
      if (tty->driver == ptm_driver)
    
    But the second if is superfluous because only the ptm_driver is of
    PTY_TYPE_MASTER subtype.
    
    Also we can remove the #if now because devpts_pty_kill is defined as
    an empty function for non-CONFIG_UNIX98_PTYS configs.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d505837b3478..ddec9f3c3396 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -54,10 +54,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 	wake_up_interruptible(&tty->link->write_wait);
 	if (tty->driver->subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &tty->flags);
-#ifdef CONFIG_UNIX98_PTYS
-		if (tty->driver == ptm_driver)
-			devpts_pty_kill(tty->link);
-#endif
+		devpts_pty_kill(tty->link);
 		tty_unlock();
 		tty_vhangup(tty->link);
 		tty_lock();

commit a4834c102f4a46808630cad1a545cb0706b3b0a2
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Thu Jan 5 13:06:02 2012 +0400

    tty: move pty count limiting into devpts
    
    Let's move this stuff to the better place, where we can account pty right in
    tty-indexes managing code.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 03147fa31d47..d505837b3478 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -21,7 +21,6 @@
 #include <linux/major.h>
 #include <linux/mm.h>
 #include <linux/init.h>
-#include <linux/sysctl.h>
 #include <linux/device.h>
 #include <linux/uaccess.h>
 #include <linux/bitops.h>
@@ -439,55 +438,9 @@ static inline void legacy_pty_init(void) { }
 
 /* Unix98 devices */
 #ifdef CONFIG_UNIX98_PTYS
-/*
- * sysctl support for setting limits on the number of Unix98 ptys allocated.
- * Otherwise one can eat up all kernel memory by opening /dev/ptmx repeatedly.
- */
-int pty_limit = NR_UNIX98_PTY_DEFAULT;
-static int pty_limit_min;
-static int pty_limit_max = NR_UNIX98_PTY_MAX;
-static int pty_count;
 
 static struct cdev ptmx_cdev;
 
-static struct ctl_table pty_table[] = {
-	{
-		.procname	= "max",
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.data		= &pty_limit,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= &pty_limit_min,
-		.extra2		= &pty_limit_max,
-	}, {
-		.procname	= "nr",
-		.maxlen		= sizeof(int),
-		.mode		= 0444,
-		.data		= &pty_count,
-		.proc_handler	= proc_dointvec,
-	}, 
-	{}
-};
-
-static struct ctl_table pty_kern_table[] = {
-	{
-		.procname	= "pty",
-		.mode		= 0555,
-		.child		= pty_table,
-	},
-	{}
-};
-
-static struct ctl_table pty_root_table[] = {
-	{
-		.procname	= "kernel",
-		.mode		= 0555,
-		.child		= pty_kern_table,
-	},
-	{}
-};
-
-
 static int pty_unix98_ioctl(struct tty_struct *tty,
 			    unsigned int cmd, unsigned long arg)
 {
@@ -587,7 +540,6 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	 */
 	tty_driver_kref_get(driver);
 	tty->count++;
-	pty_count++;
 	return 0;
 err_free_mem:
 	deinitialize_tty_struct(o_tty);
@@ -601,7 +553,6 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 
 static void ptm_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
-	pty_count--;
 }
 
 static void pts_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
@@ -760,8 +711,6 @@ static void __init unix98_pty_init(void)
 	if (tty_register_driver(pts_driver))
 		panic("Couldn't register Unix98 pts driver");
 
-	register_sysctl_table(pty_root_table);
-
 	/* Now create the /dev/ptmx special device */
 	tty_default_fops(&ptmx_fops);
 	ptmx_fops.open = ptmx_open;

commit 593a27c4b212e2afdf772a1f8dcb894e91bda0fa
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Thu Jan 5 13:04:21 2012 +0400

    tty: cleanup prohibition of direct opening for unix98 pty master
    
    cleanup hack added in v2.6.27-3203-g15582d3
    
    comment from that patch:
    
    : pty: If the administrator creates a device for a ptmx slave we should not error
    :
    : The open path for ptmx slaves is via the ptmx device. Opening them any
    : other way is not allowed. Vegard Nossum found that previously this was not
    : the case and mknod foo c 128 42; cat foo would produce nasty diagnostics
    :
    : Signed-off-by: Alan Cox <alan@redhat.com>
    : Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    devpts_get_tty() returns non-null only for inodes on devpts, but there is no
    inodes for master-devices, /dev/ptmx (/dev/pts/ptmx) is the only way to open them.
    Thus we can completely forbid lookup for master-devices and eliminate that hack in
    tty_init_dev() because tty_open() will get EIO from tty_driver_lookup_tty().
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d8653ab6f498..03147fa31d47 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -515,10 +515,8 @@ static int pty_unix98_ioctl(struct tty_struct *tty,
 static struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,
 		struct inode *ptm_inode, int idx)
 {
-	struct tty_struct *tty = devpts_get_tty(ptm_inode, idx);
-	if (tty)
-		tty = tty->link;
-	return tty;
+	/* Master must be open via /dev/ptmx */
+	return ERR_PTR(-EIO);
 }
 
 /**
@@ -677,7 +675,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	mutex_lock(&tty_mutex);
 	tty_lock();
-	tty = tty_init_dev(ptm_driver, index, 1);
+	tty = tty_init_dev(ptm_driver, index);
 	mutex_unlock(&tty_mutex);
 
 	if (IS_ERR(tty)) {

commit 484af54d432c39891ff27ad0e5194d28513063cc
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Nov 16 16:27:11 2011 +0100

    TTY: pty, cleanup the pty counting
    
    Instead of the hackish way of counting ptys, let's define a specific
    ->remove hook both from slave and master. And decrease the count only
    for master.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index e18604b3fc7d..d8653ab6f498 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -446,19 +446,8 @@ static inline void legacy_pty_init(void) { }
 int pty_limit = NR_UNIX98_PTY_DEFAULT;
 static int pty_limit_min;
 static int pty_limit_max = NR_UNIX98_PTY_MAX;
-static int tty_count;
 static int pty_count;
 
-static inline void pty_inc_count(void)
-{
-	pty_count = (++tty_count) / 2;
-}
-
-static inline void pty_dec_count(void)
-{
-	pty_count = (--tty_count) / 2;
-}
-
 static struct cdev ptmx_cdev;
 
 static struct ctl_table pty_table[] = {
@@ -600,8 +589,7 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	 */
 	tty_driver_kref_get(driver);
 	tty->count++;
-	pty_inc_count(); /* tty */
-	pty_inc_count(); /* tty->link */
+	pty_count++;
 	return 0;
 err_free_mem:
 	deinitialize_tty_struct(o_tty);
@@ -613,15 +601,19 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	return -ENOMEM;
 }
 
-static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
+static void ptm_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
+{
+	pty_count--;
+}
+
+static void pts_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
-	pty_dec_count();
 }
 
 static const struct tty_operations ptm_unix98_ops = {
 	.lookup = ptm_unix98_lookup,
 	.install = pty_unix98_install,
-	.remove = pty_unix98_remove,
+	.remove = ptm_unix98_remove,
 	.open = pty_open,
 	.close = pty_close,
 	.write = pty_write,
@@ -638,7 +630,7 @@ static const struct tty_operations ptm_unix98_ops = {
 static const struct tty_operations pty_unix98_ops = {
 	.lookup = pts_unix98_lookup,
 	.install = pty_unix98_install,
-	.remove = pty_unix98_remove,
+	.remove = pts_unix98_remove,
 	.open = pty_open,
 	.close = pty_close,
 	.write = pty_write,

commit efb8d21b2c6db3497655cc6a033ae8a9883e4063
Merge: 3cb603284b3d d208a3bf77f9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 26 15:11:09 2011 +0200

    Merge branch 'tty-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    * 'tty-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (79 commits)
      TTY: serial_core: Fix crash if DCD drop during suspend
      tty/serial: atmel_serial: bootconsole removed from auto-enumerates
      Revert "TTY: call tty_driver_lookup_tty unconditionally"
      tty/serial: atmel_serial: add device tree support
      tty/serial: atmel_serial: auto-enumerate ports
      tty/serial: atmel_serial: whitespace and braces modifications
      tty/serial: atmel_serial: change platform_data variable name
      tty/serial: RS485 bindings for device tree
      TTY: call tty_driver_lookup_tty unconditionally
      TTY: pty, release tty in all ptmx_open fail paths
      TTY: make tty_add_file non-failing
      TTY: drop driver reference in tty_open fail path
      8250_pci: Fix kernel panic when pch_uart is disabled
      h8300: drivers/serial/Kconfig was moved
      parport_pc: release IO region properly if unsupported ITE887x card is found
      tty: Support compat_ioctl get/set termios_locked
      hvc_console: display printk messages on console.
      TTY: snyclinkmp: forever loop in tx_load_dma_buffer()
      tty/n_gsm: avoid fifo overflow in gsm_dlci_data_output
      tty/n_gsm: fix a bug in gsm_dlci_data_output (adaption = 2 case)
      ...
    
    Fix up Conflicts in:
     - drivers/tty/serial/8250_pci.c
            Trivial conflict with removed duplicate device ID
     - drivers/tty/serial/atmel_serial.c
            Annoying silly conflict between "specify the port num via
            platform_data" and other changes to atmel_console_init

commit 1177c0efc04d032644895b8d757f55b433912596
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Oct 12 11:32:44 2011 +0200

    TTY: pty, release tty in all ptmx_open fail paths
    
    Mistakenly, commit 64ba3dc3143d (tty: never hold BTM while getting
    tty_mutex) switched one fail path in ptmx_open to not free the newly
    allocated tty.
    
    Fix that by jumping to the appropriate place. And rename the labels so
    that it's clear what is going on there.
    
    Introduced-in: v2.6.36-rc2
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: stable <stable@vger.kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7613f95f2d6b..2feea63d497a 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -686,15 +686,15 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	retval = devpts_pty_new(inode, tty->link);
 	if (retval)
-		goto out1;
+		goto err_release;
 
 	retval = ptm_driver->ops->open(tty, filp);
 	if (retval)
-		goto out2;
-out1:
+		goto err_release;
+
 	tty_unlock();
-	return retval;
-out2:
+	return 0;
+err_release:
 	tty_unlock();
 	tty_release(inode, filp);
 	return retval;

commit fa90e1c935472281de314e6d7c9a37db9cbc2e4e
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Oct 12 11:32:43 2011 +0200

    TTY: make tty_add_file non-failing
    
    If tty_add_file fails at the point it is now, we have to revert all
    the changes we did to the tty. It means either decrease all refcounts
    if this was a tty reopen or delete the tty if it was newly allocated.
    
    There was a try to fix this in v3.0-rc2 using tty_release in 0259894c7
    (TTY: fix fail path in tty_open). But instead it introduced a NULL
    dereference. It's because tty_release dereferences
    filp->private_data, but that one is set even in our tty_add_file. And
    when tty_add_file fails, it's still NULL/garbage. Hence tty_release
    cannot be called there.
    
    To circumvent the original leak (and the current NULL deref) we split
    tty_add_file into two functions, making the latter non-failing. In
    that case we may do the former early in open, where handling failures
    is easy. The latter stays as it is now. So there is no change in
    functionality.
    
    The original bug (leak) was introduced by f573bd176 (tty: Remove
    __GFP_NOFAIL from tty_add_file()). Thanks Dan for reporting this.
    
    Later, we may split tty_release into more functions and call only some
    of them in this fail path instead. (If at all possible.)
    
    Introduced-in: v2.6.37-rc2
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Pekka Enberg <penberg@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 98b6e3bdb000..7613f95f2d6b 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -657,12 +657,18 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	nonseekable_open(inode, filp);
 
+	retval = tty_alloc_file(filp);
+	if (retval)
+		return retval;
+
 	/* find a device that is not in use. */
 	tty_lock();
 	index = devpts_new_index(inode);
 	tty_unlock();
-	if (index < 0)
-		return index;
+	if (index < 0) {
+		retval = index;
+		goto err_file;
+	}
 
 	mutex_lock(&tty_mutex);
 	tty_lock();
@@ -676,9 +682,7 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 
-	retval = tty_add_file(tty, filp);
-	if (retval)
-		goto out;
+	tty_add_file(tty, filp);
 
 	retval = devpts_pty_new(inode, tty->link);
 	if (retval)
@@ -697,6 +701,8 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 out:
 	devpts_kill_index(inode, index);
 	tty_unlock();
+err_file:
+	tty_free_file(filp);
 	return retval;
 }
 

commit 24d406a6bf736f7aebdc8fa0f0ec86e0890c6d24
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 10 14:59:28 2011 +0200

    TTY: pty, fix pty counting
    
    tty_operations->remove is normally called like:
    queue_release_one_tty
     ->tty_shutdown
       ->tty_driver_remove_tty
         ->tty_operations->remove
    
    However tty_shutdown() is called from queue_release_one_tty() only if
    tty_operations->shutdown is NULL. But for pty, it is not.
    pty_unix98_shutdown() is used there as ->shutdown.
    
    So tty_operations->remove of pty (i.e. pty_unix98_remove()) is never
    called. This results in invalid pty_count. I.e. what can be seen in
    /proc/sys/kernel/pty/nr.
    
    I see this was already reported at:
      https://lkml.org/lkml/2009/11/5/370
    But it was not fixed since then.
    
    This patch is kind of a hackish way. The problem lies in ->install. We
    allocate there another tty (so-called tty->link). So ->install is
    called once, but ->remove twice, for both tty and tty->link. The fix
    here is to count both tty and tty->link and divide the count by 2 for
    user.
    
    And to have ->remove called, let's make tty_driver_remove_tty() global
    and call that from pty_unix98_shutdown() (tty_operations->shutdown).
    
    While at it, let's document that when ->shutdown is defined,
    tty_shutdown() is not called.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 98b6e3bdb000..e809e9d4683c 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -446,8 +446,19 @@ static inline void legacy_pty_init(void) { }
 int pty_limit = NR_UNIX98_PTY_DEFAULT;
 static int pty_limit_min;
 static int pty_limit_max = NR_UNIX98_PTY_MAX;
+static int tty_count;
 static int pty_count;
 
+static inline void pty_inc_count(void)
+{
+	pty_count = (++tty_count) / 2;
+}
+
+static inline void pty_dec_count(void)
+{
+	pty_count = (--tty_count) / 2;
+}
+
 static struct cdev ptmx_cdev;
 
 static struct ctl_table pty_table[] = {
@@ -542,6 +553,7 @@ static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
 
 static void pty_unix98_shutdown(struct tty_struct *tty)
 {
+	tty_driver_remove_tty(tty->driver, tty);
 	/* We have our own method as we don't use the tty index */
 	kfree(tty->termios);
 }
@@ -588,7 +600,8 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	 */
 	tty_driver_kref_get(driver);
 	tty->count++;
-	pty_count++;
+	pty_inc_count(); /* tty */
+	pty_inc_count(); /* tty->link */
 	return 0;
 err_free_mem:
 	deinitialize_tty_struct(o_tty);
@@ -602,7 +615,7 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 
 static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 {
-	pty_count--;
+	pty_dec_count();
 }
 
 static const struct tty_operations ptm_unix98_ops = {

commit 99edb3d10a9d384d69557bd09cc39b9ec62aa04e
Author: Jovi Zhang <bookjovi@gmail.com>
Date:   Wed Mar 30 05:30:41 2011 -0400

    tty: remove invalid location line in file header
    
    remove invalid location line in each file header after location
    moved from driver/char to driver/tty
    
    Signed-off-by: Jovi Zhang <bookjovi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 21bddf359dbb..98b6e3bdb000 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -1,6 +1,4 @@
 /*
- *  linux/drivers/char/pty.c
- *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *
  *  Added support for a Unix98-style ptmx device.

commit a9dccddb60913056bcadaeeacfe0395447fd2472
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Mar 23 10:48:36 2011 +0100

    TTY: plug in deinitialize_tty_struct
    
    Used the newly introduced deinitialize_tty_struct to properly shut
    down ldisc.
    
    It is intended to fix the Julian's reported problem. He reports that
    kmemleak checker warns about memory leak:
    unreferenced object 0xc0e19860 (size 8):
    comm cat, pid 1226, jiffies 4294919464 (age 287.476s)
    hex dump (first 8 bytes):
    44 de 2d c1 01 00 00 00 D.-.....
    backtrace:
    [<c1065a74>] create_object+0x109/0x1ad
    [<c1063d2b>] kmem_cache_alloc+0x60/0x68
    [<c113505c>] tty_ldisc_get+0x54/0x76
    [<c11358c9>] tty_ldisc_init+0xa/0x20
    [<c1130ab4>] initialize_tty_struct+0x2d/0x1ac
    [<c1130c8c>] tty_init_dev+0x59/0x10d
    [<c113136d>] tty_open+0x24a/0x3a2
    ...
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reported-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index b25d6c4014a5..21bddf359dbb 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -304,7 +304,7 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	   the easy way .. */
 	retval = tty_init_termios(tty);
 	if (retval)
-		goto err_module_put;
+		goto err_deinit_tty;
 
 	retval = tty_init_termios(o_tty);
 	if (retval)
@@ -327,7 +327,8 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	return 0;
 err_free_termios:
 	tty_free_termios(tty);
-err_module_put:
+err_deinit_tty:
+	deinitialize_tty_struct(o_tty);
 	module_put(o_tty->driver->owner);
 err_free_tty:
 	free_tty_struct(o_tty);
@@ -592,6 +593,7 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	pty_count++;
 	return 0;
 err_free_mem:
+	deinitialize_tty_struct(o_tty);
 	kfree(o_tty->termios);
 	kfree(tty->termios);
 	module_put(o_tty->driver->owner);

commit c18d77aa00cde1215d9e045ba8f93004fe843f38
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Mar 23 10:48:34 2011 +0100

    TTY: unify pty_unix98_install fail path handling
    
    Change it so that we call the deinit functions at one place at the end
    of the function (by gotos). And while at it use some sane label names.
    
    This is a preparation for the deinitialization of tty in the next
    patch.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index f5119184259c..b25d6c4014a5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -560,20 +560,19 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 		return -ENOMEM;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
-		free_tty_struct(o_tty);
-		return -ENOMEM;
+		goto err_free_tty;
 	}
 	initialize_tty_struct(o_tty, driver->other, idx);
 
 	tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
 	if (tty->termios == NULL)
-		goto free_mem_out;
+		goto err_free_mem;
 	*tty->termios = driver->init_termios;
 	tty->termios_locked = tty->termios + 1;
 
 	o_tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
 	if (o_tty->termios == NULL)
-		goto free_mem_out;
+		goto err_free_mem;
 	*o_tty->termios = driver->other->init_termios;
 	o_tty->termios_locked = o_tty->termios + 1;
 
@@ -592,11 +591,12 @@ static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
 	tty->count++;
 	pty_count++;
 	return 0;
-free_mem_out:
+err_free_mem:
 	kfree(o_tty->termios);
+	kfree(tty->termios);
 	module_put(o_tty->driver->owner);
+err_free_tty:
 	free_tty_struct(o_tty);
-	kfree(tty->termios);
 	return -ENOMEM;
 }
 

commit 8a1b8d70a07628f294f30485acf81971e3fcc755
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Mar 23 10:48:33 2011 +0100

    TTY: unify pty_install fail path handling
    
    Change it so that we call the deinit functions at one place at the end
    of the function (by gotos). And while at it use some sane label names.
    
    This is a preparation for the deinitialization of tty in the next
    patch.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 210774726add..f5119184259c 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -295,8 +295,8 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 		return -ENOMEM;
 	if (!try_module_get(driver->other->owner)) {
 		/* This cannot in fact currently happen */
-		free_tty_struct(o_tty);
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto err_free_tty;
 	}
 	initialize_tty_struct(o_tty, driver->other, idx);
 
@@ -304,13 +304,11 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	   the easy way .. */
 	retval = tty_init_termios(tty);
 	if (retval)
-		goto free_mem_out;
+		goto err_module_put;
 
 	retval = tty_init_termios(o_tty);
-	if (retval) {
-		tty_free_termios(tty);
-		goto free_mem_out;
-	}
+	if (retval)
+		goto err_free_termios;
 
 	/*
 	 * Everything allocated ... set up the o_tty structure.
@@ -327,10 +325,13 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	tty->count++;
 	driver->ttys[idx] = tty;
 	return 0;
-free_mem_out:
+err_free_termios:
+	tty_free_termios(tty);
+err_module_put:
 	module_put(o_tty->driver->owner);
+err_free_tty:
 	free_tty_struct(o_tty);
-	return -ENOMEM;
+	return retval;
 }
 
 static int pty_bsd_ioctl(struct tty_struct *tty,

commit f74b9444192c60603020c61d7915b72893137edc
Merge: 7a6362800cb7 4ba8216cd905
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 17:21:00 2011 -0700

    Merge branch 'config' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'config' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      BKL: That's all, folks
      fs/locks.c: Remove stale FIXME left over from BKL conversion
      ipx: remove the BKL
      appletalk: remove the BKL
      x25: remove the BKL
      ufs: remove the BKL
      hpfs: remove the BKL
      drivers: remove extraneous includes of smp_lock.h
      tracing: don't trace the BKL
      adfs: remove the big kernel lock

commit 5edc341313a188d94cde7ef87ac31647cea8601a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 25 22:08:05 2011 +0100

    drivers: remove extraneous includes of smp_lock.h
    
    These were missed the last time I cleaned this up
    globally, because of code moving around or new code
    getting merged.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 923a48585501..2310cb7282ff 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -23,7 +23,6 @@
 #include <linux/major.h>
 #include <linux/mm.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/sysctl.h>
 #include <linux/device.h>
 #include <linux/uaccess.h>

commit 6caa76b7786891b42b66a0e61e2c2fff2c884620
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:27:22 2011 +0000

    tty: now phase out the ioctl file pointer for good
    
    Only oddities here are a couple of drivers that bogusly called the ldisc
    helpers instead of returning -ENOIOCTLCMD. Fix the bug and the rest goes
    away.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 923a48585501..c88029af84dd 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -334,7 +334,7 @@ static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
 	return -ENOMEM;
 }
 
-static int pty_bsd_ioctl(struct tty_struct *tty, struct file *file,
+static int pty_bsd_ioctl(struct tty_struct *tty,
 			 unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
@@ -489,7 +489,7 @@ static struct ctl_table pty_root_table[] = {
 };
 
 
-static int pty_unix98_ioctl(struct tty_struct *tty, struct file *file,
+static int pty_unix98_ioctl(struct tty_struct *tty,
 			    unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {

commit 96fd7ce58ffb5c7bf376796b5525ba3ea1c9d69f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 4 11:10:29 2010 -0700

    TTY: create drivers/tty and move the tty core files there
    
    The tty code should be in its own subdirectory and not in the char
    driver with all of the cruft that is currently there.
    
    Based on work done by Arnd Bergmann <arnd@arndb.de>
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
new file mode 100644
index 000000000000..923a48585501
--- /dev/null
+++ b/drivers/tty/pty.c
@@ -0,0 +1,777 @@
+/*
+ *  linux/drivers/char/pty.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ *  Added support for a Unix98-style ptmx device.
+ *    -- C. Scott Ananian <cananian@alumni.princeton.edu>, 14-Jan-1998
+ *
+ *  When reading this code see also fs/devpts. In particular note that the
+ *  driver_data field is used by the devpts side as a binding to the devpts
+ *  inode.
+ */
+
+#include <linux/module.h>
+
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/sysctl.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/devpts_fs.h>
+#include <linux/slab.h>
+
+#include <asm/system.h>
+
+#ifdef CONFIG_UNIX98_PTYS
+static struct tty_driver *ptm_driver;
+static struct tty_driver *pts_driver;
+#endif
+
+static void pty_close(struct tty_struct *tty, struct file *filp)
+{
+	BUG_ON(!tty);
+	if (tty->driver->subtype == PTY_TYPE_MASTER)
+		WARN_ON(tty->count > 1);
+	else {
+		if (tty->count > 2)
+			return;
+	}
+	wake_up_interruptible(&tty->read_wait);
+	wake_up_interruptible(&tty->write_wait);
+	tty->packet = 0;
+	if (!tty->link)
+		return;
+	tty->link->packet = 0;
+	set_bit(TTY_OTHER_CLOSED, &tty->link->flags);
+	wake_up_interruptible(&tty->link->read_wait);
+	wake_up_interruptible(&tty->link->write_wait);
+	if (tty->driver->subtype == PTY_TYPE_MASTER) {
+		set_bit(TTY_OTHER_CLOSED, &tty->flags);
+#ifdef CONFIG_UNIX98_PTYS
+		if (tty->driver == ptm_driver)
+			devpts_pty_kill(tty->link);
+#endif
+		tty_unlock();
+		tty_vhangup(tty->link);
+		tty_lock();
+	}
+}
+
+/*
+ * The unthrottle routine is called by the line discipline to signal
+ * that it can receive more characters.  For PTY's, the TTY_THROTTLED
+ * flag is always set, to force the line discipline to always call the
+ * unthrottle routine when there are fewer than TTY_THRESHOLD_UNTHROTTLE
+ * characters in the queue.  This is necessary since each time this
+ * happens, we need to wake up any sleeping processes that could be
+ * (1) trying to send data to the pty, or (2) waiting in wait_until_sent()
+ * for the pty buffer to be drained.
+ */
+static void pty_unthrottle(struct tty_struct *tty)
+{
+	tty_wakeup(tty->link);
+	set_bit(TTY_THROTTLED, &tty->flags);
+}
+
+/**
+ *	pty_space	-	report space left for writing
+ *	@to: tty we are writing into
+ *
+ *	The tty buffers allow 64K but we sneak a peak and clip at 8K this
+ *	allows a lot of overspill room for echo and other fun messes to
+ *	be handled properly
+ */
+
+static int pty_space(struct tty_struct *to)
+{
+	int n = 8192 - to->buf.memory_used;
+	if (n < 0)
+		return 0;
+	return n;
+}
+
+/**
+ *	pty_write		-	write to a pty
+ *	@tty: the tty we write from
+ *	@buf: kernel buffer of data
+ *	@count: bytes to write
+ *
+ *	Our "hardware" write method. Data is coming from the ldisc which
+ *	may be in a non sleeping state. We simply throw this at the other
+ *	end of the link as if we were an IRQ handler receiving stuff for
+ *	the other side of the pty/tty pair.
+ */
+
+static int pty_write(struct tty_struct *tty, const unsigned char *buf, int c)
+{
+	struct tty_struct *to = tty->link;
+
+	if (tty->stopped)
+		return 0;
+
+	if (c > 0) {
+		/* Stuff the data into the input queue of the other end */
+		c = tty_insert_flip_string(to, buf, c);
+		/* And shovel */
+		if (c) {
+			tty_flip_buffer_push(to);
+			tty_wakeup(tty);
+		}
+	}
+	return c;
+}
+
+/**
+ *	pty_write_room	-	write space
+ *	@tty: tty we are writing from
+ *
+ *	Report how many bytes the ldisc can send into the queue for
+ *	the other device.
+ */
+
+static int pty_write_room(struct tty_struct *tty)
+{
+	if (tty->stopped)
+		return 0;
+	return pty_space(tty->link);
+}
+
+/**
+ *	pty_chars_in_buffer	-	characters currently in our tx queue
+ *	@tty: our tty
+ *
+ *	Report how much we have in the transmit queue. As everything is
+ *	instantly at the other end this is easy to implement.
+ */
+
+static int pty_chars_in_buffer(struct tty_struct *tty)
+{
+	return 0;
+}
+
+/* Set the lock flag on a pty */
+static int pty_set_lock(struct tty_struct *tty, int __user *arg)
+{
+	int val;
+	if (get_user(val, arg))
+		return -EFAULT;
+	if (val)
+		set_bit(TTY_PTY_LOCK, &tty->flags);
+	else
+		clear_bit(TTY_PTY_LOCK, &tty->flags);
+	return 0;
+}
+
+/* Send a signal to the slave */
+static int pty_signal(struct tty_struct *tty, int sig)
+{
+	unsigned long flags;
+	struct pid *pgrp;
+
+	if (tty->link) {
+		spin_lock_irqsave(&tty->link->ctrl_lock, flags);
+		pgrp = get_pid(tty->link->pgrp);
+		spin_unlock_irqrestore(&tty->link->ctrl_lock, flags);
+
+		kill_pgrp(pgrp, sig, 1);
+		put_pid(pgrp);
+	}
+	return 0;
+}
+
+static void pty_flush_buffer(struct tty_struct *tty)
+{
+	struct tty_struct *to = tty->link;
+	unsigned long flags;
+
+	if (!to)
+		return;
+	/* tty_buffer_flush(to); FIXME */
+	if (to->packet) {
+		spin_lock_irqsave(&tty->ctrl_lock, flags);
+		tty->ctrl_status |= TIOCPKT_FLUSHWRITE;
+		wake_up_interruptible(&to->read_wait);
+		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+	}
+}
+
+static int pty_open(struct tty_struct *tty, struct file *filp)
+{
+	int	retval = -ENODEV;
+
+	if (!tty || !tty->link)
+		goto out;
+
+	retval = -EIO;
+	if (test_bit(TTY_OTHER_CLOSED, &tty->flags))
+		goto out;
+	if (test_bit(TTY_PTY_LOCK, &tty->link->flags))
+		goto out;
+	if (tty->link->count != 1)
+		goto out;
+
+	clear_bit(TTY_OTHER_CLOSED, &tty->link->flags);
+	set_bit(TTY_THROTTLED, &tty->flags);
+	retval = 0;
+out:
+	return retval;
+}
+
+static void pty_set_termios(struct tty_struct *tty,
+					struct ktermios *old_termios)
+{
+	tty->termios->c_cflag &= ~(CSIZE | PARENB);
+	tty->termios->c_cflag |= (CS8 | CREAD);
+}
+
+/**
+ *	pty_do_resize		-	resize event
+ *	@tty: tty being resized
+ *	@ws: window size being set.
+ *
+ *	Update the termios variables and send the necessary signals to
+ *	peform a terminal resize correctly
+ */
+
+int pty_resize(struct tty_struct *tty,  struct winsize *ws)
+{
+	struct pid *pgrp, *rpgrp;
+	unsigned long flags;
+	struct tty_struct *pty = tty->link;
+
+	/* For a PTY we need to lock the tty side */
+	mutex_lock(&tty->termios_mutex);
+	if (!memcmp(ws, &tty->winsize, sizeof(*ws)))
+		goto done;
+
+	/* Get the PID values and reference them so we can
+	   avoid holding the tty ctrl lock while sending signals.
+	   We need to lock these individually however. */
+
+	spin_lock_irqsave(&tty->ctrl_lock, flags);
+	pgrp = get_pid(tty->pgrp);
+	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+
+	spin_lock_irqsave(&pty->ctrl_lock, flags);
+	rpgrp = get_pid(pty->pgrp);
+	spin_unlock_irqrestore(&pty->ctrl_lock, flags);
+
+	if (pgrp)
+		kill_pgrp(pgrp, SIGWINCH, 1);
+	if (rpgrp != pgrp && rpgrp)
+		kill_pgrp(rpgrp, SIGWINCH, 1);
+
+	put_pid(pgrp);
+	put_pid(rpgrp);
+
+	tty->winsize = *ws;
+	pty->winsize = *ws;	/* Never used so will go away soon */
+done:
+	mutex_unlock(&tty->termios_mutex);
+	return 0;
+}
+
+/* Traditional BSD devices */
+#ifdef CONFIG_LEGACY_PTYS
+
+static int pty_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	struct tty_struct *o_tty;
+	int idx = tty->index;
+	int retval;
+
+	o_tty = alloc_tty_struct();
+	if (!o_tty)
+		return -ENOMEM;
+	if (!try_module_get(driver->other->owner)) {
+		/* This cannot in fact currently happen */
+		free_tty_struct(o_tty);
+		return -ENOMEM;
+	}
+	initialize_tty_struct(o_tty, driver->other, idx);
+
+	/* We always use new tty termios data so we can do this
+	   the easy way .. */
+	retval = tty_init_termios(tty);
+	if (retval)
+		goto free_mem_out;
+
+	retval = tty_init_termios(o_tty);
+	if (retval) {
+		tty_free_termios(tty);
+		goto free_mem_out;
+	}
+
+	/*
+	 * Everything allocated ... set up the o_tty structure.
+	 */
+	driver->other->ttys[idx] = o_tty;
+	tty_driver_kref_get(driver->other);
+	if (driver->subtype == PTY_TYPE_MASTER)
+		o_tty->count++;
+	/* Establish the links in both directions */
+	tty->link   = o_tty;
+	o_tty->link = tty;
+
+	tty_driver_kref_get(driver);
+	tty->count++;
+	driver->ttys[idx] = tty;
+	return 0;
+free_mem_out:
+	module_put(o_tty->driver->owner);
+	free_tty_struct(o_tty);
+	return -ENOMEM;
+}
+
+static int pty_bsd_ioctl(struct tty_struct *tty, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
+		return pty_set_lock(tty, (int __user *) arg);
+	case TIOCSIG:    /* Send signal to other side of pty */
+		return pty_signal(tty, (int) arg);
+	}
+	return -ENOIOCTLCMD;
+}
+
+static int legacy_count = CONFIG_LEGACY_PTY_COUNT;
+module_param(legacy_count, int, 0);
+
+/*
+ * The master side of a pty can do TIOCSPTLCK and thus
+ * has pty_bsd_ioctl.
+ */
+static const struct tty_operations master_pty_ops_bsd = {
+	.install = pty_install,
+	.open = pty_open,
+	.close = pty_close,
+	.write = pty_write,
+	.write_room = pty_write_room,
+	.flush_buffer = pty_flush_buffer,
+	.chars_in_buffer = pty_chars_in_buffer,
+	.unthrottle = pty_unthrottle,
+	.set_termios = pty_set_termios,
+	.ioctl = pty_bsd_ioctl,
+	.resize = pty_resize
+};
+
+static const struct tty_operations slave_pty_ops_bsd = {
+	.install = pty_install,
+	.open = pty_open,
+	.close = pty_close,
+	.write = pty_write,
+	.write_room = pty_write_room,
+	.flush_buffer = pty_flush_buffer,
+	.chars_in_buffer = pty_chars_in_buffer,
+	.unthrottle = pty_unthrottle,
+	.set_termios = pty_set_termios,
+	.resize = pty_resize
+};
+
+static void __init legacy_pty_init(void)
+{
+	struct tty_driver *pty_driver, *pty_slave_driver;
+
+	if (legacy_count <= 0)
+		return;
+
+	pty_driver = alloc_tty_driver(legacy_count);
+	if (!pty_driver)
+		panic("Couldn't allocate pty driver");
+
+	pty_slave_driver = alloc_tty_driver(legacy_count);
+	if (!pty_slave_driver)
+		panic("Couldn't allocate pty slave driver");
+
+	pty_driver->owner = THIS_MODULE;
+	pty_driver->driver_name = "pty_master";
+	pty_driver->name = "pty";
+	pty_driver->major = PTY_MASTER_MAJOR;
+	pty_driver->minor_start = 0;
+	pty_driver->type = TTY_DRIVER_TYPE_PTY;
+	pty_driver->subtype = PTY_TYPE_MASTER;
+	pty_driver->init_termios = tty_std_termios;
+	pty_driver->init_termios.c_iflag = 0;
+	pty_driver->init_termios.c_oflag = 0;
+	pty_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
+	pty_driver->init_termios.c_lflag = 0;
+	pty_driver->init_termios.c_ispeed = 38400;
+	pty_driver->init_termios.c_ospeed = 38400;
+	pty_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW;
+	pty_driver->other = pty_slave_driver;
+	tty_set_operations(pty_driver, &master_pty_ops_bsd);
+
+	pty_slave_driver->owner = THIS_MODULE;
+	pty_slave_driver->driver_name = "pty_slave";
+	pty_slave_driver->name = "ttyp";
+	pty_slave_driver->major = PTY_SLAVE_MAJOR;
+	pty_slave_driver->minor_start = 0;
+	pty_slave_driver->type = TTY_DRIVER_TYPE_PTY;
+	pty_slave_driver->subtype = PTY_TYPE_SLAVE;
+	pty_slave_driver->init_termios = tty_std_termios;
+	pty_slave_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
+	pty_slave_driver->init_termios.c_ispeed = 38400;
+	pty_slave_driver->init_termios.c_ospeed = 38400;
+	pty_slave_driver->flags = TTY_DRIVER_RESET_TERMIOS |
+					TTY_DRIVER_REAL_RAW;
+	pty_slave_driver->other = pty_driver;
+	tty_set_operations(pty_slave_driver, &slave_pty_ops_bsd);
+
+	if (tty_register_driver(pty_driver))
+		panic("Couldn't register pty driver");
+	if (tty_register_driver(pty_slave_driver))
+		panic("Couldn't register pty slave driver");
+}
+#else
+static inline void legacy_pty_init(void) { }
+#endif
+
+/* Unix98 devices */
+#ifdef CONFIG_UNIX98_PTYS
+/*
+ * sysctl support for setting limits on the number of Unix98 ptys allocated.
+ * Otherwise one can eat up all kernel memory by opening /dev/ptmx repeatedly.
+ */
+int pty_limit = NR_UNIX98_PTY_DEFAULT;
+static int pty_limit_min;
+static int pty_limit_max = NR_UNIX98_PTY_MAX;
+static int pty_count;
+
+static struct cdev ptmx_cdev;
+
+static struct ctl_table pty_table[] = {
+	{
+		.procname	= "max",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.data		= &pty_limit,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &pty_limit_min,
+		.extra2		= &pty_limit_max,
+	}, {
+		.procname	= "nr",
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.data		= &pty_count,
+		.proc_handler	= proc_dointvec,
+	}, 
+	{}
+};
+
+static struct ctl_table pty_kern_table[] = {
+	{
+		.procname	= "pty",
+		.mode		= 0555,
+		.child		= pty_table,
+	},
+	{}
+};
+
+static struct ctl_table pty_root_table[] = {
+	{
+		.procname	= "kernel",
+		.mode		= 0555,
+		.child		= pty_kern_table,
+	},
+	{}
+};
+
+
+static int pty_unix98_ioctl(struct tty_struct *tty, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
+		return pty_set_lock(tty, (int __user *)arg);
+	case TIOCGPTN: /* Get PT Number */
+		return put_user(tty->index, (unsigned int __user *)arg);
+	case TIOCSIG:    /* Send signal to other side of pty */
+		return pty_signal(tty, (int) arg);
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+/**
+ *	ptm_unix98_lookup	-	find a pty master
+ *	@driver: ptm driver
+ *	@idx: tty index
+ *
+ *	Look up a pty master device. Called under the tty_mutex for now.
+ *	This provides our locking.
+ */
+
+static struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,
+		struct inode *ptm_inode, int idx)
+{
+	struct tty_struct *tty = devpts_get_tty(ptm_inode, idx);
+	if (tty)
+		tty = tty->link;
+	return tty;
+}
+
+/**
+ *	pts_unix98_lookup	-	find a pty slave
+ *	@driver: pts driver
+ *	@idx: tty index
+ *
+ *	Look up a pty master device. Called under the tty_mutex for now.
+ *	This provides our locking.
+ */
+
+static struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,
+		struct inode *pts_inode, int idx)
+{
+	struct tty_struct *tty = devpts_get_tty(pts_inode, idx);
+	/* Master must be open before slave */
+	if (!tty)
+		return ERR_PTR(-EIO);
+	return tty;
+}
+
+static void pty_unix98_shutdown(struct tty_struct *tty)
+{
+	/* We have our own method as we don't use the tty index */
+	kfree(tty->termios);
+}
+
+/* We have no need to install and remove our tty objects as devpts does all
+   the work for us */
+
+static int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	struct tty_struct *o_tty;
+	int idx = tty->index;
+
+	o_tty = alloc_tty_struct();
+	if (!o_tty)
+		return -ENOMEM;
+	if (!try_module_get(driver->other->owner)) {
+		/* This cannot in fact currently happen */
+		free_tty_struct(o_tty);
+		return -ENOMEM;
+	}
+	initialize_tty_struct(o_tty, driver->other, idx);
+
+	tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
+	if (tty->termios == NULL)
+		goto free_mem_out;
+	*tty->termios = driver->init_termios;
+	tty->termios_locked = tty->termios + 1;
+
+	o_tty->termios = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);
+	if (o_tty->termios == NULL)
+		goto free_mem_out;
+	*o_tty->termios = driver->other->init_termios;
+	o_tty->termios_locked = o_tty->termios + 1;
+
+	tty_driver_kref_get(driver->other);
+	if (driver->subtype == PTY_TYPE_MASTER)
+		o_tty->count++;
+	/* Establish the links in both directions */
+	tty->link   = o_tty;
+	o_tty->link = tty;
+	/*
+	 * All structures have been allocated, so now we install them.
+	 * Failures after this point use release_tty to clean up, so
+	 * there's no need to null out the local pointers.
+	 */
+	tty_driver_kref_get(driver);
+	tty->count++;
+	pty_count++;
+	return 0;
+free_mem_out:
+	kfree(o_tty->termios);
+	module_put(o_tty->driver->owner);
+	free_tty_struct(o_tty);
+	kfree(tty->termios);
+	return -ENOMEM;
+}
+
+static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
+{
+	pty_count--;
+}
+
+static const struct tty_operations ptm_unix98_ops = {
+	.lookup = ptm_unix98_lookup,
+	.install = pty_unix98_install,
+	.remove = pty_unix98_remove,
+	.open = pty_open,
+	.close = pty_close,
+	.write = pty_write,
+	.write_room = pty_write_room,
+	.flush_buffer = pty_flush_buffer,
+	.chars_in_buffer = pty_chars_in_buffer,
+	.unthrottle = pty_unthrottle,
+	.set_termios = pty_set_termios,
+	.ioctl = pty_unix98_ioctl,
+	.shutdown = pty_unix98_shutdown,
+	.resize = pty_resize
+};
+
+static const struct tty_operations pty_unix98_ops = {
+	.lookup = pts_unix98_lookup,
+	.install = pty_unix98_install,
+	.remove = pty_unix98_remove,
+	.open = pty_open,
+	.close = pty_close,
+	.write = pty_write,
+	.write_room = pty_write_room,
+	.flush_buffer = pty_flush_buffer,
+	.chars_in_buffer = pty_chars_in_buffer,
+	.unthrottle = pty_unthrottle,
+	.set_termios = pty_set_termios,
+	.shutdown = pty_unix98_shutdown
+};
+
+/**
+ *	ptmx_open		-	open a unix 98 pty master
+ *	@inode: inode of device file
+ *	@filp: file pointer to tty
+ *
+ *	Allocate a unix98 pty master device from the ptmx driver.
+ *
+ *	Locking: tty_mutex protects the init_dev work. tty->count should
+ * 		protect the rest.
+ *		allocated_ptys_lock handles the list of free pty numbers
+ */
+
+static int ptmx_open(struct inode *inode, struct file *filp)
+{
+	struct tty_struct *tty;
+	int retval;
+	int index;
+
+	nonseekable_open(inode, filp);
+
+	/* find a device that is not in use. */
+	tty_lock();
+	index = devpts_new_index(inode);
+	tty_unlock();
+	if (index < 0)
+		return index;
+
+	mutex_lock(&tty_mutex);
+	tty_lock();
+	tty = tty_init_dev(ptm_driver, index, 1);
+	mutex_unlock(&tty_mutex);
+
+	if (IS_ERR(tty)) {
+		retval = PTR_ERR(tty);
+		goto out;
+	}
+
+	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
+
+	retval = tty_add_file(tty, filp);
+	if (retval)
+		goto out;
+
+	retval = devpts_pty_new(inode, tty->link);
+	if (retval)
+		goto out1;
+
+	retval = ptm_driver->ops->open(tty, filp);
+	if (retval)
+		goto out2;
+out1:
+	tty_unlock();
+	return retval;
+out2:
+	tty_unlock();
+	tty_release(inode, filp);
+	return retval;
+out:
+	devpts_kill_index(inode, index);
+	tty_unlock();
+	return retval;
+}
+
+static struct file_operations ptmx_fops;
+
+static void __init unix98_pty_init(void)
+{
+	ptm_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
+	if (!ptm_driver)
+		panic("Couldn't allocate Unix98 ptm driver");
+	pts_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
+	if (!pts_driver)
+		panic("Couldn't allocate Unix98 pts driver");
+
+	ptm_driver->owner = THIS_MODULE;
+	ptm_driver->driver_name = "pty_master";
+	ptm_driver->name = "ptm";
+	ptm_driver->major = UNIX98_PTY_MASTER_MAJOR;
+	ptm_driver->minor_start = 0;
+	ptm_driver->type = TTY_DRIVER_TYPE_PTY;
+	ptm_driver->subtype = PTY_TYPE_MASTER;
+	ptm_driver->init_termios = tty_std_termios;
+	ptm_driver->init_termios.c_iflag = 0;
+	ptm_driver->init_termios.c_oflag = 0;
+	ptm_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
+	ptm_driver->init_termios.c_lflag = 0;
+	ptm_driver->init_termios.c_ispeed = 38400;
+	ptm_driver->init_termios.c_ospeed = 38400;
+	ptm_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM;
+	ptm_driver->other = pts_driver;
+	tty_set_operations(ptm_driver, &ptm_unix98_ops);
+
+	pts_driver->owner = THIS_MODULE;
+	pts_driver->driver_name = "pty_slave";
+	pts_driver->name = "pts";
+	pts_driver->major = UNIX98_PTY_SLAVE_MAJOR;
+	pts_driver->minor_start = 0;
+	pts_driver->type = TTY_DRIVER_TYPE_PTY;
+	pts_driver->subtype = PTY_TYPE_SLAVE;
+	pts_driver->init_termios = tty_std_termios;
+	pts_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
+	pts_driver->init_termios.c_ispeed = 38400;
+	pts_driver->init_termios.c_ospeed = 38400;
+	pts_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM;
+	pts_driver->other = ptm_driver;
+	tty_set_operations(pts_driver, &pty_unix98_ops);
+
+	if (tty_register_driver(ptm_driver))
+		panic("Couldn't register Unix98 ptm driver");
+	if (tty_register_driver(pts_driver))
+		panic("Couldn't register Unix98 pts driver");
+
+	register_sysctl_table(pty_root_table);
+
+	/* Now create the /dev/ptmx special device */
+	tty_default_fops(&ptmx_fops);
+	ptmx_fops.open = ptmx_open;
+
+	cdev_init(&ptmx_cdev, &ptmx_fops);
+	if (cdev_add(&ptmx_cdev, MKDEV(TTYAUX_MAJOR, 2), 1) ||
+	    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, "/dev/ptmx") < 0)
+		panic("Couldn't register /dev/ptmx driver\n");
+	device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 2), NULL, "ptmx");
+}
+
+#else
+static inline void unix98_pty_init(void) { }
+#endif
+
+static int __init pty_init(void)
+{
+	legacy_pty_init();
+	unix98_pty_init();
+	return 0;
+}
+module_init(pty_init);
