commit eefadcbca7f394fb9248384f2c759ebbe81e20c7
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Jan 25 14:30:45 2018 +0100

    serial: altera: set RRDY flag also without irq
    
    The UART can be operated without an irq. In this case a timer is setup
    that regularily calls altera_uart_interrupt(). The receiving part
    depends on pp->imr having the bit ALTERA_UART_STATUS_RRDY_MSK set,
    otherwise altera_uart_rx_chars() is never called. So ensure that the bit
    gets set (disguised as ALTERA_UART_CONTROL_RRDY_MSK) by not returning
    early from altera_uart_startup() if port->irq is 0.
    
    This doesn't affect the hardware as the ALTERA_UART_CONTROL_RRDY_MSK bit
    isn't actually written to the control register.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 427843761d32..0e487ce091ac 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -321,20 +321,20 @@ static int altera_uart_startup(struct uart_port *port)
 {
 	struct altera_uart *pp = container_of(port, struct altera_uart, port);
 	unsigned long flags;
-	int ret;
 
 	if (!port->irq) {
 		timer_setup(&pp->tmr, altera_uart_timer, 0);
 		mod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));
-		return 0;
-	}
-
-	ret = request_irq(port->irq, altera_uart_interrupt, 0,
-			DRV_NAME, port);
-	if (ret) {
-		pr_err(DRV_NAME ": unable to attach Altera UART %d "
-		       "interrupt vector=%d\n", port->line, port->irq);
-		return ret;
+	} else {
+		int ret;
+
+		ret = request_irq(port->irq, altera_uart_interrupt, 0,
+				DRV_NAME, port);
+		if (ret) {
+			pr_err(DRV_NAME ": unable to attach Altera UART %d "
+			       "interrupt vector=%d\n", port->line, port->irq);
+			return ret;
+		}
 	}
 
 	spin_lock_irqsave(&port->lock, flags);

commit 2ea6ad8bc60f66a5d323ca7e93fddf2363c3ed80
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Jan 25 14:30:44 2018 +0100

    serial: altera: don't enable any irq if the device doesn't feature an irq
    
    If the irq line of an altera UART device isn't used to report interrupts
    for this device the driver better ensures that this device doesn't pull
    this line to active state and so disturb the whatever might be connected
    to this line.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index ae30398fcf56..427843761d32 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -109,6 +109,20 @@ static unsigned int altera_uart_get_mctrl(struct uart_port *port)
 	return sigs;
 }
 
+static void altera_uart_update_ctrl_reg(struct altera_uart *pp)
+{
+	unsigned short imr = pp->imr;
+
+	/*
+	 * If the device doesn't have an irq, ensure that the irq bits are
+	 * masked out to keep the irq line inactive.
+	 */
+	if (!pp->port.irq)
+		imr &= ALTERA_UART_CONTROL_TRBK_MSK | ALTERA_UART_CONTROL_RTS_MSK;
+
+	altera_uart_writel(&pp->port, imr, ALTERA_UART_CONTROL_REG);
+}
+
 static void altera_uart_set_mctrl(struct uart_port *port, unsigned int sigs)
 {
 	struct altera_uart *pp = container_of(port, struct altera_uart, port);
@@ -118,7 +132,7 @@ static void altera_uart_set_mctrl(struct uart_port *port, unsigned int sigs)
 		pp->imr |= ALTERA_UART_CONTROL_RTS_MSK;
 	else
 		pp->imr &= ~ALTERA_UART_CONTROL_RTS_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 }
 
 static void altera_uart_start_tx(struct uart_port *port)
@@ -126,7 +140,7 @@ static void altera_uart_start_tx(struct uart_port *port)
 	struct altera_uart *pp = container_of(port, struct altera_uart, port);
 
 	pp->imr |= ALTERA_UART_CONTROL_TRDY_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 }
 
 static void altera_uart_stop_tx(struct uart_port *port)
@@ -134,7 +148,7 @@ static void altera_uart_stop_tx(struct uart_port *port)
 	struct altera_uart *pp = container_of(port, struct altera_uart, port);
 
 	pp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 }
 
 static void altera_uart_stop_rx(struct uart_port *port)
@@ -142,7 +156,7 @@ static void altera_uart_stop_rx(struct uart_port *port)
 	struct altera_uart *pp = container_of(port, struct altera_uart, port);
 
 	pp->imr &= ~ALTERA_UART_CONTROL_RRDY_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 }
 
 static void altera_uart_break_ctl(struct uart_port *port, int break_state)
@@ -155,7 +169,7 @@ static void altera_uart_break_ctl(struct uart_port *port, int break_state)
 		pp->imr |= ALTERA_UART_CONTROL_TRBK_MSK;
 	else
 		pp->imr &= ~ALTERA_UART_CONTROL_TRBK_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -262,7 +276,7 @@ static void altera_uart_tx_chars(struct altera_uart *pp)
 
 	if (xmit->head == xmit->tail) {
 		pp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;
-		altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+		altera_uart_update_ctrl_reg(pp);
 	}
 }
 
@@ -327,7 +341,7 @@ static int altera_uart_startup(struct uart_port *port)
 
 	/* Enable RX interrupts now */
 	pp->imr = ALTERA_UART_CONTROL_RRDY_MSK;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
@@ -343,7 +357,7 @@ static void altera_uart_shutdown(struct uart_port *port)
 
 	/* Disable all interrupts now */
 	pp->imr = 0;
-	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	altera_uart_update_ctrl_reg(pp);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 

commit 0e254963b6ba4d63ac911e79537fea38dd03dc50
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Jan 25 14:30:43 2018 +0100

    serial: altera: ensure port->regshift is honored consistently
    
    Most register accesses in the altera driver honor port->regshift by
    using altera_uart_writel(). There are a few accesses however that were
    missed when the driver was converted to use port->regshift and some
    others were added later in commit 4d9d7d896d77 ("serial: altera_uart:
    add earlycon support").
    
    Fixes: 2780ad42f5fe ("tty: serial: altera_uart: Use port->regshift to store bus shift")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index b88b05f8e81e..ae30398fcf56 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -327,7 +327,7 @@ static int altera_uart_startup(struct uart_port *port)
 
 	/* Enable RX interrupts now */
 	pp->imr = ALTERA_UART_CONTROL_RRDY_MSK;
-	writel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
@@ -343,7 +343,7 @@ static void altera_uart_shutdown(struct uart_port *port)
 
 	/* Disable all interrupts now */
 	pp->imr = 0;
-	writel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
@@ -432,7 +432,7 @@ static void altera_uart_console_putc(struct uart_port *port, int c)
 		 ALTERA_UART_STATUS_TRDY_MSK))
 		cpu_relax();
 
-	writel(c, port->membase + ALTERA_UART_TXDATA_REG);
+	altera_uart_writel(port, c, ALTERA_UART_TXDATA_REG);
 }
 
 static void altera_uart_console_write(struct console *co, const char *s,
@@ -502,13 +502,13 @@ static int __init altera_uart_earlycon_setup(struct earlycon_device *dev,
 		return -ENODEV;
 
 	/* Enable RX interrupts now */
-	writel(ALTERA_UART_CONTROL_RRDY_MSK,
-	       port->membase + ALTERA_UART_CONTROL_REG);
+	altera_uart_writel(port, ALTERA_UART_CONTROL_RRDY_MSK,
+			   ALTERA_UART_CONTROL_REG);
 
 	if (dev->baud) {
 		unsigned int baudclk = port->uartclk / dev->baud;
 
-		writel(baudclk, port->membase + ALTERA_UART_DIVISOR_REG);
+		altera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);
 	}
 
 	dev->con->write = altera_uart_earlycon_write;

commit 4793f2ebff1c890386a514998606205a2948011c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:52 2017 +0100

    tty: serial: Remove redundant license text
    
    Now that the SPDX tag is in all tty files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index f1efcfc65a1e..b88b05f8e81e 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -7,11 +7,6 @@
  * (C) Copyright 2003-2007, Greg Ungerer <gerg@snapgear.com>
  * (C) Copyright 2008, Thomas Chou <thomas@wytron.com.tw>
  * (C) Copyright 2010, Tobias Klauser <tklauser@distanz.ch>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/kernel.h>

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index a0360e640837..f1efcfc65a1e 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * altera_uart.c -- Altera UART driver
  *

commit ad0cda7a90f26970d65163095c5da39f541921bc
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 02:59:56 2017 -0700

    tty/serial: altera_uart: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: linux-serial@vger.kernel.org
    Cc: nios2-dev@lists.rocketboards.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 3e4b717670d7..a0360e640837 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -288,10 +288,10 @@ static irqreturn_t altera_uart_interrupt(int irq, void *data)
 	return IRQ_RETVAL(isr);
 }
 
-static void altera_uart_timer(unsigned long data)
+static void altera_uart_timer(struct timer_list *t)
 {
-	struct uart_port *port = (void *)data;
-	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	struct altera_uart *pp = from_timer(pp, t, tmr);
+	struct uart_port *port = &pp->port;
 
 	altera_uart_interrupt(0, port);
 	mod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));
@@ -314,7 +314,7 @@ static int altera_uart_startup(struct uart_port *port)
 	int ret;
 
 	if (!port->irq) {
-		setup_timer(&pp->tmr, altera_uart_timer, (unsigned long)port);
+		timer_setup(&pp->tmr, altera_uart_timer, 0);
 		mod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));
 		return 0;
 	}

commit 59fe2cc8b1c32dd139da80fc8222b5b3290b7a09
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri May 19 13:59:20 2017 +0200

    serial: altera_uart: call iounmap() at driver remove
    
    The driver calls ioremap() in the probe function but doesn't call
    iounmap() in the remove function correspondingly. Do so now.
    
    Follow commit 5c9d6abed9e0 ("serial: altera_jtaguart: adding iounmap()")
    
    Cc: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 46d3438a0d27..3e4b717670d7 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -615,6 +615,7 @@ static int altera_uart_remove(struct platform_device *pdev)
 	if (port) {
 		uart_remove_one_port(&altera_uart_driver, port);
 		port->mapbase = 0;
+		iounmap(port->membase);
 	}
 
 	return 0;

commit 4d9d7d896d77e70e6868cfe681e7fcd58dc9526d
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Mar 22 13:50:13 2017 +0100

    serial: altera_uart: add earlycon support
    
    Nios2 currently uses its own early printk implementation, rather than
    using unified earlycon support to show boot messages on altera_uart.
    
    Add earlycon support to altera_uart so that other archs may use it.
    Also, this (together with the corresponding patch for altera_jtaguart)
    will allow the early printk implementation in arch/nios2 to be removed
    in a future patch.
    
    Cc: Ley Foon Tan <lftan@altera.com>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 820a74208696..46d3438a0d27 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -489,6 +489,38 @@ console_initcall(altera_uart_console_init);
 
 #define	ALTERA_UART_CONSOLE	(&altera_uart_console)
 
+static void altera_uart_earlycon_write(struct console *co, const char *s,
+				       unsigned int count)
+{
+	struct earlycon_device *dev = co->data;
+
+	uart_console_write(&dev->port, s, count, altera_uart_console_putc);
+}
+
+static int __init altera_uart_earlycon_setup(struct earlycon_device *dev,
+					     const char *options)
+{
+	struct uart_port *port = &dev->port;
+
+	if (!port->membase)
+		return -ENODEV;
+
+	/* Enable RX interrupts now */
+	writel(ALTERA_UART_CONTROL_RRDY_MSK,
+	       port->membase + ALTERA_UART_CONTROL_REG);
+
+	if (dev->baud) {
+		unsigned int baudclk = port->uartclk / dev->baud;
+
+		writel(baudclk, port->membase + ALTERA_UART_DIVISOR_REG);
+	}
+
+	dev->con->write = altera_uart_earlycon_write;
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(uart, "altr,uart-1.0", altera_uart_earlycon_setup);
+
 #else
 
 #define	ALTERA_UART_CONSOLE	NULL

commit 03bd797f33ddbe1d14de7abc70a9dd21b2a12d3f
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Sep 1 19:51:32 2016 +0200

    serial: altera: constify uart_ops structures
    
    Check for uart_ops structures that are only stored in the ops field of a
    uart_port structure.  This field is declared const, so uart_ops structures
    that have this property can be declared as const also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct uart_ops i@p = { ... };
    
    @ok@
    identifier r.i;
    struct uart_port e;
    position p;
    @@
    e.ops = &i@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    struct uart_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct uart_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 61b607f2488e..820a74208696 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -404,7 +404,7 @@ static void altera_uart_poll_put_char(struct uart_port *port, unsigned char c)
 /*
  *	Define the basic serial functions we support.
  */
-static struct uart_ops altera_uart_ops = {
+static const struct uart_ops altera_uart_ops = {
 	.tx_empty	= altera_uart_tx_empty,
 	.get_mctrl	= altera_uart_get_mctrl,
 	.set_mctrl	= altera_uart_set_mctrl,

commit d144aff1363a332e43be3cb431f6f8600a449cdc
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Sep 9 20:34:12 2015 +0200

    serial: altera_uart: Use of_property_read_u32 instead of open-coding it
    
    Use of_property_read_u32 instead of of_get_property with return value
    checks and endianness conversion. Also remove the !CONFIG_OF
    implementation of altera_uart_get_of_uartclk as of_property_read_u32
    will return a non-zero value for !CONFIG_OF.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index fd87a6f574e3..61b607f2488e 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -508,29 +508,6 @@ static struct uart_driver altera_uart_driver = {
 	.cons		= ALTERA_UART_CONSOLE,
 };
 
-#ifdef CONFIG_OF
-static int altera_uart_get_of_uartclk(struct platform_device *pdev,
-				      struct uart_port *port)
-{
-	int len;
-	const __be32 *clk;
-
-	clk = of_get_property(pdev->dev.of_node, "clock-frequency", &len);
-	if (!clk || len < sizeof(__be32))
-		return -ENODEV;
-
-	port->uartclk = be32_to_cpup(clk);
-
-	return 0;
-}
-#else
-static int altera_uart_get_of_uartclk(struct platform_device *pdev,
-				      struct uart_port *port)
-{
-	return -ENODEV;
-}
-#endif /* CONFIG_OF */
-
 static int altera_uart_probe(struct platform_device *pdev)
 {
 	struct altera_uart_platform_uart *platp = dev_get_platdata(&pdev->dev);
@@ -570,7 +547,8 @@ static int altera_uart_probe(struct platform_device *pdev)
 	if (platp)
 		port->uartclk = platp->uartclk;
 	else {
-		ret = altera_uart_get_of_uartclk(pdev, port);
+		ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+					   &port->uartclk);
 		if (ret)
 			return ret;
 	}

commit 0656b1a9a5228f27af3a010b75c2c587213ee4f1
Author: Valentin Rothberg <valentinrothberg@gmail.com>
Date:   Sat Apr 11 12:21:30 2015 +0200

    drivers/tty/serial: altera: fix typos in #endif comments
    
    Correct reference on CONFIG_SERIAL_ALTERA_{JTAG}UART_CONSOLE in
    C-comment after #endif.
    
    Signed-off-by: Valentin Rothberg <valentinrothberg@gmail.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index b2859fe07e14..fd87a6f574e3 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -493,7 +493,7 @@ console_initcall(altera_uart_console_init);
 
 #define	ALTERA_UART_CONSOLE	NULL
 
-#endif /* CONFIG_ALTERA_UART_CONSOLE */
+#endif /* CONFIG_SERIAL_ALTERA_UART_CONSOLE */
 
 /*
  *	Define the altera_uart UART driver structure.

commit b820cd7643d5fdf05d6f5d32507d330609113248
Author: Ley Foon Tan <lftan@altera.com>
Date:   Tue Dec 16 15:28:34 2014 +0800

    serial: altera-uart: fix NULL device in log message
    
    Add device pointer to port->dev.
    
    Before:
    
    "(NULL device *): ttyAL0 at MMIO 0x2020 (irq = 6, base_baud = 3125000)
    is a Altera UART"
    
    After:
    "altera_uart 2020.serial: ttyAL0 at MMIO 0x2020 (irq = 6, base_baud = 3125000)
    is a Altera UART"
    
    Signed-off-by: Ley Foon Tan <lftan@altera.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index eb15a50623cb..b2859fe07e14 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -589,6 +589,7 @@ static int altera_uart_probe(struct platform_device *pdev)
 	port->iotype = SERIAL_IO_MEM;
 	port->ops = &altera_uart_ops;
 	port->flags = UPF_BOOT_AUTOCONF;
+	port->dev = &pdev->dev;
 
 	platform_set_drvdata(pdev, port);
 

commit 9144b3cded04a05d4b4e18dc9dcfb5b8ada3f2fc
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:45 2014 +0200

    tty: serial: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 1cb2cdb1bc42..eb15a50623cb 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -623,7 +623,6 @@ static struct platform_driver altera_uart_platform_driver = {
 	.remove	= altera_uart_remove,
 	.driver	= {
 		.name		= DRV_NAME,
-		.owner		= THIS_MODULE,
 		.of_match_table	= of_match_ptr(altera_uart_match),
 	},
 };

commit 4d199a55c41b25f4255eaeea358f944e33e91a4b
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Tue Aug 5 09:14:35 2014 +0200

    serial: altera: Make of_device_id arrays const
    
    Make the of_device_id arrays const, as it is handled as const by all OF
    functions.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 6a243239dbef..1cb2cdb1bc42 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -610,7 +610,7 @@ static int altera_uart_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_OF
-static struct of_device_id altera_uart_match[] = {
+static const struct of_device_id altera_uart_match[] = {
 	{ .compatible = "ALTR,uart-1.0", },
 	{ .compatible = "altr,uart-1.0", },
 	{},

commit 2970b7f5ea3cea2f169ca23fd863e24d03748ffd
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Fri Jul 11 14:00:11 2014 +0100

    serial: altera: Adopt uart_console_write()
    
    This driver does not currently use uart_console_write() and instead
    provides is own LF to LFCR conversion in it's console_write() method.
    We should use the library function instead.
    
    Cmopile tested only (with ARCH=arm).
    
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-serial@vger.kernel.org
    Cc: nios2-dev@lists.rocketboards.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 4c1eae93110c..6a243239dbef 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -430,7 +430,7 @@ static struct altera_uart altera_uart_ports[CONFIG_SERIAL_ALTERA_UART_MAXPORTS];
 
 #if defined(CONFIG_SERIAL_ALTERA_UART_CONSOLE)
 
-static void altera_uart_console_putc(struct uart_port *port, const char c)
+static void altera_uart_console_putc(struct uart_port *port, int c)
 {
 	while (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
 		 ALTERA_UART_STATUS_TRDY_MSK))
@@ -444,11 +444,7 @@ static void altera_uart_console_write(struct console *co, const char *s,
 {
 	struct uart_port *port = &(altera_uart_ports + co->index)->port;
 
-	for (; count; count--, s++) {
-		altera_uart_console_putc(port, *s);
-		if (*s == '\n')
-			altera_uart_console_putc(port, '\r');
-	}
+	uart_console_write(port, s, count, altera_uart_console_putc);
 }
 
 static int __init altera_uart_console_setup(struct console *co, char *options)

commit 8b152f1096975d012f60387b899d407e4a93b46c
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Tue Jun 3 18:54:44 2014 +0400

    serial: treewide: Remove empty implementations of enable_ms()
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 323376668b72..4c1eae93110c 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -163,10 +163,6 @@ static void altera_uart_break_ctl(struct uart_port *port, int break_state)
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static void altera_uart_enable_ms(struct uart_port *port)
-{
-}
-
 static void altera_uart_set_termios(struct uart_port *port,
 				    struct ktermios *termios,
 				    struct ktermios *old)
@@ -415,7 +411,6 @@ static struct uart_ops altera_uart_ops = {
 	.start_tx	= altera_uart_start_tx,
 	.stop_tx	= altera_uart_stop_tx,
 	.stop_rx	= altera_uart_stop_rx,
-	.enable_ms	= altera_uart_enable_ms,
 	.break_ctl	= altera_uart_break_ctl,
 	.startup	= altera_uart_startup,
 	.shutdown	= altera_uart_shutdown,

commit ef8b9ddcb45fa3b1e11acd72be2398001e807d14
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Jun 16 08:10:41 2014 -0400

    serial: Fix IGNBRK handling
    
    If IGNBRK is set without either BRKINT or PARMRK set, some uart
    drivers send a 0x00 byte for BREAK without the TTYBREAK flag to the
    line discipline, when it should send either nothing or the TTYBREAK flag
    set. This happens because the read_status_mask masks out the BI
    condition, which uart_insert_char() then interprets as a normal 0x00 byte.
    
    SUS v3 is clear regarding the meaning of IGNBRK; Section 11.2.2, General
    Terminal Interface - Input Modes, states:
      "If IGNBRK is set, a break condition detected on input shall be ignored;
       that is, not put on the input queue and therefore not read by any
       process."
    
    Fix read_status_mask to include the BI bit if IGNBRK is set; the
    lsr status retains the BI bit if a BREAK is recv'd, which is
    subsequently ignored in uart_insert_char() when masked with the
    ignore_status_mask.
    
    Affected drivers:
    8250 - all
    serial_txx9
    mfd
    amba-pl010
    amba-pl011
    atmel_serial
    bfin_uart
    dz
    ip22zilog
    max310x
    mxs-auart
    netx-serial
    pnx8xxx_uart
    pxa
    sb1250-duart
    sccnxp
    serial_ks8695
    sirfsoc_uart
    st-asc
    vr41xx_siu
    zs
    sunzilog
    fsl_lpuart
    sunsab
    ucc_uart
    bcm63xx_uart
    sunsu
    efm32-uart
    pmac_zilog
    mpsc
    msm_serial
    m32r_sio
    
    Unaffected drivers:
    omap-serial
    rp2
    sa1100
    imx
    icom
    
    Annotated for fixes:
    altera_uart
    mcf
    
    Drivers without break detection:
    21285
    xilinx-uartps
    altera_jtaguart
    apbuart
    arc-uart
    clps711x
    max3100
    uartlite
    msm_serial_hs
    nwpserial
    lantiq
    vt8500_serial
    
    Unknown:
    samsung
    mpc52xx_uart
    bfin_sport_uart
    cpm_uart/core
    
    Fixes: Bugzilla #71651, '8250_core.c incorrectly handles IGNBRK flag'
    Reported-by: Ivan <athlon_@mail.ru>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 501667e3e3f5..323376668b72 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -185,6 +185,12 @@ static void altera_uart_set_termios(struct uart_port *port,
 	uart_update_timeout(port, termios->c_cflag, baud);
 	altera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);
 	spin_unlock_irqrestore(&port->lock, flags);
+
+	/*
+	 * FIXME: port->read_status_mask and port->ignore_status_mask
+	 * need to be initialized based on termios settings for
+	 * INPCK, IGNBRK, IGNPAR, PARMRK, BRKINT
+	 */
 }
 
 static void altera_uart_rx_chars(struct altera_uart *pp)

commit dccfd1e439c11422d7aca0d834b0430d24650e85
Merge: 8e73e367f7dc 56e9e0f3a3c5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:26:27 2013 -0700

    Merge tag 'dt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC DT updates from Olof Johansson:
     "Device tree and bindings updates for 3.12.
    
      General additions of various on-chip and on-board peripherals on
      various platforms as support gets added.  Some of the bigger changes
      are:
    
       - Addition of (new) PCI-e support on Tegra.
       - More Tegra4 support, including PMC configuration for Dalmore.
       - Addition of a new board for Exynos4 (trats2) and more bindings for
         4x12 IP.
       - Addition of Allwinner A20 and A31 SoC and board files.
       - Move of the ST Ericsson device tree files to now use ste-* prefix.
       - More move of hardware description of shmobile platforms to DT.
       - Two new board dts files for Freescale MXs"
    
    * tag 'dt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (177 commits)
      dts: Rename DW APB timer compatible strings
      dts: Deprecate ALTR as a vendor prefix
      of: add vendor prefix for Altera Corp.
      ARM: at91/dt: sam9x5ek: add sound configuration
      ARM: at91/dt: sam9x5ek: enable SSC
      ARM: at91/dt: sam9x5ek: add WM8731 codec
      ARM: at91/dt: sam9x5: add SSC DMA parameters
      ARM: at91/dt: add at91rm9200 PQFP package version
      ARM: at91: at91rm9200: set default mmc0 pinctrl-names
      ARM: at91: at91sam9n12: correct pin number of gpio-key
      ARM: at91: at91sam9n12: add qt1070 support
      ARM: at91: at91sam9n12: add pinctrl of TWI
      ARM: at91: Add PMU support for sama5d3
      ARM: at91: at91sam9260: add missing pinctrl-names on mmc
      ARM: tegra: configure power off for Dalmore
      ARM: DT: binding fixup to align with vendor-prefixes.txt (DT)
      ARM: dts: add sdio blocks to bcm28155-ap board
      ARM: dts: align sdio numbers to HW definition
      ARM: sun7i: Add Olimex A20-Olinuxino-Micro support
      ARM: sun7i: Add Allwinner A20 DTSI
      ...

commit 13960b47dc1df695f8537c32a0e0ce5ae5d4eee4
Author: Dinh Nguyen <dinguyen@altera.com>
Date:   Wed Aug 14 15:25:19 2013 -0500

    dts: Deprecate ALTR as a vendor prefix
    
    Because most of the vendor prefixes are lower case, deprecate
    the vendor prefix "ALTR" in place of "altr" for Altera Corp..
    
    Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Ian Campbell <ian.campbell@citrix.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 1d46966e2a65..8b5a8a2caebc 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -613,6 +613,7 @@ static int altera_uart_remove(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static struct of_device_id altera_uart_match[] = {
 	{ .compatible = "ALTR,uart-1.0", },
+	{ .compatible = "altr,uart-1.0", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, altera_uart_match);

commit dd085ed8ef6c97e0b606da304856b36e0d3496ac
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 19 20:14:06 2013 +0530

    tty: serial: altera: drop uart_port->lock before calling tty_flip_buffer_push()
    
    The current driver triggers a lockdep warning for if tty_flip_buffer_push() is
    called with uart_port->lock locked. This never shows up on UP kernels and comes
    up only on SMP kernels.
    
    Crash looks like this (produced with samsung.c driver):
    
    -----
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8)
    [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8) from [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0)
    [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0x38) from [<c020a1a8>] (s3c24xx_serial_rx_chars+0)
    [<c020a1a8>] (s3c24xx_serial_rx_chars+0x12c/0x260) from [<c020aae8>] (s3c64xx_serial_handle_irq+)
    [<c020aae8>] (s3c64xx_serial_handle_irq+0x48/0x60) from [<c006aaa0>] (handle_irq_event_percpu+0x)
    [<c006aaa0>] (handle_irq_event_percpu+0x50/0x194) from [<c006ac20>] (handle_irq_event+0x3c/0x5c)
    [<c006ac20>] (handle_irq_event+0x3c/0x5c) from [<c006d864>] (handle_fasteoi_irq+0x80/0x13c)
    [<c006d864>] (handle_fasteoi_irq+0x80/0x13c) from [<c006a4a4>] (generic_handle_irq+0x20/0x30)
    [<c006a4a4>] (generic_handle_irq+0x20/0x30) from [<c000f454>] (handle_IRQ+0x38/0x94)
    [<c000f454>] (handle_IRQ+0x38/0x94) from [<c0008538>] (gic_handle_irq+0x34/0x68)
    [<c0008538>] (gic_handle_irq+0x34/0x68) from [<c00123c0>] (__irq_svc+0x40/0x70)
    Exception stack(0xc04cdf70 to 0xc04cdfb8)
    df60:                                     00000000 00000000 0000166e 00000000
    df80: c04cc000 c050278f c050278f 00000001 c04d444c 410fc0f4 c03649b0 00000000
    dfa0: 00000001 c04cdfb8 c000f758 c000f75c 60070013 ffffffff
    [<c00123c0>] (__irq_svc+0x40/0x70) from [<c000f75c>] (arch_cpu_idle+0x28/0x30)
    [<c000f75c>] (arch_cpu_idle+0x28/0x30) from [<c0054888>] (cpu_startup_entry+0x5c/0x148)
    [<c0054888>] (cpu_startup_entry+0x5c/0x148) from [<c0497aa4>] (start_kernel+0x334/0x38c)
    BUG: spinlock lockup suspected on CPU#0, kworker/0:1/360
     lock: s3c24xx_serial_ports+0x1d8/0x370, .magic: dead4ead, .owner: <none>/-1, .owner_cpu: -1
    CPU: 0 PID: 360 Comm: kworker/0:1 Not tainted 3.11.0-rc6-next-20130819-00003-g75485f1 #2
    Workqueue: events flush_to_ldisc
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b581c>] (do_raw_spin_lock+0x100/0x17c)
    [<c01b581c>] (do_raw_spin_lock+0x100/0x17c) from [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28)
    [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28) from [<c0203224>] (uart_start+0x18/0x34)
    [<c0203224>] (uart_start+0x18/0x34) from [<c01ef890>] (__receive_buf+0x4b4/0x738)
    [<c01ef890>] (__receive_buf+0x4b4/0x738) from [<c01efb44>] (n_tty_receive_buf2+0x30/0x98)
    [<c01efb44>] (n_tty_receive_buf2+0x30/0x98) from [<c01f2ba8>] (flush_to_ldisc+0xec/0x138)
    [<c01f2ba8>] (flush_to_ldisc+0xec/0x138) from [<c0031af0>] (process_one_work+0xfc/0x348)
    [<c0031af0>] (process_one_work+0xfc/0x348) from [<c0032138>] (worker_thread+0x138/0x37c)
    [<c0032138>] (worker_thread+0x138/0x37c) from [<c0037a7c>] (kthread+0xa4/0xb0)
    [<c0037a7c>] (kthread+0xa4/0xb0) from [<c000e5f8>] (ret_from_fork+0x14/0x3c)
    -----
    
    Release the port lock before calling tty_flip_buffer_push() and reacquire it
    after the call.
    
    Similar stuff was already done for few other drivers in the past, like:
    
    commit 2389b272168ceec056ca1d8a870a97fa9c26e11a
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue May 29 21:53:50 2007 +0100
    
        [ARM] 4417/1: Serial: Fix AMBA drivers locking
    
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index fa638db9a98c..6431472aeb1f 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -231,7 +231,9 @@ static void altera_uart_rx_chars(struct altera_uart *pp)
 				 flag);
 	}
 
+	spin_unlock(&port->lock);
 	tty_flip_buffer_push(&port->state->port);
+	spin_lock(&port->lock);
 }
 
 static void altera_uart_tx_chars(struct altera_uart *pp)

commit 574de559c1797618fd8ed03576837eb3113c5d26
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:06:57 2013 +0900

    serial: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 1d46966e2a65..fa638db9a98c 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -534,7 +534,7 @@ static int altera_uart_get_of_uartclk(struct platform_device *pdev,
 
 static int altera_uart_probe(struct platform_device *pdev)
 {
-	struct altera_uart_platform_uart *platp = pdev->dev.platform_data;
+	struct altera_uart_platform_uart *platp = dev_get_platdata(&pdev->dev);
 	struct uart_port *port;
 	struct resource *res_mem;
 	struct resource *res_irq;

commit cd97721a1b6bbf6eaa9ad050eb472c7f180bd0e0
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue May 7 16:15:28 2013 +0900

    serial: altera: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure, since commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    (device-core: Ensure drvdata = NULL when no driver is bound).
    Thus, it is not needed to manually clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 13471dd95793..1d46966e2a65 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -604,7 +604,6 @@ static int altera_uart_remove(struct platform_device *pdev)
 
 	if (port) {
 		uart_remove_one_port(&altera_uart_driver, port);
-		platform_set_drvdata(pdev, NULL);
 		port->mapbase = 0;
 	}
 

commit 61bc65599f8118fc53975670f19c37fe2be92a3d
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Tue Feb 5 18:07:42 2013 +0100

    tty: serial: altera_uart: Simplify altera_uart_init()
    
    No need for two separate return statements, consolidate them.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index e133c8814bb5..13471dd95793 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -637,11 +637,9 @@ static int __init altera_uart_init(void)
 	if (rc)
 		return rc;
 	rc = platform_driver_register(&altera_uart_platform_driver);
-	if (rc) {
+	if (rc)
 		uart_unregister_driver(&altera_uart_driver);
-		return rc;
-	}
-	return 0;
+	return rc;
 }
 
 static void __exit altera_uart_exit(void)

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 684a0808e1c7..e133c8814bb5 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -231,7 +231,7 @@ static void altera_uart_rx_chars(struct altera_uart *pp)
 				 flag);
 	}
 
-	tty_flip_buffer_push(port->state->port.tty);
+	tty_flip_buffer_push(&port->state->port);
 }
 
 static void altera_uart_tx_chars(struct altera_uart *pp)

commit ae8d8a146725a966bd7c59c94f4d0016dcf7a04f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:18 2012 -0500

    tty: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: David Brown <davidb@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 066b5035e10a..684a0808e1c7 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -598,7 +598,7 @@ static int altera_uart_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit altera_uart_remove(struct platform_device *pdev)
+static int altera_uart_remove(struct platform_device *pdev)
 {
 	struct uart_port *port = platform_get_drvdata(pdev);
 

commit 9671f09921d93e722a28ae9610d478e092ac5466
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:50 2012 -0500

    tty: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 117ea2c89630..066b5035e10a 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -532,7 +532,7 @@ static int altera_uart_get_of_uartclk(struct platform_device *pdev,
 }
 #endif /* CONFIG_OF */
 
-static int __devinit altera_uart_probe(struct platform_device *pdev)
+static int altera_uart_probe(struct platform_device *pdev)
 {
 	struct altera_uart_platform_uart *platp = pdev->dev.platform_data;
 	struct uart_port *port;

commit 2d47b7160243b1422006b91debf438484a4fde58
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:34 2012 -0500

    tty: serial: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 15d80b9fb303..117ea2c89630 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -621,7 +621,7 @@ MODULE_DEVICE_TABLE(of, altera_uart_match);
 
 static struct platform_driver altera_uart_platform_driver = {
 	.probe	= altera_uart_probe,
-	.remove	= __devexit_p(altera_uart_remove),
+	.remove	= altera_uart_remove,
 	.driver	= {
 		.name		= DRV_NAME,
 		.owner		= THIS_MODULE,

commit 1a16afa2cecd36bc4b6ba00fe4c83fcf5ca6e710
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Mon Aug 20 15:56:34 2012 +0200

    tty: serial: altera_uart: Use platform_{get,set}_drvdata
    
    Use the wrapper functions, so we can directly pass a struct
    platfrom_device.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 1f0330915d5a..15d80b9fb303 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -591,7 +591,7 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	port->ops = &altera_uart_ops;
 	port->flags = UPF_BOOT_AUTOCONF;
 
-	dev_set_drvdata(&pdev->dev, port);
+	platform_set_drvdata(pdev, port);
 
 	uart_add_one_port(&altera_uart_driver, port);
 
@@ -600,11 +600,11 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 
 static int __devexit altera_uart_remove(struct platform_device *pdev)
 {
-	struct uart_port *port = dev_get_drvdata(&pdev->dev);
+	struct uart_port *port = platform_get_drvdata(pdev);
 
 	if (port) {
 		uart_remove_one_port(&altera_uart_driver, port);
-		dev_set_drvdata(&pdev->dev, NULL);
+		platform_set_drvdata(pdev, NULL);
 		port->mapbase = 0;
 	}
 

commit acede70d6561f2d042d9dbb153d9a3469479c0ed
Author: Yuriy Kozlov <ykozlov@ptcusa.com>
Date:   Thu Mar 29 09:55:27 2012 +0200

    tty: serial: altera_uart: Check for NULL platform_data in probe.
    
    Follow altera_jtag_uart.  This fixes a crash if there is a mistake in the DTS.
    
    Signed-off-by: Yuriy Kozlov <ykozlov@ptcusa.com>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index e7903751e058..1f0330915d5a 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -556,7 +556,7 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res_mem)
 		port->mapbase = res_mem->start;
-	else if (platp->mapbase)
+	else if (platp)
 		port->mapbase = platp->mapbase;
 	else
 		return -EINVAL;
@@ -564,7 +564,7 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (res_irq)
 		port->irq = res_irq->start;
-	else if (platp->irq)
+	else if (platp)
 		port->irq = platp->irq;
 
 	/* Check platform data first so we can override device node data */

commit 418a936e84e8f346da322c2e839992aa9df108d4
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Feb 8 14:36:09 2012 +0100

    tty: serial: altera_uart: Add CONSOLE_POLL support
    
    This allows altera_uart to be used for KGDB debugging over serial line.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 217833e94b5b..e7903751e058 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -377,6 +377,26 @@ static int altera_uart_verify_port(struct uart_port *port,
 	return 0;
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int altera_uart_poll_get_char(struct uart_port *port)
+{
+	while (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+		 ALTERA_UART_STATUS_RRDY_MSK))
+		cpu_relax();
+
+	return altera_uart_readl(port, ALTERA_UART_RXDATA_REG);
+}
+
+static void altera_uart_poll_put_char(struct uart_port *port, unsigned char c)
+{
+	while (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+		 ALTERA_UART_STATUS_TRDY_MSK))
+		cpu_relax();
+
+	altera_uart_writel(port, c, ALTERA_UART_TXDATA_REG);
+}
+#endif
+
 /*
  *	Define the basic serial functions we support.
  */
@@ -397,6 +417,10 @@ static struct uart_ops altera_uart_ops = {
 	.release_port	= altera_uart_release_port,
 	.config_port	= altera_uart_config_port,
 	.verify_port	= altera_uart_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char	= altera_uart_poll_get_char,
+	.poll_put_char	= altera_uart_poll_put_char,
+#endif
 };
 
 static struct altera_uart altera_uart_ports[CONFIG_SERIAL_ALTERA_UART_MAXPORTS];

commit 3f5dc70721af68b76ad544b0c61fea365d67c041
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Feb 8 14:35:46 2012 +0100

    tty: serial: altera_uart: remove early_altera_uart_setup
    
    The function has no users inside the tree and the nios2
    (out-of-mainline) port doesn't use it either (anymore).
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 1d04c5037f25..217833e94b5b 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -403,29 +403,6 @@ static struct altera_uart altera_uart_ports[CONFIG_SERIAL_ALTERA_UART_MAXPORTS];
 
 #if defined(CONFIG_SERIAL_ALTERA_UART_CONSOLE)
 
-int __init early_altera_uart_setup(struct altera_uart_platform_uart *platp)
-{
-	struct uart_port *port;
-	int i;
-
-	for (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS && platp[i].mapbase; i++) {
-		port = &altera_uart_ports[i].port;
-
-		port->line = i;
-		port->type = PORT_ALTERA_UART;
-		port->mapbase = platp[i].mapbase;
-		port->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);
-		port->iotype = SERIAL_IO_MEM;
-		port->irq = platp[i].irq;
-		port->uartclk = platp[i].uartclk;
-		port->flags = UPF_BOOT_AUTOCONF;
-		port->ops = &altera_uart_ops;
-		port->private_data = platp;
-	}
-
-	return 0;
-}
-
 static void altera_uart_console_putc(struct uart_port *port, const char c)
 {
 	while (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &

commit 5fffb9513cb7fdd39e03c4cab1cda9c2f2694576
Merge: b96d71571f77 ae97159aed6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 27 08:35:41 2011 +0200

    Merge branch 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6
    
    * 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6:
      of_mdio: Don't phy_scan_fixups() twice
      Devicetree: Expand on ARM Primecell binding documentation
      dt: Add empty of_match_node() macro
      dt: add empty dt helpers for non-dt build
      devicetree: fix build error on drivers/tty/serial/altera_jtaguart.c
      devicetree: Add ARM pl022 spi controller binding doc
      devicetree: Add ARM pl061 gpio controller binding doc
      of/irq: of_irq_find_parent: check for parent equal to child
      MAINTAINERS: update devicetree maintainers
      dt: add helper to read 64-bit integers
      tty: use of_match_ptr() for of_match_table entry
      OF: Add of_match_ptr() macro
      dt: add empty for_each_child_of_node, of_find_property
      devicetree: Document Qualcomm and Atmel prefixes
      serial/imx: add of_alias_get_id() reference back
      dt: add of_alias_scan and of_alias_get_id
      devicetree: Add a registry of vendor prefixes

commit 85888069cf5d0f21312e3ee730458a5e3a553509
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Aug 3 10:11:43 2011 +0100

    tty: use of_match_ptr() for of_match_table entry
    
    Use the new of_match_ptr() macro for the of_match_table
    pointer entry to avoid having to #dfine match NULL
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 50bc5a5ac653..0abd31d2361b 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -616,8 +616,6 @@ static struct of_device_id altera_uart_match[] = {
 	{},
 };
 MODULE_DEVICE_TABLE(of, altera_uart_match);
-#else
-#define altera_uart_match NULL
 #endif /* CONFIG_OF */
 
 static struct platform_driver altera_uart_platform_driver = {
@@ -626,7 +624,7 @@ static struct platform_driver altera_uart_platform_driver = {
 	.driver	= {
 		.name		= DRV_NAME,
 		.owner		= THIS_MODULE,
-		.of_match_table	= altera_uart_match,
+		.of_match_table	= of_match_ptr(altera_uart_match),
 	},
 };
 

commit 9cfb5c05fee914cc65d4706801f6bc424082b5f5
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:15 2011 +0800

    TTY: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 50bc5a5ac653..d902558ccfd2 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -315,7 +315,7 @@ static int altera_uart_startup(struct uart_port *port)
 		return 0;
 	}
 
-	ret = request_irq(port->irq, altera_uart_interrupt, IRQF_DISABLED,
+	ret = request_irq(port->irq, altera_uart_interrupt, 0,
 			DRV_NAME, port);
 	if (ret) {
 		pr_err(DRV_NAME ": unable to attach Altera UART %d "

commit a664ec9675d77aa2196e797afa5516d3e476da77
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Mon Mar 28 13:57:11 2011 +0200

    serial: altera_uart: Scan for a free port if platform device id is -1
    
    Devices extracted from device tree all seem to have pdev->id set to -1.
    Up until now we mapped all devices with id -1 to the first device.  This
    behaviour could lead to problems when using more than one Altera UART in
    a system.
    
    This patch changes the behaviour of the driver to scan for the next free
    id in case the id is -1.
    
    Because we cannot refer back to the assigned id in altera_uart_remove,
    the port instance needs to be stored in device drvdata.
    
    Reported-by: David Smoot <davidsmoot@gmail.com>
    Cc: Anton Vorontsov <cbouatmailru@gmail.com>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 6d5b036ac783..50bc5a5ac653 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -540,11 +540,14 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	int i = pdev->id;
 	int ret;
 
-	/* -1 emphasizes that the platform must have one port, no .N suffix */
-	if (i == -1)
-		i = 0;
+	/* if id is -1 scan for a free id and use that one */
+	if (i == -1) {
+		for (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS; i++)
+			if (altera_uart_ports[i].port.mapbase == 0)
+				break;
+	}
 
-	if (i >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)
+	if (i < 0 || i >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)
 		return -EINVAL;
 
 	port = &altera_uart_ports[i].port;
@@ -587,6 +590,8 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	port->ops = &altera_uart_ops;
 	port->flags = UPF_BOOT_AUTOCONF;
 
+	dev_set_drvdata(&pdev->dev, port);
+
 	uart_add_one_port(&altera_uart_driver, port);
 
 	return 0;
@@ -594,14 +599,13 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 
 static int __devexit altera_uart_remove(struct platform_device *pdev)
 {
-	struct uart_port *port;
-	int i = pdev->id;
+	struct uart_port *port = dev_get_drvdata(&pdev->dev);
 
-	if (i == -1)
-		i = 0;
-
-	port = &altera_uart_ports[i].port;
-	uart_remove_one_port(&altera_uart_driver, port);
+	if (port) {
+		uart_remove_one_port(&altera_uart_driver, port);
+		dev_set_drvdata(&pdev->dev, NULL);
+		port->mapbase = 0;
+	}
 
 	return 0;
 }

commit 4c5811bf463b0ef82fabbd1708f8bb2d753aeb18
Merge: f74b9444192c 9f15444fefdb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 17:28:10 2011 -0700

    Merge branch 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6
    
    * 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6: (21 commits)
      tty: serial: altera_jtaguart: Add device tree support
      tty: serial: altera_uart: Add devicetree support
      dt: eliminate of_platform_driver shim code
      dt: Eliminate of_platform_{,un}register_driver
      dt/serial: Eliminate users of of_platform_{,un}register_driver
      dt/usb: Eliminate users of of_platform_{,un}register_driver
      dt/video: Eliminate users of of_platform_{,un}register_driver
      dt/net: Eliminate users of of_platform_{,un}register_driver
      dt/sound: Eliminate users of of_platform_{,un}register_driver
      dt/spi: Eliminate users of of_platform_{,un}register_driver
      dt: uartlite: merge platform and of_platform driver bindings
      dt: xilinx_hwicap: merge platform and of_platform driver bindings
      ipmi: convert OF driver to platform driver
      leds/leds-gpio: merge platform_driver with of_platform_driver
      dt/sparc: Eliminate users of of_platform_{,un}register_driver
      dt/powerpc: Eliminate users of of_platform_{,un}register_driver
      dt/powerpc: move of_bus_type infrastructure to ibmebus
      drivercore/dt: add a match table pointer to struct device
      dt: Typo fix.
      altera_ps2: Add devicetree support
      ...

commit 7c9325d79a3c3d51c98812161d47876d6830c062
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Feb 18 11:35:32 2011 +0100

    tty: serial: altera_uart: Add devicetree support
    
    With the recent switch of the (currently still out-of-tree) Nios2 Linux
    port to devicetree we want to be able to retrieve the resources and
    properties from dts.
    
    The old method to retrieve resources and properties from platform data
    is still supported.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 721216292a50..1803c37d58ab 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -24,6 +24,7 @@
 #include <linux/serial.h>
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
+#include <linux/of.h>
 #include <linux/io.h>
 #include <linux/altera_uart.h>
 
@@ -511,6 +512,29 @@ static struct uart_driver altera_uart_driver = {
 	.cons		= ALTERA_UART_CONSOLE,
 };
 
+#ifdef CONFIG_OF
+static int altera_uart_get_of_uartclk(struct platform_device *pdev,
+				      struct uart_port *port)
+{
+	int len;
+	const __be32 *clk;
+
+	clk = of_get_property(pdev->dev.of_node, "clock-frequency", &len);
+	if (!clk || len < sizeof(__be32))
+		return -ENODEV;
+
+	port->uartclk = be32_to_cpup(clk);
+
+	return 0;
+}
+#else
+static int altera_uart_get_of_uartclk(struct platform_device *pdev,
+				      struct uart_port *port)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_OF */
+
 static int __devinit altera_uart_probe(struct platform_device *pdev)
 {
 	struct altera_uart_platform_uart *platp = pdev->dev.platform_data;
@@ -518,6 +542,7 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	struct resource *res_mem;
 	struct resource *res_irq;
 	int i = pdev->id;
+	int ret;
 
 	/* -1 emphasizes that the platform must have one port, no .N suffix */
 	if (i == -1)
@@ -542,6 +567,15 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	else if (platp->irq)
 		port->irq = platp->irq;
 
+	/* Check platform data first so we can override device node data */
+	if (platp)
+		port->uartclk = platp->uartclk;
+	else {
+		ret = altera_uart_get_of_uartclk(pdev, port);
+		if (ret)
+			return ret;
+	}
+
 	port->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);
 	if (!port->membase)
 		return -ENOMEM;
@@ -549,7 +583,6 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	port->line = i;
 	port->type = PORT_ALTERA_UART;
 	port->iotype = SERIAL_IO_MEM;
-	port->uartclk = platp->uartclk;
 	port->ops = &altera_uart_ops;
 	port->flags = UPF_BOOT_AUTOCONF;
 	port->private_data = platp;
@@ -567,13 +600,23 @@ static int __devexit altera_uart_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static struct of_device_id altera_uart_match[] = {
+	{ .compatible = "ALTR,uart-1.0", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, altera_uart_match);
+#else
+#define altera_uart_match NULL
+#endif /* CONFIG_OF */
+
 static struct platform_driver altera_uart_platform_driver = {
 	.probe	= altera_uart_probe,
 	.remove	= __devexit_p(altera_uart_remove),
 	.driver	= {
-		.name	= DRV_NAME,
-		.owner	= THIS_MODULE,
-		.pm	= NULL,
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= altera_uart_match,
 	},
 };
 

commit 2780ad42f5fe6739882603c61c8decba6e50eaa2
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Feb 9 10:57:04 2011 +0100

    tty: serial: altera_uart: Use port->regshift to store bus shift
    
    Use the regshift member of struct uart_port to store the address stride
    from platform data. This way we can save one dereference per call of
    altera_uart_readl and altera_uart_writel.
    
    This also allows us to use the driver without platform data, which is
    needed for device tree support in the Nios2 port.
    
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index dee7a0eb6ea1..3a573528555e 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -86,16 +86,12 @@ struct altera_uart {
 
 static u32 altera_uart_readl(struct uart_port *port, int reg)
 {
-	struct altera_uart_platform_uart *platp = port->private_data;
-
-	return readl(port->membase + (reg << platp->bus_shift));
+	return readl(port->membase + (reg << port->regshift));
 }
 
 static void altera_uart_writel(struct uart_port *port, u32 dat, int reg)
 {
-	struct altera_uart_platform_uart *platp = port->private_data;
-
-	writel(dat, port->membase + (reg << platp->bus_shift));
+	writel(dat, port->membase + (reg << port->regshift));
 }
 
 static unsigned int altera_uart_tx_empty(struct uart_port *port)
@@ -546,13 +542,17 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 	if (!port->membase)
 		return -ENOMEM;
 
+	if (platp)
+		port->regshift = platp->bus_shift;
+	else
+		port->regshift = 0;
+
 	port->line = i;
 	port->type = PORT_ALTERA_UART;
 	port->iotype = SERIAL_IO_MEM;
 	port->uartclk = platp->uartclk;
 	port->ops = &altera_uart_ops;
 	port->flags = UPF_BOOT_AUTOCONF;
-	port->private_data = platp;
 
 	uart_add_one_port(&altera_uart_driver, port);
 

commit e96fabd8791aad30a3c8a03919893ae3e2e3df25
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Feb 9 10:56:52 2011 +0100

    tty: serial: altera_uart: Handle pdev->id == -1 in altera_uart_remove
    
    Commit 6b5756f176568a710d008d3b478128fafb6707f0 introduced the
    possibility for pdev->id being -1 but the change was not done equally in
    altera_uart_remove. This patch fixes this.
    
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
index 721216292a50..dee7a0eb6ea1 100644
--- a/drivers/tty/serial/altera_uart.c
+++ b/drivers/tty/serial/altera_uart.c
@@ -561,9 +561,15 @@ static int __devinit altera_uart_probe(struct platform_device *pdev)
 
 static int __devexit altera_uart_remove(struct platform_device *pdev)
 {
-	struct uart_port *port = &altera_uart_ports[pdev->id].port;
+	struct uart_port *port;
+	int i = pdev->id;
 
+	if (i == -1)
+		i = 0;
+
+	port = &altera_uart_ports[i].port;
 	uart_remove_one_port(&altera_uart_driver, port);
+
 	return 0;
 }
 

commit ab4382d27412e7e3e7c936e8d50d8888dfac3df8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 13 12:10:18 2011 -0800

    tty: move drivers/serial/ to drivers/tty/serial/
    
    The serial drivers are really just tty drivers, so move them to
    drivers/tty/ to make things a bit neater overall.
    
    This is part of the tty/serial driver movement proceedure as proposed by
    Arnd Bergmann and approved by everyone involved a number of months ago.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Rogier Wolff <R.E.Wolff@bitwizard.nl>
    Cc: Michael H. Warfield <mhw@wittsend.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/altera_uart.c b/drivers/tty/serial/altera_uart.c
new file mode 100644
index 000000000000..721216292a50
--- /dev/null
+++ b/drivers/tty/serial/altera_uart.c
@@ -0,0 +1,608 @@
+/*
+ * altera_uart.c -- Altera UART driver
+ *
+ * Based on mcf.c -- Freescale ColdFire UART driver
+ *
+ * (C) Copyright 2003-2007, Greg Ungerer <gerg@snapgear.com>
+ * (C) Copyright 2008, Thomas Chou <thomas@wytron.com.tw>
+ * (C) Copyright 2010, Tobias Klauser <tklauser@distanz.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/altera_uart.h>
+
+#define DRV_NAME "altera_uart"
+#define SERIAL_ALTERA_MAJOR 204
+#define SERIAL_ALTERA_MINOR 213
+
+/*
+ * Altera UART register definitions according to the Nios UART datasheet:
+ * http://www.altera.com/literature/ds/ds_nios_uart.pdf
+ */
+
+#define ALTERA_UART_SIZE		32
+
+#define ALTERA_UART_RXDATA_REG		0
+#define ALTERA_UART_TXDATA_REG		4
+#define ALTERA_UART_STATUS_REG		8
+#define ALTERA_UART_CONTROL_REG		12
+#define ALTERA_UART_DIVISOR_REG		16
+#define ALTERA_UART_EOP_REG		20
+
+#define ALTERA_UART_STATUS_PE_MSK	0x0001	/* parity error */
+#define ALTERA_UART_STATUS_FE_MSK	0x0002	/* framing error */
+#define ALTERA_UART_STATUS_BRK_MSK	0x0004	/* break */
+#define ALTERA_UART_STATUS_ROE_MSK	0x0008	/* RX overrun error */
+#define ALTERA_UART_STATUS_TOE_MSK	0x0010	/* TX overrun error */
+#define ALTERA_UART_STATUS_TMT_MSK	0x0020	/* TX shift register state */
+#define ALTERA_UART_STATUS_TRDY_MSK	0x0040	/* TX ready */
+#define ALTERA_UART_STATUS_RRDY_MSK	0x0080	/* RX ready */
+#define ALTERA_UART_STATUS_E_MSK	0x0100	/* exception condition */
+#define ALTERA_UART_STATUS_DCTS_MSK	0x0400	/* CTS logic-level change */
+#define ALTERA_UART_STATUS_CTS_MSK	0x0800	/* CTS logic state */
+#define ALTERA_UART_STATUS_EOP_MSK	0x1000	/* EOP written/read */
+
+						/* Enable interrupt on... */
+#define ALTERA_UART_CONTROL_PE_MSK	0x0001	/* ...parity error */
+#define ALTERA_UART_CONTROL_FE_MSK	0x0002	/* ...framing error */
+#define ALTERA_UART_CONTROL_BRK_MSK	0x0004	/* ...break */
+#define ALTERA_UART_CONTROL_ROE_MSK	0x0008	/* ...RX overrun */
+#define ALTERA_UART_CONTROL_TOE_MSK	0x0010	/* ...TX overrun */
+#define ALTERA_UART_CONTROL_TMT_MSK	0x0020	/* ...TX shift register empty */
+#define ALTERA_UART_CONTROL_TRDY_MSK	0x0040	/* ...TX ready */
+#define ALTERA_UART_CONTROL_RRDY_MSK	0x0080	/* ...RX ready */
+#define ALTERA_UART_CONTROL_E_MSK	0x0100	/* ...exception*/
+
+#define ALTERA_UART_CONTROL_TRBK_MSK	0x0200	/* TX break */
+#define ALTERA_UART_CONTROL_DCTS_MSK	0x0400	/* Interrupt on CTS change */
+#define ALTERA_UART_CONTROL_RTS_MSK	0x0800	/* RTS signal */
+#define ALTERA_UART_CONTROL_EOP_MSK	0x1000	/* Interrupt on EOP */
+
+/*
+ * Local per-uart structure.
+ */
+struct altera_uart {
+	struct uart_port port;
+	struct timer_list tmr;
+	unsigned int sigs;	/* Local copy of line sigs */
+	unsigned short imr;	/* Local IMR mirror */
+};
+
+static u32 altera_uart_readl(struct uart_port *port, int reg)
+{
+	struct altera_uart_platform_uart *platp = port->private_data;
+
+	return readl(port->membase + (reg << platp->bus_shift));
+}
+
+static void altera_uart_writel(struct uart_port *port, u32 dat, int reg)
+{
+	struct altera_uart_platform_uart *platp = port->private_data;
+
+	writel(dat, port->membase + (reg << platp->bus_shift));
+}
+
+static unsigned int altera_uart_tx_empty(struct uart_port *port)
+{
+	return (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+		ALTERA_UART_STATUS_TMT_MSK) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int altera_uart_get_mctrl(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	unsigned int sigs;
+
+	sigs = (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+	     ALTERA_UART_STATUS_CTS_MSK) ? TIOCM_CTS : 0;
+	sigs |= (pp->sigs & TIOCM_RTS);
+
+	return sigs;
+}
+
+static void altera_uart_set_mctrl(struct uart_port *port, unsigned int sigs)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+
+	pp->sigs = sigs;
+	if (sigs & TIOCM_RTS)
+		pp->imr |= ALTERA_UART_CONTROL_RTS_MSK;
+	else
+		pp->imr &= ~ALTERA_UART_CONTROL_RTS_MSK;
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+}
+
+static void altera_uart_start_tx(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+
+	pp->imr |= ALTERA_UART_CONTROL_TRDY_MSK;
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+}
+
+static void altera_uart_stop_tx(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+
+	pp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+}
+
+static void altera_uart_stop_rx(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+
+	pp->imr &= ~ALTERA_UART_CONTROL_RRDY_MSK;
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+}
+
+static void altera_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	if (break_state == -1)
+		pp->imr |= ALTERA_UART_CONTROL_TRBK_MSK;
+	else
+		pp->imr &= ~ALTERA_UART_CONTROL_TRBK_MSK;
+	altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void altera_uart_enable_ms(struct uart_port *port)
+{
+}
+
+static void altera_uart_set_termios(struct uart_port *port,
+				    struct ktermios *termios,
+				    struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int baud, baudclk;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
+	baudclk = port->uartclk / baud;
+
+	if (old)
+		tty_termios_copy_hw(termios, old);
+	tty_termios_encode_baud_rate(termios, baud, baud);
+
+	spin_lock_irqsave(&port->lock, flags);
+	uart_update_timeout(port, termios->c_cflag, baud);
+	altera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void altera_uart_rx_chars(struct altera_uart *pp)
+{
+	struct uart_port *port = &pp->port;
+	unsigned char ch, flag;
+	unsigned short status;
+
+	while ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &
+	       ALTERA_UART_STATUS_RRDY_MSK) {
+		ch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (status & ALTERA_UART_STATUS_E_MSK) {
+			altera_uart_writel(port, status,
+					   ALTERA_UART_STATUS_REG);
+
+			if (status & ALTERA_UART_STATUS_BRK_MSK) {
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					continue;
+			} else if (status & ALTERA_UART_STATUS_PE_MSK) {
+				port->icount.parity++;
+			} else if (status & ALTERA_UART_STATUS_ROE_MSK) {
+				port->icount.overrun++;
+			} else if (status & ALTERA_UART_STATUS_FE_MSK) {
+				port->icount.frame++;
+			}
+
+			status &= port->read_status_mask;
+
+			if (status & ALTERA_UART_STATUS_BRK_MSK)
+				flag = TTY_BREAK;
+			else if (status & ALTERA_UART_STATUS_PE_MSK)
+				flag = TTY_PARITY;
+			else if (status & ALTERA_UART_STATUS_FE_MSK)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			continue;
+		uart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,
+				 flag);
+	}
+
+	tty_flip_buffer_push(port->state->port.tty);
+}
+
+static void altera_uart_tx_chars(struct altera_uart *pp)
+{
+	struct uart_port *port = &pp->port;
+	struct circ_buf *xmit = &port->state->xmit;
+
+	if (port->x_char) {
+		/* Send special char - probably flow control */
+		altera_uart_writel(port, port->x_char, ALTERA_UART_TXDATA_REG);
+		port->x_char = 0;
+		port->icount.tx++;
+		return;
+	}
+
+	while (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+	       ALTERA_UART_STATUS_TRDY_MSK) {
+		if (xmit->head == xmit->tail)
+			break;
+		altera_uart_writel(port, xmit->buf[xmit->tail],
+		       ALTERA_UART_TXDATA_REG);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (xmit->head == xmit->tail) {
+		pp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;
+		altera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);
+	}
+}
+
+static irqreturn_t altera_uart_interrupt(int irq, void *data)
+{
+	struct uart_port *port = data;
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	unsigned int isr;
+
+	isr = altera_uart_readl(port, ALTERA_UART_STATUS_REG) & pp->imr;
+
+	spin_lock(&port->lock);
+	if (isr & ALTERA_UART_STATUS_RRDY_MSK)
+		altera_uart_rx_chars(pp);
+	if (isr & ALTERA_UART_STATUS_TRDY_MSK)
+		altera_uart_tx_chars(pp);
+	spin_unlock(&port->lock);
+
+	return IRQ_RETVAL(isr);
+}
+
+static void altera_uart_timer(unsigned long data)
+{
+	struct uart_port *port = (void *)data;
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+
+	altera_uart_interrupt(0, port);
+	mod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));
+}
+
+static void altera_uart_config_port(struct uart_port *port, int flags)
+{
+	port->type = PORT_ALTERA_UART;
+
+	/* Clear mask, so no surprise interrupts. */
+	altera_uart_writel(port, 0, ALTERA_UART_CONTROL_REG);
+	/* Clear status register */
+	altera_uart_writel(port, 0, ALTERA_UART_STATUS_REG);
+}
+
+static int altera_uart_startup(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	unsigned long flags;
+	int ret;
+
+	if (!port->irq) {
+		setup_timer(&pp->tmr, altera_uart_timer, (unsigned long)port);
+		mod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));
+		return 0;
+	}
+
+	ret = request_irq(port->irq, altera_uart_interrupt, IRQF_DISABLED,
+			DRV_NAME, port);
+	if (ret) {
+		pr_err(DRV_NAME ": unable to attach Altera UART %d "
+		       "interrupt vector=%d\n", port->line, port->irq);
+		return ret;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Enable RX interrupts now */
+	pp->imr = ALTERA_UART_CONTROL_RRDY_MSK;
+	writel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return 0;
+}
+
+static void altera_uart_shutdown(struct uart_port *port)
+{
+	struct altera_uart *pp = container_of(port, struct altera_uart, port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Disable all interrupts now */
+	pp->imr = 0;
+	writel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (port->irq)
+		free_irq(port->irq, port);
+	else
+		del_timer_sync(&pp->tmr);
+}
+
+static const char *altera_uart_type(struct uart_port *port)
+{
+	return (port->type == PORT_ALTERA_UART) ? "Altera UART" : NULL;
+}
+
+static int altera_uart_request_port(struct uart_port *port)
+{
+	/* UARTs always present */
+	return 0;
+}
+
+static void altera_uart_release_port(struct uart_port *port)
+{
+	/* Nothing to release... */
+}
+
+static int altera_uart_verify_port(struct uart_port *port,
+				   struct serial_struct *ser)
+{
+	if ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_ALTERA_UART))
+		return -EINVAL;
+	return 0;
+}
+
+/*
+ *	Define the basic serial functions we support.
+ */
+static struct uart_ops altera_uart_ops = {
+	.tx_empty	= altera_uart_tx_empty,
+	.get_mctrl	= altera_uart_get_mctrl,
+	.set_mctrl	= altera_uart_set_mctrl,
+	.start_tx	= altera_uart_start_tx,
+	.stop_tx	= altera_uart_stop_tx,
+	.stop_rx	= altera_uart_stop_rx,
+	.enable_ms	= altera_uart_enable_ms,
+	.break_ctl	= altera_uart_break_ctl,
+	.startup	= altera_uart_startup,
+	.shutdown	= altera_uart_shutdown,
+	.set_termios	= altera_uart_set_termios,
+	.type		= altera_uart_type,
+	.request_port	= altera_uart_request_port,
+	.release_port	= altera_uart_release_port,
+	.config_port	= altera_uart_config_port,
+	.verify_port	= altera_uart_verify_port,
+};
+
+static struct altera_uart altera_uart_ports[CONFIG_SERIAL_ALTERA_UART_MAXPORTS];
+
+#if defined(CONFIG_SERIAL_ALTERA_UART_CONSOLE)
+
+int __init early_altera_uart_setup(struct altera_uart_platform_uart *platp)
+{
+	struct uart_port *port;
+	int i;
+
+	for (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS && platp[i].mapbase; i++) {
+		port = &altera_uart_ports[i].port;
+
+		port->line = i;
+		port->type = PORT_ALTERA_UART;
+		port->mapbase = platp[i].mapbase;
+		port->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);
+		port->iotype = SERIAL_IO_MEM;
+		port->irq = platp[i].irq;
+		port->uartclk = platp[i].uartclk;
+		port->flags = UPF_BOOT_AUTOCONF;
+		port->ops = &altera_uart_ops;
+		port->private_data = platp;
+	}
+
+	return 0;
+}
+
+static void altera_uart_console_putc(struct uart_port *port, const char c)
+{
+	while (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &
+		 ALTERA_UART_STATUS_TRDY_MSK))
+		cpu_relax();
+
+	writel(c, port->membase + ALTERA_UART_TXDATA_REG);
+}
+
+static void altera_uart_console_write(struct console *co, const char *s,
+				      unsigned int count)
+{
+	struct uart_port *port = &(altera_uart_ports + co->index)->port;
+
+	for (; count; count--, s++) {
+		altera_uart_console_putc(port, *s);
+		if (*s == '\n')
+			altera_uart_console_putc(port, '\r');
+	}
+}
+
+static int __init altera_uart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = CONFIG_SERIAL_ALTERA_UART_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index < 0 || co->index >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)
+		return -EINVAL;
+	port = &altera_uart_ports[co->index].port;
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver altera_uart_driver;
+
+static struct console altera_uart_console = {
+	.name	= "ttyAL",
+	.write	= altera_uart_console_write,
+	.device	= uart_console_device,
+	.setup	= altera_uart_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &altera_uart_driver,
+};
+
+static int __init altera_uart_console_init(void)
+{
+	register_console(&altera_uart_console);
+	return 0;
+}
+
+console_initcall(altera_uart_console_init);
+
+#define	ALTERA_UART_CONSOLE	(&altera_uart_console)
+
+#else
+
+#define	ALTERA_UART_CONSOLE	NULL
+
+#endif /* CONFIG_ALTERA_UART_CONSOLE */
+
+/*
+ *	Define the altera_uart UART driver structure.
+ */
+static struct uart_driver altera_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRV_NAME,
+	.dev_name	= "ttyAL",
+	.major		= SERIAL_ALTERA_MAJOR,
+	.minor		= SERIAL_ALTERA_MINOR,
+	.nr		= CONFIG_SERIAL_ALTERA_UART_MAXPORTS,
+	.cons		= ALTERA_UART_CONSOLE,
+};
+
+static int __devinit altera_uart_probe(struct platform_device *pdev)
+{
+	struct altera_uart_platform_uart *platp = pdev->dev.platform_data;
+	struct uart_port *port;
+	struct resource *res_mem;
+	struct resource *res_irq;
+	int i = pdev->id;
+
+	/* -1 emphasizes that the platform must have one port, no .N suffix */
+	if (i == -1)
+		i = 0;
+
+	if (i >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)
+		return -EINVAL;
+
+	port = &altera_uart_ports[i].port;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem)
+		port->mapbase = res_mem->start;
+	else if (platp->mapbase)
+		port->mapbase = platp->mapbase;
+	else
+		return -EINVAL;
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res_irq)
+		port->irq = res_irq->start;
+	else if (platp->irq)
+		port->irq = platp->irq;
+
+	port->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);
+	if (!port->membase)
+		return -ENOMEM;
+
+	port->line = i;
+	port->type = PORT_ALTERA_UART;
+	port->iotype = SERIAL_IO_MEM;
+	port->uartclk = platp->uartclk;
+	port->ops = &altera_uart_ops;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->private_data = platp;
+
+	uart_add_one_port(&altera_uart_driver, port);
+
+	return 0;
+}
+
+static int __devexit altera_uart_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = &altera_uart_ports[pdev->id].port;
+
+	uart_remove_one_port(&altera_uart_driver, port);
+	return 0;
+}
+
+static struct platform_driver altera_uart_platform_driver = {
+	.probe	= altera_uart_probe,
+	.remove	= __devexit_p(altera_uart_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.pm	= NULL,
+	},
+};
+
+static int __init altera_uart_init(void)
+{
+	int rc;
+
+	rc = uart_register_driver(&altera_uart_driver);
+	if (rc)
+		return rc;
+	rc = platform_driver_register(&altera_uart_platform_driver);
+	if (rc) {
+		uart_unregister_driver(&altera_uart_driver);
+		return rc;
+	}
+	return 0;
+}
+
+static void __exit altera_uart_exit(void)
+{
+	platform_driver_unregister(&altera_uart_platform_driver);
+	uart_unregister_driver(&altera_uart_driver);
+}
+
+module_init(altera_uart_init);
+module_exit(altera_uart_exit);
+
+MODULE_DESCRIPTION("Altera UART driver");
+MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_ALTERA_MAJOR);
