commit 293f8995948330e1df9228519535593618b5ec0e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Dec 19 15:51:09 2019 +0100

    tty: serial: 21285: stop using the unused[] variable from struct uart_port
    
    Much like the samsung_tty driver (now I know where they copied the idea
    from), the 21285 uart driver uses 2 bytes from the "unused" array of
    struct uart_port to keep tx/rx enabled/disabled state.  Those fields are
    going away (they were never really needed in the first place), so fix up
    the 21285 driver by another horrible hack.
    
    Instead of creating a whole structure for just 2 bytes, just use two
    bits from the private_data pointer instead, as that pointer is never
    used.  The two bits reflect if tx/rx is now enabled/disabled.
    
    Astute readers will note that once rx is disabled, nothing ever seems to
    turn it back on, making one wonder if anyone has ever done this.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Cc: Dmitry Safonov <dima@arista.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20191219145109.GA1962496@kroah.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index 32b3acf8150a..718e010fcb04 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -41,8 +41,43 @@
 
 static const char serial21285_name[] = "Footbridge UART";
 
-#define tx_enabled(port)	((port)->unused[0])
-#define rx_enabled(port)	((port)->unused[1])
+/*
+ * We only need 2 bits of data, so instead of creating a whole structure for
+ * this, use bits of the private_data pointer of the uart port structure.
+ */
+#define tx_enabled_bit	0
+#define rx_enabled_bit	1
+
+static bool is_enabled(struct uart_port *port, int bit)
+{
+	unsigned long private_data = (unsigned long)port->private_data;
+
+	if (test_bit(bit, &private_data))
+		return true;
+	return false;
+}
+
+static void enable(struct uart_port *port, int bit)
+{
+	unsigned long private_data = (unsigned long)port->private_data;
+
+	set_bit(bit, &private_data);
+}
+
+static void disable(struct uart_port *port, int bit)
+{
+	unsigned long private_data = (unsigned long)port->private_data;
+
+	clear_bit(bit, &private_data);
+}
+
+#define is_tx_enabled(port)	is_enabled(port, tx_enabled_bit)
+#define tx_enable(port)		enable(port, tx_enabled_bit)
+#define tx_disable(port)	disable(port, tx_enabled_bit)
+
+#define is_rx_enabled(port)	is_enabled(port, rx_enabled_bit)
+#define rx_enable(port)		enable(port, rx_enabled_bit)
+#define rx_disable(port)	disable(port, rx_enabled_bit)
 
 /*
  * The documented expression for selecting the divisor is:
@@ -57,25 +92,25 @@ static const char serial21285_name[] = "Footbridge UART";
 
 static void serial21285_stop_tx(struct uart_port *port)
 {
-	if (tx_enabled(port)) {
+	if (is_tx_enabled(port)) {
 		disable_irq_nosync(IRQ_CONTX);
-		tx_enabled(port) = 0;
+		tx_disable(port);
 	}
 }
 
 static void serial21285_start_tx(struct uart_port *port)
 {
-	if (!tx_enabled(port)) {
+	if (!is_tx_enabled(port)) {
 		enable_irq(IRQ_CONTX);
-		tx_enabled(port) = 1;
+		tx_enable(port);
 	}
 }
 
 static void serial21285_stop_rx(struct uart_port *port)
 {
-	if (rx_enabled(port)) {
+	if (is_rx_enabled(port)) {
 		disable_irq_nosync(IRQ_CONRX);
-		rx_enabled(port) = 0;
+		rx_disable(port);
 	}
 }
 
@@ -185,8 +220,8 @@ static int serial21285_startup(struct uart_port *port)
 {
 	int ret;
 
-	tx_enabled(port) = 1;
-	rx_enabled(port) = 1;
+	tx_enable(port);
+	rx_enable(port);
 
 	ret = request_irq(IRQ_CONRX, serial21285_rx_chars, 0,
 			  serial21285_name, port);

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index 804632b4a929..32b3acf8150a 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Driver for the serial port on the 21285 StrongArm-110 core logic chip.
  *

commit ccb47a339dabace57c71ab41e6d7cd5f9b8d6746
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Aug 13 08:21:45 2017 +0200

    serial: 21285: constify uart_ops structures
    
    These uart_ops structures are only stored in the ops field of a
    uart_port structure and this fields is const, so the uart_ops
    structures can also be const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index 9b208bd686e6..804632b4a929 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -334,7 +334,7 @@ static int serial21285_verify_port(struct uart_port *port, struct serial_struct
 	return ret;
 }
 
-static struct uart_ops serial21285_ops = {
+static const struct uart_ops serial21285_ops = {
 	.tx_empty	= serial21285_tx_empty,
 	.get_mctrl	= serial21285_get_mctrl,
 	.set_mctrl	= serial21285_set_mctrl,

commit 8b152f1096975d012f60387b899d407e4a93b46c
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Tue Jun 3 18:54:44 2014 +0400

    serial: treewide: Remove empty implementations of enable_ms()
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index c7e8b60b6177..9b208bd686e6 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -78,10 +78,6 @@ static void serial21285_stop_rx(struct uart_port *port)
 	}
 }
 
-static void serial21285_enable_ms(struct uart_port *port)
-{
-}
-
 static irqreturn_t serial21285_rx_chars(int irq, void *dev_id)
 {
 	struct uart_port *port = dev_id;
@@ -345,7 +341,6 @@ static struct uart_ops serial21285_ops = {
 	.stop_tx	= serial21285_stop_tx,
 	.start_tx	= serial21285_start_tx,
 	.stop_rx	= serial21285_stop_rx,
-	.enable_ms	= serial21285_enable_ms,
 	.break_ctl	= serial21285_break_ctl,
 	.startup	= serial21285_startup,
 	.shutdown	= serial21285_shutdown,

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index a44345a2dbb4..c7e8b60b6177 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -85,7 +85,6 @@ static void serial21285_enable_ms(struct uart_port *port)
 static irqreturn_t serial21285_rx_chars(int irq, void *dev_id)
 {
 	struct uart_port *port = dev_id;
-	struct tty_struct *tty = port->state->port.tty;
 	unsigned int status, ch, flag, rxs, max_count = 256;
 
 	status = *CSR_UARTFLG;
@@ -115,7 +114,7 @@ static irqreturn_t serial21285_rx_chars(int irq, void *dev_id)
 
 		status = *CSR_UARTFLG;
 	}
-	tty_flip_buffer_push(tty);
+	tty_flip_buffer_push(&port->state->port);
 
 	return IRQ_HANDLED;
 }

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index f899996b4363..a44345a2dbb4 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -16,6 +16,7 @@
 
 #include <asm/irq.h>
 #include <asm/mach-types.h>
+#include <asm/system_info.h>
 #include <asm/hardware/dec21285.h>
 #include <mach/hardware.h>
 

commit d4e33fac2408d37f7b52e80ca2a89f9fb482914f
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Jan 26 17:44:09 2012 +0000

    serial: Kill off NO_IRQ
    
    We transform the offenders into a test of irq <= 0 which will be ok while
    the ARM people get their platform sorted. Once that is done (or in a while
    if they don't do it anyway) then we will change them all to !irq checks.
    
    For arch specific drivers that are already using NO_IRQ = 0 we just test
    against zero so we don't need to re-review them later.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index 1b37626e8f13..f899996b4363 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -331,7 +331,7 @@ static int serial21285_verify_port(struct uart_port *port, struct serial_struct
 	int ret = 0;
 	if (ser->type != PORT_UNKNOWN && ser->type != PORT_21285)
 		ret = -EINVAL;
-	if (ser->irq != NO_IRQ)
+	if (ser->irq <= 0)
 		ret = -EINVAL;
 	if (ser->baud_base != port->uartclk / 16)
 		ret = -EINVAL;
@@ -360,7 +360,7 @@ static struct uart_ops serial21285_ops = {
 static struct uart_port serial21285_port = {
 	.mapbase	= 0x42000160,
 	.iotype		= UPIO_MEM,
-	.irq		= NO_IRQ,
+	.irq		= 0,
 	.fifosize	= 16,
 	.ops		= &serial21285_ops,
 	.flags		= UPF_BOOT_AUTOCONF,

commit 99edb3d10a9d384d69557bd09cc39b9ec62aa04e
Author: Jovi Zhang <bookjovi@gmail.com>
Date:   Wed Mar 30 05:30:41 2011 -0400

    tty: remove invalid location line in file header
    
    remove invalid location line in each file header after location
    moved from driver/char to driver/tty
    
    Signed-off-by: Jovi Zhang <bookjovi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
index d89aa38c5cf0..1b37626e8f13 100644
--- a/drivers/tty/serial/21285.c
+++ b/drivers/tty/serial/21285.c
@@ -1,6 +1,4 @@
 /*
- * linux/drivers/serial/21285.c
- *
  * Driver for the serial port on the 21285 StrongArm-110 core logic chip.
  *
  * Based on drivers/char/serial.c

commit ab4382d27412e7e3e7c936e8d50d8888dfac3df8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 13 12:10:18 2011 -0800

    tty: move drivers/serial/ to drivers/tty/serial/
    
    The serial drivers are really just tty drivers, so move them to
    drivers/tty/ to make things a bit neater overall.
    
    This is part of the tty/serial driver movement proceedure as proposed by
    Arnd Bergmann and approved by everyone involved a number of months ago.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Rogier Wolff <R.E.Wolff@bitwizard.nl>
    Cc: Michael H. Warfield <mhw@wittsend.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
new file mode 100644
index 000000000000..d89aa38c5cf0
--- /dev/null
+++ b/drivers/tty/serial/21285.c
@@ -0,0 +1,513 @@
+/*
+ * linux/drivers/serial/21285.c
+ *
+ * Driver for the serial port on the 21285 StrongArm-110 core logic chip.
+ *
+ * Based on drivers/char/serial.c
+ */
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/dec21285.h>
+#include <mach/hardware.h>
+
+#define BAUD_BASE		(mem_fclk_21285/64)
+
+#define SERIAL_21285_NAME	"ttyFB"
+#define SERIAL_21285_MAJOR	204
+#define SERIAL_21285_MINOR	4
+
+#define RXSTAT_DUMMY_READ	0x80000000
+#define RXSTAT_FRAME		(1 << 0)
+#define RXSTAT_PARITY		(1 << 1)
+#define RXSTAT_OVERRUN		(1 << 2)
+#define RXSTAT_ANYERR		(RXSTAT_FRAME|RXSTAT_PARITY|RXSTAT_OVERRUN)
+
+#define H_UBRLCR_BREAK		(1 << 0)
+#define H_UBRLCR_PARENB		(1 << 1)
+#define H_UBRLCR_PAREVN		(1 << 2)
+#define H_UBRLCR_STOPB		(1 << 3)
+#define H_UBRLCR_FIFO		(1 << 4)
+
+static const char serial21285_name[] = "Footbridge UART";
+
+#define tx_enabled(port)	((port)->unused[0])
+#define rx_enabled(port)	((port)->unused[1])
+
+/*
+ * The documented expression for selecting the divisor is:
+ *  BAUD_BASE / baud - 1
+ * However, typically BAUD_BASE is not divisible by baud, so
+ * we want to select the divisor that gives us the minimum
+ * error.  Therefore, we want:
+ *  int(BAUD_BASE / baud - 0.5) ->
+ *  int(BAUD_BASE / baud - (baud >> 1) / baud) ->
+ *  int((BAUD_BASE - (baud >> 1)) / baud)
+ */
+
+static void serial21285_stop_tx(struct uart_port *port)
+{
+	if (tx_enabled(port)) {
+		disable_irq_nosync(IRQ_CONTX);
+		tx_enabled(port) = 0;
+	}
+}
+
+static void serial21285_start_tx(struct uart_port *port)
+{
+	if (!tx_enabled(port)) {
+		enable_irq(IRQ_CONTX);
+		tx_enabled(port) = 1;
+	}
+}
+
+static void serial21285_stop_rx(struct uart_port *port)
+{
+	if (rx_enabled(port)) {
+		disable_irq_nosync(IRQ_CONRX);
+		rx_enabled(port) = 0;
+	}
+}
+
+static void serial21285_enable_ms(struct uart_port *port)
+{
+}
+
+static irqreturn_t serial21285_rx_chars(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned int status, ch, flag, rxs, max_count = 256;
+
+	status = *CSR_UARTFLG;
+	while (!(status & 0x10) && max_count--) {
+		ch = *CSR_UARTDR;
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		rxs = *CSR_RXSTAT | RXSTAT_DUMMY_READ;
+		if (unlikely(rxs & RXSTAT_ANYERR)) {
+			if (rxs & RXSTAT_PARITY)
+				port->icount.parity++;
+			else if (rxs & RXSTAT_FRAME)
+				port->icount.frame++;
+			if (rxs & RXSTAT_OVERRUN)
+				port->icount.overrun++;
+
+			rxs &= port->read_status_mask;
+
+			if (rxs & RXSTAT_PARITY)
+				flag = TTY_PARITY;
+			else if (rxs & RXSTAT_FRAME)
+				flag = TTY_FRAME;
+		}
+
+		uart_insert_char(port, rxs, RXSTAT_OVERRUN, ch, flag);
+
+		status = *CSR_UARTFLG;
+	}
+	tty_flip_buffer_push(tty);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t serial21285_tx_chars(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	struct circ_buf *xmit = &port->state->xmit;
+	int count = 256;
+
+	if (port->x_char) {
+		*CSR_UARTDR = port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+		goto out;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		serial21285_stop_tx(port);
+		goto out;
+	}
+
+	do {
+		*CSR_UARTDR = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0 && !(*CSR_UARTFLG & 0x20));
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		serial21285_stop_tx(port);
+
+ out:
+	return IRQ_HANDLED;
+}
+
+static unsigned int serial21285_tx_empty(struct uart_port *port)
+{
+	return (*CSR_UARTFLG & 8) ? 0 : TIOCSER_TEMT;
+}
+
+/* no modem control lines */
+static unsigned int serial21285_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+static void serial21285_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void serial21285_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+	unsigned int h_lcr;
+
+	spin_lock_irqsave(&port->lock, flags);
+	h_lcr = *CSR_H_UBRLCR;
+	if (break_state)
+		h_lcr |= H_UBRLCR_BREAK;
+	else
+		h_lcr &= ~H_UBRLCR_BREAK;
+	*CSR_H_UBRLCR = h_lcr;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int serial21285_startup(struct uart_port *port)
+{
+	int ret;
+
+	tx_enabled(port) = 1;
+	rx_enabled(port) = 1;
+
+	ret = request_irq(IRQ_CONRX, serial21285_rx_chars, 0,
+			  serial21285_name, port);
+	if (ret == 0) {
+		ret = request_irq(IRQ_CONTX, serial21285_tx_chars, 0,
+				  serial21285_name, port);
+		if (ret)
+			free_irq(IRQ_CONRX, port);
+	}
+
+	return ret;
+}
+
+static void serial21285_shutdown(struct uart_port *port)
+{
+	free_irq(IRQ_CONTX, port);
+	free_irq(IRQ_CONRX, port);
+}
+
+static void
+serial21285_set_termios(struct uart_port *port, struct ktermios *termios,
+			struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int baud, quot, h_lcr, b;
+
+	/*
+	 * We don't support modem control lines.
+	 */
+	termios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	/*
+	 * We don't support BREAK character recognition.
+	 */
+	termios->c_iflag &= ~(IGNBRK | BRKINT);
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = uart_get_divisor(port, baud);
+	b = port->uartclk / (16 * quot);
+	tty_termios_encode_baud_rate(termios, b, b);
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		h_lcr = 0x00;
+		break;
+	case CS6:
+		h_lcr = 0x20;
+		break;
+	case CS7:
+		h_lcr = 0x40;
+		break;
+	default: /* CS8 */
+		h_lcr = 0x60;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		h_lcr |= H_UBRLCR_STOPB;
+	if (termios->c_cflag & PARENB) {
+		h_lcr |= H_UBRLCR_PARENB;
+		if (!(termios->c_cflag & PARODD))
+			h_lcr |= H_UBRLCR_PAREVN;
+	}
+
+	if (port->fifosize)
+		h_lcr |= H_UBRLCR_FIFO;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * Which character status flags are we interested in?
+	 */
+	port->read_status_mask = RXSTAT_OVERRUN;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;
+
+	/*
+	 * Which character status flags should we ignore?
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;
+	if (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= RXSTAT_OVERRUN;
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= RXSTAT_DUMMY_READ;
+
+	quot -= 1;
+
+	*CSR_UARTCON = 0;
+	*CSR_L_UBRLCR = quot & 0xff;
+	*CSR_M_UBRLCR = (quot >> 8) & 0x0f;
+	*CSR_H_UBRLCR = h_lcr;
+	*CSR_UARTCON = 1;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *serial21285_type(struct uart_port *port)
+{
+	return port->type == PORT_21285 ? "DC21285" : NULL;
+}
+
+static void serial21285_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, 32);
+}
+
+static int serial21285_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, 32, serial21285_name)
+			 != NULL ? 0 : -EBUSY;
+}
+
+static void serial21285_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE && serial21285_request_port(port) == 0)
+		port->type = PORT_21285;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int serial21285_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_21285)
+		ret = -EINVAL;
+	if (ser->irq != NO_IRQ)
+		ret = -EINVAL;
+	if (ser->baud_base != port->uartclk / 16)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops serial21285_ops = {
+	.tx_empty	= serial21285_tx_empty,
+	.get_mctrl	= serial21285_get_mctrl,
+	.set_mctrl	= serial21285_set_mctrl,
+	.stop_tx	= serial21285_stop_tx,
+	.start_tx	= serial21285_start_tx,
+	.stop_rx	= serial21285_stop_rx,
+	.enable_ms	= serial21285_enable_ms,
+	.break_ctl	= serial21285_break_ctl,
+	.startup	= serial21285_startup,
+	.shutdown	= serial21285_shutdown,
+	.set_termios	= serial21285_set_termios,
+	.type		= serial21285_type,
+	.release_port	= serial21285_release_port,
+	.request_port	= serial21285_request_port,
+	.config_port	= serial21285_config_port,
+	.verify_port	= serial21285_verify_port,
+};
+
+static struct uart_port serial21285_port = {
+	.mapbase	= 0x42000160,
+	.iotype		= UPIO_MEM,
+	.irq		= NO_IRQ,
+	.fifosize	= 16,
+	.ops		= &serial21285_ops,
+	.flags		= UPF_BOOT_AUTOCONF,
+};
+
+static void serial21285_setup_ports(void)
+{
+	serial21285_port.uartclk = mem_fclk_21285 / 4;
+}
+
+#ifdef CONFIG_SERIAL_21285_CONSOLE
+static void serial21285_console_putchar(struct uart_port *port, int ch)
+{
+	while (*CSR_UARTFLG & 0x20)
+		barrier();
+	*CSR_UARTDR = ch;
+}
+
+static void
+serial21285_console_write(struct console *co, const char *s,
+			  unsigned int count)
+{
+	uart_console_write(&serial21285_port, s, count, serial21285_console_putchar);
+}
+
+static void __init
+serial21285_get_options(struct uart_port *port, int *baud,
+			int *parity, int *bits)
+{
+	if (*CSR_UARTCON == 1) {
+		unsigned int tmp;
+
+		tmp = *CSR_H_UBRLCR;
+		switch (tmp & 0x60) {
+		case 0x00:
+			*bits = 5;
+			break;
+		case 0x20:
+			*bits = 6;
+			break;
+		case 0x40:
+			*bits = 7;
+			break;
+		default:
+		case 0x60:
+			*bits = 8;
+			break;
+		}
+
+		if (tmp & H_UBRLCR_PARENB) {
+			*parity = 'o';
+			if (tmp & H_UBRLCR_PAREVN)
+				*parity = 'e';
+		}
+
+		tmp = *CSR_L_UBRLCR | (*CSR_M_UBRLCR << 8);
+
+		*baud = port->uartclk / (16 * (tmp + 1));
+	}
+}
+
+static int __init serial21285_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = &serial21285_port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (machine_is_personal_server())
+		baud = 57600;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		serial21285_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver serial21285_reg;
+
+static struct console serial21285_console =
+{
+	.name		= SERIAL_21285_NAME,
+	.write		= serial21285_console_write,
+	.device		= uart_console_device,
+	.setup		= serial21285_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial21285_reg,
+};
+
+static int __init rs285_console_init(void)
+{
+	serial21285_setup_ports();
+	register_console(&serial21285_console);
+	return 0;
+}
+console_initcall(rs285_console_init);
+
+#define SERIAL_21285_CONSOLE	&serial21285_console
+#else
+#define SERIAL_21285_CONSOLE	NULL
+#endif
+
+static struct uart_driver serial21285_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "ttyFB",
+	.dev_name		= "ttyFB",
+	.major			= SERIAL_21285_MAJOR,
+	.minor			= SERIAL_21285_MINOR,
+	.nr			= 1,
+	.cons			= SERIAL_21285_CONSOLE,
+};
+
+static int __init serial21285_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: 21285 driver\n");
+
+	serial21285_setup_ports();
+
+	ret = uart_register_driver(&serial21285_reg);
+	if (ret == 0)
+		uart_add_one_port(&serial21285_reg, &serial21285_port);
+
+	return ret;
+}
+
+static void __exit serial21285_exit(void)
+{
+	uart_remove_one_port(&serial21285_reg, &serial21285_port);
+	uart_unregister_driver(&serial21285_reg);
+}
+
+module_init(serial21285_init);
+module_exit(serial21285_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel Footbridge (21285) serial driver");
+MODULE_ALIAS_CHARDEV(SERIAL_21285_MAJOR, SERIAL_21285_MINOR);
