commit cd8d71900f99c90ffd3bce65780dec5ff2b9534f
Author: Dmitry Safonov <dima@arista.com>
Date:   Fri Dec 13 00:06:45 2019 +0000

    tty/serial: Migrate sunsab to use has_sysrq
    
    The SUPPORT_SYSRQ ifdeffery is not nice as:
    - May create misunderstanding about sizeof(struct uart_port) between
      different objects
    - Prevents moving functions from serial_core.h
    - Reduces readability (well, it's ifdeffery - it's hard to follow)
    
    In order to remove SUPPORT_SYSRQ, has_sysrq variable has been added.
    Initialise it in driver's probe and remove ifdeffery.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20191213000657.931618-47-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 72131b5e132e..1eb703c980e0 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -40,10 +40,6 @@
 #include <asm/prom.h>
 #include <asm/setup.h>
 
-#if defined(CONFIG_SERIAL_SUNSAB_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-#define SUPPORT_SYSRQ
-#endif
-
 #include <linux/serial_core.h>
 #include <linux/sunserialcore.h>
 
@@ -985,6 +981,7 @@ static int sunsab_init_one(struct uart_sunsab_port *up,
 
 	up->port.fifosize = SAB82532_XMIT_FIFO_SIZE;
 	up->port.iotype = UPIO_MEM;
+	up->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SUNSAB_CONSOLE);
 
 	writeb(SAB82532_IPC_IC_ACT_LOW, &up->regs->w.ipc);
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b93d0225f8c9..72131b5e132e 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1125,8 +1125,9 @@ static int __init sunsab_init(void)
 	}
 
 	if (num_channels) {
-		sunsab_ports = kzalloc(sizeof(struct uart_sunsab_port) *
-				       num_channels, GFP_KERNEL);
+		sunsab_ports = kcalloc(num_channels,
+				       sizeof(struct uart_sunsab_port),
+				       GFP_KERNEL);
 		if (!sunsab_ports)
 			return -ENOMEM;
 

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 653a076d89d3..b93d0225f8c9 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* sunsab.c: ASYNC Driver for the SIEMENS SAB82532 DUSCC.
  *
  * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)

commit 1a607d31b264b930b986bc24958b4a840167f346
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Aug 13 08:21:42 2017 +0200

    serial: sunsab: constify uart_ops structures
    
    These uart_ops structures are only stored in the ops field of a
    uart_port structure and this fields is const, so the uart_ops
    structures can also be const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b5e3195b3697..653a076d89d3 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -819,7 +819,7 @@ static int sunsab_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return -EINVAL;
 }
 
-static struct uart_ops sunsab_pops = {
+static const struct uart_ops sunsab_pops = {
 	.tx_empty	= sunsab_tx_empty,
 	.set_mctrl	= sunsab_set_mctrl,
 	.get_mctrl	= sunsab_get_mctrl,

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 726657653ff1400bd144b6f293b907d2a1fc9865
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sun Oct 5 19:01:10 2014 +0200

    serial: sunsab: use container_of to resolve uart_sunsu_port from uart_port
    
    Use container_of instead of casting first structure member.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b339fe4811cd..e3b43a449d46 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -345,7 +345,8 @@ static irqreturn_t sunsab_interrupt(int irq, void *dev_id)
 /* port->lock is not held.  */
 static unsigned int sunsab_tx_empty(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	int ret;
 
 	/* Do not need a lock for a state test like this.  */
@@ -360,7 +361,8 @@ static unsigned int sunsab_tx_empty(struct uart_port *port)
 /* port->lock held by caller.  */
 static void sunsab_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 
 	if (mctrl & TIOCM_RTS) {
 		up->cached_mode &= ~SAB82532_MODE_FRTS;
@@ -383,7 +385,8 @@ static void sunsab_set_mctrl(struct uart_port *port, unsigned int mctrl)
 /* port->lock is held by caller and interrupts are disabled.  */
 static unsigned int sunsab_get_mctrl(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned char val;
 	unsigned int result;
 
@@ -404,7 +407,8 @@ static unsigned int sunsab_get_mctrl(struct uart_port *port)
 /* port->lock held by caller.  */
 static void sunsab_stop_tx(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 
 	up->interrupt_mask1 |= SAB82532_IMR1_XPR;
 	writeb(up->interrupt_mask1, &up->regs->w.imr1);
@@ -432,7 +436,8 @@ static void sunsab_tx_idle(struct uart_sunsab_port *up)
 /* port->lock held by caller.  */
 static void sunsab_start_tx(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	struct circ_buf *xmit = &up->port.state->xmit;
 	int i;
 
@@ -465,7 +470,8 @@ static void sunsab_start_tx(struct uart_port *port)
 /* port->lock is not held.  */
 static void sunsab_send_xchar(struct uart_port *port, char ch)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned long flags;
 
 	if (ch == __DISABLED_CHAR)
@@ -482,7 +488,8 @@ static void sunsab_send_xchar(struct uart_port *port, char ch)
 /* port->lock held by caller.  */
 static void sunsab_stop_rx(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 
 	up->interrupt_mask0 |= SAB82532_IMR0_TCD;
 	writeb(up->interrupt_mask1, &up->regs->w.imr0);
@@ -491,7 +498,8 @@ static void sunsab_stop_rx(struct uart_port *port)
 /* port->lock is not held.  */
 static void sunsab_break_ctl(struct uart_port *port, int break_state)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned long flags;
 	unsigned char val;
 
@@ -514,7 +522,8 @@ static void sunsab_break_ctl(struct uart_port *port, int break_state)
 /* port->lock is not held.  */
 static int sunsab_startup(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned long flags;
 	unsigned char tmp;
 	int err = request_irq(up->port.irq, sunsab_interrupt,
@@ -585,7 +594,8 @@ static int sunsab_startup(struct uart_port *port)
 /* port->lock is not held.  */
 static void sunsab_shutdown(struct uart_port *port)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&up->port.lock, flags);
@@ -771,7 +781,8 @@ static void sunsab_convert_to_sab(struct uart_sunsab_port *up, unsigned int cfla
 static void sunsab_set_termios(struct uart_port *port, struct ktermios *termios,
 			       struct ktermios *old)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 	unsigned long flags;
 	unsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
 	unsigned int quot = uart_get_divisor(port, baud);
@@ -840,7 +851,8 @@ static struct uart_sunsab_port *sunsab_ports;
 
 static void sunsab_console_putchar(struct uart_port *port, int c)
 {
-	struct uart_sunsab_port *up = (struct uart_sunsab_port *)port;
+	struct uart_sunsab_port *up =
+		container_of(port, struct uart_sunsab_port, port);
 
 	sunsab_tec_wait(up);
 	writeb(c, &up->regs->w.tic);

commit 9144b3cded04a05d4b4e18dc9dcfb5b8ada3f2fc
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:45 2014 +0200

    tty: serial: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b339fe4811cd..82a07a4fbf3b 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1092,7 +1092,6 @@ MODULE_DEVICE_TABLE(of, sab_match);
 static struct platform_driver sab_driver = {
 	.driver = {
 		.name = "sab",
-		.owner = THIS_MODULE,
 		.of_match_table = sab_match,
 	},
 	.probe		= sab_probe,

commit 98f8b83d6a504615f52a095acf92a2bdad985ae0
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Sep 2 17:39:17 2014 -0400

    serial: sunsab: Don't enable tx if tx stopped
    
    The serial core may call the UART driver's start_tx() even if
    tx is stopped; the UART driver must verify tx should be enabled
    before transmitting.
    
    Reported-by: Sam Ravnborg <sam@ravnborg.org>
    cc: David S. Miller <davem@davemloft.net>
    cc: <sparclinux@vger.kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 0af75f8b98a4..b339fe4811cd 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -436,7 +436,7 @@ static void sunsab_start_tx(struct uart_port *port)
 	struct circ_buf *xmit = &up->port.state->xmit;
 	int i;
 
-	if (uart_circ_empty(xmit))
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port))
 		return;
 
 	up->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);

commit db106df32d679db151b48a09543b03ee41cb2580
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Sep 2 17:39:15 2014 -0400

    serial: Fix send_xchar() handlers
    
    START_CHAR() & STOP_CHAR() can be disabled if set to '\0'
    (__DISABLED_CHAR).  UART drivers which define a send_xchar()
    handler must not transmit __DISABLED_CHAR.
    
    Document requirement.
    
    Affected drivers:
    sunsab
    sunhv
    
    cc: David S. Miller <davem@davemloft.net>
    cc: <sparclinux@vger.kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b9598b227a45..0af75f8b98a4 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -468,6 +468,9 @@ static void sunsab_send_xchar(struct uart_port *port, char ch)
 	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
 	unsigned long flags;
 
+	if (ch == __DISABLED_CHAR)
+		return;
+
 	spin_lock_irqsave(&up->port.lock, flags);
 
 	sunsab_tec_wait(up);

commit 049711bf3cc59501ebeae621aa22acd3918ebd79
Merge: ae045e245542 5b6ff9df056b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 6 09:41:23 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next
    
    Pull sparc updates from David Miller:
    
     1) Add sparc RAM output to /proc/iomem, from Bob Picco.
    
     2) Allow seeks on /dev/mdesc, from Khalid Aziz.
    
     3) Cleanup sparc64 I/O accessors, from Sam Ravnborg.
    
     4) If update_mmu_cache{,_pmd}() is called with an not-valid mapping, do
        not insert it into the TLB miss hash tables otherwise we'll
        livelock.  Based upon work by Christopher Alexander Tobias Schulze.
    
     5) Fix BREAK detection in sunsab driver when no actual characters are
        pending, from Christopher Alexander Tobias Schulze.
    
     6) Because we have modules --> openfirmware --> vmalloc ordering of
        virtual memory, the lazy VMAP TLB flusher can cons up an invocation
        of flush_tlb_kernel_range() that covers the openfirmware address
        range.  Unfortunately this will flush out the firmware's locked TLB
        mapping which causes all kinds of trouble.  Just split up the flush
        request if this happens, but in the long term the lazy VMAP flusher
        should probably be made a little bit smarter.
    
        Based upon work by Christopher Alexander Tobias Schulze.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next:
      sparc64: Fix up merge thinko.
      sparc: Add "install" target
      arch/sparc/math-emu/math_32.c: drop stray break operator
      sparc64: ldc_connect() should not return EINVAL when handshake is in progress.
      sparc64: Guard against flushing openfirmware mappings.
      sunsab: Fix detection of BREAK on sunsab serial console
      bbc-i2c: Fix BBC I2C envctrl on SunBlade 2000
      sparc64: Do not insert non-valid PTEs into the TSB hash table.
      sparc64: avoid code duplication in io_64.h
      sparc64: reorder functions in io_64.h
      sparc64: drop unused SLOW_DOWN_IO definitions
      sparc64: remove macro indirection in io_64.h
      sparc64: update IO access functions in PeeCeeI
      sparcspkr: use sbus_*() primitives for IO
      sparc: Add support for seek and shorter read to /dev/mdesc
      sparc: use %s for unaligned panic
      drivers/sbus/char: Micro-optimization in display7seg.c
      display7seg: Introduce the use of the managed version of kzalloc
      sparc64 - add mem to iomem resource

commit fe418231b195c205701c0cc550a03f6c9758fd9e
Author: Christopher Alexander Tobias Schulze <cat.schulze@alice-dsl.net>
Date:   Sun Aug 3 16:01:53 2014 +0200

    sunsab: Fix detection of BREAK on sunsab serial console
    
    Fix detection of BREAK on sunsab serial console: BREAK detection was only
    performed when there were also serial characters received simultaneously.
    To handle all BREAKs correctly, the check for BREAK and the corresponding
    call to uart_handle_break() must also be done if count == 0, therefore
    duplicate this code fragment and pull it out of the loop over the received
    characters.
    
    Patch applies to 3.16-rc6.
    
    Signed-off-by: Christopher Alexander Tobias Schulze <cat.schulze@alice-dsl.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 2f57df9a71d9..a1e09c0d46f2 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -157,6 +157,15 @@ receive_chars(struct uart_sunsab_port *up,
 	    (up->port.line == up->port.cons->index))
 		saw_console_brk = 1;
 
+	if (count == 0) {
+		if (unlikely(stat->sreg.isr1 & SAB82532_ISR1_BRK)) {
+			stat->sreg.isr0 &= ~(SAB82532_ISR0_PERR |
+					     SAB82532_ISR0_FERR);
+			up->port.icount.brk++;
+			uart_handle_break(&up->port);
+		}
+	}
+
 	for (i = 0; i < count; i++) {
 		unsigned char ch = buf[i], flag;
 

commit ca17749259d26f7ddbb0678790d5d534018d0a6b
Merge: 07584d4a356e 1795cd9b3a91
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jul 13 15:52:12 2014 -0700

    Merge 3.16-rc5 into tty-next.
    
    We want those fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c557d392fbf5badd693ea1946a4317c87a26a716
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jul 6 11:29:52 2014 -0400

    serial: Test for no tx data on tx restart
    
    Commit 717f3bbab3c7628736ef738fdbf3d9a28578c26c,
    'serial_core: Fix conditional start_tx on ring buffer not empty'
    exposes an incorrect assumption in several drivers' start_tx methods;
    the tx ring buffer can, in fact, be empty when restarting tx while
    performing flow control.
    
    Affected drivers:
    sunsab.c
    ip22zilog.c
    pmac_zilog.c
    sunzilog.c
    m32r_sio.c
    imx.c
    
    Other in-tree serial drivers either are not affected or already
    test for empty tx ring buffer before transmitting.
    
    Test for empty tx ring buffer in start_tx() method, after transmitting
    x_char (if applicable).
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Seth Bollinger <sethb@digi.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Cc: stable <stable@vger.kernel.org> # 3.15
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 80a58eca785b..2f57df9a71d9 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -427,6 +427,9 @@ static void sunsab_start_tx(struct uart_port *port)
 	struct circ_buf *xmit = &up->port.state->xmit;
 	int i;
 
+	if (uart_circ_empty(xmit))
+		return;
+
 	up->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);
 	writeb(up->interrupt_mask1, &up->regs->w.imr1);
 	

commit 8b152f1096975d012f60387b899d407e4a93b46c
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Tue Jun 3 18:54:44 2014 +0400

    serial: treewide: Remove empty implementations of enable_ms()
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 80a58eca785b..c9751d8b24c1 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -473,12 +473,6 @@ static void sunsab_stop_rx(struct uart_port *port)
 	writeb(up->interrupt_mask1, &up->regs->w.imr0);
 }
 
-/* port->lock held by caller.  */
-static void sunsab_enable_ms(struct uart_port *port)
-{
-	/* For now we always receive these interrupts.  */
-}
-
 /* port->lock is not held.  */
 static void sunsab_break_ctl(struct uart_port *port, int break_state)
 {
@@ -807,7 +801,6 @@ static struct uart_ops sunsab_pops = {
 	.start_tx	= sunsab_start_tx,
 	.send_xchar	= sunsab_send_xchar,
 	.stop_rx	= sunsab_stop_rx,
-	.enable_ms	= sunsab_enable_ms,
 	.break_ctl	= sunsab_break_ctl,
 	.startup	= sunsab_startup,
 	.shutdown	= sunsab_shutdown,

commit ef8b9ddcb45fa3b1e11acd72be2398001e807d14
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Jun 16 08:10:41 2014 -0400

    serial: Fix IGNBRK handling
    
    If IGNBRK is set without either BRKINT or PARMRK set, some uart
    drivers send a 0x00 byte for BREAK without the TTYBREAK flag to the
    line discipline, when it should send either nothing or the TTYBREAK flag
    set. This happens because the read_status_mask masks out the BI
    condition, which uart_insert_char() then interprets as a normal 0x00 byte.
    
    SUS v3 is clear regarding the meaning of IGNBRK; Section 11.2.2, General
    Terminal Interface - Input Modes, states:
      "If IGNBRK is set, a break condition detected on input shall be ignored;
       that is, not put on the input queue and therefore not read by any
       process."
    
    Fix read_status_mask to include the BI bit if IGNBRK is set; the
    lsr status retains the BI bit if a BREAK is recv'd, which is
    subsequently ignored in uart_insert_char() when masked with the
    ignore_status_mask.
    
    Affected drivers:
    8250 - all
    serial_txx9
    mfd
    amba-pl010
    amba-pl011
    atmel_serial
    bfin_uart
    dz
    ip22zilog
    max310x
    mxs-auart
    netx-serial
    pnx8xxx_uart
    pxa
    sb1250-duart
    sccnxp
    serial_ks8695
    sirfsoc_uart
    st-asc
    vr41xx_siu
    zs
    sunzilog
    fsl_lpuart
    sunsab
    ucc_uart
    bcm63xx_uart
    sunsu
    efm32-uart
    pmac_zilog
    mpsc
    msm_serial
    m32r_sio
    
    Unaffected drivers:
    omap-serial
    rp2
    sa1100
    imx
    icom
    
    Annotated for fixes:
    altera_uart
    mcf
    
    Drivers without break detection:
    21285
    xilinx-uartps
    altera_jtaguart
    apbuart
    arc-uart
    clps711x
    max3100
    uartlite
    msm_serial_hs
    nwpserial
    lantiq
    vt8500_serial
    
    Unknown:
    samsung
    mpc52xx_uart
    bfin_sport_uart
    cpm_uart/core
    
    Fixes: Bugzilla #71651, '8250_core.c incorrectly handles IGNBRK flag'
    Reported-by: Ivan <athlon_@mail.ru>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 5faa8e905e98..80a58eca785b 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -719,7 +719,7 @@ static void sunsab_convert_to_sab(struct uart_sunsab_port *up, unsigned int cfla
 	if (iflag & INPCK)
 		up->port.read_status_mask |= (SAB82532_ISR0_PERR |
 					      SAB82532_ISR0_FERR);
-	if (iflag & (BRKINT | PARMRK))
+	if (iflag & (IGNBRK | BRKINT | PARMRK))
 		up->port.read_status_mask |= (SAB82532_ISR1_BRK << 8);
 
 	/*

commit e58e241c1788856f69d58821e91e5c988905252d
Author: David Miller <davem@davemloft.net>
Date:   Tue Mar 4 15:28:35 2014 -0500

    sparc: serial: Clean up the locking for -rt
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Tested-by: Allen Pais <allen.pais@oracle.com>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 380fb5355cb2..5faa8e905e98 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -844,20 +844,16 @@ static void sunsab_console_write(struct console *con, const char *s, unsigned n)
 	unsigned long flags;
 	int locked = 1;
 
-	local_irq_save(flags);
-	if (up->port.sysrq) {
-		locked = 0;
-	} else if (oops_in_progress) {
-		locked = spin_trylock(&up->port.lock);
-	} else
-		spin_lock(&up->port.lock);
+	if (up->port.sysrq || oops_in_progress)
+		locked = spin_trylock_irqsave(&up->port.lock, flags);
+	else
+		spin_lock_irqsave(&up->port.lock, flags);
 
 	uart_console_write(&up->port, s, n, sunsab_console_putchar);
 	sunsab_tec_wait(up);
 
 	if (locked)
-		spin_unlock(&up->port.lock);
-	local_irq_restore(flags);
+		spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
 static int sunsab_console_setup(struct console *con, char *options)

commit fc811472c2167cc885b7af422b074cc9224f3a93
Author: Joe Perches <joe@perches.com>
Date:   Tue Oct 8 16:14:21 2013 -0700

    tty: Remove unnecessary semicolons
    
    These aren't necessary after switch and while blocks.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 5d6136b2a04a..380fb5355cb2 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -894,7 +894,7 @@ static int sunsab_console_setup(struct console *con, char *options)
 	case B115200: baud = 115200; break;
 	case B230400: baud = 230400; break;
 	case B460800: baud = 460800; break;
-	};
+	}
 
 	/*
 	 * Temporary fix.

commit 696faedd616e202f5c510cd03dcc8853c11ca6db
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 23 19:39:36 2013 +0900

    serial: use platform_{get,set}_drvdata()
    
    Use the wrapper functions for getting and setting the driver data using
    platform_device instead of using dev_{get,set}_drvdata() with &pdev->dev,
    so we can directly pass a struct platform_device.
    
    Also, unnecessary dev_set_drvdata() is removed, because the driver core
    clears the driver data to NULL after device_release or on probe failure.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index a422c8b55a47..5d6136b2a04a 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1037,7 +1037,7 @@ static int sab_probe(struct platform_device *op)
 	if (err)
 		goto out3;
 
-	dev_set_drvdata(&op->dev, &up[0]);
+	platform_set_drvdata(op, &up[0]);
 
 	inst++;
 
@@ -1059,7 +1059,7 @@ static int sab_probe(struct platform_device *op)
 
 static int sab_remove(struct platform_device *op)
 {
-	struct uart_sunsab_port *up = dev_get_drvdata(&op->dev);
+	struct uart_sunsab_port *up = platform_get_drvdata(op);
 
 	uart_remove_one_port(&sunsab_reg, &up[1].port);
 	uart_remove_one_port(&sunsab_reg, &up[0].port);
@@ -1070,8 +1070,6 @@ static int sab_remove(struct platform_device *op)
 		   up[0].port.membase,
 		   sizeof(union sab82532_async_regs));
 
-	dev_set_drvdata(&op->dev, NULL);
-
 	return 0;
 }
 

commit 7bbe08d6b89fce09ae4e6a7ce62ccd3c279a31ce
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Mar 14 00:30:34 2013 +0100

    TTY: serial, stop accessing potential NULLs
    
    The following commits:
    * 6732c8bb8671acbdac6cdc93dd72ddd581dd5e25 (TTY: switch
      tty_schedule_flip)
    * 2e124b4a390ca85325fae75764bef92f0547fa25 (TTY: switch
      tty_flip_buffer_push)
    * 05c7cd39907184328f48d3e7899f9cdd653ad336 (TTY: switch
      tty_insert_flip_string)
    * 92a19f9cec9a80ad93c06e115822deb729e2c6ad (TTY: switch
      tty_insert_flip_char)
    * 227434f8986c3827a1faedd1feb437acd6285315 (TTY: switch
      tty_buffer_request_room to tty_port)
    
    introduced a potential NULL dereference to some drivers. In
    particular, when the device is used as a console, incoming bytes can
    kill the box. This is caused by removed checks for TTY against NULL.
    
    It happened because it was unclear to me why the checks were there. I
    assumed them superfluous because the interrupts were unbound or
    otherwise stopped. But this is not the case for consoles for these
    drivers, as was pointed out by David Miller.
    
    Now, this patch re-introduces the checks (at this point we check
    port->state, not the tty proper, as we do not care about tty pointers
    anymore). For both of the drivers, we place the check below the
    handling of break signal so that sysrq can actually work. (One needs
    to issue a break and then sysrq key within the following 5 seconds.)
    
    We do not change sc26xx, sunhv, and sunsu here because they behave the
    same as before.  People having that hardware should fix the driver
    eventually, however. They always could unconditionally dereference tty
    in receive_chars, port->state in uart_handle_dcd_change, and
    up->port.state->port.tty.
    
    There is perhaps more to fix in all those drivers, but they are at
    least in a state they were before.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 8de2213664e0..a422c8b55a47 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -203,7 +203,7 @@ receive_chars(struct uart_sunsab_port *up,
 				flag = TTY_FRAME;
 		}
 
-		if (uart_handle_sysrq_char(&up->port, ch))
+		if (uart_handle_sysrq_char(&up->port, ch) || !port)
 			continue;
 
 		if ((stat->sreg.isr0 & (up->port.ignore_status_mask & 0xff)) == 0 &&

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 4abc4d43a8e8..8de2213664e0 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -107,22 +107,19 @@ static __inline__ void sunsab_cec_wait(struct uart_sunsab_port *up)
 		udelay(1);
 }
 
-static struct tty_struct *
+static struct tty_port *
 receive_chars(struct uart_sunsab_port *up,
 	      union sab82532_irq_status *stat)
 {
 	struct tty_port *port = NULL;
-	struct tty_struct *tty = NULL;
 	unsigned char buf[32];
 	int saw_console_brk = 0;
 	int free_fifo = 0;
 	int count = 0;
 	int i;
 
-	if (up->port.state != NULL) {		/* Unopened serial console */
+	if (up->port.state != NULL)		/* Unopened serial console */
 		port = &up->port.state->port;
-		tty = port->tty;
-	}
 
 	/* Read number of BYTES (Character + Status) available. */
 	if (stat->sreg.isr0 & SAB82532_ISR0_RPF) {
@@ -139,7 +136,7 @@ receive_chars(struct uart_sunsab_port *up,
 	if (stat->sreg.isr0 & SAB82532_ISR0_TIME) {
 		sunsab_cec_wait(up);
 		writeb(SAB82532_CMDR_RFRD, &up->regs->w.cmdr);
-		return tty;
+		return port;
 	}
 
 	if (stat->sreg.isr0 & SAB82532_ISR0_RFO)
@@ -219,7 +216,7 @@ receive_chars(struct uart_sunsab_port *up,
 	if (saw_console_brk)
 		sun_do_break();
 
-	return tty;
+	return port;
 }
 
 static void sunsab_stop_tx(struct uart_port *);
@@ -302,7 +299,7 @@ static void check_status(struct uart_sunsab_port *up,
 static irqreturn_t sunsab_interrupt(int irq, void *dev_id)
 {
 	struct uart_sunsab_port *up = dev_id;
-	struct tty_struct *tty;
+	struct tty_port *port = NULL;
 	union sab82532_irq_status status;
 	unsigned long flags;
 	unsigned char gis;
@@ -316,12 +313,11 @@ static irqreturn_t sunsab_interrupt(int irq, void *dev_id)
 	if (gis & 2)
 		status.sreg.isr1 = readb(&up->regs->r.isr1);
 
-	tty = NULL;
 	if (status.stat) {
 		if ((status.sreg.isr0 & (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |
 					 SAB82532_ISR0_RFO | SAB82532_ISR0_RPF)) ||
 		    (status.sreg.isr1 & SAB82532_ISR1_BRK))
-			tty = receive_chars(up, &status);
+			port = receive_chars(up, &status);
 		if ((status.sreg.isr0 & SAB82532_ISR0_CDSC) ||
 		    (status.sreg.isr1 & SAB82532_ISR1_CSC))
 			check_status(up, &status);
@@ -331,8 +327,8 @@ static irqreturn_t sunsab_interrupt(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
-	if (tty)
-		tty_flip_buffer_push(tty);
+	if (port)
+		tty_flip_buffer_push(port);
 
 	return IRQ_HANDLED;
 }

commit 92a19f9cec9a80ad93c06e115822deb729e2c6ad
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:03 2013 +0100

    TTY: switch tty_insert_flip_char
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    tty_insert_flip_char is the next one to proceed. This one is used all
    over the code, so the patch is huge.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index bd8b3b634103..4abc4d43a8e8 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -111,6 +111,7 @@ static struct tty_struct *
 receive_chars(struct uart_sunsab_port *up,
 	      union sab82532_irq_status *stat)
 {
+	struct tty_port *port = NULL;
 	struct tty_struct *tty = NULL;
 	unsigned char buf[32];
 	int saw_console_brk = 0;
@@ -118,8 +119,10 @@ receive_chars(struct uart_sunsab_port *up,
 	int count = 0;
 	int i;
 
-	if (up->port.state != NULL)		/* Unopened serial console */
-		tty = up->port.state->port.tty;
+	if (up->port.state != NULL) {		/* Unopened serial console */
+		port = &up->port.state->port;
+		tty = port->tty;
+	}
 
 	/* Read number of BYTES (Character + Status) available. */
 	if (stat->sreg.isr0 & SAB82532_ISR0_RPF) {
@@ -160,11 +163,6 @@ receive_chars(struct uart_sunsab_port *up,
 	for (i = 0; i < count; i++) {
 		unsigned char ch = buf[i], flag;
 
-		if (tty == NULL) {
-			uart_handle_sysrq_char(&up->port, ch);
-			continue;
-		}
-
 		flag = TTY_NORMAL;
 		up->port.icount.rx++;
 
@@ -213,9 +211,9 @@ receive_chars(struct uart_sunsab_port *up,
 
 		if ((stat->sreg.isr0 & (up->port.ignore_status_mask & 0xff)) == 0 &&
 		    (stat->sreg.isr1 & ((up->port.ignore_status_mask >> 8) & 0xff)) == 0)
-			tty_insert_flip_char(tty, ch, flag);
+			tty_insert_flip_char(port, ch, flag);
 		if (stat->sreg.isr0 & SAB82532_ISR0_RFO)
-			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+			tty_insert_flip_char(port, 0, TTY_OVERRUN);
 	}
 
 	if (saw_console_brk)

commit ae8d8a146725a966bd7c59c94f4d0016dcf7a04f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:18 2012 -0500

    tty: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: David Brown <davidb@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 9a13c54d5f8a..bd8b3b634103 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1063,7 +1063,7 @@ static int sab_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit sab_remove(struct platform_device *op)
+static int sab_remove(struct platform_device *op)
 {
 	struct uart_sunsab_port *up = dev_get_drvdata(&op->dev);
 

commit 9671f09921d93e722a28ae9610d478e092ac5466
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:50 2012 -0500

    tty: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index bbb07bc74f6c..9a13c54d5f8a 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -954,7 +954,7 @@ static inline struct console *SUNSAB_CONSOLE(void)
 #define sunsab_console_init()	do { } while (0)
 #endif
 
-static int __devinit sunsab_init_one(struct uart_sunsab_port *up,
+static int sunsab_init_one(struct uart_sunsab_port *up,
 				     struct platform_device *op,
 				     unsigned long offset,
 				     int line)
@@ -1007,7 +1007,7 @@ static int __devinit sunsab_init_one(struct uart_sunsab_port *up,
 	return 0;
 }
 
-static int __devinit sab_probe(struct platform_device *op)
+static int sab_probe(struct platform_device *op)
 {
 	static int inst;
 	struct uart_sunsab_port *up;

commit 2d47b7160243b1422006b91debf438484a4fde58
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:34 2012 -0500

    tty: serial: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index f0d93eb7e6ec..bbb07bc74f6c 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1100,7 +1100,7 @@ static struct platform_driver sab_driver = {
 		.of_match_table = sab_match,
 	},
 	.probe		= sab_probe,
-	.remove		= __devexit_p(sab_remove),
+	.remove		= sab_remove,
 };
 
 static int __init sunsab_init(void)

commit d550bbd40c0e10aefa05103dadbe0ae42e683707
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Disintegrate asm/system.h for Sparc
    
    Disintegrate asm/system.h for Sparc.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: sparclinux@vger.kernel.org

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 62dacd0ba526..f0d93eb7e6ec 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -37,6 +37,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/prom.h>
+#include <asm/setup.h>
 
 #if defined(CONFIG_SERIAL_SUNSAB_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ

commit 6816383a09b5be8d35f14f4c25dedb64498e4959
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Feb 9 18:48:19 2012 -0500

    tty: sparc: rename drivers/tty/serial/suncore.h -> include/linux/sunserialcore.h
    
    There are multiple users of this file from different source
    paths now, and rather than have ../ paths in include statements,
    just move the file to the linux header dir.
    
    Suggested-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index b5fa2a57b9da..62dacd0ba526 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -43,8 +43,8 @@
 #endif
 
 #include <linux/serial_core.h>
+#include <linux/sunserialcore.h>
 
-#include "suncore.h"
 #include "sunsab.h"
 
 struct uart_sunsab_port {

commit 793218dfea146946a076f4fe51e574db61034a3e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 21:10:26 2011 -0700

    dt/serial: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of users of of_platform_driver in drivers/serial.  The
    of_platform_{,un}register_driver functions are going away, so the
    users need to be converted to using the platform_bus_type directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index 5b246b18f42f..b5fa2a57b9da 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1006,7 +1006,7 @@ static int __devinit sunsab_init_one(struct uart_sunsab_port *up,
 	return 0;
 }
 
-static int __devinit sab_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit sab_probe(struct platform_device *op)
 {
 	static int inst;
 	struct uart_sunsab_port *up;
@@ -1092,7 +1092,7 @@ static const struct of_device_id sab_match[] = {
 };
 MODULE_DEVICE_TABLE(of, sab_match);
 
-static struct of_platform_driver sab_driver = {
+static struct platform_driver sab_driver = {
 	.driver = {
 		.name = "sab",
 		.owner = THIS_MODULE,
@@ -1130,12 +1130,12 @@ static int __init sunsab_init(void)
 		}
 	}
 
-	return of_register_platform_driver(&sab_driver);
+	return platform_driver_register(&sab_driver);
 }
 
 static void __exit sunsab_exit(void)
 {
-	of_unregister_platform_driver(&sab_driver);
+	platform_driver_unregister(&sab_driver);
 	if (sunsab_reg.nr) {
 		sunserial_unregister_minors(&sunsab_reg, sunsab_reg.nr);
 	}

commit ab4382d27412e7e3e7c936e8d50d8888dfac3df8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 13 12:10:18 2011 -0800

    tty: move drivers/serial/ to drivers/tty/serial/
    
    The serial drivers are really just tty drivers, so move them to
    drivers/tty/ to make things a bit neater overall.
    
    This is part of the tty/serial driver movement proceedure as proposed by
    Arnd Bergmann and approved by everyone involved a number of months ago.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Rogier Wolff <R.E.Wolff@bitwizard.nl>
    Cc: Michael H. Warfield <mhw@wittsend.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
new file mode 100644
index 000000000000..5b246b18f42f
--- /dev/null
+++ b/drivers/tty/serial/sunsab.c
@@ -0,0 +1,1152 @@
+/* sunsab.c: ASYNC Driver for the SIEMENS SAB82532 DUSCC.
+ *
+ * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
+ * Copyright (C) 2002, 2006  David S. Miller (davem@davemloft.net)
+ *
+ * Rewrote buffer handling to use CIRC(Circular Buffer) macros.
+ *   Maxim Krasnyanskiy <maxk@qualcomm.com>
+ *
+ * Fixed to use tty_get_baud_rate, and to allow for arbitrary baud
+ * rates to be programmed into the UART.  Also eliminated a lot of
+ * duplicated code in the console setup.
+ *   Theodore Ts'o <tytso@mit.edu>, 2001-Oct-12
+ *
+ * Ported to new 2.5.x UART layer.
+ *   David S. Miller <davem@davemloft.net>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/prom.h>
+
+#if defined(CONFIG_SERIAL_SUNSAB_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+
+#include "suncore.h"
+#include "sunsab.h"
+
+struct uart_sunsab_port {
+	struct uart_port		port;		/* Generic UART port	*/
+	union sab82532_async_regs	__iomem *regs;	/* Chip registers	*/
+	unsigned long			irqflags;	/* IRQ state flags	*/
+	int				dsr;		/* Current DSR state	*/
+	unsigned int			cec_timeout;	/* Chip poll timeout... */
+	unsigned int			tec_timeout;	/* likewise		*/
+	unsigned char			interrupt_mask0;/* ISR0 masking		*/
+	unsigned char			interrupt_mask1;/* ISR1 masking		*/
+	unsigned char			pvr_dtr_bit;	/* Which PVR bit is DTR */
+	unsigned char			pvr_dsr_bit;	/* Which PVR bit is DSR */
+	unsigned int			gis_shift;
+	int				type;		/* SAB82532 version	*/
+
+	/* Setting configuration bits while the transmitter is active
+	 * can cause garbage characters to get emitted by the chip.
+	 * Therefore, we cache such writes here and do the real register
+	 * write the next time the transmitter becomes idle.
+	 */
+	unsigned int			cached_ebrg;
+	unsigned char			cached_mode;
+	unsigned char			cached_pvr;
+	unsigned char			cached_dafo;
+};
+
+/*
+ * This assumes you have a 29.4912 MHz clock for your UART.
+ */
+#define SAB_BASE_BAUD ( 29491200 / 16 )
+
+static char *sab82532_version[16] = {
+	"V1.0", "V2.0", "V3.2", "V(0x03)",
+	"V(0x04)", "V(0x05)", "V(0x06)", "V(0x07)",
+	"V(0x08)", "V(0x09)", "V(0x0a)", "V(0x0b)",
+	"V(0x0c)", "V(0x0d)", "V(0x0e)", "V(0x0f)"
+};
+
+#define SAB82532_MAX_TEC_TIMEOUT 200000	/* 1 character time (at 50 baud) */
+#define SAB82532_MAX_CEC_TIMEOUT  50000	/* 2.5 TX CLKs (at 50 baud) */
+
+#define SAB82532_RECV_FIFO_SIZE	32      /* Standard async fifo sizes */
+#define SAB82532_XMIT_FIFO_SIZE	32
+
+static __inline__ void sunsab_tec_wait(struct uart_sunsab_port *up)
+{
+	int timeout = up->tec_timeout;
+
+	while ((readb(&up->regs->r.star) & SAB82532_STAR_TEC) && --timeout)
+		udelay(1);
+}
+
+static __inline__ void sunsab_cec_wait(struct uart_sunsab_port *up)
+{
+	int timeout = up->cec_timeout;
+
+	while ((readb(&up->regs->r.star) & SAB82532_STAR_CEC) && --timeout)
+		udelay(1);
+}
+
+static struct tty_struct *
+receive_chars(struct uart_sunsab_port *up,
+	      union sab82532_irq_status *stat)
+{
+	struct tty_struct *tty = NULL;
+	unsigned char buf[32];
+	int saw_console_brk = 0;
+	int free_fifo = 0;
+	int count = 0;
+	int i;
+
+	if (up->port.state != NULL)		/* Unopened serial console */
+		tty = up->port.state->port.tty;
+
+	/* Read number of BYTES (Character + Status) available. */
+	if (stat->sreg.isr0 & SAB82532_ISR0_RPF) {
+		count = SAB82532_RECV_FIFO_SIZE;
+		free_fifo++;
+	}
+
+	if (stat->sreg.isr0 & SAB82532_ISR0_TCD) {
+		count = readb(&up->regs->r.rbcl) & (SAB82532_RECV_FIFO_SIZE - 1);
+		free_fifo++;
+	}
+
+	/* Issue a FIFO read command in case we where idle. */
+	if (stat->sreg.isr0 & SAB82532_ISR0_TIME) {
+		sunsab_cec_wait(up);
+		writeb(SAB82532_CMDR_RFRD, &up->regs->w.cmdr);
+		return tty;
+	}
+
+	if (stat->sreg.isr0 & SAB82532_ISR0_RFO)
+		free_fifo++;
+
+	/* Read the FIFO. */
+	for (i = 0; i < count; i++)
+		buf[i] = readb(&up->regs->r.rfifo[i]);
+
+	/* Issue Receive Message Complete command. */
+	if (free_fifo) {
+		sunsab_cec_wait(up);
+		writeb(SAB82532_CMDR_RMC, &up->regs->w.cmdr);
+	}
+
+	/* Count may be zero for BRK, so we check for it here */
+	if ((stat->sreg.isr1 & SAB82532_ISR1_BRK) &&
+	    (up->port.line == up->port.cons->index))
+		saw_console_brk = 1;
+
+	for (i = 0; i < count; i++) {
+		unsigned char ch = buf[i], flag;
+
+		if (tty == NULL) {
+			uart_handle_sysrq_char(&up->port, ch);
+			continue;
+		}
+
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(stat->sreg.isr0 & (SAB82532_ISR0_PERR |
+						SAB82532_ISR0_FERR |
+						SAB82532_ISR0_RFO)) ||
+		    unlikely(stat->sreg.isr1 & SAB82532_ISR1_BRK)) {
+			/*
+			 * For statistics only
+			 */
+			if (stat->sreg.isr1 & SAB82532_ISR1_BRK) {
+				stat->sreg.isr0 &= ~(SAB82532_ISR0_PERR |
+						     SAB82532_ISR0_FERR);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					continue;
+			} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)
+				up->port.icount.parity++;
+			else if (stat->sreg.isr0 & SAB82532_ISR0_FERR)
+				up->port.icount.frame++;
+			if (stat->sreg.isr0 & SAB82532_ISR0_RFO)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ingored.
+			 */
+			stat->sreg.isr0 &= (up->port.read_status_mask & 0xff);
+			stat->sreg.isr1 &= ((up->port.read_status_mask >> 8) & 0xff);
+
+			if (stat->sreg.isr1 & SAB82532_ISR1_BRK) {
+				flag = TTY_BREAK;
+			} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)
+				flag = TTY_PARITY;
+			else if (stat->sreg.isr0 & SAB82532_ISR0_FERR)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		if ((stat->sreg.isr0 & (up->port.ignore_status_mask & 0xff)) == 0 &&
+		    (stat->sreg.isr1 & ((up->port.ignore_status_mask >> 8) & 0xff)) == 0)
+			tty_insert_flip_char(tty, ch, flag);
+		if (stat->sreg.isr0 & SAB82532_ISR0_RFO)
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+	}
+
+	if (saw_console_brk)
+		sun_do_break();
+
+	return tty;
+}
+
+static void sunsab_stop_tx(struct uart_port *);
+static void sunsab_tx_idle(struct uart_sunsab_port *);
+
+static void transmit_chars(struct uart_sunsab_port *up,
+			   union sab82532_irq_status *stat)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int i;
+
+	if (stat->sreg.isr1 & SAB82532_ISR1_ALLS) {
+		up->interrupt_mask1 |= SAB82532_IMR1_ALLS;
+		writeb(up->interrupt_mask1, &up->regs->w.imr1);
+		set_bit(SAB82532_ALLS, &up->irqflags);
+	}
+
+#if 0 /* bde@nwlink.com says this check causes problems */
+	if (!(stat->sreg.isr1 & SAB82532_ISR1_XPR))
+		return;
+#endif
+
+	if (!(readb(&up->regs->r.star) & SAB82532_STAR_XFW))
+		return;
+
+	set_bit(SAB82532_XPR, &up->irqflags);
+	sunsab_tx_idle(up);
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		up->interrupt_mask1 |= SAB82532_IMR1_XPR;
+		writeb(up->interrupt_mask1, &up->regs->w.imr1);
+		return;
+	}
+
+	up->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+	clear_bit(SAB82532_ALLS, &up->irqflags);
+
+	/* Stuff 32 bytes into Transmit FIFO. */
+	clear_bit(SAB82532_XPR, &up->irqflags);
+	for (i = 0; i < up->port.fifosize; i++) {
+		writeb(xmit->buf[xmit->tail],
+		       &up->regs->w.xfifo[i]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	/* Issue a Transmit Frame command. */
+	sunsab_cec_wait(up);
+	writeb(SAB82532_CMDR_XF, &up->regs->w.cmdr);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		sunsab_stop_tx(&up->port);
+}
+
+static void check_status(struct uart_sunsab_port *up,
+			 union sab82532_irq_status *stat)
+{
+	if (stat->sreg.isr0 & SAB82532_ISR0_CDSC)
+		uart_handle_dcd_change(&up->port,
+				       !(readb(&up->regs->r.vstr) & SAB82532_VSTR_CD));
+
+	if (stat->sreg.isr1 & SAB82532_ISR1_CSC)
+		uart_handle_cts_change(&up->port,
+				       (readb(&up->regs->r.star) & SAB82532_STAR_CTS));
+
+	if ((readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ^ up->dsr) {
+		up->dsr = (readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ? 0 : 1;
+		up->port.icount.dsr++;
+	}
+
+	wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+}
+
+static irqreturn_t sunsab_interrupt(int irq, void *dev_id)
+{
+	struct uart_sunsab_port *up = dev_id;
+	struct tty_struct *tty;
+	union sab82532_irq_status status;
+	unsigned long flags;
+	unsigned char gis;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	status.stat = 0;
+	gis = readb(&up->regs->r.gis) >> up->gis_shift;
+	if (gis & 1)
+		status.sreg.isr0 = readb(&up->regs->r.isr0);
+	if (gis & 2)
+		status.sreg.isr1 = readb(&up->regs->r.isr1);
+
+	tty = NULL;
+	if (status.stat) {
+		if ((status.sreg.isr0 & (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |
+					 SAB82532_ISR0_RFO | SAB82532_ISR0_RPF)) ||
+		    (status.sreg.isr1 & SAB82532_ISR1_BRK))
+			tty = receive_chars(up, &status);
+		if ((status.sreg.isr0 & SAB82532_ISR0_CDSC) ||
+		    (status.sreg.isr1 & SAB82532_ISR1_CSC))
+			check_status(up, &status);
+		if (status.sreg.isr1 & (SAB82532_ISR1_ALLS | SAB82532_ISR1_XPR))
+			transmit_chars(up, &status);
+	}
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	if (tty)
+		tty_flip_buffer_push(tty);
+
+	return IRQ_HANDLED;
+}
+
+/* port->lock is not held.  */
+static unsigned int sunsab_tx_empty(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	int ret;
+
+	/* Do not need a lock for a state test like this.  */
+	if (test_bit(SAB82532_ALLS, &up->irqflags))
+		ret = TIOCSER_TEMT;
+	else
+		ret = 0;
+
+	return ret;
+}
+
+/* port->lock held by caller.  */
+static void sunsab_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+
+	if (mctrl & TIOCM_RTS) {
+		up->cached_mode &= ~SAB82532_MODE_FRTS;
+		up->cached_mode |= SAB82532_MODE_RTS;
+	} else {
+		up->cached_mode |= (SAB82532_MODE_FRTS |
+				    SAB82532_MODE_RTS);
+	}
+	if (mctrl & TIOCM_DTR) {
+		up->cached_pvr &= ~(up->pvr_dtr_bit);
+	} else {
+		up->cached_pvr |= up->pvr_dtr_bit;
+	}
+
+	set_bit(SAB82532_REGS_PENDING, &up->irqflags);
+	if (test_bit(SAB82532_XPR, &up->irqflags))
+		sunsab_tx_idle(up);
+}
+
+/* port->lock is held by caller and interrupts are disabled.  */
+static unsigned int sunsab_get_mctrl(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned char val;
+	unsigned int result;
+
+	result = 0;
+
+	val = readb(&up->regs->r.pvr);
+	result |= (val & up->pvr_dsr_bit) ? 0 : TIOCM_DSR;
+
+	val = readb(&up->regs->r.vstr);
+	result |= (val & SAB82532_VSTR_CD) ? 0 : TIOCM_CAR;
+
+	val = readb(&up->regs->r.star);
+	result |= (val & SAB82532_STAR_CTS) ? TIOCM_CTS : 0;
+
+	return result;
+}
+
+/* port->lock held by caller.  */
+static void sunsab_stop_tx(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+
+	up->interrupt_mask1 |= SAB82532_IMR1_XPR;
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+}
+
+/* port->lock held by caller.  */
+static void sunsab_tx_idle(struct uart_sunsab_port *up)
+{
+	if (test_bit(SAB82532_REGS_PENDING, &up->irqflags)) {
+		u8 tmp;
+
+		clear_bit(SAB82532_REGS_PENDING, &up->irqflags);
+		writeb(up->cached_mode, &up->regs->rw.mode);
+		writeb(up->cached_pvr, &up->regs->rw.pvr);
+		writeb(up->cached_dafo, &up->regs->w.dafo);
+
+		writeb(up->cached_ebrg & 0xff, &up->regs->w.bgr);
+		tmp = readb(&up->regs->rw.ccr2);
+		tmp &= ~0xc0;
+		tmp |= (up->cached_ebrg >> 2) & 0xc0;
+		writeb(tmp, &up->regs->rw.ccr2);
+	}
+}
+
+/* port->lock held by caller.  */
+static void sunsab_start_tx(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int i;
+
+	up->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+	
+	if (!test_bit(SAB82532_XPR, &up->irqflags))
+		return;
+
+	clear_bit(SAB82532_ALLS, &up->irqflags);
+	clear_bit(SAB82532_XPR, &up->irqflags);
+
+	for (i = 0; i < up->port.fifosize; i++) {
+		writeb(xmit->buf[xmit->tail],
+		       &up->regs->w.xfifo[i]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	/* Issue a Transmit Frame command.  */
+	sunsab_cec_wait(up);
+	writeb(SAB82532_CMDR_XF, &up->regs->w.cmdr);
+}
+
+/* port->lock is not held.  */
+static void sunsab_send_xchar(struct uart_port *port, char ch)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	sunsab_tec_wait(up);
+	writeb(ch, &up->regs->w.tic);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+/* port->lock held by caller.  */
+static void sunsab_stop_rx(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+
+	up->interrupt_mask0 |= SAB82532_IMR0_TCD;
+	writeb(up->interrupt_mask1, &up->regs->w.imr0);
+}
+
+/* port->lock held by caller.  */
+static void sunsab_enable_ms(struct uart_port *port)
+{
+	/* For now we always receive these interrupts.  */
+}
+
+/* port->lock is not held.  */
+static void sunsab_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned long flags;
+	unsigned char val;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	val = up->cached_dafo;
+	if (break_state)
+		val |= SAB82532_DAFO_XBRK;
+	else
+		val &= ~SAB82532_DAFO_XBRK;
+	up->cached_dafo = val;
+
+	set_bit(SAB82532_REGS_PENDING, &up->irqflags);
+	if (test_bit(SAB82532_XPR, &up->irqflags))
+		sunsab_tx_idle(up);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+/* port->lock is not held.  */
+static int sunsab_startup(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned long flags;
+	unsigned char tmp;
+	int err = request_irq(up->port.irq, sunsab_interrupt,
+			      IRQF_SHARED, "sab", up);
+	if (err)
+		return err;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Wait for any commands or immediate characters
+	 */
+	sunsab_cec_wait(up);
+	sunsab_tec_wait(up);
+
+	/*
+	 * Clear the FIFO buffers.
+	 */
+	writeb(SAB82532_CMDR_RRES, &up->regs->w.cmdr);
+	sunsab_cec_wait(up);
+	writeb(SAB82532_CMDR_XRES, &up->regs->w.cmdr);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) readb(&up->regs->r.isr0);
+	(void) readb(&up->regs->r.isr1);
+
+	/*
+	 * Now, initialize the UART 
+	 */
+	writeb(0, &up->regs->w.ccr0);				/* power-down */
+	writeb(SAB82532_CCR0_MCE | SAB82532_CCR0_SC_NRZ |
+	       SAB82532_CCR0_SM_ASYNC, &up->regs->w.ccr0);
+	writeb(SAB82532_CCR1_ODS | SAB82532_CCR1_BCR | 7, &up->regs->w.ccr1);
+	writeb(SAB82532_CCR2_BDF | SAB82532_CCR2_SSEL |
+	       SAB82532_CCR2_TOE, &up->regs->w.ccr2);
+	writeb(0, &up->regs->w.ccr3);
+	writeb(SAB82532_CCR4_MCK4 | SAB82532_CCR4_EBRG, &up->regs->w.ccr4);
+	up->cached_mode = (SAB82532_MODE_RTS | SAB82532_MODE_FCTS |
+			   SAB82532_MODE_RAC);
+	writeb(up->cached_mode, &up->regs->w.mode);
+	writeb(SAB82532_RFC_DPS|SAB82532_RFC_RFTH_32, &up->regs->w.rfc);
+	
+	tmp = readb(&up->regs->rw.ccr0);
+	tmp |= SAB82532_CCR0_PU;	/* power-up */
+	writeb(tmp, &up->regs->rw.ccr0);
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	up->interrupt_mask0 = (SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |
+			       SAB82532_IMR0_PLLA);
+	writeb(up->interrupt_mask0, &up->regs->w.imr0);
+	up->interrupt_mask1 = (SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |
+			       SAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |
+			       SAB82532_IMR1_CSC | SAB82532_IMR1_XON |
+			       SAB82532_IMR1_XPR);
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+	set_bit(SAB82532_ALLS, &up->irqflags);
+	set_bit(SAB82532_XPR, &up->irqflags);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return 0;
+}
+
+/* port->lock is not held.  */
+static void sunsab_shutdown(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/* Disable Interrupts */
+	up->interrupt_mask0 = 0xff;
+	writeb(up->interrupt_mask0, &up->regs->w.imr0);
+	up->interrupt_mask1 = 0xff;
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+
+	/* Disable break condition */
+	up->cached_dafo = readb(&up->regs->rw.dafo);
+	up->cached_dafo &= ~SAB82532_DAFO_XBRK;
+	writeb(up->cached_dafo, &up->regs->rw.dafo);
+
+	/* Disable Receiver */	
+	up->cached_mode &= ~SAB82532_MODE_RAC;
+	writeb(up->cached_mode, &up->regs->rw.mode);
+
+	/*
+	 * XXX FIXME
+	 *
+	 * If the chip is powered down here the system hangs/crashes during
+	 * reboot or shutdown.  This needs to be investigated further,
+	 * similar behaviour occurs in 2.4 when the driver is configured
+	 * as a module only.  One hint may be that data is sometimes
+	 * transmitted at 9600 baud during shutdown (regardless of the
+	 * speed the chip was configured for when the port was open).
+	 */
+#if 0
+	/* Power Down */	
+	tmp = readb(&up->regs->rw.ccr0);
+	tmp &= ~SAB82532_CCR0_PU;
+	writeb(tmp, &up->regs->rw.ccr0);
+#endif
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	free_irq(up->port.irq, up);
+}
+
+/*
+ * This is used to figure out the divisor speeds.
+ *
+ * The formula is:    Baud = SAB_BASE_BAUD / ((N + 1) * (1 << M)),
+ *
+ * with               0 <= N < 64 and 0 <= M < 16
+ */
+
+static void calc_ebrg(int baud, int *n_ret, int *m_ret)
+{
+	int	n, m;
+
+	if (baud == 0) {
+		*n_ret = 0;
+		*m_ret = 0;
+		return;
+	}
+     
+	/*
+	 * We scale numbers by 10 so that we get better accuracy
+	 * without having to use floating point.  Here we increment m
+	 * until n is within the valid range.
+	 */
+	n = (SAB_BASE_BAUD * 10) / baud;
+	m = 0;
+	while (n >= 640) {
+		n = n / 2;
+		m++;
+	}
+	n = (n+5) / 10;
+	/*
+	 * We try very hard to avoid speeds with M == 0 since they may
+	 * not work correctly for XTAL frequences above 10 MHz.
+	 */
+	if ((m == 0) && ((n & 1) == 0)) {
+		n = n / 2;
+		m++;
+	}
+	*n_ret = n - 1;
+	*m_ret = m;
+}
+
+/* Internal routine, port->lock is held and local interrupts are disabled.  */
+static void sunsab_convert_to_sab(struct uart_sunsab_port *up, unsigned int cflag,
+				  unsigned int iflag, unsigned int baud,
+				  unsigned int quot)
+{
+	unsigned char dafo;
+	int bits, n, m;
+
+	/* Byte size and parity */
+	switch (cflag & CSIZE) {
+	      case CS5: dafo = SAB82532_DAFO_CHL5; bits = 7; break;
+	      case CS6: dafo = SAB82532_DAFO_CHL6; bits = 8; break;
+	      case CS7: dafo = SAB82532_DAFO_CHL7; bits = 9; break;
+	      case CS8: dafo = SAB82532_DAFO_CHL8; bits = 10; break;
+	      /* Never happens, but GCC is too dumb to figure it out */
+	      default:  dafo = SAB82532_DAFO_CHL5; bits = 7; break;
+	}
+
+	if (cflag & CSTOPB) {
+		dafo |= SAB82532_DAFO_STOP;
+		bits++;
+	}
+
+	if (cflag & PARENB) {
+		dafo |= SAB82532_DAFO_PARE;
+		bits++;
+	}
+
+	if (cflag & PARODD) {
+		dafo |= SAB82532_DAFO_PAR_ODD;
+	} else {
+		dafo |= SAB82532_DAFO_PAR_EVEN;
+	}
+	up->cached_dafo = dafo;
+
+	calc_ebrg(baud, &n, &m);
+
+	up->cached_ebrg = n | (m << 6);
+
+	up->tec_timeout = (10 * 1000000) / baud;
+	up->cec_timeout = up->tec_timeout >> 2;
+
+	/* CTS flow control flags */
+	/* We encode read_status_mask and ignore_status_mask like so:
+	 *
+	 * ---------------------
+	 * | ... | ISR1 | ISR0 |
+	 * ---------------------
+	 *  ..    15   8 7    0
+	 */
+
+	up->port.read_status_mask = (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |
+				     SAB82532_ISR0_RFO | SAB82532_ISR0_RPF |
+				     SAB82532_ISR0_CDSC);
+	up->port.read_status_mask |= (SAB82532_ISR1_CSC |
+				      SAB82532_ISR1_ALLS |
+				      SAB82532_ISR1_XPR) << 8;
+	if (iflag & INPCK)
+		up->port.read_status_mask |= (SAB82532_ISR0_PERR |
+					      SAB82532_ISR0_FERR);
+	if (iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= (SAB82532_ISR1_BRK << 8);
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		up->port.ignore_status_mask |= (SAB82532_ISR0_PERR |
+						SAB82532_ISR0_FERR);
+	if (iflag & IGNBRK) {
+		up->port.ignore_status_mask |= (SAB82532_ISR1_BRK << 8);
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			up->port.ignore_status_mask |= SAB82532_ISR0_RFO;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= (SAB82532_ISR0_RPF |
+						SAB82532_ISR0_TCD);
+
+	uart_update_timeout(&up->port, cflag,
+			    (up->port.uartclk / (16 * quot)));
+
+	/* Now schedule a register update when the chip's
+	 * transmitter is idle.
+	 */
+	up->cached_mode |= SAB82532_MODE_RAC;
+	set_bit(SAB82532_REGS_PENDING, &up->irqflags);
+	if (test_bit(SAB82532_XPR, &up->irqflags))
+		sunsab_tx_idle(up);
+}
+
+/* port->lock is not held.  */
+static void sunsab_set_termios(struct uart_port *port, struct ktermios *termios,
+			       struct ktermios *old)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *) port;
+	unsigned long flags;
+	unsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
+	unsigned int quot = uart_get_divisor(port, baud);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	sunsab_convert_to_sab(up, termios->c_cflag, termios->c_iflag, baud, quot);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static const char *sunsab_type(struct uart_port *port)
+{
+	struct uart_sunsab_port *up = (void *)port;
+	static char buf[36];
+	
+	sprintf(buf, "SAB82532 %s", sab82532_version[up->type]);
+	return buf;
+}
+
+static void sunsab_release_port(struct uart_port *port)
+{
+}
+
+static int sunsab_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void sunsab_config_port(struct uart_port *port, int flags)
+{
+}
+
+static int sunsab_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return -EINVAL;
+}
+
+static struct uart_ops sunsab_pops = {
+	.tx_empty	= sunsab_tx_empty,
+	.set_mctrl	= sunsab_set_mctrl,
+	.get_mctrl	= sunsab_get_mctrl,
+	.stop_tx	= sunsab_stop_tx,
+	.start_tx	= sunsab_start_tx,
+	.send_xchar	= sunsab_send_xchar,
+	.stop_rx	= sunsab_stop_rx,
+	.enable_ms	= sunsab_enable_ms,
+	.break_ctl	= sunsab_break_ctl,
+	.startup	= sunsab_startup,
+	.shutdown	= sunsab_shutdown,
+	.set_termios	= sunsab_set_termios,
+	.type		= sunsab_type,
+	.release_port	= sunsab_release_port,
+	.request_port	= sunsab_request_port,
+	.config_port	= sunsab_config_port,
+	.verify_port	= sunsab_verify_port,
+};
+
+static struct uart_driver sunsab_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "sunsab",
+	.dev_name		= "ttyS",
+	.major			= TTY_MAJOR,
+};
+
+static struct uart_sunsab_port *sunsab_ports;
+
+#ifdef CONFIG_SERIAL_SUNSAB_CONSOLE
+
+static void sunsab_console_putchar(struct uart_port *port, int c)
+{
+	struct uart_sunsab_port *up = (struct uart_sunsab_port *)port;
+
+	sunsab_tec_wait(up);
+	writeb(c, &up->regs->w.tic);
+}
+
+static void sunsab_console_write(struct console *con, const char *s, unsigned n)
+{
+	struct uart_sunsab_port *up = &sunsab_ports[con->index];
+	unsigned long flags;
+	int locked = 1;
+
+	local_irq_save(flags);
+	if (up->port.sysrq) {
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&up->port.lock);
+	} else
+		spin_lock(&up->port.lock);
+
+	uart_console_write(&up->port, s, n, sunsab_console_putchar);
+	sunsab_tec_wait(up);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
+}
+
+static int sunsab_console_setup(struct console *con, char *options)
+{
+	struct uart_sunsab_port *up = &sunsab_ports[con->index];
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	/*
+	 * The console framework calls us for each and every port
+	 * registered. Defer the console setup until the requested
+	 * port has been properly discovered. A bit of a hack,
+	 * though...
+	 */
+	if (up->port.type != PORT_SUNSAB)
+		return -1;
+
+	printk("Console: ttyS%d (SAB82532)\n",
+	       (sunsab_reg.minor - 64) + con->index);
+
+	sunserial_console_termios(con, up->port.dev->of_node);
+
+	switch (con->cflag & CBAUD) {
+	case B150: baud = 150; break;
+	case B300: baud = 300; break;
+	case B600: baud = 600; break;
+	case B1200: baud = 1200; break;
+	case B2400: baud = 2400; break;
+	case B4800: baud = 4800; break;
+	default: case B9600: baud = 9600; break;
+	case B19200: baud = 19200; break;
+	case B38400: baud = 38400; break;
+	case B57600: baud = 57600; break;
+	case B115200: baud = 115200; break;
+	case B230400: baud = 230400; break;
+	case B460800: baud = 460800; break;
+	};
+
+	/*
+	 * Temporary fix.
+	 */
+	spin_lock_init(&up->port.lock);
+
+	/*
+	 * Initialize the hardware
+	 */
+	sunsab_startup(&up->port);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	up->interrupt_mask0 = SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |
+				SAB82532_IMR0_PLLA | SAB82532_IMR0_CDSC;
+	writeb(up->interrupt_mask0, &up->regs->w.imr0);
+	up->interrupt_mask1 = SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |
+				SAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |
+				SAB82532_IMR1_CSC | SAB82532_IMR1_XON |
+				SAB82532_IMR1_XPR;
+	writeb(up->interrupt_mask1, &up->regs->w.imr1);
+
+	quot = uart_get_divisor(&up->port, baud);
+	sunsab_convert_to_sab(up, con->cflag, 0, baud, quot);
+	sunsab_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	
+	return 0;
+}
+
+static struct console sunsab_console = {
+	.name	=	"ttyS",
+	.write	=	sunsab_console_write,
+	.device	=	uart_console_device,
+	.setup	=	sunsab_console_setup,
+	.flags	=	CON_PRINTBUFFER,
+	.index	=	-1,
+	.data	=	&sunsab_reg,
+};
+
+static inline struct console *SUNSAB_CONSOLE(void)
+{
+	return &sunsab_console;
+}
+#else
+#define SUNSAB_CONSOLE()	(NULL)
+#define sunsab_console_init()	do { } while (0)
+#endif
+
+static int __devinit sunsab_init_one(struct uart_sunsab_port *up,
+				     struct platform_device *op,
+				     unsigned long offset,
+				     int line)
+{
+	up->port.line = line;
+	up->port.dev = &op->dev;
+
+	up->port.mapbase = op->resource[0].start + offset;
+	up->port.membase = of_ioremap(&op->resource[0], offset,
+				      sizeof(union sab82532_async_regs),
+				      "sab");
+	if (!up->port.membase)
+		return -ENOMEM;
+	up->regs = (union sab82532_async_regs __iomem *) up->port.membase;
+
+	up->port.irq = op->archdata.irqs[0];
+
+	up->port.fifosize = SAB82532_XMIT_FIFO_SIZE;
+	up->port.iotype = UPIO_MEM;
+
+	writeb(SAB82532_IPC_IC_ACT_LOW, &up->regs->w.ipc);
+
+	up->port.ops = &sunsab_pops;
+	up->port.type = PORT_SUNSAB;
+	up->port.uartclk = SAB_BASE_BAUD;
+
+	up->type = readb(&up->regs->r.vstr) & 0x0f;
+	writeb(~((1 << 1) | (1 << 2) | (1 << 4)), &up->regs->w.pcr);
+	writeb(0xff, &up->regs->w.pim);
+	if ((up->port.line & 0x1) == 0) {
+		up->pvr_dsr_bit = (1 << 0);
+		up->pvr_dtr_bit = (1 << 1);
+		up->gis_shift = 2;
+	} else {
+		up->pvr_dsr_bit = (1 << 3);
+		up->pvr_dtr_bit = (1 << 2);
+		up->gis_shift = 0;
+	}
+	up->cached_pvr = (1 << 1) | (1 << 2) | (1 << 4);
+	writeb(up->cached_pvr, &up->regs->w.pvr);
+	up->cached_mode = readb(&up->regs->rw.mode);
+	up->cached_mode |= SAB82532_MODE_FRTS;
+	writeb(up->cached_mode, &up->regs->rw.mode);
+	up->cached_mode |= SAB82532_MODE_RTS;
+	writeb(up->cached_mode, &up->regs->rw.mode);
+
+	up->tec_timeout = SAB82532_MAX_TEC_TIMEOUT;
+	up->cec_timeout = SAB82532_MAX_CEC_TIMEOUT;
+
+	return 0;
+}
+
+static int __devinit sab_probe(struct platform_device *op, const struct of_device_id *match)
+{
+	static int inst;
+	struct uart_sunsab_port *up;
+	int err;
+
+	up = &sunsab_ports[inst * 2];
+
+	err = sunsab_init_one(&up[0], op,
+			      0,
+			      (inst * 2) + 0);
+	if (err)
+		goto out;
+
+	err = sunsab_init_one(&up[1], op,
+			      sizeof(union sab82532_async_regs),
+			      (inst * 2) + 1);
+	if (err)
+		goto out1;
+
+	sunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,
+				&sunsab_reg, up[0].port.line,
+				false);
+
+	sunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,
+				&sunsab_reg, up[1].port.line,
+				false);
+
+	err = uart_add_one_port(&sunsab_reg, &up[0].port);
+	if (err)
+		goto out2;
+
+	err = uart_add_one_port(&sunsab_reg, &up[1].port);
+	if (err)
+		goto out3;
+
+	dev_set_drvdata(&op->dev, &up[0]);
+
+	inst++;
+
+	return 0;
+
+out3:
+	uart_remove_one_port(&sunsab_reg, &up[0].port);
+out2:
+	of_iounmap(&op->resource[0],
+		   up[1].port.membase,
+		   sizeof(union sab82532_async_regs));
+out1:
+	of_iounmap(&op->resource[0],
+		   up[0].port.membase,
+		   sizeof(union sab82532_async_regs));
+out:
+	return err;
+}
+
+static int __devexit sab_remove(struct platform_device *op)
+{
+	struct uart_sunsab_port *up = dev_get_drvdata(&op->dev);
+
+	uart_remove_one_port(&sunsab_reg, &up[1].port);
+	uart_remove_one_port(&sunsab_reg, &up[0].port);
+	of_iounmap(&op->resource[0],
+		   up[1].port.membase,
+		   sizeof(union sab82532_async_regs));
+	of_iounmap(&op->resource[0],
+		   up[0].port.membase,
+		   sizeof(union sab82532_async_regs));
+
+	dev_set_drvdata(&op->dev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id sab_match[] = {
+	{
+		.name = "se",
+	},
+	{
+		.name = "serial",
+		.compatible = "sab82532",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sab_match);
+
+static struct of_platform_driver sab_driver = {
+	.driver = {
+		.name = "sab",
+		.owner = THIS_MODULE,
+		.of_match_table = sab_match,
+	},
+	.probe		= sab_probe,
+	.remove		= __devexit_p(sab_remove),
+};
+
+static int __init sunsab_init(void)
+{
+	struct device_node *dp;
+	int err;
+	int num_channels = 0;
+
+	for_each_node_by_name(dp, "se")
+		num_channels += 2;
+	for_each_node_by_name(dp, "serial") {
+		if (of_device_is_compatible(dp, "sab82532"))
+			num_channels += 2;
+	}
+
+	if (num_channels) {
+		sunsab_ports = kzalloc(sizeof(struct uart_sunsab_port) *
+				       num_channels, GFP_KERNEL);
+		if (!sunsab_ports)
+			return -ENOMEM;
+
+		err = sunserial_register_minors(&sunsab_reg, num_channels);
+		if (err) {
+			kfree(sunsab_ports);
+			sunsab_ports = NULL;
+
+			return err;
+		}
+	}
+
+	return of_register_platform_driver(&sab_driver);
+}
+
+static void __exit sunsab_exit(void)
+{
+	of_unregister_platform_driver(&sab_driver);
+	if (sunsab_reg.nr) {
+		sunserial_unregister_minors(&sunsab_reg, sunsab_reg.nr);
+	}
+
+	kfree(sunsab_ports);
+	sunsab_ports = NULL;
+}
+
+module_init(sunsab_init);
+module_exit(sunsab_exit);
+
+MODULE_AUTHOR("Eddie C. Dost and David S. Miller");
+MODULE_DESCRIPTION("Sun SAB82532 serial port driver");
+MODULE_LICENSE("GPL");
