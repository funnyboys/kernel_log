commit 423d9118c6240eabb78bd3c75fc91ba6e3151431
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Thu May 28 10:24:29 2020 +0800

    serial: 8250_fintek: Add F81966 Support
    
    Fintek F81966 is a LPC/eSPI to 6 UARTs SuperIO. It has fully compatible
    with F81866. It's also need check the IRQ mode with system assigned.
    
    F81966 IRQ Mode setting:
            0xf0
                    Bit1: IRQ_MODE0
                    Bit0: Share mode (always on)
            0xf6
                    Bit3: IRQ_MODE1
    
            Level/Low: IRQ_MODE0:0, IRQ_MODE1:0
            Edge/High: IRQ_MODE0:1, IRQ_MODE1:0
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Cc: Ji-Ze Hong (Peter Hong) <peter_hong@fintek.com.tw>
    Link: https://lore.kernel.org/r/20200528022429.32078-1-hpeter+linux_kernel@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 31c91c2f8c6e..d1d253c4b518 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -19,6 +19,7 @@
 #define CHIP_ID2  0x21
 #define CHIP_ID_F81865 0x0407
 #define CHIP_ID_F81866 0x1010
+#define CHIP_ID_F81966 0x0215
 #define CHIP_ID_F81216AD 0x1602
 #define CHIP_ID_F81216H 0x0501
 #define CHIP_ID_F81216 0x0802
@@ -62,9 +63,9 @@
 #define F81216_LDN_HIGH	0x4
 
 /*
- * F81866 registers
+ * F81866/966 registers
  *
- * The IRQ setting mode of F81866 is not the same with F81216 series.
+ * The IRQ setting mode of F81866/966 is not the same with F81216 series.
  *	Level/Low: IRQ_MODE0:0, IRQ_MODE1:0
  *	Edge/High: IRQ_MODE0:1, IRQ_MODE1:0
  *
@@ -155,6 +156,7 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	switch (chip) {
 	case CHIP_ID_F81865:
 	case CHIP_ID_F81866:
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
 	case CHIP_ID_F81216:
@@ -171,6 +173,7 @@ static int fintek_8250_get_ldn_range(struct fintek_8250 *pdata, int *min,
 				     int *max)
 {
 	switch (pdata->pid) {
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81865:
 	case CHIP_ID_F81866:
 		*min = F81866_LDN_LOW;
@@ -248,6 +251,7 @@ static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
 	sio_write_reg(pdata, LDN, pdata->index);
 
 	switch (pdata->pid) {
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866:
 		sio_write_mask_reg(pdata, F81866_FIFO_CTRL, F81866_IRQ_MODE1,
 				   0);
@@ -274,6 +278,7 @@ static void fintek_8250_set_max_fifo(struct fintek_8250 *pdata)
 {
 	switch (pdata->pid) {
 	case CHIP_ID_F81216H: /* 128Bytes FIFO */
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866:
 		sio_write_mask_reg(pdata, FIFO_CTRL,
 				   FIFO_MODE_MASK | RXFTHR_MODE_MASK,
@@ -291,6 +296,7 @@ static void fintek_8250_goto_highspeed(struct uart_8250_port *uart,
 	sio_write_reg(pdata, LDN, pdata->index);
 
 	switch (pdata->pid) {
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866: /* set uart clock for high speed serial mode */
 		sio_write_mask_reg(pdata, F81866_UART_CLK,
 			F81866_UART_CLK_MASK,
@@ -327,6 +333,7 @@ static void fintek_8250_set_termios(struct uart_port *port,
 	case CHIP_ID_F81216H:
 		reg = RS485;
 		break;
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866:
 		reg = F81866_UART_CLK;
 		break;
@@ -373,6 +380,7 @@ static void fintek_8250_set_termios_handler(struct uart_8250_port *uart)
 
 	switch (pdata->pid) {
 	case CHIP_ID_F81216H:
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866:
 		uart->port.set_termios = fintek_8250_set_termios;
 		break;
@@ -443,6 +451,7 @@ static void fintek_8250_set_rs485_handler(struct uart_8250_port *uart)
 	switch (pdata->pid) {
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
+	case CHIP_ID_F81966:
 	case CHIP_ID_F81866:
 	case CHIP_ID_F81865:
 		uart->port.rs485_config = fintek_8250_rs485_config;

commit 9828def35a366fc1045cb794d99b6b12de89fa70
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Mar 19 23:16:46 2019 +0800

    serial: 8250_fintek: Make fintek_8250_set_termios static
    
    Fix sparse warning:
    
    drivers/tty/serial/8250/8250_fintek.c:306:6: warning:
     symbol 'fintek_8250_set_termios' was not declared. Should it be static?
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 79a4958b3f5c..31c91c2f8c6e 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -303,8 +303,9 @@ static void fintek_8250_goto_highspeed(struct uart_8250_port *uart,
 	}
 }
 
-void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
-			struct ktermios *old)
+static void fintek_8250_set_termios(struct uart_port *port,
+				    struct ktermios *termios,
+				    struct ktermios *old)
 {
 	struct fintek_8250 *pdata = port->private_data;
 	unsigned int baud = tty_termios_baud_rate(termios);

commit 07a708f0a16f040b319db647452bcb8884cd04be
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Wed Nov 8 11:05:46 2017 +0800

    serial: 8250_fintek: Fix crash with baud rate B0
    
    The 8250_fintek.c is support the Fintek F81866/F81216 with dynamic clock.
    But It'll generate "division by zero" exception and crash in
    fintek_8250_set_termios() with baud rate 0 on baudrate_table[i] % baud.
    
    It can be tested with following C code:
    
            ...
            struct termios options;
    
            tcgetattr(fd, &options);
            ...
            options.c_cflag = CS8 | CREAD; /* baud rate 0 */
            tcsetattr(fd, TCSANOW, &options);
            tcflush(fd, TCIOFLUSH);
    
    Fixes: 195638b6d44f ("serial: 8250_fintek: UART dynamic clocksource on Fintek F81866")
    Reported-by: Lukas Redlinger <rel+kernel@agilox.net>
    Cc: Lukas Redlinger <rel+kernel@agilox.net>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index ae7d86e44b76..79a4958b3f5c 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -315,6 +315,13 @@ void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
 			F81866_UART_CLK_14_769MHZ, F81866_UART_CLK_18_432MHZ,
 			F81866_UART_CLK_24MHZ };
 
+	/*
+	 * We'll use serial8250_do_set_termios() for baud = 0, otherwise It'll
+	 * crash on baudrate_table[i] % baud with "division by zero".
+	 */
+	if (!baud)
+		goto exit;
+
 	switch (pdata->pid) {
 	case CHIP_ID_F81216H:
 		reg = RS485;
@@ -327,8 +334,7 @@ void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		dev_warn(port->dev,
 			"%s: pid: %x Not support. use default set_termios.\n",
 			__func__, pdata->pid);
-		serial8250_do_set_termios(port, termios, old);
-		return;
+		goto exit;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(baudrate_table); ++i) {
@@ -356,6 +362,7 @@ void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		tty_termios_encode_baud_rate(termios, baud, baud);
 	}
 
+exit:
 	serial8250_do_set_termios(port, termios, old);
 }
 

commit 21c4e7f255e38620bb4c5d1119c64114ab280e2e
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Mon Nov 6 11:49:13 2017 +0100

    serial: 8250_fintek: Disable delays for ports != 0
    
    According to the datasheet, only the first port supports delay before
    send and delay after send.
    
    Reported-by: "Ji-Ze Hong (Peter Hong)" <hpeter@gmail.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 6c7910d8e136..ae7d86e44b76 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -212,6 +212,12 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	rs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |
 			SER_RS485_RTS_AFTER_SEND;
 
+	/* Only the first port supports delays */
+	if (pdata->index) {
+		rs485->delay_rts_before_send = 0;
+		rs485->delay_rts_after_send = 0;
+	}
+
 	if (rs485->delay_rts_before_send) {
 		rs485->delay_rts_before_send = 1;
 		config |= TXW4C_IRA;

commit 7ecc77011c6fb40d3eef7c6a0ebcec61e69b3ec3
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Mon Nov 6 11:49:12 2017 +0100

    serial: 8250_fintek: Return -EINVAL on invalid configuration
    
    Hardware does not support having the same RTS level during RX and TX
    when RS485 mode is on (URA in Fintek terminology).
    
    The manufacturer has also confirmed that the delays are not enabled if
    the RS485 mode is not enabled.
    
    Therefore we should return -EINVAL if the user wants to have the same
    value for RTS_ON_SEND and RTS_AFTER_SEND.
    
    Cc: "Ji-Ze Hong (Peter Hong)" <hpeter@gmail.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index be7029f2391e..6c7910d8e136 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -197,10 +197,17 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	if (!pdata)
 		return -EINVAL;
 
-	if (rs485->flags & SER_RS485_ENABLED)
+	/* Hardware do not support same RTS level on send and receive */
+	if (!(rs485->flags & SER_RS485_RTS_ON_SEND) ==
+			!(rs485->flags & SER_RS485_RTS_AFTER_SEND))
+		return -EINVAL;
+
+	if (rs485->flags & SER_RS485_ENABLED) {
 		memset(rs485->padding, 0, sizeof(rs485->padding));
-	else
+		config |= RS485_URA;
+	} else {
 		memset(rs485, 0, sizeof(*rs485));
+	}
 
 	rs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |
 			SER_RS485_RTS_AFTER_SEND;
@@ -215,12 +222,6 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 		config |= RXW4C_IRA;
 	}
 
-	if ((!!(rs485->flags & SER_RS485_RTS_ON_SEND)) ==
-			(!!(rs485->flags & SER_RS485_RTS_AFTER_SEND)))
-		rs485->flags &= ~SER_RS485_ENABLED;
-	else
-		config |= RS485_URA;
-
 	if (rs485->flags & SER_RS485_RTS_ON_SEND)
 		config |= RTS_INVERT;
 

commit 4793f2ebff1c890386a514998606205a2948011c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:52 2017 +0100

    tty: serial: Remove redundant license text
    
    Now that the SPDX tag is in all tty files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 894763f2c69e..be7029f2391e 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -3,11 +3,6 @@
  *  Probe for F81216A LPC to 4 UART
  *
  *  Copyright (C) 2014-2016 Ricardo Ribalda, Qtechnology A/S
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License.
  */
 #include <linux/module.h>
 #include <linux/pci.h>

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index c41cbb52f1fe..894763f2c69e 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  Probe for F81216A LPC to 4 UART
  *

commit 3236a965486ba0c6043cf2c7b51943d8b382ae29
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Oct 28 11:35:49 2017 +0200

    serial: 8250_fintek: Fix rs485 disablement on invalid ioctl()
    
    This driver's ->rs485_config callback checks if SER_RS485_RTS_ON_SEND
    and SER_RS485_RTS_AFTER_SEND have the same value.  If they do, it means
    the user has passed in invalid data with the TIOCSRS485 ioctl()
    since RTS must have a different polarity when sending and when not
    sending.  In this case, rs485 mode is not enabled (the RS485_URA bit
    is not set in the RS485 Enable Register) and this is supposed to be
    signaled back to the user by clearing the SER_RS485_ENABLED bit in
    struct serial_rs485 ... except a missing tilde character is preventing
    that from happening.
    
    Fixes: 28e3fb6c4dce ("serial: Add support for Fintek F81216A LPC to 4 UART")
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Cc: "Ji-Ze Hong (Peter Hong)" <hpeter@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index b34623914413..c41cbb52f1fe 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -221,7 +221,7 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 
 	if ((!!(rs485->flags & SER_RS485_RTS_ON_SEND)) ==
 			(!!(rs485->flags & SER_RS485_RTS_AFTER_SEND)))
-		rs485->flags &= SER_RS485_ENABLED;
+		rs485->flags &= ~SER_RS485_ENABLED;
 	else
 		config |= RS485_URA;
 

commit fd97e66c5529046e989a0879c3bb58fddb592c71
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 17 14:23:08 2017 +0800

    serial: 8250_fintek: Fix finding base_port with activated SuperIO
    
    The SuperIO will be configured at boot time by BIOS, but some BIOS
    will not deactivate the SuperIO when the end of configuration. It'll
    lead to mismatch for pdata->base_port in probe_setup_port(). So we'll
    deactivate all SuperIO before activate special base_port in
    fintek_8250_enter_key().
    
    Tested on iBASE MI802.
    
    Cc: stable@vger.kernel.org
    Tested-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Reviewd-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 96cc45f25ee9..b34623914413 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -128,6 +128,9 @@ static int fintek_8250_enter_key(u16 base_port, u8 key)
 	if (!request_muxed_region(base_port, 2, "8250_fintek"))
 		return -EBUSY;
 
+	/* Force to deactive all SuperIO in this base_port */
+	outb(EXIT_KEY, base_port + ADDR_PORT);
+
 	outb(key, base_port + ADDR_PORT);
 	outb(key, base_port + ADDR_PORT);
 	return 0;

commit 4c3897b1b0e3fffe964deb8b008da0623dfa2057
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 3 11:08:35 2017 +0800

    serial: 8250_fintek: fix warning reported from smatch
    
    This patch is fix the warning reported by smatch as following:
    
    drivers/tty/serial/8250/8250_fintek.c:294 fintek_8250_goto_highspeed()
    warn: inconsistent indenting
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index f3b622f00047..96cc45f25ee9 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -290,7 +290,7 @@ static void fintek_8250_goto_highspeed(struct uart_8250_port *uart,
 			F81866_UART_CLK_MASK,
 			F81866_UART_CLK_14_769MHZ);
 
-			uart->port.uartclk = 921600 * 16;
+		uart->port.uartclk = 921600 * 16;
 		break;
 	default: /* leave clock speed untouched */
 		break;

commit 58178914ae5bad449d8e53e38c7171ec85ad2c9a
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 3 11:08:34 2017 +0800

    serial: 8250_fintek: UART dynamic clocksource on Fintek F81216H
    
    The F81216H had 4 clocksource 1.8432/18.432/14.769/24MHzand  baud rates can
    be up to 1.5Mbits with 24MHz. The register value and mask is the same with
    F81866. But F81866 register address is F2h, F81216H is F0h.
    
    We'll implements the dynamic clocksource in fintek_8250_set_termios().
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 53ea353409ce..f3b622f00047 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -40,6 +40,16 @@
 #define IRQ_LEVEL_LOW	0
 #define IRQ_EDGE_HIGH	BIT(5)
 
+/*
+ * F81216H clock source register, the value and mask is the same with F81866,
+ * but it's on F0h.
+ *
+ * Clock speeds for UART (register F0h)
+ * 00: 1.8432MHz.
+ * 01: 18.432MHz.
+ * 10: 24MHz.
+ * 11: 14.769MHz.
+ */
 #define RS485  0xF0
 #define RTS_INVERT BIT(5)
 #define RS485_URA BIT(4)
@@ -293,11 +303,28 @@ void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	struct fintek_8250 *pdata = port->private_data;
 	unsigned int baud = tty_termios_baud_rate(termios);
 	int i;
+	u8 reg;
 	static u32 baudrate_table[] = {115200, 921600, 1152000, 1500000};
 	static u8 clock_table[] = { F81866_UART_CLK_1_8432MHZ,
 			F81866_UART_CLK_14_769MHZ, F81866_UART_CLK_18_432MHZ,
 			F81866_UART_CLK_24MHZ };
 
+	switch (pdata->pid) {
+	case CHIP_ID_F81216H:
+		reg = RS485;
+		break;
+	case CHIP_ID_F81866:
+		reg = F81866_UART_CLK;
+		break;
+	default:
+		/* Don't change clocksource with unknown PID */
+		dev_warn(port->dev,
+			"%s: pid: %x Not support. use default set_termios.\n",
+			__func__, pdata->pid);
+		serial8250_do_set_termios(port, termios, old);
+		return;
+	}
+
 	for (i = 0; i < ARRAY_SIZE(baudrate_table); ++i) {
 		if (baud > baudrate_table[i] || baudrate_table[i] % baud != 0)
 			continue;
@@ -311,8 +338,8 @@ void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		port->uartclk = baudrate_table[i] * 16;
 
 		sio_write_reg(pdata, LDN, pdata->index);
-		sio_write_mask_reg(pdata, F81866_UART_CLK,
-				F81866_UART_CLK_MASK, clock_table[i]);
+		sio_write_mask_reg(pdata, reg, F81866_UART_CLK_MASK,
+				clock_table[i]);
 
 		fintek_8250_exit_key(pdata->base_port);
 		break;
@@ -331,6 +358,7 @@ static void fintek_8250_set_termios_handler(struct uart_8250_port *uart)
 	struct fintek_8250 *pdata = uart->port.private_data;
 
 	switch (pdata->pid) {
+	case CHIP_ID_F81216H:
 	case CHIP_ID_F81866:
 		uart->port.set_termios = fintek_8250_set_termios;
 		break;

commit 195638b6d44f22c5fcbd428ebfe4b7c012c576f2
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 3 11:08:33 2017 +0800

    serial: 8250_fintek: UART dynamic clocksource on Fintek F81866
    
    The F81866 had 4 clocksource 1.8432/18.432/14.769/24MHz and baud rates can
    be up to 1.5Mbits with 24MHz. We'll implements the dynamic clocksource in
    fintek_8250_set_termios().
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index e500f7dd2470..53ea353409ce 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -287,6 +287,59 @@ static void fintek_8250_goto_highspeed(struct uart_8250_port *uart,
 	}
 }
 
+void fintek_8250_set_termios(struct uart_port *port, struct ktermios *termios,
+			struct ktermios *old)
+{
+	struct fintek_8250 *pdata = port->private_data;
+	unsigned int baud = tty_termios_baud_rate(termios);
+	int i;
+	static u32 baudrate_table[] = {115200, 921600, 1152000, 1500000};
+	static u8 clock_table[] = { F81866_UART_CLK_1_8432MHZ,
+			F81866_UART_CLK_14_769MHZ, F81866_UART_CLK_18_432MHZ,
+			F81866_UART_CLK_24MHZ };
+
+	for (i = 0; i < ARRAY_SIZE(baudrate_table); ++i) {
+		if (baud > baudrate_table[i] || baudrate_table[i] % baud != 0)
+			continue;
+
+		if (port->uartclk == baudrate_table[i] * 16)
+			break;
+
+		if (fintek_8250_enter_key(pdata->base_port, pdata->key))
+			continue;
+
+		port->uartclk = baudrate_table[i] * 16;
+
+		sio_write_reg(pdata, LDN, pdata->index);
+		sio_write_mask_reg(pdata, F81866_UART_CLK,
+				F81866_UART_CLK_MASK, clock_table[i]);
+
+		fintek_8250_exit_key(pdata->base_port);
+		break;
+	}
+
+	if (i == ARRAY_SIZE(baudrate_table)) {
+		baud = tty_termios_baud_rate(old);
+		tty_termios_encode_baud_rate(termios, baud, baud);
+	}
+
+	serial8250_do_set_termios(port, termios, old);
+}
+
+static void fintek_8250_set_termios_handler(struct uart_8250_port *uart)
+{
+	struct fintek_8250 *pdata = uart->port.private_data;
+
+	switch (pdata->pid) {
+	case CHIP_ID_F81866:
+		uart->port.set_termios = fintek_8250_set_termios;
+		break;
+
+	default:
+		break;
+	}
+}
+
 static int probe_setup_port(struct fintek_8250 *pdata,
 					struct uart_8250_port *uart)
 {
@@ -373,6 +426,7 @@ int fintek_8250_probe(struct uart_8250_port *uart)
 	memcpy(pdata, &probe_data, sizeof(probe_data));
 	uart->port.private_data = pdata;
 	fintek_8250_set_rs485_handler(uart);
+	fintek_8250_set_termios_handler(uart);
 
 	return 0;
 }

commit fab8a02b73eb2a42c589f943c377143f04b2bb73
Author: Lukas Redlinger <rel+kernel@agilox.net>
Date:   Tue Mar 14 15:09:14 2017 +0100

    serial: 8250_fintek: Enable high speed mode on Fintek F81866
    
    Fintek F81866 supports baud rates higher than 115200 but needs to raise
    it's clock speed from 1.84 to 14.76 MHz.
    This is eight times faster, so gives 921600 as resulting baud_base.
    
    F81866 clock register 0xf2:
        Bit 7-2    reserved
        Bit 1-0    00: 1.8432MHz
                   01: 18.432MHz
                   10: 24MHz
                   11: 14.769MHz
    
    Signed-off-by: Lukas Redlinger <rel+kernel@agilox.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index b67e7a544935..e500f7dd2470 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -61,6 +61,12 @@
  * The IRQ setting mode of F81866 is not the same with F81216 series.
  *	Level/Low: IRQ_MODE0:0, IRQ_MODE1:0
  *	Edge/High: IRQ_MODE0:1, IRQ_MODE1:0
+ *
+ * Clock speeds for UART (register F2h)
+ * 00: 1.8432MHz.
+ * 01: 18.432MHz.
+ * 10: 24MHz.
+ * 11: 14.769MHz.
  */
 #define F81866_IRQ_MODE		0xf0
 #define F81866_IRQ_SHARE	BIT(0)
@@ -72,6 +78,13 @@
 #define F81866_LDN_LOW		0x10
 #define F81866_LDN_HIGH		0x16
 
+#define F81866_UART_CLK 0xF2
+#define F81866_UART_CLK_MASK (BIT(1) | BIT(0))
+#define F81866_UART_CLK_1_8432MHZ 0
+#define F81866_UART_CLK_14_769MHZ (BIT(1) | BIT(0))
+#define F81866_UART_CLK_18_432MHZ BIT(0)
+#define F81866_UART_CLK_24MHZ BIT(1)
+
 struct fintek_8250 {
 	u16 pid;
 	u16 base_port;
@@ -256,8 +269,26 @@ static void fintek_8250_set_max_fifo(struct fintek_8250 *pdata)
 	}
 }
 
-static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
-			  unsigned int irq)
+static void fintek_8250_goto_highspeed(struct uart_8250_port *uart,
+			      struct fintek_8250 *pdata)
+{
+	sio_write_reg(pdata, LDN, pdata->index);
+
+	switch (pdata->pid) {
+	case CHIP_ID_F81866: /* set uart clock for high speed serial mode */
+		sio_write_mask_reg(pdata, F81866_UART_CLK,
+			F81866_UART_CLK_MASK,
+			F81866_UART_CLK_14_769MHZ);
+
+			uart->port.uartclk = 921600 * 16;
+		break;
+	default: /* leave clock speed untouched */
+		break;
+	}
+}
+
+static int probe_setup_port(struct fintek_8250 *pdata,
+					struct uart_8250_port *uart)
 {
 	static const u16 addr[] = {0x4e, 0x2e};
 	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
@@ -284,18 +315,20 @@ static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 				sio_write_reg(pdata, LDN, k);
 				aux = sio_read_reg(pdata, IO_ADDR1);
 				aux |= sio_read_reg(pdata, IO_ADDR2) << 8;
-				if (aux != io_address)
+				if (aux != uart->port.iobase)
 					continue;
 
 				pdata->index = k;
 
-				irq_data = irq_get_irq_data(irq);
+				irq_data = irq_get_irq_data(uart->port.irq);
 				if (irq_data)
 					level_mode =
 						irqd_is_level_type(irq_data);
 
 				fintek_8250_set_irq_mode(pdata, level_mode);
 				fintek_8250_set_max_fifo(pdata);
+				fintek_8250_goto_highspeed(uart, pdata);
+
 				fintek_8250_exit_key(addr[i]);
 
 				return 0;
@@ -330,7 +363,7 @@ int fintek_8250_probe(struct uart_8250_port *uart)
 	struct fintek_8250 *pdata;
 	struct fintek_8250 probe_data;
 
-	if (probe_setup_port(&probe_data, uart->port.iobase, uart->port.irq))
+	if (probe_setup_port(&probe_data, uart))
 		return -ENODEV;
 
 	pdata = devm_kzalloc(uart->port.dev, sizeof(*pdata), GFP_KERNEL);

commit de48b0999df44b5d2ab75500a48aedff5a36f0e6
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:28:04 2016 +0800

    serial: 8250_fintek: Add F81865 Support
    
    Fintek F81865 is a LPC to 6 UARTs SuperIO. It has less functional UARTs
    likes F81866. It's also need check the IRQ mode with system assigned,
    but the configuration is not the same with F81216 series.
    
    F81865 IRQ Mode setting:
        0xf0
                Bit1: IRQ_MODE0
                Bit0: Share mode (always on)
    
        Level/Low: IRQ_MODE0:0
        Edge/High: IRQ_MODE0:1
    
    The following list is brief descriptions of F81865:
    
    F81865 (0704)
        9Bit(not implements with mainline)
        RS485(implemented)
    
    Suggested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index ff4286bab791..b67e7a544935 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -21,6 +21,7 @@
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
 #define CHIP_ID2  0x21
+#define CHIP_ID_F81865 0x0407
 #define CHIP_ID_F81866 0x1010
 #define CHIP_ID_F81216AD 0x1602
 #define CHIP_ID_F81216H 0x0501
@@ -130,6 +131,7 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	chip |= sio_read_reg(pdata, CHIP_ID2) << 8;
 
 	switch (chip) {
+	case CHIP_ID_F81865:
 	case CHIP_ID_F81866:
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
@@ -147,6 +149,7 @@ static int fintek_8250_get_ldn_range(struct fintek_8250 *pdata, int *min,
 				     int *max)
 {
 	switch (pdata->pid) {
+	case CHIP_ID_F81865:
 	case CHIP_ID_F81866:
 		*min = F81866_LDN_LOW;
 		*max = F81866_LDN_HIGH;
@@ -219,6 +222,8 @@ static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
 	case CHIP_ID_F81866:
 		sio_write_mask_reg(pdata, F81866_FIFO_CTRL, F81866_IRQ_MODE1,
 				   0);
+		/* fall through */
+	case CHIP_ID_F81865:
 		sio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_SHARE,
 				   F81866_IRQ_SHARE);
 		sio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_MODE0,
@@ -311,6 +316,7 @@ static void fintek_8250_set_rs485_handler(struct uart_8250_port *uart)
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
 	case CHIP_ID_F81866:
+	case CHIP_ID_F81865:
 		uart->port.rs485_config = fintek_8250_rs485_config;
 		break;
 

commit da60d6afaa3e7be561d202c78b6859eda4c87973
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:28:03 2016 +0800

    serial: 8250_fintek: Add F81866 Support
    
    Fintek F81866 is a LPC to 6 UARTs SuperIO. It has fully functional UARTs
    likes F81216H. It's also need check the IRQ mode with system assigned,
    but the configuration is not the same with F81216 series.
    
    F81866 IRQ Mode setting:
            0xf0
                    Bit1: IRQ_MODE0
                    Bit0: Share mode (always on)
            0xf6
                    Bit3: IRQ_MODE1
    
            Level/Low: IRQ_MODE0:0, IRQ_MODE1:0
            Edge/High: IRQ_MODE0:1, IRQ_MODE1:0
    
    The following list is brief descriptions of F81866:
    
    F81866 (1010)
            9Bit/High baud rate(not implements with mainline)
            RS485, 128Bytes FIFO (implemented)
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 523d873731be..ff4286bab791 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -21,6 +21,7 @@
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
 #define CHIP_ID2  0x21
+#define CHIP_ID_F81866 0x1010
 #define CHIP_ID_F81216AD 0x1602
 #define CHIP_ID_F81216H 0x0501
 #define CHIP_ID_F81216 0x0802
@@ -50,6 +51,26 @@
 #define RXFTHR_MODE_MASK	(BIT(5) | BIT(4))
 #define RXFTHR_MODE_4X		BIT(5)
 
+#define F81216_LDN_LOW	0x0
+#define F81216_LDN_HIGH	0x4
+
+/*
+ * F81866 registers
+ *
+ * The IRQ setting mode of F81866 is not the same with F81216 series.
+ *	Level/Low: IRQ_MODE0:0, IRQ_MODE1:0
+ *	Edge/High: IRQ_MODE0:1, IRQ_MODE1:0
+ */
+#define F81866_IRQ_MODE		0xf0
+#define F81866_IRQ_SHARE	BIT(0)
+#define F81866_IRQ_MODE0	BIT(1)
+
+#define F81866_FIFO_CTRL	FIFO_CTRL
+#define F81866_IRQ_MODE1	BIT(3)
+
+#define F81866_LDN_LOW		0x10
+#define F81866_LDN_HIGH		0x16
+
 struct fintek_8250 {
 	u16 pid;
 	u16 base_port;
@@ -109,6 +130,7 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	chip |= sio_read_reg(pdata, CHIP_ID2) << 8;
 
 	switch (chip) {
+	case CHIP_ID_F81866:
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
 	case CHIP_ID_F81216:
@@ -121,6 +143,26 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	return 0;
 }
 
+static int fintek_8250_get_ldn_range(struct fintek_8250 *pdata, int *min,
+				     int *max)
+{
+	switch (pdata->pid) {
+	case CHIP_ID_F81866:
+		*min = F81866_LDN_LOW;
+		*max = F81866_LDN_HIGH;
+		return 0;
+
+	case CHIP_ID_F81216AD:
+	case CHIP_ID_F81216H:
+	case CHIP_ID_F81216:
+		*min = F81216_LDN_LOW;
+		*max = F81216_LDN_HIGH;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
 static int fintek_8250_rs485_config(struct uart_port *port,
 			      struct serial_rs485 *rs485)
 {
@@ -172,15 +214,33 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
 {
 	sio_write_reg(pdata, LDN, pdata->index);
-	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE, IRQ_SHARE);
-	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,
-			   is_level ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
+
+	switch (pdata->pid) {
+	case CHIP_ID_F81866:
+		sio_write_mask_reg(pdata, F81866_FIFO_CTRL, F81866_IRQ_MODE1,
+				   0);
+		sio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_SHARE,
+				   F81866_IRQ_SHARE);
+		sio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_MODE0,
+				   is_level ? 0 : F81866_IRQ_MODE0);
+		break;
+
+	case CHIP_ID_F81216AD:
+	case CHIP_ID_F81216H:
+	case CHIP_ID_F81216:
+		sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE,
+				   IRQ_SHARE);
+		sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,
+				   is_level ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
+		break;
+	}
 }
 
 static void fintek_8250_set_max_fifo(struct fintek_8250 *pdata)
 {
 	switch (pdata->pid) {
 	case CHIP_ID_F81216H: /* 128Bytes FIFO */
+	case CHIP_ID_F81866:
 		sio_write_mask_reg(pdata, FIFO_CTRL,
 				   FIFO_MODE_MASK | RXFTHR_MODE_MASK,
 				   FIFO_MODE_128 | RXFTHR_MODE_4X);
@@ -198,7 +258,7 @@ static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
 	struct irq_data *irq_data;
 	bool level_mode = false;
-	int i, j, k;
+	int i, j, k, min, max;
 
 	for (i = 0; i < ARRAY_SIZE(addr); i++) {
 		for (j = 0; j < ARRAY_SIZE(keys); j++) {
@@ -207,12 +267,13 @@ static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 
 			if (fintek_8250_enter_key(addr[i], keys[j]))
 				continue;
-			if (fintek_8250_check_id(pdata)) {
+			if (fintek_8250_check_id(pdata) ||
+			    fintek_8250_get_ldn_range(pdata, &min, &max)) {
 				fintek_8250_exit_key(addr[i]);
 				continue;
 			}
 
-			for (k = 0; k < 4; k++) {
+			for (k = min; k < max; k++) {
 				u16 aux;
 
 				sio_write_reg(pdata, LDN, k);
@@ -249,6 +310,7 @@ static void fintek_8250_set_rs485_handler(struct uart_8250_port *uart)
 	switch (pdata->pid) {
 	case CHIP_ID_F81216AD:
 	case CHIP_ID_F81216H:
+	case CHIP_ID_F81866:
 		uart->port.rs485_config = fintek_8250_rs485_config;
 		break;
 

commit 1e26c472c1a299c843f9762f74e8cd503cd977a2
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:28:02 2016 +0800

    serial: 8250_fintek: Add F81216 Support
    
    Fintek F81216 is a LPC to 4 UARTs device. It's the F81216 series but
    support less functional than F81216AD/F81216H
    
    The following list is brief descriptions of F81216 series:
    
    F81216H (0105)
            9Bit/High baud rate(not implements with mainline)
            RS485, 128Bytes FIFO (implemented)
    
    F81216AD (0216)
            9Bit(not implements with mainline)
            RS485(implemented)
    
    F81216 (0208)
            basically 16550A
    
    Suggested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index e039a33e59e3..523d873731be 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -23,6 +23,7 @@
 #define CHIP_ID2  0x21
 #define CHIP_ID_F81216AD 0x1602
 #define CHIP_ID_F81216H 0x0501
+#define CHIP_ID_F81216 0x0802
 #define VENDOR_ID1 0x23
 #define VENDOR_ID1_VAL 0x19
 #define VENDOR_ID2 0x24
@@ -107,8 +108,14 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	chip = sio_read_reg(pdata, CHIP_ID1);
 	chip |= sio_read_reg(pdata, CHIP_ID2) << 8;
 
-	if (chip != CHIP_ID_F81216AD && chip != CHIP_ID_F81216H)
+	switch (chip) {
+	case CHIP_ID_F81216AD:
+	case CHIP_ID_F81216H:
+	case CHIP_ID_F81216:
+		break;
+	default:
 		return -ENODEV;
+	}
 
 	pdata->pid = chip;
 	return 0;
@@ -235,6 +242,21 @@ static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 	return -ENODEV;
 }
 
+static void fintek_8250_set_rs485_handler(struct uart_8250_port *uart)
+{
+	struct fintek_8250 *pdata = uart->port.private_data;
+
+	switch (pdata->pid) {
+	case CHIP_ID_F81216AD:
+	case CHIP_ID_F81216H:
+		uart->port.rs485_config = fintek_8250_rs485_config;
+		break;
+
+	default: /* No RS485 Auto direction functional */
+		break;
+	}
+}
+
 int fintek_8250_probe(struct uart_8250_port *uart)
 {
 	struct fintek_8250 *pdata;
@@ -248,8 +270,8 @@ int fintek_8250_probe(struct uart_8250_port *uart)
 		return -ENOMEM;
 
 	memcpy(pdata, &probe_data, sizeof(probe_data));
-	uart->port.rs485_config = fintek_8250_rs485_config;
 	uart->port.private_data = pdata;
+	fintek_8250_set_rs485_handler(uart);
 
 	return 0;
 }

commit c2236facaec9e4bdd3b350a6a54d29440a234a04
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:28:01 2016 +0800

    serial: 8250_fintek: Set maximum FIFO of F81216H
    
    The Fintek F81216H had maximum 128Bytes FIFO, but some BIOS configurated
    as normal 16Bytes FIFO. This patch will set 128Bytes FIFO and trigger
    level multiplier as 4x when F81216H detected.
    
    Default 16550A trigger level is 8Bytes. When this patch applied, the
    trigger level will change to 8Byte x 4 = 32Byte. It can be reduce the RX
    incoming interrupts.
    
    Suggested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index deccd0e8434b..e039a33e59e3 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -21,8 +21,8 @@
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
 #define CHIP_ID2  0x21
-#define CHIP_ID_0 0x1602
-#define CHIP_ID_1 0x0501
+#define CHIP_ID_F81216AD 0x1602
+#define CHIP_ID_F81216H 0x0501
 #define VENDOR_ID1 0x23
 #define VENDOR_ID1_VAL 0x19
 #define VENDOR_ID2 0x24
@@ -43,7 +43,14 @@
 #define RXW4C_IRA BIT(3)
 #define TXW4C_IRA BIT(2)
 
+#define FIFO_CTRL		0xF6
+#define FIFO_MODE_MASK		(BIT(1) | BIT(0))
+#define FIFO_MODE_128		(BIT(1) | BIT(0))
+#define RXFTHR_MODE_MASK	(BIT(5) | BIT(4))
+#define RXFTHR_MODE_4X		BIT(5)
+
 struct fintek_8250 {
+	u16 pid;
 	u16 base_port;
 	u8 index;
 	u8 key;
@@ -100,9 +107,10 @@ static int fintek_8250_check_id(struct fintek_8250 *pdata)
 	chip = sio_read_reg(pdata, CHIP_ID1);
 	chip |= sio_read_reg(pdata, CHIP_ID2) << 8;
 
-	if (chip != CHIP_ID_0 && chip != CHIP_ID_1)
+	if (chip != CHIP_ID_F81216AD && chip != CHIP_ID_F81216H)
 		return -ENODEV;
 
+	pdata->pid = chip;
 	return 0;
 }
 
@@ -162,6 +170,20 @@ static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
 			   is_level ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
 }
 
+static void fintek_8250_set_max_fifo(struct fintek_8250 *pdata)
+{
+	switch (pdata->pid) {
+	case CHIP_ID_F81216H: /* 128Bytes FIFO */
+		sio_write_mask_reg(pdata, FIFO_CTRL,
+				   FIFO_MODE_MASK | RXFTHR_MODE_MASK,
+				   FIFO_MODE_128 | RXFTHR_MODE_4X);
+		break;
+
+	default: /* Default 16Bytes FIFO */
+		break;
+	}
+}
+
 static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 			  unsigned int irq)
 {
@@ -200,6 +222,7 @@ static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
 						irqd_is_level_type(irq_data);
 
 				fintek_8250_set_irq_mode(pdata, level_mode);
+				fintek_8250_set_max_fifo(pdata);
 				fintek_8250_exit_key(addr[i]);
 
 				return 0;

commit 06e3957259ef9003061c3c153232266ab8967e34
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:28:00 2016 +0800

    serial: 8250_fintek: Set IRQ Mode when port probed
    
    Set IRQ Mode when port probed in probe_setup_port()
    
    It should hold the IO port premission via fintek_8250_enter_key() and
    release via fintek_8250_exit_key() when we configure the SuperIO.
    
    This patch will move all SuperIO configure operations to
    probe_setup_port() to reduce fintek_8250_enter_key() and
    fintek_8250_exit_key() usage.
    
    Suggested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 2ae846e2c6d0..deccd0e8434b 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -154,10 +154,21 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	return 0;
 }
 
-static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
+static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
+{
+	sio_write_reg(pdata, LDN, pdata->index);
+	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE, IRQ_SHARE);
+	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,
+			   is_level ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
+}
+
+static int probe_setup_port(struct fintek_8250 *pdata, u16 io_address,
+			  unsigned int irq)
 {
 	static const u16 addr[] = {0x4e, 0x2e};
 	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
+	struct irq_data *irq_data;
+	bool level_mode = false;
 	int i, j, k;
 
 	for (i = 0; i < ARRAY_SIZE(addr); i++) {
@@ -181,9 +192,16 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 				if (aux != io_address)
 					continue;
 
-				fintek_8250_exit_key(addr[i]);
 				pdata->index = k;
 
+				irq_data = irq_get_irq_data(irq);
+				if (irq_data)
+					level_mode =
+						irqd_is_level_type(irq_data);
+
+				fintek_8250_set_irq_mode(pdata, level_mode);
+				fintek_8250_exit_key(addr[i]);
+
 				return 0;
 			}
 
@@ -194,31 +212,12 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 	return -ENODEV;
 }
 
-static int fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool level_mode)
-{
-	int status;
-
-	status = fintek_8250_enter_key(pdata->base_port, pdata->key);
-	if (status)
-		return status;
-
-	sio_write_reg(pdata, LDN, pdata->index);
-	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE, IRQ_SHARE);
-	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,
-			   level_mode ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
-
-	fintek_8250_exit_key(pdata->base_port);
-	return 0;
-}
-
 int fintek_8250_probe(struct uart_8250_port *uart)
 {
 	struct fintek_8250 *pdata;
 	struct fintek_8250 probe_data;
-	struct irq_data *irq_data = irq_get_irq_data(uart->port.irq);
-	bool level_mode = irqd_is_level_type(irq_data);
 
-	if (find_base_port(&probe_data, uart->port.iobase))
+	if (probe_setup_port(&probe_data, uart->port.iobase, uart->port.irq))
 		return -ENODEV;
 
 	pdata = devm_kzalloc(uart->port.dev, sizeof(*pdata), GFP_KERNEL);
@@ -229,5 +228,5 @@ int fintek_8250_probe(struct uart_8250_port *uart)
 	uart->port.rs485_config = fintek_8250_rs485_config;
 	uart->port.private_data = pdata;
 
-	return fintek_8250_set_irq_mode(pdata, level_mode);
+	return 0;
 }

commit f1232ac229cc078206a72ca365c3526e37ea1ae5
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Tue Oct 4 16:27:59 2016 +0800

    serial: 8250_fintek: Refactoring read/write method
    
    If we need to access SuperIO registers, It should write register offset
    to base_addr and read/write value to base_addr + 1 to perform read/write.
    We can make it more simply with write/read functions.
    
    This patch add sio_read_reg()/sio_write_reg()/sio_write_mask_reg() to
    reduce SuperIO register operation with lot of outb()/inb().
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 0facc789fe7d..2ae846e2c6d0 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -49,6 +49,27 @@ struct fintek_8250 {
 	u8 key;
 };
 
+static u8 sio_read_reg(struct fintek_8250 *pdata, u8 reg)
+{
+	outb(reg, pdata->base_port + ADDR_PORT);
+	return inb(pdata->base_port + DATA_PORT);
+}
+
+static void sio_write_reg(struct fintek_8250 *pdata, u8 reg, u8 data)
+{
+	outb(reg, pdata->base_port + ADDR_PORT);
+	outb(data, pdata->base_port + DATA_PORT);
+}
+
+static void sio_write_mask_reg(struct fintek_8250 *pdata, u8 reg, u8 mask,
+			       u8 data)
+{
+	u8 tmp;
+
+	tmp = (sio_read_reg(pdata, reg) & ~mask) | (mask & data);
+	sio_write_reg(pdata, reg, tmp);
+}
+
 static int fintek_8250_enter_key(u16 base_port, u8 key)
 {
 	if (!request_muxed_region(base_port, 2, "8250_fintek"))
@@ -66,22 +87,18 @@ static void fintek_8250_exit_key(u16 base_port)
 	release_region(base_port + ADDR_PORT, 2);
 }
 
-static int fintek_8250_check_id(u16 base_port)
+static int fintek_8250_check_id(struct fintek_8250 *pdata)
 {
 	u16 chip;
 
-	outb(VENDOR_ID1, base_port + ADDR_PORT);
-	if (inb(base_port + DATA_PORT) != VENDOR_ID1_VAL)
+	if (sio_read_reg(pdata, VENDOR_ID1) != VENDOR_ID1_VAL)
 		return -ENODEV;
 
-	outb(VENDOR_ID2, base_port + ADDR_PORT);
-	if (inb(base_port + DATA_PORT) != VENDOR_ID2_VAL)
+	if (sio_read_reg(pdata, VENDOR_ID2) != VENDOR_ID2_VAL)
 		return -ENODEV;
 
-	outb(CHIP_ID1, base_port + ADDR_PORT);
-	chip = inb(base_port + DATA_PORT);
-	outb(CHIP_ID2, base_port + ADDR_PORT);
-	chip |= inb(base_port + DATA_PORT) << 8;
+	chip = sio_read_reg(pdata, CHIP_ID1);
+	chip |= sio_read_reg(pdata, CHIP_ID2) << 8;
 
 	if (chip != CHIP_ID_0 && chip != CHIP_ID_1)
 		return -ENODEV;
@@ -128,10 +145,8 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	if (fintek_8250_enter_key(pdata->base_port, pdata->key))
 		return -EBUSY;
 
-	outb(LDN, pdata->base_port + ADDR_PORT);
-	outb(pdata->index, pdata->base_port + DATA_PORT);
-	outb(RS485, pdata->base_port + ADDR_PORT);
-	outb(config, pdata->base_port + DATA_PORT);
+	sio_write_reg(pdata, LDN, pdata->index);
+	sio_write_reg(pdata, RS485, config);
 	fintek_8250_exit_key(pdata->base_port);
 
 	port->rs485 = *rs485;
@@ -147,10 +162,12 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 
 	for (i = 0; i < ARRAY_SIZE(addr); i++) {
 		for (j = 0; j < ARRAY_SIZE(keys); j++) {
+			pdata->base_port = addr[i];
+			pdata->key = keys[j];
 
 			if (fintek_8250_enter_key(addr[i], keys[j]))
 				continue;
-			if (fintek_8250_check_id(addr[i])) {
+			if (fintek_8250_check_id(pdata)) {
 				fintek_8250_exit_key(addr[i]);
 				continue;
 			}
@@ -158,19 +175,13 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 			for (k = 0; k < 4; k++) {
 				u16 aux;
 
-				outb(LDN, addr[i] + ADDR_PORT);
-				outb(k, addr[i] + DATA_PORT);
-
-				outb(IO_ADDR1, addr[i] + ADDR_PORT);
-				aux = inb(addr[i] + DATA_PORT);
-				outb(IO_ADDR2, addr[i] + ADDR_PORT);
-				aux |= inb(addr[i] + DATA_PORT) << 8;
+				sio_write_reg(pdata, LDN, k);
+				aux = sio_read_reg(pdata, IO_ADDR1);
+				aux |= sio_read_reg(pdata, IO_ADDR2) << 8;
 				if (aux != io_address)
 					continue;
 
 				fintek_8250_exit_key(addr[i]);
-				pdata->key = keys[j];
-				pdata->base_port = addr[i];
 				pdata->index = k;
 
 				return 0;
@@ -186,24 +197,16 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 static int fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool level_mode)
 {
 	int status;
-	u8 tmp;
 
 	status = fintek_8250_enter_key(pdata->base_port, pdata->key);
 	if (status)
 		return status;
 
-	outb(LDN, pdata->base_port + ADDR_PORT);
-	outb(pdata->index, pdata->base_port + DATA_PORT);
-
-	outb(FINTEK_IRQ_MODE, pdata->base_port + ADDR_PORT);
-	tmp = inb(pdata->base_port + DATA_PORT);
-
-	tmp &= ~IRQ_MODE_MASK;
-	tmp |= IRQ_SHARE;
-	if (!level_mode)
-		tmp |= IRQ_EDGE_HIGH;
+	sio_write_reg(pdata, LDN, pdata->index);
+	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE, IRQ_SHARE);
+	sio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,
+			   level_mode ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);
 
-	outb(tmp, pdata->base_port + DATA_PORT);
 	fintek_8250_exit_key(pdata->base_port);
 	return 0;
 }

commit 87a713c8ffca33d8e497a8b6c02034332bd80394
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Aug 10 23:54:13 2016 +0200

    8250/fintek: rename IRQ_MODE macro
    
    A bugfix for the fintek driver required defining some macros, but
    one of them clashes with a system header on ARM:
    
    drivers/tty/serial/8250/8250_fintek.c:34:0: error: "IRQ_MODE" redefined [-Werror]
     #define IRQ_MODE 0x70
    
    In file included from /git/arm-soc/arch/arm/include/asm/ptrace.h:13:0,
                     from /git/arm-soc/arch/arm/include/asm/irqflags.h:6,
                     from /git/arm-soc/include/linux/irqflags.h:15,
                     from /git/arm-soc/arch/arm/include/asm/bitops.h:27,
                     from /git/arm-soc/include/linux/bitops.h:36,
                     from /git/arm-soc/include/linux/kernel.h:10,
                     from /git/arm-soc/include/linux/list.h:8,
                     from /git/arm-soc/include/linux/module.h:9,
                     from /git/arm-soc/drivers/tty/serial/8250/8250_fintek.c:11:
    arch/arm/include/uapi/asm/ptrace.h:55:0: note: this is the location of the previous definition
    
    This renames the newly introduced 'IRQ_MODE' macro to FINTEK_IRQ_MODE.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 4da22f1418cb ("serial: 8250_fintek: fix the mismatched IRQ mode")
    Link: https://patchwork.kernel.org/patch/9200119/
    Acked-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Acked-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 737b4b3957b0..0facc789fe7d 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -31,7 +31,7 @@
 #define IO_ADDR2 0x60
 #define LDN 0x7
 
-#define IRQ_MODE	0x70
+#define FINTEK_IRQ_MODE	0x70
 #define IRQ_SHARE	BIT(4)
 #define IRQ_MODE_MASK	(BIT(6) | BIT(5))
 #define IRQ_LEVEL_LOW	0
@@ -195,7 +195,7 @@ static int fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool level_mode)
 	outb(LDN, pdata->base_port + ADDR_PORT);
 	outb(pdata->index, pdata->base_port + DATA_PORT);
 
-	outb(IRQ_MODE, pdata->base_port + ADDR_PORT);
+	outb(FINTEK_IRQ_MODE, pdata->base_port + ADDR_PORT);
 	tmp = inb(pdata->base_port + DATA_PORT);
 
 	tmp &= ~IRQ_MODE_MASK;

commit 4da22f1418cb6f09e974499794db2f5e59fe8090
Author: Ji-Ze Hong (Peter Hong) <hpeter@gmail.com>
Date:   Fri May 27 10:02:51 2016 +0800

    serial: 8250_fintek: fix the mismatched IRQ mode
    
    Some BIOS only use _OSI("Linux") to distinguish between Linux & Windows.
    Apply Level/Low to UART trigger mode if Windows, Edge/High mode otherwise.
    But since 2.6.23 the mainline kernel no longer returns true for
    _OSI(“Linux”).
    
    The default IRQ0~15 trigger mode in Linux is Edge/High mode without
    ACPI MADT override. It mismatches IRQ mode and makes UART malfunctional on
    such motherboard.
    
    This patch will check the current IRQ mode and apply correct mode to UART.
    
    The following link is F81216AD spec PDF:
    http://html.alldatasheet.com/html-pdf/257956/FINTEK/F81216AD/5569/
    25/F81216AD.html
    
    LDN0~3
            70h: IRQ channel & Mode register
                    Bit 6~5 :
                            00      : Active low level mode
                            01      : Active high edge mode
                    Bit 4   : Sharing Flag (0: not share/1: share)
                    Bit 3~0 : IRQ channel
    
    Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter+linux_kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 870981dd9e39..737b4b3957b0 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -13,6 +13,7 @@
 #include <linux/pnp.h>
 #include <linux/kernel.h>
 #include <linux/serial_core.h>
+#include <linux/irq.h>
 #include  "8250.h"
 
 #define ADDR_PORT 0
@@ -30,6 +31,12 @@
 #define IO_ADDR2 0x60
 #define LDN 0x7
 
+#define IRQ_MODE	0x70
+#define IRQ_SHARE	BIT(4)
+#define IRQ_MODE_MASK	(BIT(6) | BIT(5))
+#define IRQ_LEVEL_LOW	0
+#define IRQ_EDGE_HIGH	BIT(5)
+
 #define RS485  0xF0
 #define RTS_INVERT BIT(5)
 #define RS485_URA BIT(4)
@@ -176,10 +183,37 @@ static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 	return -ENODEV;
 }
 
+static int fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool level_mode)
+{
+	int status;
+	u8 tmp;
+
+	status = fintek_8250_enter_key(pdata->base_port, pdata->key);
+	if (status)
+		return status;
+
+	outb(LDN, pdata->base_port + ADDR_PORT);
+	outb(pdata->index, pdata->base_port + DATA_PORT);
+
+	outb(IRQ_MODE, pdata->base_port + ADDR_PORT);
+	tmp = inb(pdata->base_port + DATA_PORT);
+
+	tmp &= ~IRQ_MODE_MASK;
+	tmp |= IRQ_SHARE;
+	if (!level_mode)
+		tmp |= IRQ_EDGE_HIGH;
+
+	outb(tmp, pdata->base_port + DATA_PORT);
+	fintek_8250_exit_key(pdata->base_port);
+	return 0;
+}
+
 int fintek_8250_probe(struct uart_8250_port *uart)
 {
 	struct fintek_8250 *pdata;
 	struct fintek_8250 probe_data;
+	struct irq_data *irq_data = irq_get_irq_data(uart->port.irq);
+	bool level_mode = irqd_is_level_type(irq_data);
 
 	if (find_base_port(&probe_data, uart->port.iobase))
 		return -ENODEV;
@@ -192,5 +226,5 @@ int fintek_8250_probe(struct uart_8250_port *uart)
 	uart->port.rs485_config = fintek_8250_rs485_config;
 	uart->port.private_data = pdata;
 
-	return 0;
+	return fintek_8250_set_irq_mode(pdata, level_mode);
 }

commit fa01e2ca9f531b4a5693469a196eb1574b8d7d8a
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Wed Apr 27 10:40:10 2016 +0200

    serial: 8250: Integrate Fintek into 8250_base
    
    The 8250_fintek driver advertises as the PNP0501 driver; however this
    conflicts with the standard 16550A uart PNP0501. The conflict causes
    the 8250_fintek driver to load with _every_ PNP0501, but never probe,
    and causing the entire 8250 driver stack to unload if the 8250_fintek
    driver is unloaded (modprobe doesn't know that 8250_pnp rather than
    8250_fintek claimed the resource).
    
    This patch merges the Fintek driver into 8250_base. On autoconfig_16550
    the device is probed to verify if it is a FINTEK device or not.
    
    This custom probing can be disabled completely via configuration. When a
    Fintek device is not probed it will behave as a standard 16550A device,
    with no RS485 capabilities.
    
    Reported-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 89474399ab89..870981dd9e39 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -1,9 +1,7 @@
 /*
  *  Probe for F81216A LPC to 4 UART
  *
- *  Based on drivers/tty/serial/8250_pnp.c, by Russell King, et al
- *
- *  Copyright (C) 2014 Ricardo Ribalda, Qtechnology A/S
+ *  Copyright (C) 2014-2016 Ricardo Ribalda, Qtechnology A/S
  *
  *
  * This program is free software; you can redistribute it and/or modify
@@ -38,19 +36,15 @@
 #define RXW4C_IRA BIT(3)
 #define TXW4C_IRA BIT(2)
 
-#define DRIVER_NAME "8250_fintek"
-
 struct fintek_8250 {
 	u16 base_port;
 	u8 index;
 	u8 key;
-	long line;
 };
 
 static int fintek_8250_enter_key(u16 base_port, u8 key)
 {
-
-	if (!request_muxed_region(base_port, 2, DRIVER_NAME))
+	if (!request_muxed_region(base_port, 2, "8250_fintek"))
 		return -EBUSY;
 
 	outb(key, base_port + ADDR_PORT);
@@ -138,7 +132,7 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	return 0;
 }
 
-static int fintek_8250_base_port(u16 io_address, u8 *key, u8 *index)
+static int find_base_port(struct fintek_8250 *pdata, u16 io_address)
 {
 	static const u16 addr[] = {0x4e, 0x2e};
 	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
@@ -168,10 +162,13 @@ static int fintek_8250_base_port(u16 io_address, u8 *key, u8 *index)
 					continue;
 
 				fintek_8250_exit_key(addr[i]);
-				*key = keys[j];
-				*index = k;
-				return addr[i];
+				pdata->key = keys[j];
+				pdata->base_port = addr[i];
+				pdata->index = k;
+
+				return 0;
 			}
+
 			fintek_8250_exit_key(addr[i]);
 		}
 	}
@@ -179,104 +176,21 @@ static int fintek_8250_base_port(u16 io_address, u8 *key, u8 *index)
 	return -ENODEV;
 }
 
-static int
-fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
+int fintek_8250_probe(struct uart_8250_port *uart)
 {
-	struct uart_8250_port uart;
 	struct fintek_8250 *pdata;
-	int base_port;
-	u8 key;
-	u8 index;
-
-	if (!pnp_port_valid(dev, 0))
-		return -ENODEV;
+	struct fintek_8250 probe_data;
 
-	base_port = fintek_8250_base_port(pnp_port_start(dev, 0), &key, &index);
-	if (base_port < 0)
+	if (find_base_port(&probe_data, uart->port.iobase))
 		return -ENODEV;
 
-	memset(&uart, 0, sizeof(uart));
-
-	pdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);
+	pdata = devm_kzalloc(uart->port.dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		return -ENOMEM;
-	uart.port.private_data = pdata;
 
-	if (!pnp_irq_valid(dev, 0))
-		return -ENODEV;
-	uart.port.irq = pnp_irq(dev, 0);
-	uart.port.iobase = pnp_port_start(dev, 0);
-	uart.port.iotype = UPIO_PORT;
-	uart.port.rs485_config = fintek_8250_rs485_config;
-
-	uart.port.flags |= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
-	if (pnp_irq_flags(dev, 0) & IORESOURCE_IRQ_SHAREABLE)
-		uart.port.flags |= UPF_SHARE_IRQ;
-	uart.port.uartclk = 1843200;
-	uart.port.dev = &dev->dev;
-
-	pdata->key = key;
-	pdata->base_port = base_port;
-	pdata->index = index;
-	pdata->line = serial8250_register_8250_port(&uart);
-	if (pdata->line < 0)
-		return -ENODEV;
+	memcpy(pdata, &probe_data, sizeof(probe_data));
+	uart->port.rs485_config = fintek_8250_rs485_config;
+	uart->port.private_data = pdata;
 
-	pnp_set_drvdata(dev, pdata);
 	return 0;
 }
-
-static void fintek_8250_remove(struct pnp_dev *dev)
-{
-	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
-
-	if (pdata)
-		serial8250_unregister_port(pdata->line);
-}
-
-#ifdef CONFIG_PM
-static int fintek_8250_suspend(struct pnp_dev *dev, pm_message_t state)
-{
-	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
-
-	if (!pdata)
-		return -ENODEV;
-	serial8250_suspend_port(pdata->line);
-	return 0;
-}
-
-static int fintek_8250_resume(struct pnp_dev *dev)
-{
-	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
-
-	if (!pdata)
-		return -ENODEV;
-	serial8250_resume_port(pdata->line);
-	return 0;
-}
-#else
-#define fintek_8250_suspend NULL
-#define fintek_8250_resume NULL
-#endif /* CONFIG_PM */
-
-static const struct pnp_device_id fintek_dev_table[] = {
-	/* Qtechnology Panel PC / IO1000 */
-	{ "PNP0501"},
-	{}
-};
-
-MODULE_DEVICE_TABLE(pnp, fintek_dev_table);
-
-static struct pnp_driver fintek_8250_driver = {
-	.name		= DRIVER_NAME,
-	.probe		= fintek_8250_probe,
-	.remove		= fintek_8250_remove,
-	.suspend	= fintek_8250_suspend,
-	.resume		= fintek_8250_resume,
-	.id_table	= fintek_dev_table,
-};
-
-module_pnp_driver(fintek_8250_driver);
-MODULE_DESCRIPTION("Fintek F812164 module");
-MODULE_AUTHOR("Ricardo Ribalda <ricardo.ribalda@gmail.com>");
-MODULE_LICENSE("GPL");

commit 29d58642f1a090ad574d14872b610b365b2d023b
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jun 16 10:59:40 2015 +0200

    serial/8250_fintek: Support for any io address.
    
    Fintek chip can be configured for io addresses different than the standard.
    
    Query the chip for the configured addresses and try to match it with the
    pnp address.
    
    Reported-by: Peter Hong <peter_hong@fintek.com.tw>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 5b916857671b..89474399ab89 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -28,6 +28,8 @@
 #define VENDOR_ID1_VAL 0x19
 #define VENDOR_ID2 0x24
 #define VENDOR_ID2_VAL 0x34
+#define IO_ADDR1 0x61
+#define IO_ADDR2 0x60
 #define LDN 0x7
 
 #define RS485  0xF0
@@ -63,18 +65,6 @@ static void fintek_8250_exit_key(u16 base_port)
 	release_region(base_port + ADDR_PORT, 2);
 }
 
-static int fintek_8250_get_index(resource_size_t base_addr)
-{
-	resource_size_t base[] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(base); i++)
-		if (base_addr == base[i])
-			return i;
-
-	return -ENODEV;
-}
-
 static int fintek_8250_check_id(u16 base_port)
 {
 	u16 chip;
@@ -148,24 +138,41 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	return 0;
 }
 
-static int fintek_8250_base_port(u8 *key)
+static int fintek_8250_base_port(u16 io_address, u8 *key, u8 *index)
 {
 	static const u16 addr[] = {0x4e, 0x2e};
 	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
-	int i, j;
+	int i, j, k;
 
 	for (i = 0; i < ARRAY_SIZE(addr); i++) {
 		for (j = 0; j < ARRAY_SIZE(keys); j++) {
-			int ret;
 
 			if (fintek_8250_enter_key(addr[i], keys[j]))
 				continue;
-			ret = fintek_8250_check_id(addr[i]);
-			fintek_8250_exit_key(addr[i]);
-			if (!ret) {
+			if (fintek_8250_check_id(addr[i])) {
+				fintek_8250_exit_key(addr[i]);
+				continue;
+			}
+
+			for (k = 0; k < 4; k++) {
+				u16 aux;
+
+				outb(LDN, addr[i] + ADDR_PORT);
+				outb(k, addr[i] + DATA_PORT);
+
+				outb(IO_ADDR1, addr[i] + ADDR_PORT);
+				aux = inb(addr[i] + DATA_PORT);
+				outb(IO_ADDR2, addr[i] + ADDR_PORT);
+				aux |= inb(addr[i] + DATA_PORT) << 8;
+				if (aux != io_address)
+					continue;
+
+				fintek_8250_exit_key(addr[i]);
 				*key = keys[j];
+				*index = k;
 				return addr[i];
 			}
+			fintek_8250_exit_key(addr[i]);
 		}
 	}
 
@@ -177,21 +184,17 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 {
 	struct uart_8250_port uart;
 	struct fintek_8250 *pdata;
-	int index;
 	int base_port;
 	u8 key;
+	u8 index;
 
 	if (!pnp_port_valid(dev, 0))
 		return -ENODEV;
 
-	base_port = fintek_8250_base_port(&key);
+	base_port = fintek_8250_base_port(pnp_port_start(dev, 0), &key, &index);
 	if (base_port < 0)
 		return -ENODEV;
 
-	index = fintek_8250_get_index(pnp_port_start(dev, 0));
-	if (index < 0)
-		return -ENODEV;
-
 	memset(&uart, 0, sizeof(uart));
 
 	pdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);

commit ce8c267e2ef9180d21f6915f21874898c2ac0ffb
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jun 16 10:59:39 2015 +0200

    serial/8250_fintek: Support keys different than default
    
    Chip can be configured to use entry key different than 0x77. Try all the
    valid keys until one gives out the right chip id.
    
    Reported-by: Peter Hong <peter_hong@fintek.com.tw>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 2c3228e84a2e..5b916857671b 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -19,7 +19,6 @@
 
 #define ADDR_PORT 0
 #define DATA_PORT 1
-#define ENTRY_KEY 0x77
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
 #define CHIP_ID2  0x21
@@ -42,17 +41,18 @@
 struct fintek_8250 {
 	u16 base_port;
 	u8 index;
+	u8 key;
 	long line;
 };
 
-static int fintek_8250_enter_key(u16 base_port)
+static int fintek_8250_enter_key(u16 base_port, u8 key)
 {
 
 	if (!request_muxed_region(base_port, 2, DRIVER_NAME))
 		return -EBUSY;
 
-	outb(ENTRY_KEY, base_port + ADDR_PORT);
-	outb(ENTRY_KEY, base_port + ADDR_PORT);
+	outb(key, base_port + ADDR_PORT);
+	outb(key, base_port + ADDR_PORT);
 	return 0;
 }
 
@@ -134,7 +134,7 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	if (rs485->flags & SER_RS485_RTS_ON_SEND)
 		config |= RTS_INVERT;
 
-	if (fintek_8250_enter_key(pdata->base_port))
+	if (fintek_8250_enter_key(pdata->base_port, pdata->key))
 		return -EBUSY;
 
 	outb(LDN, pdata->base_port + ADDR_PORT);
@@ -148,20 +148,25 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	return 0;
 }
 
-static int fintek_8250_base_port(void)
+static int fintek_8250_base_port(u8 *key)
 {
 	static const u16 addr[] = {0x4e, 0x2e};
-	int i;
+	static const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};
+	int i, j;
 
 	for (i = 0; i < ARRAY_SIZE(addr); i++) {
-		int ret;
-
-		if (fintek_8250_enter_key(addr[i]))
-			continue;
-		ret = fintek_8250_check_id(addr[i]);
-		fintek_8250_exit_key(addr[i]);
-		if (!ret)
-			return addr[i];
+		for (j = 0; j < ARRAY_SIZE(keys); j++) {
+			int ret;
+
+			if (fintek_8250_enter_key(addr[i], keys[j]))
+				continue;
+			ret = fintek_8250_check_id(addr[i]);
+			fintek_8250_exit_key(addr[i]);
+			if (!ret) {
+				*key = keys[j];
+				return addr[i];
+			}
+		}
 	}
 
 	return -ENODEV;
@@ -174,11 +179,12 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 	struct fintek_8250 *pdata;
 	int index;
 	int base_port;
+	u8 key;
 
 	if (!pnp_port_valid(dev, 0))
 		return -ENODEV;
 
-	base_port = fintek_8250_base_port();
+	base_port = fintek_8250_base_port(&key);
 	if (base_port < 0)
 		return -ENODEV;
 
@@ -206,6 +212,7 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 	uart.port.uartclk = 1843200;
 	uart.port.dev = &dev->dev;
 
+	pdata->key = key;
 	pdata->base_port = base_port;
 	pdata->index = index;
 	pdata->line = serial8250_register_8250_port(&uart);

commit dae77f757950c273500cc72262a094f290578bef
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jun 16 10:59:38 2015 +0200

    serial/8250_fintek: Support for chip_ip 0x0501
    
    There are some chips with the same interface but different chip ip.
    
    Reported-by: Peter Hong <peter_hong@fintek.com.tw>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 82b055b5a26d..2c3228e84a2e 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -22,9 +22,9 @@
 #define ENTRY_KEY 0x77
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
-#define CHIP_ID1_VAL 0x02
 #define CHIP_ID2  0x21
-#define CHIP_ID2_VAL 0x16
+#define CHIP_ID_0 0x1602
+#define CHIP_ID_1 0x0501
 #define VENDOR_ID1 0x23
 #define VENDOR_ID1_VAL 0x19
 #define VENDOR_ID2 0x24
@@ -77,14 +77,7 @@ static int fintek_8250_get_index(resource_size_t base_addr)
 
 static int fintek_8250_check_id(u16 base_port)
 {
-
-	outb(CHIP_ID1, base_port + ADDR_PORT);
-	if (inb(base_port + DATA_PORT) != CHIP_ID1_VAL)
-		return -ENODEV;
-
-	outb(CHIP_ID2, base_port + ADDR_PORT);
-	if (inb(base_port + DATA_PORT) != CHIP_ID2_VAL)
-		return -ENODEV;
+	u16 chip;
 
 	outb(VENDOR_ID1, base_port + ADDR_PORT);
 	if (inb(base_port + DATA_PORT) != VENDOR_ID1_VAL)
@@ -94,6 +87,14 @@ static int fintek_8250_check_id(u16 base_port)
 	if (inb(base_port + DATA_PORT) != VENDOR_ID2_VAL)
 		return -ENODEV;
 
+	outb(CHIP_ID1, base_port + ADDR_PORT);
+	chip = inb(base_port + DATA_PORT);
+	outb(CHIP_ID2, base_port + ADDR_PORT);
+	chip |= inb(base_port + DATA_PORT) << 8;
+
+	if (chip != CHIP_ID_0 && chip != CHIP_ID_1)
+		return -ENODEV;
+
 	return 0;
 }
 

commit 017bec38c08fc954fb788fe69cf9e55f0d4910e7
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jun 16 10:59:37 2015 +0200

    serial/8250_fintek: Support for multiple base_ports
    
    Fintek chip can be connected at address 0x4e and also 0x2e.
    Add some logic to find out the address of the chip.
    
    Reported-by: Peter Hong <peter_hong@fintek.com.tw>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 76d739bb5d1f..82b055b5a26d 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -17,8 +17,8 @@
 #include <linux/serial_core.h>
 #include  "8250.h"
 
-#define ADDR_PORT 0x4E
-#define DATA_PORT 0x4F
+#define ADDR_PORT 0
+#define DATA_PORT 1
 #define ENTRY_KEY 0x77
 #define EXIT_KEY 0xAA
 #define CHIP_ID1  0x20
@@ -40,24 +40,27 @@
 #define DRIVER_NAME "8250_fintek"
 
 struct fintek_8250 {
+	u16 base_port;
 	u8 index;
 	long line;
 };
 
-static int fintek_8250_enter_key(void){
+static int fintek_8250_enter_key(u16 base_port)
+{
 
-	if (!request_muxed_region(ADDR_PORT, 2, DRIVER_NAME))
+	if (!request_muxed_region(base_port, 2, DRIVER_NAME))
 		return -EBUSY;
 
-	outb(ENTRY_KEY, ADDR_PORT);
-	outb(ENTRY_KEY, ADDR_PORT);
+	outb(ENTRY_KEY, base_port + ADDR_PORT);
+	outb(ENTRY_KEY, base_port + ADDR_PORT);
 	return 0;
 }
 
-static void fintek_8250_exit_key(void){
+static void fintek_8250_exit_key(u16 base_port)
+{
 
-	outb(EXIT_KEY, ADDR_PORT);
-	release_region(ADDR_PORT, 2);
+	outb(EXIT_KEY, base_port + ADDR_PORT);
+	release_region(base_port + ADDR_PORT, 2);
 }
 
 static int fintek_8250_get_index(resource_size_t base_addr)
@@ -72,23 +75,23 @@ static int fintek_8250_get_index(resource_size_t base_addr)
 	return -ENODEV;
 }
 
-static int fintek_8250_check_id(void)
+static int fintek_8250_check_id(u16 base_port)
 {
 
-	outb(CHIP_ID1, ADDR_PORT);
-	if (inb(DATA_PORT) != CHIP_ID1_VAL)
+	outb(CHIP_ID1, base_port + ADDR_PORT);
+	if (inb(base_port + DATA_PORT) != CHIP_ID1_VAL)
 		return -ENODEV;
 
-	outb(CHIP_ID2, ADDR_PORT);
-	if (inb(DATA_PORT) != CHIP_ID2_VAL)
+	outb(CHIP_ID2, base_port + ADDR_PORT);
+	if (inb(base_port + DATA_PORT) != CHIP_ID2_VAL)
 		return -ENODEV;
 
-	outb(VENDOR_ID1, ADDR_PORT);
-	if (inb(DATA_PORT) != VENDOR_ID1_VAL)
+	outb(VENDOR_ID1, base_port + ADDR_PORT);
+	if (inb(base_port + DATA_PORT) != VENDOR_ID1_VAL)
 		return -ENODEV;
 
-	outb(VENDOR_ID2, ADDR_PORT);
-	if (inb(DATA_PORT) != VENDOR_ID2_VAL)
+	outb(VENDOR_ID2, base_port + ADDR_PORT);
+	if (inb(base_port + DATA_PORT) != VENDOR_ID2_VAL)
 		return -ENODEV;
 
 	return 0;
@@ -130,45 +133,58 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 	if (rs485->flags & SER_RS485_RTS_ON_SEND)
 		config |= RTS_INVERT;
 
-	if (fintek_8250_enter_key())
+	if (fintek_8250_enter_key(pdata->base_port))
 		return -EBUSY;
 
-	outb(LDN, ADDR_PORT);
-	outb(pdata->index, DATA_PORT);
-	outb(RS485, ADDR_PORT);
-	outb(config, DATA_PORT);
-	fintek_8250_exit_key();
+	outb(LDN, pdata->base_port + ADDR_PORT);
+	outb(pdata->index, pdata->base_port + DATA_PORT);
+	outb(RS485, pdata->base_port + ADDR_PORT);
+	outb(config, pdata->base_port + DATA_PORT);
+	fintek_8250_exit_key(pdata->base_port);
 
 	port->rs485 = *rs485;
 
 	return 0;
 }
 
+static int fintek_8250_base_port(void)
+{
+	static const u16 addr[] = {0x4e, 0x2e};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(addr); i++) {
+		int ret;
+
+		if (fintek_8250_enter_key(addr[i]))
+			continue;
+		ret = fintek_8250_check_id(addr[i]);
+		fintek_8250_exit_key(addr[i]);
+		if (!ret)
+			return addr[i];
+	}
+
+	return -ENODEV;
+}
+
 static int
 fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 {
 	struct uart_8250_port uart;
 	struct fintek_8250 *pdata;
-	int ret;
 	int index;
+	int base_port;
 
 	if (!pnp_port_valid(dev, 0))
 		return -ENODEV;
 
+	base_port = fintek_8250_base_port();
+	if (base_port < 0)
+		return -ENODEV;
+
 	index = fintek_8250_get_index(pnp_port_start(dev, 0));
 	if (index < 0)
 		return -ENODEV;
 
-	/* Enable configuration registers*/
-	if (fintek_8250_enter_key())
-		return -EBUSY;
-
-	/*Check ID*/
-	ret = fintek_8250_check_id();
-	fintek_8250_exit_key();
-	if (ret)
-		return ret;
-
 	memset(&uart, 0, sizeof(uart));
 
 	pdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);
@@ -189,6 +205,7 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 	uart.port.uartclk = 1843200;
 	uart.port.dev = &dev->dev;
 
+	pdata->base_port = base_port;
 	pdata->index = index;
 	pdata->line = serial8250_register_8250_port(&uart);
 	if (pdata->line < 0)

commit 92a5f11a1a3357964c30c34d55dc55152315b81b
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jun 16 10:59:36 2015 +0200

    serial/8250_fintek: Use private data structure
    
    Save the port index and the line id in a private structure.
    
    Reported-by: Peter Hong <peter_hong@fintek.com.tw>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 5815e81b5fc6..76d739bb5d1f 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -39,6 +39,11 @@
 
 #define DRIVER_NAME "8250_fintek"
 
+struct fintek_8250 {
+	u8 index;
+	long line;
+};
+
 static int fintek_8250_enter_key(void){
 
 	if (!request_muxed_region(ADDR_PORT, 2, DRIVER_NAME))
@@ -93,9 +98,9 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 			      struct serial_rs485 *rs485)
 {
 	uint8_t config = 0;
-	int index = fintek_8250_get_index(port->iobase);
+	struct fintek_8250 *pdata = port->private_data;
 
-	if (index < 0)
+	if (!pdata)
 		return -EINVAL;
 
 	if (rs485->flags & SER_RS485_ENABLED)
@@ -129,7 +134,7 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 		return -EBUSY;
 
 	outb(LDN, ADDR_PORT);
-	outb(index, DATA_PORT);
+	outb(pdata->index, DATA_PORT);
 	outb(RS485, ADDR_PORT);
 	outb(config, DATA_PORT);
 	fintek_8250_exit_key();
@@ -142,14 +147,16 @@ static int fintek_8250_rs485_config(struct uart_port *port,
 static int
 fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 {
-	int line;
 	struct uart_8250_port uart;
+	struct fintek_8250 *pdata;
 	int ret;
+	int index;
 
 	if (!pnp_port_valid(dev, 0))
 		return -ENODEV;
 
-	if (fintek_8250_get_index(pnp_port_start(dev, 0)) < 0)
+	index = fintek_8250_get_index(pnp_port_start(dev, 0));
+	if (index < 0)
 		return -ENODEV;
 
 	/* Enable configuration registers*/
@@ -163,6 +170,12 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 		return ret;
 
 	memset(&uart, 0, sizeof(uart));
+
+	pdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+	uart.port.private_data = pdata;
+
 	if (!pnp_irq_valid(dev, 0))
 		return -ENODEV;
 	uart.port.irq = pnp_irq(dev, 0);
@@ -176,40 +189,41 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 	uart.port.uartclk = 1843200;
 	uart.port.dev = &dev->dev;
 
-	line = serial8250_register_8250_port(&uart);
-	if (line < 0)
+	pdata->index = index;
+	pdata->line = serial8250_register_8250_port(&uart);
+	if (pdata->line < 0)
 		return -ENODEV;
 
-	pnp_set_drvdata(dev, (void *)((long)line + 1));
+	pnp_set_drvdata(dev, pdata);
 	return 0;
 }
 
 static void fintek_8250_remove(struct pnp_dev *dev)
 {
-	long line = (long)pnp_get_drvdata(dev);
+	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
 
-	if (line)
-		serial8250_unregister_port(line - 1);
+	if (pdata)
+		serial8250_unregister_port(pdata->line);
 }
 
 #ifdef CONFIG_PM
 static int fintek_8250_suspend(struct pnp_dev *dev, pm_message_t state)
 {
-	long line = (long)pnp_get_drvdata(dev);
+	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
 
-	if (!line)
+	if (!pdata)
 		return -ENODEV;
-	serial8250_suspend_port(line - 1);
+	serial8250_suspend_port(pdata->line);
 	return 0;
 }
 
 static int fintek_8250_resume(struct pnp_dev *dev)
 {
-	long line = (long)pnp_get_drvdata(dev);
+	struct fintek_8250 *pdata = pnp_get_drvdata(dev);
 
-	if (!line)
+	if (!pdata)
 		return -ENODEV;
-	serial8250_resume_port(line - 1);
+	serial8250_resume_port(pdata->line);
 	return 0;
 }
 #else

commit aee94467d9858b5441c278ffa39dcd19bef548cf
Author: Peter Huewe <PeterHuewe@gmx.de>
Date:   Mon Mar 16 21:46:37 2015 +0100

    PNP: tty/serial/8250/8250_fintek: Use module_pnp_driver to register driver
    
    Removing some boilerplate by using module_pnp_driver instead of calling
    register and unregister in the otherwise empty init/exit functions
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 1e6899bc9429..5815e81b5fc6 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -234,18 +234,7 @@ static struct pnp_driver fintek_8250_driver = {
 	.id_table	= fintek_dev_table,
 };
 
-static int fintek_8250_init(void)
-{
-	return pnp_register_driver(&fintek_8250_driver);
-}
-module_init(fintek_8250_init);
-
-static void fintek_8250_exit(void)
-{
-	pnp_unregister_driver(&fintek_8250_driver);
-}
-module_exit(fintek_8250_exit);
-
+module_pnp_driver(fintek_8250_driver);
 MODULE_DESCRIPTION("Fintek F812164 module");
 MODULE_AUTHOR("Ricardo Ribalda <ricardo.ribalda@gmail.com>");
 MODULE_LICENSE("GPL");

commit 41e69093fd608c0348fb12c0879ab464f986d2a8
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Thu Nov 6 09:22:52 2014 +0100

    8250/fintek: Use rs485 handler from serial_core
    
    In order to remove the handler for rs485 ioctls on serial_8250, all the
    drivers must use the implementation on serial_core.
    
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 1bb28cb69493..1e6899bc9429 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -89,11 +89,11 @@ static int fintek_8250_check_id(void)
 	return 0;
 }
 
-static int fintek_8250_rs4850_config(struct uart_8250_port *uart,
+static int fintek_8250_rs485_config(struct uart_port *port,
 			      struct serial_rs485 *rs485)
 {
 	uint8_t config = 0;
-	int index = fintek_8250_get_index(uart->port.iobase);
+	int index = fintek_8250_get_index(port->iobase);
 
 	if (index < 0)
 		return -EINVAL;
@@ -134,6 +134,8 @@ static int fintek_8250_rs4850_config(struct uart_8250_port *uart,
 	outb(config, DATA_PORT);
 	fintek_8250_exit_key();
 
+	port->rs485 = *rs485;
+
 	return 0;
 }
 
@@ -166,7 +168,7 @@ fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 	uart.port.irq = pnp_irq(dev, 0);
 	uart.port.iobase = pnp_port_start(dev, 0);
 	uart.port.iotype = UPIO_PORT;
-	uart.rs485_config = fintek_8250_rs4850_config;
+	uart.port.rs485_config = fintek_8250_rs485_config;
 
 	uart.port.flags |= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
 	if (pnp_irq_flags(dev, 0) & IORESOURCE_IRQ_SHAREABLE)

commit 28e3fb6c4dce76d59a76755c4360d1cd5e0e226c
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Thu Jul 31 21:22:26 2014 +0200

    serial: Add support for Fintek F81216A LPC to 4 UART
    
    This patch lets you set the RS485 cappabilites of the device through
    TIOCSRS485 and TIOCGRS485 as defined on Documentation/serial/serial-rs485.txt
    
    In order to probe the device, the PNP id and the device id is used.
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
new file mode 100644
index 000000000000..1bb28cb69493
--- /dev/null
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -0,0 +1,249 @@
+/*
+ *  Probe for F81216A LPC to 4 UART
+ *
+ *  Based on drivers/tty/serial/8250_pnp.c, by Russell King, et al
+ *
+ *  Copyright (C) 2014 Ricardo Ribalda, Qtechnology A/S
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pnp.h>
+#include <linux/kernel.h>
+#include <linux/serial_core.h>
+#include  "8250.h"
+
+#define ADDR_PORT 0x4E
+#define DATA_PORT 0x4F
+#define ENTRY_KEY 0x77
+#define EXIT_KEY 0xAA
+#define CHIP_ID1  0x20
+#define CHIP_ID1_VAL 0x02
+#define CHIP_ID2  0x21
+#define CHIP_ID2_VAL 0x16
+#define VENDOR_ID1 0x23
+#define VENDOR_ID1_VAL 0x19
+#define VENDOR_ID2 0x24
+#define VENDOR_ID2_VAL 0x34
+#define LDN 0x7
+
+#define RS485  0xF0
+#define RTS_INVERT BIT(5)
+#define RS485_URA BIT(4)
+#define RXW4C_IRA BIT(3)
+#define TXW4C_IRA BIT(2)
+
+#define DRIVER_NAME "8250_fintek"
+
+static int fintek_8250_enter_key(void){
+
+	if (!request_muxed_region(ADDR_PORT, 2, DRIVER_NAME))
+		return -EBUSY;
+
+	outb(ENTRY_KEY, ADDR_PORT);
+	outb(ENTRY_KEY, ADDR_PORT);
+	return 0;
+}
+
+static void fintek_8250_exit_key(void){
+
+	outb(EXIT_KEY, ADDR_PORT);
+	release_region(ADDR_PORT, 2);
+}
+
+static int fintek_8250_get_index(resource_size_t base_addr)
+{
+	resource_size_t base[] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(base); i++)
+		if (base_addr == base[i])
+			return i;
+
+	return -ENODEV;
+}
+
+static int fintek_8250_check_id(void)
+{
+
+	outb(CHIP_ID1, ADDR_PORT);
+	if (inb(DATA_PORT) != CHIP_ID1_VAL)
+		return -ENODEV;
+
+	outb(CHIP_ID2, ADDR_PORT);
+	if (inb(DATA_PORT) != CHIP_ID2_VAL)
+		return -ENODEV;
+
+	outb(VENDOR_ID1, ADDR_PORT);
+	if (inb(DATA_PORT) != VENDOR_ID1_VAL)
+		return -ENODEV;
+
+	outb(VENDOR_ID2, ADDR_PORT);
+	if (inb(DATA_PORT) != VENDOR_ID2_VAL)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int fintek_8250_rs4850_config(struct uart_8250_port *uart,
+			      struct serial_rs485 *rs485)
+{
+	uint8_t config = 0;
+	int index = fintek_8250_get_index(uart->port.iobase);
+
+	if (index < 0)
+		return -EINVAL;
+
+	if (rs485->flags & SER_RS485_ENABLED)
+		memset(rs485->padding, 0, sizeof(rs485->padding));
+	else
+		memset(rs485, 0, sizeof(*rs485));
+
+	rs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |
+			SER_RS485_RTS_AFTER_SEND;
+
+	if (rs485->delay_rts_before_send) {
+		rs485->delay_rts_before_send = 1;
+		config |= TXW4C_IRA;
+	}
+
+	if (rs485->delay_rts_after_send) {
+		rs485->delay_rts_after_send = 1;
+		config |= RXW4C_IRA;
+	}
+
+	if ((!!(rs485->flags & SER_RS485_RTS_ON_SEND)) ==
+			(!!(rs485->flags & SER_RS485_RTS_AFTER_SEND)))
+		rs485->flags &= SER_RS485_ENABLED;
+	else
+		config |= RS485_URA;
+
+	if (rs485->flags & SER_RS485_RTS_ON_SEND)
+		config |= RTS_INVERT;
+
+	if (fintek_8250_enter_key())
+		return -EBUSY;
+
+	outb(LDN, ADDR_PORT);
+	outb(index, DATA_PORT);
+	outb(RS485, ADDR_PORT);
+	outb(config, DATA_PORT);
+	fintek_8250_exit_key();
+
+	return 0;
+}
+
+static int
+fintek_8250_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
+{
+	int line;
+	struct uart_8250_port uart;
+	int ret;
+
+	if (!pnp_port_valid(dev, 0))
+		return -ENODEV;
+
+	if (fintek_8250_get_index(pnp_port_start(dev, 0)) < 0)
+		return -ENODEV;
+
+	/* Enable configuration registers*/
+	if (fintek_8250_enter_key())
+		return -EBUSY;
+
+	/*Check ID*/
+	ret = fintek_8250_check_id();
+	fintek_8250_exit_key();
+	if (ret)
+		return ret;
+
+	memset(&uart, 0, sizeof(uart));
+	if (!pnp_irq_valid(dev, 0))
+		return -ENODEV;
+	uart.port.irq = pnp_irq(dev, 0);
+	uart.port.iobase = pnp_port_start(dev, 0);
+	uart.port.iotype = UPIO_PORT;
+	uart.rs485_config = fintek_8250_rs4850_config;
+
+	uart.port.flags |= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
+	if (pnp_irq_flags(dev, 0) & IORESOURCE_IRQ_SHAREABLE)
+		uart.port.flags |= UPF_SHARE_IRQ;
+	uart.port.uartclk = 1843200;
+	uart.port.dev = &dev->dev;
+
+	line = serial8250_register_8250_port(&uart);
+	if (line < 0)
+		return -ENODEV;
+
+	pnp_set_drvdata(dev, (void *)((long)line + 1));
+	return 0;
+}
+
+static void fintek_8250_remove(struct pnp_dev *dev)
+{
+	long line = (long)pnp_get_drvdata(dev);
+
+	if (line)
+		serial8250_unregister_port(line - 1);
+}
+
+#ifdef CONFIG_PM
+static int fintek_8250_suspend(struct pnp_dev *dev, pm_message_t state)
+{
+	long line = (long)pnp_get_drvdata(dev);
+
+	if (!line)
+		return -ENODEV;
+	serial8250_suspend_port(line - 1);
+	return 0;
+}
+
+static int fintek_8250_resume(struct pnp_dev *dev)
+{
+	long line = (long)pnp_get_drvdata(dev);
+
+	if (!line)
+		return -ENODEV;
+	serial8250_resume_port(line - 1);
+	return 0;
+}
+#else
+#define fintek_8250_suspend NULL
+#define fintek_8250_resume NULL
+#endif /* CONFIG_PM */
+
+static const struct pnp_device_id fintek_dev_table[] = {
+	/* Qtechnology Panel PC / IO1000 */
+	{ "PNP0501"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(pnp, fintek_dev_table);
+
+static struct pnp_driver fintek_8250_driver = {
+	.name		= DRIVER_NAME,
+	.probe		= fintek_8250_probe,
+	.remove		= fintek_8250_remove,
+	.suspend	= fintek_8250_suspend,
+	.resume		= fintek_8250_resume,
+	.id_table	= fintek_dev_table,
+};
+
+static int fintek_8250_init(void)
+{
+	return pnp_register_driver(&fintek_8250_driver);
+}
+module_init(fintek_8250_init);
+
+static void fintek_8250_exit(void)
+{
+	pnp_unregister_driver(&fintek_8250_driver);
+}
+module_exit(fintek_8250_exit);
+
+MODULE_DESCRIPTION("Fintek F812164 module");
+MODULE_AUTHOR("Ricardo Ribalda <ricardo.ribalda@gmail.com>");
+MODULE_LICENSE("GPL");
