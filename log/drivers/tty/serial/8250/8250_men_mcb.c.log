commit 891e60368ba1840c1b8bbc72beb1da0dae289430
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Oct 16 12:01:58 2019 +0200

    drivers: mcb: use symbol namespaces
    
    Now that we have symbol namespaces, use them in MCB to not pollute the
    default namespace with MCB internals.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Jessica Yu <jeyu@kernel.org>
    Reviewed-by: Michael Moese <mmoese@suse.de>
    Link: https://lore.kernel.org/r/20191016100158.1400-1-jthumshirn@suse.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_men_mcb.c b/drivers/tty/serial/8250/8250_men_mcb.c
index 8df89e9cd254..e985f344b2dd 100644
--- a/drivers/tty/serial/8250/8250_men_mcb.c
+++ b/drivers/tty/serial/8250/8250_men_mcb.c
@@ -174,3 +174,4 @@ MODULE_AUTHOR("Michael Moese <michael.moese@men.de");
 MODULE_ALIAS("mcb:16z125");
 MODULE_ALIAS("mcb:16z025");
 MODULE_ALIAS("mcb:16z057");
+MODULE_IMPORT_NS(MCB);

commit f50b6805dbb993152025ec04dea094c40cc93a0c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Oct 13 23:00:16 2019 +0100

    8250-men-mcb: fix error checking when get_num_ports returns -ENODEV
    
    The current checking for failure on the number of ports fails when
    -ENODEV is returned from the call to get_num_ports. Fix this by making
    num_ports and loop counter i signed rather than unsigned ints. Also
    add check for num_ports being less than zero to check for -ve error
    returns.
    
    Addresses-Coverity: ("Unsigned compared against 0")
    Fixes: e2fea54e4592 ("8250-men-mcb: add support for 16z025 and 16z057")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Michael Moese <mmoese@suse.de>
    Link: https://lore.kernel.org/r/20191013220016.9369-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_men_mcb.c b/drivers/tty/serial/8250/8250_men_mcb.c
index 02c5aff58a74..8df89e9cd254 100644
--- a/drivers/tty/serial/8250/8250_men_mcb.c
+++ b/drivers/tty/serial/8250/8250_men_mcb.c
@@ -72,8 +72,8 @@ static int serial_8250_men_mcb_probe(struct mcb_device *mdev,
 {
 	struct serial_8250_men_mcb_data *data;
 	struct resource *mem;
-	unsigned int num_ports;
-	unsigned int i;
+	int num_ports;
+	int i;
 	void __iomem *membase;
 
 	mem = mcb_get_resource(mdev, IORESOURCE_MEM);
@@ -88,7 +88,7 @@ static int serial_8250_men_mcb_probe(struct mcb_device *mdev,
 	dev_dbg(&mdev->dev, "found a 16z%03u with %u ports\n",
 		mdev->id, num_ports);
 
-	if (num_ports == 0 || num_ports > 4) {
+	if (num_ports <= 0 || num_ports > 4) {
 		dev_err(&mdev->dev, "unexpected number of ports: %u\n",
 			num_ports);
 		return -ENODEV;
@@ -133,7 +133,7 @@ static int serial_8250_men_mcb_probe(struct mcb_device *mdev,
 
 static void serial_8250_men_mcb_remove(struct mcb_device *mdev)
 {
-	unsigned int num_ports, i;
+	int num_ports, i;
 	struct serial_8250_men_mcb_data *data = mcb_get_drvdata(mdev);
 
 	if (!data)

commit f16aa97d3f575ea660f49d4698efe1c4a4c60919
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 16:07:08 2019 +0200

    tty: fix up a few remaining files without SPDX identifiers
    
    There were a few straggling files under drivers/tty/ that did not have
    any SPDX identifier either because they entered the tree recently, or
    they somehow missed the mass-tagging of commit b24413180f56 ("License
    cleanup: add SPDX GPL-2.0 license identifier to files with no license")
    
    This commit follows the same rule as b24413180f56 ("License cleanup: add
    SPDX GPL-2.0 license identifier to files with no license") where files
    without any specified license in them fall under GPL-2.0 as the correct
    license for the individual file.  Add that identifier to these remaining
    files so that we don't have to guess at the license of them in the
    future.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_men_mcb.c b/drivers/tty/serial/8250/8250_men_mcb.c
index 127017cc41d9..02c5aff58a74 100644
--- a/drivers/tty/serial/8250/8250_men_mcb.c
+++ b/drivers/tty/serial/8250/8250_men_mcb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/module.h>

commit e2fea54e4592b5dccd97fc338d12bba95a2d16f0
Author: Michael Moese <mmoese@suse.de>
Date:   Mon Mar 5 16:24:21 2018 +0100

    8250-men-mcb: add support for 16z025 and 16z057
    
    Add support for two MEN UARTs (16z025 and 16z057) to the
    8250_men_mcb driver.
    The 16z025 consists of up to four ports, the 16z057 has
    exactly four ports. Apart from that, all of them share the
    Port settings.
    
    Signed-off-by: Michael Moese <mmoese@suse.de>
    Reported-by: Ben Turner <ben.turner@21net.com>
    Tested-by: Ben Turner <ben.turner@21net.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_men_mcb.c b/drivers/tty/serial/8250/8250_men_mcb.c
index 308977807994..127017cc41d9 100644
--- a/drivers/tty/serial/8250/8250_men_mcb.c
+++ b/drivers/tty/serial/8250/8250_men_mcb.c
@@ -1,12 +1,19 @@
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/io.h>
 #include <linux/mcb.h>
 #include <linux/serial.h>
 #include <linux/serial_core.h>
 #include <linux/serial_8250.h>
 #include <uapi/linux/serial_core.h>
 
+#define MEN_UART_ID_Z025 0x19
+#define MEN_UART_ID_Z057 0x39
+#define MEN_UART_ID_Z125 0x7d
+
+#define MEN_UART_MEM_SIZE 0x10
+
 struct serial_8250_men_mcb_data {
 	struct uart_8250_port uart;
 	int line;
@@ -18,7 +25,7 @@ struct serial_8250_men_mcb_data {
  * parameter in order to really set the correct baudrate, and
  * do so if possible without user interaction
  */
-static u32 men_z125_lookup_uartclk(struct mcb_device *mdev)
+static u32 men_lookup_uartclk(struct mcb_device *mdev)
 {
 	/* use default value if board is not available below */
 	u32 clkval = 1041666;
@@ -28,10 +35,12 @@ static u32 men_z125_lookup_uartclk(struct mcb_device *mdev)
 		mdev->bus->name);
 	if  (strncmp(mdev->bus->name, "F075", 4) == 0)
 		clkval = 1041666;
-	else if  (strncmp(mdev->bus->name, "F216", 4) == 0)
+	else if (strncmp(mdev->bus->name, "F216", 4) == 0)
 		clkval = 1843200;
 	else if (strncmp(mdev->bus->name, "G215", 4) == 0)
 		clkval = 1843200;
+	else if (strncmp(mdev->bus->name, "F210", 4) == 0)
+		clkval = 115200;
 	else
 		dev_info(&mdev->dev,
 			 "board not detected, using default uartclk\n");
@@ -41,62 +50,108 @@ static u32 men_z125_lookup_uartclk(struct mcb_device *mdev)
 	return clkval;
 }
 
+static unsigned int get_num_ports(struct mcb_device *mdev,
+				  void __iomem *membase)
+{
+	switch (mdev->id) {
+	case MEN_UART_ID_Z125:
+		return 1U;
+	case MEN_UART_ID_Z025:
+		return readb(membase) >> 4;
+	case MEN_UART_ID_Z057:
+		return 4U;
+	default:
+		dev_err(&mdev->dev, "no supported device!\n");
+		return -ENODEV;
+	}
+}
+
 static int serial_8250_men_mcb_probe(struct mcb_device *mdev,
 				     const struct mcb_device_id *id)
 {
 	struct serial_8250_men_mcb_data *data;
 	struct resource *mem;
-
-	data = devm_kzalloc(&mdev->dev,
-			    sizeof(struct serial_8250_men_mcb_data),
-			    GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
-
-	mcb_set_drvdata(mdev, data);
-	data->uart.port.dev = mdev->dma_dev;
-	spin_lock_init(&data->uart.port.lock);
-
-	data->uart.port.type = PORT_16550;
-	data->uart.port.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
-	data->uart.port.iotype = UPIO_MEM;
-	data->uart.port.uartclk = men_z125_lookup_uartclk(mdev);
-	data->uart.port.regshift = 0;
-	data->uart.port.fifosize = 60;
+	unsigned int num_ports;
+	unsigned int i;
+	void __iomem *membase;
 
 	mem = mcb_get_resource(mdev, IORESOURCE_MEM);
 	if (mem == NULL)
 		return -ENXIO;
+	membase = devm_ioremap_resource(&mdev->dev, mem);
+	if (IS_ERR(membase))
+		return PTR_ERR_OR_ZERO(membase);
 
-	data->uart.port.irq = mcb_get_irq(mdev);
+	num_ports = get_num_ports(mdev, membase);
 
-	data->uart.port.membase = devm_ioremap_resource(&mdev->dev, mem);
-	if (IS_ERR(data->uart.port.membase))
-		return PTR_ERR_OR_ZERO(data->uart.port.membase);
+	dev_dbg(&mdev->dev, "found a 16z%03u with %u ports\n",
+		mdev->id, num_ports);
 
-	data->uart.port.mapbase = (unsigned long) mem->start;
-	data->uart.port.iobase = data->uart.port.mapbase;
+	if (num_ports == 0 || num_ports > 4) {
+		dev_err(&mdev->dev, "unexpected number of ports: %u\n",
+			num_ports);
+		return -ENODEV;
+	}
 
-	/* ok, register the port */
-	data->line = serial8250_register_8250_port(&data->uart);
-	if (data->line < 0)
-		return data->line;
+	data = devm_kcalloc(&mdev->dev, num_ports,
+			    sizeof(struct serial_8250_men_mcb_data),
+			    GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
-	dev_info(&mdev->dev, "found 16Z125 UART: ttyS%d\n", data->line);
+	mcb_set_drvdata(mdev, data);
+
+	for (i = 0; i < num_ports; i++) {
+		data[i].uart.port.dev = mdev->dma_dev;
+		spin_lock_init(&data[i].uart.port.lock);
+
+		data[i].uart.port.type = PORT_16550;
+		data[i].uart.port.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ
+					  | UPF_FIXED_TYPE;
+		data[i].uart.port.iotype = UPIO_MEM;
+		data[i].uart.port.uartclk = men_lookup_uartclk(mdev);
+		data[i].uart.port.regshift = 0;
+		data[i].uart.port.irq = mcb_get_irq(mdev);
+		data[i].uart.port.membase = membase;
+		data[i].uart.port.fifosize = 60;
+		data[i].uart.port.mapbase = (unsigned long) mem->start
+					    + i * MEN_UART_MEM_SIZE;
+		data[i].uart.port.iobase = data[i].uart.port.mapbase;
+
+		/* ok, register the port */
+		data[i].line = serial8250_register_8250_port(&data[i].uart);
+		if (data[i].line < 0) {
+			dev_err(&mdev->dev, "unable to register UART port\n");
+			return data[i].line;
+		}
+		dev_info(&mdev->dev, "found MCB UART: ttyS%d\n", data[i].line);
+	}
 
 	return 0;
 }
 
 static void serial_8250_men_mcb_remove(struct mcb_device *mdev)
 {
+	unsigned int num_ports, i;
 	struct serial_8250_men_mcb_data *data = mcb_get_drvdata(mdev);
 
-	if (data)
-		serial8250_unregister_port(data->line);
+	if (!data)
+		return;
+
+	num_ports = get_num_ports(mdev, data[0].uart.port.membase);
+	if (num_ports < 0 || num_ports > 4) {
+		dev_err(&mdev->dev, "error retrieving number of ports!\n");
+		return;
+	}
+
+	for (i = 0; i < num_ports; i++)
+		serial8250_unregister_port(data[i].line);
 }
 
 static const struct mcb_device_id serial_8250_men_mcb_ids[] = {
-	{ .device = 0x7d },
+	{ .device = MEN_UART_ID_Z025 },
+	{ .device = MEN_UART_ID_Z057 },
+	{ .device = MEN_UART_ID_Z125 },
 	{ }
 };
 MODULE_DEVICE_TABLE(mcb, serial_8250_men_mcb_ids);
@@ -113,6 +168,8 @@ static struct mcb_driver mcb_driver = {
 module_mcb_driver(mcb_driver);
 
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("MEN 16z125 8250 UART driver");
+MODULE_DESCRIPTION("MEN 8250 UART driver");
 MODULE_AUTHOR("Michael Moese <michael.moese@men.de");
 MODULE_ALIAS("mcb:16z125");
+MODULE_ALIAS("mcb:16z025");
+MODULE_ALIAS("mcb:16z057");

commit 562e6ef81f9b3dadeb7d05a6055e502d43caa830
Author: Michael Moese <michael.moese@men.de>
Date:   Wed Aug 2 09:58:53 2017 +0200

    Introduce 8250_men_mcb
    
    This patch introduces the 8250_men_mcb driver for the MEN 16Z125
    IP-Core. This is a 16550-type UART with a 60 byte FIFO.
    Due to strange old hardware, every board using this IP core requires
    different values for uartclk. A reasonable default is included in
    addition to the support of three boards. Additional values for other
    boards will be added later.
    
    This v2 has some whitespace fixes, I screwed this up yesterday.
    
    Signed-off-by: Michael Moese <michael.moese@men.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/8250/8250_men_mcb.c b/drivers/tty/serial/8250/8250_men_mcb.c
new file mode 100644
index 000000000000..308977807994
--- /dev/null
+++ b/drivers/tty/serial/8250/8250_men_mcb.c
@@ -0,0 +1,118 @@
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mcb.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <uapi/linux/serial_core.h>
+
+struct serial_8250_men_mcb_data {
+	struct uart_8250_port uart;
+	int line;
+};
+
+/*
+ * The Z125 16550-compatible UART has no fixed base clock assigned
+ * So, depending on the board we're on, we need to adjust the
+ * parameter in order to really set the correct baudrate, and
+ * do so if possible without user interaction
+ */
+static u32 men_z125_lookup_uartclk(struct mcb_device *mdev)
+{
+	/* use default value if board is not available below */
+	u32 clkval = 1041666;
+
+	dev_info(&mdev->dev, "%s on board %s\n",
+		dev_name(&mdev->dev),
+		mdev->bus->name);
+	if  (strncmp(mdev->bus->name, "F075", 4) == 0)
+		clkval = 1041666;
+	else if  (strncmp(mdev->bus->name, "F216", 4) == 0)
+		clkval = 1843200;
+	else if (strncmp(mdev->bus->name, "G215", 4) == 0)
+		clkval = 1843200;
+	else
+		dev_info(&mdev->dev,
+			 "board not detected, using default uartclk\n");
+
+	clkval = clkval  << 4;
+
+	return clkval;
+}
+
+static int serial_8250_men_mcb_probe(struct mcb_device *mdev,
+				     const struct mcb_device_id *id)
+{
+	struct serial_8250_men_mcb_data *data;
+	struct resource *mem;
+
+	data = devm_kzalloc(&mdev->dev,
+			    sizeof(struct serial_8250_men_mcb_data),
+			    GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mcb_set_drvdata(mdev, data);
+	data->uart.port.dev = mdev->dma_dev;
+	spin_lock_init(&data->uart.port.lock);
+
+	data->uart.port.type = PORT_16550;
+	data->uart.port.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
+	data->uart.port.iotype = UPIO_MEM;
+	data->uart.port.uartclk = men_z125_lookup_uartclk(mdev);
+	data->uart.port.regshift = 0;
+	data->uart.port.fifosize = 60;
+
+	mem = mcb_get_resource(mdev, IORESOURCE_MEM);
+	if (mem == NULL)
+		return -ENXIO;
+
+	data->uart.port.irq = mcb_get_irq(mdev);
+
+	data->uart.port.membase = devm_ioremap_resource(&mdev->dev, mem);
+	if (IS_ERR(data->uart.port.membase))
+		return PTR_ERR_OR_ZERO(data->uart.port.membase);
+
+	data->uart.port.mapbase = (unsigned long) mem->start;
+	data->uart.port.iobase = data->uart.port.mapbase;
+
+	/* ok, register the port */
+	data->line = serial8250_register_8250_port(&data->uart);
+	if (data->line < 0)
+		return data->line;
+
+	dev_info(&mdev->dev, "found 16Z125 UART: ttyS%d\n", data->line);
+
+	return 0;
+}
+
+static void serial_8250_men_mcb_remove(struct mcb_device *mdev)
+{
+	struct serial_8250_men_mcb_data *data = mcb_get_drvdata(mdev);
+
+	if (data)
+		serial8250_unregister_port(data->line);
+}
+
+static const struct mcb_device_id serial_8250_men_mcb_ids[] = {
+	{ .device = 0x7d },
+	{ }
+};
+MODULE_DEVICE_TABLE(mcb, serial_8250_men_mcb_ids);
+
+static struct mcb_driver mcb_driver = {
+	.driver = {
+		.name = "8250_men_mcb",
+		.owner = THIS_MODULE,
+	},
+	.probe = serial_8250_men_mcb_probe,
+	.remove = serial_8250_men_mcb_remove,
+	.id_table = serial_8250_men_mcb_ids,
+};
+module_mcb_driver(mcb_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("MEN 16z125 8250 UART driver");
+MODULE_AUTHOR("Michael Moese <michael.moese@men.de");
+MODULE_ALIAS("mcb:16z125");
