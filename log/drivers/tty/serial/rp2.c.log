commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index 520b43b23543..5690c09cc041 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -774,7 +774,7 @@ static int rp2_probe(struct pci_dev *pdev,
 
 	rp2_init_card(card);
 
-	ports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,
+	ports = devm_kcalloc(&pdev->dev, card->n_ports, sizeof(*ports),
 			     GFP_KERNEL);
 	if (!ports)
 		return -ENOMEM;

commit 4793f2ebff1c890386a514998606205a2948011c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:52 2017 +0100

    tty: serial: Remove redundant license text
    
    Now that the SPDX tag is in all tty files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index 2108bf34ff90..520b43b23543 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -11,10 +11,6 @@
  *
  *   rocketport_infinity_express-linux-1.20.tar.gz
  *     Copyright (C) 2004-2011 Comtrol, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
  */
 
 #include <linux/bitops.h>

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index 056f91b3a4ca..2108bf34ff90 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Driver for Comtrol RocketPort EXPRESS/INFINITY cards
  *

commit 311df74ade503af204ac6b8ee55ce30ff2411398
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:37 2013 +0900

    tty: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index 328d6deb6b08..056f91b3a4ca 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -810,7 +810,7 @@ static void rp2_remove(struct pci_dev *pdev)
 	rp2_remove_ports(card);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(rp2_pci_tbl) = {
+static const struct pci_device_id rp2_pci_tbl[] = {
 
 	/* RocketPort INFINITY cards */
 

commit de7053c77123940ac294508d2161f42063d4166a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 19 20:14:24 2013 +0530

    tty: serial: rp2: drop uart_port->lock before calling tty_flip_buffer_push()
    
    The current driver triggers a lockdep warning for if tty_flip_buffer_push() is
    called with uart_port->lock locked. This never shows up on UP kernels and comes
    up only on SMP kernels.
    
    Crash looks like this (produced with samsung.c driver):
    
    -----
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8)
    [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8) from [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0)
    [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0x38) from [<c020a1a8>] (s3c24xx_serial_rx_chars+0)
    [<c020a1a8>] (s3c24xx_serial_rx_chars+0x12c/0x260) from [<c020aae8>] (s3c64xx_serial_handle_irq+)
    [<c020aae8>] (s3c64xx_serial_handle_irq+0x48/0x60) from [<c006aaa0>] (handle_irq_event_percpu+0x)
    [<c006aaa0>] (handle_irq_event_percpu+0x50/0x194) from [<c006ac20>] (handle_irq_event+0x3c/0x5c)
    [<c006ac20>] (handle_irq_event+0x3c/0x5c) from [<c006d864>] (handle_fasteoi_irq+0x80/0x13c)
    [<c006d864>] (handle_fasteoi_irq+0x80/0x13c) from [<c006a4a4>] (generic_handle_irq+0x20/0x30)
    [<c006a4a4>] (generic_handle_irq+0x20/0x30) from [<c000f454>] (handle_IRQ+0x38/0x94)
    [<c000f454>] (handle_IRQ+0x38/0x94) from [<c0008538>] (gic_handle_irq+0x34/0x68)
    [<c0008538>] (gic_handle_irq+0x34/0x68) from [<c00123c0>] (__irq_svc+0x40/0x70)
    Exception stack(0xc04cdf70 to 0xc04cdfb8)
    df60:                                     00000000 00000000 0000166e 00000000
    df80: c04cc000 c050278f c050278f 00000001 c04d444c 410fc0f4 c03649b0 00000000
    dfa0: 00000001 c04cdfb8 c000f758 c000f75c 60070013 ffffffff
    [<c00123c0>] (__irq_svc+0x40/0x70) from [<c000f75c>] (arch_cpu_idle+0x28/0x30)
    [<c000f75c>] (arch_cpu_idle+0x28/0x30) from [<c0054888>] (cpu_startup_entry+0x5c/0x148)
    [<c0054888>] (cpu_startup_entry+0x5c/0x148) from [<c0497aa4>] (start_kernel+0x334/0x38c)
    BUG: spinlock lockup suspected on CPU#0, kworker/0:1/360
     lock: s3c24xx_serial_ports+0x1d8/0x370, .magic: dead4ead, .owner: <none>/-1, .owner_cpu: -1
    CPU: 0 PID: 360 Comm: kworker/0:1 Not tainted 3.11.0-rc6-next-20130819-00003-g75485f1 #2
    Workqueue: events flush_to_ldisc
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b581c>] (do_raw_spin_lock+0x100/0x17c)
    [<c01b581c>] (do_raw_spin_lock+0x100/0x17c) from [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28)
    [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28) from [<c0203224>] (uart_start+0x18/0x34)
    [<c0203224>] (uart_start+0x18/0x34) from [<c01ef890>] (__receive_buf+0x4b4/0x738)
    [<c01ef890>] (__receive_buf+0x4b4/0x738) from [<c01efb44>] (n_tty_receive_buf2+0x30/0x98)
    [<c01efb44>] (n_tty_receive_buf2+0x30/0x98) from [<c01f2ba8>] (flush_to_ldisc+0xec/0x138)
    [<c01f2ba8>] (flush_to_ldisc+0xec/0x138) from [<c0031af0>] (process_one_work+0xfc/0x348)
    [<c0031af0>] (process_one_work+0xfc/0x348) from [<c0032138>] (worker_thread+0x138/0x37c)
    [<c0032138>] (worker_thread+0x138/0x37c) from [<c0037a7c>] (kthread+0xa4/0xb0)
    [<c0037a7c>] (kthread+0xa4/0xb0) from [<c000e5f8>] (ret_from_fork+0x14/0x3c)
    -----
    
    Release the port lock before calling tty_flip_buffer_push() and reacquire it
    after the call.
    
    Similar stuff was already done for few other drivers in the past, like:
    
    commit 2389b272168ceec056ca1d8a870a97fa9c26e11a
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue May 29 21:53:50 2007 +0100
    
        [ARM] 4417/1: Serial: Fix AMBA drivers locking
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index a314a943f124..328d6deb6b08 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -427,7 +427,9 @@ static void rp2_rx_chars(struct rp2_uart_port *up)
 		up->port.icount.rx++;
 	}
 
+	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(port);
+	spin_lock(&up->port.lock);
 }
 
 static void rp2_tx_chars(struct rp2_uart_port *up)

commit 7d9f49afa451d8565d00a5cea39acf9bb26feb50
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Wed Jan 16 20:28:40 2013 -0800

    serial: rp2: New driver for Comtrol RocketPort 2 cards
    
    This driver supports the RocketPort EXPRESS and RocketPort INFINITY
    families of PCI/PCIe multiport serial adapters.  These adapters use a
    "RocketPort 2" ASIC that is not compatible with the original RocketPort
    driver (CONFIG_ROCKETPORT).
    
    Tested with the RocketPort EXPRESS Octa DB9 and Quad DB9.  Also added an
    old RocketPort 8J PCI card to the same system to verify that rocket.c and
    rp2.c coexist peacefully.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
new file mode 100644
index 000000000000..a314a943f124
--- /dev/null
+++ b/drivers/tty/serial/rp2.c
@@ -0,0 +1,885 @@
+/*
+ * Driver for Comtrol RocketPort EXPRESS/INFINITY cards
+ *
+ * Copyright (C) 2012 Kevin Cernekee <cernekee@gmail.com>
+ *
+ * Inspired by, and loosely based on:
+ *
+ *   ar933x_uart.c
+ *     Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *   rocketport_infinity_express-linux-1.20.tar.gz
+ *     Copyright (C) 2004-2011 Comtrol, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/bitops.h>
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/log2.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/slab.h>
+#include <linux/sysrq.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/types.h>
+
+#define DRV_NAME			"rp2"
+
+#define RP2_FW_NAME			"rp2.fw"
+#define RP2_UCODE_BYTES			0x3f
+
+#define PORTS_PER_ASIC			16
+#define ALL_PORTS_MASK			(BIT(PORTS_PER_ASIC) - 1)
+
+#define UART_CLOCK			44236800
+#define DEFAULT_BAUD_DIV		(UART_CLOCK / (9600 * 16))
+#define FIFO_SIZE			512
+
+/* BAR0 registers */
+#define RP2_FPGA_CTL0			0x110
+#define RP2_FPGA_CTL1			0x11c
+#define RP2_IRQ_MASK			0x1ec
+#define RP2_IRQ_MASK_EN_m		BIT(0)
+#define RP2_IRQ_STATUS			0x1f0
+
+/* BAR1 registers */
+#define RP2_ASIC_SPACING		0x1000
+#define RP2_ASIC_OFFSET(i)		((i) << ilog2(RP2_ASIC_SPACING))
+
+#define RP2_PORT_BASE			0x000
+#define RP2_PORT_SPACING		0x040
+
+#define RP2_UCODE_BASE			0x400
+#define RP2_UCODE_SPACING		0x80
+
+#define RP2_CLK_PRESCALER		0xc00
+#define RP2_CH_IRQ_STAT			0xc04
+#define RP2_CH_IRQ_MASK			0xc08
+#define RP2_ASIC_IRQ			0xd00
+#define RP2_ASIC_IRQ_EN_m		BIT(20)
+#define RP2_GLOBAL_CMD			0xd0c
+#define RP2_ASIC_CFG			0xd04
+
+/* port registers */
+#define RP2_DATA_DWORD			0x000
+
+#define RP2_DATA_BYTE			0x008
+#define RP2_DATA_BYTE_ERR_PARITY_m	BIT(8)
+#define RP2_DATA_BYTE_ERR_OVERRUN_m	BIT(9)
+#define RP2_DATA_BYTE_ERR_FRAMING_m	BIT(10)
+#define RP2_DATA_BYTE_BREAK_m		BIT(11)
+
+/* This lets uart_insert_char() drop bytes received on a !CREAD port */
+#define RP2_DUMMY_READ			BIT(16)
+
+#define RP2_DATA_BYTE_EXCEPTION_MASK	(RP2_DATA_BYTE_ERR_PARITY_m | \
+					 RP2_DATA_BYTE_ERR_OVERRUN_m | \
+					 RP2_DATA_BYTE_ERR_FRAMING_m | \
+					 RP2_DATA_BYTE_BREAK_m)
+
+#define RP2_RX_FIFO_COUNT		0x00c
+#define RP2_TX_FIFO_COUNT		0x00e
+
+#define RP2_CHAN_STAT			0x010
+#define RP2_CHAN_STAT_RXDATA_m		BIT(0)
+#define RP2_CHAN_STAT_DCD_m		BIT(3)
+#define RP2_CHAN_STAT_DSR_m		BIT(4)
+#define RP2_CHAN_STAT_CTS_m		BIT(5)
+#define RP2_CHAN_STAT_RI_m		BIT(6)
+#define RP2_CHAN_STAT_OVERRUN_m		BIT(13)
+#define RP2_CHAN_STAT_DSR_CHANGED_m	BIT(16)
+#define RP2_CHAN_STAT_CTS_CHANGED_m	BIT(17)
+#define RP2_CHAN_STAT_CD_CHANGED_m	BIT(18)
+#define RP2_CHAN_STAT_RI_CHANGED_m	BIT(22)
+#define RP2_CHAN_STAT_TXEMPTY_m		BIT(25)
+
+#define RP2_CHAN_STAT_MS_CHANGED_MASK	(RP2_CHAN_STAT_DSR_CHANGED_m | \
+					 RP2_CHAN_STAT_CTS_CHANGED_m | \
+					 RP2_CHAN_STAT_CD_CHANGED_m | \
+					 RP2_CHAN_STAT_RI_CHANGED_m)
+
+#define RP2_TXRX_CTL			0x014
+#define RP2_TXRX_CTL_MSRIRQ_m		BIT(0)
+#define RP2_TXRX_CTL_RXIRQ_m		BIT(2)
+#define RP2_TXRX_CTL_RX_TRIG_s		3
+#define RP2_TXRX_CTL_RX_TRIG_m		(0x3 << RP2_TXRX_CTL_RX_TRIG_s)
+#define RP2_TXRX_CTL_RX_TRIG_1		(0x1 << RP2_TXRX_CTL_RX_TRIG_s)
+#define RP2_TXRX_CTL_RX_TRIG_256	(0x2 << RP2_TXRX_CTL_RX_TRIG_s)
+#define RP2_TXRX_CTL_RX_TRIG_448	(0x3 << RP2_TXRX_CTL_RX_TRIG_s)
+#define RP2_TXRX_CTL_RX_EN_m		BIT(5)
+#define RP2_TXRX_CTL_RTSFLOW_m		BIT(6)
+#define RP2_TXRX_CTL_DTRFLOW_m		BIT(7)
+#define RP2_TXRX_CTL_TX_TRIG_s		16
+#define RP2_TXRX_CTL_TX_TRIG_m		(0x3 << RP2_TXRX_CTL_RX_TRIG_s)
+#define RP2_TXRX_CTL_DSRFLOW_m		BIT(18)
+#define RP2_TXRX_CTL_TXIRQ_m		BIT(19)
+#define RP2_TXRX_CTL_CTSFLOW_m		BIT(23)
+#define RP2_TXRX_CTL_TX_EN_m		BIT(24)
+#define RP2_TXRX_CTL_RTS_m		BIT(25)
+#define RP2_TXRX_CTL_DTR_m		BIT(26)
+#define RP2_TXRX_CTL_LOOP_m		BIT(27)
+#define RP2_TXRX_CTL_BREAK_m		BIT(28)
+#define RP2_TXRX_CTL_CMSPAR_m		BIT(29)
+#define RP2_TXRX_CTL_nPARODD_m		BIT(30)
+#define RP2_TXRX_CTL_PARENB_m		BIT(31)
+
+#define RP2_UART_CTL			0x018
+#define RP2_UART_CTL_MODE_s		0
+#define RP2_UART_CTL_MODE_m		(0x7 << RP2_UART_CTL_MODE_s)
+#define RP2_UART_CTL_MODE_rs232		(0x1 << RP2_UART_CTL_MODE_s)
+#define RP2_UART_CTL_FLUSH_RX_m		BIT(3)
+#define RP2_UART_CTL_FLUSH_TX_m		BIT(4)
+#define RP2_UART_CTL_RESET_CH_m		BIT(5)
+#define RP2_UART_CTL_XMIT_EN_m		BIT(6)
+#define RP2_UART_CTL_DATABITS_s		8
+#define RP2_UART_CTL_DATABITS_m		(0x3 << RP2_UART_CTL_DATABITS_s)
+#define RP2_UART_CTL_DATABITS_8		(0x3 << RP2_UART_CTL_DATABITS_s)
+#define RP2_UART_CTL_DATABITS_7		(0x2 << RP2_UART_CTL_DATABITS_s)
+#define RP2_UART_CTL_DATABITS_6		(0x1 << RP2_UART_CTL_DATABITS_s)
+#define RP2_UART_CTL_DATABITS_5		(0x0 << RP2_UART_CTL_DATABITS_s)
+#define RP2_UART_CTL_STOPBITS_m		BIT(10)
+
+#define RP2_BAUD			0x01c
+
+/* ucode registers */
+#define RP2_TX_SWFLOW			0x02
+#define RP2_TX_SWFLOW_ena		0x81
+#define RP2_TX_SWFLOW_dis		0x9d
+
+#define RP2_RX_SWFLOW			0x0c
+#define RP2_RX_SWFLOW_ena		0x81
+#define RP2_RX_SWFLOW_dis		0x8d
+
+#define RP2_RX_FIFO			0x37
+#define RP2_RX_FIFO_ena			0x08
+#define RP2_RX_FIFO_dis			0x81
+
+static struct uart_driver rp2_uart_driver = {
+	.owner				= THIS_MODULE,
+	.driver_name			= DRV_NAME,
+	.dev_name			= "ttyRP",
+	.nr				= CONFIG_SERIAL_RP2_NR_UARTS,
+};
+
+struct rp2_card;
+
+struct rp2_uart_port {
+	struct uart_port		port;
+	int				idx;
+	int				ignore_rx;
+	struct rp2_card			*card;
+	void __iomem			*asic_base;
+	void __iomem			*base;
+	void __iomem			*ucode;
+};
+
+struct rp2_card {
+	struct pci_dev			*pdev;
+	struct rp2_uart_port		*ports;
+	int				n_ports;
+	int				initialized_ports;
+	int				minor_start;
+	int				smpte;
+	void __iomem			*bar0;
+	void __iomem			*bar1;
+	spinlock_t			card_lock;
+	struct completion		fw_loaded;
+};
+
+#define RP_ID(prod) PCI_VDEVICE(RP, (prod))
+#define RP_CAP(ports, smpte) (((ports) << 8) | ((smpte) << 0))
+
+static inline void rp2_decode_cap(const struct pci_device_id *id,
+				  int *ports, int *smpte)
+{
+	*ports = id->driver_data >> 8;
+	*smpte = id->driver_data & 0xff;
+}
+
+static DEFINE_SPINLOCK(rp2_minor_lock);
+static int rp2_minor_next;
+
+static int rp2_alloc_ports(int n_ports)
+{
+	int ret = -ENOSPC;
+
+	spin_lock(&rp2_minor_lock);
+	if (rp2_minor_next + n_ports <= CONFIG_SERIAL_RP2_NR_UARTS) {
+		/* sorry, no support for hot unplugging individual cards */
+		ret = rp2_minor_next;
+		rp2_minor_next += n_ports;
+	}
+	spin_unlock(&rp2_minor_lock);
+
+	return ret;
+}
+
+static inline struct rp2_uart_port *port_to_up(struct uart_port *port)
+{
+	return container_of(port, struct rp2_uart_port, port);
+}
+
+static void rp2_rmw(struct rp2_uart_port *up, int reg,
+		    u32 clr_bits, u32 set_bits)
+{
+	u32 tmp = readl(up->base + reg);
+	tmp &= ~clr_bits;
+	tmp |= set_bits;
+	writel(tmp, up->base + reg);
+}
+
+static void rp2_rmw_clr(struct rp2_uart_port *up, int reg, u32 val)
+{
+	rp2_rmw(up, reg, val, 0);
+}
+
+static void rp2_rmw_set(struct rp2_uart_port *up, int reg, u32 val)
+{
+	rp2_rmw(up, reg, 0, val);
+}
+
+static void rp2_mask_ch_irq(struct rp2_uart_port *up, int ch_num,
+			    int is_enabled)
+{
+	unsigned long flags, irq_mask;
+
+	spin_lock_irqsave(&up->card->card_lock, flags);
+
+	irq_mask = readl(up->asic_base + RP2_CH_IRQ_MASK);
+	if (is_enabled)
+		irq_mask &= ~BIT(ch_num);
+	else
+		irq_mask |= BIT(ch_num);
+	writel(irq_mask, up->asic_base + RP2_CH_IRQ_MASK);
+
+	spin_unlock_irqrestore(&up->card->card_lock, flags);
+}
+
+static unsigned int rp2_uart_tx_empty(struct uart_port *port)
+{
+	struct rp2_uart_port *up = port_to_up(port);
+	unsigned long tx_fifo_bytes, flags;
+
+	/*
+	 * This should probably check the transmitter, not the FIFO.
+	 * But the TXEMPTY bit doesn't seem to work unless the TX IRQ is
+	 * enabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+	tx_fifo_bytes = readw(up->base + RP2_TX_FIFO_COUNT);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return tx_fifo_bytes ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int rp2_uart_get_mctrl(struct uart_port *port)
+{
+	struct rp2_uart_port *up = port_to_up(port);
+	u32 status;
+
+	status = readl(up->base + RP2_CHAN_STAT);
+	return ((status & RP2_CHAN_STAT_DCD_m) ? TIOCM_CAR : 0) |
+	       ((status & RP2_CHAN_STAT_DSR_m) ? TIOCM_DSR : 0) |
+	       ((status & RP2_CHAN_STAT_CTS_m) ? TIOCM_CTS : 0) |
+	       ((status & RP2_CHAN_STAT_RI_m) ? TIOCM_RI : 0);
+}
+
+static void rp2_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	rp2_rmw(port_to_up(port), RP2_TXRX_CTL,
+		RP2_TXRX_CTL_DTR_m | RP2_TXRX_CTL_RTS_m | RP2_TXRX_CTL_LOOP_m,
+		((mctrl & TIOCM_DTR) ? RP2_TXRX_CTL_DTR_m : 0) |
+		((mctrl & TIOCM_RTS) ? RP2_TXRX_CTL_RTS_m : 0) |
+		((mctrl & TIOCM_LOOP) ? RP2_TXRX_CTL_LOOP_m : 0));
+}
+
+static void rp2_uart_start_tx(struct uart_port *port)
+{
+	rp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);
+}
+
+static void rp2_uart_stop_tx(struct uart_port *port)
+{
+	rp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);
+}
+
+static void rp2_uart_stop_rx(struct uart_port *port)
+{
+	rp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_RXIRQ_m);
+}
+
+static void rp2_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	rp2_rmw(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_BREAK_m,
+		break_state ? RP2_TXRX_CTL_BREAK_m : 0);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void rp2_uart_enable_ms(struct uart_port *port)
+{
+	rp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m);
+}
+
+static void __rp2_uart_set_termios(struct rp2_uart_port *up,
+				   unsigned long cfl,
+				   unsigned long ifl,
+				   unsigned int baud_div)
+{
+	/* baud rate divisor (calculated elsewhere).  0 = divide-by-1 */
+	writew(baud_div - 1, up->base + RP2_BAUD);
+
+	/* data bits and stop bits */
+	rp2_rmw(up, RP2_UART_CTL,
+		RP2_UART_CTL_STOPBITS_m | RP2_UART_CTL_DATABITS_m,
+		((cfl & CSTOPB) ? RP2_UART_CTL_STOPBITS_m : 0) |
+		(((cfl & CSIZE) == CS8) ? RP2_UART_CTL_DATABITS_8 : 0) |
+		(((cfl & CSIZE) == CS7) ? RP2_UART_CTL_DATABITS_7 : 0) |
+		(((cfl & CSIZE) == CS6) ? RP2_UART_CTL_DATABITS_6 : 0) |
+		(((cfl & CSIZE) == CS5) ? RP2_UART_CTL_DATABITS_5 : 0));
+
+	/* parity and hardware flow control */
+	rp2_rmw(up, RP2_TXRX_CTL,
+		RP2_TXRX_CTL_PARENB_m | RP2_TXRX_CTL_nPARODD_m |
+		RP2_TXRX_CTL_CMSPAR_m | RP2_TXRX_CTL_DTRFLOW_m |
+		RP2_TXRX_CTL_DSRFLOW_m | RP2_TXRX_CTL_RTSFLOW_m |
+		RP2_TXRX_CTL_CTSFLOW_m,
+		((cfl & PARENB) ? RP2_TXRX_CTL_PARENB_m : 0) |
+		((cfl & PARODD) ? 0 : RP2_TXRX_CTL_nPARODD_m) |
+		((cfl & CMSPAR) ? RP2_TXRX_CTL_CMSPAR_m : 0) |
+		((cfl & CRTSCTS) ? (RP2_TXRX_CTL_RTSFLOW_m |
+				    RP2_TXRX_CTL_CTSFLOW_m) : 0));
+
+	/* XON/XOFF software flow control */
+	writeb((ifl & IXON) ? RP2_TX_SWFLOW_ena : RP2_TX_SWFLOW_dis,
+	       up->ucode + RP2_TX_SWFLOW);
+	writeb((ifl & IXOFF) ? RP2_RX_SWFLOW_ena : RP2_RX_SWFLOW_dis,
+	       up->ucode + RP2_RX_SWFLOW);
+}
+
+static void rp2_uart_set_termios(struct uart_port *port,
+				 struct ktermios *new,
+				 struct ktermios *old)
+{
+	struct rp2_uart_port *up = port_to_up(port);
+	unsigned long flags;
+	unsigned int baud, baud_div;
+
+	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);
+	baud_div = uart_get_divisor(port, baud);
+
+	if (tty_termios_baud_rate(new))
+		tty_termios_encode_baud_rate(new, baud, baud);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* ignore all characters if CREAD is not set */
+	port->ignore_status_mask = (new->c_cflag & CREAD) ? 0 : RP2_DUMMY_READ;
+
+	__rp2_uart_set_termios(up, new->c_cflag, new->c_iflag, baud_div);
+	uart_update_timeout(port, new->c_cflag, baud);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void rp2_rx_chars(struct rp2_uart_port *up)
+{
+	u16 bytes = readw(up->base + RP2_RX_FIFO_COUNT);
+	struct tty_port *port = &up->port.state->port;
+
+	for (; bytes != 0; bytes--) {
+		u32 byte = readw(up->base + RP2_DATA_BYTE) | RP2_DUMMY_READ;
+		char ch = byte & 0xff;
+
+		if (likely(!(byte & RP2_DATA_BYTE_EXCEPTION_MASK))) {
+			if (!uart_handle_sysrq_char(&up->port, ch))
+				uart_insert_char(&up->port, byte, 0, ch,
+						 TTY_NORMAL);
+		} else {
+			char flag = TTY_NORMAL;
+
+			if (byte & RP2_DATA_BYTE_BREAK_m)
+				flag = TTY_BREAK;
+			else if (byte & RP2_DATA_BYTE_ERR_FRAMING_m)
+				flag = TTY_FRAME;
+			else if (byte & RP2_DATA_BYTE_ERR_PARITY_m)
+				flag = TTY_PARITY;
+			uart_insert_char(&up->port, byte,
+					 RP2_DATA_BYTE_ERR_OVERRUN_m, ch, flag);
+		}
+		up->port.icount.rx++;
+	}
+
+	tty_flip_buffer_push(port);
+}
+
+static void rp2_tx_chars(struct rp2_uart_port *up)
+{
+	u16 max_tx = FIFO_SIZE - readw(up->base + RP2_TX_FIFO_COUNT);
+	struct circ_buf *xmit = &up->port.state->xmit;
+
+	if (uart_tx_stopped(&up->port)) {
+		rp2_uart_stop_tx(&up->port);
+		return;
+	}
+
+	for (; max_tx != 0; max_tx--) {
+		if (up->port.x_char) {
+			writeb(up->port.x_char, up->base + RP2_DATA_BYTE);
+			up->port.x_char = 0;
+			up->port.icount.tx++;
+			continue;
+		}
+		if (uart_circ_empty(xmit)) {
+			rp2_uart_stop_tx(&up->port);
+			break;
+		}
+		writeb(xmit->buf[xmit->tail], up->base + RP2_DATA_BYTE);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+}
+
+static void rp2_ch_interrupt(struct rp2_uart_port *up)
+{
+	u32 status;
+
+	spin_lock(&up->port.lock);
+
+	/*
+	 * The IRQ status bits are clear-on-write.  Other status bits in
+	 * this register aren't, so it's harmless to write to them.
+	 */
+	status = readl(up->base + RP2_CHAN_STAT);
+	writel(status, up->base + RP2_CHAN_STAT);
+
+	if (status & RP2_CHAN_STAT_RXDATA_m)
+		rp2_rx_chars(up);
+	if (status & RP2_CHAN_STAT_TXEMPTY_m)
+		rp2_tx_chars(up);
+	if (status & RP2_CHAN_STAT_MS_CHANGED_MASK)
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+
+	spin_unlock(&up->port.lock);
+}
+
+static int rp2_asic_interrupt(struct rp2_card *card, unsigned int asic_id)
+{
+	void __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);
+	int ch, handled = 0;
+	unsigned long status = readl(base + RP2_CH_IRQ_STAT) &
+			       ~readl(base + RP2_CH_IRQ_MASK);
+
+	for_each_set_bit(ch, &status, PORTS_PER_ASIC) {
+		rp2_ch_interrupt(&card->ports[ch]);
+		handled++;
+	}
+	return handled;
+}
+
+static irqreturn_t rp2_uart_interrupt(int irq, void *dev_id)
+{
+	struct rp2_card *card = dev_id;
+	int handled;
+
+	handled = rp2_asic_interrupt(card, 0);
+	if (card->n_ports >= PORTS_PER_ASIC)
+		handled += rp2_asic_interrupt(card, 1);
+
+	return handled ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static inline void rp2_flush_fifos(struct rp2_uart_port *up)
+{
+	rp2_rmw_set(up, RP2_UART_CTL,
+		    RP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);
+	readl(up->base + RP2_UART_CTL);
+	udelay(10);
+	rp2_rmw_clr(up, RP2_UART_CTL,
+		    RP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);
+}
+
+static int rp2_uart_startup(struct uart_port *port)
+{
+	struct rp2_uart_port *up = port_to_up(port);
+
+	rp2_flush_fifos(up);
+	rp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m, RP2_TXRX_CTL_RXIRQ_m);
+	rp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_RX_TRIG_m,
+		RP2_TXRX_CTL_RX_TRIG_1);
+	rp2_rmw(up, RP2_CHAN_STAT, 0, 0);
+	rp2_mask_ch_irq(up, up->idx, 1);
+
+	return 0;
+}
+
+static void rp2_uart_shutdown(struct uart_port *port)
+{
+	struct rp2_uart_port *up = port_to_up(port);
+	unsigned long flags;
+
+	rp2_uart_break_ctl(port, 0);
+
+	spin_lock_irqsave(&port->lock, flags);
+	rp2_mask_ch_irq(up, up->idx, 0);
+	rp2_rmw(up, RP2_CHAN_STAT, 0, 0);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *rp2_uart_type(struct uart_port *port)
+{
+	return (port->type == PORT_RP2) ? "RocketPort 2 UART" : NULL;
+}
+
+static void rp2_uart_release_port(struct uart_port *port)
+{
+	/* Nothing to release ... */
+}
+
+static int rp2_uart_request_port(struct uart_port *port)
+{
+	/* UARTs always present */
+	return 0;
+}
+
+static void rp2_uart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_RP2;
+}
+
+static int rp2_uart_verify_port(struct uart_port *port,
+				   struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_RP2)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct uart_ops rp2_uart_ops = {
+	.tx_empty	= rp2_uart_tx_empty,
+	.set_mctrl	= rp2_uart_set_mctrl,
+	.get_mctrl	= rp2_uart_get_mctrl,
+	.stop_tx	= rp2_uart_stop_tx,
+	.start_tx	= rp2_uart_start_tx,
+	.stop_rx	= rp2_uart_stop_rx,
+	.enable_ms	= rp2_uart_enable_ms,
+	.break_ctl	= rp2_uart_break_ctl,
+	.startup	= rp2_uart_startup,
+	.shutdown	= rp2_uart_shutdown,
+	.set_termios	= rp2_uart_set_termios,
+	.type		= rp2_uart_type,
+	.release_port	= rp2_uart_release_port,
+	.request_port	= rp2_uart_request_port,
+	.config_port	= rp2_uart_config_port,
+	.verify_port	= rp2_uart_verify_port,
+};
+
+static void rp2_reset_asic(struct rp2_card *card, unsigned int asic_id)
+{
+	void __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);
+	u32 clk_cfg;
+
+	writew(1, base + RP2_GLOBAL_CMD);
+	readw(base + RP2_GLOBAL_CMD);
+	msleep(100);
+	writel(0, base + RP2_CLK_PRESCALER);
+
+	/* TDM clock configuration */
+	clk_cfg = readw(base + RP2_ASIC_CFG);
+	clk_cfg = (clk_cfg & ~BIT(8)) | BIT(9);
+	writew(clk_cfg, base + RP2_ASIC_CFG);
+
+	/* IRQ routing */
+	writel(ALL_PORTS_MASK, base + RP2_CH_IRQ_MASK);
+	writel(RP2_ASIC_IRQ_EN_m, base + RP2_ASIC_IRQ);
+}
+
+static void rp2_init_card(struct rp2_card *card)
+{
+	writel(4, card->bar0 + RP2_FPGA_CTL0);
+	writel(0, card->bar0 + RP2_FPGA_CTL1);
+
+	rp2_reset_asic(card, 0);
+	if (card->n_ports >= PORTS_PER_ASIC)
+		rp2_reset_asic(card, 1);
+
+	writel(RP2_IRQ_MASK_EN_m, card->bar0 + RP2_IRQ_MASK);
+}
+
+static void rp2_init_port(struct rp2_uart_port *up, const struct firmware *fw)
+{
+	int i;
+
+	writel(RP2_UART_CTL_RESET_CH_m, up->base + RP2_UART_CTL);
+	readl(up->base + RP2_UART_CTL);
+	udelay(1);
+
+	writel(0, up->base + RP2_TXRX_CTL);
+	writel(0, up->base + RP2_UART_CTL);
+	readl(up->base + RP2_UART_CTL);
+	udelay(1);
+
+	rp2_flush_fifos(up);
+
+	for (i = 0; i < min_t(int, fw->size, RP2_UCODE_BYTES); i++)
+		writeb(fw->data[i], up->ucode + i);
+
+	__rp2_uart_set_termios(up, CS8 | CREAD | CLOCAL, 0, DEFAULT_BAUD_DIV);
+	rp2_uart_set_mctrl(&up->port, 0);
+
+	writeb(RP2_RX_FIFO_ena, up->ucode + RP2_RX_FIFO);
+	rp2_rmw(up, RP2_UART_CTL, RP2_UART_CTL_MODE_m,
+		RP2_UART_CTL_XMIT_EN_m | RP2_UART_CTL_MODE_rs232);
+	rp2_rmw_set(up, RP2_TXRX_CTL,
+		    RP2_TXRX_CTL_TX_EN_m | RP2_TXRX_CTL_RX_EN_m);
+}
+
+static void rp2_remove_ports(struct rp2_card *card)
+{
+	int i;
+
+	for (i = 0; i < card->initialized_ports; i++)
+		uart_remove_one_port(&rp2_uart_driver, &card->ports[i].port);
+	card->initialized_ports = 0;
+}
+
+static void rp2_fw_cb(const struct firmware *fw, void *context)
+{
+	struct rp2_card *card = context;
+	resource_size_t phys_base;
+	int i, rc = -ENOENT;
+
+	if (!fw) {
+		dev_err(&card->pdev->dev, "cannot find '%s' firmware image\n",
+			RP2_FW_NAME);
+		goto no_fw;
+	}
+
+	phys_base = pci_resource_start(card->pdev, 1);
+
+	for (i = 0; i < card->n_ports; i++) {
+		struct rp2_uart_port *rp = &card->ports[i];
+		struct uart_port *p;
+		int j = (unsigned)i % PORTS_PER_ASIC;
+
+		rp->asic_base = card->bar1;
+		rp->base = card->bar1 + RP2_PORT_BASE + j*RP2_PORT_SPACING;
+		rp->ucode = card->bar1 + RP2_UCODE_BASE + j*RP2_UCODE_SPACING;
+		rp->card = card;
+		rp->idx = j;
+
+		p = &rp->port;
+		p->line = card->minor_start + i;
+		p->dev = &card->pdev->dev;
+		p->type = PORT_RP2;
+		p->iotype = UPIO_MEM32;
+		p->uartclk = UART_CLOCK;
+		p->regshift = 2;
+		p->fifosize = FIFO_SIZE;
+		p->ops = &rp2_uart_ops;
+		p->irq = card->pdev->irq;
+		p->membase = rp->base;
+		p->mapbase = phys_base + RP2_PORT_BASE + j*RP2_PORT_SPACING;
+
+		if (i >= PORTS_PER_ASIC) {
+			rp->asic_base += RP2_ASIC_SPACING;
+			rp->base += RP2_ASIC_SPACING;
+			rp->ucode += RP2_ASIC_SPACING;
+			p->mapbase += RP2_ASIC_SPACING;
+		}
+
+		rp2_init_port(rp, fw);
+		rc = uart_add_one_port(&rp2_uart_driver, p);
+		if (rc) {
+			dev_err(&card->pdev->dev,
+				"error registering port %d: %d\n", i, rc);
+			rp2_remove_ports(card);
+			break;
+		}
+		card->initialized_ports++;
+	}
+
+	release_firmware(fw);
+no_fw:
+	/*
+	 * rp2_fw_cb() is called from a workqueue long after rp2_probe()
+	 * has already returned success.  So if something failed here,
+	 * we'll just leave the now-dormant device in place until somebody
+	 * unbinds it.
+	 */
+	if (rc)
+		dev_warn(&card->pdev->dev, "driver initialization failed\n");
+
+	complete(&card->fw_loaded);
+}
+
+static int rp2_probe(struct pci_dev *pdev,
+				   const struct pci_device_id *id)
+{
+	struct rp2_card *card;
+	struct rp2_uart_port *ports;
+	void __iomem * const *bars;
+	int rc;
+
+	card = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+	pci_set_drvdata(pdev, card);
+	spin_lock_init(&card->card_lock);
+	init_completion(&card->fw_loaded);
+
+	rc = pcim_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pcim_iomap_regions_request_all(pdev, 0x03, DRV_NAME);
+	if (rc)
+		return rc;
+
+	bars = pcim_iomap_table(pdev);
+	card->bar0 = bars[0];
+	card->bar1 = bars[1];
+	card->pdev = pdev;
+
+	rp2_decode_cap(id, &card->n_ports, &card->smpte);
+	dev_info(&pdev->dev, "found new card with %d ports\n", card->n_ports);
+
+	card->minor_start = rp2_alloc_ports(card->n_ports);
+	if (card->minor_start < 0) {
+		dev_err(&pdev->dev,
+			"too many ports (try increasing CONFIG_SERIAL_RP2_NR_UARTS)\n");
+		return -EINVAL;
+	}
+
+	rp2_init_card(card);
+
+	ports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,
+			     GFP_KERNEL);
+	if (!ports)
+		return -ENOMEM;
+	card->ports = ports;
+
+	rc = devm_request_irq(&pdev->dev, pdev->irq, rp2_uart_interrupt,
+			      IRQF_SHARED, DRV_NAME, card);
+	if (rc)
+		return rc;
+
+	/*
+	 * Only catastrophic errors (e.g. ENOMEM) are reported here.
+	 * If the FW image is missing, we'll find out in rp2_fw_cb()
+	 * and print an error message.
+	 */
+	rc = request_firmware_nowait(THIS_MODULE, 1, RP2_FW_NAME, &pdev->dev,
+				     GFP_KERNEL, card, rp2_fw_cb);
+	if (rc)
+		return rc;
+	dev_dbg(&pdev->dev, "waiting for firmware blob...\n");
+
+	return 0;
+}
+
+static void rp2_remove(struct pci_dev *pdev)
+{
+	struct rp2_card *card = pci_get_drvdata(pdev);
+
+	wait_for_completion(&card->fw_loaded);
+	rp2_remove_ports(card);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(rp2_pci_tbl) = {
+
+	/* RocketPort INFINITY cards */
+
+	{ RP_ID(0x0040), RP_CAP(8,  0) }, /* INF Octa, RJ45, selectable */
+	{ RP_ID(0x0041), RP_CAP(32, 0) }, /* INF 32, ext interface */
+	{ RP_ID(0x0042), RP_CAP(8,  0) }, /* INF Octa, ext interface */
+	{ RP_ID(0x0043), RP_CAP(16, 0) }, /* INF 16, ext interface */
+	{ RP_ID(0x0044), RP_CAP(4,  0) }, /* INF Quad, DB, selectable */
+	{ RP_ID(0x0045), RP_CAP(8,  0) }, /* INF Octa, DB, selectable */
+	{ RP_ID(0x0046), RP_CAP(4,  0) }, /* INF Quad, ext interface */
+	{ RP_ID(0x0047), RP_CAP(4,  0) }, /* INF Quad, RJ45 */
+	{ RP_ID(0x004a), RP_CAP(4,  0) }, /* INF Plus, Quad */
+	{ RP_ID(0x004b), RP_CAP(8,  0) }, /* INF Plus, Octa */
+	{ RP_ID(0x004c), RP_CAP(8,  0) }, /* INF III, Octa */
+	{ RP_ID(0x004d), RP_CAP(4,  0) }, /* INF III, Quad */
+	{ RP_ID(0x004e), RP_CAP(2,  0) }, /* INF Plus, 2, RS232 */
+	{ RP_ID(0x004f), RP_CAP(2,  1) }, /* INF Plus, 2, SMPTE */
+	{ RP_ID(0x0050), RP_CAP(4,  0) }, /* INF Plus, Quad, RJ45 */
+	{ RP_ID(0x0051), RP_CAP(8,  0) }, /* INF Plus, Octa, RJ45 */
+	{ RP_ID(0x0052), RP_CAP(8,  1) }, /* INF Octa, SMPTE */
+
+	/* RocketPort EXPRESS cards */
+
+	{ RP_ID(0x0060), RP_CAP(8,  0) }, /* EXP Octa, RJ45, selectable */
+	{ RP_ID(0x0061), RP_CAP(32, 0) }, /* EXP 32, ext interface */
+	{ RP_ID(0x0062), RP_CAP(8,  0) }, /* EXP Octa, ext interface */
+	{ RP_ID(0x0063), RP_CAP(16, 0) }, /* EXP 16, ext interface */
+	{ RP_ID(0x0064), RP_CAP(4,  0) }, /* EXP Quad, DB, selectable */
+	{ RP_ID(0x0065), RP_CAP(8,  0) }, /* EXP Octa, DB, selectable */
+	{ RP_ID(0x0066), RP_CAP(4,  0) }, /* EXP Quad, ext interface */
+	{ RP_ID(0x0067), RP_CAP(4,  0) }, /* EXP Quad, RJ45 */
+	{ RP_ID(0x0068), RP_CAP(8,  0) }, /* EXP Octa, RJ11 */
+	{ RP_ID(0x0072), RP_CAP(8,  1) }, /* EXP Octa, SMPTE */
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, rp2_pci_tbl);
+
+static struct pci_driver rp2_pci_driver = {
+	.name		= DRV_NAME,
+	.id_table	= rp2_pci_tbl,
+	.probe		= rp2_probe,
+	.remove		= rp2_remove,
+};
+
+static int __init rp2_uart_init(void)
+{
+	int rc;
+
+	rc = uart_register_driver(&rp2_uart_driver);
+	if (rc)
+		return rc;
+
+	rc = pci_register_driver(&rp2_pci_driver);
+	if (rc) {
+		uart_unregister_driver(&rp2_uart_driver);
+		return rc;
+	}
+
+	return 0;
+}
+
+static void __exit rp2_uart_exit(void)
+{
+	pci_unregister_driver(&rp2_pci_driver);
+	uart_unregister_driver(&rp2_uart_driver);
+}
+
+module_init(rp2_uart_init);
+module_exit(rp2_uart_exit);
+
+MODULE_DESCRIPTION("Comtrol RocketPort EXPRESS/INFINITY driver");
+MODULE_AUTHOR("Kevin Cernekee <cernekee@gmail.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_FIRMWARE(RP2_FW_NAME);
