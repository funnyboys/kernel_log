commit 933505e9b41759fb7cb8a1b648553d7c00a8bf1c
Author: Dmitry Safonov <dima@arista.com>
Date:   Fri Dec 13 00:06:10 2019 +0000

    tty/serial: Migrate arc_uart to use has_sysrq
    
    The SUPPORT_SYSRQ ifdeffery is not nice as:
    - May create misunderstanding about sizeof(struct uart_port) between
      different objects
    - Prevents moving functions from serial_core.h
    - Reduces readability (well, it's ifdeffery - it's hard to follow)
    
    In order to remove SUPPORT_SYSRQ, has_sysrq variable has been added.
    Initialise it in driver's probe and remove ifdeffery.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20191213000657.931618-12-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index d904a3a345e7..17c3fc398fc6 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -21,10 +21,6 @@
  *  -check if sysreq works
  */
 
-#if defined(CONFIG_SERIAL_ARC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-#define SUPPORT_SYSRQ
-#endif
-
 #include <linux/module.h>
 #include <linux/serial.h>
 #include <linux/console.h>
@@ -625,6 +621,7 @@ static int arc_serial_probe(struct platform_device *pdev)
 	port->flags = UPF_BOOT_AUTOCONF;
 	port->line = dev_id;
 	port->ops = &arc_serial_pops;
+	port->has_sysrq = IS_ENABLED(CONFIG_SERIAL_ARC_CONSOLE);
 
 	port->fifosize = ARC_UART_TX_FIFO_SIZE;
 

commit f9f5786987e81d166c60833edcb7d1836aa16944
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Feb 23 14:38:29 2018 +0100

    serial: arc_uart: Fix out-of-bounds access through DT alias
    
    The arc_uart_ports[] array is indexed using a value derived from the
    "serialN" alias in DT, which may lead to an out-of-bounds access.
    
    Fix this by adding a range check.
    
    Note that the array size is defined by a Kconfig symbol
    (CONFIG_SERIAL_ARC_NR_PORTS), so this can even be triggered using a
    legitimate DTB.
    
    Fixes: ea28fd56fcde69af ("serial/arc-uart: switch to devicetree based probing")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 2599f9ecccfe..d904a3a345e7 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -593,6 +593,11 @@ static int arc_serial_probe(struct platform_device *pdev)
 	if (dev_id < 0)
 		dev_id = 0;
 
+	if (dev_id >= ARRAY_SIZE(arc_uart_ports)) {
+		dev_err(&pdev->dev, "serial%d out of range\n", dev_id);
+		return -EINVAL;
+	}
+
 	uart = &arc_uart_ports[dev_id];
 	port = &uart->port;
 

commit 4793f2ebff1c890386a514998606205a2948011c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:52 2017 +0100

    tty: serial: Remove redundant license text
    
    Now that the SPDX tag is in all tty files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 54d979ba4657..2599f9ecccfe 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -4,10 +4,6 @@
  *
  * Copyright (C) 2010-2012 Synopsys, Inc. (www.synopsys.com)
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * vineetg: July 10th 2012
  *  -Decoupled the driver from arch/arc
  *    +Using platform_get_resource() for irq/membase (thx to bfin_uart.c)

commit e3b3d0f549c1d19b94e6ac55c66643166ea649ef
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 18:11:51 2017 +0100

    tty: add SPDX identifiers to all remaining files in drivers/tty/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/tty files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: David Sterba <dsterba@suse.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Joachim Eastwood <manabian@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: "Uwe Kleine-König" <kernel@pengutronix.de>
    Cc: Pat Gefre <pfg@sgi.com>
    Cc: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andy Gross <andy.gross@linaro.org>
    Cc: David Brown <david.brown@linaro.org>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Timur Tabi <timur@tabi.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 77fe306690c4..54d979ba4657 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ARC On-Chip(fpga) UART Driver
  *

commit ac1e6965597d26cc1d16559b01261cbe1279ed00
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Jul 18 14:02:54 2017 +0800

    serial: arc: Remove __init marking from early write
    
    The earlycon would be alive outside the init code in these cases:
    1/ we have keep_bootcon in cmdline.
    2/ we don't have a real console to switch to.
    
    So remove the __init marking to avoid invalid memory access.
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 5ac06fcaa9c6..77fe306690c4 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -549,8 +549,8 @@ static struct console arc_console = {
 	.data	= &arc_uart_driver
 };
 
-static __init void arc_early_serial_write(struct console *con, const char *s,
-					  unsigned int n)
+static void arc_early_serial_write(struct console *con, const char *s,
+				   unsigned int n)
 {
 	struct earlycon_device *dev = con->data;
 

commit 8232884e2dfa606edef66b2c889d4d2ebe042cb8
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Sep 1 19:51:38 2016 +0200

    serial/arc: constify uart_ops structures
    
    Check for uart_ops structures that are only stored in the ops field of a
    uart_port structure.  This field is declared const, so uart_ops structures
    that have this property can be declared as const also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct uart_ops i@p = { ... };
    
    @ok@
    identifier r.i;
    struct uart_port e;
    position p;
    @@
    e.ops = &i@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    struct uart_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct uart_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 3a1de5c87cb4..5ac06fcaa9c6 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -464,7 +464,7 @@ static int arc_serial_poll_getchar(struct uart_port *port)
 }
 #endif
 
-static struct uart_ops arc_serial_pops = {
+static const struct uart_ops arc_serial_pops = {
 	.tx_empty	= arc_serial_tx_empty,
 	.set_mctrl	= arc_serial_set_mctrl,
 	.get_mctrl	= arc_serial_get_mctrl,

commit 2eaa790989e03900298ad24f77f1086dbbc1aebd
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:39 2016 -0800

    earlycon: Use common framework for earlycon declarations
    
    Use a single common table of struct earlycon_id for both command line
    and devicetree. Re-define OF_EARLYCON_DECLARE() macro to instance a
    unique earlycon declaration (the declaration is only guaranteed to be
    unique within a compilation unit; separate compilation units must still
    use unique earlycon names).
    
    The semantics of OF_EARLYCON_DECLARE() is different; it declares an
    earlycon which can matched either on the command line or by devicetree.
    EARLYCON_DECLARE() is semantically unchanged; it declares an earlycon
    which is matched by command line only. Remove redundant instances of
    EARLYCON_DECLARE().
    
    This enables all earlycons to properly initialize struct console
    with the appropriate name and index, which improves diagnostics and
    enables direct earlycon-to-console handoff.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 03ebe401fff7..3a1de5c87cb4 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -576,7 +576,6 @@ static int __init arc_early_console_setup(struct earlycon_device *dev,
 	dev->con->write = arc_early_serial_write;
 	return 0;
 }
-EARLYCON_DECLARE(arc_uart, arc_early_console_setup);
 OF_EARLYCON_DECLARE(arc_uart, "snps,arc-uart", arc_early_console_setup);
 
 #endif	/* CONFIG_SERIAL_ARC_CONSOLE */

commit 9144b3cded04a05d4b4e18dc9dcfb5b8ada3f2fc
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:45 2014 +0200

    tty: serial: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index a59d1d77e750..03ebe401fff7 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -653,7 +653,6 @@ static struct platform_driver arc_platform_driver = {
 	.remove = arc_serial_remove,
 	.driver = {
 		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
 		.of_match_table  = arc_uart_dt_ids,
 	 },
 };

commit ca17749259d26f7ddbb0678790d5d534018d0a6b
Merge: 07584d4a356e 1795cd9b3a91
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jul 13 15:52:12 2014 -0700

    Merge 3.16-rc5 into tty-next.
    
    We want those fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f363ca2fc8d12ebaad1a8bdae0f164c17c747b89
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Jul 11 18:31:37 2014 +0530

    serial/arc: Fix warning with CONSOLE_POLL
    
    | drivers/tty/serial/arc_uart.c:516:2: warning: (near initialization for 'arc_serial_pops.poll_put_char') [enabled by default]
    
    This partially undoes "serial/arc: use uart_console_write() helper" by
    restoring the prototpye of poll helper and use a different one in
    uart_console_write()
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 3a504fb9c9e8..f8dc7d381956 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -442,18 +442,16 @@ static void arc_serial_config_port(struct uart_port *port, int flags)
 		port->type = PORT_ARC;
 }
 
-#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_ARC_CONSOLE)
+#ifdef CONFIG_CONSOLE_POLL
 
-static void arc_serial_poll_putchar(struct uart_port *port, int chr)
+static void arc_serial_poll_putchar(struct uart_port *port, unsigned char chr)
 {
 	while (!(UART_GET_STATUS(port) & TXEMPTY))
 		cpu_relax();
 
-	UART_SET_DATA(port, (unsigned char)chr);
+	UART_SET_DATA(port, chr);
 }
-#endif
 
-#ifdef CONFIG_CONSOLE_POLL
 static int arc_serial_poll_getchar(struct uart_port *port)
 {
 	unsigned char chr;
@@ -519,6 +517,14 @@ static int arc_serial_console_setup(struct console *co, char *options)
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
+static void arc_serial_console_putchar(struct uart_port *port, int ch)
+{
+	while (!(UART_GET_STATUS(port) & TXEMPTY))
+		cpu_relax();
+
+	UART_SET_DATA(port, (unsigned char)ch);
+}
+
 /*
  * Interrupts are disabled on entering
  */
@@ -529,7 +535,7 @@ static void arc_serial_console_write(struct console *co, const char *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
-	uart_console_write(port, s, count, arc_serial_poll_putchar);
+	uart_console_write(port, s, count, arc_serial_console_putchar);
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -548,7 +554,7 @@ static __init void arc_early_serial_write(struct console *con, const char *s,
 {
 	struct earlycon_device *dev = con->data;
 
-	uart_console_write(&dev->port, s, n, arc_serial_poll_putchar);
+	uart_console_write(&dev->port, s, n, arc_serial_console_putchar);
 }
 
 static int __init arc_early_console_setup(struct earlycon_device *dev,

commit 99ecb001f52ef10ebf686d4e55b1cf64b1e56aa6
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jul 6 11:29:53 2014 -0400

    serial: arc_uart: Use uart_circ_empty() for open-coded comparison
    
    Replace open-coded test for empty tx ring buffer with equivalent
    helper function, uart_circ_empty(). No functional change.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index c9f5c9dcc15c..008c223eaf26 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -177,7 +177,7 @@ static void arc_serial_tx_chars(struct arc_uart_port *uart)
 		uart->port.icount.tx++;
 		uart->port.x_char = 0;
 		sent = 1;
-	} else if (xmit->tail != xmit->head) {	/* TODO: uart_circ_empty */
+	} else if (!uart_circ_empty(xmit)) {
 		ch = xmit->buf[xmit->tail];
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		uart->port.icount.tx++;

commit 8c6abf7a9e5d0f4a27140cf13220a28e0f5c829c
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:14 2014 +0530

    serial/arc: Enable DT based earlycon
    
    This allows a param less earlycon to pick up the earlyconsole from
    chosen/stdout-path
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 3b5285373658..3a504fb9c9e8 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -571,6 +571,7 @@ static int __init arc_early_console_setup(struct earlycon_device *dev,
 	return 0;
 }
 EARLYCON_DECLARE(arc_uart, arc_early_console_setup);
+OF_EARLYCON_DECLARE(arc_uart, "snps,arc-uart", arc_early_console_setup);
 
 #endif	/* CONFIG_SERIAL_ARC_CONSOLE */
 

commit 8dbe1d5e09a7faec8d22cadcc1011acab8fa6e2a
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:12 2014 +0530

    serial/arc: inline the probe helper
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 68433adea35b..3b5285373658 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -488,50 +488,6 @@ static struct uart_ops arc_serial_pops = {
 #endif
 };
 
-static int
-arc_uart_init_one(struct platform_device *pdev, int dev_id)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
-	struct uart_port *port = &uart->port;
-	u32 val;
-
-	if (of_property_read_u32(np, "clock-frequency", &val)) {
-		dev_err(&pdev->dev, "clock-frequency property NOTset\n");
-		return -EINVAL;
-	}
-	port->uartclk = val;
-
-	if (of_property_read_u32(np, "current-speed", &val)) {
-		dev_err(&pdev->dev, "current-speed property NOT set\n");
-		return -EINVAL;
-	}
-	uart->baud = val;
-
-	port->membase = of_iomap(np, 0);
-	if (!port->membase)
-		/* No point of dev_err since UART itself is hosed here */
-		return -ENXIO;
-
-	port->irq = irq_of_parse_and_map(np, 0);
-
-	port->dev = &pdev->dev;
-	port->iotype = UPIO_MEM;
-	port->flags = UPF_BOOT_AUTOCONF;
-	port->line = dev_id;
-	port->ops = &arc_serial_pops;
-
-	port->fifosize = ARC_UART_TX_FIFO_SIZE;
-
-	/*
-	 * uart_insert_char( ) uses it in decideding whether to ignore a
-	 * char or not. Explicitly setting it here, removes the subtelty
-	 */
-	port->ignore_status_mask = 0;
-
-	return 0;
-}
-
 #ifdef CONFIG_SERIAL_ARC_CONSOLE
 
 static int arc_serial_console_setup(struct console *co, char *options)
@@ -620,8 +576,11 @@ EARLYCON_DECLARE(arc_uart, arc_early_console_setup);
 
 static int arc_serial_probe(struct platform_device *pdev)
 {
-	int rc, dev_id;
 	struct device_node *np = pdev->dev.of_node;
+	struct arc_uart_port *uart;
+	struct uart_port *port;
+	int dev_id;
+	u32 val;
 
 	/* no device tree device */
 	if (!np)
@@ -631,12 +590,43 @@ static int arc_serial_probe(struct platform_device *pdev)
 	if (dev_id < 0)
 		dev_id = 0;
 
-	rc = arc_uart_init_one(pdev, dev_id);
-	if (rc)
-		return rc;
+	uart = &arc_uart_ports[dev_id];
+	port = &uart->port;
+
+	if (of_property_read_u32(np, "clock-frequency", &val)) {
+		dev_err(&pdev->dev, "clock-frequency property NOTset\n");
+		return -EINVAL;
+	}
+	port->uartclk = val;
+
+	if (of_property_read_u32(np, "current-speed", &val)) {
+		dev_err(&pdev->dev, "current-speed property NOT set\n");
+		return -EINVAL;
+	}
+	uart->baud = val;
+
+	port->membase = of_iomap(np, 0);
+	if (!port->membase)
+		/* No point of dev_err since UART itself is hosed here */
+		return -ENXIO;
+
+	port->irq = irq_of_parse_and_map(np, 0);
+
+	port->dev = &pdev->dev;
+	port->iotype = UPIO_MEM;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->line = dev_id;
+	port->ops = &arc_serial_pops;
+
+	port->fifosize = ARC_UART_TX_FIFO_SIZE;
+
+	/*
+	 * uart_insert_char( ) uses it in decideding whether to ignore a
+	 * char or not. Explicitly setting it here, removes the subtelty
+	 */
+	port->ignore_status_mask = 0;
 
-	rc = uart_add_one_port(&arc_uart_driver, &arc_uart_ports[dev_id].port);
-	return rc;
+	return uart_add_one_port(&arc_uart_driver, &arc_uart_ports[dev_id].port);
 }
 
 static int arc_serial_remove(struct platform_device *pdev)

commit 91f1b62a9b2b8d334b64d3029f4b0dcccf56bc1e
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:11 2014 +0530

    serial/arc: remove last remanants of platform data
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 94d345bfd08d..68433adea35b 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -37,8 +37,8 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_core.h>
 #include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
 
 /*************************************
  * ARC UART Hardware Specs
@@ -491,11 +491,9 @@ static struct uart_ops arc_serial_pops = {
 static int
 arc_uart_init_one(struct platform_device *pdev, int dev_id)
 {
-	struct resource *res, *res2;
+	struct device_node *np = pdev->dev.of_node;
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 	struct uart_port *port = &uart->port;
-
-	struct device_node *np = pdev->dev.of_node;
 	u32 val;
 
 	if (of_property_read_u32(np, "clock-frequency", &val)) {
@@ -510,21 +508,13 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	}
 	uart->baud = val;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENODEV;
-
-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res2)
-		return -ENODEV;
-
-	port->mapbase = res->start;
-	port->membase = ioremap_nocache(res->start, resource_size(res));
+	port->membase = of_iomap(np, 0);
 	if (!port->membase)
 		/* No point of dev_err since UART itself is hosed here */
 		return -ENXIO;
 
-	port->irq = res2->start;
+	port->irq = irq_of_parse_and_map(np, 0);
+
 	port->dev = &pdev->dev;
 	port->iotype = UPIO_MEM;
 	port->flags = UPF_BOOT_AUTOCONF;

commit 2e6fb7cbd0632d4230d4219ee9eb610f975d6669
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:10 2014 +0530

    serial/arc: remove earlyprintk support and switch to earlycon
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 41d2e351c06d..94d345bfd08d 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -492,33 +492,23 @@ static int
 arc_uart_init_one(struct platform_device *pdev, int dev_id)
 {
 	struct resource *res, *res2;
-	unsigned long *plat_data;
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 	struct uart_port *port = &uart->port;
 
-	plat_data = dev_get_platdata(&pdev->dev);
-	if (!plat_data)
-		return -ENODEV;
+	struct device_node *np = pdev->dev.of_node;
+	u32 val;
 
-	if (is_early_platform_device(pdev)) {
-		port->uartclk = plat_data[1];
-		uart->baud = plat_data[2];
-	} else {
-		struct device_node *np = pdev->dev.of_node;
-		u32 val;
-
-		if (of_property_read_u32(np, "clock-frequency", &val)) {
-			dev_err(&pdev->dev, "clock-frequency property NOTset\n");
-			return -EINVAL;
-		}
-		port->uartclk = val;
-
-		if (of_property_read_u32(np, "current-speed", &val)) {
-			dev_err(&pdev->dev, "current-speed property NOT set\n");
-			return -EINVAL;
-		}
-		uart->baud = val;
+	if (of_property_read_u32(np, "clock-frequency", &val)) {
+		dev_err(&pdev->dev, "clock-frequency property NOTset\n");
+		return -EINVAL;
 	}
+	port->uartclk = val;
+
+	if (of_property_read_u32(np, "current-speed", &val)) {
+		dev_err(&pdev->dev, "current-speed property NOT set\n");
+		return -EINVAL;
+	}
+	uart->baud = val;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
@@ -607,38 +597,6 @@ static struct console arc_console = {
 	.data	= &arc_uart_driver
 };
 
-static __init void early_serial_write(struct console *con, const char *s,
-					unsigned int n)
-{
-	struct uart_port *port = &arc_uart_ports[con->index].port;
-
-	uart_console_write(port, s, n, arc_serial_poll_putchar);
-}
-
-static struct console arc_early_serial_console __initdata = {
-	.name = "early_ARCuart",
-	.write = early_serial_write,
-	.flags = CON_PRINTBUFFER | CON_BOOT,
-	.index = -1
-};
-
-static int __init arc_serial_probe_earlyprintk(struct platform_device *pdev)
-{
-	int dev_id = pdev->id < 0 ? 0 : pdev->id;
-	int rc;
-
-	arc_early_serial_console.index = dev_id;
-
-	rc = arc_uart_init_one(pdev, dev_id);
-	if (rc)
-		panic("early console init failed\n");
-
-	arc_serial_console_setup(&arc_early_serial_console, NULL);
-
-	register_console(&arc_early_serial_console);
-	return 0;
-}
-
 static __init void arc_early_serial_write(struct console *con, const char *s,
 					  unsigned int n)
 {
@@ -713,27 +671,6 @@ static struct platform_driver arc_platform_driver = {
 	 },
 };
 
-#ifdef CONFIG_SERIAL_ARC_CONSOLE
-
-static struct platform_driver early_arc_platform_driver __initdata = {
-	.probe = arc_serial_probe_earlyprintk,
-	.remove = arc_serial_remove,
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	 },
-};
-/*
- * Register an early platform driver of "earlyprintk" class.
- * ARCH platform code installs the driver and probes the early devices
- * The installation could rely on user specifying earlyprintk=xyx in cmd line
- * or it could be done independently, for all "earlyprintk" class drivers.
- * [see arch/arc/plat-arcfpga/platform.c]
- */
-early_platform_init("earlyprintk", &early_arc_platform_driver);
-
-#endif  /* CONFIG_SERIAL_ARC_CONSOLE */
-
 static int __init arc_serial_init(void)
 {
 	int ret;

commit 27cfe4ec17d85c2a9e7f26804d1652ad3fabf19e
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:09 2014 +0530

    serial/arc: Use generic earlycon infrastructure
    
    With this change both earlyprintk and earlycon coexist
    We switch over to latter in next patch
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index ea954c3be18b..41d2e351c06d 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -638,6 +638,36 @@ static int __init arc_serial_probe_earlyprintk(struct platform_device *pdev)
 	register_console(&arc_early_serial_console);
 	return 0;
 }
+
+static __init void arc_early_serial_write(struct console *con, const char *s,
+					  unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, arc_serial_poll_putchar);
+}
+
+static int __init arc_early_console_setup(struct earlycon_device *dev,
+					  const char *opt)
+{
+	struct uart_port *port = &dev->port;
+	unsigned int l, h, hw_val;
+
+	if (!dev->port.membase)
+		return -ENODEV;
+
+	hw_val = port->uartclk / (dev->baud * 4) - 1;
+	l = hw_val & 0xFF;
+	h = (hw_val >> 8) & 0xFF;
+
+	UART_SET_BAUDL(port, l);
+	UART_SET_BAUDH(port, h);
+
+	dev->con->write = arc_early_serial_write;
+	return 0;
+}
+EARLYCON_DECLARE(arc_uart, arc_early_console_setup);
+
 #endif	/* CONFIG_SERIAL_ARC_CONSOLE */
 
 static int arc_serial_probe(struct platform_device *pdev)

commit 5a56d59e853b3dcd97e9497c1c7d3834b24f0664
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:08 2014 +0530

    serial/arc: Remove the workaround for legacy ISS
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index b58544de4e86..ea954c3be18b 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -102,7 +102,6 @@
 struct arc_uart_port {
 	struct uart_port port;
 	unsigned long baud;
-	int is_emulated;	/* H/w vs. Instruction Set Simulator */
 };
 
 #define to_arc_port(uport)  container_of(uport, struct arc_uart_port, port)
@@ -380,17 +379,6 @@ arc_serial_set_termios(struct uart_port *port, struct ktermios *new,
 	uartl = hw_val & 0xFF;
 	uarth = (hw_val >> 8) & 0xFF;
 
-	/*
-	 * UART ISS(Instruction Set simulator) emulation has a subtle bug:
-	 * A existing value of Baudh = 0 is used as a indication to startup
-	 * it's internal state machine.
-	 * Thus if baudh is set to 0, 2 times, it chokes.
-	 * This happens with BAUD=115200 and the formaula above
-	 * Until that is fixed, when running on ISS, we will set baudh to !0
-	 */
-	if (uart->is_emulated)
-		uarth = 1;
-
 	spin_lock_irqsave(&port->lock, flags);
 
 	UART_ALL_IRQ_DISABLE(port);
@@ -512,8 +500,6 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	if (!plat_data)
 		return -ENODEV;
 
-	uart->is_emulated = !!plat_data[0];	/* workaround ISS bug */
-
 	if (is_early_platform_device(pdev)) {
 		port->uartclk = plat_data[1];
 		uart->baud = plat_data[2];

commit 12d15e6f6377fe46b1f9dc51133890a732f1ae05
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:07 2014 +0530

    serial/arc: Refactor by referencing to uart_port where possible
    
    The ARC UART MMIO helpers would take arc_uart_port and then reference
    generic uart_port->membase member. So change them to difrectly refer to
    uart_port and fix call sites accordingly.
    
    This removes the need for to_arc_port() converion almost eveeywhere and
    makes code a bit easier to read.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index b4859598e157..b58544de4e86 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -72,7 +72,7 @@
 #define RXOERR  0x02	/* OverFlow Err: Char recv but RXFULL still set */
 
 /* Uart bit fiddling helpers: lowest level */
-#define RBASE(uart, reg)      (uart->port.membase + reg)
+#define RBASE(port, reg)      (port->membase + reg)
 #define UART_REG_SET(u, r, v) writeb((v), RBASE(u, r))
 #define UART_REG_GET(u, r)    readb(RBASE(u, r))
 
@@ -129,19 +129,15 @@ static struct uart_driver arc_uart_driver = {
 
 static void arc_serial_stop_rx(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
-	UART_RX_IRQ_DISABLE(uart);
+	UART_RX_IRQ_DISABLE(port);
 }
 
 static void arc_serial_stop_tx(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
-	while (!(UART_GET_STATUS(uart) & TXEMPTY))
+	while (!(UART_GET_STATUS(port) & TXEMPTY))
 		cpu_relax();
 
-	UART_TX_IRQ_DISABLE(uart);
+	UART_TX_IRQ_DISABLE(port);
 }
 
 /*
@@ -149,10 +145,9 @@ static void arc_serial_stop_tx(struct uart_port *port)
  */
 static unsigned int arc_serial_tx_empty(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
 	unsigned int stat;
 
-	stat = UART_GET_STATUS(uart);
+	stat = UART_GET_STATUS(port);
 	if (stat & TXEMPTY)
 		return TIOCSER_TEMT;
 
@@ -166,24 +161,24 @@ static unsigned int arc_serial_tx_empty(struct uart_port *port)
  *     = by uart_start( ) before calling us
  *     = tx_ist checks that too before calling
  */
-static void arc_serial_tx_chars(struct arc_uart_port *uart)
+static void arc_serial_tx_chars(struct uart_port *port)
 {
-	struct circ_buf *xmit = &uart->port.state->xmit;
+	struct circ_buf *xmit = &port->state->xmit;
 	int sent = 0;
 	unsigned char ch;
 
-	if (unlikely(uart->port.x_char)) {
-		UART_SET_DATA(uart, uart->port.x_char);
-		uart->port.icount.tx++;
-		uart->port.x_char = 0;
+	if (unlikely(port->x_char)) {
+		UART_SET_DATA(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
 		sent = 1;
 	} else if (xmit->tail != xmit->head) {	/* TODO: uart_circ_empty */
 		ch = xmit->buf[xmit->tail];
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		uart->port.icount.tx++;
-		while (!(UART_GET_STATUS(uart) & TXEMPTY))
+		port->icount.tx++;
+		while (!(UART_GET_STATUS(port) & TXEMPTY))
 			cpu_relax();
-		UART_SET_DATA(uart, ch);
+		UART_SET_DATA(port, ch);
 		sent = 1;
 	}
 
@@ -192,10 +187,10 @@ static void arc_serial_tx_chars(struct arc_uart_port *uart)
 	 * By Hard ISR to schedule processing in software interrupt part
 	 */
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&uart->port);
+		uart_write_wakeup(port);
 
 	if (sent)
-		UART_TX_IRQ_ENABLE(uart);
+		UART_TX_IRQ_ENABLE(port);
 }
 
 /*
@@ -204,12 +199,10 @@ static void arc_serial_tx_chars(struct arc_uart_port *uart)
  */
 static void arc_serial_start_tx(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
-	arc_serial_tx_chars(uart);
+	arc_serial_tx_chars(port);
 }
 
-static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
+static void arc_serial_rx_chars(struct uart_port *port, unsigned int status)
 {
 	unsigned int ch, flg = 0;
 
@@ -229,15 +222,15 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 		 */
 		if (unlikely(status & (RXOERR | RXFERR))) {
 			if (status & RXOERR) {
-				uart->port.icount.overrun++;
+				port->icount.overrun++;
 				flg = TTY_OVERRUN;
-				UART_CLR_STATUS(uart, RXOERR);
+				UART_CLR_STATUS(port, RXOERR);
 			}
 
 			if (status & RXFERR) {
-				uart->port.icount.frame++;
+				port->icount.frame++;
 				flg = TTY_FRAME;
-				UART_CLR_STATUS(uart, RXFERR);
+				UART_CLR_STATUS(port, RXFERR);
 			}
 		} else
 			flg = TTY_NORMAL;
@@ -245,16 +238,16 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 		if (status & RXEMPTY)
 			continue;
 
-		ch = UART_GET_DATA(uart);
-		uart->port.icount.rx++;
+		ch = UART_GET_DATA(port);
+		port->icount.rx++;
 
-		if (!(uart_handle_sysrq_char(&uart->port, ch)))
-			uart_insert_char(&uart->port, status, RXOERR, ch, flg);
+		if (!(uart_handle_sysrq_char(port, ch)))
+			uart_insert_char(port, status, RXOERR, ch, flg);
 
-		spin_unlock(&uart->port.lock);
-		tty_flip_buffer_push(&uart->port.state->port);
-		spin_lock(&uart->port.lock);
-	} while (!((status = UART_GET_STATUS(uart)) & RXEMPTY));
+		spin_unlock(&port->lock);
+		tty_flip_buffer_push(&port->state->port);
+		spin_lock(&port->lock);
+	} while (!((status = UART_GET_STATUS(port)) & RXEMPTY));
 }
 
 /*
@@ -287,10 +280,10 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 
 static irqreturn_t arc_serial_isr(int irq, void *dev_id)
 {
-	struct arc_uart_port *uart = dev_id;
+	struct uart_port *port = dev_id;
 	unsigned int status;
 
-	status = UART_GET_STATUS(uart);
+	status = UART_GET_STATUS(port);
 
 	/*
 	 * Single IRQ for both Rx (data available) Tx (room available) Interrupt
@@ -300,9 +293,9 @@ static irqreturn_t arc_serial_isr(int irq, void *dev_id)
 	if (status & RXIENB) {
 
 		/* already in ISR, no need of xx_irqsave */
-		spin_lock(&uart->port.lock);
-		arc_serial_rx_chars(uart, status);
-		spin_unlock(&uart->port.lock);
+		spin_lock(&port->lock);
+		arc_serial_rx_chars(port, status);
+		spin_unlock(&port->lock);
 	}
 
 	if ((status & TXIENB) && (status & TXEMPTY)) {
@@ -310,14 +303,14 @@ static irqreturn_t arc_serial_isr(int irq, void *dev_id)
 		/* Unconditionally disable further Tx-Interrupts.
 		 * will be enabled by tx_chars() if needed.
 		 */
-		UART_TX_IRQ_DISABLE(uart);
+		UART_TX_IRQ_DISABLE(port);
 
-		spin_lock(&uart->port.lock);
+		spin_lock(&port->lock);
 
-		if (!uart_tx_stopped(&uart->port))
-			arc_serial_tx_chars(uart);
+		if (!uart_tx_stopped(port))
+			arc_serial_tx_chars(port);
 
-		spin_unlock(&uart->port.lock);
+		spin_unlock(&port->lock);
 	}
 
 	return IRQ_HANDLED;
@@ -347,18 +340,15 @@ static void arc_serial_break_ctl(struct uart_port *port, int break_state)
 
 static int arc_serial_startup(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
 	/* Before we hook up the ISR, Disable all UART Interrupts */
-	UART_ALL_IRQ_DISABLE(uart);
+	UART_ALL_IRQ_DISABLE(port);
 
-	if (request_irq(uart->port.irq, arc_serial_isr, 0, "arc uart rx-tx",
-			uart)) {
-		dev_warn(uart->port.dev, "Unable to attach ARC UART intr\n");
+	if (request_irq(port->irq, arc_serial_isr, 0, "arc uart rx-tx", port)) {
+		dev_warn(port->dev, "Unable to attach ARC UART intr\n");
 		return -EBUSY;
 	}
 
-	UART_RX_IRQ_ENABLE(uart); /* Only Rx IRQ enabled to begin with */
+	UART_RX_IRQ_ENABLE(port); /* Only Rx IRQ enabled to begin with */
 
 	return 0;
 }
@@ -366,8 +356,7 @@ static int arc_serial_startup(struct uart_port *port)
 /* This is not really needed */
 static void arc_serial_shutdown(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-	free_irq(uart->port.irq, uart);
+	free_irq(port->irq, port);
 }
 
 static void
@@ -404,12 +393,12 @@ arc_serial_set_termios(struct uart_port *port, struct ktermios *new,
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	UART_ALL_IRQ_DISABLE(uart);
+	UART_ALL_IRQ_DISABLE(port);
 
-	UART_SET_BAUDL(uart, uartl);
-	UART_SET_BAUDH(uart, uarth);
+	UART_SET_BAUDL(port, uartl);
+	UART_SET_BAUDH(port, uarth);
 
-	UART_RX_IRQ_ENABLE(uart);
+	UART_RX_IRQ_ENABLE(port);
 
 	/*
 	 * UART doesn't support Parity/Hardware Flow Control;
@@ -432,9 +421,7 @@ arc_serial_set_termios(struct uart_port *port, struct ktermios *new,
 
 static const char *arc_serial_type(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
-	return uart->port.type == PORT_ARC ? DRIVER_NAME : NULL;
+	return port->type == PORT_ARC ? DRIVER_NAME : NULL;
 }
 
 static void arc_serial_release_port(struct uart_port *port)
@@ -463,35 +450,30 @@ arc_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
  */
 static void arc_serial_config_port(struct uart_port *port, int flags)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
 	if (flags & UART_CONFIG_TYPE)
-		uart->port.type = PORT_ARC;
+		port->type = PORT_ARC;
 }
 
 #if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_ARC_CONSOLE)
 
 static void arc_serial_poll_putchar(struct uart_port *port, int chr)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
-
-	while (!(UART_GET_STATUS(uart) & TXEMPTY))
+	while (!(UART_GET_STATUS(port) & TXEMPTY))
 		cpu_relax();
 
-	UART_SET_DATA(uart, (unsigned char)chr);
+	UART_SET_DATA(port, (unsigned char)chr);
 }
 #endif
 
 #ifdef CONFIG_CONSOLE_POLL
 static int arc_serial_poll_getchar(struct uart_port *port)
 {
-	struct arc_uart_port *uart = to_arc_port(port);
 	unsigned char chr;
 
-	while (!(UART_GET_STATUS(uart) & RXEMPTY))
+	while (!(UART_GET_STATUS(port) & RXEMPTY))
 		cpu_relax();
 
-	chr = UART_GET_DATA(uart);
+	chr = UART_GET_DATA(port);
 	return chr;
 }
 #endif
@@ -524,6 +506,7 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	struct resource *res, *res2;
 	unsigned long *plat_data;
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
+	struct uart_port *port = &uart->port;
 
 	plat_data = dev_get_platdata(&pdev->dev);
 	if (!plat_data)
@@ -532,7 +515,7 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	uart->is_emulated = !!plat_data[0];	/* workaround ISS bug */
 
 	if (is_early_platform_device(pdev)) {
-		uart->port.uartclk = plat_data[1];
+		port->uartclk = plat_data[1];
 		uart->baud = plat_data[2];
 	} else {
 		struct device_node *np = pdev->dev.of_node;
@@ -542,7 +525,7 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 			dev_err(&pdev->dev, "clock-frequency property NOTset\n");
 			return -EINVAL;
 		}
-		uart->port.uartclk = val;
+		port->uartclk = val;
 
 		if (of_property_read_u32(np, "current-speed", &val)) {
 			dev_err(&pdev->dev, "current-speed property NOT set\n");
@@ -559,26 +542,26 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	if (!res2)
 		return -ENODEV;
 
-	uart->port.mapbase = res->start;
-	uart->port.membase = ioremap_nocache(res->start, resource_size(res));
-	if (!uart->port.membase)
+	port->mapbase = res->start;
+	port->membase = ioremap_nocache(res->start, resource_size(res));
+	if (!port->membase)
 		/* No point of dev_err since UART itself is hosed here */
 		return -ENXIO;
 
-	uart->port.irq = res2->start;
-	uart->port.dev = &pdev->dev;
-	uart->port.iotype = UPIO_MEM;
-	uart->port.flags = UPF_BOOT_AUTOCONF;
-	uart->port.line = dev_id;
-	uart->port.ops = &arc_serial_pops;
+	port->irq = res2->start;
+	port->dev = &pdev->dev;
+	port->iotype = UPIO_MEM;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->line = dev_id;
+	port->ops = &arc_serial_pops;
 
-	uart->port.fifosize = ARC_UART_TX_FIFO_SIZE;
+	port->fifosize = ARC_UART_TX_FIFO_SIZE;
 
 	/*
 	 * uart_insert_char( ) uses it in decideding whether to ignore a
 	 * char or not. Explicitly setting it here, removes the subtelty
 	 */
-	uart->port.ignore_status_mask = 0;
+	port->ignore_status_mask = 0;
 
 	return 0;
 }

commit 3bce1b70d6f2cdb83c9323c553b2336974b8516f
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jun 24 13:55:06 2014 +0530

    serial/arc: use uart_console_write() helper
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 643658f2b5b2..b4859598e157 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -471,14 +471,14 @@ static void arc_serial_config_port(struct uart_port *port, int flags)
 
 #if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_ARC_CONSOLE)
 
-static void arc_serial_poll_putchar(struct uart_port *port, unsigned char chr)
+static void arc_serial_poll_putchar(struct uart_port *port, int chr)
 {
 	struct arc_uart_port *uart = to_arc_port(port);
 
 	while (!(UART_GET_STATUS(uart) & TXEMPTY))
 		cpu_relax();
 
-	UART_SET_DATA(uart, chr);
+	UART_SET_DATA(uart, (unsigned char)chr);
 }
 #endif
 
@@ -614,11 +614,6 @@ static int arc_serial_console_setup(struct console *co, char *options)
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
-static void arc_serial_console_putchar(struct uart_port *port, int ch)
-{
-	arc_serial_poll_putchar(port, (unsigned char)ch);
-}
-
 /*
  * Interrupts are disabled on entering
  */
@@ -629,7 +624,7 @@ static void arc_serial_console_write(struct console *co, const char *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
-	uart_console_write(port, s, count, arc_serial_console_putchar);
+	uart_console_write(port, s, count, arc_serial_poll_putchar);
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -647,13 +642,8 @@ static __init void early_serial_write(struct console *con, const char *s,
 					unsigned int n)
 {
 	struct uart_port *port = &arc_uart_ports[con->index].port;
-	unsigned int i;
 
-	for (i = 0; i < n; i++, s++) {
-		if (*s == '\n')
-			arc_serial_poll_putchar(port, '\r');
-		arc_serial_poll_putchar(port, *s);
-	}
+	uart_console_write(port, s, n, arc_serial_poll_putchar);
 }
 
 static struct console arc_early_serial_console __initdata = {

commit 8b152f1096975d012f60387b899d407e4a93b46c
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Tue Jun 3 18:54:44 2014 +0400

    serial: treewide: Remove empty implementations of enable_ms()
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index c9f5c9dcc15c..643658f2b5b2 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -340,13 +340,6 @@ static void arc_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	/* MCR not present */
 }
 
-/* Enable Modem Status Interrupts */
-
-static void arc_serial_enable_ms(struct uart_port *port)
-{
-	/* MSR not present */
-}
-
 static void arc_serial_break_ctl(struct uart_port *port, int break_state)
 {
 	/* ARC UART doesn't support sending Break signal */
@@ -510,7 +503,6 @@ static struct uart_ops arc_serial_pops = {
 	.stop_tx	= arc_serial_stop_tx,
 	.start_tx	= arc_serial_start_tx,
 	.stop_rx	= arc_serial_stop_rx,
-	.enable_ms	= arc_serial_enable_ms,
 	.break_ctl	= arc_serial_break_ctl,
 	.startup	= arc_serial_startup,
 	.shutdown	= arc_serial_shutdown,

commit 0d8570ad7ec99f4c89135657ea2821bdae78423f
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Sep 9 14:06:45 2013 +0900

    serial: arc_uart: Remove casting the return value which is a void pointer
    
    Casting the return value which is a void pointer is redundant.
    The conversion from void pointer to any other pointer type is
    guaranteed by the C programming language.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 569872f4c9b8..c9f5c9dcc15c 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -533,7 +533,7 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	unsigned long *plat_data;
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 
-	plat_data = (unsigned long *)dev_get_platdata(&pdev->dev);
+	plat_data = dev_get_platdata(&pdev->dev);
 	if (!plat_data)
 		return -ENODEV;
 

commit 3fa1200851c7ff88950042d827554334dba8b58d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 19 20:14:09 2013 +0530

    tty: serial: arc: drop uart_port->lock before calling tty_flip_buffer_push()
    
    The current driver triggers a lockdep warning for if tty_flip_buffer_push() is
    called with uart_port->lock locked. This never shows up on UP kernels and comes
    up only on SMP kernels.
    
    Crash looks like this (produced with samsung.c driver):
    
    -----
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8)
    [<c01b59ac>] (do_raw_spin_unlock+0xc4/0xd8) from [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0)
    [<c03627e4>] (_raw_spin_unlock_irqrestore+0xc/0x38) from [<c020a1a8>] (s3c24xx_serial_rx_chars+0)
    [<c020a1a8>] (s3c24xx_serial_rx_chars+0x12c/0x260) from [<c020aae8>] (s3c64xx_serial_handle_irq+)
    [<c020aae8>] (s3c64xx_serial_handle_irq+0x48/0x60) from [<c006aaa0>] (handle_irq_event_percpu+0x)
    [<c006aaa0>] (handle_irq_event_percpu+0x50/0x194) from [<c006ac20>] (handle_irq_event+0x3c/0x5c)
    [<c006ac20>] (handle_irq_event+0x3c/0x5c) from [<c006d864>] (handle_fasteoi_irq+0x80/0x13c)
    [<c006d864>] (handle_fasteoi_irq+0x80/0x13c) from [<c006a4a4>] (generic_handle_irq+0x20/0x30)
    [<c006a4a4>] (generic_handle_irq+0x20/0x30) from [<c000f454>] (handle_IRQ+0x38/0x94)
    [<c000f454>] (handle_IRQ+0x38/0x94) from [<c0008538>] (gic_handle_irq+0x34/0x68)
    [<c0008538>] (gic_handle_irq+0x34/0x68) from [<c00123c0>] (__irq_svc+0x40/0x70)
    Exception stack(0xc04cdf70 to 0xc04cdfb8)
    df60:                                     00000000 00000000 0000166e 00000000
    df80: c04cc000 c050278f c050278f 00000001 c04d444c 410fc0f4 c03649b0 00000000
    dfa0: 00000001 c04cdfb8 c000f758 c000f75c 60070013 ffffffff
    [<c00123c0>] (__irq_svc+0x40/0x70) from [<c000f75c>] (arch_cpu_idle+0x28/0x30)
    [<c000f75c>] (arch_cpu_idle+0x28/0x30) from [<c0054888>] (cpu_startup_entry+0x5c/0x148)
    [<c0054888>] (cpu_startup_entry+0x5c/0x148) from [<c0497aa4>] (start_kernel+0x334/0x38c)
    BUG: spinlock lockup suspected on CPU#0, kworker/0:1/360
     lock: s3c24xx_serial_ports+0x1d8/0x370, .magic: dead4ead, .owner: <none>/-1, .owner_cpu: -1
    CPU: 0 PID: 360 Comm: kworker/0:1 Not tainted 3.11.0-rc6-next-20130819-00003-g75485f1 #2
    Workqueue: events flush_to_ldisc
    [<c0014d58>] (unwind_backtrace+0x0/0xf8) from [<c0011908>] (show_stack+0x10/0x14)
    [<c0011908>] (show_stack+0x10/0x14) from [<c035da34>] (dump_stack+0x6c/0xac)
    [<c035da34>] (dump_stack+0x6c/0xac) from [<c01b581c>] (do_raw_spin_lock+0x100/0x17c)
    [<c01b581c>] (do_raw_spin_lock+0x100/0x17c) from [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28)
    [<c03628a0>] (_raw_spin_lock_irqsave+0x20/0x28) from [<c0203224>] (uart_start+0x18/0x34)
    [<c0203224>] (uart_start+0x18/0x34) from [<c01ef890>] (__receive_buf+0x4b4/0x738)
    [<c01ef890>] (__receive_buf+0x4b4/0x738) from [<c01efb44>] (n_tty_receive_buf2+0x30/0x98)
    [<c01efb44>] (n_tty_receive_buf2+0x30/0x98) from [<c01f2ba8>] (flush_to_ldisc+0xec/0x138)
    [<c01f2ba8>] (flush_to_ldisc+0xec/0x138) from [<c0031af0>] (process_one_work+0xfc/0x348)
    [<c0031af0>] (process_one_work+0xfc/0x348) from [<c0032138>] (worker_thread+0x138/0x37c)
    [<c0032138>] (worker_thread+0x138/0x37c) from [<c0037a7c>] (kthread+0xa4/0xb0)
    [<c0037a7c>] (kthread+0xa4/0xb0) from [<c000e5f8>] (ret_from_fork+0x14/0x3c)
    -----
    
    Release the port lock before calling tty_flip_buffer_push() and reacquire it
    after the call.
    
    Similar stuff was already done for few other drivers in the past, like:
    
    commit 2389b272168ceec056ca1d8a870a97fa9c26e11a
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue May 29 21:53:50 2007 +0100
    
        [ARM] 4417/1: Serial: Fix AMBA drivers locking
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 37abf6ca2f34..569872f4c9b8 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -251,7 +251,9 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 		if (!(uart_handle_sysrq_char(&uart->port, ch)))
 			uart_insert_char(&uart->port, status, RXOERR, ch, flg);
 
+		spin_unlock(&uart->port.lock);
 		tty_flip_buffer_push(&uart->port.state->port);
+		spin_lock(&uart->port.lock);
 	} while (!((status = UART_GET_STATUS(uart)) & RXEMPTY));
 }
 

commit 5ac1ccb70a3b7d4627c257fcbb2579b2dc4d2a0a
Merge: a4f2dc9efc00 c095ba7224d8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 5 05:41:03 2013 +0800

    Merge 3.11-rc4 into tty-next
    
    We want the tty fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 00a135b3952f6ccedfb688919c59bb3fa199a11f
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Thu Aug 1 21:49:20 2013 -0700

    serial/arc-uart: Remove the goto/label
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Mischa Jonker <mjonker@synopsys.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index e296c892df61..6ac5270c74dd 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -248,12 +248,9 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 		ch = UART_GET_DATA(uart);
 		uart->port.icount.rx++;
 
-		if (unlikely(uart_handle_sysrq_char(&uart->port, ch)))
-			goto done;
+		if (!(uart_handle_sysrq_char(&uart->port, ch)))
+			uart_insert_char(&uart->port, status, RXOERR, ch, flg);
 
-		uart_insert_char(&uart->port, status, RXOERR, ch, flg);
-
-done:
 		tty_flip_buffer_push(&uart->port.state->port);
 	} while (!((status = UART_GET_STATUS(uart)) & RXEMPTY));
 }

commit 5284eba7b37dfeffe75bfdf81a13e9efebe0480a
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Thu Aug 1 21:49:19 2013 -0700

    serial/arc-uart: Handle Rx Error Interrupts w/o any data
    
    Currently, Rx error handling only triggers if there is some Rx data.
    Fix that by checking for error - before the data handling.
    
    Reported-by: Mischa Jonker <mjonker@synopsys.com>
    Tested-by: Mischa Jonker <mjonker@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 2f195f0d7a11..e296c892df61 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -209,9 +209,9 @@ static void arc_serial_start_tx(struct uart_port *port)
 	arc_serial_tx_chars(uart);
 }
 
-static void arc_serial_rx_chars(struct arc_uart_port *uart)
+static void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)
 {
-	unsigned int status, ch, flg = 0;
+	unsigned int ch, flg = 0;
 
 	/*
 	 * UART has 4 deep RX-FIFO. Driver's recongnition of this fact
@@ -222,11 +222,11 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart)
 	 * before RX-EMPTY=0, implies some sort of buffering going on in the
 	 * controller, which is indeed the Rx-FIFO.
 	 */
-	while (!((status = UART_GET_STATUS(uart)) & RXEMPTY)) {
-
-		ch = UART_GET_DATA(uart);
-		uart->port.icount.rx++;
-
+	do {
+		/*
+		 * This could be an Rx Intr for err (no data),
+		 * so check err and clear that Intr first
+		 */
 		if (unlikely(status & (RXOERR | RXFERR))) {
 			if (status & RXOERR) {
 				uart->port.icount.overrun++;
@@ -242,6 +242,12 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart)
 		} else
 			flg = TTY_NORMAL;
 
+		if (status & RXEMPTY)
+			continue;
+
+		ch = UART_GET_DATA(uart);
+		uart->port.icount.rx++;
+
 		if (unlikely(uart_handle_sysrq_char(&uart->port, ch)))
 			goto done;
 
@@ -249,7 +255,7 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart)
 
 done:
 		tty_flip_buffer_push(&uart->port.state->port);
-	}
+	} while (!((status = UART_GET_STATUS(uart)) & RXEMPTY));
 }
 
 /*
@@ -292,11 +298,11 @@ static irqreturn_t arc_serial_isr(int irq, void *dev_id)
 	 * notifications from the UART Controller.
 	 * To demultiplex between the two, we check the relevant bits
 	 */
-	if ((status & RXIENB) && !(status & RXEMPTY)) {
+	if (status & RXIENB) {
 
 		/* already in ISR, no need of xx_irqsave */
 		spin_lock(&uart->port.lock);
-		arc_serial_rx_chars(uart);
+		arc_serial_rx_chars(uart, status);
 		spin_unlock(&uart->port.lock);
 	}
 

commit 574de559c1797618fd8ed03576837eb3113c5d26
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:06:57 2013 +0900

    serial: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index cbf1d155b7b2..2f195f0d7a11 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -528,7 +528,7 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	unsigned long *plat_data;
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 
-	plat_data = ((unsigned long *)(pdev->dev.platform_data));
+	plat_data = (unsigned long *)dev_get_platdata(&pdev->dev);
 	if (!plat_data)
 		return -ENODEV;
 

commit d5a12ea7a9e58d9e5c19d25cb668aadb396423ec
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Jul 21 10:14:15 2013 +0800

    serial: arc_uart: Fix module alias
    
    Platform drivers use "platform:" prefix in module alias.
    Also use DRIVER_NAME in MODULE_ALIAS to make module autoloading work.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index cbf1d155b7b2..22f280aa4f2c 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -773,6 +773,6 @@ module_init(arc_serial_init);
 module_exit(arc_serial_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("plat-arcfpga/uart");
+MODULE_ALIAS("platform:" DRIVER_NAME);
 MODULE_AUTHOR("Vineet Gupta");
 MODULE_DESCRIPTION("ARC(Synopsys) On-Chip(fpga) serial driver");

commit ee7970690568b0c875467f475d9c957ec0d9e099
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Mar 7 13:12:34 2013 +0100

    TTY: cleanup tty->hw_stopped uses
    
    tty->hw_stopped is set only by drivers to remember HW state. If it is
    never set to 1 in a particular driver, there is no need to check it in
    the driver at all. Remove such checks.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index d97e194b6bc5..cbf1d155b7b2 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -162,7 +162,7 @@ static unsigned int arc_serial_tx_empty(struct uart_port *port)
 /*
  * Driver internal routine, used by both tty(serial core) as well as tx-isr
  *  -Called under spinlock in either cases
- *  -also tty->stopped / tty->hw_stopped has already been checked
+ *  -also tty->stopped has already been checked
  *     = by uart_start( ) before calling us
  *     = tx_ist checks that too before calling
  */

commit 11c62d4f1d8583dd6305824d704f33301da4e93a
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Mon Feb 11 14:11:41 2013 +0530

    serial/arc-uart: Miscll DT related updates (Grant's review comments)
    
    -replace "baud" with "current-speed"
    -if uart alias doesn't exist in DT, don't abort, pick 0
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Rob Landley <rob@landley.net>
    Cc: linux-serial@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 6f7eadc424a3..d97e194b6bc5 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -547,8 +547,8 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 		}
 		uart->port.uartclk = val;
 
-		if (of_property_read_u32(np, "baud", &val)) {
-			dev_err(&pdev->dev, "baud property NOT set\n");
+		if (of_property_read_u32(np, "current-speed", &val)) {
+			dev_err(&pdev->dev, "current-speed property NOT set\n");
 			return -EINVAL;
 		}
 		uart->baud = val;
@@ -694,10 +694,8 @@ static int arc_serial_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	dev_id = of_alias_get_id(np, "serial");
-	if (dev_id < 0) {
-		dev_err(&pdev->dev, "failed to get alias id: %d\n", dev_id);
-		return dev_id;
-	}
+	if (dev_id < 0)
+		dev_id = 0;
 
 	rc = arc_uart_init_one(pdev, dev_id);
 	if (rc)

commit 795b5bbe215c7b988fcf218613d2f3357924f0d2
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Wed Jan 16 13:47:23 2013 +0530

    serial/arc-uart: Fix section mistmatch
    
    Commit "serial/arc-uart: split probe from probe_earlyprintk" introduced
    a build time warning:
    
    "WARNING: vmlinux.o(.data+0x5baa0): Section mismatch in reference from
    the variable early_arc_platform_driver to the function
    .init.text:arc_serial_probe_earlyprintk()"
    
    While at it - fixed another incorrectly placed initdata annotation.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: fengguang.wu@intel.com
    Cc: linux-serial@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index da734222e537..6f7eadc424a3 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -659,7 +659,7 @@ static __init void early_serial_write(struct console *con, const char *s,
 	}
 }
 
-static struct __initdata console arc_early_serial_console = {
+static struct console arc_early_serial_console __initdata = {
 	.name = "early_ARCuart",
 	.write = early_serial_write,
 	.flags = CON_PRINTBUFFER | CON_BOOT,
@@ -731,7 +731,7 @@ static struct platform_driver arc_platform_driver = {
 
 #ifdef CONFIG_SERIAL_ARC_CONSOLE
 
-static struct platform_driver early_arc_platform_driver = {
+static struct platform_driver early_arc_platform_driver __initdata = {
 	.probe = arc_serial_probe_earlyprintk,
 	.remove = arc_serial_remove,
 	.driver = {

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index b46860104312..da734222e537 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -211,12 +211,8 @@ static void arc_serial_start_tx(struct uart_port *port)
 
 static void arc_serial_rx_chars(struct arc_uart_port *uart)
 {
-	struct tty_struct *tty = tty_port_tty_get(&uart->port.state->port);
 	unsigned int status, ch, flg = 0;
 
-	if (!tty)
-		return;
-
 	/*
 	 * UART has 4 deep RX-FIFO. Driver's recongnition of this fact
 	 * is very subtle. Here's how ...
@@ -252,10 +248,8 @@ static void arc_serial_rx_chars(struct arc_uart_port *uart)
 		uart_insert_char(&uart->port, status, RXOERR, ch, flg);
 
 done:
-		tty_flip_buffer_push(tty);
+		tty_flip_buffer_push(&uart->port.state->port);
 	}
-
-	tty_kref_put(tty);
 }
 
 /*

commit ea28fd56fcde69af768135e428093f94c5ca6a88
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Jan 11 11:50:23 2013 +0530

    serial/arc-uart: switch to devicetree based probing
    
    * DT binding for arc-uart
    * With alll the bits in place we can now use DT probing.
    
    Note that there's a bit of kludge right now because earlyprintk portion
    of driver can't use the DT infrastrcuture to get resoures/plat_data.
    This requires some infrastructre changes to of_flat_ framework
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Rob Landley <rob@landley.net>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 2db64105677b..b46860104312 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -37,6 +37,8 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_core.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
 
 /*************************************
  * ARC UART Hardware Specs
@@ -537,8 +539,26 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 		return -ENODEV;
 
 	uart->is_emulated = !!plat_data[0];	/* workaround ISS bug */
-	uart->port.uartclk = plat_data[1];
-	uart->baud = plat_data[2];
+
+	if (is_early_platform_device(pdev)) {
+		uart->port.uartclk = plat_data[1];
+		uart->baud = plat_data[2];
+	} else {
+		struct device_node *np = pdev->dev.of_node;
+		u32 val;
+
+		if (of_property_read_u32(np, "clock-frequency", &val)) {
+			dev_err(&pdev->dev, "clock-frequency property NOTset\n");
+			return -EINVAL;
+		}
+		uart->port.uartclk = val;
+
+		if (of_property_read_u32(np, "baud", &val)) {
+			dev_err(&pdev->dev, "baud property NOT set\n");
+			return -EINVAL;
+		}
+		uart->baud = val;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
@@ -673,8 +693,18 @@ static int __init arc_serial_probe_earlyprintk(struct platform_device *pdev)
 static int arc_serial_probe(struct platform_device *pdev)
 {
 	int rc, dev_id;
+	struct device_node *np = pdev->dev.of_node;
+
+	/* no device tree device */
+	if (!np)
+		return -ENODEV;
+
+	dev_id = of_alias_get_id(np, "serial");
+	if (dev_id < 0) {
+		dev_err(&pdev->dev, "failed to get alias id: %d\n", dev_id);
+		return dev_id;
+	}
 
-	dev_id = pdev->id < 0 ? 0 : pdev->id;
 	rc = arc_uart_init_one(pdev, dev_id);
 	if (rc)
 		return rc;
@@ -689,12 +719,19 @@ static int arc_serial_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id arc_uart_dt_ids[] = {
+	{ .compatible = "snps,arc-uart" },
+	{ /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, arc_uart_dt_ids);
+
 static struct platform_driver arc_platform_driver = {
 	.probe = arc_serial_probe,
 	.remove = arc_serial_remove,
 	.driver = {
 		.name = DRIVER_NAME,
 		.owner = THIS_MODULE,
+		.of_match_table  = arc_uart_dt_ids,
 	 },
 };
 

commit d6c0d06b341803fde45e592df4233579f3afb04e
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Jan 11 11:50:22 2013 +0530

    serial/arc-uart: platform_data order changed
    
    * is_emulated is now 1st element, rather than last
    * also tucked all platform data refs together
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-serial@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 9de26ba48d20..2db64105677b 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -533,7 +533,12 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 
 	plat_data = ((unsigned long *)(pdev->dev.platform_data));
-	uart->baud = plat_data[0];
+	if (!plat_data)
+		return -ENODEV;
+
+	uart->is_emulated = !!plat_data[0];	/* workaround ISS bug */
+	uart->port.uartclk = plat_data[1];
+	uart->baud = plat_data[2];
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
@@ -556,7 +561,6 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	uart->port.line = dev_id;
 	uart->port.ops = &arc_serial_pops;
 
-	uart->port.uartclk = plat_data[1];
 	uart->port.fifosize = ARC_UART_TX_FIFO_SIZE;
 
 	/*
@@ -565,9 +569,6 @@ arc_uart_init_one(struct platform_device *pdev, int dev_id)
 	 */
 	uart->port.ignore_status_mask = 0;
 
-	/* Real Hardware vs. emulated to work around a bug */
-	uart->is_emulated = !!plat_data[2];
-
 	return 0;
 }
 

commit e163d1f42bc2089efae58b4966287c4d3504d4c7
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Jan 11 11:50:21 2013 +0530

    serial/arc-uart: split probe from probe_earlyprintk
    
    This is in preparation for devicetree based probing, where earlyprintk
    won't have access to DT serial aliases which the normal probe would
    absolutely rely on.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-serial@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 8089dc355ac5..9de26ba48d20 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -651,7 +651,7 @@ static struct __initdata console arc_early_serial_console = {
 	.index = -1
 };
 
-static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
+static int __init arc_serial_probe_earlyprintk(struct platform_device *pdev)
 {
 	int dev_id = pdev->id < 0 ? 0 : pdev->id;
 	int rc;
@@ -667,20 +667,12 @@ static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
 	register_console(&arc_early_serial_console);
 	return 0;
 }
-#else
-static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
-{
-	return -ENODEV;
-}
 #endif	/* CONFIG_SERIAL_ARC_CONSOLE */
 
 static int arc_serial_probe(struct platform_device *pdev)
 {
 	int rc, dev_id;
 
-	if (is_early_platform_device(pdev))
-		return arc_serial_probe_earlyprintk(pdev);
-
 	dev_id = pdev->id < 0 ? 0 : pdev->id;
 	rc = arc_uart_init_one(pdev, dev_id);
 	if (rc)
@@ -706,6 +698,15 @@ static struct platform_driver arc_platform_driver = {
 };
 
 #ifdef CONFIG_SERIAL_ARC_CONSOLE
+
+static struct platform_driver early_arc_platform_driver = {
+	.probe = arc_serial_probe_earlyprintk,
+	.remove = arc_serial_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	 },
+};
 /*
  * Register an early platform driver of "earlyprintk" class.
  * ARCH platform code installs the driver and probes the early devices
@@ -713,7 +714,7 @@ static struct platform_driver arc_platform_driver = {
  * or it could be done independently, for all "earlyprintk" class drivers.
  * [see arch/arc/plat-arcfpga/platform.c]
  */
-early_platform_init("earlyprintk", &arc_platform_driver);
+early_platform_init("earlyprintk", &early_arc_platform_driver);
 
 #endif  /* CONFIG_SERIAL_ARC_CONSOLE */
 

commit 026bb292c4018dd77186dee1fcb73c9067e69b89
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Jan 11 11:50:20 2013 +0530

    serial/arc-uart: Don't index with -ve platform_device->id
    
    probe routine could index into port[] with -ve index. The check in
    arc_uart_init_one() was too late.
    
    This came to light when trying to port driver to CONFIG_OF, where
    bydefault of-core code sets -ve platform dev id and in absence of
    DT serial aliases, driver would use the -ve index.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-serial@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 3e0b3fac6a0e..8089dc355ac5 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -526,15 +526,11 @@ static struct uart_ops arc_serial_pops = {
 };
 
 static int
-arc_uart_init_one(struct platform_device *pdev, struct arc_uart_port *uart)
+arc_uart_init_one(struct platform_device *pdev, int dev_id)
 {
 	struct resource *res, *res2;
 	unsigned long *plat_data;
-
-	if (pdev->id < 0 || pdev->id >= CONFIG_SERIAL_ARC_NR_PORTS) {
-		dev_err(&pdev->dev, "Wrong uart platform device id.\n");
-		return -ENOENT;
-	}
+	struct arc_uart_port *uart = &arc_uart_ports[dev_id];
 
 	plat_data = ((unsigned long *)(pdev->dev.platform_data));
 	uart->baud = plat_data[0];
@@ -557,7 +553,7 @@ arc_uart_init_one(struct platform_device *pdev, struct arc_uart_port *uart)
 	uart->port.dev = &pdev->dev;
 	uart->port.iotype = UPIO_MEM;
 	uart->port.flags = UPF_BOOT_AUTOCONF;
-	uart->port.line = pdev->id;
+	uart->port.line = dev_id;
 	uart->port.ops = &arc_serial_pops;
 
 	uart->port.uartclk = plat_data[1];
@@ -657,9 +653,14 @@ static struct __initdata console arc_early_serial_console = {
 
 static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
 {
-	arc_early_serial_console.index = pdev->id;
+	int dev_id = pdev->id < 0 ? 0 : pdev->id;
+	int rc;
 
-	arc_uart_init_one(pdev, &arc_uart_ports[pdev->id]);
+	arc_early_serial_console.index = dev_id;
+
+	rc = arc_uart_init_one(pdev, dev_id);
+	if (rc)
+		panic("early console init failed\n");
 
 	arc_serial_console_setup(&arc_early_serial_console, NULL);
 
@@ -675,18 +676,18 @@ static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
 
 static int arc_serial_probe(struct platform_device *pdev)
 {
-	struct arc_uart_port *uart;
-	int rc;
+	int rc, dev_id;
 
 	if (is_early_platform_device(pdev))
 		return arc_serial_probe_earlyprintk(pdev);
 
-	uart = &arc_uart_ports[pdev->id];
-	rc = arc_uart_init_one(pdev, uart);
+	dev_id = pdev->id < 0 ? 0 : pdev->id;
+	rc = arc_uart_init_one(pdev, dev_id);
 	if (rc)
 		return rc;
 
-	return uart_add_one_port(&arc_uart_driver, &uart->port);
+	rc = uart_add_one_port(&arc_uart_driver, &arc_uart_ports[dev_id].port);
+	return rc;
 }
 
 static int arc_serial_remove(struct platform_device *pdev)

commit ae8d8a146725a966bd7c59c94f4d0016dcf7a04f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:18 2012 -0500

    tty: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: David Brown <davidb@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index 158d798a5203..3e0b3fac6a0e 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -689,7 +689,7 @@ static int arc_serial_probe(struct platform_device *pdev)
 	return uart_add_one_port(&arc_uart_driver, &uart->port);
 }
 
-static int __devexit arc_serial_remove(struct platform_device *pdev)
+static int arc_serial_remove(struct platform_device *pdev)
 {
 	/* This will never be called */
 	return 0;

commit 9671f09921d93e722a28ae9610d478e092ac5466
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:50 2012 -0500

    tty: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index d6525698db31..158d798a5203 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -525,7 +525,7 @@ static struct uart_ops arc_serial_pops = {
 #endif
 };
 
-static int __devinit
+static int
 arc_uart_init_one(struct platform_device *pdev, struct arc_uart_port *uart)
 {
 	struct resource *res, *res2;
@@ -577,7 +577,7 @@ arc_uart_init_one(struct platform_device *pdev, struct arc_uart_port *uart)
 
 #ifdef CONFIG_SERIAL_ARC_CONSOLE
 
-static int __devinit arc_serial_console_setup(struct console *co, char *options)
+static int arc_serial_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
 	int baud = 115200;
@@ -655,7 +655,7 @@ static struct __initdata console arc_early_serial_console = {
 	.index = -1
 };
 
-static int __devinit arc_serial_probe_earlyprintk(struct platform_device *pdev)
+static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
 {
 	arc_early_serial_console.index = pdev->id;
 
@@ -667,13 +667,13 @@ static int __devinit arc_serial_probe_earlyprintk(struct platform_device *pdev)
 	return 0;
 }
 #else
-static int __devinit arc_serial_probe_earlyprintk(struct platform_device *pdev)
+static int arc_serial_probe_earlyprintk(struct platform_device *pdev)
 {
 	return -ENODEV;
 }
 #endif	/* CONFIG_SERIAL_ARC_CONSOLE */
 
-static int __devinit arc_serial_probe(struct platform_device *pdev)
+static int arc_serial_probe(struct platform_device *pdev)
 {
 	struct arc_uart_port *uart;
 	int rc;

commit 2d47b7160243b1422006b91debf438484a4fde58
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:34 2012 -0500

    tty: serial: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Lucas Tavares <lucaskt@linux.vnet.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
index e9c61d1b1c79..d6525698db31 100644
--- a/drivers/tty/serial/arc_uart.c
+++ b/drivers/tty/serial/arc_uart.c
@@ -697,7 +697,7 @@ static int __devexit arc_serial_remove(struct platform_device *pdev)
 
 static struct platform_driver arc_platform_driver = {
 	.probe = arc_serial_probe,
-	.remove = __devexit_p(arc_serial_remove),
+	.remove = arc_serial_remove,
 	.driver = {
 		.name = DRIVER_NAME,
 		.owner = THIS_MODULE,

commit 2ac4ad2a1468123f6bb439a547880a9c0d302e0a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Sat Oct 27 12:47:12 2012 +0530

    serial/arc-uart: Add new driver
    
    Driver for non-standard on-chip UART, instantiated in the ARC (Synopsys)
    FPGA Boards such as ARCAngel4/ML50x
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/arc_uart.c b/drivers/tty/serial/arc_uart.c
new file mode 100644
index 000000000000..e9c61d1b1c79
--- /dev/null
+++ b/drivers/tty/serial/arc_uart.c
@@ -0,0 +1,746 @@
+/*
+ * ARC On-Chip(fpga) UART Driver
+ *
+ * Copyright (C) 2010-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * vineetg: July 10th 2012
+ *  -Decoupled the driver from arch/arc
+ *    +Using platform_get_resource() for irq/membase (thx to bfin_uart.c)
+ *    +Using early_platform_xxx() for early console (thx to mach-shmobile/xxx)
+ *
+ * Vineetg: Aug 21st 2010
+ *  -Is uart_tx_stopped() not done in tty write path as it has already been
+ *   taken care of, in serial core
+ *
+ * Vineetg: Aug 18th 2010
+ *  -New Serial Core based ARC UART driver
+ *  -Derived largely from blackfin driver albiet with some major tweaks
+ *
+ * TODO:
+ *  -check if sysreq works
+ */
+
+#if defined(CONFIG_SERIAL_ARC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+
+/*************************************
+ * ARC UART Hardware Specs
+ ************************************/
+#define ARC_UART_TX_FIFO_SIZE  1
+
+/*
+ * UART Register set (this is not a Standards Compliant IP)
+ * Also each reg is Word aligned, but only 8 bits wide
+ */
+#define R_ID0	0
+#define R_ID1	4
+#define R_ID2	8
+#define R_ID3	12
+#define R_DATA	16
+#define R_STS	20
+#define R_BAUDL	24
+#define R_BAUDH	28
+
+/* Bits for UART Status Reg (R/W) */
+#define RXIENB  0x04	/* Receive Interrupt Enable */
+#define TXIENB  0x40	/* Transmit Interrupt Enable */
+
+#define RXEMPTY 0x20	/* Receive FIFO Empty: No char receivede */
+#define TXEMPTY 0x80	/* Transmit FIFO Empty, thus char can be written into */
+
+#define RXFULL  0x08	/* Receive FIFO full */
+#define RXFULL1 0x10	/* Receive FIFO has space for 1 char (tot space=4) */
+
+#define RXFERR  0x01	/* Frame Error: Stop Bit not detected */
+#define RXOERR  0x02	/* OverFlow Err: Char recv but RXFULL still set */
+
+/* Uart bit fiddling helpers: lowest level */
+#define RBASE(uart, reg)      (uart->port.membase + reg)
+#define UART_REG_SET(u, r, v) writeb((v), RBASE(u, r))
+#define UART_REG_GET(u, r)    readb(RBASE(u, r))
+
+#define UART_REG_OR(u, r, v)  UART_REG_SET(u, r, UART_REG_GET(u, r) | (v))
+#define UART_REG_CLR(u, r, v) UART_REG_SET(u, r, UART_REG_GET(u, r) & ~(v))
+
+/* Uart bit fiddling helpers: API level */
+#define UART_SET_DATA(uart, val)   UART_REG_SET(uart, R_DATA, val)
+#define UART_GET_DATA(uart)        UART_REG_GET(uart, R_DATA)
+
+#define UART_SET_BAUDH(uart, val)  UART_REG_SET(uart, R_BAUDH, val)
+#define UART_SET_BAUDL(uart, val)  UART_REG_SET(uart, R_BAUDL, val)
+
+#define UART_CLR_STATUS(uart, val) UART_REG_CLR(uart, R_STS, val)
+#define UART_GET_STATUS(uart)      UART_REG_GET(uart, R_STS)
+
+#define UART_ALL_IRQ_DISABLE(uart) UART_REG_CLR(uart, R_STS, RXIENB|TXIENB)
+#define UART_RX_IRQ_DISABLE(uart)  UART_REG_CLR(uart, R_STS, RXIENB)
+#define UART_TX_IRQ_DISABLE(uart)  UART_REG_CLR(uart, R_STS, TXIENB)
+
+#define UART_ALL_IRQ_ENABLE(uart)  UART_REG_OR(uart, R_STS, RXIENB|TXIENB)
+#define UART_RX_IRQ_ENABLE(uart)   UART_REG_OR(uart, R_STS, RXIENB)
+#define UART_TX_IRQ_ENABLE(uart)   UART_REG_OR(uart, R_STS, TXIENB)
+
+#define ARC_SERIAL_DEV_NAME	"ttyARC"
+
+struct arc_uart_port {
+	struct uart_port port;
+	unsigned long baud;
+	int is_emulated;	/* H/w vs. Instruction Set Simulator */
+};
+
+#define to_arc_port(uport)  container_of(uport, struct arc_uart_port, port)
+
+static struct arc_uart_port arc_uart_ports[CONFIG_SERIAL_ARC_NR_PORTS];
+
+#ifdef CONFIG_SERIAL_ARC_CONSOLE
+static struct console arc_console;
+#endif
+
+#define DRIVER_NAME	"arc-uart"
+
+static struct uart_driver arc_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRIVER_NAME,
+	.dev_name	= ARC_SERIAL_DEV_NAME,
+	.major		= 0,
+	.minor		= 0,
+	.nr		= CONFIG_SERIAL_ARC_NR_PORTS,
+#ifdef CONFIG_SERIAL_ARC_CONSOLE
+	.cons		= &arc_console,
+#endif
+};
+
+static void arc_serial_stop_rx(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	UART_RX_IRQ_DISABLE(uart);
+}
+
+static void arc_serial_stop_tx(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	while (!(UART_GET_STATUS(uart) & TXEMPTY))
+		cpu_relax();
+
+	UART_TX_IRQ_DISABLE(uart);
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static unsigned int arc_serial_tx_empty(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+	unsigned int stat;
+
+	stat = UART_GET_STATUS(uart);
+	if (stat & TXEMPTY)
+		return TIOCSER_TEMT;
+
+	return 0;
+}
+
+/*
+ * Driver internal routine, used by both tty(serial core) as well as tx-isr
+ *  -Called under spinlock in either cases
+ *  -also tty->stopped / tty->hw_stopped has already been checked
+ *     = by uart_start( ) before calling us
+ *     = tx_ist checks that too before calling
+ */
+static void arc_serial_tx_chars(struct arc_uart_port *uart)
+{
+	struct circ_buf *xmit = &uart->port.state->xmit;
+	int sent = 0;
+	unsigned char ch;
+
+	if (unlikely(uart->port.x_char)) {
+		UART_SET_DATA(uart, uart->port.x_char);
+		uart->port.icount.tx++;
+		uart->port.x_char = 0;
+		sent = 1;
+	} else if (xmit->tail != xmit->head) {	/* TODO: uart_circ_empty */
+		ch = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		uart->port.icount.tx++;
+		while (!(UART_GET_STATUS(uart) & TXEMPTY))
+			cpu_relax();
+		UART_SET_DATA(uart, ch);
+		sent = 1;
+	}
+
+	/*
+	 * If num chars in xmit buffer are too few, ask tty layer for more.
+	 * By Hard ISR to schedule processing in software interrupt part
+	 */
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&uart->port);
+
+	if (sent)
+		UART_TX_IRQ_ENABLE(uart);
+}
+
+/*
+ * port is locked and interrupts are disabled
+ * uart_start( ) calls us under the port spinlock irqsave
+ */
+static void arc_serial_start_tx(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	arc_serial_tx_chars(uart);
+}
+
+static void arc_serial_rx_chars(struct arc_uart_port *uart)
+{
+	struct tty_struct *tty = tty_port_tty_get(&uart->port.state->port);
+	unsigned int status, ch, flg = 0;
+
+	if (!tty)
+		return;
+
+	/*
+	 * UART has 4 deep RX-FIFO. Driver's recongnition of this fact
+	 * is very subtle. Here's how ...
+	 * Upon getting a RX-Intr, such that RX-EMPTY=0, meaning data available,
+	 * driver reads the DATA Reg and keeps doing that in a loop, until
+	 * RX-EMPTY=1. Multiple chars being avail, with a single Interrupt,
+	 * before RX-EMPTY=0, implies some sort of buffering going on in the
+	 * controller, which is indeed the Rx-FIFO.
+	 */
+	while (!((status = UART_GET_STATUS(uart)) & RXEMPTY)) {
+
+		ch = UART_GET_DATA(uart);
+		uart->port.icount.rx++;
+
+		if (unlikely(status & (RXOERR | RXFERR))) {
+			if (status & RXOERR) {
+				uart->port.icount.overrun++;
+				flg = TTY_OVERRUN;
+				UART_CLR_STATUS(uart, RXOERR);
+			}
+
+			if (status & RXFERR) {
+				uart->port.icount.frame++;
+				flg = TTY_FRAME;
+				UART_CLR_STATUS(uart, RXFERR);
+			}
+		} else
+			flg = TTY_NORMAL;
+
+		if (unlikely(uart_handle_sysrq_char(&uart->port, ch)))
+			goto done;
+
+		uart_insert_char(&uart->port, status, RXOERR, ch, flg);
+
+done:
+		tty_flip_buffer_push(tty);
+	}
+
+	tty_kref_put(tty);
+}
+
+/*
+ * A note on the Interrupt handling state machine of this driver
+ *
+ * kernel printk writes funnel thru the console driver framework and in order
+ * to keep things simple as well as efficient, it writes to UART in polled
+ * mode, in one shot, and exits.
+ *
+ * OTOH, Userland output (via tty layer), uses interrupt based writes as there
+ * can be undeterministic delay between char writes.
+ *
+ * Thus Rx-interrupts are always enabled, while tx-interrupts are by default
+ * disabled.
+ *
+ * When tty has some data to send out, serial core calls driver's start_tx
+ * which
+ *   -checks-if-tty-buffer-has-char-to-send
+ *   -writes-data-to-uart
+ *   -enable-tx-intr
+ *
+ * Once data bits are pushed out, controller raises the Tx-room-avail-Interrupt.
+ * The first thing Tx ISR does is disable further Tx interrupts (as this could
+ * be the last char to send, before settling down into the quiet polled mode).
+ * It then calls the exact routine used by tty layer write to send out any
+ * more char in tty buffer. In case of sending, it re-enables Tx-intr. In case
+ * of no data, it remains disabled.
+ * This is how the transmit state machine is dynamically switched on/off
+ */
+
+static irqreturn_t arc_serial_isr(int irq, void *dev_id)
+{
+	struct arc_uart_port *uart = dev_id;
+	unsigned int status;
+
+	status = UART_GET_STATUS(uart);
+
+	/*
+	 * Single IRQ for both Rx (data available) Tx (room available) Interrupt
+	 * notifications from the UART Controller.
+	 * To demultiplex between the two, we check the relevant bits
+	 */
+	if ((status & RXIENB) && !(status & RXEMPTY)) {
+
+		/* already in ISR, no need of xx_irqsave */
+		spin_lock(&uart->port.lock);
+		arc_serial_rx_chars(uart);
+		spin_unlock(&uart->port.lock);
+	}
+
+	if ((status & TXIENB) && (status & TXEMPTY)) {
+
+		/* Unconditionally disable further Tx-Interrupts.
+		 * will be enabled by tx_chars() if needed.
+		 */
+		UART_TX_IRQ_DISABLE(uart);
+
+		spin_lock(&uart->port.lock);
+
+		if (!uart_tx_stopped(&uart->port))
+			arc_serial_tx_chars(uart);
+
+		spin_unlock(&uart->port.lock);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int arc_serial_get_mctrl(struct uart_port *port)
+{
+	/*
+	 * Pretend we have a Modem status reg and following bits are
+	 *  always set, to satify the serial core state machine
+	 *  (DSR) Data Set Ready
+	 *  (CTS) Clear To Send
+	 *  (CAR) Carrier Detect
+	 */
+	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+static void arc_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* MCR not present */
+}
+
+/* Enable Modem Status Interrupts */
+
+static void arc_serial_enable_ms(struct uart_port *port)
+{
+	/* MSR not present */
+}
+
+static void arc_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	/* ARC UART doesn't support sending Break signal */
+}
+
+static int arc_serial_startup(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	/* Before we hook up the ISR, Disable all UART Interrupts */
+	UART_ALL_IRQ_DISABLE(uart);
+
+	if (request_irq(uart->port.irq, arc_serial_isr, 0, "arc uart rx-tx",
+			uart)) {
+		dev_warn(uart->port.dev, "Unable to attach ARC UART intr\n");
+		return -EBUSY;
+	}
+
+	UART_RX_IRQ_ENABLE(uart); /* Only Rx IRQ enabled to begin with */
+
+	return 0;
+}
+
+/* This is not really needed */
+static void arc_serial_shutdown(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+	free_irq(uart->port.irq, uart);
+}
+
+static void
+arc_serial_set_termios(struct uart_port *port, struct ktermios *new,
+		       struct ktermios *old)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+	unsigned int baud, uartl, uarth, hw_val;
+	unsigned long flags;
+
+	/*
+	 * Use the generic handler so that any specially encoded baud rates
+	 * such as SPD_xx flags or "%B0" can be handled
+	 * Max Baud I suppose will not be more than current 115K * 4
+	 * Formula for ARC UART is: hw-val = ((CLK/(BAUD*4)) -1)
+	 * spread over two 8-bit registers
+	 */
+	baud = uart_get_baud_rate(port, new, old, 0, 460800);
+
+	hw_val = port->uartclk / (uart->baud * 4) - 1;
+	uartl = hw_val & 0xFF;
+	uarth = (hw_val >> 8) & 0xFF;
+
+	/*
+	 * UART ISS(Instruction Set simulator) emulation has a subtle bug:
+	 * A existing value of Baudh = 0 is used as a indication to startup
+	 * it's internal state machine.
+	 * Thus if baudh is set to 0, 2 times, it chokes.
+	 * This happens with BAUD=115200 and the formaula above
+	 * Until that is fixed, when running on ISS, we will set baudh to !0
+	 */
+	if (uart->is_emulated)
+		uarth = 1;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	UART_ALL_IRQ_DISABLE(uart);
+
+	UART_SET_BAUDL(uart, uartl);
+	UART_SET_BAUDH(uart, uarth);
+
+	UART_RX_IRQ_ENABLE(uart);
+
+	/*
+	 * UART doesn't support Parity/Hardware Flow Control;
+	 * Only supports 8N1 character size
+	 */
+	new->c_cflag &= ~(CMSPAR|CRTSCTS|CSIZE);
+	new->c_cflag |= CS8;
+
+	if (old)
+		tty_termios_copy_hw(new, old);
+
+	/* Don't rewrite B0 */
+	if (tty_termios_baud_rate(new))
+		tty_termios_encode_baud_rate(new, baud, baud);
+
+	uart_update_timeout(port, new->c_cflag, baud);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *arc_serial_type(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	return uart->port.type == PORT_ARC ? DRIVER_NAME : NULL;
+}
+
+static void arc_serial_release_port(struct uart_port *port)
+{
+}
+
+static int arc_serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int
+arc_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (port->type != PORT_UNKNOWN && ser->type != PORT_ARC)
+		return -EINVAL;
+
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void arc_serial_config_port(struct uart_port *port, int flags)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	if (flags & UART_CONFIG_TYPE)
+		uart->port.type = PORT_ARC;
+}
+
+#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_ARC_CONSOLE)
+
+static void arc_serial_poll_putchar(struct uart_port *port, unsigned char chr)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+
+	while (!(UART_GET_STATUS(uart) & TXEMPTY))
+		cpu_relax();
+
+	UART_SET_DATA(uart, chr);
+}
+#endif
+
+#ifdef CONFIG_CONSOLE_POLL
+static int arc_serial_poll_getchar(struct uart_port *port)
+{
+	struct arc_uart_port *uart = to_arc_port(port);
+	unsigned char chr;
+
+	while (!(UART_GET_STATUS(uart) & RXEMPTY))
+		cpu_relax();
+
+	chr = UART_GET_DATA(uart);
+	return chr;
+}
+#endif
+
+static struct uart_ops arc_serial_pops = {
+	.tx_empty	= arc_serial_tx_empty,
+	.set_mctrl	= arc_serial_set_mctrl,
+	.get_mctrl	= arc_serial_get_mctrl,
+	.stop_tx	= arc_serial_stop_tx,
+	.start_tx	= arc_serial_start_tx,
+	.stop_rx	= arc_serial_stop_rx,
+	.enable_ms	= arc_serial_enable_ms,
+	.break_ctl	= arc_serial_break_ctl,
+	.startup	= arc_serial_startup,
+	.shutdown	= arc_serial_shutdown,
+	.set_termios	= arc_serial_set_termios,
+	.type		= arc_serial_type,
+	.release_port	= arc_serial_release_port,
+	.request_port	= arc_serial_request_port,
+	.config_port	= arc_serial_config_port,
+	.verify_port	= arc_serial_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char = arc_serial_poll_putchar,
+	.poll_get_char = arc_serial_poll_getchar,
+#endif
+};
+
+static int __devinit
+arc_uart_init_one(struct platform_device *pdev, struct arc_uart_port *uart)
+{
+	struct resource *res, *res2;
+	unsigned long *plat_data;
+
+	if (pdev->id < 0 || pdev->id >= CONFIG_SERIAL_ARC_NR_PORTS) {
+		dev_err(&pdev->dev, "Wrong uart platform device id.\n");
+		return -ENOENT;
+	}
+
+	plat_data = ((unsigned long *)(pdev->dev.platform_data));
+	uart->baud = plat_data[0];
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res2)
+		return -ENODEV;
+
+	uart->port.mapbase = res->start;
+	uart->port.membase = ioremap_nocache(res->start, resource_size(res));
+	if (!uart->port.membase)
+		/* No point of dev_err since UART itself is hosed here */
+		return -ENXIO;
+
+	uart->port.irq = res2->start;
+	uart->port.dev = &pdev->dev;
+	uart->port.iotype = UPIO_MEM;
+	uart->port.flags = UPF_BOOT_AUTOCONF;
+	uart->port.line = pdev->id;
+	uart->port.ops = &arc_serial_pops;
+
+	uart->port.uartclk = plat_data[1];
+	uart->port.fifosize = ARC_UART_TX_FIFO_SIZE;
+
+	/*
+	 * uart_insert_char( ) uses it in decideding whether to ignore a
+	 * char or not. Explicitly setting it here, removes the subtelty
+	 */
+	uart->port.ignore_status_mask = 0;
+
+	/* Real Hardware vs. emulated to work around a bug */
+	uart->is_emulated = !!plat_data[2];
+
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_ARC_CONSOLE
+
+static int __devinit arc_serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index < 0 || co->index >= CONFIG_SERIAL_ARC_NR_PORTS)
+		return -ENODEV;
+
+	/*
+	 * The uart port backing the console (e.g. ttyARC1) might not have been
+	 * init yet. If so, defer the console setup to after the port.
+	 */
+	port = &arc_uart_ports[co->index].port;
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	/*
+	 * Serial core will call port->ops->set_termios( )
+	 * which will set the baud reg
+	 */
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static void arc_serial_console_putchar(struct uart_port *port, int ch)
+{
+	arc_serial_poll_putchar(port, (unsigned char)ch);
+}
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void arc_serial_console_write(struct console *co, const char *s,
+				     unsigned int count)
+{
+	struct uart_port *port = &arc_uart_ports[co->index].port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	uart_console_write(port, s, count, arc_serial_console_putchar);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static struct console arc_console = {
+	.name	= ARC_SERIAL_DEV_NAME,
+	.write	= arc_serial_console_write,
+	.device	= uart_console_device,
+	.setup	= arc_serial_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &arc_uart_driver
+};
+
+static __init void early_serial_write(struct console *con, const char *s,
+					unsigned int n)
+{
+	struct uart_port *port = &arc_uart_ports[con->index].port;
+	unsigned int i;
+
+	for (i = 0; i < n; i++, s++) {
+		if (*s == '\n')
+			arc_serial_poll_putchar(port, '\r');
+		arc_serial_poll_putchar(port, *s);
+	}
+}
+
+static struct __initdata console arc_early_serial_console = {
+	.name = "early_ARCuart",
+	.write = early_serial_write,
+	.flags = CON_PRINTBUFFER | CON_BOOT,
+	.index = -1
+};
+
+static int __devinit arc_serial_probe_earlyprintk(struct platform_device *pdev)
+{
+	arc_early_serial_console.index = pdev->id;
+
+	arc_uart_init_one(pdev, &arc_uart_ports[pdev->id]);
+
+	arc_serial_console_setup(&arc_early_serial_console, NULL);
+
+	register_console(&arc_early_serial_console);
+	return 0;
+}
+#else
+static int __devinit arc_serial_probe_earlyprintk(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
+#endif	/* CONFIG_SERIAL_ARC_CONSOLE */
+
+static int __devinit arc_serial_probe(struct platform_device *pdev)
+{
+	struct arc_uart_port *uart;
+	int rc;
+
+	if (is_early_platform_device(pdev))
+		return arc_serial_probe_earlyprintk(pdev);
+
+	uart = &arc_uart_ports[pdev->id];
+	rc = arc_uart_init_one(pdev, uart);
+	if (rc)
+		return rc;
+
+	return uart_add_one_port(&arc_uart_driver, &uart->port);
+}
+
+static int __devexit arc_serial_remove(struct platform_device *pdev)
+{
+	/* This will never be called */
+	return 0;
+}
+
+static struct platform_driver arc_platform_driver = {
+	.probe = arc_serial_probe,
+	.remove = __devexit_p(arc_serial_remove),
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	 },
+};
+
+#ifdef CONFIG_SERIAL_ARC_CONSOLE
+/*
+ * Register an early platform driver of "earlyprintk" class.
+ * ARCH platform code installs the driver and probes the early devices
+ * The installation could rely on user specifying earlyprintk=xyx in cmd line
+ * or it could be done independently, for all "earlyprintk" class drivers.
+ * [see arch/arc/plat-arcfpga/platform.c]
+ */
+early_platform_init("earlyprintk", &arc_platform_driver);
+
+#endif  /* CONFIG_SERIAL_ARC_CONSOLE */
+
+static int __init arc_serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&arc_uart_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&arc_platform_driver);
+	if (ret)
+		uart_unregister_driver(&arc_uart_driver);
+
+	return ret;
+}
+
+static void __exit arc_serial_exit(void)
+{
+	platform_driver_unregister(&arc_platform_driver);
+	uart_unregister_driver(&arc_uart_driver);
+}
+
+module_init(arc_serial_init);
+module_exit(arc_serial_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("plat-arcfpga/uart");
+MODULE_AUTHOR("Vineet Gupta");
+MODULE_DESCRIPTION("ARC(Synopsys) On-Chip(fpga) serial driver");
