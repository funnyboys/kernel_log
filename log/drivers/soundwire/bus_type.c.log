commit bcac59029955ae57d3c660a0a1d6d4c7ae78fb49
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue May 19 04:35:51 2020 +0800

    soundwire: add Slave sysfs support
    
    Expose MIPI DisCo Slave properties in sysfs.
    
    For Slave properties and Data Port 0, the attributes are managed with
    simple devm_ support.
    
    A Slave Device may have more than one Data Port (DPN), and each Data
    Port can be sink or source. The attributes are created dynamically
    using pre-canned macros, but still use devm_ with a name attribute
    group to avoid creating kobjects - as requested by GregKH. In the
    _show function, we use container_of() to retrieve port number and
    direction required to extract the information.
    
    Audio modes are not supported for now. Depending on the discussions
    the SoundWire Device Class, we may add it later as is or follow the
    new specification.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20200518203551.2053-4-yung-chuan.liao@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 2c1a19caba51..de9a671802b8 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -7,6 +7,7 @@
 #include <linux/soundwire/sdw.h>
 #include <linux/soundwire/sdw_type.h>
 #include "bus.h"
+#include "sysfs_local.h"
 
 /**
  * sdw_get_device_id - find the matching SoundWire device id
@@ -46,8 +47,7 @@ static int sdw_bus_match(struct device *dev, struct device_driver *ddrv)
 	return ret;
 }
 
-static int sdw_slave_modalias(const struct sdw_slave *slave, char *buf,
-			      size_t size)
+int sdw_slave_modalias(const struct sdw_slave *slave, char *buf, size_t size)
 {
 	/* modalias is sdw:m<mfg_id>p<part_id> */
 
@@ -105,6 +105,11 @@ static int sdw_drv_probe(struct device *dev)
 	if (slave->ops && slave->ops->read_prop)
 		slave->ops->read_prop(slave);
 
+	/* init the sysfs as we have properties now */
+	ret = sdw_slave_sysfs_init(slave);
+	if (ret < 0)
+		dev_warn(dev, "Slave sysfs init failed:%d\n", ret);
+
 	/*
 	 * Check for valid clk_stop_timeout, use DisCo worst case value of
 	 * 300ms

commit 90acca1d54ad566b4af5f1030b4a4a2420ce2ef0
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue May 19 01:43:19 2020 +0800

    soundwire: bus_type: introduce sdw_slave_type and sdw_master_type
    
    this is a preparatory patch before the introduction of the
    sdw_master_type. The SoundWire slave support is slightly modified with
    the use of a sdw_slave_type, and the uevent handling move to
    slave.c (since it's not necessary for the master).
    
    No functionality change other than moving code around.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Link: https://lore.kernel.org/r/20200518174322.31561-3-yung-chuan.liao@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 17f096dd6806..2c1a19caba51 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -33,13 +33,21 @@ sdw_get_device_id(struct sdw_slave *slave, struct sdw_driver *drv)
 
 static int sdw_bus_match(struct device *dev, struct device_driver *ddrv)
 {
-	struct sdw_slave *slave = dev_to_sdw_dev(dev);
-	struct sdw_driver *drv = drv_to_sdw_driver(ddrv);
+	struct sdw_slave *slave;
+	struct sdw_driver *drv;
+	int ret = 0;
+
+	if (is_sdw_slave(dev)) {
+		slave = dev_to_sdw_dev(dev);
+		drv = drv_to_sdw_driver(ddrv);
 
-	return !!sdw_get_device_id(slave, drv);
+		ret = !!sdw_get_device_id(slave, drv);
+	}
+	return ret;
 }
 
-int sdw_slave_modalias(const struct sdw_slave *slave, char *buf, size_t size)
+static int sdw_slave_modalias(const struct sdw_slave *slave, char *buf,
+			      size_t size)
 {
 	/* modalias is sdw:m<mfg_id>p<part_id> */
 
@@ -47,7 +55,7 @@ int sdw_slave_modalias(const struct sdw_slave *slave, char *buf, size_t size)
 			slave->id.mfg_id, slave->id.part_id);
 }
 
-static int sdw_uevent(struct device *dev, struct kobj_uevent_env *env)
+int sdw_slave_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct sdw_slave *slave = dev_to_sdw_dev(dev);
 	char modalias[32];
@@ -63,7 +71,6 @@ static int sdw_uevent(struct device *dev, struct kobj_uevent_env *env)
 struct bus_type sdw_bus_type = {
 	.name = "soundwire",
 	.match = sdw_bus_match,
-	.uevent = sdw_uevent,
 };
 EXPORT_SYMBOL_GPL(sdw_bus_type);
 

commit 2140b66b5d3ecf6c7c0fa9dc5eebb41855765ace
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue Jan 14 18:08:35 2020 -0600

    soundwire: bus: fix race condition with probe_complete signaling
    
    The driver probe takes care of basic initialization and is invoked
    when a Slave becomes attached, after a match between the Slave DevID
    registers and ACPI/DT entries.
    
    The update_status callback is invoked when a Slave state changes,
    e.g. when it is assigned a non-zero Device Number and it reports with
    an ATTACHED/ALERT state.
    
    The state change detection is usually hardware-based and based on the
    SoundWire frame rate (e.g. double-digit microseconds) while the probe
    is a pure software operation, which may involve a kernel module
    load. In corner cases, it's possible that the state changes before the
    probe completes.
    
    This patch suggests the use of wait_for_completion to avoid races on
    startup, so that the update_status callback does not rely on invalid
    pointers/data structures.
    
    Signed-off-by: Rander Wang <rander.wang@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200115000844.14695-2-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 4a465f55039f..17f096dd6806 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -110,6 +110,11 @@ static int sdw_drv_probe(struct device *dev)
 	slave->bus->clk_stop_timeout = max_t(u32, slave->bus->clk_stop_timeout,
 					     slave->prop.clk_stop_timeout);
 
+	slave->probed = true;
+	complete(&slave->probe_complete);
+
+	dev_dbg(dev, "probe complete\n");
+
 	return 0;
 }
 

commit bf03473d5bcc85fbe9533fa042f67809d8520c4e
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Aug 21 13:58:18 2019 -0500

    soundwire: add debugfs support
    
    Add base debugfs mechanism for SoundWire bus by creating soundwire
    root and master-N and slave-x hierarchy.
    
    Also add SDW Slave SCP, DP0 and DP-N register debug file.
    
    Registers not implemented will print as "XX"
    
    Credits: this patch is based on an earlier internal contribution by
    Vinod Koul, Sanyog Kale, Shreyas Nc and Hardik Shah.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Sanyog Kale <sanyog.r.kale@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20190821185821.12690-2-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 2655602f0cfb..4a465f55039f 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -6,6 +6,7 @@
 #include <linux/pm_domain.h>
 #include <linux/soundwire/sdw.h>
 #include <linux/soundwire/sdw_type.h>
+#include "bus.h"
 
 /**
  * sdw_get_device_id - find the matching SoundWire device id
@@ -177,11 +178,13 @@ EXPORT_SYMBOL_GPL(sdw_unregister_driver);
 
 static int __init sdw_bus_init(void)
 {
+	sdw_debugfs_init();
 	return bus_register(&sdw_bus_type);
 }
 
 static void __exit sdw_bus_exit(void)
 {
+	sdw_debugfs_exit();
 	bus_unregister(&sdw_bus_type);
 }
 

commit 74a8d8022fd9d91a56d02d10e6c0d53481172f51
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed May 1 10:57:32 2019 -0500

    soundwire: bus_type: fix alignment issues
    
    Use Linux style
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 283b2832728e..2655602f0cfb 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -107,7 +107,7 @@ static int sdw_drv_probe(struct device *dev)
 		slave->prop.clk_stop_timeout = 300;
 
 	slave->bus->clk_stop_timeout = max_t(u32, slave->bus->clk_stop_timeout,
-					slave->prop.clk_stop_timeout);
+					     slave->prop.clk_stop_timeout);
 
 	return 0;
 }
@@ -148,7 +148,7 @@ int __sdw_register_driver(struct sdw_driver *drv, struct module *owner)
 
 	if (!drv->probe) {
 		pr_err("driver %s didn't provide SDW probe routine\n",
-							drv->name);
+		       drv->name);
 		return -EINVAL;
 	}
 

commit 29ffcc88f2065f83e97e371f688c0255a7a7d907
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:09 2018 +0200

    soundwire: Respect all error codes from dev_pm_domain_attach()
    
    The limitation of being able to check only for -EPROBE_DEFER from
    dev_pm_domain_attach() has been removed. Hence let's respect all error
    codes and bail out accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index d5f3a70c06b0..283b2832728e 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -83,17 +83,16 @@ static int sdw_drv_probe(struct device *dev)
 	 * attach to power domain but don't turn on (last arg)
 	 */
 	ret = dev_pm_domain_attach(dev, false);
-	if (ret != -EPROBE_DEFER) {
-		ret = drv->probe(slave, id);
-		if (ret) {
-			dev_err(dev, "Probe of %s failed: %d\n", drv->name, ret);
-			dev_pm_domain_detach(dev, false);
-		}
-	}
-
 	if (ret)
 		return ret;
 
+	ret = drv->probe(slave, id);
+	if (ret) {
+		dev_err(dev, "Probe of %s failed: %d\n", drv->name, ret);
+		dev_pm_domain_detach(dev, false);
+		return ret;
+	}
+
 	/* device is probed so let's read the properties now */
 	if (slave->ops && slave->ops->read_prop)
 		slave->ops->read_prop(slave);

commit 56d4fe31af77f684bed62fb8201e6327e6ddf4e6
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Dec 14 11:19:35 2017 +0530

    soundwire: Add MIPI DisCo property helpers
    
    MIPI Discovery And Configuration (DisCo) Specification for SoundWire
    specifies properties to be implemented for SoundWire Masters and
    Slaves. The DisCo spec doesn't mandate these properties. However,
    SDW bus cannot work without knowing these values.
    
    The helper functions read the Master and Slave properties.
    Implementers of Master or Slave drivers can use any of the below
    three mechanisms:
       a) Use these APIs here as .read_prop() callback for Master
          and Slave
       b) Implement own methods and set those as .read_prop(), but invoke
          APIs in this file for generic read and override the values with
          platform specific data
       c) Implement ones own methods which do not use anything provided
          here
    
    Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-By: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
index 8d8dcc68e9a8..d5f3a70c06b0 100644
--- a/drivers/soundwire/bus_type.c
+++ b/drivers/soundwire/bus_type.c
@@ -77,6 +77,8 @@ static int sdw_drv_probe(struct device *dev)
 	if (!id)
 		return -ENODEV;
 
+	slave->ops = drv->ops;
+
 	/*
 	 * attach to power domain but don't turn on (last arg)
 	 */
@@ -89,7 +91,26 @@ static int sdw_drv_probe(struct device *dev)
 		}
 	}
 
-	return ret;
+	if (ret)
+		return ret;
+
+	/* device is probed so let's read the properties now */
+	if (slave->ops && slave->ops->read_prop)
+		slave->ops->read_prop(slave);
+
+	/*
+	 * Check for valid clk_stop_timeout, use DisCo worst case value of
+	 * 300ms
+	 *
+	 * TODO: check the timeouts and driver removal case
+	 */
+	if (slave->prop.clk_stop_timeout == 0)
+		slave->prop.clk_stop_timeout = 300;
+
+	slave->bus->clk_stop_timeout = max_t(u32, slave->bus->clk_stop_timeout,
+					slave->prop.clk_stop_timeout);
+
+	return 0;
 }
 
 static int sdw_drv_remove(struct device *dev)

commit 9251345dca24b62b14e4e53e6ee3387ae7d9c790
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Dec 14 11:19:33 2017 +0530

    soundwire: Add SoundWire bus type
    
    This adds the base SoundWire bus type, bus and driver registration.
    along with changes to module device table for new SoundWire
    device type.
    
    Signed-off-by: Sanyog Kale <sanyog.r.kale@intel.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-By: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/soundwire/bus_type.c b/drivers/soundwire/bus_type.c
new file mode 100644
index 000000000000..8d8dcc68e9a8
--- /dev/null
+++ b/drivers/soundwire/bus_type.c
@@ -0,0 +1,172 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright(c) 2015-17 Intel Corporation.
+
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/pm_domain.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_type.h>
+
+/**
+ * sdw_get_device_id - find the matching SoundWire device id
+ * @slave: SoundWire Slave Device
+ * @drv: SoundWire Slave Driver
+ *
+ * The match is done by comparing the mfg_id and part_id from the
+ * struct sdw_device_id.
+ */
+static const struct sdw_device_id *
+sdw_get_device_id(struct sdw_slave *slave, struct sdw_driver *drv)
+{
+	const struct sdw_device_id *id = drv->id_table;
+
+	while (id && id->mfg_id) {
+		if (slave->id.mfg_id == id->mfg_id &&
+		    slave->id.part_id == id->part_id)
+			return id;
+		id++;
+	}
+
+	return NULL;
+}
+
+static int sdw_bus_match(struct device *dev, struct device_driver *ddrv)
+{
+	struct sdw_slave *slave = dev_to_sdw_dev(dev);
+	struct sdw_driver *drv = drv_to_sdw_driver(ddrv);
+
+	return !!sdw_get_device_id(slave, drv);
+}
+
+int sdw_slave_modalias(const struct sdw_slave *slave, char *buf, size_t size)
+{
+	/* modalias is sdw:m<mfg_id>p<part_id> */
+
+	return snprintf(buf, size, "sdw:m%04Xp%04X\n",
+			slave->id.mfg_id, slave->id.part_id);
+}
+
+static int sdw_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct sdw_slave *slave = dev_to_sdw_dev(dev);
+	char modalias[32];
+
+	sdw_slave_modalias(slave, modalias, sizeof(modalias));
+
+	if (add_uevent_var(env, "MODALIAS=%s", modalias))
+		return -ENOMEM;
+
+	return 0;
+}
+
+struct bus_type sdw_bus_type = {
+	.name = "soundwire",
+	.match = sdw_bus_match,
+	.uevent = sdw_uevent,
+};
+EXPORT_SYMBOL_GPL(sdw_bus_type);
+
+static int sdw_drv_probe(struct device *dev)
+{
+	struct sdw_slave *slave = dev_to_sdw_dev(dev);
+	struct sdw_driver *drv = drv_to_sdw_driver(dev->driver);
+	const struct sdw_device_id *id;
+	int ret;
+
+	id = sdw_get_device_id(slave, drv);
+	if (!id)
+		return -ENODEV;
+
+	/*
+	 * attach to power domain but don't turn on (last arg)
+	 */
+	ret = dev_pm_domain_attach(dev, false);
+	if (ret != -EPROBE_DEFER) {
+		ret = drv->probe(slave, id);
+		if (ret) {
+			dev_err(dev, "Probe of %s failed: %d\n", drv->name, ret);
+			dev_pm_domain_detach(dev, false);
+		}
+	}
+
+	return ret;
+}
+
+static int sdw_drv_remove(struct device *dev)
+{
+	struct sdw_slave *slave = dev_to_sdw_dev(dev);
+	struct sdw_driver *drv = drv_to_sdw_driver(dev->driver);
+	int ret = 0;
+
+	if (drv->remove)
+		ret = drv->remove(slave);
+
+	dev_pm_domain_detach(dev, false);
+
+	return ret;
+}
+
+static void sdw_drv_shutdown(struct device *dev)
+{
+	struct sdw_slave *slave = dev_to_sdw_dev(dev);
+	struct sdw_driver *drv = drv_to_sdw_driver(dev->driver);
+
+	if (drv->shutdown)
+		drv->shutdown(slave);
+}
+
+/**
+ * __sdw_register_driver() - register a SoundWire Slave driver
+ * @drv: driver to register
+ * @owner: owning module/driver
+ *
+ * Return: zero on success, else a negative error code.
+ */
+int __sdw_register_driver(struct sdw_driver *drv, struct module *owner)
+{
+	drv->driver.bus = &sdw_bus_type;
+
+	if (!drv->probe) {
+		pr_err("driver %s didn't provide SDW probe routine\n",
+							drv->name);
+		return -EINVAL;
+	}
+
+	drv->driver.owner = owner;
+	drv->driver.probe = sdw_drv_probe;
+
+	if (drv->remove)
+		drv->driver.remove = sdw_drv_remove;
+
+	if (drv->shutdown)
+		drv->driver.shutdown = sdw_drv_shutdown;
+
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(__sdw_register_driver);
+
+/**
+ * sdw_unregister_driver() - unregisters the SoundWire Slave driver
+ * @drv: driver to unregister
+ */
+void sdw_unregister_driver(struct sdw_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(sdw_unregister_driver);
+
+static int __init sdw_bus_init(void)
+{
+	return bus_register(&sdw_bus_type);
+}
+
+static void __exit sdw_bus_exit(void)
+{
+	bus_unregister(&sdw_bus_type);
+}
+
+postcore_initcall(sdw_bus_init);
+module_exit(sdw_bus_exit);
+
+MODULE_DESCRIPTION("SoundWire bus");
+MODULE_LICENSE("GPL v2");
