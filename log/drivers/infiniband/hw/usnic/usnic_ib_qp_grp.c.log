commit d12c416dd131df990036b9b9136d98e5682bb1a7
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Nov 29 10:42:13 2018 +0000

    IB/usnic: fix spelling mistake "miniumum" -> "minimum"
    
    There is a spelling mistake in a usnic_err error message, fix it.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index bf5136533d49..0cdb156e165e 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -681,7 +681,7 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,
 	err = usnic_vnic_res_spec_satisfied(&min_transport_spec[transport],
 						res_spec);
 	if (err) {
-		usnic_err("Spec does not meet miniumum req for transport %d\n",
+		usnic_err("Spec does not meet minimum req for transport %d\n",
 				transport);
 		log_spec(res_spec);
 		return ERR_PTR(err);

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 912d8ef04352..bf5136533d49 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -543,7 +543,7 @@ alloc_res_chunk_list(struct usnic_vnic *vnic,
 		/* Do Nothing */
 	}
 
-	res_chunk_list = kzalloc(sizeof(*res_chunk_list)*(res_lst_sz+1),
+	res_chunk_list = kcalloc(res_lst_sz + 1, sizeof(*res_chunk_list),
 					GFP_ATOMIC);
 	if (!res_chunk_list)
 		return ERR_PTR(-ENOMEM);

commit 4c23e5085fd53478a14bb743dc7386abb2f68ec6
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Oct 11 10:49:26 2017 -0700

    RDMA/usnic: Remove a set-but-not-used variable
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Christian Benvenuti <benve@cisco.com>
    Cc: Dave Goodell <dgoodell@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 092d4e11a633..912d8ef04352 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -392,14 +392,12 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 				void *data)
 {
 	int status = 0;
-	int vnic_idx;
 	struct ib_event ib_event;
 	enum ib_qp_state old_state;
 	struct usnic_transport_spec *trans_spec;
 	struct usnic_ib_qp_grp_flow *qp_flow;
 
 	old_state = qp_grp->state;
-	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 	trans_spec = (struct usnic_transport_spec *) data;
 
 	spin_lock(&qp_grp->lock);

commit 9032ad78bb58f2567fc95125ee69cde7b74c0a21
Merge: 86ef0beaa0bd 46d0703fac3f 22b1ae6169e3 512fb1b32bac 37f69f43fb5a 4fa354c9dbfe
Author: Doug Ledford <dledford@redhat.com>
Date:   Wed Dec 14 14:44:47 2016 -0500

    Merge branches 'misc', 'qedr', 'reject-helpers', 'rxe' and 'srp' into merge-test

commit 5f4c7e4eb5f36974ed46a485290f5d01ace5fdba
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Nov 11 20:04:26 2016 +0100

    IB/usnic: simplify IS_ERR_OR_NULL to IS_ERR
    
    The function usnic_ib_qp_grp_get_chunk only returns an ERR_PTR value or a
    valid pointer, never NULL.  The same is true of get_qp_res_chunk, which
    just returns the result of calling usnic_ib_qp_grp_get_chunk.  Simplify
    IS_ERR_OR_NULL to IS_ERR in both cases.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression t,e;
    @@
    
    t = \(usnic_ib_qp_grp_get_chunk(...)\|get_qp_res_chunk(...)\)
    ... when != t=e
    - IS_ERR_OR_NULL(t)
    + IS_ERR(t)
    
    @@
    expression t,e,e1;
    @@
    
    t = \(usnic_ib_qp_grp_get_chunk(...)\|get_qp_res_chunk(...)\)
    ... when != t=e
    ?- t ? PTR_ERR(t) : e1
    + PTR_ERR(t)
    ... when any
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 5b0248adf4ce..2b1a3819627f 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -117,10 +117,10 @@ static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
 	res_chunk = get_qp_res_chunk(qp_grp);
-	if (IS_ERR_OR_NULL(res_chunk)) {
+	if (IS_ERR(res_chunk)) {
 		usnic_err("Unable to get qp res with err %ld\n",
 				PTR_ERR(res_chunk));
-		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+		return PTR_ERR(res_chunk);
 	}
 
 	for (i = 0; i < res_chunk->cnt; i++) {
@@ -158,10 +158,10 @@ static int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
 	res_chunk = get_qp_res_chunk(qp_grp);
-	if (IS_ERR_OR_NULL(res_chunk)) {
+	if (IS_ERR(res_chunk)) {
 		usnic_err("Unable to get qp res with err %ld\n",
 			PTR_ERR(res_chunk));
-		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+		return PTR_ERR(res_chunk);
 	}
 
 	for (i = 0; i < res_chunk->cnt; i++) {
@@ -186,11 +186,11 @@ static int init_filter_action(struct usnic_ib_qp_grp *qp_grp,
 	struct usnic_vnic_res_chunk *res_chunk;
 
 	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
-	if (IS_ERR_OR_NULL(res_chunk)) {
+	if (IS_ERR(res_chunk)) {
 		usnic_err("Unable to get %s with err %ld\n",
 			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
 			PTR_ERR(res_chunk));
-		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+		return PTR_ERR(res_chunk);
 	}
 
 	uaction->vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);

commit 02d93f8e6b8bfef8453c4dfa61220335cabbb138
Author: Leon Romanovsky <leon@kernel.org>
Date:   Thu Nov 3 16:44:21 2016 +0200

    IB/usninc: Remove and fix debug prints after allocation failure
    
    This patch removes unneeded prints after allocation failure
    and moves one debug print into the appropriate place.
    
    Signed-off-by: Leon Romanovsky <leon@kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 5b0248adf4ce..0e813ecbcd7d 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -228,8 +228,6 @@ create_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,
 
 	flow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);
 	if (IS_ERR_OR_NULL(flow)) {
-		usnic_err("Unable to alloc flow failed with err %ld\n",
-				PTR_ERR(flow));
 		err = flow ? PTR_ERR(flow) : -EFAULT;
 		goto out_unreserve_port;
 	}
@@ -303,8 +301,6 @@ create_udp_flow(struct usnic_ib_qp_grp *qp_grp,
 
 	flow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);
 	if (IS_ERR_OR_NULL(flow)) {
-		usnic_err("Unable to alloc flow failed with err %ld\n",
-				PTR_ERR(flow));
 		err = flow ? PTR_ERR(flow) : -EFAULT;
 		goto out_put_sock;
 	}
@@ -694,18 +690,14 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,
 	}
 
 	qp_grp = kzalloc(sizeof(*qp_grp), GFP_ATOMIC);
-	if (!qp_grp) {
-		usnic_err("Unable to alloc qp_grp - Out of memory\n");
+	if (!qp_grp)
 		return NULL;
-	}
 
 	qp_grp->res_chunk_list = alloc_res_chunk_list(vf->vnic, res_spec,
 							qp_grp);
 	if (IS_ERR_OR_NULL(qp_grp->res_chunk_list)) {
 		err = qp_grp->res_chunk_list ?
 				PTR_ERR(qp_grp->res_chunk_list) : -ENOMEM;
-		usnic_err("Unable to alloc res for %d with err %d\n",
-				qp_grp->grp_id, err);
 		goto out_free_qp_grp;
 	}
 

commit 49dc2b7173010792c6923930ffcee84b7094b7de
Merge: d66435cc7da9 d00cd819d7df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 21:38:27 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      drivers/rtc: broken link fix
      drm/i915 Fix typos in i915_gem_fence.c
      Docs: fix missing word in REPORTING-BUGS
      lib+mm: fix few spelling mistakes
      MAINTAINERS: add git URL for APM driver
      treewide: Fix typo in printk

commit fc4fa6e112c0f999fab022a4eb7f6614bb47c7ab
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun Dec 13 15:26:11 2015 +0900

    treewide: Fix typo in printk
    
    This patch fix spelling typos found in printk and Kconfig.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 85dc3f989ff7..704d08744116 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -64,7 +64,7 @@ const char *usnic_ib_qp_grp_state_to_string(enum ib_qp_state state)
 	case IB_QPS_ERR:
 		return "ERR";
 	default:
-		return "UNKOWN STATE";
+		return "UNKNOWN STATE";
 
 	}
 }

commit dc92d14684c066f81f120e740ef38b87f37e0622
Author: Nelson Escobar <neescoba@cisco.com>
Date:   Wed Dec 9 10:42:18 2015 -0800

    IB/usnic: Fix resource leak in error case
    
    Signed-off-by: Dave Goodell <dgoodell@cisco.com>
    Reviewed-by: Reese Faucette <rfaucett@cisco.com>
    Reviewed-by: Xuyang Wang <xuywang@cisco.com>
    Signed-off-by: Nelson Escobar <neescoba@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index b3068704f079..5f44b66ccb86 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -575,7 +575,7 @@ alloc_res_chunk_list(struct usnic_vnic *vnic,
 	return res_chunk_list;
 
 out_free_res:
-	for (i--; i > 0; i--)
+	for (i--; i >= 0; i--)
 		usnic_vnic_put_resources(res_chunk_list[i]);
 	kfree(res_chunk_list);
 	return ERR_PTR(err);

commit 2547a3663c5e765dfdc87009afde80643f586efe
Author: Nelson Escobar <neescoba@cisco.com>
Date:   Wed Dec 9 10:42:16 2015 -0800

    IB/usnic: Fix message typo
    
    Signed-off-by: Dave Goodell <dgoodell@cisco.com>
    Reviewed-by: Reese Faucette <rfaucett@cisco.com>
    Reviewed-by: Xuyang Wang <xuywang@cisco.com>
    Signed-off-by: Nelson Escobar <neescoba@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index fcea3a24d3eb..b3068704f079 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -521,7 +521,7 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 
 	if (!status) {
 		qp_grp->state = new_state;
-		usnic_info("Transistioned %u from %s to %s",
+		usnic_info("Transitioned %u from %s to %s",
 		qp_grp->grp_id,
 		usnic_ib_qp_grp_state_to_string(old_state),
 		usnic_ib_qp_grp_state_to_string(new_state));

commit fe274c5aed1b5e311e0e83306572b70312c0313a
Author: Insu Yun <wuninsu@gmail.com>
Date:   Mon Oct 19 16:57:10 2015 +0000

    usnic: correctly handle kzalloc return value
    
    Since kzalloc returns memory address, not error code,
    it should be checked whether it is null or not.
    
    Signed-off-by: Insu Yun <wuninsu@gmail.com>
    Reviewed-by: Dave Goodell <dgoodell@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 85dc3f989ff7..fcea3a24d3eb 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -236,8 +236,8 @@ create_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,
 
 	/* Create Flow Handle */
 	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
-	if (IS_ERR_OR_NULL(qp_flow)) {
-		err = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;
+	if (!qp_flow) {
+		err = -ENOMEM;
 		goto out_dealloc_flow;
 	}
 	qp_flow->flow = flow;
@@ -311,8 +311,8 @@ create_udp_flow(struct usnic_ib_qp_grp *qp_grp,
 
 	/* Create qp_flow */
 	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
-	if (IS_ERR_OR_NULL(qp_flow)) {
-		err = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;
+	if (!qp_flow) {
+		err = -ENOMEM;
 		goto out_dealloc_flow;
 	}
 	qp_flow->flow = flow;

commit 3805eade3b7c4a5ad593525703c2c82a84fd9b13
Author: Jeff Squyres <jsquyres@cisco.com>
Date:   Wed Sep 30 13:34:00 2015 -0700

    usnic: add missing clauses to BSD license
    
    The usnic_verbs kernel module was clearly marked with the following in
    its code:
    
      MODULE_LICENSE("Dual BSD/GPL");
    
    However, we accidentally left a few clauses of the BSD text out of the
    license header in all the source files.  This commit fixes that: all
    the files are properly dual BSD/GPL-licensed.  Contributors that might
    have been confused by this have been contacted to get their permission
    and are Cc:ed here.
    
    Cc: Benoit Taine <benoit.taine@lip6.fr>
    Cc: Ira Weiny <ira.weiny@intel.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Matan Barak <matanb@mellanox.com>
    Cc: Michael Wang <yun.wang@profitbricks.com>
    Cc: Roland Dreier <roland@purestorage.com>
    Cc: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Fabio Estevam <fabio.estevam@freescale.com>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Jeff Squyres <jsquyres@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index db3588df3546..85dc3f989ff7 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -1,9 +1,24 @@
 /*
  * Copyright (c) 2013, Cisco Systems, Inc. All rights reserved.
  *
- * This program is free software; you may redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

commit 9b13494c916dc0bf93802d7426b477cc0130fb48
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Aug 6 22:31:28 2014 +0900

    treewide: Fix typo in printk
    
    This patch fix spelling typo in printk within vairous
    part of the code.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index f8dfd76be89f..db3588df3546 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -511,7 +511,7 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 		usnic_ib_qp_grp_state_to_string(old_state),
 		usnic_ib_qp_grp_state_to_string(new_state));
 	} else {
-		usnic_err("Failed to transistion %u from %s to %s",
+		usnic_err("Failed to transition %u from %s to %s",
 		qp_grp->grp_id,
 		usnic_ib_qp_grp_state_to_string(old_state),
 		usnic_ib_qp_grp_state_to_string(new_state));

commit f809309a251a13bd97cc189c3fa428782aab9716
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 23 22:38:04 2014 +0000

    IB/usnic: Fix smatch endianness error
    
    Error reported at http://marc.info/?l=linux-rdma&m=138995755801039&w=2
    
    Fix short to int cast for big endian systems.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 7ecc6061f1f4..f8dfd76be89f 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -629,6 +629,7 @@ static int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,
 {
 	enum usnic_transport_type trans_type = qp_flow->trans_type;
 	int err;
+	uint16_t port_num = 0;
 
 	switch (trans_type) {
 	case USNIC_TRANSPORT_ROCE_CUSTOM:
@@ -637,9 +638,15 @@ static int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,
 	case USNIC_TRANSPORT_IPV4_UDP:
 		err = usnic_transport_sock_get_addr(qp_flow->udp.sock,
 							NULL, NULL,
-							(uint16_t *) id);
+							&port_num);
 		if (err)
 			return err;
+		/*
+		 * Copy port_num to stack first and then to *id,
+		 * so that the short to int cast works for little
+		 * and big endian systems.
+		 */
+		*id = port_num;
 		break;
 	default:
 		usnic_err("Unsupported transport %u\n", trans_type);

commit 9f637f7936025aef57f247b11036bad18bb87c06
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 15:40:58 2014 -0800

    IB/usnic: Expose flows via debugfs
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 3e17c7c156c3..7ecc6061f1f4 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -24,6 +24,7 @@
 #include "usnic_vnic.h"
 #include "usnic_fwd.h"
 #include "usnic_uiom.h"
+#include "usnic_debugfs.h"
 #include "usnic_ib_qp_grp.h"
 #include "usnic_ib_sysfs.h"
 #include "usnic_transport.h"
@@ -340,8 +341,10 @@ create_and_add_flow(struct usnic_ib_qp_grp *qp_grp,
 		return ERR_PTR(-EINVAL);
 	}
 
-	if (!IS_ERR_OR_NULL(qp_flow))
+	if (!IS_ERR_OR_NULL(qp_flow)) {
 		list_add_tail(&qp_flow->link, &qp_grp->flows_lst);
+		usnic_debugfs_flow_add(qp_flow);
+	}
 
 
 	return qp_flow;
@@ -349,6 +352,7 @@ create_and_add_flow(struct usnic_ib_qp_grp *qp_grp,
 
 static void release_and_remove_flow(struct usnic_ib_qp_grp_flow *qp_flow)
 {
+	usnic_debugfs_flow_remove(qp_flow);
 	list_del(&qp_flow->link);
 
 	switch (qp_flow->trans_type) {
@@ -728,9 +732,9 @@ void usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)
 	WARN_ON(qp_grp->state != IB_QPS_RESET);
 	lockdep_assert_held(&qp_grp->vf->lock);
 
+	release_and_remove_all_flows(qp_grp);
 	usnic_ib_sysfs_qpn_remove(qp_grp);
 	qp_grp_and_vf_unbind(qp_grp);
-	release_and_remove_all_flows(qp_grp);
 	free_qp_grp_res(qp_grp->res_chunk_list);
 	kfree(qp_grp);
 }

commit 6a54d9f9a04ed35e6615a47974c1ef02ff3a62cb
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:48:36 2014 -0800

    IB/usnic: Remove superflous parentheses
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index d6667a198d0b..3e17c7c156c3 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -214,14 +214,14 @@ create_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,
 	if (IS_ERR_OR_NULL(flow)) {
 		usnic_err("Unable to alloc flow failed with err %ld\n",
 				PTR_ERR(flow));
-		err = (flow) ? PTR_ERR(flow) : -EFAULT;
+		err = flow ? PTR_ERR(flow) : -EFAULT;
 		goto out_unreserve_port;
 	}
 
 	/* Create Flow Handle */
 	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
 	if (IS_ERR_OR_NULL(qp_flow)) {
-		err = (qp_flow) ? PTR_ERR(qp_flow) : -ENOMEM;
+		err = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;
 		goto out_dealloc_flow;
 	}
 	qp_flow->flow = flow;
@@ -289,14 +289,14 @@ create_udp_flow(struct usnic_ib_qp_grp *qp_grp,
 	if (IS_ERR_OR_NULL(flow)) {
 		usnic_err("Unable to alloc flow failed with err %ld\n",
 				PTR_ERR(flow));
-		err = (flow) ? PTR_ERR(flow) : -EFAULT;
+		err = flow ? PTR_ERR(flow) : -EFAULT;
 		goto out_put_sock;
 	}
 
 	/* Create qp_flow */
 	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
 	if (IS_ERR_OR_NULL(qp_flow)) {
-		err = (qp_flow) ? PTR_ERR(qp_flow) : -ENOMEM;
+		err = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;
 		goto out_dealloc_flow;
 	}
 	qp_flow->flow = flow;
@@ -415,7 +415,7 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 				qp_flow = create_and_add_flow(qp_grp,
 								trans_spec);
 				if (IS_ERR_OR_NULL(qp_flow)) {
-					status = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+					status = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;
 					break;
 				}
 			} else {
@@ -430,7 +430,7 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 				qp_flow = create_and_add_flow(qp_grp,
 								trans_spec);
 				if (IS_ERR_OR_NULL(qp_flow)) {
-					status = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+					status = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;
 					break;
 				}
 			} else {
@@ -543,8 +543,8 @@ alloc_res_chunk_list(struct usnic_vnic *vnic,
 		res_chunk_list[i] = usnic_vnic_get_resources(vnic, res_type,
 					res_cnt, owner_obj);
 		if (IS_ERR_OR_NULL(res_chunk_list[i])) {
-			err = (res_chunk_list[i] ?
-					PTR_ERR(res_chunk_list[i]) : -ENOMEM);
+			err = res_chunk_list[i] ?
+					PTR_ERR(res_chunk_list[i]) : -ENOMEM;
 			usnic_err("Failed to get %s from %s with err %d\n",
 				usnic_vnic_res_type_to_str(res_type),
 				usnic_vnic_pci_name(vnic),
@@ -697,7 +697,7 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,
 	if (IS_ERR_OR_NULL(qp_flow)) {
 		usnic_err("Unable to create and add flow with err %ld\n",
 				PTR_ERR(qp_flow));
-		err = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+		err = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;
 		goto out_qp_grp_vf_unbind;
 	}
 

commit e45e614e4015a489d2f8013eaed45d498d884e86
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:48:18 2014 -0800

    IB/usnic: Add UDP support in usnic_ib_qp_grp.[hc]
    
    UDP support for qp_grps/qps.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 2b7e0a1a07b4..d6667a198d0b 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -245,6 +245,80 @@ static void release_roce_custom_flow(struct usnic_ib_qp_grp_flow *qp_flow)
 	kfree(qp_flow);
 }
 
+static struct usnic_ib_qp_grp_flow*
+create_udp_flow(struct usnic_ib_qp_grp *qp_grp,
+		struct usnic_transport_spec *trans_spec)
+{
+	struct socket *sock;
+	int sock_fd;
+	int err;
+	struct filter filter;
+	struct usnic_filter_action uaction;
+	struct usnic_ib_qp_grp_flow *qp_flow;
+	struct usnic_fwd_flow *flow;
+	enum usnic_transport_type trans_type;
+	uint32_t addr;
+	uint16_t port_num;
+	int proto;
+
+	trans_type = trans_spec->trans_type;
+	sock_fd = trans_spec->udp.sock_fd;
+
+	/* Get and check socket */
+	sock = usnic_transport_get_socket(sock_fd);
+	if (IS_ERR_OR_NULL(sock))
+		return ERR_CAST(sock);
+
+	err = usnic_transport_sock_get_addr(sock, &proto, &addr, &port_num);
+	if (err)
+		goto out_put_sock;
+
+	if (proto != IPPROTO_UDP) {
+		usnic_err("Protocol for fd %d is not UDP", sock_fd);
+		err = -EPERM;
+		goto out_put_sock;
+	}
+
+	/* Create flow */
+	usnic_fwd_init_udp_filter(&filter, addr, port_num);
+	err = init_filter_action(qp_grp, &uaction);
+	if (err)
+		goto out_put_sock;
+
+	flow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);
+	if (IS_ERR_OR_NULL(flow)) {
+		usnic_err("Unable to alloc flow failed with err %ld\n",
+				PTR_ERR(flow));
+		err = (flow) ? PTR_ERR(flow) : -EFAULT;
+		goto out_put_sock;
+	}
+
+	/* Create qp_flow */
+	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
+	if (IS_ERR_OR_NULL(qp_flow)) {
+		err = (qp_flow) ? PTR_ERR(qp_flow) : -ENOMEM;
+		goto out_dealloc_flow;
+	}
+	qp_flow->flow = flow;
+	qp_flow->trans_type = trans_type;
+	qp_flow->udp.sock = sock;
+	qp_flow->qp_grp = qp_grp;
+	return qp_flow;
+
+out_dealloc_flow:
+	usnic_fwd_dealloc_flow(flow);
+out_put_sock:
+	usnic_transport_put_socket(sock);
+	return ERR_PTR(err);
+}
+
+static void release_udp_flow(struct usnic_ib_qp_grp_flow *qp_flow)
+{
+	usnic_fwd_dealloc_flow(qp_flow->flow);
+	usnic_transport_put_socket(qp_flow->udp.sock);
+	kfree(qp_flow);
+}
+
 static struct usnic_ib_qp_grp_flow*
 create_and_add_flow(struct usnic_ib_qp_grp *qp_grp,
 			struct usnic_transport_spec *trans_spec)
@@ -257,6 +331,9 @@ create_and_add_flow(struct usnic_ib_qp_grp *qp_grp,
 	case USNIC_TRANSPORT_ROCE_CUSTOM:
 		qp_flow = create_roce_custom_flow(qp_grp, trans_spec);
 		break;
+	case USNIC_TRANSPORT_IPV4_UDP:
+		qp_flow = create_udp_flow(qp_grp, trans_spec);
+		break;
 	default:
 		usnic_err("Unsupported transport %u\n",
 				trans_spec->trans_type);
@@ -278,6 +355,9 @@ static void release_and_remove_flow(struct usnic_ib_qp_grp_flow *qp_flow)
 	case USNIC_TRANSPORT_ROCE_CUSTOM:
 		release_roce_custom_flow(qp_flow);
 		break;
+	case USNIC_TRANSPORT_IPV4_UDP:
+		release_udp_flow(qp_flow);
+		break;
 	default:
 		WARN(1, "Unsupported transport %u\n",
 				qp_flow->trans_type);
@@ -544,11 +624,19 @@ static int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,
 				uint32_t *id)
 {
 	enum usnic_transport_type trans_type = qp_flow->trans_type;
+	int err;
 
 	switch (trans_type) {
 	case USNIC_TRANSPORT_ROCE_CUSTOM:
 		*id = qp_flow->usnic_roce.port_num;
 		break;
+	case USNIC_TRANSPORT_IPV4_UDP:
+		err = usnic_transport_sock_get_addr(qp_flow->udp.sock,
+							NULL, NULL,
+							(uint16_t *) id);
+		if (err)
+			return err;
+		break;
 	default:
 		usnic_err("Unsupported transport %u\n", trans_type);
 		return -EINVAL;

commit 256d6a6ac52ee02e897cec88ecc96c3ae7f9cb88
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:48:09 2014 -0800

    IB/usnic: Port over usnic_ib_qp_grp.[hc] to new usnic_fwd.h
    
    This patch ports usnic_ib_qp_grp.[hc] to the new interface
    of usnic_fwd.h.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 5a873f5c2794..2b7e0a1a07b4 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -15,6 +15,7 @@
  * SOFTWARE.
  *
  */
+#include <linux/bug.h>
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
@@ -27,6 +28,8 @@
 #include "usnic_ib_sysfs.h"
 #include "usnic_transport.h"
 
+#define DFLT_RQ_IDX	0
+
 const char *usnic_ib_qp_grp_state_to_string(enum ib_qp_state state)
 {
 	switch (state) {
@@ -58,83 +61,31 @@ int usnic_ib_qp_grp_dump_hdr(char *buf, int buf_sz)
 int usnic_ib_qp_grp_dump_rows(void *obj, char *buf, int buf_sz)
 {
 	struct usnic_ib_qp_grp *qp_grp = obj;
-	struct usnic_fwd_filter_hndl *default_filter_hndl;
+	struct usnic_ib_qp_grp_flow *default_flow;
 	if (obj) {
-		default_filter_hndl = list_first_entry(&qp_grp->filter_hndls,
-					struct usnic_fwd_filter_hndl, link);
+		default_flow = list_first_entry(&qp_grp->flows_lst,
+					struct usnic_ib_qp_grp_flow, link);
 		return scnprintf(buf, buf_sz, "|%d\t|%s\t|%d\t|%hu\t|%d",
 					qp_grp->ibqp.qp_num,
 					usnic_ib_qp_grp_state_to_string(
 							qp_grp->state),
 					qp_grp->owner_pid,
 					usnic_vnic_get_index(qp_grp->vf->vnic),
-					default_filter_hndl->id);
+					default_flow->flow->flow_id);
 	} else {
 		return scnprintf(buf, buf_sz, "|N/A\t|N/A\t|N/A\t|N/A\t|N/A");
 	}
 }
 
-static int add_fwd_filter(struct usnic_ib_qp_grp *qp_grp,
-				struct usnic_fwd_filter *fwd_filter)
-{
-	struct usnic_fwd_filter_hndl *filter_hndl;
-	int status;
-	struct usnic_vnic_res_chunk *chunk;
-	int rq_idx;
-
-	lockdep_assert_held(&qp_grp->lock);
-
-	chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
-	if (IS_ERR_OR_NULL(chunk) || chunk->cnt < 1) {
-		usnic_err("Failed to get RQ info for qp_grp %u\n",
-				qp_grp->grp_id);
-		return -EFAULT;
-	}
-
-	rq_idx = chunk->res[0]->vnic_idx;
-
-	switch (qp_grp->transport) {
-	case USNIC_TRANSPORT_ROCE_CUSTOM:
-		status = usnic_fwd_add_usnic_filter(qp_grp->ufdev,
-					usnic_vnic_get_index(qp_grp->vf->vnic),
-					rq_idx,
-					fwd_filter,
-					&filter_hndl);
-		break;
-	default:
-		usnic_err("Unable to install filter for qp_grp %u for transport %d",
-				qp_grp->grp_id, qp_grp->transport);
-		status = -EINVAL;
-	}
-
-	if (status)
-		return status;
-
-	list_add_tail(&filter_hndl->link, &qp_grp->filter_hndls);
-	return 0;
-}
-
-static int del_all_filters(struct usnic_ib_qp_grp *qp_grp)
+static struct usnic_vnic_res_chunk *
+get_qp_res_chunk(struct usnic_ib_qp_grp *qp_grp)
 {
-	int err, status;
-	struct usnic_fwd_filter_hndl *filter_hndl, *tmp;
-
 	lockdep_assert_held(&qp_grp->lock);
-
-	status = 0;
-
-	list_for_each_entry_safe(filter_hndl, tmp,
-					&qp_grp->filter_hndls, link) {
-		list_del(&filter_hndl->link);
-		err = usnic_fwd_del_filter(filter_hndl);
-		if (err) {
-			usnic_err("Failed to delete filter %u of qp_grp %d\n",
-					filter_hndl->id, qp_grp->grp_id);
-		}
-		status |= err;
-	}
-
-	return status;
+	/*
+	 * The QP res chunk, used to derive qp indices,
+	 * are just indices of the RQs
+	 */
+	return usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
 }
 
 static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
@@ -149,22 +100,20 @@ static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
-	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	res_chunk = get_qp_res_chunk(qp_grp);
 	if (IS_ERR_OR_NULL(res_chunk)) {
-		usnic_err("Unable to get %s with err %ld\n",
-			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
-			PTR_ERR(res_chunk));
+		usnic_err("Unable to get qp res with err %ld\n",
+				PTR_ERR(res_chunk));
 		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
 	}
 
 	for (i = 0; i < res_chunk->cnt; i++) {
 		res = res_chunk->res[i];
-		status = usnic_fwd_enable_rq(qp_grp->ufdev, vnic_idx,
+		status = usnic_fwd_enable_qp(qp_grp->ufdev, vnic_idx,
 						res->vnic_idx);
 		if (status) {
-			usnic_err("Failed to enable rq %d of %s:%d\n with err %d\n",
-					res->vnic_idx,
-					netdev_name(qp_grp->ufdev->netdev),
+			usnic_err("Failed to enable qp %d of %s:%d\n with err %d\n",
+					res->vnic_idx, qp_grp->ufdev->name,
 					vnic_idx, status);
 			goto out_err;
 		}
@@ -175,7 +124,7 @@ static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 out_err:
 	for (i--; i >= 0; i--) {
 		res = res_chunk->res[i];
-		usnic_fwd_disable_rq(qp_grp->ufdev, vnic_idx,
+		usnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,
 					res->vnic_idx);
 	}
 
@@ -192,22 +141,21 @@ static int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 	lockdep_assert_held(&qp_grp->lock);
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
-	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	res_chunk = get_qp_res_chunk(qp_grp);
 	if (IS_ERR_OR_NULL(res_chunk)) {
-		usnic_err("Unable to get %s with err %ld\n",
-			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
+		usnic_err("Unable to get qp res with err %ld\n",
 			PTR_ERR(res_chunk));
 		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
 	}
 
 	for (i = 0; i < res_chunk->cnt; i++) {
 		res = res_chunk->res[i];
-		status = usnic_fwd_disable_rq(qp_grp->ufdev, vnic_idx,
+		status = usnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,
 						res->vnic_idx);
 		if (status) {
 			usnic_err("Failed to disable rq %d of %s:%d\n with err %d\n",
 					res->vnic_idx,
-					netdev_name(qp_grp->ufdev->netdev),
+					qp_grp->ufdev->name,
 					vnic_idx, status);
 		}
 	}
@@ -216,17 +164,148 @@ static int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 
 }
 
+static int init_filter_action(struct usnic_ib_qp_grp *qp_grp,
+				struct usnic_filter_action *uaction)
+{
+	struct usnic_vnic_res_chunk *res_chunk;
+
+	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	if (IS_ERR_OR_NULL(res_chunk)) {
+		usnic_err("Unable to get %s with err %ld\n",
+			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
+			PTR_ERR(res_chunk));
+		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+	}
+
+	uaction->vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
+	uaction->action.type = FILTER_ACTION_RQ_STEERING;
+	uaction->action.u.rq_idx = res_chunk->res[DFLT_RQ_IDX]->vnic_idx;
+
+	return 0;
+}
+
+static struct usnic_ib_qp_grp_flow*
+create_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,
+			struct usnic_transport_spec *trans_spec)
+{
+	uint16_t port_num;
+	int err;
+	struct filter filter;
+	struct usnic_filter_action uaction;
+	struct usnic_ib_qp_grp_flow *qp_flow;
+	struct usnic_fwd_flow *flow;
+	enum usnic_transport_type trans_type;
+
+	trans_type = trans_spec->trans_type;
+	port_num = trans_spec->usnic_roce.port_num;
+
+	/* Reserve Port */
+	port_num = usnic_transport_rsrv_port(trans_type, port_num);
+	if (port_num == 0)
+		return ERR_PTR(-EINVAL);
+
+	/* Create Flow */
+	usnic_fwd_init_usnic_filter(&filter, port_num);
+	err = init_filter_action(qp_grp, &uaction);
+	if (err)
+		goto out_unreserve_port;
+
+	flow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);
+	if (IS_ERR_OR_NULL(flow)) {
+		usnic_err("Unable to alloc flow failed with err %ld\n",
+				PTR_ERR(flow));
+		err = (flow) ? PTR_ERR(flow) : -EFAULT;
+		goto out_unreserve_port;
+	}
+
+	/* Create Flow Handle */
+	qp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);
+	if (IS_ERR_OR_NULL(qp_flow)) {
+		err = (qp_flow) ? PTR_ERR(qp_flow) : -ENOMEM;
+		goto out_dealloc_flow;
+	}
+	qp_flow->flow = flow;
+	qp_flow->trans_type = trans_type;
+	qp_flow->usnic_roce.port_num = port_num;
+	qp_flow->qp_grp = qp_grp;
+	return qp_flow;
+
+out_dealloc_flow:
+	usnic_fwd_dealloc_flow(flow);
+out_unreserve_port:
+	usnic_transport_unrsrv_port(trans_type, port_num);
+	return ERR_PTR(err);
+}
+
+static void release_roce_custom_flow(struct usnic_ib_qp_grp_flow *qp_flow)
+{
+	usnic_fwd_dealloc_flow(qp_flow->flow);
+	usnic_transport_unrsrv_port(qp_flow->trans_type,
+					qp_flow->usnic_roce.port_num);
+	kfree(qp_flow);
+}
+
+static struct usnic_ib_qp_grp_flow*
+create_and_add_flow(struct usnic_ib_qp_grp *qp_grp,
+			struct usnic_transport_spec *trans_spec)
+{
+	struct usnic_ib_qp_grp_flow *qp_flow;
+	enum usnic_transport_type trans_type;
+
+	trans_type = trans_spec->trans_type;
+	switch (trans_type) {
+	case USNIC_TRANSPORT_ROCE_CUSTOM:
+		qp_flow = create_roce_custom_flow(qp_grp, trans_spec);
+		break;
+	default:
+		usnic_err("Unsupported transport %u\n",
+				trans_spec->trans_type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!IS_ERR_OR_NULL(qp_flow))
+		list_add_tail(&qp_flow->link, &qp_grp->flows_lst);
+
+
+	return qp_flow;
+}
+
+static void release_and_remove_flow(struct usnic_ib_qp_grp_flow *qp_flow)
+{
+	list_del(&qp_flow->link);
+
+	switch (qp_flow->trans_type) {
+	case USNIC_TRANSPORT_ROCE_CUSTOM:
+		release_roce_custom_flow(qp_flow);
+		break;
+	default:
+		WARN(1, "Unsupported transport %u\n",
+				qp_flow->trans_type);
+		break;
+	}
+}
+
+static void release_and_remove_all_flows(struct usnic_ib_qp_grp *qp_grp)
+{
+	struct usnic_ib_qp_grp_flow *qp_flow, *tmp;
+	list_for_each_entry_safe(qp_flow, tmp, &qp_grp->flows_lst, link)
+		release_and_remove_flow(qp_flow);
+}
+
 int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 				enum ib_qp_state new_state,
-				struct usnic_fwd_filter *fwd_filter)
+				void *data)
 {
 	int status = 0;
 	int vnic_idx;
 	struct ib_event ib_event;
 	enum ib_qp_state old_state;
+	struct usnic_transport_spec *trans_spec;
+	struct usnic_ib_qp_grp_flow *qp_flow;
 
 	old_state = qp_grp->state;
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
+	trans_spec = (struct usnic_transport_spec *) data;
 
 	spin_lock(&qp_grp->lock);
 	switch (new_state) {
@@ -236,13 +315,14 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 			/* NO-OP */
 			break;
 		case IB_QPS_INIT:
-			status = del_all_filters(qp_grp);
+			release_and_remove_all_flows(qp_grp);
+			status = 0;
 			break;
 		case IB_QPS_RTR:
 		case IB_QPS_RTS:
 		case IB_QPS_ERR:
 			status = disable_qp_grp(qp_grp);
-			status &= del_all_filters(qp_grp);
+			release_and_remove_all_flows(qp_grp);
 			break;
 		default:
 			status = -EINVAL;
@@ -251,10 +331,35 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 	case IB_QPS_INIT:
 		switch (old_state) {
 		case IB_QPS_RESET:
-			status = add_fwd_filter(qp_grp, fwd_filter);
+			if (trans_spec) {
+				qp_flow = create_and_add_flow(qp_grp,
+								trans_spec);
+				if (IS_ERR_OR_NULL(qp_flow)) {
+					status = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+					break;
+				}
+			} else {
+				/*
+				 * Optional to specify filters.
+				 */
+				status = 0;
+			}
 			break;
 		case IB_QPS_INIT:
-			status = add_fwd_filter(qp_grp, fwd_filter);
+			if (trans_spec) {
+				qp_flow = create_and_add_flow(qp_grp,
+								trans_spec);
+				if (IS_ERR_OR_NULL(qp_flow)) {
+					status = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+					break;
+				}
+			} else {
+				/*
+				 * Doesn't make sense to go into INIT state
+				 * from INIT state w/o adding filters.
+				 */
+				status = -EINVAL;
+			}
 			break;
 		case IB_QPS_RTR:
 			status = disable_qp_grp(qp_grp);
@@ -295,14 +400,14 @@ int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
 					qp_grp->ibqp.qp_context);
 			break;
 		case IB_QPS_INIT:
-			status = del_all_filters(qp_grp);
+			release_and_remove_all_flows(qp_grp);
 			qp_grp->ibqp.event_handler(&ib_event,
 					qp_grp->ibqp.qp_context);
 			break;
 		case IB_QPS_RTR:
 		case IB_QPS_RTS:
 			status = disable_qp_grp(qp_grp);
-			status &= del_all_filters(qp_grp);
+			release_and_remove_all_flows(qp_grp);
 			qp_grp->ibqp.event_handler(&ib_event,
 					qp_grp->ibqp.qp_context);
 			break;
@@ -435,16 +540,33 @@ static void log_spec(struct usnic_vnic_res_spec *res_spec)
 	usnic_dbg("%s\n", buf);
 }
 
+static int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,
+				uint32_t *id)
+{
+	enum usnic_transport_type trans_type = qp_flow->trans_type;
+
+	switch (trans_type) {
+	case USNIC_TRANSPORT_ROCE_CUSTOM:
+		*id = qp_flow->usnic_roce.port_num;
+		break;
+	default:
+		usnic_err("Unsupported transport %u\n", trans_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 struct usnic_ib_qp_grp *
-usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev,
-			struct usnic_ib_vf *vf,
+usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,
 			struct usnic_ib_pd *pd,
 			struct usnic_vnic_res_spec *res_spec,
-			enum usnic_transport_type transport)
+			struct usnic_transport_spec *transport_spec)
 {
 	struct usnic_ib_qp_grp *qp_grp;
-	u16 port_num;
 	int err;
+	enum usnic_transport_type transport = transport_spec->trans_type;
+	struct usnic_ib_qp_grp_flow *qp_flow;
 
 	lockdep_assert_held(&vf->lock);
 
@@ -457,13 +579,6 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev,
 		return ERR_PTR(err);
 	}
 
-	port_num = usnic_transport_rsrv_port(transport, 0);
-	if (!port_num) {
-		usnic_err("Unable to allocate port for %s\n",
-				netdev_name(ufdev->netdev));
-		return ERR_PTR(-EINVAL);
-	}
-
 	qp_grp = kzalloc(sizeof(*qp_grp), GFP_ATOMIC);
 	if (!qp_grp) {
 		usnic_err("Unable to alloc qp_grp - Out of memory\n");
@@ -477,53 +592,59 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev,
 				PTR_ERR(qp_grp->res_chunk_list) : -ENOMEM;
 		usnic_err("Unable to alloc res for %d with err %d\n",
 				qp_grp->grp_id, err);
-		goto out_free_port;
+		goto out_free_qp_grp;
 	}
 
-	INIT_LIST_HEAD(&qp_grp->filter_hndls);
+	err = qp_grp_and_vf_bind(vf, pd, qp_grp);
+	if (err)
+		goto out_free_res;
+
+	INIT_LIST_HEAD(&qp_grp->flows_lst);
 	spin_lock_init(&qp_grp->lock);
 	qp_grp->ufdev = ufdev;
-	qp_grp->transport = transport;
-	qp_grp->filters[DFLT_FILTER_IDX].transport = transport;
-	qp_grp->filters[DFLT_FILTER_IDX].port_num = port_num;
 	qp_grp->state = IB_QPS_RESET;
 	qp_grp->owner_pid = current->pid;
 
-	/* qp_num is same as default filter port_num */
-	qp_grp->ibqp.qp_num = qp_grp->filters[DFLT_FILTER_IDX].port_num;
-	qp_grp->grp_id = qp_grp->ibqp.qp_num;
+	qp_flow = create_and_add_flow(qp_grp, transport_spec);
+	if (IS_ERR_OR_NULL(qp_flow)) {
+		usnic_err("Unable to create and add flow with err %ld\n",
+				PTR_ERR(qp_flow));
+		err = (qp_flow) ? PTR_ERR(qp_flow) : -EFAULT;
+		goto out_qp_grp_vf_unbind;
+	}
 
-	err = qp_grp_and_vf_bind(vf, pd, qp_grp);
+	err = qp_grp_id_from_flow(qp_flow, &qp_grp->grp_id);
 	if (err)
-		goto out_free_port;
+		goto out_release_flow;
+	qp_grp->ibqp.qp_num = qp_grp->grp_id;
 
 	usnic_ib_sysfs_qpn_add(qp_grp);
 
 	return qp_grp;
 
-out_free_port:
+out_release_flow:
+	release_and_remove_flow(qp_flow);
+out_qp_grp_vf_unbind:
+	qp_grp_and_vf_unbind(qp_grp);
+out_free_res:
+	free_qp_grp_res(qp_grp->res_chunk_list);
+out_free_qp_grp:
 	kfree(qp_grp);
-	usnic_transport_unrsrv_port(transport, port_num);
 
 	return ERR_PTR(err);
 }
 
 void usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)
 {
-	u16 default_port_num;
-	enum usnic_transport_type transport;
 
 	WARN_ON(qp_grp->state != IB_QPS_RESET);
 	lockdep_assert_held(&qp_grp->vf->lock);
 
-	transport = qp_grp->filters[DFLT_FILTER_IDX].transport;
-	default_port_num = qp_grp->filters[DFLT_FILTER_IDX].port_num;
-
 	usnic_ib_sysfs_qpn_remove(qp_grp);
 	qp_grp_and_vf_unbind(qp_grp);
+	release_and_remove_all_flows(qp_grp);
 	free_qp_grp_res(qp_grp->res_chunk_list);
 	kfree(qp_grp);
-	usnic_transport_unrsrv_port(transport, default_port_num);
 }
 
 struct usnic_vnic_res_chunk*

commit 8192d4acb5c5376c0f6756f2106ab243036c8c7d
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:47:33 2014 -0800

    IB/usnic: Change WARN_ON to lockdep_assert_held
    
    usNIC calls WARN_ON(spin_is_locked..) at few places.  In some of these
    instances, the call is made while holding a spinlock.  Change
    all WARN_ON(spin_is_locked...) calls in usNIC to
    lockdep_assert_held to make it fool-proof bc the latter can be
    called while holding a spinlock and unlike spin_is_locked,
    lockdep_assert_held also works correctly on UP.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index ca5fa6ad59ac..5a873f5c2794 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -82,7 +82,7 @@ static int add_fwd_filter(struct usnic_ib_qp_grp *qp_grp,
 	struct usnic_vnic_res_chunk *chunk;
 	int rq_idx;
 
-	WARN_ON(!spin_is_locked(&qp_grp->lock));
+	lockdep_assert_held(&qp_grp->lock);
 
 	chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
 	if (IS_ERR_OR_NULL(chunk) || chunk->cnt < 1) {
@@ -119,7 +119,7 @@ static int del_all_filters(struct usnic_ib_qp_grp *qp_grp)
 	int err, status;
 	struct usnic_fwd_filter_hndl *filter_hndl, *tmp;
 
-	WARN_ON(!spin_is_locked(&qp_grp->lock));
+	lockdep_assert_held(&qp_grp->lock);
 
 	status = 0;
 
@@ -145,7 +145,7 @@ static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 	struct usnic_vnic_res_chunk *res_chunk;
 	struct usnic_vnic_res *res;
 
-	WARN_ON(!spin_is_locked(&qp_grp->lock));
+	lockdep_assert_held(&qp_grp->lock);
 
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
@@ -189,7 +189,7 @@ static int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
 	struct usnic_vnic_res *res;
 	int status = 0;
 
-	WARN_ON(!spin_is_locked(&qp_grp->lock));
+	lockdep_assert_held(&qp_grp->lock);
 	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
 
 	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
@@ -392,7 +392,7 @@ static int qp_grp_and_vf_bind(struct usnic_ib_vf *vf,
 	int err;
 	struct pci_dev *pdev;
 
-	WARN_ON(!spin_is_locked(&vf->lock));
+	lockdep_assert_held(&vf->lock);
 
 	pdev = usnic_vnic_get_pdev(vf->vnic);
 	if (vf->qp_grp_ref_cnt == 0) {
@@ -417,7 +417,7 @@ static void qp_grp_and_vf_unbind(struct usnic_ib_qp_grp *qp_grp)
 	struct pci_dev *pdev;
 	struct usnic_ib_pd *pd;
 
-	WARN_ON(!spin_is_locked(&qp_grp->vf->lock));
+	lockdep_assert_held(&qp_grp->vf->lock);
 
 	pd = qp_grp->vf->pd;
 	pdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);
@@ -446,7 +446,7 @@ usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev,
 	u16 port_num;
 	int err;
 
-	WARN_ON(!spin_is_locked(&vf->lock));
+	lockdep_assert_held(&vf->lock);
 
 	err = usnic_vnic_res_spec_satisfied(&min_transport_spec[transport],
 						res_spec);
@@ -514,7 +514,7 @@ void usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)
 	enum usnic_transport_type transport;
 
 	WARN_ON(qp_grp->state != IB_QPS_RESET);
-	WARN_ON(!spin_is_locked(&qp_grp->vf->lock));
+	lockdep_assert_held(&qp_grp->vf->lock);
 
 	transport = qp_grp->filters[DFLT_FILTER_IDX].transport;
 	default_port_num = qp_grp->filters[DFLT_FILTER_IDX].port_num;

commit e3cf00d0a87f025db5855a43a67c67a41fa79fef
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Tue Sep 10 03:38:16 2013 +0000

    IB/usnic: Add Cisco VIC low-level hardware driver
    
    This adds a driver that allows userspace to use UD-like QPs over a
    proprietary Cisco transport with Cisco's Virtual Interface Cards (VICs),
    including VIC 1240 and 1280 cards.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Christian Benvenuti <benve@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
new file mode 100644
index 000000000000..ca5fa6ad59ac
--- /dev/null
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -0,0 +1,541 @@
+/*
+ * Copyright (c) 2013, Cisco Systems, Inc. All rights reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+#include "usnic_log.h"
+#include "usnic_vnic.h"
+#include "usnic_fwd.h"
+#include "usnic_uiom.h"
+#include "usnic_ib_qp_grp.h"
+#include "usnic_ib_sysfs.h"
+#include "usnic_transport.h"
+
+const char *usnic_ib_qp_grp_state_to_string(enum ib_qp_state state)
+{
+	switch (state) {
+	case IB_QPS_RESET:
+		return "Rst";
+	case IB_QPS_INIT:
+		return "Init";
+	case IB_QPS_RTR:
+		return "RTR";
+	case IB_QPS_RTS:
+		return "RTS";
+	case IB_QPS_SQD:
+		return "SQD";
+	case IB_QPS_SQE:
+		return "SQE";
+	case IB_QPS_ERR:
+		return "ERR";
+	default:
+		return "UNKOWN STATE";
+
+	}
+}
+
+int usnic_ib_qp_grp_dump_hdr(char *buf, int buf_sz)
+{
+	return scnprintf(buf, buf_sz, "|QPN\t|State\t|PID\t|VF Idx\t|Fil ID");
+}
+
+int usnic_ib_qp_grp_dump_rows(void *obj, char *buf, int buf_sz)
+{
+	struct usnic_ib_qp_grp *qp_grp = obj;
+	struct usnic_fwd_filter_hndl *default_filter_hndl;
+	if (obj) {
+		default_filter_hndl = list_first_entry(&qp_grp->filter_hndls,
+					struct usnic_fwd_filter_hndl, link);
+		return scnprintf(buf, buf_sz, "|%d\t|%s\t|%d\t|%hu\t|%d",
+					qp_grp->ibqp.qp_num,
+					usnic_ib_qp_grp_state_to_string(
+							qp_grp->state),
+					qp_grp->owner_pid,
+					usnic_vnic_get_index(qp_grp->vf->vnic),
+					default_filter_hndl->id);
+	} else {
+		return scnprintf(buf, buf_sz, "|N/A\t|N/A\t|N/A\t|N/A\t|N/A");
+	}
+}
+
+static int add_fwd_filter(struct usnic_ib_qp_grp *qp_grp,
+				struct usnic_fwd_filter *fwd_filter)
+{
+	struct usnic_fwd_filter_hndl *filter_hndl;
+	int status;
+	struct usnic_vnic_res_chunk *chunk;
+	int rq_idx;
+
+	WARN_ON(!spin_is_locked(&qp_grp->lock));
+
+	chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	if (IS_ERR_OR_NULL(chunk) || chunk->cnt < 1) {
+		usnic_err("Failed to get RQ info for qp_grp %u\n",
+				qp_grp->grp_id);
+		return -EFAULT;
+	}
+
+	rq_idx = chunk->res[0]->vnic_idx;
+
+	switch (qp_grp->transport) {
+	case USNIC_TRANSPORT_ROCE_CUSTOM:
+		status = usnic_fwd_add_usnic_filter(qp_grp->ufdev,
+					usnic_vnic_get_index(qp_grp->vf->vnic),
+					rq_idx,
+					fwd_filter,
+					&filter_hndl);
+		break;
+	default:
+		usnic_err("Unable to install filter for qp_grp %u for transport %d",
+				qp_grp->grp_id, qp_grp->transport);
+		status = -EINVAL;
+	}
+
+	if (status)
+		return status;
+
+	list_add_tail(&filter_hndl->link, &qp_grp->filter_hndls);
+	return 0;
+}
+
+static int del_all_filters(struct usnic_ib_qp_grp *qp_grp)
+{
+	int err, status;
+	struct usnic_fwd_filter_hndl *filter_hndl, *tmp;
+
+	WARN_ON(!spin_is_locked(&qp_grp->lock));
+
+	status = 0;
+
+	list_for_each_entry_safe(filter_hndl, tmp,
+					&qp_grp->filter_hndls, link) {
+		list_del(&filter_hndl->link);
+		err = usnic_fwd_del_filter(filter_hndl);
+		if (err) {
+			usnic_err("Failed to delete filter %u of qp_grp %d\n",
+					filter_hndl->id, qp_grp->grp_id);
+		}
+		status |= err;
+	}
+
+	return status;
+}
+
+static int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
+{
+
+	int status;
+	int i, vnic_idx;
+	struct usnic_vnic_res_chunk *res_chunk;
+	struct usnic_vnic_res *res;
+
+	WARN_ON(!spin_is_locked(&qp_grp->lock));
+
+	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
+
+	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	if (IS_ERR_OR_NULL(res_chunk)) {
+		usnic_err("Unable to get %s with err %ld\n",
+			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
+			PTR_ERR(res_chunk));
+		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+	}
+
+	for (i = 0; i < res_chunk->cnt; i++) {
+		res = res_chunk->res[i];
+		status = usnic_fwd_enable_rq(qp_grp->ufdev, vnic_idx,
+						res->vnic_idx);
+		if (status) {
+			usnic_err("Failed to enable rq %d of %s:%d\n with err %d\n",
+					res->vnic_idx,
+					netdev_name(qp_grp->ufdev->netdev),
+					vnic_idx, status);
+			goto out_err;
+		}
+	}
+
+	return 0;
+
+out_err:
+	for (i--; i >= 0; i--) {
+		res = res_chunk->res[i];
+		usnic_fwd_disable_rq(qp_grp->ufdev, vnic_idx,
+					res->vnic_idx);
+	}
+
+	return status;
+}
+
+static int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)
+{
+	int i, vnic_idx;
+	struct usnic_vnic_res_chunk *res_chunk;
+	struct usnic_vnic_res *res;
+	int status = 0;
+
+	WARN_ON(!spin_is_locked(&qp_grp->lock));
+	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
+
+	res_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);
+	if (IS_ERR_OR_NULL(res_chunk)) {
+		usnic_err("Unable to get %s with err %ld\n",
+			usnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),
+			PTR_ERR(res_chunk));
+		return res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;
+	}
+
+	for (i = 0; i < res_chunk->cnt; i++) {
+		res = res_chunk->res[i];
+		status = usnic_fwd_disable_rq(qp_grp->ufdev, vnic_idx,
+						res->vnic_idx);
+		if (status) {
+			usnic_err("Failed to disable rq %d of %s:%d\n with err %d\n",
+					res->vnic_idx,
+					netdev_name(qp_grp->ufdev->netdev),
+					vnic_idx, status);
+		}
+	}
+
+	return status;
+
+}
+
+int usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,
+				enum ib_qp_state new_state,
+				struct usnic_fwd_filter *fwd_filter)
+{
+	int status = 0;
+	int vnic_idx;
+	struct ib_event ib_event;
+	enum ib_qp_state old_state;
+
+	old_state = qp_grp->state;
+	vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);
+
+	spin_lock(&qp_grp->lock);
+	switch (new_state) {
+	case IB_QPS_RESET:
+		switch (old_state) {
+		case IB_QPS_RESET:
+			/* NO-OP */
+			break;
+		case IB_QPS_INIT:
+			status = del_all_filters(qp_grp);
+			break;
+		case IB_QPS_RTR:
+		case IB_QPS_RTS:
+		case IB_QPS_ERR:
+			status = disable_qp_grp(qp_grp);
+			status &= del_all_filters(qp_grp);
+			break;
+		default:
+			status = -EINVAL;
+		}
+		break;
+	case IB_QPS_INIT:
+		switch (old_state) {
+		case IB_QPS_RESET:
+			status = add_fwd_filter(qp_grp, fwd_filter);
+			break;
+		case IB_QPS_INIT:
+			status = add_fwd_filter(qp_grp, fwd_filter);
+			break;
+		case IB_QPS_RTR:
+			status = disable_qp_grp(qp_grp);
+			break;
+		case IB_QPS_RTS:
+			status = disable_qp_grp(qp_grp);
+			break;
+		default:
+			status = -EINVAL;
+		}
+		break;
+	case IB_QPS_RTR:
+		switch (old_state) {
+		case IB_QPS_INIT:
+			status = enable_qp_grp(qp_grp);
+			break;
+		default:
+			status = -EINVAL;
+		}
+		break;
+	case IB_QPS_RTS:
+		switch (old_state) {
+		case IB_QPS_RTR:
+			/* NO-OP FOR NOW */
+			break;
+		default:
+			status = -EINVAL;
+		}
+		break;
+	case IB_QPS_ERR:
+		ib_event.device = &qp_grp->vf->pf->ib_dev;
+		ib_event.element.qp = &qp_grp->ibqp;
+		ib_event.event = IB_EVENT_QP_FATAL;
+
+		switch (old_state) {
+		case IB_QPS_RESET:
+			qp_grp->ibqp.event_handler(&ib_event,
+					qp_grp->ibqp.qp_context);
+			break;
+		case IB_QPS_INIT:
+			status = del_all_filters(qp_grp);
+			qp_grp->ibqp.event_handler(&ib_event,
+					qp_grp->ibqp.qp_context);
+			break;
+		case IB_QPS_RTR:
+		case IB_QPS_RTS:
+			status = disable_qp_grp(qp_grp);
+			status &= del_all_filters(qp_grp);
+			qp_grp->ibqp.event_handler(&ib_event,
+					qp_grp->ibqp.qp_context);
+			break;
+		default:
+			status = -EINVAL;
+		}
+		break;
+	default:
+		status = -EINVAL;
+	}
+	spin_unlock(&qp_grp->lock);
+
+	if (!status) {
+		qp_grp->state = new_state;
+		usnic_info("Transistioned %u from %s to %s",
+		qp_grp->grp_id,
+		usnic_ib_qp_grp_state_to_string(old_state),
+		usnic_ib_qp_grp_state_to_string(new_state));
+	} else {
+		usnic_err("Failed to transistion %u from %s to %s",
+		qp_grp->grp_id,
+		usnic_ib_qp_grp_state_to_string(old_state),
+		usnic_ib_qp_grp_state_to_string(new_state));
+	}
+
+	return status;
+}
+
+static struct usnic_vnic_res_chunk**
+alloc_res_chunk_list(struct usnic_vnic *vnic,
+			struct usnic_vnic_res_spec *res_spec, void *owner_obj)
+{
+	enum usnic_vnic_res_type res_type;
+	struct usnic_vnic_res_chunk **res_chunk_list;
+	int err, i, res_cnt, res_lst_sz;
+
+	for (res_lst_sz = 0;
+		res_spec->resources[res_lst_sz].type != USNIC_VNIC_RES_TYPE_EOL;
+		res_lst_sz++) {
+		/* Do Nothing */
+	}
+
+	res_chunk_list = kzalloc(sizeof(*res_chunk_list)*(res_lst_sz+1),
+					GFP_ATOMIC);
+	if (!res_chunk_list)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; res_spec->resources[i].type != USNIC_VNIC_RES_TYPE_EOL;
+		i++) {
+		res_type = res_spec->resources[i].type;
+		res_cnt = res_spec->resources[i].cnt;
+
+		res_chunk_list[i] = usnic_vnic_get_resources(vnic, res_type,
+					res_cnt, owner_obj);
+		if (IS_ERR_OR_NULL(res_chunk_list[i])) {
+			err = (res_chunk_list[i] ?
+					PTR_ERR(res_chunk_list[i]) : -ENOMEM);
+			usnic_err("Failed to get %s from %s with err %d\n",
+				usnic_vnic_res_type_to_str(res_type),
+				usnic_vnic_pci_name(vnic),
+				err);
+			goto out_free_res;
+		}
+	}
+
+	return res_chunk_list;
+
+out_free_res:
+	for (i--; i > 0; i--)
+		usnic_vnic_put_resources(res_chunk_list[i]);
+	kfree(res_chunk_list);
+	return ERR_PTR(err);
+}
+
+static void free_qp_grp_res(struct usnic_vnic_res_chunk **res_chunk_list)
+{
+	int i;
+	for (i = 0; res_chunk_list[i]; i++)
+		usnic_vnic_put_resources(res_chunk_list[i]);
+	kfree(res_chunk_list);
+}
+
+static int qp_grp_and_vf_bind(struct usnic_ib_vf *vf,
+				struct usnic_ib_pd *pd,
+				struct usnic_ib_qp_grp *qp_grp)
+{
+	int err;
+	struct pci_dev *pdev;
+
+	WARN_ON(!spin_is_locked(&vf->lock));
+
+	pdev = usnic_vnic_get_pdev(vf->vnic);
+	if (vf->qp_grp_ref_cnt == 0) {
+		err = usnic_uiom_attach_dev_to_pd(pd->umem_pd, &pdev->dev);
+		if (err) {
+			usnic_err("Failed to attach %s to domain\n",
+					pci_name(pdev));
+			return err;
+		}
+		vf->pd = pd;
+	}
+	vf->qp_grp_ref_cnt++;
+
+	WARN_ON(vf->pd != pd);
+	qp_grp->vf = vf;
+
+	return 0;
+}
+
+static void qp_grp_and_vf_unbind(struct usnic_ib_qp_grp *qp_grp)
+{
+	struct pci_dev *pdev;
+	struct usnic_ib_pd *pd;
+
+	WARN_ON(!spin_is_locked(&qp_grp->vf->lock));
+
+	pd = qp_grp->vf->pd;
+	pdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);
+	if (--qp_grp->vf->qp_grp_ref_cnt == 0) {
+		qp_grp->vf->pd = NULL;
+		usnic_uiom_detach_dev_from_pd(pd->umem_pd, &pdev->dev);
+	}
+	qp_grp->vf = NULL;
+}
+
+static void log_spec(struct usnic_vnic_res_spec *res_spec)
+{
+	char buf[512];
+	usnic_vnic_spec_dump(buf, sizeof(buf), res_spec);
+	usnic_dbg("%s\n", buf);
+}
+
+struct usnic_ib_qp_grp *
+usnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev,
+			struct usnic_ib_vf *vf,
+			struct usnic_ib_pd *pd,
+			struct usnic_vnic_res_spec *res_spec,
+			enum usnic_transport_type transport)
+{
+	struct usnic_ib_qp_grp *qp_grp;
+	u16 port_num;
+	int err;
+
+	WARN_ON(!spin_is_locked(&vf->lock));
+
+	err = usnic_vnic_res_spec_satisfied(&min_transport_spec[transport],
+						res_spec);
+	if (err) {
+		usnic_err("Spec does not meet miniumum req for transport %d\n",
+				transport);
+		log_spec(res_spec);
+		return ERR_PTR(err);
+	}
+
+	port_num = usnic_transport_rsrv_port(transport, 0);
+	if (!port_num) {
+		usnic_err("Unable to allocate port for %s\n",
+				netdev_name(ufdev->netdev));
+		return ERR_PTR(-EINVAL);
+	}
+
+	qp_grp = kzalloc(sizeof(*qp_grp), GFP_ATOMIC);
+	if (!qp_grp) {
+		usnic_err("Unable to alloc qp_grp - Out of memory\n");
+		return NULL;
+	}
+
+	qp_grp->res_chunk_list = alloc_res_chunk_list(vf->vnic, res_spec,
+							qp_grp);
+	if (IS_ERR_OR_NULL(qp_grp->res_chunk_list)) {
+		err = qp_grp->res_chunk_list ?
+				PTR_ERR(qp_grp->res_chunk_list) : -ENOMEM;
+		usnic_err("Unable to alloc res for %d with err %d\n",
+				qp_grp->grp_id, err);
+		goto out_free_port;
+	}
+
+	INIT_LIST_HEAD(&qp_grp->filter_hndls);
+	spin_lock_init(&qp_grp->lock);
+	qp_grp->ufdev = ufdev;
+	qp_grp->transport = transport;
+	qp_grp->filters[DFLT_FILTER_IDX].transport = transport;
+	qp_grp->filters[DFLT_FILTER_IDX].port_num = port_num;
+	qp_grp->state = IB_QPS_RESET;
+	qp_grp->owner_pid = current->pid;
+
+	/* qp_num is same as default filter port_num */
+	qp_grp->ibqp.qp_num = qp_grp->filters[DFLT_FILTER_IDX].port_num;
+	qp_grp->grp_id = qp_grp->ibqp.qp_num;
+
+	err = qp_grp_and_vf_bind(vf, pd, qp_grp);
+	if (err)
+		goto out_free_port;
+
+	usnic_ib_sysfs_qpn_add(qp_grp);
+
+	return qp_grp;
+
+out_free_port:
+	kfree(qp_grp);
+	usnic_transport_unrsrv_port(transport, port_num);
+
+	return ERR_PTR(err);
+}
+
+void usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)
+{
+	u16 default_port_num;
+	enum usnic_transport_type transport;
+
+	WARN_ON(qp_grp->state != IB_QPS_RESET);
+	WARN_ON(!spin_is_locked(&qp_grp->vf->lock));
+
+	transport = qp_grp->filters[DFLT_FILTER_IDX].transport;
+	default_port_num = qp_grp->filters[DFLT_FILTER_IDX].port_num;
+
+	usnic_ib_sysfs_qpn_remove(qp_grp);
+	qp_grp_and_vf_unbind(qp_grp);
+	free_qp_grp_res(qp_grp->res_chunk_list);
+	kfree(qp_grp);
+	usnic_transport_unrsrv_port(transport, default_port_num);
+}
+
+struct usnic_vnic_res_chunk*
+usnic_ib_qp_grp_get_chunk(struct usnic_ib_qp_grp *qp_grp,
+				enum usnic_vnic_res_type res_type)
+{
+	int i;
+
+	for (i = 0; qp_grp->res_chunk_list[i]; i++) {
+		if (qp_grp->res_chunk_list[i]->type == res_type)
+			return qp_grp->res_chunk_list[i];
+	}
+
+	return ERR_PTR(-EINVAL);
+}
