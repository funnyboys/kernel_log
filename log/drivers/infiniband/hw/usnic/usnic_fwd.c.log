commit 7cfcc71eb0e50f191983d714223c169c47437021
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Jul 23 15:37:01 2018 -0700

    RDMA/usnic: Suppress a compiler warning
    
    This patch avoids that the following compiler warning is reported when
    building with gcc 8 and W=1:
    
    drivers/infiniband/hw/usnic/usnic_fwd.c:95:2: warning: 'strncpy' output may be truncated copying 16 bytes from a string of length 20 [-Wstringop-truncation]
      strncpy(ufdev->name, netdev_name(ufdev->netdev),
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        sizeof(ufdev->name) - 1);
        ~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
index 995a26b65156..7875883621f4 100644
--- a/drivers/infiniband/hw/usnic/usnic_fwd.c
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -92,8 +92,8 @@ struct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)
 	ufdev->pdev = pdev;
 	ufdev->netdev = pci_get_drvdata(pdev);
 	spin_lock_init(&ufdev->lock);
-	strncpy(ufdev->name, netdev_name(ufdev->netdev),
-			sizeof(ufdev->name) - 1);
+	BUILD_BUG_ON(sizeof(ufdev->name) != sizeof(ufdev->netdev->name));
+	strcpy(ufdev->name, ufdev->netdev->name);
 
 	return ufdev;
 }

commit 5d50f400e56fbc7a14ef3f8d42ba47710e455881
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Thu Aug 17 15:50:41 2017 +0300

    RDMA/usnic: Fix remove address space warning
    
    Sparse tool complains with the following error:
    drivers/infiniband/hw/usnic/usnic_ib_main.c:445:16: warning: cast removes
            address space of expression
    
    Fix it by doing casting on correct field and convert function helper which
    sets ifaddr to be void, because there are no users who are interested in
    returned value.
    
    Fixes: c7845bcafe4d ("IB/usnic: Add UDP support in u*verbs.c, u*main.c and u*util.h")
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
index 3c37dd59c04e..995a26b65156 100644
--- a/drivers/infiniband/hw/usnic/usnic_fwd.c
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -110,20 +110,12 @@ void usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN])
 	spin_unlock(&ufdev->lock);
 }
 
-int usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)
+void usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)
 {
-	int status;
-
 	spin_lock(&ufdev->lock);
-	if (ufdev->inaddr == 0) {
+	if (!ufdev->inaddr)
 		ufdev->inaddr = inaddr;
-		status = 0;
-	} else {
-		status = -EFAULT;
-	}
 	spin_unlock(&ufdev->lock);
-
-	return status;
 }
 
 void usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev)

commit 3805eade3b7c4a5ad593525703c2c82a84fd9b13
Author: Jeff Squyres <jsquyres@cisco.com>
Date:   Wed Sep 30 13:34:00 2015 -0700

    usnic: add missing clauses to BSD license
    
    The usnic_verbs kernel module was clearly marked with the following in
    its code:
    
      MODULE_LICENSE("Dual BSD/GPL");
    
    However, we accidentally left a few clauses of the BSD text out of the
    license header in all the source files.  This commit fixes that: all
    the files are properly dual BSD/GPL-licensed.  Contributors that might
    have been confused by this have been contacted to get their permission
    and are Cc:ed here.
    
    Cc: Benoit Taine <benoit.taine@lip6.fr>
    Cc: Ira Weiny <ira.weiny@intel.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Matan Barak <matanb@mellanox.com>
    Cc: Michael Wang <yun.wang@profitbricks.com>
    Cc: Roland Dreier <roland@purestorage.com>
    Cc: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Fabio Estevam <fabio.estevam@freescale.com>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Jeff Squyres <jsquyres@cisco.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
index e3c9bd9d3ba3..3c37dd59c04e 100644
--- a/drivers/infiniband/hw/usnic/usnic_fwd.c
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -1,9 +1,24 @@
 /*
  * Copyright (c) 2013, Cisco Systems, Inc. All rights reserved.
  *
- * This program is free software; you may redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

commit 3f92bed3d6c073f41efc0777ecd3442aa1f03d20
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:48:15 2014 -0800

    IB/usnic: Add UDP support to usnic_fwd.[hc]
    
    Add *ip field* to *struct usnic_fwd_dev* as well as new *functions* to
    manipulate the *ip field.*  Furthermore, add new functions for
    programming UDP flows in the forwarding device.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
index 33fdd771e599..e3c9bd9d3ba3 100644
--- a/drivers/infiniband/hw/usnic/usnic_fwd.c
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -95,6 +95,29 @@ void usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN])
 	spin_unlock(&ufdev->lock);
 }
 
+int usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)
+{
+	int status;
+
+	spin_lock(&ufdev->lock);
+	if (ufdev->inaddr == 0) {
+		ufdev->inaddr = inaddr;
+		status = 0;
+	} else {
+		status = -EFAULT;
+	}
+	spin_unlock(&ufdev->lock);
+
+	return status;
+}
+
+void usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev)
+{
+	spin_lock(&ufdev->lock);
+	ufdev->inaddr = 0;
+	spin_unlock(&ufdev->lock);
+}
+
 void usnic_fwd_carrier_up(struct usnic_fwd_dev *ufdev)
 {
 	spin_lock(&ufdev->lock);
@@ -126,6 +149,30 @@ static int usnic_fwd_dev_ready_locked(struct usnic_fwd_dev *ufdev)
 	return 0;
 }
 
+static int validate_filter_locked(struct usnic_fwd_dev *ufdev,
+					struct filter *filter)
+{
+
+	lockdep_assert_held(&ufdev->lock);
+
+	if (filter->type == FILTER_IPV4_5TUPLE) {
+		if (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_AD))
+			return -EACCES;
+		if (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_PT))
+			return -EBUSY;
+		else if (ufdev->inaddr == 0)
+			return -EINVAL;
+		else if (filter->u.ipv4.dst_port == 0)
+			return -ERANGE;
+		else if (ntohl(ufdev->inaddr) != filter->u.ipv4.dst_addr)
+			return -EFAULT;
+		else
+			return 0;
+	}
+
+	return 0;
+}
+
 static void fill_tlv(struct filter_tlv *tlv, struct filter *filter,
 		struct filter_action *action)
 {
@@ -177,6 +224,13 @@ usnic_fwd_alloc_flow(struct usnic_fwd_dev *ufdev, struct filter *filter,
 		goto out_free_tlv;
 	}
 
+	status = validate_filter_locked(ufdev, filter);
+	if (status) {
+		usnic_err("Failed to validate filter with status %d\n",
+				status);
+		goto out_free_tlv;
+	}
+
 	/* Issue Devcmd */
 	a0 = tlv_pa;
 	a1 = tlv_size;

commit 2183b990b67b761f81c68a18f60df028e080cf05
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Thu Jan 9 14:48:07 2014 -0800

    IB/usnic: Push all forwarding state to usnic_fwd.[hc]
    
    Push all of the usnic device forwarding state - such as mtu, mac - to
    usnic_fwd_dev.  Furthermore, usnic_fwd.h exposes a improved interface
    for rest of the usnic code.  The primary improvement is that
    usnic_fwd.h's flow management interface takes in high-level *filter*
    and *action* structures now, instead of low-level paramaters such as
    vnic_idx, rq_idx.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
index 8e42216362e7..33fdd771e599 100644
--- a/drivers/infiniband/hw/usnic/usnic_fwd.c
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -23,6 +23,49 @@
 #include "usnic_fwd.h"
 #include "usnic_log.h"
 
+static int usnic_fwd_devcmd_locked(struct usnic_fwd_dev *ufdev, int vnic_idx,
+					enum vnic_devcmd_cmd cmd, u64 *a0,
+					u64 *a1)
+{
+	int status;
+	struct net_device *netdev = ufdev->netdev;
+
+	lockdep_assert_held(&ufdev->lock);
+
+	status = enic_api_devcmd_proxy_by_index(netdev,
+			vnic_idx,
+			cmd,
+			a0, a1,
+			1000);
+	if (status) {
+		if (status == ERR_EINVAL && cmd == CMD_DEL_FILTER) {
+			usnic_dbg("Dev %s vnic idx %u cmd %u already deleted",
+					ufdev->name, vnic_idx, cmd);
+		} else {
+			usnic_err("Dev %s vnic idx %u cmd %u failed with status %d\n",
+					ufdev->name, vnic_idx, cmd,
+					status);
+		}
+	} else {
+		usnic_dbg("Dev %s vnic idx %u cmd %u success",
+				ufdev->name, vnic_idx, cmd);
+	}
+
+	return status;
+}
+
+static int usnic_fwd_devcmd(struct usnic_fwd_dev *ufdev, int vnic_idx,
+				enum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1)
+{
+	int status;
+
+	spin_lock(&ufdev->lock);
+	status = usnic_fwd_devcmd_locked(ufdev, vnic_idx, cmd, a0, a1);
+	spin_unlock(&ufdev->lock);
+
+	return status;
+}
+
 struct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)
 {
 	struct usnic_fwd_dev *ufdev;
@@ -34,6 +77,8 @@ struct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)
 	ufdev->pdev = pdev;
 	ufdev->netdev = pci_get_drvdata(pdev);
 	spin_lock_init(&ufdev->lock);
+	strncpy(ufdev->name, netdev_name(ufdev->netdev),
+			sizeof(ufdev->name) - 1);
 
 	return ufdev;
 }
@@ -43,200 +88,208 @@ void usnic_fwd_dev_free(struct usnic_fwd_dev *ufdev)
 	kfree(ufdev);
 }
 
-static int usnic_fwd_devcmd(struct usnic_fwd_dev *ufdev, int vnic_idx,
-				enum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1)
+void usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN])
 {
-	int status;
-	struct net_device *netdev = ufdev->netdev;
+	spin_lock(&ufdev->lock);
+	memcpy(&ufdev->mac, mac, sizeof(ufdev->mac));
+	spin_unlock(&ufdev->lock);
+}
 
+void usnic_fwd_carrier_up(struct usnic_fwd_dev *ufdev)
+{
 	spin_lock(&ufdev->lock);
-	status = enic_api_devcmd_proxy_by_index(netdev,
-			vnic_idx,
-			cmd,
-			a0, a1,
-			1000);
+	ufdev->link_up = 1;
 	spin_unlock(&ufdev->lock);
-	if (status) {
-		if (status == ERR_EINVAL && cmd == CMD_DEL_FILTER) {
-			usnic_dbg("Dev %s vnic idx %u cmd %u already deleted",
-					netdev_name(netdev), vnic_idx, cmd);
-		} else {
-			usnic_err("Dev %s vnic idx %u cmd %u failed with status %d\n",
-					netdev_name(netdev), vnic_idx, cmd,
-					status);
-		}
-	} else {
-		usnic_dbg("Dev %s vnic idx %u cmd %u success",
-				netdev_name(netdev), vnic_idx,
-				cmd);
-	}
+}
 
-	return status;
+void usnic_fwd_carrier_down(struct usnic_fwd_dev *ufdev)
+{
+	spin_lock(&ufdev->lock);
+	ufdev->link_up = 0;
+	spin_unlock(&ufdev->lock);
+}
+
+void usnic_fwd_set_mtu(struct usnic_fwd_dev *ufdev, unsigned int mtu)
+{
+	spin_lock(&ufdev->lock);
+	ufdev->mtu = mtu;
+	spin_unlock(&ufdev->lock);
+}
+
+static int usnic_fwd_dev_ready_locked(struct usnic_fwd_dev *ufdev)
+{
+	lockdep_assert_held(&ufdev->lock);
+
+	if (!ufdev->link_up)
+		return -EPERM;
+
+	return 0;
+}
+
+static void fill_tlv(struct filter_tlv *tlv, struct filter *filter,
+		struct filter_action *action)
+{
+	tlv->type = CLSF_TLV_FILTER;
+	tlv->length = sizeof(struct filter);
+	*((struct filter *)&tlv->val) = *filter;
+
+	tlv = (struct filter_tlv *)((char *)tlv + sizeof(struct filter_tlv) +
+			sizeof(struct filter));
+	tlv->type = CLSF_TLV_ACTION;
+	tlv->length = sizeof(struct filter_action);
+	*((struct filter_action *)&tlv->val) = *action;
 }
 
-int usnic_fwd_add_usnic_filter(struct usnic_fwd_dev *ufdev, int vnic_idx,
-				int rq_idx, struct usnic_fwd_filter *fwd_filter,
-				struct usnic_fwd_filter_hndl **filter_hndl)
+struct usnic_fwd_flow*
+usnic_fwd_alloc_flow(struct usnic_fwd_dev *ufdev, struct filter *filter,
+				struct usnic_filter_action *uaction)
 {
-	struct filter_tlv *tlv, *tlv_va;
-	struct filter *filter;
-	struct filter_action *action;
+	struct filter_tlv *tlv;
 	struct pci_dev *pdev;
-	struct usnic_fwd_filter_hndl *usnic_filter_hndl;
-	int status;
-	u64 a0, a1;
-	u64 tlv_size;
+	struct usnic_fwd_flow *flow;
+	uint64_t a0, a1;
+	uint64_t tlv_size;
 	dma_addr_t tlv_pa;
+	int status;
 
 	pdev = ufdev->pdev;
-	tlv_size = (2*sizeof(struct filter_tlv) +
-		sizeof(struct filter) +
-		sizeof(struct filter_action));
+	tlv_size = (2*sizeof(struct filter_tlv) + sizeof(struct filter) +
+			sizeof(struct filter_action));
+
+	flow = kzalloc(sizeof(*flow), GFP_ATOMIC);
+	if (!flow)
+		return ERR_PTR(-ENOMEM);
+
 	tlv = pci_alloc_consistent(pdev, tlv_size, &tlv_pa);
 	if (!tlv) {
 		usnic_err("Failed to allocate memory\n");
-		return -ENOMEM;
+		status = -ENOMEM;
+		goto out_free_flow;
 	}
 
-	usnic_filter_hndl = kzalloc(sizeof(*usnic_filter_hndl), GFP_ATOMIC);
-	if (!usnic_filter_hndl) {
-		usnic_err("Failed to allocate memory for hndl\n");
-		pci_free_consistent(pdev, tlv_size, tlv, tlv_pa);
-		return -ENOMEM;
+	fill_tlv(tlv, filter, &uaction->action);
+
+	spin_lock(&ufdev->lock);
+	status = usnic_fwd_dev_ready_locked(ufdev);
+	if (status) {
+		usnic_err("Forwarding dev %s not ready with status %d\n",
+				ufdev->name, status);
+		goto out_free_tlv;
 	}
 
-	tlv_va = tlv;
+	/* Issue Devcmd */
 	a0 = tlv_pa;
 	a1 = tlv_size;
-	memset(tlv, 0, tlv_size);
-	tlv->type = CLSF_TLV_FILTER;
-	tlv->length = sizeof(struct filter);
-	filter = (struct filter *)&tlv->val;
-	filter->type = FILTER_USNIC_ID;
-	filter->u.usnic.ethtype = USNIC_ROCE_ETHERTYPE;
-	filter->u.usnic.flags = FILTER_FIELD_USNIC_ETHTYPE |
-					FILTER_FIELD_USNIC_ID |
-					FILTER_FIELD_USNIC_PROTO;
-	filter->u.usnic.proto_version = (USNIC_ROCE_GRH_VER <<
-						USNIC_ROCE_GRH_VER_SHIFT)
-							| USNIC_PROTO_VER;
-	filter->u.usnic.usnic_id = fwd_filter->port_num;
-	tlv = (struct filter_tlv *)((char *)tlv + sizeof(struct filter_tlv) +
-			sizeof(struct filter));
-	tlv->type = CLSF_TLV_ACTION;
-	tlv->length = sizeof(struct filter_action);
-	action = (struct filter_action *)&tlv->val;
-	action->type = FILTER_ACTION_RQ_STEERING;
-	action->u.rq_idx = rq_idx;
-
-	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_ADD_FILTER, &a0, &a1);
-	pci_free_consistent(pdev, tlv_size, tlv_va, tlv_pa);
+	status = usnic_fwd_devcmd_locked(ufdev, uaction->vnic_idx,
+						CMD_ADD_FILTER, &a0, &a1);
 	if (status) {
 		usnic_err("VF %s Filter add failed with status:%d",
-				pci_name(pdev),
-				status);
-		kfree(usnic_filter_hndl);
-		return status;
+				ufdev->name, status);
+		status = -EFAULT;
+		goto out_free_tlv;
 	} else {
-		usnic_dbg("VF %s FILTER ID:%u",
-				pci_name(pdev),
-				(u32)a0);
+		usnic_dbg("VF %s FILTER ID:%llu", ufdev->name, a0);
 	}
 
-	usnic_filter_hndl->type = FILTER_USNIC_ID;
-	usnic_filter_hndl->id = (u32)a0;
-	usnic_filter_hndl->vnic_idx = vnic_idx;
-	usnic_filter_hndl->ufdev = ufdev;
-	usnic_filter_hndl->filter = fwd_filter;
-	*filter_hndl = usnic_filter_hndl;
+	flow->flow_id = (uint32_t) a0;
+	flow->vnic_idx = uaction->vnic_idx;
+	flow->ufdev = ufdev;
 
-	return status;
+out_free_tlv:
+	spin_unlock(&ufdev->lock);
+	pci_free_consistent(pdev, tlv_size, tlv, tlv_pa);
+	if (!status)
+		return flow;
+out_free_flow:
+	kfree(flow);
+	return ERR_PTR(status);
 }
 
-int usnic_fwd_del_filter(struct usnic_fwd_filter_hndl *filter_hndl)
+int usnic_fwd_dealloc_flow(struct usnic_fwd_flow *flow)
 {
 	int status;
 	u64 a0, a1;
-	struct net_device *netdev;
 
-	netdev = filter_hndl->ufdev->netdev;
-	a0 = filter_hndl->id;
+	a0 = flow->flow_id;
 
-	status = usnic_fwd_devcmd(filter_hndl->ufdev, filter_hndl->vnic_idx,
+	status = usnic_fwd_devcmd(flow->ufdev, flow->vnic_idx,
 					CMD_DEL_FILTER, &a0, &a1);
 	if (status) {
 		if (status == ERR_EINVAL) {
 			usnic_dbg("Filter %u already deleted for VF Idx %u pf: %s status: %d",
-					filter_hndl->id, filter_hndl->vnic_idx,
-					netdev_name(netdev), status);
-			status = 0;
-			kfree(filter_hndl);
+					flow->flow_id, flow->vnic_idx,
+					flow->ufdev->name, status);
 		} else {
 			usnic_err("PF %s VF Idx %u Filter: %u FILTER DELETE failed with status %d",
-					netdev_name(netdev),
-					filter_hndl->vnic_idx, filter_hndl->id,
-					status);
+					flow->ufdev->name, flow->vnic_idx,
+					flow->flow_id, status);
 		}
+		status = 0;
+		/*
+		 * Log the error and fake success to the caller because if
+		 * a flow fails to be deleted in the firmware, it is an
+		 * unrecoverable error.
+		 */
 	} else {
 		usnic_dbg("PF %s VF Idx %u Filter: %u FILTER DELETED",
-				netdev_name(netdev), filter_hndl->vnic_idx,
-				filter_hndl->id);
-		kfree(filter_hndl);
+				flow->ufdev->name, flow->vnic_idx,
+				flow->flow_id);
 	}
 
+	kfree(flow);
 	return status;
 }
 
-int usnic_fwd_enable_rq(struct usnic_fwd_dev *ufdev, int vnic_idx, int rq_idx)
+int usnic_fwd_enable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)
 {
 	int status;
 	struct net_device *pf_netdev;
 	u64 a0, a1;
 
 	pf_netdev = ufdev->netdev;
-	a0 = rq_idx;
+	a0 = qp_idx;
 	a1 = CMD_QP_RQWQ;
 
-	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_ENABLE, &a0, &a1);
-
+	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_ENABLE,
+						&a0, &a1);
 	if (status) {
 		usnic_err("PF %s VNIC Index %u RQ Index: %u ENABLE Failed with status %d",
 				netdev_name(pf_netdev),
 				vnic_idx,
-				rq_idx,
+				qp_idx,
 				status);
 	} else {
 		usnic_dbg("PF %s VNIC Index %u RQ Index: %u ENABLED",
 				netdev_name(pf_netdev),
-				vnic_idx, rq_idx);
+				vnic_idx, qp_idx);
 	}
 
 	return status;
 }
 
-int usnic_fwd_disable_rq(struct usnic_fwd_dev *ufdev, int vnic_idx, int rq_idx)
+int usnic_fwd_disable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)
 {
 	int status;
 	u64 a0, a1;
 	struct net_device *pf_netdev;
 
 	pf_netdev = ufdev->netdev;
-	a0 = rq_idx;
+	a0 = qp_idx;
 	a1 = CMD_QP_RQWQ;
 
-	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_DISABLE, &a0, &a1);
-
+	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_DISABLE,
+			&a0, &a1);
 	if (status) {
 		usnic_err("PF %s VNIC Index %u RQ Index: %u DISABLE Failed with status %d",
 				netdev_name(pf_netdev),
 				vnic_idx,
-				rq_idx,
+				qp_idx,
 				status);
 	} else {
 		usnic_dbg("PF %s VNIC Index %u RQ Index: %u DISABLED",
 				netdev_name(pf_netdev),
 				vnic_idx,
-				rq_idx);
+				qp_idx);
 	}
 
 	return status;

commit e3cf00d0a87f025db5855a43a67c67a41fa79fef
Author: Upinder Malhi <umalhi@cisco.com>
Date:   Tue Sep 10 03:38:16 2013 +0000

    IB/usnic: Add Cisco VIC low-level hardware driver
    
    This adds a driver that allows userspace to use UD-like QPs over a
    proprietary Cisco transport with Cisco's Virtual Interface Cards (VICs),
    including VIC 1240 and 1280 cards.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Christian Benvenuti <benve@cisco.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c
new file mode 100644
index 000000000000..8e42216362e7
--- /dev/null
+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2013, Cisco Systems, Inc. All rights reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+
+#include "enic_api.h"
+#include "usnic_common_pkt_hdr.h"
+#include "usnic_fwd.h"
+#include "usnic_log.h"
+
+struct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)
+{
+	struct usnic_fwd_dev *ufdev;
+
+	ufdev = kzalloc(sizeof(*ufdev), GFP_KERNEL);
+	if (!ufdev)
+		return NULL;
+
+	ufdev->pdev = pdev;
+	ufdev->netdev = pci_get_drvdata(pdev);
+	spin_lock_init(&ufdev->lock);
+
+	return ufdev;
+}
+
+void usnic_fwd_dev_free(struct usnic_fwd_dev *ufdev)
+{
+	kfree(ufdev);
+}
+
+static int usnic_fwd_devcmd(struct usnic_fwd_dev *ufdev, int vnic_idx,
+				enum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1)
+{
+	int status;
+	struct net_device *netdev = ufdev->netdev;
+
+	spin_lock(&ufdev->lock);
+	status = enic_api_devcmd_proxy_by_index(netdev,
+			vnic_idx,
+			cmd,
+			a0, a1,
+			1000);
+	spin_unlock(&ufdev->lock);
+	if (status) {
+		if (status == ERR_EINVAL && cmd == CMD_DEL_FILTER) {
+			usnic_dbg("Dev %s vnic idx %u cmd %u already deleted",
+					netdev_name(netdev), vnic_idx, cmd);
+		} else {
+			usnic_err("Dev %s vnic idx %u cmd %u failed with status %d\n",
+					netdev_name(netdev), vnic_idx, cmd,
+					status);
+		}
+	} else {
+		usnic_dbg("Dev %s vnic idx %u cmd %u success",
+				netdev_name(netdev), vnic_idx,
+				cmd);
+	}
+
+	return status;
+}
+
+int usnic_fwd_add_usnic_filter(struct usnic_fwd_dev *ufdev, int vnic_idx,
+				int rq_idx, struct usnic_fwd_filter *fwd_filter,
+				struct usnic_fwd_filter_hndl **filter_hndl)
+{
+	struct filter_tlv *tlv, *tlv_va;
+	struct filter *filter;
+	struct filter_action *action;
+	struct pci_dev *pdev;
+	struct usnic_fwd_filter_hndl *usnic_filter_hndl;
+	int status;
+	u64 a0, a1;
+	u64 tlv_size;
+	dma_addr_t tlv_pa;
+
+	pdev = ufdev->pdev;
+	tlv_size = (2*sizeof(struct filter_tlv) +
+		sizeof(struct filter) +
+		sizeof(struct filter_action));
+	tlv = pci_alloc_consistent(pdev, tlv_size, &tlv_pa);
+	if (!tlv) {
+		usnic_err("Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	usnic_filter_hndl = kzalloc(sizeof(*usnic_filter_hndl), GFP_ATOMIC);
+	if (!usnic_filter_hndl) {
+		usnic_err("Failed to allocate memory for hndl\n");
+		pci_free_consistent(pdev, tlv_size, tlv, tlv_pa);
+		return -ENOMEM;
+	}
+
+	tlv_va = tlv;
+	a0 = tlv_pa;
+	a1 = tlv_size;
+	memset(tlv, 0, tlv_size);
+	tlv->type = CLSF_TLV_FILTER;
+	tlv->length = sizeof(struct filter);
+	filter = (struct filter *)&tlv->val;
+	filter->type = FILTER_USNIC_ID;
+	filter->u.usnic.ethtype = USNIC_ROCE_ETHERTYPE;
+	filter->u.usnic.flags = FILTER_FIELD_USNIC_ETHTYPE |
+					FILTER_FIELD_USNIC_ID |
+					FILTER_FIELD_USNIC_PROTO;
+	filter->u.usnic.proto_version = (USNIC_ROCE_GRH_VER <<
+						USNIC_ROCE_GRH_VER_SHIFT)
+							| USNIC_PROTO_VER;
+	filter->u.usnic.usnic_id = fwd_filter->port_num;
+	tlv = (struct filter_tlv *)((char *)tlv + sizeof(struct filter_tlv) +
+			sizeof(struct filter));
+	tlv->type = CLSF_TLV_ACTION;
+	tlv->length = sizeof(struct filter_action);
+	action = (struct filter_action *)&tlv->val;
+	action->type = FILTER_ACTION_RQ_STEERING;
+	action->u.rq_idx = rq_idx;
+
+	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_ADD_FILTER, &a0, &a1);
+	pci_free_consistent(pdev, tlv_size, tlv_va, tlv_pa);
+	if (status) {
+		usnic_err("VF %s Filter add failed with status:%d",
+				pci_name(pdev),
+				status);
+		kfree(usnic_filter_hndl);
+		return status;
+	} else {
+		usnic_dbg("VF %s FILTER ID:%u",
+				pci_name(pdev),
+				(u32)a0);
+	}
+
+	usnic_filter_hndl->type = FILTER_USNIC_ID;
+	usnic_filter_hndl->id = (u32)a0;
+	usnic_filter_hndl->vnic_idx = vnic_idx;
+	usnic_filter_hndl->ufdev = ufdev;
+	usnic_filter_hndl->filter = fwd_filter;
+	*filter_hndl = usnic_filter_hndl;
+
+	return status;
+}
+
+int usnic_fwd_del_filter(struct usnic_fwd_filter_hndl *filter_hndl)
+{
+	int status;
+	u64 a0, a1;
+	struct net_device *netdev;
+
+	netdev = filter_hndl->ufdev->netdev;
+	a0 = filter_hndl->id;
+
+	status = usnic_fwd_devcmd(filter_hndl->ufdev, filter_hndl->vnic_idx,
+					CMD_DEL_FILTER, &a0, &a1);
+	if (status) {
+		if (status == ERR_EINVAL) {
+			usnic_dbg("Filter %u already deleted for VF Idx %u pf: %s status: %d",
+					filter_hndl->id, filter_hndl->vnic_idx,
+					netdev_name(netdev), status);
+			status = 0;
+			kfree(filter_hndl);
+		} else {
+			usnic_err("PF %s VF Idx %u Filter: %u FILTER DELETE failed with status %d",
+					netdev_name(netdev),
+					filter_hndl->vnic_idx, filter_hndl->id,
+					status);
+		}
+	} else {
+		usnic_dbg("PF %s VF Idx %u Filter: %u FILTER DELETED",
+				netdev_name(netdev), filter_hndl->vnic_idx,
+				filter_hndl->id);
+		kfree(filter_hndl);
+	}
+
+	return status;
+}
+
+int usnic_fwd_enable_rq(struct usnic_fwd_dev *ufdev, int vnic_idx, int rq_idx)
+{
+	int status;
+	struct net_device *pf_netdev;
+	u64 a0, a1;
+
+	pf_netdev = ufdev->netdev;
+	a0 = rq_idx;
+	a1 = CMD_QP_RQWQ;
+
+	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_ENABLE, &a0, &a1);
+
+	if (status) {
+		usnic_err("PF %s VNIC Index %u RQ Index: %u ENABLE Failed with status %d",
+				netdev_name(pf_netdev),
+				vnic_idx,
+				rq_idx,
+				status);
+	} else {
+		usnic_dbg("PF %s VNIC Index %u RQ Index: %u ENABLED",
+				netdev_name(pf_netdev),
+				vnic_idx, rq_idx);
+	}
+
+	return status;
+}
+
+int usnic_fwd_disable_rq(struct usnic_fwd_dev *ufdev, int vnic_idx, int rq_idx)
+{
+	int status;
+	u64 a0, a1;
+	struct net_device *pf_netdev;
+
+	pf_netdev = ufdev->netdev;
+	a0 = rq_idx;
+	a1 = CMD_QP_RQWQ;
+
+	status = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_DISABLE, &a0, &a1);
+
+	if (status) {
+		usnic_err("PF %s VNIC Index %u RQ Index: %u DISABLE Failed with status %d",
+				netdev_name(pf_netdev),
+				vnic_idx,
+				rq_idx,
+				status);
+	} else {
+		usnic_dbg("PF %s VNIC Index %u RQ Index: %u DISABLED",
+				netdev_name(pf_netdev),
+				vnic_idx,
+				rq_idx);
+	}
+
+	return status;
+}
