commit 6d1e7ba241e990b5c6ba7fdaa03d466f852f3c9e
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Tue May 19 10:27:11 2020 +0300

    IB/uverbs: Introduce create/destroy QP commands over ioctl
    
    Introduce create/destroy QP commands over the ioctl interface to let it
    be extended to get an asynchronous event FD.
    
    Link: https://lore.kernel.org/r/20200519072711.257271-8-leon@kernel.org
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 0ec8cf86ecfa..5addc8fae3f3 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -634,6 +634,7 @@ static const struct uapi_definition uverbs_core_api[] = {
 	UAPI_DEF_CHAIN(uverbs_def_obj_flow_action),
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
 	UAPI_DEF_CHAIN(uverbs_def_obj_mr),
+	UAPI_DEF_CHAIN(uverbs_def_obj_qp),
 	UAPI_DEF_CHAIN(uverbs_def_obj_srq),
 	UAPI_DEF_CHAIN(uverbs_def_obj_wq),
 	UAPI_DEF_CHAIN(uverbs_def_write_intf),

commit ef3bc084a8ed461e3d1f82481f47dacb96596f8f
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Tue May 19 10:27:10 2020 +0300

    IB/uverbs: Introduce create/destroy WQ commands over ioctl
    
    Introduce create/destroy WQ commands over the ioctl interface to let it
    be extended to get an asynchronous event FD.
    
    Link: https://lore.kernel.org/r/20200519072711.257271-7-leon@kernel.org
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 3f5627954fe7..0ec8cf86ecfa 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -635,6 +635,7 @@ static const struct uapi_definition uverbs_core_api[] = {
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
 	UAPI_DEF_CHAIN(uverbs_def_obj_mr),
 	UAPI_DEF_CHAIN(uverbs_def_obj_srq),
+	UAPI_DEF_CHAIN(uverbs_def_obj_wq),
 	UAPI_DEF_CHAIN(uverbs_def_write_intf),
 	{},
 };

commit c3eab946aba443f0b44a08f446735c74495610a9
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Tue May 19 10:27:09 2020 +0300

    IB/uverbs: Introduce create/destroy SRQ commands over ioctl
    
    Introduce create/destroy SRQ commands over the ioctl interface to let it
    be extended to get an asynchronous event FD.
    
    Link: https://lore.kernel.org/r/20200519072711.257271-6-leon@kernel.org
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 3f121ac31e0a..3f5627954fe7 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -634,6 +634,7 @@ static const struct uapi_definition uverbs_core_api[] = {
 	UAPI_DEF_CHAIN(uverbs_def_obj_flow_action),
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
 	UAPI_DEF_CHAIN(uverbs_def_obj_mr),
+	UAPI_DEF_CHAIN(uverbs_def_obj_srq),
 	UAPI_DEF_CHAIN(uverbs_def_write_intf),
 	{},
 };

commit 3e032c0e92aa0c4c0b46c5e2d6d41706c8fce488
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:22:05 2020 +0200

    RDMA/core: Make ib_uverbs_async_event_file into a uobject
    
    This makes async events aligned with completion events as both are full
    uobjects of FD type and use the same uobject lifecycle.
    
    A bunch of duplicate code is consolidated and the general flow between the
    two FDs is now very similar.
    
    Link: https://lore.kernel.org/r/1578504126-9400-14-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 9b84a126187a..3f121ac31e0a 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -626,6 +626,7 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 }
 
 static const struct uapi_definition uverbs_core_api[] = {
+	UAPI_DEF_CHAIN(uverbs_def_obj_async_fd),
 	UAPI_DEF_CHAIN(uverbs_def_obj_counters),
 	UAPI_DEF_CHAIN(uverbs_def_obj_cq),
 	UAPI_DEF_CHAIN(uverbs_def_obj_device),

commit f7c8416ccea52b41e29227b3a5066540f51ee471
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:21:54 2020 +0200

    RDMA/core: Simplify destruction of FD uobjects
    
    FD uobjects have a weird split between the struct file and uobject
    world. Simplify this to make them pure uobjects and use a generic release
    method for all struct file operations.
    
    This fixes the control flow so that mlx5_cmd_cleanup_async_ctx() is always
    called before erasing the linked list contents to make the concurrancy
    simpler to understand.
    
    For this to work the uobject destruction must fence anything that it is
    cleaning up - the design must not rely on struct file lifetime.
    
    Only deliver_event() relies on the struct file to when adding new events
    to the queue, add a is_destroyed check under lock to block it.
    
    Link: https://lore.kernel.org/r/1578504126-9400-3-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 00c547887132..9b84a126187a 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -195,9 +195,9 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 		 * disassociation, and the FD types require the driver to use
 		 * struct file_operations.owner to prevent the driver module
 		 * code from unloading while the file is open. This provides
-		 * enough safety that uverbs_close_fd() will continue to work.
-		 * Drivers using FD are responsible to handle disassociation of
-		 * the device on their own.
+		 * enough safety that uverbs_uobject_fd_release() will
+		 * continue to work.  Drivers using FD are responsible to
+		 * handle disassociation of the device on their own.
 		 */
 		if (WARN_ON(is_driver &&
 			    obj->type_attrs->type_class != &uverbs_idr_class &&

commit b9560a419bfd498279333387817adcf5faef2825
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jun 5 14:39:24 2019 -0300

    RDMA: Move driver_id into struct ib_device_ops
    
    No reason for every driver to emit code to set this, just make it part of
    the driver's existing static const ops structure.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index ccc4be0a6566..00c547887132 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -647,7 +647,7 @@ struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev)
 		return ERR_PTR(-ENOMEM);
 
 	INIT_RADIX_TREE(&uapi->radix, GFP_KERNEL);
-	uapi->driver_id = ibdev->driver_id;
+	uapi->driver_id = ibdev->ops.driver_id;
 
 	rc = uapi_merge_def(uapi, ibdev, uverbs_core_api, false);
 	if (rc)

commit cac2a301c02a9b178842e22df34217da7854e588
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu May 30 11:20:24 2019 +0300

    RDMA/uverbs: check for allocation failure in uapi_add_elm()
    
    If the kzalloc() fails then we should return ERR_PTR(-ENOMEM).  In the
    current code it's possible that the kzalloc() fails and the
    radix_tree_insert() inserts the NULL pointer successfully and we return
    the NULL "elm" pointer to the caller.  That results in a NULL pointer
    dereference.
    
    Fixes: 9ed3e5f44772 ("IB/uverbs: Build the specs into a radix tree at runtime")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 7a987acf0c0b..ccc4be0a6566 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -22,6 +22,8 @@ static void *uapi_add_elm(struct uverbs_api *uapi, u32 key, size_t alloc_size)
 		return ERR_PTR(-EOVERFLOW);
 
 	elm = kzalloc(alloc_size, GFP_KERNEL);
+	if (!elm)
+		return ERR_PTR(-ENOMEM);
 	rc = radix_tree_insert(&uapi->radix, key, elm);
 	if (rc) {
 		kfree(elm);

commit 6bf8f22aea0ddd93af822aed8afeeee4acdf7694
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Tue Jan 22 08:29:56 2019 +0200

    IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_CMD_FD
    
    Introduce MLX5_IB_OBJECT_DEVX_ASYNC_CMD_FD and its initial implementation.
    
    This object is from type class FD and will be used to read DEVX async
    commands completion.
    
    The core layer should allow the driver to set object from type FD in a
    safe mode, this option was added with a matching comment in place.
    
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 9ae08e4b78a3..7a987acf0c0b 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -188,13 +188,18 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 		obj_elm->type_attrs = obj->type_attrs;
 		obj_elm->type_class = obj->type_attrs->type_class;
 		/*
-		 * Today drivers are only permitted to use idr_class
-		 * types. They cannot use FD types because we currently have
-		 * no way to revoke the fops pointer after device
-		 * disassociation.
+		 * Today drivers are only permitted to use idr_class and
+		 * fd_class types. We can revoke the IDR types during
+		 * disassociation, and the FD types require the driver to use
+		 * struct file_operations.owner to prevent the driver module
+		 * code from unloading while the file is open. This provides
+		 * enough safety that uverbs_close_fd() will continue to work.
+		 * Drivers using FD are responsible to handle disassociation of
+		 * the device on their own.
 		 */
 		if (WARN_ON(is_driver &&
-			    obj->type_attrs->type_class != &uverbs_idr_class))
+			    obj->type_attrs->type_class != &uverbs_idr_class &&
+			    obj->type_attrs->type_class != &uverbs_fd_class))
 			return -EINVAL;
 	}
 

commit 4785860e04bc8d7e244b25257168e1cf8a5529ab
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Fri Nov 30 13:06:21 2018 +0200

    RDMA/uverbs: Implement an ioctl that can call write and write_ex handlers
    
    Now that the handlers do not process their own udata we can make a
    sensible ioctl that wrappers them. The ioctl follows the same format as
    the write_ex() and has the user explicitly specify the core and driver
    in/out opaque structures and a command number.
    
    This works for all forms of write commands.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 830e48fe5e65..9ae08e4b78a3 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -621,6 +621,7 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 static const struct uapi_definition uverbs_core_api[] = {
 	UAPI_DEF_CHAIN(uverbs_def_obj_counters),
 	UAPI_DEF_CHAIN(uverbs_def_obj_cq),
+	UAPI_DEF_CHAIN(uverbs_def_obj_device),
 	UAPI_DEF_CHAIN(uverbs_def_obj_dm),
 	UAPI_DEF_CHAIN(uverbs_def_obj_flow_action),
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),

commit 3023a1e93656c02b8d6a3a46e712b815843fa514
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Mon Dec 10 21:09:48 2018 +0200

    RDMA: Start use ib_device_ops
    
    Make all the required change to start use the ib_device_ops structure.
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 0136c1d78a0f..830e48fe5e65 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -300,7 +300,8 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 			return 0;
 
 		case UAPI_DEF_IS_SUPPORTED_DEV_FN: {
-			void **ibdev_fn = (void *)ibdev + def->needs_fn_offset;
+			void **ibdev_fn =
+				(void *)(&ibdev->ops) + def->needs_fn_offset;
 
 			if (*ibdev_fn)
 				continue;

commit 04ca16cc198c2bd2fc51749123c118a284d1605e
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Mon Nov 26 08:28:34 2018 +0200

    IB/core: Enable getting an object type from a given uobject
    
    Enable getting an object type from a given uobject, the type is saved
    upon tree merging and is returned as part of some helper function.
    
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index faac225184a6..0136c1d78a0f 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -184,6 +184,7 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 		if (WARN_ON(obj_elm->type_attrs))
 			return -EINVAL;
 
+		obj_elm->id = obj->id;
 		obj_elm->type_attrs = obj->type_attrs;
 		obj_elm->type_class = obj->type_attrs->type_class;
 		/*

commit 4d7e8cc57429e1874658acbff98d3877c81cd0a4
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Mon Nov 26 08:28:33 2018 +0200

    IB/core: Introduce UVERBS_IDR_ANY_OBJECT
    
    Introduce the UVERBS_IDR_ANY_OBJECT type to match any IDR object.
    
    Once used, the infrastructure skips checking for the IDR type, it
    becomes the driver handler responsibility.
    
    This enables drivers to get in a given method an object from various of
    types.
    
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 19ae4b19b2ef..faac225184a6 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -580,8 +580,13 @@ static void uapi_finalize_disable(struct uverbs_api *uapi)
 			if (obj_key == UVERBS_API_KEY_ERR)
 				continue;
 			tmp_obj = uapi_get_object(uapi, obj_key);
-			if (tmp_obj && !tmp_obj->disabled)
-				continue;
+			if (IS_ERR(tmp_obj)) {
+				if (PTR_ERR(tmp_obj) == -ENOMSG)
+					continue;
+			} else {
+				if (!tmp_obj->disabled)
+					continue;
+			}
 
 			starting_key = iter.index;
 			uapi_remove_method(

commit 974d6b4b2bc33c53334e086a40715b384f48f2e2
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:58:45 2018 +0200

    RDMA/uverbs: Use only attrs for the write() handler signature
    
    All of the old arguments can be derived from the uverbs_attr_bundle
    structure, so get rid of the redundant arguments. Most of the prior work
    has been removing users of the arguments to allow this to be a simple
    patch.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index b3d5f36b0462..19ae4b19b2ef 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -8,14 +8,7 @@
 #include "rdma_core.h"
 #include "uverbs.h"
 
-static int ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs,
-			     const char __user *buf, int in_len, int out_len)
-{
-	return -EOPNOTSUPP;
-}
-
-static int ib_uverbs_ex_notsupp(struct uverbs_attr_bundle *attrs,
-				struct ib_udata *ucore)
+static int ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs)
 {
 	return -EOPNOTSUPP;
 }
@@ -79,22 +72,17 @@ static int uapi_create_write(struct uverbs_api *uapi,
 	if (IS_ERR(method_elm))
 		return PTR_ERR(method_elm);
 
-	if (WARN_ON(exists && (def->write.is_ex != method_elm->is_ex ||
-			       method_elm->handler_ex || method_elm->handler)))
+	if (WARN_ON(exists && (def->write.is_ex != method_elm->is_ex)))
 		return -EINVAL;
 
 	method_elm->is_ex = def->write.is_ex;
-	if (def->write.is_ex) {
-		method_elm->handler_ex = def->func_write_ex;
-
+	method_elm->handler = def->func_write;
+	if (def->write.is_ex)
 		method_elm->disabled = !(ibdev->uverbs_ex_cmd_mask &
 					 BIT_ULL(def->write.command_num));
-	} else {
-		method_elm->handler = def->func_write;
-
+	else
 		method_elm->disabled = !(ibdev->uverbs_cmd_mask &
 					 BIT_ULL(def->write.command_num));
-	}
 
 	if (!def->write.is_ex && def->func_write) {
 		method_elm->has_udata = def->write.has_udata;
@@ -449,7 +437,6 @@ static int uapi_finalize(struct uverbs_api *uapi)
 	}
 
 	uapi->notsupp_method.handler = ib_uverbs_notsupp;
-	uapi->notsupp_method.handler_ex = ib_uverbs_ex_notsupp;
 	uapi->num_write = max_write + 1;
 	uapi->num_write_ex = max_write_ex + 1;
 	data = kmalloc_array(uapi->num_write + uapi->num_write_ex,

commit 07f05f40d956d40f32852a7b3ff109a72d254cf9
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:51:20 2018 +0200

    RDMA/uverbs: Use uverbs_attr_bundle to pass udata for ioctl()
    
    Have the core code initialize the driver_udata if the method has a udata
    description. This is done using the same create_udata the handler was
    supposed to call.
    
    This makes ioctl consistent with the write and write_ex paths.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index e16137cc5b28..b3d5f36b0462 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -381,6 +381,9 @@ uapi_finalize_ioctl_method(struct uverbs_api *uapi,
 		if (elm->spec.mandatory)
 			__set_bit(attr_bkey, method_elm->attr_mandatory);
 
+		if (elm->spec.is_udata)
+			method_elm->has_udata = true;
+
 		if (type == UVERBS_ATTR_TYPE_IDR ||
 		    type == UVERBS_ATTR_TYPE_FD) {
 			u8 access = elm->spec.u.obj.access;

commit ef87df2c7a8f04d31cbf06f0b14b8dd5feafe473
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:51:18 2018 +0200

    RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write_ex
    
    The core code needs to compute the udata so we may as well pass it in the
    uverbs_attr_bundle instead of on the stack. This converts the simple case
    of write_ex() which already has a core calculation.
    
    Also change the write() path to use the attrs for ib_uverbs_init_udata()
    instead of on the stack. This lets the write to write_ex compatibility
    path continue to follow the lead of the _ex path.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 4870c9c16084..e16137cc5b28 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -15,7 +15,7 @@ static int ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs,
 }
 
 static int ib_uverbs_ex_notsupp(struct uverbs_attr_bundle *attrs,
-				struct ib_udata *ucore, struct ib_udata *uhw)
+				struct ib_udata *ucore)
 {
 	return -EOPNOTSUPP;
 }

commit 669dac1e00c50a65cb8ecf08862c3c9dd7a29a98
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:51:16 2018 +0200

    RDMA/uverbs: Add structure size info to write commands
    
    We need the structure sizes to compute the location of the udata in the
    core code. Annotate the sizes into the new macro language.
    
    This is generated largely by script and checked by comparing against the
    similar list in rdma-core.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 4738c266ff50..4870c9c16084 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -96,6 +96,13 @@ static int uapi_create_write(struct uverbs_api *uapi,
 					 BIT_ULL(def->write.command_num));
 	}
 
+	if (!def->write.is_ex && def->func_write) {
+		method_elm->has_udata = def->write.has_udata;
+		method_elm->has_resp = def->write.has_resp;
+		method_elm->req_size = def->write.req_size;
+		method_elm->resp_size = def->write.resp_size;
+	}
+
 	*cur_method_key = method_key;
 	return 0;
 }

commit 7106a9769715bb4c0448927a29aa3b505855871c
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:51:14 2018 +0200

    RDMA/uverbs: Make write() handlers return 0 on success
    
    Currently they return the command length, while all other handlers return
    0. This makes the write path closer to the write_ex and ioctl path.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index ad72d726efa9..4738c266ff50 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -8,9 +8,8 @@
 #include "rdma_core.h"
 #include "uverbs.h"
 
-static ssize_t ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs,
-				 const char __user *buf, int in_len,
-				 int out_len)
+static int ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs,
+			     const char __user *buf, int in_len, int out_len)
 {
 	return -EOPNOTSUPP;
 }

commit 8313c10fa8be032fccc1e757bccc21207f533127
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Sun Nov 25 20:51:13 2018 +0200

    RDMA/uverbs: Replace ib_uverbs_file with uverbs_attr_bundle for write
    
    Now that we can add meta-data to the description of write() methods we
    need to pass the uverbs_attr_bundle into all write based handlers so
    future patches can use it as a container for any new data transferred out
    of the core.
    
    This is the first step to bringing the write() and ioctl() methods to a
    common interface signature.
    
    This is a simple search/replace, and we push the attr down into the uobj
    and other APIs to keep changes minimal.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index a92adbe2b034..ad72d726efa9 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -8,14 +8,14 @@
 #include "rdma_core.h"
 #include "uverbs.h"
 
-static ssize_t ib_uverbs_notsupp(struct ib_uverbs_file *file,
+static ssize_t ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs,
 				 const char __user *buf, int in_len,
 				 int out_len)
 {
 	return -EOPNOTSUPP;
 }
 
-static int ib_uverbs_ex_notsupp(struct ib_uverbs_file *file,
+static int ib_uverbs_ex_notsupp(struct uverbs_attr_bundle *attrs,
 				struct ib_udata *ucore, struct ib_udata *uhw)
 {
 	return -EOPNOTSUPP;

commit a140692a52d2e12ba6a76dd042d556348e8bb55a
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:58 2018 +0200

    RDMA/uverbs: Check for NULL driver methods for every write call
    
    Add annotations to the uverbs_api structure indicating which driver
    methods are called by the implementation. If the required method
    is NULL the write API will be not be callable.
    
    This effectively duplicates the cmd_mask system, however it does it by
    expressing invariants required by the core code, not by delegating
    decision making to the driver. This is another step toward eliminating
    cmd_mask.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 1e880f1d9d62..a92adbe2b034 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -60,8 +60,11 @@ static void *uapi_add_get_elm(struct uverbs_api *uapi, u32 key,
 	return elm;
 }
 
-static int uapi_create_write(struct uverbs_api *uapi, struct ib_device *ibdev,
-			     const struct uapi_definition *def, u32 obj_key)
+static int uapi_create_write(struct uverbs_api *uapi,
+			     struct ib_device *ibdev,
+			     const struct uapi_definition *def,
+			     u32 obj_key,
+			     u32 *cur_method_key)
 {
 	struct uverbs_api_write_method *method_elm;
 	u32 method_key = obj_key;
@@ -93,6 +96,8 @@ static int uapi_create_write(struct uverbs_api *uapi, struct ib_device *ibdev,
 		method_elm->disabled = !(ibdev->uverbs_cmd_mask &
 					 BIT_ULL(def->write.command_num));
 	}
+
+	*cur_method_key = method_key;
 	return 0;
 }
 
@@ -218,7 +223,8 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 
 static int uapi_disable_elm(struct uverbs_api *uapi,
 			    const struct uapi_definition *def,
-			    u32 obj_key)
+			    u32 obj_key,
+			    u32 method_key)
 {
 	bool exists;
 
@@ -233,6 +239,31 @@ static int uapi_disable_elm(struct uverbs_api *uapi,
 		return 0;
 	}
 
+	if (def->scope == UAPI_SCOPE_METHOD &&
+	    uapi_key_is_ioctl_method(method_key)) {
+		struct uverbs_api_ioctl_method *method_elm;
+
+		method_elm = uapi_add_get_elm(uapi, method_key,
+					      sizeof(*method_elm), &exists);
+		if (IS_ERR(method_elm))
+			return PTR_ERR(method_elm);
+		method_elm->disabled = 1;
+		return 0;
+	}
+
+	if (def->scope == UAPI_SCOPE_METHOD &&
+	    (uapi_key_is_write_method(method_key) ||
+	     uapi_key_is_write_ex_method(method_key))) {
+		struct uverbs_api_write_method *write_elm;
+
+		write_elm = uapi_add_get_elm(uapi, method_key,
+					     sizeof(*write_elm), &exists);
+		if (IS_ERR(write_elm))
+			return PTR_ERR(write_elm);
+		write_elm->disabled = 1;
+		return 0;
+	}
+
 	WARN_ON(true);
 	return -EINVAL;
 }
@@ -243,6 +274,7 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 {
 	const struct uapi_definition *def = def_list;
 	u32 cur_obj_key = UVERBS_API_KEY_ERR;
+	u32 cur_method_key = UVERBS_API_KEY_ERR;
 	bool exists;
 	int rc;
 
@@ -277,7 +309,8 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 
 			if (*ibdev_fn)
 				continue;
-			rc = uapi_disable_elm(uapi, def, cur_obj_key);
+			rc = uapi_disable_elm(
+				uapi, def, cur_obj_key, cur_method_key);
 			if (rc)
 				return rc;
 			continue;
@@ -286,7 +319,8 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 		case UAPI_DEF_IS_SUPPORTED_FUNC:
 			if (def->func_is_supported(ibdev))
 				continue;
-			rc = uapi_disable_elm(uapi, def, cur_obj_key);
+			rc = uapi_disable_elm(
+				uapi, def, cur_obj_key, cur_method_key);
 			if (rc)
 				return rc;
 			continue;
@@ -303,7 +337,8 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 		}
 
 		case UAPI_DEF_WRITE:
-			rc = uapi_create_write(uapi, ibdev, def, cur_obj_key);
+			rc = uapi_create_write(
+				uapi, ibdev, def, cur_obj_key, &cur_method_key);
 			if (rc)
 				return rc;
 			continue;

commit d120c3c91871650699ac8e71795925cc98358c3d
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:56 2018 +0200

    RDMA/uverbs: Convert the write interface to use uverbs_api
    
    This organizes the write commands into objects and links them to the
    uverbs_api data structure. The command path is reworked to use uapi
    instead of its internal structures.
    
    The command mask is moved from a runtime check to a registration time
    check in the uapi.
    
    Since the write interface does not have the object ID as part of the
    command, the radix bins are converted into linear lists to support the
    lookup.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 1cf79fc33c37..1e880f1d9d62 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -587,6 +587,7 @@ static const struct uapi_definition uverbs_core_api[] = {
 	UAPI_DEF_CHAIN(uverbs_def_obj_flow_action),
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
 	UAPI_DEF_CHAIN(uverbs_def_obj_mr),
+	UAPI_DEF_CHAIN(uverbs_def_write_intf),
 	{},
 };
 

commit 6884c6c4bd09fb35b79a3967d15821cdfcbe77a3
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:55 2018 +0200

    RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api
    
    Bringing all uapi entry points into one place lets us deal with them
    consistently. For instance the write, write_ex and ioctl paths can be
    disabled when an API is not supported by the driver.
    
    This will replace the uverbs_cmd_table static arrays.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 363a2d25728a..1cf79fc33c37 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -8,6 +8,19 @@
 #include "rdma_core.h"
 #include "uverbs.h"
 
+static ssize_t ib_uverbs_notsupp(struct ib_uverbs_file *file,
+				 const char __user *buf, int in_len,
+				 int out_len)
+{
+	return -EOPNOTSUPP;
+}
+
+static int ib_uverbs_ex_notsupp(struct ib_uverbs_file *file,
+				struct ib_udata *ucore, struct ib_udata *uhw)
+{
+	return -EOPNOTSUPP;
+}
+
 static void *uapi_add_elm(struct uverbs_api *uapi, u32 key, size_t alloc_size)
 {
 	void *elm;
@@ -47,6 +60,42 @@ static void *uapi_add_get_elm(struct uverbs_api *uapi, u32 key,
 	return elm;
 }
 
+static int uapi_create_write(struct uverbs_api *uapi, struct ib_device *ibdev,
+			     const struct uapi_definition *def, u32 obj_key)
+{
+	struct uverbs_api_write_method *method_elm;
+	u32 method_key = obj_key;
+	bool exists;
+
+	if (def->write.is_ex)
+		method_key |= uapi_key_write_ex_method(def->write.command_num);
+	else
+		method_key |= uapi_key_write_method(def->write.command_num);
+
+	method_elm = uapi_add_get_elm(uapi, method_key, sizeof(*method_elm),
+				      &exists);
+	if (IS_ERR(method_elm))
+		return PTR_ERR(method_elm);
+
+	if (WARN_ON(exists && (def->write.is_ex != method_elm->is_ex ||
+			       method_elm->handler_ex || method_elm->handler)))
+		return -EINVAL;
+
+	method_elm->is_ex = def->write.is_ex;
+	if (def->write.is_ex) {
+		method_elm->handler_ex = def->func_write_ex;
+
+		method_elm->disabled = !(ibdev->uverbs_ex_cmd_mask &
+					 BIT_ULL(def->write.command_num));
+	} else {
+		method_elm->handler = def->func_write;
+
+		method_elm->disabled = !(ibdev->uverbs_cmd_mask &
+					 BIT_ULL(def->write.command_num));
+	}
+	return 0;
+}
+
 static int uapi_merge_method(struct uverbs_api *uapi,
 			     struct uverbs_api_object *obj_elm, u32 obj_key,
 			     const struct uverbs_method_def *method,
@@ -194,6 +243,7 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 {
 	const struct uapi_definition *def = def_list;
 	u32 cur_obj_key = UVERBS_API_KEY_ERR;
+	bool exists;
 	int rc;
 
 	if (!def_list)
@@ -240,6 +290,23 @@ static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 			if (rc)
 				return rc;
 			continue;
+
+		case UAPI_DEF_OBJECT_START: {
+			struct uverbs_api_object *obj_elm;
+
+			cur_obj_key = uapi_key_obj(def->object_start.object_id);
+			obj_elm = uapi_add_get_elm(uapi, cur_obj_key,
+						   sizeof(*obj_elm), &exists);
+			if (IS_ERR(obj_elm))
+				return PTR_ERR(obj_elm);
+			continue;
+		}
+
+		case UAPI_DEF_WRITE:
+			rc = uapi_create_write(uapi, ibdev, def, cur_obj_key);
+			if (rc)
+				return rc;
+			continue;
 		}
 		WARN_ON(true);
 		return -EINVAL;
@@ -266,8 +333,8 @@ uapi_finalize_ioctl_method(struct uverbs_api *uapi,
 		u32 attr_bkey = uapi_bkey_attr(attr_key);
 		u8 type = elm->spec.type;
 
-		if (uapi_key_attr_to_method(iter.index) !=
-		    uapi_key_attr_to_method(method_key))
+		if (uapi_key_attr_to_ioctl_method(iter.index) !=
+		    uapi_key_attr_to_ioctl_method(method_key))
 			break;
 
 		if (elm->spec.mandatory)
@@ -309,9 +376,13 @@ uapi_finalize_ioctl_method(struct uverbs_api *uapi,
 
 static int uapi_finalize(struct uverbs_api *uapi)
 {
+	const struct uverbs_api_write_method **data;
+	unsigned long max_write_ex = 0;
+	unsigned long max_write = 0;
 	struct radix_tree_iter iter;
 	void __rcu **slot;
 	int rc;
+	int i;
 
 	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
 		struct uverbs_api_ioctl_method *method_elm =
@@ -323,6 +394,36 @@ static int uapi_finalize(struct uverbs_api *uapi)
 			if (rc)
 				return rc;
 		}
+
+		if (uapi_key_is_write_method(iter.index))
+			max_write = max(max_write,
+					iter.index & UVERBS_API_ATTR_KEY_MASK);
+		if (uapi_key_is_write_ex_method(iter.index))
+			max_write_ex =
+				max(max_write_ex,
+				    iter.index & UVERBS_API_ATTR_KEY_MASK);
+	}
+
+	uapi->notsupp_method.handler = ib_uverbs_notsupp;
+	uapi->notsupp_method.handler_ex = ib_uverbs_ex_notsupp;
+	uapi->num_write = max_write + 1;
+	uapi->num_write_ex = max_write_ex + 1;
+	data = kmalloc_array(uapi->num_write + uapi->num_write_ex,
+			     sizeof(*uapi->write_methods), GFP_KERNEL);
+	for (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)
+		data[i] = &uapi->notsupp_method;
+	uapi->write_methods = data;
+	uapi->write_ex_methods = data + uapi->num_write;
+
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+		if (uapi_key_is_write_method(iter.index))
+			uapi->write_methods[iter.index &
+					    UVERBS_API_ATTR_KEY_MASK] =
+				rcu_dereference_protected(*slot, true);
+		if (uapi_key_is_write_ex_method(iter.index))
+			uapi->write_ex_methods[iter.index &
+					       UVERBS_API_ATTR_KEY_MASK] =
+				rcu_dereference_protected(*slot, true);
 	}
 
 	return 0;
@@ -365,6 +466,23 @@ static u32 uapi_get_obj_id(struct uverbs_attr_spec *spec)
 	return UVERBS_API_KEY_ERR;
 }
 
+static void uapi_key_okay(u32 key)
+{
+	unsigned int count = 0;
+
+	if (uapi_key_is_object(key))
+		count++;
+	if (uapi_key_is_ioctl_method(key))
+		count++;
+	if (uapi_key_is_write_method(key))
+		count++;
+	if (uapi_key_is_write_ex_method(key))
+		count++;
+	if (uapi_key_is_attr(key))
+		count++;
+	WARN(count != 1, "Bad count %d key=%x", count, key);
+}
+
 static void uapi_finalize_disable(struct uverbs_api *uapi)
 {
 	struct radix_tree_iter iter;
@@ -374,6 +492,8 @@ static void uapi_finalize_disable(struct uverbs_api *uapi)
 
 again:
 	radix_tree_for_each_slot (slot, &uapi->radix, &iter, starting_key) {
+		uapi_key_okay(iter.index);
+
 		if (uapi_key_is_object(iter.index)) {
 			struct uverbs_api_object *obj_elm =
 				rcu_dereference_protected(*slot, true);
@@ -400,6 +520,18 @@ static void uapi_finalize_disable(struct uverbs_api *uapi)
 			continue;
 		}
 
+		if (uapi_key_is_write_method(iter.index) ||
+		    uapi_key_is_write_ex_method(iter.index)) {
+			struct uverbs_api_write_method *method_elm =
+				rcu_dereference_protected(*slot, true);
+
+			if (method_elm->disabled) {
+				kfree(method_elm);
+				radix_tree_iter_delete(&uapi->radix, &iter, slot);
+			}
+			continue;
+		}
+
 		if (uapi_key_is_attr(iter.index)) {
 			struct uverbs_api_attr *attr_elm =
 				rcu_dereference_protected(*slot, true);
@@ -444,6 +576,7 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 		return;
 
 	uapi_remove_range(uapi, 0, U32_MAX);
+	kfree(uapi->write_methods);
 	kfree(uapi);
 }
 

commit 0bd01f3d090788188d3766bac044292de2789d03
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:54 2018 +0200

    RDMA/uverbs: Require all objects to have a driver destroy function
    
    If we can't destroy the object then we certainly shouldn't allow it be
    created or used. Remove it from the uverbs_uapi in this case.
    
    This also disables methods of other objects that have mandatory object
    handle inputs - ie REG_DM_MR is now automatically removed if DM objects
    cannot be created.
    
    Typically drivers not supporting an interface will mark all of the
    supporting functions as NULL, including destroy.
    
    This is intended to automatically eliminate entire corner cases in the API
    that are difficult to test.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 9a904dd51694..363a2d25728a 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -448,7 +448,12 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 }
 
 static const struct uapi_definition uverbs_core_api[] = {
+	UAPI_DEF_CHAIN(uverbs_def_obj_counters),
+	UAPI_DEF_CHAIN(uverbs_def_obj_cq),
+	UAPI_DEF_CHAIN(uverbs_def_obj_dm),
+	UAPI_DEF_CHAIN(uverbs_def_obj_flow_action),
 	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
+	UAPI_DEF_CHAIN(uverbs_def_obj_mr),
 	{},
 };
 

commit 6829c1c2b371674a05562a39d608b5cf48351bea
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:52 2018 +0200

    RDMA/uverbs: Add helpers to mark uapi functions as unsupported
    
    We have many cases where parts of the uapi are not supported in a driver,
    needs a certain protocol, or whatever. It is best to reflect this directly
    into the struct uverbs_api when it is built so that everything is simply
    blocked off, and future introspection can report a proper supported list.
    
    This is done by adding some additional helpers to the definition list
    language that disable objects based on a 'supported' call back, and a
    helper that disables based on a NULL struct ib_device function pointer.
    
    Disablement is global. For instance, if a driver disables an object then
    everything connected to that object is removed, including core methods.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index cb35f1864781..9a904dd51694 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -167,11 +167,33 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 	return 0;
 }
 
-static int uapi_merge_def(struct uverbs_api *uapi,
+static int uapi_disable_elm(struct uverbs_api *uapi,
+			    const struct uapi_definition *def,
+			    u32 obj_key)
+{
+	bool exists;
+
+	if (def->scope == UAPI_SCOPE_OBJECT) {
+		struct uverbs_api_object *obj_elm;
+
+		obj_elm = uapi_add_get_elm(
+			uapi, obj_key, sizeof(*obj_elm), &exists);
+		if (IS_ERR(obj_elm))
+			return PTR_ERR(obj_elm);
+		obj_elm->disabled = 1;
+		return 0;
+	}
+
+	WARN_ON(true);
+	return -EINVAL;
+}
+
+static int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,
 			  const struct uapi_definition *def_list,
 			  bool is_driver)
 {
 	const struct uapi_definition *def = def_list;
+	u32 cur_obj_key = UVERBS_API_KEY_ERR;
 	int rc;
 
 	if (!def_list)
@@ -180,7 +202,7 @@ static int uapi_merge_def(struct uverbs_api *uapi,
 	for (;; def++) {
 		switch ((enum uapi_definition_kind)def->kind) {
 		case UAPI_DEF_CHAIN:
-			rc = uapi_merge_def(uapi, def->chain, is_driver);
+			rc = uapi_merge_def(uapi, ibdev, def->chain, is_driver);
 			if (rc)
 				return rc;
 			continue;
@@ -190,6 +212,7 @@ static int uapi_merge_def(struct uverbs_api *uapi,
 				    def->chain_obj_tree->id))
 				return -EINVAL;
 
+			cur_obj_key = uapi_key_obj(def->object_start.object_id);
 			rc = uapi_merge_obj_tree(uapi, def->chain_obj_tree,
 						 is_driver);
 			if (rc)
@@ -198,6 +221,25 @@ static int uapi_merge_def(struct uverbs_api *uapi,
 
 		case UAPI_DEF_END:
 			return 0;
+
+		case UAPI_DEF_IS_SUPPORTED_DEV_FN: {
+			void **ibdev_fn = (void *)ibdev + def->needs_fn_offset;
+
+			if (*ibdev_fn)
+				continue;
+			rc = uapi_disable_elm(uapi, def, cur_obj_key);
+			if (rc)
+				return rc;
+			continue;
+		}
+
+		case UAPI_DEF_IS_SUPPORTED_FUNC:
+			if (def->func_is_supported(ibdev))
+				continue;
+			rc = uapi_disable_elm(uapi, def, cur_obj_key);
+			if (rc)
+				return rc;
+			continue;
 		}
 		WARN_ON(true);
 		return -EINVAL;
@@ -286,18 +328,122 @@ static int uapi_finalize(struct uverbs_api *uapi)
 	return 0;
 }
 
-void uverbs_destroy_api(struct uverbs_api *uapi)
+static void uapi_remove_range(struct uverbs_api *uapi, u32 start, u32 last)
 {
 	struct radix_tree_iter iter;
 	void __rcu **slot;
 
-	if (!uapi)
-		return;
-
-	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, start) {
+		if (iter.index > last)
+			return;
 		kfree(rcu_dereference_protected(*slot, true));
 		radix_tree_iter_delete(&uapi->radix, &iter, slot);
 	}
+}
+
+static void uapi_remove_object(struct uverbs_api *uapi, u32 obj_key)
+{
+	uapi_remove_range(uapi, obj_key,
+			  obj_key | UVERBS_API_METHOD_KEY_MASK |
+				  UVERBS_API_ATTR_KEY_MASK);
+}
+
+static void uapi_remove_method(struct uverbs_api *uapi, u32 method_key)
+{
+	uapi_remove_range(uapi, method_key,
+			  method_key | UVERBS_API_ATTR_KEY_MASK);
+}
+
+
+static u32 uapi_get_obj_id(struct uverbs_attr_spec *spec)
+{
+	if (spec->type == UVERBS_ATTR_TYPE_IDR ||
+	    spec->type == UVERBS_ATTR_TYPE_FD)
+		return spec->u.obj.obj_type;
+	if (spec->type == UVERBS_ATTR_TYPE_IDRS_ARRAY)
+		return spec->u2.objs_arr.obj_type;
+	return UVERBS_API_KEY_ERR;
+}
+
+static void uapi_finalize_disable(struct uverbs_api *uapi)
+{
+	struct radix_tree_iter iter;
+	u32 starting_key = 0;
+	bool scan_again = false;
+	void __rcu **slot;
+
+again:
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, starting_key) {
+		if (uapi_key_is_object(iter.index)) {
+			struct uverbs_api_object *obj_elm =
+				rcu_dereference_protected(*slot, true);
+
+			if (obj_elm->disabled) {
+				/* Have to check all the attrs again */
+				scan_again = true;
+				starting_key = iter.index;
+				uapi_remove_object(uapi, iter.index);
+				goto again;
+			}
+			continue;
+		}
+
+		if (uapi_key_is_ioctl_method(iter.index)) {
+			struct uverbs_api_ioctl_method *method_elm =
+				rcu_dereference_protected(*slot, true);
+
+			if (method_elm->disabled) {
+				starting_key = iter.index;
+				uapi_remove_method(uapi, iter.index);
+				goto again;
+			}
+			continue;
+		}
+
+		if (uapi_key_is_attr(iter.index)) {
+			struct uverbs_api_attr *attr_elm =
+				rcu_dereference_protected(*slot, true);
+			const struct uverbs_api_object *tmp_obj;
+			u32 obj_key;
+
+			/*
+			 * If the method has a mandatory object handle
+			 * attribute which relies on an object which is not
+			 * present then the entire method is uncallable.
+			 */
+			if (!attr_elm->spec.mandatory)
+				continue;
+			obj_key = uapi_get_obj_id(&attr_elm->spec);
+			if (obj_key == UVERBS_API_KEY_ERR)
+				continue;
+			tmp_obj = uapi_get_object(uapi, obj_key);
+			if (tmp_obj && !tmp_obj->disabled)
+				continue;
+
+			starting_key = iter.index;
+			uapi_remove_method(
+				uapi,
+				iter.index & (UVERBS_API_OBJ_KEY_MASK |
+					      UVERBS_API_METHOD_KEY_MASK));
+			goto again;
+		}
+
+		WARN_ON(false);
+	}
+
+	if (!scan_again)
+		return;
+	scan_again = false;
+	starting_key = 0;
+	goto again;
+}
+
+void uverbs_destroy_api(struct uverbs_api *uapi)
+{
+	if (!uapi)
+		return;
+
+	uapi_remove_range(uapi, 0, U32_MAX);
 	kfree(uapi);
 }
 
@@ -306,8 +452,7 @@ static const struct uapi_definition uverbs_core_api[] = {
 	{},
 };
 
-struct uverbs_api *uverbs_alloc_api(const struct uapi_definition *driver_def,
-				    enum rdma_driver_id driver_id)
+struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev)
 {
 	struct uverbs_api *uapi;
 	int rc;
@@ -317,15 +462,16 @@ struct uverbs_api *uverbs_alloc_api(const struct uapi_definition *driver_def,
 		return ERR_PTR(-ENOMEM);
 
 	INIT_RADIX_TREE(&uapi->radix, GFP_KERNEL);
-	uapi->driver_id = driver_id;
+	uapi->driver_id = ibdev->driver_id;
 
-	rc = uapi_merge_def(uapi, uverbs_core_api, false);
+	rc = uapi_merge_def(uapi, ibdev, uverbs_core_api, false);
 	if (rc)
 		goto err;
-	rc = uapi_merge_def(uapi, driver_def, true);
+	rc = uapi_merge_def(uapi, ibdev, ibdev->driver_def, true);
 	if (rc)
 		goto err;
 
+	uapi_finalize_disable(uapi);
 	rc = uapi_finalize(uapi);
 	if (rc)
 		goto err;
@@ -333,8 +479,9 @@ struct uverbs_api *uverbs_alloc_api(const struct uapi_definition *driver_def,
 	return uapi;
 err:
 	if (rc != -ENOMEM)
-		pr_err("Setup of uverbs_api failed, kernel parsing tree description is not valid (%d)??\n",
-		       rc);
+		dev_err(&ibdev->dev,
+			"Setup of uverbs_api failed, kernel parsing tree description is not valid (%d)??\n",
+			rc);
 
 	uverbs_destroy_api(uapi);
 	return ERR_PTR(rc);

commit c27f6aa8c9df7f3270d5f5f2957a2a024262eb99
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:51 2018 +0200

    RDMA/uverbs: Factor out the add/get pattern into a helper
    
    The next patch needs another copy of this, provide a simple helper to
    reduce the coding. uapi_add_get_elm() returns an existing entry or adds a
    new one.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 67e8e96adb05..cb35f1864781 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -26,6 +26,27 @@ static void *uapi_add_elm(struct uverbs_api *uapi, u32 key, size_t alloc_size)
 	return elm;
 }
 
+static void *uapi_add_get_elm(struct uverbs_api *uapi, u32 key,
+			      size_t alloc_size, bool *exists)
+{
+	void *elm;
+
+	elm = uapi_add_elm(uapi, key, alloc_size);
+	if (!IS_ERR(elm)) {
+		*exists = false;
+		return elm;
+	}
+
+	if (elm != ERR_PTR(-EEXIST))
+		return elm;
+
+	elm = radix_tree_lookup(&uapi->radix, key);
+	if (WARN_ON(!elm))
+		return ERR_PTR(-EINVAL);
+	*exists = true;
+	return elm;
+}
+
 static int uapi_merge_method(struct uverbs_api *uapi,
 			     struct uverbs_api_object *obj_elm, u32 obj_key,
 			     const struct uverbs_method_def *method,
@@ -34,23 +55,21 @@ static int uapi_merge_method(struct uverbs_api *uapi,
 	u32 method_key = obj_key | uapi_key_ioctl_method(method->id);
 	struct uverbs_api_ioctl_method *method_elm;
 	unsigned int i;
+	bool exists;
 
 	if (!method->attrs)
 		return 0;
 
-	method_elm = uapi_add_elm(uapi, method_key, sizeof(*method_elm));
-	if (IS_ERR(method_elm)) {
-		if (method_elm != ERR_PTR(-EEXIST))
-			return PTR_ERR(method_elm);
-
+	method_elm = uapi_add_get_elm(uapi, method_key, sizeof(*method_elm),
+				      &exists);
+	if (IS_ERR(method_elm))
+		return PTR_ERR(method_elm);
+	if (exists) {
 		/*
 		 * This occurs when a driver uses ADD_UVERBS_ATTRIBUTES_SIMPLE
 		 */
 		if (WARN_ON(method->handler))
 			return -EINVAL;
-		method_elm = radix_tree_lookup(&uapi->radix, method_key);
-		if (WARN_ON(!method_elm))
-			return -EINVAL;
 	} else {
 		WARN_ON(!method->handler);
 		rcu_assign_pointer(method_elm->handler, method->handler);
@@ -105,34 +124,29 @@ static int uapi_merge_obj_tree(struct uverbs_api *uapi,
 	struct uverbs_api_object *obj_elm;
 	unsigned int i;
 	u32 obj_key;
+	bool exists;
 	int rc;
 
 	obj_key = uapi_key_obj(obj->id);
-	obj_elm = uapi_add_elm(uapi, obj_key, sizeof(*obj_elm));
-	if (IS_ERR(obj_elm)) {
-		if (obj_elm != ERR_PTR(-EEXIST))
-			return PTR_ERR(obj_elm);
+	obj_elm = uapi_add_get_elm(uapi, obj_key, sizeof(*obj_elm), &exists);
+	if (IS_ERR(obj_elm))
+		return PTR_ERR(obj_elm);
 
-		/* This occurs when a driver uses ADD_UVERBS_METHODS */
-		if (WARN_ON(obj->type_attrs))
+	if (obj->type_attrs) {
+		if (WARN_ON(obj_elm->type_attrs))
 			return -EINVAL;
-		obj_elm = radix_tree_lookup(&uapi->radix, obj_key);
-		if (WARN_ON(!obj_elm))
-			return -EINVAL;
-	} else {
+
 		obj_elm->type_attrs = obj->type_attrs;
-		if (obj->type_attrs) {
-			obj_elm->type_class = obj->type_attrs->type_class;
-			/*
-			 * Today drivers are only permitted to use idr_class
-			 * types. They cannot use FD types because we
-			 * currently have no way to revoke the fops pointer
-			 * after device disassociation.
-			 */
-			if (WARN_ON(is_driver && obj->type_attrs->type_class !=
-							 &uverbs_idr_class))
-				return -EINVAL;
-		}
+		obj_elm->type_class = obj->type_attrs->type_class;
+		/*
+		 * Today drivers are only permitted to use idr_class
+		 * types. They cannot use FD types because we currently have
+		 * no way to revoke the fops pointer after device
+		 * disassociation.
+		 */
+		if (WARN_ON(is_driver &&
+			    obj->type_attrs->type_class != &uverbs_idr_class))
+			return -EINVAL;
 	}
 
 	if (!obj->methods)

commit 0cbf432db405289216747a8d31d74bab2452337c
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Nov 12 22:59:50 2018 +0200

    RDMA/uverbs: Use a linear list to describe the compiled-in uapi
    
    The 'tree' data structure is very hard to build at compile time, and this
    makes it very limited. The new radix tree based compiler can handle a more
    complex input language that does not require the compiler to perfectly
    group everything into a neat tree structure.
    
    Instead use a simple list to describe to input, where the list elements
    can be of various different 'opcodes' instructing the radix compiler what
    to do. Start out with opcodes chaining to other definition lists and
    chaining to the existing 'tree' definition.
    
    Replace the very top level of the 'object tree' with this list type and
    get rid of struct uverbs_object_tree_def and DECLARE_UVERBS_OBJECT_TREE.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 86f3fc5e04b4..67e8e96adb05 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -98,72 +98,96 @@ static int uapi_merge_method(struct uverbs_api *uapi,
 	return 0;
 }
 
-static int uapi_merge_tree(struct uverbs_api *uapi,
-			   const struct uverbs_object_tree_def *tree,
-			   bool is_driver)
+static int uapi_merge_obj_tree(struct uverbs_api *uapi,
+			       const struct uverbs_object_def *obj,
+			       bool is_driver)
 {
-	unsigned int i, j;
+	struct uverbs_api_object *obj_elm;
+	unsigned int i;
+	u32 obj_key;
 	int rc;
 
-	if (!tree->objects)
+	obj_key = uapi_key_obj(obj->id);
+	obj_elm = uapi_add_elm(uapi, obj_key, sizeof(*obj_elm));
+	if (IS_ERR(obj_elm)) {
+		if (obj_elm != ERR_PTR(-EEXIST))
+			return PTR_ERR(obj_elm);
+
+		/* This occurs when a driver uses ADD_UVERBS_METHODS */
+		if (WARN_ON(obj->type_attrs))
+			return -EINVAL;
+		obj_elm = radix_tree_lookup(&uapi->radix, obj_key);
+		if (WARN_ON(!obj_elm))
+			return -EINVAL;
+	} else {
+		obj_elm->type_attrs = obj->type_attrs;
+		if (obj->type_attrs) {
+			obj_elm->type_class = obj->type_attrs->type_class;
+			/*
+			 * Today drivers are only permitted to use idr_class
+			 * types. They cannot use FD types because we
+			 * currently have no way to revoke the fops pointer
+			 * after device disassociation.
+			 */
+			if (WARN_ON(is_driver && obj->type_attrs->type_class !=
+							 &uverbs_idr_class))
+				return -EINVAL;
+		}
+	}
+
+	if (!obj->methods)
 		return 0;
 
-	for (i = 0; i != tree->num_objects; i++) {
-		const struct uverbs_object_def *obj = (*tree->objects)[i];
-		struct uverbs_api_object *obj_elm;
-		u32 obj_key;
+	for (i = 0; i != obj->num_methods; i++) {
+		const struct uverbs_method_def *method = (*obj->methods)[i];
 
-		if (!obj)
+		if (!method)
 			continue;
 
-		obj_key = uapi_key_obj(obj->id);
-		obj_elm = uapi_add_elm(uapi, obj_key, sizeof(*obj_elm));
-		if (IS_ERR(obj_elm)) {
-			if (obj_elm != ERR_PTR(-EEXIST))
-				return PTR_ERR(obj_elm);
+		rc = uapi_merge_method(uapi, obj_elm, obj_key, method,
+				       is_driver);
+		if (rc)
+			return rc;
+	}
 
-			/* This occurs when a driver uses ADD_UVERBS_METHODS */
-			if (WARN_ON(obj->type_attrs))
-				return -EINVAL;
-			obj_elm = radix_tree_lookup(&uapi->radix, obj_key);
-			if (WARN_ON(!obj_elm))
-				return -EINVAL;
-		} else {
-			obj_elm->type_attrs = obj->type_attrs;
-			if (obj->type_attrs) {
-				obj_elm->type_class =
-					obj->type_attrs->type_class;
-				/*
-				 * Today drivers are only permitted to use
-				 * idr_class types. They cannot use FD types
-				 * because we currently have no way to revoke
-				 * the fops pointer after device
-				 * disassociation.
-				 */
-				if (WARN_ON(is_driver &&
-					    obj->type_attrs->type_class !=
-						    &uverbs_idr_class))
-					return -EINVAL;
-			}
-		}
+	return 0;
+}
+
+static int uapi_merge_def(struct uverbs_api *uapi,
+			  const struct uapi_definition *def_list,
+			  bool is_driver)
+{
+	const struct uapi_definition *def = def_list;
+	int rc;
+
+	if (!def_list)
+		return 0;
 
-		if (!obj->methods)
+	for (;; def++) {
+		switch ((enum uapi_definition_kind)def->kind) {
+		case UAPI_DEF_CHAIN:
+			rc = uapi_merge_def(uapi, def->chain, is_driver);
+			if (rc)
+				return rc;
 			continue;
 
-		for (j = 0; j != obj->num_methods; j++) {
-			const struct uverbs_method_def *method =
-				(*obj->methods)[j];
-			if (!method)
-				continue;
+		case UAPI_DEF_CHAIN_OBJ_TREE:
+			if (WARN_ON(def->object_start.object_id !=
+				    def->chain_obj_tree->id))
+				return -EINVAL;
 
-			rc = uapi_merge_method(uapi, obj_elm, obj_key, method,
-					       is_driver);
+			rc = uapi_merge_obj_tree(uapi, def->chain_obj_tree,
+						 is_driver);
 			if (rc)
 				return rc;
+			continue;
+
+		case UAPI_DEF_END:
+			return 0;
 		}
+		WARN_ON(true);
+		return -EINVAL;
 	}
-
-	return 0;
 }
 
 static int
@@ -263,9 +287,13 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 	kfree(uapi);
 }
 
-struct uverbs_api *uverbs_alloc_api(
-	const struct uverbs_object_tree_def *const *driver_specs,
-	enum rdma_driver_id driver_id)
+static const struct uapi_definition uverbs_core_api[] = {
+	UAPI_DEF_CHAIN(uverbs_def_obj_intf),
+	{},
+};
+
+struct uverbs_api *uverbs_alloc_api(const struct uapi_definition *driver_def,
+				    enum rdma_driver_id driver_id)
 {
 	struct uverbs_api *uapi;
 	int rc;
@@ -277,15 +305,12 @@ struct uverbs_api *uverbs_alloc_api(
 	INIT_RADIX_TREE(&uapi->radix, GFP_KERNEL);
 	uapi->driver_id = driver_id;
 
-	rc = uapi_merge_tree(uapi, uverbs_default_get_objects(), false);
+	rc = uapi_merge_def(uapi, uverbs_core_api, false);
+	if (rc)
+		goto err;
+	rc = uapi_merge_def(uapi, driver_def, true);
 	if (rc)
 		goto err;
-
-	for (; driver_specs && *driver_specs; driver_specs++) {
-		rc = uapi_merge_tree(uapi, *driver_specs, true);
-		if (rc)
-			goto err;
-	}
 
 	rc = uapi_finalize(uapi);
 	if (rc)

commit 59bfc59a68286c5e6824ec3dddcf5232a73c217e
Merge: ed7a01fd3fd7 dd9a40349570
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue Oct 16 00:01:02 2018 -0600

    Merge branch 'for-rc' into rdma.git for-next
    
    From git://git.kernel.org/pub/scm/linux/kernel/git/rdma/rdma.git
    
    This is required to resolve dependencies of the next series of RDMA
    patches.
    
    The code motion conflicts in drivers/infiniband/core/cache.c were
    resolved.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

commit a9360abd3de0aad745d25d003923d56afb28a04b
Author: Mark Bloch <markb@mellanox.com>
Date:   Tue Sep 25 11:23:55 2018 +0300

    IB/uverbs: Free uapi on destroy
    
    Make sure we free struct uverbs_api once we clean the radix tree. It was
    allocated by uverbs_alloc_api().
    
    Fixes: 9ed3e5f44772 ("IB/uverbs: Build the specs into a radix tree at runtime")
    Reported-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 73ea6f0db88f..be854628a7c6 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -248,6 +248,7 @@ void uverbs_destroy_api(struct uverbs_api *uapi)
 		kfree(rcu_dereference_protected(*slot, true));
 		radix_tree_iter_delete(&uapi->radix, &iter, slot);
 	}
+	kfree(uapi);
 }
 
 struct uverbs_api *uverbs_alloc_api(

commit 70cd20aed00f719f3536154df02596106e431e45
Author: Guy Levi <guyle@mellanox.com>
Date:   Thu Sep 6 17:27:01 2018 +0300

    IB/uverbs: Add IDRs array attribute type to ioctl() interface
    
    Methods sometimes need to get a flexible set of IDRs and not a strict set
    as can be achieved today by the conventional IDR attribute. Add a new
    IDRS_ARRAY attribute to the generic uverbs ioctl layer.
    
    IDRS_ARRAY points to array of idrs of the same object type and same access
    rights, only write and read are supported.
    
    Signed-off-by: Guy Levi <guyle@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>``
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 73ea6f0db88f..cdf5ced2c84f 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -73,6 +73,18 @@ static int uapi_merge_method(struct uverbs_api *uapi,
 		if (attr->attr.type == UVERBS_ATTR_TYPE_ENUM_IN)
 			method_elm->driver_method |= is_driver;
 
+		/*
+		 * Like other uobject based things we only support a single
+		 * uobject being NEW'd or DESTROY'd
+		 */
+		if (attr->attr.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {
+			u8 access = attr->attr.u2.objs_arr.access;
+
+			if (WARN_ON(access == UVERBS_ACCESS_NEW ||
+				    access == UVERBS_ACCESS_DESTROY))
+				return -EINVAL;
+		}
+
 		attr_slot =
 			uapi_add_elm(uapi, method_key | uapi_key_attr(attr->id),
 				     sizeof(*attr_slot));

commit 3a863577a7496278892360a69d90d8465733100c
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Thu Aug 9 20:14:42 2018 -0600

    IB/uverbs: Use uverbs_api to unmarshal ioctl commands
    
    Convert the ioctl method syscall path to use the uverbs_api data
    structures. The new uapi structure includes all the same information, just
    in a different and more optimal way.
    
     - Use attr_bkey instead of 2 level radix trees for everything related to
       attributes. This includes the attribute storage, presence, and
       detection of missing mandatory attributes.
     - Avoid iterating over all attribute storage at finish, instead use
       find_first_bit with the attr_bkey to locate only those attrs that need
       cleanup.
     - Organize things to always run, and always rely on, cleanup. This
       avoids a bunch of tricky error unwind cases.
     - Locate the method using the radix tree, and locate the attributes
       using a very efficient incremental radix tree lookup
     - Use the precomputed destroy_bkey to handle uobject destruction
     - Use the precomputed allocation sizes and precomputed 'need_stack'
       to avoid maths in the fast path. This is optimal if userspace
       does not pass (many) unsupported attributes.
    
    Overall this results in much better codegen for the attribute accessors,
    everything is now stored in bitmaps or linear arrays indexed by attr_bkey.
    The compiler can compute attr_bkey values at compile time for all method
    attributes, meaning things like uverbs_attr_is_valid() now compile into
    single instruction bit tests.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
index 21c0de034511..73ea6f0db88f 100644
--- a/drivers/infiniband/core/uverbs_uapi.c
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -160,6 +160,7 @@ uapi_finalize_ioctl_method(struct uverbs_api *uapi,
 			   u32 method_key)
 {
 	struct radix_tree_iter iter;
+	unsigned int num_attrs = 0;
 	unsigned int max_bkey = 0;
 	bool single_uobj = false;
 	void __rcu **slot;
@@ -204,11 +205,13 @@ uapi_finalize_ioctl_method(struct uverbs_api *uapi,
 		}
 
 		max_bkey = max(max_bkey, attr_bkey);
+		num_attrs++;
 	}
 
 	method_elm->key_bitmap_len = max_bkey + 1;
 	WARN_ON(method_elm->key_bitmap_len > UVERBS_API_ATTR_BKEY_LEN);
 
+	uapi_compute_bundle_size(method_elm, num_attrs);
 	return 0;
 }
 

commit 9ed3e5f447723a41de6bcc29633e9f7e6246d2f7
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Thu Aug 9 20:14:36 2018 -0600

    IB/uverbs: Build the specs into a radix tree at runtime
    
    This radix tree datastructure is intended to replace the 'hash' structure
    used today for parsing ioctl methods during system calls. This first
    commit introduces the structure and builds it from the existing .rodata
    descriptions.
    
    The so-called hash arrangement is actually a 5 level open coded radix tree.
    This new version uses a 3 level radix tree built using the radix tree
    library.
    
    Overall this is much less code and much easier to build as the radix tree
    API allows for dynamic modification during the building. There is a small
    memory penalty to pay for this, but since the radix tree is allocated on
    a per device basis, a few kb of RAM seems immaterial considering the
    gained simplicity.
    
    The radix tree is similar to the existing tree, but also has a 'attr_bkey'
    concept, which is a small value'd index for each method attribute. This is
    used to simplify and improve performance of everything in the next
    patches.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>

diff --git a/drivers/infiniband/core/uverbs_uapi.c b/drivers/infiniband/core/uverbs_uapi.c
new file mode 100644
index 000000000000..21c0de034511
--- /dev/null
+++ b/drivers/infiniband/core/uverbs_uapi.c
@@ -0,0 +1,343 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/*
+ * Copyright (c) 2017, Mellanox Technologies inc.  All rights reserved.
+ */
+#include <rdma/uverbs_ioctl.h>
+#include <rdma/rdma_user_ioctl.h>
+#include <linux/bitops.h>
+#include "rdma_core.h"
+#include "uverbs.h"
+
+static void *uapi_add_elm(struct uverbs_api *uapi, u32 key, size_t alloc_size)
+{
+	void *elm;
+	int rc;
+
+	if (key == UVERBS_API_KEY_ERR)
+		return ERR_PTR(-EOVERFLOW);
+
+	elm = kzalloc(alloc_size, GFP_KERNEL);
+	rc = radix_tree_insert(&uapi->radix, key, elm);
+	if (rc) {
+		kfree(elm);
+		return ERR_PTR(rc);
+	}
+
+	return elm;
+}
+
+static int uapi_merge_method(struct uverbs_api *uapi,
+			     struct uverbs_api_object *obj_elm, u32 obj_key,
+			     const struct uverbs_method_def *method,
+			     bool is_driver)
+{
+	u32 method_key = obj_key | uapi_key_ioctl_method(method->id);
+	struct uverbs_api_ioctl_method *method_elm;
+	unsigned int i;
+
+	if (!method->attrs)
+		return 0;
+
+	method_elm = uapi_add_elm(uapi, method_key, sizeof(*method_elm));
+	if (IS_ERR(method_elm)) {
+		if (method_elm != ERR_PTR(-EEXIST))
+			return PTR_ERR(method_elm);
+
+		/*
+		 * This occurs when a driver uses ADD_UVERBS_ATTRIBUTES_SIMPLE
+		 */
+		if (WARN_ON(method->handler))
+			return -EINVAL;
+		method_elm = radix_tree_lookup(&uapi->radix, method_key);
+		if (WARN_ON(!method_elm))
+			return -EINVAL;
+	} else {
+		WARN_ON(!method->handler);
+		rcu_assign_pointer(method_elm->handler, method->handler);
+		if (method->handler != uverbs_destroy_def_handler)
+			method_elm->driver_method = is_driver;
+	}
+
+	for (i = 0; i != method->num_attrs; i++) {
+		const struct uverbs_attr_def *attr = (*method->attrs)[i];
+		struct uverbs_api_attr *attr_slot;
+
+		if (!attr)
+			continue;
+
+		/*
+		 * ENUM_IN contains the 'ids' pointer to the driver's .rodata,
+		 * so if it is specified by a driver then it always makes this
+		 * into a driver method.
+		 */
+		if (attr->attr.type == UVERBS_ATTR_TYPE_ENUM_IN)
+			method_elm->driver_method |= is_driver;
+
+		attr_slot =
+			uapi_add_elm(uapi, method_key | uapi_key_attr(attr->id),
+				     sizeof(*attr_slot));
+		/* Attributes are not allowed to be modified by drivers */
+		if (IS_ERR(attr_slot))
+			return PTR_ERR(attr_slot);
+
+		attr_slot->spec = attr->attr;
+	}
+
+	return 0;
+}
+
+static int uapi_merge_tree(struct uverbs_api *uapi,
+			   const struct uverbs_object_tree_def *tree,
+			   bool is_driver)
+{
+	unsigned int i, j;
+	int rc;
+
+	if (!tree->objects)
+		return 0;
+
+	for (i = 0; i != tree->num_objects; i++) {
+		const struct uverbs_object_def *obj = (*tree->objects)[i];
+		struct uverbs_api_object *obj_elm;
+		u32 obj_key;
+
+		if (!obj)
+			continue;
+
+		obj_key = uapi_key_obj(obj->id);
+		obj_elm = uapi_add_elm(uapi, obj_key, sizeof(*obj_elm));
+		if (IS_ERR(obj_elm)) {
+			if (obj_elm != ERR_PTR(-EEXIST))
+				return PTR_ERR(obj_elm);
+
+			/* This occurs when a driver uses ADD_UVERBS_METHODS */
+			if (WARN_ON(obj->type_attrs))
+				return -EINVAL;
+			obj_elm = radix_tree_lookup(&uapi->radix, obj_key);
+			if (WARN_ON(!obj_elm))
+				return -EINVAL;
+		} else {
+			obj_elm->type_attrs = obj->type_attrs;
+			if (obj->type_attrs) {
+				obj_elm->type_class =
+					obj->type_attrs->type_class;
+				/*
+				 * Today drivers are only permitted to use
+				 * idr_class types. They cannot use FD types
+				 * because we currently have no way to revoke
+				 * the fops pointer after device
+				 * disassociation.
+				 */
+				if (WARN_ON(is_driver &&
+					    obj->type_attrs->type_class !=
+						    &uverbs_idr_class))
+					return -EINVAL;
+			}
+		}
+
+		if (!obj->methods)
+			continue;
+
+		for (j = 0; j != obj->num_methods; j++) {
+			const struct uverbs_method_def *method =
+				(*obj->methods)[j];
+			if (!method)
+				continue;
+
+			rc = uapi_merge_method(uapi, obj_elm, obj_key, method,
+					       is_driver);
+			if (rc)
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int
+uapi_finalize_ioctl_method(struct uverbs_api *uapi,
+			   struct uverbs_api_ioctl_method *method_elm,
+			   u32 method_key)
+{
+	struct radix_tree_iter iter;
+	unsigned int max_bkey = 0;
+	bool single_uobj = false;
+	void __rcu **slot;
+
+	method_elm->destroy_bkey = UVERBS_API_ATTR_BKEY_LEN;
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter,
+				  uapi_key_attrs_start(method_key)) {
+		struct uverbs_api_attr *elm =
+			rcu_dereference_protected(*slot, true);
+		u32 attr_key = iter.index & UVERBS_API_ATTR_KEY_MASK;
+		u32 attr_bkey = uapi_bkey_attr(attr_key);
+		u8 type = elm->spec.type;
+
+		if (uapi_key_attr_to_method(iter.index) !=
+		    uapi_key_attr_to_method(method_key))
+			break;
+
+		if (elm->spec.mandatory)
+			__set_bit(attr_bkey, method_elm->attr_mandatory);
+
+		if (type == UVERBS_ATTR_TYPE_IDR ||
+		    type == UVERBS_ATTR_TYPE_FD) {
+			u8 access = elm->spec.u.obj.access;
+
+			/*
+			 * Verbs specs may only have one NEW/DESTROY, we don't
+			 * have the infrastructure to abort multiple NEW's or
+			 * cope with multiple DESTROY failure.
+			 */
+			if (access == UVERBS_ACCESS_NEW ||
+			    access == UVERBS_ACCESS_DESTROY) {
+				if (WARN_ON(single_uobj))
+					return -EINVAL;
+
+				single_uobj = true;
+				if (WARN_ON(!elm->spec.mandatory))
+					return -EINVAL;
+			}
+
+			if (access == UVERBS_ACCESS_DESTROY)
+				method_elm->destroy_bkey = attr_bkey;
+		}
+
+		max_bkey = max(max_bkey, attr_bkey);
+	}
+
+	method_elm->key_bitmap_len = max_bkey + 1;
+	WARN_ON(method_elm->key_bitmap_len > UVERBS_API_ATTR_BKEY_LEN);
+
+	return 0;
+}
+
+static int uapi_finalize(struct uverbs_api *uapi)
+{
+	struct radix_tree_iter iter;
+	void __rcu **slot;
+	int rc;
+
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+		struct uverbs_api_ioctl_method *method_elm =
+			rcu_dereference_protected(*slot, true);
+
+		if (uapi_key_is_ioctl_method(iter.index)) {
+			rc = uapi_finalize_ioctl_method(uapi, method_elm,
+							iter.index);
+			if (rc)
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+void uverbs_destroy_api(struct uverbs_api *uapi)
+{
+	struct radix_tree_iter iter;
+	void __rcu **slot;
+
+	if (!uapi)
+		return;
+
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+		kfree(rcu_dereference_protected(*slot, true));
+		radix_tree_iter_delete(&uapi->radix, &iter, slot);
+	}
+}
+
+struct uverbs_api *uverbs_alloc_api(
+	const struct uverbs_object_tree_def *const *driver_specs,
+	enum rdma_driver_id driver_id)
+{
+	struct uverbs_api *uapi;
+	int rc;
+
+	uapi = kzalloc(sizeof(*uapi), GFP_KERNEL);
+	if (!uapi)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_RADIX_TREE(&uapi->radix, GFP_KERNEL);
+	uapi->driver_id = driver_id;
+
+	rc = uapi_merge_tree(uapi, uverbs_default_get_objects(), false);
+	if (rc)
+		goto err;
+
+	for (; driver_specs && *driver_specs; driver_specs++) {
+		rc = uapi_merge_tree(uapi, *driver_specs, true);
+		if (rc)
+			goto err;
+	}
+
+	rc = uapi_finalize(uapi);
+	if (rc)
+		goto err;
+
+	return uapi;
+err:
+	if (rc != -ENOMEM)
+		pr_err("Setup of uverbs_api failed, kernel parsing tree description is not valid (%d)??\n",
+		       rc);
+
+	uverbs_destroy_api(uapi);
+	return ERR_PTR(rc);
+}
+
+/*
+ * The pre version is done before destroying the HW objects, it only blocks
+ * off method access. All methods that require the ib_dev or the module data
+ * must test one of these assignments prior to continuing.
+ */
+void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev)
+{
+	struct uverbs_api *uapi = uverbs_dev->uapi;
+	struct radix_tree_iter iter;
+	void __rcu **slot;
+
+	rcu_assign_pointer(uverbs_dev->ib_dev, NULL);
+
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+		if (uapi_key_is_ioctl_method(iter.index)) {
+			struct uverbs_api_ioctl_method *method_elm =
+				rcu_dereference_protected(*slot, true);
+
+			if (method_elm->driver_method)
+				rcu_assign_pointer(method_elm->handler, NULL);
+		}
+	}
+
+	synchronize_srcu(&uverbs_dev->disassociate_srcu);
+}
+
+/*
+ * Called when a driver disassociates from the ib_uverbs_device. The
+ * assumption is that the driver module will unload after. Replace everything
+ * related to the driver with NULL as a safety measure.
+ */
+void uverbs_disassociate_api(struct uverbs_api *uapi)
+{
+	struct radix_tree_iter iter;
+	void __rcu **slot;
+
+	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
+		if (uapi_key_is_object(iter.index)) {
+			struct uverbs_api_object *object_elm =
+				rcu_dereference_protected(*slot, true);
+
+			/*
+			 * Some type_attrs are in the driver module. We don't
+			 * bother to keep track of which since there should be
+			 * no use of this after disassociate.
+			 */
+			object_elm->type_attrs = NULL;
+		} else if (uapi_key_is_attr(iter.index)) {
+			struct uverbs_api_attr *elm =
+				rcu_dereference_protected(*slot, true);
+
+			if (elm->spec.type == UVERBS_ATTR_TYPE_ENUM_IN)
+				elm->spec.u2.enum_def.ids = NULL;
+		}
+	}
+}
