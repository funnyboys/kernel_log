commit cf7e93c12fbc0f18cbea0571406e302d6904a7ac
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Thu Oct 10 10:11:04 2019 +0300

    RDMA/restrack: Remove PID namespace support
    
    IB resources are bounded to IB device and file descriptors, both entities
    are unaware to PID namespaces and to task lifetime.
    
    The difference in model caused to unpredictable behavior for the following
    scenario:
     1. Create FD and context
     2. Share it with ephemeral child
     3. Create any object and exit that child
    
    The end result of this flow, that those newly created objects will be
    tracked by restrack, but won't be visible for users because task_struct
    associated with them already exited.
    
    The right thing is to rely on net namespace only for any filtering
    purposes and drop PID namespace.
    
    Link: https://lore.kernel.org/r/20191010071105.25538-2-leon@kernel.org
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index a07665f7ef8c..62fbb0ae9cb4 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -116,11 +116,8 @@ int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type)
 	u32 cnt = 0;
 
 	xa_lock(&rt->xa);
-	xas_for_each(&xas, e, U32_MAX) {
-		if (!rdma_is_visible_in_pid_ns(e))
-			continue;
+	xas_for_each(&xas, e, U32_MAX)
 		cnt++;
-	}
 	xa_unlock(&rt->xa);
 	return cnt;
 }
@@ -346,18 +343,3 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	}
 }
 EXPORT_SYMBOL(rdma_restrack_del);
-
-bool rdma_is_visible_in_pid_ns(struct rdma_restrack_entry *res)
-{
-	/*
-	 * 1. Kern resources should be visible in init
-	 *    namespace only
-	 * 2. Present only resources visible in the current
-	 *     namespace
-	 */
-	if (rdma_is_kernel_res(res))
-		return task_active_pid_ns(current) == &init_pid_ns;
-
-	/* PID 0 means that resource is not found in current namespace */
-	return task_pid_vnr(res->task);
-}

commit 60c78668ae50d6b815ead4a62216822a92097125
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Thu Aug 15 11:38:29 2019 +0300

    RDMA/restrack: Rewrite PID namespace check to be reliable
    
    task_active_pid_ns() is wrong API to check PID namespace because it
    posses some restrictions and return PID namespace where the process
    was allocated. It created mismatches with current namespace, which
    can be different.
    
    Rewrite whole rdma_is_visible_in_pid_ns() logic to provide reliable
    results without any relation to allocated PID namespace.
    
    Fixes: 8be565e65fa9 ("RDMA/nldev: Factor out the PID namespace check")
    Fixes: 6a6c306a09b5 ("RDMA/restrack: Make is_visible_in_pid_ns() as an API")
    Reviewed-by: Mark Zhang <markz@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Link: https://lore.kernel.org/r/20190815083834.9245-4-leon@kernel.org
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index bddff426ee0f..a07665f7ef8c 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -107,10 +107,8 @@ void rdma_restrack_clean(struct ib_device *dev)
  * rdma_restrack_count() - the current usage of specific object
  * @dev:  IB device
  * @type: actual type of object to operate
- * @ns:   PID namespace
  */
-int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
-			struct pid_namespace *ns)
+int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type)
 {
 	struct rdma_restrack_root *rt = &dev->res[type];
 	struct rdma_restrack_entry *e;
@@ -119,10 +117,9 @@ int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 
 	xa_lock(&rt->xa);
 	xas_for_each(&xas, e, U32_MAX) {
-		if (ns == &init_pid_ns ||
-		    (!rdma_is_kernel_res(e) &&
-		     ns == task_active_pid_ns(e->task)))
-			cnt++;
+		if (!rdma_is_visible_in_pid_ns(e))
+			continue;
+		cnt++;
 	}
 	xa_unlock(&rt->xa);
 	return cnt;
@@ -360,5 +357,7 @@ bool rdma_is_visible_in_pid_ns(struct rdma_restrack_entry *res)
 	 */
 	if (rdma_is_kernel_res(res))
 		return task_active_pid_ns(current) == &init_pid_ns;
-	return task_active_pid_ns(current) == task_active_pid_ns(res->task);
+
+	/* PID 0 means that resource is not found in current namespace */
+	return task_pid_vnr(res->task);
 }

commit 6a6c306a09b5227d51fcc1643c888e316935dfa8
Author: Mark Zhang <markz@mellanox.com>
Date:   Tue Jul 2 13:02:33 2019 +0300

    RDMA/restrack: Make is_visible_in_pid_ns() as an API
    
    Remove is_visible_in_pid_ns() from nldev.c and make it as a restrack API,
    so that it can be taken advantage by other parts like counter.
    
    Signed-off-by: Mark Zhang <markz@mellanox.com>
    Reviewed-by: Majd Dibbiny <majd@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 3714634ae296..bddff426ee0f 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -349,3 +349,16 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	}
 }
 EXPORT_SYMBOL(rdma_restrack_del);
+
+bool rdma_is_visible_in_pid_ns(struct rdma_restrack_entry *res)
+{
+	/*
+	 * 1. Kern resources should be visible in init
+	 *    namespace only
+	 * 2. Present only resources visible in the current
+	 *     namespace
+	 */
+	if (rdma_is_kernel_res(res))
+		return task_active_pid_ns(current) == &init_pid_ns;
+	return task_active_pid_ns(current) == task_active_pid_ns(res->task);
+}

commit 699a9c540a04d05aa342cd84606bc8b1e8c05b7b
Author: Mark Zhang <markz@mellanox.com>
Date:   Tue Jul 2 13:02:32 2019 +0300

    RDMA/restrack: Add an API to attach a task to a resource
    
    Add rdma_restrack_attach_task() which is able to attach a task other then
    "current" to a resource.
    
    Signed-off-by: Mark Zhang <markz@mellanox.com>
    Reviewed-by: Majd Dibbiny <majd@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 95573f292aae..3714634ae296 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -194,6 +194,20 @@ void rdma_restrack_set_task(struct rdma_restrack_entry *res,
 }
 EXPORT_SYMBOL(rdma_restrack_set_task);
 
+/**
+ * rdma_restrack_attach_task() - attach the task onto this resource
+ * @res:  resource entry
+ * @task: the task to attach, the current task will be used if it is NULL.
+ */
+void rdma_restrack_attach_task(struct rdma_restrack_entry *res,
+			       struct task_struct *task)
+{
+	if (res->task)
+		put_task_struct(res->task);
+	get_task_struct(task);
+	res->task = task;
+}
+
 static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);

commit 7ade1ff96c7aa7e10445688a433d7ae39a13c6c9
Author: Mark Zhang <markz@mellanox.com>
Date:   Tue Jul 2 13:02:31 2019 +0300

    RDMA/restrack: Introduce statistic counter
    
    Introduce statistic counter as a new resource. It allows a user to monitor
    specific objects (e.g., QPs) by binding to a counter.
    
    In some cases a user counter resource is created with task other then
    "current", because its creation is done as part of rdmatool call.
    
    Signed-off-by: Mark Zhang <markz@mellanox.com>
    Reviewed-by: Majd Dibbiny <majd@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 3b5ff2f7b5f8..95573f292aae 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -6,6 +6,7 @@
 #include <rdma/rdma_cm.h>
 #include <rdma/ib_verbs.h>
 #include <rdma/restrack.h>
+#include <rdma/rdma_counter.h>
 #include <linux/mutex.h>
 #include <linux/sched/task.h>
 #include <linux/pid_namespace.h>
@@ -45,6 +46,7 @@ static const char *type2str(enum rdma_restrack_type type)
 		[RDMA_RESTRACK_CM_ID] = "CM_ID",
 		[RDMA_RESTRACK_MR] = "MR",
 		[RDMA_RESTRACK_CTX] = "CTX",
+		[RDMA_RESTRACK_COUNTER] = "COUNTER",
 	};
 
 	return names[type];
@@ -169,6 +171,8 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 		return container_of(res, struct ib_mr, res)->device;
 	case RDMA_RESTRACK_CTX:
 		return container_of(res, struct ib_ucontext, res)->device;
+	case RDMA_RESTRACK_COUNTER:
+		return container_of(res, struct rdma_counter, res)->device;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return NULL;
@@ -203,15 +207,22 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 
 	kref_init(&res->kref);
 	init_completion(&res->comp);
-	if (res->type != RDMA_RESTRACK_QP)
-		ret = xa_alloc_cyclic(&rt->xa, &res->id, res, xa_limit_32b,
-				&rt->next_id, GFP_KERNEL);
-	else {
+	if (res->type == RDMA_RESTRACK_QP) {
 		/* Special case to ensure that LQPN points to right QP */
 		struct ib_qp *qp = container_of(res, struct ib_qp, res);
 
 		ret = xa_insert(&rt->xa, qp->qp_num, res, GFP_KERNEL);
 		res->id = ret ? 0 : qp->qp_num;
+	} else if (res->type == RDMA_RESTRACK_COUNTER) {
+		/* Special case to ensure that cntn points to right counter */
+		struct rdma_counter *counter;
+
+		counter = container_of(res, struct rdma_counter, res);
+		ret = xa_insert(&rt->xa, counter->id, res, GFP_KERNEL);
+		res->id = ret ? 0 : counter->id;
+	} else {
+		ret = xa_alloc_cyclic(&rt->xa, &res->id, res, xa_limit_32b,
+				      &rt->next_id, GFP_KERNEL);
 	}
 
 	if (!ret)
@@ -237,7 +248,8 @@ EXPORT_SYMBOL(rdma_restrack_kadd);
  */
 void rdma_restrack_uadd(struct rdma_restrack_entry *res)
 {
-	if (res->type != RDMA_RESTRACK_CM_ID)
+	if ((res->type != RDMA_RESTRACK_CM_ID) &&
+	    (res->type != RDMA_RESTRACK_COUNTER))
 		res->task = NULL;
 
 	if (!res->task)

commit ea295481b6e313b4ea3ca2720ffcafd6005b5643
Merge: f3124ccf025c 4a5c8d898948
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 11 20:06:18 2019 -0700

    Merge tag 'xarray-5.1-rc1' of git://git.infradead.org/users/willy/linux-dax
    
    Pull XArray updates from Matthew Wilcox:
     "This pull request changes the xa_alloc() API. I'm only aware of one
      subsystem that has started trying to use it, and we agree on the fixup
      as part of the merge.
    
      The xa_insert() error code also changed to match xa_alloc() (EEXIST to
      EBUSY), and I added xa_alloc_cyclic(). Beyond that, the usual
      bugfixes, optimisations and tweaking.
    
      I now have a git tree with all users of the radix tree and IDR
      converted over to the XArray that I'll be feeding to maintainers over
      the next few weeks"
    
    * tag 'xarray-5.1-rc1' of git://git.infradead.org/users/willy/linux-dax:
      XArray: Fix xa_reserve for 2-byte aligned entries
      XArray: Fix xa_erase of 2-byte aligned entries
      XArray: Use xa_cmpxchg to implement xa_reserve
      XArray: Fix xa_release in allocating arrays
      XArray: Mark xa_insert and xa_reserve as must_check
      XArray: Add cyclic allocation
      XArray: Redesign xa_alloc API
      XArray: Add support for 1s-based allocation
      XArray: Change xa_insert to return -EBUSY
      XArray: Update xa_erase family descriptions
      XArray tests: RCU lock prohibits GFP_KERNEL

commit 1b8b778864b338b2e295687733d785ae1a65a9ea
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:51 2019 +0200

    RDMA/nldev: Connect QP number to .doit callback
    
    This patch adds ability to query specific QP based on its LQPN (local
    QPN), which is assigned by HW and needs special treatment while inserting
    into restrack DB.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index a5ea3988b4c3..fa804093fafb 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -225,7 +225,16 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 
 	kref_init(&res->kref);
 	init_completion(&res->comp);
-	ret = rt_xa_alloc_cyclic(&rt->xa, &res->id, res, &rt->next_id);
+	if (res->type != RDMA_RESTRACK_QP)
+		ret = rt_xa_alloc_cyclic(&rt->xa, &res->id, res, &rt->next_id);
+	else {
+		/* Special case to ensure that LQPN points to right QP */
+		struct ib_qp *qp = container_of(res, struct ib_qp, res);
+
+		ret = xa_insert(&rt->xa, qp->qp_num, res, GFP_KERNEL);
+		res->id = ret ? 0 : qp->qp_num;
+	}
+
 	if (!ret)
 		res->valid = true;
 }

commit 7c77c6a9bf9d71711dd3f89858bb0f5157a11919
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:48 2019 +0200

    RDMA/restrack: Prepare restrack_root to addition of extra fields per-type
    
    As a preparation to extension of rdma_restrack_root to provide software
    IDs, which will be per-type too. We convert the rdma_restrack_root from
    struct with arrays to array of structs.
    
    Such conversion allows us to drop rwsem lock in favour of internal XArray
    lock.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 6a4b76c66bcb..a5ea3988b4c3 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -9,7 +9,6 @@
 #include <linux/mutex.h>
 #include <linux/sched/task.h>
 #include <linux/pid_namespace.h>
-#include <linux/rwsem.h>
 
 #include "cma_priv.h"
 #include "restrack.h"
@@ -47,15 +46,14 @@ int rdma_restrack_init(struct ib_device *dev)
 	struct rdma_restrack_root *rt;
 	int i;
 
-	dev->res = kzalloc(sizeof(*rt), GFP_KERNEL);
+	dev->res = kcalloc(RDMA_RESTRACK_MAX, sizeof(*rt), GFP_KERNEL);
 	if (!dev->res)
 		return -ENOMEM;
 
 	rt = dev->res;
 
-	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++)
-		xa_init_flags(&rt->xa[i], XA_FLAGS_ALLOC);
-	init_rwsem(&rt->rwsem);
+	for (i = 0; i < RDMA_RESTRACK_MAX; i++)
+		xa_init_flags(&rt[i].xa, XA_FLAGS_ALLOC);
 
 	return 0;
 }
@@ -88,7 +86,7 @@ void rdma_restrack_clean(struct ib_device *dev)
 	int i;
 
 	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {
-		struct xarray *xa = &dev->res->xa[i];
+		struct xarray *xa = &dev->res[i].xa;
 
 		if (!xa_empty(xa)) {
 			unsigned long index;
@@ -134,19 +132,19 @@ void rdma_restrack_clean(struct ib_device *dev)
 int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 			struct pid_namespace *ns)
 {
-	struct xarray *xa = &dev->res->xa[type];
+	struct rdma_restrack_root *rt = &dev->res[type];
 	struct rdma_restrack_entry *e;
-	unsigned long index = 0;
+	XA_STATE(xas, &rt->xa, 0);
 	u32 cnt = 0;
 
-	down_read(&dev->res->rwsem);
-	xa_for_each(xa, index, e) {
+	xa_lock(&rt->xa);
+	xas_for_each(&xas, e, U32_MAX) {
 		if (ns == &init_pid_ns ||
 		    (!rdma_is_kernel_res(e) &&
 		     ns == task_active_pid_ns(e->task)))
 			cnt++;
 	}
-	up_read(&dev->res->rwsem);
+	xa_unlock(&rt->xa);
 	return cnt;
 }
 EXPORT_SYMBOL(rdma_restrack_count);
@@ -218,18 +216,16 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
 	struct rdma_restrack_root *rt;
-	struct xarray *xa;
 	int ret;
 
 	if (!dev)
 		return;
 
-	rt = dev->res;
-	xa = &dev->res->xa[res->type];
+	rt = &dev->res[res->type];
 
 	kref_init(&res->kref);
 	init_completion(&res->comp);
-	ret = rt_xa_alloc_cyclic(xa, &res->id, res, &rt->next_id[res->type]);
+	ret = rt_xa_alloc_cyclic(&rt->xa, &res->id, res, &rt->next_id);
 	if (!ret)
 		res->valid = true;
 }
@@ -283,14 +279,14 @@ struct rdma_restrack_entry *
 rdma_restrack_get_byid(struct ib_device *dev,
 		       enum rdma_restrack_type type, u32 id)
 {
-	struct xarray *xa = &dev->res->xa[type];
+	struct rdma_restrack_root *rt = &dev->res[type];
 	struct rdma_restrack_entry *res;
 
-	down_read(&dev->res->rwsem);
-	res = xa_load(xa, id);
+	xa_lock(&rt->xa);
+	res = xa_load(&rt->xa, id);
 	if (!res || !rdma_restrack_get(res))
 		res = ERR_PTR(-ENOENT);
-	up_read(&dev->res->rwsem);
+	xa_unlock(&rt->xa);
 
 	return res;
 }
@@ -312,33 +308,22 @@ EXPORT_SYMBOL(rdma_restrack_put);
 
 void rdma_restrack_del(struct rdma_restrack_entry *res)
 {
-	struct ib_device *dev = res_to_dev(res);
-	struct xarray *xa;
+	struct rdma_restrack_entry *old;
+	struct rdma_restrack_root *rt;
+	struct ib_device *dev;
 
 	if (!res->valid)
 		goto out;
 
-	/*
-	 * All objects except CM_ID set valid device immediately
-	 * after new object is created, it means that for not valid
-	 * objects will still have "dev".
-	 *
-	 * It is not the case for CM_ID, newly created object has
-	 * this field set to NULL and it is set in _cma_attach_to_dev()
-	 * only.
-	 *
-	 * Because we don't want to add any conditions on call
-	 * to rdma_restrack_del(), the check below protects from
-	 * NULL-dereference.
-	 */
-	if (!dev)
+	dev = res_to_dev(res);
+	if (WARN_ON(!dev))
 		return;
 
-	xa = &dev->res->xa[res->type];
-	down_write(&dev->res->rwsem);
-	xa_erase(xa, res->id);
+	rt = &dev->res[res->type];
+
+	old = xa_erase(&rt->xa, res->id);
+	WARN_ON(old != res);
 	res->valid = false;
-	up_write(&dev->res->rwsem);
 
 	rdma_restrack_put(res);
 	wait_for_completion(&res->comp);

commit 41eda65c6100930d95bb854a0114f3544593070c
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:47 2019 +0200

    RDMA/restrack: Hide restrack DB from IB/core
    
    There is no need to expose internals of restrack DB to IB/core.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 076ef6475df8..6a4b76c66bcb 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -9,8 +9,10 @@
 #include <linux/mutex.h>
 #include <linux/sched/task.h>
 #include <linux/pid_namespace.h>
+#include <linux/rwsem.h>
 
 #include "cma_priv.h"
+#include "restrack.h"
 
 static int rt_xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
 			      u32 *next)
@@ -35,18 +37,27 @@ static int rt_xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
 }
 
 /**
- * rdma_restrack_init() - initialize resource tracking
+ * rdma_restrack_init() - initialize and allocate resource tracking
  * @dev:  IB device
+ *
+ * Return: 0 on success
  */
-void rdma_restrack_init(struct ib_device *dev)
+int rdma_restrack_init(struct ib_device *dev)
 {
-	struct rdma_restrack_root *res = &dev->res;
+	struct rdma_restrack_root *rt;
 	int i;
 
+	dev->res = kzalloc(sizeof(*rt), GFP_KERNEL);
+	if (!dev->res)
+		return -ENOMEM;
+
+	rt = dev->res;
+
 	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++)
-		xa_init_flags(&res->xa[i], XA_FLAGS_ALLOC);
+		xa_init_flags(&rt->xa[i], XA_FLAGS_ALLOC);
+	init_rwsem(&rt->rwsem);
 
-	init_rwsem(&res->rwsem);
+	return 0;
 }
 
 static const char *type2str(enum rdma_restrack_type type)
@@ -69,7 +80,7 @@ static const char *type2str(enum rdma_restrack_type type)
  */
 void rdma_restrack_clean(struct ib_device *dev)
 {
-	struct rdma_restrack_root *res = &dev->res;
+	struct rdma_restrack_root *rt = dev->res;
 	struct rdma_restrack_entry *e;
 	char buf[TASK_COMM_LEN];
 	bool found = false;
@@ -77,14 +88,16 @@ void rdma_restrack_clean(struct ib_device *dev)
 	int i;
 
 	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {
-		if (!xa_empty(&res->xa[i])) {
+		struct xarray *xa = &dev->res->xa[i];
+
+		if (!xa_empty(xa)) {
 			unsigned long index;
 
 			if (!found) {
 				pr_err("restrack: %s", CUT_HERE);
 				dev_err(&dev->dev, "BUG: RESTRACK detected leak of resources\n");
 			}
-			xa_for_each(&res->xa[i], index, e) {
+			xa_for_each(xa, index, e) {
 				if (rdma_is_kernel_res(e)) {
 					owner = e->kern_name;
 				} else {
@@ -104,10 +117,12 @@ void rdma_restrack_clean(struct ib_device *dev)
 			}
 			found = true;
 		}
-		xa_destroy(&res->xa[i]);
+		xa_destroy(xa);
 	}
 	if (found)
 		pr_err("restrack: %s", CUT_HERE);
+
+	kfree(rt);
 }
 
 /**
@@ -119,19 +134,19 @@ void rdma_restrack_clean(struct ib_device *dev)
 int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 			struct pid_namespace *ns)
 {
-	struct rdma_restrack_root *res = &dev->res;
+	struct xarray *xa = &dev->res->xa[type];
 	struct rdma_restrack_entry *e;
 	unsigned long index = 0;
 	u32 cnt = 0;
 
-	down_read(&res->rwsem);
-	xa_for_each(&res->xa[type], index, e) {
+	down_read(&dev->res->rwsem);
+	xa_for_each(xa, index, e) {
 		if (ns == &init_pid_ns ||
 		    (!rdma_is_kernel_res(e) &&
 		     ns == task_active_pid_ns(e->task)))
 			cnt++;
 	}
-	up_read(&res->rwsem);
+	up_read(&dev->res->rwsem);
 	return cnt;
 }
 EXPORT_SYMBOL(rdma_restrack_count);
@@ -202,17 +217,19 @@ EXPORT_SYMBOL(rdma_restrack_set_task);
 static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
+	struct rdma_restrack_root *rt;
+	struct xarray *xa;
 	int ret;
 
 	if (!dev)
 		return;
 
+	rt = dev->res;
+	xa = &dev->res->xa[res->type];
+
 	kref_init(&res->kref);
 	init_completion(&res->comp);
-
-	ret = rt_xa_alloc_cyclic(&dev->res.xa[res->type], &res->id, res,
-				 &dev->res.next_id[res->type]);
-
+	ret = rt_xa_alloc_cyclic(xa, &res->id, res, &rt->next_id[res->type]);
 	if (!ret)
 		res->valid = true;
 }
@@ -266,14 +283,14 @@ struct rdma_restrack_entry *
 rdma_restrack_get_byid(struct ib_device *dev,
 		       enum rdma_restrack_type type, u32 id)
 {
-	struct rdma_restrack_root *rt = &dev->res;
+	struct xarray *xa = &dev->res->xa[type];
 	struct rdma_restrack_entry *res;
 
-	down_read(&dev->res.rwsem);
-	res = xa_load(&rt->xa[type], id);
+	down_read(&dev->res->rwsem);
+	res = xa_load(xa, id);
 	if (!res || !rdma_restrack_get(res))
 		res = ERR_PTR(-ENOENT);
-	up_read(&dev->res.rwsem);
+	up_read(&dev->res->rwsem);
 
 	return res;
 }
@@ -295,19 +312,33 @@ EXPORT_SYMBOL(rdma_restrack_put);
 
 void rdma_restrack_del(struct rdma_restrack_entry *res)
 {
-	struct ib_device *dev;
+	struct ib_device *dev = res_to_dev(res);
+	struct xarray *xa;
 
 	if (!res->valid)
 		goto out;
 
-	dev = res_to_dev(res);
+	/*
+	 * All objects except CM_ID set valid device immediately
+	 * after new object is created, it means that for not valid
+	 * objects will still have "dev".
+	 *
+	 * It is not the case for CM_ID, newly created object has
+	 * this field set to NULL and it is set in _cma_attach_to_dev()
+	 * only.
+	 *
+	 * Because we don't want to add any conditions on call
+	 * to rdma_restrack_del(), the check below protects from
+	 * NULL-dereference.
+	 */
 	if (!dev)
 		return;
 
-	down_write(&dev->res.rwsem);
-	xa_erase(&dev->res.xa[res->type], res->id);
+	xa = &dev->res->xa[res->type];
+	down_write(&dev->res->rwsem);
+	xa_erase(xa, res->id);
 	res->valid = false;
-	up_write(&dev->res.rwsem);
+	up_write(&dev->res->rwsem);
 
 	rdma_restrack_put(res);
 	wait_for_completion(&res->comp);

commit 48118527186fb255461ebf3685ab0f1c2680bd9c
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:46 2019 +0200

    RDMA/restrack: Reduce scope of synchronization lock while updating DB
    
    XArray uses internal lock for updates to XArray. This means that our
    external RW lock is needed to ensure that entry is not deleted while we
    are performing iteration over list.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index ac97167da81c..076ef6475df8 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -210,13 +210,11 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 	kref_init(&res->kref);
 	init_completion(&res->comp);
 
-	down_write(&dev->res.rwsem);
 	ret = rt_xa_alloc_cyclic(&dev->res.xa[res->type], &res->id, res,
 				 &dev->res.next_id[res->type]);
 
 	if (!ret)
 		res->valid = true;
-	up_write(&dev->res.rwsem);
 }
 
 /**

commit 18c4c66f76d99df89ad682ba25bafb9227e8ec30
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:44 2019 +0200

    RDMA/restrack: Translate from ID to restrack object
    
    Add new general helper to get restrack entry given by ID and their
    respective type.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index b4f302811858..ac97167da81c 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -256,6 +256,31 @@ int __must_check rdma_restrack_get(struct rdma_restrack_entry *res)
 }
 EXPORT_SYMBOL(rdma_restrack_get);
 
+/**
+ * rdma_restrack_get_byid() - translate from ID to restrack object
+ * @dev: IB device
+ * @type: resource track type
+ * @id: ID to take a look
+ *
+ * Return: Pointer to restrack entry or -ENOENT in case of error.
+ */
+struct rdma_restrack_entry *
+rdma_restrack_get_byid(struct ib_device *dev,
+		       enum rdma_restrack_type type, u32 id)
+{
+	struct rdma_restrack_root *rt = &dev->res;
+	struct rdma_restrack_entry *res;
+
+	down_read(&dev->res.rwsem);
+	res = xa_load(&rt->xa[type], id);
+	if (!res || !rdma_restrack_get(res))
+		res = ERR_PTR(-ENOENT);
+	up_read(&dev->res.rwsem);
+
+	return res;
+}
+EXPORT_SYMBOL(rdma_restrack_get_byid);
+
 static void restrack_release(struct kref *kref)
 {
 	struct rdma_restrack_entry *res;

commit fd47c2f99f04249d1ba82c422d1818dcbe193908
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 18 22:25:43 2019 +0200

    RDMA/restrack: Convert internal DB from hash to XArray
    
    The additions of .doit callbacks posses new access pattern to the resource
    entries by some user visible index. Back then, the legacy DB was
    implemented as hash because per-index access wasn't needed and XArray
    wasn't accepted yet.
    
    Acceptance of XArray together with per-index access requires the refresh
    of DB implementation.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index f80b37d437ac..b4f302811858 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -12,6 +12,28 @@
 
 #include "cma_priv.h"
 
+static int rt_xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry,
+			      u32 *next)
+{
+	int err;
+
+	*id = *next;
+	if (*next == U32_MAX)
+		*id = 0;
+
+	xa_lock(xa);
+	err = __xa_alloc(xa, id, U32_MAX, entry, GFP_KERNEL);
+	if (err && *next != U32_MAX) {
+		*id = 0;
+		err = __xa_alloc(xa, id, *next, entry, GFP_KERNEL);
+	}
+
+	if (!err)
+		*next = *id + 1;
+	xa_unlock(xa);
+	return err;
+}
+
 /**
  * rdma_restrack_init() - initialize resource tracking
  * @dev:  IB device
@@ -19,6 +41,10 @@
 void rdma_restrack_init(struct ib_device *dev)
 {
 	struct rdma_restrack_root *res = &dev->res;
+	int i;
+
+	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++)
+		xa_init_flags(&res->xa[i], XA_FLAGS_ALLOC);
 
 	init_rwsem(&res->rwsem);
 }
@@ -46,33 +72,42 @@ void rdma_restrack_clean(struct ib_device *dev)
 	struct rdma_restrack_root *res = &dev->res;
 	struct rdma_restrack_entry *e;
 	char buf[TASK_COMM_LEN];
+	bool found = false;
 	const char *owner;
-	int bkt;
-
-	if (hash_empty(res->hash))
-		return;
-
-	dev = container_of(res, struct ib_device, res);
-	pr_err("restrack: %s", CUT_HERE);
-	dev_err(&dev->dev, "BUG: RESTRACK detected leak of resources\n");
-	hash_for_each(res->hash, bkt, e, node) {
-		if (rdma_is_kernel_res(e)) {
-			owner = e->kern_name;
-		} else {
-			/*
-			 * There is no need to call get_task_struct here,
-			 * because we can be here only if there are more
-			 * get_task_struct() call than put_task_struct().
-			 */
-			get_task_comm(buf, e->task);
-			owner = buf;
+	int i;
+
+	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {
+		if (!xa_empty(&res->xa[i])) {
+			unsigned long index;
+
+			if (!found) {
+				pr_err("restrack: %s", CUT_HERE);
+				dev_err(&dev->dev, "BUG: RESTRACK detected leak of resources\n");
+			}
+			xa_for_each(&res->xa[i], index, e) {
+				if (rdma_is_kernel_res(e)) {
+					owner = e->kern_name;
+				} else {
+					/*
+					 * There is no need to call get_task_struct here,
+					 * because we can be here only if there are more
+					 * get_task_struct() call than put_task_struct().
+					 */
+					get_task_comm(buf, e->task);
+					owner = buf;
+				}
+
+				pr_err("restrack: %s %s object allocated by %s is not freed\n",
+				       rdma_is_kernel_res(e) ? "Kernel" :
+							       "User",
+				       type2str(e->type), owner);
+			}
+			found = true;
 		}
-
-		pr_err("restrack: %s %s object allocated by %s is not freed\n",
-		       rdma_is_kernel_res(e) ? "Kernel" : "User",
-		       type2str(e->type), owner);
+		xa_destroy(&res->xa[i]);
 	}
-	pr_err("restrack: %s", CUT_HERE);
+	if (found)
+		pr_err("restrack: %s", CUT_HERE);
 }
 
 /**
@@ -86,10 +121,11 @@ int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 {
 	struct rdma_restrack_root *res = &dev->res;
 	struct rdma_restrack_entry *e;
+	unsigned long index = 0;
 	u32 cnt = 0;
 
 	down_read(&res->rwsem);
-	hash_for_each_possible(res->hash, e, node, type) {
+	xa_for_each(&res->xa[type], index, e) {
 		if (ns == &init_pid_ns ||
 		    (!rdma_is_kernel_res(e) &&
 		     ns == task_active_pid_ns(e->task)))
@@ -166,16 +202,20 @@ EXPORT_SYMBOL(rdma_restrack_set_task);
 static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
+	int ret;
 
 	if (!dev)
 		return;
 
 	kref_init(&res->kref);
 	init_completion(&res->comp);
-	res->valid = true;
 
 	down_write(&dev->res.rwsem);
-	hash_add(dev->res.hash, &res->node, res->type);
+	ret = rt_xa_alloc_cyclic(&dev->res.xa[res->type], &res->id, res,
+				 &dev->res.next_id[res->type]);
+
+	if (!ret)
+		res->valid = true;
 	up_write(&dev->res.rwsem);
 }
 
@@ -241,15 +281,14 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	if (!dev)
 		return;
 
-	rdma_restrack_put(res);
-
-	wait_for_completion(&res->comp);
-
 	down_write(&dev->res.rwsem);
-	hash_del(&res->node);
+	xa_erase(&dev->res.xa[res->type], res->id);
 	res->valid = false;
 	up_write(&dev->res.rwsem);
 
+	rdma_restrack_put(res);
+	wait_for_completion(&res->comp);
+
 out:
 	if (res->task) {
 		put_task_struct(res->task);

commit 02da37509705d3ba6a58fe4799a0caf6b4baecb0
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Wed Jan 30 12:49:02 2019 +0200

    RDMA/core: Use the ops infrastructure to keep all callbacks in one place
    
    As preparation to hide rdma_restrack_root, refactor the code to use the
    ops structure instead of a special callback which is hidden in
    rdma_restrack_root.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index bd7770ed4174..f80b37d437ac 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -12,12 +12,6 @@
 
 #include "cma_priv.h"
 
-static int fill_res_noop(struct sk_buff *msg,
-			 struct rdma_restrack_entry *entry)
-{
-	return 0;
-}
-
 /**
  * rdma_restrack_init() - initialize resource tracking
  * @dev:  IB device
@@ -27,7 +21,6 @@ void rdma_restrack_init(struct ib_device *dev)
 	struct rdma_restrack_root *res = &dev->res;
 
 	init_rwsem(&res->rwsem);
-	res->fill_res_entry = fill_res_noop;
 }
 
 static const char *type2str(enum rdma_restrack_type type)

commit 5e458d3f899ef6158d59b6909b8df9348868ccc4
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Wed Jan 30 12:49:05 2019 +0200

    RDMA/restrack: Refactor user/kernel restrack additions
    
    Since we already know if we are user/kernel before calling restrack_add,
    move type dependent code into the callers to make the flow more readable.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 0ade3da0a5c7..bd7770ed4174 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -177,17 +177,6 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 	if (!dev)
 		return;
 
-	if (res->type != RDMA_RESTRACK_CM_ID || rdma_is_kernel_res(res))
-		res->task = NULL;
-
-	if (!rdma_is_kernel_res(res)) {
-		if (!res->task)
-			rdma_restrack_set_task(res, NULL);
-		res->kern_name = NULL;
-	} else {
-		set_kern_name(res);
-	}
-
 	kref_init(&res->kref);
 	init_completion(&res->comp);
 	res->valid = true;
@@ -203,6 +192,8 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
  */
 void rdma_restrack_kadd(struct rdma_restrack_entry *res)
 {
+	res->task = NULL;
+	set_kern_name(res);
 	res->user = false;
 	rdma_restrack_add(res);
 }
@@ -214,6 +205,13 @@ EXPORT_SYMBOL(rdma_restrack_kadd);
  */
 void rdma_restrack_uadd(struct rdma_restrack_entry *res)
 {
+	if (res->type != RDMA_RESTRACK_CM_ID)
+		res->task = NULL;
+
+	if (!res->task)
+		rdma_restrack_set_task(res, NULL);
+	res->kern_name = NULL;
+
 	res->user = true;
 	rdma_restrack_add(res);
 }

commit 0ad699c0edc97a864177679dd67f2ccd73b07cb7
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Wed Jan 30 12:48:58 2019 +0200

    RDMA/core: Simplify restrack interface
    
    In the current implementation, we have one restrack root per-device and
    all users are simply providing it directly. Let's simplify the interface
    and have callers provide the ib_device and internally access the
    restrack_root.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 46a5c553c624..0ade3da0a5c7 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -18,8 +18,14 @@ static int fill_res_noop(struct sk_buff *msg,
 	return 0;
 }
 
-void rdma_restrack_init(struct rdma_restrack_root *res)
+/**
+ * rdma_restrack_init() - initialize resource tracking
+ * @dev:  IB device
+ */
+void rdma_restrack_init(struct ib_device *dev)
 {
+	struct rdma_restrack_root *res = &dev->res;
+
 	init_rwsem(&res->rwsem);
 	res->fill_res_entry = fill_res_noop;
 }
@@ -38,11 +44,15 @@ static const char *type2str(enum rdma_restrack_type type)
 	return names[type];
 };
 
-void rdma_restrack_clean(struct rdma_restrack_root *res)
+/**
+ * rdma_restrack_clean() - clean resource tracking
+ * @dev:  IB device
+ */
+void rdma_restrack_clean(struct ib_device *dev)
 {
+	struct rdma_restrack_root *res = &dev->res;
 	struct rdma_restrack_entry *e;
 	char buf[TASK_COMM_LEN];
-	struct ib_device *dev;
 	const char *owner;
 	int bkt;
 
@@ -72,10 +82,16 @@ void rdma_restrack_clean(struct rdma_restrack_root *res)
 	pr_err("restrack: %s", CUT_HERE);
 }
 
-int rdma_restrack_count(struct rdma_restrack_root *res,
-			enum rdma_restrack_type type,
+/**
+ * rdma_restrack_count() - the current usage of specific object
+ * @dev:  IB device
+ * @type: actual type of object to operate
+ * @ns:   PID namespace
+ */
+int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 			struct pid_namespace *ns)
 {
+	struct rdma_restrack_root *res = &dev->res;
 	struct rdma_restrack_entry *e;
 	u32 cnt = 0;
 

commit af8d70375d562034d375ca7a8b08997422223258
Author: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
Date:   Mon Dec 17 17:15:16 2018 +0200

    RDMA/restrack: Resource-tracker should not use uobject pointers
    
    Having uobject pointer embedded in ib core objects is not aligned with a
    future shared ib_x model. The resource tracker only does this to keep
    track of user/kernel objects - track this directly instead.
    
    Signed-off-by: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 3dd316159f5f..46a5c553c624 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -139,27 +139,6 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 	}
 }
 
-static bool res_is_user(struct rdma_restrack_entry *res)
-{
-	switch (res->type) {
-	case RDMA_RESTRACK_PD:
-		return container_of(res, struct ib_pd, res)->uobject;
-	case RDMA_RESTRACK_CQ:
-		return container_of(res, struct ib_cq, res)->uobject;
-	case RDMA_RESTRACK_QP:
-		return container_of(res, struct ib_qp, res)->uobject;
-	case RDMA_RESTRACK_CM_ID:
-		return !res->kern_name;
-	case RDMA_RESTRACK_MR:
-		return container_of(res, struct ib_mr, res)->pd->uobject;
-	case RDMA_RESTRACK_CTX:
-		return true;
-	default:
-		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
-		return false;
-	}
-}
-
 void rdma_restrack_set_task(struct rdma_restrack_entry *res,
 			    const char *caller)
 {
@@ -175,17 +154,17 @@ void rdma_restrack_set_task(struct rdma_restrack_entry *res,
 }
 EXPORT_SYMBOL(rdma_restrack_set_task);
 
-void rdma_restrack_add(struct rdma_restrack_entry *res)
+static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
 
 	if (!dev)
 		return;
 
-	if (res->type != RDMA_RESTRACK_CM_ID || !res_is_user(res))
+	if (res->type != RDMA_RESTRACK_CM_ID || rdma_is_kernel_res(res))
 		res->task = NULL;
 
-	if (res_is_user(res)) {
+	if (!rdma_is_kernel_res(res)) {
 		if (!res->task)
 			rdma_restrack_set_task(res, NULL);
 		res->kern_name = NULL;
@@ -201,7 +180,28 @@ void rdma_restrack_add(struct rdma_restrack_entry *res)
 	hash_add(dev->res.hash, &res->node, res->type);
 	up_write(&dev->res.rwsem);
 }
-EXPORT_SYMBOL(rdma_restrack_add);
+
+/**
+ * rdma_restrack_kadd() - add kernel object to the reource tracking database
+ * @res:  resource entry
+ */
+void rdma_restrack_kadd(struct rdma_restrack_entry *res)
+{
+	res->user = false;
+	rdma_restrack_add(res);
+}
+EXPORT_SYMBOL(rdma_restrack_kadd);
+
+/**
+ * rdma_restrack_uadd() - add user object to the reource tracking database
+ * @res:  resource entry
+ */
+void rdma_restrack_uadd(struct rdma_restrack_entry *res)
+{
+	res->user = true;
+	rdma_restrack_add(res);
+}
+EXPORT_SYMBOL(rdma_restrack_uadd);
 
 int __must_check rdma_restrack_get(struct rdma_restrack_entry *res)
 {

commit 606152107bbdbc0e21f25e0d15ef2787a4ab90fd
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Wed Nov 28 13:16:43 2018 +0200

    RDMA/restrack: Track ucontext
    
    Add ability to track allocated ib_ucontext, which are limited
    resource and worth to be visible by users.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 06d8657ce583..3dd316159f5f 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -32,6 +32,7 @@ static const char *type2str(enum rdma_restrack_type type)
 		[RDMA_RESTRACK_QP] = "QP",
 		[RDMA_RESTRACK_CM_ID] = "CM_ID",
 		[RDMA_RESTRACK_MR] = "MR",
+		[RDMA_RESTRACK_CTX] = "CTX",
 	};
 
 	return names[type];
@@ -130,6 +131,8 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 				    res)->id.device;
 	case RDMA_RESTRACK_MR:
 		return container_of(res, struct ib_mr, res)->device;
+	case RDMA_RESTRACK_CTX:
+		return container_of(res, struct ib_ucontext, res)->device;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return NULL;
@@ -149,6 +152,8 @@ static bool res_is_user(struct rdma_restrack_entry *res)
 		return !res->kern_name;
 	case RDMA_RESTRACK_MR:
 		return container_of(res, struct ib_mr, res)->pd->uobject;
+	case RDMA_RESTRACK_CTX:
+		return true;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return false;

commit fe9bc1644918aa1d02a889b4ca788bfb67f90816
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Thu Oct 11 22:10:10 2018 +0300

    RDMA/restrack: Protect from reentry to resource return path
    
    Nullify the resource task struct pointer to ensure that subsequent calls
    won't try to release task_struct again.
    
    ------------[ cut here ]------------
    ODEBUG: free active (active state 1) object type: rcu_head hint:
    (null)
    WARNING: CPU: 0 PID: 6048 at lib/debugobjects.c:329
    debug_print_object+0x16a/0x210 lib/debugobjects.c:326
    Kernel panic - not syncing: panic_on_warn set ...
    
    CPU: 0 PID: 6048 Comm: syz-executor022 Not tainted
    4.19.0-rc7-next-20181008+ #89
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0x244/0x3ab lib/dump_stack.c:113
      panic+0x238/0x4e7 kernel/panic.c:184
      __warn.cold.8+0x163/0x1ba kernel/panic.c:536
      report_bug+0x254/0x2d0 lib/bug.c:186
      fixup_bug arch/x86/kernel/traps.c:178 [inline]
      do_error_trap+0x11b/0x200 arch/x86/kernel/traps.c:271
      do_invalid_op+0x36/0x40 arch/x86/kernel/traps.c:290
      invalid_op+0x14/0x20 arch/x86/entry/entry_64.S:969
    RIP: 0010:debug_print_object+0x16a/0x210 lib/debugobjects.c:326
    Code: 41 88 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 92 00 00 00 48 8b 14
    dd
    60 02 41 88 4c 89 fe 48 c7 c7 00 f8 40 88 e8 36 2f b4 fd <0f> 0b 83 05
    a9
    f4 5e 06 01 48 83 c4 18 5b 41 5c 41 5d 41 5e 41 5f
    RSP: 0018:ffff8801d8c3eda8 EFLAGS: 00010086
    RAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: ffffffff8164d235 RDI: 0000000000000005
    RBP: ffff8801d8c3ede8 R08: ffff8801d70aa280 R09: ffffed003b5c3eda
    R10: ffffed003b5c3eda R11: ffff8801dae1f6d7 R12: 0000000000000001
    R13: ffffffff8939a760 R14: 0000000000000000 R15: ffffffff8840fca0
      __debug_check_no_obj_freed lib/debugobjects.c:786 [inline]
      debug_check_no_obj_freed+0x3ae/0x58d lib/debugobjects.c:818
      kmem_cache_free+0x202/0x290 mm/slab.c:3759
      free_task_struct kernel/fork.c:163 [inline]
      free_task+0x16e/0x1f0 kernel/fork.c:457
      __put_task_struct+0x2e6/0x620 kernel/fork.c:730
      put_task_struct include/linux/sched/task.h:96 [inline]
      finish_task_switch+0x66c/0x900 kernel/sched/core.c:2715
      context_switch kernel/sched/core.c:2834 [inline]
      __schedule+0x8d7/0x21d0 kernel/sched/core.c:3480
      schedule+0xfe/0x460 kernel/sched/core.c:3524
      freezable_schedule include/linux/freezer.h:172 [inline]
      futex_wait_queue_me+0x3f9/0x840 kernel/futex.c:2530
      futex_wait+0x45c/0xa50 kernel/futex.c:2645
      do_futex+0x31a/0x26d0 kernel/futex.c:3528
      __do_sys_futex kernel/futex.c:3589 [inline]
      __se_sys_futex kernel/futex.c:3557 [inline]
      __x64_sys_futex+0x472/0x6a0 kernel/futex.c:3557
      do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x446549
    Code: e8 2c b3 02 00 48 83 c4 18 c3 0f 1f 80 00 00 00 00 48 89 f8 48 89 f7
    48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff
    ff 0f 83 2b 09 fc ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f3a998f5da8 EFLAGS: 00000246 ORIG_RAX: 00000000000000ca
    RAX: ffffffffffffffda RBX: 00000000006dbc38 RCX: 0000000000446549
    RDX: 0000000000000000 RSI: 0000000000000080 RDI: 00000000006dbc38
    RBP: 00000000006dbc30 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00000000006dbc3c
    R13: 2f646e6162696e69 R14: 666e692f7665642f R15: 00000000006dbd2c
    Kernel Offset: disabled
    
    Reported-by: syzbot+71aff6ea121ffefc280f@syzkaller.appspotmail.com
    Fixes: ed7a01fd3fd7 ("RDMA/restrack: Release task struct which was hold by CM_ID object")
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 16b5f9949770..06d8657ce583 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -239,7 +239,9 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	up_write(&dev->res.rwsem);
 
 out:
-	if (res->task)
+	if (res->task) {
 		put_task_struct(res->task);
+		res->task = NULL;
+	}
 }
 EXPORT_SYMBOL(rdma_restrack_del);

commit ed7a01fd3fd77f40b4ef2562b966a5decd8928d2
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Tue Oct 2 11:48:03 2018 +0300

    RDMA/restrack: Release task struct which was hold by CM_ID object
    
    Tracking CM_ID resource is performed in two stages: creation of cm_id
    and connecting it to the cma_dev. It is needed because rdma-cm protocol
    exports two separate user-visible calls rdma_create_id and rdma_accept.
    
    At the time of CM_ID creation, the real owner of that object is unknown
    yet and we need to grab task_struct. This task_struct is released or
    reassigned in attach phase later on. but call to rdma_destroy_id left
    this task_struct unreleased.
    
    Such separation is unique to CM_ID and other restrack objects initialize
    in one shot. It means that it is safe to use "res->valid" check to catch
    unfinished CM_ID flow and release task_struct for that object.
    
    Fixes: 00313983cda6 ("RDMA/nldev: provide detailed CM_ID information")
    Reported-by: Artemy Kovalyov <artemyko@mellanox.com>
    Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
    Reviewed-by: Yossi Itigin <yosefe@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 035af568ba64..16b5f9949770 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -223,7 +223,7 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	struct ib_device *dev;
 
 	if (!res->valid)
-		return;
+		goto out;
 
 	dev = res_to_dev(res);
 	if (!dev)
@@ -236,8 +236,10 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	down_write(&dev->res.rwsem);
 	hash_del(&res->node);
 	res->valid = false;
+	up_write(&dev->res.rwsem);
+
+out:
 	if (res->task)
 		put_task_struct(res->task);
-	up_write(&dev->res.rwsem);
 }
 EXPORT_SYMBOL(rdma_restrack_del);

commit 2165fc264079ecb7fbfa5e8b330a92eb3f0fcbe1
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Tue Oct 2 11:48:02 2018 +0300

    RDMA/restrack: Consolidate task name updates in one place
    
    Unify task update and kernel name set in one place.
    
    Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
    Reviewed-by: Yossi Itigin <yosefe@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index b02d43988e16..035af568ba64 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -156,12 +156,17 @@ static bool res_is_user(struct rdma_restrack_entry *res)
 }
 
 void rdma_restrack_set_task(struct rdma_restrack_entry *res,
-			    struct task_struct *task)
+			    const char *caller)
 {
+	if (caller) {
+		res->kern_name = caller;
+		return;
+	}
+
 	if (res->task)
 		put_task_struct(res->task);
-	get_task_struct(task);
-	res->task = task;
+	get_task_struct(current);
+	res->task = current;
 }
 EXPORT_SYMBOL(rdma_restrack_set_task);
 
@@ -177,7 +182,7 @@ void rdma_restrack_add(struct rdma_restrack_entry *res)
 
 	if (res_is_user(res)) {
 		if (!res->task)
-			rdma_restrack_set_task(res, current);
+			rdma_restrack_set_task(res, NULL);
 		res->kern_name = NULL;
 	} else {
 		set_kern_name(res);

commit 363ad35577de3a73cf97006ec5f00fccaee73172
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Tue Oct 2 11:48:01 2018 +0300

    RDMA/restrack: Un-inline set task implementation
    
    Prepare rdma_restrack_set_task() call to accommodate more
    code by moving its implementation from *.h to *.c.
    
    Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
    Reviewed-by: Yossi Itigin <yosefe@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index bcc693fffd4c..b02d43988e16 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -155,6 +155,16 @@ static bool res_is_user(struct rdma_restrack_entry *res)
 	}
 }
 
+void rdma_restrack_set_task(struct rdma_restrack_entry *res,
+			    struct task_struct *task)
+{
+	if (res->task)
+		put_task_struct(res->task);
+	get_task_struct(task);
+	res->task = task;
+}
+EXPORT_SYMBOL(rdma_restrack_set_task);
+
 void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);

commit 43c7c851b9bce9e6091f2c882871a3b388aa38c3
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Thu Sep 20 16:42:23 2018 -0600

    RDMA/core: Use dev_err/dbg/etc instead of pr_* + ibdev->name
    
    Any messages related to a device should be printed with the dev_*
    formatters. This provides greater consistency for the user.
    
    The core does not set pr_fmt so this has no significant change.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 3b7fa0ccaa08..bcc693fffd4c 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -50,8 +50,7 @@ void rdma_restrack_clean(struct rdma_restrack_root *res)
 
 	dev = container_of(res, struct ib_device, res);
 	pr_err("restrack: %s", CUT_HERE);
-	pr_err("restrack: BUG: RESTRACK detected leak of resources on %s\n",
-	       dev->name);
+	dev_err(&dev->dev, "BUG: RESTRACK detected leak of resources\n");
 	hash_for_each(res->hash, bkt, e, node) {
 		if (rdma_is_kernel_res(e)) {
 			owner = e->kern_name;

commit 33edc3b2db8735cafa9d72f8510dc6bb394ddec8
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Tue Jun 5 07:48:08 2018 +0300

    RDMA/restrack: Change SPDX tag to properly reflect license
    
    Resource tracking is supposed to be dual licensed: GPL-2.0 and
    OpenIB, but the SPDX tag was not compliant to it. Update the tag to
    properly reflect license.
    
    Fixes: 02d8883f520e ("RDMA/restrack: Add general infrastructure to track RDMA resources")
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 172b517dc7b9..3b7fa0ccaa08 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
 /*
  * Copyright (c) 2017-2018 Mellanox Technologies. All rights reserved.
  */

commit da5c8507821573b8ed6e3f47e009f273493ffaf7
Author: Steve Wise <swise@opengridcomputing.com>
Date:   Thu May 3 08:41:30 2018 -0700

    RDMA/nldev: add driver-specific resource tracking
    
    Each driver can register a "fill entry" function with the restrack core.
    This function will be called when filling out a resource, allowing the
    driver to add driver-specific details.  The details consist of a
    nltable of nested attributes, that are in the form of <key, [print-type],
    value> tuples.  Both key and value attributes are mandatory.  The key
    nlattr must be a string, and the value nlattr can be one of the driver
    attributes that are generic, but typed, allowing the attributes to be
    validated.  Currently the driver nlattr types include string, s32,
    u32, s64, and u64.  The print-type nlattr allows a driver to specify
    an alternative display format for user tools displaying the attribute.
    For example, a u32 attribute will default to "%u", but a print-type
    attribute can be included for it to be displayed in hex.  This allows
    the user tool to print the number in the format desired by the driver
    driver.
    
    More attrs can be defined as they become needed by drivers.
    
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index efddd13e3edb..172b517dc7b9 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -12,9 +12,16 @@
 
 #include "cma_priv.h"
 
+static int fill_res_noop(struct sk_buff *msg,
+			 struct rdma_restrack_entry *entry)
+{
+	return 0;
+}
+
 void rdma_restrack_init(struct rdma_restrack_root *res)
 {
 	init_rwsem(&res->rwsem);
+	res->fill_res_entry = fill_res_noop;
 }
 
 static const char *type2str(enum rdma_restrack_type type)

commit 03286030ac0420c759fa25f5b976e40293bccaaf
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Wed Mar 21 17:12:42 2018 +0200

    RDMA/restrack: Remove ambiguity in resource track clean logic
    
    The restrack clean routine had simple, but powerful WARN_ON check
    to see if all resources are cleared prior to releasing device.
    
    The WARN_ON check performed very well, but lack of information
    which device caused to resource leak, the object type and origin
    made debug to be fun and challenging at the same time.
    
    The fact that all dumps were the same because restrack_clean() is
    called in dealloc() didn't help either.
    
    So let's fix spelling error and convert WARN_ON to be more debug
    friendly. The dmesg cut below gives example of how the output
    will look output for the case fixed in patch [1]
    
    [  438.421372] restrack: ------------[ cut here ]------------
    [  438.423448] restrack: BUG: RESTRACK detected leak of resources on mlx5_2
    [  438.425600] restrack: Kernel PD object allocated by mlx5_ib is not freed
    [  438.427753] restrack: Kernel CQ object allocated by mlx5_ib is not freed
    [  438.429660] restrack: ------------[ cut here ]------------
    
    [1] https://patchwork.kernel.org/patch/10298695/
    
    Cc: Michal Kalderon <Michal.Kalderon@cavium.com>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 4cad0cd9aa0c..efddd13e3edb 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -17,9 +17,52 @@ void rdma_restrack_init(struct rdma_restrack_root *res)
 	init_rwsem(&res->rwsem);
 }
 
+static const char *type2str(enum rdma_restrack_type type)
+{
+	static const char * const names[RDMA_RESTRACK_MAX] = {
+		[RDMA_RESTRACK_PD] = "PD",
+		[RDMA_RESTRACK_CQ] = "CQ",
+		[RDMA_RESTRACK_QP] = "QP",
+		[RDMA_RESTRACK_CM_ID] = "CM_ID",
+		[RDMA_RESTRACK_MR] = "MR",
+	};
+
+	return names[type];
+};
+
 void rdma_restrack_clean(struct rdma_restrack_root *res)
 {
-	WARN_ON_ONCE(!hash_empty(res->hash));
+	struct rdma_restrack_entry *e;
+	char buf[TASK_COMM_LEN];
+	struct ib_device *dev;
+	const char *owner;
+	int bkt;
+
+	if (hash_empty(res->hash))
+		return;
+
+	dev = container_of(res, struct ib_device, res);
+	pr_err("restrack: %s", CUT_HERE);
+	pr_err("restrack: BUG: RESTRACK detected leak of resources on %s\n",
+	       dev->name);
+	hash_for_each(res->hash, bkt, e, node) {
+		if (rdma_is_kernel_res(e)) {
+			owner = e->kern_name;
+		} else {
+			/*
+			 * There is no need to call get_task_struct here,
+			 * because we can be here only if there are more
+			 * get_task_struct() call than put_task_struct().
+			 */
+			get_task_comm(buf, e->task);
+			owner = buf;
+		}
+
+		pr_err("restrack: %s %s object allocated by %s is not freed\n",
+		       rdma_is_kernel_res(e) ? "Kernel" : "User",
+		       type2str(e->type), owner);
+	}
+	pr_err("restrack: %s", CUT_HERE);
 }
 
 int rdma_restrack_count(struct rdma_restrack_root *res,

commit 7d9a935e169b7e51a5f84caf8dfb02aad6206902
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Thu Mar 15 11:10:42 2018 +0200

    RDMA/restrack: Don't rely on uninitialized variable in restrack_add flow
    
    The restrack code relies on the fact that object structures are zeroed at
    the allocation stage, the mlx4 CQ wasn't allocated with kzalloc and it
    caused to the following crash.
    
    [  137.392209] general protection fault: 0000 [#1] SMP KASAN PTI
    [  137.392972] CPU: 0 PID: 622 Comm: ibv_rc_pingpong Tainted: G        W        4.16.0-rc1-00099-g00313983cda6 #11
    [  137.395079] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-2.fc27 04/01/2014
    [  137.396866] RIP: 0010:rdma_restrack_del+0xc8/0xf0
    [  137.397762] RSP: 0018:ffff8801b54e7968 EFLAGS: 00010206
    [  137.399008] RAX: 0000000000000000 RBX: ffff8801d8bcbae8 RCX: ffffffffb82314df
    [  137.400055] RDX: dffffc0000000000 RSI: dffffc0000000000 RDI: 70696b533d454741
    [  137.401103] RBP: ffff8801d90c07a0 R08: ffff8801d8bcbb00 R09: 0000000000000000
    [  137.402470] R10: 0000000000000001 R11: ffffed0036a9cf52 R12: ffff8801d90c0ad0
    [  137.403318] R13: ffff8801d853fb20 R14: ffff8801d8bcbb28 R15: 0000000000000014
    [  137.404736] FS:  00007fb415d43740(0000) GS:ffff8801e5c00000(0000) knlGS:0000000000000000
    [  137.406074] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  137.407101] CR2: 00007fb41557df20 CR3: 00000001b580c001 CR4: 00000000003606b0
    [  137.408308] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  137.409352] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [  137.410385] Call Trace:
    [  137.411058]  ib_destroy_cq+0x23/0x60
    [  137.411460]  uverbs_free_cq+0x37/0xa0
    [  137.412040]  remove_commit_idr_uobject+0x38/0xf0
    [  137.413042]  _rdma_remove_commit_uobject+0x5c/0x160
    [  137.413782]  ? lookup_get_idr_uobject+0x39/0x50
    [  137.414737]  rdma_remove_commit_uobject+0x3b/0x70
    [  137.415742]  ib_uverbs_destroy_cq+0x114/0x1d0
    [  137.416260]  ? ib_uverbs_req_notify_cq+0x160/0x160
    [  137.417073]  ? kernel_text_address+0x5c/0x90
    [  137.417805]  ? __kernel_text_address+0xe/0x30
    [  137.418766]  ? unwind_get_return_address+0x2f/0x50
    [  137.419558]  ib_uverbs_write+0x453/0x6a0
    [  137.420220]  ? show_ibdev+0x90/0x90
    [  137.420653]  ? __kasan_slab_free+0x136/0x180
    [  137.421155]  ? kmem_cache_free+0x78/0x1e0
    [  137.422192]  ? remove_vma+0x83/0x90
    [  137.422614]  ? do_munmap+0x447/0x6c0
    [  137.423045]  ? vm_munmap+0xb0/0x100
    [  137.423481]  ? SyS_munmap+0x1d/0x30
    [  137.424120]  ? do_syscall_64+0xeb/0x250
    [  137.424984]  ? entry_SYSCALL_64_after_hwframe+0x21/0x86
    [  137.425611]  ? lru_add_drain_all+0x270/0x270
    [  137.426116]  ? lru_add_drain_cpu+0xa3/0x170
    [  137.426616]  ? lru_add_drain+0x11/0x20
    [  137.427058]  ? free_pages_and_swap_cache+0xa6/0x120
    [  137.427672]  ? tlb_flush_mmu_free+0x78/0x90
    [  137.428168]  ? arch_tlb_finish_mmu+0x6d/0xb0
    [  137.428680]  __vfs_write+0xc4/0x350
    [  137.430917]  ? kernel_read+0xa0/0xa0
    [  137.432758]  ? remove_vma+0x90/0x90
    [  137.434781]  ? __kasan_slab_free+0x14b/0x180
    [  137.437486]  ? remove_vma+0x83/0x90
    [  137.439836]  ? kmem_cache_free+0x78/0x1e0
    [  137.442195]  ? percpu_counter_add_batch+0x1d/0x90
    [  137.444389]  vfs_write+0xf7/0x280
    [  137.446030]  SyS_write+0xa1/0x120
    [  137.447867]  ? SyS_read+0x120/0x120
    [  137.449670]  ? mm_fault_error+0x180/0x180
    [  137.451539]  ? _cond_resched+0x16/0x50
    [  137.453697]  ? SyS_read+0x120/0x120
    [  137.455883]  do_syscall_64+0xeb/0x250
    [  137.457686]  entry_SYSCALL_64_after_hwframe+0x21/0x86
    [  137.459595] RIP: 0033:0x7fb415637b94
    [  137.461315] RSP: 002b:00007ffdebea7d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  137.463879] RAX: ffffffffffffffda RBX: 00005565022d1bd0 RCX: 00007fb415637b94
    [  137.466519] RDX: 0000000000000018 RSI: 00007ffdebea7da0 RDI: 0000000000000003
    [  137.469543] RBP: 00007ffdebea7d98 R08: 0000000000000000 R09: 00005565022d40c0
    [  137.472479] R10: 00000000000009cf R11: 0000000000000246 R12: 00005565022d2520
    [  137.475125] R13: 00000000000003e8 R14: 0000000000000000 R15: 00007ffdebea7fd0
    [  137.477760] Code: f7 e8 dd 0d 0b ff 48 c7 43 40 00 00 00 00 48 89 df e8 0d 0b 0b ff 48 8d 7b 28 c6 03 00 e8 41 0d 0b ff 48 8b 7b 28 48 85 ff 74 06 <f0> ff 4f 48 74 10 5b 48 89 ef 5d 41 5c 41 5d 41 5e e9 32 b0 ee
    [  137.483375] RIP: rdma_restrack_del+0xc8/0xf0 RSP: ffff8801b54e7968
    [  137.486436] ---[ end trace 81835a1ea6722eed ]---
    [  137.488566] Kernel panic - not syncing: Fatal exception
    [  137.491162] Kernel Offset: 0x36000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)
    
    Fixes: 00313983cda6 ("RDMA/nldev: provide detailed CM_ID information")
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index e1d9934d6e81..4cad0cd9aa0c 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -113,13 +113,15 @@ void rdma_restrack_add(struct rdma_restrack_entry *res)
 	if (!dev)
 		return;
 
+	if (res->type != RDMA_RESTRACK_CM_ID || !res_is_user(res))
+		res->task = NULL;
+
 	if (res_is_user(res)) {
 		if (!res->task)
 			rdma_restrack_set_task(res, current);
 		res->kern_name = NULL;
 	} else {
 		set_kern_name(res);
-		res->task = NULL;
 	}
 
 	kref_init(&res->kref);

commit fccec5b89ac61ebe2f353feecd08a16621f2418b
Author: Steve Wise <swise@opengridcomputing.com>
Date:   Thu Mar 1 13:58:13 2018 -0800

    RDMA/nldev: provide detailed MR information
    
    Implement the RDMA nldev netlink interface for dumping detailed
    MR information.
    
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 6da949e7a50b..e1d9934d6e81 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -43,22 +43,28 @@ EXPORT_SYMBOL(rdma_restrack_count);
 
 static void set_kern_name(struct rdma_restrack_entry *res)
 {
-	enum rdma_restrack_type type = res->type;
-	struct ib_qp *qp;
+	struct ib_pd *pd;
 
-	if (type != RDMA_RESTRACK_QP)
-		/* Other types already have this name embedded in */
-		return;
-
-	qp = container_of(res, struct ib_qp, res);
-	if (!qp->pd) {
-		WARN_ONCE(true, "XRC QPs are not supported\n");
-		/* Survive, despite the programmer's error */
-		res->kern_name = " ";
-		return;
+	switch (res->type) {
+	case RDMA_RESTRACK_QP:
+		pd = container_of(res, struct ib_qp, res)->pd;
+		if (!pd) {
+			WARN_ONCE(true, "XRC QPs are not supported\n");
+			/* Survive, despite the programmer's error */
+			res->kern_name = " ";
+		}
+		break;
+	case RDMA_RESTRACK_MR:
+		pd = container_of(res, struct ib_mr, res)->pd;
+		break;
+	default:
+		/* Other types set kern_name directly */
+		pd = NULL;
+		break;
 	}
 
-	res->kern_name = qp->pd->res.kern_name;
+	if (pd)
+		res->kern_name = pd->res.kern_name;
 }
 
 static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
@@ -73,6 +79,8 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 	case RDMA_RESTRACK_CM_ID:
 		return container_of(res, struct rdma_id_private,
 				    res)->id.device;
+	case RDMA_RESTRACK_MR:
+		return container_of(res, struct ib_mr, res)->device;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return NULL;
@@ -90,6 +98,8 @@ static bool res_is_user(struct rdma_restrack_entry *res)
 		return container_of(res, struct ib_qp, res)->uobject;
 	case RDMA_RESTRACK_CM_ID:
 		return !res->kern_name;
+	case RDMA_RESTRACK_MR:
+		return container_of(res, struct ib_mr, res)->pd->uobject;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return false;

commit 00313983cda6f37f747058e58c1cb8fba02bc134
Author: Steve Wise <swise@opengridcomputing.com>
Date:   Thu Mar 1 13:57:44 2018 -0800

    RDMA/nldev: provide detailed CM_ID information
    
    Implement RDMA nldev netlink interface to get detailed CM_ID information.
    
    Because cm_id's are attached to rdma devices in various work queue
    contexts, the pid and task information at restrak_add() time is sometimes
    not useful.  For example, an nvme/f host connection cm_id ends up being
    bound to a device in a work queue context and the resulting pid at attach
    time no longer exists after connection setup.  So instead we mark all
    cm_id's created via the rdma_ucm as "user", and all others as "kernel".
    This required tweaking the restrack code a little.  It also required
    wrapping some rdma_cm functions to allow passing the module name string.
    
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 41a780085e6d..6da949e7a50b 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -3,12 +3,15 @@
  * Copyright (c) 2017-2018 Mellanox Technologies. All rights reserved.
  */
 
+#include <rdma/rdma_cm.h>
 #include <rdma/ib_verbs.h>
 #include <rdma/restrack.h>
 #include <linux/mutex.h>
 #include <linux/sched/task.h>
 #include <linux/pid_namespace.h>
 
+#include "cma_priv.h"
+
 void rdma_restrack_init(struct rdma_restrack_root *res)
 {
 	init_rwsem(&res->rwsem);
@@ -44,7 +47,7 @@ static void set_kern_name(struct rdma_restrack_entry *res)
 	struct ib_qp *qp;
 
 	if (type != RDMA_RESTRACK_QP)
-		/* PD and CQ types already have this name embedded in */
+		/* Other types already have this name embedded in */
 		return;
 
 	qp = container_of(res, struct ib_qp, res);
@@ -67,6 +70,9 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 		return container_of(res, struct ib_cq, res)->device;
 	case RDMA_RESTRACK_QP:
 		return container_of(res, struct ib_qp, res)->device;
+	case RDMA_RESTRACK_CM_ID:
+		return container_of(res, struct rdma_id_private,
+				    res)->id.device;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return NULL;
@@ -82,6 +88,8 @@ static bool res_is_user(struct rdma_restrack_entry *res)
 		return container_of(res, struct ib_cq, res)->uobject;
 	case RDMA_RESTRACK_QP:
 		return container_of(res, struct ib_qp, res)->uobject;
+	case RDMA_RESTRACK_CM_ID:
+		return !res->kern_name;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return false;
@@ -96,8 +104,8 @@ void rdma_restrack_add(struct rdma_restrack_entry *res)
 		return;
 
 	if (res_is_user(res)) {
-		get_task_struct(current);
-		res->task = current;
+		if (!res->task)
+			rdma_restrack_set_task(res, current);
 		res->kern_name = NULL;
 	} else {
 		set_kern_name(res);

commit 88831a2cfe2245822200ecf4bd7ff77abdf1499a
Author: Steve Wise <swise@opengridcomputing.com>
Date:   Thu Mar 1 13:57:22 2018 -0800

    RDMA/restrack: clean up res_to_dev()
    
    Simplify res_to_dev() to make it easier to read/maintain.
    
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 3dbc4e4cca41..41a780085e6d 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -60,31 +60,17 @@ static void set_kern_name(struct rdma_restrack_entry *res)
 
 static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 {
-	enum rdma_restrack_type type = res->type;
-	struct ib_device *dev;
-	struct ib_pd *pd;
-	struct ib_cq *cq;
-	struct ib_qp *qp;
-
-	switch (type) {
+	switch (res->type) {
 	case RDMA_RESTRACK_PD:
-		pd = container_of(res, struct ib_pd, res);
-		dev = pd->device;
-		break;
+		return container_of(res, struct ib_pd, res)->device;
 	case RDMA_RESTRACK_CQ:
-		cq = container_of(res, struct ib_cq, res);
-		dev = cq->device;
-		break;
+		return container_of(res, struct ib_cq, res)->device;
 	case RDMA_RESTRACK_QP:
-		qp = container_of(res, struct ib_qp, res);
-		dev = qp->device;
-		break;
+		return container_of(res, struct ib_qp, res)->device;
 	default:
-		WARN_ONCE(true, "Wrong resource tracking type %u\n", type);
+		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
 		return NULL;
 	}
-
-	return dev;
 }
 
 static bool res_is_user(struct rdma_restrack_entry *res)

commit 2f08ee363fe097bc6dc01aac53e1798b16c00986
Author: Steve Wise <swise@opengridcomputing.com>
Date:   Wed Feb 14 18:43:36 2018 -0800

    RDMA/restrack: don't use uaccess_kernel()
    
    uaccess_kernel() isn't sufficient to determine if an rdma resource is
    user-mode or not.  For example, resources allocated in the add_one()
    function of an ib_client get falsely labeled as user mode, when they
    are kernel mode allocations.  EG: mad qps.
    
    The result is that these qps are skipped over during a nldev query
    because of an erroneous namespace mismatch.
    
    So now we determine if the resource is user-mode by looking at the object
    struct's uobject or similar pointer to know if it was allocated for user
    mode applications.
    
    Fixes: 02d8883f520e ("RDMA/restrack: Add general infrastructure to track RDMA resources")
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index d8dc709a3715..3dbc4e4cca41 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -7,7 +7,6 @@
 #include <rdma/restrack.h>
 #include <linux/mutex.h>
 #include <linux/sched/task.h>
-#include <linux/uaccess.h>
 #include <linux/pid_namespace.h>
 
 void rdma_restrack_init(struct rdma_restrack_root *res)
@@ -88,6 +87,21 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 	return dev;
 }
 
+static bool res_is_user(struct rdma_restrack_entry *res)
+{
+	switch (res->type) {
+	case RDMA_RESTRACK_PD:
+		return container_of(res, struct ib_pd, res)->uobject;
+	case RDMA_RESTRACK_CQ:
+		return container_of(res, struct ib_cq, res)->uobject;
+	case RDMA_RESTRACK_QP:
+		return container_of(res, struct ib_qp, res)->uobject;
+	default:
+		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
+		return false;
+	}
+}
+
 void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
@@ -95,7 +109,7 @@ void rdma_restrack_add(struct rdma_restrack_entry *res)
 	if (!dev)
 		return;
 
-	if (!uaccess_kernel()) {
+	if (res_is_user(res)) {
 		get_task_struct(current);
 		res->task = current;
 		res->kern_name = NULL;

commit 415bb699d793f7ad9c67c04a766d1e655fa6b203
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Tue Feb 13 12:18:28 2018 +0200

    RDMA/restrack: Remove unimplemented XRCD object
    
    Resource tracking of XRCD objects is not implemented in current
    version of restrack and hence can be removed.
    
    Fixes: 02d8883f520e ("RDMA/restrack: Add general infrastructure to track RDMA resources")
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index 857637bf46da..d8dc709a3715 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -63,7 +63,6 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 {
 	enum rdma_restrack_type type = res->type;
 	struct ib_device *dev;
-	struct ib_xrcd *xrcd;
 	struct ib_pd *pd;
 	struct ib_cq *cq;
 	struct ib_qp *qp;
@@ -81,10 +80,6 @@ static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
 		qp = container_of(res, struct ib_qp, res);
 		dev = qp->device;
 		break;
-	case RDMA_RESTRACK_XRCD:
-		xrcd = container_of(res, struct ib_xrcd, res);
-		dev = xrcd->device;
-		break;
 	default:
 		WARN_ONCE(true, "Wrong resource tracking type %u\n", type);
 		return NULL;

commit 02d8883f520ee91c4c40c0a31892eb25ea2df2c9
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Sun Jan 28 11:17:20 2018 +0200

    RDMA/restrack: Add general infrastructure to track RDMA resources
    
    The RDMA subsystem has very strict set of objects to work with, but it
    completely lacks tracking facilities and has no visibility of resource
    utilization.
    
    The following patch adds such infrastructure to keep track of RDMA
    resources to help with debugging of user space applications. The primary
    user of this infrastructure is RDMA nldev netlink (following patches), to
    be exposed to userspace via rdmatool, but it is not limited too that.
    
    At this stage, the main three objects (PD, CQ and QP) are added, and more
    will be added later.
    
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Reviewed-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
new file mode 100644
index 000000000000..857637bf46da
--- /dev/null
+++ b/drivers/infiniband/core/restrack.c
@@ -0,0 +1,164 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (c) 2017-2018 Mellanox Technologies. All rights reserved.
+ */
+
+#include <rdma/ib_verbs.h>
+#include <rdma/restrack.h>
+#include <linux/mutex.h>
+#include <linux/sched/task.h>
+#include <linux/uaccess.h>
+#include <linux/pid_namespace.h>
+
+void rdma_restrack_init(struct rdma_restrack_root *res)
+{
+	init_rwsem(&res->rwsem);
+}
+
+void rdma_restrack_clean(struct rdma_restrack_root *res)
+{
+	WARN_ON_ONCE(!hash_empty(res->hash));
+}
+
+int rdma_restrack_count(struct rdma_restrack_root *res,
+			enum rdma_restrack_type type,
+			struct pid_namespace *ns)
+{
+	struct rdma_restrack_entry *e;
+	u32 cnt = 0;
+
+	down_read(&res->rwsem);
+	hash_for_each_possible(res->hash, e, node, type) {
+		if (ns == &init_pid_ns ||
+		    (!rdma_is_kernel_res(e) &&
+		     ns == task_active_pid_ns(e->task)))
+			cnt++;
+	}
+	up_read(&res->rwsem);
+	return cnt;
+}
+EXPORT_SYMBOL(rdma_restrack_count);
+
+static void set_kern_name(struct rdma_restrack_entry *res)
+{
+	enum rdma_restrack_type type = res->type;
+	struct ib_qp *qp;
+
+	if (type != RDMA_RESTRACK_QP)
+		/* PD and CQ types already have this name embedded in */
+		return;
+
+	qp = container_of(res, struct ib_qp, res);
+	if (!qp->pd) {
+		WARN_ONCE(true, "XRC QPs are not supported\n");
+		/* Survive, despite the programmer's error */
+		res->kern_name = " ";
+		return;
+	}
+
+	res->kern_name = qp->pd->res.kern_name;
+}
+
+static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
+{
+	enum rdma_restrack_type type = res->type;
+	struct ib_device *dev;
+	struct ib_xrcd *xrcd;
+	struct ib_pd *pd;
+	struct ib_cq *cq;
+	struct ib_qp *qp;
+
+	switch (type) {
+	case RDMA_RESTRACK_PD:
+		pd = container_of(res, struct ib_pd, res);
+		dev = pd->device;
+		break;
+	case RDMA_RESTRACK_CQ:
+		cq = container_of(res, struct ib_cq, res);
+		dev = cq->device;
+		break;
+	case RDMA_RESTRACK_QP:
+		qp = container_of(res, struct ib_qp, res);
+		dev = qp->device;
+		break;
+	case RDMA_RESTRACK_XRCD:
+		xrcd = container_of(res, struct ib_xrcd, res);
+		dev = xrcd->device;
+		break;
+	default:
+		WARN_ONCE(true, "Wrong resource tracking type %u\n", type);
+		return NULL;
+	}
+
+	return dev;
+}
+
+void rdma_restrack_add(struct rdma_restrack_entry *res)
+{
+	struct ib_device *dev = res_to_dev(res);
+
+	if (!dev)
+		return;
+
+	if (!uaccess_kernel()) {
+		get_task_struct(current);
+		res->task = current;
+		res->kern_name = NULL;
+	} else {
+		set_kern_name(res);
+		res->task = NULL;
+	}
+
+	kref_init(&res->kref);
+	init_completion(&res->comp);
+	res->valid = true;
+
+	down_write(&dev->res.rwsem);
+	hash_add(dev->res.hash, &res->node, res->type);
+	up_write(&dev->res.rwsem);
+}
+EXPORT_SYMBOL(rdma_restrack_add);
+
+int __must_check rdma_restrack_get(struct rdma_restrack_entry *res)
+{
+	return kref_get_unless_zero(&res->kref);
+}
+EXPORT_SYMBOL(rdma_restrack_get);
+
+static void restrack_release(struct kref *kref)
+{
+	struct rdma_restrack_entry *res;
+
+	res = container_of(kref, struct rdma_restrack_entry, kref);
+	complete(&res->comp);
+}
+
+int rdma_restrack_put(struct rdma_restrack_entry *res)
+{
+	return kref_put(&res->kref, restrack_release);
+}
+EXPORT_SYMBOL(rdma_restrack_put);
+
+void rdma_restrack_del(struct rdma_restrack_entry *res)
+{
+	struct ib_device *dev;
+
+	if (!res->valid)
+		return;
+
+	dev = res_to_dev(res);
+	if (!dev)
+		return;
+
+	rdma_restrack_put(res);
+
+	wait_for_completion(&res->comp);
+
+	down_write(&dev->res.rwsem);
+	hash_del(&res->node);
+	res->valid = false;
+	if (res->task)
+		put_task_struct(res->task);
+	up_write(&dev->res.rwsem);
+}
+EXPORT_SYMBOL(rdma_restrack_del);
