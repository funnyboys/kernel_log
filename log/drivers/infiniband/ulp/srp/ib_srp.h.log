commit f273ad4f8d90bb87d2259fe37caee82e9aa7906c
Author: Max Gurtovoy <maxg@mellanox.com>
Date:   Thu May 28 16:45:44 2020 -0300

    RDMA/srp: Remove support for FMR memory registration
    
    FMR is not supported on most recent RDMA devices (that use fast memory
    registration mechanism). Also, FMR was recently removed from NFS/RDMA
    ULP.
    
    Link: https://lore.kernel.org/r/2-v3-f58e6669d5d3+2cf-fmr_removal_jgg@mellanox.com
    Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
    Reviewed-by: Israel Rukshin <israelr@mellanox.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 6fabcc2faf1f..6818cac0a3b7 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -44,7 +44,6 @@
 #include <rdma/ib_verbs.h>
 #include <rdma/ib_sa.h>
 #include <rdma/ib_cm.h>
-#include <rdma/ib_fmr_pool.h>
 #include <rdma/rdma_cm.h>
 
 enum {
@@ -95,8 +94,7 @@ enum srp_iu_type {
 /*
  * @mr_page_mask: HCA memory registration page mask.
  * @mr_page_size: HCA memory registration page size.
- * @mr_max_size: Maximum size in bytes of a single FMR / FR registration
- *   request.
+ * @mr_max_size: Maximum size in bytes of a single FR registration request.
  */
 struct srp_device {
 	struct list_head	dev_list;
@@ -107,9 +105,7 @@ struct srp_device {
 	int			mr_page_size;
 	int			mr_max_size;
 	int			max_pages_per_mr;
-	bool			has_fmr;
 	bool			has_fr;
-	bool			use_fmr;
 	bool			use_fast_reg;
 };
 
@@ -127,11 +123,7 @@ struct srp_host {
 struct srp_request {
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
-	union {
-		struct ib_pool_fmr **fmr_list;
-		struct srp_fr_desc **fr_list;
-	};
-	u64		       *map_page;
+	struct srp_fr_desc     **fr_list;
 	struct srp_direct_buf  *indirect_desc;
 	dma_addr_t		indirect_dma_addr;
 	short			nmdesc;
@@ -155,10 +147,7 @@ struct srp_rdma_ch {
 	struct ib_cq	       *send_cq;
 	struct ib_cq	       *recv_cq;
 	struct ib_qp	       *qp;
-	union {
-		struct ib_fmr_pool     *fmr_pool;
-		struct srp_fr_pool     *fr_pool;
-	};
+	struct srp_fr_pool     *fr_pool;
 	uint32_t		max_it_iu_len;
 	uint32_t		max_ti_iu_len;
 	u8			max_imm_sge;
@@ -319,19 +308,15 @@ struct srp_fr_pool {
  * @pages:	    Array with DMA addresses of pages being considered for
  *		    memory registration.
  * @base_dma_addr:  DMA address of the first page that has not yet been mapped.
- * @dma_len:	    Number of bytes that will be registered with the next
- *		    FMR or FR memory registration call.
+ * @dma_len:	    Number of bytes that will be registered with the next FR
+ *                  memory registration call.
  * @total_len:	    Total number of bytes in the sg-list being mapped.
  * @npages:	    Number of page addresses in the pages[] array.
- * @nmdesc:	    Number of FMR or FR memory descriptors used for mapping.
+ * @nmdesc:	    Number of FR memory descriptors used for mapping.
  * @ndesc:	    Number of SRP buffer descriptors that have been filled in.
  */
 struct srp_map_state {
 	union {
-		struct {
-			struct ib_pool_fmr **next;
-			struct ib_pool_fmr **end;
-		} fmr;
 		struct {
 			struct srp_fr_desc **next;
 			struct srp_fr_desc **end;

commit 5b361328ca649534d721e4eae20c96ccbe702ce7
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Feb 12 19:04:25 2020 -0600

    RDMA: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Link: https://lore.kernel.org/r/20200213010425.GA13068@embeddedor.com
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com> # added a few more

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 5359ece561ca..6fabcc2faf1f 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -309,7 +309,7 @@ struct srp_fr_pool {
 	int			max_page_list_len;
 	spinlock_t		lock;
 	struct list_head	free_list;
-	struct srp_fr_desc	desc[0];
+	struct srp_fr_desc	desc[];
 };
 
 /**

commit 547ed331bbe89575ff91939e1ac9a023fe526b74
Author: Honggang Li <honli@redhat.com>
Date:   Sat Sep 28 01:43:51 2019 +0800

    RDMA/srp: Add parse function for maximum initiator to target IU size
    
    According to SRP specifications 'srp-r16a' and 'srp2r06',
    IOControllerProfile attributes for SRP target port include the maximum
    initiator to target IU size.
    
    SRP connection daemons, such as srp_daemon, can get the value from the
    subnet manager. The SRP connection daemon can pass this value to kernel.
    
    This patch adds a parse function for it.
    
    Upstream commit [1] enables the kernel parameter, 'use_imm_data', by
    default. [1] also use (8 * 1024) as the default value for kernel parameter
    'max_imm_data'. With those default values, the maximum initiator to target
    IU size will be 8260.
    
    In case the SRPT modules, which include the in-tree 'ib_srpt.ko' module,
    do not support SRP-2 'immediate data' feature, the default maximum
    initiator to target IU size is significantly smaller than 8260. For
    'ib_srpt.ko' module, which built from source before [2], the default
    maximum initiator to target IU is 2116.
    
    [1] introduces a regression issue for old srp targets with default kernel
    parameters, as the connection will be rejected because of a too large
    maximum initiator to target IU size.
    
    [1] commit 882981f4a411 ("RDMA/srp: Add support for immediate data")
    [2] commit 5dabcd0456d7 ("RDMA/srpt: Add support for immediate data")
    
    Link: https://lore.kernel.org/r/20190927174352.7800-1-honli@redhat.com
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Honggang Li <honli@redhat.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index f38fbb00d0e8..5359ece561ca 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -210,6 +210,7 @@ struct srp_target_port {
 	u32			ch_count;
 	u32			lkey;
 	enum srp_target_state	state;
+	uint32_t		max_it_iu_size;
 	unsigned int		cmd_sg_cnt;
 	unsigned int		indirect_size;
 	bool			allow_ext_sg;

commit bf583470617e31c836afc4fa2039dabc43350533
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Sep 30 16:16:59 2019 -0700

    RDMA/srp: Honor the max_send_sge device attribute
    
    Instead of assuming that max_send_sge >= 3, restrict the number of scatter
    gather elements to what is supported by the RDMA adapter.
    
    Link: https://lore.kernel.org/r/20190930231707.48259-8-bvanassche@acm.org
    Cc: Honggang LI <honli@redhat.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index af9922550ae1..f38fbb00d0e8 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -161,6 +161,7 @@ struct srp_rdma_ch {
 	};
 	uint32_t		max_it_iu_len;
 	uint32_t		max_ti_iu_len;
+	u8			max_imm_sge;
 	bool			use_imm_data;
 
 	/* Everything above this point is used in the hot path of

commit 14673778d06ee551a55695947548b52d503e7273
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Sep 30 16:16:58 2019 -0700

    RDMA/srp: Remove two casts
    
    This patch does not change any functionality.
    
    Link: https://lore.kernel.org/r/20190930231707.48259-7-bvanassche@acm.org
    Cc: Honggang LI <honli@redhat.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index b2861cd2087a..af9922550ae1 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -245,11 +245,13 @@ struct srp_target_port {
 			union {
 				struct sockaddr_in	ip4;
 				struct sockaddr_in6	ip6;
+				struct sockaddr		sa;
 				struct sockaddr_storage ss;
 			} src;
 			union {
 				struct sockaddr_in	ip4;
 				struct sockaddr_in6	ip6;
+				struct sockaddr		sa;
 				struct sockaddr_storage ss;
 			} dst;
 			bool src_specified;

commit 882981f4a4112b44376ba21aa4d82dbdd5d8f148
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 17 13:20:39 2018 -0800

    RDMA/srp: Add support for immediate data
    
    Request permission to send immediate data during login. If the SRP
    target grants this request, send the payload of write requests <= 8 KB
    as immediate data.
    
    Cc: Sergey Gorenko <sergeygo@mellanox.com>
    Cc: Max Gurtovoy <maxg@mellanox.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 9a271ae6573b..b2861cd2087a 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -69,6 +69,15 @@ enum {
 	SRP_MAX_PAGES_PER_MR	= 512,
 
 	SRP_MAX_ADD_CDB_LEN	= 16,
+
+	SRP_MAX_IMM_SGE		= 2,
+	SRP_MAX_SGE		= SRP_MAX_IMM_SGE + 1,
+	/*
+	 * Choose the immediate data offset such that a 32 byte CDB still fits.
+	 */
+	SRP_IMM_DATA_OFFSET	= sizeof(struct srp_cmd) +
+				  SRP_MAX_ADD_CDB_LEN +
+				  sizeof(struct srp_imm_buf),
 };
 
 enum srp_target_state {
@@ -152,6 +161,7 @@ struct srp_rdma_ch {
 	};
 	uint32_t		max_it_iu_len;
 	uint32_t		max_ti_iu_len;
+	bool			use_imm_data;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.
@@ -263,6 +273,8 @@ struct srp_iu {
 	void		       *buf;
 	size_t			size;
 	enum dma_data_direction	direction;
+	u32			num_sge;
+	struct ib_sge		sge[SRP_MAX_SGE];
 	struct ib_cqe		cqe;
 };
 

commit 513d5647116b2aaeb6d99471f70ab9c9f3f65663
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 17 13:20:38 2018 -0800

    RDMA/srp: Rework handling of the maximum information unit length
    
    Move the maximum initiator to target information unit length parameter
    from struct srp_target_port into struct srp_rdma_ch. This patch does
    not change any functionality but makes the next patch easier to read.
    
    Cc: Sergey Gorenko <sergeygo@mellanox.com>
    Cc: Max Gurtovoy <maxg@mellanox.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index cba29e378a74..9a271ae6573b 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -132,6 +132,7 @@ struct srp_request {
 /**
  * struct srp_rdma_ch
  * @comp_vector: Completion vector used by this RDMA channel.
+ * @max_it_iu_len: Maximum initiator-to-target information unit length.
  * @max_ti_iu_len: Maximum target-to-initiator information unit length.
  */
 struct srp_rdma_ch {
@@ -149,6 +150,7 @@ struct srp_rdma_ch {
 		struct ib_fmr_pool     *fmr_pool;
 		struct srp_fr_pool     *fr_pool;
 	};
+	uint32_t		max_it_iu_len;
 	uint32_t		max_ti_iu_len;
 
 	/* Everything above this point is used in the hot path of
@@ -197,7 +199,6 @@ struct srp_target_port {
 	u32			ch_count;
 	u32			lkey;
 	enum srp_target_state	state;
-	unsigned int		max_iu_len;
 	unsigned int		cmd_sg_cnt;
 	unsigned int		indirect_size;
 	bool			allow_ext_sg;

commit 4f6d498c360c31006dec8062ce3d4601e557e9df
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 17 13:20:37 2018 -0800

    RDMA/srp: Move srp_rdma_ch.max_ti_iu_len declaration
    
    Since srp_rdma_ch.max_ti_iu_len is used in the hot path, move it to the
    section with data structure members used in the hot path.
    
    Cc: Sergey Gorenko <sergeygo@mellanox.com>
    Cc: Max Gurtovoy <maxg@mellanox.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index d6c116a53d5e..cba29e378a74 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -132,6 +132,7 @@ struct srp_request {
 /**
  * struct srp_rdma_ch
  * @comp_vector: Completion vector used by this RDMA channel.
+ * @max_ti_iu_len: Maximum target-to-initiator information unit length.
  */
 struct srp_rdma_ch {
 	/* These are RW in the hot path, and commonly used together */
@@ -148,6 +149,7 @@ struct srp_rdma_ch {
 		struct ib_fmr_pool     *fmr_pool;
 		struct srp_fr_pool     *fr_pool;
 	};
+	uint32_t		max_ti_iu_len;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.
@@ -171,7 +173,6 @@ struct srp_rdma_ch {
 	struct srp_iu	      **tx_ring;
 	struct srp_iu	      **rx_ring;
 	struct srp_request     *req_ring;
-	int			max_ti_iu_len;
 	int			comp_vector;
 
 	u64			tsk_mgmt_tag;

commit 482fffc43c032ec09dd9ee792a546b36e973dcef
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 17 13:20:35 2018 -0800

    RDMA/srp: Handle large SCSI CDBs correctly
    
    Reserve additional space for CDBs that contain more than sixteen bytes
    and set the add_cdb_len field for such CDBs as required. From the SRP
    standard: "The ADDITIONAL CDB LENGTH field contains the length in
    dwords of the ADDITIONAL CDB field."
    
    Cc: Sergey Gorenko <sergeygo@mellanox.com>
    Cc: Max Gurtovoy <maxg@mellanox.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index a2706086b9c7..d6c116a53d5e 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -67,6 +67,8 @@ enum {
 	SRP_TAG_TSK_MGMT	= 1U << 31,
 
 	SRP_MAX_PAGES_PER_MR	= 512,
+
+	SRP_MAX_ADD_CDB_LEN	= 16,
 };
 
 enum srp_target_state {

commit b0780ee56ee264cfdfee46023e02386282041aad
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Jan 22 14:27:13 2018 -0800

    IB/srp: Add target_can_queue login parameter
    
    Although I'm not sure this parameter is useful for regular SRP users,
    setting this parameter to 1 has shown to be invaluable for testing the
    block layer core, SCSI core and device mapper queue running mechanisms.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 911fc1582f61..a2706086b9c7 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -211,6 +211,7 @@ struct srp_target_port {
 	char			target_name[32];
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
+	unsigned int		target_can_queue;
 	int			mr_pool_size;
 	int			mr_per_cmd;
 	int			queue_size;

commit 19f313438c7754e6cc2bceddeebeaa5132e2e0a1
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Jan 22 14:27:12 2018 -0800

    IB/srp: Add RDMA/CM support
    
    Since the SRP_LOGIN_REQ defined in the SRP standard is larger than
    what fits in the RDMA/CM login request private data, introduce a new
    login request format for the RDMA/CM.
    
    Note: since srp_daemon and ibsrpdm rely on the subnet manager and
    since there is no equivalent of the IB subnet manager in non-IB
    networks, login has to be performed manually for non-IB networks.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index a814f5ef16f9..911fc1582f61 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -45,6 +45,7 @@
 #include <rdma/ib_sa.h>
 #include <rdma/ib_cm.h>
 #include <rdma/ib_fmr_pool.h>
+#include <rdma/rdma_cm.h>
 
 enum {
 	SRP_PATH_REC_TIMEOUT_MS	= 1000,
@@ -153,11 +154,18 @@ struct srp_rdma_ch {
 	struct completion	done;
 	int			status;
 
-	struct sa_path_rec	path;
-	struct ib_sa_query     *path_query;
-	int			path_query_id;
+	union {
+		struct ib_cm {
+			struct sa_path_rec	path;
+			struct ib_sa_query	*path_query;
+			int			path_query_id;
+			struct ib_cm_id		*cm_id;
+		} ib_cm;
+		struct rdma_cm {
+			struct rdma_cm_id	*cm_id;
+		} rdma_cm;
+	};
 
-	struct ib_cm_id	       *cm_id;
 	struct srp_iu	      **tx_ring;
 	struct srp_iu	      **rx_ring;
 	struct srp_request     *req_ring;
@@ -182,6 +190,7 @@ struct srp_target_port {
 	/* read only in the hot path */
 	u32			global_rkey;
 	struct srp_rdma_ch	*ch;
+	struct net		*net;
 	u32			ch_count;
 	u32			lkey;
 	enum srp_target_state	state;
@@ -194,7 +203,6 @@ struct srp_target_port {
 	union ib_gid		sgid;
 	__be64			id_ext;
 	__be64			ioc_guid;
-	__be64			service_id;
 	__be64			initiator_ext;
 	u16			io_class;
 	struct srp_host	       *srp_host;
@@ -210,8 +218,28 @@ struct srp_target_port {
 	int			comp_vector;
 	int			tl_retry_count;
 
-	union ib_gid		orig_dgid;
-	__be16			pkey;
+	bool			using_rdma_cm;
+
+	union {
+		struct {
+			__be64			service_id;
+			union ib_gid		orig_dgid;
+			__be16			pkey;
+		} ib_cm;
+		struct {
+			union {
+				struct sockaddr_in	ip4;
+				struct sockaddr_in6	ip6;
+				struct sockaddr_storage ss;
+			} src;
+			union {
+				struct sockaddr_in	ip4;
+				struct sockaddr_in6	ip6;
+				struct sockaddr_storage ss;
+			} dst;
+			bool src_specified;
+		} rdma_cm;
+	};
 
 	u32			rq_tmo_jiffies;
 

commit cee687b68dbc718b5e10f2181102dc0bc3e4f006
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Oct 11 10:27:28 2017 -0700

    IB/srp: Cache global rkey
    
    This is a micro-optimization for the hot path.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index ab9077b81d5a..a814f5ef16f9 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -90,6 +90,7 @@ struct srp_device {
 	struct list_head	dev_list;
 	struct ib_device       *dev;
 	struct ib_pd	       *pd;
+	u32			global_rkey;
 	u64			mr_page_mask;
 	int			mr_page_size;
 	int			mr_max_size;
@@ -179,7 +180,7 @@ struct srp_target_port {
 	spinlock_t		lock;
 
 	/* read only in the hot path */
-	struct ib_pd		*pd;
+	u32			global_rkey;
 	struct srp_rdma_ch	*ch;
 	u32			ch_count;
 	u32			lkey;

commit c2f8fc4ec4400901e5561d4815deca19f395deb6
Author: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
Date:   Thu Apr 27 19:05:58 2017 -0400

    IB/SA: Rename ib_sa_path_rec to sa_path_rec
    
    Rename ib_sa_path_rec to a more generic sa_path_rec.
    This is part of extending ib_sa to also support OPA
    path records in addition to the IB defined path records.
    
    Reviewed-by: Don Hiatt <don.hiatt@intel.com>
    Reviewed-by: Ira Weiny <ira.weiny@intel.com>
    Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 32ed40db3ca2..ab9077b81d5a 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -152,7 +152,7 @@ struct srp_rdma_ch {
 	struct completion	done;
 	int			status;
 
-	struct ib_sa_path_rec	path;
+	struct sa_path_rec	path;
 	struct ib_sa_query     *path_query;
 	int			path_query_id;
 

commit 0a6fdbdeb1c25e31763c1fb333fa2723a7d2aba6
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Tue Feb 14 10:56:31 2017 -0800

    IB/srp: Fix race conditions related to task management
    
    Avoid that srp_process_rsp() overwrites the status information
    in ch if the SRP target response timed out and processing of
    another task management function has already started. Avoid that
    issuing multiple task management functions concurrently triggers
    list corruption. This patch prevents that the following stack
    trace appears in the system log:
    
    WARNING: CPU: 8 PID: 9269 at lib/list_debug.c:52 __list_del_entry_valid+0xbc/0xc0
    list_del corruption. prev->next should be ffffc90004bb7b00, but was ffff8804052ecc68
    CPU: 8 PID: 9269 Comm: sg_reset Tainted: G        W       4.10.0-rc7-dbg+ #3
    Call Trace:
     dump_stack+0x68/0x93
     __warn+0xc6/0xe0
     warn_slowpath_fmt+0x4a/0x50
     __list_del_entry_valid+0xbc/0xc0
     wait_for_completion_timeout+0x12e/0x170
     srp_send_tsk_mgmt+0x1ef/0x2d0 [ib_srp]
     srp_reset_device+0x5b/0x110 [ib_srp]
     scsi_ioctl_reset+0x1c7/0x290
     scsi_ioctl+0x12a/0x420
     sd_ioctl+0x9d/0x100
     blkdev_ioctl+0x51e/0x9f0
     block_ioctl+0x38/0x40
     do_vfs_ioctl+0x8f/0x700
     SyS_ioctl+0x3c/0x70
     entry_SYSCALL_64_fastpath+0x18/0xad
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Israel Rukshin <israelr@mellanox.com>
    Cc: Max Gurtovoy <maxg@mellanox.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Steve Feeley <Steve.Feeley@sandisk.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 21c69695f9d4..32ed40db3ca2 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -163,6 +163,7 @@ struct srp_rdma_ch {
 	int			max_ti_iu_len;
 	int			comp_vector;
 
+	u64			tsk_mgmt_tag;
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;
 	bool			connected;

commit 5f071777f9cbd71faa00eb854d15f42ae74e0471
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 5 12:56:19 2016 +0200

    IB/srp: use IB_PD_UNSAFE_GLOBAL_RKEY
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 26bb9b0a7a63..21c69695f9d4 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -90,7 +90,6 @@ struct srp_device {
 	struct list_head	dev_list;
 	struct ib_device       *dev;
 	struct ib_pd	       *pd;
-	struct ib_mr	       *global_mr;
 	u64			mr_page_mask;
 	int			mr_page_size;
 	int			mr_max_size;
@@ -179,7 +178,7 @@ struct srp_target_port {
 	spinlock_t		lock;
 
 	/* read only in the hot path */
-	struct ib_mr		*global_mr;
+	struct ib_pd		*pd;
 	struct srp_rdma_ch	*ch;
 	u32			ch_count;
 	u32			lkey;

commit 509c5f33f4f6dc328d96bf4099ef6589739f22d4
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu May 12 10:50:35 2016 -0700

    IB/srp: Prevent mapping failures
    
    If both max_sectors and the queue_depth are high enough it can
    happen that the MR pool is depleted temporarily. This causes
    the SRP initiator to report mapping failures. Although the SRP
    initiator recovers from such mapping failures, prevent that
    this can happen by allocating more memory regions.
    
    Additionally, only enable memory registration if at least two
    pages can be registered per memory region.
    
    Reported-by: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Tested-by: Laurence Oberman <loberman@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index a00914cdd44e..26bb9b0a7a63 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -203,6 +203,7 @@ struct srp_target_port {
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
 	int			mr_pool_size;
+	int			mr_per_cmd;
 	int			queue_size;
 	int			req_ring_size;
 	int			comp_vector;

commit fa9863f869202a4ccc673cbd8dd326bf54a8efff
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Fri Apr 22 14:13:57 2016 -0700

    IB/srp: Introduce target->mr_pool_size
    
    This patch does not change any functionality.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 9e05ce4a04fd..a00914cdd44e 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -202,6 +202,7 @@ struct srp_target_port {
 	char			target_name[32];
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
+	int			mr_pool_size;
 	int			queue_size;
 	int			req_ring_size;
 	int			comp_vector;

commit c6333f9f9f7646e311248a09e8ed96126a97aba8
Merge: 9f9499ae8e64 cfeb91b375ad
Author: Doug Ledford <dledford@redhat.com>
Date:   Tue Dec 15 14:10:44 2015 -0500

    Merge branch 'rdma-cq.2' of git://git.infradead.org/users/hch/rdma into 4.5/rdma-cq
    
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    
    Conflicts:
            drivers/infiniband/ulp/srp/ib_srp.c - Conflicts with changes in
            ib_srp.c introduced during 4.4-rc updates

commit 1dc7b1f10dcbbaf875a0770b2b26d63bc326d92a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 13 12:57:13 2015 +0100

    IB/srp: use the new CQ API
    
    This also moves recv completion handling from hardirq context into
    softirq context.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 87a2a919dc43..7fec482f3669 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -66,11 +66,6 @@ enum {
 	SRP_TAG_TSK_MGMT	= 1U << 31,
 
 	SRP_MAX_PAGES_PER_MR	= 512,
-
-	LOCAL_INV_WR_ID_MASK	= 1,
-	FAST_REG_WR_ID_MASK	= 2,
-
-	SRP_LAST_WR_ID		= 0xfffffffcU,
 };
 
 enum srp_target_state {
@@ -128,6 +123,7 @@ struct srp_request {
 	struct srp_direct_buf  *indirect_desc;
 	dma_addr_t		indirect_dma_addr;
 	short			nmdesc;
+	struct ib_cqe		reg_cqe;
 };
 
 /**
@@ -231,6 +227,7 @@ struct srp_iu {
 	void		       *buf;
 	size_t			size;
 	enum dma_data_direction	direction;
+	struct ib_cqe		cqe;
 };
 
 /**

commit 57b0be9c0fb0ba3a35683c6ce21db7162d6758c5
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Tue Dec 1 10:19:38 2015 -0800

    IB/srp: Fix srp_map_sg_fr()
    
    After dma_map_sg() has been called the return value of that function
    must be used as the number of elements in the scatterlist instead of
    scsi_sg_count().
    
    Fixes: commit f7f7aab1a5c0 ("IB/srp: Convert to new registration API")
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: stable <stable@vger.kernel.org> # v4.4+
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: Sebastian Parschauer <sebastian.riemer@profitbricks.com>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 87a2a919dc43..f6af531f9f32 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -300,10 +300,7 @@ struct srp_map_state {
 	dma_addr_t		base_dma_addr;
 	u32			dma_len;
 	u32			total_len;
-	union {
-		unsigned int	npages;
-		int		sg_nents;
-	};
+	unsigned int		npages;
 	unsigned int		nmdesc;
 	unsigned int		ndesc;
 };

commit f7f7aab1a5c0a495ae9a2d604badd1e3f9f20795
Author: Sagi Grimberg <sagig@mellanox.com>
Date:   Tue Oct 13 19:11:39 2015 +0300

    IB/srp: Convert to new registration API
    
    Instead of constructing a page list, call ib_map_mr_sg
    and post a new ib_reg_wr. srp_map_finish_fr now returns
    the number of sg elements registered.
    
    Remove srp_finish_mapping since no one is calling it.
    
    Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
    Tested-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 3608f2e4819c..87a2a919dc43 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -242,7 +242,6 @@ struct srp_iu {
 struct srp_fr_desc {
 	struct list_head		entry;
 	struct ib_mr			*mr;
-	struct ib_fast_reg_page_list	*frpl;
 };
 
 /**
@@ -294,11 +293,17 @@ struct srp_map_state {
 		} gen;
 	};
 	struct srp_direct_buf  *desc;
-	u64		       *pages;
+	union {
+		u64			*pages;
+		struct scatterlist	*sg;
+	};
 	dma_addr_t		base_dma_addr;
 	u32			dma_len;
 	u32			total_len;
-	unsigned int		npages;
+	union {
+		unsigned int	npages;
+		int		sg_nents;
+	};
 	unsigned int		nmdesc;
 	unsigned int		ndesc;
 };

commit 03f6fb93fde24f01a940283bdf55024e576ee87d
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon Aug 10 17:09:36 2015 -0700

    IB/srp: Create an insecure all physical rkey only if needed
    
    The SRP initiator only needs this if the insecure register_always=N
    performance optimization is enabled, or if FRWR/FMR is not supported
    in the driver.
    
    Do not create an all physical MR unless it is needed to support
    either of those modes. Default register_always to true so the out of
    the box configuration does not create an insecure all physical MR.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    [bvanassche: reworked and rebased this patch]
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 255b0e591aa4..3608f2e4819c 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -95,7 +95,7 @@ struct srp_device {
 	struct list_head	dev_list;
 	struct ib_device       *dev;
 	struct ib_pd	       *pd;
-	struct ib_mr	       *mr;
+	struct ib_mr	       *global_mr;
 	u64			mr_page_mask;
 	int			mr_page_size;
 	int			mr_max_size;
@@ -183,10 +183,10 @@ struct srp_target_port {
 	spinlock_t		lock;
 
 	/* read only in the hot path */
+	struct ib_mr		*global_mr;
 	struct srp_rdma_ch	*ch;
 	u32			ch_count;
 	u32			lkey;
-	u32			rkey;
 	enum srp_target_state	state;
 	unsigned int		max_iu_len;
 	unsigned int		cmd_sg_cnt;

commit 330179f2fa93c1c6c41a90c7deabc98e363018e5
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon Aug 10 17:09:05 2015 -0700

    IB/srp: Register the indirect data buffer descriptor
    
    Instead of always using the global rkey for the indirect data
    buffer descriptor, register that descriptor with the HCA if
    the kernel module parameter register_always has been set to Y.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 60a33c1de328..255b0e591aa4 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -288,6 +288,10 @@ struct srp_map_state {
 			struct srp_fr_desc **next;
 			struct srp_fr_desc **end;
 		} fr;
+		struct {
+			void		   **next;
+			void		   **end;
+		} gen;
 	};
 	struct srp_direct_buf  *desc;
 	u64		       *pages;

commit 002f15674c84fb4c38ed5237c1e7235e09c033f0
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon Aug 10 17:08:44 2015 -0700

    IB/srp: Introduce srp_device.use_fmr
    
    Introduce the variable srp_device.use_fmr. Leave out the dev->has_fr /
    dev->has_fmr and ch->fr_pool / ch->fmr_pool checks since these are
    redundant. This patch does not change any functionality but makes the
    source code easier to read.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 1e424181fdf8..60a33c1de328 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -102,6 +102,7 @@ struct srp_device {
 	int			max_pages_per_mr;
 	bool			has_fmr;
 	bool			has_fr;
+	bool			use_fmr;
 	bool			use_fast_reg;
 };
 

commit 0e0d3a480090d03f29e58dfd717960776f3416d9
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon Aug 10 17:07:46 2015 -0700

    IB/srp: Remove the memory registration backtracking code
    
    Mapping a discontiguous sg-list requires multiple memory regions
    and hence can exhaust the memory region pool. The SRP initiator
    already handles this by temporarily reducing the queue depth. This
    means that it is safe to remove the memory registration backtracking
    code. This patch has been tested with direct I/O sizes up to 256 MB.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 2ab73bc76da1..1e424181fdf8 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -276,9 +276,6 @@ struct srp_fr_pool {
  * @npages:	    Number of page addresses in the pages[] array.
  * @nmdesc:	    Number of FMR or FR memory descriptors used for mapping.
  * @ndesc:	    Number of SRP buffer descriptors that have been filled in.
- * @unmapped_sg:    First element of the sg-list that is mapped via FMR or FR.
- * @unmapped_index: Index of the first element mapped via FMR or FR.
- * @unmapped_addr:  DMA address of the first element mapped via FMR or FR.
  */
 struct srp_map_state {
 	union {
@@ -299,9 +296,6 @@ struct srp_map_state {
 	unsigned int		npages;
 	unsigned int		nmdesc;
 	unsigned int		ndesc;
-	struct scatterlist     *unmapped_sg;
-	int			unmapped_index;
-	dma_addr_t		unmapped_addr;
 };
 
 #endif /* IB_SRP_H */

commit f731ed62934ace0d3f5aa9ec557349171711be05
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon Aug 10 17:07:27 2015 -0700

    IB/srp: Add memory descriptor array pointer range checking
    
    Although most paths through which a request is submitted check
    block layer parameters like the max_segments limit, these are
    not checked when an SG_IO or direct I/O request is submitted.
    Hence add a range check for the memory descriptor array pointer.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 17ee3f80ba55..2ab73bc76da1 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -282,8 +282,14 @@ struct srp_fr_pool {
  */
 struct srp_map_state {
 	union {
-		struct ib_pool_fmr **next_fmr;
-		struct srp_fr_desc **next_fr;
+		struct {
+			struct ib_pool_fmr **next;
+			struct ib_pool_fmr **end;
+		} fmr;
+		struct {
+			struct srp_fr_desc **next;
+			struct srp_fr_desc **end;
+		} fr;
 	};
 	struct srp_direct_buf  *desc;
 	u64		       *pages;

commit 985aa49556a576416d3f960f8fc1c6513863e33e
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon May 18 13:27:14 2015 +0200

    IB/srp: Add 64-bit LUN support
    
    The SCSI standard defines 64-bit values for LUNs. Large arrays
    employing large or hierarchical LUN numbers become more and more
    common. So update the SRP initiator to use 64-bit LUN numbers.
    See also Hannes Reinecke, commit 9cb78c16f5da ("scsi: use 64-bit LUNs"),
    June 2014.
    
    The largest LUN number that has been tested is 0xd2003fff00000000.
    
    Checked the following structure sizes with gdb:
    * sizeof(struct srp_cmd) = 48
    * sizeof(struct srp_tsk_mgmt) = 48
    * sizeof(struct srp_aer_req) = 36
    
    The ibmvscsi changes have been compile tested only (on a PPC system).
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Reviewed-by: Yann Droneaud <ydroneaud@opteya.com>
    Cc: Sebastian Parschauer <sebastian.riemer@profitbricks.com>
    Cc: Brian King <brking@linux.vnet.ibm.com>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e690847a46dd..17ee3f80ba55 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -54,7 +54,6 @@ enum {
 	SRP_DLID_REDIRECT	= 2,
 	SRP_STALE_CONN		= 3,
 
-	SRP_MAX_LUN		= 512,
 	SRP_DEF_SG_TABLESIZE	= 12,
 
 	SRP_DEFAULT_QUEUE_SIZE	= 1 << 6,

commit c014c8cd31b161e12deb81c0f7f477811bd1eddc
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Mon May 18 13:23:57 2015 +0200

    IB/srp: Fix connection state tracking
    
    Reception of a DREQ message only causes the state of a single
    channel to change. Hence move the 'connected' member variable
    from the target to the channel data structure. This patch
    avoids that following false positive warning can be reported
    by srp_destroy_qp():
    
    WARNING: at drivers/infiniband/ulp/srp/ib_srp.c:617 srp_destroy_qp+0xa6/0x120 [ib_srp]()
    Call Trace:
    [<ffffffff8106e10f>] warn_slowpath_common+0x7f/0xc0
    [<ffffffff8106e16a>] warn_slowpath_null+0x1a/0x20
    [<ffffffffa0440226>] srp_destroy_qp+0xa6/0x120 [ib_srp]
    [<ffffffffa0440322>] srp_free_ch_ib+0x82/0x1e0 [ib_srp]
    [<ffffffffa044408b>] srp_create_target+0x7ab/0x998 [ib_srp]
    [<ffffffff81346f60>] dev_attr_store+0x20/0x30
    [<ffffffff811dd90f>] sysfs_write_file+0xef/0x170
    [<ffffffff8116d248>] vfs_write+0xc8/0x190
    [<ffffffff8116d411>] sys_write+0x51/0x90
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: Sebastian Parschauer <sebastian.riemer@profitbricks.com>
    Cc: <stable@vger.kernel.org> #v3.19
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index a611556406ac..e690847a46dd 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -170,6 +170,7 @@ struct srp_rdma_ch {
 
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;
+	bool			connected;
 };
 
 /**
@@ -214,7 +215,6 @@ struct srp_target_port {
 	__be16			pkey;
 
 	u32			rq_tmo_jiffies;
-	bool			connected;
 
 	int			zero_req_lim;
 

commit 7dad6b2e440d810273946b0e7092a8fe043c3b8a
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue Oct 21 18:00:35 2014 +0200

    IB/srp: Fix a race condition triggered by destroying a queue pair
    
    At least LID reassignment can trigger a race condition in the SRP
    initiator driver, namely the receive completion handler trying to
    post a request on a QP during or after QP destruction and before
    the CQ's have been destroyed. Avoid this race by modifying a QP
    into the error state and by waiting until all receive completions
    have been processed before destroying a QP.
    
    Reported-by: Max Gurtuvoy <maxg@mellanox.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index ca7c6f065434..a611556406ac 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -70,6 +70,8 @@ enum {
 
 	LOCAL_INV_WR_ID_MASK	= 1,
 	FAST_REG_WR_ID_MASK	= 2,
+
+	SRP_LAST_WR_ID		= 0xfffffffcU,
 };
 
 enum srp_target_state {

commit d92c0da71a35dfddccca7bfa932829504311359e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Oct 6 17:14:36 2014 +0200

    IB/srp: Add multichannel support
    
    Improve performance by using multiple RDMA/RC channels per SCSI
    host for communication with an SRP target. About the
    implementation:
    - Introduce a loop over all channels in the code that uses
      target->ch.
    - Set the SRP_MULTICHAN_MULTI flag during login for the creation
      of the second and subsequent channels.
    - RDMA completion vectors are chosen such that RDMA completion
      interrupts are handled by the CPU socket that submitted the I/O
      request. As one can see in this patch it has been assumed if a
      system contains n CPU sockets and m RDMA completion vectors
      have been assigned to an RDMA HCA that IRQ affinity has been
      configured such that completion vectors [i*m/n..(i+1)*m/n) are
      bound to CPU socket i with 0 <= i < n.
    - Modify srp_free_ch_ib() and srp_free_req_data() such that it
      becomes safe to invoke these functions after the corresponding
      allocation function failed.
    - Add a ch_count sysfs attribute per target port.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 37aa9f49947a..ca7c6f065434 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -179,8 +179,9 @@ struct srp_target_port {
 	/* read and written in the hot path */
 	spinlock_t		lock;
 
-	struct srp_rdma_ch	ch;
 	/* read only in the hot path */
+	struct srp_rdma_ch	*ch;
+	u32			ch_count;
 	u32			lkey;
 	u32			rkey;
 	enum srp_target_state	state;

commit 77f2c1a40e6fed202d08c8ec0bdca36a76dab368
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Oct 2 15:29:25 2014 +0200

    IB/srp: Use block layer tags
    
    Since the block layer already contains functionality to assign
    a tag to each request, use that functionality instead of
    reimplementing that functionality in the SRP initiator driver.
    This change makes the free_reqs list superfluous. Hence remove
    that list.
    
    [hch: updated to use .use_blk_tags instead scsi_activate_tcq]
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 74530d9e6391..37aa9f49947a 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -116,7 +116,6 @@ struct srp_host {
 };
 
 struct srp_request {
-	struct list_head	list;
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
 	union {
@@ -127,7 +126,6 @@ struct srp_request {
 	struct srp_direct_buf  *indirect_desc;
 	dma_addr_t		indirect_dma_addr;
 	short			nmdesc;
-	short			index;
 };
 
 /**
@@ -137,7 +135,6 @@ struct srp_request {
 struct srp_rdma_ch {
 	/* These are RW in the hot path, and commonly used together */
 	struct list_head	free_tx;
-	struct list_head	free_reqs;
 	spinlock_t		lock;
 	s32			req_lim;
 

commit 509c07bc18500c3ded1a8e6273ace5002136c9d2
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Oct 30 14:48:30 2014 +0100

    IB/srp: Separate target and channel variables
    
    Changes in this patch:
    - Move channel variables into a new structure (struct srp_rdma_ch).
    - Add an srp_target_port pointer, 'lock' and 'comp_vector' members
      in struct srp_rdma_ch.
    - Add code to initialize these three new member variables.
    - Many boring "target->" into "ch->" changes.
    - The cm_id and completion handler context pointers are now of type
      srp_rdma_ch * instead of srp_target_port *.
    - Three kzalloc(a * b, f) calls have been changed into kcalloc(a, b, f)
      to avoid that this patch would trigger a checkpatch warning.
    - Two casts from u64 into unsigned long long have been left out
      because these are superfluous. Since considerable time u64 is
      defined as unsigned long long for all architectures supported by
      the Linux kernel.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 8635ab674358..74530d9e6391 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -130,7 +130,11 @@ struct srp_request {
 	short			index;
 };
 
-struct srp_target_port {
+/**
+ * struct srp_rdma_ch
+ * @comp_vector: Completion vector used by this RDMA channel.
+ */
+struct srp_rdma_ch {
 	/* These are RW in the hot path, and commonly used together */
 	struct list_head	free_tx;
 	struct list_head	free_reqs;
@@ -138,13 +142,48 @@ struct srp_target_port {
 	s32			req_lim;
 
 	/* These are read-only in the hot path */
-	struct ib_cq	       *send_cq ____cacheline_aligned_in_smp;
+	struct srp_target_port *target ____cacheline_aligned_in_smp;
+	struct ib_cq	       *send_cq;
 	struct ib_cq	       *recv_cq;
 	struct ib_qp	       *qp;
 	union {
 		struct ib_fmr_pool     *fmr_pool;
 		struct srp_fr_pool     *fr_pool;
 	};
+
+	/* Everything above this point is used in the hot path of
+	 * command processing. Try to keep them packed into cachelines.
+	 */
+
+	struct completion	done;
+	int			status;
+
+	struct ib_sa_path_rec	path;
+	struct ib_sa_query     *path_query;
+	int			path_query_id;
+
+	struct ib_cm_id	       *cm_id;
+	struct srp_iu	      **tx_ring;
+	struct srp_iu	      **rx_ring;
+	struct srp_request     *req_ring;
+	int			max_ti_iu_len;
+	int			comp_vector;
+
+	struct completion	tsk_mgmt_done;
+	u8			tsk_mgmt_status;
+};
+
+/**
+ * struct srp_target_port
+ * @comp_vector: Completion vector used by the first RDMA channel created for
+ *   this target port.
+ */
+struct srp_target_port {
+	/* read and written in the hot path */
+	spinlock_t		lock;
+
+	struct srp_rdma_ch	ch;
+	/* read only in the hot path */
 	u32			lkey;
 	u32			rkey;
 	enum srp_target_state	state;
@@ -153,10 +192,7 @@ struct srp_target_port {
 	unsigned int		indirect_size;
 	bool			allow_ext_sg;
 
-	/* Everything above this point is used in the hot path of
-	 * command processing. Try to keep them packed into cachelines.
-	 */
-
+	/* other member variables */
 	union ib_gid		sgid;
 	__be64			id_ext;
 	__be64			ioc_guid;
@@ -176,33 +212,17 @@ struct srp_target_port {
 
 	union ib_gid		orig_dgid;
 	__be16			pkey;
-	struct ib_sa_path_rec	path;
-	struct ib_sa_query     *path_query;
-	int			path_query_id;
 
 	u32			rq_tmo_jiffies;
 	bool			connected;
 
-	struct ib_cm_id	       *cm_id;
-
-	int			max_ti_iu_len;
-
 	int			zero_req_lim;
 
-	struct srp_iu	       **tx_ring;
-	struct srp_iu	       **rx_ring;
-	struct srp_request	*req_ring;
-
 	struct work_struct	tl_err_work;
 	struct work_struct	remove_work;
 
 	struct list_head	list;
-	struct completion	done;
-	int			status;
 	bool			qp_in_error;
-
-	struct completion	tsk_mgmt_done;
-	u8			tsk_mgmt_status;
 };
 
 struct srp_iu {

commit 747fe000ef38eb977945146d08f9050a0e504035
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Oct 30 14:48:05 2014 +0100

    IB/srp: Introduce two new srp_target_port member variables
    
    Introduce the srp_target_port member variables 'sgid' and 'pkey'.
    Change the type of 'orig_dgid' from __be16[8] into union ib_gid.
    This patch does not change any functionality but makes the
    "Separate target and channel variables" patch easier to verify.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 00c7c480f680..8635ab674358 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -157,6 +157,7 @@ struct srp_target_port {
 	 * command processing. Try to keep them packed into cachelines.
 	 */
 
+	union ib_gid		sgid;
 	__be64			id_ext;
 	__be64			ioc_guid;
 	__be64			service_id;
@@ -173,8 +174,9 @@ struct srp_target_port {
 	int			comp_vector;
 	int			tl_retry_count;
 
+	union ib_gid		orig_dgid;
+	__be16			pkey;
 	struct ib_sa_path_rec	path;
-	__be16			orig_dgid[8];
 	struct ib_sa_query     *path_query;
 	int			path_query_id;
 

commit 34aa654ecb8eaef729c2bf51f7f97edab12fc3a6
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Oct 30 14:47:22 2014 +0100

    IB/srp: Avoid that I/O hangs due to a cable pull during LUN scanning
    
    If a cable is pulled during LUN scanning it can happen that the
    SRP rport and the SCSI host have been created but no LUNs have been
    added to the SCSI host. Since multipathd only sends SCSI commands
    to a SCSI target if one or more SCSI devices are present and since
    there is no keepalive mechanism for IB queue pairs this means that
    after a LUN scan failed and after a reconnect has succeeded no
    data will be sent over the QP and hence that a subsequent cable
    pull will not be detected. Avoid this by not creating an rport or
    SCSI host if a cable is pulled during a SCSI LUN scan.
    
    Note: so far the above behavior has only been observed with the
    kernel module parameter ch_count set to a value >= 2.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e46ecb15aa0d..00c7c480f680 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -73,6 +73,7 @@ enum {
 };
 
 enum srp_target_state {
+	SRP_TARGET_SCANNING,
 	SRP_TARGET_LIVE,
 	SRP_TARGET_REMOVED,
 };

commit 5cfb17828d877a5541171087b9d746befdf2a126
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue May 20 15:08:34 2014 +0200

    IB/srp: Add fast registration support
    
    Certain HCA types (e.g. Connect-IB) and certain configurations (e.g.
    ConnectX VF) support fast registration but not FMR. Hence add fast
    registration support.
    
    In function srp_rport_reconnect(), move the the srp_finish_req()
    loop from after to before the srp_create_target_ib() call. This is
    needed to avoid that srp_finish_req() tries to queue any
    invalidation requests for rkeys associated with the old queue pair
    on the newly allocated queue pair. Invoking srp_finish_req() before
    the queue pair has been reallocated is safe since srp_claim_req()
    handles completions correctly that arrive after srp_finish_req()
    has been invoked.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index eb130486b1c8..e46ecb15aa0d 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -68,8 +68,8 @@ enum {
 
 	SRP_MAX_PAGES_PER_MR	= 512,
 
-	SRP_MAP_ALLOW_FMR	= 0,
-	SRP_MAP_NO_FMR		= 1,
+	LOCAL_INV_WR_ID_MASK	= 1,
+	FAST_REG_WR_ID_MASK	= 2,
 };
 
 enum srp_target_state {
@@ -83,6 +83,12 @@ enum srp_iu_type {
 	SRP_IU_RSP,
 };
 
+/*
+ * @mr_page_mask: HCA memory registration page mask.
+ * @mr_page_size: HCA memory registration page size.
+ * @mr_max_size: Maximum size in bytes of a single FMR / FR registration
+ *   request.
+ */
 struct srp_device {
 	struct list_head	dev_list;
 	struct ib_device       *dev;
@@ -93,6 +99,8 @@ struct srp_device {
 	int			mr_max_size;
 	int			max_pages_per_mr;
 	bool			has_fmr;
+	bool			has_fr;
+	bool			use_fast_reg;
 };
 
 struct srp_host {
@@ -110,7 +118,10 @@ struct srp_request {
 	struct list_head	list;
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
-	struct ib_pool_fmr    **fmr_list;
+	union {
+		struct ib_pool_fmr **fmr_list;
+		struct srp_fr_desc **fr_list;
+	};
 	u64		       *map_page;
 	struct srp_direct_buf  *indirect_desc;
 	dma_addr_t		indirect_dma_addr;
@@ -129,7 +140,10 @@ struct srp_target_port {
 	struct ib_cq	       *send_cq ____cacheline_aligned_in_smp;
 	struct ib_cq	       *recv_cq;
 	struct ib_qp	       *qp;
-	struct ib_fmr_pool     *fmr_pool;
+	union {
+		struct ib_fmr_pool     *fmr_pool;
+		struct srp_fr_pool     *fr_pool;
+	};
 	u32			lkey;
 	u32			rkey;
 	enum srp_target_state	state;
@@ -196,8 +210,59 @@ struct srp_iu {
 	enum dma_data_direction	direction;
 };
 
+/**
+ * struct srp_fr_desc - fast registration work request arguments
+ * @entry: Entry in srp_fr_pool.free_list.
+ * @mr:    Memory region.
+ * @frpl:  Fast registration page list.
+ */
+struct srp_fr_desc {
+	struct list_head		entry;
+	struct ib_mr			*mr;
+	struct ib_fast_reg_page_list	*frpl;
+};
+
+/**
+ * struct srp_fr_pool - pool of fast registration descriptors
+ *
+ * An entry is available for allocation if and only if it occurs in @free_list.
+ *
+ * @size:      Number of descriptors in this pool.
+ * @max_page_list_len: Maximum fast registration work request page list length.
+ * @lock:      Protects free_list.
+ * @free_list: List of free descriptors.
+ * @desc:      Fast registration descriptor pool.
+ */
+struct srp_fr_pool {
+	int			size;
+	int			max_page_list_len;
+	spinlock_t		lock;
+	struct list_head	free_list;
+	struct srp_fr_desc	desc[0];
+};
+
+/**
+ * struct srp_map_state - per-request DMA memory mapping state
+ * @desc:	    Pointer to the element of the SRP buffer descriptor array
+ *		    that is being filled in.
+ * @pages:	    Array with DMA addresses of pages being considered for
+ *		    memory registration.
+ * @base_dma_addr:  DMA address of the first page that has not yet been mapped.
+ * @dma_len:	    Number of bytes that will be registered with the next
+ *		    FMR or FR memory registration call.
+ * @total_len:	    Total number of bytes in the sg-list being mapped.
+ * @npages:	    Number of page addresses in the pages[] array.
+ * @nmdesc:	    Number of FMR or FR memory descriptors used for mapping.
+ * @ndesc:	    Number of SRP buffer descriptors that have been filled in.
+ * @unmapped_sg:    First element of the sg-list that is mapped via FMR or FR.
+ * @unmapped_index: Index of the first element mapped via FMR or FR.
+ * @unmapped_addr:  DMA address of the first element mapped via FMR or FR.
+ */
 struct srp_map_state {
-	struct ib_pool_fmr    **next_fmr;
+	union {
+		struct ib_pool_fmr **next_fmr;
+		struct srp_fr_desc **next_fr;
+	};
 	struct srp_direct_buf  *desc;
 	u64		       *pages;
 	dma_addr_t		base_dma_addr;

commit 52ede08f00ebfc21d50a1f3e5908a78655900519
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue May 20 15:07:45 2014 +0200

    IB/srp: Rename FMR-related variables
    
    The next patch will cause the renamed variables to be shared between
    the code for FMR and for FR memory registration. Make the names of
    these variables independent of the memory registration mode. This
    patch does not change any functionality. The start of this patch was
    the changes applied via the following shell command:
    
    sed -i.orig 's/SRP_FMR_SIZE/SRP_MAX_PAGES_PER_MR/g; \
        s/fmr_page_mask/mr_page_mask/g;s/fmr_page_size/mr_page_size/g; \
        s/fmr_page_shift/mr_page_shift/g;s/fmr_max_size/mr_max_size/g; \
        s/max_pages_per_fmr/max_pages_per_mr/g;s/nfmr/nmdesc/g; \
        s/fmr_len/dma_len/g' drivers/infiniband/ulp/srp/ib_srp.[ch]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 2d99e52f2f5c..eb130486b1c8 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -66,7 +66,7 @@ enum {
 	SRP_TAG_NO_REQ		= ~0U,
 	SRP_TAG_TSK_MGMT	= 1U << 31,
 
-	SRP_FMR_SIZE		= 512,
+	SRP_MAX_PAGES_PER_MR	= 512,
 
 	SRP_MAP_ALLOW_FMR	= 0,
 	SRP_MAP_NO_FMR		= 1,
@@ -88,10 +88,10 @@ struct srp_device {
 	struct ib_device       *dev;
 	struct ib_pd	       *pd;
 	struct ib_mr	       *mr;
-	u64			fmr_page_mask;
-	int			fmr_page_size;
-	int			fmr_max_size;
-	int			max_pages_per_fmr;
+	u64			mr_page_mask;
+	int			mr_page_size;
+	int			mr_max_size;
+	int			max_pages_per_mr;
 	bool			has_fmr;
 };
 
@@ -114,7 +114,7 @@ struct srp_request {
 	u64		       *map_page;
 	struct srp_direct_buf  *indirect_desc;
 	dma_addr_t		indirect_dma_addr;
-	short			nfmr;
+	short			nmdesc;
 	short			index;
 };
 
@@ -201,10 +201,10 @@ struct srp_map_state {
 	struct srp_direct_buf  *desc;
 	u64		       *pages;
 	dma_addr_t		base_dma_addr;
-	u32			fmr_len;
+	u32			dma_len;
 	u32			total_len;
 	unsigned int		npages;
-	unsigned int		nfmr;
+	unsigned int		nmdesc;
 	unsigned int		ndesc;
 	struct scatterlist     *unmapped_sg;
 	int			unmapped_index;

commit d1b4289e16477fe13e95b88ffb7067c87b10ab6e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue May 20 15:07:20 2014 +0200

    IB/srp: One FMR pool per SRP connection
    
    Allocate one FMR pool per SRP connection instead of one SRP pool
    per HCA. This improves scalability of the SRP initiator.
    
    Only request the SCSI mid-layer to retry a SCSI command after a
    temporary mapping failure (-ENOMEM) but not after a permanent
    mapping failure. This avoids that SCSI commands are retried
    indefinitely if a permanent memory mapping failure occurs.
    
    Tell the SCSI mid-layer to reduce queue depth temporarily in the
    unlikely case where an application is queuing many requests with
    more than max_pages_per_fmr sg-list elements.
    
    For FMR pool allocation, base the max_pages_per_fmr parameter on
    the HCA memory registration limit. Only try to allocate an FMR
    pool if FMR is supported.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index aad27b7b4a46..2d99e52f2f5c 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -67,9 +67,6 @@ enum {
 	SRP_TAG_TSK_MGMT	= 1U << 31,
 
 	SRP_FMR_SIZE		= 512,
-	SRP_FMR_MIN_SIZE	= 128,
-	SRP_FMR_POOL_SIZE	= 1024,
-	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4,
 
 	SRP_MAP_ALLOW_FMR	= 0,
 	SRP_MAP_NO_FMR		= 1,
@@ -91,10 +88,11 @@ struct srp_device {
 	struct ib_device       *dev;
 	struct ib_pd	       *pd;
 	struct ib_mr	       *mr;
-	struct ib_fmr_pool     *fmr_pool;
 	u64			fmr_page_mask;
 	int			fmr_page_size;
 	int			fmr_max_size;
+	int			max_pages_per_fmr;
+	bool			has_fmr;
 };
 
 struct srp_host {
@@ -131,6 +129,7 @@ struct srp_target_port {
 	struct ib_cq	       *send_cq ____cacheline_aligned_in_smp;
 	struct ib_cq	       *recv_cq;
 	struct ib_qp	       *qp;
+	struct ib_fmr_pool     *fmr_pool;
 	u32			lkey;
 	u32			rkey;
 	enum srp_target_state	state;

commit 2d7091bcf6f893a9b1a2add357c637055eae4e68
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Mar 14 13:52:45 2014 +0100

    IB/srp: Avoid duplicate connections
    
    The connection uniqueness check is performed before a new connection
    is added to the target list. This patch protects both actions by a
    mutex such that simultaneous writes from two different threads into the
    "add_target" variable do not result in duplicate connections.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 575681063f38..aad27b7b4a46 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -105,6 +105,7 @@ struct srp_host {
 	spinlock_t		target_lock;
 	struct completion	released;
 	struct list_head	list;
+	struct mutex		add_target_mutex;
 };
 
 struct srp_request {

commit 4d73f95f708ce540a85113b00f5363d0593d871d
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Oct 26 14:40:37 2013 +0200

    IB/srp: Make queue size configurable
    
    Certain storage configurations, e.g. a sufficiently large array of
    hard disks in a RAID configuration, need a queue depth above 64 to
    achieve optimal performance. Hence make the queue depth configurable.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Tested-by: Jack Wang <xjtuwjp@gmail.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 446b0452107b..575681063f38 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -57,14 +57,11 @@ enum {
 	SRP_MAX_LUN		= 512,
 	SRP_DEF_SG_TABLESIZE	= 12,
 
-	SRP_RQ_SHIFT    	= 6,
-	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
-
-	SRP_SQ_SIZE		= SRP_RQ_SIZE,
+	SRP_DEFAULT_QUEUE_SIZE	= 1 << 6,
 	SRP_RSP_SQ_SIZE		= 1,
-	SRP_REQ_SQ_SIZE		= SRP_SQ_SIZE - SRP_RSP_SQ_SIZE,
 	SRP_TSK_MGMT_SQ_SIZE	= 1,
-	SRP_CMD_SQ_SIZE		= SRP_REQ_SQ_SIZE - SRP_TSK_MGMT_SQ_SIZE,
+	SRP_DEFAULT_CMD_SQ_SIZE = SRP_DEFAULT_QUEUE_SIZE - SRP_RSP_SQ_SIZE -
+				  SRP_TSK_MGMT_SQ_SIZE,
 
 	SRP_TAG_NO_REQ		= ~0U,
 	SRP_TAG_TSK_MGMT	= 1U << 31,
@@ -156,6 +153,8 @@ struct srp_target_port {
 	char			target_name[32];
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
+	int			queue_size;
+	int			req_ring_size;
 	int			comp_vector;
 	int			tl_retry_count;
 
@@ -173,9 +172,9 @@ struct srp_target_port {
 
 	int			zero_req_lim;
 
-	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
-	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
-	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
+	struct srp_iu	       **tx_ring;
+	struct srp_iu	       **rx_ring;
+	struct srp_request	*req_ring;
 
 	struct work_struct	tl_err_work;
 	struct work_struct	remove_work;

commit c1120f8981fe8ac8dd21092afaf664ba030a76cd
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Oct 26 14:35:08 2013 +0200

    IB/srp: Start timers if a transport layer error occurs
    
    Start the reconnect timer, fast_io_fail timer and dev_loss timers if a
    transport layer error occurs.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index fd1817e48ad4..446b0452107b 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -177,6 +177,7 @@ struct srp_target_port {
 	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
 
+	struct work_struct	tl_err_work;
 	struct work_struct	remove_work;
 
 	struct list_head	list;

commit ed9b2264fb393327a6c8a4229d8df55df596188e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Oct 26 14:34:27 2013 +0200

    IB/srp: Use SRP transport layer error recovery
    
    Enable fast_io_fail_tmo and dev_loss_tmo functionality for the IB SRP
    initiator.  Add kernel module parameters that allow to specify default
    values for these parameters.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 2a1768fcc57d..fd1817e48ad4 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -140,7 +140,6 @@ struct srp_target_port {
 	unsigned int		cmd_sg_cnt;
 	unsigned int		indirect_size;
 	bool			allow_ext_sg;
-	bool			transport_offline;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.

commit 9dd69a600a680fab1c9235a644c886d8d6a2da2a
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Oct 26 14:32:30 2013 +0200

    IB/srp: Keep rport as long as the IB transport layer
    
    Keep the rport data structure around after srp_remove_host() has
    finished until cleanup of the IB transport layer has finished
    completely. This is necessary because later patches use the rport
    pointer inside the queuecommand callback. Without this patch
    accessing the rport from inside a queuecommand callback is racy
    because srp_remove_host() must be invoked before scsi_remove_host()
    and because the queuecommand callback could get invoked after
    srp_remove_host() has finished. In other words, without this patch
    the queuecommand callback can get invoked after the rport data
    structure has been freed.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 84d821b24ec7..2a1768fcc57d 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -153,6 +153,7 @@ struct srp_target_port {
 	u16			io_class;
 	struct srp_host	       *srp_host;
 	struct Scsi_Host       *scsi_host;
+	struct srp_rport       *rport;
 	char			target_name[32];
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;

commit 7bb312e4a2f323fa460bbf9f33eeb00b5dabdb6b
Author: Vu Pham <vuhuong@mellanox.com>
Date:   Sat Oct 26 14:31:27 2013 +0200

    IB/srp: Make transport layer retry count configurable
    
    Allow the InfiniBand RC retry count to be configured by the user as an
    option in the target login string.  Reducing this retry count allows to
    reduce the path failover time.
    
    Signed-off-by: Vu Pham <vu@mellanox.com>
    
    [ bvanassche: Rewrote patch description / changed default retry count ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e641088c14dc..84d821b24ec7 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -157,6 +157,7 @@ struct srp_target_port {
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
 	int			comp_vector;
+	int			tl_retry_count;
 
 	struct ib_sa_path_rec	path;
 	__be16			orig_dgid[8];

commit 4b5e5f41c8e114bb856347134657eb9e1cccc822
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Jun 28 14:57:42 2013 +0200

    IB/srp: Make HCA completion vector configurable
    
    Several InfiniBand HCAs allow configuring the completion vector per
    CQ.  This allows spreading the workload created by IB completion
    interrupts over multiple MSI-X vectors and hence over multiple CPU
    cores.  In other words, configuring the completion vector properly not
    only allows reducing latency on an initiator connected to multiple
    SRP targets but also allows improving throughput.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 66fbedda4571..e641088c14dc 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -156,6 +156,7 @@ struct srp_target_port {
 	char			target_name[32];
 	unsigned int		scsi_id;
 	unsigned int		sg_tablesize;
+	int			comp_vector;
 
 	struct ib_sa_path_rec	path;
 	__be16			orig_dgid[8];

commit 2ce19e72f4d570c87e025ee6fca4eae699a8b712
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Feb 21 17:20:00 2013 +0000

    IB/srp: Fail I/O requests if the transport is offline
    
    If an SRP target is no longer reachable and srp_reset_host() fails to
    reconnect then ib_srp will invoke scsi_remove_host().  That function
    will invoke __scsi_remove_device() for each LUN.  And that last
    function will change the device state from SDEV_TRANSPORT_OFFLINE into
    SDEV_CANCEL.  Certain user space software, e.g. older versions of
    multipathd, continue queueing I/O to SCSI devices that are in the
    SDEV_CANCEL state.
    
    If these I/O requests are submitted as SG_IO that means that the
    REQ_PREEMPT flag will be set and hence that these requests will be
    passed to srp_queuecommand().  These requests will time out.  If new
    requests are queued fast enough from user space these active requests
    will prevent __scsi_remove_device() to finish.
    
    Avoid this by failing I/O requests in the SDEV_CANCEL state if the
    transport is offline.  Introduce a new variable to keep track of the
    transport state instead of failing requests if (!target->connected ||
    target->qp_in_error), so that the SCSI error handler has a chance to
    retry commands after a transport layer failure occurred.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: <stable@vger.kernel.org> # 3.8
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index de2d0b3c0bfe..66fbedda4571 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -140,6 +140,7 @@ struct srp_target_port {
 	unsigned int		cmd_sg_cnt;
 	unsigned int		indirect_size;
 	bool			allow_ext_sg;
+	bool			transport_offline;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.

commit ef6c49d87c3418c442a22e55e3ce2f91b163d69e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 26 16:49:18 2011 +0000

    IB/srp: Eliminate state SRP_TARGET_DEAD
    
    Only queue removal work after having changed the target state
    into SRP_TARGET_REMOVED and not if that state was already equal
    to SRP_TARGET_REMOVED.  That allows us to remove the state
    SRP_TARGET_DEAD.  Add a call to srp_disconnect_target() in
    srp_remove_target() -- due to previous changes it is now safe to
    invoke that function even if the IB connection has already
    been disconnected.  This change allows us to replace the target
    removal code in srp_remove_one() by an (indirect) call to
    srp_remove_target().  Rename srp_target_port.work into
    srp_target_port.remove_work to reflect its usage.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index ef95fa4ca3ef..de2d0b3c0bfe 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -80,8 +80,7 @@ enum {
 
 enum srp_target_state {
 	SRP_TARGET_LIVE,
-	SRP_TARGET_DEAD,
-	SRP_TARGET_REMOVED
+	SRP_TARGET_REMOVED,
 };
 
 enum srp_iu_type {
@@ -175,7 +174,7 @@ struct srp_target_port {
 	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
 
-	struct work_struct	work;
+	struct work_struct	remove_work;
 
 	struct list_head	list;
 	struct completion	done;

commit 294c875a65269361defd7aeb97804ba99eb57cbf
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sun Dec 25 12:18:12 2011 +0000

    IB/srp: Suppress superfluous error messages
    
    Keep track of the connection state.  Only report QP errors while
    connected.  Only invoke ib_send_cm_dreq() when connected so that
    invoking srp_disconnect_target() after having received a DREQ does not
    cause an error message to be printed.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 02dc3acb718c..ef95fa4ca3ef 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -163,6 +163,7 @@ struct srp_target_port {
 	int			path_query_id;
 
 	u32			rq_tmo_jiffies;
+	bool			connected;
 
 	struct ib_cm_id	       *cm_id;
 

commit 948d1e889e5bd6ceffcc31db2beba39331087df3
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Sep 3 09:25:42 2011 +0200

    IB/srp: Introduce srp_handle_qp_err()
    
    Introduce the function srp_handle_qp_err(), change the type of
    qp_in_error from int into bool and move the initialization of that
    variable from srp_reconnect_target() to srp_connect_target().
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 8b436cee46ad..02dc3acb718c 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -179,7 +179,7 @@ struct srp_target_port {
 	struct list_head	list;
 	struct completion	done;
 	int			status;
-	int			qp_in_error;
+	bool			qp_in_error;
 
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;

commit 09be70a238005cc33f2a52b0aeae52f117e81582
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Mar 17 17:18:54 2012 +0000

    IB/srp: Eliminate state SRP_TARGET_CONNECTING
    
    Block the SCSI host while reconnecting instead of representing the
    reconnection activity as a distinct SRP target state.  This allows us
    to eliminate the target state SRP_TARGET_CONNECTING.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e3a6304ba87b..8b436cee46ad 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -80,7 +80,6 @@ enum {
 
 enum srp_target_state {
 	SRP_TARGET_LIVE,
-	SRP_TARGET_CONNECTING,
 	SRP_TARGET_DEAD,
 	SRP_TARGET_REMOVED
 };

commit c9b03c1ae55decc721310b79d8f50d44fbb37dc7
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Sep 3 09:34:48 2011 +0200

    IB/srp: Increase block layer timeout
    
    Increase the block layer timeout for disks so that it is above the
    InfiniBand transport layer timeout.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Acked-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 020caf0c3789..e3a6304ba87b 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -163,6 +163,8 @@ struct srp_target_port {
 	struct ib_sa_query     *path_query;
 	int			path_query_id;
 
+	u32			rq_tmo_jiffies;
+
 	struct ib_cm_id	       *cm_id;
 
 	int			max_ti_iu_len;

commit be8b981453a4904399cb090c1660618e250092d8
Author: David Dillow <dillowda@ornl.gov>
Date:   Tue Jan 18 21:58:09 2011 -0500

    IB/srp: try to use larger FMR sizes to cover our mappings
    
    Now that we can get larger SG lists, we can take advantage of HCAs that
    allow us to use larger FMR sizes. In many cases, we can use up to 512
    entries, so start there and work our way down.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index cf696218eeeb..020caf0c3789 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -69,7 +69,8 @@ enum {
 	SRP_TAG_NO_REQ		= ~0U,
 	SRP_TAG_TSK_MGMT	= 1U << 31,
 
-	SRP_FMR_SIZE		= 256,
+	SRP_FMR_SIZE		= 512,
+	SRP_FMR_MIN_SIZE	= 128,
 	SRP_FMR_POOL_SIZE	= 1024,
 	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4,
 

commit c07d424d6118d528ef71b22b7424bfc359c307a5
Author: David Dillow <dillowda@ornl.gov>
Date:   Sun Jan 16 13:57:10 2011 -0500

    IB/srp: add support for indirect tables that don't fit in SRP_CMD
    
    This allows us to guarantee the ability to submit up to 8 MB requests
    based on the current value of SCSI_MAX_SG_CHAIN_SEGMENTS. While FMR will
    usually condense the requests into 8 SG entries, it is imperative that
    the target support external tables in case the FMR mapping fails or is
    not supported.
    
    We add a safety valve to allow targets without the needed support to
    reap the benefits of the large tables, but fail in a manner that lets
    the user know that the data didn't make it to the device. The user must
    add "allow_ext_sg=1" to the target parameters to indicate that the
    target has the needed support.
    
    If indirect_sg_entries is not specified in the modules options, then
    the sg_tablesize for the target will default to cmd_sg_entries unless
    overridden by the target options.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index b43b5e7acbde..cf696218eeeb 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -117,6 +117,8 @@ struct srp_request {
 	struct srp_iu	       *cmd;
 	struct ib_pool_fmr    **fmr_list;
 	u64		       *map_page;
+	struct srp_direct_buf  *indirect_desc;
+	dma_addr_t		indirect_dma_addr;
 	short			nfmr;
 	short			index;
 };
@@ -137,6 +139,8 @@ struct srp_target_port {
 	enum srp_target_state	state;
 	unsigned int		max_iu_len;
 	unsigned int		cmd_sg_cnt;
+	unsigned int		indirect_size;
+	bool			allow_ext_sg;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.
@@ -151,6 +155,7 @@ struct srp_target_port {
 	struct Scsi_Host       *scsi_host;
 	char			target_name[32];
 	unsigned int		scsi_id;
+	unsigned int		sg_tablesize;
 
 	struct ib_sa_path_rec	path;
 	__be16			orig_dgid[8];

commit 8f26c9ff9cd0317ad867bce972f69e0c6c2cbe3c
Author: David Dillow <dillowda@ornl.gov>
Date:   Fri Jan 14 19:45:50 2011 -0500

    IB/srp: rework mapping engine to use multiple FMR entries
    
    Instead of forcing all of the S/G entries to fit in one FMR, and falling
    back to indirect descriptors if that fails, allow the use of as many
    FMRs as needed to map the request. This lays the groundwork for allowing
    indirect descriptor tables that are larger than can fit in the command
    IU, but should marginally improve performance now by reducing the number
    of indirect descriptors needed.
    
    We increase the minimum page size for the FMR pool to 4K, as larger
    pages help increase the coverage of each FMR, and it is rare that the
    kernel would send down a request with scattered 512 byte fragments.
    
    This patch also move some of the target initialization code afte the
    parsing of options, to keep it together with the new code that needs to
    allocate memory based on the options given.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index db39dbf76216..b43b5e7acbde 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -71,7 +71,10 @@ enum {
 
 	SRP_FMR_SIZE		= 256,
 	SRP_FMR_POOL_SIZE	= 1024,
-	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4
+	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4,
+
+	SRP_MAP_ALLOW_FMR	= 0,
+	SRP_MAP_NO_FMR		= 1,
 };
 
 enum srp_target_state {
@@ -93,9 +96,9 @@ struct srp_device {
 	struct ib_pd	       *pd;
 	struct ib_mr	       *mr;
 	struct ib_fmr_pool     *fmr_pool;
-	int			fmr_page_shift;
-	int			fmr_page_size;
 	u64			fmr_page_mask;
+	int			fmr_page_size;
+	int			fmr_max_size;
 };
 
 struct srp_host {
@@ -112,7 +115,9 @@ struct srp_request {
 	struct list_head	list;
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
-	struct ib_pool_fmr     *fmr;
+	struct ib_pool_fmr    **fmr_list;
+	u64		       *map_page;
+	short			nfmr;
 	short			index;
 };
 
@@ -181,4 +186,19 @@ struct srp_iu {
 	enum dma_data_direction	direction;
 };
 
+struct srp_map_state {
+	struct ib_pool_fmr    **next_fmr;
+	struct srp_direct_buf  *desc;
+	u64		       *pages;
+	dma_addr_t		base_dma_addr;
+	u32			fmr_len;
+	u32			total_len;
+	unsigned int		npages;
+	unsigned int		nfmr;
+	unsigned int		ndesc;
+	struct scatterlist     *unmapped_sg;
+	int			unmapped_index;
+	dma_addr_t		unmapped_addr;
+};
+
 #endif /* IB_SRP_H */

commit 4924864404d0ce2c32a6d20b27b5b6fcb31e481d
Author: David Dillow <dillowda@ornl.gov>
Date:   Fri Jan 14 18:23:24 2011 -0500

    IB/srp: allow sg_tablesize to be set for each target
    
    Different configurations of target software allow differing max sizes of
    the command IU. Allowing this to be changed per-target allows all
    targets on an initiator to get an optimal setting.
    
    We deprecate srp_sg_tablesize and replace it with cmd_sg_entries in
    preparation for allowing more indirect descriptors than can fit in the
    IU.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 9dc6fc3fd894..db39dbf76216 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -130,6 +130,8 @@ struct srp_target_port {
 	u32			lkey;
 	u32			rkey;
 	enum srp_target_state	state;
+	unsigned int		max_iu_len;
+	unsigned int		cmd_sg_cnt;
 
 	/* Everything above this point is used in the hot path of
 	 * command processing. Try to keep them packed into cachelines.

commit 9af762719e8f8fa282de02997dced593030eb238
Author: David Dillow <dillowda@ornl.gov>
Date:   Fri Nov 26 15:34:46 2010 -0500

    IB/srp: consolidate hot-path variables into cache lines
    
    Put the variables accessed together in the hot-path into common
    cachelines, and separate them by RW vs RO to avoid false dirtying.
    We keep a local copy of the lkey and rkey in the target to avoid
    traversing pointers (and associated cache lines) to find them.
    
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index acb435d3c1e3..9dc6fc3fd894 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -117,6 +117,24 @@ struct srp_request {
 };
 
 struct srp_target_port {
+	/* These are RW in the hot path, and commonly used together */
+	struct list_head	free_tx;
+	struct list_head	free_reqs;
+	spinlock_t		lock;
+	s32			req_lim;
+
+	/* These are read-only in the hot path */
+	struct ib_cq	       *send_cq ____cacheline_aligned_in_smp;
+	struct ib_cq	       *recv_cq;
+	struct ib_qp	       *qp;
+	u32			lkey;
+	u32			rkey;
+	enum srp_target_state	state;
+
+	/* Everything above this point is used in the hot path of
+	 * command processing. Try to keep them packed into cachelines.
+	 */
+
 	__be64			id_ext;
 	__be64			ioc_guid;
 	__be64			service_id;
@@ -133,23 +151,13 @@ struct srp_target_port {
 	int			path_query_id;
 
 	struct ib_cm_id	       *cm_id;
-	struct ib_cq	       *recv_cq;
-	struct ib_cq	       *send_cq;
-	struct ib_qp	       *qp;
 
 	int			max_ti_iu_len;
-	s32			req_lim;
 
 	int			zero_req_lim;
 
-	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
-
-	spinlock_t		lock;
-
-	struct list_head	free_tx;
 	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
-
-	struct list_head	free_reqs;
+	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
 
 	struct work_struct	work;
@@ -157,7 +165,6 @@ struct srp_target_port {
 	struct list_head	list;
 	struct completion	done;
 	int			status;
-	enum srp_target_state	state;
 	int			qp_in_error;
 
 	struct completion	tsk_mgmt_done;

commit e9684678221441f886b4d7c74f8770bb0981737a
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Nov 26 15:08:38 2010 -0500

    IB/srp: stop sharing the host lock with SCSI
    
    We don't need protection against the SCSI stack, so use our own lock to
    allow parallel progress on separate CPUs.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    [ broken out and small cleanups by David Dillow ]
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 81686eee7e62..acb435d3c1e3 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -144,6 +144,8 @@ struct srp_target_port {
 
 	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 
+	spinlock_t		lock;
+
 	struct list_head	free_tx;
 	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
 

commit 76c75b258f1fe6abac6af2356989ad4d6518886e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Nov 26 14:37:47 2010 -0500

    IB/srp: reduce local coverage for command submission and EH
    
    We only need locks to protect our lists and number of credits available.
    By pre-consuming the credit for the request, we can reduce our lock
    coverage to just those areas. If we don't actually send the request,
    we'll need to put the credit back into the pool.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    [ broken out and small cleanups by David Dillow ]
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 924d8e9c6672..81686eee7e62 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -168,7 +168,6 @@ struct srp_iu {
 	void		       *buf;
 	size_t			size;
 	enum dma_data_direction	direction;
-	enum srp_iu_type	type;
 };
 
 #endif /* IB_SRP_H */

commit 536ae14e7588e85203d4b4147c041309be5b3efb
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Nov 26 13:58:27 2010 -0500

    IB/srp: don't move active requests to their own list
    
    We use req->scmnd != NULL to indicate an active request, so there's no
    need to keep a separate list for them. We can afford the array iteration
    during error handling, and dropping it gives us one less item that needs
    lock protection.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    [ broken out and small cleanups by David Dillow ]
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 41ecb46adf15..924d8e9c6672 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -148,7 +148,6 @@ struct srp_target_port {
 	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
 
 	struct list_head	free_reqs;
-	struct list_head	req_queue;
 	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
 
 	struct work_struct	work;

commit dcb4cb85f4b7caac9769bce464fef16306a4758c
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Nov 26 13:22:48 2010 -0500

    IB/srp: allow lockless work posting
    
    Only one CPU at a time will own an RX IU, so using the address of the IU
    as the work request cookie allows us to avoid taking a lock. We can
    similarly prepare the TX path for lockless posting by moving the free TX
    IUs to a list. This also removes the requirement that the queue sizes be
    a power of 2.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    [ broken out, small cleanups, and modified to avoid needing an extra field
      in the IU by David Dillow]
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index f8b689a644b7..41ecb46adf15 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -59,10 +59,8 @@ enum {
 
 	SRP_RQ_SHIFT    	= 6,
 	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
-	SRP_RQ_MASK		= SRP_RQ_SIZE - 1,
 
 	SRP_SQ_SIZE		= SRP_RQ_SIZE,
-	SRP_SQ_MASK		= SRP_SQ_SIZE - 1,
 	SRP_RSP_SQ_SIZE		= 1,
 	SRP_REQ_SQ_SIZE		= SRP_SQ_SIZE - SRP_RSP_SQ_SIZE,
 	SRP_TSK_MGMT_SQ_SIZE	= 1,
@@ -144,11 +142,9 @@ struct srp_target_port {
 
 	int			zero_req_lim;
 
-	unsigned		rx_head;
 	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 
-	unsigned		tx_head;
-	unsigned		tx_tail;
+	struct list_head	free_tx;
 	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
 
 	struct list_head	free_reqs;
@@ -168,6 +164,7 @@ struct srp_target_port {
 };
 
 struct srp_iu {
+	struct list_head	list;
 	u64			dma;
 	void		       *buf;
 	size_t			size;

commit f8b6e31e4e46bf514c27fce38783ed5615cca01d
Author: David Dillow <dillowda@ornl.gov>
Date:   Fri Nov 26 13:02:21 2010 -0500

    IB/srp: allow task management without a previous request
    
    We can only have one task management comment outstanding, so move the
    completion and status to the target port. This allows us to handle
    resets of a LUN without a corresponding request having been sent.
    Meanwhile, we don't need to play games with host_scribble, just use it
    as the pointer it is.
    
    This fixes a crash when we issue a bus reset using sg_reset.
    
    Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=13893
    Reported-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: David Dillow <dillowda@ornl.gov>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index ed0dce9e479f..f8b689a644b7 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -68,7 +68,8 @@ enum {
 	SRP_TSK_MGMT_SQ_SIZE	= 1,
 	SRP_CMD_SQ_SIZE		= SRP_REQ_SQ_SIZE - SRP_TSK_MGMT_SQ_SIZE,
 
-	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1),
+	SRP_TAG_NO_REQ		= ~0U,
+	SRP_TAG_TSK_MGMT	= 1U << 31,
 
 	SRP_FMR_SIZE		= 256,
 	SRP_FMR_POOL_SIZE	= 1024,
@@ -113,12 +114,8 @@ struct srp_request {
 	struct list_head	list;
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
-	struct srp_iu	       *tsk_mgmt;
 	struct ib_pool_fmr     *fmr;
-	struct completion	done;
 	short			index;
-	u8			cmd_done;
-	u8			tsk_status;
 };
 
 struct srp_target_port {
@@ -165,6 +162,9 @@ struct srp_target_port {
 	int			status;
 	enum srp_target_state	state;
 	int			qp_in_error;
+
+	struct completion	tsk_mgmt_done;
+	u8			tsk_mgmt_status;
 };
 
 struct srp_iu {

commit bb12588a38e6db85e01dceadff7bc161fc92e7d2
Author: David Dillow <dillowda@ornl.gov>
Date:   Fri Oct 8 14:40:47 2010 -0400

    IB/srp: Implement SRP_CRED_REQ and SRP_AER_REQ
    
    This patch adds support for SRP_CRED_REQ to avoid a lockup by targets
    that use that mechanism to return credits to the initiator. This
    prevents a lockup observed in the field where we would never add the
    credits from the SRP_CRED_REQ to our current count, and would therefore
    never send another command to the target.
    
    Minimal support for SRP_AER_REQ is also added, as these messages can
    also be used to convey additional credits to the initiator.
    
    Based upon extensive debugging and code by Bart Van Assche and a bug
    report by Chris Worley.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 7a959d5f2fa6..ed0dce9e479f 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -82,9 +82,10 @@ enum srp_target_state {
 	SRP_TARGET_REMOVED
 };
 
-enum srp_request_type {
-	SRP_REQ_NORMAL,
-	SRP_REQ_TASK_MGMT,
+enum srp_iu_type {
+	SRP_IU_CMD,
+	SRP_IU_TSK_MGMT,
+	SRP_IU_RSP,
 };
 
 struct srp_device {
@@ -171,6 +172,7 @@ struct srp_iu {
 	void		       *buf;
 	size_t			size;
 	enum dma_data_direction	direction;
+	enum srp_iu_type	type;
 };
 
 #endif /* IB_SRP_H */

commit dd5e6e38b2b8bd8bf71cae800e2b613e85ef1522
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Aug 30 19:27:20 2010 +0000

    IB/srp: Preparation for transmit ring response allocation
    
    The transmit ring in ib_srp (srp_target.tx_ring) is currently only used
    for allocating requests sent by the initiator to the target. This patch
    prepares using that ring for allocation of both requests and responses.
    Also, this patch differentiates the uses of SRP_SQ_SIZE, increases the
    size of the IB send completion queue by one element and reserves one
    transmit ring slot for SRP_TSK_MGMT requests.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 5a80eac6fdaa..7a959d5f2fa6 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -59,7 +59,14 @@ enum {
 
 	SRP_RQ_SHIFT    	= 6,
 	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
-	SRP_SQ_SIZE		= SRP_RQ_SIZE - 1,
+	SRP_RQ_MASK		= SRP_RQ_SIZE - 1,
+
+	SRP_SQ_SIZE		= SRP_RQ_SIZE,
+	SRP_SQ_MASK		= SRP_SQ_SIZE - 1,
+	SRP_RSP_SQ_SIZE		= 1,
+	SRP_REQ_SQ_SIZE		= SRP_SQ_SIZE - SRP_RSP_SQ_SIZE,
+	SRP_TSK_MGMT_SQ_SIZE	= 1,
+	SRP_CMD_SQ_SIZE		= SRP_REQ_SQ_SIZE - SRP_TSK_MGMT_SQ_SIZE,
 
 	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1),
 
@@ -144,11 +151,11 @@ struct srp_target_port {
 
 	unsigned		tx_head;
 	unsigned		tx_tail;
-	struct srp_iu	       *tx_ring[SRP_SQ_SIZE + 1];
+	struct srp_iu	       *tx_ring[SRP_SQ_SIZE];
 
 	struct list_head	free_reqs;
 	struct list_head	req_queue;
-	struct srp_request	req_ring[SRP_SQ_SIZE];
+	struct srp_request	req_ring[SRP_CMD_SQ_SIZE];
 
 	struct work_struct	work;
 

commit 9c03dc9f19351edf25c1107e3cfd3cc538c7ab9e
Author: Bart Van Assche <bart.vanassche@gmail.com>
Date:   Tue Feb 2 19:23:54 2010 +0000

    IB/srp: Split send and recieve CQs to reduce number of interrupts
    
    We can reduce the number of IB interrupts from two interrupts per
    srp_queuecommand() call to one by using separate CQs for send and
    receive completions and processing send completions by polling every
    time a TX IU is allocated.
    
    Receive completion events still trigger an interrupt.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@gmail.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e185b907fc12..5a80eac6fdaa 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -60,7 +60,6 @@ enum {
 	SRP_RQ_SHIFT    	= 6,
 	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
 	SRP_SQ_SIZE		= SRP_RQ_SIZE - 1,
-	SRP_CQ_SIZE		= SRP_SQ_SIZE + SRP_RQ_SIZE,
 
 	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1),
 
@@ -69,8 +68,6 @@ enum {
 	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4
 };
 
-#define SRP_OP_RECV		(1 << 31)
-
 enum srp_target_state {
 	SRP_TARGET_LIVE,
 	SRP_TARGET_CONNECTING,
@@ -133,7 +130,8 @@ struct srp_target_port {
 	int			path_query_id;
 
 	struct ib_cm_id	       *cm_id;
-	struct ib_cq	       *cq;
+	struct ib_cq	       *recv_cq;
+	struct ib_cq	       *send_cq;
 	struct ib_qp	       *qp;
 
 	int			max_ti_iu_len;

commit f3781d2e89f12dd5afa046dc56032af6e39bd116
Author: Roland Dreier <rolandd@cisco.com>
Date:   Mon Jul 14 23:48:44 2008 -0700

    RDMA: Remove subversion $Id tags
    
    They don't get updated by git and so they're worse than useless.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 63d2ae724061..e185b907fc12 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -28,8 +28,6 @@
  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
- *
- * $Id: ib_srp.h 3932 2005-11-01 17:19:29Z roland $
  */
 
 #ifndef IB_SRP_H

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 67e17c336a50..63d2ae724061 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -99,7 +99,7 @@ struct srp_device {
 struct srp_host {
 	struct srp_device      *srp_dev;
 	u8			port;
-	struct class_device	class_dev;
+	struct device		dev;
 	struct list_head	target_list;
 	spinlock_t		target_lock;
 	struct completion	released;

commit 05321937469a8592d6a6d35f1d38ca882d243044
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 6 00:13:36 2008 +0100

    IB: rename "dev" to "srp_dev" in srp_host structure
    
    This sets us up to be able to convert the srp_host to use a struct
    device instead of a class_device.
    
    Based on a original patch from Tony Jones, but split up into this piece
    by Greg.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Reviewed-by: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index cb6eb816024a..67e17c336a50 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -97,7 +97,7 @@ struct srp_device {
 };
 
 struct srp_host {
-	struct srp_device      *dev;
+	struct srp_device      *srp_dev;
 	u8			port;
 	struct class_device	class_dev;
 	struct list_head	target_list;

commit 9fe4bcf45ece0b0081031edaaa41581c85ef7049
Author: David Dillow <dillowda@ornl.gov>
Date:   Tue Jan 8 17:08:52 2008 -0500

    IB/srp: Retry stale connections
    
    When a host just goes away (crash, power loss, etc.) without tearing
    down its IB connections, it can get stale connection errors when it
    tries to reconnect to targets upon rebooting.  Retrying the connection
    a few times will prevent sysadmins from playing the "which disk(s)
    went missing?" game.
    
    This would have made things slightly quicker when tracking down some
    of the recent bugs, but it also helps quite a bit when you've got a
    large number of targets hanging off a wedged server.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 4a3c1f37e4c2..cb6eb816024a 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -54,6 +54,7 @@ enum {
 
 	SRP_PORT_REDIRECT	= 1,
 	SRP_DLID_REDIRECT	= 2,
+	SRP_STALE_CONN		= 3,
 
 	SRP_MAX_LUN		= 512,
 	SRP_DEF_SG_TABLESIZE	= 12,

commit 8cba2077325b361dedf058c7dfc6c33691422497
Author: David Dillow <dillowda@ornl.gov>
Date:   Wed Dec 19 17:08:43 2007 -0500

    IB/srp: Respect target credit limit
    
    The current SRP initiator will send requests even if it has no credits
    available.  The results of sending extra requests are vendor specific,
    but on some devices, overrunning credits will cost 85% of peak
    performance -- e.g. 100 MB/s vs 720 MB/s.  Other devices may just drop
    the requests.
    
    This patch will tell the SCSI midlayer to queue requests if there are
    fewer than two credits remaining, and will not issue a task management
    request if there are no credits remaining.  The mid-layer will retry
    the queued command once an outstanding command completes.
    
    The patch also removes the unlikely() in __srp_get_tx_iu(), as it is
    not at all unlikely to hit this limit under heavy load.
    
    Signed-off-by: David Dillow <dillowda@ornl.gov>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index e3573e7038c4..4a3c1f37e4c2 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -79,6 +79,11 @@ enum srp_target_state {
 	SRP_TARGET_REMOVED
 };
 
+enum srp_request_type {
+	SRP_REQ_NORMAL,
+	SRP_REQ_TASK_MGMT,
+};
+
 struct srp_device {
 	struct list_head	dev_list;
 	struct ib_device       *dev;

commit bb350d1decd9c48ffaa7f7e263df3056df9f4f21
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat May 26 02:28:25 2007 +0900

    [SCSI] ib_srp: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 1d53c7bc368f..e3573e7038c4 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -106,11 +106,6 @@ struct srp_request {
 	struct srp_iu	       *cmd;
 	struct srp_iu	       *tsk_mgmt;
 	struct ib_pool_fmr     *fmr;
-	/*
-	 * Fake scatterlist used when scmnd->use_sg==0.  Can be killed
-	 * when the SCSI midlayer no longer generates non-SG commands.
-	 */
-	struct scatterlist	fake_sg;
 	struct completion	done;
 	short			index;
 	u8			cmd_done;

commit 3633b3d096286cf21bc07b16fa6265fb006d0844
Author: Ishai Rabinovitz <ishai@mellanox.co.il>
Date:   Sun May 6 21:18:11 2007 -0700

    IB/srp: Add orig_dgid sysfs attribute to scsi_host
    
    Add an orig_dgid attribute in sysfs for SRP scsi_hosts, so that
    userspace can tell what the original dgid value written to the
    add_target file was, even if the connection is redirected to a
    different port while connecting.
    
    Signed-off-by: Ishai Rabinovitz <ishai@mellanox.co.il>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 2f3319c719a5..1d53c7bc368f 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -129,6 +129,7 @@ struct srp_target_port {
 	unsigned int		scsi_id;
 
 	struct ib_sa_path_rec	path;
+	__be16			orig_dgid[8];
 	struct ib_sa_query     *path_query;
 	int			path_query_id;
 

commit 1033ff670d49760604f5d4c73a1b60741863a406
Author: Ishai Rabinovitz <ishai@mellanox.co.il>
Date:   Tue Jan 16 17:26:22 2007 +0200

    IB/srp: Don't wait for response when QP is in error state.
    
    When there is a call to send_tsk_mgmt SRP posts a send and waits for 5
    seconds to get a response.
    
    When the QP is in the error state it is obvious that there will be no
    response so it is quite useless to wait.  In fact, the timeout causes
    SRP to wait a long time to reconnect when a QP error occurs. (Each
    abort and each reset_device calls send_tsk_mgmt, which waits for the
    timeout).  The following patch solves this problem by identifying the
    failure and returning an immediate error code.
    
    Signed-off-by: Ishai Rabinovitz <ishai@mellanox.co.il>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index c21772317b86..2f3319c719a5 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -158,6 +158,7 @@ struct srp_target_port {
 	struct completion	done;
 	int			status;
 	enum srp_target_state	state;
+	int			qp_in_error;
 };
 
 struct srp_iu {

commit bf628dc22a09ed2022abb32c76011ae5f99ad6b0
Author: Roland Dreier <rolandd@cisco.com>
Date:   Fri Dec 15 14:01:49 2006 -0800

    IB/srp: Fix FMR mapping for 32-bit kernels and addresses above 4G
    
    struct srp_device.fmr_page_mask was unsigned long, which means that
    the top part of addresses above 4G was being chopped off on 32-bit
    architectures.  Of course nothing good happens when data from SRP
    targets is DMAed to the wrong place.
    
    Fix this by changing fmr_page_mask to u64, to match the addresses
    actually used by IB devices.
    
    Thanks to Brian Cain <Brian.Cain@ge.com> and David McMillen
    <davem@systemfabricworks.com> for help diagnosing the bug and testing
    the fix.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 868a540ef7cd..c21772317b86 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -87,7 +87,7 @@ struct srp_device {
 	struct ib_fmr_pool     *fmr_pool;
 	int			fmr_page_shift;
 	int			fmr_page_size;
-	unsigned long		fmr_page_mask;
+	u64			fmr_page_mask;
 };
 
 struct srp_host {

commit 85507bcce0cd6ec859943da4e07227c124a18f3f
Author: Ralph Campbell <ralph.campbell@qlogic.com>
Date:   Tue Dec 12 14:30:55 2006 -0800

    IB/srp: Use new verbs IB DMA mapping functions
    
    Convert SRP to use the new verbs DMA mapping functions for kernel
    verbs consumers.
    
    Signed-off-by: Ralph Campbell <ralph.campbell@qlogic.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index d4e35ef51374..868a540ef7cd 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -161,7 +161,7 @@ struct srp_target_port {
 };
 
 struct srp_iu {
-	dma_addr_t		dma;
+	u64			dma;
 	void		       *buf;
 	size_t			size;
 	enum dma_data_direction	direction;

commit 01cb9bcbd34b7ba768a7f05375faf43becdb8a60
Author: Ishai Rabinovitz <ishai@mellanox.co.il>
Date:   Wed Oct 4 15:28:56 2006 +0200

    IB/srp: Enable multiple connections to the same target
    
    Enable multiple concurrent connections to the same SRP target:
    
    1) Use port GUID instead of node GUID in the initiator port
       identifier.  This allows connections to be made from multiple HCA
       ports at the same time.
    2) Let the user specify the identifier extention when adding the
       device.  This allows userspace to make multiple connections even
       from the same port, if it wants too.
    
    Without this, only one connection can be made from any given HCA, even
    if it has multiple ports, because we don't use multi-channel mode, so
    targets will only allow one connection from a given initiator port ID.
    
    Signed-off-by: Ishai Rabinovitz <ishai@mellanox.co.il>
    Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 5b581fb8eb0d..d4e35ef51374 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -91,7 +91,6 @@ struct srp_device {
 };
 
 struct srp_host {
-	u8			initiator_port_id[16];
 	struct srp_device      *dev;
 	u8			port;
 	struct class_device	class_dev;
@@ -122,6 +121,7 @@ struct srp_target_port {
 	__be64			id_ext;
 	__be64			ioc_guid;
 	__be64			service_id;
+	__be64			initiator_ext;
 	u16			io_class;
 	struct srp_host	       *srp_host;
 	struct Scsi_Host       *scsi_host;

commit 0c0450db31481aa01a04e7faecc93ee6841972d6
Author: Ramachandra K <rkuchimanchi@silverstorm.com>
Date:   Sat Jun 17 20:37:38 2006 -0700

    IB/srp: Support SRP rev. 10 targets
    
    There has been a change in the format of port identifiers between
    revision 10 of the SRP specification and the current revision 16A.
    
    Revision 10 specifies port identifier format as
    
      lower 8 bytes :  GUID   upper 8 bytes :  Extension
    
    Whereas revision 16A specifies it as
    
     lower 8 bytes :  Extension  upper 8 bytes :  GUID
    
    There are older targets (e.g. SilverStorm Virtual Fibre Channel
    Bridge) which conform to revision 10 of the SRP specification.
    
    The I/O class of revision 10 is 0xFF00 and the I/O class of revision
    16A is 0x0100.
    
    For supporting older targets, this patch:
    
    1) Adds a new optional target creation parameter "io_class". Default
       value of io_class is 0x0100 (i.e. revision 16A)
    2) Uses the correct port identifier format for targets with IO class
       of 0xFF00 (i.e. conforming to revision 10)
    
    Signed-off-by: Ramachandra K <rkuchimanchi@silverstorm.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index ad45e4856e1c..5b581fb8eb0d 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -122,6 +122,7 @@ struct srp_target_port {
 	__be64			id_ext;
 	__be64			ioc_guid;
 	__be64			service_id;
+	u16			io_class;
 	struct srp_host	       *srp_host;
 	struct Scsi_Host       *scsi_host;
 	char			target_name[32];

commit 6bfa24fa3e189269e113197a80e12862c211b3d3
Author: Roland Dreier <rolandd@cisco.com>
Date:   Sat Jun 17 20:37:33 2006 -0700

    IB/srp: Get rid of "Target has req_lim 0" messages
    
    It's perfectly valid for a connection to an SRP target to have a
    request limit of 0, so get rid of the message about it, which can spam
    kernel logs even with printk_ratelimit().  Keep a count of such events
    in a "zero_req_lim" SCSI host attribute instead, so someone who cares
    can look at the statistics.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 033a44772ae3..ad45e4856e1c 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -138,6 +138,8 @@ struct srp_target_port {
 	int			max_ti_iu_len;
 	s32			req_lim;
 
+	int			zero_req_lim;
+
 	unsigned		rx_head;
 	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
 

commit 74b0a15b5e18e44206c98419745a472c3d28e561
Author: Vu Pham <vu@mellanox.com>
Date:   Sat Jun 17 20:37:32 2006 -0700

    IB/srp: Allow sg_tablesize to be adjusted
    
    Make the sg_tablesize used by SRP adjustable at module load time via a
    module parameter.  Calculate the corresponding IU length required to
    support this.
    
    Signed-off-by: Vu Pham <vu@mellanox.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index c071c3032700..033a44772ae3 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -56,7 +56,7 @@ enum {
 	SRP_DLID_REDIRECT	= 2,
 
 	SRP_MAX_LUN		= 512,
-	SRP_MAX_IU_LEN		= 256,
+	SRP_DEF_SG_TABLESIZE	= 12,
 
 	SRP_RQ_SHIFT    	= 6,
 	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
@@ -71,9 +71,6 @@ enum {
 };
 
 #define SRP_OP_RECV		(1 << 31)
-#define SRP_MAX_INDIRECT	((SRP_MAX_IU_LEN -			\
-				  sizeof (struct srp_cmd) -		\
-				  sizeof (struct srp_indirect_buf)) / 16)
 
 enum srp_target_state {
 	SRP_TARGET_LIVE,

commit b3589fd49067bab9fe0c60430860e6befbd5ba37
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat Jun 17 20:37:30 2006 -0700

    IB/srp: Change target_mutex to a spinlock
    
    The SRP driver never sleeps while holding target_mutex, and it's just
    used to protect some simple list operations, so hold times will be
    short.  So just convert it to a spinlock, which is smaller and faster.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 5ecda4ad8906..c071c3032700 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -99,7 +99,7 @@ struct srp_host {
 	u8			port;
 	struct class_device	class_dev;
 	struct list_head	target_list;
-	struct mutex		target_mutex;
+	spinlock_t		target_lock;
 	struct completion	released;
 	struct list_head	list;
 };

commit f5358a172f79e3f995919224401b25637f4324f6
Author: Roland Dreier <rolandd@cisco.com>
Date:   Sat Jun 17 20:37:29 2006 -0700

    IB/srp: Use FMRs to map gather/scatter lists
    
    Create an SRP FMR pool on HCAs that support FMRs, and use FMRs to map
    gather/scatter lists that have more than one entry into a single
    memory region that appears virtually contiguous to the SRP target
    (which is the RDMA initiator).
    
    This patch bails out on FMR mapping for SCSI commands where the
    gather/scatter list cannot be mapped into a single FMR because there
    are sub-page-sized entries in middle of the list.  An unaligned
    start or end of the list is OK.
    
    Based on a patch by Vu Pham <vuhuong@mellanox.com>.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index c5cd43aae860..5ecda4ad8906 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -46,6 +46,7 @@
 #include <rdma/ib_verbs.h>
 #include <rdma/ib_sa.h>
 #include <rdma/ib_cm.h>
+#include <rdma/ib_fmr_pool.h>
 
 enum {
 	SRP_PATH_REC_TIMEOUT_MS	= 1000,
@@ -62,7 +63,11 @@ enum {
 	SRP_SQ_SIZE		= SRP_RQ_SIZE - 1,
 	SRP_CQ_SIZE		= SRP_SQ_SIZE + SRP_RQ_SIZE,
 
-	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1)
+	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1),
+
+	SRP_FMR_SIZE		= 256,
+	SRP_FMR_POOL_SIZE	= 1024,
+	SRP_FMR_DIRTY_SIZE	= SRP_FMR_POOL_SIZE / 4
 };
 
 #define SRP_OP_RECV		(1 << 31)
@@ -77,15 +82,24 @@ enum srp_target_state {
 	SRP_TARGET_REMOVED
 };
 
-struct srp_host {
-	u8			initiator_port_id[16];
+struct srp_device {
+	struct list_head	dev_list;
 	struct ib_device       *dev;
-	u8                      port;
 	struct ib_pd	       *pd;
 	struct ib_mr	       *mr;
+	struct ib_fmr_pool     *fmr_pool;
+	int			fmr_page_shift;
+	int			fmr_page_size;
+	unsigned long		fmr_page_mask;
+};
+
+struct srp_host {
+	u8			initiator_port_id[16];
+	struct srp_device      *dev;
+	u8			port;
 	struct class_device	class_dev;
 	struct list_head	target_list;
-	struct mutex            target_mutex;
+	struct mutex		target_mutex;
 	struct completion	released;
 	struct list_head	list;
 };
@@ -95,6 +109,7 @@ struct srp_request {
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
 	struct srp_iu	       *tsk_mgmt;
+	struct ib_pool_fmr     *fmr;
 	/*
 	 * Fake scatterlist used when scmnd->use_sg==0.  Can be killed
 	 * when the SCSI midlayer no longer generates non-SG commands.

commit d945e1df28ca07642b3e1a9b9d07074ba5f76be0
Author: Roland Dreier <rolandd@cisco.com>
Date:   Tue May 9 10:50:28 2006 -0700

    IB/srp: Fix tracking of pending requests during error handling
    
    If a SCSI abort completes, or the command completes successfully, then
    the driver must remove the command from its queue of pending
    commands.  Similarly, if a device reset succeeds, then all commands
    queued for the given device must be removed from the queue.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index bd7f7c3115de..c5cd43aae860 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -101,7 +101,7 @@ struct srp_request {
 	 */
 	struct scatterlist	fake_sg;
 	struct completion	done;
-	short			next;
+	short			index;
 	u8			cmd_done;
 	u8			tsk_status;
 };
@@ -133,7 +133,7 @@ struct srp_target_port {
 	unsigned		tx_tail;
 	struct srp_iu	       *tx_ring[SRP_SQ_SIZE + 1];
 
-	int			req_head;
+	struct list_head	free_reqs;
 	struct list_head	req_queue;
 	struct srp_request	req_ring[SRP_SQ_SIZE];
 

commit cf368713a3f3b2eb737a92d1b7186dedcc51167c
Author: Roland Dreier <rolandd@cisco.com>
Date:   Fri Mar 24 15:47:26 2006 -0800

    IB/srp: Use a fake scatterlist for non-SG SCSI commands
    
    Since the SCSI midlayer is moving towards entirely getting rid of
    commands with use_sg == 0, we should treat this case as an exception.
    Therefore, change the IB SRP initiator to create a fake scatterlist
    for these commands with sg_init_one().  This simplifies the flow of
    DMA mapping and unmapping, since SRP can just use dma_map_sg() and
    dma_unmap_sg() unconditionally, rather than having to choose between
    the dma_{map,unmap}_sg() and dma_{map,unmap}_single() variants.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 4e7727df32f1..bd7f7c3115de 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -38,6 +38,7 @@
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
+#include <linux/scatterlist.h>
 
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
@@ -94,7 +95,11 @@ struct srp_request {
 	struct scsi_cmnd       *scmnd;
 	struct srp_iu	       *cmd;
 	struct srp_iu	       *tsk_mgmt;
-	DECLARE_PCI_UNMAP_ADDR(direct_mapping)
+	/*
+	 * Fake scatterlist used when scmnd->use_sg==0.  Can be killed
+	 * when the SCSI midlayer no longer generates non-SG commands.
+	 */
+	struct scatterlist	fake_sg;
 	struct completion	done;
 	short			next;
 	u8			cmd_done;

commit 8e9e5f4f5eb1d44ddabfd1ddea4ca4e4244a9ffb
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 30 15:21:21 2006 -0800

    IB/srp: Semaphore to mutex conversion
    
    Convert srp_host->target_mutex from a semaphore to a mutex.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index b564f18caf78..4e7727df32f1 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -37,8 +37,7 @@
 
 #include <linux/types.h>
 #include <linux/list.h>
-
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
@@ -85,7 +84,7 @@ struct srp_host {
 	struct ib_mr	       *mr;
 	struct class_device	class_dev;
 	struct list_head	target_list;
-	struct semaphore        target_mutex;
+	struct mutex            target_mutex;
 	struct completion	released;
 	struct list_head	list;
 };

commit 5f068992a1bccda5574b4f6d33458ef806686d7f
Author: Roland Dreier <rolandd@cisco.com>
Date:   Fri Nov 11 14:06:01 2005 -0800

    [IB] srp: increase max_luns
    
    Increase SRP max_luns to 512 to match the kernel's default, since SRP
    storage targets can have lots of LUNs and the SRP initiator itself
    doesn't have any particular limit.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 4fec28a71367..b564f18caf78 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -54,6 +54,7 @@ enum {
 	SRP_PORT_REDIRECT	= 1,
 	SRP_DLID_REDIRECT	= 2,
 
+	SRP_MAX_LUN		= 512,
 	SRP_MAX_IU_LEN		= 256,
 
 	SRP_RQ_SHIFT    	= 6,

commit aef9ec39c47f0cece886ddd6b53c440321e0b2a6
Author: Roland Dreier <rolandd@cisco.com>
Date:   Wed Nov 2 14:07:13 2005 -0800

    IB: Add SCSI RDMA Protocol (SRP) initiator
    
    Add an InfiniBand SCSI RDMA Protocol (SRP) initiator.  This driver is
    used to talk talk to InfiniBand SRP targets (storage devices).
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
new file mode 100644
index 000000000000..4fec28a71367
--- /dev/null
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2005 Cisco Systems.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Id: ib_srp.h 3932 2005-11-01 17:19:29Z roland $
+ */
+
+#ifndef IB_SRP_H
+#define IB_SRP_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+
+#include <asm/semaphore.h>
+
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+
+#include <rdma/ib_verbs.h>
+#include <rdma/ib_sa.h>
+#include <rdma/ib_cm.h>
+
+enum {
+	SRP_PATH_REC_TIMEOUT_MS	= 1000,
+	SRP_ABORT_TIMEOUT_MS	= 5000,
+
+	SRP_PORT_REDIRECT	= 1,
+	SRP_DLID_REDIRECT	= 2,
+
+	SRP_MAX_IU_LEN		= 256,
+
+	SRP_RQ_SHIFT    	= 6,
+	SRP_RQ_SIZE		= 1 << SRP_RQ_SHIFT,
+	SRP_SQ_SIZE		= SRP_RQ_SIZE - 1,
+	SRP_CQ_SIZE		= SRP_SQ_SIZE + SRP_RQ_SIZE,
+
+	SRP_TAG_TSK_MGMT	= 1 << (SRP_RQ_SHIFT + 1)
+};
+
+#define SRP_OP_RECV		(1 << 31)
+#define SRP_MAX_INDIRECT	((SRP_MAX_IU_LEN -			\
+				  sizeof (struct srp_cmd) -		\
+				  sizeof (struct srp_indirect_buf)) / 16)
+
+enum srp_target_state {
+	SRP_TARGET_LIVE,
+	SRP_TARGET_CONNECTING,
+	SRP_TARGET_DEAD,
+	SRP_TARGET_REMOVED
+};
+
+struct srp_host {
+	u8			initiator_port_id[16];
+	struct ib_device       *dev;
+	u8                      port;
+	struct ib_pd	       *pd;
+	struct ib_mr	       *mr;
+	struct class_device	class_dev;
+	struct list_head	target_list;
+	struct semaphore        target_mutex;
+	struct completion	released;
+	struct list_head	list;
+};
+
+struct srp_request {
+	struct list_head	list;
+	struct scsi_cmnd       *scmnd;
+	struct srp_iu	       *cmd;
+	struct srp_iu	       *tsk_mgmt;
+	DECLARE_PCI_UNMAP_ADDR(direct_mapping)
+	struct completion	done;
+	short			next;
+	u8			cmd_done;
+	u8			tsk_status;
+};
+
+struct srp_target_port {
+	__be64			id_ext;
+	__be64			ioc_guid;
+	__be64			service_id;
+	struct srp_host	       *srp_host;
+	struct Scsi_Host       *scsi_host;
+	char			target_name[32];
+	unsigned int		scsi_id;
+
+	struct ib_sa_path_rec	path;
+	struct ib_sa_query     *path_query;
+	int			path_query_id;
+
+	struct ib_cm_id	       *cm_id;
+	struct ib_cq	       *cq;
+	struct ib_qp	       *qp;
+
+	int			max_ti_iu_len;
+	s32			req_lim;
+
+	unsigned		rx_head;
+	struct srp_iu	       *rx_ring[SRP_RQ_SIZE];
+
+	unsigned		tx_head;
+	unsigned		tx_tail;
+	struct srp_iu	       *tx_ring[SRP_SQ_SIZE + 1];
+
+	int			req_head;
+	struct list_head	req_queue;
+	struct srp_request	req_ring[SRP_SQ_SIZE];
+
+	struct work_struct	work;
+
+	struct list_head	list;
+	struct completion	done;
+	int			status;
+	enum srp_target_state	state;
+};
+
+struct srp_iu {
+	dma_addr_t		dma;
+	void		       *buf;
+	size_t			size;
+	enum dma_data_direction	direction;
+};
+
+#endif /* IB_SRP_H */
