commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index b2879767fc98..ce42675d3274 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AMD Secure Processor driver
  *
@@ -6,10 +7,6 @@
  * Author: Tom Lendacky <thomas.lendacky@amd.com>
  * Author: Gary R Hook <gary.hook@amd.com>
  * Author: Brijesh Singh <brijesh.singh@amd.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>

commit fa5cd1c72e32bd4f9c52626d9a9a2b0ca635b3bc
Author: Hook, Gary <Gary.Hook@amd.com>
Date:   Tue Dec 18 15:48:29 2018 +0000

    crypto: ccp - Update copyright notices and dates
    
    Correct copyright dates for files that have had code added
    to them in 2018.
    
    Signed-off-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index e0459002eb71..b2879767fc98 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -1,7 +1,7 @@
 /*
  * AMD Secure Processor driver
  *
- * Copyright (C) 2017 Advanced Micro Devices, Inc.
+ * Copyright (C) 2017-2018 Advanced Micro Devices, Inc.
  *
  * Author: Tom Lendacky <thomas.lendacky@amd.com>
  * Author: Gary R Hook <gary.hook@amd.com>

commit 716c7c32eae4b8a45c4f5602b50453865929b670
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Wed Feb 21 08:41:39 2018 -0600

    crypto: ccp - add check to get PSP master only when PSP is detected
    
    Paulian reported the below kernel crash on Ryzen 5 system:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000073
    RIP: 0010:.LC0+0x41f/0xa00
    RSP: 0018:ffffa9968003bdd0 EFLAGS: 00010002
    RAX: ffffffffb113b130 RBX: 0000000000000000 RCX: 00000000000005a7
    RDX: 00000000000000ff RSI: ffff8b46dee651a0 RDI: ffffffffb1bd617c
    RBP: 0000000000000246 R08: 00000000000251a0 R09: 0000000000000000
    R10: ffffd81f11a38200 R11: ffff8b52e8e0a161 R12: ffffffffb19db220
    R13: 0000000000000007 R14: ffffffffb17e4888 R15: 5dccd7affc30a31e
    FS:  0000000000000000(0000) GS:ffff8b46dee40000(0000) knlGS:0000000000000000
    CR2: 0000000000000073 CR3: 000080128120a000 CR4: 00000000003406e0
    Call Trace:
     ? sp_get_psp_master_device+0x56/0x80
     ? map_properties+0x540/0x540
     ? psp_pci_init+0x20/0xe0
     ? map_properties+0x540/0x540
     ? sp_mod_init+0x16/0x1a
     ? do_one_initcall+0x4b/0x190
     ? kernel_init_freeable+0x19b/0x23c
     ? rest_init+0xb0/0xb0
     ? kernel_init+0xa/0x100
     ? ret_from_fork+0x22/0x40
    
    Since Ryzen does not support PSP/SEV firmware hence i->psp_data will
    NULL in all sp instances. In those cases, 'i' will point to the
    list head after list_for_each_entry(). Dereferencing the head will
    cause kernel crash.
    
    Add check to call get master device only when PSP/SEV is detected.
    
    Reported-by: Paulian Bogdan Marinca <paulian@marinca.net>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    CC: Gary R Hook <gary.hook@amd.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index eb0da6572720..e0459002eb71 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -252,12 +252,12 @@ struct sp_device *sp_get_psp_master_device(void)
 		goto unlock;
 
 	list_for_each_entry(i, &sp_units, entry) {
-		if (i->psp_data)
+		if (i->psp_data && i->get_psp_master_device) {
+			ret = i->get_psp_master_device();
 			break;
+		}
 	}
 
-	if (i->get_psp_master_device)
-		ret = i->get_psp_master_device();
 unlock:
 	write_unlock_irqrestore(&sp_unit_lock, flags);
 	return ret;

commit 200664d5237f3f8cd2a2f9f5c5dea08502336bd1
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Mon Dec 4 10:57:28 2017 -0600

    crypto: ccp: Add Secure Encrypted Virtualization (SEV) command support
    
    AMD's new Secure Encrypted Virtualization (SEV) feature allows the
    memory contents of virtual machines to be transparently encrypted with a
    key unique to the VM. The programming and management of the encryption
    keys are handled by the AMD Secure Processor (AMD-SP) which exposes the
    commands for these tasks. The complete spec is available at:
    
    http://support.amd.com/TechDocs/55766_SEV-KM%20API_Specification.pdf
    
    Extend the AMD-SP driver to provide the following support:
    
     - an in-kernel API to communicate with the SEV firmware. The API can be
       used by the hypervisor to create encryption context for a SEV guest.
    
     - a userspace IOCTL to manage the platform certificates.
    
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Gary Hook <gary.hook@amd.com>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: linux-crypto@vger.kernel.org
    Cc: kvm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Improvements-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index cf101c039c8f..eb0da6572720 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -272,6 +272,10 @@ static int __init sp_mod_init(void)
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_CRYPTO_DEV_SP_PSP
+	psp_pci_init();
+#endif
+
 	return 0;
 #endif
 
@@ -291,6 +295,11 @@ static int __init sp_mod_init(void)
 static void __exit sp_mod_exit(void)
 {
 #ifdef CONFIG_X86
+
+#ifdef CONFIG_CRYPTO_DEV_SP_PSP
+	psp_pci_exit();
+#endif
+
 	sp_pci_exit();
 #endif
 

commit 2a6170dfe755b167ca8d6bba2e73695f08b37c54
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Mon Dec 4 10:57:28 2017 -0600

    crypto: ccp: Add Platform Security Processor (PSP) device support
    
    The Platform Security Processor (PSP) is part of the AMD Secure
    Processor (AMD-SP) functionality. The PSP is a dedicated processor
    that provides support for key management commands in Secure Encrypted
    Virtualization (SEV) mode, along with software-based Trusted Execution
    Environment (TEE) to enable third-party trusted applications.
    
    Note that the key management functionality provided by the SEV firmware
    can be used outside of the kvm-amd driver hence it doesn't need to
    depend on CONFIG_KVM_AMD.
    
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Gary Hook <gary.hook@amd.com>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: linux-crypto@vger.kernel.org
    Cc: kvm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Improvements-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index bef387c8abfd..cf101c039c8f 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -198,6 +198,8 @@ int sp_init(struct sp_device *sp)
 	if (sp->dev_vdata->ccp_vdata)
 		ccp_dev_init(sp);
 
+	if (sp->dev_vdata->psp_vdata)
+		psp_dev_init(sp);
 	return 0;
 }
 
@@ -206,6 +208,9 @@ void sp_destroy(struct sp_device *sp)
 	if (sp->dev_vdata->ccp_vdata)
 		ccp_dev_destroy(sp);
 
+	if (sp->dev_vdata->psp_vdata)
+		psp_dev_destroy(sp);
+
 	sp_del_device(sp);
 }
 
@@ -237,6 +242,27 @@ int sp_resume(struct sp_device *sp)
 }
 #endif
 
+struct sp_device *sp_get_psp_master_device(void)
+{
+	struct sp_device *i, *ret = NULL;
+	unsigned long flags;
+
+	write_lock_irqsave(&sp_unit_lock, flags);
+	if (list_empty(&sp_units))
+		goto unlock;
+
+	list_for_each_entry(i, &sp_units, entry) {
+		if (i->psp_data)
+			break;
+	}
+
+	if (i->get_psp_master_device)
+		ret = i->get_psp_master_device();
+unlock:
+	write_unlock_irqrestore(&sp_unit_lock, flags);
+	return ret;
+}
+
 static int __init sp_mod_init(void)
 {
 #ifdef CONFIG_X86

commit 57de3aefb73fec7cebaf5c6f5f47ef6be4416c12
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Thu Jul 6 09:59:17 2017 -0500

    crypto: ccp - remove ccp_present() check from device initialize
    
    Since SP device driver supports multiples devices (e.g CCP, PSP), we
    should not fail the driver init just because CCP device is not found.
    
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Acked-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index 1e5ffad4437b..bef387c8abfd 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -246,12 +246,6 @@ static int __init sp_mod_init(void)
 	if (ret)
 		return ret;
 
-	/* Don't leave the driver loaded if init failed */
-	if (ccp_present() != 0) {
-		sp_pci_exit();
-		return -ENODEV;
-	}
-
 	return 0;
 #endif
 
@@ -262,12 +256,6 @@ static int __init sp_mod_init(void)
 	if (ret)
 		return ret;
 
-	/* Don't leave the driver loaded if init failed */
-	if (ccp_present() != 0) {
-		sp_platform_exit();
-		return -ENODEV;
-	}
-
 	return 0;
 #endif
 

commit d0ebbc0c407a10485a8672ef370dfe55c666d57f
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Thu Jul 6 09:59:16 2017 -0500

    crypto: ccp - rename ccp driver initialize files as sp device
    
    CCP device initializes is now integerated into higher level SP device,
    to avoid the confusion lets rename the ccp driver initialization files
    (ccp-platform.c->sp-platform.c, ccp-pci.c->sp-pci.c). The patch does not
    make any functional changes other than renaming file and structures
    
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Acked-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index 7e30773443e9..1e5ffad4437b 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -242,13 +242,13 @@ static int __init sp_mod_init(void)
 #ifdef CONFIG_X86
 	int ret;
 
-	ret = ccp_pci_init();
+	ret = sp_pci_init();
 	if (ret)
 		return ret;
 
 	/* Don't leave the driver loaded if init failed */
 	if (ccp_present() != 0) {
-		ccp_pci_exit();
+		sp_pci_exit();
 		return -ENODEV;
 	}
 
@@ -258,13 +258,13 @@ static int __init sp_mod_init(void)
 #ifdef CONFIG_ARM64
 	int ret;
 
-	ret = ccp_platform_init();
+	ret = sp_platform_init();
 	if (ret)
 		return ret;
 
 	/* Don't leave the driver loaded if init failed */
 	if (ccp_present() != 0) {
-		ccp_platform_exit();
+		sp_platform_exit();
 		return -ENODEV;
 	}
 
@@ -277,11 +277,11 @@ static int __init sp_mod_init(void)
 static void __exit sp_mod_exit(void)
 {
 #ifdef CONFIG_X86
-	ccp_pci_exit();
+	sp_pci_exit();
 #endif
 
 #ifdef CONFIG_ARM64
-	ccp_platform_exit();
+	sp_platform_exit();
 #endif
 }
 

commit f4d18d656f882a7ca558313d5f1b18b1fd01f759
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Thu Jul 6 09:59:15 2017 -0500

    crypto: ccp - Abstract interrupt registeration
    
    The CCP and PSP devices part of AMD Secure Procesor may share the same
    interrupt. Hence we expand the SP device to register a common interrupt
    handler and provide functions to CCP and PSP devices to register their
    interrupt callback which will be invoked upon interrupt.
    
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Acked-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
index 63cc74ee6d2a..7e30773443e9 100644
--- a/drivers/crypto/ccp/sp-dev.c
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -64,6 +64,113 @@ static void sp_del_device(struct sp_device *sp)
 	write_unlock_irqrestore(&sp_unit_lock, flags);
 }
 
+static irqreturn_t sp_irq_handler(int irq, void *data)
+{
+	struct sp_device *sp = data;
+
+	if (sp->ccp_irq_handler)
+		sp->ccp_irq_handler(irq, sp->ccp_irq_data);
+
+	if (sp->psp_irq_handler)
+		sp->psp_irq_handler(irq, sp->psp_irq_data);
+
+	return IRQ_HANDLED;
+}
+
+int sp_request_ccp_irq(struct sp_device *sp, irq_handler_t handler,
+		       const char *name, void *data)
+{
+	int ret;
+
+	if ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->psp_vdata) {
+		/* Need a common routine to manage all interrupts */
+		sp->ccp_irq_data = data;
+		sp->ccp_irq_handler = handler;
+
+		if (!sp->irq_registered) {
+			ret = request_irq(sp->ccp_irq, sp_irq_handler, 0,
+					  sp->name, sp);
+			if (ret)
+				return ret;
+
+			sp->irq_registered = true;
+		}
+	} else {
+		/* Each sub-device can manage it's own interrupt */
+		ret = request_irq(sp->ccp_irq, handler, 0, name, data);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int sp_request_psp_irq(struct sp_device *sp, irq_handler_t handler,
+		       const char *name, void *data)
+{
+	int ret;
+
+	if ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->ccp_vdata) {
+		/* Need a common routine to manage all interrupts */
+		sp->psp_irq_data = data;
+		sp->psp_irq_handler = handler;
+
+		if (!sp->irq_registered) {
+			ret = request_irq(sp->psp_irq, sp_irq_handler, 0,
+					  sp->name, sp);
+			if (ret)
+				return ret;
+
+			sp->irq_registered = true;
+		}
+	} else {
+		/* Each sub-device can manage it's own interrupt */
+		ret = request_irq(sp->psp_irq, handler, 0, name, data);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+void sp_free_ccp_irq(struct sp_device *sp, void *data)
+{
+	if ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->psp_vdata) {
+		/* Using common routine to manage all interrupts */
+		if (!sp->psp_irq_handler) {
+			/* Nothing else using it, so free it */
+			free_irq(sp->ccp_irq, sp);
+
+			sp->irq_registered = false;
+		}
+
+		sp->ccp_irq_handler = NULL;
+		sp->ccp_irq_data = NULL;
+	} else {
+		/* Each sub-device can manage it's own interrupt */
+		free_irq(sp->ccp_irq, data);
+	}
+}
+
+void sp_free_psp_irq(struct sp_device *sp, void *data)
+{
+	if ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->ccp_vdata) {
+		/* Using common routine to manage all interrupts */
+		if (!sp->ccp_irq_handler) {
+			/* Nothing else using it, so free it */
+			free_irq(sp->psp_irq, sp);
+
+			sp->irq_registered = false;
+		}
+
+		sp->psp_irq_handler = NULL;
+		sp->psp_irq_data = NULL;
+	} else {
+		/* Each sub-device can manage it's own interrupt */
+		free_irq(sp->psp_irq, data);
+	}
+}
+
 /**
  * sp_alloc_struct - allocate and initialize the sp_device struct
  *

commit 720419f01832f7e697cb80480b97b2a1e96045cd
Author: Brijesh Singh <brijesh.singh@amd.com>
Date:   Thu Jul 6 09:59:14 2017 -0500

    crypto: ccp - Introduce the AMD Secure Processor device
    
    The CCP device is part of the AMD Secure Processor. In order to expand
    the usage of the AMD Secure Processor, create a framework that allows
    functional components of the AMD Secure Processor to be initialized and
    handled appropriately.
    
    Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
    Acked-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccp/sp-dev.c b/drivers/crypto/ccp/sp-dev.c
new file mode 100644
index 000000000000..63cc74ee6d2a
--- /dev/null
+++ b/drivers/crypto/ccp/sp-dev.c
@@ -0,0 +1,182 @@
+/*
+ * AMD Secure Processor driver
+ *
+ * Copyright (C) 2017 Advanced Micro Devices, Inc.
+ *
+ * Author: Tom Lendacky <thomas.lendacky@amd.com>
+ * Author: Gary R Hook <gary.hook@amd.com>
+ * Author: Brijesh Singh <brijesh.singh@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/types.h>
+#include <linux/ccp.h>
+
+#include "ccp-dev.h"
+#include "sp-dev.h"
+
+MODULE_AUTHOR("Tom Lendacky <thomas.lendacky@amd.com>");
+MODULE_AUTHOR("Gary R Hook <gary.hook@amd.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.1.0");
+MODULE_DESCRIPTION("AMD Secure Processor driver");
+
+/* List of SPs, SP count, read-write access lock, and access functions
+ *
+ * Lock structure: get sp_unit_lock for reading whenever we need to
+ * examine the SP list.
+ */
+static DEFINE_RWLOCK(sp_unit_lock);
+static LIST_HEAD(sp_units);
+
+/* Ever-increasing value to produce unique unit numbers */
+static atomic_t sp_ordinal;
+
+static void sp_add_device(struct sp_device *sp)
+{
+	unsigned long flags;
+
+	write_lock_irqsave(&sp_unit_lock, flags);
+
+	list_add_tail(&sp->entry, &sp_units);
+
+	write_unlock_irqrestore(&sp_unit_lock, flags);
+}
+
+static void sp_del_device(struct sp_device *sp)
+{
+	unsigned long flags;
+
+	write_lock_irqsave(&sp_unit_lock, flags);
+
+	list_del(&sp->entry);
+
+	write_unlock_irqrestore(&sp_unit_lock, flags);
+}
+
+/**
+ * sp_alloc_struct - allocate and initialize the sp_device struct
+ *
+ * @dev: device struct of the SP
+ */
+struct sp_device *sp_alloc_struct(struct device *dev)
+{
+	struct sp_device *sp;
+
+	sp = devm_kzalloc(dev, sizeof(*sp), GFP_KERNEL);
+	if (!sp)
+		return NULL;
+
+	sp->dev = dev;
+	sp->ord = atomic_inc_return(&sp_ordinal);
+	snprintf(sp->name, SP_MAX_NAME_LEN, "sp-%u", sp->ord);
+
+	return sp;
+}
+
+int sp_init(struct sp_device *sp)
+{
+	sp_add_device(sp);
+
+	if (sp->dev_vdata->ccp_vdata)
+		ccp_dev_init(sp);
+
+	return 0;
+}
+
+void sp_destroy(struct sp_device *sp)
+{
+	if (sp->dev_vdata->ccp_vdata)
+		ccp_dev_destroy(sp);
+
+	sp_del_device(sp);
+}
+
+#ifdef CONFIG_PM
+int sp_suspend(struct sp_device *sp, pm_message_t state)
+{
+	int ret;
+
+	if (sp->dev_vdata->ccp_vdata) {
+		ret = ccp_dev_suspend(sp, state);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int sp_resume(struct sp_device *sp)
+{
+	int ret;
+
+	if (sp->dev_vdata->ccp_vdata) {
+		ret = ccp_dev_resume(sp);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int __init sp_mod_init(void)
+{
+#ifdef CONFIG_X86
+	int ret;
+
+	ret = ccp_pci_init();
+	if (ret)
+		return ret;
+
+	/* Don't leave the driver loaded if init failed */
+	if (ccp_present() != 0) {
+		ccp_pci_exit();
+		return -ENODEV;
+	}
+
+	return 0;
+#endif
+
+#ifdef CONFIG_ARM64
+	int ret;
+
+	ret = ccp_platform_init();
+	if (ret)
+		return ret;
+
+	/* Don't leave the driver loaded if init failed */
+	if (ccp_present() != 0) {
+		ccp_platform_exit();
+		return -ENODEV;
+	}
+
+	return 0;
+#endif
+
+	return -ENODEV;
+}
+
+static void __exit sp_mod_exit(void)
+{
+#ifdef CONFIG_X86
+	ccp_pci_exit();
+#endif
+
+#ifdef CONFIG_ARM64
+	ccp_platform_exit();
+#endif
+}
+
+module_init(sp_mod_init);
+module_exit(sp_mod_exit);
