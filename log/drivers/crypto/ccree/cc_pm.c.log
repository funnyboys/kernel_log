commit f33d807c9d8847c634ddcb033178f93347428e7b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:11 2020 +0100

    crypto: ccree - make cc_pm_{suspend,resume}() static
    
    cc_pm_suspend() and cc_pm_resume() are not used outside
    drivers/crypto/ccree/cc_pm.c.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 3b4927c41a17..d39e1664fc7e 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -15,11 +15,7 @@
 #define POWER_DOWN_ENABLE 0x01
 #define POWER_DOWN_DISABLE 0x00
 
-const struct dev_pm_ops ccree_pm = {
-	SET_RUNTIME_PM_OPS(cc_pm_suspend, cc_pm_resume, NULL)
-};
-
-int cc_pm_suspend(struct device *dev)
+static int cc_pm_suspend(struct device *dev)
 {
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
 
@@ -30,7 +26,7 @@ int cc_pm_suspend(struct device *dev)
 	return 0;
 }
 
-int cc_pm_resume(struct device *dev)
+static int cc_pm_resume(struct device *dev)
 {
 	int rc;
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
@@ -62,6 +58,10 @@ int cc_pm_resume(struct device *dev)
 	return 0;
 }
 
+const struct dev_pm_ops ccree_pm = {
+	SET_RUNTIME_PM_OPS(cc_pm_suspend, cc_pm_resume, NULL)
+};
+
 int cc_pm_get(struct device *dev)
 {
 	int rc = pm_runtime_get_sync(dev);

commit 8f76b35211bd78437d37de897d29a0b83e370c08
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:10 2020 +0100

    crypto: ccree - remove cc_pm_is_dev_suspended() wrapper
    
    If CONFIG_PM=y, cc_pm_is_dev_suspended() is just a wrapper around
    pm_runtime_suspended().
    If CONFIG_PM=n, cc_pm_is_dev_suspended() a dummy that behaves exactly
    the same as the dummy for pm_runtime_suspended().
    
    Hence remove cc_pm_is_dev_suspended(), and call pm_runtime_suspended()
    directly.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index f7729fc1ee59..3b4927c41a17 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -74,9 +74,3 @@ void cc_pm_put_suspend(struct device *dev)
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
 }
-
-bool cc_pm_is_dev_suspended(struct device *dev)
-{
-	/* check device state using runtime api */
-	return pm_runtime_suspended(dev);
-}

commit 8c7849a30255cfd9a9ba412b1517e20a8572448b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:08 2020 +0100

    crypto: ccree - simplify Runtime PM handling
    
    Currently, a large part of the probe function runs before Runtime PM is
    enabled.  As the driver manages the device's clock manually, this may
    work fine on some systems, but may break on platforms with a more
    complex power hierarchy.
    
    Fix this by moving the initialization of Runtime PM before the first
    register access (in cc_wait_for_reset_completion()), and putting the
    device to sleep only after the last access (in cc_set_ree_fips_status()).
    
    This allows to remove the pm_on flag, which was used to track manually
    if Runtime PM had been enabled or not.
    Remove the cc_pm_{init,go,fini}() wrappers, as they are called only
    once, and obscure operation.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 81376173c3ec..f7729fc1ee59 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -64,23 +64,15 @@ int cc_pm_resume(struct device *dev)
 
 int cc_pm_get(struct device *dev)
 {
-	int rc = 0;
-	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
-
-	if (drvdata->pm_on)
-		rc = pm_runtime_get_sync(dev);
+	int rc = pm_runtime_get_sync(dev);
 
 	return (rc == 1 ? 0 : rc);
 }
 
 void cc_pm_put_suspend(struct device *dev)
 {
-	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
-
-	if (drvdata->pm_on) {
-		pm_runtime_mark_last_busy(dev);
-		pm_runtime_put_autosuspend(dev);
-	}
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
 }
 
 bool cc_pm_is_dev_suspended(struct device *dev)
@@ -88,27 +80,3 @@ bool cc_pm_is_dev_suspended(struct device *dev)
 	/* check device state using runtime api */
 	return pm_runtime_suspended(dev);
 }
-
-int cc_pm_init(struct cc_drvdata *drvdata)
-{
-	struct device *dev = drvdata_to_dev(drvdata);
-
-	/* must be before the enabling to avoid redundant suspending */
-	pm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);
-	pm_runtime_use_autosuspend(dev);
-	/* set us as active - note we won't do PM ops until cc_pm_go()! */
-	return pm_runtime_set_active(dev);
-}
-
-/* enable the PM module*/
-void cc_pm_go(struct cc_drvdata *drvdata)
-{
-	pm_runtime_enable(drvdata_to_dev(drvdata));
-	drvdata->pm_on = true;
-}
-
-void cc_pm_fini(struct cc_drvdata *drvdata)
-{
-	pm_runtime_disable(drvdata_to_dev(drvdata));
-	drvdata->pm_on = false;
-}

commit 2f272ef37c29425a6526fec976cf200dda950ee1
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:02 2020 +0100

    crypto: ccree - clean up clock handling
    
    Use devm_clk_get_optional() instead of devm_clk_get() and explicit
    optional clock handling.
    As clk_prepare_enable() and clk_disable_unprepare() handle optional
    clocks fine, the cc_clk_on() and cc_clk_off() wrappers can be removed.
    
    While at it, use the new "%pe" format specifier to print error codes.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 24c368b866f6..81376173c3ec 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -26,7 +26,7 @@ int cc_pm_suspend(struct device *dev)
 	dev_dbg(dev, "set HOST_POWER_DOWN_EN\n");
 	fini_cc_regs(drvdata);
 	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_ENABLE);
-	cc_clk_off(drvdata);
+	clk_disable_unprepare(drvdata->clk);
 	return 0;
 }
 
@@ -37,7 +37,7 @@ int cc_pm_resume(struct device *dev)
 
 	dev_dbg(dev, "unset HOST_POWER_DOWN_EN\n");
 	/* Enables the device source clk */
-	rc = cc_clk_on(drvdata);
+	rc = clk_prepare_enable(drvdata->clk);
 	if (rc) {
 		dev_err(dev, "failed getting clock back on. We're toast.\n");
 		return rc;

commit bc88606ac030c4d89976e4dd8f00f31ba1640f2f
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Thu Jan 16 12:14:45 2020 +0200

    crypto: ccree - make cc_pm_put_suspend() void
    
    cc_pm_put_suspend() return value was never checked and is not
    useful. Turn it into a void functions.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index ee9e9cba2fbb..24c368b866f6 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -73,17 +73,14 @@ int cc_pm_get(struct device *dev)
 	return (rc == 1 ? 0 : rc);
 }
 
-int cc_pm_put_suspend(struct device *dev)
+void cc_pm_put_suspend(struct device *dev)
 {
-	int rc = 0;
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
 
 	if (drvdata->pm_on) {
 		pm_runtime_mark_last_busy(dev);
-		rc = pm_runtime_put_autosuspend(dev);
+		pm_runtime_put_autosuspend(dev);
 	}
-
-	return rc;
 }
 
 bool cc_pm_is_dev_suspended(struct device *dev)

commit 15fd2566bf54ee4d4781d8f170acfc9472a1541f
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Thu Jan 16 12:14:43 2020 +0200

    crypto: ccree - fix PM race condition
    
    The PM code was racy, possibly causing the driver to submit
    requests to a powered down device. Fix the race and while
    at it simplify the PM code.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Fixes: 1358c13a48c4 ("crypto: ccree - fix resume race condition on init")
    Cc: stable@kernel.org # v4.20
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 79c612144310..ee9e9cba2fbb 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -22,14 +22,8 @@ const struct dev_pm_ops ccree_pm = {
 int cc_pm_suspend(struct device *dev)
 {
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
-	int rc;
 
 	dev_dbg(dev, "set HOST_POWER_DOWN_EN\n");
-	rc = cc_suspend_req_queue(drvdata);
-	if (rc) {
-		dev_err(dev, "cc_suspend_req_queue (%x)\n", rc);
-		return rc;
-	}
 	fini_cc_regs(drvdata);
 	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_ENABLE);
 	cc_clk_off(drvdata);
@@ -63,13 +57,6 @@ int cc_pm_resume(struct device *dev)
 	/* check if tee fips error occurred during power down */
 	cc_tee_handle_fips_error(drvdata);
 
-	rc = cc_resume_req_queue(drvdata);
-	if (rc) {
-		dev_err(dev, "cc_resume_req_queue (%x)\n", rc);
-		return rc;
-	}
-
-	/* must be after the queue resuming as it uses the HW queue*/
 	cc_init_hash_sram(drvdata);
 
 	return 0;
@@ -80,10 +67,8 @@ int cc_pm_get(struct device *dev)
 	int rc = 0;
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
 
-	if (cc_req_queue_suspended(drvdata))
+	if (drvdata->pm_on)
 		rc = pm_runtime_get_sync(dev);
-	else
-		pm_runtime_get_noresume(dev);
 
 	return (rc == 1 ? 0 : rc);
 }
@@ -93,14 +78,11 @@ int cc_pm_put_suspend(struct device *dev)
 	int rc = 0;
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
 
-	if (!cc_req_queue_suspended(drvdata)) {
+	if (drvdata->pm_on) {
 		pm_runtime_mark_last_busy(dev);
 		rc = pm_runtime_put_autosuspend(dev);
-	} else {
-		/* Something wrong happens*/
-		dev_err(dev, "request to suspend already suspended queue");
-		rc = -EBUSY;
 	}
+
 	return rc;
 }
 
@@ -117,7 +99,7 @@ int cc_pm_init(struct cc_drvdata *drvdata)
 	/* must be before the enabling to avoid redundant suspending */
 	pm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);
 	pm_runtime_use_autosuspend(dev);
-	/* activate the PM module */
+	/* set us as active - note we won't do PM ops until cc_pm_go()! */
 	return pm_runtime_set_active(dev);
 }
 
@@ -125,9 +107,11 @@ int cc_pm_init(struct cc_drvdata *drvdata)
 void cc_pm_go(struct cc_drvdata *drvdata)
 {
 	pm_runtime_enable(drvdata_to_dev(drvdata));
+	drvdata->pm_on = true;
 }
 
 void cc_pm_fini(struct cc_drvdata *drvdata)
 {
 	pm_runtime_disable(drvdata_to_dev(drvdata));
+	drvdata->pm_on = false;
 }

commit cedca59fae5834af8445b403c66c9953754375d7
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Thu Jan 16 12:14:40 2020 +0200

    crypto: ccree - fix pm wrongful error reporting
    
    pm_runtime_get_sync() can return 1 as a valid (none error) return
    code. Treat it as such.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 4de25c85d127..79c612144310 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -85,7 +85,7 @@ int cc_pm_get(struct device *dev)
 	else
 		pm_runtime_get_noresume(dev);
 
-	return rc;
+	return (rc == 1 ? 0 : rc);
 }
 
 int cc_pm_put_suspend(struct device *dev)

commit 684cf266eb04911825a6de10dadd188cf801d063
Author: Hadar Gat <hadar.gat@arm.com>
Date:   Thu Jan 16 12:14:37 2020 +0200

    crypto: ccree - fix typo in comment
    
    Fixed a typo in a commnet.
    
    Signed-off-by: Hadar Gat <hadar.gat@arm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index c1066f433a28..4de25c85d127 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -48,7 +48,7 @@ int cc_pm_resume(struct device *dev)
 		dev_err(dev, "failed getting clock back on. We're toast.\n");
 		return rc;
 	}
-	/* wait for Crytpcell reset completion */
+	/* wait for Cryptocell reset completion */
 	if (!cc_wait_for_reset_completion(drvdata)) {
 		dev_err(dev, "Cryptocell reset not completed");
 		return -EBUSY;

commit e86eca4107ce067e6059fcc4544680ecbac4e80b
Author: Hadar Gat <hadar.gat@arm.com>
Date:   Wed Nov 27 10:49:06 2019 +0200

    crypto: ccree - fix typos in comments
    
    Fix some typos in code comments.
    
    Signed-off-by: Hadar Gat <hadar.gat@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index dbc508fb719b..c1066f433a28 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -114,7 +114,7 @@ int cc_pm_init(struct cc_drvdata *drvdata)
 {
 	struct device *dev = drvdata_to_dev(drvdata);
 
-	/* must be before the enabling to avoid resdundent suspending */
+	/* must be before the enabling to avoid redundant suspending */
 	pm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);
 	pm_runtime_use_autosuspend(dev);
 	/* activate the PM module */

commit e6e6600c001c3aa3760aeb83dbd4630063e926ee
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Tue Jul 2 14:39:18 2019 +0300

    crypto: ccree - drop legacy ivgen support
    
    ccree had a mechanism for IV generation which was not compatible
    with the Linux seqiv or echainiv iv generator and was never used
    in any of the upstream versions so drop all the code implementing it.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 899a52f05b7a..dbc508fb719b 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -8,7 +8,6 @@
 #include "cc_buffer_mgr.h"
 #include "cc_request_mgr.h"
 #include "cc_sram_mgr.h"
-#include "cc_ivgen.h"
 #include "cc_hash.h"
 #include "cc_pm.h"
 #include "cc_fips.h"
@@ -73,7 +72,6 @@ int cc_pm_resume(struct device *dev)
 	/* must be after the queue resuming as it uses the HW queue*/
 	cc_init_hash_sram(drvdata);
 
-	cc_init_iv_sram(drvdata);
 	return 0;
 }
 

commit 3db617e77ae2f8051fd6f5d3fff0e15f086d5b4c
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Mon Jun 17 11:46:29 2019 +0300

    crypto: ccree - prevent isr handling in case driver is suspended
    
    ccree irq may be shared with other devices, in order to prevent ccree isr
    handling while device maybe suspended we added a check to verify that the
    device is not suspended.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 20f7f3d34e27..899a52f05b7a 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -106,6 +106,12 @@ int cc_pm_put_suspend(struct device *dev)
 	return rc;
 }
 
+bool cc_pm_is_dev_suspended(struct device *dev)
+{
+	/* check device state using runtime api */
+	return pm_runtime_suspended(dev);
+}
+
 int cc_pm_init(struct cc_drvdata *drvdata)
 {
 	struct device *dev = drvdata_to_dev(drvdata);

commit d84f6269ce24eb4c468e246b24fc0fdce34ab6f6
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Mon Jun 17 11:46:28 2019 +0300

    crypto: ccree - check that cryptocell reset completed
    
    In case of driver probe and pm resume we need to check that the cryptocell
    hardware reset cycle is completed. during the reset cycle that Cryptocell
    provide read only access to the APB interface which allows to verify
    through the CC registers that the reset is completed. Until reset
    completion we assume that any write/crypto operation is blocked.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 2dad9c9543c6..20f7f3d34e27 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -49,6 +49,11 @@ int cc_pm_resume(struct device *dev)
 		dev_err(dev, "failed getting clock back on. We're toast.\n");
 		return rc;
 	}
+	/* wait for Crytpcell reset completion */
+	if (!cc_wait_for_reset_completion(drvdata)) {
+		dev_err(dev, "Cryptocell reset not completed");
+		return -EBUSY;
+	}
 
 	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_DISABLE);
 	rc = init_cc_regs(drvdata, false);

commit 7138377ce10455b7183c6dde4b2c51b33f464c45
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:10 2019 +0300

    crypto: ccree - handle tee fips error during power management resume
    
    in order to support cryptocell tee fips error that may occurs while
    cryptocell ree is suspended, an cc_tee_handle_fips_error  call added
    to the cc_pm_resume function.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 77025da2dcb6..2dad9c9543c6 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -11,6 +11,7 @@
 #include "cc_ivgen.h"
 #include "cc_hash.h"
 #include "cc_pm.h"
+#include "cc_fips.h"
 
 #define POWER_DOWN_ENABLE 0x01
 #define POWER_DOWN_DISABLE 0x00
@@ -50,12 +51,13 @@ int cc_pm_resume(struct device *dev)
 	}
 
 	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_DISABLE);
-
 	rc = init_cc_regs(drvdata, false);
 	if (rc) {
 		dev_err(dev, "init_cc_regs (%x)\n", rc);
 		return rc;
 	}
+	/* check if tee fips error occurred during power down */
+	cc_tee_handle_fips_error(drvdata);
 
 	rc = cc_resume_req_queue(drvdata);
 	if (rc) {

commit 3499efbeed39d114873267683b9e776bcb34b058
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:08 2019 +0300

    crypto: ccree - HOST_POWER_DOWN_EN should be the last CC access during suspend
    
    During power management suspend the driver need to prepare the device
    for the power down operation and as a last indication write to the
    HOST_POWER_DOWN_EN register which signals to the hardware that
    The ccree is ready for power down.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 9a5abe406996..77025da2dcb6 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -25,13 +25,13 @@ int cc_pm_suspend(struct device *dev)
 	int rc;
 
 	dev_dbg(dev, "set HOST_POWER_DOWN_EN\n");
-	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_ENABLE);
 	rc = cc_suspend_req_queue(drvdata);
 	if (rc) {
 		dev_err(dev, "cc_suspend_req_queue (%x)\n", rc);
 		return rc;
 	}
 	fini_cc_regs(drvdata);
+	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_ENABLE);
 	cc_clk_off(drvdata);
 	return 0;
 }

commit 7766dd774d80463cec7b81d90c8672af91de2da1
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:06 2019 +0300

    crypto: ccree - pm resume first enable the source clk
    
    On power management resume function first enable the device clk source
    to allow access to the device registers.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 6f278a0d8ee6..9a5abe406996 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -42,14 +42,15 @@ int cc_pm_resume(struct device *dev)
 	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
 
 	dev_dbg(dev, "unset HOST_POWER_DOWN_EN\n");
-	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_DISABLE);
-
+	/* Enables the device source clk */
 	rc = cc_clk_on(drvdata);
 	if (rc) {
 		dev_err(dev, "failed getting clock back on. We're toast.\n");
 		return rc;
 	}
 
+	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_DISABLE);
+
 	rc = init_cc_regs(drvdata, false);
 	if (rc) {
 		dev_err(dev, "init_cc_regs (%x)\n", rc);

commit 03963caeb0dd77b1ead84a5ec913a7d28e8fe816
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Thu Apr 18 16:38:53 2019 +0300

    crypto: ccree - copyright header update
    
    This sacrificial copyright header update is offered to the legal department
    as atonement for any changes made in this driver files in the course of
    the current year which have not been duly recorded as such.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index 6ff7e75ad90e..6f278a0d8ee6 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2012-2018 ARM Limited or its affiliates. */
+/* Copyright (C) 2012-2019 ARM Limited (or its affiliates). */
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>

commit 1358c13a48c43f5e4de0c1835291837a27b9720c
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Thu Feb 7 15:36:11 2019 +0200

    crypto: ccree - fix resume race condition on init
    
    We were enabling autosuspend, which is using data set by the
    hash module, prior to the hash module being inited, casuing
    a crash on resume as part of the startup sequence if the race
    was lost.
    
    This was never a real problem because the PM infra was using low
    res timers so we were always winning the race, until commit 8234f6734c5d
    ("PM-runtime: Switch autosuspend over to using hrtimers") changed that :-)
    
    Fix this by seperating the PM setup and enablement and doing the
    latter only at the end of the init sequence.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: stable@kernel.org # v4.20
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index d990f472e89f..6ff7e75ad90e 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -100,20 +100,19 @@ int cc_pm_put_suspend(struct device *dev)
 
 int cc_pm_init(struct cc_drvdata *drvdata)
 {
-	int rc = 0;
 	struct device *dev = drvdata_to_dev(drvdata);
 
 	/* must be before the enabling to avoid resdundent suspending */
 	pm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);
 	pm_runtime_use_autosuspend(dev);
 	/* activate the PM module */
-	rc = pm_runtime_set_active(dev);
-	if (rc)
-		return rc;
-	/* enable the PM module*/
-	pm_runtime_enable(dev);
+	return pm_runtime_set_active(dev);
+}
 
-	return rc;
+/* enable the PM module*/
+void cc_pm_go(struct cc_drvdata *drvdata)
+{
+	pm_runtime_enable(drvdata_to_dev(drvdata));
 }
 
 void cc_pm_fini(struct cc_drvdata *drvdata)

commit 63893811b0fcb52f6eaf9811cc08bddd46f81c3e
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Mon Jan 22 09:27:02 2018 +0000

    crypto: ccree - add ahash support
    
    Add CryptoCell async. hash and HMAC support.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
index b2d35e030b49..d990f472e89f 100644
--- a/drivers/crypto/ccree/cc_pm.c
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -9,6 +9,7 @@
 #include "cc_request_mgr.h"
 #include "cc_sram_mgr.h"
 #include "cc_ivgen.h"
+#include "cc_hash.h"
 #include "cc_pm.h"
 
 #define POWER_DOWN_ENABLE 0x01
@@ -61,6 +62,9 @@ int cc_pm_resume(struct device *dev)
 		return rc;
 	}
 
+	/* must be after the queue resuming as it uses the HW queue*/
+	cc_init_hash_sram(drvdata);
+
 	cc_init_iv_sram(drvdata);
 	return 0;
 }

commit 4c3f97276e156820a0433bf7b59a4df1100829ae
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Mon Jan 22 09:27:00 2018 +0000

    crypto: ccree - introduce CryptoCell driver
    
    Introduce basic low level Arm TrustZone CryptoCell HW support.
    This first patch doesn't actually register any Crypto API
    transformations, these will follow up in the next patch.
    
    This first revision supports the CC 712 REE component.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/ccree/cc_pm.c b/drivers/crypto/ccree/cc_pm.c
new file mode 100644
index 000000000000..b2d35e030b49
--- /dev/null
+++ b/drivers/crypto/ccree/cc_pm.c
@@ -0,0 +1,118 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2012-2018 ARM Limited or its affiliates. */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include "cc_driver.h"
+#include "cc_buffer_mgr.h"
+#include "cc_request_mgr.h"
+#include "cc_sram_mgr.h"
+#include "cc_ivgen.h"
+#include "cc_pm.h"
+
+#define POWER_DOWN_ENABLE 0x01
+#define POWER_DOWN_DISABLE 0x00
+
+const struct dev_pm_ops ccree_pm = {
+	SET_RUNTIME_PM_OPS(cc_pm_suspend, cc_pm_resume, NULL)
+};
+
+int cc_pm_suspend(struct device *dev)
+{
+	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
+	int rc;
+
+	dev_dbg(dev, "set HOST_POWER_DOWN_EN\n");
+	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_ENABLE);
+	rc = cc_suspend_req_queue(drvdata);
+	if (rc) {
+		dev_err(dev, "cc_suspend_req_queue (%x)\n", rc);
+		return rc;
+	}
+	fini_cc_regs(drvdata);
+	cc_clk_off(drvdata);
+	return 0;
+}
+
+int cc_pm_resume(struct device *dev)
+{
+	int rc;
+	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "unset HOST_POWER_DOWN_EN\n");
+	cc_iowrite(drvdata, CC_REG(HOST_POWER_DOWN_EN), POWER_DOWN_DISABLE);
+
+	rc = cc_clk_on(drvdata);
+	if (rc) {
+		dev_err(dev, "failed getting clock back on. We're toast.\n");
+		return rc;
+	}
+
+	rc = init_cc_regs(drvdata, false);
+	if (rc) {
+		dev_err(dev, "init_cc_regs (%x)\n", rc);
+		return rc;
+	}
+
+	rc = cc_resume_req_queue(drvdata);
+	if (rc) {
+		dev_err(dev, "cc_resume_req_queue (%x)\n", rc);
+		return rc;
+	}
+
+	cc_init_iv_sram(drvdata);
+	return 0;
+}
+
+int cc_pm_get(struct device *dev)
+{
+	int rc = 0;
+	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
+
+	if (cc_req_queue_suspended(drvdata))
+		rc = pm_runtime_get_sync(dev);
+	else
+		pm_runtime_get_noresume(dev);
+
+	return rc;
+}
+
+int cc_pm_put_suspend(struct device *dev)
+{
+	int rc = 0;
+	struct cc_drvdata *drvdata = dev_get_drvdata(dev);
+
+	if (!cc_req_queue_suspended(drvdata)) {
+		pm_runtime_mark_last_busy(dev);
+		rc = pm_runtime_put_autosuspend(dev);
+	} else {
+		/* Something wrong happens*/
+		dev_err(dev, "request to suspend already suspended queue");
+		rc = -EBUSY;
+	}
+	return rc;
+}
+
+int cc_pm_init(struct cc_drvdata *drvdata)
+{
+	int rc = 0;
+	struct device *dev = drvdata_to_dev(drvdata);
+
+	/* must be before the enabling to avoid resdundent suspending */
+	pm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);
+	pm_runtime_use_autosuspend(dev);
+	/* activate the PM module */
+	rc = pm_runtime_set_active(dev);
+	if (rc)
+		return rc;
+	/* enable the PM module*/
+	pm_runtime_enable(dev);
+
+	return rc;
+}
+
+void cc_pm_fini(struct cc_drvdata *drvdata)
+{
+	pm_runtime_disable(drvdata_to_dev(drvdata));
+}
