commit 58ca0060ec4e51208d2eee12198fc55fd9e4feb3
Author: Weili Qian <qianweili@huawei.com>
Date:   Wed May 20 17:19:50 2020 +0800

    crypto: hisilicon - fix driver compatibility issue with different versions of devices
    
    In order to be compatible with devices of different versions, V1 in the
    accelerator driver is now isolated, and other versions are the previous
    V2 processing flow.
    
    Signed-off-by: Weili Qian <qianweili@huawei.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 632674423c04..0a351de8d838 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -108,6 +108,7 @@ enum qm_hw_ver {
 	QM_HW_UNKNOWN = -1,
 	QM_HW_V1 = 0x20,
 	QM_HW_V2 = 0x21,
+	QM_HW_V3 = 0x30,
 };
 
 enum qm_fun_type {
@@ -287,7 +288,6 @@ static inline int q_num_set(const char *val, const struct kernel_param *kp,
 	struct pci_dev *pdev = pci_get_device(PCI_VENDOR_ID_HUAWEI,
 					      device, NULL);
 	u32 n, q_num;
-	u8 rev_id;
 	int ret;
 
 	if (!val)
@@ -298,17 +298,10 @@ static inline int q_num_set(const char *val, const struct kernel_param *kp,
 		pr_info("No device found currently, suppose queue number is %d\n",
 			q_num);
 	} else {
-		rev_id = pdev->revision;
-		switch (rev_id) {
-		case QM_HW_V1:
+		if (pdev->revision == QM_HW_V1)
 			q_num = QM_QNUM_V1;
-			break;
-		case QM_HW_V2:
+		else
 			q_num = QM_QNUM_V2;
-			break;
-		default:
-			return -EINVAL;
-		}
 	}
 
 	ret = kstrtou32(val, 10, &n);

commit c31dc9fe165d1b53c0494e0260a798d491de7bb4
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Fri May 15 17:13:59 2020 +0800

    crypto: hisilicon/qm - add DebugFS for xQC and xQE dump
    
    Add dump information of SQC/CQC/EQC/AEQC/SQE/CQE/EQE/AEQE.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index e4b46a7b10ef..632674423c04 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -137,6 +137,8 @@ struct debugfs_file {
 
 struct qm_debug {
 	u32 curr_qm_qp_num;
+	u32 sqe_mask_offset;
+	u32 sqe_mask_len;
 	struct qm_dfx dfx;
 	struct dentry *debug_root;
 	struct dentry *qm_d;

commit 8502652542c6684dd142f74c1bd1772730f653bd
Author: Longfang Liu <liulongfang@huawei.com>
Date:   Fri May 15 17:13:54 2020 +0800

    crypto: hisilicon/qm - add debugfs for QM
    
    Add DebugFS method to get the information of IRQ/Requests/QP .etc of QM
    for HPRE/ZIP/SEC drivers.
    
    Signed-off-by: Longfang Liu <liulongfang@huawei.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index a431ff2fac3c..e4b46a7b10ef 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -121,6 +121,14 @@ enum qm_debug_file {
 	DEBUG_FILE_NUM,
 };
 
+struct qm_dfx {
+	atomic64_t err_irq_cnt;
+	atomic64_t aeq_irq_cnt;
+	atomic64_t abnormal_irq_cnt;
+	atomic64_t create_qp_err_cnt;
+	atomic64_t mb_err_cnt;
+};
+
 struct debugfs_file {
 	enum qm_debug_file index;
 	struct mutex lock;
@@ -129,6 +137,7 @@ struct debugfs_file {
 
 struct qm_debug {
 	u32 curr_qm_qp_num;
+	struct qm_dfx dfx;
 	struct dentry *debug_root;
 	struct dentry *qm_d;
 	struct debugfs_file files[DEBUG_FILE_NUM];

commit dbdc1ec31fc05c118eedb4211f502e6352c915b9
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Sat May 9 17:44:04 2020 +0800

    crypto: hisilicon - add device error report through abnormal irq
    
    By configuring the device error in firmware to report through abnormal
    interruption, process all NFE errors in irq handler.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index fc5e96a02399..a431ff2fac3c 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -226,6 +226,7 @@ struct hisi_qm {
 
 	struct workqueue_struct *wq;
 	struct work_struct work;
+	struct work_struct rst_work;
 
 	const char *algs;
 	bool use_sva;

commit 3176637ac10eddffdc3bd75281fa354a0d5a0c1e
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Sat May 9 17:44:03 2020 +0800

    crypto: hisilicon - remove codes of directly report device errors through MSI
    
    The hardware device can be configured to report directly through MSI, but
    this method will not go through RAS, configure all hardware errors that
    should be processed by driver to NFE.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 80b9746dfe19..fc5e96a02399 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -74,7 +74,7 @@
 
 #define QM_BASE_NFE	(QM_AXI_RRESP | QM_AXI_BRESP | QM_ECC_MBIT | \
 			 QM_ACC_GET_TASK_TIMEOUT | QM_DB_TIMEOUT | \
-			 QM_OF_FIFO_OF)
+			 QM_OF_FIFO_OF | QM_DB_RANDOM_INVALID)
 #define QM_BASE_CE			QM_ECC_1BIT
 
 #define QM_Q_DEPTH			1024
@@ -158,7 +158,6 @@ struct hisi_qm_err_info {
 	u32 ce;
 	u32 nfe;
 	u32 fe;
-	u32 msi;
 };
 
 struct hisi_qm_err_status {
@@ -224,7 +223,6 @@ struct hisi_qm {
 	struct qm_debug debug;
 
 	u32 error_mask;
-	u32 msi_mask;
 
 	struct workqueue_struct *wq;
 	struct work_struct work;

commit 5308f6600a393ee848ed9d9f77b167aa6b202e9c
Author: Weili Qian <qianweili@huawei.com>
Date:   Sat May 9 17:44:02 2020 +0800

    crypto: hisilicon - QM memory management optimization
    
    Put all the code for the memory allocation into the QM initialization
    process. Before, The qp memory was allocated when the qp was created,
    and released when the qp was released, It is now changed to allocate
    all the qp memory once.
    
    Signed-off-by: Weili Qian <qianweili@huawei.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 743cb63d2de6..80b9746dfe19 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -214,8 +214,8 @@ struct hisi_qm {
 	unsigned long reset_flag;
 
 	struct rw_semaphore qps_lock;
-	unsigned long *qp_bitmap;
-	struct hisi_qp **qp_array;
+	struct idr qp_idr;
+	struct hisi_qp *qp_array;
 
 	struct mutex mailbox_lock;
 

commit b977e03005127b1cbfef05517fbedaa7c5a177a1
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Sat May 9 17:44:00 2020 +0800

    crypto: hisilicon - remove use_dma_api related codes
    
    The codes related use_dma_api is useless which should be removed.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 25934e3c7acd..743cb63d2de6 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -230,7 +230,6 @@ struct hisi_qm {
 	struct work_struct work;
 
 	const char *algs;
-	bool use_dma_api;
 	bool use_sva;
 	resource_size_t phys_base;
 	resource_size_t phys_size;

commit 7ce396fa12a96a0e709a7b55cd5ab24161259634
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Sat May 9 17:43:59 2020 +0800

    crypto: hisilicon - add FLR support
    
    Add callback reset_prepare and reset_done in QM, The callback
    reset_prepare will uninit device error configuration and stop
    the QM, the callback reset_done will init the device error
    configuration and restart the QM.
    
    Uninit the error configuration will disable device block master OOO
    when Multi-bit ECC error occurs to avoid the request of FLR will not
    return.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index eff156a26f48..25934e3c7acd 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -371,6 +371,8 @@ void hisi_qm_dev_err_uninit(struct hisi_qm *qm);
 pci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,
 					  pci_channel_state_t state);
 pci_ers_result_t hisi_qm_dev_slot_reset(struct pci_dev *pdev);
+void hisi_qm_reset_prepare(struct pci_dev *pdev);
+void hisi_qm_reset_done(struct pci_dev *pdev);
 
 struct hisi_acc_sgl_pool;
 struct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,

commit b67202e8ed30bfa07b07a6f8fc762417a9a4e6de
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Sat May 9 17:43:58 2020 +0800

    crypto: hisilicon/qm - add state machine for QM
    
    Add specific states for qm and qp, every state change under critical region
    to prevent from race condition. Meanwhile, qp state change will also depend
    on qm state.
    
    Due to the introduction of these states, it is necessary to pay attention
    to the calls of public logic, such as concurrent scenarios resetting and
    releasing queue will call hisi_qm_stop, which needs to add additional
    status to distinguish and process.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index d1be8cdc99a3..eff156a26f48 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -84,8 +84,24 @@
 /* page number for queue file region */
 #define QM_DOORBELL_PAGE_NR		1
 
+enum qm_stop_reason {
+	QM_NORMAL,
+	QM_SOFT_RESET,
+	QM_FLR,
+};
+
+enum qm_state {
+	QM_INIT = 0,
+	QM_START,
+	QM_CLOSE,
+	QM_STOP,
+};
+
 enum qp_state {
+	QP_INIT = 1,
+	QP_START,
 	QP_STOP,
+	QP_CLOSE,
 };
 
 enum qm_hw_ver {
@@ -129,7 +145,8 @@ struct hisi_qm_status {
 	bool eqc_phase;
 	u32 aeq_head;
 	bool aeqc_phase;
-	unsigned long flags;
+	atomic_t flags;
+	int stop_reason;
 };
 
 struct hisi_qm;
@@ -196,7 +213,7 @@ struct hisi_qm {
 	struct hisi_qm_err_status err_status;
 	unsigned long reset_flag;
 
-	rwlock_t qps_lock;
+	struct rw_semaphore qps_lock;
 	unsigned long *qp_bitmap;
 	struct hisi_qp **qp_array;
 
@@ -225,7 +242,7 @@ struct hisi_qp_status {
 	u16 sq_tail;
 	u16 cq_head;
 	bool cqc_phase;
-	unsigned long flags;
+	atomic_t flags;
 };
 
 struct hisi_qp_ops {
@@ -250,6 +267,7 @@ struct hisi_qp {
 	void (*event_cb)(struct hisi_qp *qp);
 
 	struct hisi_qm *qm;
+	bool is_resetting;
 	u16 pasid;
 	struct uacce_queue *uacce_q;
 };

commit 20b291f51802b35d84e20efbf110e8c9a853a22c
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Sat May 9 17:43:57 2020 +0800

    crypto: hisilicon - refactor module parameter pf_q_num related code
    
    put q_num_set similar code into qm to reduce the redundancy.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 9d17167840f8..d1be8cdc99a3 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -8,6 +8,8 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 
+#define QM_QNUM_V1			4096
+#define QM_QNUM_V2			1024
 #define QM_MAX_VFS_NUM_V2		63
 
 /* qm user domain */
@@ -252,6 +254,43 @@ struct hisi_qp {
 	struct uacce_queue *uacce_q;
 };
 
+static inline int q_num_set(const char *val, const struct kernel_param *kp,
+			    unsigned int device)
+{
+	struct pci_dev *pdev = pci_get_device(PCI_VENDOR_ID_HUAWEI,
+					      device, NULL);
+	u32 n, q_num;
+	u8 rev_id;
+	int ret;
+
+	if (!val)
+		return -EINVAL;
+
+	if (!pdev) {
+		q_num = min_t(u32, QM_QNUM_V1, QM_QNUM_V2);
+		pr_info("No device found currently, suppose queue number is %d\n",
+			q_num);
+	} else {
+		rev_id = pdev->revision;
+		switch (rev_id) {
+		case QM_HW_V1:
+			q_num = QM_QNUM_V1;
+			break;
+		case QM_HW_V2:
+			q_num = QM_QNUM_V2;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	ret = kstrtou32(val, 10, &n);
+	if (ret || !n || n > q_num)
+		return -EINVAL;
+
+	return param_set_int(val, kp);
+}
+
 static inline int vfs_num_set(const char *val, const struct kernel_param *kp)
 {
 	u32 n;

commit 6c6dd5802c2d6769fa589c0e8de54299def199a7
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Fri Apr 3 16:16:38 2020 +0800

    crypto: hisilicon/qm - add controller reset interface
    
    Add the main implementation of the controller reset interface, which is
    roughly divided into three parts, stop, reset, and reinitialization.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 1b5171b91141..9d17167840f8 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -133,16 +133,28 @@ struct hisi_qm_status {
 struct hisi_qm;
 
 struct hisi_qm_err_info {
+	char *acpi_rst;
+	u32 msi_wr_port;
+	u32 ecc_2bits_mask;
 	u32 ce;
 	u32 nfe;
 	u32 fe;
 	u32 msi;
 };
 
+struct hisi_qm_err_status {
+	u32 is_qm_ecc_mbit;
+	u32 is_dev_ecc_mbit;
+};
+
 struct hisi_qm_err_ini {
+	int (*hw_init)(struct hisi_qm *qm);
 	void (*hw_err_enable)(struct hisi_qm *qm);
 	void (*hw_err_disable)(struct hisi_qm *qm);
 	u32 (*get_dev_hw_err_status)(struct hisi_qm *qm);
+	void (*clear_dev_hw_err_status)(struct hisi_qm *qm, u32 err_sts);
+	void (*open_axi_master_ooo)(struct hisi_qm *qm);
+	void (*close_axi_master_ooo)(struct hisi_qm *qm);
 	void (*log_dev_hw_err)(struct hisi_qm *qm, u32 err_sts);
 	struct hisi_qm_err_info err_info;
 };
@@ -165,6 +177,7 @@ struct hisi_qm {
 	u32 ctrl_qp_num;
 	u32 vfs_num;
 	struct list_head list;
+	struct hisi_qm_list *qm_list;
 
 	struct qm_dma qdma;
 	struct qm_sqc *sqc;
@@ -178,6 +191,8 @@ struct hisi_qm {
 
 	struct hisi_qm_status status;
 	const struct hisi_qm_err_ini *err_ini;
+	struct hisi_qm_err_status err_status;
+	unsigned long reset_flag;
 
 	rwlock_t qps_lock;
 	unsigned long *qp_bitmap;
@@ -298,6 +313,7 @@ void hisi_qm_dev_err_init(struct hisi_qm *qm);
 void hisi_qm_dev_err_uninit(struct hisi_qm *qm);
 pci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,
 					  pci_channel_state_t state);
+pci_ers_result_t hisi_qm_dev_slot_reset(struct pci_dev *pdev);
 
 struct hisi_acc_sgl_pool;
 struct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,

commit 35ee280fb1fb97ffa32a19953457becb4f45579b
Author: Hao Fang <fanghao11@huawei.com>
Date:   Thu Apr 2 14:53:03 2020 +0800

    crypto: hisilicon - add vfs_num module parameter for hpre/sec
    
    The vfs_num module parameter has been used in zip driver, this patch adds
    this for HPRE and SEC driver.
    
    Signed-off-by: Hao Fang <fanghao11@huawei.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 665e53d8d958..1b5171b91141 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -8,6 +8,8 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 
+#define QM_MAX_VFS_NUM_V2		63
+
 /* qm user domain */
 #define QM_ARUSER_M_CFG_1		0x100088
 #define AXUSER_SNOOP_ENABLE		BIT(30)
@@ -235,6 +237,24 @@ struct hisi_qp {
 	struct uacce_queue *uacce_q;
 };
 
+static inline int vfs_num_set(const char *val, const struct kernel_param *kp)
+{
+	u32 n;
+	int ret;
+
+	if (!val)
+		return -EINVAL;
+
+	ret = kstrtou32(val, 10, &n);
+	if (ret < 0)
+		return ret;
+
+	if (n > QM_MAX_VFS_NUM_V2)
+		return -EINVAL;
+
+	return param_set_int(val, kp);
+}
+
 static inline void hisi_qm_init_list(struct hisi_qm_list *qm_list)
 {
 	INIT_LIST_HEAD(&qm_list->list);

commit cd1b7ae3435cc428579615241adeee36d217320c
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Thu Apr 2 14:53:02 2020 +0800

    crypto: hisilicon - unify SR-IOV related codes into QM
    
    Clean the duplicate SR-IOV related codes, put all into qm.c.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 33c5a8edd2ae..665e53d8d958 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -268,10 +268,12 @@ void hisi_qm_release_qp(struct hisi_qp *qp);
 int hisi_qp_send(struct hisi_qp *qp, const void *msg);
 int hisi_qm_get_free_qp_num(struct hisi_qm *qm);
 int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number);
-int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
 int hisi_qm_debug_init(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
 void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
+int hisi_qm_sriov_enable(struct pci_dev *pdev, int max_vfs);
+int hisi_qm_sriov_disable(struct pci_dev *pdev);
+int hisi_qm_sriov_configure(struct pci_dev *pdev, int num_vfs);
 void hisi_qm_dev_err_init(struct hisi_qm *qm);
 void hisi_qm_dev_err_uninit(struct hisi_qm *qm);
 pci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,

commit 619e464ae22a17e6a060527c8591ccf78eb368ba
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Thu Apr 2 14:53:01 2020 +0800

    crypto: hisilicon - put vfs_num into struct hisi_qm
    
    We plan to move vfs_num related code into qm.c, put the param
    vfs_num into struct hisi_qm first.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index ec5b6f48db6c..33c5a8edd2ae 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -161,6 +161,7 @@ struct hisi_qm {
 	u32 qp_num;
 	u32 qp_in_used;
 	u32 ctrl_qp_num;
+	u32 vfs_num;
 	struct list_head list;
 
 	struct qm_dma qdma;

commit 3f1ec97aacf19eb44162fc9c413eb4cd66f62002
Author: Weili Qian <qianweili@huawei.com>
Date:   Tue Mar 10 16:42:49 2020 +0800

    crypto: hisilicon/qm - Put device finding logic into QM
    
    Use struct hisi_qm to maintain device list. Meanwhile, add two external
    interface into qm, merge find proper device and create qp into QP alloc
    logic, merge release qps into QP free logic.
    
    Signed-off-by: Weili Qian <qianweili@huawei.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Reviewed-by: Zaibo Xu <xuzaibo@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index c72c2e64d04b..ec5b6f48db6c 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -145,6 +145,11 @@ struct hisi_qm_err_ini {
 	struct hisi_qm_err_info err_info;
 };
 
+struct hisi_qm_list {
+	struct mutex lock;
+	struct list_head list;
+};
+
 struct hisi_qm {
 	enum qm_hw_ver ver;
 	enum qm_fun_type fun_type;
@@ -156,6 +161,7 @@ struct hisi_qm {
 	u32 qp_num;
 	u32 qp_in_used;
 	u32 ctrl_qp_num;
+	struct list_head list;
 
 	struct qm_dma qdma;
 	struct qm_sqc *sqc;
@@ -228,6 +234,28 @@ struct hisi_qp {
 	struct uacce_queue *uacce_q;
 };
 
+static inline void hisi_qm_init_list(struct hisi_qm_list *qm_list)
+{
+	INIT_LIST_HEAD(&qm_list->list);
+	mutex_init(&qm_list->lock);
+}
+
+static inline void hisi_qm_add_to_list(struct hisi_qm *qm,
+				       struct hisi_qm_list *qm_list)
+{
+	mutex_lock(&qm_list->lock);
+	list_add_tail(&qm->list, &qm_list->list);
+	mutex_unlock(&qm_list->lock);
+}
+
+static inline void hisi_qm_del_from_list(struct hisi_qm *qm,
+					 struct hisi_qm_list *qm_list)
+{
+	mutex_lock(&qm_list->lock);
+	list_del(&qm->list);
+	mutex_unlock(&qm_list->lock);
+}
+
 int hisi_qm_init(struct hisi_qm *qm);
 void hisi_qm_uninit(struct hisi_qm *qm);
 int hisi_qm_start(struct hisi_qm *qm);
@@ -258,4 +286,7 @@ struct hisi_acc_sgl_pool *hisi_acc_create_sgl_pool(struct device *dev,
 						   u32 count, u32 sge_nr);
 void hisi_acc_free_sgl_pool(struct device *dev,
 			    struct hisi_acc_sgl_pool *pool);
+int hisi_qm_alloc_qps_node(struct hisi_qm_list *qm_list, int qp_num,
+			   u8 alg_type, int node, struct hisi_qp **qps);
+void hisi_qm_free_qps(struct hisi_qp **qps, int qp_num);
 #endif

commit 57ca81245f4db4a0222d545f8f5d4709544c26cf
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Thu Mar 5 10:06:21 2020 +0800

    crypto: hisilicon - Use one workqueue per qm instead of per qp
    
    Since SEC need not so many workqueues as our test, we just use
    one workqueue created by the device driver of QM if necessary,
    which will also reduce CPU waste without any throughput decreasing.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Zaibo Xu <xuzaibo@huawei.com>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 1a4f208a9448..c72c2e64d04b 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -183,6 +183,9 @@ struct hisi_qm {
 	u32 error_mask;
 	u32 msi_mask;
 
+	struct workqueue_struct *wq;
+	struct work_struct work;
+
 	const char *algs;
 	bool use_dma_api;
 	bool use_sva;
@@ -219,8 +222,6 @@ struct hisi_qp {
 	void *qp_ctx;
 	void (*req_cb)(struct hisi_qp *qp, void *data);
 	void (*event_cb)(struct hisi_qp *qp);
-	struct work_struct work;
-	struct workqueue_struct *wq;
 
 	struct hisi_qm *qm;
 	u16 pasid;

commit 9e00df7156e45e42c695ffc596b4bf1328d00516
Author: Zhangfei Gao <zhangfei.gao@linaro.org>
Date:   Tue Feb 11 15:54:25 2020 +0800

    crypto: hisilicon - register zip engine to uacce
    
    Register qm to uacce framework for user crypto driver
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Zhangfei Gao <zhangfei.gao@linaro.org>
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index cae26eabd849..1a4f208a9448 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -77,6 +77,9 @@
 
 #define HISI_ACC_SGL_SGE_NR_MAX		255
 
+/* page number for queue file region */
+#define QM_DOORBELL_PAGE_NR		1
+
 enum qp_state {
 	QP_STOP,
 };
@@ -180,7 +183,12 @@ struct hisi_qm {
 	u32 error_mask;
 	u32 msi_mask;
 
+	const char *algs;
 	bool use_dma_api;
+	bool use_sva;
+	resource_size_t phys_base;
+	resource_size_t phys_size;
+	struct uacce_device *uacce;
 };
 
 struct hisi_qp_status {
@@ -210,10 +218,13 @@ struct hisi_qp {
 	struct hisi_qp_ops *hw_ops;
 	void *qp_ctx;
 	void (*req_cb)(struct hisi_qp *qp, void *data);
+	void (*event_cb)(struct hisi_qp *qp);
 	struct work_struct work;
 	struct workqueue_struct *wq;
 
 	struct hisi_qm *qm;
+	u16 pasid;
+	struct uacce_queue *uacce_q;
 };
 
 int hisi_qm_init(struct hisi_qm *qm);

commit f826e6efb42b9eb0097d0969310a407aa039be08
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Mon Jan 20 15:30:08 2020 +0800

    crypto: hisilicon - Unify error detect process into qm
    
    In error detect process, a lot of duplicate code can put into qm. We add
    two callback(get_dev_hw_err_status and log_dev_hw_err) into struct
    hisi_qm_err_ini to handle device error detect, meanwhile the qm error
    detect not changed.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Zaibo Xu <xuzaibo@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 325f6d5d7991..cae26eabd849 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -137,6 +137,8 @@ struct hisi_qm_err_info {
 struct hisi_qm_err_ini {
 	void (*hw_err_enable)(struct hisi_qm *qm);
 	void (*hw_err_disable)(struct hisi_qm *qm);
+	u32 (*get_dev_hw_err_status)(struct hisi_qm *qm);
+	void (*log_dev_hw_err)(struct hisi_qm *qm, u32 err_sts);
 	struct hisi_qm_err_info err_info;
 };
 
@@ -227,11 +229,12 @@ int hisi_qm_get_free_qp_num(struct hisi_qm *qm);
 int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number);
 int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
 int hisi_qm_debug_init(struct hisi_qm *qm);
-pci_ers_result_t hisi_qm_hw_error_handle(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
 void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
 void hisi_qm_dev_err_init(struct hisi_qm *qm);
 void hisi_qm_dev_err_uninit(struct hisi_qm *qm);
+pci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,
+					  pci_channel_state_t state);
 
 struct hisi_acc_sgl_pool;
 struct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,

commit eaebf4c3b103dfc3c00dd3b6d3966fb9e08777ce
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Mon Jan 20 15:30:06 2020 +0800

    crypto: hisilicon - Unify hardware error init/uninit into QM
    
    The initialization and uninitialization of zip/hpre/sec/qm hardware error
    is processed in respective drivers, which could be unified into qm.c. We
    add struct hisi_qm_err_ini into struct hisi_qm, which involve all error
    handlers of device and assignment should be done in driver probe.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Zaibo Xu <xuzaibo@huawei.com>
    Reviewed-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 078b8f1f1b77..325f6d5d7991 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -125,6 +125,21 @@ struct hisi_qm_status {
 	unsigned long flags;
 };
 
+struct hisi_qm;
+
+struct hisi_qm_err_info {
+	u32 ce;
+	u32 nfe;
+	u32 fe;
+	u32 msi;
+};
+
+struct hisi_qm_err_ini {
+	void (*hw_err_enable)(struct hisi_qm *qm);
+	void (*hw_err_disable)(struct hisi_qm *qm);
+	struct hisi_qm_err_info err_info;
+};
+
 struct hisi_qm {
 	enum qm_hw_ver ver;
 	enum qm_fun_type fun_type;
@@ -148,6 +163,7 @@ struct hisi_qm {
 	dma_addr_t aeqe_dma;
 
 	struct hisi_qm_status status;
+	const struct hisi_qm_err_ini *err_ini;
 
 	rwlock_t qps_lock;
 	unsigned long *qp_bitmap;
@@ -211,11 +227,11 @@ int hisi_qm_get_free_qp_num(struct hisi_qm *qm);
 int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number);
 int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
 int hisi_qm_debug_init(struct hisi_qm *qm);
-void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
-			   u32 msi);
 pci_ers_result_t hisi_qm_hw_error_handle(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
 void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
+void hisi_qm_dev_err_init(struct hisi_qm *qm);
+void hisi_qm_dev_err_uninit(struct hisi_qm *qm);
 
 struct hisi_acc_sgl_pool;
 struct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,

commit 700f7d0d29c795c36517dcd3541e4432a76c2efc
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Sat Oct 26 11:00:16 2019 +0800

    crypto: hisilicon - fix to return sub-optimal device when best device has no qps
    
    Currently find_zip_device() finds zip device which has the min NUMA
    distance with current CPU.
    
    This patch modifies find_zip_device to return sub-optimal device when best
    device has no qps. This patch sorts all devices by NUMA distance, then
    finds the best zip device which has free qp.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 61064bd2f336..078b8f1f1b77 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -134,6 +134,7 @@ struct hisi_qm {
 	u32 sqe_size;
 	u32 qp_base;
 	u32 qp_num;
+	u32 qp_in_used;
 	u32 ctrl_qp_num;
 
 	struct qm_dma qdma;
@@ -206,6 +207,7 @@ int hisi_qm_start_qp(struct hisi_qp *qp, unsigned long arg);
 int hisi_qm_stop_qp(struct hisi_qp *qp);
 void hisi_qm_release_qp(struct hisi_qp *qp);
 int hisi_qp_send(struct hisi_qp *qp, const void *msg);
+int hisi_qm_get_free_qp_num(struct hisi_qm *qm);
 int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number);
 int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
 int hisi_qm_debug_init(struct hisi_qm *qm);

commit 9a8641a7ffbf6f896bcd2bb2c6c0f4b403831c18
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Mon Oct 21 15:41:03 2019 +0800

    crypto: hisilicon - fix endianness verification problem of QM
    
    This patch fixes following sparse warning:
    
    qm.c:345:33: warning: cast removes address space '<asn:2>' of expression
    qm.c:359:20: warning: incorrect type in assignment (different base types)
    qm.c:359:20:    expected restricted __le16 [usertype] w0
    qm.c:359:20:    got int
    qm.c:362:27: warning: incorrect type in assignment (different base types)
    qm.c:362:27:    expected restricted __le16 [usertype] queue_num
    qm.c:362:27:    got unsigned short [usertype] queue
    qm.c:363:24: warning: incorrect type in assignment (different base types)
    qm.c:363:24:    expected restricted __le32 [usertype] base_l
    qm.c:363:24:    got unsigned int [usertype]
    qm.c:364:24: warning: incorrect type in assignment (different base types)
    qm.c:364:24:    expected restricted __le32 [usertype] base_h
    qm.c:364:24:    got unsigned int [usertype]
    qm.c:451:22: warning: restricted __le32 degrades to integer
    qm.c:471:24: warning: restricted __le16 degrades to integer
    ......
    qm.c:1617:19: warning: incorrect type in assignment (different base types)
    qm.c:1617:19:    expected restricted __le32 [usertype] dw6
    qm.c:1617:19:    got int
    qm.c:1891:24: warning: incorrect type in return expression (different base types)
    qm.c:1891:24:    expected int
    qm.c:1891:24:    got restricted pci_ers_result_t
    qm.c:1894:40: warning: incorrect type in return expression (different base types)
    qm.c:1894:40:    expected int
    qm.c:1894:40:    got restricted pci_ers_result_t
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 103e2fde84b1..61064bd2f336 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -211,7 +211,7 @@ int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
 int hisi_qm_debug_init(struct hisi_qm *qm);
 void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
 			   u32 msi);
-int hisi_qm_hw_error_handle(struct hisi_qm *qm);
+pci_ers_result_t hisi_qm_hw_error_handle(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
 void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
 

commit f081fda293ffba54216a7dab66faba7275475006
Author: Shukun Tan <tanshukun1@huawei.com>
Date:   Mon Sep 30 15:08:53 2019 +0800

    crypto: hisilicon - add sgl_sge_nr module param for zip
    
    Add a module parameter for zip driver to set the number of SGE in one SGL.
    
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 978d2aeb4d6c..103e2fde84b1 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -75,6 +75,8 @@
 
 #define QM_Q_DEPTH			1024
 
+#define HISI_ACC_SGL_SGE_NR_MAX		255
+
 enum qp_state {
 	QP_STOP,
 };

commit 48c1cd40fae31aa39e33930e7d28a0d96f01ea17
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Mon Sep 30 15:08:52 2019 +0800

    crypto: hisilicon - merge sgl support to hisi_qm module
    
    As HW SGL can be seen as a data format of QM's sqe, we merge sgl code into
    qm module and rename it as hisi_qm, which reduces the number of module and
    make the name less generic.
    
    This patch also modify the interface of SGL:
     - Create/free hisi_acc_sgl_pool inside.
     - Let user to pass the SGE number in one SGL when creating sgl pool, which
       is better than a unified module parameter for sgl module before.
     - Modify zip driver according to sgl interface change.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Shukun Tan <tanshukun1@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 70e672ae86bf..978d2aeb4d6c 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -212,4 +212,15 @@ void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
 int hisi_qm_hw_error_handle(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
 void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
+
+struct hisi_acc_sgl_pool;
+struct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,
+	struct scatterlist *sgl, struct hisi_acc_sgl_pool *pool,
+	u32 index, dma_addr_t *hw_sgl_dma);
+void hisi_acc_sg_buf_unmap(struct device *dev, struct scatterlist *sgl,
+			   struct hisi_acc_hw_sgl *hw_sgl);
+struct hisi_acc_sgl_pool *hisi_acc_create_sgl_pool(struct device *dev,
+						   u32 count, u32 sge_nr);
+void hisi_acc_free_sgl_pool(struct device *dev,
+			    struct hisi_acc_sgl_pool *pool);
 #endif

commit 72c7a68d2ea34803e9c4ef948261ec6744fc72fc
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Fri Aug 2 15:57:55 2019 +0800

    crypto: hisilicon - add debugfs for ZIP and QM
    
    HiSilicon ZIP engine driver uses debugfs to provide debug information,
    the usage can be found in /Documentation/ABI/testing/debugfs-hisi-zip.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index 8b3cb69dffca..70e672ae86bf 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -46,6 +46,13 @@
 #define PEH_AXUSER_CFG			0x401001
 #define PEH_AXUSER_CFG_ENABLE		0xffffffff
 
+#define QM_DFX_MB_CNT_VF		0x104010
+#define QM_DFX_DB_CNT_VF		0x104020
+#define QM_DFX_SQE_CNT_VF_SQN		0x104030
+#define QM_DFX_CQE_CNT_VF_CQN		0x104040
+#define QM_DFX_QN_SHIFT			16
+#define CURRENT_FUN_MASK		GENMASK(5, 0)
+#define CURRENT_Q_MASK			GENMASK(31, 16)
 
 #define QM_AXI_RRESP			BIT(0)
 #define QM_AXI_BRESP			BIT(1)
@@ -83,6 +90,25 @@ enum qm_fun_type {
 	QM_HW_VF,
 };
 
+enum qm_debug_file {
+	CURRENT_Q,
+	CLEAR_ENABLE,
+	DEBUG_FILE_NUM,
+};
+
+struct debugfs_file {
+	enum qm_debug_file index;
+	struct mutex lock;
+	struct qm_debug *debug;
+};
+
+struct qm_debug {
+	u32 curr_qm_qp_num;
+	struct dentry *debug_root;
+	struct dentry *qm_d;
+	struct debugfs_file files[DEBUG_FILE_NUM];
+};
+
 struct qm_dma {
 	void *va;
 	dma_addr_t dma;
@@ -128,6 +154,8 @@ struct hisi_qm {
 
 	const struct hisi_qm_hw_ops *ops;
 
+	struct qm_debug debug;
+
 	u32 error_mask;
 	u32 msi_mask;
 
@@ -183,4 +211,5 @@ void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
 			   u32 msi);
 int hisi_qm_hw_error_handle(struct hisi_qm *qm);
 enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
+void hisi_qm_debug_regs_clear(struct hisi_qm *qm);
 #endif

commit 79e09f30eeba857b09832209bfc66bd689c58328
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Fri Aug 2 15:57:53 2019 +0800

    crypto: hisilicon - add SRIOV support for ZIP
    
    HiSilicon ZIP engine supports PCI SRIOV. This patch enable this feature.
    User can enable VFs and pass through them to VM, same ZIP driver can work
    in VM to provide ZLIB and GZIP algorithm by crypto acomp interface.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
index a5849db163cb..8b3cb69dffca 100644
--- a/drivers/crypto/hisilicon/qm.h
+++ b/drivers/crypto/hisilicon/qm.h
@@ -80,6 +80,7 @@ enum qm_hw_ver {
 
 enum qm_fun_type {
 	QM_HW_PF,
+	QM_HW_VF,
 };
 
 struct qm_dma {
@@ -98,6 +99,7 @@ struct hisi_qm_status {
 
 struct hisi_qm {
 	enum qm_hw_ver ver;
+	enum qm_fun_type fun_type;
 	const char *dev_name;
 	struct pci_dev *pdev;
 	void __iomem *io_base;
@@ -174,7 +176,9 @@ int hisi_qm_start_qp(struct hisi_qp *qp, unsigned long arg);
 int hisi_qm_stop_qp(struct hisi_qp *qp);
 void hisi_qm_release_qp(struct hisi_qp *qp);
 int hisi_qp_send(struct hisi_qp *qp, const void *msg);
+int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number);
 int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
+int hisi_qm_debug_init(struct hisi_qm *qm);
 void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
 			   u32 msi);
 int hisi_qm_hw_error_handle(struct hisi_qm *qm);

commit 263c9959c9376ec0217d6adc61222a53469eed3c
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Fri Aug 2 15:57:50 2019 +0800

    crypto: hisilicon - add queue management driver for HiSilicon QM module
    
    QM is a general IP used by HiSilicon accelerators. It provides a general
    PCIe interface for the CPU and the accelerator to share a group of queues.
    
    A QM integrated in an accelerator provides queue management service.
    Queues can be assigned to PF and VFs, and queues can be controlled by
    unified mailboxes and doorbells. Specific task request are descripted by
    specific description buffer, which will be controlled and pass to related
    accelerator IP by QM.
    
    This patch adds a QM driver used by the accelerator driver to access
    the QM hardware.
    
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Kenneth Lee <liguozhu@hisilicon.com>
    Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
    Signed-off-by: Hao Fang <fanghao11@huawei.com>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/hisilicon/qm.h b/drivers/crypto/hisilicon/qm.h
new file mode 100644
index 000000000000..a5849db163cb
--- /dev/null
+++ b/drivers/crypto/hisilicon/qm.h
@@ -0,0 +1,182 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2019 HiSilicon Limited. */
+#ifndef HISI_ACC_QM_H
+#define HISI_ACC_QM_H
+
+#include <linux/bitfield.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+/* qm user domain */
+#define QM_ARUSER_M_CFG_1		0x100088
+#define AXUSER_SNOOP_ENABLE		BIT(30)
+#define AXUSER_CMD_TYPE			GENMASK(14, 12)
+#define AXUSER_CMD_SMMU_NORMAL		1
+#define AXUSER_NS			BIT(6)
+#define AXUSER_NO			BIT(5)
+#define AXUSER_FP			BIT(4)
+#define AXUSER_SSV			BIT(0)
+#define AXUSER_BASE			(AXUSER_SNOOP_ENABLE |		\
+					FIELD_PREP(AXUSER_CMD_TYPE,	\
+					AXUSER_CMD_SMMU_NORMAL) |	\
+					AXUSER_NS | AXUSER_NO | AXUSER_FP)
+#define QM_ARUSER_M_CFG_ENABLE		0x100090
+#define ARUSER_M_CFG_ENABLE		0xfffffffe
+#define QM_AWUSER_M_CFG_1		0x100098
+#define QM_AWUSER_M_CFG_ENABLE		0x1000a0
+#define AWUSER_M_CFG_ENABLE		0xfffffffe
+#define QM_WUSER_M_CFG_ENABLE		0x1000a8
+#define WUSER_M_CFG_ENABLE		0xffffffff
+
+/* qm cache */
+#define QM_CACHE_CTL			0x100050
+#define SQC_CACHE_ENABLE		BIT(0)
+#define CQC_CACHE_ENABLE		BIT(1)
+#define SQC_CACHE_WB_ENABLE		BIT(4)
+#define SQC_CACHE_WB_THRD		GENMASK(10, 5)
+#define CQC_CACHE_WB_ENABLE		BIT(11)
+#define CQC_CACHE_WB_THRD		GENMASK(17, 12)
+#define QM_AXI_M_CFG			0x1000ac
+#define AXI_M_CFG			0xffff
+#define QM_AXI_M_CFG_ENABLE		0x1000b0
+#define AXI_M_CFG_ENABLE		0xffffffff
+#define QM_PEH_AXUSER_CFG		0x1000cc
+#define QM_PEH_AXUSER_CFG_ENABLE	0x1000d0
+#define PEH_AXUSER_CFG			0x401001
+#define PEH_AXUSER_CFG_ENABLE		0xffffffff
+
+
+#define QM_AXI_RRESP			BIT(0)
+#define QM_AXI_BRESP			BIT(1)
+#define QM_ECC_MBIT			BIT(2)
+#define QM_ECC_1BIT			BIT(3)
+#define QM_ACC_GET_TASK_TIMEOUT		BIT(4)
+#define QM_ACC_DO_TASK_TIMEOUT		BIT(5)
+#define QM_ACC_WB_NOT_READY_TIMEOUT	BIT(6)
+#define QM_SQ_CQ_VF_INVALID		BIT(7)
+#define QM_CQ_VF_INVALID		BIT(8)
+#define QM_SQ_VF_INVALID		BIT(9)
+#define QM_DB_TIMEOUT			BIT(10)
+#define QM_OF_FIFO_OF			BIT(11)
+#define QM_DB_RANDOM_INVALID		BIT(12)
+
+#define QM_BASE_NFE	(QM_AXI_RRESP | QM_AXI_BRESP | QM_ECC_MBIT | \
+			 QM_ACC_GET_TASK_TIMEOUT | QM_DB_TIMEOUT | \
+			 QM_OF_FIFO_OF)
+#define QM_BASE_CE			QM_ECC_1BIT
+
+#define QM_Q_DEPTH			1024
+
+enum qp_state {
+	QP_STOP,
+};
+
+enum qm_hw_ver {
+	QM_HW_UNKNOWN = -1,
+	QM_HW_V1 = 0x20,
+	QM_HW_V2 = 0x21,
+};
+
+enum qm_fun_type {
+	QM_HW_PF,
+};
+
+struct qm_dma {
+	void *va;
+	dma_addr_t dma;
+	size_t size;
+};
+
+struct hisi_qm_status {
+	u32 eq_head;
+	bool eqc_phase;
+	u32 aeq_head;
+	bool aeqc_phase;
+	unsigned long flags;
+};
+
+struct hisi_qm {
+	enum qm_hw_ver ver;
+	const char *dev_name;
+	struct pci_dev *pdev;
+	void __iomem *io_base;
+	u32 sqe_size;
+	u32 qp_base;
+	u32 qp_num;
+	u32 ctrl_qp_num;
+
+	struct qm_dma qdma;
+	struct qm_sqc *sqc;
+	struct qm_cqc *cqc;
+	struct qm_eqe *eqe;
+	struct qm_aeqe *aeqe;
+	dma_addr_t sqc_dma;
+	dma_addr_t cqc_dma;
+	dma_addr_t eqe_dma;
+	dma_addr_t aeqe_dma;
+
+	struct hisi_qm_status status;
+
+	rwlock_t qps_lock;
+	unsigned long *qp_bitmap;
+	struct hisi_qp **qp_array;
+
+	struct mutex mailbox_lock;
+
+	const struct hisi_qm_hw_ops *ops;
+
+	u32 error_mask;
+	u32 msi_mask;
+
+	bool use_dma_api;
+};
+
+struct hisi_qp_status {
+	atomic_t used;
+	u16 sq_tail;
+	u16 cq_head;
+	bool cqc_phase;
+	unsigned long flags;
+};
+
+struct hisi_qp_ops {
+	int (*fill_sqe)(void *sqe, void *q_parm, void *d_parm);
+};
+
+struct hisi_qp {
+	u32 qp_id;
+	u8 alg_type;
+	u8 req_type;
+
+	struct qm_dma qdma;
+	void *sqe;
+	struct qm_cqe *cqe;
+	dma_addr_t sqe_dma;
+	dma_addr_t cqe_dma;
+
+	struct hisi_qp_status qp_status;
+	struct hisi_qp_ops *hw_ops;
+	void *qp_ctx;
+	void (*req_cb)(struct hisi_qp *qp, void *data);
+	struct work_struct work;
+	struct workqueue_struct *wq;
+
+	struct hisi_qm *qm;
+};
+
+int hisi_qm_init(struct hisi_qm *qm);
+void hisi_qm_uninit(struct hisi_qm *qm);
+int hisi_qm_start(struct hisi_qm *qm);
+int hisi_qm_stop(struct hisi_qm *qm);
+struct hisi_qp *hisi_qm_create_qp(struct hisi_qm *qm, u8 alg_type);
+int hisi_qm_start_qp(struct hisi_qp *qp, unsigned long arg);
+int hisi_qm_stop_qp(struct hisi_qp *qp);
+void hisi_qm_release_qp(struct hisi_qp *qp);
+int hisi_qp_send(struct hisi_qp *qp, const void *msg);
+int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base, u32 number);
+void hisi_qm_hw_error_init(struct hisi_qm *qm, u32 ce, u32 nfe, u32 fe,
+			   u32 msi);
+int hisi_qm_hw_error_handle(struct hisi_qm *qm);
+enum qm_hw_ver hisi_qm_get_hw_version(struct pci_dev *pdev);
+#endif
