commit 1a3daadce955530df92b1bb22093618dd26a1717
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Tue Aug 20 13:23:55 2019 -0700

    crypto: caam - make CAAM_PTR_SZ dynamic
    
    In order to be able to configure CAAM pointer size at run-time, which
    needed to support i.MX8MQ, which is 64-bit SoC with 32-bit pointer
    size, convert CAAM_PTR_SZ to refer to a global variable of the same
    name ("caam_ptr_sz") and adjust the rest of the code accordingly. No
    functional change intended.
    
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Cc: Chris Spencer <christopher.spencer@sea.co.uk>
    Cc: Cory Tusar <cory.tusar@zii.aero>
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Cc: Horia Geantă <horia.geanta@nxp.com>
    Cc: Aymen Sghaier <aymen.sghaier@nxp.com>
    Cc: Leonard Crestez <leonard.crestez@nxp.com>
    Cc: linux-crypto@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index b7fbf1be37a4..17c6108b6d41 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -56,6 +56,9 @@ EXPORT_SYMBOL(caam_little_end);
 bool caam_imx;
 EXPORT_SYMBOL(caam_imx);
 
+size_t caam_ptr_sz;
+EXPORT_SYMBOL(caam_ptr_sz);
+
 static const struct {
 	u8 value;
 	const char *error_text;

commit 1984aaeec372fbfb597883074253d290cbd543d4
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Wed Jul 31 16:08:03 2019 +0300

    crypto: caam - fix return code in completion callbacks
    
    Modify drive to provide a valid errno (and not the HW error ID)
    to the user, via completion callbacks.
    
    A "valid errno" is currently not explicitly mentioned in the docs,
    however the error code is expected to match the one returned by the
    generic SW implementation.
    
    Note: in most error cases caam/qi and caam/qi2 returned -EIO; align all
    caam drivers to return -EINVAL.
    
    While here, ratelimit prints triggered by fuzz testing, such that
    console is not flooded.
    
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Iuliana Prodan <iuliana.prodan@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 95da6ae43482..b7fbf1be37a4 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -211,8 +211,8 @@ static const char * const rng_err_id_list[] = {
 	"Secure key generation",
 };
 
-static void report_ccb_status(struct device *jrdev, const u32 status,
-			      const char *error)
+static int report_ccb_status(struct device *jrdev, const u32 status,
+			     const char *error)
 {
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
@@ -248,22 +248,27 @@ static void report_ccb_status(struct device *jrdev, const u32 status,
 	 * CCB ICV check failures are part of normal operation life;
 	 * we leave the upper layers to do what they want with them.
 	 */
-	if (err_id != JRSTA_CCBERR_ERRID_ICVCHK)
-		dev_err(jrdev, "%08x: %s: %s %d: %s%s: %s%s\n",
-			status, error, idx_str, idx,
-			cha_str, cha_err_code,
-			err_str, err_err_code);
+	if (err_id == JRSTA_CCBERR_ERRID_ICVCHK)
+		return -EBADMSG;
+
+	dev_err_ratelimited(jrdev, "%08x: %s: %s %d: %s%s: %s%s\n", status,
+			    error, idx_str, idx, cha_str, cha_err_code,
+			    err_str, err_err_code);
+
+	return -EINVAL;
 }
 
-static void report_jump_status(struct device *jrdev, const u32 status,
-			       const char *error)
+static int report_jump_status(struct device *jrdev, const u32 status,
+			      const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
+
+	return -EINVAL;
 }
 
-static void report_deco_status(struct device *jrdev, const u32 status,
-			       const char *error)
+static int report_deco_status(struct device *jrdev, const u32 status,
+			      const char *error)
 {
 	u8 err_id = status & JRSTA_DECOERR_ERROR_MASK;
 	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
@@ -289,10 +294,12 @@ static void report_deco_status(struct device *jrdev, const u32 status,
 
 	dev_err(jrdev, "%08x: %s: %s %d: %s%s\n",
 		status, error, idx_str, idx, err_str, err_err_code);
+
+	return -EINVAL;
 }
 
-static void report_qi_status(struct device *qidev, const u32 status,
-			     const char *error)
+static int report_qi_status(struct device *qidev, const u32 status,
+			    const char *error)
 {
 	u8 err_id = status & JRSTA_QIERR_ERROR_MASK;
 	const char *err_str = "unidentified error value 0x";
@@ -310,27 +317,33 @@ static void report_qi_status(struct device *qidev, const u32 status,
 
 	dev_err(qidev, "%08x: %s: %s%s\n",
 		status, error, err_str, err_err_code);
+
+	return -EINVAL;
 }
 
-static void report_jr_status(struct device *jrdev, const u32 status,
-			     const char *error)
+static int report_jr_status(struct device *jrdev, const u32 status,
+			    const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
+
+	return -EINVAL;
 }
 
-static void report_cond_code_status(struct device *jrdev, const u32 status,
-				    const char *error)
+static int report_cond_code_status(struct device *jrdev, const u32 status,
+				   const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
+
+	return -EINVAL;
 }
 
-void caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)
+int caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)
 {
 	static const struct stat_src {
-		void (*report_ssed)(struct device *jrdev, const u32 status,
-				    const char *error);
+		int (*report_ssed)(struct device *jrdev, const u32 status,
+				   const char *error);
 		const char *error;
 	} status_src[16] = {
 		{ NULL, "No error" },
@@ -358,11 +371,14 @@ void caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)
 	 * Otherwise print the error source name.
 	 */
 	if (status_src[ssrc].report_ssed)
-		status_src[ssrc].report_ssed(jrdev, status, error);
-	else if (error)
+		return status_src[ssrc].report_ssed(jrdev, status, error);
+
+	if (error)
 		dev_err(jrdev, "%d: %s\n", ssrc, error);
 	else
 		dev_err(jrdev, "%d: unknown error source\n", ssrc);
+
+	return -EINVAL;
 }
 EXPORT_SYMBOL(caam_strstatus);
 

commit 51fab3d73054ca5b06b26e20edac0486b052c6f4
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Wed Jul 31 16:08:02 2019 +0300

    crypto: caam/qi - fix error handling in ERN handler
    
    ERN handler calls the caam/qi frontend "done" callback with a status
    of -EIO. This is incorrect, since the callback expects a status value
    meaningful for the crypto engine - hence the cryptic messages
    like the one below:
    platform caam_qi: 15: unknown error source
    
    Fix this by providing the callback with:
    -the status returned by the crypto engine (fd[status]) in case
    it contains an error, OR
    -a QI "No error" code otherwise; this will trigger the message:
    platform caam_qi: 50000000: Queue Manager Interface: No error
    which is fine, since QMan driver provides details about the cause of
    failure
    
    Cc: <stable@vger.kernel.org> # v5.1+
    Fixes: 67c2315def06 ("crypto: caam - add Queue Interface (QI) backend support")
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Reviewed-by: Iuliana Prodan <iuliana.prodan@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 4f0d45865aa2..95da6ae43482 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -118,6 +118,7 @@ static const struct {
 	u8 value;
 	const char *error_text;
 } qi_error_list[] = {
+	{ 0x00, "No error" },
 	{ 0x1F, "Job terminated by FQ or ICID flush" },
 	{ 0x20, "FD format error"},
 	{ 0x21, "FD command format error"},

commit 8a82451bd04f57bfde8915f289fc2d1f9457abae
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu May 23 10:50:30 2019 +0200

    crypto: caam - print messages in caam_dump_sg at debug level
    
    caam_dump_sg() is only compiled in when DEBUG is defined, hence the
    messages are debug messages. Remove the @level argument from
    caam_dump_sg() and print all messages at debug level.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 4da844e4b61d..4f0d45865aa2 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -13,7 +13,7 @@
 #ifdef DEBUG
 #include <linux/highmem.h>
 
-void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
+void caam_dump_sg(const char *prefix_str, int prefix_type,
 		  int rowsize, int groupsize, struct scatterlist *sg,
 		  size_t tlen, bool ascii)
 {
@@ -35,15 +35,15 @@ void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
 
 		buf = it_page + it->offset;
 		len = min_t(size_t, tlen, it->length);
-		print_hex_dump(level, prefix_str, prefix_type, rowsize,
-			       groupsize, buf, len, ascii);
+		print_hex_dump_debug(prefix_str, prefix_type, rowsize,
+				     groupsize, buf, len, ascii);
 		tlen -= len;
 
 		kunmap_atomic(it_page);
 	}
 }
 #else
-void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
+void caam_dump_sg(const char *prefix_str, int prefix_type,
 		  int rowsize, int groupsize, struct scatterlist *sg,
 		  size_t tlen, bool ascii)
 {}

commit 8c65d35435e8cbfdf953cafe5ebe3648ee9276a2
Author: Iuliana Prodan <iuliana.prodan@nxp.com>
Date:   Tue May 7 16:37:03 2019 +0300

    crypto: caam - fix caam_dump_sg that iterates through scatterlist
    
    Fix caam_dump_sg by correctly determining the next scatterlist
    entry in the list.
    
    Fixes: 5ecf8ef9103c ("crypto: caam - fix sg dump")
    Signed-off-by: Iuliana Prodan <iuliana.prodan@nxp.com>
    Reviewed-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index a4129a35a330..4da844e4b61d 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -22,7 +22,7 @@ void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
 	size_t len;
 	void *buf;
 
-	for (it = sg; it && tlen > 0 ; it = sg_next(sg)) {
+	for (it = sg; it && tlen > 0 ; it = sg_next(it)) {
 		/*
 		 * make sure the scatterlist's page
 		 * has a valid virtual memory mapping

commit 6ddc8e3117d602ebe05f8fcc5429628b6d3a5853
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Apr 15 13:40:21 2019 +0100

    crypto: caam - fix spelling mistake "cannote" -> "cannot"
    
    There is a spelling mistake in an error message in the qi_error_list
    array. Fix this.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 21a70fd32f5d..a4129a35a330 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -138,7 +138,7 @@ static const struct {
 	{ 0x46, "Annotation length exceeds offset (reuse mode)"},
 	{ 0x48, "Annotation output enabled but ASA limited by ASAR (reuse mode)"},
 	{ 0x49, "Data offset correction exceeds input frame data length (reuse mode)"},
-	{ 0x4B, "Annotation output enabled but ASA cannote be expanded (frame list)"},
+	{ 0x4B, "Annotation output enabled but ASA cannot be expanded (frame list)"},
 	{ 0x51, "Unsupported IF reuse mode"},
 	{ 0x52, "Unsupported FL use mode"},
 	{ 0x53, "Unsupported RJD use mode"},

commit 5b3b9871cc28dbf827c41595d73595627434ff4d
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Thu Jan 10 15:58:12 2019 +0200

    crypto: caam - move shared symbols in a common location
    
    There are several issues with symbols shared b/w:
    -caam/jr and caam/qi drivers on one hand
    -caam/qi2 driver on the other hand
    
    Commit 52813ab24959 ("crypto: caam/qi2 - avoid double export") fixed
    some of them, however compilation still fails for CRYPTO_DEV_FSL_CAAM=m
    and CRYPTO_DEV_FSL_DPAA2_CAAM=y.
    
    Another issue is related to dependency cycles reported by depmod when
    CRYPTO_DEV_FSL_CAAM=n and CRYPTO_DEV_FSL_DPAA2_CAAM=m, as mentioned in
    82c7b351be3f ("Revert "arm64: defconfig: Enable FSL_MC_BUS and FSL_MC_DPIO"")
    
    To fix all these, move the symbols shared by these drivers in a common
    location. The only existing possibility is error.c file (note that naming
    doesn't help and should probably change).
    
    Fixes: 52813ab24959 ("crypto: caam/qi2 - avoid double export")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 7e8d690f2827..21a70fd32f5d 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -50,6 +50,12 @@ void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
 #endif /* DEBUG */
 EXPORT_SYMBOL(caam_dump_sg);
 
+bool caam_little_end;
+EXPORT_SYMBOL(caam_little_end);
+
+bool caam_imx;
+EXPORT_SYMBOL(caam_imx);
+
 static const struct {
 	u8 value;
 	const char *error_text;

commit 8d818c1055013d355d36188f21c7535687374f6c
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Wed Sep 12 11:59:33 2018 +0300

    crypto: caam/qi2 - add DPAA2-CAAM driver
    
    Add CAAM driver that works using the DPSECI backend, i.e. manages
    DPSECI DPAA2 objects sitting on the Management Complex (MC) fsl-mc bus.
    
    Data transfers (crypto requests) are sent/received to/from CAAM crypto
    engine via Queue Interface (v2), this being similar to existing caam/qi.
    OTOH, configuration/setup (obtaining virtual queue IDs, authorization
    etc.) is done by sending commands to the MC f/w.
    
    Note that the CAAM accelerator included in DPAA2 platforms still has
    Job Rings. However, the driver being added does not handle access
    via this backend. Kconfig & Makefile are updated such that DPAA2-CAAM
    (a.k.a. "caam/qi2") driver does not depend on caam/jr or caam/qi
    backends - which rely on platform bus support (ctrl.c).
    
    Support for the following aead and authenc algorithms is also added
    in this patch:
    -aead:
    gcm(aes)
    rfc4106(gcm(aes))
    rfc4543(gcm(aes))
    -authenc:
    authenc(hmac({md5,sha*}),cbc({aes,des,des3_ede}))
    echainiv(authenc(hmac({md5,sha*}),cbc({aes,des,des3_ede})))
    authenc(hmac({md5,sha*}),rfc3686(ctr(aes))
    seqiv(authenc(hmac({md5,sha*}),rfc3686(ctr(aes)))
    
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index db0f0d96842e..7e8d690f2827 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -358,3 +358,7 @@ void caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)
 		dev_err(jrdev, "%d: unknown error source\n", ssrc);
 }
 EXPORT_SYMBOL(caam_strstatus);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("FSL CAAM error reporting");
+MODULE_AUTHOR("Freescale Semiconductor");

commit 94cebd9da42cffbcf308c295656e6cd73d02a610
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Wed Sep 12 11:59:32 2018 +0300

    crypto: caam - add Queue Interface v2 error codes
    
    Add support to translate error codes returned by QI v2, i.e.
    Queue Interface present on DataPath Acceleration Architecture
    v2 (DPAA2).
    
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 8da88beb1abb..db0f0d96842e 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -108,6 +108,54 @@ static const struct {
 	{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
 };
 
+static const struct {
+	u8 value;
+	const char *error_text;
+} qi_error_list[] = {
+	{ 0x1F, "Job terminated by FQ or ICID flush" },
+	{ 0x20, "FD format error"},
+	{ 0x21, "FD command format error"},
+	{ 0x23, "FL format error"},
+	{ 0x25, "CRJD specified in FD, but not enabled in FLC"},
+	{ 0x30, "Max. buffer size too small"},
+	{ 0x31, "DHR exceeds max. buffer size (allocate mode, S/G format)"},
+	{ 0x32, "SGT exceeds max. buffer size (allocate mode, S/G format"},
+	{ 0x33, "Size over/underflow (allocate mode)"},
+	{ 0x34, "Size over/underflow (reuse mode)"},
+	{ 0x35, "Length exceeds max. short length (allocate mode, S/G/ format)"},
+	{ 0x36, "Memory footprint exceeds max. value (allocate mode, S/G/ format)"},
+	{ 0x41, "SBC frame format not supported (allocate mode)"},
+	{ 0x42, "Pool 0 invalid / pool 1 size < pool 0 size (allocate mode)"},
+	{ 0x43, "Annotation output enabled but ASAR = 0 (allocate mode)"},
+	{ 0x44, "Unsupported or reserved frame format or SGHR = 1 (reuse mode)"},
+	{ 0x45, "DHR correction underflow (reuse mode, single buffer format)"},
+	{ 0x46, "Annotation length exceeds offset (reuse mode)"},
+	{ 0x48, "Annotation output enabled but ASA limited by ASAR (reuse mode)"},
+	{ 0x49, "Data offset correction exceeds input frame data length (reuse mode)"},
+	{ 0x4B, "Annotation output enabled but ASA cannote be expanded (frame list)"},
+	{ 0x51, "Unsupported IF reuse mode"},
+	{ 0x52, "Unsupported FL use mode"},
+	{ 0x53, "Unsupported RJD use mode"},
+	{ 0x54, "Unsupported inline descriptor use mode"},
+	{ 0xC0, "Table buffer pool 0 depletion"},
+	{ 0xC1, "Table buffer pool 1 depletion"},
+	{ 0xC2, "Data buffer pool 0 depletion, no OF allocated"},
+	{ 0xC3, "Data buffer pool 1 depletion, no OF allocated"},
+	{ 0xC4, "Data buffer pool 0 depletion, partial OF allocated"},
+	{ 0xC5, "Data buffer pool 1 depletion, partial OF allocated"},
+	{ 0xD0, "FLC read error"},
+	{ 0xD1, "FL read error"},
+	{ 0xD2, "FL write error"},
+	{ 0xD3, "OF SGT write error"},
+	{ 0xD4, "PTA read error"},
+	{ 0xD5, "PTA write error"},
+	{ 0xD6, "OF SGT F-bit write error"},
+	{ 0xD7, "ASA write error"},
+	{ 0xE1, "FLC[ICR]=0 ICID error"},
+	{ 0xE2, "FLC[ICR]=1 ICID error"},
+	{ 0xE4, "source of ICID flush not trusted (BDI = 0)"},
+};
+
 static const char * const cha_id_list[] = {
 	"",
 	"AES",
@@ -236,6 +284,27 @@ static void report_deco_status(struct device *jrdev, const u32 status,
 		status, error, idx_str, idx, err_str, err_err_code);
 }
 
+static void report_qi_status(struct device *qidev, const u32 status,
+			     const char *error)
+{
+	u8 err_id = status & JRSTA_QIERR_ERROR_MASK;
+	const char *err_str = "unidentified error value 0x";
+	char err_err_code[3] = { 0 };
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(qi_error_list); i++)
+		if (qi_error_list[i].value == err_id)
+			break;
+
+	if (i != ARRAY_SIZE(qi_error_list) && qi_error_list[i].error_text)
+		err_str = qi_error_list[i].error_text;
+	else
+		snprintf(err_err_code, sizeof(err_err_code), "%02x", err_id);
+
+	dev_err(qidev, "%08x: %s: %s%s\n",
+		status, error, err_str, err_err_code);
+}
+
 static void report_jr_status(struct device *jrdev, const u32 status,
 			     const char *error)
 {
@@ -250,7 +319,7 @@ static void report_cond_code_status(struct device *jrdev, const u32 status,
 		status, error, __func__);
 }
 
-void caam_jr_strstatus(struct device *jrdev, u32 status)
+void caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)
 {
 	static const struct stat_src {
 		void (*report_ssed)(struct device *jrdev, const u32 status,
@@ -262,7 +331,7 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 		{ report_ccb_status, "CCB" },
 		{ report_jump_status, "Jump" },
 		{ report_deco_status, "DECO" },
-		{ NULL, "Queue Manager Interface" },
+		{ report_qi_status, "Queue Manager Interface" },
 		{ report_jr_status, "Job Ring" },
 		{ report_cond_code_status, "Condition Code" },
 		{ NULL, NULL },
@@ -288,4 +357,4 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 	else
 		dev_err(jrdev, "%d: unknown error source\n", ssrc);
 }
-EXPORT_SYMBOL(caam_jr_strstatus);
+EXPORT_SYMBOL(caam_strstatus);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 3d639f3b45aa..8da88beb1abb 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * CAAM Error Reporting
  *

commit 972b812bd1e17cb0a9112f565951795f886fcc94
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Mon Jul 10 08:40:28 2017 +0300

    crypto: caam/qi - fix compilation with DEBUG enabled
    
    caam/qi driver does not compile when DEBUG is enabled
    (CRYPTO_DEV_FSL_CAAM_DEBUG=y):
    
    drivers/crypto/caam/caamalg_qi.c: In function 'ablkcipher_done':
    drivers/crypto/caam/caamalg_qi.c:794:2: error: implicit declaration of function 'dbg_dump_sg' [-Werror=implicit-function-declaration]
      dbg_dump_sg(KERN_ERR, "dst    @" __stringify(__LINE__)": ",
    
    Since dbg_dump_sg() is shared between caam/jr and caam/qi, move it
    in a shared location and export it.
    
    At the same time:
    -reduce ifdeferry by providing a no-op implementation for !DEBUG case
    -rename it to caam_dump_sg() to be consistent in terms of
    exported symbols namespace (caam_*)
    
    Cc: <stable@vger.kernel.org>
    Fixes: b189817cf789 ("crypto: caam/qi - add ablkcipher and authenc algorithms")
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 6f44ccb55c63..3d639f3b45aa 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -9,6 +9,46 @@
 #include "desc.h"
 #include "error.h"
 
+#ifdef DEBUG
+#include <linux/highmem.h>
+
+void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
+		  int rowsize, int groupsize, struct scatterlist *sg,
+		  size_t tlen, bool ascii)
+{
+	struct scatterlist *it;
+	void *it_page;
+	size_t len;
+	void *buf;
+
+	for (it = sg; it && tlen > 0 ; it = sg_next(sg)) {
+		/*
+		 * make sure the scatterlist's page
+		 * has a valid virtual memory mapping
+		 */
+		it_page = kmap_atomic(sg_page(it));
+		if (unlikely(!it_page)) {
+			pr_err("caam_dump_sg: kmap failed\n");
+			return;
+		}
+
+		buf = it_page + it->offset;
+		len = min_t(size_t, tlen, it->length);
+		print_hex_dump(level, prefix_str, prefix_type, rowsize,
+			       groupsize, buf, len, ascii);
+		tlen -= len;
+
+		kunmap_atomic(it_page);
+	}
+}
+#else
+void caam_dump_sg(const char *level, const char *prefix_str, int prefix_type,
+		  int rowsize, int groupsize, struct scatterlist *sg,
+		  size_t tlen, bool ascii)
+{}
+#endif /* DEBUG */
+EXPORT_SYMBOL(caam_dump_sg);
+
 static const struct {
 	u8 value;
 	const char *error_text;

commit 78fd0fff7fbb55b352bd7058bf51caa46dd3a0f1
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Fri Feb 10 14:07:14 2017 +0200

    crypto: caam - don't include unneeded headers
    
    intern.h, jr.h are not needed in error.c
    error.h is not needed in ctrl.c
    
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 79a0cc70717f..6f44ccb55c63 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -6,9 +6,7 @@
 
 #include "compat.h"
 #include "regs.h"
-#include "intern.h"
 #include "desc.h"
-#include "jr.h"
 #include "error.h"
 
 static const struct {

commit 9305dff7ab8b5e1aef2c4c5c733ce7e1dc345433
Author: Horia Geantă <horia.geanta@nxp.com>
Date:   Wed Nov 9 10:46:19 2016 +0200

    crypto: caam - remove unreachable code in report_ccb_status()
    
    ERRID is a 4-bit field.
    Since err_id values are in [0..15] and err_id_list array size is 16,
    the condition "err_id < ARRAY_SIZE(err_id_list)" is always true.
    
    Signed-off-by: Horia Geantă <horia.geanta@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 33e41ea83fcc..79a0cc70717f 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -146,10 +146,9 @@ static void report_ccb_status(struct device *jrdev, const u32 status,
 	    strlen(rng_err_id_list[err_id])) {
 		/* RNG-only error */
 		err_str = rng_err_id_list[err_id];
-	} else if (err_id < ARRAY_SIZE(err_id_list))
+	} else {
 		err_str = err_id_list[err_id];
-	else
-		snprintf(err_err_code, sizeof(err_err_code), "%02x", err_id);
+	}
 
 	/*
 	 * CCB ICV check failures are part of normal operation life;

commit 3f80be023900790d029a63e27440f1e33c048b73
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Tue Jan 20 12:43:10 2015 -0600

    crypto: caam - don't emit ICV check failures to dmesg
    
    ICV check failures are part of normal operation;
    leave user notification up to the higher levels,
    as is done in s/w algorithm implementations.
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Tested-by: Cristian Stoica <cristian.stoica@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 66d73bf54166..33e41ea83fcc 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -151,10 +151,15 @@ static void report_ccb_status(struct device *jrdev, const u32 status,
 	else
 		snprintf(err_err_code, sizeof(err_err_code), "%02x", err_id);
 
-	dev_err(jrdev, "%08x: %s: %s %d: %s%s: %s%s\n",
-		status, error, idx_str, idx,
-		cha_str, cha_err_code,
-		err_str, err_err_code);
+	/*
+	 * CCB ICV check failures are part of normal operation life;
+	 * we leave the upper layers to do what they want with them.
+	 */
+	if (err_id != JRSTA_CCBERR_ERRID_ICVCHK)
+		dev_err(jrdev, "%08x: %s: %s %d: %s%s: %s%s\n",
+			status, error, idx_str, idx,
+			cha_str, cha_err_code,
+			err_str, err_err_code);
 }
 
 static void report_jump_status(struct device *jrdev, const u32 status,

commit 49783d0f54219e1c68eac738fdd3244b7a6cbda7
Author: Cristian Stoica <cristian.stoica@freescale.com>
Date:   Wed Nov 5 11:21:24 2014 +0200

    crypto: caam - fix error reporting
    
    The error code returned by hardware is four bits wide with an expected
    zero MSB. A hardware error condition where the error code can get between
    0x8 and 0xf will trigger an out of bound array access on the error
    message table.
    This patch fixes the invalid array access following such an error and
    reports the condition.
    
    Signed-off-by: Cristian Stoica <cristian.stoica@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 6531054a44c8..66d73bf54166 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -213,27 +213,36 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 		void (*report_ssed)(struct device *jrdev, const u32 status,
 				    const char *error);
 		const char *error;
-	} status_src[] = {
+	} status_src[16] = {
 		{ NULL, "No error" },
 		{ NULL, NULL },
 		{ report_ccb_status, "CCB" },
 		{ report_jump_status, "Jump" },
 		{ report_deco_status, "DECO" },
-		{ NULL, NULL },
+		{ NULL, "Queue Manager Interface" },
 		{ report_jr_status, "Job Ring" },
 		{ report_cond_code_status, "Condition Code" },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
+		{ NULL, NULL },
 	};
 	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
 	const char *error = status_src[ssrc].error;
 
 	/*
-	 * If there is no further error handling function, just
-	 * print the error code, error string and exit. Otherwise
-	 * call the handler function.
+	 * If there is an error handling function, call it to report the error.
+	 * Otherwise print the error source name.
 	 */
-	if (!status_src[ssrc].report_ssed)
-		dev_err(jrdev, "%08x: %s: \n", status, status_src[ssrc].error);
-	else
+	if (status_src[ssrc].report_ssed)
 		status_src[ssrc].report_ssed(jrdev, status, error);
+	else if (error)
+		dev_err(jrdev, "%d: %s\n", ssrc, error);
+	else
+		dev_err(jrdev, "%d: unknown error source\n", ssrc);
 }
 EXPORT_SYMBOL(caam_jr_strstatus);

commit da37503d37bb6ae72cca0b4d729c153f04b9f0cc
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:22 2014 +0200

    crypto: caam - Fix the 'quoted string split across lines'
    
    Fix the checkpatch warnings that the strings were split across
    multiple lines. Checkpatch now complains about lines over 80,
    but this is better, since we can actually grep the source code
    for these strings now.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 0f4725cc8039..6531054a44c8 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -16,13 +16,10 @@ static const struct {
 	const char *error_text;
 } desc_error_list[] = {
 	{ 0x00, "No error." },
-	{ 0x01, "SGT Length Error. The descriptor is trying to read "
-		"more data than is contained in the SGT table." },
+	{ 0x01, "SGT Length Error. The descriptor is trying to read more data than is contained in the SGT table." },
 	{ 0x02, "SGT Null Entry Error." },
-	{ 0x03, "Job Ring Control Error. There is a bad value in the "
-		"Job Ring Control register." },
-	{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
-		"field is invalid." },
+	{ 0x03, "Job Ring Control Error. There is a bad value in the Job Ring Control register." },
+	{ 0x04, "Invalid Descriptor Command. The Descriptor Command field is invalid." },
 	{ 0x05, "Reserved." },
 	{ 0x06, "Invalid KEY Command" },
 	{ 0x07, "Invalid LOAD Command" },
@@ -31,55 +28,26 @@ static const struct {
 	{ 0x0A, "Invalid FIFO LOAD Command" },
 	{ 0x0B, "Invalid FIFO STORE Command" },
 	{ 0x0C, "Invalid MOVE/MOVE_LEN Command" },
-	{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
-		"invalid because the target is not a Job Header "
-		"Command, or the jump is from a Trusted Descriptor to "
-		"a Job Descriptor, or because the target Descriptor "
-		"contains a Shared Descriptor." },
+	{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is invalid because the target is not a Job Header Command, or the jump is from a Trusted Descriptor to a Job Descriptor, or because the target Descriptor contains a Shared Descriptor." },
 	{ 0x0E, "Invalid MATH Command" },
 	{ 0x0F, "Invalid SIGNATURE Command" },
-	{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
-		"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
-		"LOAD, or SEQ FIFO STORE decremented the input or "
-		"output sequence length below 0. This error may result "
-		"if a built-in PROTOCOL Command has encountered a "
-		"malformed PDU." },
+	{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO LOAD, or SEQ FIFO STORE decremented the input or output sequence length below 0. This error may result if a built-in PROTOCOL Command has encountered a malformed PDU." },
 	{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
 	{ 0x12, "Shared Descriptor Header Error" },
-	{ 0x13, "Header Error. Invalid length or parity, or certain "
-		"other problems." },
-	{ 0x14, "Burster Error. Burster has gotten to an illegal "
-		"state" },
-	{ 0x15, "Context Register Length Error. The descriptor is "
-		"trying to read or write past the end of the Context "
-		"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
-		"set was executed with too large a length in the "
-		"variable length register (VSOL for SEQ STORE or VSIL "
-		"for SEQ LOAD)." },
+	{ 0x13, "Header Error. Invalid length or parity, or certain other problems." },
+	{ 0x14, "Burster Error. Burster has gotten to an illegal state" },
+	{ 0x15, "Context Register Length Error. The descriptor is trying to read or write past the end of the Context Register. A SEQ LOAD or SEQ STORE with the VLF bit set was executed with too large a length in the variable length register (VSOL for SEQ STORE or VSIL for SEQ LOAD)." },
 	{ 0x16, "DMA Error" },
 	{ 0x17, "Reserved." },
 	{ 0x1A, "Job failed due to JR reset" },
 	{ 0x1B, "Job failed due to Fail Mode" },
 	{ 0x1C, "DECO Watchdog timer timeout error" },
-	{ 0x1D, "DECO tried to copy a key from another DECO but the "
-		"other DECO's Key Registers were locked" },
-	{ 0x1E, "DECO attempted to copy data from a DECO that had an "
-		"unmasked Descriptor error" },
-	{ 0x1F, "LIODN error. DECO was trying to share from itself or "
-		"from another DECO but the two Non-SEQ LIODN values "
-		"didn't match or the 'shared from' DECO's Descriptor "
-		"required that the SEQ LIODNs be the same and they "
-		"aren't." },
-	{ 0x20, "DECO has completed a reset initiated via the DRR "
-		"register" },
-	{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
-		"option in the FIFO STORE Command, the Nonce counter "
-		"reached its maximum value and this encryption mode "
-		"can no longer be used." },
-	{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
-		"(input frame; block ciphers) and IPsec decap (output "
-		"frame, when doing the next header byte update) and "
-		"DCRC (output frame)." },
+	{ 0x1D, "DECO tried to copy a key from another DECO but the other DECO's Key Registers were locked" },
+	{ 0x1E, "DECO attempted to copy data from a DECO that had an unmasked Descriptor error" },
+	{ 0x1F, "LIODN error. DECO was trying to share from itself or from another DECO but the two Non-SEQ LIODN values didn't match or the 'shared from' DECO's Descriptor required that the SEQ LIODNs be the same and they aren't." },
+	{ 0x20, "DECO has completed a reset initiated via the DRR register" },
+	{ 0x21, "Nonce error. When using EKT (CCM) key encryption option in the FIFO STORE Command, the Nonce counter reached its maximum value and this encryption mode can no longer be used." },
+	{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap (input frame; block ciphers) and IPsec decap (output frame, when doing the next header byte update) and DCRC (output frame)." },
 	{ 0x23, "Read Input Frame error" },
 	{ 0x24, "JDKEK, TDKEK or TDSK not loaded error" },
 	{ 0x80, "DNR (do not run) error" },
@@ -90,23 +58,14 @@ static const struct {
 	{ 0x85, "Sequence number overflow" },
 	{ 0x86, "Sigver invalid signature" },
 	{ 0x87, "DSA Sign Illegal test descriptor" },
-	{ 0x88, "Protocol Format Error - A protocol has seen an error "
-		"in the format of data received. When running RSA, "
-		"this means that formatting with random padding was "
-		"used, and did not follow the form: 0x00, 0x02, 8-to-N "
-		"bytes of non-zero pad, 0x00, F data." },
-	{ 0x89, "Protocol Size Error - A protocol has seen an error in "
-		"size. When running RSA, pdb size N < (size of F) when "
-		"no formatting is used; or pdb size N < (F + 11) when "
-		"formatting is used." },
+	{ 0x88, "Protocol Format Error - A protocol has seen an error in the format of data received. When running RSA, this means that formatting with random padding was used, and did not follow the form: 0x00, 0x02, 8-to-N bytes of non-zero pad, 0x00, F data." },
+	{ 0x89, "Protocol Size Error - A protocol has seen an error in size. When running RSA, pdb size N < (size of F) when no formatting is used; or pdb size N < (F + 11) when formatting is used." },
 	{ 0xC1, "Blob Command error: Undefined mode" },
 	{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
-	{ 0xC4, "Blob Command error: Black Blob key or input size "
-		"error" },
+	{ 0xC4, "Blob Command error: Black Blob key or input size error" },
 	{ 0xC5, "Blob Command error: Invalid key destination" },
 	{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
-	{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
-		"or was decremented to 0" },
+	{ 0xF0, "IPsec TTL or hop limit field either came in as 0, or was decremented to 0" },
 	{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
 };
 

commit e397ee0f2242a5f316906e1ff05f8669791b4e2c
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:21 2014 +0200

    crypto: caam - Sweep the remnants
    
    Clean up the remnants from the rework. Constify function arguments.
    
    Note that checkpatch again complains about this space before newline,
    but this is the original code behavior, so I'm keeping it.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 7ed2e4fb3c15..0f4725cc8039 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -13,7 +13,7 @@
 
 static const struct {
 	u8 value;
-	char *error_text;
+	const char *error_text;
 } desc_error_list[] = {
 	{ 0x00, "No error." },
 	{ 0x01, "SGT Length Error. The descriptor is trying to read "
@@ -158,8 +158,8 @@ static const char * const rng_err_id_list[] = {
 	"Secure key generation",
 };
 
-static void report_ccb_status(struct device *jrdev, u32 status,
-			      const char *error, char *__outstr)
+static void report_ccb_status(struct device *jrdev, const u32 status,
+			      const char *error)
 {
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
@@ -198,21 +198,21 @@ static void report_ccb_status(struct device *jrdev, u32 status,
 		err_str, err_err_code);
 }
 
-static void report_jump_status(struct device *jrdev, u32 status,
-			       const char *error, char *outstr)
+static void report_jump_status(struct device *jrdev, const u32 status,
+			       const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
 }
 
-static void report_deco_status(struct device *jrdev, u32 status,
-			       const char *error, char *__outstr)
+static void report_deco_status(struct device *jrdev, const u32 status,
+			       const char *error)
 {
 	u8 err_id = status & JRSTA_DECOERR_ERROR_MASK;
 	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
 		  JRSTA_DECOERR_INDEX_SHIFT;
 	char *idx_str;
-	char *err_str = "unidentified error value 0x";
+	const char *err_str = "unidentified error value 0x";
 	char err_err_code[3] = { 0 };
 	int i;
 
@@ -234,15 +234,15 @@ static void report_deco_status(struct device *jrdev, u32 status,
 		status, error, idx_str, idx, err_str, err_err_code);
 }
 
-static void report_jr_status(struct device *jrdev, u32 status,
-			     const char *error, char *outstr)
+static void report_jr_status(struct device *jrdev, const u32 status,
+			     const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
 }
 
-static void report_cond_code_status(struct device *jrdev, u32 status,
-				    const char *error, char *outstr)
+static void report_cond_code_status(struct device *jrdev, const u32 status,
+				    const char *error)
 {
 	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
 		status, error, __func__);
@@ -251,8 +251,8 @@ static void report_cond_code_status(struct device *jrdev, u32 status,
 void caam_jr_strstatus(struct device *jrdev, u32 status)
 {
 	static const struct stat_src {
-		void (*report_ssed)(struct device *jrdev, u32 status,
-				    const char *error, char *outstr);
+		void (*report_ssed)(struct device *jrdev, const u32 status,
+				    const char *error);
 		const char *error;
 	} status_src[] = {
 		{ NULL, "No error" },
@@ -265,17 +265,16 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 		{ report_cond_code_status, "Condition Code" },
 	};
 	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
+	const char *error = status_src[ssrc].error;
 
 	/*
 	 * If there is no further error handling function, just
-	 * print the error code, error string and exit.
+	 * print the error code, error string and exit. Otherwise
+	 * call the handler function.
 	 */
-	if (!status_src[ssrc].report_ssed) {
+	if (!status_src[ssrc].report_ssed)
 		dev_err(jrdev, "%08x: %s: \n", status, status_src[ssrc].error);
-		return;
-	}
-
-	status_src[ssrc].report_ssed(jrdev, status,
-			status_src[ssrc].error, NULL);
+	else
+		status_src[ssrc].report_ssed(jrdev, status, error);
 }
 EXPORT_SYMBOL(caam_jr_strstatus);

commit e22cdcfa13d9799ea46245946ae09b4a328ff27d
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:20 2014 +0200

    crypto: caam - Kill SPRINTFCAT() with fire
    
    This macro is just like an encyclopedia of string handling done wrong.
    This must die. This is so wrong on so many levels.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 66a7461cf9ae..7ed2e4fb3c15 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -158,16 +158,6 @@ static const char * const rng_err_id_list[] = {
 	"Secure key generation",
 };
 
-#define SPRINTFCAT(str, format, param, max_alloc)		\
-{								\
-	char *tmp;						\
-								\
-	tmp = kmalloc(sizeof(format) + max_alloc, GFP_ATOMIC);	\
-	sprintf(tmp, format, param);				\
-	strcat(str, tmp);					\
-	kfree(tmp);						\
-}
-
 static void report_ccb_status(struct device *jrdev, u32 status,
 			      const char *error, char *__outstr)
 {

commit 4f0fa52a5d89d763423cb9b428e988ea824fd95a
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:19 2014 +0200

    crypto: caam - Clean up report_deco_status()
    
    Clean this function up and rework it into sensible shape. This function
    now contains one single dev_err() instead of the previous insanity full
    of memory allocation, chaotic string handling and use of SPRINTFCAT().
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 91cc5fc7670f..66a7461cf9ae 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -218,35 +218,30 @@ static void report_jump_status(struct device *jrdev, u32 status,
 static void report_deco_status(struct device *jrdev, u32 status,
 			       const char *error, char *__outstr)
 {
-	char outstr[CAAM_ERROR_STR_MAX];
-
-	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
+	u8 err_id = status & JRSTA_DECOERR_ERROR_MASK;
 	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
 		  JRSTA_DECOERR_INDEX_SHIFT;
-
+	char *idx_str;
+	char *err_str = "unidentified error value 0x";
+	char err_err_code[3] = { 0 };
 	int i;
-	sprintf(outstr, "%s: ", error);
 
 	if (status & JRSTA_DECOERR_JUMP)
-		strcat(outstr, "jump tgt desc idx ");
+		idx_str = "jump tgt desc idx";
 	else
-		strcat(outstr, "desc idx ");
-
-	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+		idx_str = "desc idx";
 
 	for (i = 0; i < ARRAY_SIZE(desc_error_list); i++)
-		if (desc_error_list[i].value == desc_error)
+		if (desc_error_list[i].value == err_id)
 			break;
 
-	if (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text) {
-		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
-			   strlen(desc_error_list[i].error_text));
-	} else {
-		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
-			   desc_error, sizeof("ff"));
-	}
+	if (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text)
+		err_str = desc_error_list[i].error_text;
+	else
+		snprintf(err_err_code, sizeof(err_err_code), "%02x", err_id);
 
-	dev_err(jrdev, "%08x: %s\n", status, outstr);
+	dev_err(jrdev, "%08x: %s: %s %d: %s%s\n",
+		status, error, idx_str, idx, err_str, err_err_code);
 }
 
 static void report_jr_status(struct device *jrdev, u32 status,

commit 1e16322da45b747c753162e421b7a1b25259377a
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:18 2014 +0200

    crypto: caam - Clean up report_ccb_status()
    
    Clean this function up and rework it into sensible shape. This function
    now contains one single dev_err() instead of the previous insanity full
    of memory allocation, possible stack overwriting, chaotic string handling
    and use of SPRINTFCAT().
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index aa7d5cf2a294..91cc5fc7670f 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -171,46 +171,41 @@ static const char * const rng_err_id_list[] = {
 static void report_ccb_status(struct device *jrdev, u32 status,
 			      const char *error, char *__outstr)
 {
-	char outstr[CAAM_ERROR_STR_MAX];
-
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
 	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
 		  JRSTA_DECOERR_INDEX_SHIFT;
-
-	sprintf(outstr, "%s: ", error);
+	char *idx_str;
+	const char *cha_str = "unidentified cha_id value 0x";
+	char cha_err_code[3] = { 0 };
+	const char *err_str = "unidentified err_id value 0x";
+	char err_err_code[3] = { 0 };
 
 	if (status & JRSTA_DECOERR_JUMP)
-		strcat(outstr, "jump tgt desc idx ");
+		idx_str = "jump tgt desc idx";
 	else
-		strcat(outstr, "desc idx ");
-
-	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+		idx_str = "desc idx";
 
-	if (cha_id < ARRAY_SIZE(cha_id_list)) {
-		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
-			   strlen(cha_id_list[cha_id]));
-	} else {
-		SPRINTFCAT(outstr, "unidentified cha_id value 0x%02x: ",
-			   cha_id, sizeof("ff"));
-	}
+	if (cha_id < ARRAY_SIZE(cha_id_list))
+		cha_str = cha_id_list[cha_id];
+	else
+		snprintf(cha_err_code, sizeof(cha_err_code), "%02x", cha_id);
 
 	if ((cha_id << JRSTA_CCBERR_CHAID_SHIFT) == JRSTA_CCBERR_CHAID_RNG &&
 	    err_id < ARRAY_SIZE(rng_err_id_list) &&
 	    strlen(rng_err_id_list[err_id])) {
 		/* RNG-only error */
-		SPRINTFCAT(outstr, "%s", rng_err_id_list[err_id],
-			   strlen(rng_err_id_list[err_id]));
-	} else if (err_id < ARRAY_SIZE(err_id_list)) {
-		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
-			   strlen(err_id_list[err_id]));
-	} else {
-		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
-			   err_id, sizeof("ff"));
-	}
+		err_str = rng_err_id_list[err_id];
+	} else if (err_id < ARRAY_SIZE(err_id_list))
+		err_str = err_id_list[err_id];
+	else
+		snprintf(err_err_code, sizeof(err_err_code), "%02x", err_id);
 
-	dev_err(jrdev, "%08x: %s\n", status, outstr);
+	dev_err(jrdev, "%08x: %s: %s %d: %s%s: %s%s\n",
+		status, error, idx_str, idx,
+		cha_str, cha_err_code,
+		err_str, err_err_code);
 }
 
 static void report_jump_status(struct device *jrdev, u32 status,

commit 526243cc872398ed8139a52ee0bf7715a3abcf31
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:17 2014 +0200

    crypto: caam - Dissolve report_jump_idx()
    
    Just dissolve this function so it's not in the way of applying
    further white magic cleanup down the line.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index a8736abd717d..aa7d5cf2a294 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -168,19 +168,6 @@ static const char * const rng_err_id_list[] = {
 	kfree(tmp);						\
 }
 
-static void report_jump_idx(u32 status, char *outstr)
-{
-	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
-		  JRSTA_DECOERR_INDEX_SHIFT;
-
-	if (status & JRSTA_DECOERR_JUMP)
-		strcat(outstr, "jump tgt desc idx ");
-	else
-		strcat(outstr, "desc idx ");
-
-	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
-}
-
 static void report_ccb_status(struct device *jrdev, u32 status,
 			      const char *error, char *__outstr)
 {
@@ -189,10 +176,17 @@ static void report_ccb_status(struct device *jrdev, u32 status,
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
+	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
+		  JRSTA_DECOERR_INDEX_SHIFT;
 
 	sprintf(outstr, "%s: ", error);
 
-	report_jump_idx(status, outstr);
+	if (status & JRSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
 
 	if (cha_id < ARRAY_SIZE(cha_id_list)) {
 		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
@@ -232,10 +226,18 @@ static void report_deco_status(struct device *jrdev, u32 status,
 	char outstr[CAAM_ERROR_STR_MAX];
 
 	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
+	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
+		  JRSTA_DECOERR_INDEX_SHIFT;
+
 	int i;
 	sprintf(outstr, "%s: ", error);
 
-	report_jump_idx(status, outstr);
+	if (status & JRSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
 
 	for (i = 0; i < ARRAY_SIZE(desc_error_list); i++)
 		if (desc_error_list[i].value == desc_error)

commit e75880dd9afb60ff59efe079ac50ccc16daffe54
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:16 2014 +0200

    crypto: caam - Kill the easy targets
    
    Fix the functions which can be obviously done right with a simple
    dev_err() now. While at it, further press the on-stack allocation
    of buffer for sprintf() voodoo down into the abominated functions.
    
    This patch cleans up most of the functions and leaves just two
    remaining functions, report_ccb_status() and report_deco_status()
    ugly and unhappy.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 7ce1d0349d68..a8736abd717d 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -182,8 +182,10 @@ static void report_jump_idx(u32 status, char *outstr)
 }
 
 static void report_ccb_status(struct device *jrdev, u32 status,
-			      const char *error, char *outstr)
+			      const char *error, char *__outstr)
 {
+	char outstr[CAAM_ERROR_STR_MAX];
+
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
@@ -213,18 +215,22 @@ static void report_ccb_status(struct device *jrdev, u32 status,
 		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
 			   err_id, sizeof("ff"));
 	}
+
+	dev_err(jrdev, "%08x: %s\n", status, outstr);
 }
 
 static void report_jump_status(struct device *jrdev, u32 status,
 			       const char *error, char *outstr)
 {
-	sprintf(outstr, "%s: ", error);
-	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
+		status, error, __func__);
 }
 
 static void report_deco_status(struct device *jrdev, u32 status,
-			       const char *error, char *outstr)
+			       const char *error, char *__outstr)
 {
+	char outstr[CAAM_ERROR_STR_MAX];
+
 	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
 	int i;
 	sprintf(outstr, "%s: ", error);
@@ -242,25 +248,26 @@ static void report_deco_status(struct device *jrdev, u32 status,
 		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
 			   desc_error, sizeof("ff"));
 	}
+
+	dev_err(jrdev, "%08x: %s\n", status, outstr);
 }
 
 static void report_jr_status(struct device *jrdev, u32 status,
 			     const char *error, char *outstr)
 {
-	sprintf(outstr, "%s: ", error);
-	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
+		status, error, __func__);
 }
 
 static void report_cond_code_status(struct device *jrdev, u32 status,
 				    const char *error, char *outstr)
 {
-	sprintf(outstr, "%s: ", error);
-	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+	dev_err(jrdev, "%08x: %s: %s() not implemented\n",
+		status, error, __func__);
 }
 
 void caam_jr_strstatus(struct device *jrdev, u32 status)
 {
-	char outstr[CAAM_ERROR_STR_MAX];
 	static const struct stat_src {
 		void (*report_ssed)(struct device *jrdev, u32 status,
 				    const char *error, char *outstr);
@@ -287,8 +294,6 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 	}
 
 	status_src[ssrc].report_ssed(jrdev, status,
-			status_src[ssrc].error, outstr);
-
-	dev_err(jrdev, "%08x: %s\n", status, outstr);
+			status_src[ssrc].error, NULL);
 }
 EXPORT_SYMBOL(caam_jr_strstatus);

commit 8a4758268292eb036a63f49746fbfe3fcdc0c51d
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:15 2014 +0200

    crypto: caam - Pass error type into the functions
    
    Pass the error type string into the functions, so they can handle
    the printing of the string. This is now still using the very unsafe
    sprintf(), but we will fix that.
    
    While at this, pass the device pointer too, so we can dev_err()
    functions readily when we start fixing this proper.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 961331d1b6ab..7ce1d0349d68 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -181,12 +181,15 @@ static void report_jump_idx(u32 status, char *outstr)
 	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
 }
 
-static void report_ccb_status(u32 status, char *outstr)
+static void report_ccb_status(struct device *jrdev, u32 status,
+			      const char *error, char *outstr)
 {
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
 
+	sprintf(outstr, "%s: ", error);
+
 	report_jump_idx(status, outstr);
 
 	if (cha_id < ARRAY_SIZE(cha_id_list)) {
@@ -212,15 +215,19 @@ static void report_ccb_status(u32 status, char *outstr)
 	}
 }
 
-static void report_jump_status(u32 status, char *outstr)
+static void report_jump_status(struct device *jrdev, u32 status,
+			       const char *error, char *outstr)
 {
+	sprintf(outstr, "%s: ", error);
 	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
 }
 
-static void report_deco_status(u32 status, char *outstr)
+static void report_deco_status(struct device *jrdev, u32 status,
+			       const char *error, char *outstr)
 {
 	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
 	int i;
+	sprintf(outstr, "%s: ", error);
 
 	report_jump_idx(status, outstr);
 
@@ -237,13 +244,17 @@ static void report_deco_status(u32 status, char *outstr)
 	}
 }
 
-static void report_jr_status(u32 status, char *outstr)
+static void report_jr_status(struct device *jrdev, u32 status,
+			     const char *error, char *outstr)
 {
+	sprintf(outstr, "%s: ", error);
 	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
 }
 
-static void report_cond_code_status(u32 status, char *outstr)
+static void report_cond_code_status(struct device *jrdev, u32 status,
+				    const char *error, char *outstr)
 {
+	sprintf(outstr, "%s: ", error);
 	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
 }
 
@@ -251,8 +262,9 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 {
 	char outstr[CAAM_ERROR_STR_MAX];
 	static const struct stat_src {
-		void (*report_ssed)(u32 status, char *outstr);
-		char *error;
+		void (*report_ssed)(struct device *jrdev, u32 status,
+				    const char *error, char *outstr);
+		const char *error;
 	} status_src[] = {
 		{ NULL, "No error" },
 		{ NULL, NULL },
@@ -274,9 +286,8 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 		return;
 	}
 
-	sprintf(outstr, "%s: ", status_src[ssrc].error);
-
-	status_src[ssrc].report_ssed(status, outstr);
+	status_src[ssrc].report_ssed(jrdev, status,
+			status_src[ssrc].error, outstr);
 
 	dev_err(jrdev, "%08x: %s\n", status, outstr);
 }

commit 867e1ee395d845f49ae280c3d8f5271b214fa7e4
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:14 2014 +0200

    crypto: caam - Implement fast-path for error codes with no handler
    
    Implement fast-path error code printout for errors with no associated
    handler function. This reduces calls to this kmalloc() nonsense in
    SPRINTFCAT() already.
    
    Note that the format of output is compatible with the old code, even
    if -- exposed like this -- it looks a bit weird. Checkpatch complains
    on this one as well.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 3d7be4c05008..961331d1b6ab 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -265,10 +265,18 @@ void caam_jr_strstatus(struct device *jrdev, u32 status)
 	};
 	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
 
+	/*
+	 * If there is no further error handling function, just
+	 * print the error code, error string and exit.
+	 */
+	if (!status_src[ssrc].report_ssed) {
+		dev_err(jrdev, "%08x: %s: \n", status, status_src[ssrc].error);
+		return;
+	}
+
 	sprintf(outstr, "%s: ", status_src[ssrc].error);
 
-	if (status_src[ssrc].report_ssed)
-		status_src[ssrc].report_ssed(status, outstr);
+	status_src[ssrc].report_ssed(status, outstr);
 
 	dev_err(jrdev, "%08x: %s\n", status, outstr);
 }

commit 9724d7adbb34b067b844b97599c1a5905229aa2b
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:13 2014 +0200

    crypto: caam - Pull all the error codes out
    
    Pull the error code <-> error string mapping tables out of the function
    so the code becomes readable. This lets me see the real flesh of the
    functions, without all that flab clouding the view.
    
    Note: There is a checkpatch issue with quoted strings across multiple
          lines. I will fix that in a subsequent patch to keep the changes
          small and separate.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index ba426d902783..3d7be4c05008 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -11,6 +11,153 @@
 #include "jr.h"
 #include "error.h"
 
+static const struct {
+	u8 value;
+	char *error_text;
+} desc_error_list[] = {
+	{ 0x00, "No error." },
+	{ 0x01, "SGT Length Error. The descriptor is trying to read "
+		"more data than is contained in the SGT table." },
+	{ 0x02, "SGT Null Entry Error." },
+	{ 0x03, "Job Ring Control Error. There is a bad value in the "
+		"Job Ring Control register." },
+	{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
+		"field is invalid." },
+	{ 0x05, "Reserved." },
+	{ 0x06, "Invalid KEY Command" },
+	{ 0x07, "Invalid LOAD Command" },
+	{ 0x08, "Invalid STORE Command" },
+	{ 0x09, "Invalid OPERATION Command" },
+	{ 0x0A, "Invalid FIFO LOAD Command" },
+	{ 0x0B, "Invalid FIFO STORE Command" },
+	{ 0x0C, "Invalid MOVE/MOVE_LEN Command" },
+	{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
+		"invalid because the target is not a Job Header "
+		"Command, or the jump is from a Trusted Descriptor to "
+		"a Job Descriptor, or because the target Descriptor "
+		"contains a Shared Descriptor." },
+	{ 0x0E, "Invalid MATH Command" },
+	{ 0x0F, "Invalid SIGNATURE Command" },
+	{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
+		"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
+		"LOAD, or SEQ FIFO STORE decremented the input or "
+		"output sequence length below 0. This error may result "
+		"if a built-in PROTOCOL Command has encountered a "
+		"malformed PDU." },
+	{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
+	{ 0x12, "Shared Descriptor Header Error" },
+	{ 0x13, "Header Error. Invalid length or parity, or certain "
+		"other problems." },
+	{ 0x14, "Burster Error. Burster has gotten to an illegal "
+		"state" },
+	{ 0x15, "Context Register Length Error. The descriptor is "
+		"trying to read or write past the end of the Context "
+		"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
+		"set was executed with too large a length in the "
+		"variable length register (VSOL for SEQ STORE or VSIL "
+		"for SEQ LOAD)." },
+	{ 0x16, "DMA Error" },
+	{ 0x17, "Reserved." },
+	{ 0x1A, "Job failed due to JR reset" },
+	{ 0x1B, "Job failed due to Fail Mode" },
+	{ 0x1C, "DECO Watchdog timer timeout error" },
+	{ 0x1D, "DECO tried to copy a key from another DECO but the "
+		"other DECO's Key Registers were locked" },
+	{ 0x1E, "DECO attempted to copy data from a DECO that had an "
+		"unmasked Descriptor error" },
+	{ 0x1F, "LIODN error. DECO was trying to share from itself or "
+		"from another DECO but the two Non-SEQ LIODN values "
+		"didn't match or the 'shared from' DECO's Descriptor "
+		"required that the SEQ LIODNs be the same and they "
+		"aren't." },
+	{ 0x20, "DECO has completed a reset initiated via the DRR "
+		"register" },
+	{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
+		"option in the FIFO STORE Command, the Nonce counter "
+		"reached its maximum value and this encryption mode "
+		"can no longer be used." },
+	{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
+		"(input frame; block ciphers) and IPsec decap (output "
+		"frame, when doing the next header byte update) and "
+		"DCRC (output frame)." },
+	{ 0x23, "Read Input Frame error" },
+	{ 0x24, "JDKEK, TDKEK or TDSK not loaded error" },
+	{ 0x80, "DNR (do not run) error" },
+	{ 0x81, "undefined protocol command" },
+	{ 0x82, "invalid setting in PDB" },
+	{ 0x83, "Anti-replay LATE error" },
+	{ 0x84, "Anti-replay REPLAY error" },
+	{ 0x85, "Sequence number overflow" },
+	{ 0x86, "Sigver invalid signature" },
+	{ 0x87, "DSA Sign Illegal test descriptor" },
+	{ 0x88, "Protocol Format Error - A protocol has seen an error "
+		"in the format of data received. When running RSA, "
+		"this means that formatting with random padding was "
+		"used, and did not follow the form: 0x00, 0x02, 8-to-N "
+		"bytes of non-zero pad, 0x00, F data." },
+	{ 0x89, "Protocol Size Error - A protocol has seen an error in "
+		"size. When running RSA, pdb size N < (size of F) when "
+		"no formatting is used; or pdb size N < (F + 11) when "
+		"formatting is used." },
+	{ 0xC1, "Blob Command error: Undefined mode" },
+	{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
+	{ 0xC4, "Blob Command error: Black Blob key or input size "
+		"error" },
+	{ 0xC5, "Blob Command error: Invalid key destination" },
+	{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
+	{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
+		"or was decremented to 0" },
+	{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
+};
+
+static const char * const cha_id_list[] = {
+	"",
+	"AES",
+	"DES",
+	"ARC4",
+	"MDHA",
+	"RNG",
+	"SNOW f8",
+	"Kasumi f8/9",
+	"PKHA",
+	"CRCA",
+	"SNOW f9",
+	"ZUCE",
+	"ZUCA",
+};
+
+static const char * const err_id_list[] = {
+	"No error.",
+	"Mode error.",
+	"Data size error.",
+	"Key size error.",
+	"PKHA A memory size error.",
+	"PKHA B memory size error.",
+	"Data arrived out of sequence error.",
+	"PKHA divide-by-zero error.",
+	"PKHA modulus even error.",
+	"DES key parity error.",
+	"ICV check failed.",
+	"Hardware error.",
+	"Unsupported CCM AAD size.",
+	"Class 1 CHA is not reset",
+	"Invalid CHA combination was selected",
+	"Invalid CHA selected.",
+};
+
+static const char * const rng_err_id_list[] = {
+	"",
+	"",
+	"",
+	"Instantiate",
+	"Not instantiated",
+	"Test instantiate",
+	"Prediction resistance",
+	"Prediction resistance and test request",
+	"Uninstantiate",
+	"Secure key generation",
+};
+
 #define SPRINTFCAT(str, format, param, max_alloc)		\
 {								\
 	char *tmp;						\
@@ -36,51 +183,6 @@ static void report_jump_idx(u32 status, char *outstr)
 
 static void report_ccb_status(u32 status, char *outstr)
 {
-	static const char * const cha_id_list[] = {
-		"",
-		"AES",
-		"DES",
-		"ARC4",
-		"MDHA",
-		"RNG",
-		"SNOW f8",
-		"Kasumi f8/9",
-		"PKHA",
-		"CRCA",
-		"SNOW f9",
-		"ZUCE",
-		"ZUCA",
-	};
-	static const char * const err_id_list[] = {
-		"No error.",
-		"Mode error.",
-		"Data size error.",
-		"Key size error.",
-		"PKHA A memory size error.",
-		"PKHA B memory size error.",
-		"Data arrived out of sequence error.",
-		"PKHA divide-by-zero error.",
-		"PKHA modulus even error.",
-		"DES key parity error.",
-		"ICV check failed.",
-		"Hardware error.",
-		"Unsupported CCM AAD size.",
-		"Class 1 CHA is not reset",
-		"Invalid CHA combination was selected",
-		"Invalid CHA selected.",
-	};
-	static const char * const rng_err_id_list[] = {
-		"",
-		"",
-		"",
-		"Instantiate",
-		"Not instantiated",
-		"Test instantiate",
-		"Prediction resistance",
-		"Prediction resistance and test request",
-		"Uninstantiate",
-		"Secure key generation",
-	};
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
@@ -117,104 +219,6 @@ static void report_jump_status(u32 status, char *outstr)
 
 static void report_deco_status(u32 status, char *outstr)
 {
-	static const struct {
-		u8 value;
-		char *error_text;
-	} desc_error_list[] = {
-		{ 0x00, "No error." },
-		{ 0x01, "SGT Length Error. The descriptor is trying to read "
-			"more data than is contained in the SGT table." },
-		{ 0x02, "SGT Null Entry Error." },
-		{ 0x03, "Job Ring Control Error. There is a bad value in the "
-			"Job Ring Control register." },
-		{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
-			"field is invalid." },
-		{ 0x05, "Reserved." },
-		{ 0x06, "Invalid KEY Command" },
-		{ 0x07, "Invalid LOAD Command" },
-		{ 0x08, "Invalid STORE Command" },
-		{ 0x09, "Invalid OPERATION Command" },
-		{ 0x0A, "Invalid FIFO LOAD Command" },
-		{ 0x0B, "Invalid FIFO STORE Command" },
-		{ 0x0C, "Invalid MOVE/MOVE_LEN Command" },
-		{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
-			"invalid because the target is not a Job Header "
-			"Command, or the jump is from a Trusted Descriptor to "
-			"a Job Descriptor, or because the target Descriptor "
-			"contains a Shared Descriptor." },
-		{ 0x0E, "Invalid MATH Command" },
-		{ 0x0F, "Invalid SIGNATURE Command" },
-		{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
-			"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
-			"LOAD, or SEQ FIFO STORE decremented the input or "
-			"output sequence length below 0. This error may result "
-			"if a built-in PROTOCOL Command has encountered a "
-			"malformed PDU." },
-		{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
-		{ 0x12, "Shared Descriptor Header Error" },
-		{ 0x13, "Header Error. Invalid length or parity, or certain "
-			"other problems." },
-		{ 0x14, "Burster Error. Burster has gotten to an illegal "
-			"state" },
-		{ 0x15, "Context Register Length Error. The descriptor is "
-			"trying to read or write past the end of the Context "
-			"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
-			"set was executed with too large a length in the "
-			"variable length register (VSOL for SEQ STORE or VSIL "
-			"for SEQ LOAD)." },
-		{ 0x16, "DMA Error" },
-		{ 0x17, "Reserved." },
-		{ 0x1A, "Job failed due to JR reset" },
-		{ 0x1B, "Job failed due to Fail Mode" },
-		{ 0x1C, "DECO Watchdog timer timeout error" },
-		{ 0x1D, "DECO tried to copy a key from another DECO but the "
-			"other DECO's Key Registers were locked" },
-		{ 0x1E, "DECO attempted to copy data from a DECO that had an "
-			"unmasked Descriptor error" },
-		{ 0x1F, "LIODN error. DECO was trying to share from itself or "
-			"from another DECO but the two Non-SEQ LIODN values "
-			"didn't match or the 'shared from' DECO's Descriptor "
-			"required that the SEQ LIODNs be the same and they "
-			"aren't." },
-		{ 0x20, "DECO has completed a reset initiated via the DRR "
-			"register" },
-		{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
-			"option in the FIFO STORE Command, the Nonce counter "
-			"reached its maximum value and this encryption mode "
-			"can no longer be used." },
-		{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
-			"(input frame; block ciphers) and IPsec decap (output "
-			"frame, when doing the next header byte update) and "
-			"DCRC (output frame)." },
-		{ 0x23, "Read Input Frame error" },
-		{ 0x24, "JDKEK, TDKEK or TDSK not loaded error" },
-		{ 0x80, "DNR (do not run) error" },
-		{ 0x81, "undefined protocol command" },
-		{ 0x82, "invalid setting in PDB" },
-		{ 0x83, "Anti-replay LATE error" },
-		{ 0x84, "Anti-replay REPLAY error" },
-		{ 0x85, "Sequence number overflow" },
-		{ 0x86, "Sigver invalid signature" },
-		{ 0x87, "DSA Sign Illegal test descriptor" },
-		{ 0x88, "Protocol Format Error - A protocol has seen an error "
-			"in the format of data received. When running RSA, "
-			"this means that formatting with random padding was "
-			"used, and did not follow the form: 0x00, 0x02, 8-to-N "
-			"bytes of non-zero pad, 0x00, F data." },
-		{ 0x89, "Protocol Size Error - A protocol has seen an error in "
-			"size. When running RSA, pdb size N < (size of F) when "
-			"no formatting is used; or pdb size N < (F + 11) when "
-			"formatting is used." },
-		{ 0xC1, "Blob Command error: Undefined mode" },
-		{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
-		{ 0xC4, "Blob Command error: Black Blob key or input size "
-			"error" },
-		{ 0xC5, "Blob Command error: Invalid key destination" },
-		{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
-		{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
-			"or was decremented to 0" },
-		{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
-	};
 	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
 	int i;
 

commit fa9659cd4d3f40cead6263986cc235f3e67ab872
Author: Marek Vasut <marex@denx.de>
Date:   Thu Apr 24 20:05:12 2014 +0200

    crypto: caam - Contain caam_jr_strstatus() ugliness
    
    The tentacles of this function were firmly attached to various
    places in the CAAM code. Just cut them, or this cthulhu function
    will sprout them anew.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Horia Geanta <horia.geanta@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 9f25f5296029..ba426d902783 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -243,8 +243,9 @@ static void report_cond_code_status(u32 status, char *outstr)
 	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
 }
 
-char *caam_jr_strstatus(char *outstr, u32 status)
+void caam_jr_strstatus(struct device *jrdev, u32 status)
 {
+	char outstr[CAAM_ERROR_STR_MAX];
 	static const struct stat_src {
 		void (*report_ssed)(u32 status, char *outstr);
 		char *error;
@@ -265,6 +266,6 @@ char *caam_jr_strstatus(char *outstr, u32 status)
 	if (status_src[ssrc].report_ssed)
 		status_src[ssrc].report_ssed(status, outstr);
 
-	return outstr;
+	dev_err(jrdev, "%08x: %s\n", status, outstr);
 }
 EXPORT_SYMBOL(caam_jr_strstatus);

commit 96aef9a8ba37da48f2ae9612ccd0f6b7bc0542eb
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Tue Mar 26 18:10:15 2013 -0500

    crypto: caam - static constify error data
    
    checkstack reports report_deco_status(), report_ccb_status() as
    particularly excessive stack users.  Move their lookup tables
    off the stack and put them in .rodata.
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 30b8f74833d4..9f25f5296029 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -36,7 +36,7 @@ static void report_jump_idx(u32 status, char *outstr)
 
 static void report_ccb_status(u32 status, char *outstr)
 {
-	char *cha_id_list[] = {
+	static const char * const cha_id_list[] = {
 		"",
 		"AES",
 		"DES",
@@ -51,7 +51,7 @@ static void report_ccb_status(u32 status, char *outstr)
 		"ZUCE",
 		"ZUCA",
 	};
-	char *err_id_list[] = {
+	static const char * const err_id_list[] = {
 		"No error.",
 		"Mode error.",
 		"Data size error.",
@@ -69,7 +69,7 @@ static void report_ccb_status(u32 status, char *outstr)
 		"Invalid CHA combination was selected",
 		"Invalid CHA selected.",
 	};
-	char *rng_err_id_list[] = {
+	static const char * const rng_err_id_list[] = {
 		"",
 		"",
 		"",
@@ -117,7 +117,7 @@ static void report_jump_status(u32 status, char *outstr)
 
 static void report_deco_status(u32 status, char *outstr)
 {
-	const struct {
+	static const struct {
 		u8 value;
 		char *error_text;
 	} desc_error_list[] = {
@@ -245,7 +245,7 @@ static void report_cond_code_status(u32 status, char *outstr)
 
 char *caam_jr_strstatus(char *outstr, u32 status)
 {
-	struct stat_src {
+	static const struct stat_src {
 		void (*report_ssed)(u32 status, char *outstr);
 		char *error;
 	} status_src[] = {

commit 39ab735835818b12c05b6ae7282630000cd50fe8
Author: Horia Geanta <horia.geanta@freescale.com>
Date:   Sat Sep 15 03:33:54 2012 +0300

    crypto: caam - fix error IDs for SEC v5.x RNG4
    
    According to SEC v5.0-v5.3 reference manuals.
    
    Signed-off-by: Horia Geanta <horia.geanta@freescale.com>
    Acked-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 9955ed9643e6..30b8f74833d4 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -77,10 +77,8 @@ static void report_ccb_status(u32 status, char *outstr)
 		"Not instantiated",
 		"Test instantiate",
 		"Prediction resistance",
-		"",
 		"Prediction resistance and test request",
 		"Uninstantiate",
-		"",
 		"Secure key generation",
 	};
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>

commit 281922a1d4f59bdebbe78c1d9f4c50a967eb6cff
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Fri Jun 22 19:48:52 2012 -0500

    crypto: caam - add support for SEC v5.x RNG4
    
    The SEC v4.x' RNGB h/w block self-initialized.  RNG4, available
    on SEC versions 5 and beyond, is based on a different standard
    that requires manual initialization.
    
    Also update any new errors From the SEC v5.2 reference manual:
    The SEC v5.2's RNG4 unit reuses some error IDs, thus the addition
    of rng_err_id_list over the CHA-independent err_id_list.
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 7e2d54bffad6..9955ed9643e6 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -39,18 +39,20 @@ static void report_ccb_status(u32 status, char *outstr)
 	char *cha_id_list[] = {
 		"",
 		"AES",
-		"DES, 3DES",
+		"DES",
 		"ARC4",
-		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
+		"MDHA",
 		"RNG",
 		"SNOW f8",
-		"Kasumi f8, f9",
-		"All Public Key Algorithms",
-		"CRC",
+		"Kasumi f8/9",
+		"PKHA",
+		"CRCA",
 		"SNOW f9",
+		"ZUCE",
+		"ZUCA",
 	};
 	char *err_id_list[] = {
-		"None. No error.",
+		"No error.",
 		"Mode error.",
 		"Data size error.",
 		"Key size error.",
@@ -67,6 +69,20 @@ static void report_ccb_status(u32 status, char *outstr)
 		"Invalid CHA combination was selected",
 		"Invalid CHA selected.",
 	};
+	char *rng_err_id_list[] = {
+		"",
+		"",
+		"",
+		"Instantiate",
+		"Not instantiated",
+		"Test instantiate",
+		"Prediction resistance",
+		"",
+		"Prediction resistance and test request",
+		"Uninstantiate",
+		"",
+		"Secure key generation",
+	};
 	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
 		    JRSTA_CCBERR_CHAID_SHIFT;
 	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
@@ -81,7 +97,13 @@ static void report_ccb_status(u32 status, char *outstr)
 			   cha_id, sizeof("ff"));
 	}
 
-	if (err_id < ARRAY_SIZE(err_id_list)) {
+	if ((cha_id << JRSTA_CCBERR_CHAID_SHIFT) == JRSTA_CCBERR_CHAID_RNG &&
+	    err_id < ARRAY_SIZE(rng_err_id_list) &&
+	    strlen(rng_err_id_list[err_id])) {
+		/* RNG-only error */
+		SPRINTFCAT(outstr, "%s", rng_err_id_list[err_id],
+			   strlen(rng_err_id_list[err_id]));
+	} else if (err_id < ARRAY_SIZE(err_id_list)) {
 		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
 			   strlen(err_id_list[err_id]));
 	} else {
@@ -101,10 +123,10 @@ static void report_deco_status(u32 status, char *outstr)
 		u8 value;
 		char *error_text;
 	} desc_error_list[] = {
-		{ 0x00, "None. No error." },
+		{ 0x00, "No error." },
 		{ 0x01, "SGT Length Error. The descriptor is trying to read "
 			"more data than is contained in the SGT table." },
-		{ 0x02, "Reserved." },
+		{ 0x02, "SGT Null Entry Error." },
 		{ 0x03, "Job Ring Control Error. There is a bad value in the "
 			"Job Ring Control register." },
 		{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
@@ -116,7 +138,7 @@ static void report_deco_status(u32 status, char *outstr)
 		{ 0x09, "Invalid OPERATION Command" },
 		{ 0x0A, "Invalid FIFO LOAD Command" },
 		{ 0x0B, "Invalid FIFO STORE Command" },
-		{ 0x0C, "Invalid MOVE Command" },
+		{ 0x0C, "Invalid MOVE/MOVE_LEN Command" },
 		{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
 			"invalid because the target is not a Job Header "
 			"Command, or the jump is from a Trusted Descriptor to "
@@ -166,6 +188,8 @@ static void report_deco_status(u32 status, char *outstr)
 			"(input frame; block ciphers) and IPsec decap (output "
 			"frame, when doing the next header byte update) and "
 			"DCRC (output frame)." },
+		{ 0x23, "Read Input Frame error" },
+		{ 0x24, "JDKEK, TDKEK or TDSK not loaded error" },
 		{ 0x80, "DNR (do not run) error" },
 		{ 0x81, "undefined protocol command" },
 		{ 0x82, "invalid setting in PDB" },

commit 6d00376ad15a931d4b148e52d80abc54173e9bf5
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Mar 23 21:21:53 2011 +0800

    crypto: caam - ARRAY_SIZE() vs sizeof()
    
    ARRAY_SIZE() was intended here instead of sizeof().  sizeof() is four
    times larger than ARRAY_SIZE().  outstr is normally 256 chars so
    printing garbage to it could overfill the buffer and corrupt memory.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Acked-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index bd57a6825f57..7e2d54bffad6 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -73,7 +73,7 @@ static void report_ccb_status(u32 status, char *outstr)
 
 	report_jump_idx(status, outstr);
 
-	if (cha_id < sizeof(cha_id_list)) {
+	if (cha_id < ARRAY_SIZE(cha_id_list)) {
 		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
 			   strlen(cha_id_list[cha_id]));
 	} else {
@@ -81,7 +81,7 @@ static void report_ccb_status(u32 status, char *outstr)
 			   cha_id, sizeof("ff"));
 	}
 
-	if (err_id < sizeof(err_id_list)) {
+	if (err_id < ARRAY_SIZE(err_id_list)) {
 		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
 			   strlen(err_id_list[err_id]));
 	} else {
@@ -198,11 +198,11 @@ static void report_deco_status(u32 status, char *outstr)
 
 	report_jump_idx(status, outstr);
 
-	for (i = 0; i < sizeof(desc_error_list); i++)
+	for (i = 0; i < ARRAY_SIZE(desc_error_list); i++)
 		if (desc_error_list[i].value == desc_error)
 			break;
 
-	if (i != sizeof(desc_error_list) && desc_error_list[i].error_text) {
+	if (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text) {
 		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
 			   strlen(desc_error_list[i].error_text));
 	} else {

commit 8e8ec596e6c0144e2dd500a57ee23dde9684df46
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Sun Mar 13 16:54:26 2011 +0800

    crypto: caam - Add support for the Freescale SEC4/CAAM
    
    The SEC4 supercedes the SEC2.x/3.x as Freescale's
    Integrated Security Engine.  Its programming model is
    incompatible with all prior versions of the SEC (talitos).
    
    The SEC4 is also known as the Cryptographic Accelerator
    and Assurance Module (CAAM); this driver is named caam.
    
    This initial submission does not include support for Data Path
    mode operation - AEAD descriptors are submitted via the job
    ring interface, while the Queue Interface (QI) is enabled
    for use by others.  Only AEAD algorithms are implemented
    at this time, for use with IPsec.
    
    Many thanks to the Freescale STC team for their contributions
    to this driver.
    
    Signed-off-by: Steve Cornelius <sec@pobox.com>
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
new file mode 100644
index 000000000000..bd57a6825f57
--- /dev/null
+++ b/drivers/crypto/caam/error.c
@@ -0,0 +1,248 @@
+/*
+ * CAAM Error Reporting
+ *
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ */
+
+#include "compat.h"
+#include "regs.h"
+#include "intern.h"
+#include "desc.h"
+#include "jr.h"
+#include "error.h"
+
+#define SPRINTFCAT(str, format, param, max_alloc)		\
+{								\
+	char *tmp;						\
+								\
+	tmp = kmalloc(sizeof(format) + max_alloc, GFP_ATOMIC);	\
+	sprintf(tmp, format, param);				\
+	strcat(str, tmp);					\
+	kfree(tmp);						\
+}
+
+static void report_jump_idx(u32 status, char *outstr)
+{
+	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
+		  JRSTA_DECOERR_INDEX_SHIFT;
+
+	if (status & JRSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+}
+
+static void report_ccb_status(u32 status, char *outstr)
+{
+	char *cha_id_list[] = {
+		"",
+		"AES",
+		"DES, 3DES",
+		"ARC4",
+		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
+		"RNG",
+		"SNOW f8",
+		"Kasumi f8, f9",
+		"All Public Key Algorithms",
+		"CRC",
+		"SNOW f9",
+	};
+	char *err_id_list[] = {
+		"None. No error.",
+		"Mode error.",
+		"Data size error.",
+		"Key size error.",
+		"PKHA A memory size error.",
+		"PKHA B memory size error.",
+		"Data arrived out of sequence error.",
+		"PKHA divide-by-zero error.",
+		"PKHA modulus even error.",
+		"DES key parity error.",
+		"ICV check failed.",
+		"Hardware error.",
+		"Unsupported CCM AAD size.",
+		"Class 1 CHA is not reset",
+		"Invalid CHA combination was selected",
+		"Invalid CHA selected.",
+	};
+	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
+		    JRSTA_CCBERR_CHAID_SHIFT;
+	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
+
+	report_jump_idx(status, outstr);
+
+	if (cha_id < sizeof(cha_id_list)) {
+		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
+			   strlen(cha_id_list[cha_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified cha_id value 0x%02x: ",
+			   cha_id, sizeof("ff"));
+	}
+
+	if (err_id < sizeof(err_id_list)) {
+		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
+			   strlen(err_id_list[err_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
+			   err_id, sizeof("ff"));
+	}
+}
+
+static void report_jump_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_deco_status(u32 status, char *outstr)
+{
+	const struct {
+		u8 value;
+		char *error_text;
+	} desc_error_list[] = {
+		{ 0x00, "None. No error." },
+		{ 0x01, "SGT Length Error. The descriptor is trying to read "
+			"more data than is contained in the SGT table." },
+		{ 0x02, "Reserved." },
+		{ 0x03, "Job Ring Control Error. There is a bad value in the "
+			"Job Ring Control register." },
+		{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
+			"field is invalid." },
+		{ 0x05, "Reserved." },
+		{ 0x06, "Invalid KEY Command" },
+		{ 0x07, "Invalid LOAD Command" },
+		{ 0x08, "Invalid STORE Command" },
+		{ 0x09, "Invalid OPERATION Command" },
+		{ 0x0A, "Invalid FIFO LOAD Command" },
+		{ 0x0B, "Invalid FIFO STORE Command" },
+		{ 0x0C, "Invalid MOVE Command" },
+		{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
+			"invalid because the target is not a Job Header "
+			"Command, or the jump is from a Trusted Descriptor to "
+			"a Job Descriptor, or because the target Descriptor "
+			"contains a Shared Descriptor." },
+		{ 0x0E, "Invalid MATH Command" },
+		{ 0x0F, "Invalid SIGNATURE Command" },
+		{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
+			"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
+			"LOAD, or SEQ FIFO STORE decremented the input or "
+			"output sequence length below 0. This error may result "
+			"if a built-in PROTOCOL Command has encountered a "
+			"malformed PDU." },
+		{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
+		{ 0x12, "Shared Descriptor Header Error" },
+		{ 0x13, "Header Error. Invalid length or parity, or certain "
+			"other problems." },
+		{ 0x14, "Burster Error. Burster has gotten to an illegal "
+			"state" },
+		{ 0x15, "Context Register Length Error. The descriptor is "
+			"trying to read or write past the end of the Context "
+			"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
+			"set was executed with too large a length in the "
+			"variable length register (VSOL for SEQ STORE or VSIL "
+			"for SEQ LOAD)." },
+		{ 0x16, "DMA Error" },
+		{ 0x17, "Reserved." },
+		{ 0x1A, "Job failed due to JR reset" },
+		{ 0x1B, "Job failed due to Fail Mode" },
+		{ 0x1C, "DECO Watchdog timer timeout error" },
+		{ 0x1D, "DECO tried to copy a key from another DECO but the "
+			"other DECO's Key Registers were locked" },
+		{ 0x1E, "DECO attempted to copy data from a DECO that had an "
+			"unmasked Descriptor error" },
+		{ 0x1F, "LIODN error. DECO was trying to share from itself or "
+			"from another DECO but the two Non-SEQ LIODN values "
+			"didn't match or the 'shared from' DECO's Descriptor "
+			"required that the SEQ LIODNs be the same and they "
+			"aren't." },
+		{ 0x20, "DECO has completed a reset initiated via the DRR "
+			"register" },
+		{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
+			"option in the FIFO STORE Command, the Nonce counter "
+			"reached its maximum value and this encryption mode "
+			"can no longer be used." },
+		{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
+			"(input frame; block ciphers) and IPsec decap (output "
+			"frame, when doing the next header byte update) and "
+			"DCRC (output frame)." },
+		{ 0x80, "DNR (do not run) error" },
+		{ 0x81, "undefined protocol command" },
+		{ 0x82, "invalid setting in PDB" },
+		{ 0x83, "Anti-replay LATE error" },
+		{ 0x84, "Anti-replay REPLAY error" },
+		{ 0x85, "Sequence number overflow" },
+		{ 0x86, "Sigver invalid signature" },
+		{ 0x87, "DSA Sign Illegal test descriptor" },
+		{ 0x88, "Protocol Format Error - A protocol has seen an error "
+			"in the format of data received. When running RSA, "
+			"this means that formatting with random padding was "
+			"used, and did not follow the form: 0x00, 0x02, 8-to-N "
+			"bytes of non-zero pad, 0x00, F data." },
+		{ 0x89, "Protocol Size Error - A protocol has seen an error in "
+			"size. When running RSA, pdb size N < (size of F) when "
+			"no formatting is used; or pdb size N < (F + 11) when "
+			"formatting is used." },
+		{ 0xC1, "Blob Command error: Undefined mode" },
+		{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
+		{ 0xC4, "Blob Command error: Black Blob key or input size "
+			"error" },
+		{ 0xC5, "Blob Command error: Invalid key destination" },
+		{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
+		{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
+			"or was decremented to 0" },
+		{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
+	};
+	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
+	int i;
+
+	report_jump_idx(status, outstr);
+
+	for (i = 0; i < sizeof(desc_error_list); i++)
+		if (desc_error_list[i].value == desc_error)
+			break;
+
+	if (i != sizeof(desc_error_list) && desc_error_list[i].error_text) {
+		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
+			   strlen(desc_error_list[i].error_text));
+	} else {
+		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
+			   desc_error, sizeof("ff"));
+	}
+}
+
+static void report_jr_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_cond_code_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+char *caam_jr_strstatus(char *outstr, u32 status)
+{
+	struct stat_src {
+		void (*report_ssed)(u32 status, char *outstr);
+		char *error;
+	} status_src[] = {
+		{ NULL, "No error" },
+		{ NULL, NULL },
+		{ report_ccb_status, "CCB" },
+		{ report_jump_status, "Jump" },
+		{ report_deco_status, "DECO" },
+		{ NULL, NULL },
+		{ report_jr_status, "Job Ring" },
+		{ report_cond_code_status, "Condition Code" },
+	};
+	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
+
+	sprintf(outstr, "%s: ", status_src[ssrc].error);
+
+	if (status_src[ssrc].report_ssed)
+		status_src[ssrc].report_ssed(status, outstr);
+
+	return outstr;
+}
+EXPORT_SYMBOL(caam_jr_strstatus);
