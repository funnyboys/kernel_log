commit e4f9eefbb8a976bb86dbdc9d2dd1a2a113801464
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Oct 22 16:40:09 2019 +0100

    firmware: imx: add missing include of <linux/firmware/imx/sci.h>
    
    Include <linux/firmware/imx/sci.h> for the declarations of the
    functions exported from this driver. This fixes the following
    sparse warnings:
    
    drivers/firmware/imx/imx-scu-irq.c:45:5: warning: symbol 'imx_scu_irq_register_notifier' was not declared. Should it be static?
    drivers/firmware/imx/imx-scu-irq.c:52:5: warning: symbol 'imx_scu_irq_unregister_notifier' was not declared. Should it be static?
    drivers/firmware/imx/imx-scu-irq.c:97:5: warning: symbol 'imx_scu_irq_group_enable' was not declared. Should it be static?
    drivers/firmware/imx/imx-scu-irq.c:130:5: warning: symbol 'imx_scu_enable_general_irq_channel' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/imx-scu-irq.c b/drivers/firmware/imx/imx-scu-irq.c
index 687121f8c4d5..db655e87cdc8 100644
--- a/drivers/firmware/imx/imx-scu-irq.c
+++ b/drivers/firmware/imx/imx-scu-irq.c
@@ -8,6 +8,7 @@
 
 #include <dt-bindings/firmware/imx/rsrc.h>
 #include <linux/firmware/imx/ipc.h>
+#include <linux/firmware/imx/sci.h>
 #include <linux/mailbox_client.h>
 
 #define IMX_SC_IRQ_FUNC_ENABLE	1

commit a0b14e6585b97b52765f9cbd86cedb7bb382159b
Author: Anson Huang <anson.huang@nxp.com>
Date:   Sun May 12 08:38:22 2019 +0000

    firmware: imx: SCU irq should ONLY be enabled after SCU IPC is ready
    
    The imx_scu_irq_group_enable() is normally called during module driver
    probe phase to enable SCU group irq, if SCU IPC is NOT ready, below
    dump will show out:
    
    [    0.933001] Hardware name: Freescale i.MX8QXP MEK (DT)
    [    0.938129] pstate: 60000005 (nZCv daif -PAN -UAO)
    [    0.942907] pc : imx_scu_call_rpc+0x114/0x158
    [    0.947251] lr : imx_scu_irq_group_enable+0x74/0xc4
    [    0.952113] sp : ffff00001005bae0
    [    0.955415] x29: ffff00001005bae0 x28: ffff0000111bb0a0
    [    0.960712] x27: ffff00001140b000 x26: ffff00001111068c
    [    0.966011] x25: ffff0000111bb100 x24: 0000000000000000
    [    0.971311] x23: ffff0000113d9cd8 x22: 0000000000000001
    [    0.976610] x21: 0000000000000001 x20: ffff80083b51a410
    [    0.981909] x19: ffff000011259000 x18: 0000000000000480
    [    0.987209] x17: 000000000023ffb8 x16: 0000000000000010
    [    0.992508] x15: 000000000000023f x14: ffffffffffffffff
    [    0.997807] x13: 0000000000000018 x12: 0000000000000030
    [    1.003107] x11: 0000000000000003 x10: 0101010101010101
    [    1.008406] x9 : ffffffffffffffff x8 : 7f7f7f7f7f7f7f7f
    [    1.013706] x7 : fefefeff646c606d x6 : 0000000000000000
    [    1.019005] x5 : ffff0000112596c8 x4 : 0000000000000008
    [    1.024304] x3 : 0000000000000003 x2 : 0000000000000001
    [    1.029604] x1 : ffff00001005bb58 x0 : 0000000000000000
    [    1.034905] Call trace:
    [    1.037341]  imx_scu_call_rpc+0x114/0x158
    [    1.041334]  imx_scu_irq_group_enable+0x74/0xc4
    [    1.045856]  imx_sc_wdt_probe+0x24/0x150
    [    1.049766]  platform_drv_probe+0x4c/0xb0
    [    1.053762]  really_probe+0x1f8/0x2c8
    [    1.057407]  driver_probe_device+0x58/0xfc
    [    1.061490]  device_driver_attach+0x68/0x70
    [    1.065660]  __driver_attach+0x94/0xdc
    [    1.069397]  bus_for_each_dev+0x64/0xc0
    [    1.073220]  driver_attach+0x20/0x28
    [    1.076782]  bus_add_driver+0x148/0x1fc
    [    1.080601]  driver_register+0x68/0x120
    [    1.084424]  __platform_driver_register+0x4c/0x54
    [    1.089120]  imx_sc_wdt_driver_init+0x18/0x20
    [    1.093463]  do_one_initcall+0x58/0x1b8
    [    1.097287]  kernel_init_freeable+0x1cc/0x288
    [    1.101630]  kernel_init+0x10/0x100
    [    1.105101]  ret_from_fork+0x10/0x18
    [    1.108669] ---[ end trace 9e03302114457de9 ]---
    [    1.113296] enable irq failed, group 1, mask 1, ret -22
    
    To avoid such scenario, return -EPROBE_DEFER in imx_scu_irq_group_enable()
    API if SCU IPC is NOT ready, then module driver which calls this API
    in probe phase will defer probe after SCU IPC ready.
    
    Fixes: 851826c7566e ("firmware: imx: enable imx scu general irq function")
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/imx-scu-irq.c b/drivers/firmware/imx/imx-scu-irq.c
index 043833ad3c1a..687121f8c4d5 100644
--- a/drivers/firmware/imx/imx-scu-irq.c
+++ b/drivers/firmware/imx/imx-scu-irq.c
@@ -100,6 +100,9 @@ int imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable)
 	struct imx_sc_rpc_msg *hdr = &msg.hdr;
 	int ret;
 
+	if (!imx_sc_irq_ipc_handle)
+		return -EPROBE_DEFER;
+
 	hdr->ver = IMX_SC_RPC_VERSION;
 	hdr->svc = IMX_SC_RPC_SVC_IRQ;
 	hdr->func = IMX_SC_IRQ_FUNC_ENABLE;

commit 851826c7566e9bb4d03eb050634031ecc802affb
Author: Anson Huang <anson.huang@nxp.com>
Date:   Tue Apr 9 04:59:55 2019 +0000

    firmware: imx: enable imx scu general irq function
    
    The System Controller Firmware (SCFW) controls RTC, thermal
    and WDOG etc., these resources' interrupt function are managed
    by SCU. When any IRQ pending, SCU will notify Linux via MU general
    interrupt channel #3, and Linux kernel needs to call SCU APIs
    to get IRQ status and notify each module to handle the interrupt.
    
    Since there is no data transmission for SCU IRQ notification, so
    doorbell mode is used for this MU channel, and SCU driver will
    use notifier mechanism to broadcast to every module which registers
    the SCU block notifier.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/imx-scu-irq.c b/drivers/firmware/imx/imx-scu-irq.c
new file mode 100644
index 000000000000..043833ad3c1a
--- /dev/null
+++ b/drivers/firmware/imx/imx-scu-irq.c
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 NXP
+ *
+ * Implementation of the SCU IRQ functions using MU.
+ *
+ */
+
+#include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/firmware/imx/ipc.h>
+#include <linux/mailbox_client.h>
+
+#define IMX_SC_IRQ_FUNC_ENABLE	1
+#define IMX_SC_IRQ_FUNC_STATUS	2
+#define IMX_SC_IRQ_NUM_GROUP	4
+
+static u32 mu_resource_id;
+
+struct imx_sc_msg_irq_get_status {
+	struct imx_sc_rpc_msg hdr;
+	union {
+		struct {
+			u16 resource;
+			u8 group;
+			u8 reserved;
+		} __packed req;
+		struct {
+			u32 status;
+		} resp;
+	} data;
+};
+
+struct imx_sc_msg_irq_enable {
+	struct imx_sc_rpc_msg hdr;
+	u32 mask;
+	u16 resource;
+	u8 group;
+	u8 enable;
+} __packed;
+
+static struct imx_sc_ipc *imx_sc_irq_ipc_handle;
+static struct work_struct imx_sc_irq_work;
+static ATOMIC_NOTIFIER_HEAD(imx_scu_irq_notifier_chain);
+
+int imx_scu_irq_register_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(
+		&imx_scu_irq_notifier_chain, nb);
+}
+EXPORT_SYMBOL(imx_scu_irq_register_notifier);
+
+int imx_scu_irq_unregister_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(
+		&imx_scu_irq_notifier_chain, nb);
+}
+EXPORT_SYMBOL(imx_scu_irq_unregister_notifier);
+
+static int imx_scu_irq_notifier_call_chain(unsigned long status, u8 *group)
+{
+	return atomic_notifier_call_chain(&imx_scu_irq_notifier_chain,
+		status, (void *)group);
+}
+
+static void imx_scu_irq_work_handler(struct work_struct *work)
+{
+	struct imx_sc_msg_irq_get_status msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	u32 irq_status;
+	int ret;
+	u8 i;
+
+	for (i = 0; i < IMX_SC_IRQ_NUM_GROUP; i++) {
+		hdr->ver = IMX_SC_RPC_VERSION;
+		hdr->svc = IMX_SC_RPC_SVC_IRQ;
+		hdr->func = IMX_SC_IRQ_FUNC_STATUS;
+		hdr->size = 2;
+
+		msg.data.req.resource = mu_resource_id;
+		msg.data.req.group = i;
+
+		ret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);
+		if (ret) {
+			pr_err("get irq group %d status failed, ret %d\n",
+			       i, ret);
+			return;
+		}
+
+		irq_status = msg.data.resp.status;
+		if (!irq_status)
+			continue;
+
+		imx_scu_irq_notifier_call_chain(irq_status, &i);
+	}
+}
+
+int imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable)
+{
+	struct imx_sc_msg_irq_enable msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	int ret;
+
+	hdr->ver = IMX_SC_RPC_VERSION;
+	hdr->svc = IMX_SC_RPC_SVC_IRQ;
+	hdr->func = IMX_SC_IRQ_FUNC_ENABLE;
+	hdr->size = 3;
+
+	msg.resource = mu_resource_id;
+	msg.group = group;
+	msg.mask = mask;
+	msg.enable = enable;
+
+	ret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);
+	if (ret)
+		pr_err("enable irq failed, group %d, mask %d, ret %d\n",
+			group, mask, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(imx_scu_irq_group_enable);
+
+static void imx_scu_irq_callback(struct mbox_client *c, void *msg)
+{
+	schedule_work(&imx_sc_irq_work);
+}
+
+int imx_scu_enable_general_irq_channel(struct device *dev)
+{
+	struct of_phandle_args spec;
+	struct mbox_client *cl;
+	struct mbox_chan *ch;
+	int ret = 0, i = 0;
+
+	ret = imx_scu_get_handle(&imx_sc_irq_ipc_handle);
+	if (ret)
+		return ret;
+
+	cl = devm_kzalloc(dev, sizeof(*cl), GFP_KERNEL);
+	if (!cl)
+		return -ENOMEM;
+
+	cl->dev = dev;
+	cl->rx_callback = imx_scu_irq_callback;
+
+	/* SCU general IRQ uses general interrupt channel 3 */
+	ch = mbox_request_channel_byname(cl, "gip3");
+	if (IS_ERR(ch)) {
+		ret = PTR_ERR(ch);
+		dev_err(dev, "failed to request mbox chan gip3, ret %d\n", ret);
+		devm_kfree(dev, cl);
+		return ret;
+	}
+
+	INIT_WORK(&imx_sc_irq_work, imx_scu_irq_work_handler);
+
+	if (!of_parse_phandle_with_args(dev->of_node, "mboxes",
+				       "#mbox-cells", 0, &spec))
+		i = of_alias_get_id(spec.np, "mu");
+
+	/* use mu1 as general mu irq channel if failed */
+	if (i < 0)
+		i = 1;
+
+	mu_resource_id = IMX_SC_R_MU_0A + i;
+
+	return ret;
+}
+EXPORT_SYMBOL(imx_scu_enable_general_irq_channel);
