commit d18292dc07dbaaacef040a23a5e5e65c6ea61803
Merge: 0e8fb69f287b cedb414aa8c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 3 15:05:35 2020 -0700

    Merge tag 'arm-drivers-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM driver updates from Arnd Bergmann:
     "These are the usual updates for SoC specific device drivers and
      related subsystems that don't have their own top-level maintainers:
    
       - ARM SCMI/SCPI updates to allow pluggable transport layers
    
       - TEE subsystem cleanups
    
       - A new driver for the Amlogic secure power domain controller
    
       - Various driver updates for the NXP Layerscape DPAA2, NXP i.MX SCU
         and TI OMAP2+ sysc drivers.
    
       - Qualcomm SoC driver updates, including a new library module for
         "protection domain" notifications
    
       - Lots of smaller bugfixes and cleanups in other drivers"
    
    * tag 'arm-drivers-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (70 commits)
      soc: fsl: qe: fix sparse warnings for ucc_slow.c
      soc: fsl: qe: ucc_slow: remove 0 assignment for kzalloc'ed structure
      soc: fsl: qe: fix sparse warnings for ucc_fast.c
      soc: fsl: qe: fix sparse warnings for qe_ic.c
      soc: fsl: qe: fix sparse warnings for ucc.c
      soc: fsl: qe: fix sparse warning for qe_common.c
      soc: fsl: qe: fix sparse warnings for qe.c
      soc: qcom: Fix QCOM_APR dependencies
      soc: qcom: pdr: Avoid uninitialized use of found in pdr_indication_cb
      soc: imx: drop COMPILE_TEST for IMX_SCU_SOC
      firmware: imx: add COMPILE_TEST for IMX_SCU driver
      soc: imx: gpc: fix power up sequencing
      soc: imx: increase build coverage for imx8m soc driver
      soc: qcom: apr: Add avs/audio tracking functionality
      dt-bindings: soc: qcom: apr: Add protection domain bindings
      soc: qcom: Introduce Protection Domain Restart helpers
      devicetree: bindings: firmware: add ipq806x to qcom_scm
      memory: tegra: Correct debugfs clk rate-range on Tegra124
      memory: tegra: Correct debugfs clk rate-range on Tegra30
      memory: tegra: Correct debugfs clk rate-range on Tegra20
      ...

commit 705dcca91d0a75f5657f3d5465f7dbd31c3efa8b
Author: Joakim Zhang <qiangqing.zhang@nxp.com>
Date:   Mon Feb 17 11:19:15 2020 +0800

    firmware: imx: scu-pd: add power domain for I2C and INTMUX in CM40 SS
    
    Add power domain for I2C and INTMUX in CM40 SS.
    
    Signed-off-by: Joakim Zhang <qiangqing.zhang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 09cfa268c6bd..f3b4246ff200 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -165,6 +165,10 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* DC SS */
 	{ "dc0", IMX_SC_R_DC_0, 1, false, 0 },
 	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, true, 0 },
+
+	/* CM40 SS */
+	{ "cm40_i2c", IMX_SC_R_M4_0_I2C, 1, 0 },
+	{ "cm40_intmux", IMX_SC_R_M4_0_INTMUX, 1, 0 },
 };
 
 static const struct imx_sc_pd_soc imx8qxp_scu_pd = {

commit 7c1a1c814ccc858633c761951c2546041202b24e
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Thu Feb 20 18:29:35 2020 +0200

    firmware: imx: scu-pd: Align imx sc msg structs to 4
    
    The imx SC api strongly assumes that messages are composed out of
    4-bytes words but some of our message structs have odd sizeofs.
    
    This produces many oopses with CONFIG_KASAN=y.
    
    Fix by marking with __aligned(4).
    
    Fixes: c800cd7824bd ("firmware: imx: add SCU power domain driver")
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index b556612207e5..af3ae0087de4 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -61,7 +61,7 @@ struct imx_sc_msg_req_set_resource_power_mode {
 	struct imx_sc_rpc_msg hdr;
 	u16 resource;
 	u8 mode;
-} __packed;
+} __packed __aligned(4);
 
 #define IMX_SCU_PD_NAME_SIZE 20
 struct imx_sc_pm_domain {

commit e391b24d94915ff870cdca9a1cee01324326bb95
Author: Sebastien Fagard <sebastien.fagard@nxp.com>
Date:   Mon Jan 27 14:27:32 2020 +0000

    firmware: imx: scu-pd: enlarge PD range for mu_b
    
    The range of resources for Messaging Units side B needs to contain
    all the possible MUB resource available: starting from MU_5B up to
    MU_13B.
    This patch is needed to enable MU_8B for the 'imx-shmem-net' driver
    which allows two OS partitions communicating via MUs without Hypervisor.
    
    Signed-off-by: Sebastien Fagard <sebastien.fagard@nxp.com>
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index c10f63901c1c..09cfa268c6bd 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -93,7 +93,7 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "kpp", IMX_SC_R_KPP, 1, false, 0 },
 	{ "fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
 	{ "mu_a", IMX_SC_R_MU_0A, 14, true, 0 },
-	{ "mu_b", IMX_SC_R_MU_13B, 1, true, 13 },
+	{ "mu_b", IMX_SC_R_MU_5B, 9, true, 5 },
 
 	/* CONN SS */
 	{ "usb", IMX_SC_R_USB_0, 2, true, 0 },

commit 0a7696b319511b0eccb0c92d030d84653b90a975
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Mon Jan 27 14:27:31 2020 +0000

    firmware: imx: scu-pd: Add missing audio PD ranges
    
    imx8qxp_scu_pd_ranges keeps PD ranges for both i.MX8QM and
    i.MX8QXP.
    
    The following PD are missing: audio-clk1/ spdif1 / sai3..7.
    Add them now.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index b556612207e5..c10f63901c1c 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -109,6 +109,7 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },
 	{ "audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },
 	{ "audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },
+	{ "audio-clk-1", IMX_SC_R_AUDIO_CLK_1, 1, false, 0 },
 	{ "dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true, 0 },
 	{ "dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true, 0 },
 	{ "dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
@@ -116,7 +117,13 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "asrc1", IMX_SC_R_ASRC_1, 1, false, 0 },
 	{ "esai0", IMX_SC_R_ESAI_0, 1, false, 0 },
 	{ "spdif0", IMX_SC_R_SPDIF_0, 1, false, 0 },
+	{ "spdif1", IMX_SC_R_SPDIF_1, 1, false, 0 },
 	{ "sai", IMX_SC_R_SAI_0, 3, true, 0 },
+	{ "sai3", IMX_SC_R_SAI_3, 1, false, 0 },
+	{ "sai4", IMX_SC_R_SAI_4, 1, false, 0 },
+	{ "sai5", IMX_SC_R_SAI_5, 1, false, 0 },
+	{ "sai6", IMX_SC_R_SAI_6, 1, false, 0 },
+	{ "sai7", IMX_SC_R_SAI_7, 1, false, 0 },
 	{ "amix", IMX_SC_R_AMIX, 1, false, 0 },
 	{ "mqs0", IMX_SC_R_MQS_0, 1, false, 0 },
 	{ "dsp", IMX_SC_R_DSP, 1, false, 0 },

commit d43dc52274d40a1543ca962008feb9ff784e3a49
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Thu Jul 18 13:25:19 2019 +0300

    firmware: imx: scu-pd: Add IRQSTR_DSP PD range
    
    The DSP interrupt steer gathers interrupts from the system
    and can be used to steer them to DSP.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index eb9700b66a76..b556612207e5 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -131,6 +131,7 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },
 	{ "lpuart", IMX_SC_R_UART_0, 4, true, 0 },
 	{ "lpspi", IMX_SC_R_SPI_0, 4, true, 0 },
+	{ "irqstr_dsp", IMX_SC_R_IRQSTR_DSP, 1, false, 0 },
 
 	/* VPU SS */
 	{ "vpu", IMX_SC_R_VPU, 1, false, 0 },

commit 590b346b58badfe87cb13a64abdc8af25e907846
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Thu Jul 18 13:25:18 2019 +0300

    firmware: imx: scu-pd: Add mu13 b side PD range
    
    LSIO subsystem contains 14 MU instances.
    
    5 MUs to communicate between AP <-> SCU
      - side-A PD range managed by AP
      - side-B PD range managed by SCU
    
    9 MUs to communicate between all cores (AP/M4/DSP).
      - side-A PD range managed by core-A (AP/M4/DSP)
      - side-B PD range managed by core-B (AP/M4/DSP).
    
    Communication between AP <-> DSP is done through the
    assigned MU number 13.
    
    So, we power up side-A by the AP and we decide to
    power up side-B also from AP. This is because powering
    it up from DSP would be painful.
    
    Powering up side B from DSP would require the DSP to
    communicate with SCU and to keep things simple we don't
    want that now.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 950d30238186..eb9700b66a76 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -93,6 +93,7 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "kpp", IMX_SC_R_KPP, 1, false, 0 },
 	{ "fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
 	{ "mu_a", IMX_SC_R_MU_0A, 14, true, 0 },
+	{ "mu_b", IMX_SC_R_MU_13B, 1, true, 13 },
 
 	/* CONN SS */
 	{ "usb", IMX_SC_R_USB_0, 2, true, 0 },

commit 6d9d21711b38c9cd5f70e04623151f498f3129ac
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Thu Jul 18 13:25:17 2019 +0300

    firmware: imx: scu-pd: Rename mu PD range to mu_a
    
    The Messaging Unit module enables two processors within the SoC to
    communicate and coordinate by passing messages through the MU interface.
    
    MUs have 2 “sides” with independent programming interfaces. Rename
    mu PD range to mu_a because it's actually side A of MUs.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 480cec69e2c9..950d30238186 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -92,7 +92,7 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "gpt", IMX_SC_R_GPT_0, 5, true, 0 },
 	{ "kpp", IMX_SC_R_KPP, 1, false, 0 },
 	{ "fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
-	{ "mu", IMX_SC_R_MU_0A, 14, true, 0 },
+	{ "mu_a", IMX_SC_R_MU_0A, 14, true, 0 },
 
 	/* CONN SS */
 	{ "usb", IMX_SC_R_USB_0, 2, true, 0 },

commit 32654dad06e24e2909c64b4fc3d61689f5522975
Author: Aisheng Dong <aisheng.dong@nxp.com>
Date:   Wed Feb 20 14:38:36 2019 +0000

    firmware: imx: scu-pd: decouple the SS information from domain names
    
    As resource power domain service is provided by SCU firmware, no
    SS information required. So we can remove the SS indicator from
    the domain names, then the domains defined can be better shared
    among different SCU based platforms.
    
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 8a2b6ada58ad..480cec69e2c9 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -87,49 +87,51 @@ struct imx_sc_pd_soc {
 
 static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* LSIO SS */
-	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, true, 0 },
-	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, true, 0 },
-	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, true, 0 },
-	{ "lsio-kpp", IMX_SC_R_KPP, 1, false, 0 },
-	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
-	{ "lsio-mu", IMX_SC_R_MU_0A, 14, true, 0 },
+	{ "pwm", IMX_SC_R_PWM_0, 8, true, 0 },
+	{ "gpio", IMX_SC_R_GPIO_0, 8, true, 0 },
+	{ "gpt", IMX_SC_R_GPT_0, 5, true, 0 },
+	{ "kpp", IMX_SC_R_KPP, 1, false, 0 },
+	{ "fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
+	{ "mu", IMX_SC_R_MU_0A, 14, true, 0 },
 
 	/* CONN SS */
-	{ "con-usb", IMX_SC_R_USB_0, 2, true, 0 },
-	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, false, 0 },
-	{ "con-usb2", IMX_SC_R_USB_2, 1, false, 0 },
-	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, false, 0 },
-	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, true, 0 },
-	{ "con-enet", IMX_SC_R_ENET_0, 2, true, 0 },
-	{ "con-nand", IMX_SC_R_NAND, 1, false, 0 },
-	{ "con-mlb", IMX_SC_R_MLB_0, 1, true, 0 },
-
-	/* Audio DMA SS */
-	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },
-	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },
-	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },
-	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true, 0 },
-	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true, 0 },
-	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
-	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, false, 0 },
-	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, false, 0 },
-	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, false, 0 },
-	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, false, 0 },
-	{ "adma-sai", IMX_SC_R_SAI_0, 3, true, 0 },
-	{ "adma-amix", IMX_SC_R_AMIX, 1, false, 0 },
-	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, false, 0 },
-	{ "adma-dsp", IMX_SC_R_DSP, 1, false, 0 },
-	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, false, 0 },
-	{ "adma-can", IMX_SC_R_CAN_0, 3, true, 0 },
-	{ "adma-ftm", IMX_SC_R_FTM_0, 2, true, 0 },
-	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, true, 0 },
-	{ "adma-adc", IMX_SC_R_ADC_0, 1, true, 0 },
-	{ "adma-lcd", IMX_SC_R_LCD_0, 1, true, 0 },
-	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },
-	{ "adma-lpuart", IMX_SC_R_UART_0, 4, true, 0 },
-	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, true, 0 },
-
-	/* VPU SS  */
+	{ "usb", IMX_SC_R_USB_0, 2, true, 0 },
+	{ "usb0phy", IMX_SC_R_USB_0_PHY, 1, false, 0 },
+	{ "usb2", IMX_SC_R_USB_2, 1, false, 0 },
+	{ "usb2phy", IMX_SC_R_USB_2_PHY, 1, false, 0 },
+	{ "sdhc", IMX_SC_R_SDHC_0, 3, true, 0 },
+	{ "enet", IMX_SC_R_ENET_0, 2, true, 0 },
+	{ "nand", IMX_SC_R_NAND, 1, false, 0 },
+	{ "mlb", IMX_SC_R_MLB_0, 1, true, 0 },
+
+	/* AUDIO SS */
+	{ "audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },
+	{ "audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },
+	{ "audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },
+	{ "dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true, 0 },
+	{ "dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true, 0 },
+	{ "dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
+	{ "asrc0", IMX_SC_R_ASRC_0, 1, false, 0 },
+	{ "asrc1", IMX_SC_R_ASRC_1, 1, false, 0 },
+	{ "esai0", IMX_SC_R_ESAI_0, 1, false, 0 },
+	{ "spdif0", IMX_SC_R_SPDIF_0, 1, false, 0 },
+	{ "sai", IMX_SC_R_SAI_0, 3, true, 0 },
+	{ "amix", IMX_SC_R_AMIX, 1, false, 0 },
+	{ "mqs0", IMX_SC_R_MQS_0, 1, false, 0 },
+	{ "dsp", IMX_SC_R_DSP, 1, false, 0 },
+	{ "dsp-ram", IMX_SC_R_DSP_RAM, 1, false, 0 },
+
+	/* DMA SS */
+	{ "can", IMX_SC_R_CAN_0, 3, true, 0 },
+	{ "ftm", IMX_SC_R_FTM_0, 2, true, 0 },
+	{ "lpi2c", IMX_SC_R_I2C_0, 4, true, 0 },
+	{ "adc", IMX_SC_R_ADC_0, 1, true, 0 },
+	{ "lcd", IMX_SC_R_LCD_0, 1, true, 0 },
+	{ "lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },
+	{ "lpuart", IMX_SC_R_UART_0, 4, true, 0 },
+	{ "lpspi", IMX_SC_R_SPI_0, 4, true, 0 },
+
+	/* VPU SS */
 	{ "vpu", IMX_SC_R_VPU, 1, false, 0 },
 	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, true, 0 },
 	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, false, 0 },
@@ -139,14 +141,16 @@ static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, true, 0 },
 
 	/* HSIO SS */
-	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, false, 0 },
-	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, false, 0 },
+	{ "pcie-b", IMX_SC_R_PCIE_B, 1, false, 0 },
+	{ "serdes-1", IMX_SC_R_SERDES_1, 1, false, 0 },
 	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, false, 0 },
 
-	/* MIPI/LVDS SS */
+	/* MIPI SS */
 	{ "mipi0", IMX_SC_R_MIPI_0, 1, false, 0 },
 	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, false, 0 },
 	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, true, 0 },
+
+	/* LVDS SS */
 	{ "lvds0", IMX_SC_R_LVDS_0, 1, false, 0 },
 
 	/* DC SS */

commit ad8cc071c557b075b923bf27aee8a7dae7338f5e
Author: Aisheng Dong <aisheng.dong@nxp.com>
Date:   Wed Feb 20 14:38:32 2019 +0000

    firmware: imx: scu-pd: add specifying the base of domain name index support
    
    As the domain resource id in the same type may not be continuous, so it's
    hard to describe all such power domains with current struct imx_sc_pd_range.
    
    Adding the optional base for domain name index to address this issue.
    Then we can add the discrete domains easily later.
    
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index e7802ec591c2..8a2b6ada58ad 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -74,7 +74,10 @@ struct imx_sc_pd_range {
 	char *name;
 	u32 rsrc;
 	u8 num;
+
+	/* add domain index */
 	bool postfix;
+	u8 start_from;
 };
 
 struct imx_sc_pd_soc {
@@ -84,71 +87,71 @@ struct imx_sc_pd_soc {
 
 static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* LSIO SS */
-	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, true },
-	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, true },
-	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, true },
-	{ "lsio-kpp", IMX_SC_R_KPP, 1, false },
-	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, true },
-	{ "lsio-mu", IMX_SC_R_MU_0A, 14, true },
+	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, true, 0 },
+	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, true, 0 },
+	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, true, 0 },
+	{ "lsio-kpp", IMX_SC_R_KPP, 1, false, 0 },
+	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, true, 0 },
+	{ "lsio-mu", IMX_SC_R_MU_0A, 14, true, 0 },
 
 	/* CONN SS */
-	{ "con-usb", IMX_SC_R_USB_0, 2, true },
-	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, false },
-	{ "con-usb2", IMX_SC_R_USB_2, 1, false },
-	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, false },
-	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, true },
-	{ "con-enet", IMX_SC_R_ENET_0, 2, true },
-	{ "con-nand", IMX_SC_R_NAND, 1, false },
-	{ "con-mlb", IMX_SC_R_MLB_0, 1, true },
+	{ "con-usb", IMX_SC_R_USB_0, 2, true, 0 },
+	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, false, 0 },
+	{ "con-usb2", IMX_SC_R_USB_2, 1, false, 0 },
+	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, false, 0 },
+	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, true, 0 },
+	{ "con-enet", IMX_SC_R_ENET_0, 2, true, 0 },
+	{ "con-nand", IMX_SC_R_NAND, 1, false, 0 },
+	{ "con-mlb", IMX_SC_R_MLB_0, 1, true, 0 },
 
 	/* Audio DMA SS */
-	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false },
-	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false },
-	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false },
-	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true },
-	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true },
-	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true },
-	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, false },
-	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, false },
-	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, false },
-	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, false },
-	{ "adma-sai", IMX_SC_R_SAI_0, 3, true },
-	{ "adma-amix", IMX_SC_R_AMIX, 1, false },
-	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, false },
-	{ "adma-dsp", IMX_SC_R_DSP, 1, false },
-	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, false },
-	{ "adma-can", IMX_SC_R_CAN_0, 3, true },
-	{ "adma-ftm", IMX_SC_R_FTM_0, 2, true },
-	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, true },
-	{ "adma-adc", IMX_SC_R_ADC_0, 1, true },
-	{ "adma-lcd", IMX_SC_R_LCD_0, 1, true },
-	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true },
-	{ "adma-lpuart", IMX_SC_R_UART_0, 4, true },
-	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, true },
+	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false, 0 },
+	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false, 0 },
+	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false, 0 },
+	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true, 0 },
+	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true, 0 },
+	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true, 0 },
+	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, false, 0 },
+	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, false, 0 },
+	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, false, 0 },
+	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, false, 0 },
+	{ "adma-sai", IMX_SC_R_SAI_0, 3, true, 0 },
+	{ "adma-amix", IMX_SC_R_AMIX, 1, false, 0 },
+	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, false, 0 },
+	{ "adma-dsp", IMX_SC_R_DSP, 1, false, 0 },
+	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, false, 0 },
+	{ "adma-can", IMX_SC_R_CAN_0, 3, true, 0 },
+	{ "adma-ftm", IMX_SC_R_FTM_0, 2, true, 0 },
+	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, true, 0 },
+	{ "adma-adc", IMX_SC_R_ADC_0, 1, true, 0 },
+	{ "adma-lcd", IMX_SC_R_LCD_0, 1, true, 0 },
+	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true, 0 },
+	{ "adma-lpuart", IMX_SC_R_UART_0, 4, true, 0 },
+	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, true, 0 },
 
 	/* VPU SS  */
-	{ "vpu", IMX_SC_R_VPU, 1, false },
-	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, true },
-	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, false },
-	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, false },
+	{ "vpu", IMX_SC_R_VPU, 1, false, 0 },
+	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, true, 0 },
+	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, false, 0 },
+	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, false, 0 },
 
 	/* GPU SS */
-	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, true },
+	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, true, 0 },
 
 	/* HSIO SS */
-	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, false },
-	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, false },
-	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, false },
+	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, false, 0 },
+	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, false, 0 },
+	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, false, 0 },
 
 	/* MIPI/LVDS SS */
-	{ "mipi0", IMX_SC_R_MIPI_0, 1, false },
-	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, false },
-	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, true },
-	{ "lvds0", IMX_SC_R_LVDS_0, 1, false },
+	{ "mipi0", IMX_SC_R_MIPI_0, 1, false, 0 },
+	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, false, 0 },
+	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, true, 0 },
+	{ "lvds0", IMX_SC_R_LVDS_0, 1, false, 0 },
 
 	/* DC SS */
-	{ "dc0", IMX_SC_R_DC_0, 1, false },
-	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, true },
+	{ "dc0", IMX_SC_R_DC_0, 1, false, 0 },
+	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, true, 0 },
 };
 
 static const struct imx_sc_pd_soc imx8qxp_scu_pd = {
@@ -236,7 +239,7 @@ imx_scu_add_pm_domain(struct device *dev, int idx,
 
 	if (pd_ranges->postfix)
 		snprintf(sc_pd->name, sizeof(sc_pd->name),
-			 "%s%i", pd_ranges->name, idx);
+			 "%s%i", pd_ranges->name, pd_ranges->start_from + idx);
 	else
 		snprintf(sc_pd->name, sizeof(sc_pd->name),
 			 "%s", pd_ranges->name);

commit 9d616d62faefd573f6eaf687f6c83a872708afcf
Author: Aisheng Dong <aisheng.dong@nxp.com>
Date:   Wed Feb 20 14:38:27 2019 +0000

    firmware: imx: scu-pd: use bool to set postfix
    
    Using bool instead 0/1 to indicate whether adding a postfix for domain
    names which can improve the code readability and less confusing.
    
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 39a94c7177fc..e7802ec591c2 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -84,71 +84,71 @@ struct imx_sc_pd_soc {
 
 static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
 	/* LSIO SS */
-	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, 1 },
-	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, 1 },
-	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, 1 },
-	{ "lsio-kpp", IMX_SC_R_KPP, 1, 0 },
-	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, 1 },
-	{ "lsio-mu", IMX_SC_R_MU_0A, 14, 1 },
+	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, true },
+	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, true },
+	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, true },
+	{ "lsio-kpp", IMX_SC_R_KPP, 1, false },
+	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, true },
+	{ "lsio-mu", IMX_SC_R_MU_0A, 14, true },
 
 	/* CONN SS */
-	{ "con-usb", IMX_SC_R_USB_0, 2, 1 },
-	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, 0 },
-	{ "con-usb2", IMX_SC_R_USB_2, 1, 0 },
-	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, 0 },
-	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, 1 },
-	{ "con-enet", IMX_SC_R_ENET_0, 2, 1 },
-	{ "con-nand", IMX_SC_R_NAND, 1, 0 },
-	{ "con-mlb", IMX_SC_R_MLB_0, 1, 1 },
+	{ "con-usb", IMX_SC_R_USB_0, 2, true },
+	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, false },
+	{ "con-usb2", IMX_SC_R_USB_2, 1, false },
+	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, false },
+	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, true },
+	{ "con-enet", IMX_SC_R_ENET_0, 2, true },
+	{ "con-nand", IMX_SC_R_NAND, 1, false },
+	{ "con-mlb", IMX_SC_R_MLB_0, 1, true },
 
 	/* Audio DMA SS */
-	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, 0 },
-	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, 0 },
-	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, 0 },
-	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, 1 },
-	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, 1 },
-	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, 1 },
-	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, 0 },
-	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, 0 },
-	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, 0 },
-	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, 0 },
-	{ "adma-sai", IMX_SC_R_SAI_0, 3, 1 },
-	{ "adma-amix", IMX_SC_R_AMIX, 1, 0 },
-	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, 0 },
-	{ "adma-dsp", IMX_SC_R_DSP, 1, 0 },
-	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, 0 },
-	{ "adma-can", IMX_SC_R_CAN_0, 3, 1 },
-	{ "adma-ftm", IMX_SC_R_FTM_0, 2, 1 },
-	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, 1 },
-	{ "adma-adc", IMX_SC_R_ADC_0, 1, 1 },
-	{ "adma-lcd", IMX_SC_R_LCD_0, 1, 1 },
-	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, 1 },
-	{ "adma-lpuart", IMX_SC_R_UART_0, 4, 1 },
-	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, 1 },
+	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, false },
+	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, false },
+	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, false },
+	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, true },
+	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, true },
+	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, true },
+	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, false },
+	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, false },
+	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, false },
+	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, false },
+	{ "adma-sai", IMX_SC_R_SAI_0, 3, true },
+	{ "adma-amix", IMX_SC_R_AMIX, 1, false },
+	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, false },
+	{ "adma-dsp", IMX_SC_R_DSP, 1, false },
+	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, false },
+	{ "adma-can", IMX_SC_R_CAN_0, 3, true },
+	{ "adma-ftm", IMX_SC_R_FTM_0, 2, true },
+	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, true },
+	{ "adma-adc", IMX_SC_R_ADC_0, 1, true },
+	{ "adma-lcd", IMX_SC_R_LCD_0, 1, true },
+	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, true },
+	{ "adma-lpuart", IMX_SC_R_UART_0, 4, true },
+	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, true },
 
 	/* VPU SS  */
-	{ "vpu", IMX_SC_R_VPU, 1, 0 },
-	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, 1 },
-	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, 0 },
-	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, 0 },
+	{ "vpu", IMX_SC_R_VPU, 1, false },
+	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, true },
+	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, false },
+	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, false },
 
 	/* GPU SS */
-	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, 1 },
+	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, true },
 
 	/* HSIO SS */
-	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, 0 },
-	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, 0 },
-	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, 0 },
+	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, false },
+	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, false },
+	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, false },
 
 	/* MIPI/LVDS SS */
-	{ "mipi0", IMX_SC_R_MIPI_0, 1, 0 },
-	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, 0 },
-	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, 1 },
-	{ "lvds0", IMX_SC_R_LVDS_0, 1, 0 },
+	{ "mipi0", IMX_SC_R_MIPI_0, 1, false },
+	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, false },
+	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, true },
+	{ "lvds0", IMX_SC_R_LVDS_0, 1, false },
 
 	/* DC SS */
-	{ "dc0", IMX_SC_R_DC_0, 1, 0 },
-	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, 1 },
+	{ "dc0", IMX_SC_R_DC_0, 1, false },
+	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, true },
 };
 
 static const struct imx_sc_pd_soc imx8qxp_scu_pd = {

commit e59e59b80e33b62a4c6f18435907ebd2317e2200
Author: Aisheng Dong <aisheng.dong@nxp.com>
Date:   Tue Dec 18 16:01:29 2018 +0000

    firmware: imx: scu-pd: add fallback compatible string support
    
    SCU power domain can be used in the same way by IMX8QXP and IMX8QM SoCs.
    Make the driver support the fallback compatible string "fsl,scu-pd" to
    allow other SoCs to reuse the common part.
    
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
index 407245f2efd0..39a94c7177fc 100644
--- a/drivers/firmware/imx/scu-pd.c
+++ b/drivers/firmware/imx/scu-pd.c
@@ -322,6 +322,7 @@ static int imx_sc_pd_probe(struct platform_device *pdev)
 
 static const struct of_device_id imx_sc_pd_match[] = {
 	{ .compatible = "fsl,imx8qxp-scu-pd", &imx8qxp_scu_pd},
+	{ .compatible = "fsl,scu-pd", &imx8qxp_scu_pd},
 	{ /* sentinel */ }
 };
 

commit c800cd7824bd8ceb1291f90e3f124c9172f59177
Author: A.s. Dong <aisheng.dong@nxp.com>
Date:   Thu Nov 1 15:20:13 2018 +0000

    firmware: imx: add SCU power domain driver
    
    Some i.MX SoCs contain a system controller that is responsible for
    controlling the state of the IPs that are present. Communication
    between the host processor running an OS and the system controller
    happens through a SCU protocol. This patch adds SCU protocol based
    power domains drivers.
    
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/firmware/imx/scu-pd.c b/drivers/firmware/imx/scu-pd.c
new file mode 100644
index 000000000000..407245f2efd0
--- /dev/null
+++ b/drivers/firmware/imx/scu-pd.c
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017-2018 NXP
+ *	Dong Aisheng <aisheng.dong@nxp.com>
+ *
+ * Implementation of the SCU based Power Domains
+ *
+ * NOTE: a better implementation suggested by Ulf Hansson is using a
+ * single global power domain and implement the ->attach|detach_dev()
+ * callback for the genpd and use the regular of_genpd_add_provider_simple().
+ * From within the ->attach_dev(), we could get the OF node for
+ * the device that is being attached and then parse the power-domain
+ * cell containing the "resource id" and store that in the per device
+ * struct generic_pm_domain_data (we have void pointer there for
+ * storing these kind of things).
+ *
+ * Additionally, we need to implement the ->stop() and ->start()
+ * callbacks of genpd, which is where you "power on/off" devices,
+ * rather than using the above ->power_on|off() callbacks.
+ *
+ * However, there're two known issues:
+ * 1. The ->attach_dev() of power domain infrastructure still does
+ *    not support multi domains case as the struct device *dev passed
+ *    in is a virtual PD device, it does not help for parsing the real
+ *    device resource id from device tree, so it's unware of which
+ *    real sub power domain of device should be attached.
+ *
+ *    The framework needs some proper extension to support multi power
+ *    domain cases.
+ *
+ * 2. It also breaks most of current drivers as the driver probe sequence
+ *    behavior changed if removing ->power_on|off() callback and use
+ *    ->start() and ->stop() instead. genpd_dev_pm_attach will only power
+ *    up the domain and attach device, but will not call .start() which
+ *    relies on device runtime pm. That means the device power is still
+ *    not up before running driver probe function. For SCU enabled
+ *    platforms, all device drivers accessing registers/clock without power
+ *    domain enabled will trigger a HW access error. That means we need fix
+ *    most drivers probe sequence with proper runtime pm.
+ *
+ * In summary, we need fix above two issue before being able to switch to
+ * the "single global power domain" way.
+ *
+ */
+
+#include <dt-bindings/firmware/imx/rsrc.h>
+#include <linux/firmware/imx/sci.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_domain.h>
+#include <linux/slab.h>
+
+/* SCU Power Mode Protocol definition */
+struct imx_sc_msg_req_set_resource_power_mode {
+	struct imx_sc_rpc_msg hdr;
+	u16 resource;
+	u8 mode;
+} __packed;
+
+#define IMX_SCU_PD_NAME_SIZE 20
+struct imx_sc_pm_domain {
+	struct generic_pm_domain pd;
+	char name[IMX_SCU_PD_NAME_SIZE];
+	u32 rsrc;
+};
+
+struct imx_sc_pd_range {
+	char *name;
+	u32 rsrc;
+	u8 num;
+	bool postfix;
+};
+
+struct imx_sc_pd_soc {
+	const struct imx_sc_pd_range *pd_ranges;
+	u8 num_ranges;
+};
+
+static const struct imx_sc_pd_range imx8qxp_scu_pd_ranges[] = {
+	/* LSIO SS */
+	{ "lsio-pwm", IMX_SC_R_PWM_0, 8, 1 },
+	{ "lsio-gpio", IMX_SC_R_GPIO_0, 8, 1 },
+	{ "lsio-gpt", IMX_SC_R_GPT_0, 5, 1 },
+	{ "lsio-kpp", IMX_SC_R_KPP, 1, 0 },
+	{ "lsio-fspi", IMX_SC_R_FSPI_0, 2, 1 },
+	{ "lsio-mu", IMX_SC_R_MU_0A, 14, 1 },
+
+	/* CONN SS */
+	{ "con-usb", IMX_SC_R_USB_0, 2, 1 },
+	{ "con-usb0phy", IMX_SC_R_USB_0_PHY, 1, 0 },
+	{ "con-usb2", IMX_SC_R_USB_2, 1, 0 },
+	{ "con-usb2phy", IMX_SC_R_USB_2_PHY, 1, 0 },
+	{ "con-sdhc", IMX_SC_R_SDHC_0, 3, 1 },
+	{ "con-enet", IMX_SC_R_ENET_0, 2, 1 },
+	{ "con-nand", IMX_SC_R_NAND, 1, 0 },
+	{ "con-mlb", IMX_SC_R_MLB_0, 1, 1 },
+
+	/* Audio DMA SS */
+	{ "adma-audio-pll0", IMX_SC_R_AUDIO_PLL_0, 1, 0 },
+	{ "adma-audio-pll1", IMX_SC_R_AUDIO_PLL_1, 1, 0 },
+	{ "adma-audio-clk-0", IMX_SC_R_AUDIO_CLK_0, 1, 0 },
+	{ "adma-dma0-ch", IMX_SC_R_DMA_0_CH0, 16, 1 },
+	{ "adma-dma1-ch", IMX_SC_R_DMA_1_CH0, 16, 1 },
+	{ "adma-dma2-ch", IMX_SC_R_DMA_2_CH0, 5, 1 },
+	{ "adma-asrc0", IMX_SC_R_ASRC_0, 1, 0 },
+	{ "adma-asrc1", IMX_SC_R_ASRC_1, 1, 0 },
+	{ "adma-esai0", IMX_SC_R_ESAI_0, 1, 0 },
+	{ "adma-spdif0", IMX_SC_R_SPDIF_0, 1, 0 },
+	{ "adma-sai", IMX_SC_R_SAI_0, 3, 1 },
+	{ "adma-amix", IMX_SC_R_AMIX, 1, 0 },
+	{ "adma-mqs0", IMX_SC_R_MQS_0, 1, 0 },
+	{ "adma-dsp", IMX_SC_R_DSP, 1, 0 },
+	{ "adma-dsp-ram", IMX_SC_R_DSP_RAM, 1, 0 },
+	{ "adma-can", IMX_SC_R_CAN_0, 3, 1 },
+	{ "adma-ftm", IMX_SC_R_FTM_0, 2, 1 },
+	{ "adma-lpi2c", IMX_SC_R_I2C_0, 4, 1 },
+	{ "adma-adc", IMX_SC_R_ADC_0, 1, 1 },
+	{ "adma-lcd", IMX_SC_R_LCD_0, 1, 1 },
+	{ "adma-lcd0-pwm", IMX_SC_R_LCD_0_PWM_0, 1, 1 },
+	{ "adma-lpuart", IMX_SC_R_UART_0, 4, 1 },
+	{ "adma-lpspi", IMX_SC_R_SPI_0, 4, 1 },
+
+	/* VPU SS  */
+	{ "vpu", IMX_SC_R_VPU, 1, 0 },
+	{ "vpu-pid", IMX_SC_R_VPU_PID0, 8, 1 },
+	{ "vpu-dec0", IMX_SC_R_VPU_DEC_0, 1, 0 },
+	{ "vpu-enc0", IMX_SC_R_VPU_ENC_0, 1, 0 },
+
+	/* GPU SS */
+	{ "gpu0-pid", IMX_SC_R_GPU_0_PID0, 4, 1 },
+
+	/* HSIO SS */
+	{ "hsio-pcie-b", IMX_SC_R_PCIE_B, 1, 0 },
+	{ "hsio-serdes-1", IMX_SC_R_SERDES_1, 1, 0 },
+	{ "hsio-gpio", IMX_SC_R_HSIO_GPIO, 1, 0 },
+
+	/* MIPI/LVDS SS */
+	{ "mipi0", IMX_SC_R_MIPI_0, 1, 0 },
+	{ "mipi0-pwm0", IMX_SC_R_MIPI_0_PWM_0, 1, 0 },
+	{ "mipi0-i2c", IMX_SC_R_MIPI_0_I2C_0, 2, 1 },
+	{ "lvds0", IMX_SC_R_LVDS_0, 1, 0 },
+
+	/* DC SS */
+	{ "dc0", IMX_SC_R_DC_0, 1, 0 },
+	{ "dc0-pll", IMX_SC_R_DC_0_PLL_0, 2, 1 },
+};
+
+static const struct imx_sc_pd_soc imx8qxp_scu_pd = {
+	.pd_ranges = imx8qxp_scu_pd_ranges,
+	.num_ranges = ARRAY_SIZE(imx8qxp_scu_pd_ranges),
+};
+
+static struct imx_sc_ipc *pm_ipc_handle;
+
+static inline struct imx_sc_pm_domain *
+to_imx_sc_pd(struct generic_pm_domain *genpd)
+{
+	return container_of(genpd, struct imx_sc_pm_domain, pd);
+}
+
+static int imx_sc_pd_power(struct generic_pm_domain *domain, bool power_on)
+{
+	struct imx_sc_msg_req_set_resource_power_mode msg;
+	struct imx_sc_rpc_msg *hdr = &msg.hdr;
+	struct imx_sc_pm_domain *pd;
+	int ret;
+
+	pd = to_imx_sc_pd(domain);
+
+	hdr->ver = IMX_SC_RPC_VERSION;
+	hdr->svc = IMX_SC_RPC_SVC_PM;
+	hdr->func = IMX_SC_PM_FUNC_SET_RESOURCE_POWER_MODE;
+	hdr->size = 2;
+
+	msg.resource = pd->rsrc;
+	msg.mode = power_on ? IMX_SC_PM_PW_MODE_ON : IMX_SC_PM_PW_MODE_LP;
+
+	ret = imx_scu_call_rpc(pm_ipc_handle, &msg, true);
+	if (ret)
+		dev_err(&domain->dev, "failed to power %s resource %d ret %d\n",
+			power_on ? "up" : "off", pd->rsrc, ret);
+
+	return ret;
+}
+
+static int imx_sc_pd_power_on(struct generic_pm_domain *domain)
+{
+	return imx_sc_pd_power(domain, true);
+}
+
+static int imx_sc_pd_power_off(struct generic_pm_domain *domain)
+{
+	return imx_sc_pd_power(domain, false);
+}
+
+static struct generic_pm_domain *imx_scu_pd_xlate(struct of_phandle_args *spec,
+						  void *data)
+{
+	struct generic_pm_domain *domain = ERR_PTR(-ENOENT);
+	struct genpd_onecell_data *pd_data = data;
+	unsigned int i;
+
+	for (i = 0; i < pd_data->num_domains; i++) {
+		struct imx_sc_pm_domain *sc_pd;
+
+		sc_pd = to_imx_sc_pd(pd_data->domains[i]);
+		if (sc_pd->rsrc == spec->args[0]) {
+			domain = &sc_pd->pd;
+			break;
+		}
+	}
+
+	return domain;
+}
+
+static struct imx_sc_pm_domain *
+imx_scu_add_pm_domain(struct device *dev, int idx,
+		      const struct imx_sc_pd_range *pd_ranges)
+{
+	struct imx_sc_pm_domain *sc_pd;
+	int ret;
+
+	sc_pd = devm_kzalloc(dev, sizeof(*sc_pd), GFP_KERNEL);
+	if (!sc_pd)
+		return ERR_PTR(-ENOMEM);
+
+	sc_pd->rsrc = pd_ranges->rsrc + idx;
+	sc_pd->pd.power_off = imx_sc_pd_power_off;
+	sc_pd->pd.power_on = imx_sc_pd_power_on;
+
+	if (pd_ranges->postfix)
+		snprintf(sc_pd->name, sizeof(sc_pd->name),
+			 "%s%i", pd_ranges->name, idx);
+	else
+		snprintf(sc_pd->name, sizeof(sc_pd->name),
+			 "%s", pd_ranges->name);
+
+	sc_pd->pd.name = sc_pd->name;
+
+	if (sc_pd->rsrc >= IMX_SC_R_LAST) {
+		dev_warn(dev, "invalid pd %s rsrc id %d found",
+			 sc_pd->name, sc_pd->rsrc);
+
+		devm_kfree(dev, sc_pd);
+		return NULL;
+	}
+
+	ret = pm_genpd_init(&sc_pd->pd, NULL, true);
+	if (ret) {
+		dev_warn(dev, "failed to init pd %s rsrc id %d",
+			 sc_pd->name, sc_pd->rsrc);
+		devm_kfree(dev, sc_pd);
+		return NULL;
+	}
+
+	return sc_pd;
+}
+
+static int imx_scu_init_pm_domains(struct device *dev,
+				    const struct imx_sc_pd_soc *pd_soc)
+{
+	const struct imx_sc_pd_range *pd_ranges = pd_soc->pd_ranges;
+	struct generic_pm_domain **domains;
+	struct genpd_onecell_data *pd_data;
+	struct imx_sc_pm_domain *sc_pd;
+	u32 count = 0;
+	int i, j;
+
+	for (i = 0; i < pd_soc->num_ranges; i++)
+		count += pd_ranges[i].num;
+
+	domains = devm_kcalloc(dev, count, sizeof(*domains), GFP_KERNEL);
+	if (!domains)
+		return -ENOMEM;
+
+	pd_data = devm_kzalloc(dev, sizeof(*pd_data), GFP_KERNEL);
+	if (!pd_data)
+		return -ENOMEM;
+
+	count = 0;
+	for (i = 0; i < pd_soc->num_ranges; i++) {
+		for (j = 0; j < pd_ranges[i].num; j++) {
+			sc_pd = imx_scu_add_pm_domain(dev, j, &pd_ranges[i]);
+			if (IS_ERR_OR_NULL(sc_pd))
+				continue;
+
+			domains[count++] = &sc_pd->pd;
+			dev_dbg(dev, "added power domain %s\n", sc_pd->pd.name);
+		}
+	}
+
+	pd_data->domains = domains;
+	pd_data->num_domains = count;
+	pd_data->xlate = imx_scu_pd_xlate;
+
+	of_genpd_add_provider_onecell(dev->of_node, pd_data);
+
+	return 0;
+}
+
+static int imx_sc_pd_probe(struct platform_device *pdev)
+{
+	const struct imx_sc_pd_soc *pd_soc;
+	int ret;
+
+	ret = imx_scu_get_handle(&pm_ipc_handle);
+	if (ret)
+		return ret;
+
+	pd_soc = of_device_get_match_data(&pdev->dev);
+	if (!pd_soc)
+		return -ENODEV;
+
+	return imx_scu_init_pm_domains(&pdev->dev, pd_soc);
+}
+
+static const struct of_device_id imx_sc_pd_match[] = {
+	{ .compatible = "fsl,imx8qxp-scu-pd", &imx8qxp_scu_pd},
+	{ /* sentinel */ }
+};
+
+static struct platform_driver imx_sc_pd_driver = {
+	.driver = {
+		.name = "imx-scu-pd",
+		.of_match_table = imx_sc_pd_match,
+	},
+	.probe = imx_sc_pd_probe,
+};
+builtin_platform_driver(imx_sc_pd_driver);
+
+MODULE_AUTHOR("Dong Aisheng <aisheng.dong@nxp.com>");
+MODULE_DESCRIPTION("IMX SCU Power Domain driver");
+MODULE_LICENSE("GPL v2");
