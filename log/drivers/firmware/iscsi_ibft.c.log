commit 8192e60c6a73f945c783d37934034eac29b5edb8
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 28 09:35:11 2020 -0500

    ibft: Replace zero-length array with flexible-array
    
    There is a regular need in the kernel to provide a way to declare having a
    dynamically sized set of trailing elements in a structure. Kernel code should
    always use “flexible array members”[1] for these cases. The older style of
    one-element or zero-length arrays should no longer be used[2].
    
    [1] https://en.wikipedia.org/wiki/Flexible_array_member
    [2] https://github.com/KSPP/linux/issues/21
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 96758b71a8db..7127a04bca19 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -104,7 +104,7 @@ struct ibft_control {
 	u16 tgt0_off;
 	u16 nic1_off;
 	u16 tgt1_off;
-	u16 expansion[0];
+	u16 expansion[];
 } __attribute__((__packed__));
 
 struct ibft_initiator {

commit c08406033fe83a4cb307f2a2e949c59bb86b4f49
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Sat Dec 21 08:09:56 2019 +0100

    iscsi_ibft: Don't limits Targets and NICs to two
    
    According to iSCSI Boot Firmware Table Version 1.03 [1], the length of
    the control table is ">= 18", where the optional expansion structure
    pointer follow the mandatory ones. This allows for more than two NICs
    and Targets.
    
    [1] ftp://ftp.software.ibm.com/systems/support/bladecenter/iscsi_boot_firmware_table_v1.03.pdf
    
    Let's enforce the minimum length of the control structure instead
    instead of limiting it to the smallest allowed size.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@darnok.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 7e12cbdf957c..96758b71a8db 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -104,6 +104,7 @@ struct ibft_control {
 	u16 tgt0_off;
 	u16 nic1_off;
 	u16 tgt1_off;
+	u16 expansion[0];
 } __attribute__((__packed__));
 
 struct ibft_initiator {
@@ -235,7 +236,7 @@ static int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)
 				"found %d instead!\n", t, id, hdr->id);
 		return -ENODEV;
 	}
-	if (hdr->length != length) {
+	if (length && hdr->length != length) {
 		printk(KERN_ERR "iBFT error: We expected the %s " \
 				"field header.length to have %d but " \
 				"found %d instead!\n", t, length, hdr->length);
@@ -749,16 +750,16 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header)
 	control = (void *)header + sizeof(*header);
 	end = (void *)control + control->hdr.length;
 	eot_offset = (void *)header + header->header.length - (void *)control;
-	rc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control,
-			     sizeof(*control));
+	rc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control, 0);
 
 	/* iBFT table safety checking */
 	rc |= ((control->hdr.index) ? -ENODEV : 0);
+	rc |= ((control->hdr.length < sizeof(*control)) ? -ENODEV : 0);
 	if (rc) {
 		printk(KERN_ERR "iBFT error: Control header is invalid!\n");
 		return rc;
 	}
-	for (ptr = &control->initiator_off; ptr < end; ptr += sizeof(u16)) {
+	for (ptr = &control->initiator_off; ptr + sizeof(u16) <= end; ptr += sizeof(u16)) {
 		offset = *(u16 *)ptr;
 		if (offset && offset < header->header.length &&
 						offset < eot_offset) {

commit 55d31aaec0da46801e7337779bb3ebe88b034ef3
Merge: 6108cd475ca8 94bccc340710
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 26 09:43:43 2019 -0700

    Merge branch 'for-linus-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/ibft
    
    Pull iscsi_ibft fix from Konrad Rzeszutek Wilk:
     "One tiny fix to enable iSCSI IBFT to be compiled under ARM"
    
    * 'for-linus-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/ibft:
      iscsi_ibft: make ISCSI_IBFT depend on ACPI instead of ISCSI_IBFT_FIND

commit 94bccc34071094c165c79b515d21b63c78f7e968
Author: Thomas Tai <thomas.tai@oracle.com>
Date:   Thu Jul 18 18:37:34 2019 +0000

    iscsi_ibft: make ISCSI_IBFT dependson ACPI instead of ISCSI_IBFT_FIND
    
    iscsi_ibft can use ACPI to find the iBFT entry during bootup,
    currently, ISCSI_IBFT depends on ISCSI_IBFT_FIND which is
    a X86 legacy way to find the iBFT by searching through the
    low memory. This patch changes the dependency so that other
    arch like ARM64 can use ISCSI_IBFT as long as the arch supports
    ACPI.
    
    ibft_init() needs to use the global variable ibft_addr declared
    in iscsi_ibft_find.c. A #ifndef CONFIG_ISCSI_IBFT_FIND is needed
    to declare the variable if CONFIG_ISCSI_IBFT_FIND is not selected.
    Moving ibft_addr into the iscsi_ibft.c does not work because if
    ISCSI_IBFT is selected as a module, the arch/x86/kernel/setup.c won't
    be able to find the variable at compile time.
    
    Signed-off-by: Thomas Tai <thomas.tai@oracle.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index c51462f5aa1e..966aef334c42 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -93,6 +93,10 @@ MODULE_DESCRIPTION("sysfs interface to BIOS iBFT information");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(IBFT_ISCSI_VERSION);
 
+#ifndef CONFIG_ISCSI_IBFT_FIND
+struct acpi_table_ibft *ibft_addr;
+#endif
+
 struct ibft_hdr {
 	u8 id;
 	u8 version;

commit d95236782b8d6535d5a9f3fce15af8e29c195b34
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:01 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 287
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license v2 0 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 23 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.115786599@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index a5dc0629f225..ab3aa3983833 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Copyright 2007-2010 Red Hat, Inc.
  *  by Peter Jones <pjones@redhat.com>
@@ -8,15 +9,6 @@
  *
  * This code exposes the iSCSI Boot Format Table to userland via sysfs.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License v2.0 as published by
- * the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Changelog:
  *
  *  06 Jan 2010 - Peter Jones <pjones@redhat.com>
@@ -63,7 +55,6 @@
  *
  *  27 Aug 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
  *   First version exposing iBFT data via a binary /sysfs. (v0.1)
- *
  */
 
 

commit 3278675567dfb901d831d46849c386a4f932905e
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:25 2019 -0700

    ACPICA: Rename nameseg length macro/define for clarity
    
    ACPICA commit 24870bd9e73d71e2a1ff0a1e94519f8f8409e57d
    
    ACPI_NAME_SIZE changed to ACPI_NAMESEG_SIZE
    This clarifies that this is the length of an individual
    nameseg, not the length of a generic namestring/namepath.
    Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/24870bd9
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index c51462f5aa1e..a5dc0629f225 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -425,7 +425,7 @@ static ssize_t ibft_attr_show_acpitbl(void *data, int type, char *buf)
 
 	switch (type) {
 	case ISCSI_BOOT_ACPITBL_SIGNATURE:
-		str += sprintf_string(str, ACPI_NAME_SIZE,
+		str += sprintf_string(str, ACPI_NAMESEG_SIZE,
 				      entry->header->header.signature);
 		break;
 	case ISCSI_BOOT_ACPITBL_OEM_ID:

commit df997abeebadaa4824271009e2d2b526a70a11cb
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Feb 11 12:43:23 2019 -0600

    iscsi_ibft: Fix missing break in switch statement
    
    Add missing break statement in order to prevent the code from falling
    through to case ISCSI_BOOT_TGT_NAME, which is unnecessary.
    
    This bug was found thanks to the ongoing efforts to enable
    -Wimplicit-fallthrough.
    
    Fixes: b33a84a38477 ("ibft: convert iscsi_ibft module to iscsi boot lib")
    Cc: stable@vger.kernel.org
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 6bc8e6640d71..c51462f5aa1e 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -542,6 +542,7 @@ static umode_t __init ibft_check_tgt_for(void *data, int type)
 	case ISCSI_BOOT_TGT_NIC_ASSOC:
 	case ISCSI_BOOT_TGT_CHAP_TYPE:
 		rc = S_IRUGO;
+		break;
 	case ISCSI_BOOT_TGT_NAME:
 		if (tgt->tgt_name_len)
 			rc = S_IRUGO;

commit cb5264be3c665f11e5bd0b9037c4f78d1d281edd
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Dec 19 00:37:43 2017 -0500

    ibft: Deprecate pci_get_bus_and_slot()
    
    pci_get_bus_and_slot() is restrictive such that it assumes domain=0 as
    where a PCI device is present. This restricts the device drivers to be
    reused for other domain numbers.
    
    Getting ready to remove pci_get_bus_and_slot() function in favor of
    pci_get_domain_bus_and_slot().
    
    We don't search for the device in other domains than zero. This is because
    on x86 platforms the BIOS executes only devices which are in domain 0.
    Furthermore, the iBFT spec doesn't have a domain id field.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Acked-by: Konrad Rzeszutek Wilk <konrad@kernel.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 14042a64bdd5..6bc8e6640d71 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -719,8 +719,9 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		* executes only devices which are in domain 0. Furthermore, the
 		* iBFT spec doesn't have a domain id field :-(
 		*/
-		pci_dev = pci_get_bus_and_slot((nic->pci_bdf & 0xff00) >> 8,
-					       (nic->pci_bdf & 0xff));
+		pci_dev = pci_get_domain_bus_and_slot(0,
+						(nic->pci_bdf & 0xff00) >> 8,
+						(nic->pci_bdf & 0xff));
 		if (pci_dev) {
 			rc = sysfs_create_link(&boot_kobj->kobj,
 					       &pci_dev->dev.kobj, "device");

commit b3c8eb50383178f3a4dcf1dc867001156da6473d
Author: David Bond <dbond@suse.com>
Date:   Wed Mar 23 21:49:26 2016 -0400

    ibft: Expose iBFT acpi header via sysfs
    
    Some ethernet adapter vendors are supplying products which support optional
    (payed license) features. On some adapters this includes a hardware iscsi
    initiator.  The same adapters in a normal (no extra licenses) mode of
    operation can be used as a software iscsi initiator.  In addition, software
    iscsi boot initiators are becoming a standard part of many vendors uefi
    implementations.  This is creating difficulties during early boot/install
    determining the proper configuration method for these adapters when they
    are used as a boot device.
    
    The attached patch creates sysfs entries to expose information from the
    acpi header of the ibft table.  This information allows for a method to
    easily determining if an ibft table was created by a ethernet card's
    firmware or the system uefi/bios.  In the case of a hardware initiator this
    information in combination with the pci vendor and device id can be used
    to ascertain any vendor specific behaviors that need to be accommodated.
    
    Reviewed-by: Lee Duncan <lduncan@suse.com>
    Signed-off-by: David Bond <dbond@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 81037e5fe301..14042a64bdd5 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -418,6 +418,31 @@ static ssize_t ibft_attr_show_target(void *data, int type, char *buf)
 	return str - buf;
 }
 
+static ssize_t ibft_attr_show_acpitbl(void *data, int type, char *buf)
+{
+	struct ibft_kobject *entry = data;
+	char *str = buf;
+
+	switch (type) {
+	case ISCSI_BOOT_ACPITBL_SIGNATURE:
+		str += sprintf_string(str, ACPI_NAME_SIZE,
+				      entry->header->header.signature);
+		break;
+	case ISCSI_BOOT_ACPITBL_OEM_ID:
+		str += sprintf_string(str, ACPI_OEM_ID_SIZE,
+				      entry->header->header.oem_id);
+		break;
+	case ISCSI_BOOT_ACPITBL_OEM_TABLE_ID:
+		str += sprintf_string(str, ACPI_OEM_TABLE_ID_SIZE,
+				      entry->header->header.oem_table_id);
+		break;
+	default:
+		break;
+	}
+
+	return str - buf;
+}
+
 static int __init ibft_check_device(void)
 {
 	int len;
@@ -576,6 +601,24 @@ static umode_t __init ibft_check_initiator_for(void *data, int type)
 	return rc;
 }
 
+static umode_t __init ibft_check_acpitbl_for(void *data, int type)
+{
+
+	umode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_ACPITBL_SIGNATURE:
+	case ISCSI_BOOT_ACPITBL_OEM_ID:
+	case ISCSI_BOOT_ACPITBL_OEM_TABLE_ID:
+		rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
 static void ibft_kobj_release(void *data)
 {
 	kfree(data);
@@ -699,6 +742,8 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 static int __init ibft_register_kobjects(struct acpi_table_ibft *header)
 {
 	struct ibft_control *control = NULL;
+	struct iscsi_boot_kobj *boot_kobj;
+	struct ibft_kobject *ibft_kobj;
 	void *ptr, *end;
 	int rc = 0;
 	u16 offset;
@@ -726,6 +771,25 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header)
 				break;
 		}
 	}
+	if (rc)
+		return rc;
+
+	ibft_kobj = kzalloc(sizeof(*ibft_kobj), GFP_KERNEL);
+	if (!ibft_kobj)
+		return -ENOMEM;
+
+	ibft_kobj->header = header;
+	ibft_kobj->hdr = NULL; /*for ibft_unregister*/
+
+	boot_kobj = iscsi_boot_create_acpitbl(boot_kset, 0,
+					ibft_kobj,
+					ibft_attr_show_acpitbl,
+					ibft_check_acpitbl_for,
+					ibft_kobj_release);
+	if (!boot_kobj)  {
+		kfree(ibft_kobj);
+		rc = -ENOMEM;
+	}
 
 	return rc;
 }
@@ -738,7 +802,7 @@ static void ibft_unregister(void)
 	list_for_each_entry_safe(boot_kobj, tmp_kobj,
 				 &boot_kset->kobj_list, list) {
 		ibft_kobj = boot_kobj->data;
-		if (ibft_kobj->hdr->id == id_nic)
+		if (ibft_kobj->hdr && ibft_kobj->hdr->id == id_nic)
 			sysfs_remove_link(&boot_kobj->kobj, "device");
 	};
 }

commit 9a99425f0736a416442525ac7b15903173888b86
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Feb 25 09:56:04 2016 -0800

    iscsi_ibft: Add prefix-len attr and display netmask
    
    The iBFT table only specifies a prefix length, not a netmask.
    And the netmask is pretty much pointless for IPv6.
    So introduce a new attribute 'prefix-len'.
    
    Some older user-space code might rely on the netmask attribute
    being present, so we should always display it.
    
    Changes from v1:
     - Combined two patches into one
    
    Changes from v2:
     - Cleaned up/corrected wording for patch description
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Lee Duncan <lduncan@suse.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 72791232e46b..81037e5fe301 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -319,6 +319,9 @@ static ssize_t ibft_attr_show_nic(void *data, int type, char *buf)
 		val = cpu_to_be32(~((1 << (32-nic->subnet_mask_prefix))-1));
 		str += sprintf(str, "%pI4", &val);
 		break;
+	case ISCSI_BOOT_ETH_PREFIX_LEN:
+		str += sprintf(str, "%d\n", nic->subnet_mask_prefix);
+		break;
 	case ISCSI_BOOT_ETH_ORIGIN:
 		str += sprintf(str, "%d\n", nic->origin);
 		break;
@@ -460,6 +463,7 @@ static umode_t ibft_check_nic_for(void *data, int type)
 		if (address_not_null(nic->ip_addr))
 			rc = S_IRUGO;
 		break;
+	case ISCSI_BOOT_ETH_PREFIX_LEN:
 	case ISCSI_BOOT_ETH_SUBNET_MASK:
 		if (nic->subnet_mask_prefix)
 			rc = S_IRUGO;

commit e6050b61df8a8765ce4e99da0b593d781c7fdfb1
Author: Chris Leech <cleech@redhat.com>
Date:   Thu May 28 12:51:51 2015 -0700

    iscsi_ibft: filter null v4-mapped v6 addresses
    
    I've had reports of UEFI platforms failing iSCSI boot in various
    configurations, that ended up being caused by network initialization
    scripts getting tripped up by unexpected null addresses (0.0.0.0) being
    reported for gateways, dhcp servers, and dns servers.
    
    The tianocore EDK2 iSCSI driver generates an iBFT table that always uses
    IPv4-mapped IPv6 addresses for the NIC structure fields.  This results
    in values that are "not present or not specified" being reported as
    ::ffff:0.0.0.0 rather than all zeros as specified.
    
    The iscsi_ibft module filters unspecified fields from the iBFT from
    sysfs, preventing userspace from using invalid values and making it easy
    to check for the presence of a value.  This currently fails in regard to
    these mapped null addresses.
    
    In order to remain consistent with how the iBFT information is exposed,
    we should accommodate the behavior of the tianocore iSCSI driver as it's
    already in the wild in a large number of servers.
    
    Tested under qemu using an OVMF build of tianocore EDK2.
    
    Signed-off-by: Chris Leech <cleech@redhat.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 071c2c969eec..72791232e46b 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -186,8 +186,20 @@ struct ibft_kobject {
 
 static struct iscsi_boot_kset *boot_kset;
 
+/* fully null address */
 static const char nulls[16];
 
+/* IPv4-mapped IPv6 ::ffff:0.0.0.0 */
+static const char mapped_nulls[16] = { 0x00, 0x00, 0x00, 0x00,
+                                       0x00, 0x00, 0x00, 0x00,
+                                       0x00, 0x00, 0xff, 0xff,
+                                       0x00, 0x00, 0x00, 0x00 };
+
+static int address_not_null(u8 *ip)
+{
+	return (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));
+}
+
 /*
  * Helper functions to parse data properly.
  */
@@ -445,7 +457,7 @@ static umode_t ibft_check_nic_for(void *data, int type)
 		rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_IP_ADDR:
-		if (memcmp(nic->ip_addr, nulls, sizeof(nic->ip_addr)))
+		if (address_not_null(nic->ip_addr))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_SUBNET_MASK:
@@ -456,21 +468,19 @@ static umode_t ibft_check_nic_for(void *data, int type)
 		rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_GATEWAY:
-		if (memcmp(nic->gateway, nulls, sizeof(nic->gateway)))
+		if (address_not_null(nic->gateway))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_PRIMARY_DNS:
-		if (memcmp(nic->primary_dns, nulls,
-			   sizeof(nic->primary_dns)))
+		if (address_not_null(nic->primary_dns))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_SECONDARY_DNS:
-		if (memcmp(nic->secondary_dns, nulls,
-			   sizeof(nic->secondary_dns)))
+		if (address_not_null(nic->secondary_dns))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_DHCP:
-		if (memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+		if (address_not_null(nic->dhcp))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_ETH_VLAN:
@@ -536,23 +546,19 @@ static umode_t __init ibft_check_initiator_for(void *data, int type)
 		rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_INI_ISNS_SERVER:
-		if (memcmp(init->isns_server, nulls,
-			   sizeof(init->isns_server)))
+		if (address_not_null(init->isns_server))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_INI_SLP_SERVER:
-		if (memcmp(init->slp_server, nulls,
-			   sizeof(init->slp_server)))
+		if (address_not_null(init->slp_server))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_INI_PRI_RADIUS_SERVER:
-		if (memcmp(init->pri_radius_server, nulls,
-			   sizeof(init->pri_radius_server)))
+		if (address_not_null(init->pri_radius_server))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_INI_SEC_RADIUS_SERVER:
-		if (memcmp(init->sec_radius_server, nulls,
-			   sizeof(init->sec_radius_server)))
+		if (address_not_null(init->sec_radius_server))
 			rc = S_IRUGO;
 		break;
 	case ISCSI_BOOT_INI_INITIATOR_NAME:

commit 629c27aa0c930b9c67188cfc625bf6cdd2af6764
Author: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Date:   Tue May 13 07:41:32 2014 -0400

    iscsi_ibft: Fix finding Broadcom specific ibft sign
    
    Search for Broadcom specific ibft sign "BIFT"
    along with other possible values on UEFI
    
    This patch is fix for regression introduced in
    “935a9fee51c945b8942be2d7b4bae069167b4886”.
    https://lkml.org/lkml/2011/12/16/353
    
    This impacts Broadcom CNA for iSCSI Boot on UEFI platform.
    
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Mike Christie <michaelc@cs.wisc.edu>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 3ee852c9925b..071c2c969eec 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -756,6 +756,7 @@ static const struct {
 	 */
 	{ ACPI_SIG_IBFT },
 	{ "iBFT" },
+	{ "BIFT" },	/* Broadcom iSCSI Offload */
 };
 
 static void __init acpi_find_ibft_region(void)

commit 587a1f1659e8b330b8738ef4901832a2b63f0bed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 23:11:19 2011 -0400

    switch ->is_visible() to returning umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 2cce44a1d7d0..3ee852c9925b 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -433,11 +433,11 @@ static int __init ibft_check_device(void)
  * Helper routiners to check to determine if the entry is valid
  * in the proper iBFT structure.
  */
-static mode_t ibft_check_nic_for(void *data, int type)
+static umode_t ibft_check_nic_for(void *data, int type)
 {
 	struct ibft_kobject *entry = data;
 	struct ibft_nic *nic = entry->nic;
-	mode_t rc = 0;
+	umode_t rc = 0;
 
 	switch (type) {
 	case ISCSI_BOOT_ETH_INDEX:
@@ -488,11 +488,11 @@ static mode_t ibft_check_nic_for(void *data, int type)
 	return rc;
 }
 
-static mode_t __init ibft_check_tgt_for(void *data, int type)
+static umode_t __init ibft_check_tgt_for(void *data, int type)
 {
 	struct ibft_kobject *entry = data;
 	struct ibft_tgt *tgt = entry->tgt;
-	mode_t rc = 0;
+	umode_t rc = 0;
 
 	switch (type) {
 	case ISCSI_BOOT_TGT_INDEX:
@@ -524,11 +524,11 @@ static mode_t __init ibft_check_tgt_for(void *data, int type)
 	return rc;
 }
 
-static mode_t __init ibft_check_initiator_for(void *data, int type)
+static umode_t __init ibft_check_initiator_for(void *data, int type)
 {
 	struct ibft_kobject *entry = data;
 	struct ibft_initiator *init = entry->initiator;
-	mode_t rc = 0;
+	umode_t rc = 0;
 
 	switch (type) {
 	case ISCSI_BOOT_INI_INDEX:

commit 935a9fee51c945b8942be2d7b4bae069167b4886
Author: Yinghai Lu <yinghai.lu@oracle.com>
Date:   Mon Dec 12 12:39:14 2011 -0800

    ibft: Fix finding IBFT ACPI table on UEFI
    
    Found one system with UEFI/iBFT, kernel does not detect the iBFT during
    iscsi_ibft module loading.
    
    Root cause: on x86 (UEFI), we are calling of find_ibft_region() much earlier
    - specifically in setup_arch() before ACPI is enabled.
    
    Try to split acpi checking code out and call that later
    
    At that time ACPI iBFT already get permanent mapped with ioremap.
    So isa_virt_to_bus() will get wrong phys from right virt address.
    We could just skip that phys address printing.
    
    For legacy one, print the found address early.
    
    -v2: update comments and description according to Konrad.
    -v3: fix problem about module use case that is found by Konrad.
    -v4: use acpi_get_table() instead of acpi_table_parse() to handle module use case that is found by Konrad again..
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index c811cb107904..2cce44a1d7d0 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -746,6 +746,37 @@ static void __exit ibft_exit(void)
 	ibft_cleanup();
 }
 
+#ifdef CONFIG_ACPI
+static const struct {
+	char *sign;
+} ibft_signs[] = {
+	/*
+	 * One spec says "IBFT", the other says "iBFT". We have to check
+	 * for both.
+	 */
+	{ ACPI_SIG_IBFT },
+	{ "iBFT" },
+};
+
+static void __init acpi_find_ibft_region(void)
+{
+	int i;
+	struct acpi_table_header *table = NULL;
+
+	if (acpi_disabled)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(ibft_signs) && !ibft_addr; i++) {
+		acpi_get_table(ibft_signs[i].sign, 0, &table);
+		ibft_addr = (struct acpi_table_ibft *)table;
+	}
+}
+#else
+static void __init acpi_find_ibft_region(void)
+{
+}
+#endif
+
 /*
  * ibft_init() - creates sysfs tree entries for the iBFT data.
  */
@@ -753,9 +784,16 @@ static int __init ibft_init(void)
 {
 	int rc = 0;
 
+	/*
+	   As on UEFI systems the setup_arch()/find_ibft_region()
+	   is called before ACPI tables are parsed and it only does
+	   legacy finding.
+	*/
+	if (!ibft_addr)
+		acpi_find_ibft_region();
+
 	if (ibft_addr) {
-		printk(KERN_INFO "iBFT detected at 0x%llx.\n",
-		       (u64)isa_virt_to_bus(ibft_addr));
+		pr_info("iBFT detected.\n");
 
 		rc = ibft_check_device();
 		if (rc)

commit f457a46f179df41b0f6d80dee33b6e629945f276
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Fri Jun 24 15:11:53 2011 -0500

    [SCSI] iscsi_ibft, be2iscsi, iscsi_boot: fix boot kobj data lifetime management
    
    be2iscsi passes the boot functions its phba object which is
    allocated in the shost, but iscsi_ibft passes in a object
    allocated for each item to display. The problem is that
    iscsi_boot_sysfs was managing the lifetime of the object
    passed in and doing a kfree on release. This causes a double
    free for be2iscsi which frees the shost in its pci_remove.
    
    This patch fixes the problem by adding a release callback
    which the drivers can call kfree or a put() type of function
    (needed for be2iscsi which will do a get/put on the shost).
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index ce33f4626957..c811cb107904 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -566,6 +566,11 @@ static mode_t __init ibft_check_initiator_for(void *data, int type)
 	return rc;
 }
 
+static void ibft_kobj_release(void *data)
+{
+	kfree(data);
+}
+
 /*
  * Helper function for ibft_register_kobjects.
  */
@@ -595,7 +600,8 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		boot_kobj = iscsi_boot_create_initiator(boot_kset, hdr->index,
 						ibft_kobj,
 						ibft_attr_show_initiator,
-						ibft_check_initiator_for);
+						ibft_check_initiator_for,
+						ibft_kobj_release);
 		if (!boot_kobj) {
 			rc = -ENOMEM;
 			goto free_ibft_obj;
@@ -610,7 +616,8 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		boot_kobj = iscsi_boot_create_ethernet(boot_kset, hdr->index,
 						       ibft_kobj,
 						       ibft_attr_show_nic,
-						       ibft_check_nic_for);
+						       ibft_check_nic_for,
+						       ibft_kobj_release);
 		if (!boot_kobj) {
 			rc = -ENOMEM;
 			goto free_ibft_obj;
@@ -625,7 +632,8 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		boot_kobj = iscsi_boot_create_target(boot_kset, hdr->index,
 						     ibft_kobj,
 						     ibft_attr_show_target,
-						     ibft_check_tgt_for);
+						     ibft_check_tgt_for,
+						     ibft_kobj_release);
 		if (!boot_kobj) {
 			rc = -ENOMEM;
 			goto free_ibft_obj;

commit 85ee7a1d39d75d23d21f3871f6dc9b87d572747a
Author: Joe Perches <joe@perches.com>
Date:   Sat Apr 23 20:38:19 2011 -0700

    treewide: cleanup continuations and remove logging message whitespace
    
    Using C line continuation inside format strings is error prone.
    Clean up the unintended whitespace introduced by misuse of \.
    Neaten correctly used line continations as well for consistency.
    
    drivers/scsi/arcmsr/arcmsr_hba.c has these errors as well,
    but arcmsr needs a lot more work and the driver should likely be
    moved to staging instead.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 6148a1c67895..ce33f4626957 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -87,8 +87,8 @@
 #define IBFT_ISCSI_VERSION "0.5.0"
 #define IBFT_ISCSI_DATE "2010-Feb-25"
 
-MODULE_AUTHOR("Peter Jones <pjones@redhat.com> and \
-Konrad Rzeszutek <ketuzsezr@darnok.org>");
+MODULE_AUTHOR("Peter Jones <pjones@redhat.com> and "
+	      "Konrad Rzeszutek <ketuzsezr@darnok.org>");
 MODULE_DESCRIPTION("sysfs interface to BIOS iBFT information");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(IBFT_ISCSI_VERSION);

commit a12415ff589ac5106e6b489f44c947b565fcb963
Author: Konrad Rzeszutek Wilk <konrad@kernel.org>
Date:   Wed Aug 11 16:35:40 2010 -0400

    ibft: Kernel oops when rmmoding iscsi_ibft with no iBFT present.
    
    We failed to check to see if actually allocated structures
    to contain the iBFT structure and went ahead to dereference it.
    
    This patch fixes the OOPS.
    
    Reported-by:  "Jayamohan Kalickal" <jayamohank@serverengines.com>  
    Tested-by: "Jayamohan Kalickal" <jayamohank@serverengines.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Signed-off-by: Peter Jones <pjones@redhat.com>
     

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 4f04ec0410a0..6148a1c67895 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -727,8 +727,10 @@ static void ibft_unregister(void)
 
 static void ibft_cleanup(void)
 {
-	ibft_unregister();
-	iscsi_boot_destroy_kset(boot_kset);
+	if (boot_kset) {
+		ibft_unregister();
+		iscsi_boot_destroy_kset(boot_kset);
+	}
 }
 
 static void __exit ibft_exit(void)

commit b33a84a384776fb2593dac4d77c72050f9e181b0
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Apr 12 18:06:18 2010 +0000

    ibft: convert iscsi_ibft module to iscsi boot lib
    
    This patch just converts the iscsi_ibft module to the
    iscsi boot sysfs lib module.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Signed-off-by: Peter Jones <pjones@redhat.com>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index b3ab24f9d78f..4f04ec0410a0 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -82,6 +82,7 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/acpi.h>
+#include <linux/iscsi_boot_sysfs.h>
 
 #define IBFT_ISCSI_VERSION "0.5.0"
 #define IBFT_ISCSI_DATE "2010-Feb-25"
@@ -169,74 +170,6 @@ enum ibft_id {
 	id_end_marker,
 };
 
-/*
- * We do not support the other types, hence the usage of NULL.
- * This maps to the enum ibft_id.
- */
-static const char *ibft_id_names[] =
-	{NULL, NULL, "initiator", "ethernet%d", "target%d", NULL, NULL};
-
-/*
- * The text attributes names for each of the kobjects.
-*/
-enum ibft_eth_properties_enum {
-	ibft_eth_index,
-	ibft_eth_flags,
-	ibft_eth_ip_addr,
-	ibft_eth_subnet_mask,
-	ibft_eth_origin,
-	ibft_eth_gateway,
-	ibft_eth_primary_dns,
-	ibft_eth_secondary_dns,
-	ibft_eth_dhcp,
-	ibft_eth_vlan,
-	ibft_eth_mac,
-	/* ibft_eth_pci_bdf - this is replaced by link to the device itself. */
-	ibft_eth_hostname,
-	ibft_eth_end_marker,
-};
-
-static const char *ibft_eth_properties[] =
-	{"index", "flags", "ip-addr", "subnet-mask", "origin", "gateway",
-	"primary-dns", "secondary-dns", "dhcp", "vlan", "mac", "hostname",
-	NULL};
-
-enum ibft_tgt_properties_enum {
-	ibft_tgt_index,
-	ibft_tgt_flags,
-	ibft_tgt_ip_addr,
-	ibft_tgt_port,
-	ibft_tgt_lun,
-	ibft_tgt_chap_type,
-	ibft_tgt_nic_assoc,
-	ibft_tgt_name,
-	ibft_tgt_chap_name,
-	ibft_tgt_chap_secret,
-	ibft_tgt_rev_chap_name,
-	ibft_tgt_rev_chap_secret,
-	ibft_tgt_end_marker,
-};
-
-static const char *ibft_tgt_properties[] =
-	{"index", "flags", "ip-addr", "port", "lun", "chap-type", "nic-assoc",
-	"target-name", "chap-name", "chap-secret", "rev-chap-name",
-	"rev-chap-name-secret", NULL};
-
-enum ibft_initiator_properties_enum {
-	ibft_init_index,
-	ibft_init_flags,
-	ibft_init_isns_server,
-	ibft_init_slp_server,
-	ibft_init_pri_radius_server,
-	ibft_init_sec_radius_server,
-	ibft_init_initiator_name,
-	ibft_init_end_marker,
-};
-
-static const char *ibft_initiator_properties[] =
-	{"index", "flags", "isns-server", "slp-server", "pri-radius-server",
-	"sec-radius-server", "initiator-name", NULL};
-
 /*
  * The kobject and attribute structures.
  */
@@ -249,29 +182,9 @@ struct ibft_kobject {
 		struct ibft_tgt *tgt;
 		struct ibft_hdr *hdr;
 	};
-	struct kobject kobj;
-	struct list_head node;
 };
 
-struct ibft_attribute {
-	struct attribute attr;
-	ssize_t (*show) (struct  ibft_kobject *entry,
-			 struct ibft_attribute *attr, char *buf);
-	union {
-		struct ibft_initiator *initiator;
-		struct ibft_nic *nic;
-		struct ibft_tgt *tgt;
-		struct ibft_hdr *hdr;
-	};
-	struct kobject *kobj;
-	int type; /* The enum of the type. This can be any value of:
-		ibft_eth_properties_enum, ibft_tgt_properties_enum,
-		or ibft_initiator_properties_enum. */
-	struct list_head node;
-};
-
-static LIST_HEAD(ibft_attr_list);
-static LIST_HEAD(ibft_kobject_list);
+static struct iscsi_boot_kset *boot_kset;
 
 static const char nulls[16];
 
@@ -310,35 +223,27 @@ static ssize_t sprintf_string(char *str, int len, char *buf)
 static int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)
 {
 	if (hdr->id != id) {
-		printk(KERN_ERR "iBFT error: We expected the " \
+		printk(KERN_ERR "iBFT error: We expected the %s " \
 				"field header.id to have %d but " \
-				"found %d instead!\n", id, hdr->id);
+				"found %d instead!\n", t, id, hdr->id);
 		return -ENODEV;
 	}
 	if (hdr->length != length) {
-		printk(KERN_ERR "iBFT error: We expected the " \
+		printk(KERN_ERR "iBFT error: We expected the %s " \
 				"field header.length to have %d but " \
-				"found %d instead!\n", length, hdr->length);
+				"found %d instead!\n", t, length, hdr->length);
 		return -ENODEV;
 	}
 
 	return 0;
 }
 
-static void ibft_release(struct kobject *kobj)
-{
-	struct ibft_kobject *ibft =
-		container_of(kobj, struct ibft_kobject, kobj);
-	kfree(ibft);
-}
-
 /*
  *  Routines for parsing the iBFT data to be human readable.
  */
-static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
-					struct ibft_attribute *attr,
-					char *buf)
+static ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_initiator *initiator = entry->initiator;
 	void *ibft_loc = entry->header;
 	char *str = buf;
@@ -346,26 +251,26 @@ static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
 	if (!initiator)
 		return 0;
 
-	switch (attr->type) {
-	case ibft_init_index:
+	switch (type) {
+	case ISCSI_BOOT_INI_INDEX:
 		str += sprintf(str, "%d\n", initiator->hdr.index);
 		break;
-	case ibft_init_flags:
+	case ISCSI_BOOT_INI_FLAGS:
 		str += sprintf(str, "%d\n", initiator->hdr.flags);
 		break;
-	case ibft_init_isns_server:
+	case ISCSI_BOOT_INI_ISNS_SERVER:
 		str += sprintf_ipaddr(str, initiator->isns_server);
 		break;
-	case ibft_init_slp_server:
+	case ISCSI_BOOT_INI_SLP_SERVER:
 		str += sprintf_ipaddr(str, initiator->slp_server);
 		break;
-	case ibft_init_pri_radius_server:
+	case ISCSI_BOOT_INI_PRI_RADIUS_SERVER:
 		str += sprintf_ipaddr(str, initiator->pri_radius_server);
 		break;
-	case ibft_init_sec_radius_server:
+	case ISCSI_BOOT_INI_SEC_RADIUS_SERVER:
 		str += sprintf_ipaddr(str, initiator->sec_radius_server);
 		break;
-	case ibft_init_initiator_name:
+	case ISCSI_BOOT_INI_INITIATOR_NAME:
 		str += sprintf_string(str, initiator->initiator_name_len,
 				      (char *)ibft_loc +
 				      initiator->initiator_name_off);
@@ -377,10 +282,9 @@ static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
 	return str - buf;
 }
 
-static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
-				  struct ibft_attribute *attr,
-				  char *buf)
+static ssize_t ibft_attr_show_nic(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_nic *nic = entry->nic;
 	void *ibft_loc = entry->header;
 	char *str = buf;
@@ -389,42 +293,42 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	if (!nic)
 		return 0;
 
-	switch (attr->type) {
-	case ibft_eth_index:
+	switch (type) {
+	case ISCSI_BOOT_ETH_INDEX:
 		str += sprintf(str, "%d\n", nic->hdr.index);
 		break;
-	case ibft_eth_flags:
+	case ISCSI_BOOT_ETH_FLAGS:
 		str += sprintf(str, "%d\n", nic->hdr.flags);
 		break;
-	case ibft_eth_ip_addr:
+	case ISCSI_BOOT_ETH_IP_ADDR:
 		str += sprintf_ipaddr(str, nic->ip_addr);
 		break;
-	case ibft_eth_subnet_mask:
+	case ISCSI_BOOT_ETH_SUBNET_MASK:
 		val = cpu_to_be32(~((1 << (32-nic->subnet_mask_prefix))-1));
 		str += sprintf(str, "%pI4", &val);
 		break;
-	case ibft_eth_origin:
+	case ISCSI_BOOT_ETH_ORIGIN:
 		str += sprintf(str, "%d\n", nic->origin);
 		break;
-	case ibft_eth_gateway:
+	case ISCSI_BOOT_ETH_GATEWAY:
 		str += sprintf_ipaddr(str, nic->gateway);
 		break;
-	case ibft_eth_primary_dns:
+	case ISCSI_BOOT_ETH_PRIMARY_DNS:
 		str += sprintf_ipaddr(str, nic->primary_dns);
 		break;
-	case ibft_eth_secondary_dns:
+	case ISCSI_BOOT_ETH_SECONDARY_DNS:
 		str += sprintf_ipaddr(str, nic->secondary_dns);
 		break;
-	case ibft_eth_dhcp:
+	case ISCSI_BOOT_ETH_DHCP:
 		str += sprintf_ipaddr(str, nic->dhcp);
 		break;
-	case ibft_eth_vlan:
+	case ISCSI_BOOT_ETH_VLAN:
 		str += sprintf(str, "%d\n", nic->vlan);
 		break;
-	case ibft_eth_mac:
+	case ISCSI_BOOT_ETH_MAC:
 		str += sprintf(str, "%pM\n", nic->mac);
 		break;
-	case ibft_eth_hostname:
+	case ISCSI_BOOT_ETH_HOSTNAME:
 		str += sprintf_string(str, nic->hostname_len,
 				      (char *)ibft_loc + nic->hostname_off);
 		break;
@@ -435,10 +339,9 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	return str - buf;
 };
 
-static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
-				     struct ibft_attribute *attr,
-				     char *buf)
+static ssize_t ibft_attr_show_target(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_tgt *tgt = entry->tgt;
 	void *ibft_loc = entry->header;
 	char *str = buf;
@@ -447,48 +350,48 @@ static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
 	if (!tgt)
 		return 0;
 
-	switch (attr->type) {
-	case ibft_tgt_index:
+	switch (type) {
+	case ISCSI_BOOT_TGT_INDEX:
 		str += sprintf(str, "%d\n", tgt->hdr.index);
 		break;
-	case ibft_tgt_flags:
+	case ISCSI_BOOT_TGT_FLAGS:
 		str += sprintf(str, "%d\n", tgt->hdr.flags);
 		break;
-	case ibft_tgt_ip_addr:
+	case ISCSI_BOOT_TGT_IP_ADDR:
 		str += sprintf_ipaddr(str, tgt->ip_addr);
 		break;
-	case ibft_tgt_port:
+	case ISCSI_BOOT_TGT_PORT:
 		str += sprintf(str, "%d\n", tgt->port);
 		break;
-	case ibft_tgt_lun:
+	case ISCSI_BOOT_TGT_LUN:
 		for (i = 0; i < 8; i++)
 			str += sprintf(str, "%x", (u8)tgt->lun[i]);
 		str += sprintf(str, "\n");
 		break;
-	case ibft_tgt_nic_assoc:
+	case ISCSI_BOOT_TGT_NIC_ASSOC:
 		str += sprintf(str, "%d\n", tgt->nic_assoc);
 		break;
-	case ibft_tgt_chap_type:
+	case ISCSI_BOOT_TGT_CHAP_TYPE:
 		str += sprintf(str, "%d\n", tgt->chap_type);
 		break;
-	case ibft_tgt_name:
+	case ISCSI_BOOT_TGT_NAME:
 		str += sprintf_string(str, tgt->tgt_name_len,
 				      (char *)ibft_loc + tgt->tgt_name_off);
 		break;
-	case ibft_tgt_chap_name:
+	case ISCSI_BOOT_TGT_CHAP_NAME:
 		str += sprintf_string(str, tgt->chap_name_len,
 				      (char *)ibft_loc + tgt->chap_name_off);
 		break;
-	case ibft_tgt_chap_secret:
+	case ISCSI_BOOT_TGT_CHAP_SECRET:
 		str += sprintf_string(str, tgt->chap_secret_len,
 				      (char *)ibft_loc + tgt->chap_secret_off);
 		break;
-	case ibft_tgt_rev_chap_name:
+	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
 		str += sprintf_string(str, tgt->rev_chap_name_len,
 				      (char *)ibft_loc +
 				      tgt->rev_chap_name_off);
 		break;
-	case ibft_tgt_rev_chap_secret:
+	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
 		str += sprintf_string(str, tgt->rev_chap_secret_len,
 				      (char *)ibft_loc +
 				      tgt->rev_chap_secret_off);
@@ -500,40 +403,6 @@ static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
 	return str - buf;
 }
 
-/*
- * The routine called for all sysfs attributes.
- */
-static ssize_t ibft_show_attribute(struct kobject *kobj,
-				    struct attribute *attr,
-				    char *buf)
-{
-	struct ibft_kobject *dev =
-		container_of(kobj, struct ibft_kobject, kobj);
-	struct ibft_attribute *ibft_attr =
-		container_of(attr, struct ibft_attribute, attr);
-	ssize_t ret = -EIO;
-	char *str = buf;
-
-	if (!capable(CAP_SYS_ADMIN))
-		return -EACCES;
-
-	if (ibft_attr->show)
-		ret = ibft_attr->show(dev, ibft_attr, str);
-
-	return ret;
-}
-
-static const struct sysfs_ops ibft_attr_ops = {
-	.show = ibft_show_attribute,
-};
-
-static struct kobj_type ibft_ktype = {
-	.release = ibft_release,
-	.sysfs_ops = &ibft_attr_ops,
-};
-
-static struct kset *ibft_kset;
-
 static int __init ibft_check_device(void)
 {
 	int len;
@@ -560,13 +429,150 @@ static int __init ibft_check_device(void)
 	return 0;
 }
 
+/*
+ * Helper routiners to check to determine if the entry is valid
+ * in the proper iBFT structure.
+ */
+static mode_t ibft_check_nic_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_nic *nic = entry->nic;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_ETH_INDEX:
+	case ISCSI_BOOT_ETH_FLAGS:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_IP_ADDR:
+		if (memcmp(nic->ip_addr, nulls, sizeof(nic->ip_addr)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_SUBNET_MASK:
+		if (nic->subnet_mask_prefix)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_ORIGIN:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_GATEWAY:
+		if (memcmp(nic->gateway, nulls, sizeof(nic->gateway)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_PRIMARY_DNS:
+		if (memcmp(nic->primary_dns, nulls,
+			   sizeof(nic->primary_dns)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_SECONDARY_DNS:
+		if (memcmp(nic->secondary_dns, nulls,
+			   sizeof(nic->secondary_dns)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_DHCP:
+		if (memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_VLAN:
+	case ISCSI_BOOT_ETH_MAC:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_HOSTNAME:
+		if (nic->hostname_off)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static mode_t __init ibft_check_tgt_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_tgt *tgt = entry->tgt;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_TGT_INDEX:
+	case ISCSI_BOOT_TGT_FLAGS:
+	case ISCSI_BOOT_TGT_IP_ADDR:
+	case ISCSI_BOOT_TGT_PORT:
+	case ISCSI_BOOT_TGT_LUN:
+	case ISCSI_BOOT_TGT_NIC_ASSOC:
+	case ISCSI_BOOT_TGT_CHAP_TYPE:
+		rc = S_IRUGO;
+	case ISCSI_BOOT_TGT_NAME:
+		if (tgt->tgt_name_len)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_TGT_CHAP_NAME:
+	case ISCSI_BOOT_TGT_CHAP_SECRET:
+		if (tgt->chap_name_len)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
+	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
+		if (tgt->rev_chap_name_len)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static mode_t __init ibft_check_initiator_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_initiator *init = entry->initiator;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_INI_INDEX:
+	case ISCSI_BOOT_INI_FLAGS:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_ISNS_SERVER:
+		if (memcmp(init->isns_server, nulls,
+			   sizeof(init->isns_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_SLP_SERVER:
+		if (memcmp(init->slp_server, nulls,
+			   sizeof(init->slp_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_PRI_RADIUS_SERVER:
+		if (memcmp(init->pri_radius_server, nulls,
+			   sizeof(init->pri_radius_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_SEC_RADIUS_SERVER:
+		if (memcmp(init->sec_radius_server, nulls,
+			   sizeof(init->sec_radius_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_INITIATOR_NAME:
+		if (init->initiator_name_len)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
 /*
  * Helper function for ibft_register_kobjects.
  */
 static int __init ibft_create_kobject(struct acpi_table_ibft *header,
-				       struct ibft_hdr *hdr,
-				       struct list_head *list)
+				      struct ibft_hdr *hdr)
 {
+	struct iscsi_boot_kobj *boot_kobj = NULL;
 	struct ibft_kobject *ibft_kobj = NULL;
 	struct ibft_nic *nic = (struct ibft_nic *)hdr;
 	struct pci_dev *pci_dev;
@@ -583,14 +589,47 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 	case id_initiator:
 		rc = ibft_verify_hdr("initiator", hdr, id_initiator,
 				     sizeof(*ibft_kobj->initiator));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_initiator(boot_kset, hdr->index,
+						ibft_kobj,
+						ibft_attr_show_initiator,
+						ibft_check_initiator_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_nic:
 		rc = ibft_verify_hdr("ethernet", hdr, id_nic,
 				     sizeof(*ibft_kobj->nic));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_ethernet(boot_kset, hdr->index,
+						       ibft_kobj,
+						       ibft_attr_show_nic,
+						       ibft_check_nic_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_target:
 		rc = ibft_verify_hdr("target", hdr, id_target,
 				     sizeof(*ibft_kobj->tgt));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_target(boot_kset, hdr->index,
+						     ibft_kobj,
+						     ibft_attr_show_target,
+						     ibft_check_tgt_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_reserved:
 	case id_control:
@@ -608,22 +647,10 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 
 	if (rc) {
 		/* Skip adding this kobject, but exit with non-fatal error. */
-		kfree(ibft_kobj);
-		goto out_invalid_struct;
-	}
-
-	ibft_kobj->kobj.kset = ibft_kset;
-
-	rc = kobject_init_and_add(&ibft_kobj->kobj, &ibft_ktype,
-				  NULL, ibft_id_names[hdr->id], hdr->index);
-
-	if (rc) {
-		kfree(ibft_kobj);
-		goto out;
+		rc = 0;
+		goto free_ibft_obj;
 	}
 
-	kobject_uevent(&ibft_kobj->kobj, KOBJ_ADD);
-
 	if (hdr->id == id_nic) {
 		/*
 		* We don't search for the device in other domains than
@@ -634,19 +661,16 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		pci_dev = pci_get_bus_and_slot((nic->pci_bdf & 0xff00) >> 8,
 					       (nic->pci_bdf & 0xff));
 		if (pci_dev) {
-			rc = sysfs_create_link(&ibft_kobj->kobj,
+			rc = sysfs_create_link(&boot_kobj->kobj,
 					       &pci_dev->dev.kobj, "device");
 			pci_dev_put(pci_dev);
 		}
 	}
+	return 0;
 
-	/* Nothing broke so lets add it to the list. */
-	list_add_tail(&ibft_kobj->node, list);
-out:
+free_ibft_obj:
+	kfree(ibft_kobj);
 	return rc;
-out_invalid_struct:
-	/* Unsupported structs are skipped. */
-	return 0;
 }
 
 /*
@@ -654,8 +678,7 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
  * found add them on the passed-in list. We do not support the other
  * fields at this point, so they are skipped.
  */
-static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
-					  struct list_head *list)
+static int __init ibft_register_kobjects(struct acpi_table_ibft *header)
 {
 	struct ibft_control *control = NULL;
 	void *ptr, *end;
@@ -680,8 +703,7 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
 		if (offset && offset < header->header.length &&
 						offset < eot_offset) {
 			rc = ibft_create_kobject(header,
-						 (void *)header + offset,
-						 list);
+						 (void *)header + offset);
 			if (rc)
 				break;
 		}
@@ -690,240 +712,28 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
 	return rc;
 }
 
-static void ibft_unregister(struct list_head *attr_list,
-			     struct list_head *kobj_list)
+static void ibft_unregister(void)
 {
-	struct ibft_kobject *data = NULL, *n;
-	struct ibft_attribute *attr = NULL, *m;
-
-	list_for_each_entry_safe(attr, m, attr_list, node) {
-		sysfs_remove_file(attr->kobj, &attr->attr);
-		list_del(&attr->node);
-		kfree(attr);
+	struct iscsi_boot_kobj *boot_kobj, *tmp_kobj;
+	struct ibft_kobject *ibft_kobj;
+
+	list_for_each_entry_safe(boot_kobj, tmp_kobj,
+				 &boot_kset->kobj_list, list) {
+		ibft_kobj = boot_kobj->data;
+		if (ibft_kobj->hdr->id == id_nic)
+			sysfs_remove_link(&boot_kobj->kobj, "device");
 	};
-	list_del_init(attr_list);
-
-	list_for_each_entry_safe(data, n, kobj_list, node) {
-		list_del(&data->node);
-		if (data->hdr->id == id_nic)
-			sysfs_remove_link(&data->kobj, "device");
-		kobject_put(&data->kobj);
-	};
-	list_del_init(kobj_list);
 }
 
-static int __init ibft_create_attribute(struct ibft_kobject *kobj_data,
-					 int type,
-					 const char *name,
-					 ssize_t (*show)(struct ibft_kobject *,
-							 struct ibft_attribute*,
-							 char *buf),
-					 struct list_head *list)
+static void ibft_cleanup(void)
 {
-	struct ibft_attribute *attr = NULL;
-	struct ibft_hdr *hdr = kobj_data->hdr;
-
-	attr = kmalloc(sizeof(*attr), GFP_KERNEL);
-	if (!attr)
-		return -ENOMEM;
-
-	attr->attr.name = name;
-	attr->attr.mode = S_IRUSR;
-
-	attr->hdr = hdr;
-	attr->show = show;
-	attr->kobj = &kobj_data->kobj;
-	attr->type = type;
-
-	list_add_tail(&attr->node, list);
-
-	return 0;
-}
-
-/*
- * Helper routiners to check to determine if the entry is valid
- * in the proper iBFT structure.
- */
-static int __init ibft_check_nic_for(struct ibft_nic *nic, int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_eth_index:
-	case ibft_eth_flags:
-		rc = 1;
-		break;
-	case ibft_eth_ip_addr:
-		if (memcmp(nic->ip_addr, nulls, sizeof(nic->ip_addr)))
-			rc = 1;
-		break;
-	case ibft_eth_subnet_mask:
-		if (nic->subnet_mask_prefix)
-			rc = 1;
-		break;
-	case ibft_eth_origin:
-		rc = 1;
-		break;
-	case ibft_eth_gateway:
-		if (memcmp(nic->gateway, nulls, sizeof(nic->gateway)))
-			rc = 1;
-		break;
-	case ibft_eth_primary_dns:
-		if (memcmp(nic->primary_dns, nulls,
-			   sizeof(nic->primary_dns)))
-			rc = 1;
-		break;
-	case ibft_eth_secondary_dns:
-		if (memcmp(nic->secondary_dns, nulls,
-			   sizeof(nic->secondary_dns)))
-			rc = 1;
-		break;
-	case ibft_eth_dhcp:
-		if (memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
-			rc = 1;
-		break;
-	case ibft_eth_vlan:
-	case ibft_eth_mac:
-		rc = 1;
-		break;
-	case ibft_eth_hostname:
-		if (nic->hostname_off)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
+	ibft_unregister();
+	iscsi_boot_destroy_kset(boot_kset);
 }
 
-static int __init ibft_check_tgt_for(struct ibft_tgt *tgt, int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_tgt_index:
-	case ibft_tgt_flags:
-	case ibft_tgt_ip_addr:
-	case ibft_tgt_port:
-	case ibft_tgt_lun:
-	case ibft_tgt_nic_assoc:
-	case ibft_tgt_chap_type:
-		rc = 1;
-	case ibft_tgt_name:
-		if (tgt->tgt_name_len)
-			rc = 1;
-		break;
-	case ibft_tgt_chap_name:
-	case ibft_tgt_chap_secret:
-		if (tgt->chap_name_len)
-			rc = 1;
-		break;
-	case ibft_tgt_rev_chap_name:
-	case ibft_tgt_rev_chap_secret:
-		if (tgt->rev_chap_name_len)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
-}
-
-static int __init ibft_check_initiator_for(struct ibft_initiator *init,
-					    int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_init_index:
-	case ibft_init_flags:
-		rc = 1;
-		break;
-	case ibft_init_isns_server:
-		if (memcmp(init->isns_server, nulls,
-			   sizeof(init->isns_server)))
-			rc = 1;
-		break;
-	case ibft_init_slp_server:
-		if (memcmp(init->slp_server, nulls,
-			   sizeof(init->slp_server)))
-			rc = 1;
-		break;
-	case ibft_init_pri_radius_server:
-		if (memcmp(init->pri_radius_server, nulls,
-			   sizeof(init->pri_radius_server)))
-			rc = 1;
-		break;
-	case ibft_init_sec_radius_server:
-		if (memcmp(init->sec_radius_server, nulls,
-			   sizeof(init->sec_radius_server)))
-			rc = 1;
-		break;
-	case ibft_init_initiator_name:
-		if (init->initiator_name_len)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
-}
-
-/*
- *  Register the attributes for all of the kobjects.
- */
-static int __init ibft_register_attributes(struct list_head *kobject_list,
-					    struct list_head *attr_list)
+static void __exit ibft_exit(void)
 {
-	int rc = 0, i = 0;
-	struct ibft_kobject *data = NULL;
-	struct ibft_attribute *attr = NULL, *m;
-
-	list_for_each_entry(data, kobject_list, node) {
-		switch (data->hdr->id) {
-		case id_nic:
-			for (i = 0; i < ibft_eth_end_marker && !rc; i++)
-				if (ibft_check_nic_for(data->nic, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_eth_properties[i],
-						ibft_attr_show_nic, attr_list);
-			break;
-		case id_target:
-			for (i = 0; i < ibft_tgt_end_marker && !rc; i++)
-				if (ibft_check_tgt_for(data->tgt, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_tgt_properties[i],
-						ibft_attr_show_target,
-						attr_list);
-			break;
-		case id_initiator:
-			for (i = 0; i < ibft_init_end_marker && !rc; i++)
-				if (ibft_check_initiator_for(
-					data->initiator, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_initiator_properties[i],
-						ibft_attr_show_initiator,
-						attr_list);
-			break;
-		default:
-			break;
-		}
-		if (rc)
-			break;
-	}
-	list_for_each_entry_safe(attr, m, attr_list, node) {
-		rc = sysfs_create_file(attr->kobj, &attr->attr);
-		if (rc) {
-			list_del(&attr->node);
-			kfree(attr);
-			break;
-		}
-	}
-
-	return rc;
+	ibft_cleanup();
 }
 
 /*
@@ -933,26 +743,20 @@ static int __init ibft_init(void)
 {
 	int rc = 0;
 
-	ibft_kset = kset_create_and_add("ibft", NULL, firmware_kobj);
-	if (!ibft_kset)
-		return -ENOMEM;
-
 	if (ibft_addr) {
 		printk(KERN_INFO "iBFT detected at 0x%llx.\n",
 		       (u64)isa_virt_to_bus(ibft_addr));
 
 		rc = ibft_check_device();
 		if (rc)
-			goto out_firmware_unregister;
+			return rc;
 
-		/* Scan the IBFT for data and register the kobjects. */
-		rc = ibft_register_kobjects(ibft_addr, &ibft_kobject_list);
-		if (rc)
-			goto out_free;
+		boot_kset = iscsi_boot_create_kset("ibft");
+		if (!boot_kset)
+			return -ENOMEM;
 
-		/* Register the attributes */
-		rc = ibft_register_attributes(&ibft_kobject_list,
-					      &ibft_attr_list);
+		/* Scan the IBFT for data and register the kobjects. */
+		rc = ibft_register_kobjects(ibft_addr);
 		if (rc)
 			goto out_free;
 	} else
@@ -961,17 +765,9 @@ static int __init ibft_init(void)
 	return 0;
 
 out_free:
-	ibft_unregister(&ibft_attr_list, &ibft_kobject_list);
-out_firmware_unregister:
-	kset_unregister(ibft_kset);
+	ibft_cleanup();
 	return rc;
 }
 
-static void __exit ibft_exit(void)
-{
-	ibft_unregister(&ibft_attr_list, &ibft_kobject_list);
-	kset_unregister(ibft_kset);
-}
-
 module_init(ibft_init);
 module_exit(ibft_exit);

commit 4e639fdf0d0d745648aa62228ab8a0d9c03a563f
Author: Peter Jones <pjones@redhat.com>
Date:   Thu Feb 25 15:37:17 2010 -0500

    ibft: Update iBFT handling for v1.03 of the spec.
    
    - Use struct acpi_table_ibft instead of struct ibft_table_header
    - Don't do reserve_ibft_region() on UEFI machines (section 1.4.3.1)
    - If ibft_addr isn't initialized when ibft_init() is called, check for
      ACPI-based tables.
    - Fix compiler error when CONFIG_ACPI is not defined.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index ed2801c378de..b3ab24f9d78f 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2007 Red Hat, Inc.
+ *  Copyright 2007-2010 Red Hat, Inc.
  *  by Peter Jones <pjones@redhat.com>
  *  Copyright 2008 IBM, Inc.
  *  by Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
@@ -19,6 +19,9 @@
  *
  * Changelog:
  *
+ *  06 Jan 2010 - Peter Jones <pjones@redhat.com>
+ *    New changelog entries are in the git log from now on.  Not here.
+ *
  *  14 Mar 2008 - Konrad Rzeszutek <ketuzsezr@darnok.org>
  *    Updated comments and copyrights. (v0.4.9)
  *
@@ -78,9 +81,10 @@
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#include <linux/acpi.h>
 
-#define IBFT_ISCSI_VERSION "0.4.9"
-#define IBFT_ISCSI_DATE "2008-Mar-14"
+#define IBFT_ISCSI_VERSION "0.5.0"
+#define IBFT_ISCSI_DATE "2010-Feb-25"
 
 MODULE_AUTHOR("Peter Jones <pjones@redhat.com> and \
 Konrad Rzeszutek <ketuzsezr@darnok.org>");
@@ -238,7 +242,7 @@ static const char *ibft_initiator_properties[] =
  */
 
 struct ibft_kobject {
-	struct ibft_table_header *header;
+	struct acpi_table_ibft *header;
 	union {
 		struct ibft_initiator *initiator;
 		struct ibft_nic *nic;
@@ -536,12 +540,13 @@ static int __init ibft_check_device(void)
 	u8 *pos;
 	u8 csum = 0;
 
-	len = ibft_addr->length;
+	len = ibft_addr->header.length;
 
 	/* Sanity checking of iBFT. */
-	if (ibft_addr->revision != 1) {
+	if (ibft_addr->header.revision != 1) {
 		printk(KERN_ERR "iBFT module supports only revision 1, " \
-				"while this is %d.\n", ibft_addr->revision);
+				"while this is %d.\n",
+				ibft_addr->header.revision);
 		return -ENOENT;
 	}
 	for (pos = (u8 *)ibft_addr; pos < (u8 *)ibft_addr + len; pos++)
@@ -558,7 +563,7 @@ static int __init ibft_check_device(void)
 /*
  * Helper function for ibft_register_kobjects.
  */
-static int __init ibft_create_kobject(struct ibft_table_header *header,
+static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 				       struct ibft_hdr *hdr,
 				       struct list_head *list)
 {
@@ -596,7 +601,7 @@ static int __init ibft_create_kobject(struct ibft_table_header *header,
 	default:
 		printk(KERN_ERR "iBFT has unknown structure type (%d). " \
 				"Report this bug to %.6s!\n", hdr->id,
-				header->oem_id);
+				header->header.oem_id);
 		rc = 1;
 		break;
 	}
@@ -649,7 +654,7 @@ static int __init ibft_create_kobject(struct ibft_table_header *header,
  * found add them on the passed-in list. We do not support the other
  * fields at this point, so they are skipped.
  */
-static int __init ibft_register_kobjects(struct ibft_table_header *header,
+static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
 					  struct list_head *list)
 {
 	struct ibft_control *control = NULL;
@@ -660,7 +665,7 @@ static int __init ibft_register_kobjects(struct ibft_table_header *header,
 
 	control = (void *)header + sizeof(*header);
 	end = (void *)control + control->hdr.length;
-	eot_offset = (void *)header + header->length - (void *)control;
+	eot_offset = (void *)header + header->header.length - (void *)control;
 	rc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control,
 			     sizeof(*control));
 
@@ -672,7 +677,8 @@ static int __init ibft_register_kobjects(struct ibft_table_header *header,
 	}
 	for (ptr = &control->initiator_off; ptr < end; ptr += sizeof(u16)) {
 		offset = *(u16 *)ptr;
-		if (offset && offset < header->length && offset < eot_offset) {
+		if (offset && offset < header->header.length &&
+						offset < eot_offset) {
 			rc = ibft_create_kobject(header,
 						 (void *)header + offset,
 						 list);

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index a3600e3ed0fa..ed2801c378de 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -519,7 +519,7 @@ static ssize_t ibft_show_attribute(struct kobject *kobj,
 	return ret;
 }
 
-static struct sysfs_ops ibft_attr_ops = {
+static const struct sysfs_ops ibft_attr_ops = {
 	.show = ibft_show_attribute,
 };
 

commit 47871889c601d8199c51a4086f77eebd77c29b0b
Merge: c16cc0b464b8 30ff056c42c6
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Feb 28 19:23:06 2010 -0800

    Merge branch 'master' of /home/davem/src/GIT/linux-2.6/
    
    Conflicts:
            drivers/firmware/iscsi_ibft.c

commit 00e7825b943f486e80ff1305cd0594d8791870f8
Author: Joe Perches <joe@perches.com>
Date:   Thu Jan 14 11:34:19 2010 -0500

    drivers/firmware/iscsi_ibft.c: remove NIPQUAD_FMT, use %pI4
    
    Convert netmask to __be32 and format it with %pI4
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Konrad Rzeszutek <ketuzsezr@darnok.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 051d1ebbd287..f82bcdae130b 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -381,7 +381,7 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	void *ibft_loc = entry->header;
 	char *str = buf;
 	char *mac;
-	int val;
+	__be32 val;
 
 	if (!nic)
 		return 0;
@@ -397,10 +397,8 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 		str += sprintf_ipaddr(str, nic->ip_addr);
 		break;
 	case ibft_eth_subnet_mask:
-		val = ~((1 << (32-nic->subnet_mask_prefix))-1);
-		str += sprintf(str, NIPQUAD_FMT,
-			       (u8)(val >> 24), (u8)(val >> 16),
-			       (u8)(val >> 8), (u8)(val));
+		val = cpu_to_be32(~((1 << (32-nic->subnet_mask_prefix))-1));
+		str += sprintf(str, "%pI4", &val);
 		break;
 	case ibft_eth_origin:
 		str += sprintf(str, "%d\n", nic->origin);

commit 2c35294853b2e977bdfc9e401b7b6d881fcaa69b
Author: hartleys <hartleys@visionengravers.com>
Date:   Tue Jan 5 06:37:43 2010 +0000

    drivers/firmware/iscsi_ibft.c: use %pM to show MAC address
    
    Use the %pM kernel extension to display the MAC address.
    
    Also, remove the 'mac' variable and use nic->mac directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Peter Jones <pjones@redhat.com>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 051d1ebbd287..5aeb3b541c80 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -380,7 +380,6 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	struct ibft_nic *nic = entry->nic;
 	void *ibft_loc = entry->header;
 	char *str = buf;
-	char *mac;
 	int val;
 
 	if (!nic)
@@ -421,10 +420,7 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 		str += sprintf(str, "%d\n", nic->vlan);
 		break;
 	case ibft_eth_mac:
-		mac = nic->mac;
-		str += sprintf(str, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-			       (u8)mac[0], (u8)mac[1], (u8)mac[2],
-			       (u8)mac[3], (u8)mac[4], (u8)mac[5]);
+		str += sprintf(str, "%pM\n", nic->mac);
 		break;
 	case ibft_eth_hostname:
 		str += sprintf_string(str, nic->hostname_len,

commit ed3c661448a1b4b0b07c0a0d3c6e8a19c7d0ffd7
Author: Jan Beulich <JBeulich@novell.com>
Date:   Fri Oct 2 16:12:39 2009 +0100

    iSCSI/iBFT: use proper address translation
    
    In virtual environments (namely, Xen Dom0) virt <-> phys and
    virt <-> isa-bus translations cannot be freely interchanged (and
    even outside such environments it is not really correct to do so).
    When looking at memory below 1M, the latter translations should
    always be used.
    
    iscsi_ibft_find.c part from: Martin Wilck <martin.wilck@ts.fujitsu.com>.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <ketuzsezs@darnok.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 420a96e7f2db..051d1ebbd287 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -939,7 +939,7 @@ static int __init ibft_init(void)
 
 	if (ibft_addr) {
 		printk(KERN_INFO "iBFT detected at 0x%llx.\n",
-		       (u64)virt_to_phys((void *)ibft_addr));
+		       (u64)isa_virt_to_bus(ibft_addr));
 
 		rc = ibft_check_device();
 		if (rc)

commit 65fd21058a791f35aff11eeccd2e270f0faf11ec
Author: Ashutosh Naik <ashutosh.naik@gmail.com>
Date:   Thu Apr 30 15:08:58 2009 -0700

    ibft: fix the display of a few fields in the NIC attribute structure in sysfs
    
    Fix the display of a few fields in the iBFT NIC attribute structure in
    sysfs.
    
    Ensure that, if the DHCP IP address and the subnet mask for the interface
    is present in the iBFT NIC structure, the corresponding entries are
    created in sysfs tree for the device.  This would hence create the
    additional entries in the tree based on the iBFT table and would not
    delete any existing entries.
    
    Signed-off-by: Ashutosh Naik <ashutosh.naik@gmail.com>
    Cc: Vishnu V <vishnu@chelsio.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 7b7ddc2d51c9..420a96e7f2db 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -754,11 +754,11 @@ static int __init ibft_check_nic_for(struct ibft_nic *nic, int entry)
 		rc = 1;
 		break;
 	case ibft_eth_ip_addr:
-		if (!memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+		if (memcmp(nic->ip_addr, nulls, sizeof(nic->ip_addr)))
 			rc = 1;
 		break;
 	case ibft_eth_subnet_mask:
-		if (!memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+		if (nic->subnet_mask_prefix)
 			rc = 1;
 		break;
 	case ibft_eth_origin:

commit f537a53da9389f56df277057684df23997410e9c
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Wed Feb 11 23:51:34 2009 +0530

    iscsi_ibft.c fix compilation warning
    
     drivers/firmware/iscsi_ibft.c: In function ‘ibft_init’:
     drivers/firmware/iscsi_ibft.c:942: warning: format ‘%lx’ expects type ‘long unsigned int’, but argument 2 has type ‘phys_addr_t’
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 3ab3e4a41d67..7b7ddc2d51c9 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -938,8 +938,8 @@ static int __init ibft_init(void)
 		return -ENOMEM;
 
 	if (ibft_addr) {
-		printk(KERN_INFO "iBFT detected at 0x%lx.\n",
-		       virt_to_phys((void *)ibft_addr));
+		printk(KERN_INFO "iBFT detected at 0x%llx.\n",
+		       (u64)virt_to_phys((void *)ibft_addr));
 
 		rc = ibft_check_device();
 		if (rc)

commit 63779436ab4ad0867bcea53bf853b0004d7b895d
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Oct 31 00:56:00 2008 -0700

    drivers: replace NIPQUAD()
    
    Using NIPQUAD() with NIPQUAD_FMT, %d.%d.%d.%d or %u.%u.%u.%u
    can be replaced with %pI4
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index acb82aff8808..3ab3e4a41d67 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -284,8 +284,7 @@ static ssize_t sprintf_ipaddr(char *buf, u8 *ip)
 		/*
 		 * IPV4
 		 */
-		str += sprintf(buf, NIPQUAD_FMT, ip[12],
-			       ip[13], ip[14], ip[15]);
+		str += sprintf(buf, "%pI4", ip + 12);
 	} else {
 		/*
 		 * IPv6

commit 5b095d98928fdb9e3b75be20a54b7a6cbf6ca9ad
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Oct 29 12:52:50 2008 -0700

    net: replace %p6 with %pI6
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 0a6472097a81..acb82aff8808 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -290,7 +290,7 @@ static ssize_t sprintf_ipaddr(char *buf, u8 *ip)
 		/*
 		 * IPv6
 		 */
-		str += sprintf(str, "%p6", ip);
+		str += sprintf(str, "%pI6", ip);
 	}
 	str += sprintf(str, "\n");
 	return str - buf;

commit 1afa67f5e70b4733d5b237df61e6d639af6283bb
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Tue Oct 28 16:06:44 2008 -0700

    misc: replace NIP6_FMT with %p6 format specifier
    
    The iscsi_ibft.c changes are almost certainly a bugfix as the
    pointer 'ip' is a u8 *, so they never print the last 8 bytes
    of the IPv6 address, and the eight bytes they do print have
    a zero byte with them in each 16-bit word.
    
    Other than that, this should cause no difference in functionality.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 4353414a0b77..0a6472097a81 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -290,9 +290,7 @@ static ssize_t sprintf_ipaddr(char *buf, u8 *ip)
 		/*
 		 * IPv6
 		 */
-		str += sprintf(str, NIP6_FMT, ntohs(ip[0]), ntohs(ip[1]),
-			       ntohs(ip[2]), ntohs(ip[3]), ntohs(ip[4]),
-			       ntohs(ip[5]), ntohs(ip[6]), ntohs(ip[7]));
+		str += sprintf(str, "%p6", ip);
 	}
 	str += sprintf(str, "\n");
 	return str - buf;

commit 01e8ef11bc1a74e65678ed55795f59266d4add01
Author: Parag Warudkar <parag.lkml@gmail.com>
Date:   Sat Oct 18 20:28:50 2008 -0700

    x86: sysfs: kill owner field from attribute
    
    Tejun's commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15 made sysfs
    attribute->owner unnecessary.  But the field was left in the structure to
    ease the merge.  It's been over a year since that change and it is now
    time to start killing attribute->owner along with its users - one arch at
    a time!
    
    This patch is attempt #1 to get rid of attribute->owner only for
    CONFIG_X86_64 or CONFIG_X86_32 .  We will deal with other arches later on
    as and when possible - avr32 will be the next since that is something I
    can test.  Compile (make allyesconfig / make allmodconfig / custom config)
    and boot tested.
    
    akpm: the idea is that we put the declaration of sttribute.owner inside
    `#ifndef CONFIG_X86'.  But that proved to be too ambitious for now because
    new usages kept on turning up in subsystem trees.
    
    [akpm: remove the ifdef for now]
    Signed-off-by: Parag Warudkar <parag.lkml@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index deb154aa47c4..4353414a0b77 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -732,7 +732,6 @@ static int __init ibft_create_attribute(struct ibft_kobject *kobj_data,
 
 	attr->attr.name = name;
 	attr->attr.mode = S_IRUSR;
-	attr->attr.owner = THIS_MODULE;
 
 	attr->hdr = hdr;
 	attr->show = show;

commit 9cf899d12583082c77a0fcc758f3179b440518ee
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Aug 12 15:43:59 2008 -0400

    drivers/firmware/iscsi_ibft.c: make 3 functions static
    
    This patch makes the following needlessly global functions static:
    - ibft_attr_show_initiator()
    - ibft_attr_show_nic()
    - ibft_attr_show_target()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Konrad Rzeszutek <ketuzsezr@darnok.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index b91ef63126ed..deb154aa47c4 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -334,9 +334,9 @@ static void ibft_release(struct kobject *kobj)
 /*
  *  Routines for parsing the iBFT data to be human readable.
  */
-ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
-				  struct ibft_attribute *attr,
-				  char *buf)
+static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
+					struct ibft_attribute *attr,
+					char *buf)
 {
 	struct ibft_initiator *initiator = entry->initiator;
 	void *ibft_loc = entry->header;
@@ -376,9 +376,9 @@ ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
 	return str - buf;
 }
 
-ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
-			    struct ibft_attribute *attr,
-			    char *buf)
+static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
+				  struct ibft_attribute *attr,
+				  char *buf)
 {
 	struct ibft_nic *nic = entry->nic;
 	void *ibft_loc = entry->header;
@@ -440,9 +440,9 @@ ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	return str - buf;
 };
 
-ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
-			       struct ibft_attribute *attr,
-			       char *buf)
+static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
+				     struct ibft_attribute *attr,
+				     char *buf)
 {
 	struct ibft_tgt *tgt = entry->tgt;
 	void *ibft_loc = entry->header;

commit bb8fb4e6840ecebdc61f7ebd0653187e7128dde5
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Tue Sep 2 14:36:07 2008 -0700

    ibft: fix target info parsing in ibft module
    
    I got this patch through Red Hat's bugzilla from the bug submitter and
    patch creator.  I have just fixed it up so it applies without fuzz to
    upstream kernels.
    
    Original patch and description from Shyam kumar Iyer:
    
    The issue [ibft module not displaying targets with short names] is because
    of an offset calculatation error in the iscsi_ibft.c code.  Due to this
    error directory structure for the target in /sys/firmware/ibft does not
    get created and so the initiator is unable to connect to the target.
    
    Note that this bug surfaced only with an name that had a short section at
    the end.  eg: "iqn.1984-05.com.dell:dell".  It did not surface when the
    iqn's had a longer section at the end.  eg:
    "iqn.2001-04.com.example:storage.disk2.sys1.xyz"
    
    So, the eot_offset was calculated such that an extra 48 bytes i.e.  the
    size of the ibft_header which has already been accounted was subtracted
    twice.
    
    This was not evident with longer iqn names because they would overshoot
    the total ibft length more than 48 bytes and thus would escape the bug.
    
    Signed-off-by: Shyam Kumar Iyer <shyam_iyer@dell.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Konrad Rzeszutek <konrad@virtualiron.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 8024e3bfd877..b91ef63126ed 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -669,8 +669,7 @@ static int __init ibft_register_kobjects(struct ibft_table_header *header,
 
 	control = (void *)header + sizeof(*header);
 	end = (void *)control + control->hdr.length;
-	eot_offset = (void *)header + header->length -
-		     (void *)control - sizeof(*header);
+	eot_offset = (void *)header + header->length - (void *)control;
 	rc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control,
 			     sizeof(*control));
 

commit 138fe4e069798d9aa948a5402ff15e58f483ee4e
Author: Konrad Rzeszutek <ketuzsezr@darnok.org>
Date:   Wed Apr 9 19:50:41 2008 -0700

    Firmware: add iSCSI iBFT Support
    
    Add /sysfs/firmware/ibft/[initiator|targetX|ethernetX] directories along with
    text properties which export the the iSCSI Boot Firmware Table (iBFT)
    structure.
    
    What is iSCSI Boot Firmware Table?  It is a mechanism for the iSCSI tools to
    extract from the machine NICs the iSCSI connection information so that they
    can automagically mount the iSCSI share/target.  Currently the iSCSI
    information is hard-coded in the initrd.  The /sysfs entries are read-only
    one-name-and-value fields.
    
    The usual set of data exposed is:
    
    # for a in `find /sys/firmware/ibft/ -type f -print`; do  echo -n "$a: ";  cat $a; done
    /sys/firmware/ibft/target0/target-name: iqn.2007.com.intel-sbx44:storage-10gb
    /sys/firmware/ibft/target0/nic-assoc: 0
    /sys/firmware/ibft/target0/chap-type: 0
    /sys/firmware/ibft/target0/lun: 00000000
    /sys/firmware/ibft/target0/port: 3260
    /sys/firmware/ibft/target0/ip-addr: 192.168.79.116
    /sys/firmware/ibft/target0/flags: 3
    /sys/firmware/ibft/target0/index: 0
    /sys/firmware/ibft/ethernet0/mac: 00:11:25:9d:8b:01
    /sys/firmware/ibft/ethernet0/vlan: 0
    /sys/firmware/ibft/ethernet0/gateway: 192.168.79.254
    /sys/firmware/ibft/ethernet0/origin: 0
    /sys/firmware/ibft/ethernet0/subnet-mask: 255.255.252.0
    /sys/firmware/ibft/ethernet0/ip-addr: 192.168.77.41
    /sys/firmware/ibft/ethernet0/flags: 7
    /sys/firmware/ibft/ethernet0/index: 0
    /sys/firmware/ibft/initiator/initiator-name: iqn.2007-07.com:konrad.initiator
    /sys/firmware/ibft/initiator/flags: 3
    /sys/firmware/ibft/initiator/index: 0
    
    For full details of the IBFT structure please take a look at:
    ftp://ftp.software.ibm.com/systems/support/system_x_pdf/ibm_iscsi_boot_firmware_table_v1.02.pdf
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
new file mode 100644
index 000000000000..8024e3bfd877
--- /dev/null
+++ b/drivers/firmware/iscsi_ibft.c
@@ -0,0 +1,982 @@
+/*
+ *  Copyright 2007 Red Hat, Inc.
+ *  by Peter Jones <pjones@redhat.com>
+ *  Copyright 2008 IBM, Inc.
+ *  by Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *  Copyright 2008
+ *  by Konrad Rzeszutek <ketuzsezr@darnok.org>
+ *
+ * This code exposes the iSCSI Boot Format Table to userland via sysfs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License v2.0 as published by
+ * the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Changelog:
+ *
+ *  14 Mar 2008 - Konrad Rzeszutek <ketuzsezr@darnok.org>
+ *    Updated comments and copyrights. (v0.4.9)
+ *
+ *  11 Feb 2008 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *    Converted to using ibft_addr. (v0.4.8)
+ *
+ *   8 Feb 2008 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *    Combined two functions in one: reserve_ibft_region. (v0.4.7)
+ *
+ *  30 Jan 2008 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added logic to handle IPv6 addresses. (v0.4.6)
+ *
+ *  25 Jan 2008 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added logic to handle badly not-to-spec iBFT. (v0.4.5)
+ *
+ *   4 Jan 2008 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added __init to function declarations. (v0.4.4)
+ *
+ *  21 Dec 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Updated kobject registration, combined unregister functions in one
+ *   and code and style cleanup. (v0.4.3)
+ *
+ *   5 Dec 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added end-markers to enums and re-organized kobject registration. (v0.4.2)
+ *
+ *   4 Dec 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Created 'device' sysfs link to the NIC and style cleanup. (v0.4.1)
+ *
+ *  28 Nov 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added sysfs-ibft documentation, moved 'find_ibft' function to
+ *   in its own file and added text attributes for every struct field.  (v0.4)
+ *
+ *  21 Nov 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added text attributes emulating OpenFirmware /proc/device-tree naming.
+ *   Removed binary /sysfs interface (v0.3)
+ *
+ *  29 Aug 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   Added functionality in setup.c to reserve iBFT region. (v0.2)
+ *
+ *  27 Aug 2007 - Konrad Rzeszutek <konradr@linux.vnet.ibm.com>
+ *   First version exposing iBFT data via a binary /sysfs. (v0.1)
+ *
+ */
+
+
+#include <linux/blkdev.h>
+#include <linux/capability.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/iscsi_ibft.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#define IBFT_ISCSI_VERSION "0.4.9"
+#define IBFT_ISCSI_DATE "2008-Mar-14"
+
+MODULE_AUTHOR("Peter Jones <pjones@redhat.com> and \
+Konrad Rzeszutek <ketuzsezr@darnok.org>");
+MODULE_DESCRIPTION("sysfs interface to BIOS iBFT information");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(IBFT_ISCSI_VERSION);
+
+struct ibft_hdr {
+	u8 id;
+	u8 version;
+	u16 length;
+	u8 index;
+	u8 flags;
+} __attribute__((__packed__));
+
+struct ibft_control {
+	struct ibft_hdr hdr;
+	u16 extensions;
+	u16 initiator_off;
+	u16 nic0_off;
+	u16 tgt0_off;
+	u16 nic1_off;
+	u16 tgt1_off;
+} __attribute__((__packed__));
+
+struct ibft_initiator {
+	struct ibft_hdr hdr;
+	char isns_server[16];
+	char slp_server[16];
+	char pri_radius_server[16];
+	char sec_radius_server[16];
+	u16 initiator_name_len;
+	u16 initiator_name_off;
+} __attribute__((__packed__));
+
+struct ibft_nic {
+	struct ibft_hdr hdr;
+	char ip_addr[16];
+	u8 subnet_mask_prefix;
+	u8 origin;
+	char gateway[16];
+	char primary_dns[16];
+	char secondary_dns[16];
+	char dhcp[16];
+	u16 vlan;
+	char mac[6];
+	u16 pci_bdf;
+	u16 hostname_len;
+	u16 hostname_off;
+} __attribute__((__packed__));
+
+struct ibft_tgt {
+	struct ibft_hdr hdr;
+	char ip_addr[16];
+	u16 port;
+	char lun[8];
+	u8 chap_type;
+	u8 nic_assoc;
+	u16 tgt_name_len;
+	u16 tgt_name_off;
+	u16 chap_name_len;
+	u16 chap_name_off;
+	u16 chap_secret_len;
+	u16 chap_secret_off;
+	u16 rev_chap_name_len;
+	u16 rev_chap_name_off;
+	u16 rev_chap_secret_len;
+	u16 rev_chap_secret_off;
+} __attribute__((__packed__));
+
+/*
+ * The kobject different types and its names.
+ *
+*/
+enum ibft_id {
+	id_reserved = 0, /* We don't support. */
+	id_control = 1, /* Should show up only once and is not exported. */
+	id_initiator = 2,
+	id_nic = 3,
+	id_target = 4,
+	id_extensions = 5, /* We don't support. */
+	id_end_marker,
+};
+
+/*
+ * We do not support the other types, hence the usage of NULL.
+ * This maps to the enum ibft_id.
+ */
+static const char *ibft_id_names[] =
+	{NULL, NULL, "initiator", "ethernet%d", "target%d", NULL, NULL};
+
+/*
+ * The text attributes names for each of the kobjects.
+*/
+enum ibft_eth_properties_enum {
+	ibft_eth_index,
+	ibft_eth_flags,
+	ibft_eth_ip_addr,
+	ibft_eth_subnet_mask,
+	ibft_eth_origin,
+	ibft_eth_gateway,
+	ibft_eth_primary_dns,
+	ibft_eth_secondary_dns,
+	ibft_eth_dhcp,
+	ibft_eth_vlan,
+	ibft_eth_mac,
+	/* ibft_eth_pci_bdf - this is replaced by link to the device itself. */
+	ibft_eth_hostname,
+	ibft_eth_end_marker,
+};
+
+static const char *ibft_eth_properties[] =
+	{"index", "flags", "ip-addr", "subnet-mask", "origin", "gateway",
+	"primary-dns", "secondary-dns", "dhcp", "vlan", "mac", "hostname",
+	NULL};
+
+enum ibft_tgt_properties_enum {
+	ibft_tgt_index,
+	ibft_tgt_flags,
+	ibft_tgt_ip_addr,
+	ibft_tgt_port,
+	ibft_tgt_lun,
+	ibft_tgt_chap_type,
+	ibft_tgt_nic_assoc,
+	ibft_tgt_name,
+	ibft_tgt_chap_name,
+	ibft_tgt_chap_secret,
+	ibft_tgt_rev_chap_name,
+	ibft_tgt_rev_chap_secret,
+	ibft_tgt_end_marker,
+};
+
+static const char *ibft_tgt_properties[] =
+	{"index", "flags", "ip-addr", "port", "lun", "chap-type", "nic-assoc",
+	"target-name", "chap-name", "chap-secret", "rev-chap-name",
+	"rev-chap-name-secret", NULL};
+
+enum ibft_initiator_properties_enum {
+	ibft_init_index,
+	ibft_init_flags,
+	ibft_init_isns_server,
+	ibft_init_slp_server,
+	ibft_init_pri_radius_server,
+	ibft_init_sec_radius_server,
+	ibft_init_initiator_name,
+	ibft_init_end_marker,
+};
+
+static const char *ibft_initiator_properties[] =
+	{"index", "flags", "isns-server", "slp-server", "pri-radius-server",
+	"sec-radius-server", "initiator-name", NULL};
+
+/*
+ * The kobject and attribute structures.
+ */
+
+struct ibft_kobject {
+	struct ibft_table_header *header;
+	union {
+		struct ibft_initiator *initiator;
+		struct ibft_nic *nic;
+		struct ibft_tgt *tgt;
+		struct ibft_hdr *hdr;
+	};
+	struct kobject kobj;
+	struct list_head node;
+};
+
+struct ibft_attribute {
+	struct attribute attr;
+	ssize_t (*show) (struct  ibft_kobject *entry,
+			 struct ibft_attribute *attr, char *buf);
+	union {
+		struct ibft_initiator *initiator;
+		struct ibft_nic *nic;
+		struct ibft_tgt *tgt;
+		struct ibft_hdr *hdr;
+	};
+	struct kobject *kobj;
+	int type; /* The enum of the type. This can be any value of:
+		ibft_eth_properties_enum, ibft_tgt_properties_enum,
+		or ibft_initiator_properties_enum. */
+	struct list_head node;
+};
+
+static LIST_HEAD(ibft_attr_list);
+static LIST_HEAD(ibft_kobject_list);
+
+static const char nulls[16];
+
+/*
+ * Helper functions to parse data properly.
+ */
+static ssize_t sprintf_ipaddr(char *buf, u8 *ip)
+{
+	char *str = buf;
+
+	if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0 &&
+	    ip[4] == 0 && ip[5] == 0 && ip[6] == 0 && ip[7] == 0 &&
+	    ip[8] == 0 && ip[9] == 0 && ip[10] == 0xff && ip[11] == 0xff) {
+		/*
+		 * IPV4
+		 */
+		str += sprintf(buf, NIPQUAD_FMT, ip[12],
+			       ip[13], ip[14], ip[15]);
+	} else {
+		/*
+		 * IPv6
+		 */
+		str += sprintf(str, NIP6_FMT, ntohs(ip[0]), ntohs(ip[1]),
+			       ntohs(ip[2]), ntohs(ip[3]), ntohs(ip[4]),
+			       ntohs(ip[5]), ntohs(ip[6]), ntohs(ip[7]));
+	}
+	str += sprintf(str, "\n");
+	return str - buf;
+}
+
+static ssize_t sprintf_string(char *str, int len, char *buf)
+{
+	return sprintf(str, "%.*s\n", len, buf);
+}
+
+/*
+ * Helper function to verify the IBFT header.
+ */
+static int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)
+{
+	if (hdr->id != id) {
+		printk(KERN_ERR "iBFT error: We expected the " \
+				"field header.id to have %d but " \
+				"found %d instead!\n", id, hdr->id);
+		return -ENODEV;
+	}
+	if (hdr->length != length) {
+		printk(KERN_ERR "iBFT error: We expected the " \
+				"field header.length to have %d but " \
+				"found %d instead!\n", length, hdr->length);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void ibft_release(struct kobject *kobj)
+{
+	struct ibft_kobject *ibft =
+		container_of(kobj, struct ibft_kobject, kobj);
+	kfree(ibft);
+}
+
+/*
+ *  Routines for parsing the iBFT data to be human readable.
+ */
+ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
+				  struct ibft_attribute *attr,
+				  char *buf)
+{
+	struct ibft_initiator *initiator = entry->initiator;
+	void *ibft_loc = entry->header;
+	char *str = buf;
+
+	if (!initiator)
+		return 0;
+
+	switch (attr->type) {
+	case ibft_init_index:
+		str += sprintf(str, "%d\n", initiator->hdr.index);
+		break;
+	case ibft_init_flags:
+		str += sprintf(str, "%d\n", initiator->hdr.flags);
+		break;
+	case ibft_init_isns_server:
+		str += sprintf_ipaddr(str, initiator->isns_server);
+		break;
+	case ibft_init_slp_server:
+		str += sprintf_ipaddr(str, initiator->slp_server);
+		break;
+	case ibft_init_pri_radius_server:
+		str += sprintf_ipaddr(str, initiator->pri_radius_server);
+		break;
+	case ibft_init_sec_radius_server:
+		str += sprintf_ipaddr(str, initiator->sec_radius_server);
+		break;
+	case ibft_init_initiator_name:
+		str += sprintf_string(str, initiator->initiator_name_len,
+				      (char *)ibft_loc +
+				      initiator->initiator_name_off);
+		break;
+	default:
+		break;
+	}
+
+	return str - buf;
+}
+
+ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
+			    struct ibft_attribute *attr,
+			    char *buf)
+{
+	struct ibft_nic *nic = entry->nic;
+	void *ibft_loc = entry->header;
+	char *str = buf;
+	char *mac;
+	int val;
+
+	if (!nic)
+		return 0;
+
+	switch (attr->type) {
+	case ibft_eth_index:
+		str += sprintf(str, "%d\n", nic->hdr.index);
+		break;
+	case ibft_eth_flags:
+		str += sprintf(str, "%d\n", nic->hdr.flags);
+		break;
+	case ibft_eth_ip_addr:
+		str += sprintf_ipaddr(str, nic->ip_addr);
+		break;
+	case ibft_eth_subnet_mask:
+		val = ~((1 << (32-nic->subnet_mask_prefix))-1);
+		str += sprintf(str, NIPQUAD_FMT,
+			       (u8)(val >> 24), (u8)(val >> 16),
+			       (u8)(val >> 8), (u8)(val));
+		break;
+	case ibft_eth_origin:
+		str += sprintf(str, "%d\n", nic->origin);
+		break;
+	case ibft_eth_gateway:
+		str += sprintf_ipaddr(str, nic->gateway);
+		break;
+	case ibft_eth_primary_dns:
+		str += sprintf_ipaddr(str, nic->primary_dns);
+		break;
+	case ibft_eth_secondary_dns:
+		str += sprintf_ipaddr(str, nic->secondary_dns);
+		break;
+	case ibft_eth_dhcp:
+		str += sprintf_ipaddr(str, nic->dhcp);
+		break;
+	case ibft_eth_vlan:
+		str += sprintf(str, "%d\n", nic->vlan);
+		break;
+	case ibft_eth_mac:
+		mac = nic->mac;
+		str += sprintf(str, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			       (u8)mac[0], (u8)mac[1], (u8)mac[2],
+			       (u8)mac[3], (u8)mac[4], (u8)mac[5]);
+		break;
+	case ibft_eth_hostname:
+		str += sprintf_string(str, nic->hostname_len,
+				      (char *)ibft_loc + nic->hostname_off);
+		break;
+	default:
+		break;
+	}
+
+	return str - buf;
+};
+
+ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
+			       struct ibft_attribute *attr,
+			       char *buf)
+{
+	struct ibft_tgt *tgt = entry->tgt;
+	void *ibft_loc = entry->header;
+	char *str = buf;
+	int i;
+
+	if (!tgt)
+		return 0;
+
+	switch (attr->type) {
+	case ibft_tgt_index:
+		str += sprintf(str, "%d\n", tgt->hdr.index);
+		break;
+	case ibft_tgt_flags:
+		str += sprintf(str, "%d\n", tgt->hdr.flags);
+		break;
+	case ibft_tgt_ip_addr:
+		str += sprintf_ipaddr(str, tgt->ip_addr);
+		break;
+	case ibft_tgt_port:
+		str += sprintf(str, "%d\n", tgt->port);
+		break;
+	case ibft_tgt_lun:
+		for (i = 0; i < 8; i++)
+			str += sprintf(str, "%x", (u8)tgt->lun[i]);
+		str += sprintf(str, "\n");
+		break;
+	case ibft_tgt_nic_assoc:
+		str += sprintf(str, "%d\n", tgt->nic_assoc);
+		break;
+	case ibft_tgt_chap_type:
+		str += sprintf(str, "%d\n", tgt->chap_type);
+		break;
+	case ibft_tgt_name:
+		str += sprintf_string(str, tgt->tgt_name_len,
+				      (char *)ibft_loc + tgt->tgt_name_off);
+		break;
+	case ibft_tgt_chap_name:
+		str += sprintf_string(str, tgt->chap_name_len,
+				      (char *)ibft_loc + tgt->chap_name_off);
+		break;
+	case ibft_tgt_chap_secret:
+		str += sprintf_string(str, tgt->chap_secret_len,
+				      (char *)ibft_loc + tgt->chap_secret_off);
+		break;
+	case ibft_tgt_rev_chap_name:
+		str += sprintf_string(str, tgt->rev_chap_name_len,
+				      (char *)ibft_loc +
+				      tgt->rev_chap_name_off);
+		break;
+	case ibft_tgt_rev_chap_secret:
+		str += sprintf_string(str, tgt->rev_chap_secret_len,
+				      (char *)ibft_loc +
+				      tgt->rev_chap_secret_off);
+		break;
+	default:
+		break;
+	}
+
+	return str - buf;
+}
+
+/*
+ * The routine called for all sysfs attributes.
+ */
+static ssize_t ibft_show_attribute(struct kobject *kobj,
+				    struct attribute *attr,
+				    char *buf)
+{
+	struct ibft_kobject *dev =
+		container_of(kobj, struct ibft_kobject, kobj);
+	struct ibft_attribute *ibft_attr =
+		container_of(attr, struct ibft_attribute, attr);
+	ssize_t ret = -EIO;
+	char *str = buf;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (ibft_attr->show)
+		ret = ibft_attr->show(dev, ibft_attr, str);
+
+	return ret;
+}
+
+static struct sysfs_ops ibft_attr_ops = {
+	.show = ibft_show_attribute,
+};
+
+static struct kobj_type ibft_ktype = {
+	.release = ibft_release,
+	.sysfs_ops = &ibft_attr_ops,
+};
+
+static struct kset *ibft_kset;
+
+static int __init ibft_check_device(void)
+{
+	int len;
+	u8 *pos;
+	u8 csum = 0;
+
+	len = ibft_addr->length;
+
+	/* Sanity checking of iBFT. */
+	if (ibft_addr->revision != 1) {
+		printk(KERN_ERR "iBFT module supports only revision 1, " \
+				"while this is %d.\n", ibft_addr->revision);
+		return -ENOENT;
+	}
+	for (pos = (u8 *)ibft_addr; pos < (u8 *)ibft_addr + len; pos++)
+		csum += *pos;
+
+	if (csum) {
+		printk(KERN_ERR "iBFT has incorrect checksum (0x%x)!\n", csum);
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+/*
+ * Helper function for ibft_register_kobjects.
+ */
+static int __init ibft_create_kobject(struct ibft_table_header *header,
+				       struct ibft_hdr *hdr,
+				       struct list_head *list)
+{
+	struct ibft_kobject *ibft_kobj = NULL;
+	struct ibft_nic *nic = (struct ibft_nic *)hdr;
+	struct pci_dev *pci_dev;
+	int rc = 0;
+
+	ibft_kobj = kzalloc(sizeof(*ibft_kobj), GFP_KERNEL);
+	if (!ibft_kobj)
+		return -ENOMEM;
+
+	ibft_kobj->header = header;
+	ibft_kobj->hdr = hdr;
+
+	switch (hdr->id) {
+	case id_initiator:
+		rc = ibft_verify_hdr("initiator", hdr, id_initiator,
+				     sizeof(*ibft_kobj->initiator));
+		break;
+	case id_nic:
+		rc = ibft_verify_hdr("ethernet", hdr, id_nic,
+				     sizeof(*ibft_kobj->nic));
+		break;
+	case id_target:
+		rc = ibft_verify_hdr("target", hdr, id_target,
+				     sizeof(*ibft_kobj->tgt));
+		break;
+	case id_reserved:
+	case id_control:
+	case id_extensions:
+		/* Fields which we don't support. Ignore them */
+		rc = 1;
+		break;
+	default:
+		printk(KERN_ERR "iBFT has unknown structure type (%d). " \
+				"Report this bug to %.6s!\n", hdr->id,
+				header->oem_id);
+		rc = 1;
+		break;
+	}
+
+	if (rc) {
+		/* Skip adding this kobject, but exit with non-fatal error. */
+		kfree(ibft_kobj);
+		goto out_invalid_struct;
+	}
+
+	ibft_kobj->kobj.kset = ibft_kset;
+
+	rc = kobject_init_and_add(&ibft_kobj->kobj, &ibft_ktype,
+				  NULL, ibft_id_names[hdr->id], hdr->index);
+
+	if (rc) {
+		kfree(ibft_kobj);
+		goto out;
+	}
+
+	kobject_uevent(&ibft_kobj->kobj, KOBJ_ADD);
+
+	if (hdr->id == id_nic) {
+		/*
+		* We don't search for the device in other domains than
+		* zero. This is because on x86 platforms the BIOS
+		* executes only devices which are in domain 0. Furthermore, the
+		* iBFT spec doesn't have a domain id field :-(
+		*/
+		pci_dev = pci_get_bus_and_slot((nic->pci_bdf & 0xff00) >> 8,
+					       (nic->pci_bdf & 0xff));
+		if (pci_dev) {
+			rc = sysfs_create_link(&ibft_kobj->kobj,
+					       &pci_dev->dev.kobj, "device");
+			pci_dev_put(pci_dev);
+		}
+	}
+
+	/* Nothing broke so lets add it to the list. */
+	list_add_tail(&ibft_kobj->node, list);
+out:
+	return rc;
+out_invalid_struct:
+	/* Unsupported structs are skipped. */
+	return 0;
+}
+
+/*
+ * Scan the IBFT table structure for the NIC and Target fields. When
+ * found add them on the passed-in list. We do not support the other
+ * fields at this point, so they are skipped.
+ */
+static int __init ibft_register_kobjects(struct ibft_table_header *header,
+					  struct list_head *list)
+{
+	struct ibft_control *control = NULL;
+	void *ptr, *end;
+	int rc = 0;
+	u16 offset;
+	u16 eot_offset;
+
+	control = (void *)header + sizeof(*header);
+	end = (void *)control + control->hdr.length;
+	eot_offset = (void *)header + header->length -
+		     (void *)control - sizeof(*header);
+	rc = ibft_verify_hdr("control", (struct ibft_hdr *)control, id_control,
+			     sizeof(*control));
+
+	/* iBFT table safety checking */
+	rc |= ((control->hdr.index) ? -ENODEV : 0);
+	if (rc) {
+		printk(KERN_ERR "iBFT error: Control header is invalid!\n");
+		return rc;
+	}
+	for (ptr = &control->initiator_off; ptr < end; ptr += sizeof(u16)) {
+		offset = *(u16 *)ptr;
+		if (offset && offset < header->length && offset < eot_offset) {
+			rc = ibft_create_kobject(header,
+						 (void *)header + offset,
+						 list);
+			if (rc)
+				break;
+		}
+	}
+
+	return rc;
+}
+
+static void ibft_unregister(struct list_head *attr_list,
+			     struct list_head *kobj_list)
+{
+	struct ibft_kobject *data = NULL, *n;
+	struct ibft_attribute *attr = NULL, *m;
+
+	list_for_each_entry_safe(attr, m, attr_list, node) {
+		sysfs_remove_file(attr->kobj, &attr->attr);
+		list_del(&attr->node);
+		kfree(attr);
+	};
+	list_del_init(attr_list);
+
+	list_for_each_entry_safe(data, n, kobj_list, node) {
+		list_del(&data->node);
+		if (data->hdr->id == id_nic)
+			sysfs_remove_link(&data->kobj, "device");
+		kobject_put(&data->kobj);
+	};
+	list_del_init(kobj_list);
+}
+
+static int __init ibft_create_attribute(struct ibft_kobject *kobj_data,
+					 int type,
+					 const char *name,
+					 ssize_t (*show)(struct ibft_kobject *,
+							 struct ibft_attribute*,
+							 char *buf),
+					 struct list_head *list)
+{
+	struct ibft_attribute *attr = NULL;
+	struct ibft_hdr *hdr = kobj_data->hdr;
+
+	attr = kmalloc(sizeof(*attr), GFP_KERNEL);
+	if (!attr)
+		return -ENOMEM;
+
+	attr->attr.name = name;
+	attr->attr.mode = S_IRUSR;
+	attr->attr.owner = THIS_MODULE;
+
+	attr->hdr = hdr;
+	attr->show = show;
+	attr->kobj = &kobj_data->kobj;
+	attr->type = type;
+
+	list_add_tail(&attr->node, list);
+
+	return 0;
+}
+
+/*
+ * Helper routiners to check to determine if the entry is valid
+ * in the proper iBFT structure.
+ */
+static int __init ibft_check_nic_for(struct ibft_nic *nic, int entry)
+{
+	int rc = 0;
+
+	switch (entry) {
+	case ibft_eth_index:
+	case ibft_eth_flags:
+		rc = 1;
+		break;
+	case ibft_eth_ip_addr:
+		if (!memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+			rc = 1;
+		break;
+	case ibft_eth_subnet_mask:
+		if (!memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+			rc = 1;
+		break;
+	case ibft_eth_origin:
+		rc = 1;
+		break;
+	case ibft_eth_gateway:
+		if (memcmp(nic->gateway, nulls, sizeof(nic->gateway)))
+			rc = 1;
+		break;
+	case ibft_eth_primary_dns:
+		if (memcmp(nic->primary_dns, nulls,
+			   sizeof(nic->primary_dns)))
+			rc = 1;
+		break;
+	case ibft_eth_secondary_dns:
+		if (memcmp(nic->secondary_dns, nulls,
+			   sizeof(nic->secondary_dns)))
+			rc = 1;
+		break;
+	case ibft_eth_dhcp:
+		if (memcmp(nic->dhcp, nulls, sizeof(nic->dhcp)))
+			rc = 1;
+		break;
+	case ibft_eth_vlan:
+	case ibft_eth_mac:
+		rc = 1;
+		break;
+	case ibft_eth_hostname:
+		if (nic->hostname_off)
+			rc = 1;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static int __init ibft_check_tgt_for(struct ibft_tgt *tgt, int entry)
+{
+	int rc = 0;
+
+	switch (entry) {
+	case ibft_tgt_index:
+	case ibft_tgt_flags:
+	case ibft_tgt_ip_addr:
+	case ibft_tgt_port:
+	case ibft_tgt_lun:
+	case ibft_tgt_nic_assoc:
+	case ibft_tgt_chap_type:
+		rc = 1;
+	case ibft_tgt_name:
+		if (tgt->tgt_name_len)
+			rc = 1;
+		break;
+	case ibft_tgt_chap_name:
+	case ibft_tgt_chap_secret:
+		if (tgt->chap_name_len)
+			rc = 1;
+		break;
+	case ibft_tgt_rev_chap_name:
+	case ibft_tgt_rev_chap_secret:
+		if (tgt->rev_chap_name_len)
+			rc = 1;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static int __init ibft_check_initiator_for(struct ibft_initiator *init,
+					    int entry)
+{
+	int rc = 0;
+
+	switch (entry) {
+	case ibft_init_index:
+	case ibft_init_flags:
+		rc = 1;
+		break;
+	case ibft_init_isns_server:
+		if (memcmp(init->isns_server, nulls,
+			   sizeof(init->isns_server)))
+			rc = 1;
+		break;
+	case ibft_init_slp_server:
+		if (memcmp(init->slp_server, nulls,
+			   sizeof(init->slp_server)))
+			rc = 1;
+		break;
+	case ibft_init_pri_radius_server:
+		if (memcmp(init->pri_radius_server, nulls,
+			   sizeof(init->pri_radius_server)))
+			rc = 1;
+		break;
+	case ibft_init_sec_radius_server:
+		if (memcmp(init->sec_radius_server, nulls,
+			   sizeof(init->sec_radius_server)))
+			rc = 1;
+		break;
+	case ibft_init_initiator_name:
+		if (init->initiator_name_len)
+			rc = 1;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+/*
+ *  Register the attributes for all of the kobjects.
+ */
+static int __init ibft_register_attributes(struct list_head *kobject_list,
+					    struct list_head *attr_list)
+{
+	int rc = 0, i = 0;
+	struct ibft_kobject *data = NULL;
+	struct ibft_attribute *attr = NULL, *m;
+
+	list_for_each_entry(data, kobject_list, node) {
+		switch (data->hdr->id) {
+		case id_nic:
+			for (i = 0; i < ibft_eth_end_marker && !rc; i++)
+				if (ibft_check_nic_for(data->nic, i))
+					rc = ibft_create_attribute(data, i,
+						ibft_eth_properties[i],
+						ibft_attr_show_nic, attr_list);
+			break;
+		case id_target:
+			for (i = 0; i < ibft_tgt_end_marker && !rc; i++)
+				if (ibft_check_tgt_for(data->tgt, i))
+					rc = ibft_create_attribute(data, i,
+						ibft_tgt_properties[i],
+						ibft_attr_show_target,
+						attr_list);
+			break;
+		case id_initiator:
+			for (i = 0; i < ibft_init_end_marker && !rc; i++)
+				if (ibft_check_initiator_for(
+					data->initiator, i))
+					rc = ibft_create_attribute(data, i,
+						ibft_initiator_properties[i],
+						ibft_attr_show_initiator,
+						attr_list);
+			break;
+		default:
+			break;
+		}
+		if (rc)
+			break;
+	}
+	list_for_each_entry_safe(attr, m, attr_list, node) {
+		rc = sysfs_create_file(attr->kobj, &attr->attr);
+		if (rc) {
+			list_del(&attr->node);
+			kfree(attr);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+/*
+ * ibft_init() - creates sysfs tree entries for the iBFT data.
+ */
+static int __init ibft_init(void)
+{
+	int rc = 0;
+
+	ibft_kset = kset_create_and_add("ibft", NULL, firmware_kobj);
+	if (!ibft_kset)
+		return -ENOMEM;
+
+	if (ibft_addr) {
+		printk(KERN_INFO "iBFT detected at 0x%lx.\n",
+		       virt_to_phys((void *)ibft_addr));
+
+		rc = ibft_check_device();
+		if (rc)
+			goto out_firmware_unregister;
+
+		/* Scan the IBFT for data and register the kobjects. */
+		rc = ibft_register_kobjects(ibft_addr, &ibft_kobject_list);
+		if (rc)
+			goto out_free;
+
+		/* Register the attributes */
+		rc = ibft_register_attributes(&ibft_kobject_list,
+					      &ibft_attr_list);
+		if (rc)
+			goto out_free;
+	} else
+		printk(KERN_INFO "No iBFT detected.\n");
+
+	return 0;
+
+out_free:
+	ibft_unregister(&ibft_attr_list, &ibft_kobject_list);
+out_firmware_unregister:
+	kset_unregister(ibft_kset);
+	return rc;
+}
+
+static void __exit ibft_exit(void)
+{
+	ibft_unregister(&ibft_attr_list, &ibft_kobject_list);
+	kset_unregister(ibft_kset);
+}
+
+module_init(ibft_init);
+module_exit(ibft_exit);
