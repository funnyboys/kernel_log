commit 2a55280a3675203496d302463b941834228b9875
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jun 7 15:41:35 2020 +0200

    efi/libstub: arm: Print CPU boot mode and MMU state at boot
    
    On 32-bit ARM, we may boot at HYP mode, or with the MMU and caches off
    (or both), even though the EFI spec does not actually support this.
    While booting at HYP mode is something we might tolerate, fiddling
    with the caches is a more serious issue, as disabling the caches is
    tricky to do safely from C code, and running without the Dcache makes
    it impossible to support unaligned memory accesses, which is another
    explicit requirement imposed by the EFI spec.
    
    So take note of the CPU mode and MMU state in the EFI stub diagnostic
    output so that we can easily diagnose any issues that may arise from
    this. E.g.,
    
      EFI stub: Entering in SVC mode with MMU enabled
    
    Also, capture the CPSR and SCTLR system register values at EFI stub
    entry, and after ExitBootServices() returns, and check whether the
    MMU and Dcache were disabled at any point. If this is the case, a
    diagnostic message like the following will be emitted:
    
      efi: [Firmware Bug]: EFI stub was entered with MMU and Dcache disabled, please fix your firmware!
      efi: CPSR at EFI stub entry        : 0x600001d3
      efi: SCTLR at EFI stub entry       : 0x00c51838
      efi: CPSR after ExitBootServices() : 0x600001d3
      efi: SCTLR after ExitBootServices(): 0x00c50838
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Leif Lindholm <leif@nuviainc.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index ac756f1fdb1a..2c9d42264c29 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -777,4 +777,6 @@ efi_status_t efi_load_initrd(efi_loaded_image_t *image,
 			     unsigned long soft_limit,
 			     unsigned long hard_limit);
 
+void efi_handle_post_ebs_state(void);
+
 #endif

commit 8c0a839c2bccb756454e35e8977e44fcf2bd417e
Author: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date:   Tue Jun 16 01:42:31 2020 +0200

    efi/libstub: Descriptions for stub helper functions
    
    Provide missing descriptions for EFI stub helper functions.
    Adjust formatting of existing descriptions to kernel style.
    
    Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Link: https://lore.kernel.org/r/20200615234231.21059-1-xypron.glpk@gmx.de
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index bcd8c0a785f0..ac756f1fdb1a 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -157,8 +157,14 @@ typedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);
 #define EFI_EVT_NOTIFY_WAIT	0x00000100U
 #define EFI_EVT_NOTIFY_SIGNAL	0x00000200U
 
-/*
- * boottime->wait_for_event takes an array of events as input.
+/**
+ * efi_set_event_at() - add event to events array
+ *
+ * @events:	array of UEFI events
+ * @ids:	index where to put the event in the array
+ * @event:	event to add to the aray
+ *
+ * boottime->wait_for_event() takes an array of events as input.
  * Provide a helper to set it up correctly for mixed mode.
  */
 static inline

commit d1343da330f6ff3f40abf1f360d4701af784b85a
Merge: a5d8e55b2c7d 9241dfe7f277
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 25 15:11:14 2020 +0200

    Merge tag 'efi-changes-for-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/efi/efi into efi/core
    
    More EFI changes for v5.8:
    
     - Rename pr_efi/pr_efi_err to efi_info/efi_err, and use them consistently
     - Simplify and unify initrd loading
     - Parse the builtin command line on x86 (if provided)
     - Implement printk() support, including support for wide character strings
     - Some fixes for issues introduced by the first batch of v5.8 changes
     - Fix a missing prototypes warning
     - Simplify GDT handling in early mixed mode thunking code
     - Some other minor fixes and cleanups
    
    Conflicts:
            drivers/firmware/efi/libstub/efistub.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a5d8e55b2c7d3d18d7837af0ef8d1477eeeb919c
Merge: 4da0b2b7e675 9cb1fd0efd19
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 25 15:10:37 2020 +0200

    Merge tag 'v5.7-rc7' into efi/core, to refresh the branch and pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 6e99d3213b10ee18428d6d20715ad6c0e89ead4d
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sat May 23 11:01:57 2020 +0200

    efi/libstub: Add missing prototype for PE/COFF entry point
    
    Fix a missing prototype warning by adding a forward declaration
    for the PE/COFF entrypoint, and while at it, align the function
    name between the x86 and ARM versions of the stub.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 1de8dc02529a..03f74608b963 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -40,6 +40,9 @@ extern bool efi_novamap;
 
 extern const efi_system_table_t *efi_system_table;
 
+efi_status_t __efiapi efi_pe_entry(efi_handle_t handle,
+				   efi_system_table_t *sys_table_arg);
+
 #ifndef ARCH_HAS_EFISTUB_WRAPPERS
 
 #define efi_is_native()		(true)

commit 27cd5511feffea3956d081585316272795e45bce
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue May 19 10:43:01 2020 +0200

    efi/libstub: Use pool allocation for the command line
    
    Now that we removed the memory limit for the allocation of the
    command line, there is no longer a need to use the page based
    allocator so switch to a pool allocation instead.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index ad7e0406d0ba..1de8dc02529a 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -708,8 +708,7 @@ __printf(1, 2) int efi_printk(char const *fmt, ...);
 
 void efi_free(unsigned long size, unsigned long addr);
 
-char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len,
-			  unsigned long max_addr);
+char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
 
 efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
 

commit 14c574f35cfbc9272fc67b41f074c847db139652
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:07:11 2020 -0400

    efi/gop: Add an option to list out the available GOP modes
    
    Add video=efifb:list option to list the modes that are available.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-20-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index c7c03099367f..ad7e0406d0ba 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -323,6 +323,8 @@ union efi_simple_text_input_protocol {
 	} mixed_mode;
 };
 
+efi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key);
+
 union efi_simple_text_output_protocol {
 	struct {
 		void *reset;

commit 9b47c5275614a16fd64359fab73fe6c736bf57a0
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:07:10 2020 -0400

    efi/libstub: Add definitions for console input and events
    
    Add the required typedefs etc for using con_in's simple text input
    protocol, and for using the boottime event services.
    
    Also add the prototype for the "stall" boot service.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-19-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 3a323a009836..c7c03099367f 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -111,6 +111,16 @@ void efi_set_u64_split(u64 data, u32 *lo, u32 *hi)
 #define EFI_LOCATE_BY_REGISTER_NOTIFY		1
 #define EFI_LOCATE_BY_PROTOCOL			2
 
+/*
+ * boottime->stall takes the time period in microseconds
+ */
+#define EFI_USEC_PER_SEC		1000000
+
+/*
+ * boottime->set_timer takes the time in 100ns units
+ */
+#define EFI_100NSEC_PER_USEC	((u64)10)
+
 struct efi_boot_memmap {
 	efi_memory_desc_t	**map;
 	unsigned long		*map_size;
@@ -122,6 +132,39 @@ struct efi_boot_memmap {
 
 typedef struct efi_generic_dev_path efi_device_path_protocol_t;
 
+typedef void *efi_event_t;
+/* Note that notifications won't work in mixed mode */
+typedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);
+
+#define EFI_EVT_TIMER		0x80000000U
+#define EFI_EVT_RUNTIME		0x40000000U
+#define EFI_EVT_NOTIFY_WAIT	0x00000100U
+#define EFI_EVT_NOTIFY_SIGNAL	0x00000200U
+
+/*
+ * boottime->wait_for_event takes an array of events as input.
+ * Provide a helper to set it up correctly for mixed mode.
+ */
+static inline
+void efi_set_event_at(efi_event_t *events, size_t idx, efi_event_t event)
+{
+	if (efi_is_native())
+		events[idx] = event;
+	else
+		((u32 *)events)[idx] = (u32)(unsigned long)event;
+}
+
+#define EFI_TPL_APPLICATION	4
+#define EFI_TPL_CALLBACK	8
+#define EFI_TPL_NOTIFY		16
+#define EFI_TPL_HIGH_LEVEL	31
+
+typedef enum {
+	EfiTimerCancel,
+	EfiTimerPeriodic,
+	EfiTimerRelative
+} EFI_TIMER_DELAY;
+
 /*
  * EFI Boot Services table
  */
@@ -140,11 +183,16 @@ union efi_boot_services {
 		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
 						       void **);
 		efi_status_t (__efiapi *free_pool)(void *);
-		void *create_event;
-		void *set_timer;
-		void *wait_for_event;
+		efi_status_t (__efiapi *create_event)(u32, unsigned long,
+						      efi_event_notify_t, void *,
+						      efi_event_t *);
+		efi_status_t (__efiapi *set_timer)(efi_event_t,
+						  EFI_TIMER_DELAY, u64);
+		efi_status_t (__efiapi *wait_for_event)(unsigned long,
+							efi_event_t *,
+							unsigned long *);
 		void *signal_event;
-		void *close_event;
+		efi_status_t (__efiapi *close_event)(efi_event_t);
 		void *check_event;
 		void *install_protocol_interface;
 		void *reinstall_protocol_interface;
@@ -171,7 +219,7 @@ union efi_boot_services {
 		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
 							    unsigned long);
 		void *get_next_monotonic_count;
-		void *stall;
+		efi_status_t (__efiapi *stall)(unsigned long);
 		void *set_watchdog_timer;
 		void *connect_controller;
 		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
@@ -256,6 +304,25 @@ union efi_uga_draw_protocol {
 	} mixed_mode;
 };
 
+typedef struct {
+	u16 scan_code;
+	efi_char16_t unicode_char;
+} efi_input_key_t;
+
+union efi_simple_text_input_protocol {
+	struct {
+		void *reset;
+		efi_status_t (__efiapi *read_keystroke)(efi_simple_text_input_protocol_t *,
+							efi_input_key_t *);
+		efi_event_t wait_for_key;
+	};
+	struct {
+		u32 reset;
+		u32 read_keystroke;
+		u32 wait_for_key;
+	} mixed_mode;
+};
+
 union efi_simple_text_output_protocol {
 	struct {
 		void *reset;

commit 23d5b73fbfd787c4c63841912b079eac000a7414
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Wed May 20 19:07:54 2020 +0200

    efi/libstub: Implement printk-style logging
    
    Use the efi_printk function in efi_info/efi_err, and add efi_debug. This
    allows formatted output at different log levels.
    
    Add the notion of a loglevel instead of just quiet/not-quiet, and
    parse the efi=debug kernel parameter in addition to quiet.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200520170223.GA3333632@rani.riverdale.lan/
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index caa7dcc71c69..3a323a009836 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -6,6 +6,7 @@
 #include <linux/compiler.h>
 #include <linux/efi.h>
 #include <linux/kernel.h>
+#include <linux/kern_levels.h>
 #include <linux/types.h>
 #include <asm/efi.h>
 
@@ -34,7 +35,7 @@
 extern bool efi_nochunk;
 extern bool efi_nokaslr;
 extern bool efi_noinitrd;
-extern bool efi_quiet;
+extern int efi_loglevel;
 extern bool efi_novamap;
 
 extern const efi_system_table_t *efi_system_table;
@@ -49,11 +50,12 @@ extern const efi_system_table_t *efi_system_table;
 
 #endif
 
-#define efi_info(msg)		do {			\
-	if (!efi_quiet) efi_puts("EFI stub: "msg);	\
-} while (0)
-
-#define efi_err(msg) efi_puts("EFI stub: ERROR: "msg)
+#define efi_info(fmt, ...) \
+	efi_printk(KERN_INFO fmt, ##__VA_ARGS__)
+#define efi_err(fmt, ...) \
+	efi_printk(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
+#define efi_debug(fmt, ...) \
+	efi_printk(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
 
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var

commit 2c7d1e30e5884dc6f6727ecd9417491c9f321b59
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:06:56 2020 -0400

    efi/libstub: Add a basic printf implementation
    
    Copy vsprintf from arch/x86/boot/printf.c to get a simple printf
    implementation.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-5-nivedita@alum.mit.edu
    [ardb: add some missing braces in if...else clauses]
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 4f57611a65f2..caa7dcc71c69 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -3,6 +3,7 @@
 #ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 #define _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 
+#include <linux/compiler.h>
 #include <linux/efi.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -632,6 +633,8 @@ void *get_efi_config_table(efi_guid_t guid);
 void efi_char16_puts(efi_char16_t *);
 void efi_puts(const char *str);
 
+__printf(1, 2) int efi_printk(char const *fmt, ...);
+
 void efi_free(unsigned long size, unsigned long addr);
 
 char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len,

commit cb8c90a08c7f2f761919190093fca0611c1cece4
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:06:54 2020 -0400

    efi/libstub: Rename efi_[char16_]printk to efi_[char16_]puts
    
    These functions do not support formatting, unlike printk. Rename them to
    puts to make that clear.
    
    Move the implementations of these two functions next to each other.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-3-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 998924916b03..4f57611a65f2 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -49,10 +49,10 @@ extern const efi_system_table_t *efi_system_table;
 #endif
 
 #define efi_info(msg)		do {			\
-	if (!efi_quiet) efi_printk("EFI stub: "msg);	\
+	if (!efi_quiet) efi_puts("EFI stub: "msg);	\
 } while (0)
 
-#define efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
+#define efi_err(msg) efi_puts("EFI stub: ERROR: "msg)
 
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var
@@ -605,8 +605,6 @@ efi_status_t efi_exit_boot_services(void *handle,
 				    void *priv,
 				    efi_exit_boot_map_processing priv_func);
 
-void efi_char16_printk(efi_char16_t *);
-
 efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
 					    unsigned long *new_fdt_addr,
 					    unsigned long max_addr,
@@ -630,7 +628,9 @@ efi_status_t check_platform_features(void);
 
 void *get_efi_config_table(efi_guid_t guid);
 
-void efi_printk(const char *str);
+/* NOTE: These functions do not print a trailing newline after the string */
+void efi_char16_puts(efi_char16_t *);
+void efi_puts(const char *str);
 
 void efi_free(unsigned long size, unsigned long addr);
 

commit 0b76735380224497e1c78a1bed606cbda83e3427
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:06:53 2020 -0400

    efi/libstub: Include dependencies of efistub.h
    
    Add #include directives for include files that efistub.h depends on,
    instead of relying on them having been included by the C source files
    prior to efistub.h.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-2-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 15d0b6f3f6c6..998924916b03 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -3,6 +3,11 @@
 #ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 #define _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 
+#include <linux/efi.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/efi.h>
+
 /* error code which can't be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 

commit fd62619598069c974739476d1851a00d665041d7
Author: Lenny Szubowicz <lszubowi@redhat.com>
Date:   Thu May 7 14:33:32 2020 -0400

    efi/libstub/x86: Avoid EFI map buffer alloc in allocate_e820()
    
    In allocate_e820(), call the EFI get_memory_map() service directly
    instead of indirectly via efi_get_memory_map(). This avoids allocation
    of a buffer and return of the full EFI memory map, which is not needed
    here and would otherwise need to be freed.
    
    Routine allocate_e820() only needs to know how many EFI memory
    descriptors there are in the map to allocate an adequately sized
    e820ext buffer, if it's needed. Note that since efi_get_memory_map()
    returns a memory map buffer sized with extra headroom, allocate_e820()
    now needs to explicitly factor that into the e820ext size calculation.
    
    Signed-off-by: Lenny Szubowicz <lszubowi@redhat.com>
    Suggested-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 67d26949fd26..62943992f02f 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -92,6 +92,19 @@ extern __pure efi_system_table_t  *efi_system_table(void);
 #define EFI_LOCATE_BY_REGISTER_NOTIFY		1
 #define EFI_LOCATE_BY_PROTOCOL			2
 
+/*
+ * An efi_boot_memmap is used by efi_get_memory_map() to return the
+ * EFI memory map in a dynamically allocated buffer.
+ *
+ * The buffer allocated for the EFI memory map includes extra room for
+ * a minimum of EFI_MMAP_NR_SLACK_SLOTS additional EFI memory descriptors.
+ * This facilitates the reuse of the EFI memory map buffer when a second
+ * call to ExitBootServices() is needed because of intervening changes to
+ * the EFI memory map. Other related structures, e.g. x86 e820ext, need
+ * to factor in this headroom requirement as well.
+ */
+#define EFI_MMAP_NR_SLACK_SLOTS	8
+
 struct efi_boot_memmap {
 	efi_memory_desc_t	**map;
 	unsigned long		*map_size;

commit 0b8d9fc9953fde4ea3eb3191d986ca2d01eb783c
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue May 5 10:27:18 2020 +0200

    efi/libstub: Make efi_printk() input argument const char*
    
    To help the compiler figure out that efi_printk() will not modify
    the string it is given, make the input argument type const char*.
    
    While at it, simplify the implementation as well.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 4f10a09563f3..15d0b6f3f6c6 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -625,7 +625,7 @@ efi_status_t check_platform_features(void);
 
 void *get_efi_config_table(efi_guid_t guid);
 
-void efi_printk(char *str);
+void efi_printk(const char *str);
 
 void efi_free(unsigned long size, unsigned long addr);
 

commit de8c55208c3865d0532466097b0244fbea1d9089
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 4 11:02:48 2020 -0400

    efi/libstub: Fix mixed mode boot issue after macro refactor
    
    Commit
    
      22090f84bc3f ("efi/libstub: unify EFI call wrappers for non-x86")
    
    refactored the macros that are used to provide wrappers for mixed-mode
    calls on x86, allowing us to boot a 64-bit kernel on 32-bit firmware.
    
    Unfortunately, this broke mixed mode boot due to the fact that
    efi_is_native() is not a macro on x86.
    
    All of these macros should go together, so rather than testing each one
    to see if it is defined, condition the generic macro definitions on a
    new ARCH_HAS_EFISTUB_WRAPPERS, and remove the wrapper definitions on x86
    as well if CONFIG_EFI_MIXED is not enabled.
    
    Fixes: 22090f84bc3f ("efi/libstub: unify EFI call wrappers for non-x86")
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200504150248.62482-1-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 874233cf8820..4f10a09563f3 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -33,20 +33,14 @@ extern bool efi_novamap;
 
 extern const efi_system_table_t *efi_system_table;
 
-#ifndef efi_bs_call
+#ifndef ARCH_HAS_EFISTUB_WRAPPERS
+
+#define efi_is_native()		(true)
 #define efi_bs_call(func, ...)	efi_system_table->boottime->func(__VA_ARGS__)
-#endif
-#ifndef efi_rt_call
 #define efi_rt_call(func, ...)	efi_system_table->runtime->func(__VA_ARGS__)
-#endif
-#ifndef efi_is_native
-#define efi_is_native()		(true)
-#endif
-#ifndef efi_table_attr
 #define efi_table_attr(inst, attr)	(inst->attr)
-#endif
-#ifndef efi_call_proto
 #define efi_call_proto(inst, func, ...) inst->func(inst, ##__VA_ARGS__)
+
 #endif
 
 #define efi_info(msg)		do {			\

commit f61900fd0ebf6c6b91719d63272a54f4d11051df
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 30 14:28:41 2020 -0400

    efi/libstub: Unify initrd loading across architectures
    
    Factor out the initrd loading into a common function that can be called
    both from the generic efi-stub.c and the x86-specific x86-stub.c.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200430182843.2510180-10-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 8c905a1be1b4..874233cf8820 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -677,21 +677,10 @@ static inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,
 				    ULONG_MAX, ULONG_MAX, load_addr, load_size);
 }
 
-static inline efi_status_t efi_load_initrd(efi_loaded_image_t *image,
-					   unsigned long *load_addr,
-					   unsigned long *load_size,
-					   unsigned long soft_limit,
-					   unsigned long hard_limit)
-{
-	if (!IS_ENABLED(CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER))
-		return EFI_SUCCESS;
-
-	return handle_cmdline_files(image, L"initrd=", sizeof(L"initrd=") - 2,
-				    soft_limit, hard_limit, load_addr, load_size);
-}
-
-efi_status_t efi_load_initrd_dev_path(unsigned long *load_addr,
-				      unsigned long *load_size,
-				      unsigned long max);
+efi_status_t efi_load_initrd(efi_loaded_image_t *image,
+			     unsigned long *load_addr,
+			     unsigned long *load_size,
+			     unsigned long soft_limit,
+			     unsigned long hard_limit);
 
 #endif

commit 793473c28a4b17ade3c2bb69782fb0b55acb6e0b
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 30 14:28:35 2020 -0400

    efi/libstub: Move pr_efi/pr_efi_err into efi namespace
    
    Rename pr_efi to efi_info and pr_efi_err to efi_err to make it more
    obvious that they are part of the EFI stub and not generic printk infra.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200430182843.2510180-4-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index e8aa70ba08d5..8c905a1be1b4 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -49,11 +49,11 @@ extern const efi_system_table_t *efi_system_table;
 #define efi_call_proto(inst, func, ...) inst->func(inst, ##__VA_ARGS__)
 #endif
 
-#define pr_efi(msg)		do {			\
+#define efi_info(msg)		do {			\
 	if (!efi_quiet) efi_printk("EFI stub: "msg);	\
 } while (0)
 
-#define pr_efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
+#define efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
 
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var

commit eed4e0193ee7b00213791f7732bce0fc0c54f3b3
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 30 14:28:34 2020 -0400

    efi/libstub: Add a helper function to split 64-bit values
    
    In several places 64-bit values need to be split up into two 32-bit
    fields, in order to be backward-compatible with the old 32-bit ABIs.
    
    Instead of open-coding this, add a helper function to set a 64-bit value
    as two 32-bit fields.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200430182843.2510180-3-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 5ff63230a1f1..e8aa70ba08d5 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -87,6 +87,13 @@ extern const efi_system_table_t *efi_system_table;
 		((handle = efi_get_handle_at((array), i)) || true);	\
 	     i++)
 
+static inline
+void efi_set_u64_split(u64 data, u32 *lo, u32 *hi)
+{
+	*lo = lower_32_bits(data);
+	*hi = upper_32_bits(data);
+}
+
 /*
  * Allocation types for calls to boottime->allocate_pages.
  */

commit 980771f616624e4c563a2014a32b7d23876d1ecf
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Apr 16 18:45:24 2020 +0200

    efi/libstub: Drop __pure getters for EFI stub options
    
    The practice of using __pure getter functions to access global
    variables in the EFI stub dates back to the time when we had to
    carefully prevent GOT entries from being emitted, because we
    could not rely on the toolchain to do this for us.
    
    Today, we use the hidden visibility pragma for all EFI stub source
    files, which now all live in the same subdirectory, and we apply a
    sanity check on the objects, so we can get rid of these getter
    functions and simply refer to global data objects directly.
    
    So switch over the remaining boolean variables carrying options set
    on the kernel command line.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index c1481c5abea4..5ff63230a1f1 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,11 +25,11 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-extern bool __pure nochunk(void);
-extern bool __pure nokaslr(void);
-extern bool __pure noinitrd(void);
-extern bool __pure is_quiet(void);
-extern bool __pure novamap(void);
+extern bool efi_nochunk;
+extern bool efi_nokaslr;
+extern bool efi_noinitrd;
+extern bool efi_quiet;
+extern bool efi_novamap;
 
 extern const efi_system_table_t *efi_system_table;
 
@@ -50,7 +50,7 @@ extern const efi_system_table_t *efi_system_table;
 #endif
 
 #define pr_efi(msg)		do {			\
-	if (!is_quiet()) efi_printk("EFI stub: "msg);	\
+	if (!efi_quiet) efi_printk("EFI stub: "msg);	\
 } while (0)
 
 #define pr_efi_err(msg) efi_printk("EFI stub: ERROR: "msg)

commit ccc27ae77494252965aedca68588e7457829cfad
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Apr 16 18:38:06 2020 +0200

    efi/libstub: Drop __pure getter for efi_system_table
    
    The practice of using __pure getter functions to access global
    variables in the EFI stub dates back to the time when we had to
    carefully prevent GOT entries from being emitted, because we
    could not rely on the toolchain to do this for us.
    
    Today, we use the hidden visibility pragma for all EFI stub source
    files, which now all live in the same subdirectory, and we apply a
    sanity check on the objects, so we can get rid of these getter
    functions and simply refer to global data objects directly.
    
    Start with efi_system_table(), and convert it into a global variable.
    While at it, make it a pointer-to-const, because we can.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 9a87fff1d4ba..c1481c5abea4 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -31,13 +31,13 @@ extern bool __pure noinitrd(void);
 extern bool __pure is_quiet(void);
 extern bool __pure novamap(void);
 
-extern __pure efi_system_table_t  *efi_system_table(void);
+extern const efi_system_table_t *efi_system_table;
 
 #ifndef efi_bs_call
-#define efi_bs_call(func, ...)	efi_system_table()->boottime->func(__VA_ARGS__)
+#define efi_bs_call(func, ...)	efi_system_table->boottime->func(__VA_ARGS__)
 #endif
 #ifndef efi_rt_call
-#define efi_rt_call(func, ...)	efi_system_table()->runtime->func(__VA_ARGS__)
+#define efi_rt_call(func, ...)	efi_system_table->runtime->func(__VA_ARGS__)
 #endif
 #ifndef efi_is_native
 #define efi_is_native()		(true)

commit 544393707f3ca4f185ea1e41cc3206d1526c99cf
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 16 11:12:27 2020 -0400

    efi: Kill __efistub_global
    
    Now that both arm and x86 are using the linker script to place the EFI
    stub's global variables in the correct section, remove __efistub_global.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
    Link: https://lore.kernel.org/r/20200416151227.3360778-4-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 5244eacc5d4b..9a87fff1d4ba 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,8 +25,6 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-#define __efistub_global
-
 extern bool __pure nochunk(void);
 extern bool __pure nokaslr(void);
 extern bool __pure noinitrd(void);

commit 26a92425f9a301fdeb5482e7891915ce43cc0556
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 16 11:12:26 2020 -0400

    efi/x86: Remove __efistub_global and add relocation check
    
    Instead of using __efistub_global to force variables into the .data
    section, leave them in the .bss but pull the EFI stub's .bss section
    into .data in the linker script for the compressed kernel.
    
    Add relocation checking for x86 as well to catch non-PC-relative
    relocations that require runtime processing, since the EFI stub does not
    do any runtime relocation processing.
    
    This will catch, for example, data relocations created by static
    initializers of pointers.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200416151227.3360778-3-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 96e25b17c88e..5244eacc5d4b 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,11 +25,7 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-#if defined(CONFIG_X86)
-#define __efistub_global	__section(.data)
-#else
 #define __efistub_global
-#endif
 
 extern bool __pure nochunk(void);
 extern bool __pure nokaslr(void);

commit 420b6d00ca94ce5b6578b1bc12e767ac7a0251ac
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 16 11:12:25 2020 -0400

    efi/arm: Remove __efistub_global annotation
    
    Instead of using __efistub_global to force variables into the .data
    section, leave them in the .bss but pull the EFI stub's .bss section
    into .data in the linker script for the compressed kernel.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
    Link: https://lore.kernel.org/r/20200416151227.3360778-2-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 2a0698d9dc78..96e25b17c88e 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,7 +25,7 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-#if defined(CONFIG_ARM) || defined(CONFIG_X86)
+#if defined(CONFIG_X86)
 #define __efistub_global	__section(.data)
 #else
 #define __efistub_global

commit 685d8164b5da3aeb75b0320fd3a3bf75e4f9c51e
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Apr 13 14:23:57 2020 +0200

    efi/libstub: Move efi_relocate_kernel() into separate source file
    
    Move efi_relocate_kernel() into a separate source file, so that it
    only gets pulled into builds for architectures that use it. Since
    efi_relocate_kernel() is the only user of efi_low_alloc(), let's
    move that over as well.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index baa0bc166074..2a0698d9dc78 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -639,21 +639,6 @@ char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len,
 
 efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
 
-efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
-				 unsigned long *addr, unsigned long min);
-
-static inline
-efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
-			   unsigned long *addr)
-{
-	/*
-	 * Don't allocate at 0x0. It will confuse code that
-	 * checks pointers against NULL. Skip the first 8
-	 * bytes so we start at a nice even number.
-	 */
-	return efi_low_alloc_above(size, align, addr, 0x8);
-}
-
 efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
 				unsigned long max);
 

commit 43b1df0e013c25abb536699f46d0e9f291b586a0
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Mar 27 16:09:40 2020 +0100

    efi/libstub: Add API function to allocate aligned memory
    
    Break out the code to create an aligned page allocation from mem.c
    and move it into a function efi_allocate_pages_aligned() in alignedmem.c.
    Update efi_allocate_pages() to invoke it unless the minimum alignment
    equals the EFI page size (4 KB), in which case the ordinary page
    allocator is sufficient. This way, efi_allocate_pages_aligned() will
    only be pulled into the build if it is actually being used (which will
    be on arm64 only in the immediate future)
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 9af65be3b278..baa0bc166074 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -657,6 +657,9 @@ efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
 efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
 				unsigned long max);
 
+efi_status_t efi_allocate_pages_aligned(unsigned long size, unsigned long *addr,
+					unsigned long max, unsigned long align);
+
 efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 				 unsigned long image_size,
 				 unsigned long alloc_size,

commit fffb68047e563fb74f782c726e9bdf1fa117d93d
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Mar 19 22:00:25 2020 -0400

    efi/gop: Allow specifying mode number on command line
    
    Add the ability to choose a video mode for the selected gop by using a
    command-line argument of the form
            video=efifb:mode=<n>
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200320020028.1936003-12-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 321244ed20a4..9af65be3b278 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -666,6 +666,8 @@ efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 
 efi_status_t efi_parse_options(char const *cmdline);
 
+void efi_parse_option_graphics(char *option);
+
 efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 			   unsigned long size);
 

commit b4b89a02724245c4f4eda9dbfb7895ddf122ca7f
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Mar 19 22:00:24 2020 -0400

    efi/gop: Add prototypes for query_mode and set_mode
    
    Add prototypes and argmap for the Graphics Output Protocol's QueryMode
    and SetMode functions.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200320020028.1936003-11-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index d9ad8582dbea..321244ed20a4 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -314,8 +314,10 @@ typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
 
 union efi_graphics_output_protocol {
 	struct {
-		void *query_mode;
-		void *set_mode;
+		efi_status_t (__efiapi *query_mode)(efi_graphics_output_protocol_t *,
+						    u32, unsigned long *,
+						    efi_graphics_output_mode_info_t **);
+		efi_status_t (__efiapi *set_mode)  (efi_graphics_output_protocol_t *, u32);
 		void *blt;
 		efi_graphics_output_protocol_mode_t *mode;
 	};

commit 22090f84bc3f8081e0ec180ccaedc85820085376
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Apr 23 13:44:50 2020 +0200

    efi/libstub: unify EFI call wrappers for non-x86
    
    We have wrappers around EFI calls so that x86 can define special
    versions for mixed mode, while all other architectures can use the
    same simple definition that just issues the call directly.
    In preparation for the arrival of yet another architecture that doesn't
    need anything special here (RISC-V), let's move the default definition
    into a shared header.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 7517683b31e9..d9ad8582dbea 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -39,6 +39,22 @@ extern bool __pure novamap(void);
 
 extern __pure efi_system_table_t  *efi_system_table(void);
 
+#ifndef efi_bs_call
+#define efi_bs_call(func, ...)	efi_system_table()->boottime->func(__VA_ARGS__)
+#endif
+#ifndef efi_rt_call
+#define efi_rt_call(func, ...)	efi_system_table()->runtime->func(__VA_ARGS__)
+#endif
+#ifndef efi_is_native
+#define efi_is_native()		(true)
+#endif
+#ifndef efi_table_attr
+#define efi_table_attr(inst, attr)	(inst->attr)
+#endif
+#ifndef efi_call_proto
+#define efi_call_proto(inst, func, ...) inst->func(inst, ##__VA_ARGS__)
+#endif
+
 #define pr_efi(msg)		do {			\
 	if (!is_quiet()) efi_printk("EFI stub: "msg);	\
 } while (0)

commit cf6b83664895a5c7e97710df282e220bd047f0f5
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Apr 21 09:17:35 2020 +0200

    efi/libstub: Make initrd file loader configurable
    
    Loading an initrd passed via the kernel command line is deprecated: it
    is limited to files that reside in the same volume as the one the kernel
    itself was loaded from, and we have more flexible ways to achieve the
    same. So make it configurable so new architectures can decide not to
    enable it.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 67d26949fd26..7517683b31e9 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -651,15 +651,35 @@ efi_status_t efi_parse_options(char const *cmdline);
 efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 			   unsigned long size);
 
-efi_status_t efi_load_dtb(efi_loaded_image_t *image,
-			  unsigned long *load_addr,
-			  unsigned long *load_size);
-
-efi_status_t efi_load_initrd(efi_loaded_image_t *image,
-			     unsigned long *load_addr,
-			     unsigned long *load_size,
-			     unsigned long soft_limit,
-			     unsigned long hard_limit);
+efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
+				  const efi_char16_t *optstr,
+				  int optstr_size,
+				  unsigned long soft_limit,
+				  unsigned long hard_limit,
+				  unsigned long *load_addr,
+				  unsigned long *load_size);
+
+
+static inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,
+					unsigned long *load_addr,
+					unsigned long *load_size)
+{
+	return handle_cmdline_files(image, L"dtb=", sizeof(L"dtb=") - 2,
+				    ULONG_MAX, ULONG_MAX, load_addr, load_size);
+}
+
+static inline efi_status_t efi_load_initrd(efi_loaded_image_t *image,
+					   unsigned long *load_addr,
+					   unsigned long *load_size,
+					   unsigned long soft_limit,
+					   unsigned long hard_limit)
+{
+	if (!IS_ENABLED(CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER))
+		return EFI_SUCCESS;
+
+	return handle_cmdline_files(image, L"initrd=", sizeof(L"initrd=") - 2,
+				    soft_limit, hard_limit, load_addr, load_size);
+}
 
 efi_status_t efi_load_initrd_dev_path(unsigned long *load_addr,
 				      unsigned long *load_size,

commit 105cb9544b161819b7be23a8a8419353a3218807
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Thu Apr 9 15:04:28 2020 +0200

    efi/x86: Move efi stub globals from .bss to .data
    
    Commit
    
      3ee372ccce4d ("x86/boot/compressed/64: Remove .bss/.pgtable from bzImage")
    
    removed the .bss section from the bzImage.
    
    However, while a PE loader is required to zero-initialize the .bss
    section before calling the PE entry point, the EFI handover protocol
    does not currently document any requirement that .bss be initialized by
    the bootloader prior to calling the handover entry.
    
    When systemd-boot is used to boot a unified kernel image [1], the image
    is constructed by embedding the bzImage as a .linux section in a PE
    executable that contains a small stub loader from systemd together with
    additional sections and potentially an initrd. As the .bss section
    within the bzImage is no longer explicitly present as part of the file,
    it is not initialized before calling the EFI handover entry.
    Furthermore, as the size of the embedded .linux section is only the size
    of the bzImage file itself, the .bss section's memory may not even have
    been allocated.
    
    In particular, this can result in efi_disable_pci_dma being true even
    when it was not specified via the command line or configuration option,
    which in turn causes crashes while booting on some systems.
    
    To avoid issues, place all EFI stub global variables into the .data
    section instead of .bss. As of this writing, only boolean flags for a
    few command line arguments and the sys_table pointer were in .bss and
    will now move into the .data section.
    
    [1] https://systemd.io/BOOT_LOADER_SPECIFICATION/#type-2-efi-unified-kernel-images
    
    Fixes: 3ee372ccce4d ("x86/boot/compressed/64: Remove .bss/.pgtable from bzImage")
    Reported-by: Sergey Shatunov <me@prok.pw>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200406180614.429454-1-nivedita@alum.mit.edu
    Link: https://lore.kernel.org/r/20200409130434.6736-4-ardb@kernel.org

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index cc90a748bcf0..67d26949fd26 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,7 +25,7 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-#ifdef CONFIG_ARM
+#if defined(CONFIG_ARM) || defined(CONFIG_X86)
 #define __efistub_global	__section(.data)
 #else
 #define __efistub_global

commit 3b8f44fc0810d51b58837cf7fdba3f72f8cffcdc
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Feb 16 00:03:25 2020 +0100

    efi/libstub/x86: Use Exit() boot service to exit the stub on errors
    
    Currently, we either return with an error [from efi_pe_entry()] or
    enter a deadloop [in efi_main()] if any fatal errors occur during
    execution of the EFI stub. Let's switch to calling the Exit() EFI boot
    service instead in both cases, so that we
    a) can get rid of the deadloop, and simply return to the boot manager
       if any errors occur during execution of the stub, including during
       the call to ExitBootServices(),
    b) can also return cleanly from efi_pe_entry() or efi_main() in mixed
       mode, once we introduce support for LoadImage/StartImage based mixed
       mode in the next patch.
    
    Note that on systems running downstream GRUBs [which do not use LoadImage
    or StartImage to boot the kernel, and instead, pass their own image
    handle as the loaded image handle], calling Exit() will exit from GRUB
    rather than from the kernel, but this is a tolerable side effect.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 6960e730f990..cc90a748bcf0 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -144,7 +144,10 @@ union efi_boot_services {
 								     void *);
 		void *load_image;
 		void *start_image;
-		void *exit;
+		efi_status_t __noreturn (__efiapi *exit)(efi_handle_t,
+							 efi_status_t,
+							 unsigned long,
+							 efi_char16_t *);
 		void *unload_image;
 		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
 							    unsigned long);

commit f7b85b33eb0b3025830a102b01e6e1c3426cdf13
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Feb 14 14:29:21 2020 +0100

    efi/libstub/x86: Make loaded_image protocol handling mixed mode safe
    
    Add the definitions and use the special wrapper so that the loaded_image
    UEFI protocol can be safely used from mixed mode.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 2e5e79edb4d7..6960e730f990 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -308,20 +308,37 @@ union efi_graphics_output_protocol {
 	} mixed_mode;
 };
 
-typedef struct {
-	u32			revision;
-	efi_handle_t		parent_handle;
-	efi_system_table_t	*system_table;
-	efi_handle_t		device_handle;
-	void			*file_path;
-	void			*reserved;
-	u32			load_options_size;
-	void			*load_options;
-	void			*image_base;
-	__aligned_u64		image_size;
-	unsigned int		image_code_type;
-	unsigned int		image_data_type;
-	efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
+typedef union {
+	struct {
+		u32			revision;
+		efi_handle_t		parent_handle;
+		efi_system_table_t	*system_table;
+		efi_handle_t		device_handle;
+		void			*file_path;
+		void			*reserved;
+		u32			load_options_size;
+		void			*load_options;
+		void			*image_base;
+		__aligned_u64		image_size;
+		unsigned int		image_code_type;
+		unsigned int		image_data_type;
+		efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
+	};
+	struct {
+		u32		revision;
+		u32		parent_handle;
+		u32		system_table;
+		u32		device_handle;
+		u32		file_path;
+		u32		reserved;
+		u32		load_options_size;
+		u32		load_options;
+		u32		image_base;
+		__aligned_u64	image_size;
+		u32		image_code_type;
+		u32		image_data_type;
+		u32		unload;
+	} mixed_mode;
 } efi_loaded_image_t;
 
 typedef struct {

commit 79d3219d4e56b3c47fc5184aa962dac886a73729
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Feb 4 22:01:22 2020 +0000

    efi/libstub: Take noinitrd cmdline argument into account for devpath initrd
    
    One of the advantages of using what basically amounts to a callback
    interface into the bootloader for loading the initrd is that it provides
    a natural place for the bootloader or firmware to measure the initrd
    contents while they are being passed to the kernel.
    
    Unfortunately, this is not a guarantee that the initrd will in fact be
    loaded and its /init invoked by the kernel, since the command line may
    contain the 'noinitrd' option, in which case the initrd is ignored, but
    this will not be reflected in the PCR that covers the initrd measurement.
    
    This could be addressed by measuring the command line as well, and
    including that PCR in the attestation policy, but this locks down the
    command line completely, which may be too restrictive.
    
    So let's take the noinitrd argument into account in the stub, too. This
    forces any PCR that covers the initrd to assume a different value when
    noinitrd is passed, allowing an attestation policy to disregard the
    command line if there is no need to take its measurement into account
    for other reasons.
    
    As Peter points out, this would still require the agent that takes the
    measurements to measure a separator event into the PCR in question at
    ExitBootServices() time, to prevent replay attacks using the known
    measurement from the TPM log.
    
    Cc: Peter Jones <pjones@redhat.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index b58cb2c4474e..2e5e79edb4d7 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -33,6 +33,7 @@
 
 extern bool __pure nochunk(void);
 extern bool __pure nokaslr(void);
+extern bool __pure noinitrd(void);
 extern bool __pure is_quiet(void);
 extern bool __pure novamap(void);
 

commit ec93fc371f014a6fb483e3556061ecad4b40735c
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 3 23:45:14 2020 +0000

    efi/libstub: Add support for loading the initrd from a device path
    
    There are currently two ways to specify the initrd to be passed to the
    Linux kernel when booting via the EFI stub:
    - it can be passed as a initrd= command line option when doing a pure PE
      boot (as opposed to the EFI handover protocol that exists for x86)
    - otherwise, the bootloader or firmware can load the initrd into memory,
      and pass the address and size via the bootparams struct (x86) or
      device tree (ARM)
    
    In the first case, we are limited to loading from the same file system
    that the kernel was loaded from, and it is also problematic in a trusted
    boot context, given that we cannot easily protect the command line from
    tampering without either adding complicated white/blacklisting of boot
    arguments or locking down the command line altogether.
    
    In the second case, we force the bootloader to duplicate knowledge about
    the boot protocol which is already encoded in the stub, and which may be
    subject to change over time, e.g., bootparams struct definitions, memory
    allocation/alignment requirements for the placement of the initrd etc etc.
    In the ARM case, it also requires the bootloader to modify the hardware
    description provided by the firmware, as it is passed in the same file.
    On systems where the initrd is measured after loading, it creates a time
    window where the initrd contents might be manipulated in memory before
    handing over to the kernel.
    
    Address these concerns by adding support for loading the initrd into
    memory by invoking the EFI LoadFile2 protocol installed on a vendor
    GUIDed device path that specifically designates a Linux initrd.
    This addresses the above concerns, by putting the EFI stub in charge of
    placement in memory and of passing the base and size to the kernel proper
    (via whatever means it desires) while still leaving it up to the firmware
    or bootloader to obtain the file contents, potentially from other file
    systems than the one the kernel itself was loaded from. On platforms that
    implement measured boot, it permits the firmware to take the measurement
    right before the kernel actually consumes the contents.
    
    Acked-by: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
    Acked-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 34fe3fad042f..b58cb2c4474e 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -640,4 +640,8 @@ efi_status_t efi_load_initrd(efi_loaded_image_t *image,
 			     unsigned long soft_limit,
 			     unsigned long hard_limit);
 
+efi_status_t efi_load_initrd_dev_path(unsigned long *load_addr,
+				      unsigned long *load_size,
+				      unsigned long max);
+
 #endif

commit 2931d526d5674940d916a4b513a681ee3562e574
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:48 2020 +0100

    efi/libstub: Make the LoadFile EFI protocol accessible
    
    Add the protocol definitions, GUIDs and mixed mode glue so that
    the EFI loadfile protocol can be used from the stub. This will
    be used in a future patch to load the initrd.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index afa774a312f5..34fe3fad042f 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -541,6 +541,20 @@ union efi_tcg2_protocol {
 	} mixed_mode;
 };
 
+typedef union efi_load_file_protocol efi_load_file_protocol_t;
+typedef union efi_load_file_protocol efi_load_file2_protocol_t;
+
+union efi_load_file_protocol {
+	struct {
+		efi_status_t (__efiapi *load_file)(efi_load_file_protocol_t *,
+						   efi_device_path_protocol_t *,
+						   bool, unsigned long *, void *);
+	};
+	struct {
+		u32 load_file;
+	} mixed_mode;
+};
+
 void efi_pci_disable_bridge_busmaster(void);
 
 typedef efi_status_t (*efi_exit_boot_map_processing)(

commit abd268685a21cb5d0c991bb21a88ea0c1d2e15d8
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:47 2020 +0100

    efi/libstub: Expose LocateDevicePath boot service
    
    We will be adding support for loading the initrd from a GUIDed
    device path in a subsequent patch, so update the prototype of
    the LocateDevicePath() boot service to make it callable from
    our code.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index d282d907cd33..afa774a312f5 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -100,6 +100,8 @@ struct efi_boot_memmap {
 	unsigned long		*buff_size;
 };
 
+typedef struct efi_generic_dev_path efi_device_path_protocol_t;
+
 /*
  * EFI Boot Services table
  */
@@ -134,7 +136,9 @@ union efi_boot_services {
 		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
 						       void *, unsigned long *,
 						       efi_handle_t *);
-		void *locate_device_path;
+		efi_status_t (__efiapi *locate_device_path)(efi_guid_t *,
+							    efi_device_path_protocol_t **,
+							    efi_handle_t *);
 		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
 								     void *);
 		void *load_image;

commit 31f5e546655b502d508e160e6cab20462089e34d
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:45 2020 +0100

    efi/libstub: Take soft and hard memory limits into account for initrd loading
    
    On x86, the preferred load address of the initrd is still below 4 GB,
    even though in some cases, we can cope with an initrd that is loaded
    above that.
    
    To simplify the code, and to make it more straightforward to introduce
    other ways to load the initrd, pass the soft and hard memory limits at
    the same time, and let the code handling the initrd= command line option
    deal with this.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 60d929469b8b..d282d907cd33 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -619,6 +619,7 @@ efi_status_t efi_load_dtb(efi_loaded_image_t *image,
 efi_status_t efi_load_initrd(efi_loaded_image_t *image,
 			     unsigned long *load_addr,
 			     unsigned long *load_size,
-			     unsigned long max_addr);
+			     unsigned long soft_limit,
+			     unsigned long hard_limit);
 
 #endif

commit 9302c1bb8e475829330146423626c3d32e8cb012
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:44 2020 +0100

    efi/libstub: Rewrite file I/O routine
    
    The file I/O routine that is used to load initrd or dtb files from
    the EFI system partition suffers from a few issues:
    - it converts the u8[] command line back to a UTF-16 string, which is
      pointless since we only handle initrd or dtb arguments provided via
      the loaded image protocol anyway, which is where we got the UTF-16[]
      command line from in the first place when booting via the PE entry
      point,
    - in the far majority of cases, only a single initrd= option is present,
      but it optimizes for multiple options, by going over the command line
      twice, allocating heap buffers for dynamically sized arrays, etc.
    - the coding style is hard to follow, with few comments, and all logic
      including string parsing etc all combined in a single routine.
    
    Let's fix this by rewriting most of it, based on the idea that in the
    case of multiple initrds, we can just allocate a new, bigger buffer
    and copy over the data before freeing the old one.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index e057d509d5d8..60d929469b8b 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -327,7 +327,7 @@ typedef struct {
 	efi_time_t		last_access_time;
 	efi_time_t		modification_time;
 	__aligned_u64		attribute;
-	efi_char16_t		filename[1];
+	efi_char16_t		filename[];
 } efi_file_info_t;
 
 typedef struct efi_file_protocol efi_file_protocol_t;
@@ -607,15 +607,18 @@ efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 				 unsigned long alignment,
 				 unsigned long min_addr);
 
-efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
-				  char *cmd_line, char *option_string,
-				  unsigned long max_addr,
-				  unsigned long *load_addr,
-				  unsigned long *load_size);
-
 efi_status_t efi_parse_options(char const *cmdline);
 
 efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 			   unsigned long size);
 
+efi_status_t efi_load_dtb(efi_loaded_image_t *image,
+			  unsigned long *load_addr,
+			  unsigned long *load_size);
+
+efi_status_t efi_load_initrd(efi_loaded_image_t *image,
+			     unsigned long *load_addr,
+			     unsigned long *load_size,
+			     unsigned long max_addr);
+
 #endif

commit 5193a33d78ce8b4fdf880a754700bce21b3756b5
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:43 2020 +0100

    efi/libstub: Move file I/O support code into separate file
    
    Split off the file I/O support code into a separate source file so
    it ends up in a separate object file in the static library, allowing
    the linker to omit it if the routines are not used.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 5123def761e9..e057d509d5d8 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -31,6 +31,7 @@
 #define __efistub_global
 #endif
 
+extern bool __pure nochunk(void);
 extern bool __pure nokaslr(void);
 extern bool __pure is_quiet(void);
 extern bool __pure novamap(void);

commit b87174541abcad8d37ab799fa431ca225175ca19
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:42 2020 +0100

    efi/libstub: Move get_dram_base() into arm-stub.c
    
    get_dram_base() is only called from arm-stub.c so move it into
    the same source file as its caller.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index b94c63d17a4f..5123def761e9 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -549,8 +549,6 @@ efi_status_t efi_exit_boot_services(void *handle,
 
 void efi_char16_printk(efi_char16_t *);
 
-unsigned long get_dram_base(void);
-
 efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
 					    unsigned long *new_fdt_addr,
 					    unsigned long max_addr,

commit 1e45bf7372c48c78e1f7e538fd3e612946f6ad20
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:40 2020 +0100

    efi/libstub/x86: Permit cmdline data to be allocated above 4 GB
    
    We now support cmdline data that is located in memory that is not
    32-bit addressable, so relax the allocation limit on systems where
    this feature is enabled.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 8bb46c1fd2cd..b94c63d17a4f 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -578,7 +578,8 @@ void efi_printk(char *str);
 
 void efi_free(unsigned long size, unsigned long addr);
 
-char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
+char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len,
+			  unsigned long max_addr);
 
 efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
 

commit 8166ec091573fad528d884ede291fd1ec02d0298
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:38 2020 +0100

    efi/libstub: Move stub specific declarations into efistub.h
    
    Move all the declarations that are only used in stub code from
    linux/efi.h to efistub.h which is only included locally.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 79cdb219f439..8bb46c1fd2cd 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -43,34 +43,6 @@ extern __pure efi_system_table_t  *efi_system_table(void);
 
 #define pr_efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
 
-void efi_char16_printk(efi_char16_t *);
-void efi_char16_printk(efi_char16_t *);
-
-unsigned long get_dram_base(void);
-
-efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
-					    unsigned long *new_fdt_addr,
-					    unsigned long max_addr,
-					    u64 initrd_addr, u64 initrd_size,
-					    char *cmdline_ptr,
-					    unsigned long fdt_addr,
-					    unsigned long fdt_size);
-
-void *get_fdt(unsigned long *fdt_size);
-
-void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
-		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
-		     int *count);
-
-efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
-
-efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
-			      unsigned long *addr, unsigned long random_seed);
-
-efi_status_t check_platform_features(void);
-
-void *get_efi_config_table(efi_guid_t guid);
-
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var
 #define fdt_setprop_inplace_var(fdt, node_offset, name, var) \
@@ -90,6 +62,156 @@ void *get_efi_config_table(efi_guid_t guid);
 	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
 		    (efi_guid_t *)(vendor), __VA_ARGS__)
 
+#define efi_get_handle_at(array, idx)					\
+	(efi_is_native() ? (array)[idx] 				\
+		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
+
+#define efi_get_handle_num(size)					\
+	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
+
+#define for_each_efi_handle(handle, array, size, i)			\
+	for (i = 0;							\
+	     i < efi_get_handle_num(size) &&				\
+		((handle = efi_get_handle_at((array), i)) || true);	\
+	     i++)
+
+/*
+ * Allocation types for calls to boottime->allocate_pages.
+ */
+#define EFI_ALLOCATE_ANY_PAGES		0
+#define EFI_ALLOCATE_MAX_ADDRESS	1
+#define EFI_ALLOCATE_ADDRESS		2
+#define EFI_MAX_ALLOCATE_TYPE		3
+
+/*
+ * The type of search to perform when calling boottime->locate_handle
+ */
+#define EFI_LOCATE_ALL_HANDLES			0
+#define EFI_LOCATE_BY_REGISTER_NOTIFY		1
+#define EFI_LOCATE_BY_PROTOCOL			2
+
+struct efi_boot_memmap {
+	efi_memory_desc_t	**map;
+	unsigned long		*map_size;
+	unsigned long		*desc_size;
+	u32			*desc_ver;
+	unsigned long		*key_ptr;
+	unsigned long		*buff_size;
+};
+
+/*
+ * EFI Boot Services table
+ */
+union efi_boot_services {
+	struct {
+		efi_table_hdr_t hdr;
+		void *raise_tpl;
+		void *restore_tpl;
+		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
+							efi_physical_addr_t *);
+		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
+						    unsigned long);
+		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
+							unsigned long *,
+							unsigned long *, u32 *);
+		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
+						       void **);
+		efi_status_t (__efiapi *free_pool)(void *);
+		void *create_event;
+		void *set_timer;
+		void *wait_for_event;
+		void *signal_event;
+		void *close_event;
+		void *check_event;
+		void *install_protocol_interface;
+		void *reinstall_protocol_interface;
+		void *uninstall_protocol_interface;
+		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
+							 efi_guid_t *, void **);
+		void *__reserved;
+		void *register_protocol_notify;
+		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
+						       void *, unsigned long *,
+						       efi_handle_t *);
+		void *locate_device_path;
+		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
+								     void *);
+		void *load_image;
+		void *start_image;
+		void *exit;
+		void *unload_image;
+		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
+							    unsigned long);
+		void *get_next_monotonic_count;
+		void *stall;
+		void *set_watchdog_timer;
+		void *connect_controller;
+		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
+							       efi_handle_t,
+							       efi_handle_t);
+		void *open_protocol;
+		void *close_protocol;
+		void *open_protocol_information;
+		void *protocols_per_handle;
+		void *locate_handle_buffer;
+		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
+							 void **);
+		void *install_multiple_protocol_interfaces;
+		void *uninstall_multiple_protocol_interfaces;
+		void *calculate_crc32;
+		void *copy_mem;
+		void *set_mem;
+		void *create_event_ex;
+	};
+	struct {
+		efi_table_hdr_t hdr;
+		u32 raise_tpl;
+		u32 restore_tpl;
+		u32 allocate_pages;
+		u32 free_pages;
+		u32 get_memory_map;
+		u32 allocate_pool;
+		u32 free_pool;
+		u32 create_event;
+		u32 set_timer;
+		u32 wait_for_event;
+		u32 signal_event;
+		u32 close_event;
+		u32 check_event;
+		u32 install_protocol_interface;
+		u32 reinstall_protocol_interface;
+		u32 uninstall_protocol_interface;
+		u32 handle_protocol;
+		u32 __reserved;
+		u32 register_protocol_notify;
+		u32 locate_handle;
+		u32 locate_device_path;
+		u32 install_configuration_table;
+		u32 load_image;
+		u32 start_image;
+		u32 exit;
+		u32 unload_image;
+		u32 exit_boot_services;
+		u32 get_next_monotonic_count;
+		u32 stall;
+		u32 set_watchdog_timer;
+		u32 connect_controller;
+		u32 disconnect_controller;
+		u32 open_protocol;
+		u32 close_protocol;
+		u32 open_protocol_information;
+		u32 protocols_per_handle;
+		u32 locate_handle_buffer;
+		u32 locate_protocol;
+		u32 install_multiple_protocol_interfaces;
+		u32 uninstall_multiple_protocol_interfaces;
+		u32 calculate_crc32;
+		u32 copy_mem;
+		u32 set_mem;
+		u32 create_event_ex;
+	} mixed_mode;
+};
+
 typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
 
 union efi_uga_draw_protocol {
@@ -106,7 +228,81 @@ union efi_uga_draw_protocol {
 	} mixed_mode;
 };
 
-typedef struct efi_loaded_image {
+union efi_simple_text_output_protocol {
+	struct {
+		void *reset;
+		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
+						       efi_char16_t *);
+		void *test_string;
+	};
+	struct {
+		u32 reset;
+		u32 output_string;
+		u32 test_string;
+	} mixed_mode;
+};
+
+#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
+#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
+#define PIXEL_BIT_MASK					2
+#define PIXEL_BLT_ONLY					3
+#define PIXEL_FORMAT_MAX				4
+
+typedef struct {
+	u32 red_mask;
+	u32 green_mask;
+	u32 blue_mask;
+	u32 reserved_mask;
+} efi_pixel_bitmask_t;
+
+typedef struct {
+	u32 version;
+	u32 horizontal_resolution;
+	u32 vertical_resolution;
+	int pixel_format;
+	efi_pixel_bitmask_t pixel_information;
+	u32 pixels_per_scan_line;
+} efi_graphics_output_mode_info_t;
+
+typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
+
+union efi_graphics_output_protocol_mode {
+	struct {
+		u32 max_mode;
+		u32 mode;
+		efi_graphics_output_mode_info_t *info;
+		unsigned long size_of_info;
+		efi_physical_addr_t frame_buffer_base;
+		unsigned long frame_buffer_size;
+	};
+	struct {
+		u32 max_mode;
+		u32 mode;
+		u32 info;
+		u32 size_of_info;
+		u64 frame_buffer_base;
+		u32 frame_buffer_size;
+	} mixed_mode;
+};
+
+typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
+
+union efi_graphics_output_protocol {
+	struct {
+		void *query_mode;
+		void *set_mode;
+		void *blt;
+		efi_graphics_output_protocol_mode_t *mode;
+	};
+	struct {
+		u32 query_mode;
+		u32 set_mode;
+		u32 blt;
+		u32 mode;
+	} mixed_mode;
+};
+
+typedef struct {
 	u32			revision;
 	efi_handle_t		parent_handle;
 	efi_system_table_t	*system_table;
@@ -169,4 +365,257 @@ struct efi_simple_file_system_protocol {
 #define EFI_FILE_MODE_WRITE	0x0000000000000002
 #define EFI_FILE_MODE_CREATE	0x8000000000000000
 
+typedef enum {
+	EfiPciIoWidthUint8,
+	EfiPciIoWidthUint16,
+	EfiPciIoWidthUint32,
+	EfiPciIoWidthUint64,
+	EfiPciIoWidthFifoUint8,
+	EfiPciIoWidthFifoUint16,
+	EfiPciIoWidthFifoUint32,
+	EfiPciIoWidthFifoUint64,
+	EfiPciIoWidthFillUint8,
+	EfiPciIoWidthFillUint16,
+	EfiPciIoWidthFillUint32,
+	EfiPciIoWidthFillUint64,
+	EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+typedef enum {
+	EfiPciIoAttributeOperationGet,
+	EfiPciIoAttributeOperationSet,
+	EfiPciIoAttributeOperationEnable,
+	EfiPciIoAttributeOperationDisable,
+	EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+typedef struct {
+	u32 read;
+	u32 write;
+} efi_pci_io_protocol_access_32_t;
+
+typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
+
+typedef
+efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
+						   EFI_PCI_IO_PROTOCOL_WIDTH,
+						   u32 offset,
+						   unsigned long count,
+						   void *buffer);
+
+typedef struct {
+	void *read;
+	void *write;
+} efi_pci_io_protocol_access_t;
+
+typedef struct {
+	efi_pci_io_protocol_cfg_t read;
+	efi_pci_io_protocol_cfg_t write;
+} efi_pci_io_protocol_config_access_t;
+
+union efi_pci_io_protocol {
+	struct {
+		void *poll_mem;
+		void *poll_io;
+		efi_pci_io_protocol_access_t mem;
+		efi_pci_io_protocol_access_t io;
+		efi_pci_io_protocol_config_access_t pci;
+		void *copy_mem;
+		void *map;
+		void *unmap;
+		void *allocate_buffer;
+		void *free_buffer;
+		void *flush;
+		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
+						      unsigned long *segment_nr,
+						      unsigned long *bus_nr,
+						      unsigned long *device_nr,
+						      unsigned long *func_nr);
+		void *attributes;
+		void *get_bar_attributes;
+		void *set_bar_attributes;
+		uint64_t romsize;
+		void *romimage;
+	};
+	struct {
+		u32 poll_mem;
+		u32 poll_io;
+		efi_pci_io_protocol_access_32_t mem;
+		efi_pci_io_protocol_access_32_t io;
+		efi_pci_io_protocol_access_32_t pci;
+		u32 copy_mem;
+		u32 map;
+		u32 unmap;
+		u32 allocate_buffer;
+		u32 free_buffer;
+		u32 flush;
+		u32 get_location;
+		u32 attributes;
+		u32 get_bar_attributes;
+		u32 set_bar_attributes;
+		u64 romsize;
+		u32 romimage;
+	} mixed_mode;
+};
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
+
+struct efi_dev_path;
+
+typedef union apple_properties_protocol apple_properties_protocol_t;
+
+union apple_properties_protocol {
+	struct {
+		unsigned long version;
+		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *, void *, u32 *);
+		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *, void *, u32);
+		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *);
+		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
+						 void *buffer, u32 *);
+	};
+	struct {
+		u32 version;
+		u32 get;
+		u32 set;
+		u32 del;
+		u32 get_all;
+	} mixed_mode;
+};
+
+typedef u32 efi_tcg2_event_log_format;
+
+typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
+
+union efi_tcg2_protocol {
+	struct {
+		void *get_capability;
+		efi_status_t (__efiapi *get_event_log)(efi_handle_t,
+						       efi_tcg2_event_log_format,
+						       efi_physical_addr_t *,
+						       efi_physical_addr_t *,
+						       efi_bool_t *);
+		void *hash_log_extend_event;
+		void *submit_command;
+		void *get_active_pcr_banks;
+		void *set_active_pcr_banks;
+		void *get_result_of_set_active_pcr_banks;
+	};
+	struct {
+		u32 get_capability;
+		u32 get_event_log;
+		u32 hash_log_extend_event;
+		u32 submit_command;
+		u32 get_active_pcr_banks;
+		u32 set_active_pcr_banks;
+		u32 get_result_of_set_active_pcr_banks;
+	} mixed_mode;
+};
+
+void efi_pci_disable_bridge_busmaster(void);
+
+typedef efi_status_t (*efi_exit_boot_map_processing)(
+	struct efi_boot_memmap *map,
+	void *priv);
+
+efi_status_t efi_exit_boot_services(void *handle,
+				    struct efi_boot_memmap *map,
+				    void *priv,
+				    efi_exit_boot_map_processing priv_func);
+
+void efi_char16_printk(efi_char16_t *);
+
+unsigned long get_dram_base(void);
+
+efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
+					    unsigned long *new_fdt_addr,
+					    unsigned long max_addr,
+					    u64 initrd_addr, u64 initrd_size,
+					    char *cmdline_ptr,
+					    unsigned long fdt_addr,
+					    unsigned long fdt_size);
+
+void *get_fdt(unsigned long *fdt_size);
+
+void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
+		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
+		     int *count);
+
+efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
+
+efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
+			      unsigned long *addr, unsigned long random_seed);
+
+efi_status_t check_platform_features(void);
+
+void *get_efi_config_table(efi_guid_t guid);
+
+void efi_printk(char *str);
+
+void efi_free(unsigned long size, unsigned long addr);
+
+char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
+
+efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
+
+efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
+				 unsigned long *addr, unsigned long min);
+
+static inline
+efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
+			   unsigned long *addr)
+{
+	/*
+	 * Don't allocate at 0x0. It will confuse code that
+	 * checks pointers against NULL. Skip the first 8
+	 * bytes so we start at a nice even number.
+	 */
+	return efi_low_alloc_above(size, align, addr, 0x8);
+}
+
+efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
+				unsigned long max);
+
+efi_status_t efi_relocate_kernel(unsigned long *image_addr,
+				 unsigned long image_size,
+				 unsigned long alloc_size,
+				 unsigned long preferred_addr,
+				 unsigned long alignment,
+				 unsigned long min_addr);
+
+efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
+				  char *cmd_line, char *option_string,
+				  unsigned long max_addr,
+				  unsigned long *load_addr,
+				  unsigned long *load_size);
+
+efi_status_t efi_parse_options(char const *cmdline);
+
+efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
+			   unsigned long size);
+
 #endif

commit a46a290a01149120f40f83a694d3e6041bcf8f70
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:37 2020 +0100

    efi/libstub: Use consistent type names for file I/O protocols
    
    Align the naming of efi_file_io_interface_t and efi_file_handle_t with
    the UEFI spec, and call them efi_simple_file_system_protocol_t and
    efi_file_protocol_t, respectively, using the same convention we use
    for all other type definitions that originate in the UEFI spec.
    
    While at it, move the definitions to efistub.h, so they are only seen
    by code that needs them.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 55de118e8267..79cdb219f439 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -106,4 +106,67 @@ union efi_uga_draw_protocol {
 	} mixed_mode;
 };
 
+typedef struct efi_loaded_image {
+	u32			revision;
+	efi_handle_t		parent_handle;
+	efi_system_table_t	*system_table;
+	efi_handle_t		device_handle;
+	void			*file_path;
+	void			*reserved;
+	u32			load_options_size;
+	void			*load_options;
+	void			*image_base;
+	__aligned_u64		image_size;
+	unsigned int		image_code_type;
+	unsigned int		image_data_type;
+	efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
+} efi_loaded_image_t;
+
+typedef struct {
+	u64			size;
+	u64			file_size;
+	u64			phys_size;
+	efi_time_t		create_time;
+	efi_time_t		last_access_time;
+	efi_time_t		modification_time;
+	__aligned_u64		attribute;
+	efi_char16_t		filename[1];
+} efi_file_info_t;
+
+typedef struct efi_file_protocol efi_file_protocol_t;
+
+struct efi_file_protocol {
+	u64		revision;
+	efi_status_t	(__efiapi *open)	(efi_file_protocol_t *,
+						 efi_file_protocol_t **,
+						 efi_char16_t *, u64, u64);
+	efi_status_t	(__efiapi *close)	(efi_file_protocol_t *);
+	efi_status_t	(__efiapi *delete)	(efi_file_protocol_t *);
+	efi_status_t	(__efiapi *read)	(efi_file_protocol_t *,
+						 unsigned long *, void *);
+	efi_status_t	(__efiapi *write)	(efi_file_protocol_t *,
+						 unsigned long, void *);
+	efi_status_t	(__efiapi *get_position)(efi_file_protocol_t *, u64 *);
+	efi_status_t	(__efiapi *set_position)(efi_file_protocol_t *, u64);
+	efi_status_t	(__efiapi *get_info)	(efi_file_protocol_t *,
+						 efi_guid_t *, unsigned long *,
+						 void *);
+	efi_status_t	(__efiapi *set_info)	(efi_file_protocol_t *,
+						 efi_guid_t *, unsigned long,
+						 void *);
+	efi_status_t	(__efiapi *flush)	(efi_file_protocol_t *);
+};
+
+typedef struct efi_simple_file_system_protocol efi_simple_file_system_protocol_t;
+
+struct efi_simple_file_system_protocol {
+	u64	revision;
+	int	(__efiapi *open_volume)(efi_simple_file_system_protocol_t *,
+					efi_file_protocol_t **);
+};
+
+#define EFI_FILE_MODE_READ	0x0000000000000001
+#define EFI_FILE_MODE_WRITE	0x0000000000000002
+#define EFI_FILE_MODE_CREATE	0x8000000000000000
+
 #endif

commit c2d0b470154c5be39f253da7814742030635f300
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:36 2020 +0100

    efi/libstub/x86: Incorporate eboot.c into libstub
    
    Most of the EFI stub source files of all architectures reside under
    drivers/firmware/efi/libstub, where they share a Makefile with special
    CFLAGS and an include file with declarations that are only relevant
    for stub code.
    
    Currently, we carry a lot of stub specific stuff in linux/efi.h only
    because eboot.c in arch/x86 needs them as well. So let's move eboot.c
    into libstub/, and move the contents of eboot.h that we still care
    about into efistub.h
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index c244b165005e..55de118e8267 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -90,4 +90,20 @@ void *get_efi_config_table(efi_guid_t guid);
 	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
 		    (efi_guid_t *)(vendor), __VA_ARGS__)
 
+typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
+
+union efi_uga_draw_protocol {
+	struct {
+		efi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,
+						  u32*, u32*, u32*, u32*);
+		void *set_mode;
+		void *blt;
+	};
+	struct {
+		u32 get_mode;
+		u32 set_mode;
+		u32 blt;
+	} mixed_mode;
+};
+
 #endif

commit 7d4e323d02c9a37d68c067f5a951307f3af14694
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:24 2019 +0100

    efi/libstub: Tidy up types and names of global cmdline variables
    
    Drop leading underscores and use bool not int for true/false
    variables set on the command line.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-25-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 4e2b33fd6a43..c244b165005e 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,9 +25,15 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
-extern int __pure nokaslr(void);
-extern int __pure is_quiet(void);
-extern int __pure novamap(void);
+#ifdef CONFIG_ARM
+#define __efistub_global	__section(.data)
+#else
+#define __efistub_global
+#endif
+
+extern bool __pure nokaslr(void);
+extern bool __pure is_quiet(void);
+extern bool __pure novamap(void);
 
 extern __pure efi_system_table_t  *efi_system_table(void);
 

commit 966291f6344d7eb6fc3204381a426bafa20a3d18
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:23 2019 +0100

    efi/libstub: Rename efi_call_early/_runtime macros to be more intuitive
    
    The macros efi_call_early and efi_call_runtime are used to call EFI
    boot services and runtime services, respectively. However, the naming
    is confusing, given that the early vs runtime distinction may suggest
    that these are used for calling the same set of services either early
    or late (== at runtime), while in reality, the sets of services they
    can be used with are completely disjoint, and efi_call_runtime is also
    only usable in 'early' code.
    
    So do a global sweep to replace all occurrences with efi_bs_call or
    efi_rt_call, respectively, where BS and RT match the idiom used by
    the UEFI spec to refer to boot time or runtime services.
    
    While at it, use 'func' as the macro parameter name for the function
    pointers, which is less likely to collide and cause weird build errors.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-24-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index b5d9c9e65213..4e2b33fd6a43 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -76,4 +76,12 @@ void *get_efi_config_table(efi_guid_t guid);
 	fdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))
 #endif
 
+#define get_efi_var(name, vendor, ...)				\
+	efi_rt_call(get_variable, (efi_char16_t *)(name),	\
+		    (efi_guid_t *)(vendor), __VA_ARGS__)
+
+#define set_efi_var(name, vendor, ...)				\
+	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
+		    (efi_guid_t *)(vendor), __VA_ARGS__)
+
 #endif

commit cd33a5c1d53e43bef1683c70dc3b68b6d9e8eca6
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:19 2019 +0100

    efi/libstub: Remove 'sys_table_arg' from all function prototypes
    
    We have a helper efi_system_table() that gives us the address of the
    EFI system table in memory, so there is no longer point in passing
    it around from each function to the next.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-20-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 4a6acd28ce65..b5d9c9e65213 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -40,10 +40,9 @@ extern __pure efi_system_table_t  *efi_system_table(void);
 void efi_char16_printk(efi_char16_t *);
 void efi_char16_printk(efi_char16_t *);
 
-unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
+unsigned long get_dram_base(void);
 
-efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
-					    void *handle,
+efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
 					    unsigned long *new_fdt_addr,
 					    unsigned long max_addr,
 					    u64 initrd_addr, u64 initrd_size,
@@ -51,22 +50,20 @@ efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 					    unsigned long fdt_addr,
 					    unsigned long fdt_size);
 
-void *get_fdt(efi_system_table_t *sys_table, unsigned long *fdt_size);
+void *get_fdt(unsigned long *fdt_size);
 
 void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
 		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
 		     int *count);
 
-efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
-				  unsigned long size, u8 *out);
+efi_status_t efi_get_random_bytes(unsigned long size, u8 *out);
 
-efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
-			      unsigned long size, unsigned long align,
+efi_status_t efi_random_alloc(unsigned long size, unsigned long align,
 			      unsigned long *addr, unsigned long random_seed);
 
-efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
+efi_status_t check_platform_features(void);
 
-void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
+void *get_efi_config_table(efi_guid_t guid);
 
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var

commit 8173ec7905b5b07c989b06a105d171c169dde93b
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:18 2019 +0100

    efi/libstub: Drop sys_table_arg from printk routines
    
    As a first step towards getting rid of the need to pass around a function
    parameter 'sys_table_arg' pointing to the EFI system table, remove the
    references to it in the printing code, which is represents the majority
    of the use cases.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-19-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index e6775c16a97d..4a6acd28ce65 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -31,13 +31,14 @@ extern int __pure novamap(void);
 
 extern __pure efi_system_table_t  *efi_system_table(void);
 
-#define pr_efi(sys_table, msg)		do {				\
-	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
+#define pr_efi(msg)		do {			\
+	if (!is_quiet()) efi_printk("EFI stub: "msg);	\
 } while (0)
 
-#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
+#define pr_efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
 
-void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+void efi_char16_printk(efi_char16_t *);
+void efi_char16_printk(efi_char16_t *);
 
 unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
 

commit 2fcdad2a80a6d6fd0f77205108232d1adc709a84
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:15 2019 +0100

    efi/libstub: Get rid of 'sys_table_arg' macro parameter
    
    The efi_call macros on ARM have a dependency on a variable 'sys_table_arg'
    existing in the scope of the macro instantiation. Since this variable
    always points to the same data structure, let's create a global getter
    for it and use that instead.
    
    Note that the use of a global variable with external linkage is avoided,
    given the problems we had in the past with early processing of the GOT
    tables.
    
    While at it, drop the redundant casts in the efi_table_attr and
    efi_call_proto macros.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-16-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 05739ae013c8..e6775c16a97d 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -29,6 +29,8 @@ extern int __pure nokaslr(void);
 extern int __pure is_quiet(void);
 extern int __pure novamap(void);
 
+extern __pure efi_system_table_t  *efi_system_table(void);
+
 #define pr_efi(sys_table, msg)		do {				\
 	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
 } while (0)

commit 0d95981438c3bdb53cc99b0fb656d24d7a80e1f3
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Nov 6 08:06:13 2019 +0100

    x86: efi/random: Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table
    
    Invoke the EFI_RNG_PROTOCOL protocol in the context of the x86 EFI stub,
    same as is done on arm/arm64 since commit 568bc4e87033 ("efi/arm*/libstub:
    Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table"). Within the stub,
    a Linux-specific RNG seed UEFI config table will be seeded. The EFI routines
    in the core kernel will pick that up later, yet still early during boot,
    to seed the kernel entropy pool. If CONFIG_RANDOM_TRUST_BOOTLOADER, entropy
    is credited for this seed.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 7f1556fd867d..05739ae013c8 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -63,8 +63,6 @@ efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
 
 efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
 
-efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
-
 void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
 
 /* Helper macros for the usual case of using simple C variables: */

commit 82d736ac56d7cd78696c5234853684bad05efadf
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Fri Jun 7 13:51:46 2019 -0700

    Abstract out support for locating an EFI config table
    
    We want to grab a pointer to the TPM final events table, so abstract out
    the existing code for finding an FDT table and make it generic.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 1b1dfcaa6fb9..7f1556fd867d 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -65,6 +65,8 @@ efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
 
 efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
 
+void *get_efi_config_table(efi_system_table_t *sys_table, efi_guid_t guid);
+
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var
 #define fdt_setprop_inplace_var(fdt, node_offset, name, var) \

commit 4e46c2a956215482418d7b315749fb1b6c6bc224
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Feb 2 10:41:16 2019 +0100

    efi/arm/arm64: Allow SetVirtualAddressMap() to be omitted
    
    The UEFI spec revision 2.7 errata A section 8.4 has the following to
    say about the virtual memory runtime services:
    
      "This section contains function definitions for the virtual memory
      support that may be optionally used by an operating system at runtime.
      If an operating system chooses to make EFI runtime service calls in a
      virtual addressing mode instead of the flat physical mode, then the
      operating system must use the services in this section to switch the
      EFI runtime services from flat physical addressing to virtual
      addressing."
    
    So it is pretty clear that calling SetVirtualAddressMap() is entirely
    optional, and so there is no point in doing so unless it achieves
    anything useful for us.
    
    This is not the case for 64-bit ARM. The identity mapping used by the
    firmware is arbitrarily converted into another permutation of userland
    addresses (i.e., bits [63:48] cleared), and the runtime code could easily
    deal with the original layout in exactly the same way as it deals with
    the converted layout. However, due to constraints related to page size
    differences if the OS is not running with 4k pages, and related to
    systems that may expose the individual sections of PE/COFF runtime
    modules as different memory regions, creating the virtual layout is a
    bit fiddly, and requires us to sort the memory map and reason about
    adjacent regions with identical memory types etc etc.
    
    So the obvious fix is to stop calling SetVirtualAddressMap() altogether
    on arm64 systems. However, to avoid surprises, which are notoriously
    hard to diagnose when it comes to OS<->firmware interactions, let's
    start by making it an opt-out feature, and implement support for the
    'efi=novamap' kernel command line parameter on ARM and arm64 systems.
    
    ( Note that 32-bit ARM generally does require SetVirtualAddressMap() to be
      used, given that the physical memory map and the kernel virtual address
      map are not guaranteed to be non-overlapping like on arm64. However,
      having support for efi=novamap,noruntime on 32-bit ARM, combined with
      the recently proposed support for earlycon=efifb, is likely to be useful
      to diagnose boot issues on such systems if they have no accessible serial
      port. )
    
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Alexander Graf <agraf@suse.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-8-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index cefcf6ba3150..1b1dfcaa6fb9 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -27,6 +27,7 @@
 
 extern int __pure nokaslr(void);
 extern int __pure is_quiet(void);
+extern int __pure novamap(void);
 
 #define pr_efi(sys_table, msg)		do {				\
 	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\

commit ac9aff8ef99095b9d46d53d0a779f2bda24ba181
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Feb 2 10:41:14 2019 +0100

    efi/fdt: Apply more cleanups
    
    Apply a number of cleanups:
    
     - Introduce fdt_setprop_*var() helper macros to simplify and shorten repetitive
       sequences - this also makes it less likely that the wrong variable size is
       passed in. This change makes a lot of the property-setting calls single-line
       and easier to read.
    
     - Harmonize comment style: capitalization, punctuation, whitespaces, etc.
    
     - Fix some whitespace noise in the libstub Makefile which I happened to notice.
    
     - Use the standard tabular initialization style:
    
        -       map.map =       &runtime_map;
        -       map.map_size =  &map_size;
        -       map.desc_size = &desc_size;
        -       map.desc_ver =  &desc_ver;
        -       map.key_ptr =   &mmap_key;
        -       map.buff_size = &buff_size;
    
        +       map.map         = &runtime_map;
        +       map.map_size    = &map_size;
        +       map.desc_size   = &desc_size;
        +       map.desc_ver    = &desc_ver;
        +       map.key_ptr     = &mmap_key;
        +       map.buff_size   = &buff_size;
    
     - Use tabular structure definition for better readability.
    
     - Make all pr*() lines single-line, even if they marginally exceed 80 cols - this
       makes them visually less intrusive.
    
     - Unbreak line breaks into single lines when the length exceeds 80 cols only
       marginally, for better readability.
    
     - Move assignment closer to the actual usage site.
    
     - Plus some other smaller cleanups, spelling fixes, etc.
    
    No change in functionality intended.
    
    [ ardb: move changes to upstream libfdt into local header. ]
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Alexander Graf <agraf@suse.de>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 32799cf039ef..cefcf6ba3150 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -64,4 +64,15 @@ efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
 
 efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
 
+/* Helper macros for the usual case of using simple C variables: */
+#ifndef fdt_setprop_inplace_var
+#define fdt_setprop_inplace_var(fdt, node_offset, name, var) \
+	fdt_setprop_inplace((fdt), (node_offset), (name), &(var), sizeof(var))
+#endif
+
+#ifndef fdt_setprop_var
+#define fdt_setprop_var(fdt, node_offset, name, var) \
+	fdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))
+#endif
+
 #endif

commit c4db9c1e8c70bc60e392da8a485bcfb035d559c2
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 20 10:47:23 2018 +0900

    efi: Deduplicate efi_open_volume()
    
    There's one ARM, one x86_32 and one x86_64 version of efi_open_volume()
    which can be folded into a single shared version by masking their
    differences with the efi_call_proto() macro introduced by commit:
    
      3552fdf29f01 ("efi: Allow bitness-agnostic protocol calls").
    
    To be able to dereference the device_handle attribute from the
    efi_loaded_image_t table in an arch- and bitness-agnostic manner,
    introduce the efi_table_attr() macro (which already exists for x86)
    to arm and arm64.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180720014726.24031-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index f59564b72ddc..32799cf039ef 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -36,9 +36,6 @@ extern int __pure is_quiet(void);
 
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
-efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,
-			     void **__fh);
-
 unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
 
 efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 83f268c05007..f59564b72ddc 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 
 #ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 #define _DRIVERS_FIRMWARE_EFI_EFISTUB_H

commit eeff7d634f4750306785be709ca444140c29b043
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 4 17:09:09 2017 +0100

    efi/libstub/arm/arm64: Disable debug prints on 'quiet' cmdline arg
    
    The EFI stub currently prints a number of diagnostic messages that do
    not carry a lot of information. Since these prints are not controlled
    by 'loglevel' or other command line parameters, and since they appear on
    the EFI framebuffer as well (if enabled), it would be nice if we could
    turn them off.
    
    So let's add support for the 'quiet' command line parameter in the stub,
    and disable the non-error prints if it is passed.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bhe@redhat.com
    Cc: bhsharma@redhat.com
    Cc: bp@alien8.de
    Cc: eugene@hp.com
    Cc: evgeny.kalugin@intel.com
    Cc: jhugo@codeaurora.org
    Cc: leif.lindholm@linaro.org
    Cc: linux-efi@vger.kernel.org
    Cc: roy.franz@cavium.com
    Cc: rruigrok@codeaurora.org
    Link: http://lkml.kernel.org/r/20170404160910.28115-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index a7a2a2c3f199..83f268c05007 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -25,6 +25,13 @@
 #endif
 
 extern int __pure nokaslr(void);
+extern int __pure is_quiet(void);
+
+#define pr_efi(sys_table, msg)		do {				\
+	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
+} while (0)
+
+#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
 
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 

commit 60f38de7a8d4e816100ceafd1b382df52527bd50
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 4 17:09:08 2017 +0100

    efi/libstub: Unify command line param parsing
    
    Merge the parsing of the command line carried out in arm-stub.c with
    the handling in efi_parse_options(). Note that this also fixes the
    missing handling of CONFIG_CMDLINE_FORCE=y, in which case the builtin
    command line should supersede the one passed by the firmware.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bhe@redhat.com
    Cc: bhsharma@redhat.com
    Cc: bp@alien8.de
    Cc: eugene@hp.com
    Cc: evgeny.kalugin@intel.com
    Cc: jhugo@codeaurora.org
    Cc: leif.lindholm@linaro.org
    Cc: linux-efi@vger.kernel.org
    Cc: mark.rutland@arm.com
    Cc: roy.franz@cavium.com
    Cc: rruigrok@codeaurora.org
    Link: http://lkml.kernel.org/r/20170404160910.28115-1-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 71c4d0e3c4ed..a7a2a2c3f199 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -24,6 +24,8 @@
 #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
 #endif
 
+extern int __pure nokaslr(void);
+
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,

commit 2bd79f30eea1a7c3082c930a91370bb68435b86d
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jan 31 13:21:33 2017 +0000

    efi: Deduplicate efi_file_size() / _read() / _close()
    
    There's one ARM, one x86_32 and one x86_64 version which can be folded
    into a single shared version by masking their differences with the shiny
    new efi_call_proto() macro.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-2-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 0e2a96b12cb3..71c4d0e3c4ed 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -29,14 +29,6 @@ void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,
 			     void **__fh);
 
-efi_status_t efi_file_size(efi_system_table_t *sys_table_arg, void *__fh,
-			   efi_char16_t *filename_16, void **handle,
-			   u64 *file_sz);
-
-efi_status_t efi_file_read(void *handle, unsigned long *size, void *addr);
-
-efi_status_t efi_file_close(void *handle);
-
 unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
 
 efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,

commit abfb7b686a3e5be27bf81db62f9c5c895b76f5d1
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Dec 24 13:59:23 2016 +0000

    efi/libstub/arm*: Pass latest memory map to the kernel
    
    As reported by James Morse, the current libstub code involving the
    annotated memory map only works somewhat correctly by accident, due
    to the fact that a pool allocation happens to be reused immediately,
    retaining its former contents on most implementations of the
    UEFI boot services.
    
    Instead of juggling memory maps, which makes the code more complex than
    it needs to be, simply put placeholder values into the FDT for the memory
    map parameters, and only write the actual values after ExitBootServices()
    has been called.
    
    Reported-by: James Morse <james.morse@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Fixes: ed9cc156c42f ("efi/libstub: Use efi_exit_boot_services() in FDT")
    Link: http://lkml.kernel.org/r/1482587963-20183-2-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index b98824e3800a..0e2a96b12cb3 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -39,14 +39,6 @@ efi_status_t efi_file_close(void *handle);
 
 unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
 
-efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,
-			unsigned long orig_fdt_size,
-			void *fdt, int new_fdt_size, char *cmdline_ptr,
-			u64 initrd_addr, u64 initrd_size,
-			efi_memory_desc_t *memory_map,
-			unsigned long map_size, unsigned long desc_size,
-			u32 desc_ver);
-
 efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 					    void *handle,
 					    unsigned long *new_fdt_addr,

commit 568bc4e87033d232c5fd00d5b0cd22a2ccc04944
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Nov 12 21:32:33 2016 +0000

    efi/arm*/libstub: Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table
    
    Invoke the EFI_RNG_PROTOCOL protocol in the context of the stub and
    install the Linux-specific RNG seed UEFI config table. This will be
    picked up by the EFI routines in the core kernel to seed the kernel
    entropy pool.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-6-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index fe1f22584c69..b98824e3800a 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -71,4 +71,6 @@ efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
 
 efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
 
+efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
+
 #endif

commit a6a144698db93a2c456d1e3811140cadef1ba0e3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Nov 12 21:32:32 2016 +0000

    efi/libstub: Add random.c to ARM build
    
    Make random.c build for ARM by moving the fallback definition of
    EFI_ALLOC_ALIGN to efistub.h, and replacing a division by a value
    we know to be a power of 2 with a right shift (this is required since
    ARM does not have any integer division helper routines in its decompressor)
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-5-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index ee49cd23ee63..fe1f22584c69 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -15,6 +15,15 @@
  */
 #undef __init
 
+/*
+ * Allow the platform to override the allocation granularity: this allows
+ * systems that have the capability to run with a larger page size to deal
+ * with the allocations for initrd and fdt more efficiently.
+ */
+#ifndef EFI_ALLOC_ALIGN
+#define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
+#endif
+
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,

commit 24b5e20f11a75866bbffc46c30a22fa50612a769
Merge: 26660a4046b1 d367cef0a7f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 20 18:58:18 2016 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes are:
    
       - Use separate EFI page tables when executing EFI firmware code.
         This isolates the EFI context from the rest of the kernel, which
         has security and general robustness advantages.  (Matt Fleming)
    
       - Run regular UEFI firmware with interrupts enabled.  This is already
         the status quo under other OSs.  (Ard Biesheuvel)
    
       - Various x86 EFI enhancements, such as the use of non-executable
         attributes for EFI memory mappings.  (Sai Praneeth Prakhya)
    
       - Various arm64 UEFI enhancements.  (Ard Biesheuvel)
    
       - ... various fixes and cleanups.
    
      The separate EFI page tables feature got delayed twice already,
      because it's an intrusive change and we didn't feel confident about
      it - third time's the charm we hope!"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU
      x86/efi: Only map kernel text for EFI mixed mode
      x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
      x86/mm/pat: Don't implicitly allow _PAGE_RW in kernel_map_pages_in_pgd()
      efi/arm*: Perform hardware compatibility check
      efi/arm64: Check for h/w support before booting a >4 KB granular kernel
      efi/arm: Check for LPAE support before booting a LPAE kernel
      efi/arm-init: Use read-only early mappings
      efi/efistub: Prevent __init annotations from being used
      arm64/vmlinux.lds.S: Handle .init.rodata.xxx and .init.bss sections
      efi/arm64: Drop __init annotation from handle_kernel_image()
      x86/mm/pat: Use _PAGE_GLOBAL bit for EFI page table mappings
      efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled
      efi: Reformat GUID tables to follow the format in UEFI spec
      efi: Add Persistent Memory type name
      efi: Add NV memory attribute
      x86/efi: Show actual ending addresses in efi_print_memmap
      x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0
      efivars: Use to_efivar_entry
      efi: Runtime-wrapper: Get rid of the rtc_lock spinlock
      ...

commit 2ddbfc81eac84a299cb4747a8764bc43f23e9008
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Jan 11 10:43:16 2016 +0100

    efi: stub: add implementation of efi_random_alloc()
    
    This implements efi_random_alloc(), which allocates a chunk of memory of
    a certain size at a certain alignment, and uses the random_seed argument
    it receives to randomize the address of the allocation.
    
    This is implemented by iterating over the UEFI memory map, counting the
    number of suitable slots (aligned offsets) within each region, and picking
    a random number between 0 and 'number of slots - 1' to select the slot,
    This should guarantee that each possible offset is chosen equally likely.
    
    Suggested-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 206b7252b9d1..5ed3d3f38166 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -46,4 +46,8 @@ void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
 efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
 				  unsigned long size, u8 *out);
 
+efi_status_t efi_random_alloc(efi_system_table_t *sys_table_arg,
+			      unsigned long size, unsigned long align,
+			      unsigned long *addr, unsigned long random_seed);
+
 #endif

commit e4fbf4767440472f9d23b0f25a2b905e1c63b6a8
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sun Jan 10 11:29:07 2016 +0100

    efi: stub: implement efi_get_random_bytes() based on EFI_RNG_PROTOCOL
    
    This exposes the firmware's implementation of EFI_RNG_PROTOCOL via a new
    function efi_get_random_bytes().
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 6b6548fda089..206b7252b9d1 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -43,4 +43,7 @@ void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
 		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
 		     int *count);
 
+efi_status_t efi_get_random_bytes(efi_system_table_t *sys_table,
+				  unsigned long size, u8 *out);
+
 #endif

commit b9d6769b5678dbd6cb328d20716561d35b2b1510
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Feb 17 12:36:03 2016 +0000

    efi/arm*: Perform hardware compatibility check
    
    Before proceeding with relocating the kernel and parsing the command line,
    insert a call to check_platform_features() to allow an arch specific check
    to be performed whether the current kernel can execute on the current
    hardware.
    
    Tested-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Jeremy Linton <jeremy.linton@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1455712566-16727-11-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 86ff7bfa6ace..981c6035ce09 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -53,4 +53,6 @@ void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
 		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
 		     int *count);
 
+efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);
+
 #endif

commit 07e83dbb75865b016f6493c119a30aac7c25051a
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Feb 17 12:35:59 2016 +0000

    efi/efistub: Prevent __init annotations from being used
    
    __init annotations should not be used in the EFI stub, since the code is
    either included in the decompressor (x86, ARM) where they have no effect,
    or the whole stub is __init annotated at the section level (arm64), by
    renaming the sections.
    
    In the second case the __init annotations will be redundant, and will
    result in section names like .init.init.text, and our linker script does
    not expect that.
    
    So un-#define __init so that its inadvertent use will force a build error.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1455712566-16727-7-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 6b6548fda089..86ff7bfa6ace 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -5,6 +5,16 @@
 /* error code which can't be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 
+/*
+ * __init annotations should not be used in the EFI stub, since the code is
+ * either included in the decompressor (x86, ARM) where they have no effect,
+ * or the whole stub is __init annotated at the section level (arm64), by
+ * renaming the sections, in which case the __init annotation will be
+ * redundant, and will result in section names like .init.init.text, and our
+ * linker script does not expect that.
+ */
+#undef __init
+
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,

commit 769a8089c1fd2fe94c13e66fe6e03d7820953ee3
Author: Andrey Ryabinin <ryabinin.a.a@gmail.com>
Date:   Tue Sep 22 14:59:17 2015 -0700

    x86, efi, kasan: #undef memset/memcpy/memmove per arch
    
    In not-instrumented code KASAN replaces instrumented memset/memcpy/memmove
    with not-instrumented analogues __memset/__memcpy/__memove.
    
    However, on x86 the EFI stub is not linked with the kernel.  It uses
    not-instrumented mem*() functions from arch/x86/boot/compressed/string.c
    
    So we don't replace them with __mem*() variants in EFI stub.
    
    On ARM64 the EFI stub is linked with the kernel, so we should replace
    mem*() functions with __mem*(), because the EFI stub runs before KASAN
    sets up early shadow.
    
    So let's move these #undef mem* into arch's asm/efi.h which is also
    included by the EFI stub.
    
    Also, this will fix the warning in 32-bit build reported by kbuild test
    robot:
    
            efi-stub-helper.c:599:2: warning: implicit declaration of function 'memcpy'
    
    [akpm@linux-foundation.org: use 80 cols in comment]
    Signed-off-by: Andrey Ryabinin <ryabinin.a.a@gmail.com>
    Reported-by: Fengguang Wu <fengguang.wu@gmail.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index e334a01cf92f..6b6548fda089 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -5,10 +5,6 @@
 /* error code which can't be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 
-#undef memcpy
-#undef memset
-#undef memmove
-
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,

commit a643375f4b175569bc3c03c7a3e758f845c1ccd9
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Mar 4 13:02:29 2015 +0100

    efi/libstub: Retrieve FDT size when loaded from UEFI config table
    
    When allocating memory for the copy of the FDT that the stub
    modifies and passes to the kernel, it uses the current size as
    an estimate of how much memory to allocate, and increases it page
    by page if it turns out to be too small. However, when loading
    the FDT from a UEFI configuration table, the estimated size is
    left at its default value of zero, and the allocation loop runs
    starting from zero all the way up to the allocation size that
    finally fits the updated FDT.
    
    Instead, retrieve the size of the FDT from the FDT header when
    loading it from the UEFI config table.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Roy Franz <roy.franz@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 47437b16b186..e334a01cf92f 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -41,7 +41,7 @@ efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 					    unsigned long fdt_addr,
 					    unsigned long fdt_size);
 
-void *get_fdt(efi_system_table_t *sys_table);
+void *get_fdt(efi_system_table_t *sys_table, unsigned long *fdt_size);
 
 void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
 		     unsigned long desc_size, efi_memory_desc_t *runtime_map,

commit 393f203f5fd54421fddb1e2a263f64d3876eeadb
Author: Andrey Ryabinin <a.ryabinin@samsung.com>
Date:   Fri Feb 13 14:39:56 2015 -0800

    x86_64: kasan: add interceptors for memset/memmove/memcpy functions
    
    Recently instrumentation of builtin functions calls was removed from GCC
    5.0.  To check the memory accessed by such functions, userspace asan
    always uses interceptors for them.
    
    So now we should do this as well.  This patch declares
    memset/memmove/memcpy as weak symbols.  In mm/kasan/kasan.c we have our
    own implementation of those functions which checks memory before accessing
    it.
    
    Default memset/memmove/memcpy now now always have aliases with '__'
    prefix.  For files that built without kasan instrumentation (e.g.
    mm/slub.c) original mem* replaced (via #define) with prefixed variants,
    cause we don't want to check memory accesses there.
    
    Signed-off-by: Andrey Ryabinin <a.ryabinin@samsung.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Konstantin Serebryany <kcc@google.com>
    Cc: Dmitry Chernenkov <dmitryc@google.com>
    Signed-off-by: Andrey Konovalov <adech.fo@gmail.com>
    Cc: Yuri Gribov <tetra2005@gmail.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 2be10984a67a..47437b16b186 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -5,6 +5,10 @@
 /* error code which can't be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 
+#undef memcpy
+#undef memset
+#undef memmove
+
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,

commit f3cdfd239da56a4cea75a2920dc326f0f45f67e3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Oct 20 16:27:26 2014 +0200

    arm64/efi: move SetVirtualAddressMap() to UEFI stub
    
    In order to support kexec, the kernel needs to be able to deal with the
    state of the UEFI firmware after SetVirtualAddressMap() has been called.
    To avoid having separate code paths for non-kexec and kexec, let's move
    the call to SetVirtualAddressMap() to the stub: this will guarantee us
    that it will only be called once (since the stub is not executed during
    kexec), and ensures that the UEFI state is identical between kexec and
    normal boot.
    
    This implies that the layout of the virtual mapping needs to be created
    by the stub as well. All regions are rounded up to a naturally aligned
    multiple of 64 KB (for compatibility with 64k pages kernels) and recorded
    in the UEFI memory map. The kernel proper reads those values and installs
    the mappings in a dedicated set of page tables that are swapped in during
    UEFI Runtime Services calls.
    
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 304ab295ca1a..2be10984a67a 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -39,4 +39,8 @@ efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 
 void *get_fdt(efi_system_table_t *sys_table);
 
+void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,
+		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
+		     int *count);
+
 #endif

commit f4f75ad5741fe0331bbe1f5c42b906cda299f26b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 2 14:54:43 2014 +0200

    efi: efistub: Convert into static library
    
    This patch changes both x86 and arm64 efistub implementations
    from #including shared .c files under drivers/firmware/efi to
    building shared code as a static library.
    
    The x86 code uses a stub built into the boot executable which
    uncompresses the kernel at boot time. In this case, the library is
    linked into the decompressor.
    
    In the arm64 case, the stub is part of the kernel proper so the library
    is linked into the kernel proper as well.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
new file mode 100644
index 000000000000..304ab295ca1a
--- /dev/null
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -0,0 +1,42 @@
+
+#ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
+#define _DRIVERS_FIRMWARE_EFI_EFISTUB_H
+
+/* error code which can't be mistaken for valid address */
+#define EFI_ERROR	(~0UL)
+
+void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
+
+efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,
+			     void **__fh);
+
+efi_status_t efi_file_size(efi_system_table_t *sys_table_arg, void *__fh,
+			   efi_char16_t *filename_16, void **handle,
+			   u64 *file_sz);
+
+efi_status_t efi_file_read(void *handle, unsigned long *size, void *addr);
+
+efi_status_t efi_file_close(void *handle);
+
+unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
+
+efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,
+			unsigned long orig_fdt_size,
+			void *fdt, int new_fdt_size, char *cmdline_ptr,
+			u64 initrd_addr, u64 initrd_size,
+			efi_memory_desc_t *memory_map,
+			unsigned long map_size, unsigned long desc_size,
+			u32 desc_ver);
+
+efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
+					    void *handle,
+					    unsigned long *new_fdt_addr,
+					    unsigned long max_addr,
+					    u64 initrd_addr, u64 initrd_size,
+					    char *cmdline_ptr,
+					    unsigned long fdt_addr,
+					    unsigned long fdt_size);
+
+void *get_fdt(efi_system_table_t *sys_table);
+
+#endif
