commit 435d1a471598752446a72ad1201b3c980526d869
Author: Peter Jones <pjones@redhat.com>
Date:   Mon Jun 15 16:24:08 2020 -0400

    efi: Make it possible to disable efivar_ssdt entirely
    
    In most cases, such as CONFIG_ACPI_CUSTOM_DSDT and
    CONFIG_ACPI_TABLE_UPGRADE, boot-time modifications to firmware tables
    are tied to specific Kconfig options.  Currently this is not the case
    for modifying the ACPI SSDT via the efivar_ssdt kernel command line
    option and associated EFI variable.
    
    This patch adds CONFIG_EFI_CUSTOM_SSDT_OVERLAYS, which defaults
    disabled, in order to allow enabling or disabling that feature during
    the build.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Link: https://lore.kernel.org/r/20200615202408.2242614-1-pjones@redhat.com
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index edc5d36caf54..5114cae4ec97 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -189,7 +189,7 @@ static void generic_ops_unregister(void)
 	efivars_unregister(&generic_efivars);
 }
 
-#if IS_ENABLED(CONFIG_ACPI)
+#ifdef CONFIG_EFI_CUSTOM_SSDT_OVERLAYS
 #define EFIVAR_SSDT_NAME_MAX	16
 static char efivar_ssdt[EFIVAR_SSDT_NAME_MAX] __initdata;
 static int __init efivar_ssdt_setup(char *str)

commit 2963795122f50b36ed16e3ba880c3ed2de1bda6e
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Wed May 27 12:14:25 2020 -0500

    efi: Replace zero-length array and use struct_size() helper
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    Lastly, make use of the sizeof_field() helper instead of an open-coded
    version.
    
    This issue was found with the help of Coccinelle and audited _manually_.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/r/20200527171425.GA4053@embeddedor
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 7f1657b6c30d..edc5d36caf54 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -622,7 +622,8 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 			rsv = (void *)(p + prsv % PAGE_SIZE);
 
 			/* reserve the entry itself */
-			memblock_reserve(prsv, EFI_MEMRESERVE_SIZE(rsv->size));
+			memblock_reserve(prsv,
+					 struct_size(rsv, entry, rsv->size));
 
 			for (i = 0; i < atomic_read(&rsv->count); i++) {
 				memblock_reserve(rsv->entry[i].base,

commit 14c3656b7284a8649496584869e8c6642ec1abbb
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:40 2020 -0700

    mmap locking API: add MMAP_LOCK_INITIALIZER
    
    Define a new initializer for the mmap locking api.  Initially this just
    evaluates to __RWSEM_INITIALIZER as the API is defined as wrappers around
    rwsem.
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Laurent Dufour <ldufour@linux.ibm.com>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-9-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 9357d6b6e87c..7f1657b6c30d 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -54,7 +54,7 @@ struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
 	.mm_users		= ATOMIC_INIT(2),
 	.mm_count		= ATOMIC_INIT(1),
-	.mmap_sem		= __RWSEM_INITIALIZER(efi_mm.mmap_sem),
+	MMAP_LOCK_INITIALIZER(efi_mm)
 	.page_table_lock	= __SPIN_LOCK_UNLOCKED(efi_mm.page_table_lock),
 	.mmlist			= LIST_HEAD_INIT(efi_mm.mmlist),
 	.cpu_bitmap		= { [BITS_TO_LONGS(NR_CPUS)] = 0},

commit a5d8e55b2c7d3d18d7837af0ef8d1477eeeb919c
Merge: 4da0b2b7e675 9cb1fd0efd19
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 25 15:10:37 2020 +0200

    Merge tag 'v5.7-rc7' into efi/core, to refresh the branch and pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit e8da08a088236aff4b51d4ec97c750051f9fe417
Author: Benjamin Thiel <b.thiel@posteo.de>
Date:   Sat May 16 15:26:47 2020 +0200

    efi: Pull up arch-specific prototype efi_systab_show_arch()
    
    Pull up arch-specific prototype efi_systab_show_arch() in order to
    fix a -Wmissing-prototypes warning:
    
    arch/x86/platform/efi/efi.c:957:7: warning: no previous prototype for
    ‘efi_systab_show_arch’ [-Wmissing-prototypes]
    char *efi_systab_show_arch(char *str)
    
    Signed-off-by: Benjamin Thiel <b.thiel@posteo.de>
    Link: https://lore.kernel.org/r/20200516132647.14568-1-b.thiel@posteo.de
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 911a2bd0f6b7..4e3055238f31 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -130,11 +130,8 @@ static ssize_t systab_show(struct kobject *kobj,
 	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
 
-	if (IS_ENABLED(CONFIG_IA64) || IS_ENABLED(CONFIG_X86)) {
-		extern char *efi_systab_show_arch(char *str);
-
+	if (IS_ENABLED(CONFIG_IA64) || IS_ENABLED(CONFIG_X86))
 		str = efi_systab_show_arch(str);
-	}
 
 	return str - buf;
 }

commit 4eb8320bd1aaa7e69d039f2c251735e3ef0b9a38
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Mar 26 09:34:35 2020 +0100

    efi: Move arch_tables check to caller
    
    Instead of making match_config_table() test its table_types pointer for
    NULL-ness, omit the call entirely if no arch_tables pointer was provided
    to efi_config_parse_tables().
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index e49c0b6db988..48d0188936c3 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -525,15 +525,13 @@ static __init int match_config_table(const efi_guid_t *guid,
 {
 	int i;
 
-	if (table_types) {
-		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
-			if (!efi_guidcmp(*guid, table_types[i].guid)) {
-				*(table_types[i].ptr) = table;
-				if (table_types[i].name[0])
-					pr_cont(" %s=0x%lx ",
-						table_types[i].name, table);
-				return 1;
-			}
+	for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
+		if (!efi_guidcmp(*guid, table_types[i].guid)) {
+			*(table_types[i].ptr) = table;
+			if (table_types[i].name[0])
+				pr_cont("%s=0x%lx ",
+					table_types[i].name, table);
+			return 1;
 		}
 	}
 
@@ -570,7 +568,7 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 			table = tbl32[i].table;
 		}
 
-		if (!match_config_table(guid, table, common_tables))
+		if (!match_config_table(guid, table, common_tables) && arch_tables)
 			match_config_table(guid, table, arch_tables);
 	}
 	pr_cont("\n");

commit 4e9a0f73f030e19a9259b69a7079021048e1f904
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Mar 26 09:24:14 2020 +0100

    efi: Clean up config table description arrays
    
    Increase legibility by adding whitespace to the efi_config_table_type_t
    arrays that describe which EFI config tables we look for when going over
    the firmware provided list. While at it, replace the 'name' char pointer
    with a char array, which is more space efficient on relocatable 64-bit
    kernels, as it avoids a 8 byte pointer and the associated relocation
    data (24 bytes when using RELA format)
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 911a2bd0f6b7..e49c0b6db988 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -502,21 +502,21 @@ void __init efi_mem_reserve(phys_addr_t addr, u64 size)
 }
 
 static const efi_config_table_type_t common_tables[] __initconst = {
-	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
-	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
-	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
-	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
-	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
-	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi_mem_attr_table},
-	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi_rng_seed},
-	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
-	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
-	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &mem_reserve},
-	{EFI_RT_PROPERTIES_TABLE_GUID, "RTPROP", &rt_prop},
+	{ACPI_20_TABLE_GUID,			&efi.acpi20,		"ACPI 2.0"	},
+	{ACPI_TABLE_GUID,			&efi.acpi,		"ACPI"		},
+	{SMBIOS_TABLE_GUID,			&efi.smbios,		"SMBIOS"	},
+	{SMBIOS3_TABLE_GUID,			&efi.smbios3,		"SMBIOS 3.0"	},
+	{EFI_SYSTEM_RESOURCE_TABLE_GUID,	&efi.esrt,		"ESRT"		},
+	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID,	&efi_mem_attr_table,	"MEMATTR"	},
+	{LINUX_EFI_RANDOM_SEED_TABLE_GUID,	&efi_rng_seed,		"RNG"		},
+	{LINUX_EFI_TPM_EVENT_LOG_GUID,		&efi.tpm_log,		"TPMEventLog"	},
+	{LINUX_EFI_TPM_FINAL_LOG_GUID,		&efi.tpm_final_log,	"TPMFinalLog"	},
+	{LINUX_EFI_MEMRESERVE_TABLE_GUID,	&mem_reserve,		"MEMRESERVE"	},
+	{EFI_RT_PROPERTIES_TABLE_GUID,		&rt_prop,		"RTPROP"	},
 #ifdef CONFIG_EFI_RCI2_TABLE
-	{DELLEMC_EFI_RCI2_TABLE_GUID, NULL, &rci2_table_phys},
+	{DELLEMC_EFI_RCI2_TABLE_GUID,		&rci2_table_phys			},
 #endif
-	{NULL_GUID, NULL, NULL},
+	{},
 };
 
 static __init int match_config_table(const efi_guid_t *guid,
@@ -529,7 +529,7 @@ static __init int match_config_table(const efi_guid_t *guid,
 		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
 			if (!efi_guidcmp(*guid, table_types[i].guid)) {
 				*(table_types[i].ptr) = table;
-				if (table_types[i].name)
+				if (table_types[i].name[0])
 					pr_cont(" %s=0x%lx ",
 						table_types[i].name, table);
 				return 1;

commit dd09fad9d2caad2325a39b766ce9e79cfc690184
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Mar 8 09:08:51 2020 +0100

    efi/x86: Ignore the memory attributes table on i386
    
    Commit:
    
      3a6b6c6fb23667fa ("efi: Make EFI_MEMORY_ATTRIBUTES_TABLE initialization common across all architectures")
    
    moved the call to efi_memattr_init() from ARM specific to the generic
    EFI init code, in order to be able to apply the restricted permissions
    described in that table on x86 as well.
    
    We never enabled this feature fully on i386, and so mapping and
    reserving this table is pointless. However, due to the early call to
    memblock_reserve(), the memory bookkeeping gets confused to the point
    where it produces the splat below when we try to map the memory later
    on:
    
      ------------[ cut here ]------------
      ioremap on RAM at 0x3f251000 - 0x3fa1afff
      WARNING: CPU: 0 PID: 0 at arch/x86/mm/ioremap.c:166 __ioremap_caller ...
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.20.0 #48
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015
      EIP: __ioremap_caller.constprop.0+0x249/0x260
      Code: 90 0f b7 05 4e 38 40 de 09 45 e0 e9 09 ff ff ff 90 8d 45 ec c6 05 ...
      EAX: 00000029 EBX: 00000000 ECX: de59c228 EDX: 00000001
      ESI: 3f250fff EDI: 00000000 EBP: de3edf20 ESP: de3edee0
      DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00200296
      CR0: 80050033 CR2: ffd17000 CR3: 1e58c000 CR4: 00040690
      Call Trace:
       ioremap_cache+0xd/0x10
       ? old_map_region+0x72/0x9d
       old_map_region+0x72/0x9d
       efi_map_region+0x8/0xa
       efi_enter_virtual_mode+0x260/0x43b
       start_kernel+0x329/0x3aa
       i386_start_kernel+0xa7/0xab
       startup_32_smp+0x164/0x168
      ---[ end trace e15ccf6b9f356833 ]---
    
    Let's work around this by disregarding the memory attributes table
    altogether on i386, which does not result in a loss of functionality
    or protection, given that we never consumed the contents.
    
    Fixes: 3a6b6c6fb23667fa ("efi: Make EFI_MEMORY_ATTRIBUTES_TABLE ... ")
    Tested-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200304165917.5893-1-ardb@kernel.org
    Link: https://lore.kernel.org/r/20200308080859.21568-21-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 3f41947a4d66..911a2bd0f6b7 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -600,7 +600,7 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 		}
 	}
 
-	if (efi_enabled(EFI_MEMMAP))
+	if (!IS_ENABLED(CONFIG_X86_32) && efi_enabled(EFI_MEMMAP))
 		efi_memattr_init();
 
 	efi_tpm_eventlog_init();

commit 6120681bdf1a1c648e8c555704b71e04abe2e899
Merge: 3be5f0d286dc d6c066fda90d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Mar 8 09:57:58 2020 +0100

    Merge branch 'efi/urgent' into efi/core, to pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3be5f0d286dc944dee65fdcbddfc4d314f7d4482
Merge: c98a76eabbb6 f0df68d5bae8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Mar 8 08:59:47 2020 +0100

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/efi/efi into efi/core
    
    More EFI updates for v5.7
    
     - Incorporate a stable branch with the EFI pieces of Hans's work on
       loading device firmware from EFI boot service memory regions
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0e72a6a3cfc3a32273f5e99bfaa4407f4917d343
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:45 2020 +0100

    efi: Export boot-services code and data as debugfs-blobs
    
    Sometimes it is useful to be able to dump the efi boot-services code and
    data. This commit adds these as debugfs-blobs to /sys/kernel/debug/efi,
    but only if efi=debug is passed on the kernel-commandline as this requires
    not freeing those memory-regions, which costs 20+ MB of RAM.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-2-hdegoede@redhat.com
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 621220ab3d0e..201a6799671d 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -17,6 +17,7 @@
 #include <linux/kobject.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/efi.h>
 #include <linux/of.h>
@@ -325,6 +326,59 @@ static __init int efivar_ssdt_load(void)
 static inline int efivar_ssdt_load(void) { return 0; }
 #endif
 
+#ifdef CONFIG_DEBUG_FS
+
+#define EFI_DEBUGFS_MAX_BLOBS 32
+
+static struct debugfs_blob_wrapper debugfs_blob[EFI_DEBUGFS_MAX_BLOBS];
+
+static void __init efi_debugfs_init(void)
+{
+	struct dentry *efi_debugfs;
+	efi_memory_desc_t *md;
+	char name[32];
+	int type_count[EFI_BOOT_SERVICES_DATA + 1] = {};
+	int i = 0;
+
+	efi_debugfs = debugfs_create_dir("efi", NULL);
+	if (IS_ERR_OR_NULL(efi_debugfs))
+		return;
+
+	for_each_efi_memory_desc(md) {
+		switch (md->type) {
+		case EFI_BOOT_SERVICES_CODE:
+			snprintf(name, sizeof(name), "boot_services_code%d",
+				 type_count[md->type]++);
+			break;
+		case EFI_BOOT_SERVICES_DATA:
+			snprintf(name, sizeof(name), "boot_services_data%d",
+				 type_count[md->type]++);
+			break;
+		default:
+			continue;
+		}
+
+		if (i >= EFI_DEBUGFS_MAX_BLOBS) {
+			pr_warn("More then %d EFI boot service segments, only showing first %d in debugfs\n",
+				EFI_DEBUGFS_MAX_BLOBS, EFI_DEBUGFS_MAX_BLOBS);
+			break;
+		}
+
+		debugfs_blob[i].size = md->num_pages << EFI_PAGE_SHIFT;
+		debugfs_blob[i].data = memremap(md->phys_addr,
+						debugfs_blob[i].size,
+						MEMREMAP_WB);
+		if (!debugfs_blob[i].data)
+			continue;
+
+		debugfs_create_blob(name, 0400, efi_debugfs, &debugfs_blob[i]);
+		i++;
+	}
+}
+#else
+static inline void efi_debugfs_init(void) {}
+#endif
+
 /*
  * We register the efi subsystem with the firmware subsystem and the
  * efivars subsystem with the efi subsystem, if the system was booted with
@@ -381,6 +435,9 @@ static int __init efisubsys_init(void)
 		goto err_remove_group;
 	}
 
+	if (efi_enabled(EFI_DBG) && efi_enabled(EFI_PRESERVE_BS_REGIONS))
+		efi_debugfs_init();
+
 	return 0;
 
 err_remove_group:

commit 3e03dca500ca65b37dff0a205893095dca74f054
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Feb 28 13:14:08 2020 +0100

    efi: Mark all EFI runtime services as unsupported on non-EFI boot
    
    Recent changes to the way we deal with EFI runtime services that
    are marked as unsupported by the firmware resulted in a regression
    for non-EFI boot. The problem is that all EFI runtime services are
    marked as available by default, and any non-NULL checks on the EFI
    service function pointers (which will be non-NULL even for runtime
    services that are unsupported on an EFI boot) were replaced with
    checks against the mask stored in efi.runtime_supported_mask.
    
    When doing a non-EFI boot, this check against the mask will return
    a false positive, given the fact that all runtime services are
    marked as enabled by default. Since we dropped the non-NULL check
    of the runtime service function pointer in favor of the mask check,
    we will now unconditionally dereference the function pointer, even
    if it is NULL, and go boom.
    
    So let's ensure that the mask reflects reality on a non-EFI boot,
    which is that all EFI runtime services are unsupported.
    
    Reported-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Link: https://lore.kernel.org/r/20200228121408.9075-7-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 41269a95ff85..d1746a579c99 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -300,12 +300,12 @@ static int __init efisubsys_init(void)
 {
 	int error;
 
-	if (!efi_enabled(EFI_BOOT))
-		return 0;
-
 	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 		efi.runtime_supported_mask = 0;
 
+	if (!efi_enabled(EFI_BOOT))
+		return 0;
+
 	if (efi.runtime_supported_mask) {
 		/*
 		 * Since we process only one efi_runtime_service() at a time, an

commit 98649365e59da18221850e137620d18b50ec99e5
Author: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date:   Fri Feb 28 13:14:05 2020 +0100

    efi: Don't shadow 'i' in efi_config_parse_tables()
    
    Shadowing variables is generally frowned upon.
    
    Let's simply reuse the existing loop counter 'i' instead of shadowing it.
    
    Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Link: https://lore.kernel.org/r/20200223221324.156086-1-xypron.glpk@gmx.de
    Link: https://lore.kernel.org/r/20200228121408.9075-4-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 1e79f77d4e6c..41269a95ff85 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -554,7 +554,6 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 		while (prsv) {
 			struct linux_efi_memreserve *rsv;
 			u8 *p;
-			int i;
 
 			/*
 			 * Just map a full page: that is what we will get

commit badc61982adb6018a48ed8fe32087b9754cae14b
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Fri Feb 28 13:14:04 2020 +0100

    efi/x86: Add RNG seed EFI table to unencrypted mapping check
    
    When booting with SME active, EFI tables must be mapped unencrypted since
    they were built by UEFI in unencrypted memory. Update the list of tables
    to be checked during early_memremap() processing to account for the EFI
    RNG seed table.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Link: https://lore.kernel.org/r/b64385fc13e5d7ad4b459216524f138e7879234f.1582662842.git.thomas.lendacky@amd.com
    Link: https://lore.kernel.org/r/20200228121408.9075-3-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 69a585106d30..1e79f77d4e6c 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -45,7 +45,7 @@ struct efi __read_mostly efi = {
 };
 EXPORT_SYMBOL(efi);
 
-static unsigned long __ro_after_init rng_seed = EFI_INVALID_TABLE_ADDR;
+unsigned long __ro_after_init efi_rng_seed = EFI_INVALID_TABLE_ADDR;
 static unsigned long __initdata mem_reserve = EFI_INVALID_TABLE_ADDR;
 static unsigned long __initdata rt_prop = EFI_INVALID_TABLE_ADDR;
 
@@ -451,7 +451,7 @@ static const efi_config_table_type_t common_tables[] __initconst = {
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi_mem_attr_table},
-	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &rng_seed},
+	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi_rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
 	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &mem_reserve},
@@ -519,11 +519,11 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 	pr_cont("\n");
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
 
-	if (rng_seed != EFI_INVALID_TABLE_ADDR) {
+	if (efi_rng_seed != EFI_INVALID_TABLE_ADDR) {
 		struct linux_efi_random_seed *seed;
 		u32 size = 0;
 
-		seed = early_memremap(rng_seed, sizeof(*seed));
+		seed = early_memremap(efi_rng_seed, sizeof(*seed));
 		if (seed != NULL) {
 			size = seed->size;
 			early_memunmap(seed, sizeof(*seed));
@@ -531,7 +531,8 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 			pr_err("Could not map UEFI random seed!\n");
 		}
 		if (size > 0) {
-			seed = early_memremap(rng_seed, sizeof(*seed) + size);
+			seed = early_memremap(efi_rng_seed,
+					      sizeof(*seed) + size);
 			if (seed != NULL) {
 				pr_notice("seeding entropy pool\n");
 				add_bootloader_randomness(seed->bits, seed->size);
@@ -923,7 +924,7 @@ static int update_efi_random_seed(struct notifier_block *nb,
 	if (!kexec_in_progress)
 		return NOTIFY_DONE;
 
-	seed = memremap(rng_seed, sizeof(*seed), MEMREMAP_WB);
+	seed = memremap(efi_rng_seed, sizeof(*seed), MEMREMAP_WB);
 	if (seed != NULL) {
 		size = min(seed->size, EFI_RANDOM_SEED_SIZE);
 		memunmap(seed);
@@ -931,7 +932,8 @@ static int update_efi_random_seed(struct notifier_block *nb,
 		pr_err("Could not map UEFI random seed!\n");
 	}
 	if (size > 0) {
-		seed = memremap(rng_seed, sizeof(*seed) + size, MEMREMAP_WB);
+		seed = memremap(efi_rng_seed, sizeof(*seed) + size,
+				MEMREMAP_WB);
 		if (seed != NULL) {
 			seed->size = size;
 			get_random_bytes(seed->bits, seed->size);
@@ -949,7 +951,7 @@ static struct notifier_block efi_random_seed_nb = {
 
 static int __init register_update_efi_random_seed(void)
 {
-	if (rng_seed == EFI_INVALID_TABLE_ADDR)
+	if (efi_rng_seed == EFI_INVALID_TABLE_ADDR)
 		return 0;
 	return register_reboot_notifier(&efi_random_seed_nb);
 }

commit be36f9e7517e17810ec369626a128d7948942259
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 21 09:48:49 2020 +0100

    efi: READ_ONCE rng seed size before munmap
    
    This function is consistent with using size instead of seed->size
    (except for one place that this patch fixes), but it reads seed->size
    without using READ_ONCE, which means the compiler might still do
    something unwanted. So, this commit simply adds the READ_ONCE
    wrapper.
    
    Fixes: 636259880a7e ("efi: Add support for seeding the RNG from a UEFI ...")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200217123354.21140-1-Jason@zx2c4.com
    Link: https://lore.kernel.org/r/20200221084849.26878-5-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 621220ab3d0e..21ea99f65113 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -552,7 +552,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 
 		seed = early_memremap(efi.rng_seed, sizeof(*seed));
 		if (seed != NULL) {
-			size = seed->size;
+			size = READ_ONCE(seed->size);
 			early_memunmap(seed, sizeof(*seed));
 		} else {
 			pr_err("Could not map UEFI random seed!\n");
@@ -562,7 +562,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 					      sizeof(*seed) + size);
 			if (seed != NULL) {
 				pr_notice("seeding entropy pool\n");
-				add_bootloader_randomness(seed->bits, seed->size);
+				add_bootloader_randomness(seed->bits, size);
 				early_memunmap(seed, sizeof(*seed) + size);
 			} else {
 				pr_err("Could not map UEFI random seed!\n");

commit e5c3b1cc99451d97ed3b94aff09817c66c040399
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Jan 23 09:14:09 2020 +0100

    efi: Register EFI rtc platform device only when available
    
    Drop the separate driver that registers the EFI rtc on all EFI
    systems that have runtime services available, and instead, move
    the registration into the core EFI code, and make it conditional
    on whether the actual time related services are available.
    
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index abf4c02e0201..69a585106d30 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -321,6 +321,9 @@ static int __init efisubsys_init(void)
 		}
 	}
 
+	if (efi_rt_services_supported(EFI_RT_SUPPORTED_TIME_SERVICES))
+		platform_device_register_simple("rtc-efi", 0, NULL, 0);
+
 	/* We register the efi directory at /sys/firmware/efi */
 	efi_kobj = kobject_create_and_add("efi", firmware_kobj);
 	if (!efi_kobj) {

commit bf67fad19e493bd3f7267b35b97b860280f87acc
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Jan 23 09:12:00 2020 +0100

    efi: Use more granular check for availability for variable services
    
    The UEFI spec rev 2.8 permits firmware implementations to support only
    a subset of EFI runtime services at OS runtime (i.e., after the call to
    ExitBootServices()), so let's take this into account in the drivers that
    rely specifically on the availability of the EFI variable services.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index a35230517f9c..abf4c02e0201 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -328,12 +328,13 @@ static int __init efisubsys_init(void)
 		return -ENOMEM;
 	}
 
-	error = generic_ops_register();
-	if (error)
-		goto err_put;
-
-	if (efi_enabled(EFI_RUNTIME_SERVICES))
+	if (efi_rt_services_supported(EFI_RT_SUPPORTED_VARIABLE_SERVICES)) {
 		efivar_ssdt_load();
+		error = generic_ops_register();
+		if (error)
+			goto err_put;
+		platform_device_register_simple("efivars", 0, NULL, 0);
+	}
 
 	error = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);
 	if (error) {
@@ -358,7 +359,8 @@ static int __init efisubsys_init(void)
 err_remove_group:
 	sysfs_remove_group(efi_kobj, &efi_subsys_attr_group);
 err_unregister:
-	generic_ops_unregister();
+	if (efi_rt_services_supported(EFI_RT_SUPPORTED_VARIABLE_SERVICES))
+		generic_ops_unregister();
 err_put:
 	kobject_put(efi_kobj);
 	return error;
@@ -650,20 +652,6 @@ void __init efi_systab_report_header(const efi_table_hdr_t *systab_hdr,
 		vendor);
 }
 
-#ifdef CONFIG_EFI_VARS_MODULE
-static int __init efi_load_efivars(void)
-{
-	struct platform_device *pdev;
-
-	if (!efi_enabled(EFI_RUNTIME_SERVICES))
-		return 0;
-
-	pdev = platform_device_register_simple("efivars", 0, NULL, 0);
-	return PTR_ERR_OR_ZERO(pdev);
-}
-device_initcall(efi_load_efivars);
-#endif
-
 static __initdata char memory_type_name[][20] = {
 	"Reserved",
 	"Loader Code",

commit fe4db90a80cd12ebe4efe385d40d6636330149ed
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Jan 23 13:10:25 2020 +0100

    efi: Add support for EFI_RT_PROPERTIES table
    
    Take the newly introduced EFI_RT_PROPERTIES_TABLE configuration table
    into account, which carries a mask of which EFI runtime services are
    still functional after ExitBootServices() has been called by the OS.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 703a019d81b4..a35230517f9c 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -47,6 +47,7 @@ EXPORT_SYMBOL(efi);
 
 static unsigned long __ro_after_init rng_seed = EFI_INVALID_TABLE_ADDR;
 static unsigned long __initdata mem_reserve = EFI_INVALID_TABLE_ADDR;
+static unsigned long __initdata rt_prop = EFI_INVALID_TABLE_ADDR;
 
 struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
@@ -449,6 +450,7 @@ static const efi_config_table_type_t common_tables[] __initconst = {
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
 	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &mem_reserve},
+	{EFI_RT_PROPERTIES_TABLE_GUID, "RTPROP", &rt_prop},
 #ifdef CONFIG_EFI_RCI2_TABLE
 	{DELLEMC_EFI_RCI2_TABLE_GUID, NULL, &rci2_table_phys},
 #endif
@@ -575,6 +577,16 @@ int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
 		}
 	}
 
+	if (rt_prop != EFI_INVALID_TABLE_ADDR) {
+		efi_rt_properties_table_t *tbl;
+
+		tbl = early_memremap(rt_prop, sizeof(*tbl));
+		if (tbl) {
+			efi.runtime_supported_mask &= tbl->runtime_services_supported;
+			early_memunmap(tbl, sizeof(*tbl));
+		}
+	}
+
 	return 0;
 }
 

commit 96a3dd3dece8134ba19b0ded7e6663136d3107b9
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 11:17:47 2020 +0100

    efi: Store mask of supported runtime services in struct efi
    
    Revision 2.8 of the UEFI spec introduces provisions for firmware to
    advertise lack of support for certain runtime services at OS runtime.
    Let's store this mask in struct efi for easy access.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 7dbe1487b111..703a019d81b4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -34,6 +34,7 @@
 #include <asm/early_ioremap.h>
 
 struct efi __read_mostly efi = {
+	.runtime_supported_mask = EFI_RT_SUPPORTED_ALL,
 	.acpi			= EFI_INVALID_TABLE_ADDR,
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
@@ -301,16 +302,22 @@ static int __init efisubsys_init(void)
 	if (!efi_enabled(EFI_BOOT))
 		return 0;
 
-	/*
-	 * Since we process only one efi_runtime_service() at a time, an
-	 * ordered workqueue (which creates only one execution context)
-	 * should suffice all our needs.
-	 */
-	efi_rts_wq = alloc_ordered_workqueue("efi_rts_wq", 0);
-	if (!efi_rts_wq) {
-		pr_err("Creating efi_rts_wq failed, EFI runtime services disabled.\n");
-		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
-		return 0;
+	if (!efi_enabled(EFI_RUNTIME_SERVICES))
+		efi.runtime_supported_mask = 0;
+
+	if (efi.runtime_supported_mask) {
+		/*
+		 * Since we process only one efi_runtime_service() at a time, an
+		 * ordered workqueue (which creates only one execution context)
+		 * should suffice for all our needs.
+		 */
+		efi_rts_wq = alloc_ordered_workqueue("efi_rts_wq", 0);
+		if (!efi_rts_wq) {
+			pr_err("Creating efi_rts_wq failed, EFI runtime services disabled.\n");
+			clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+			efi.runtime_supported_mask = 0;
+			return 0;
+		}
 	}
 
 	/* We register the efi directory at /sys/firmware/efi */

commit ac5abc700a43b3d448c86932196db22af470eca1
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Feb 18 09:54:05 2020 +0100

    efi/arm: Move FDT param discovery code out of efi.c
    
    On ARM systems, we discover the UEFI system table address and memory
    map address from the /chosen node in the device tree, or in the Xen
    case, from a similar node under /hypervisor.
    
    Before making some functional changes to that code, move it into its
    own file that only gets built if CONFIG_EFI_PARAMS_FROM_FDT=y.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 718dddfa0a0b..7dbe1487b111 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -20,7 +20,6 @@
 #include <linux/device.h>
 #include <linux/efi.h>
 #include <linux/of.h>
-#include <linux/of_fdt.h>
 #include <linux/io.h>
 #include <linux/kexec.h>
 #include <linux/platform_device.h>
@@ -646,140 +645,6 @@ static int __init efi_load_efivars(void)
 device_initcall(efi_load_efivars);
 #endif
 
-#ifdef CONFIG_EFI_PARAMS_FROM_FDT
-
-#define UEFI_PARAM(name, prop, field)			   \
-	{						   \
-		{ name },				   \
-		{ prop },				   \
-		offsetof(struct efi_fdt_params, field),    \
-		sizeof_field(struct efi_fdt_params, field) \
-	}
-
-struct params {
-	const char name[32];
-	const char propname[32];
-	int offset;
-	int size;
-};
-
-static __initdata struct params fdt_params[] = {
-	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
-	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
-	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
-	UEFI_PARAM("MemMap Desc. Size", "linux,uefi-mmap-desc-size", desc_size),
-	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
-};
-
-static __initdata struct params xen_fdt_params[] = {
-	UEFI_PARAM("System Table", "xen,uefi-system-table", system_table),
-	UEFI_PARAM("MemMap Address", "xen,uefi-mmap-start", mmap),
-	UEFI_PARAM("MemMap Size", "xen,uefi-mmap-size", mmap_size),
-	UEFI_PARAM("MemMap Desc. Size", "xen,uefi-mmap-desc-size", desc_size),
-	UEFI_PARAM("MemMap Desc. Version", "xen,uefi-mmap-desc-ver", desc_ver)
-};
-
-#define EFI_FDT_PARAMS_SIZE	ARRAY_SIZE(fdt_params)
-
-static __initdata struct {
-	const char *uname;
-	const char *subnode;
-	struct params *params;
-} dt_params[] = {
-	{ "hypervisor", "uefi", xen_fdt_params },
-	{ "chosen", NULL, fdt_params },
-};
-
-struct param_info {
-	int found;
-	void *params;
-	const char *missing;
-};
-
-static int __init __find_uefi_params(unsigned long node,
-				     struct param_info *info,
-				     struct params *params)
-{
-	const void *prop;
-	void *dest;
-	u64 val;
-	int i, len;
-
-	for (i = 0; i < EFI_FDT_PARAMS_SIZE; i++) {
-		prop = of_get_flat_dt_prop(node, params[i].propname, &len);
-		if (!prop) {
-			info->missing = params[i].name;
-			return 0;
-		}
-
-		dest = info->params + params[i].offset;
-		info->found++;
-
-		val = of_read_number(prop, len / sizeof(u32));
-
-		if (params[i].size == sizeof(u32))
-			*(u32 *)dest = val;
-		else
-			*(u64 *)dest = val;
-
-		if (efi_enabled(EFI_DBG))
-			pr_info("  %s: 0x%0*llx\n", params[i].name,
-				params[i].size * 2, val);
-	}
-
-	return 1;
-}
-
-static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
-				       int depth, void *data)
-{
-	struct param_info *info = data;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
-		const char *subnode = dt_params[i].subnode;
-
-		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
-			info->missing = dt_params[i].params[0].name;
-			continue;
-		}
-
-		if (subnode) {
-			int err = of_get_flat_dt_subnode_by_name(node, subnode);
-
-			if (err < 0)
-				return 0;
-
-			node = err;
-		}
-
-		return __find_uefi_params(node, info, dt_params[i].params);
-	}
-
-	return 0;
-}
-
-int __init efi_get_fdt_params(struct efi_fdt_params *params)
-{
-	struct param_info info;
-	int ret;
-
-	pr_info("Getting EFI parameters from FDT:\n");
-
-	info.found = 0;
-	info.params = params;
-
-	ret = of_scan_flat_dt(fdt_find_uefi_params, &info);
-	if (!info.found)
-		pr_info("UEFI not found.\n");
-	else if (!ret)
-		pr_err("Can't find '%s' in device tree!\n",
-		       info.missing);
-
-	return ret;
-}
-#endif /* CONFIG_EFI_PARAMS_FROM_FDT */
-
 static __initdata char memory_type_name[][20] = {
 	"Reserved",
 	"Loader Code",

commit 9cd437ac0ef4f324a92e2579784b03bb487ae7fb
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:23:21 2020 +0100

    efi/x86: Make fw_vendor, config_table and runtime sysfs nodes x86 specific
    
    There is some code that exposes physical addresses of certain parts of
    the EFI firmware implementation via sysfs nodes. These nodes are only
    used on x86, and are of dubious value to begin with, so let's move
    their handling into the x86 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 45de4c4a696b..718dddfa0a0b 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -39,9 +39,6 @@ struct efi __read_mostly efi = {
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
 	.smbios3		= EFI_INVALID_TABLE_ADDR,
-	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
-	.runtime		= EFI_INVALID_TABLE_ADDR,
-	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
 	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
@@ -142,55 +139,30 @@ static ssize_t systab_show(struct kobject *kobj,
 
 static struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);
 
-#define EFI_FIELD(var) efi.var
-
-#define EFI_ATTR_SHOW(name) \
-static ssize_t name##_show(struct kobject *kobj, \
-				struct kobj_attribute *attr, char *buf) \
-{ \
-	return sprintf(buf, "0x%lx\n", EFI_FIELD(name)); \
-}
-
-EFI_ATTR_SHOW(fw_vendor);
-EFI_ATTR_SHOW(runtime);
-EFI_ATTR_SHOW(config_table);
-
 static ssize_t fw_platform_size_show(struct kobject *kobj,
 				     struct kobj_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", efi_enabled(EFI_64BIT) ? 64 : 32);
 }
 
-static struct kobj_attribute efi_attr_fw_vendor = __ATTR_RO(fw_vendor);
-static struct kobj_attribute efi_attr_runtime = __ATTR_RO(runtime);
-static struct kobj_attribute efi_attr_config_table = __ATTR_RO(config_table);
+extern __weak struct kobj_attribute efi_attr_fw_vendor;
+extern __weak struct kobj_attribute efi_attr_runtime;
+extern __weak struct kobj_attribute efi_attr_config_table;
 static struct kobj_attribute efi_attr_fw_platform_size =
 	__ATTR_RO(fw_platform_size);
 
 static struct attribute *efi_subsys_attrs[] = {
 	&efi_attr_systab.attr,
+	&efi_attr_fw_platform_size.attr,
 	&efi_attr_fw_vendor.attr,
 	&efi_attr_runtime.attr,
 	&efi_attr_config_table.attr,
-	&efi_attr_fw_platform_size.attr,
 	NULL,
 };
 
-static umode_t efi_attr_is_visible(struct kobject *kobj,
-				   struct attribute *attr, int n)
+umode_t __weak efi_attr_is_visible(struct kobject *kobj, struct attribute *attr,
+				   int n)
 {
-	if (attr == &efi_attr_fw_vendor.attr) {
-		if (efi_enabled(EFI_PARAVIRT) ||
-				efi.fw_vendor == EFI_INVALID_TABLE_ADDR)
-			return 0;
-	} else if (attr == &efi_attr_runtime.attr) {
-		if (efi.runtime == EFI_INVALID_TABLE_ADDR)
-			return 0;
-	} else if (attr == &efi_attr_config_table.attr) {
-		if (efi.config_table == EFI_INVALID_TABLE_ADDR)
-			return 0;
-	}
-
 	return attr->mode;
 }
 

commit 06c0bd93434c5b9b284773f90bb054aff591d5be
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 14:40:57 2020 +0100

    efi: Clean up config_parse_tables()
    
    config_parse_tables() is a jumble of pointer arithmetic, due to the
    fact that on x86, we may be dealing with firmware whose native word
    size differs from the kernel's.
    
    This is not a concern on other architectures, and doesn't quite
    justify the state of the code, so let's clean it up by adding a
    non-x86 code path, constifying statically allocated tables and
    replacing preprocessor conditionals with IS_ENABLED() checks.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 2bfd6c0806ce..45de4c4a696b 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -460,7 +460,7 @@ void __init efi_mem_reserve(phys_addr_t addr, u64 size)
 	efi_arch_mem_reserve(addr, size);
 }
 
-static __initdata efi_config_table_type_t common_tables[] = {
+static const efi_config_table_type_t common_tables[] __initconst = {
 	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
@@ -477,9 +477,9 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{NULL_GUID, NULL, NULL},
 };
 
-static __init int match_config_table(efi_guid_t *guid,
+static __init int match_config_table(const efi_guid_t *guid,
 				     unsigned long table,
-				     efi_config_table_type_t *table_types)
+				     const efi_config_table_type_t *table_types)
 {
 	int i;
 
@@ -498,39 +498,38 @@ static __init int match_config_table(efi_guid_t *guid,
 	return 0;
 }
 
-int __init efi_config_parse_tables(void *config_tables, int count, int sz,
-				   efi_config_table_type_t *arch_tables)
+int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
+				   int count,
+				   const efi_config_table_type_t *arch_tables)
 {
-	void *tablep;
+	const efi_config_table_64_t *tbl64 = (void *)config_tables;
+	const efi_config_table_32_t *tbl32 = (void *)config_tables;
+	const efi_guid_t *guid;
+	unsigned long table;
 	int i;
 
-	tablep = config_tables;
 	pr_info("");
 	for (i = 0; i < count; i++) {
-		efi_guid_t guid;
-		unsigned long table;
-
-		if (efi_enabled(EFI_64BIT)) {
-			u64 table64;
-			guid = ((efi_config_table_64_t *)tablep)->guid;
-			table64 = ((efi_config_table_64_t *)tablep)->table;
-			table = table64;
-#ifndef CONFIG_64BIT
-			if (table64 >> 32) {
+		if (!IS_ENABLED(CONFIG_X86)) {
+			guid = &config_tables[i].guid;
+			table = (unsigned long)config_tables[i].table;
+		} else if (efi_enabled(EFI_64BIT)) {
+			guid = &tbl64[i].guid;
+			table = tbl64[i].table;
+
+			if (IS_ENABLED(CONFIG_X86_32) &&
+			    tbl64[i].table > U32_MAX) {
 				pr_cont("\n");
 				pr_err("Table located above 4GB, disabling EFI.\n");
 				return -EINVAL;
 			}
-#endif
 		} else {
-			guid = ((efi_config_table_32_t *)tablep)->guid;
-			table = ((efi_config_table_32_t *)tablep)->table;
+			guid = &tbl32[i].guid;
+			table = tbl32[i].table;
 		}
 
-		if (!match_config_table(&guid, table, common_tables))
-			match_config_table(&guid, table, arch_tables);
-
-		tablep += sz;
+		if (!match_config_table(guid, table, common_tables))
+			match_config_table(guid, table, arch_tables);
 	}
 	pr_cont("\n");
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);

commit 3a0701dc7ff8ebe1031a9f64c99c638929cd2d70
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:17:27 2020 +0100

    efi: Make efi_config_init() x86 only
    
    The efi_config_init() routine is no longer shared with ia64 so let's
    move it into the x86 arch code before making further x86 specific
    changes to it.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 80fe0044f2e2..2bfd6c0806ce 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -601,37 +601,6 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 	return 0;
 }
 
-int __init efi_config_init(efi_config_table_type_t *arch_tables)
-{
-	void *config_tables;
-	int sz, ret;
-
-	if (efi.systab->nr_tables == 0)
-		return 0;
-
-	if (efi_enabled(EFI_64BIT))
-		sz = sizeof(efi_config_table_64_t);
-	else
-		sz = sizeof(efi_config_table_32_t);
-
-	/*
-	 * Let's see what config tables the firmware passed to us.
-	 */
-	config_tables = early_memremap(efi.systab->tables,
-				       efi.systab->nr_tables * sz);
-	if (config_tables == NULL) {
-		pr_err("Could not map Configuration table!\n");
-		return -ENOMEM;
-	}
-
-	ret = efi_config_parse_tables(config_tables, efi.systab->nr_tables, sz,
-				      arch_tables);
-
-	early_memunmap(config_tables, efi.systab->nr_tables * sz);
-	return ret;
-}
-
-
 int __init efi_systab_check_header(const efi_table_hdr_t *systab_hdr,
 				   int min_major_version)
 {

commit 14fb4209094355928d5a742e35afabdf7b404c17
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 10:49:11 2020 +0100

    efi: Merge EFI system table revision and vendor checks
    
    We have three different versions of the code that checks the EFI system
    table revision and copies the firmware vendor string, and they are
    mostly equivalent, with the exception of the use of early_memremap_ro
    vs. __va() and the lowest major revision to warn about. Let's move this
    into common code and factor out the commonalities.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 41bb2c44cea4..80fe0044f2e2 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -631,6 +631,67 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	return ret;
 }
 
+
+int __init efi_systab_check_header(const efi_table_hdr_t *systab_hdr,
+				   int min_major_version)
+{
+	if (systab_hdr->signature != EFI_SYSTEM_TABLE_SIGNATURE) {
+		pr_err("System table signature incorrect!\n");
+		return -EINVAL;
+	}
+
+	if ((systab_hdr->revision >> 16) < min_major_version)
+		pr_err("Warning: System table version %d.%02d, expected %d.00 or greater!\n",
+		       systab_hdr->revision >> 16,
+		       systab_hdr->revision & 0xffff,
+		       min_major_version);
+
+	return 0;
+}
+
+#ifndef CONFIG_IA64
+static const efi_char16_t *__init map_fw_vendor(unsigned long fw_vendor,
+						size_t size)
+{
+	const efi_char16_t *ret;
+
+	ret = early_memremap_ro(fw_vendor, size);
+	if (!ret)
+		pr_err("Could not map the firmware vendor!\n");
+	return ret;
+}
+
+static void __init unmap_fw_vendor(const void *fw_vendor, size_t size)
+{
+	early_memunmap((void *)fw_vendor, size);
+}
+#else
+#define map_fw_vendor(p, s)	__va(p)
+#define unmap_fw_vendor(v, s)
+#endif
+
+void __init efi_systab_report_header(const efi_table_hdr_t *systab_hdr,
+				     unsigned long fw_vendor)
+{
+	char vendor[100] = "unknown";
+	const efi_char16_t *c16;
+	size_t i;
+
+	c16 = map_fw_vendor(fw_vendor, sizeof(vendor) * sizeof(efi_char16_t));
+	if (c16) {
+		for (i = 0; i < sizeof(vendor) - 1 && c16[i]; ++i)
+			vendor[i] = c16[i];
+		vendor[i] = '\0';
+
+		unmap_fw_vendor(c16, sizeof(vendor) * sizeof(efi_char16_t));
+	}
+
+	pr_info("EFI v%u.%.02u by %s\n",
+		systab_hdr->revision >> 16,
+		systab_hdr->revision & 0xffff,
+		vendor);
+}
+
 #ifdef CONFIG_EFI_VARS_MODULE
 static int __init efi_load_efivars(void)
 {

commit b7846e6be235c4a19337a32168b27ed836a1504e
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 15:06:54 2020 +0100

    efi: Make memreserve table handling local to efi.c
    
    There is no need for struct efi to carry the address of the memreserve
    table and share it with the world. So move it out and make it
    __initdata as well.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 1fc4e174f11d..41bb2c44cea4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -45,11 +45,11 @@ struct efi __read_mostly efi = {
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
 	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
-	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
 static unsigned long __ro_after_init rng_seed = EFI_INVALID_TABLE_ADDR;
+static unsigned long __initdata mem_reserve = EFI_INVALID_TABLE_ADDR;
 
 struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
@@ -470,7 +470,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
-	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
+	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &mem_reserve},
 #ifdef CONFIG_EFI_RCI2_TABLE
 	{DELLEMC_EFI_RCI2_TABLE_GUID, NULL, &rci2_table_phys},
 #endif
@@ -563,8 +563,8 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 
 	efi_tpm_eventlog_init();
 
-	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
-		unsigned long prsv = efi.mem_reserve;
+	if (mem_reserve != EFI_INVALID_TABLE_ADDR) {
+		unsigned long prsv = mem_reserve;
 
 		while (prsv) {
 			struct linux_efi_memreserve *rsv;
@@ -939,10 +939,10 @@ static struct linux_efi_memreserve *efi_memreserve_root __ro_after_init;
 
 static int __init efi_memreserve_map_root(void)
 {
-	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+	if (mem_reserve == EFI_INVALID_TABLE_ADDR)
 		return -ENODEV;
 
-	efi_memreserve_root = memremap(efi.mem_reserve,
+	efi_memreserve_root = memremap(mem_reserve,
 				       sizeof(*efi_memreserve_root),
 				       MEMREMAP_WB);
 	if (WARN_ON_ONCE(!efi_memreserve_root))

commit a17e809ea573e69474064ba2bbff06d212861e19
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 15:05:12 2020 +0100

    efi: Move mem_attr_table out of struct efi
    
    The memory attributes table is only used at init time by the core EFI
    code, so there is no need to carry its address in struct efi that is
    shared with the world. So move it out, and make it __ro_after_init as
    well, considering that the value is set during early boot.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index bbb6246d08be..1fc4e174f11d 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -43,7 +43,6 @@ struct efi __read_mostly efi = {
 	.runtime		= EFI_INVALID_TABLE_ADDR,
 	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
-	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
 	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
 	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
@@ -467,7 +466,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
-	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
+	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi_mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},

commit 5d288dbd88606d8f215c7138b10649115d79cadd
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 14:58:15 2020 +0100

    efi: Make rng_seed table handling local to efi.c
    
    Move the rng_seed table address from struct efi into a static global
    variable in efi.c, which is the only place we ever refer to it anyway.
    This reduces the footprint of struct efi, which is a r/w data structure
    that is shared with the world.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 68527fbbe01c..bbb6246d08be 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -44,13 +44,14 @@ struct efi __read_mostly efi = {
 	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
-	.rng_seed		= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
 	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
 	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
+static unsigned long __ro_after_init rng_seed = EFI_INVALID_TABLE_ADDR;
+
 struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
 	.mm_users		= ATOMIC_INIT(2),
@@ -467,7 +468,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
-	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
+	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
 	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
@@ -535,11 +536,11 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 	pr_cont("\n");
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
 
-	if (efi.rng_seed != EFI_INVALID_TABLE_ADDR) {
+	if (rng_seed != EFI_INVALID_TABLE_ADDR) {
 		struct linux_efi_random_seed *seed;
 		u32 size = 0;
 
-		seed = early_memremap(efi.rng_seed, sizeof(*seed));
+		seed = early_memremap(rng_seed, sizeof(*seed));
 		if (seed != NULL) {
 			size = seed->size;
 			early_memunmap(seed, sizeof(*seed));
@@ -547,8 +548,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 			pr_err("Could not map UEFI random seed!\n");
 		}
 		if (size > 0) {
-			seed = early_memremap(efi.rng_seed,
-					      sizeof(*seed) + size);
+			seed = early_memremap(rng_seed, sizeof(*seed) + size);
 			if (seed != NULL) {
 				pr_notice("seeding entropy pool\n");
 				add_bootloader_randomness(seed->bits, seed->size);
@@ -1048,7 +1048,7 @@ static int update_efi_random_seed(struct notifier_block *nb,
 	if (!kexec_in_progress)
 		return NOTIFY_DONE;
 
-	seed = memremap(efi.rng_seed, sizeof(*seed), MEMREMAP_WB);
+	seed = memremap(rng_seed, sizeof(*seed), MEMREMAP_WB);
 	if (seed != NULL) {
 		size = min(seed->size, EFI_RANDOM_SEED_SIZE);
 		memunmap(seed);
@@ -1056,8 +1056,7 @@ static int update_efi_random_seed(struct notifier_block *nb,
 		pr_err("Could not map UEFI random seed!\n");
 	}
 	if (size > 0) {
-		seed = memremap(efi.rng_seed, sizeof(*seed) + size,
-				MEMREMAP_WB);
+		seed = memremap(rng_seed, sizeof(*seed) + size, MEMREMAP_WB);
 		if (seed != NULL) {
 			seed->size = size;
 			get_random_bytes(seed->bits, seed->size);
@@ -1073,9 +1072,9 @@ static struct notifier_block efi_random_seed_nb = {
 	.notifier_call = update_efi_random_seed,
 };
 
-static int register_update_efi_random_seed(void)
+static int __init register_update_efi_random_seed(void)
 {
-	if (efi.rng_seed == EFI_INVALID_TABLE_ADDR)
+	if (rng_seed == EFI_INVALID_TABLE_ADDR)
 		return 0;
 	return register_reboot_notifier(&efi_random_seed_nb);
 }

commit fd506e0cf9fd4306aa0eb57cbff5f00514da8179
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 16:17:59 2020 +0100

    efi: Move UGA and PROP table handling to x86 code
    
    The UGA table is x86 specific (its handling was introduced when the
    EFI support code was modified to accommodate IA32), so there is no
    need to handle it in generic code.
    
    The EFI properties table is not strictly x86 specific, but it was
    deprecated almost immediately after having been introduced, due to
    implementation difficulties. Only x86 takes it into account today,
    and this is not going to change, so make this table x86 only as well.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 8129a52f8ef5..68527fbbe01c 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -39,12 +39,10 @@ struct efi __read_mostly efi = {
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
 	.smbios3		= EFI_INVALID_TABLE_ADDR,
-	.uga			= EFI_INVALID_TABLE_ADDR,
 	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
 	.runtime		= EFI_INVALID_TABLE_ADDR,
 	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
-	.properties_table	= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.rng_seed		= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
@@ -132,10 +130,8 @@ static ssize_t systab_show(struct kobject *kobj,
 		str += sprintf(str, "SMBIOS3=0x%lx\n", efi.smbios3);
 	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
-	if (efi.uga != EFI_INVALID_TABLE_ADDR)
-		str += sprintf(str, "UGA=0x%lx\n", efi.uga);
 
-	if (IS_ENABLED(CONFIG_IA64)) {
+	if (IS_ENABLED(CONFIG_IA64) || IS_ENABLED(CONFIG_X86)) {
 		extern char *efi_systab_show_arch(char *str);
 
 		str = efi_systab_show_arch(str);
@@ -469,9 +465,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
-	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
-	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
@@ -570,23 +564,6 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 
 	efi_tpm_eventlog_init();
 
-	/* Parse the EFI Properties table if it exists */
-	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
-		efi_properties_table_t *tbl;
-
-		tbl = early_memremap(efi.properties_table, sizeof(*tbl));
-		if (tbl == NULL) {
-			pr_err("Could not map Properties table!\n");
-			return -ENOMEM;
-		}
-
-		if (tbl->memory_protection_attribute &
-		    EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA)
-			set_bit(EFI_NX_PE_DATA, &efi.flags);
-
-		early_memunmap(tbl, sizeof(*tbl));
-	}
-
 	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
 		unsigned long prsv = efi.mem_reserve;
 

commit 120540f230d5d2d32846adc0156b58961c8c59d1
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 15:43:53 2020 +0100

    efi/ia64: Move HCDP and MPS table handling into IA64 arch code
    
    The HCDP and MPS tables are Itanium specific EFI config tables, so
    move their handling to ia64 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 5464e3849ee4..8129a52f8ef5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -35,12 +35,10 @@
 #include <asm/early_ioremap.h>
 
 struct efi __read_mostly efi = {
-	.mps			= EFI_INVALID_TABLE_ADDR,
 	.acpi			= EFI_INVALID_TABLE_ADDR,
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
 	.smbios3		= EFI_INVALID_TABLE_ADDR,
-	.hcdp			= EFI_INVALID_TABLE_ADDR,
 	.uga			= EFI_INVALID_TABLE_ADDR,
 	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
 	.runtime		= EFI_INVALID_TABLE_ADDR,
@@ -121,8 +119,6 @@ static ssize_t systab_show(struct kobject *kobj,
 	if (!kobj || !buf)
 		return -EINVAL;
 
-	if (efi.mps != EFI_INVALID_TABLE_ADDR)
-		str += sprintf(str, "MPS=0x%lx\n", efi.mps);
 	if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "ACPI20=0x%lx\n", efi.acpi20);
 	if (efi.acpi != EFI_INVALID_TABLE_ADDR)
@@ -136,11 +132,15 @@ static ssize_t systab_show(struct kobject *kobj,
 		str += sprintf(str, "SMBIOS3=0x%lx\n", efi.smbios3);
 	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
-	if (efi.hcdp != EFI_INVALID_TABLE_ADDR)
-		str += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);
 	if (efi.uga != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "UGA=0x%lx\n", efi.uga);
 
+	if (IS_ENABLED(CONFIG_IA64)) {
+		extern char *efi_systab_show_arch(char *str);
+
+		str = efi_systab_show_arch(str);
+	}
+
 	return str - buf;
 }
 
@@ -467,8 +467,6 @@ void __init efi_mem_reserve(phys_addr_t addr, u64 size)
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
-	{HCDP_TABLE_GUID, "HCDP", &efi.hcdp},
-	{MPS_TABLE_GUID, "MPS", &efi.mps},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},

commit 50d53c58dd77d3b0b6a5afe391eaac3722fc3153
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 15:29:21 2020 +0100

    efi: Drop handling of 'boot_info' configuration table
    
    Some plumbing exists to handle a UEFI configuration table of type
    BOOT_INFO but since we never match it to a GUID anywhere, we never
    actually register such a table, or access it, for that matter. So
    simply drop all mentions of it.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 621220ab3d0e..5464e3849ee4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -40,7 +40,6 @@ struct efi __read_mostly efi = {
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
 	.smbios3		= EFI_INVALID_TABLE_ADDR,
-	.boot_info		= EFI_INVALID_TABLE_ADDR,
 	.hcdp			= EFI_INVALID_TABLE_ADDR,
 	.uga			= EFI_INVALID_TABLE_ADDR,
 	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
@@ -139,8 +138,6 @@ static ssize_t systab_show(struct kobject *kobj,
 		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
 	if (efi.hcdp != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);
-	if (efi.boot_info != EFI_INVALID_TABLE_ADDR)
-		str += sprintf(str, "BOOTINFO=0x%lx\n", efi.boot_info);
 	if (efi.uga != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "UGA=0x%lx\n", efi.uga);
 

commit 62b605b53ad4dc6d9ec11ab4c7aa61df10b76af6
Author: Anshuman Khandual <anshuman.khandual@arm.com>
Date:   Mon Jan 13 18:22:41 2020 +0100

    efi: Fix comment for efi_mem_type() wrt absent physical addresses
    
    A previous commit f99afd08a45f ("efi: Update efi_mem_type() to return an
    error rather than 0") changed the return value from EFI_RESERVED_TYPE to
    -EINVAL when the searched physical address is not present in any memory
    descriptor. But the comment preceding the function never changed. Let's
    change the comment now to reflect the new return value -EINVAL.
    
    Signed-off-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-10-ardb@kernel.org

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 2b02cb165f16..621220ab3d0e 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -908,7 +908,7 @@ u64 efi_mem_attributes(unsigned long phys_addr)
  *
  * Search in the EFI memory map for the region covering @phys_addr.
  * Returns the EFI memory type if the region was found in the memory
- * map, EFI_RESERVED_TYPE (zero) otherwise.
+ * map, -EINVAL otherwise.
  */
 int efi_mem_type(unsigned long phys_addr)
 {

commit a114a18c7dbc2b7ac5a1379a8dcced6095c52ead
Merge: ea200dec5128 a470552ee896
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 17 10:39:55 2019 -0800

    Merge branch 'efi-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI fixes from Ingo Molnar:
     "Protect presistent EFI memory reservations from kexec, fix EFIFB early
      console, EFI stub graphics output fixes and other misc fixes."
    
    * 'efi-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      efi: Don't attempt to map RCI2 config table if it doesn't exist
      efi/earlycon: Remap entire framebuffer after page initialization
      efi: Fix efi_loaded_image_t::unload type
      efi/gop: Fix memory leak in __gop_query32/64()
      efi/gop: Return EFI_SUCCESS if a usable GOP was found
      efi/gop: Return EFI_NOT_FOUND if there are no usable GOPs
      efi/memreserve: Register reservations as 'reserved' in /proc/iomem

commit c593642c8be046915ca3a4a300243a68077cd207
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Mon Dec 9 10:31:43 2019 -0800

    treewide: Use sizeof_field() macro
    
    Replace all the occurrences of FIELD_SIZEOF() with sizeof_field() except
    at places where these are defined. Later patches will remove the unused
    definition of FIELD_SIZEOF().
    
    This patch is generated using following script:
    
    EXCLUDE_FILES="include/linux/stddef.h|include/linux/kernel.h"
    
    git grep -l -e "\bFIELD_SIZEOF\b" | while read file;
    do
    
            if [[ "$file" =~ $EXCLUDE_FILES ]]; then
                    continue
            fi
            sed -i  -e 's/\bFIELD_SIZEOF\b/sizeof_field/g' $file;
    done
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Link: https://lore.kernel.org/r/20190924105839.110713-3-pankaj.laxminarayan.bharadiya@intel.com
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: David Miller <davem@davemloft.net> # for net

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index d101f072c8f8..407816da9fcb 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -681,7 +681,7 @@ device_initcall(efi_load_efivars);
 		{ name },				   \
 		{ prop },				   \
 		offsetof(struct efi_fdt_params, field),    \
-		FIELD_SIZEOF(struct efi_fdt_params, field) \
+		sizeof_field(struct efi_fdt_params, field) \
 	}
 
 struct params {

commit ab0eb16205b43ece4c78e2259e681ff3d645ea66
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Dec 6 16:55:37 2019 +0000

    efi/memreserve: Register reservations as 'reserved' in /proc/iomem
    
    Memory regions that are reserved using efi_mem_reserve_persistent()
    are recorded in a special EFI config table which survives kexec,
    allowing the incoming kernel to honour them as well. However,
    such reservations are not visible in /proc/iomem, and so the kexec
    tools that load the incoming kernel and its initrd into memory may
    overwrite these reserved regions before the incoming kernel has a
    chance to reserve them from further use.
    
    Address this problem by adding these reservations to /proc/iomem as
    they are created. Note that reservations that are inherited from a
    previous kernel are memblock_reserve()'d early on, so they are already
    visible in /proc/iomem.
    
    Tested-by: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: <stable@vger.kernel.org> # v5.4+
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191206165542.31469-2-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index d101f072c8f8..b0961950d918 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -979,6 +979,24 @@ static int __init efi_memreserve_map_root(void)
 	return 0;
 }
 
+static int efi_mem_reserve_iomem(phys_addr_t addr, u64 size)
+{
+	struct resource *res, *parent;
+
+	res = kzalloc(sizeof(struct resource), GFP_ATOMIC);
+	if (!res)
+		return -ENOMEM;
+
+	res->name	= "reserved";
+	res->flags	= IORESOURCE_MEM;
+	res->start	= addr;
+	res->end	= addr + size - 1;
+
+	/* we expect a conflict with a 'System RAM' region */
+	parent = request_resource_conflict(&iomem_resource, res);
+	return parent ? request_resource(parent, res) : 0;
+}
+
 int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 {
 	struct linux_efi_memreserve *rsv;
@@ -1003,7 +1021,7 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 			rsv->entry[index].size = size;
 
 			memunmap(rsv);
-			return 0;
+			return efi_mem_reserve_iomem(addr, size);
 		}
 		memunmap(rsv);
 	}
@@ -1013,6 +1031,12 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 	if (!rsv)
 		return -ENOMEM;
 
+	rc = efi_mem_reserve_iomem(__pa(rsv), SZ_4K);
+	if (rc) {
+		free_page((unsigned long)rsv);
+		return rc;
+	}
+
 	/*
 	 * The memremap() call above assumes that a linux_efi_memreserve entry
 	 * never crosses a page boundary, so let's ensure that this remains true
@@ -1029,7 +1053,7 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 	efi_memreserve_root->next = __pa(rsv);
 	spin_unlock(&efi_mem_reserve_persistent_lock);
 
-	return 0;
+	return efi_mem_reserve_iomem(addr, size);
 }
 
 static int __init efi_memreserve_root_init(void)

commit 782b59711e1561ee0da06bc478ca5e8249aa8d09
Merge: 995e2ef08280 0f1839d08887
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 26 10:31:02 2019 +0100

    Merge branch 'acpi-mm'
    
    * acpi-mm:
      ACPI: HMAT: use %u instead of %d to print u32 values
      ACPI: NUMA: HMAT: fix a section mismatch
      ACPI: HMAT: don't mix pxm and nid when setting memory target processor_pxm
      ACPI: NUMA: HMAT: Register "soft reserved" memory as an "hmem" device
      ACPI: NUMA: HMAT: Register HMAT at device_initcall level
      device-dax: Add a driver for "hmem" devices
      dax: Fix alloc_dax_region() compile warning
      lib: Uplevel the pmem "region" ida to a global allocator
      x86/efi: Add efi_fake_mem support for EFI_MEMORY_SP
      arm/efi: EFI soft reservation to memblock
      x86/efi: EFI soft reservation to E820 enumeration
      efi: Common enable/disable infrastructure for EFI soft reservation
      x86/efi: Push EFI_MEMMAP check into leaf routines
      efi: Enumerate EFI_MEMORY_SP
      ACPI: NUMA: Establish a new drivers/acpi/numa/ directory

commit 713608a30b0a5f5b0866a7c4f462e51b362ee06d
Merge: b4447c0dcd0d c7ccf10bb92e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 26 10:29:54 2019 +0100

    Merge branch 'acpica'
    
    * acpica:
      ACPICA: Update version to 20191018
      ACPICA: debugger: remove leading whitespaces when converting a string to a buffer
      ACPICA: acpiexec: initialize all simple types and field units from user input
      ACPICA: debugger: add field unit support for acpi_db_get_next_token
      ACPICA: debugger: surround field unit output with braces '{'
      ACPICA: debugger: add command to dump all fields of particular subtype
      ACPICA: utilities: add flag to only display data when dumping buffers
      ACPICA: make acpi_load_table() return table index
      ACPICA: Add new external interface, acpi_unload_table()
      ACPICA: More Clang changes
      ACPICA: Win OSL: Replace get_tick_count with get_tick_count64
      ACPICA: Results from Clang

commit b617c5266eedbef2ccbb90931bb9175faa4ae0bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:11 2019 -0800

    efi: Common enable/disable infrastructure for EFI soft reservation
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose".
    
    The proposed Linux behavior for specific purpose memory is that it is
    reserved for direct-access (device-dax) by default and not available for
    any kernel usage, not even as an OOM fallback.  Later, through udev
    scripts or another init mechanism, these device-dax claimed ranges can
    be reconfigured and hot-added to the available System-RAM with a unique
    node identifier. This device-dax management scheme implements "soft" in
    the "soft reserved" designation by allowing some or all of the
    reservation to be recovered as typical memory. This policy can be
    disabled at compile-time with CONFIG_EFI_SOFT_RESERVE=n, or runtime with
    efi=nosoftreserve.
    
    As for this patch, define the common helpers to determine if the
    EFI_MEMORY_SP attribute should be honored. The determination needs to be
    made early to prevent the kernel from being loaded into soft-reserved
    memory, or otherwise allowing early allocations to land there. Follow-on
    changes are needed per architecture to leverage these helpers in their
    respective mem-init paths.
    
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f8f8e273d809..e1cb915b45c6 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -81,6 +81,11 @@ bool efi_runtime_disabled(void)
 	return disable_runtime;
 }
 
+bool __pure __efi_soft_reserve_enabled(void)
+{
+	return !efi_enabled(EFI_MEM_NO_SOFT_RESERVE);
+}
+
 static int __init parse_efi_cmdline(char *str)
 {
 	if (!str) {
@@ -94,6 +99,9 @@ static int __init parse_efi_cmdline(char *str)
 	if (parse_option_str(str, "noruntime"))
 		disable_runtime = true;
 
+	if (parse_option_str(str, "nosoftreserve"))
+		set_bit(EFI_MEM_NO_SOFT_RESERVE, &efi.flags);
+
 	return 0;
 }
 early_param("efi", parse_efi_cmdline);

commit fe3e5e65c06edb1c56e64e567f053e243142001f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:00 2019 -0800

    efi: Enumerate EFI_MEMORY_SP
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose". The intent of this bit is to allow the OS to identify precious
    or scarce memory resources and optionally manage it separately from
    EfiConventionalMemory. As defined older OSes that do not know about this
    attribute are permitted to ignore it and the memory will be handled
    according to the OS default policy for the given memory type.
    
    In other words, this "specific purpose" hint is deliberately weaker than
    EfiReservedMemoryType in that the system continues to operate if the OS
    takes no action on the attribute. The risk of taking no action is
    potentially unwanted / unmovable kernel allocations from the designated
    resource that prevent the full realization of the "specific purpose".
    For example, consider a system with a high-bandwidth memory pool. Older
    kernels are permitted to boot and consume that memory as conventional
    "System-RAM" newer kernels may arrange for that memory to be set aside
    (soft reserved) by the system administrator for a dedicated
    high-bandwidth memory aware application to consume.
    
    Specifically, this mechanism allows for the elimination of scenarios
    where platform firmware tries to game OS policy by lying about ACPI SLIT
    values, i.e. claiming that a precious memory resource has a high
    distance to trigger the OS to avoid it by default. This reservation hint
    allows platform-firmware to instead tell the truth about performance
    characteristics by indicate to OS memory management to put immovable
    allocations elsewhere.
    
    Implement simple detection of the bit for EFI memory table dumps and
    save the kernel policy for a follow-on change.
    
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index e98bbf8e56d9..f8f8e273d809 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -842,15 +842,16 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
-		     EFI_MEMORY_NV |
+		     EFI_MEMORY_NV | EFI_MEMORY_SP |
 		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
 		snprintf(pos, size, "|attr=0x%016llx]",
 			 (unsigned long long)attr);
 	else
 		snprintf(pos, size,
-			 "|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+			 "|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
 			 attr & EFI_MEMORY_MORE_RELIABLE ? "MR" : "",
+			 attr & EFI_MEMORY_SP      ? "SP"  : "",
 			 attr & EFI_MEMORY_NV      ? "NV"  : "",
 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
 			 attr & EFI_MEMORY_RP      ? "RP"  : "",

commit 18b915ac6b0ac5ba7ded03156860f60a9f16df2b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Oct 29 18:37:52 2019 +0100

    efi/random: Treat EFI_RNG_PROTOCOL output as bootloader randomness
    
    Commit 428826f5358c ("fdt: add support for rng-seed") introduced
    add_bootloader_randomness(), permitting randomness provided by the
    bootloader or firmware to be credited as entropy. However, the fact
    that the UEFI support code was already wired into the RNG subsystem
    via a call to add_device_randomness() was overlooked, and so it was
    not converted at the same time.
    
    Note that this UEFI (v2.4 or newer) feature is currently only
    implemented for EFI stub booting on ARM, and further note that
    CONFIG_RANDOM_TRUST_BOOTLOADER must be enabled, and this should be
    done only if there indeed is sufficient trust in the bootloader
    _and_ its source of randomness.
    
    [ ardb: update commit log ]
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191029173755.27149-4-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 69f00f7453a3..e98bbf8e56d9 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -554,7 +554,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 					      sizeof(*seed) + size);
 			if (seed != NULL) {
 				pr_notice("seeding entropy pool\n");
-				add_device_randomness(seed->bits, seed->size);
+				add_bootloader_randomness(seed->bits, seed->size);
 				early_memunmap(seed, sizeof(*seed) + size);
 			} else {
 				pr_err("Could not map UEFI random seed!\n");

commit 1770093c5bed404ac69b04dc8b9e62a2c4db944a
Author: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
Date:   Fri Oct 25 14:36:53 2019 -0700

    ACPICA: make acpi_load_table() return table index
    
    ACPICA commit d1716a829d19be23277d9157c575a03b9abb7457
    
    For unloading an ACPI table, it is necessary to provide the index of
    the table. The method intended for dynamically loading or hotplug
    addition of tables, acpi_load_table(), should provide this information
    via an optional pointer to the loaded table index.
    
    This patch fixes the table unload function of acpi_configfs.
    
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Fixes: d06c47e3dd07f ("ACPI: configfs: Resolve objects on host-directed table loads")
    Link: https://github.com/acpica/acpica/commit/d1716a82
    Signed-off-by: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Tested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 69f00f7453a3..0d65cb21519d 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -296,7 +296,7 @@ static __init int efivar_ssdt_load(void)
 			goto free_data;
 		}
 
-		ret = acpi_load_table(data);
+		ret = acpi_load_table(data, NULL);
 		if (ret) {
 			pr_err("failed to load table: %d\n", ret);
 			goto free_data;

commit c05f8f92b701576b615f30aac31fabdc0648649b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Oct 2 18:58:59 2019 +0200

    efivar/ssdt: Don't iterate over EFI vars if no SSDT override was specified
    
    The kernel command line option efivar_ssdt= allows the name to be
    specified of an EFI variable containing an ACPI SSDT table that should
    be loaded into memory by the OS, and treated as if it was provided by
    the firmware.
    
    Currently, that code will always iterate over the EFI variables and
    compare each name with the provided name, even if the command line
    option wasn't set to begin with.
    
    So bail early when no variable name was provided. This works around a
    boot regression on the 2012 Mac Pro, as reported by Scott.
    
    Tested-by: Scott Talbert <swt@techie.net>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org> # v4.9+
    Cc: Ben Dooks <ben.dooks@codethink.co.uk>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Cc: Jerry Snitselaar <jsnitsel@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: Lyude Paul <lyude@redhat.com>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: Octavian Purdila <octavian.purdila@intel.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Cc: linux-integrity@vger.kernel.org
    Fixes: 475fb4e8b2f4 ("efi / ACPI: load SSTDs from EFI variables")
    Link: https://lkml.kernel.org/r/20191002165904.8819-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 8d3e778e988b..69f00f7453a3 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -267,6 +267,9 @@ static __init int efivar_ssdt_load(void)
 	void *data;
 	int ret;
 
+	if (!efivar_ssdt[0])
+		return 0;
+
 	ret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);
 
 	list_for_each_entry_safe(entry, aux, &entries, list) {

commit aefcf2f4b58155d27340ba5f9ddbe9513da8286d
Merge: f1f2f614d535 45893a0abee6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 28 08:14:15 2019 -0700

    Merge branch 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull kernel lockdown mode from James Morris:
     "This is the latest iteration of the kernel lockdown patchset, from
      Matthew Garrett, David Howells and others.
    
      From the original description:
    
        This patchset introduces an optional kernel lockdown feature,
        intended to strengthen the boundary between UID 0 and the kernel.
        When enabled, various pieces of kernel functionality are restricted.
        Applications that rely on low-level access to either hardware or the
        kernel may cease working as a result - therefore this should not be
        enabled without appropriate evaluation beforehand.
    
        The majority of mainstream distributions have been carrying variants
        of this patchset for many years now, so there's value in providing a
        doesn't meet every distribution requirement, but gets us much closer
        to not requiring external patches.
    
      There are two major changes since this was last proposed for mainline:
    
       - Separating lockdown from EFI secure boot. Background discussion is
         covered here: https://lwn.net/Articles/751061/
    
       -  Implementation as an LSM, with a default stackable lockdown LSM
          module. This allows the lockdown feature to be policy-driven,
          rather than encoding an implicit policy within the mechanism.
    
      The new locked_down LSM hook is provided to allow LSMs to make a
      policy decision around whether kernel functionality that would allow
      tampering with or examining the runtime state of the kernel should be
      permitted.
    
      The included lockdown LSM provides an implementation with a simple
      policy intended for general purpose use. This policy provides a coarse
      level of granularity, controllable via the kernel command line:
    
        lockdown={integrity|confidentiality}
    
      Enable the kernel lockdown feature. If set to integrity, kernel features
      that allow userland to modify the running kernel are disabled. If set to
      confidentiality, kernel features that allow userland to extract
      confidential information from the kernel are also disabled.
    
      This may also be controlled via /sys/kernel/security/lockdown and
      overriden by kernel configuration.
    
      New or existing LSMs may implement finer-grained controls of the
      lockdown features. Refer to the lockdown_reason documentation in
      include/linux/security.h for details.
    
      The lockdown feature has had signficant design feedback and review
      across many subsystems. This code has been in linux-next for some
      weeks, with a few fixes applied along the way.
    
      Stephen Rothwell noted that commit 9d1f8be5cf42 ("bpf: Restrict bpf
      when kernel lockdown is in confidentiality mode") is missing a
      Signed-off-by from its author. Matthew responded that he is providing
      this under category (c) of the DCO"
    
    * 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (31 commits)
      kexec: Fix file verification on S390
      security: constify some arrays in lockdown LSM
      lockdown: Print current->comm in restriction messages
      efi: Restrict efivar_ssdt_load when the kernel is locked down
      tracefs: Restrict tracefs when the kernel is locked down
      debugfs: Restrict debugfs when the kernel is locked down
      kexec: Allow kexec_file() with appropriate IMA policy when locked down
      lockdown: Lock down perf when in confidentiality mode
      bpf: Restrict bpf when kernel lockdown is in confidentiality mode
      lockdown: Lock down tracing and perf kprobes when in confidentiality mode
      lockdown: Lock down /proc/kcore
      x86/mmiotrace: Lock down the testmmiotrace module
      lockdown: Lock down module params that specify hardware parameters (eg. ioport)
      lockdown: Lock down TIOCSSERIAL
      lockdown: Prohibit PCMCIA CIS storage when the kernel is locked down
      acpi: Disable ACPI table override if the kernel is locked down
      acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
      ACPI: Limit access to custom_method when the kernel is locked down
      x86/msr: Restrict MSR access when the kernel is locked down
      x86: Lock down IO port access when the kernel is locked down
      ...

commit 1957a85b0032a81e6482ca4aab883643b8dae06e
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Mon Aug 19 17:18:04 2019 -0700

    efi: Restrict efivar_ssdt_load when the kernel is locked down
    
    efivar_ssdt_load allows the kernel to import arbitrary ACPI code from an
    EFI variable, which gives arbitrary code execution in ring 0. Prevent
    that when the kernel is locked down.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: linux-efi@vger.kernel.org
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4b7cf7bc0ded..5f98374f77f4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -30,6 +30,7 @@
 #include <linux/acpi.h>
 #include <linux/ucs2_string.h>
 #include <linux/memblock.h>
+#include <linux/security.h>
 
 #include <asm/early_ioremap.h>
 
@@ -241,6 +242,11 @@ static void generic_ops_unregister(void)
 static char efivar_ssdt[EFIVAR_SSDT_NAME_MAX] __initdata;
 static int __init efivar_ssdt_setup(char *str)
 {
+	int ret = security_locked_down(LOCKDOWN_ACPI_TABLES);
+
+	if (ret)
+		return ret;
+
 	if (strlen(str) < sizeof(efivar_ssdt))
 		memcpy(efivar_ssdt, str, strlen(str));
 	else

commit 1c5fecb61255aa12a16c4c06335ab68979865914
Author: Narendra K <Narendra.K@dell.com>
Date:   Wed Jul 10 18:59:15 2019 +0000

    efi: Export Runtime Configuration Interface table to sysfs
    
    System firmware advertises the address of the 'Runtime
    Configuration Interface table version 2 (RCI2)' via
    an EFI Configuration Table entry. This code retrieves the RCI2
    table from the address and exports it to sysfs as a binary
    attribute 'rci2' under /sys/firmware/efi/tables directory.
    The approach adopted is similar to the attribute 'DMI' under
    /sys/firmware/dmi/tables.
    
    RCI2 table contains BIOS HII in XML format and is used to populate
    BIOS setup page in Dell EMC OpenManage Server Administrator tool.
    The BIOS setup page contains BIOS tokens which can be configured.
    
    Signed-off-by: Narendra K <Narendra.K@dell.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 801925c5bcfb..8f1ab04f6743 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -465,6 +465,9 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
 	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
+#ifdef CONFIG_EFI_RCI2_TABLE
+	{DELLEMC_EFI_RCI2_TABLE_GUID, NULL, &rci2_table_phys},
+#endif
 	{NULL_GUID, NULL, NULL},
 };
 

commit 5828efb95bc43ad6a59f05458d3aed9649dd5a63
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 16:28:53 2019 +0200

    efi: ia64: move SAL systab handling out of generic EFI code
    
    The SAL systab is an Itanium specific EFI configuration table, so
    move its handling into arch/ia64 where it belongs.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4dfd873373bd..801925c5bcfb 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -39,7 +39,6 @@ struct efi __read_mostly efi = {
 	.acpi20			= EFI_INVALID_TABLE_ADDR,
 	.smbios			= EFI_INVALID_TABLE_ADDR,
 	.smbios3		= EFI_INVALID_TABLE_ADDR,
-	.sal_systab		= EFI_INVALID_TABLE_ADDR,
 	.boot_info		= EFI_INVALID_TABLE_ADDR,
 	.hcdp			= EFI_INVALID_TABLE_ADDR,
 	.uga			= EFI_INVALID_TABLE_ADDR,
@@ -456,7 +455,6 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
 	{HCDP_TABLE_GUID, "HCDP", &efi.hcdp},
 	{MPS_TABLE_GUID, "MPS", &efi.mps},
-	{SAL_SYSTEM_TABLE_GUID, "SALsystab", &efi.sal_systab},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},

commit ec7e1605d79d1d469b25e396f2056e42386f512f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 15:48:35 2019 +0200

    efi/x86: move UV_SYSTAB handling into arch/x86
    
    The SGI UV UEFI machines are tightly coupled to the x86 architecture
    so there is no need to keep any awareness of its existence in the
    generic EFI layer, especially since we already have the infrastructure
    to handle arch-specific configuration tables, and were even already
    using it to some extent.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cbdbdbc8f9eb..4dfd873373bd 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -43,7 +43,6 @@ struct efi __read_mostly efi = {
 	.boot_info		= EFI_INVALID_TABLE_ADDR,
 	.hcdp			= EFI_INVALID_TABLE_ADDR,
 	.uga			= EFI_INVALID_TABLE_ADDR,
-	.uv_systab		= EFI_INVALID_TABLE_ADDR,
 	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
 	.runtime		= EFI_INVALID_TABLE_ADDR,
 	.config_table		= EFI_INVALID_TABLE_ADDR,

commit e55f31a599478fb06a5a5d95e019e963322535cb
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 15:36:45 2019 +0200

    efi: x86: move efi_is_table_address() into arch/x86
    
    The function efi_is_table_address() and the associated array of table
    pointers is specific to x86. Since we will be adding some more x86
    specific tables, let's move this code out of the generic code first.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index ad3b1f4866b3..cbdbdbc8f9eb 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -57,25 +57,6 @@ struct efi __read_mostly efi = {
 };
 EXPORT_SYMBOL(efi);
 
-static unsigned long *efi_tables[] = {
-	&efi.mps,
-	&efi.acpi,
-	&efi.acpi20,
-	&efi.smbios,
-	&efi.smbios3,
-	&efi.sal_systab,
-	&efi.boot_info,
-	&efi.hcdp,
-	&efi.uga,
-	&efi.uv_systab,
-	&efi.fw_vendor,
-	&efi.runtime,
-	&efi.config_table,
-	&efi.esrt,
-	&efi.properties_table,
-	&efi.mem_attr_table,
-};
-
 struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
 	.mm_users		= ATOMIC_INIT(2),
@@ -964,20 +945,6 @@ int efi_status_to_err(efi_status_t status)
 	return err;
 }
 
-bool efi_is_table_address(unsigned long phys_addr)
-{
-	unsigned int i;
-
-	if (phys_addr == EFI_INVALID_TABLE_ADDR)
-		return false;
-
-	for (i = 0; i < ARRAY_SIZE(efi_tables); i++)
-		if (*(efi_tables[i]) == phys_addr)
-			return true;
-
-	return false;
-}
-
 static DEFINE_SPINLOCK(efi_mem_reserve_persistent_lock);
 static struct linux_efi_memreserve *efi_memreserve_root __ro_after_init;
 

commit 884922591e2b58fd7f1018701f957446d1ffac4d
Merge: 222a21d29521 166a2809d65b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 18:47:42 2019 -0700

    Merge tag 'tpmdd-next-20190625' of git://git.infradead.org/users/jjs/linux-tpmdd
    
    Pull tpm updates from Jarkko Sakkinen:
     "This contains two critical bug fixes and support for obtaining TPM
      events triggered by ExitBootServices().
    
      For the latter I have to give a quite verbose explanation not least
      because I had to revisit all the details myself to remember what was
      going on in Matthew's patches.
    
      The preboot software stack maintains an event log that gets entries
      every time something gets hashed to any of the PCR registers. What
      gets hashed could be a component to be run or perhaps log of some
      actions taken just to give couple of coarse examples. In general,
      anything relevant for the boot process that the preboot software does
      gets hashed and a log entry with a specific event type [1].
    
      The main application for this is remote attestation and the reason why
      it is useful is nicely put in the very first section of [1]:
    
         "Attestation is used to provide information about the platform’s
          state to a challenger. However, PCR contents are difficult to
          interpret; therefore, attestation is typically more useful when
          the PCR contents are accompanied by a measurement log. While not
          trusted on their own, the measurement log contains a richer set of
          information than do the PCR contents. The PCR contents are used to
          provide the validation of the measurement log."
    
      Because EFI_TCG2_PROTOCOL.GetEventLog() is not available after calling
      ExitBootServices(), Linux EFI stub copies the event log to a custom
      configuration table. Unfortunately, ExitBootServices() also generates
      events and obviously these events do not get copied to that table.
      Luckily firmware does this for us by providing a configuration table
      identified by EFI_TCG2_FINAL_EVENTS_TABLE_GUID.
    
      This essentially contains necessary changes to provide the full event
      log for the use the user space that is concatenated from these two
      partial event logs [2]"
    
    [1] https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/
    [2] The final concatenation is done in drivers/char/tpm/eventlog/efi.c
    
    * tag 'tpmdd-next-20190625' of git://git.infradead.org/users/jjs/linux-tpmdd:
      tpm: Don't duplicate events from the final event log in the TCG2 log
      Abstract out support for locating an EFI config table
      tpm: Fix TPM 1.2 Shutdown sequence to prevent future TPM operations
      efi: Attempt to get the TCG2 event log in the boot stub
      tpm: Append the final event log to the TPM event log
      tpm: Reserve the TPM final events table
      tpm: Abstract crypto agile event size calculations
      tpm: Actually fail on TPM errors during "get random"

commit c46f3405692de1ac82240d927b9c7a0f9d6a4a36
Author: Matthew Garrett <mjg59@google.com>
Date:   Mon May 20 13:54:59 2019 -0700

    tpm: Reserve the TPM final events table
    
    UEFI systems provide a boot services protocol for obtaining the TPM
    event log, but this is unusable after ExitBootServices() is called.
    Unfortunately ExitBootServices() itself triggers additional TPM events
    that then can't be obtained using this protocol. The platform provides a
    mechanism for the OS to obtain these events by recording them to a
    separate UEFI configuration table which the OS can then map.
    
    Unfortunately this table isn't self describing in terms of providing its
    length, so we need to parse the events inside it to figure out how long
    it is. Since the table isn't mapped at this point, we need to extend the
    length calculation function to be able to map the event as it goes
    along.
    
    (Fixes by Bartosz Szczepanek <bsz@semihalf.com>)
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Bartosz Szczepanek <bsz@semihalf.com>
    Tested-by: Bartosz Szczepanek <bsz@semihalf.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 16b2137d117c..a449e645c44f 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -52,6 +52,7 @@ struct efi __read_mostly efi = {
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.rng_seed		= EFI_INVALID_TABLE_ADDR,
 	.tpm_log		= EFI_INVALID_TABLE_ADDR,
+	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
 	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
@@ -484,6 +485,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
+	{LINUX_EFI_TPM_FINAL_LOG_GUID, "TPMFinalLog", &efi.tpm_final_log},
 	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
 	{NULL_GUID, NULL, NULL},
 };

commit 18df7577adae6c6c778bf774b3aebcacbc1fb439
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sun Jun 9 20:17:44 2019 +0200

    efi/memreserve: deal with memreserve entries in unmapped memory
    
    Ensure that the EFI memreserve entries can be accessed, even if they
    are located in memory that the kernel (e.g., a crashkernel) omits from
    the linear map.
    
    Fixes: 80424b02d42b ("efi: Reduce the amount of memblock reservations ...")
    Cc: <stable@vger.kernel.org> # 5.0+
    Reported-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
    Reviewed-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
    Tested-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 16b2137d117c..4b7cf7bc0ded 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -1009,14 +1009,16 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 
 	/* first try to find a slot in an existing linked list entry */
 	for (prsv = efi_memreserve_root->next; prsv; prsv = rsv->next) {
-		rsv = __va(prsv);
+		rsv = memremap(prsv, sizeof(*rsv), MEMREMAP_WB);
 		index = atomic_fetch_add_unless(&rsv->count, 1, rsv->size);
 		if (index < rsv->size) {
 			rsv->entry[index].base = addr;
 			rsv->entry[index].size = size;
 
+			memunmap(rsv);
 			return 0;
 		}
+		memunmap(rsv);
 	}
 
 	/* no slot found - allocate a new linked list entry */
@@ -1024,7 +1026,13 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 	if (!rsv)
 		return -ENOMEM;
 
-	rsv->size = EFI_MEMRESERVE_COUNT(PAGE_SIZE);
+	/*
+	 * The memremap() call above assumes that a linux_efi_memreserve entry
+	 * never crosses a page boundary, so let's ensure that this remains true
+	 * even when kexec'ing a 4k pages kernel from a >4k pages kernel, by
+	 * using SZ_4K explicitly in the size calculation below.
+	 */
+	rsv->size = EFI_MEMRESERVE_COUNT(SZ_4K);
 	atomic_set(&rsv->count, 1);
 	rsv->entry[0].base = addr;
 	rsv->entry[0].size = size;

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 521a541d02ad..16b2137d117c 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * efi.c - EFI subsystem
  *
@@ -9,8 +10,6 @@
  * allowing the efivarfs to be mounted or the efivars module to be loaded.
  * The existance of /sys/firmware/efi may also be used by userspace to
  * determine that the system supports EFI.
- *
- * This file is released under the GPLv2.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 88447c5b93d98be847f428c39ba589779a59eb83
Author: Rob Bradford <robert.bradford@intel.com>
Date:   Sat May 25 13:25:59 2019 +0200

    efi: Allow the number of EFI configuration tables entries to be zero
    
    Only try and access the EFI configuration tables if there there are any
    reported. This allows EFI to be continued to used on systems where there
    are no configuration table entries.
    
    Signed-off-by: Rob Bradford <robert.bradford@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Gen Zhang <blackgod016574@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190525112559.7917-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 55b77c576c42..521a541d02ad 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -636,6 +636,9 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	void *config_tables;
 	int sz, ret;
 
+	if (efi.systab->nr_tables == 0)
+		return 0;
+
 	if (efi_enabled(EFI_64BIT))
 		sz = sizeof(efi_config_table_64_t);
 	else

commit 582a32e708823e5957fd73ccd78dc4a9e49d21ea
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 15 13:33:33 2019 +0100

    efi/arm: Revert "Defer persistent reservations until after paging_init()"
    
    This reverts commit eff896288872d687d9662000ec9ae11b6d61766f, which
    deferred the processing of persistent memory reservations to a point
    where the memory may have already been allocated and overwritten,
    defeating the purpose.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190215123333.21209-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4c46ff6f2242..55b77c576c42 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -592,11 +592,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 
 		early_memunmap(tbl, sizeof(*tbl));
 	}
-	return 0;
-}
 
-int __init efi_apply_persistent_mem_reservations(void)
-{
 	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
 		unsigned long prsv = efi.mem_reserve;
 

commit 80424b02d42bb22f8ff8839cb93a84ade53b39c0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Nov 29 18:12:29 2018 +0100

    efi: Reduce the amount of memblock reservations for persistent allocations
    
    The current implementation of efi_mem_reserve_persistent() is rather
    naive, in the sense that for each invocation, it creates a separate
    linked list entry to describe the reservation. Since the linked list
    entries themselves need to persist across subsequent kexec reboots,
    every reservation created this way results in two memblock_reserve()
    calls at the next boot.
    
    On arm64 systems with 100s of CPUs, this may result in a excessive
    number of memblock reservations, and needless fragmentation.
    
    So instead, make use of the newly updated struct linux_efi_memreserve
    layout to put multiple reservations into a single linked list entry.
    This should get rid of the numerous tiny memblock reservations, and
    effectively cut the total number of reservations in half on arm64
    systems with many CPUs.
    
     [ mingo: build warning fix. ]
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-11-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 80b11521627a..4c46ff6f2242 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -997,8 +997,8 @@ static int __init efi_memreserve_map_root(void)
 int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 {
 	struct linux_efi_memreserve *rsv;
-	int rsvsize = EFI_MEMRESERVE_SIZE(1);
-	int rc;
+	unsigned long prsv;
+	int rc, index;
 
 	if (efi_memreserve_root == (void *)ULONG_MAX)
 		return -ENODEV;
@@ -1009,11 +1009,24 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 			return rc;
 	}
 
-	rsv = kmalloc(rsvsize, GFP_ATOMIC);
+	/* first try to find a slot in an existing linked list entry */
+	for (prsv = efi_memreserve_root->next; prsv; prsv = rsv->next) {
+		rsv = __va(prsv);
+		index = atomic_fetch_add_unless(&rsv->count, 1, rsv->size);
+		if (index < rsv->size) {
+			rsv->entry[index].base = addr;
+			rsv->entry[index].size = size;
+
+			return 0;
+		}
+	}
+
+	/* no slot found - allocate a new linked list entry */
+	rsv = (struct linux_efi_memreserve *)__get_free_page(GFP_ATOMIC);
 	if (!rsv)
 		return -ENOMEM;
 
-	rsv->size = 1;
+	rsv->size = EFI_MEMRESERVE_COUNT(PAGE_SIZE);
 	atomic_set(&rsv->count, 1);
 	rsv->entry[0].base = addr;
 	rsv->entry[0].size = size;

commit 5f0b0ecf043a5319e729c11a53bc8294df12dab3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Nov 29 18:12:28 2018 +0100

    efi: Permit multiple entries in persistent memreserve data structure
    
    In preparation of updating efi_mem_reserve_persistent() to cause less
    fragmentation when dealing with many persistent reservations, update
    the struct definition and the code that handles it currently so it
    can describe an arbitrary number of reservations using a single linked
    list entry. The actual optimization will be implemented in a subsequent
    patch.
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-10-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 415849bab233..80b11521627a 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -602,21 +602,33 @@ int __init efi_apply_persistent_mem_reservations(void)
 
 		while (prsv) {
 			struct linux_efi_memreserve *rsv;
-
-			/* reserve the entry itself */
-			memblock_reserve(prsv, sizeof(*rsv));
-
-			rsv = early_memremap(prsv, sizeof(*rsv));
-			if (rsv == NULL) {
+			u8 *p;
+			int i;
+
+			/*
+			 * Just map a full page: that is what we will get
+			 * anyway, and it permits us to map the entire entry
+			 * before knowing its size.
+			 */
+			p = early_memremap(ALIGN_DOWN(prsv, PAGE_SIZE),
+					   PAGE_SIZE);
+			if (p == NULL) {
 				pr_err("Could not map UEFI memreserve entry!\n");
 				return -ENOMEM;
 			}
 
-			if (rsv->size)
-				memblock_reserve(rsv->base, rsv->size);
+			rsv = (void *)(p + prsv % PAGE_SIZE);
+
+			/* reserve the entry itself */
+			memblock_reserve(prsv, EFI_MEMRESERVE_SIZE(rsv->size));
+
+			for (i = 0; i < atomic_read(&rsv->count); i++) {
+				memblock_reserve(rsv->entry[i].base,
+						 rsv->entry[i].size);
+			}
 
 			prsv = rsv->next;
-			early_memunmap(rsv, sizeof(*rsv));
+			early_memunmap(p, PAGE_SIZE);
 		}
 	}
 
@@ -985,6 +997,7 @@ static int __init efi_memreserve_map_root(void)
 int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 {
 	struct linux_efi_memreserve *rsv;
+	int rsvsize = EFI_MEMRESERVE_SIZE(1);
 	int rc;
 
 	if (efi_memreserve_root == (void *)ULONG_MAX)
@@ -996,12 +1009,14 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 			return rc;
 	}
 
-	rsv = kmalloc(sizeof(*rsv), GFP_ATOMIC);
+	rsv = kmalloc(rsvsize, GFP_ATOMIC);
 	if (!rsv)
 		return -ENOMEM;
 
-	rsv->base = addr;
-	rsv->size = size;
+	rsv->size = 1;
+	atomic_set(&rsv->count, 1);
+	rsv->entry[0].base = addr;
+	rsv->entry[0].size = size;
 
 	spin_lock(&efi_mem_reserve_persistent_lock);
 	rsv->next = efi_memreserve_root->next;

commit 976b489120cdab2b1b3a41ffa14661db43d58190
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Nov 23 22:51:32 2018 +0100

    efi: Prevent GICv3 WARN() by mapping the memreserve table before first use
    
    Mapping the MEMRESERVE EFI configuration table from an early initcall
    is too late: the GICv3 ITS code that creates persistent reservations
    for the boot CPU's LPI tables is invoked from init_IRQ(), which runs
    much earlier than the handling of the initcalls. This results in a
    WARN() splat because the LPI tables cannot be reserved persistently,
    which will result in silent memory corruption after a kexec reboot.
    
    So instead, invoke the initialization performed by the initcall from
    efi_mem_reserve_persistent() itself as well, but keep the initcall so
    that the init is guaranteed to have been called before SMP boot.
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 63eb322d89c8 ("efi: Permit calling efi_mem_reserve_persistent() ...")
    Link: http://lkml.kernel.org/r/20181123215132.7951-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index fad7c62cfc0e..415849bab233 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -969,13 +969,33 @@ bool efi_is_table_address(unsigned long phys_addr)
 static DEFINE_SPINLOCK(efi_mem_reserve_persistent_lock);
 static struct linux_efi_memreserve *efi_memreserve_root __ro_after_init;
 
-int efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
+static int __init efi_memreserve_map_root(void)
+{
+	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+		return -ENODEV;
+
+	efi_memreserve_root = memremap(efi.mem_reserve,
+				       sizeof(*efi_memreserve_root),
+				       MEMREMAP_WB);
+	if (WARN_ON_ONCE(!efi_memreserve_root))
+		return -ENOMEM;
+	return 0;
+}
+
+int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 {
 	struct linux_efi_memreserve *rsv;
+	int rc;
 
-	if (!efi_memreserve_root)
+	if (efi_memreserve_root == (void *)ULONG_MAX)
 		return -ENODEV;
 
+	if (!efi_memreserve_root) {
+		rc = efi_memreserve_map_root();
+		if (rc)
+			return rc;
+	}
+
 	rsv = kmalloc(sizeof(*rsv), GFP_ATOMIC);
 	if (!rsv)
 		return -ENOMEM;
@@ -993,14 +1013,10 @@ int efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 
 static int __init efi_memreserve_root_init(void)
 {
-	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
-		return -ENODEV;
-
-	efi_memreserve_root = memremap(efi.mem_reserve,
-				       sizeof(*efi_memreserve_root),
-				       MEMREMAP_WB);
-	if (!efi_memreserve_root)
-		return -ENOMEM;
+	if (efi_memreserve_root)
+		return 0;
+	if (efi_memreserve_map_root())
+		efi_memreserve_root = (void *)ULONG_MAX;
 	return 0;
 }
 early_initcall(efi_memreserve_root_init);

commit 63eb322d89c8505af9b4a3d703e85e42281ebaa0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Nov 14 09:55:44 2018 -0800

    efi: Permit calling efi_mem_reserve_persistent() from atomic context
    
    Currently, efi_mem_reserve_persistent() may not be called from atomic
    context, since both the kmalloc() call and the memremap() call may
    sleep.
    
    The kmalloc() call is easy enough to fix, but the memremap() call
    needs to be moved into an init hook since we cannot control the
    memory allocation behavior of memremap() at the call site.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181114175544.12860-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 72a4da76d274..fad7c62cfc0e 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -967,36 +967,43 @@ bool efi_is_table_address(unsigned long phys_addr)
 }
 
 static DEFINE_SPINLOCK(efi_mem_reserve_persistent_lock);
+static struct linux_efi_memreserve *efi_memreserve_root __ro_after_init;
 
 int efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 {
-	struct linux_efi_memreserve *rsv, *parent;
+	struct linux_efi_memreserve *rsv;
 
-	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+	if (!efi_memreserve_root)
 		return -ENODEV;
 
-	rsv = kmalloc(sizeof(*rsv), GFP_KERNEL);
+	rsv = kmalloc(sizeof(*rsv), GFP_ATOMIC);
 	if (!rsv)
 		return -ENOMEM;
 
-	parent = memremap(efi.mem_reserve, sizeof(*rsv), MEMREMAP_WB);
-	if (!parent) {
-		kfree(rsv);
-		return -ENOMEM;
-	}
-
 	rsv->base = addr;
 	rsv->size = size;
 
 	spin_lock(&efi_mem_reserve_persistent_lock);
-	rsv->next = parent->next;
-	parent->next = __pa(rsv);
+	rsv->next = efi_memreserve_root->next;
+	efi_memreserve_root->next = __pa(rsv);
 	spin_unlock(&efi_mem_reserve_persistent_lock);
 
-	memunmap(parent);
+	return 0;
+}
 
+static int __init efi_memreserve_root_init(void)
+{
+	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+		return -ENODEV;
+
+	efi_memreserve_root = memremap(efi.mem_reserve,
+				       sizeof(*efi_memreserve_root),
+				       MEMREMAP_WB);
+	if (!efi_memreserve_root)
+		return -ENOMEM;
 	return 0;
 }
+early_initcall(efi_memreserve_root_init);
 
 #ifdef CONFIG_KEXEC
 static int update_efi_random_seed(struct notifier_block *nb,

commit eff896288872d687d9662000ec9ae11b6d61766f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Nov 14 09:55:43 2018 -0800

    efi/arm: Defer persistent reservations until after paging_init()
    
    The new memory EFI reservation feature we introduced to allow memory
    reservations to persist across kexec may trigger an unbounded number
    of calls to memblock_reserve(). The memblock subsystem can deal with
    this fine, but not before memblock resizing is enabled, which we can
    only do after paging_init(), when the memory we reallocate the array
    into is actually mapped.
    
    So break out the memreserve table processing into a separate routine
    and call it after paging_init() on arm64. On ARM, because of limited
    reviewing bandwidth of the maintainer, we cannot currently fix this,
    so instead, disable the EFI persistent memreserve entirely on ARM so
    we can fix it later.
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181114175544.12860-5-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 249eb70691b0..72a4da76d274 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -592,7 +592,11 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 
 		early_memunmap(tbl, sizeof(*tbl));
 	}
+	return 0;
+}
 
+int __init efi_apply_persistent_mem_reservations(void)
+{
 	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
 		unsigned long prsv = efi.mem_reserve;
 

commit a23d3bb05ccbd815c79293d2207fedede0b3515d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Sep 21 09:32:46 2018 -0700

    efi: add API to reserve memory persistently across kexec reboot
    
    Add kernel plumbing to reserve memory regions persistently on a EFI
    system by adding entries to the MEMRESERVE linked list.
    
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 688132ac8a0a..249eb70691b0 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -962,6 +962,38 @@ bool efi_is_table_address(unsigned long phys_addr)
 	return false;
 }
 
+static DEFINE_SPINLOCK(efi_mem_reserve_persistent_lock);
+
+int efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
+{
+	struct linux_efi_memreserve *rsv, *parent;
+
+	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+		return -ENODEV;
+
+	rsv = kmalloc(sizeof(*rsv), GFP_KERNEL);
+	if (!rsv)
+		return -ENOMEM;
+
+	parent = memremap(efi.mem_reserve, sizeof(*rsv), MEMREMAP_WB);
+	if (!parent) {
+		kfree(rsv);
+		return -ENOMEM;
+	}
+
+	rsv->base = addr;
+	rsv->size = size;
+
+	spin_lock(&efi_mem_reserve_persistent_lock);
+	rsv->next = parent->next;
+	parent->next = __pa(rsv);
+	spin_unlock(&efi_mem_reserve_persistent_lock);
+
+	memunmap(parent);
+
+	return 0;
+}
+
 #ifdef CONFIG_KEXEC
 static int update_efi_random_seed(struct notifier_block *nb,
 				  unsigned long code, void *unused)

commit 71e0940d52e107748b270213a01d3b1546657d74
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Sep 21 09:32:44 2018 -0700

    efi: honour memory reservations passed via a linux specific config table
    
    In order to allow the OS to reserve memory persistently across a
    kexec, introduce a Linux-specific UEFI configuration table that
    points to the head of a linked list in memory, allowing each kernel
    to add list items describing memory regions that the next kernel
    should treat as reserved.
    
    This is useful, e.g., for GICv3 based ARM systems that cannot disable
    DMA access to the LPI tables, forcing them to reuse the same memory
    region again after a kexec reboot.
    
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 2a29dd9c986d..688132ac8a0a 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -52,7 +52,8 @@ struct efi __read_mostly efi = {
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.rng_seed		= EFI_INVALID_TABLE_ADDR,
-	.tpm_log		= EFI_INVALID_TABLE_ADDR
+	.tpm_log		= EFI_INVALID_TABLE_ADDR,
+	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -484,6 +485,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
 	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
+	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
 	{NULL_GUID, NULL, NULL},
 };
 
@@ -591,6 +593,29 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 		early_memunmap(tbl, sizeof(*tbl));
 	}
 
+	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
+		unsigned long prsv = efi.mem_reserve;
+
+		while (prsv) {
+			struct linux_efi_memreserve *rsv;
+
+			/* reserve the entry itself */
+			memblock_reserve(prsv, sizeof(*rsv));
+
+			rsv = early_memremap(prsv, sizeof(*rsv));
+			if (rsv == NULL) {
+				pr_err("Could not map UEFI memreserve entry!\n");
+				return -ENOMEM;
+			}
+
+			if (rsv->size)
+				memblock_reserve(rsv->base, rsv->size);
+
+			prsv = rsv->next;
+			early_memunmap(rsv, sizeof(*rsv));
+		}
+	}
+
 	return 0;
 }
 

commit 203b4fc903b644223a27ad3f25f3a0f3a3911d1d
Merge: 7edcf0d314f6 765d28f13629
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 16:29:35 2018 -0700

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 mm updates from Thomas Gleixner:
    
     - Make lazy TLB mode even lazier to avoid pointless switch_mm()
       operations, which reduces CPU load by 1-2% for memcache workloads
    
     - Small cleanups and improvements all over the place
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/mm: Remove redundant check for kmem_cache_create()
      arm/asm/tlb.h: Fix build error implicit func declaration
      x86/mm/tlb: Make clear_asid_other() static
      x86/mm/tlb: Skip atomic operations for 'init_mm' in switch_mm_irqs_off()
      x86/mm/tlb: Always use lazy TLB mode
      x86/mm/tlb: Only send page table free TLB flush to lazy TLB CPUs
      x86/mm/tlb: Make lazy TLB mode lazier
      x86/mm/tlb: Restructure switch_mm_irqs_off()
      x86/mm/tlb: Leave lazy TLB mode at page table free time
      mm: Allocate the mm_cpumask (mm->cpu_bitmap[]) dynamically based on nr_cpu_ids
      x86/mm: Add TLB purge to free pmd/pte page interfaces
      ioremap: Update pgtable free interfaces with addr
      x86/mm: Disable ioremap free page handling on x86-PAE

commit c1a2f7f0c06454387c2cd7b93ff1491c715a8c69
Author: Rik van Riel <riel@surriel.com>
Date:   Mon Jul 16 15:03:31 2018 -0400

    mm: Allocate the mm_cpumask (mm->cpu_bitmap[]) dynamically based on nr_cpu_ids
    
    The mm_struct always contains a cpumask bitmap, regardless of
    CONFIG_CPUMASK_OFFSTACK. That means the first step can be to
    simplify things, and simply have one bitmask at the end of the
    mm_struct for the mm_cpumask.
    
    This does necessitate moving everything else in mm_struct into
    an anonymous sub-structure, which can be randomized when struct
    randomization is enabled.
    
    The second step is to determine the correct size for the
    mm_struct slab object from the size of the mm_struct
    (excluding the CPU bitmap) and the size the cpumask.
    
    For init_mm we can simply allocate the maximum size this
    kernel is compiled for, since we only have one init_mm
    in the system, anyway.
    
    Pointer magic by Mike Galbraith, to evade -Wstringop-overflow
    getting confused by the dynamically sized array.
    
    Tested-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Rik van Riel <riel@surriel.com>
    Signed-off-by: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Rik van Riel <riel@surriel.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: kernel-team@fb.com
    Cc: luto@kernel.org
    Link: http://lkml.kernel.org/r/20180716190337.26133-2-riel@surriel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 232f4915223b..7f0b19410a95 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -82,6 +82,7 @@ struct mm_struct efi_mm = {
 	.mmap_sem		= __RWSEM_INITIALIZER(efi_mm.mmap_sem),
 	.page_table_lock	= __SPIN_LOCK_UNLOCKED(efi_mm.page_table_lock),
 	.mmlist			= LIST_HEAD_INIT(efi_mm.mmlist),
+	.cpu_bitmap		= { [BITS_TO_LONGS(NR_CPUS)] = 0},
 };
 
 static bool disable_runtime;

commit 7e1550b8f2081cccdfa9f1cf1e54cbc4d720af7f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 11 11:40:39 2018 +0200

    efi: Drop type and attribute checks in efi_mem_desc_lookup()
    
    The current implementation of efi_mem_desc_lookup() includes the
    following check on the memory descriptor it returns:
    
        if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
            md->type != EFI_BOOT_SERVICES_DATA &&
            md->type != EFI_RUNTIME_SERVICES_DATA) {
                continue;
        }
    
    This means that only EfiBootServicesData or EfiRuntimeServicesData
    regions are considered, or any other region type provided that it
    has the EFI_MEMORY_RUNTIME attribute set.
    
    Given what the name of the function implies, and the fact that any
    physical address can be described in the UEFI memory map only a single
    time, it does not make sense to impose this condition in the body of the
    loop, but instead, should be imposed by the caller depending on the value
    that is returned to it.
    
    Two such callers exist at the moment:
    
    - The BGRT code when running on x86, via efi_mem_reserve() and
      efi_arch_mem_reserve(). In this case, the region is already known to
      be EfiBootServicesData, and so the check is redundant.
    
    - The ESRT handling code which introduced this function, which calls it
      both directly from efi_esrt_init() and again via efi_mem_reserve() and
      efi_arch_mem_reserve() [on x86].
    
    So let's move this check into the callers instead. This preserves the
    current behavior both for BGRT and ESRT handling, and allows the lookup
    routine to be reused by other [upcoming] users that don't have this
    limitation.
    
    In the ESRT case, keep the entire condition, so that platforms that
    deviate from the UEFI spec and use something other than
    EfiBootServicesData for the ESRT table will keep working as before.
    
    For x86's efi_arch_mem_reserve() implementation, limit the type to
    EfiBootServicesData, since it is the only type the reservation code
    expects to operate on in the first place.
    
    While we're at it, drop the __init annotation so that drivers can use it
    as well.
    
    Tested-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-8-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 1379a375dfa8..d8a33a781a57 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -402,7 +402,7 @@ subsys_initcall(efisubsys_init);
  * and if so, populate the supplied memory descriptor with the appropriate
  * data.
  */
-int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
+int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 {
 	efi_memory_desc_t *md;
 
@@ -420,12 +420,6 @@ int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 		u64 size;
 		u64 end;
 
-		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
-		    md->type != EFI_BOOT_SERVICES_DATA &&
-		    md->type != EFI_RUNTIME_SERVICES_DATA) {
-			continue;
-		}
-
 		size = md->num_pages << EFI_PAGE_SHIFT;
 		end = md->phys_addr + size;
 		if (phys_addr >= md->phys_addr && phys_addr < end) {

commit 3eb420e70d879ce0e6bf752accf5cdedb0a59de8
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Jul 11 11:40:35 2018 +0200

    efi: Use a work queue to invoke EFI Runtime Services
    
    Presently, when a user process requests the kernel to execute any
    UEFI runtime service, the kernel temporarily switches to a separate
    set of page tables that describe the virtual mapping of the UEFI
    runtime services regions in memory. Since UEFI runtime services are
    typically invoked with interrupts enabled, any code that may be called
    during this time, will have an incorrect view of the process's address
    space. Although it is unusual for code running in interrupt context to
    make assumptions about the process context it runs in, there are cases
    (such as the perf subsystem taking samples) where this causes problems.
    
    So let's set up a work queue for calling UEFI runtime services, so that
    the actual calls are made when the work queue items are dispatched by a
    work queue worker running in a separate kernel thread. Such threads are
    not expected to have userland mappings in the first place, and so the
    additional mappings created for the UEFI runtime services can never
    clash with any.
    
    The ResetSystem() runtime service is not covered by the work queue
    handling, since it is not expected to return, and may be called at a
    time when the kernel is torn down to the point where we cannot expect
    work queues to still be operational.
    
    The non-blocking variants of SetVariable() and QueryVariableInfo()
    are also excluded: these are intended to be used from atomic context,
    which obviously rules out waiting for a completion to be signalled by
    another thread. Note that these variants are currently only used for
    UEFI runtime services calls that occur very early in the boot, and
    for ones that occur in critical conditions, e.g., to flush kernel logs
    to UEFI variables via efi-pstore.
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    [ardb: exclude ResetSystem() from the workqueue treatment
           merge from 2 separate patches and rewrite commit log]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 232f4915223b..1379a375dfa8 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -84,6 +84,8 @@ struct mm_struct efi_mm = {
 	.mmlist			= LIST_HEAD_INIT(efi_mm.mmlist),
 };
 
+struct workqueue_struct *efi_rts_wq;
+
 static bool disable_runtime;
 static int __init setup_noefi(char *arg)
 {
@@ -337,6 +339,18 @@ static int __init efisubsys_init(void)
 	if (!efi_enabled(EFI_BOOT))
 		return 0;
 
+	/*
+	 * Since we process only one efi_runtime_service() at a time, an
+	 * ordered workqueue (which creates only one execution context)
+	 * should suffice all our needs.
+	 */
+	efi_rts_wq = alloc_ordered_workqueue("efi_rts_wq", 0);
+	if (!efi_rts_wq) {
+		pr_err("Creating efi_rts_wq failed, EFI runtime services disabled.\n");
+		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+		return 0;
+	}
+
 	/* We register the efi directory at /sys/firmware/efi */
 	efi_kobj = kobject_create_and_add("efi", firmware_kobj);
 	if (!efi_kobj) {

commit 7e904a91bf6049071ef9d605a52f863ae774081d
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Mon Mar 12 08:44:56 2018 +0000

    efi: Use efi_mm in x86 as well as ARM
    
    Presently, only ARM uses mm_struct to manage EFI page tables and EFI
    runtime region mappings. As this is the preferred approach, let's make
    this data structure common across architectures. Specially, for x86,
    using this data structure improves code maintainability and readability.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    [ardb: don't #include the world to get a declaration of struct mm_struct]
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Lee, Chun-Yi <jlee@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180312084500.10764-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 92b9e79e5da9..232f4915223b 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -75,6 +75,15 @@ static unsigned long *efi_tables[] = {
 	&efi.mem_attr_table,
 };
 
+struct mm_struct efi_mm = {
+	.mm_rb			= RB_ROOT,
+	.mm_users		= ATOMIC_INIT(2),
+	.mm_count		= ATOMIC_INIT(1),
+	.mmap_sem		= __RWSEM_INITIALIZER(efi_mm.mmap_sem),
+	.page_table_lock	= __SPIN_LOCK_UNLOCKED(efi_mm.page_table_lock),
+	.mmlist			= LIST_HEAD_INIT(efi_mm.mmlist),
+};
+
 static bool disable_runtime;
 static int __init setup_noefi(char *arg)
 {

commit 5b4e4c3aa220d07d166d3f21f158bc9c69e3c044
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Mar 8 08:00:18 2018 +0000

    efi: Reorder pr_notice() with add_device_randomness() call
    
    Currently, when we receive a random seed from the EFI stub, we call
    add_device_randomness() to incorporate it into the entropy pool, and
    issue a pr_notice() saying we are about to do that, e.g.,
    
      [    0.000000] efi:  RNG=0x87ff92cf18
      [    0.000000] random: fast init done
      [    0.000000] efi: seeding entropy pool
    
    Let's reorder those calls to make the output look less confusing:
    
      [    0.000000] efi: seeding entropy pool
      [    0.000000] efi:  RNG=0x87ff92cf18
      [    0.000000] random: fast init done
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180308080020.22828-11-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cd42f66a7c85..92b9e79e5da9 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -542,9 +542,9 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 			seed = early_memremap(efi.rng_seed,
 					      sizeof(*seed) + size);
 			if (seed != NULL) {
+				pr_notice("seeding entropy pool\n");
 				add_device_randomness(seed->bits, seed->size);
 				early_memunmap(seed, sizeof(*seed) + size);
-				pr_notice("seeding entropy pool\n");
 			} else {
 				pr_err("Could not map UEFI random seed!\n");
 			}

commit ae0cb7be35fe6c7e8bcc816ec4185d0a37748cc1
Merge: 2a7149031457 ebceb1c87c0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 13:12:31 2018 -0800

    Merge branch 'next-tpm' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull tpm updates from James Morris:
    
     - reduce polling delays in tpm_tis
    
     - support retrieving TPM 2.0 Event Log through EFI before
       ExitBootServices
    
     - replace tpm-rng.c with a hwrng device managed by the driver for each
       TPM device
    
     - TPM resource manager synthesizes TPM_RC_COMMAND_CODE response instead
       of returning -EINVAL for unknown TPM commands. This makes user space
       more sound.
    
     - CLKRUN fixes:
    
        * Keep #CLKRUN disable through the entier TPM command/response flow
    
        * Check whether #CLKRUN is enabled before disabling and enabling it
          again because enabling it breaks PS/2 devices on a system where it
          is disabled
    
    * 'next-tpm' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      tpm: remove unused variables
      tpm: remove unused data fields from I2C and OF device ID tables
      tpm: only attempt to disable the LPC CLKRUN if is already enabled
      tpm: follow coding style for variable declaration in tpm_tis_core_init()
      tpm: delete the TPM_TIS_CLK_ENABLE flag
      tpm: Update MAINTAINERS for Jason Gunthorpe
      tpm: Keep CLKRUN enabled throughout the duration of transmit_cmd()
      tpm_tis: Move ilb_base_addr to tpm_tis_data
      tpm2-cmd: allow more attempts for selftest execution
      tpm: return a TPM_RC_COMMAND_CODE response if command is not implemented
      tpm: Move Linux RNG connection to hwrng
      tpm: use struct tpm_chip for tpm_chip_find_get()
      tpm: parse TPM event logs based on EFI table
      efi: call get_event_log before ExitBootServices
      tpm: add event log format version
      tpm: rename event log provider files
      tpm: move tpm_eventlog.h outside of drivers folder
      tpm: use tpm_msleep() value as max delay
      tpm: reduce tpm polling delay in tpm_tis_core
      tpm: move wait_for_tpm_stat() to respective driver files

commit 33b6d03469b2206fb51ecc37f40411a857ad8fff
Author: Thiebaud Weksteen <tweek@google.com>
Date:   Wed Sep 20 10:13:39 2017 +0200

    efi: call get_event_log before ExitBootServices
    
    With TPM 2.0 specification, the event logs may only be accessible by
    calling an EFI Boot Service. Modify the EFI stub to copy the log area to
    a new Linux-specific EFI configuration table so it remains accessible
    once booted.
    
    When calling this service, it is possible to specify the expected format
    of the logs: TPM 1.2 (SHA1) or TPM 2.0 ("Crypto Agile"). For now, only the
    first format is retrieved.
    
    Signed-off-by: Thiebaud Weksteen <tweek@google.com>
    Reviewed-by: Javier Martinez Canillas <javierm@redhat.com>
    Tested-by: Javier Martinez Canillas <javierm@redhat.com>
    Tested-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 557a47829d03..cfa6fe786ab6 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -52,6 +52,7 @@ struct efi __read_mostly efi = {
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.rng_seed		= EFI_INVALID_TABLE_ADDR,
+	.tpm_log		= EFI_INVALID_TABLE_ADDR
 };
 EXPORT_SYMBOL(efi);
 
@@ -464,6 +465,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
+	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 	{NULL_GUID, NULL, NULL},
 };
 
@@ -552,6 +554,8 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 	if (efi_enabled(EFI_MEMMAP))
 		efi_memattr_init();
 
+	efi_tpm_eventlog_init();
+
 	/* Parse the EFI Properties table if it exists */
 	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
 		efi_properties_table_t *tbl;

commit 50342b2e498777df237a40a23eebc02f0935e636
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Tue Jan 2 18:10:40 2018 +0000

    efi: Use PTR_ERR_OR_ZERO()
    
    Fix ptr_ret.cocci warnings:
    
      drivers/firmware/efi/efi.c:610:8-14: WARNING: PTR_ERR_OR_ZERO can be used
    
    Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tyler Baicar <tbaicar@codeaurora.org>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180102181042.19074-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 557a47829d03..8ce70c2e73d5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -608,7 +608,7 @@ static int __init efi_load_efivars(void)
 		return 0;
 
 	pdev = platform_device_register_simple("efivars", 0, NULL, 0);
-	return IS_ERR(pdev) ? PTR_ERR(pdev) : 0;
+	return PTR_ERR_OR_ZERO(pdev);
 }
 device_initcall(efi_load_efivars);
 #endif

commit 0b02e448a2ebb46eb9be4f1bdfc87112bd420cbf
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Dec 6 09:50:10 2017 +0000

    efi: Add comment to avoid future expanding of sysfs systab
    
    /sys/firmware/efi/systab shows several different values, it breaks sysfs
    one file one value design.  But since there are already userspace tools
    depend on it eg. kexec-tools so add code comment to alert future expanding
    of this file.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20171206095010.24170-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c3eefa126e3b..557a47829d03 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -109,6 +109,8 @@ struct kobject *efi_kobj;
 /*
  * Let's not leave out systab information that snuck into
  * the efivars driver
+ * Note, do not add more fields in systab sysfs file as it breaks sysfs
+ * one value per file rule!
  */
 static ssize_t systab_show(struct kobject *kobj,
 			   struct kobj_attribute *attr, char *buf)

commit af97a77bc01ce49a466f9d4c0125479e2e2230b6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Dec 6 09:50:08 2017 +0000

    efi: Move some sysfs files to be read-only by root
    
    Thanks to the scripts/leaking_addresses.pl script, it was found that
    some EFI values should not be readable by non-root users.
    
    So make them root-only, and to do that, add a __ATTR_RO_MODE() macro to
    make this easier, and use it in other places at the same time.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Tested-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Cc: stable <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20171206095010.24170-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f70febf680c3..c3eefa126e3b 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -143,8 +143,7 @@ static ssize_t systab_show(struct kobject *kobj,
 	return str - buf;
 }
 
-static struct kobj_attribute efi_attr_systab =
-			__ATTR(systab, 0400, systab_show, NULL);
+static struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);
 
 #define EFI_FIELD(var) efi.var
 

commit 23f0571c9fd184504f7a2f27011750e0ad99bb73
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri Aug 25 16:50:18 2017 +0100

    efi: Move efi_mem_type() to common code
    
    This follows efi_mem_attributes(), as it's similarly generic. Drop
    __weak from that one though (and don't introduce it for efi_mem_type()
    in the first place) to make clear that other overrides to these
    functions are really not intended.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Jan Beulich <JBeulich@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170825155019.6740-5-ard.biesheuvel@linaro.org
    [ Resolved conflict with: f99afd08a45f: (efi: Update efi_mem_type() to return an error rather than 0) ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c8a27a2c30c1..f70febf680c3 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -810,6 +810,11 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 	return buf;
 }
 
+/*
+ * IA64 has a funky EFI memory map that doesn't work the same way as
+ * other architectures.
+ */
+#ifndef CONFIG_IA64
 /*
  * efi_mem_attributes - lookup memmap attributes for physical address
  * @phys_addr: the physical address to lookup
@@ -817,13 +822,8 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
  * Search in the EFI memory map for the region covering
  * @phys_addr. Returns the EFI memory attributes if the region
  * was found in the memory map, 0 otherwise.
- *
- * Despite being marked __weak, most architectures should *not*
- * override this function. It is __weak solely for the benefit
- * of ia64 which has a funky EFI memory map that doesn't work
- * the same way as other architectures.
  */
-u64 __weak efi_mem_attributes(unsigned long phys_addr)
+u64 efi_mem_attributes(unsigned long phys_addr)
 {
 	efi_memory_desc_t *md;
 
@@ -839,6 +839,31 @@ u64 __weak efi_mem_attributes(unsigned long phys_addr)
 	return 0;
 }
 
+/*
+ * efi_mem_type - lookup memmap type for physical address
+ * @phys_addr: the physical address to lookup
+ *
+ * Search in the EFI memory map for the region covering @phys_addr.
+ * Returns the EFI memory type if the region was found in the memory
+ * map, EFI_RESERVED_TYPE (zero) otherwise.
+ */
+int efi_mem_type(unsigned long phys_addr)
+{
+	const efi_memory_desc_t *md;
+
+	if (!efi_enabled(EFI_MEMMAP))
+		return -ENOTSUPP;
+
+	for_each_efi_memory_desc(md) {
+		if ((md->phys_addr <= phys_addr) &&
+		    (phys_addr < (md->phys_addr +
+				  (md->num_pages << EFI_PAGE_SHIFT))))
+			return md->type;
+	}
+	return -EINVAL;
+}
+#endif
+
 int efi_status_to_err(efi_status_t status)
 {
 	int err;

commit c2ceb5fd4e921506e86208b82fca716a2c3aad59
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 25 16:50:16 2017 +0100

    efi/random: Increase size of firmware supplied randomness
    
    The crng code requires at least 64 bytes (2 * CHACHA20_BLOCK_SIZE)
    to complete the fast boot-time init, so provide that many bytes
    when invoking UEFI protocols to seed the entropy pool. Also, add
    a notice so we can tell from the boot log when the seeding actually
    took place.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170825155019.6740-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index a32e1460ade8..c8a27a2c30c1 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -541,6 +541,7 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 			if (seed != NULL) {
 				add_device_randomness(seed->bits, seed->size);
 				early_memunmap(seed, sizeof(*seed) + size);
+				pr_notice("seeding entropy pool\n");
 			} else {
 				pr_err("Could not map UEFI random seed!\n");
 			}
@@ -900,7 +901,7 @@ static int update_efi_random_seed(struct notifier_block *nb,
 
 	seed = memremap(efi.rng_seed, sizeof(*seed), MEMREMAP_WB);
 	if (seed != NULL) {
-		size = min(seed->size, 32U);
+		size = min(seed->size, EFI_RANDOM_SEED_SIZE);
 		memunmap(seed);
 	} else {
 		pr_err("Could not map UEFI random seed!\n");

commit 3cb9bc85029f2ceb7a5babadcab445c7cb861da8
Merge: f1a5b5357000 413d63d71b22
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Aug 26 09:20:01 2017 +0200

    Merge branch 'x86/mm' into efi/core, to pick up dependencies
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3ad6bd7c0a1c49a78d00001cfda3d474c23bc354
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 20:49:46 2017 +0100

    firmware/efi: Constify attribute_group structures
    
    attribute_group are not supposed to change at runtime. All functions
    working with attribute_group provided by <linux/sysfs.h> work with
    const attribute_group. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170818194947.19347-14-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 045d6d311bde..6519be44387c 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -179,7 +179,7 @@ static umode_t efi_attr_is_visible(struct kobject *kobj,
 	return attr->mode;
 }
 
-static struct attribute_group efi_subsys_attr_group = {
+static const struct attribute_group efi_subsys_attr_group = {
 	.attrs = efi_subsys_attrs,
 	.is_visible = efi_attr_is_visible,
 };

commit a19d66c56af1c52b8b463bf94d21116ae8c1aa5a
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Mon Jul 17 16:10:13 2017 -0500

    efi: Add an EFI table address match function
    
    Add a function that will determine if a supplied physical address matches
    the address of an EFI table.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brijesh Singh <brijesh.singh@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Toshimitsu Kani <toshi.kani@hpe.com>
    Cc: kasan-dev@googlegroups.com
    Cc: kvm@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Cc: linux-mm@kvack.org
    Link: http://lkml.kernel.org/r/e1e06441d80f44776df391e0e4cb485b345b7518.1500319216.git.thomas.lendacky@amd.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 045d6d311bde..69d4d130e055 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -55,6 +55,25 @@ struct efi __read_mostly efi = {
 };
 EXPORT_SYMBOL(efi);
 
+static unsigned long *efi_tables[] = {
+	&efi.mps,
+	&efi.acpi,
+	&efi.acpi20,
+	&efi.smbios,
+	&efi.smbios3,
+	&efi.sal_systab,
+	&efi.boot_info,
+	&efi.hcdp,
+	&efi.uga,
+	&efi.uv_systab,
+	&efi.fw_vendor,
+	&efi.runtime,
+	&efi.config_table,
+	&efi.esrt,
+	&efi.properties_table,
+	&efi.mem_attr_table,
+};
+
 static bool disable_runtime;
 static int __init setup_noefi(char *arg)
 {
@@ -855,6 +874,20 @@ int efi_status_to_err(efi_status_t status)
 	return err;
 }
 
+bool efi_is_table_address(unsigned long phys_addr)
+{
+	unsigned int i;
+
+	if (phys_addr == EFI_INVALID_TABLE_ADDR)
+		return false;
+
+	for (i = 0; i < ARRAY_SIZE(efi_tables); i++)
+		if (*(efi_tables[i]) == phys_addr)
+			return true;
+
+	return false;
+}
+
 #ifdef CONFIG_KEXEC
 static int update_efi_random_seed(struct notifier_block *nb,
 				  unsigned long code, void *unused)

commit 457ea3f7e97881f937136ce0ba1f29f82b9abdb0
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Thu Jun 22 12:51:36 2017 +0200

    efi: Process the MEMATTR table only if EFI_MEMMAP is enabled
    
    Otherwise e.g. Xen dom0 on x86_64 EFI platforms crashes.
    
    In theory we can check EFI_PARAVIRT too, however,
    EFI_MEMMAP looks more targeted and covers more cases.
    
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: andrew.cooper3@citrix.com
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: linux-efi@vger.kernel.org
    Cc: matt@codeblueprint.co.uk
    Cc: stable@vger.kernel.org
    Cc: xen-devel@lists.xenproject.org
    Link: http://lkml.kernel.org/r/1498128697-12943-2-git-send-email-daniel.kiper@oracle.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index b372aad3b449..045d6d311bde 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -528,7 +528,8 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 		}
 	}
 
-	efi_memattr_init();
+	if (efi_enabled(EFI_MEMMAP))
+		efi_memattr_init();
 
 	/* Parse the EFI Properties table if it exists */
 	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {

commit 822f5845f710e57d7e2df1fd1ee00d6e19d334fe
Author: Daniel Drake <drake@endlessm.com>
Date:   Tue Feb 7 13:08:23 2017 -0600

    efi/esrt: Cleanup bad memory map log messages
    
    The Intel Compute Stick STCK1A8LFC and Weibu F3C platforms both
    log 2 error messages during boot:
    
       efi: requested map not found.
       esrt: ESRT header is not in the memory map.
    
    Searching the web, this seems to affect many other platforms too.
    Since these messages are logged as errors, they appear on-screen during
    the boot process even when using the "quiet" boot parameter used by
    distros.
    
    Demote the ESRT error to a warning so that it does not appear on-screen,
    and delete the error logging from efi_mem_desc_lookup; both callsites
    of that function log more specific messages upon failure.
    
    Out of curiosity I looked closer at the Weibu F3C. There is no entry in
    the UEFI-provided memory map which corresponds to the ESRT pointer, but
    hacking the code to map it anyway, the ESRT does appear to be valid with
    2 entries.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index e7d404059b73..b372aad3b449 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -389,7 +389,6 @@ int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 			return 0;
 		}
 	}
-	pr_err_once("requested map not found.\n");
 	return -ENOENT;
 }
 

commit 3a6b6c6fb23667fa383053bd5259aabc96468571
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Jan 31 13:21:35 2017 +0000

    efi: Make EFI_MEMORY_ATTRIBUTES_TABLE initialization common across all architectures
    
    Since EFI_PROPERTIES_TABLE and EFI_MEMORY_ATTRIBUTES_TABLE deal with
    updating memory region attributes, it makes sense to call
    EFI_MEMORY_ATTRIBUTES_TABLE initialization function from the same place
    as EFI_PROPERTIES_TABLE. This also moves the EFI_MEMORY_ATTRIBUTES_TABLE
    initialization code to a more generic efi initialization path rather
    than ARM specific efi initialization. This is important because
    EFI_MEMORY_ATTRIBUTES_TABLE will be supported by x86 as well.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-4-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 92914801e388..e7d404059b73 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -529,6 +529,8 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 		}
 	}
 
+	efi_memattr_init();
+
 	/* Parse the EFI Properties table if it exists */
 	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
 		efi_properties_table_t *tbl;

commit 636259880a7e7d3446a707dddebc799da94bdd0b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Nov 12 21:32:31 2016 +0000

    efi: Add support for seeding the RNG from a UEFI config table
    
    Specify a Linux specific UEFI configuration table that carries some
    random bits, and use the contents during early boot to seed the kernel's
    random number generator. This allows much strong random numbers to be
    generated early on.
    
    The entropy is fed to the kernel using add_device_randomness(), which is
    documented as being appropriate for being called very early.
    
    Since UEFI configuration tables may also be consumed by kexec'd kernels,
    register a reboot notifier that updates the seed in the table.
    
    Note that the config table could be generated by the EFI stub or by any
    other UEFI driver or application (e.g., GRUB), but the random seed table
    GUID and the associated functionality should be considered an internal
    kernel interface (unless it is promoted to ABI later on)
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-4-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index a4944e22f294..92914801e388 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -23,7 +23,10 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/io.h>
+#include <linux/kexec.h>
 #include <linux/platform_device.h>
+#include <linux/random.h>
+#include <linux/reboot.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/ucs2_string.h>
@@ -48,6 +51,7 @@ struct efi __read_mostly efi = {
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
+	.rng_seed		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -440,6 +444,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
+	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
 	{NULL_GUID, NULL, NULL},
 };
 
@@ -501,6 +506,29 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 	pr_cont("\n");
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
 
+	if (efi.rng_seed != EFI_INVALID_TABLE_ADDR) {
+		struct linux_efi_random_seed *seed;
+		u32 size = 0;
+
+		seed = early_memremap(efi.rng_seed, sizeof(*seed));
+		if (seed != NULL) {
+			size = seed->size;
+			early_memunmap(seed, sizeof(*seed));
+		} else {
+			pr_err("Could not map UEFI random seed!\n");
+		}
+		if (size > 0) {
+			seed = early_memremap(efi.rng_seed,
+					      sizeof(*seed) + size);
+			if (seed != NULL) {
+				add_device_randomness(seed->bits, seed->size);
+				early_memunmap(seed, sizeof(*seed) + size);
+			} else {
+				pr_err("Could not map UEFI random seed!\n");
+			}
+		}
+	}
+
 	/* Parse the EFI Properties table if it exists */
 	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
 		efi_properties_table_t *tbl;
@@ -824,3 +852,47 @@ int efi_status_to_err(efi_status_t status)
 
 	return err;
 }
+
+#ifdef CONFIG_KEXEC
+static int update_efi_random_seed(struct notifier_block *nb,
+				  unsigned long code, void *unused)
+{
+	struct linux_efi_random_seed *seed;
+	u32 size = 0;
+
+	if (!kexec_in_progress)
+		return NOTIFY_DONE;
+
+	seed = memremap(efi.rng_seed, sizeof(*seed), MEMREMAP_WB);
+	if (seed != NULL) {
+		size = min(seed->size, 32U);
+		memunmap(seed);
+	} else {
+		pr_err("Could not map UEFI random seed!\n");
+	}
+	if (size > 0) {
+		seed = memremap(efi.rng_seed, sizeof(*seed) + size,
+				MEMREMAP_WB);
+		if (seed != NULL) {
+			seed->size = size;
+			get_random_bytes(seed->bits, seed->size);
+			memunmap(seed);
+		} else {
+			pr_err("Could not map UEFI random seed!\n");
+		}
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block efi_random_seed_nb = {
+	.notifier_call = update_efi_random_seed,
+};
+
+static int register_update_efi_random_seed(void)
+{
+	if (efi.rng_seed == EFI_INVALID_TABLE_ADDR)
+		return 0;
+	return register_reboot_notifier(&efi_random_seed_nb);
+}
+late_initcall(register_update_efi_random_seed);
+#endif

commit a75dcb5848359f488c32c0aef8711d9bd37a77b8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 18 15:33:18 2016 +0100

    efi/efivar_ssdt_load: Don't return success on allocation failure
    
    We should return -ENOMEM here, instead of success.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 475fb4e8b2f4 ("efi / ACPI: load SSTDs from EFI variables")
    Link: http://lkml.kernel.org/r/20161018143318.15673-9-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 1ac199cd75e7..a4944e22f294 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -259,8 +259,10 @@ static __init int efivar_ssdt_load(void)
 		}
 
 		data = kmalloc(size, GFP_KERNEL);
-		if (!data)
+		if (!data) {
+			ret = -ENOMEM;
 			goto free_entry;
+		}
 
 		ret = efivar_entry_get(entry, NULL, &size, data);
 		if (ret) {

commit 5465fe0fc3316f7cdda66732a7986f4ebe76d949
Merge: cbf2f8a99a23 0a637ee61247
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Sep 13 20:21:55 2016 +0200

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into efi/core
    
    Pull EFI updates from Matt Fleming:
    
    "* Refactor the EFI memory map code into architecture neutral files
       and allow drivers to permanently reserve EFI boot services regions
       on x86, as well as ARM/arm64 - Matt Fleming
    
     * Add ARM support for the EFI esrt driver - Ard Biesheuvel
    
     * Make the EFI runtime services and efivar API interruptible by
       swapping spinlocks for semaphores - Sylvain Chouleur
    
     * Provide the EFI identity mapping for kexec which allows kexec to
       work on SGI/UV platforms with requiring the "noefi" kernel command
       line parameter - Alex Thorlton
    
     * Add debugfs node to dump EFI page tables on arm64 - Ard Biesheuvel
    
     * Merge the EFI test driver being carried out of tree until now in
       the FWTS project - Ivan Hu
    
     * Expand the list of flags for classifying EFI regions as "RAM" on
       arm64 so we align with the UEFI spec - Ard Biesheuvel
    
     * Optimise out the EFI mixed mode if it's unsupported (CONFIG_X86_32)
       or disabled (CONFIG_EFI_MIXED=n) and switch the early EFI boot
       services function table for direct calls, alleviating us from
       having to maintain the custom function table - Lukas Wunner
    
     * Miscellaneous cleanups and fixes"
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit dce48e351c0d42014e5fb16ac3eb099e11b7e716
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Jul 15 21:36:31 2016 +0200

    efi: Replace runtime services spinlock with semaphore
    
    The purpose of the efi_runtime_lock is to prevent concurrent calls into
    the firmware. There is no need to use spinlocks here, as long as we ensure
    that runtime service invocations from an atomic context (i.e., EFI pstore)
    cannot block.
    
    So use a semaphore instead, and use down_trylock() in the nonblocking case.
    We don't use a mutex here because the mutex_trylock() function must not
    be called from interrupt context, whereas the down_trylock() can.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sylvain Chouleur <sylvain.chouleur@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index dfe07316cae5..97d98e82f0f4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -810,6 +810,9 @@ int efi_status_to_err(efi_status_t status)
 	case EFI_NOT_FOUND:
 		err = -ENOENT;
 		break;
+	case EFI_ABORTED:
+		err = -EINTR;
+		break;
 	default:
 		err = -EINVAL;
 	}

commit 816e76129ed5fadd28e526c43397c79775194b5c
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Feb 29 21:22:52 2016 +0000

    efi: Allow drivers to reserve boot services forever
    
    Today, it is not possible for drivers to reserve EFI boot services for
    access after efi_free_boot_services() has been called on x86. For
    ARM/arm64 it can be done simply by calling memblock_reserve().
    
    Having this ability for all three architectures is desirable for a
    couple of reasons,
    
      1) It saves drivers copying data out of those regions
      2) kexec reboot can now make use of things like ESRT
    
    Instead of using the standard memblock_reserve() which is insufficient
    to reserve the region on x86 (see efi_reserve_boot_services()), a new
    API is introduced in this patch; efi_mem_reserve().
    
    efi.memmap now always represents which EFI memory regions are
    available. On x86 the EFI boot services regions that have not been
    reserved via efi_mem_reserve() will be removed from efi.memmap during
    efi_free_boot_services().
    
    This has implications for kexec, since it is not possible for a newly
    kexec'd kernel to access the same boot services regions that the
    initial boot kernel had access to unless they are reserved by every
    kexec kernel in the chain.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index d4886fd50c16..dfe07316cae5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/ucs2_string.h>
+#include <linux/memblock.h>
 
 #include <asm/early_ioremap.h>
 
@@ -396,6 +397,35 @@ u64 __init efi_mem_desc_end(efi_memory_desc_t *md)
 	return end;
 }
 
+void __init __weak efi_arch_mem_reserve(phys_addr_t addr, u64 size) {}
+
+/**
+ * efi_mem_reserve - Reserve an EFI memory region
+ * @addr: Physical address to reserve
+ * @size: Size of reservation
+ *
+ * Mark a region as reserved from general kernel allocation and
+ * prevent it being released by efi_free_boot_services().
+ *
+ * This function should be called drivers once they've parsed EFI
+ * configuration tables to figure out where their data lives, e.g.
+ * efi_esrt_init().
+ */
+void __init efi_mem_reserve(phys_addr_t addr, u64 size)
+{
+	if (!memblock_is_region_reserved(addr, size))
+		memblock_reserve(addr, size);
+
+	/*
+	 * Some architectures (x86) reserve all boot services ranges
+	 * until efi_free_boot_services() because of buggy firmware
+	 * implementations. This means the above memblock_reserve() is
+	 * superfluous on x86 and instead what it needs to do is
+	 * ensure the @start, @size is not freed.
+	 */
+	efi_arch_mem_reserve(addr, size);
+}
+
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},

commit 60863c0d1a96b740048cc7d94a2d00d6f89ba3d8
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Feb 29 20:30:39 2016 +0000

    efi: Split out EFI memory map functions into new file
    
    Also move the functions from the EFI fake mem driver since future
    patches will require access to the memmap insertion code even if
    CONFIG_EFI_FAKE_MEM isn't enabled.
    
    This will be useful when we need to build custom EFI memory maps to
    allow drivers to mark regions as reserved.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 8a5e0db72b8f..d4886fd50c16 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -516,135 +516,6 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	return ret;
 }
 
-/**
- * __efi_memmap_init - Common code for mapping the EFI memory map
- * @data: EFI memory map data
- * @late: Use early or late mapping function?
- *
- * This function takes care of figuring out which function to use to
- * map the EFI memory map in efi.memmap based on how far into the boot
- * we are.
- *
- * During bootup @late should be %false since we only have access to
- * the early_memremap*() functions as the vmalloc space isn't setup.
- * Once the kernel is fully booted we can fallback to the more robust
- * memremap*() API.
- *
- * Returns zero on success, a negative error code on failure.
- */
-static int __init
-__efi_memmap_init(struct efi_memory_map_data *data, bool late)
-{
-	struct efi_memory_map map;
-	phys_addr_t phys_map;
-
-	if (efi_enabled(EFI_PARAVIRT))
-		return 0;
-
-	phys_map = data->phys_map;
-
-	if (late)
-		map.map = memremap(phys_map, data->size, MEMREMAP_WB);
-	else
-		map.map = early_memremap(phys_map, data->size);
-
-	if (!map.map) {
-		pr_err("Could not map the memory map!\n");
-		return -ENOMEM;
-	}
-
-	map.phys_map = data->phys_map;
-	map.nr_map = data->size / data->desc_size;
-	map.map_end = map.map + data->size;
-
-	map.desc_version = data->desc_version;
-	map.desc_size = data->desc_size;
-	map.late = late;
-
-	set_bit(EFI_MEMMAP, &efi.flags);
-
-	efi.memmap = map;
-
-	return 0;
-}
-
-/**
- * efi_memmap_init_early - Map the EFI memory map data structure
- * @data: EFI memory map data
- *
- * Use early_memremap() to map the passed in EFI memory map and assign
- * it to efi.memmap.
- */
-int __init efi_memmap_init_early(struct efi_memory_map_data *data)
-{
-	/* Cannot go backwards */
-	WARN_ON(efi.memmap.late);
-
-	return __efi_memmap_init(data, false);
-}
-
-void __init efi_memmap_unmap(void)
-{
-	if (!efi.memmap.late) {
-		unsigned long size;
-
-		size = efi.memmap.desc_size * efi.memmap.nr_map;
-		early_memunmap(efi.memmap.map, size);
-	} else {
-		memunmap(efi.memmap.map);
-	}
-
-	efi.memmap.map = NULL;
-	clear_bit(EFI_MEMMAP, &efi.flags);
-}
-
-/**
- * efi_memmap_init_late - Map efi.memmap with memremap()
- * @phys_addr: Physical address of the new EFI memory map
- * @size: Size in bytes of the new EFI memory map
- *
- * Setup a mapping of the EFI memory map using ioremap_cache(). This
- * function should only be called once the vmalloc space has been
- * setup and is therefore not suitable for calling during early EFI
- * initialise, e.g. in efi_init(). Additionally, it expects
- * efi_memmap_init_early() to have already been called.
- *
- * The reason there are two EFI memmap initialisation
- * (efi_memmap_init_early() and this late version) is because the
- * early EFI memmap should be explicitly unmapped once EFI
- * initialisation is complete as the fixmap space used to map the EFI
- * memmap (via early_memremap()) is a scarce resource.
- *
- * This late mapping is intended to persist for the duration of
- * runtime so that things like efi_mem_desc_lookup() and
- * efi_mem_attributes() always work.
- *
- * Returns zero on success, a negative error code on failure.
- */
-int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size)
-{
-	struct efi_memory_map_data data = {
-		.phys_map = addr,
-		.size = size,
-	};
-
-	/* Did we forget to unmap the early EFI memmap? */
-	WARN_ON(efi.memmap.map);
-
-	/* Were we already called? */
-	WARN_ON(efi.memmap.late);
-
-	/*
-	 * It makes no sense to allow callers to register different
-	 * values for the following fields. Copy them out of the
-	 * existing early EFI memmap.
-	 */
-	data.desc_version = efi.memmap.desc_version;
-	data.desc_size = efi.memmap.desc_size;
-
-	return __efi_memmap_init(&data, true);
-}
-
 #ifdef CONFIG_EFI_VARS_MODULE
 static int __init efi_load_efivars(void)
 {

commit dca0f971ea6fcf2f1bb78f7995adf80da9f4767f
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Sat Feb 27 15:52:50 2016 +0000

    efi: Add efi_memmap_init_late() for permanent EFI memmap
    
    Drivers need a way to access the EFI memory map at runtime. ARM and
    arm64 currently provide this by remapping the EFI memory map into the
    vmalloc space before setting up the EFI virtual mappings.
    
    x86 does not provide this functionality which has resulted in the code
    in efi_mem_desc_lookup() where it will manually map individual EFI
    memmap entries if the memmap has already been torn down on x86,
    
      /*
       * If a driver calls this after efi_free_boot_services,
       * ->map will be NULL, and the target may also not be mapped.
       * So just always get our own virtual map on the CPU.
       *
       */
      md = early_memremap(p, sizeof (*md));
    
    There isn't a good reason for not providing a permanent EFI memory map
    for runtime queries, especially since the EFI regions are not mapped
    into the standard kernel page tables.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c1879999abe7..8a5e0db72b8f 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -347,56 +347,31 @@ subsys_initcall(efisubsys_init);
 
 /*
  * Find the efi memory descriptor for a given physical address.  Given a
- * physicall address, determine if it exists within an EFI Memory Map entry,
+ * physical address, determine if it exists within an EFI Memory Map entry,
  * and if so, populate the supplied memory descriptor with the appropriate
  * data.
  */
 int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 {
-	struct efi_memory_map *map = &efi.memmap;
-	phys_addr_t p, e;
+	efi_memory_desc_t *md;
 
 	if (!efi_enabled(EFI_MEMMAP)) {
 		pr_err_once("EFI_MEMMAP is not enabled.\n");
 		return -EINVAL;
 	}
 
-	if (!map) {
-		pr_err_once("efi.memmap is not set.\n");
-		return -EINVAL;
-	}
 	if (!out_md) {
 		pr_err_once("out_md is null.\n");
 		return -EINVAL;
         }
-	if (WARN_ON_ONCE(!map->phys_map))
-		return -EINVAL;
-	if (WARN_ON_ONCE(map->nr_map == 0) || WARN_ON_ONCE(map->desc_size == 0))
-		return -EINVAL;
 
-	e = map->phys_map + map->nr_map * map->desc_size;
-	for (p = map->phys_map; p < e; p += map->desc_size) {
-		efi_memory_desc_t *md;
+	for_each_efi_memory_desc(md) {
 		u64 size;
 		u64 end;
 
-		/*
-		 * If a driver calls this after efi_free_boot_services,
-		 * ->map will be NULL, and the target may also not be mapped.
-		 * So just always get our own virtual map on the CPU.
-		 *
-		 */
-		md = early_memremap(p, sizeof (*md));
-		if (!md) {
-			pr_err_once("early_memremap(%pa, %zu) failed.\n",
-				    &p, sizeof (*md));
-			return -ENOMEM;
-		}
-
 		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
 		    md->type != EFI_BOOT_SERVICES_DATA &&
 		    md->type != EFI_RUNTIME_SERVICES_DATA) {
-			early_memunmap(md, sizeof (*md));
 			continue;
 		}
 
@@ -404,11 +379,8 @@ int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 		end = md->phys_addr + size;
 		if (phys_addr >= md->phys_addr && phys_addr < end) {
 			memcpy(out_md, md, sizeof(*out_md));
-			early_memunmap(md, sizeof (*md));
 			return 0;
 		}
-
-		early_memunmap(md, sizeof (*md));
 	}
 	pr_err_once("requested map not found.\n");
 	return -ENOENT;
@@ -545,32 +517,49 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 }
 
 /**
- * efi_memmap_init_early - Map the EFI memory map data structure
+ * __efi_memmap_init - Common code for mapping the EFI memory map
  * @data: EFI memory map data
+ * @late: Use early or late mapping function?
  *
- * Use early_memremap() to map the passed in EFI memory map and assign
- * it to efi.memmap.
+ * This function takes care of figuring out which function to use to
+ * map the EFI memory map in efi.memmap based on how far into the boot
+ * we are.
+ *
+ * During bootup @late should be %false since we only have access to
+ * the early_memremap*() functions as the vmalloc space isn't setup.
+ * Once the kernel is fully booted we can fallback to the more robust
+ * memremap*() API.
+ *
+ * Returns zero on success, a negative error code on failure.
  */
-int __init efi_memmap_init_early(struct efi_memory_map_data *data)
+static int __init
+__efi_memmap_init(struct efi_memory_map_data *data, bool late)
 {
 	struct efi_memory_map map;
+	phys_addr_t phys_map;
 
 	if (efi_enabled(EFI_PARAVIRT))
 		return 0;
 
-	map.phys_map = data->phys_map;
+	phys_map = data->phys_map;
+
+	if (late)
+		map.map = memremap(phys_map, data->size, MEMREMAP_WB);
+	else
+		map.map = early_memremap(phys_map, data->size);
 
-	map.map = early_memremap(data->phys_map, data->size);
 	if (!map.map) {
 		pr_err("Could not map the memory map!\n");
 		return -ENOMEM;
 	}
 
+	map.phys_map = data->phys_map;
 	map.nr_map = data->size / data->desc_size;
 	map.map_end = map.map + data->size;
 
 	map.desc_version = data->desc_version;
 	map.desc_size = data->desc_size;
+	map.late = late;
 
 	set_bit(EFI_MEMMAP, &efi.flags);
 
@@ -579,17 +568,83 @@ int __init efi_memmap_init_early(struct efi_memory_map_data *data)
 	return 0;
 }
 
+/**
+ * efi_memmap_init_early - Map the EFI memory map data structure
+ * @data: EFI memory map data
+ *
+ * Use early_memremap() to map the passed in EFI memory map and assign
+ * it to efi.memmap.
+ */
+int __init efi_memmap_init_early(struct efi_memory_map_data *data)
+{
+	/* Cannot go backwards */
+	WARN_ON(efi.memmap.late);
+
+	return __efi_memmap_init(data, false);
+}
+
 void __init efi_memmap_unmap(void)
 {
-	unsigned long size;
+	if (!efi.memmap.late) {
+		unsigned long size;
 
-	size = efi.memmap.desc_size * efi.memmap.nr_map;
+		size = efi.memmap.desc_size * efi.memmap.nr_map;
+		early_memunmap(efi.memmap.map, size);
+	} else {
+		memunmap(efi.memmap.map);
+	}
 
-	early_memunmap(efi.memmap.map, size);
 	efi.memmap.map = NULL;
 	clear_bit(EFI_MEMMAP, &efi.flags);
 }
 
+/**
+ * efi_memmap_init_late - Map efi.memmap with memremap()
+ * @phys_addr: Physical address of the new EFI memory map
+ * @size: Size in bytes of the new EFI memory map
+ *
+ * Setup a mapping of the EFI memory map using ioremap_cache(). This
+ * function should only be called once the vmalloc space has been
+ * setup and is therefore not suitable for calling during early EFI
+ * initialise, e.g. in efi_init(). Additionally, it expects
+ * efi_memmap_init_early() to have already been called.
+ *
+ * The reason there are two EFI memmap initialisation
+ * (efi_memmap_init_early() and this late version) is because the
+ * early EFI memmap should be explicitly unmapped once EFI
+ * initialisation is complete as the fixmap space used to map the EFI
+ * memmap (via early_memremap()) is a scarce resource.
+ *
+ * This late mapping is intended to persist for the duration of
+ * runtime so that things like efi_mem_desc_lookup() and
+ * efi_mem_attributes() always work.
+ *
+ * Returns zero on success, a negative error code on failure.
+ */
+int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size)
+{
+	struct efi_memory_map_data data = {
+		.phys_map = addr,
+		.size = size,
+	};
+
+	/* Did we forget to unmap the early EFI memmap? */
+	WARN_ON(efi.memmap.map);
+
+	/* Were we already called? */
+	WARN_ON(efi.memmap.late);
+
+	/*
+	 * It makes no sense to allow callers to register different
+	 * values for the following fields. Copy them out of the
+	 * existing early EFI memmap.
+	 */
+	data.desc_version = efi.memmap.desc_version;
+	data.desc_size = efi.memmap.desc_size;
+
+	return __efi_memmap_init(&data, true);
+}
+
 #ifdef CONFIG_EFI_VARS_MODULE
 static int __init efi_load_efivars(void)
 {

commit 9479c7cebfb568f8b8b424be7f1cac120e9eea95
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Feb 26 21:22:05 2016 +0000

    efi: Refactor efi_memmap_init_early() into arch-neutral code
    
    Every EFI architecture apart from ia64 needs to setup the EFI memory
    map at efi.memmap, and the code for doing that is essentially the same
    across all implementations. Therefore, it makes sense to factor this
    out into the common code under drivers/firmware/efi/.
    
    The only slight variation is the data structure out of which we pull
    the initial memory map information, such as physical address, memory
    descriptor size and version, etc. We can address this by passing a
    generic data structure (struct efi_memory_map_data) as the argument to
    efi_memmap_init_early() which contains the minimum info required for
    initialising the memory map.
    
    In the process, this patch also fixes a few undesirable implementation
    differences:
    
     - ARM and arm64 were failing to clear the EFI_MEMMAP bit when
       unmapping the early EFI memory map. EFI_MEMMAP indicates whether
       the EFI memory map is mapped (not the regions contained within) and
       can be traversed.  It's more correct to set the bit as soon as we
       memremap() the passed in EFI memmap.
    
     - Rename efi_unmmap_memmap() to efi_memmap_unmap() to adhere to the
       regular naming scheme.
    
    This patch also uses a read-write mapping for the memory map instead
    of the read-only mapping currently used on ARM and arm64. x86 needs
    the ability to update the memory map in-place when assigning virtual
    addresses to regions (efi_map_region()) and tagging regions when
    reserving boot services (efi_reserve_boot_services()).
    
    There's no way for the generic fake_mem code to know which mapping to
    use without introducing some arch-specific constant/hook, so just use
    read-write since read-only is of dubious value for the EFI memory map.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 5a2631af7410..c1879999abe7 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -544,6 +544,52 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	return ret;
 }
 
+/**
+ * efi_memmap_init_early - Map the EFI memory map data structure
+ * @data: EFI memory map data
+ *
+ * Use early_memremap() to map the passed in EFI memory map and assign
+ * it to efi.memmap.
+ */
+int __init efi_memmap_init_early(struct efi_memory_map_data *data)
+{
+	struct efi_memory_map map;
+
+	if (efi_enabled(EFI_PARAVIRT))
+		return 0;
+
+	map.phys_map = data->phys_map;
+
+	map.map = early_memremap(data->phys_map, data->size);
+	if (!map.map) {
+		pr_err("Could not map the memory map!\n");
+		return -ENOMEM;
+	}
+
+	map.nr_map = data->size / data->desc_size;
+	map.map_end = map.map + data->size;
+
+	map.desc_version = data->desc_version;
+	map.desc_size = data->desc_size;
+
+	set_bit(EFI_MEMMAP, &efi.flags);
+
+	efi.memmap = map;
+
+	return 0;
+}
+
+void __init efi_memmap_unmap(void)
+{
+	unsigned long size;
+
+	size = efi.memmap.desc_size * efi.memmap.nr_map;
+
+	early_memunmap(efi.memmap.map, size);
+	efi.memmap.map = NULL;
+	clear_bit(EFI_MEMMAP, &efi.flags);
+}
+
 #ifdef CONFIG_EFI_VARS_MODULE
 static int __init efi_load_efivars(void)
 {

commit 4af9ed578a50cd331a725322cfd9d555251ce788
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Tue Aug 30 12:41:37 2016 +0200

    efi: Fix handling error value in fdt_find_uefi_params
    
    of_get_flat_dt_subnode_by_name can return negative value in case of error.
    Assigning the result to unsigned variable and checking if the variable
    is lesser than zero is incorrect and always false.
    The patch fixes it by using signed variable to check the result.
    
    The problem has been detected using semantic patch
    scripts/coccinelle/tests/unsigned_lesser_than_zero.cocci
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Shawn Lin <shawn.lin@rock-chips.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 5a2631af7410..7dd2e2d37231 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -657,9 +657,12 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 		}
 
 		if (subnode) {
-			node = of_get_flat_dt_subnode_by_name(node, subnode);
-			if (node < 0)
+			int err = of_get_flat_dt_subnode_by_name(node, subnode);
+
+			if (err < 0)
 				return 0;
+
+			node = err;
 		}
 
 		return __find_uefi_params(node, info, dt_params[i].params);

commit 08fd8c17686c6b09fa410a26d516548dd80ff147
Merge: e831101a73fb d34c30cc1fa8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 27 11:35:37 2016 -0700

    Merge tag 'for-linus-4.8-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen updates from David Vrabel:
     "Features and fixes for 4.8-rc0:
    
       - ACPI support for guests on ARM platforms.
       - Generic steal time support for arm and x86.
       - Support cases where kernel cpu is not Xen VCPU number (e.g., if
         in-guest kexec is used).
       - Use the system workqueue instead of a custom workqueue in various
         places"
    
    * tag 'for-linus-4.8-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip: (47 commits)
      xen: add static initialization of steal_clock op to xen_time_ops
      xen/pvhvm: run xen_vcpu_setup() for the boot CPU
      xen/evtchn: use xen_vcpu_id mapping
      xen/events: fifo: use xen_vcpu_id mapping
      xen/events: use xen_vcpu_id mapping in events_base
      x86/xen: use xen_vcpu_id mapping when pointing vcpu_info to shared_info
      x86/xen: use xen_vcpu_id mapping for HYPERVISOR_vcpu_op
      xen: introduce xen_vcpu_id mapping
      x86/acpi: store ACPI ids from MADT for future usage
      x86/xen: update cpuid.h from Xen-4.7
      xen/evtchn: add IOCTL_EVTCHN_RESTRICT
      xen-blkback: really don't leak mode property
      xen-blkback: constify instance of "struct attribute_group"
      xen-blkfront: prefer xenbus_scanf() over xenbus_gather()
      xen-blkback: prefer xenbus_scanf() over xenbus_gather()
      xen: support runqueue steal time on xen
      arm/xen: add support for vm_assist hypercall
      xen: update xen headers
      xen-pciback: drop superfluous variables
      xen-pciback: short-circuit read path used for merging write values
      ...

commit 475fb4e8b2f4444d1d7b406ff3a7d21bc89a1e6f
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:12 2016 +0300

    efi / ACPI: load SSTDs from EFI variables
    
    This patch allows SSDTs to be loaded from EFI variables. It works by
    specifying the EFI variable name containing the SSDT to be loaded. All
    variables with the same name (regardless of the vendor GUID) will be
    loaded.
    
    Note that we can't use acpi_install_table and we must rely on the
    dynamic ACPI table loading and bus re-scanning mechanisms. That is
    because I2C/SPI controllers are initialized earlier then the EFI
    subsystems and all I2C/SPI ACPI devices are enumerated when the
    I2C/SPI controllers are initialized.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 05509f3aaee8..8730fd475bf3 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -24,6 +24,9 @@
 #include <linux/of_fdt.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/acpi.h>
+#include <linux/ucs2_string.h>
 
 #include <asm/early_ioremap.h>
 
@@ -195,6 +198,96 @@ static void generic_ops_unregister(void)
 	efivars_unregister(&generic_efivars);
 }
 
+#if IS_ENABLED(CONFIG_ACPI)
+#define EFIVAR_SSDT_NAME_MAX	16
+static char efivar_ssdt[EFIVAR_SSDT_NAME_MAX] __initdata;
+static int __init efivar_ssdt_setup(char *str)
+{
+	if (strlen(str) < sizeof(efivar_ssdt))
+		memcpy(efivar_ssdt, str, strlen(str));
+	else
+		pr_warn("efivar_ssdt: name too long: %s\n", str);
+	return 0;
+}
+__setup("efivar_ssdt=", efivar_ssdt_setup);
+
+static __init int efivar_ssdt_iter(efi_char16_t *name, efi_guid_t vendor,
+				   unsigned long name_size, void *data)
+{
+	struct efivar_entry *entry;
+	struct list_head *list = data;
+	char utf8_name[EFIVAR_SSDT_NAME_MAX];
+	int limit = min_t(unsigned long, EFIVAR_SSDT_NAME_MAX, name_size);
+
+	ucs2_as_utf8(utf8_name, name, limit - 1);
+	if (strncmp(utf8_name, efivar_ssdt, limit) != 0)
+		return 0;
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return 0;
+
+	memcpy(entry->var.VariableName, name, name_size);
+	memcpy(&entry->var.VendorGuid, &vendor, sizeof(efi_guid_t));
+
+	efivar_entry_add(entry, list);
+
+	return 0;
+}
+
+static __init int efivar_ssdt_load(void)
+{
+	LIST_HEAD(entries);
+	struct efivar_entry *entry, *aux;
+	unsigned long size;
+	void *data;
+	int ret;
+
+	ret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);
+
+	list_for_each_entry_safe(entry, aux, &entries, list) {
+		pr_info("loading SSDT from variable %s-%pUl\n", efivar_ssdt,
+			&entry->var.VendorGuid);
+
+		list_del(&entry->list);
+
+		ret = efivar_entry_size(entry, &size);
+		if (ret) {
+			pr_err("failed to get var size\n");
+			goto free_entry;
+		}
+
+		data = kmalloc(size, GFP_KERNEL);
+		if (!data)
+			goto free_entry;
+
+		ret = efivar_entry_get(entry, NULL, &size, data);
+		if (ret) {
+			pr_err("failed to get var data\n");
+			goto free_data;
+		}
+
+		ret = acpi_load_table(data);
+		if (ret) {
+			pr_err("failed to load table: %d\n", ret);
+			goto free_data;
+		}
+
+		goto free_entry;
+
+free_data:
+		kfree(data);
+
+free_entry:
+		kfree(entry);
+	}
+
+	return ret;
+}
+#else
+static inline int efivar_ssdt_load(void) { return 0; }
+#endif
+
 /*
  * We register the efi subsystem with the firmware subsystem and the
  * efivars subsystem with the efi subsystem, if the system was booted with
@@ -218,6 +311,9 @@ static int __init efisubsys_init(void)
 	if (error)
 		goto err_put;
 
+	if (efi_enabled(EFI_RUNTIME_SERVICES))
+		efivar_ssdt_load();
+
 	error = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);
 	if (error) {
 		pr_err("efi: Sysfs attribute export failed with error %d.\n",

commit 0cac5c3018b32707b3bab40e4beb83f91c4204f1
Author: Shannon Zhao <shannon.zhao@linaro.org>
Date:   Thu May 12 20:19:54 2016 +0800

    Xen: EFI: Parse DT parameters for Xen specific UEFI
    
    The EFI DT parameters for bare metal are located under /chosen node,
    while for Xen Dom0 they are located under /hyperviosr/uefi node. These
    parameters under /chosen and /hyperviosr/uefi are not expected to appear
    at the same time.
    
    Parse these EFI parameters and initialize EFI like the way for bare
    metal except the runtime services because the runtime services for Xen
    Dom0 are available through hypercalls and they are always enabled. So it
    sets the EFI_RUNTIME_SERVICES flag if it finds /hyperviosr/uefi node and
    bails out in arm_enable_runtime_services() when EFI_RUNTIME_SERVICES
    flag is set already.
    
    Signed-off-by: Shannon Zhao <shannon.zhao@linaro.org>
    Cc: Stefano Stabellini <sstabellini@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 05509f3aaee8..1c6f9dda3c3e 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -472,12 +472,14 @@ device_initcall(efi_load_efivars);
 		FIELD_SIZEOF(struct efi_fdt_params, field) \
 	}
 
-static __initdata struct {
+struct params {
 	const char name[32];
 	const char propname[32];
 	int offset;
 	int size;
-} dt_params[] = {
+};
+
+static __initdata struct params fdt_params[] = {
 	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
 	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
 	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
@@ -485,44 +487,91 @@ static __initdata struct {
 	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
 };
 
+static __initdata struct params xen_fdt_params[] = {
+	UEFI_PARAM("System Table", "xen,uefi-system-table", system_table),
+	UEFI_PARAM("MemMap Address", "xen,uefi-mmap-start", mmap),
+	UEFI_PARAM("MemMap Size", "xen,uefi-mmap-size", mmap_size),
+	UEFI_PARAM("MemMap Desc. Size", "xen,uefi-mmap-desc-size", desc_size),
+	UEFI_PARAM("MemMap Desc. Version", "xen,uefi-mmap-desc-ver", desc_ver)
+};
+
+#define EFI_FDT_PARAMS_SIZE	ARRAY_SIZE(fdt_params)
+
+static __initdata struct {
+	const char *uname;
+	const char *subnode;
+	struct params *params;
+} dt_params[] = {
+	{ "hypervisor", "uefi", xen_fdt_params },
+	{ "chosen", NULL, fdt_params },
+};
+
 struct param_info {
 	int found;
 	void *params;
+	const char *missing;
 };
 
-static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
-				       int depth, void *data)
+static int __init __find_uefi_params(unsigned long node,
+				     struct param_info *info,
+				     struct params *params)
 {
-	struct param_info *info = data;
 	const void *prop;
 	void *dest;
 	u64 val;
 	int i, len;
 
-	if (depth != 1 || strcmp(uname, "chosen") != 0)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
-		prop = of_get_flat_dt_prop(node, dt_params[i].propname, &len);
-		if (!prop)
+	for (i = 0; i < EFI_FDT_PARAMS_SIZE; i++) {
+		prop = of_get_flat_dt_prop(node, params[i].propname, &len);
+		if (!prop) {
+			info->missing = params[i].name;
 			return 0;
-		dest = info->params + dt_params[i].offset;
+		}
+
+		dest = info->params + params[i].offset;
 		info->found++;
 
 		val = of_read_number(prop, len / sizeof(u32));
 
-		if (dt_params[i].size == sizeof(u32))
+		if (params[i].size == sizeof(u32))
 			*(u32 *)dest = val;
 		else
 			*(u64 *)dest = val;
 
 		if (efi_enabled(EFI_DBG))
-			pr_info("  %s: 0x%0*llx\n", dt_params[i].name,
-				dt_params[i].size * 2, val);
+			pr_info("  %s: 0x%0*llx\n", params[i].name,
+				params[i].size * 2, val);
 	}
+
 	return 1;
 }
 
+static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
+				       int depth, void *data)
+{
+	struct param_info *info = data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
+		const char *subnode = dt_params[i].subnode;
+
+		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
+			info->missing = dt_params[i].params[0].name;
+			continue;
+		}
+
+		if (subnode) {
+			node = of_get_flat_dt_subnode_by_name(node, subnode);
+			if (node < 0)
+				return 0;
+		}
+
+		return __find_uefi_params(node, info, dt_params[i].params);
+	}
+
+	return 0;
+}
+
 int __init efi_get_fdt_params(struct efi_fdt_params *params)
 {
 	struct param_info info;
@@ -538,7 +587,7 @@ int __init efi_get_fdt_params(struct efi_fdt_params *params)
 		pr_info("UEFI not found.\n");
 	else if (!ret)
 		pr_err("Can't find '%s' in device tree!\n",
-		       dt_params[info.found].name);
+		       info.missing);
 
 	return ret;
 }

commit 806b0351c9ff9890c1ef0ba2c46237baef49ac79
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:58 2016 +0100

    efi: Move efi_status_to_err() to drivers/firmware/efi/
    
    Move efi_status_to_err() to the architecture independent code as it's
    generally useful in all bits of EFI code where there is a need to
    convert an efi_status_t to a kernel error value.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: joeyli <jlee@suse.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-27-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4991371012b4..05509f3aaee8 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -636,3 +636,36 @@ u64 __weak efi_mem_attributes(unsigned long phys_addr)
 	}
 	return 0;
 }
+
+int efi_status_to_err(efi_status_t status)
+{
+	int err;
+
+	switch (status) {
+	case EFI_SUCCESS:
+		err = 0;
+		break;
+	case EFI_INVALID_PARAMETER:
+		err = -EINVAL;
+		break;
+	case EFI_OUT_OF_RESOURCES:
+		err = -ENOSPC;
+		break;
+	case EFI_DEVICE_ERROR:
+		err = -EIO;
+		break;
+	case EFI_WRITE_PROTECTED:
+		err = -EROFS;
+		break;
+	case EFI_SECURITY_VIOLATION:
+		err = -EACCES;
+		break;
+	case EFI_NOT_FOUND:
+		err = -ENOENT;
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}

commit 801820bee9bccb7c156af2b95c7208f428a06ae7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:53 2016 +0100

    efi/arm/libstub: Make screen_info accessible to the UEFI stub
    
    In order to hand over the framebuffer described by the GOP protocol and
    discovered by the UEFI stub, make struct screen_info accessible by the
    stub. This involves allocating a loader data buffer and passing it to the
    kernel proper via a UEFI Configuration Table, since the UEFI stub executes
    in the context of the decompressor, and cannot access the kernel's copy of
    struct screen_info directly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-22-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 583e647912a5..4991371012b4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -353,8 +353,9 @@ static __init int match_config_table(efi_guid_t *guid,
 		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
 			if (!efi_guidcmp(*guid, table_types[i].guid)) {
 				*(table_types[i].ptr) = table;
-				pr_cont(" %s=0x%lx ",
-					table_types[i].name, table);
+				if (table_types[i].name)
+					pr_cont(" %s=0x%lx ",
+						table_types[i].name, table);
 				return 1;
 			}
 		}

commit a604af075a3226adaff84b7026876f0c6dfe9f52
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:44 2016 +0100

    efi: Add support for the EFI_MEMORY_ATTRIBUTES_TABLE config table
    
    This declares the GUID and struct typedef for the new memory attributes
    table which contains the permissions that can be used to apply stricter
    permissions to UEFI Runtime Services memory regions.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-13-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f7d36c6cc1ad..583e647912a5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -43,6 +43,7 @@ struct efi __read_mostly efi = {
 	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
+	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -338,6 +339,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
+	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{NULL_GUID, NULL, NULL},
 };
 

commit 884f4f66ffd6ffe632f3a8be4e6d10a858afdc37
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:39 2016 +0100

    efi: Remove global 'memmap' EFI memory map
    
    Abolish the poorly named EFI memory map, 'memmap'. It is shadowed by a
    bunch of local definitions in various files and having two ways to
    access the EFI memory map ('efi.memmap' vs. 'memmap') is rather
    confusing.
    
    Furthermore, IA64 doesn't even provide this global object, which has
    caused issues when trying to write generic EFI memmap code.
    
    Replace all occurrences with efi.memmap, and convert the remaining
    iterator code to use for_each_efi_mem_desc().
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Luck, Tony <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-8-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4b533ce73374..f7d36c6cc1ad 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -256,7 +256,7 @@ subsys_initcall(efisubsys_init);
  */
 int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 {
-	struct efi_memory_map *map = efi.memmap;
+	struct efi_memory_map *map = &efi.memmap;
 	phys_addr_t p, e;
 
 	if (!efi_enabled(EFI_MEMMAP)) {

commit 78ce248faa3c46e24e9bd42db3ab3650659f16dd
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:38 2016 +0100

    efi: Iterate over efi.memmap in for_each_efi_memory_desc()
    
    Most of the users of for_each_efi_memory_desc() are equally happy
    iterating over the EFI memory map in efi.memmap instead of 'memmap',
    since the former is usually a pointer to the latter.
    
    For those users that want to specify an EFI memory map other than
    efi.memmap, that can be done using for_each_efi_memory_desc_in_map().
    One such example is in the libstub code where the firmware is queried
    directly for the memory map, it gets iterated over, and then freed.
    
    This change goes part of the way toward deleting the global 'memmap'
    variable, which is not universally available on all architectures
    (notably IA64) and is rather poorly named.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-7-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 3a69ed5ecfcb..4b533ce73374 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -620,16 +620,12 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
  */
 u64 __weak efi_mem_attributes(unsigned long phys_addr)
 {
-	struct efi_memory_map *map;
 	efi_memory_desc_t *md;
-	void *p;
 
 	if (!efi_enabled(EFI_MEMMAP))
 		return 0;
 
-	map = efi.memmap;
-	for (p = map->map; p < map->map_end; p += map->desc_size) {
-		md = p;
+	for_each_efi_memory_desc(md) {
 		if ((md->phys_addr <= phys_addr) &&
 		    (phys_addr < (md->phys_addr +
 		    (md->num_pages << EFI_PAGE_SHIFT))))

commit 35575e0e8ba633fc8276509a21f89b599b4f9006
Author: Robert Elliott <elliott@hpe.com>
Date:   Mon Feb 1 22:07:07 2016 +0000

    efi: Add Persistent Memory type name
    
    Add the "Persistent Memory" string for type 14 introduced in
    UEFI 2.5.  This is used when printing the UEFI memory map.
    
    old:
      efi: mem61: [type=14            |   |  |  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    new:
      efi: mem61: [Persistent Memory  |   |  |  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    Signed-off-by: Robert Elliott <elliott@hpe.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-14-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f4370485c26a..3a69ed5ecfcb 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -555,7 +555,8 @@ static __initdata char memory_type_name[][20] = {
 	"ACPI Memory NVS",
 	"Memory Mapped I/O",
 	"MMIO Port Space",
-	"PAL Code"
+	"PAL Code",
+	"Persistent Memory",
 };
 
 char * __init efi_md_typeattr_format(char *buf, size_t size,

commit c016ca08f89c6c78ed815f025262bdb87aba3f4c
Author: Robert Elliott <elliott@hpe.com>
Date:   Mon Feb 1 22:07:06 2016 +0000

    efi: Add NV memory attribute
    
    Add the NV memory attribute introduced in UEFI 2.5 and add a
    column for it in the types and attributes string used when
    printing the UEFI memory map.
    
    old:
      efi: mem61: [type=14            |   |  |  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    new:
      efi: mem61: [type=14            |   |  |NV|  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    Signed-off-by: Robert Elliott <elliott@hpe.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-13-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 20451c290233..f4370485c26a 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -582,13 +582,16 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
+		     EFI_MEMORY_NV |
 		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
 		snprintf(pos, size, "|attr=0x%016llx]",
 			 (unsigned long long)attr);
 	else
-		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+		snprintf(pos, size,
+			 "|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
 			 attr & EFI_MEMORY_MORE_RELIABLE ? "MR" : "",
+			 attr & EFI_MEMORY_NV      ? "NV"  : "",
 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
 			 attr & EFI_MEMORY_RP      ? "RP"  : "",
 			 attr & EFI_MEMORY_WP      ? "WP"  : "",

commit 9c6672ac9c91f7eb1ec436be1442b8c26d098e55
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 1 22:06:55 2016 +0000

    efi: Expose non-blocking set_variable() wrapper to efivars
    
    Commit 6d80dba1c9fe ("efi: Provide a non-blocking SetVariable()
    operation") implemented a non-blocking alternative for the UEFI
    SetVariable() invocation performed by efivars, since it may
    occur in atomic context. However, this version of the function
    was never exposed via the efivars struct, so the non-blocking
    versions was not actually callable. Fix that.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 6d80dba1c9fe ("efi: Provide a non-blocking SetVariable() operation")
    Link: http://lkml.kernel.org/r/1454364428-494-2-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 9b815c813687..20451c290233 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -182,6 +182,7 @@ static int generic_ops_register(void)
 {
 	generic_ops.get_variable = efi.get_variable;
 	generic_ops.set_variable = efi.set_variable;
+	generic_ops.set_variable_nonblocking = efi.set_variable_nonblocking;
 	generic_ops.get_next_variable = efi.get_next_variable;
 	generic_ops.query_variable_store = efi_query_variable_store;
 

commit 03e075b38e6cd25267c8d6e2797fa4537ca3348d
Merge: 753b11ef8e92 34229b277480
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 3 11:30:36 2016 +0100

    Merge branch 'linus' into efi/core, to refresh the branch and to pick up recent fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0f7f2f0c0fcbe5e2bcba707a628ebaedfe2be4b4
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jan 12 14:22:46 2016 +0100

    efi: include asm/early_ioremap.h not asm/efi.h to get early_memremap
    
    The code in efi.c uses early_memremap(), but relies on a transitive
    include rather than including asm/early_ioremap.h directly, since
    this header did not exist on ia64.
    
    Commit f7d924894265 ("arm64/efi: refactor EFI init and runtime code
    for reuse by 32-bit ARM") attempted to work around this by including
    asm/efi.h, which transitively includes asm/early_ioremap.h on most
    architectures. However, since asm/efi.h does not exist on ia64 either,
    this is not much of an improvement.
    
    Now that we have created an asm/early_ioremap.h for ia64, we can just
    include it directly.
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cffa89b3317b..2cd37dad67a6 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -25,7 +25,7 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 
-#include <asm/efi.h>
+#include <asm/early_ioremap.h>
 
 struct efi __read_mostly efi = {
 	.mps			= EFI_INVALID_TABLE_ADDR,

commit 50a0cb565246f20d59cdb161778531e4b19d35ac
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Dec 9 15:41:08 2015 -0800

    x86/efi-bgrt: Fix kernel panic when mapping BGRT data
    
    Starting with this commit 35eb8b81edd4 ("x86/efi: Build our own page
    table structures") efi regions have a separate page directory called
    "efi_pgd". In order to access any efi region we have to first shift %cr3
    to this page table. In the bgrt code we are trying to copy bgrt_header
    and image, but these regions fall under "EFI_BOOT_SERVICES_DATA"
    and to access these regions we have to shift %cr3 to efi_pgd and not
    doing so will cause page fault as shown below.
    
    [    0.251599] Last level dTLB entries: 4KB 64, 2MB 0, 4MB 0, 1GB 4
    [    0.259126] Freeing SMP alternatives memory: 32K (ffffffff8230e000 - ffffffff82316000)
    [    0.271803] BUG: unable to handle kernel paging request at fffffffefce35002
    [    0.279740] IP: [<ffffffff821bca49>] efi_bgrt_init+0x144/0x1fd
    [    0.286383] PGD 300f067 PUD 0
    [    0.289879] Oops: 0000 [#1] SMP
    [    0.293566] Modules linked in:
    [    0.297039] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.4.0-rc1-eywa-eywa-built-in-47041+ #2
    [    0.306619] Hardware name: Intel Corporation Skylake Client platform/Skylake Y LPDDR3 RVP3, BIOS SKLSE2R1.R00.B104.B01.1511110114 11/11/2015
    [    0.320925] task: ffffffff820134c0 ti: ffffffff82000000 task.ti: ffffffff82000000
    [    0.329420] RIP: 0010:[<ffffffff821bca49>]  [<ffffffff821bca49>] efi_bgrt_init+0x144/0x1fd
    [    0.338821] RSP: 0000:ffffffff82003f18  EFLAGS: 00010246
    [    0.344852] RAX: fffffffefce35000 RBX: fffffffefce35000 RCX: fffffffefce2b000
    [    0.352952] RDX: 000000008a82b000 RSI: ffffffff8235bb80 RDI: 000000008a835000
    [    0.361050] RBP: ffffffff82003f30 R08: 000000008a865000 R09: ffffffffff202850
    [    0.369149] R10: ffffffff811ad62f R11: 0000000000000000 R12: 0000000000000000
    [    0.377248] R13: ffff88016dbaea40 R14: ffffffff822622c0 R15: ffffffff82003fb0
    [    0.385348] FS:  0000000000000000(0000) GS:ffff88016d800000(0000) knlGS:0000000000000000
    [    0.394533] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [    0.401054] CR2: fffffffefce35002 CR3: 000000000300c000 CR4: 00000000003406f0
    [    0.409153] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [    0.417252] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [    0.425350] Stack:
    [    0.427638]  ffffffffffffffff ffffffff82256900 ffff88016dbaea40 ffffffff82003f40
    [    0.436086]  ffffffff821bbce0 ffffffff82003f88 ffffffff8219c0c2 0000000000000000
    [    0.444533]  ffffffff8219ba4a ffffffff822622c0 0000000000083000 00000000ffffffff
    [    0.452978] Call Trace:
    [    0.455763]  [<ffffffff821bbce0>] efi_late_init+0x9/0xb
    [    0.461697]  [<ffffffff8219c0c2>] start_kernel+0x463/0x47f
    [    0.467928]  [<ffffffff8219ba4a>] ? set_init_arg+0x55/0x55
    [    0.474159]  [<ffffffff8219b120>] ? early_idt_handler_array+0x120/0x120
    [    0.481669]  [<ffffffff8219b5ee>] x86_64_start_reservations+0x2a/0x2c
    [    0.488982]  [<ffffffff8219b72d>] x86_64_start_kernel+0x13d/0x14c
    [    0.495897] Code: 00 41 b4 01 48 8b 78 28 e8 09 36 01 00 48 85 c0 48 89 c3 75 13 48 c7 c7 f8 ac d3 81 31 c0 e8 d7 3b fb fe e9 b5 00 00 00 45 84 e4 <44> 8b 6b 02 74 0d be 06 00 00 00 48 89 df e8 ae 34 0$
    [    0.518151] RIP  [<ffffffff821bca49>] efi_bgrt_init+0x144/0x1fd
    [    0.524888]  RSP <ffffffff82003f18>
    [    0.528851] CR2: fffffffefce35002
    [    0.532615] ---[ end trace 7b06521e6ebf2aea ]---
    [    0.537852] Kernel panic - not syncing: Attempted to kill the idle task!
    
    As said above one way to fix this bug is to shift %cr3 to efi_pgd but we
    are not doing that way because it leaks inner details of how we switch
    to EFI page tables into a new call site and it also adds duplicate code.
    Instead, we remove the call to efi_lookup_mapped_addr() and always
    perform early_mem*() instead of early_io*() because we want to remap RAM
    regions and not I/O regions. We also delete efi_lookup_mapped_addr()
    because we are no longer using it.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Reported-by: Wendy Wang <wendy.wang@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 027ca212179f..e9c458ba9353 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -324,38 +324,6 @@ u64 __init efi_mem_desc_end(efi_memory_desc_t *md)
 	return end;
 }
 
-/*
- * We can't ioremap data in EFI boot services RAM, because we've already mapped
- * it as RAM.  So, look it up in the existing EFI memory map instead.  Only
- * callable after efi_enter_virtual_mode and before efi_free_boot_services.
- */
-void __iomem *efi_lookup_mapped_addr(u64 phys_addr)
-{
-	struct efi_memory_map *map;
-	void *p;
-	map = efi.memmap;
-	if (!map)
-		return NULL;
-	if (WARN_ON(!map->map))
-		return NULL;
-	for (p = map->map; p < map->map_end; p += map->desc_size) {
-		efi_memory_desc_t *md = p;
-		u64 size = md->num_pages << EFI_PAGE_SHIFT;
-		u64 end = md->phys_addr + size;
-		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
-		    md->type != EFI_BOOT_SERVICES_CODE &&
-		    md->type != EFI_BOOT_SERVICES_DATA)
-			continue;
-		if (!md->virt_addr)
-			continue;
-		if (phys_addr >= md->phys_addr && phys_addr < end) {
-			phys_addr += md->virt_addr - md->phys_addr;
-			return (__force void __iomem *)(unsigned long)phys_addr;
-		}
-	}
-	return NULL;
-}
-
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},

commit f7d924894265794f447ea799dd853400749b5a22
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Nov 30 13:28:19 2015 +0100

    arm64/efi: refactor EFI init and runtime code for reuse by 32-bit ARM
    
    This refactors the EFI init and runtime code that will be shared
    between arm64 and ARM so that it can be built for both archs.
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 027ca212179f..cffa89b3317b 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -25,6 +25,8 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 
+#include <asm/efi.h>
+
 struct efi __read_mostly efi = {
 	.mps			= EFI_INVALID_TABLE_ADDR,
 	.acpi			= EFI_INVALID_TABLE_ADDR,

commit 44511fb9e55ada760822b0b0d7be9d150576f17f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Oct 23 11:48:16 2015 +0200

    efi: Use correct type for struct efi_memory_map::phys_map
    
    We have been getting away with using a void* for the physical
    address of the UEFI memory map, since, even on 32-bit platforms
    with 64-bit physical addresses, no truncation takes place if the
    memory map has been allocated by the firmware (which only uses
    1:1 virtually addressable memory), which is usually the case.
    
    However, commit:
    
      0f96a99dab36 ("efi: Add "efi_fake_mem" boot option")
    
    adds code that clones and modifies the UEFI memory map, and the
    clone may live above 4 GB on 32-bit platforms.
    
    This means our use of void* for struct efi_memory_map::phys_map has
    graduated from 'incorrect but working' to 'incorrect and
    broken', and we need to fix it.
    
    So redefine struct efi_memory_map::phys_map as phys_addr_t, and
    get rid of a bunch of casts that are now unneeded.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: izumi.taku@jp.fujitsu.com
    Cc: kamezawa.hiroyu@jp.fujitsu.com
    Cc: linux-efi@vger.kernel.org
    Cc: matt.fleming@intel.com
    Link: http://lkml.kernel.org/r/1445593697-1342-1-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 31fc864eb037..027ca212179f 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -254,7 +254,7 @@ subsys_initcall(efisubsys_init);
 int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 {
 	struct efi_memory_map *map = efi.memmap;
-	void *p, *e;
+	phys_addr_t p, e;
 
 	if (!efi_enabled(EFI_MEMMAP)) {
 		pr_err_once("EFI_MEMMAP is not enabled.\n");
@@ -286,10 +286,10 @@ int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 		 * So just always get our own virtual map on the CPU.
 		 *
 		 */
-		md = early_memremap((phys_addr_t)p, sizeof (*md));
+		md = early_memremap(p, sizeof (*md));
 		if (!md) {
-			pr_err_once("early_memremap(%p, %zu) failed.\n",
-				    p, sizeof (*md));
+			pr_err_once("early_memremap(%pa, %zu) failed.\n",
+				    &p, sizeof (*md));
 			return -ENOMEM;
 		}
 

commit a1041713349d0b823b492d7b4ea4325d0b5666db
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Sep 23 07:29:34 2015 -0700

    efi: Introduce EFI_NX_PE_DATA bit and set it from properties table
    
    UEFI v2.5 introduces a runtime memory protection feature that splits
    PE/COFF runtime images into separate code and data regions. Since this
    may require special handling by the OS, allocate a EFI_xxx bit to
    keep track of whether this feature is currently active or not.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c297d78f50fd..31fc864eb037 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -426,6 +426,24 @@ int __init efi_config_parse_tables(void *config_tables, int count, int sz,
 	}
 	pr_cont("\n");
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
+
+	/* Parse the EFI Properties table if it exists */
+	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
+		efi_properties_table_t *tbl;
+
+		tbl = early_memremap(efi.properties_table, sizeof(*tbl));
+		if (tbl == NULL) {
+			pr_err("Could not map Properties table!\n");
+			return -ENOMEM;
+		}
+
+		if (tbl->memory_protection_attribute &
+		    EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA)
+			set_bit(EFI_NX_PE_DATA, &efi.flags);
+
+		early_memunmap(tbl, sizeof(*tbl));
+	}
+
 	return 0;
 }
 

commit bf924863c9445174c6e118f723dc477e2b6ccc7e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Sep 9 10:08:15 2015 +0200

    efi: Add support for UEFIv2.5 Properties table
    
    Version 2.5 of the UEFI spec introduces a new configuration table
    called the 'EFI Properties table'. Currently, it is only used to
    convey whether the Memory Protection feature is enabled, which splits
    PE/COFF images into separate code and data memory regions.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 278d4d88d250..c297d78f50fd 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -26,20 +26,21 @@
 #include <linux/platform_device.h>
 
 struct efi __read_mostly efi = {
-	.mps        = EFI_INVALID_TABLE_ADDR,
-	.acpi       = EFI_INVALID_TABLE_ADDR,
-	.acpi20     = EFI_INVALID_TABLE_ADDR,
-	.smbios     = EFI_INVALID_TABLE_ADDR,
-	.smbios3    = EFI_INVALID_TABLE_ADDR,
-	.sal_systab = EFI_INVALID_TABLE_ADDR,
-	.boot_info  = EFI_INVALID_TABLE_ADDR,
-	.hcdp       = EFI_INVALID_TABLE_ADDR,
-	.uga        = EFI_INVALID_TABLE_ADDR,
-	.uv_systab  = EFI_INVALID_TABLE_ADDR,
-	.fw_vendor  = EFI_INVALID_TABLE_ADDR,
-	.runtime    = EFI_INVALID_TABLE_ADDR,
-	.config_table  = EFI_INVALID_TABLE_ADDR,
-	.esrt       = EFI_INVALID_TABLE_ADDR,
+	.mps			= EFI_INVALID_TABLE_ADDR,
+	.acpi			= EFI_INVALID_TABLE_ADDR,
+	.acpi20			= EFI_INVALID_TABLE_ADDR,
+	.smbios			= EFI_INVALID_TABLE_ADDR,
+	.smbios3		= EFI_INVALID_TABLE_ADDR,
+	.sal_systab		= EFI_INVALID_TABLE_ADDR,
+	.boot_info		= EFI_INVALID_TABLE_ADDR,
+	.hcdp			= EFI_INVALID_TABLE_ADDR,
+	.uga			= EFI_INVALID_TABLE_ADDR,
+	.uv_systab		= EFI_INVALID_TABLE_ADDR,
+	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
+	.runtime		= EFI_INVALID_TABLE_ADDR,
+	.config_table		= EFI_INVALID_TABLE_ADDR,
+	.esrt			= EFI_INVALID_TABLE_ADDR,
+	.properties_table	= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -365,6 +366,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
+	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 	{NULL_GUID, NULL, NULL},
 };
 

commit 8be4432eb629a2762bad9173d6b06e6ea9c0dfcb
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Aug 27 02:11:19 2015 +0900

    efi: Add EFI_MEMORY_MORE_RELIABLE support to efi_md_typeattr_format()
    
    UEFI spec 2.5 introduces new Memory Attribute Definition named
    EFI_MEMORY_MORE_RELIABLE. This patch adds this new attribute
    support to efi_md_typeattr_format().
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index a0a0469e2869..278d4d88d250 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -591,12 +591,13 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
-		     EFI_MEMORY_RUNTIME))
+		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
 		snprintf(pos, size, "|attr=0x%016llx]",
 			 (unsigned long long)attr);
 	else
-		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
+			 attr & EFI_MEMORY_MORE_RELIABLE ? "MR" : "",
 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
 			 attr & EFI_MEMORY_RP      ? "RP"  : "",
 			 attr & EFI_MEMORY_WP      ? "WP"  : "",

commit 7968c0e338085eba0ee2f0e0b0d833057a966679
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Wed Aug 26 14:24:58 2015 +0100

    efi/arm64: Clean up efi_get_fdt_params() interface
    
    As we now have a common debug infrastructure between core and arm64 efi,
    drop the bit of the interface passing verbose output flags around.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f0372a022c86..a0a0469e2869 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -492,7 +492,6 @@ static __initdata struct {
 };
 
 struct param_info {
-	int verbose;
 	int found;
 	void *params;
 };
@@ -523,21 +522,20 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 		else
 			*(u64 *)dest = val;
 
-		if (info->verbose)
+		if (efi_enabled(EFI_DBG))
 			pr_info("  %s: 0x%0*llx\n", dt_params[i].name,
 				dt_params[i].size * 2, val);
 	}
 	return 1;
 }
 
-int __init efi_get_fdt_params(struct efi_fdt_params *params, int verbose)
+int __init efi_get_fdt_params(struct efi_fdt_params *params)
 {
 	struct param_info info;
 	int ret;
 
 	pr_info("Getting EFI parameters from FDT:\n");
 
-	info.verbose = verbose;
 	info.found = 0;
 	info.params = params;
 

commit 12dd00e83fb83fa41dcc965cdd1e1627494348cb
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Wed Aug 26 14:24:56 2015 +0100

    efi/x86: Move efi=debug option parsing to core
    
    fed6cefe3b6e ("x86/efi: Add a "debug" option to the efi= cmdline")
    adds the DBG flag, but does so for x86 only. Move this early param
    parsing to core code.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 16c4928e36af..f0372a022c86 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -63,6 +63,9 @@ static int __init parse_efi_cmdline(char *str)
 		return -EINVAL;
 	}
 
+	if (parse_option_str(str, "debug"))
+		set_bit(EFI_DBG, &efi.flags);
+
 	if (parse_option_str(str, "noruntime"))
 		disable_runtime = true;
 

commit 0ce423b6492a02be11662bfaa837dd16945aad3e
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Sat Oct 3 23:26:07 2015 +0100

    efi: Use the generic efi.memmap instead of 'memmap'
    
    Guenter reports that commit:
    
      7bf793115dd9 ("efi, x86: Rearrange efi_mem_attributes()")
    
    breaks the IA64 compilation with the following error:
    
      drivers/built-in.o: In function `efi_mem_attributes': (.text+0xde962): undefined reference to `memmap'
    
    Instead of using the (rather poorly named) global variable
    'memmap' which doesn't exist on IA64, use efi.memmap which
    points to the 'memmap' object on x86 and arm64 and which is NULL
    for IA64.
    
    The fact that efi.memmap is NULL for IA64 is OK because IA64
    provides its own implementation of efi_mem_attributes().
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Jonathan Zhang <zjzhang@codeaurora.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: http://lkml.kernel.org/r/20151003222607.GA2682@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index afee2880e0fd..16c4928e36af 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -623,13 +623,15 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
  */
 u64 __weak efi_mem_attributes(unsigned long phys_addr)
 {
+	struct efi_memory_map *map;
 	efi_memory_desc_t *md;
 	void *p;
 
 	if (!efi_enabled(EFI_MEMMAP))
 		return 0;
 
-	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+	map = efi.memmap;
+	for (p = map->map; p < map->map_end; p += map->desc_size) {
 		md = p;
 		if ((md->phys_addr <= phys_addr) &&
 		    (phys_addr < (md->phys_addr +

commit 7bf793115dd96ce9bd8ed1665fc187d961a95dba
Author: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
Date:   Fri Aug 7 09:36:57 2015 +0100

    efi, x86: Rearrange efi_mem_attributes()
    
    x86 and ia64 implement efi_mem_attributes() differently. This
    function needs to be available for other architectures
    (such as arm64) as well, such as for the purpose of ACPI/APEI.
    
    ia64 EFI does not set up a 'memmap' variable and does not set
    the EFI_MEMMAP flag, so it needs to have its unique implementation
    of efi_mem_attributes().
    
    Move efi_mem_attributes() implementation from x86 to the core
    EFI code, and declare it with __weak.
    
    It is recommended that other architectures should not override
    the default implementation.
    
    Signed-off-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Reviewed-by: Matt Fleming <matt.fleming@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1438936621-5215-4-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index d7a9160008d3..afee2880e0fd 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -607,3 +607,34 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 			 attr & EFI_MEMORY_UC      ? "UC"  : "");
 	return buf;
 }
+
+/*
+ * efi_mem_attributes - lookup memmap attributes for physical address
+ * @phys_addr: the physical address to lookup
+ *
+ * Search in the EFI memory map for the region covering
+ * @phys_addr. Returns the EFI memory attributes if the region
+ * was found in the memory map, 0 otherwise.
+ *
+ * Despite being marked __weak, most architectures should *not*
+ * override this function. It is __weak solely for the benefit
+ * of ia64 which has a funky EFI memory map that doesn't work
+ * the same way as other architectures.
+ */
+u64 __weak efi_mem_attributes(unsigned long phys_addr)
+{
+	efi_memory_desc_t *md;
+	void *p;
+
+	if (!efi_enabled(EFI_MEMMAP))
+		return 0;
+
+	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+		md = p;
+		if ((md->phys_addr <= phys_addr) &&
+		    (phys_addr < (md->phys_addr +
+		    (md->num_pages << EFI_PAGE_SHIFT))))
+			return md->attribute;
+	}
+	return 0;
+}

commit 87db73aebf55554fefaa3eade0a28f282a1511b8
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 7 09:36:54 2015 +0100

    efi: Add support for EFI_MEMORY_RO attribute introduced by UEFIv2.5
    
    The UEFI spec v2.5 introduces a new memory attribute
    EFI_MEMORY_RO, which is now the preferred attribute to convey
    that the nature of the contents of such a region allows it to be
    mapped read-only (i.e., it contains .text and .rodata only).
    
    The specification of the existing EFI_MEMORY_WP attribute has been
    updated to align more closely with its common use as a
    cacheability attribute rather than a permission attribute.
    
    Add the #define and add the attribute to the memory map dumping
    routine.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1438936621-5215-1-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index d6144e3b97c5..d7a9160008d3 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -588,16 +588,18 @@ char * __init efi_md_typeattr_format(char *buf, size_t size,
 
 	attr = md->attribute;
 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
-		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_WP |
-		     EFI_MEMORY_RP | EFI_MEMORY_XP | EFI_MEMORY_RUNTIME))
+		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
+		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
+		     EFI_MEMORY_RUNTIME))
 		snprintf(pos, size, "|attr=0x%016llx]",
 			 (unsigned long long)attr);
 	else
-		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
 			 attr & EFI_MEMORY_RP      ? "RP"  : "",
 			 attr & EFI_MEMORY_WP      ? "WP"  : "",
+			 attr & EFI_MEMORY_RO      ? "RO"  : "",
 			 attr & EFI_MEMORY_UCE     ? "UCE" : "",
 			 attr & EFI_MEMORY_WB      ? "WB"  : "",
 			 attr & EFI_MEMORY_WT      ? "WT"  : "",

commit 9115c7589b11349a1c3099758b4bded579ff69e0
Author: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date:   Wed Jul 15 19:36:03 2015 -0700

    efi: Check for NULL efi kernel parameters
    
    Even though it is documented how to specifiy efi parameters, it is
    possible to cause a kernel panic due to a dereference of a NULL pointer when
    parsing such parameters if "efi" alone is given:
    
    PANIC: early exception 0e rip 10:ffffffff812fb361 error 0 cr2 0
    [ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 4.2.0-rc1+ #450
    [ 0.000000]  ffffffff81fe20a9 ffffffff81e03d50 ffffffff8184bb0f 00000000000003f8
    [ 0.000000]  0000000000000000 ffffffff81e03e08 ffffffff81f371a1 64656c62616e6520
    [ 0.000000]  0000000000000069 000000000000005f 0000000000000000 0000000000000000
    [ 0.000000] Call Trace:
    [ 0.000000]  [<ffffffff8184bb0f>] dump_stack+0x45/0x57
    [ 0.000000]  [<ffffffff81f371a1>] early_idt_handler_common+0x81/0xae
    [ 0.000000]  [<ffffffff812fb361>] ? parse_option_str+0x11/0x90
    [ 0.000000]  [<ffffffff81f4dd69>] arch_parse_efi_cmdline+0x15/0x42
    [ 0.000000]  [<ffffffff81f376e1>] do_early_param+0x50/0x8a
    [ 0.000000]  [<ffffffff8106b1b3>] parse_args+0x1e3/0x400
    [ 0.000000]  [<ffffffff81f37a43>] parse_early_options+0x24/0x28
    [ 0.000000]  [<ffffffff81f37691>] ? loglevel+0x31/0x31
    [ 0.000000]  [<ffffffff81f37a78>] parse_early_param+0x31/0x3d
    [ 0.000000]  [<ffffffff81f3ae98>] setup_arch+0x2de/0xc08
    [ 0.000000]  [<ffffffff8109629a>] ? vprintk_default+0x1a/0x20
    [ 0.000000]  [<ffffffff81f37b20>] start_kernel+0x90/0x423
    [ 0.000000]  [<ffffffff81f37495>] x86_64_start_reservations+0x2a/0x2c
    [ 0.000000]  [<ffffffff81f37582>] x86_64_start_kernel+0xeb/0xef
    [ 0.000000] RIP 0xffffffff81ba2efc
    
    This panic is not reproducible with "efi=" as this will result in a non-NULL
    zero-length string.
    
    Thus, verify that the pointer to the parameter string is not NULL. This is
    consistent with other parameter-parsing functions which check for NULL pointers.
    
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 9fa8084a7c8d..d6144e3b97c5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -58,6 +58,11 @@ bool efi_runtime_disabled(void)
 
 static int __init parse_efi_cmdline(char *str)
 {
+	if (!str) {
+		pr_warn("need at least one option\n");
+		return -EINVAL;
+	}
+
 	if (parse_option_str(str, "noruntime"))
 		disable_runtime = true;
 

commit 0cbee992696236227a7ea411e4b0fbf73b918b6a
Merge: 2fee94b74b45 93e3bce6287e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 3 15:20:57 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace updates from Eric Biederman:
     "Long ago and far away when user namespaces where young it was realized
      that allowing fresh mounts of proc and sysfs with only user namespace
      permissions could violate the basic rule that only root gets to decide
      if proc or sysfs should be mounted at all.
    
      Some hacks were put in place to reduce the worst of the damage could
      be done, and the common sense rule was adopted that fresh mounts of
      proc and sysfs should allow no more than bind mounts of proc and
      sysfs.  Unfortunately that rule has not been fully enforced.
    
      There are two kinds of gaps in that enforcement.  Only filesystems
      mounted on empty directories of proc and sysfs should be ignored but
      the test for empty directories was insufficient.  So in my tree
      directories on proc, sysctl and sysfs that will always be empty are
      created specially.  Every other technique is imperfect as an ordinary
      directory can have entries added even after a readdir returns and
      shows that the directory is empty.  Special creation of directories
      for mount points makes the code in the kernel a smidge clearer about
      it's purpose.  I asked container developers from the various container
      projects to help test this and no holes were found in the set of mount
      points on proc and sysfs that are created specially.
    
      This set of changes also starts enforcing the mount flags of fresh
      mounts of proc and sysfs are consistent with the existing mount of
      proc and sysfs.  I expected this to be the boring part of the work but
      unfortunately unprivileged userspace winds up mounting fresh copies of
      proc and sysfs with noexec and nosuid clear when root set those flags
      on the previous mount of proc and sysfs.  So for now only the atime,
      read-only and nodev attributes which userspace happens to keep
      consistent are enforced.  Dealing with the noexec and nosuid
      attributes remains for another time.
    
      This set of changes also addresses an issue with how open file
      descriptors from /proc/<pid>/ns/* are displayed.  Recently readlink of
      /proc/<pid>/fd has been triggering a WARN_ON that has not been
      meaningful since it was added (as all of the code in the kernel was
      converted) and is not now actively wrong.
    
      There is also a short list of issues that have not been fixed yet that
      I will mention briefly.
    
      It is possible to rename a directory from below to above a bind mount.
      At which point any directory pointers below the renamed directory can
      be walked up to the root directory of the filesystem.  With user
      namespaces enabled a bind mount of the bind mount can be created
      allowing the user to pick a directory whose children they can rename
      to outside of the bind mount.  This is challenging to fix and doubly
      so because all obvious solutions must touch code that is in the
      performance part of pathname resolution.
    
      As mentioned above there is also a question of how to ensure that
      developers by accident or with purpose do not introduce exectuable
      files on sysfs and proc and in doing so introduce security regressions
      in the current userspace that will not be immediately obvious and as
      such are likely to require breaking userspace in painful ways once
      they are recognized"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      vfs: Remove incorrect debugging WARN in prepend_path
      mnt: Update fs_fully_visible to test for permanently empty directories
      sysfs: Create mountpoints with sysfs_create_mount_point
      sysfs: Add support for permanently empty directories to serve as mount points.
      kernfs: Add support for always empty directories.
      proc: Allow creating permanently empty directories that serve as mount points
      sysctl: Allow creating permanently empty directories that serve as mountpoints.
      fs: Add helper functions for permanently empty directories.
      vfs: Ignore unlocked mounts in fs_fully_visible
      mnt: Modify fs_fully_visible to deal with locked ro nodev and atime
      mnt: Refactor the logic for mounting sysfs and proc in a user namespace

commit f9bb48825a6b5d02f4cabcc78967c75db903dcdc
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed May 13 17:35:41 2015 -0500

    sysfs: Create mountpoints with sysfs_create_mount_point
    
    This allows for better documentation in the code and
    it allows for a simpler and fully correct version of
    fs_fully_visible to be written.
    
    The mount points converted and their filesystems are:
    /sys/hypervisor/s390/       s390_hypfs
    /sys/kernel/config/         configfs
    /sys/kernel/debug/          debugfs
    /sys/firmware/efi/efivars/  efivarfs
    /sys/fs/fuse/connections/   fusectl
    /sys/fs/pstore/             pstore
    /sys/kernel/tracing/        tracefs
    /sys/fs/cgroup/             cgroup
    /sys/kernel/security/       securityfs
    /sys/fs/selinux/            selinuxfs
    /sys/fs/smackfs/            smackfs
    
    Cc: stable@vger.kernel.org
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 3061bb8629dc..e14363d12690 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -65,7 +65,6 @@ static int __init parse_efi_cmdline(char *str)
 early_param("efi", parse_efi_cmdline);
 
 static struct kobject *efi_kobj;
-static struct kobject *efivars_kobj;
 
 /*
  * Let's not leave out systab information that snuck into
@@ -212,10 +211,9 @@ static int __init efisubsys_init(void)
 		goto err_remove_group;
 
 	/* and the standard mountpoint for efivarfs */
-	efivars_kobj = kobject_create_and_add("efivars", efi_kobj);
-	if (!efivars_kobj) {
+	error = sysfs_create_mount_point(efi_kobj, "efivars");
+	if (error) {
 		pr_err("efivars: Subsystem registration failed.\n");
-		error = -ENOMEM;
 		goto err_remove_group;
 	}
 

commit b119fe080a83d32d78f56877fe3a95a155417130
Author: Jean Delvare <jdelvare@suse.de>
Date:   Thu Apr 30 15:23:05 2015 +0200

    efi: dmi: List SMBIOS3 table before SMBIOS table
    
    The SMBIOS3 table should appear before the SMBIOS table in
    /sys/firmware/efi/systab. This allows user-space utilities which
    support both to pick the SMBIOS3 table with a single pass on systems
    where both are implemented. The SMBIOS3 entry point is more capable
    than the SMBIOS entry point so it should be preferred.
    
    This follows the same logic as the ACPI20 table being listed before
    the ACPI table.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 48b4c356740f..ca617f40574a 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -86,10 +86,15 @@ static ssize_t systab_show(struct kobject *kobj,
 		str += sprintf(str, "ACPI20=0x%lx\n", efi.acpi20);
 	if (efi.acpi != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "ACPI=0x%lx\n", efi.acpi);
-	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
-		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
+	/*
+	 * If both SMBIOS and SMBIOS3 entry points are implemented, the
+	 * SMBIOS3 entry point shall be preferred, so we list it first to
+	 * let applications stop parsing after the first match.
+	 */
 	if (efi.smbios3 != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "SMBIOS3=0x%lx\n", efi.smbios3);
+	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
 	if (efi.hcdp != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);
 	if (efi.boot_info != EFI_INVALID_TABLE_ADDR)

commit 0bb549052d33f8992544764a6cf1299d06ba7e2f
Author: Peter Jones <pjones@redhat.com>
Date:   Tue Apr 28 18:44:31 2015 -0400

    efi: Add esrt support
    
    Add sysfs files for the EFI System Resource Table (ESRT) under
    /sys/firmware/efi/esrt and for each EFI System Resource Entry under
    entries/ as a subdir.
    
    The EFI System Resource Table (ESRT) provides a read-only catalog of
    system components for which the system accepts firmware upgrades via
    UEFI's "Capsule Update" feature.  This module allows userland utilities
    to evaluate what firmware updates can be applied to this system, and
    potentially arrange for those updates to occur.
    
    The ESRT is described as part of the UEFI specification, in version 2.5
    which should be available from http://uefi.org/specifications in early
    2015.  If you're a member of the UEFI Forum, information about its
    addition to the standard is available as UEFI Mantis 1090.
    
    For some hardware platforms, additional restrictions may be found at
    http://msdn.microsoft.com/en-us/library/windows/hardware/jj128256.aspx ,
    and additional documentation may be found at
    http://download.microsoft.com/download/5/F/5/5F5D16CD-2530-4289-8019-94C6A20BED3C/windows-uefi-firmware-update-platform.docx
    .
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 3061bb8629dc..48b4c356740f 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -39,6 +39,7 @@ struct efi __read_mostly efi = {
 	.fw_vendor  = EFI_INVALID_TABLE_ADDR,
 	.runtime    = EFI_INVALID_TABLE_ADDR,
 	.config_table  = EFI_INVALID_TABLE_ADDR,
+	.esrt       = EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -64,7 +65,7 @@ static int __init parse_efi_cmdline(char *str)
 }
 early_param("efi", parse_efi_cmdline);
 
-static struct kobject *efi_kobj;
+struct kobject *efi_kobj;
 static struct kobject *efivars_kobj;
 
 /*
@@ -232,6 +233,84 @@ static int __init efisubsys_init(void)
 
 subsys_initcall(efisubsys_init);
 
+/*
+ * Find the efi memory descriptor for a given physical address.  Given a
+ * physicall address, determine if it exists within an EFI Memory Map entry,
+ * and if so, populate the supplied memory descriptor with the appropriate
+ * data.
+ */
+int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
+{
+	struct efi_memory_map *map = efi.memmap;
+	void *p, *e;
+
+	if (!efi_enabled(EFI_MEMMAP)) {
+		pr_err_once("EFI_MEMMAP is not enabled.\n");
+		return -EINVAL;
+	}
+
+	if (!map) {
+		pr_err_once("efi.memmap is not set.\n");
+		return -EINVAL;
+	}
+	if (!out_md) {
+		pr_err_once("out_md is null.\n");
+		return -EINVAL;
+        }
+	if (WARN_ON_ONCE(!map->phys_map))
+		return -EINVAL;
+	if (WARN_ON_ONCE(map->nr_map == 0) || WARN_ON_ONCE(map->desc_size == 0))
+		return -EINVAL;
+
+	e = map->phys_map + map->nr_map * map->desc_size;
+	for (p = map->phys_map; p < e; p += map->desc_size) {
+		efi_memory_desc_t *md;
+		u64 size;
+		u64 end;
+
+		/*
+		 * If a driver calls this after efi_free_boot_services,
+		 * ->map will be NULL, and the target may also not be mapped.
+		 * So just always get our own virtual map on the CPU.
+		 *
+		 */
+		md = early_memremap((phys_addr_t)p, sizeof (*md));
+		if (!md) {
+			pr_err_once("early_memremap(%p, %zu) failed.\n",
+				    p, sizeof (*md));
+			return -ENOMEM;
+		}
+
+		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
+		    md->type != EFI_BOOT_SERVICES_DATA &&
+		    md->type != EFI_RUNTIME_SERVICES_DATA) {
+			early_memunmap(md, sizeof (*md));
+			continue;
+		}
+
+		size = md->num_pages << EFI_PAGE_SHIFT;
+		end = md->phys_addr + size;
+		if (phys_addr >= md->phys_addr && phys_addr < end) {
+			memcpy(out_md, md, sizeof(*out_md));
+			early_memunmap(md, sizeof (*md));
+			return 0;
+		}
+
+		early_memunmap(md, sizeof (*md));
+	}
+	pr_err_once("requested map not found.\n");
+	return -ENOENT;
+}
+
+/*
+ * Calculate the highest address of an efi memory descriptor.
+ */
+u64 __init efi_mem_desc_end(efi_memory_desc_t *md)
+{
+	u64 size = md->num_pages << EFI_PAGE_SHIFT;
+	u64 end = md->phys_addr + size;
+	return end;
+}
 
 /*
  * We can't ioremap data in EFI boot services RAM, because we've already mapped
@@ -274,6 +353,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
+	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 	{NULL_GUID, NULL, NULL},
 };
 

commit 6b00f7efb5303418c231994c91fb8239f5ada260
Merge: b3d6524ff795 d476d94f180a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 11 18:03:54 2015 -0800

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "arm64 updates for 3.20:
    
       - reimplementation of the virtual remapping of UEFI Runtime Services
         in a way that is stable across kexec
       - emulation of the "setend" instruction for 32-bit tasks (user
         endianness switching trapped in the kernel, SCTLR_EL1.E0E bit set
         accordingly)
       - compat_sys_call_table implemented in C (from asm) and made it a
         constant array together with sys_call_table
       - export CPU cache information via /sys (like other architectures)
       - DMA API implementation clean-up in preparation for IOMMU support
       - macros clean-up for KVM
       - dropped some unnecessary cache+tlb maintenance
       - CONFIG_ARM64_CPU_SUSPEND clean-up
       - defconfig update (CPU_IDLE)
    
      The EFI changes going via the arm64 tree have been acked by Matt
      Fleming.  There is also a patch adding sys_*stat64 prototypes to
      include/linux/syscalls.h, acked by Andrew Morton"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (47 commits)
      arm64: compat: Remove incorrect comment in compat_siginfo
      arm64: Fix section mismatch on alloc_init_p[mu]d()
      arm64: Avoid breakage caused by .altmacro in fpsimd save/restore macros
      arm64: mm: use *_sect to check for section maps
      arm64: drop unnecessary cache+tlb maintenance
      arm64:mm: free the useless initial page table
      arm64: Enable CPU_IDLE in defconfig
      arm64: kernel: remove ARM64_CPU_SUSPEND config option
      arm64: make sys_call_table const
      arm64: Remove asm/syscalls.h
      arm64: Implement the compat_sys_call_table in C
      syscalls: Declare sys_*stat64 prototypes if __ARCH_WANT_(COMPAT_)STAT64
      compat: Declare compat_sys_sigpending and compat_sys_sigprocmask prototypes
      arm64: uapi: expose our struct ucontext to the uapi headers
      smp, ARM64: Kill SMP single function call interrupt
      arm64: Emulate SETEND for AArch32 tasks
      arm64: Consolidate hotplug notifier for instruction emulation
      arm64: Track system support for mixed endian EL0
      arm64: implement generic IOMMU configuration
      arm64: Combine coherent and non-coherent swiotlb dma_ops
      ...

commit 3c01b74e818a7a3b2ee9b0d584cca0bc154a031c
Merge: c59c961ca511 11629305043c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Jan 29 19:16:40 2015 +0100

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into x86/efi
    
    Pull EFI updates from Matt Fleming:
    
    " - Move efivarfs from the misc filesystem section to pseudo filesystem,
        since that's a more logical and accurate place - Leif Lindholm
    
      - Update efibootmgr URL in Kconfig help - Peter Jones
    
      - Improve accuracy of EFI guid function names - Borislav Petkov
    
      - Expose firmware platform size in sysfs for the benefit of EFI boot
        loader installers and other utilities - Steve McIntyre
    
      - Cleanup __init annotations for arm64/efi code - Ard Biesheuvel
    
      - Mark the UIE as unsupported for rtc-efi - Ard Biesheuvel
    
      - Fix memory leak in error code path of runtime map code - Dan Carpenter
    
      - Improve robustness of get_memory_map() by removing assumptions on the
        size of efi_memory_desc_t (which could change in future spec
        versions) and querying the firmware instead of guessing about the
        memmap size - Ard Biesheuvel
    
      - Remove superfluous guid unparse calls - Ivan Khoronzhuk
    
      - Delete unnecessary chosen@0 DT node FDT code since was duplicated
        from code in drivers/of and is entirely unnecessary - Leif Lindholm
    
       There's nothing super scary, mainly cleanups, and a merge from Ricardo who
       kindly picked up some patches from the linux-efi mailing list while I
       was out on annual leave in December.
    
       Perhaps the biggest risk is the get_memory_map() change from Ard, which
       changes the way that both the arm64 and x86 EFI boot stub build the
       early memory map. It would be good to have it bake in linux-next for a
       while.
    "
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 11629305043c513454c4ccb4fc384a1bfe610647
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Tue Jan 20 16:34:38 2015 +0000

    efi: Don't look for chosen@0 node on DT platforms
    
    Due to some scary special case handling noticed in drivers/of, various
    bits of the ARM* EFI support patches did duplicate looking for @0
    variants of various nodes. Unless on an ancient PPC system, these are
    not in fact required. Most instances have become refactored out along
    the way, this removes the last one.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index f8f126812656..23f1eca92dc4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -403,8 +403,7 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 	u64 val;
 	int i, len;
 
-	if (depth != 1 ||
-	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
+	if (depth != 1 || strcmp(uname, "chosen") != 0)
 		return 0;
 
 	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {

commit 613782b0875269b6f849e3344a789e647414a434
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Tue Jan 20 22:26:03 2015 +0000

    firmware: efi: Remove unneeded guid unparse
    
    There is no reason to translate guid number to string here.
    So remove it in order to not do unneeded work.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 9bdbc0533627..f8f126812656 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -277,15 +277,10 @@ static __init int match_config_table(efi_guid_t *guid,
 				     unsigned long table,
 				     efi_config_table_type_t *table_types)
 {
-	u8 str[EFI_VARIABLE_GUID_LEN + 1];
 	int i;
 
 	if (table_types) {
-		efi_guid_to_str(guid, str);
-
 		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
-			efi_guid_to_str(&table_types[i].guid, str);
-
 			if (!efi_guidcmp(*guid, table_types[i].guid)) {
 				*(table_types[i].ptr) = table;
 				pr_cont(" %s=0x%lx ",

commit 2859dff97e54db4795b8b7d9606cb8efcec722ff
Author: Steve McIntyre <steve@einval.com>
Date:   Fri Jan 9 15:29:53 2015 +0000

    efi: Expose underlying UEFI firmware platform size to userland
    
    In some cases (e.g. Intel Bay Trail machines), the kernel will happily
    run in 64-bit even if the underlying UEFI firmware platform is
    32-bit. That's great, but it's difficult for userland utilities like
    grub-install to do the right thing in such a situation.
    
    The kernel already knows about the size of the firmware via
    efi_enabled(EFI_64BIT). Add an extra sysfs interface
    /sys/firmware/efi/fw_platform_size to expose that information to
    userland for low-level utilities to use.
    
    Signed-off-by: Steve McIntyre <steve@einval.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index ff0bbe383b31..9bdbc0533627 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -112,15 +112,24 @@ EFI_ATTR_SHOW(fw_vendor);
 EFI_ATTR_SHOW(runtime);
 EFI_ATTR_SHOW(config_table);
 
+static ssize_t fw_platform_size_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", efi_enabled(EFI_64BIT) ? 64 : 32);
+}
+
 static struct kobj_attribute efi_attr_fw_vendor = __ATTR_RO(fw_vendor);
 static struct kobj_attribute efi_attr_runtime = __ATTR_RO(runtime);
 static struct kobj_attribute efi_attr_config_table = __ATTR_RO(config_table);
+static struct kobj_attribute efi_attr_fw_platform_size =
+	__ATTR_RO(fw_platform_size);
 
 static struct attribute *efi_subsys_attrs[] = {
 	&efi_attr_systab.attr,
 	&efi_attr_fw_vendor.attr,
 	&efi_attr_runtime.attr,
 	&efi_attr_config_table.attr,
+	&efi_attr_fw_platform_size.attr,
 	NULL,
 };
 

commit 7bb68410ef22067b08fd52887875b8f337f89dcc
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Oct 18 15:04:15 2014 +0200

    efi: split off remapping code from efi_config_init()
    
    Split of the remapping code from efi_config_init() so that the caller
    can perform its own remapping. This is necessary to correctly handle
    virtually remapped UEFI memory regions under kexec, as efi.systab will
    have been updated to a virtual address.
    
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 9035c1b74d58..b7ba9d8ec4b0 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -293,29 +293,15 @@ static __init int match_config_table(efi_guid_t *guid,
 	return 0;
 }
 
-int __init efi_config_init(efi_config_table_type_t *arch_tables)
+int __init efi_config_parse_tables(void *config_tables, int count, int sz,
+				   efi_config_table_type_t *arch_tables)
 {
-	void *config_tables, *tablep;
-	int i, sz;
-
-	if (efi_enabled(EFI_64BIT))
-		sz = sizeof(efi_config_table_64_t);
-	else
-		sz = sizeof(efi_config_table_32_t);
-
-	/*
-	 * Let's see what config tables the firmware passed to us.
-	 */
-	config_tables = early_memremap(efi.systab->tables,
-				       efi.systab->nr_tables * sz);
-	if (config_tables == NULL) {
-		pr_err("Could not map Configuration table!\n");
-		return -ENOMEM;
-	}
+	void *tablep;
+	int i;
 
 	tablep = config_tables;
 	pr_info("");
-	for (i = 0; i < efi.systab->nr_tables; i++) {
+	for (i = 0; i < count; i++) {
 		efi_guid_t guid;
 		unsigned long table;
 
@@ -328,8 +314,6 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 			if (table64 >> 32) {
 				pr_cont("\n");
 				pr_err("Table located above 4GB, disabling EFI.\n");
-				early_memunmap(config_tables,
-					       efi.systab->nr_tables * sz);
 				return -EINVAL;
 			}
 #endif
@@ -344,13 +328,37 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 		tablep += sz;
 	}
 	pr_cont("\n");
-	early_memunmap(config_tables, efi.systab->nr_tables * sz);
-
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
-
 	return 0;
 }
 
+int __init efi_config_init(efi_config_table_type_t *arch_tables)
+{
+	void *config_tables;
+	int sz, ret;
+
+	if (efi_enabled(EFI_64BIT))
+		sz = sizeof(efi_config_table_64_t);
+	else
+		sz = sizeof(efi_config_table_32_t);
+
+	/*
+	 * Let's see what config tables the firmware passed to us.
+	 */
+	config_tables = early_memremap(efi.systab->tables,
+				       efi.systab->nr_tables * sz);
+	if (config_tables == NULL) {
+		pr_err("Could not map Configuration table!\n");
+		return -ENOMEM;
+	}
+
+	ret = efi_config_parse_tables(config_tables, efi.systab->nr_tables, sz,
+				      arch_tables);
+
+	early_memunmap(config_tables, efi.systab->nr_tables * sz);
+	return ret;
+}
+
 #ifdef CONFIG_EFI_VARS_MODULE
 static int __init efi_load_efivars(void)
 {

commit 26e022727f5e88c6e5054e14d954425deacbe56a
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Dec 18 16:02:17 2014 +0100

    efi: Rename efi_guid_unparse to efi_guid_to_str
    
    Call it what it does - "unparse" is plain-misleading.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 8590099ac148..ff0bbe383b31 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -272,10 +272,10 @@ static __init int match_config_table(efi_guid_t *guid,
 	int i;
 
 	if (table_types) {
-		efi_guid_unparse(guid, str);
+		efi_guid_to_str(guid, str);
 
 		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
-			efi_guid_unparse(&table_types[i].guid, str);
+			efi_guid_to_str(&table_types[i].guid, str);
 
 			if (!efi_guidcmp(*guid, table_types[i].guid)) {
 				*(table_types[i].ptr) = table;

commit e1ccbbc9d5aa01a6c1c9c78acea6515db4f1be71
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Oct 14 16:34:47 2014 +0200

    efi: dmi: add support for SMBIOS 3.0 UEFI configuration table
    
    This adds support to the UEFI side for detecting the presence of
    a SMBIOS 3.0 64-bit entry point. This allows the actual SMBIOS
    structure table to reside at a physical offset over 4 GB, which
    cannot be supported by the legacy SMBIOS 32-bit entry point.
    
    Since the firmware can legally provide both entry points, store
    the SMBIOS 3.0 entry point in a separate variable, and let the
    DMI decoding layer decide which one will be used.
    
    Tested-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 8590099ac148..9035c1b74d58 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -30,6 +30,7 @@ struct efi __read_mostly efi = {
 	.acpi       = EFI_INVALID_TABLE_ADDR,
 	.acpi20     = EFI_INVALID_TABLE_ADDR,
 	.smbios     = EFI_INVALID_TABLE_ADDR,
+	.smbios3    = EFI_INVALID_TABLE_ADDR,
 	.sal_systab = EFI_INVALID_TABLE_ADDR,
 	.boot_info  = EFI_INVALID_TABLE_ADDR,
 	.hcdp       = EFI_INVALID_TABLE_ADDR,
@@ -86,6 +87,8 @@ static ssize_t systab_show(struct kobject *kobj,
 		str += sprintf(str, "ACPI=0x%lx\n", efi.acpi);
 	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
+	if (efi.smbios3 != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "SMBIOS3=0x%lx\n", efi.smbios3);
 	if (efi.hcdp != EFI_INVALID_TABLE_ADDR)
 		str += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);
 	if (efi.boot_info != EFI_INVALID_TABLE_ADDR)
@@ -260,6 +263,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{MPS_TABLE_GUID, "MPS", &efi.mps},
 	{SAL_SYSTEM_TABLE_GUID, "SALsystab", &efi.sal_systab},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
+	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
 	{NULL_GUID, NULL, NULL},
 };

commit 98d2a6ca14520904a47c46258d3bad02ffcd3f96
Author: Laszlo Ersek <lersek@redhat.com>
Date:   Wed Sep 3 13:32:20 2014 +0200

    efi: Introduce efi_md_typeattr_format()
    
    At the moment, there are three architectures debug-printing the EFI memory
    map at initialization: x86, ia64, and arm64. They all use different format
    strings, plus the EFI memory type and the EFI memory attributes are
    similarly hard to decode for a human reader.
    
    Introduce a helper __init function that formats the memory type and the
    memory attributes in a unified way, to a user-provided character buffer.
    
    The array "memory_type_name" is copied from the arm64 code, temporarily
    duplicating it. The (otherwise optional) braces around each string literal
    in the initializer list are dropped in order to match the kernel coding
    style more closely. The element size is tightened from 32 to 20 bytes
    (maximum actual string length + 1) so that we can derive the field width
    from the element size.
    
    Signed-off-by: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    [ Dropped useless 'register' keyword, which compiler will ignore ]
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cebfa36a27ae..8590099ac148 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -445,3 +445,60 @@ int __init efi_get_fdt_params(struct efi_fdt_params *params, int verbose)
 	return ret;
 }
 #endif /* CONFIG_EFI_PARAMS_FROM_FDT */
+
+static __initdata char memory_type_name[][20] = {
+	"Reserved",
+	"Loader Code",
+	"Loader Data",
+	"Boot Code",
+	"Boot Data",
+	"Runtime Code",
+	"Runtime Data",
+	"Conventional Memory",
+	"Unusable Memory",
+	"ACPI Reclaim Memory",
+	"ACPI Memory NVS",
+	"Memory Mapped I/O",
+	"MMIO Port Space",
+	"PAL Code"
+};
+
+char * __init efi_md_typeattr_format(char *buf, size_t size,
+				     const efi_memory_desc_t *md)
+{
+	char *pos;
+	int type_len;
+	u64 attr;
+
+	pos = buf;
+	if (md->type >= ARRAY_SIZE(memory_type_name))
+		type_len = snprintf(pos, size, "[type=%u", md->type);
+	else
+		type_len = snprintf(pos, size, "[%-*s",
+				    (int)(sizeof(memory_type_name[0]) - 1),
+				    memory_type_name[md->type]);
+	if (type_len >= size)
+		return buf;
+
+	pos += type_len;
+	size -= type_len;
+
+	attr = md->attribute;
+	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
+		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_WP |
+		     EFI_MEMORY_RP | EFI_MEMORY_XP | EFI_MEMORY_RUNTIME))
+		snprintf(pos, size, "|attr=0x%016llx]",
+			 (unsigned long long)attr);
+	else
+		snprintf(pos, size, "|%3s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
+			 attr & EFI_MEMORY_XP      ? "XP"  : "",
+			 attr & EFI_MEMORY_RP      ? "RP"  : "",
+			 attr & EFI_MEMORY_WP      ? "WP"  : "",
+			 attr & EFI_MEMORY_UCE     ? "UCE" : "",
+			 attr & EFI_MEMORY_WB      ? "WB"  : "",
+			 attr & EFI_MEMORY_WT      ? "WT"  : "",
+			 attr & EFI_MEMORY_WC      ? "WC"  : "",
+			 attr & EFI_MEMORY_UC      ? "UC"  : "");
+	return buf;
+}

commit 5ae3683c380e78aebc60d710617ba2c0dccc9e84
Author: Dave Young <dyoung@redhat.com>
Date:   Thu Aug 14 17:15:28 2014 +0800

    efi: Add kernel param efi=noruntime
    
    noefi kernel param means actually disabling efi runtime, Per suggestion
    from Leif Lindholm efi=noruntime should be better. But since noefi is
    already used in X86 thus just adding another param efi=noruntime for
    same purpose.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index c8f01a73edb5..cebfa36a27ae 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -54,6 +54,15 @@ bool efi_runtime_disabled(void)
 	return disable_runtime;
 }
 
+static int __init parse_efi_cmdline(char *str)
+{
+	if (parse_option_str(str, "noruntime"))
+		disable_runtime = true;
+
+	return 0;
+}
+early_param("efi", parse_efi_cmdline);
+
 static struct kobject *efi_kobj;
 static struct kobject *efivars_kobj;
 

commit b2e0a54a1296a91b800f316df7bef7d1905e4fd0
Author: Dave Young <dyoung@redhat.com>
Date:   Thu Aug 14 17:15:26 2014 +0800

    efi: Move noefi early param code out of x86 arch code
    
    noefi param can be used for arches other than X86 later, thus move it
    out of x86 platform code.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 64ecbb501c50..c8f01a73edb5 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -41,6 +41,19 @@ struct efi __read_mostly efi = {
 };
 EXPORT_SYMBOL(efi);
 
+static bool disable_runtime;
+static int __init setup_noefi(char *arg)
+{
+	disable_runtime = true;
+	return 0;
+}
+early_param("noefi", setup_noefi);
+
+bool efi_runtime_disabled(void)
+{
+	return disable_runtime;
+}
+
 static struct kobject *efi_kobj;
 static struct kobject *efivars_kobj;
 

commit 76f09aa464a1913efd596dd0edbf88f932fde08c
Merge: e9c9eecabaa8 99a5603e2a1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 4 17:13:50 2014 -0700

    Merge branch 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI changes from Ingo Molnar:
     "Main changes in this cycle are:
    
       - arm64 efi stub fixes, preservation of FP/SIMD registers across
         firmware calls, and conversion of the EFI stub code into a static
         library - Ard Biesheuvel
    
       - Xen EFI support - Daniel Kiper
    
       - Support for autoloading the efivars driver - Lee, Chun-Yi
    
       - Use the PE/COFF headers in the x86 EFI boot stub to request that
         the stub be loaded with CONFIG_PHYSICAL_ALIGN alignment - Michael
         Brown
    
       - Consolidate all the x86 EFI quirks into one file - Saurabh Tangri
    
       - Additional error logging in x86 EFI boot stub - Ulf Winkelvos
    
       - Support loading initrd above 4G in EFI boot stub - Yinghai Lu
    
       - EFI reboot patches for ACPI hardware reduced platforms"
    
    * 'x86-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      efi/arm64: Handle missing virtual mapping for UEFI System Table
      arch/x86/xen: Silence compiler warnings
      xen: Silence compiler warnings
      x86/efi: Request desired alignment via the PE/COFF headers
      x86/efi: Add better error logging to EFI boot stub
      efi: Autoload efivars
      efi: Update stale locking comment for struct efivars
      arch/x86: Remove efi_set_rtc_mmss()
      arch/x86: Replace plain strings with constants
      xen: Put EFI machinery in place
      xen: Define EFI related stuff
      arch/x86: Remove redundant set_bit(EFI_MEMMAP) call
      arch/x86: Remove redundant set_bit(EFI_SYSTEM_TABLES) call
      efi: Introduce EFI_PARAVIRT flag
      arch/x86: Do not access EFI memory map if it is not available
      efi: Use early_mem*() instead of early_io*()
      arch/ia64: Define early_memunmap()
      x86/reboot: Add EFI reboot quirk for ACPI Hardware Reduced flag
      efi/reboot: Allow powering off machines using EFI
      efi/reboot: Add generic wrapper around EfiResetSystem()
      ...

commit 28d54022e6ff9c16bf4dacb5f64a97443a38caa9
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Wed Jul 9 18:39:29 2014 +0800

    efi: Autoload efivars
    
    The original patch is from Ben Hutchings's contribution to debian
    kernel. Got Ben's permission to remove the code of efi-pstore.c and
    send to linux-efi:
    https://github.com/BlankOn/linux-debian/blob/master/debian/patches/features/all/efi-autoload-efivars.patch
    
    efivars is generally useful to have on EFI systems, and in some cases
    it may be impossible to load it after a kernel upgrade in order to
    complete a boot loader update. At the same time we don't want to waste
    memory on non-EFI systems by making them built-in.
    
    Instead, give them module aliases as if they are platform drivers, and
    register a corresponding platform device whenever EFI runtime services
    are available.  This should trigger udev to load them.
    
    Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index ac88ec05eb70..36ffa1747e84 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -23,6 +23,7 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
 
 struct efi __read_mostly efi = {
 	.mps        = EFI_INVALID_TABLE_ADDR,
@@ -324,6 +325,20 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	return 0;
 }
 
+#ifdef CONFIG_EFI_VARS_MODULE
+static int __init efi_load_efivars(void)
+{
+	struct platform_device *pdev;
+
+	if (!efi_enabled(EFI_RUNTIME_SERVICES))
+		return 0;
+
+	pdev = platform_device_register_simple("efivars", 0, NULL, 0);
+	return IS_ERR(pdev) ? PTR_ERR(pdev) : 0;
+}
+device_initcall(efi_load_efivars);
+#endif
+
 #ifdef CONFIG_EFI_PARAMS_FROM_FDT
 
 #define UEFI_PARAM(name, prop, field)			   \

commit 9f27bc543bdf92e179927037e2ab8ed0261579a9
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Mon Jun 30 19:52:58 2014 +0200

    efi: Introduce EFI_PARAVIRT flag
    
    Introduce EFI_PARAVIRT flag. If it is set then kernel runs
    on EFI platform but it has not direct control on EFI stuff
    like EFI runtime, tables, structures, etc. If not this means
    that Linux Kernel has direct access to EFI infrastructure
    and everything runs as usual.
    
    This functionality is used in Xen dom0 because hypervisor
    has full control on EFI stuff and all calls from dom0 to
    EFI must be requested via special hypercall which in turn
    executes relevant EFI code in behalf of dom0.
    
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 023937a63a48..ac88ec05eb70 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -104,16 +104,19 @@ static struct attribute *efi_subsys_attrs[] = {
 static umode_t efi_attr_is_visible(struct kobject *kobj,
 				   struct attribute *attr, int n)
 {
-	umode_t mode = attr->mode;
-
-	if (attr == &efi_attr_fw_vendor.attr)
-		return (efi.fw_vendor == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
-	else if (attr == &efi_attr_runtime.attr)
-		return (efi.runtime == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
-	else if (attr == &efi_attr_config_table.attr)
-		return (efi.config_table == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
+	if (attr == &efi_attr_fw_vendor.attr) {
+		if (efi_enabled(EFI_PARAVIRT) ||
+				efi.fw_vendor == EFI_INVALID_TABLE_ADDR)
+			return 0;
+	} else if (attr == &efi_attr_runtime.attr) {
+		if (efi.runtime == EFI_INVALID_TABLE_ADDR)
+			return 0;
+	} else if (attr == &efi_attr_config_table.attr) {
+		if (efi.config_table == EFI_INVALID_TABLE_ADDR)
+			return 0;
+	}
 
-	return mode;
+	return attr->mode;
 }
 
 static struct attribute_group efi_subsys_attr_group = {

commit abc93f8eb6e46a480485f19256bdbda36ec78a84
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Mon Jun 30 19:52:56 2014 +0200

    efi: Use early_mem*() instead of early_io*()
    
    Use early_mem*() instead of early_io*() because all mapped EFI regions
    are memory (usually RAM but they could also be ROM, EPROM, EEPROM, flash,
    etc.) not I/O regions. Additionally, I/O family calls do not work correctly
    under Xen in our case. early_ioremap() skips the PFN to MFN conversion
    when building the PTE. Using it for memory will attempt to map the wrong
    machine frame. However, all artificial EFI structures created under Xen
    live in dom0 memory and should be mapped/unmapped using early_mem*() family
    calls which map domain memory.
    
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cd36deb619fa..023937a63a48 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -298,7 +298,7 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 			if (table64 >> 32) {
 				pr_cont("\n");
 				pr_err("Table located above 4GB, disabling EFI.\n");
-				early_iounmap(config_tables,
+				early_memunmap(config_tables,
 					       efi.systab->nr_tables * sz);
 				return -EINVAL;
 			}
@@ -314,7 +314,7 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 		tablep += sz;
 	}
 	pr_cont("\n");
-	early_iounmap(config_tables, efi.systab->nr_tables * sz);
+	early_memunmap(config_tables, efi.systab->nr_tables * sz);
 
 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
 

commit 29e2435fd6d71e0136e2c2ff0433b7dbeeaaccfd
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jul 8 16:54:18 2014 +0100

    efi: fdt: Do not report an error during boot if UEFI is not available
    
    Currently, fdt_find_uefi_params() reports an error if no EFI parameters
    are found in the DT. This is however a valid case for non-UEFI kernel
    booting. This patch checks changes the error reporting to a
    pr_info("UEFI not found") when no EFI parameters are found in the DT.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index eff1a2f22f09..dc79346689e6 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -346,6 +346,7 @@ static __initdata struct {
 
 struct param_info {
 	int verbose;
+	int found;
 	void *params;
 };
 
@@ -362,16 +363,12 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 		return 0;
 
-	pr_info("Getting parameters from FDT:\n");
-
 	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
 		prop = of_get_flat_dt_prop(node, dt_params[i].propname, &len);
-		if (!prop) {
-			pr_err("Can't find %s in device tree!\n",
-			       dt_params[i].name);
+		if (!prop)
 			return 0;
-		}
 		dest = info->params + dt_params[i].offset;
+		info->found++;
 
 		val = of_read_number(prop, len / sizeof(u32));
 
@@ -390,10 +387,21 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 int __init efi_get_fdt_params(struct efi_fdt_params *params, int verbose)
 {
 	struct param_info info;
+	int ret;
+
+	pr_info("Getting EFI parameters from FDT:\n");
 
 	info.verbose = verbose;
+	info.found = 0;
 	info.params = params;
 
-	return of_scan_flat_dt(fdt_find_uefi_params, &info);
+	ret = of_scan_flat_dt(fdt_find_uefi_params, &info);
+	if (!info.found)
+		pr_info("UEFI not found.\n");
+	else if (!ret)
+		pr_err("Can't find '%s' in device tree!\n",
+		       dt_params[info.found].name);
+
+	return ret;
 }
 #endif /* CONFIG_EFI_PARAMS_FROM_FDT */

commit 6fb8cc82c096fd5ccf277678639193cae07125a0
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jun 2 11:31:06 2014 +0100

    efi: Fix compiler warnings (unused, const, type)
    
    This patch fixes a few compiler warning in the efi code for unused
    variable, discarding const qualifier and wrong pointer type:
    
    drivers/firmware/efi/fdt.c|66 col 22| warning: unused variable ‘name’ [-Wunused-variable]
    drivers/firmware/efi/efi.c|368 col 3| warning: passing argument 3 of ‘of_get_flat_dt_prop’ from incompatible pointer type [enabled by default]
    drivers/firmware/efi/efi.c|368 col 8| warning: assignment discards ‘const’ qualifier from pointer target type [enabled by default]
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index cd36deb619fa..eff1a2f22f09 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -353,10 +353,10 @@ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 				       int depth, void *data)
 {
 	struct param_info *info = data;
-	void *prop, *dest;
-	unsigned long len;
+	const void *prop;
+	void *dest;
 	u64 val;
-	int i;
+	int i, len;
 
 	if (depth != 1 ||
 	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))

commit 0302f71c0aa59571ac306f93068fbbfe65ea349b
Author: Mark Salter <msalter@redhat.com>
Date:   Mon Dec 30 12:12:12 2013 -0500

    efi: add helper function to get UEFI params from FDT
    
    ARM and ARM64 architectures use the device tree to pass UEFI parameters
    from stub to kernel. These parameters are things known to the stub but
    not discoverable by the kernel after the stub calls ExitBootSerives().
    There is a helper function in:
    
       drivers/firmware/efi/fdt.c
    
    which the stub uses to add the UEFI parameters to the device tree.
    This patch adds a complimentary helper function which UEFI runtime
    support may use to retrieve the parameters from the device tree.
    If an architecture wants to use this helper, it should select
    CONFIG_EFI_PARAMS_FROM_FDT.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index af20f1712337..cd36deb619fa 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -20,6 +20,8 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/efi.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
 #include <linux/io.h>
 
 struct efi __read_mostly efi = {
@@ -318,3 +320,80 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 
 	return 0;
 }
+
+#ifdef CONFIG_EFI_PARAMS_FROM_FDT
+
+#define UEFI_PARAM(name, prop, field)			   \
+	{						   \
+		{ name },				   \
+		{ prop },				   \
+		offsetof(struct efi_fdt_params, field),    \
+		FIELD_SIZEOF(struct efi_fdt_params, field) \
+	}
+
+static __initdata struct {
+	const char name[32];
+	const char propname[32];
+	int offset;
+	int size;
+} dt_params[] = {
+	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
+	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
+	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
+	UEFI_PARAM("MemMap Desc. Size", "linux,uefi-mmap-desc-size", desc_size),
+	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
+};
+
+struct param_info {
+	int verbose;
+	void *params;
+};
+
+static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
+				       int depth, void *data)
+{
+	struct param_info *info = data;
+	void *prop, *dest;
+	unsigned long len;
+	u64 val;
+	int i;
+
+	if (depth != 1 ||
+	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
+		return 0;
+
+	pr_info("Getting parameters from FDT:\n");
+
+	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
+		prop = of_get_flat_dt_prop(node, dt_params[i].propname, &len);
+		if (!prop) {
+			pr_err("Can't find %s in device tree!\n",
+			       dt_params[i].name);
+			return 0;
+		}
+		dest = info->params + dt_params[i].offset;
+
+		val = of_read_number(prop, len / sizeof(u32));
+
+		if (dt_params[i].size == sizeof(u32))
+			*(u32 *)dest = val;
+		else
+			*(u64 *)dest = val;
+
+		if (info->verbose)
+			pr_info("  %s: 0x%0*llx\n", dt_params[i].name,
+				dt_params[i].size * 2, val);
+	}
+	return 1;
+}
+
+int __init efi_get_fdt_params(struct efi_fdt_params *params, int verbose)
+{
+	struct param_info info;
+
+	info.verbose = verbose;
+	info.params = params;
+
+	return of_scan_flat_dt(fdt_find_uefi_params, &info);
+}
+#endif /* CONFIG_EFI_PARAMS_FROM_FDT */

commit 69e608411473ac56358ef35277563982d0565381
Author: Daeseok Youn <daeseok.youn@gmail.com>
Date:   Thu Feb 13 17:16:36 2014 +0900

    efi: Use NULL instead of 0 for pointer
    
    Fix following sparse warnings:
    
    drivers/firmware/efi/efivars.c:230:66: warning:
     Using plain integer as NULL pointer
    drivers/firmware/efi/efi.c:236:27: warning:
     Using plain integer as NULL pointer
    
    Signed-off-by: Daeseok Youn <daeseok.youn@gmail.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index b25b36b1ef23..af20f1712337 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -233,7 +233,7 @@ static __initdata efi_config_table_type_t common_tables[] = {
 	{SAL_SYSTEM_TABLE_GUID, "SALsystab", &efi.sal_systab},
 	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
-	{NULL_GUID, NULL, 0},
+	{NULL_GUID, NULL, NULL},
 };
 
 static __init int match_config_table(efi_guid_t *guid,

commit 0f8093a92da77afe24fd258a5a1037bb2b97a870
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Jan 15 13:36:33 2014 +0000

    efi: Set feature flags inside feature init functions
    
    It makes more sense to set the feature flag in the success path of the
    detection function than it does to rely on the caller doing it. Apart
    from it being more logical to group the code and data together, it sets
    a much better example for new EFI architectures.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 4753bac65279..b25b36b1ef23 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -313,5 +313,8 @@ int __init efi_config_init(efi_config_table_type_t *arch_tables)
 	}
 	pr_cont("\n");
 	early_iounmap(config_tables, efi.systab->nr_tables * sz);
+
+	set_bit(EFI_CONFIG_TABLES, &efi.flags);
+
 	return 0;
 }

commit 926172d46038d7610b6b8d84e40db727cefb482d
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:18 2013 +0800

    efi: Export EFI runtime memory mapping to sysfs
    
    kexec kernel will need exactly same mapping for EFI runtime memory
    ranges. Thus here export the runtime ranges mapping to sysfs,
    kexec-tools will assemble them and pass to 2nd kernel via setup_data.
    
    Introducing a new directory /sys/firmware/efi/runtime-map just like
    /sys/firmware/memmap. Containing below attribute in each file of that
    directory:
    
    attribute  num_pages  phys_addr  type  virt_addr
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 72533af72b98..4753bac65279 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -167,6 +167,10 @@ static int __init efisubsys_init(void)
 		goto err_unregister;
 	}
 
+	error = efi_runtime_map_init(efi_kobj);
+	if (error)
+		goto err_remove_group;
+
 	/* and the standard mountpoint for efivarfs */
 	efivars_kobj = kobject_create_and_add("efivars", efi_kobj);
 	if (!efivars_kobj) {

commit a0998eb15afeffbf52a2c2829318f67df9ac57b8
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:17 2013 +0800

    efi: Export more EFI table variables to sysfs
    
    Export fw_vendor, runtime and config table physical addresses to
    /sys/firmware/efi/{fw_vendor,runtime,config_table} because kexec kernels
    need them.
    
    From EFI spec these 3 variables will be updated to virtual address after
    entering virtual mode. But kernel startup code will need the physical
    address.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 2e2fbdec0845..72533af72b98 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -32,6 +32,9 @@ struct efi __read_mostly efi = {
 	.hcdp       = EFI_INVALID_TABLE_ADDR,
 	.uga        = EFI_INVALID_TABLE_ADDR,
 	.uv_systab  = EFI_INVALID_TABLE_ADDR,
+	.fw_vendor  = EFI_INVALID_TABLE_ADDR,
+	.runtime    = EFI_INVALID_TABLE_ADDR,
+	.config_table  = EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
@@ -71,13 +74,49 @@ static ssize_t systab_show(struct kobject *kobj,
 static struct kobj_attribute efi_attr_systab =
 			__ATTR(systab, 0400, systab_show, NULL);
 
+#define EFI_FIELD(var) efi.var
+
+#define EFI_ATTR_SHOW(name) \
+static ssize_t name##_show(struct kobject *kobj, \
+				struct kobj_attribute *attr, char *buf) \
+{ \
+	return sprintf(buf, "0x%lx\n", EFI_FIELD(name)); \
+}
+
+EFI_ATTR_SHOW(fw_vendor);
+EFI_ATTR_SHOW(runtime);
+EFI_ATTR_SHOW(config_table);
+
+static struct kobj_attribute efi_attr_fw_vendor = __ATTR_RO(fw_vendor);
+static struct kobj_attribute efi_attr_runtime = __ATTR_RO(runtime);
+static struct kobj_attribute efi_attr_config_table = __ATTR_RO(config_table);
+
 static struct attribute *efi_subsys_attrs[] = {
 	&efi_attr_systab.attr,
-	NULL,	/* maybe more in the future? */
+	&efi_attr_fw_vendor.attr,
+	&efi_attr_runtime.attr,
+	&efi_attr_config_table.attr,
+	NULL,
 };
 
+static umode_t efi_attr_is_visible(struct kobject *kobj,
+				   struct attribute *attr, int n)
+{
+	umode_t mode = attr->mode;
+
+	if (attr == &efi_attr_fw_vendor.attr)
+		return (efi.fw_vendor == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
+	else if (attr == &efi_attr_runtime.attr)
+		return (efi.runtime == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
+	else if (attr == &efi_attr_config_table.attr)
+		return (efi.config_table == EFI_INVALID_TABLE_ADDR) ? 0 : mode;
+
+	return mode;
+}
+
 static struct attribute_group efi_subsys_attr_group = {
 	.attrs = efi_subsys_attrs,
+	.is_visible = efi_attr_is_visible,
 };
 
 static struct efivars generic_efivars;

commit 258f6fd738221766b512cd8c7120563b78d62829
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Sep 5 11:34:55 2013 +0100

    efi: x86: make efi_lookup_mapped_addr() a common function
    
    efi_lookup_mapped_addr() is a handy utility for other platforms than
    x86. Move it from arch/x86 to drivers/firmware. Add memmap pointer
    to global efi structure, and initialise it on x86.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index e1010d450b65..2e2fbdec0845 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -150,6 +150,38 @@ static int __init efisubsys_init(void)
 subsys_initcall(efisubsys_init);
 
 
+/*
+ * We can't ioremap data in EFI boot services RAM, because we've already mapped
+ * it as RAM.  So, look it up in the existing EFI memory map instead.  Only
+ * callable after efi_enter_virtual_mode and before efi_free_boot_services.
+ */
+void __iomem *efi_lookup_mapped_addr(u64 phys_addr)
+{
+	struct efi_memory_map *map;
+	void *p;
+	map = efi.memmap;
+	if (!map)
+		return NULL;
+	if (WARN_ON(!map->map))
+		return NULL;
+	for (p = map->map; p < map->map_end; p += map->desc_size) {
+		efi_memory_desc_t *md = p;
+		u64 size = md->num_pages << EFI_PAGE_SHIFT;
+		u64 end = md->phys_addr + size;
+		if (!(md->attribute & EFI_MEMORY_RUNTIME) &&
+		    md->type != EFI_BOOT_SERVICES_CODE &&
+		    md->type != EFI_BOOT_SERVICES_DATA)
+			continue;
+		if (!md->virt_addr)
+			continue;
+		if (phys_addr >= md->phys_addr && phys_addr < end) {
+			phys_addr += md->virt_addr - md->phys_addr;
+			return (__force void __iomem *)(unsigned long)phys_addr;
+		}
+	}
+	return NULL;
+}
+
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},

commit 272686bf46a34f86d270cf192f68769667792026
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Sep 5 11:34:54 2013 +0100

    efi: x86: ia64: provide a generic efi_config_init()
    
    Common to (U)EFI support on all platforms is the global "efi" data
    structure, and the code that parses the System Table to locate
    addresses to populate that structure with.
    
    This patch adds both of these to the global EFI driver code and
    removes the local definition of the global "efi" data structure from
    the x86 and ia64 code.
    
    Squashed into one big patch to avoid breaking bisection.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 5145fa344ad5..e1010d450b65 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -13,11 +13,27 @@
  * This file is released under the GPLv2.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kobject.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/efi.h>
+#include <linux/io.h>
+
+struct efi __read_mostly efi = {
+	.mps        = EFI_INVALID_TABLE_ADDR,
+	.acpi       = EFI_INVALID_TABLE_ADDR,
+	.acpi20     = EFI_INVALID_TABLE_ADDR,
+	.smbios     = EFI_INVALID_TABLE_ADDR,
+	.sal_systab = EFI_INVALID_TABLE_ADDR,
+	.boot_info  = EFI_INVALID_TABLE_ADDR,
+	.hcdp       = EFI_INVALID_TABLE_ADDR,
+	.uga        = EFI_INVALID_TABLE_ADDR,
+	.uv_systab  = EFI_INVALID_TABLE_ADDR,
+};
+EXPORT_SYMBOL(efi);
 
 static struct kobject *efi_kobj;
 static struct kobject *efivars_kobj;
@@ -132,3 +148,95 @@ static int __init efisubsys_init(void)
 }
 
 subsys_initcall(efisubsys_init);
+
+
+static __initdata efi_config_table_type_t common_tables[] = {
+	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
+	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
+	{HCDP_TABLE_GUID, "HCDP", &efi.hcdp},
+	{MPS_TABLE_GUID, "MPS", &efi.mps},
+	{SAL_SYSTEM_TABLE_GUID, "SALsystab", &efi.sal_systab},
+	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
+	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
+	{NULL_GUID, NULL, 0},
+};
+
+static __init int match_config_table(efi_guid_t *guid,
+				     unsigned long table,
+				     efi_config_table_type_t *table_types)
+{
+	u8 str[EFI_VARIABLE_GUID_LEN + 1];
+	int i;
+
+	if (table_types) {
+		efi_guid_unparse(guid, str);
+
+		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
+			efi_guid_unparse(&table_types[i].guid, str);
+
+			if (!efi_guidcmp(*guid, table_types[i].guid)) {
+				*(table_types[i].ptr) = table;
+				pr_cont(" %s=0x%lx ",
+					table_types[i].name, table);
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int __init efi_config_init(efi_config_table_type_t *arch_tables)
+{
+	void *config_tables, *tablep;
+	int i, sz;
+
+	if (efi_enabled(EFI_64BIT))
+		sz = sizeof(efi_config_table_64_t);
+	else
+		sz = sizeof(efi_config_table_32_t);
+
+	/*
+	 * Let's see what config tables the firmware passed to us.
+	 */
+	config_tables = early_memremap(efi.systab->tables,
+				       efi.systab->nr_tables * sz);
+	if (config_tables == NULL) {
+		pr_err("Could not map Configuration table!\n");
+		return -ENOMEM;
+	}
+
+	tablep = config_tables;
+	pr_info("");
+	for (i = 0; i < efi.systab->nr_tables; i++) {
+		efi_guid_t guid;
+		unsigned long table;
+
+		if (efi_enabled(EFI_64BIT)) {
+			u64 table64;
+			guid = ((efi_config_table_64_t *)tablep)->guid;
+			table64 = ((efi_config_table_64_t *)tablep)->table;
+			table = table64;
+#ifndef CONFIG_64BIT
+			if (table64 >> 32) {
+				pr_cont("\n");
+				pr_err("Table located above 4GB, disabling EFI.\n");
+				early_iounmap(config_tables,
+					       efi.systab->nr_tables * sz);
+				return -EINVAL;
+			}
+#endif
+		} else {
+			guid = ((efi_config_table_32_t *)tablep)->guid;
+			table = ((efi_config_table_32_t *)tablep)->table;
+		}
+
+		if (!match_config_table(&guid, table, common_tables))
+			match_config_table(&guid, table, arch_tables);
+
+		tablep += sz;
+	}
+	pr_cont("\n");
+	early_iounmap(config_tables, efi.systab->nr_tables * sz);
+	return 0;
+}

commit a614e1923d5389d01f3545ee4a90e39a04d0c90d
Merge: f53f292eeaa2 c1be5a5b1b35
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Apr 30 11:30:24 2013 +0100

    Merge tag 'v3.9' into efi-for-tip2
    
    Resolve conflicts for Ingo.
    
    Conflicts:
            drivers/firmware/Kconfig
            drivers/firmware/efivars.c
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

commit a9499fa7cd3fd4824a7202d00c766b269fa3bda6
Author: Tom Gundersen <teg@jklm.no>
Date:   Fri Feb 8 15:37:06 2013 +0000

    efi: split efisubsystem from efivars
    
    This registers /sys/firmware/efi/{,systab,efivars/} whenever EFI is enabled
    and the system is booted with EFI.
    
    This allows
     *) userspace to check for the existence of /sys/firmware/efi as a way
        to determine whether or it is running on an EFI system.
     *) 'mount -t efivarfs none /sys/firmware/efi/efivars' without manually
        loading any modules.
    
    [ Also, move the efivar API into vars.c and unconditionally compile it.
      This allows us to move efivars.c, which now only contains the sysfs
      variable code, into the firmware/efi directory. Note that the efivars.c
      filename is kept to maintain backwards compatability with the old
      efivars.ko module. With this patch it is now possible for efivarfs
      to be built without CONFIG_EFI_VARS - Matt ]
    
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Mike Waychison <mikew@google.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Chun-Yi Lee <jlee@suse.com>
    Cc: Andy Whitcroft <apw@canonical.com>
    Cc: Tobias Powalowski <tpowa@archlinux.org>
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
new file mode 100644
index 000000000000..32bdf4f8e432
--- /dev/null
+++ b/drivers/firmware/efi/efi.c
@@ -0,0 +1,134 @@
+/*
+ * efi.c - EFI subsystem
+ *
+ * Copyright (C) 2001,2003,2004 Dell <Matt_Domsch@dell.com>
+ * Copyright (C) 2004 Intel Corporation <matthew.e.tolentino@intel.com>
+ * Copyright (C) 2013 Tom Gundersen <teg@jklm.no>
+ *
+ * This code registers /sys/firmware/efi{,/efivars} when EFI is supported,
+ * allowing the efivarfs to be mounted or the efivars module to be loaded.
+ * The existance of /sys/firmware/efi may also be used by userspace to
+ * determine that the system supports EFI.
+ *
+ * This file is released under the GPLv2.
+ */
+
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/efi.h>
+
+static struct kobject *efi_kobj;
+static struct kobject *efivars_kobj;
+
+/*
+ * Let's not leave out systab information that snuck into
+ * the efivars driver
+ */
+static ssize_t systab_show(struct kobject *kobj,
+			   struct kobj_attribute *attr, char *buf)
+{
+	char *str = buf;
+
+	if (!kobj || !buf)
+		return -EINVAL;
+
+	if (efi.mps != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "MPS=0x%lx\n", efi.mps);
+	if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "ACPI20=0x%lx\n", efi.acpi20);
+	if (efi.acpi != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "ACPI=0x%lx\n", efi.acpi);
+	if (efi.smbios != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);
+	if (efi.hcdp != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);
+	if (efi.boot_info != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "BOOTINFO=0x%lx\n", efi.boot_info);
+	if (efi.uga != EFI_INVALID_TABLE_ADDR)
+		str += sprintf(str, "UGA=0x%lx\n", efi.uga);
+
+	return str - buf;
+}
+
+static struct kobj_attribute efi_attr_systab =
+			__ATTR(systab, 0400, systab_show, NULL);
+
+static struct attribute *efi_subsys_attrs[] = {
+	&efi_attr_systab.attr,
+	NULL,	/* maybe more in the future? */
+};
+
+static struct attribute_group efi_subsys_attr_group = {
+	.attrs = efi_subsys_attrs,
+};
+
+static struct efivars generic_efivars;
+static struct efivar_operations generic_ops;
+
+static int generic_ops_register(void)
+{
+	generic_ops.get_variable = efi.get_variable;
+	generic_ops.set_variable = efi.set_variable;
+	generic_ops.get_next_variable = efi.get_next_variable;
+	generic_ops.query_variable_info = efi.query_variable_info;
+
+	return efivars_register(&generic_efivars, &generic_ops, efi_kobj);
+}
+
+static void generic_ops_unregister(void)
+{
+	efivars_unregister(&generic_efivars);
+}
+
+/*
+ * We register the efi subsystem with the firmware subsystem and the
+ * efivars subsystem with the efi subsystem, if the system was booted with
+ * EFI.
+ */
+static int __init efisubsys_init(void)
+{
+	int error;
+
+	if (!efi_enabled(EFI_BOOT))
+		return 0;
+
+	/* We register the efi directory at /sys/firmware/efi */
+	efi_kobj = kobject_create_and_add("efi", firmware_kobj);
+	if (!efi_kobj) {
+		pr_err("efi: Firmware registration failed.\n");
+		return -ENOMEM;
+	}
+
+	error = generic_ops_register();
+	if (error)
+		goto err_put;
+
+	error = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);
+	if (error) {
+		pr_err("efi: Sysfs attribute export failed with error %d.\n",
+		       error);
+		goto err_unregister;
+	}
+
+	/* and the standard mountpoint for efivarfs */
+	efivars_kobj = kobject_create_and_add("efivars", efi_kobj);
+	if (!efivars_kobj) {
+		pr_err("efivars: Subsystem registration failed.\n");
+		error = -ENOMEM;
+		goto err_remove_group;
+	}
+
+	return 0;
+
+err_remove_group:
+	sysfs_remove_group(efi_kobj, &efi_subsys_attr_group);
+err_unregister:
+	generic_ops_unregister();
+err_put:
+	kobject_put(efi_kobj);
+	return error;
+}
+
+subsys_initcall(efisubsys_init);
