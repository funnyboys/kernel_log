commit 2a55280a3675203496d302463b941834228b9875
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jun 7 15:41:35 2020 +0200

    efi/libstub: arm: Print CPU boot mode and MMU state at boot
    
    On 32-bit ARM, we may boot at HYP mode, or with the MMU and caches off
    (or both), even though the EFI spec does not actually support this.
    While booting at HYP mode is something we might tolerate, fiddling
    with the caches is a more serious issue, as disabling the caches is
    tricky to do safely from C code, and running without the Dcache makes
    it impossible to support unaligned memory accesses, which is another
    explicit requirement imposed by the EFI spec.
    
    So take note of the CPU mode and MMU state in the EFI stub diagnostic
    output so that we can easily diagnose any issues that may arise from
    this. E.g.,
    
      EFI stub: Entering in SVC mode with MMU enabled
    
    Also, capture the CPSR and SCTLR system register values at EFI stub
    entry, and after ExitBootServices() returns, and check whether the
    MMU and Dcache were disabled at any point. If this is the case, a
    diagnostic message like the following will be emitted:
    
      efi: [Firmware Bug]: EFI stub was entered with MMU and Dcache disabled, please fix your firmware!
      efi: CPSR at EFI stub entry        : 0x600001d3
      efi: SCTLR at EFI stub entry       : 0x00c51838
      efi: CPSR after ExitBootServices() : 0x600001d3
      efi: SCTLR after ExitBootServices(): 0x00c50838
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Leif Lindholm <leif@nuviainc.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 6f4baf70db16..71c445d20258 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -52,9 +52,11 @@ static phys_addr_t __init efi_to_phys(unsigned long addr)
 }
 
 static __initdata unsigned long screen_info_table = EFI_INVALID_TABLE_ADDR;
+static __initdata unsigned long cpu_state_table = EFI_INVALID_TABLE_ADDR;
 
 static const efi_config_table_type_t arch_tables[] __initconst = {
 	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, &screen_info_table},
+	{LINUX_EFI_ARM_CPU_STATE_TABLE_GUID, &cpu_state_table},
 	{}
 };
 
@@ -240,9 +242,37 @@ void __init efi_init(void)
 
 	init_screen_info();
 
+#ifdef CONFIG_ARM
 	/* ARM does not permit early mappings to persist across paging_init() */
-	if (IS_ENABLED(CONFIG_ARM))
-		efi_memmap_unmap();
+	efi_memmap_unmap();
+
+	if (cpu_state_table != EFI_INVALID_TABLE_ADDR) {
+		struct efi_arm_entry_state *state;
+		bool dump_state = true;
+
+		state = early_memremap_ro(cpu_state_table,
+					  sizeof(struct efi_arm_entry_state));
+		if (state == NULL) {
+			pr_warn("Unable to map CPU entry state table.\n");
+			return;
+		}
+
+		if ((state->sctlr_before_ebs & 1) == 0)
+			pr_warn(FW_BUG "EFI stub was entered with MMU and Dcache disabled, please fix your firmware!\n");
+		else if ((state->sctlr_after_ebs & 1) == 0)
+			pr_warn(FW_BUG "ExitBootServices() returned with MMU and Dcache disabled, please fix your firmware!\n");
+		else
+			dump_state = false;
+
+		if (dump_state || efi_enabled(EFI_DBG)) {
+			pr_info("CPSR at EFI stub entry        : 0x%08x\n", state->cpsr_before_ebs);
+			pr_info("SCTLR at EFI stub entry       : 0x%08x\n", state->sctlr_before_ebs);
+			pr_info("CPSR after ExitBootServices() : 0x%08x\n", state->cpsr_after_ebs);
+			pr_info("SCTLR after ExitBootServices(): 0x%08x\n", state->sctlr_after_ebs);
+		}
+		early_memunmap(state, sizeof(struct efi_arm_entry_state));
+	}
+#endif
 }
 
 static bool efifb_overlaps_pci_range(const struct of_pci_range *range)

commit 62956be8f95b93e9f91ffe2e5aa9c0e411af5a14
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jun 16 12:53:30 2020 +0200

    efi/libstub: arm: Omit arch specific config table matching array on arm64
    
    On arm64, the EFI stub is built into the kernel proper, and so the stub
    can refer to its symbols directly. Therefore, the practice of using EFI
    configuration tables to pass information between them is never needed,
    so we can omit any code consuming such tables when building for arm64.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Leif Lindholm <leif@nuviainc.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index c697e70ca7e7..6f4baf70db16 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -62,7 +62,8 @@ static void __init init_screen_info(void)
 {
 	struct screen_info *si;
 
-	if (screen_info_table != EFI_INVALID_TABLE_ADDR) {
+	if (IS_ENABLED(CONFIG_ARM) &&
+	    screen_info_table != EFI_INVALID_TABLE_ADDR) {
 		si = early_memremap_ro(screen_info_table, sizeof(*si));
 		if (!si) {
 			pr_err("Could not map screen_info config table\n");
@@ -116,7 +117,8 @@ static int __init uefi_init(u64 efi_system_table)
 		goto out;
 	}
 	retval = efi_config_parse_tables(config_tables, systab->nr_tables,
-					 arch_tables);
+					 IS_ENABLED(CONFIG_ARM) ? arch_tables
+								: NULL);
 
 	early_memunmap(config_tables, table_size);
 out:

commit 4e9a0f73f030e19a9259b69a7079021048e1f904
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Mar 26 09:24:14 2020 +0100

    efi: Clean up config table description arrays
    
    Increase legibility by adding whitespace to the efi_config_table_type_t
    arrays that describe which EFI config tables we look for when going over
    the firmware provided list. While at it, replace the 'name' char pointer
    with a char array, which is more space efficient on relocatable 64-bit
    kernels, as it avoids a 8 byte pointer and the associated relocation
    data (24 bytes when using RELA format)
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 9e5e62f5f94d..c697e70ca7e7 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -54,8 +54,8 @@ static phys_addr_t __init efi_to_phys(unsigned long addr)
 static __initdata unsigned long screen_info_table = EFI_INVALID_TABLE_ADDR;
 
 static const efi_config_table_type_t arch_tables[] __initconst = {
-	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, NULL, &screen_info_table},
-	{NULL_GUID, NULL, NULL}
+	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, &screen_info_table},
+	{}
 };
 
 static void __init init_screen_info(void)

commit a776c270a0b2fad6715cb714187e4290cadb9237
Merge: 7c4fa150714f 594e576d4b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 16:13:08 2020 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The EFI changes in this cycle are much larger than usual, for two
      (positive) reasons:
    
       - The GRUB project is showing signs of life again, resulting in the
         introduction of the generic Linux/UEFI boot protocol, instead of
         x86 specific hacks which are increasingly difficult to maintain.
         There's hope that all future extensions will now go through that
         boot protocol.
    
       - Preparatory work for RISC-V EFI support.
    
      The main changes are:
    
       - Boot time GDT handling changes
    
       - Simplify handling of EFI properties table on arm64
    
       - Generic EFI stub cleanups, to improve command line handling, file
         I/O, memory allocation, etc.
    
       - Introduce a generic initrd loading method based on calling back
         into the firmware, instead of relying on the x86 EFI handover
         protocol or device tree.
    
       - Introduce a mixed mode boot method that does not rely on the x86
         EFI handover protocol either, and could potentially be adopted by
         other architectures (if another one ever surfaces where one
         execution mode is a superset of another)
    
       - Clean up the contents of 'struct efi', and move out everything that
         doesn't need to be stored there.
    
       - Incorporate support for UEFI spec v2.8A changes that permit
         firmware implementations to return EFI_UNSUPPORTED from UEFI
         runtime services at OS runtime, and expose a mask of which ones are
         supported or unsupported via a configuration table.
    
       - Partial fix for the lack of by-VA cache maintenance in the
         decompressor on 32-bit ARM.
    
       - Changes to load device firmware from EFI boot service memory
         regions
    
       - Various documentation updates and minor code cleanups and fixes"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      efi/libstub/arm: Fix spurious message that an initrd was loaded
      efi/libstub/arm64: Avoid image_base value from efi_loaded_image
      partitions/efi: Fix partition name parsing in GUID partition entry
      efi/x86: Fix cast of image argument
      efi/libstub/x86: Use ULONG_MAX as upper bound for all allocations
      efi: Fix a mistype in comments mentioning efivar_entry_iter_begin()
      efi/libstub: Avoid linking libstub/lib-ksyms.o into vmlinux
      efi/x86: Preserve %ebx correctly in efi_set_virtual_address_map()
      efi/x86: Ignore the memory attributes table on i386
      efi/x86: Don't relocate the kernel unless necessary
      efi/x86: Remove extra headroom for setup block
      efi/x86: Add kernel preferred address to PE header
      efi/x86: Decompress at start of PE image load address
      x86/boot/compressed/32: Save the output address instead of recalculating it
      efi/libstub/x86: Deal with exit() boot service returning
      x86/boot: Use unsigned comparison for addresses
      efi/x86: Avoid using code32_start
      efi/x86: Make efi32_pe_entry() more readable
      efi/x86: Respect 32-bit ABI in efi32_pe_entry()
      efi/x86: Annotate the LOADED_IMAGE_PROTOCOL_GUID with SYM_DATA
      ...

commit 35223d15f32a097b3529cfb31766e27759682af0
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:36 2020 -0800

    efi/arm: Start using fw_devlink_get_flags()
    
    The fw_devlink_get_flags() provides the right flags to use when creating
    mandatory device links derived from information provided by the
    firmware. So, use that.
    
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index d99f5b0c8a09..6703bedfa9e1 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -349,7 +349,7 @@ static int efifb_add_links(const struct fwnode_handle *fwnode,
 	 * If this fails, retrying this function at a later point won't
 	 * change anything. So, don't return an error after this.
 	 */
-	if (!device_link_add(dev, sup_dev, 0))
+	if (!device_link_add(dev, sup_dev, fw_devlink_get_flags()))
 		dev_warn(dev, "device_link_add() failed\n");
 
 	put_device(sup_dev);

commit 3b2e4b4c634cc7dd4730ce3e1c75b8206dcc4b04
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Feb 18 10:19:34 2020 +0100

    efi/arm: Move FDT specific definitions into fdtparams.c
    
    Push the FDT params specific types and definition into fdtparams.c,
    and instead, pass a reference to the memory map data structure and
    populate it directly, and return the system table address as the
    return value.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 76bf5b22e49e..2791a8048f30 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -205,17 +205,13 @@ static __init void reserve_regions(void)
 void __init efi_init(void)
 {
 	struct efi_memory_map_data data;
-	struct efi_fdt_params params;
+	u64 efi_system_table;
 
 	/* Grab UEFI information placed in FDT by stub */
-	if (!efi_get_fdt_params(&params))
+	efi_system_table = efi_get_fdt_params(&data);
+	if (!efi_system_table)
 		return;
 
-	data.desc_version = params.desc_ver;
-	data.desc_size = params.desc_size;
-	data.size = params.mmap_size;
-	data.phys_map = params.mmap;
-
 	if (efi_memmap_init_early(&data) < 0) {
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only
@@ -229,7 +225,7 @@ void __init efi_init(void)
 	     "Unexpected EFI_MEMORY_DESCRIPTOR version %ld",
 	      efi.memmap.desc_version);
 
-	if (uefi_init(params.system_table) < 0) {
+	if (uefi_init(efi_system_table) < 0) {
 		efi_memmap_unmap();
 		return;
 	}
@@ -237,9 +233,8 @@ void __init efi_init(void)
 	reserve_regions();
 	efi_esrt_init();
 
-	memblock_reserve(params.mmap & PAGE_MASK,
-			 PAGE_ALIGN(params.mmap_size +
-				    (params.mmap & ~PAGE_MASK)));
+	memblock_reserve(data.phys_map & PAGE_MASK,
+			 PAGE_ALIGN(data.size + (data.phys_map & ~PAGE_MASK)));
 
 	init_screen_info();
 

commit 8819ba39661efec88efd11610988424cb1bf99f8
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:39:39 2020 +0100

    efi/arm: Drop unnecessary references to efi.systab
    
    Instead of populating efi.systab very early during efi_init() with
    a mapping that is released again before the function exits, use a
    local variable here. Now that we use efi.runtime to access the runtime
    services table, this removes the only reference efi.systab, so there is
    no need to populate it anymore, or discover its virtually remapped
    address. So drop the references entirely.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 77048f7a9659..76bf5b22e49e 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -22,8 +22,6 @@
 
 #include <asm/efi.h>
 
-u64 efi_system_table;
-
 static int __init is_memory(efi_memory_desc_t *md)
 {
 	if (md->attribute & (EFI_MEMORY_WB|EFI_MEMORY_WT|EFI_MEMORY_WC))
@@ -36,7 +34,7 @@ static int __init is_memory(efi_memory_desc_t *md)
  * as some data members of the EFI system table are virtually remapped after
  * SetVirtualAddressMap() has been called.
  */
-static phys_addr_t efi_to_phys(unsigned long addr)
+static phys_addr_t __init efi_to_phys(unsigned long addr)
 {
 	efi_memory_desc_t *md;
 
@@ -83,15 +81,15 @@ static void __init init_screen_info(void)
 		memblock_mark_nomap(screen_info.lfb_base, screen_info.lfb_size);
 }
 
-static int __init uefi_init(void)
+static int __init uefi_init(u64 efi_system_table)
 {
 	efi_config_table_t *config_tables;
+	efi_system_table_t *systab;
 	size_t table_size;
 	int retval;
 
-	efi.systab = early_memremap_ro(efi_system_table,
-				       sizeof(efi_system_table_t));
-	if (efi.systab == NULL) {
+	systab = early_memremap_ro(efi_system_table, sizeof(efi_system_table_t));
+	if (systab == NULL) {
 		pr_warn("Unable to map EFI system table.\n");
 		return -ENOMEM;
 	}
@@ -100,30 +98,29 @@ static int __init uefi_init(void)
 	if (IS_ENABLED(CONFIG_64BIT))
 		set_bit(EFI_64BIT, &efi.flags);
 
-	retval = efi_systab_check_header(&efi.systab->hdr, 2);
+	retval = efi_systab_check_header(&systab->hdr, 2);
 	if (retval)
 		goto out;
 
-	efi.runtime = efi.systab->runtime;
-	efi.runtime_version = efi.systab->hdr.revision;
+	efi.runtime = systab->runtime;
+	efi.runtime_version = systab->hdr.revision;
 
-	efi_systab_report_header(&efi.systab->hdr,
-				 efi_to_phys(efi.systab->fw_vendor));
+	efi_systab_report_header(&systab->hdr, efi_to_phys(systab->fw_vendor));
 
-	table_size = sizeof(efi_config_table_64_t) * efi.systab->nr_tables;
-	config_tables = early_memremap_ro(efi_to_phys(efi.systab->tables),
+	table_size = sizeof(efi_config_table_t) * systab->nr_tables;
+	config_tables = early_memremap_ro(efi_to_phys(systab->tables),
 					  table_size);
 	if (config_tables == NULL) {
 		pr_warn("Unable to map EFI config table array.\n");
 		retval = -ENOMEM;
 		goto out;
 	}
-	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
+	retval = efi_config_parse_tables(config_tables, systab->nr_tables,
 					 arch_tables);
 
 	early_memunmap(config_tables, table_size);
 out:
-	early_memunmap(efi.systab,  sizeof(efi_system_table_t));
+	early_memunmap(systab, sizeof(efi_system_table_t));
 	return retval;
 }
 
@@ -214,8 +211,6 @@ void __init efi_init(void)
 	if (!efi_get_fdt_params(&params))
 		return;
 
-	efi_system_table = params.system_table;
-
 	data.desc_version = params.desc_ver;
 	data.desc_size = params.desc_size;
 	data.size = params.mmap_size;
@@ -234,7 +229,7 @@ void __init efi_init(void)
 	     "Unexpected EFI_MEMORY_DESCRIPTOR version %ld",
 	      efi.memmap.desc_version);
 
-	if (uefi_init() < 0) {
+	if (uefi_init(params.system_table) < 0) {
 		efi_memmap_unmap();
 		return;
 	}

commit 59f2a619a2db86111e8bb30f349aebff6eb75baa
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 09:44:43 2020 +0100

    efi: Add 'runtime' pointer to struct efi
    
    Instead of going through the EFI system table each time, just copy the
    runtime services table pointer into struct efi directly. This is the
    last use of the system table pointer in struct efi, allowing us to
    drop it in a future patch, along with a fair amount of quirky handling
    of the translated address.
    
    Note that usually, the runtime services pointer changes value during
    the call to SetVirtualAddressMap(), so grab the updated value as soon
    as that call returns. (Mixed mode uses a 1:1 mapping, and kexec boot
    enters with the updated address in the system table, so in those cases,
    we don't need to do anything here)
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 5fc2f6813b84..77048f7a9659 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -104,6 +104,7 @@ static int __init uefi_init(void)
 	if (retval)
 		goto out;
 
+	efi.runtime = efi.systab->runtime;
 	efi.runtime_version = efi.systab->hdr.revision;
 
 	efi_systab_report_header(&efi.systab->hdr,

commit 9cd437ac0ef4f324a92e2579784b03bb487ae7fb
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:23:21 2020 +0100

    efi/x86: Make fw_vendor, config_table and runtime sysfs nodes x86 specific
    
    There is some code that exposes physical addresses of certain parts of
    the EFI firmware implementation via sysfs nodes. These nodes are only
    used on x86, and are of dubious value to begin with, so let's move
    their handling into the x86 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index d1f44c847841..5fc2f6813b84 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -120,9 +120,6 @@ static int __init uefi_init(void)
 	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
 					 arch_tables);
 
-	if (!retval)
-		efi.config_table = (unsigned long)efi.systab->tables;
-
 	early_memunmap(config_tables, table_size);
 out:
 	early_memunmap(efi.systab,  sizeof(efi_system_table_t));

commit 06c0bd93434c5b9b284773f90bb054aff591d5be
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 14:40:57 2020 +0100

    efi: Clean up config_parse_tables()
    
    config_parse_tables() is a jumble of pointer arithmetic, due to the
    fact that on x86, we may be dealing with firmware whose native word
    size differs from the kernel's.
    
    This is not a concern on other architectures, and doesn't quite
    justify the state of the code, so let's clean it up by adding a
    non-x86 code path, constifying statically allocated tables and
    replacing preprocessor conditionals with IS_ENABLED() checks.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index a656bfcd7e27..d1f44c847841 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -55,7 +55,7 @@ static phys_addr_t efi_to_phys(unsigned long addr)
 
 static __initdata unsigned long screen_info_table = EFI_INVALID_TABLE_ADDR;
 
-static __initdata efi_config_table_type_t arch_tables[] = {
+static const efi_config_table_type_t arch_tables[] __initconst = {
 	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, NULL, &screen_info_table},
 	{NULL_GUID, NULL, NULL}
 };
@@ -85,7 +85,7 @@ static void __init init_screen_info(void)
 
 static int __init uefi_init(void)
 {
-	void *config_tables;
+	efi_config_table_t *config_tables;
 	size_t table_size;
 	int retval;
 
@@ -118,7 +118,6 @@ static int __init uefi_init(void)
 		goto out;
 	}
 	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
-					 sizeof(efi_config_table_t),
 					 arch_tables);
 
 	if (!retval)

commit 14fb4209094355928d5a742e35afabdf7b404c17
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 10:49:11 2020 +0100

    efi: Merge EFI system table revision and vendor checks
    
    We have three different versions of the code that checks the EFI system
    table revision and copies the firmware vendor string, and they are
    mostly equivalent, with the exception of the use of early_memremap_ro
    vs. __va() and the lowest major revision to warn about. Let's move this
    into common code and factor out the commonalities.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index d99f5b0c8a09..a656bfcd7e27 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -85,11 +85,9 @@ static void __init init_screen_info(void)
 
 static int __init uefi_init(void)
 {
-	efi_char16_t *c16;
 	void *config_tables;
 	size_t table_size;
-	char vendor[100] = "unknown";
-	int i, retval;
+	int retval;
 
 	efi.systab = early_memremap_ro(efi_system_table,
 				       sizeof(efi_system_table_t));
@@ -102,34 +100,14 @@ static int __init uefi_init(void)
 	if (IS_ENABLED(CONFIG_64BIT))
 		set_bit(EFI_64BIT, &efi.flags);
 
-	/*
-	 * Verify the EFI Table
-	 */
-	if (efi.systab->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE) {
-		pr_err("System table signature incorrect\n");
-		retval = -EINVAL;
+	retval = efi_systab_check_header(&efi.systab->hdr, 2);
+	if (retval)
 		goto out;
-	}
-	if ((efi.systab->hdr.revision >> 16) < 2)
-		pr_warn("Warning: EFI system table version %d.%02d, expected 2.00 or greater\n",
-			efi.systab->hdr.revision >> 16,
-			efi.systab->hdr.revision & 0xffff);
 
 	efi.runtime_version = efi.systab->hdr.revision;
 
-	/* Show what we know for posterity */
-	c16 = early_memremap_ro(efi_to_phys(efi.systab->fw_vendor),
-				sizeof(vendor) * sizeof(efi_char16_t));
-	if (c16) {
-		for (i = 0; i < (int) sizeof(vendor) - 1 && *c16; ++i)
-			vendor[i] = c16[i];
-		vendor[i] = '\0';
-		early_memunmap(c16, sizeof(vendor) * sizeof(efi_char16_t));
-	}
-
-	pr_info("EFI v%u.%.02u by %s\n",
-		efi.systab->hdr.revision >> 16,
-		efi.systab->hdr.revision & 0xffff, vendor);
+	efi_systab_report_header(&efi.systab->hdr,
+				 efi_to_phys(efi.systab->fw_vendor));
 
 	table_size = sizeof(efi_config_table_64_t) * efi.systab->nr_tables;
 	config_tables = early_memremap_ro(efi_to_phys(efi.systab->tables),

commit 64c8a0cd0a535891d5905c3a1651150f0f141439
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 13 18:22:40 2020 +0100

    efi/arm: Defer probe of PCIe backed efifb on DT systems
    
    The new of_devlink support breaks PCIe probing on ARM platforms booting
    via UEFI if the firmware exposes a EFI framebuffer that is backed by a
    PCI device. The reason is that the probing order gets reversed,
    resulting in a resource conflict on the framebuffer memory window when
    the PCIe probes last, causing it to give up entirely.
    
    Given that we rely on PCI quirks to deal with EFI framebuffers that get
    moved around in memory, we cannot simply drop the memory reservation, so
    instead, let's use the device link infrastructure to register this
    dependency, and force the probing to occur in the expected order.
    
    Co-developed-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-9-ardb@kernel.org

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 904fa09e6a6b..d99f5b0c8a09 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -10,10 +10,12 @@
 #define pr_fmt(fmt)	"efi: " fmt
 
 #include <linux/efi.h>
+#include <linux/fwnode.h>
 #include <linux/init.h>
 #include <linux/memblock.h>
 #include <linux/mm_types.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_fdt.h>
 #include <linux/platform_device.h>
 #include <linux/screen_info.h>
@@ -276,15 +278,112 @@ void __init efi_init(void)
 		efi_memmap_unmap();
 }
 
+static bool efifb_overlaps_pci_range(const struct of_pci_range *range)
+{
+	u64 fb_base = screen_info.lfb_base;
+
+	if (screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE)
+		fb_base |= (u64)(unsigned long)screen_info.ext_lfb_base << 32;
+
+	return fb_base >= range->cpu_addr &&
+	       fb_base < (range->cpu_addr + range->size);
+}
+
+static struct device_node *find_pci_overlap_node(void)
+{
+	struct device_node *np;
+
+	for_each_node_by_type(np, "pci") {
+		struct of_pci_range_parser parser;
+		struct of_pci_range range;
+		int err;
+
+		err = of_pci_range_parser_init(&parser, np);
+		if (err) {
+			pr_warn("of_pci_range_parser_init() failed: %d\n", err);
+			continue;
+		}
+
+		for_each_of_pci_range(&parser, &range)
+			if (efifb_overlaps_pci_range(&range))
+				return np;
+	}
+	return NULL;
+}
+
+/*
+ * If the efifb framebuffer is backed by a PCI graphics controller, we have
+ * to ensure that this relation is expressed using a device link when
+ * running in DT mode, or the probe order may be reversed, resulting in a
+ * resource reservation conflict on the memory window that the efifb
+ * framebuffer steals from the PCIe host bridge.
+ */
+static int efifb_add_links(const struct fwnode_handle *fwnode,
+			   struct device *dev)
+{
+	struct device_node *sup_np;
+	struct device *sup_dev;
+
+	sup_np = find_pci_overlap_node();
+
+	/*
+	 * If there's no PCI graphics controller backing the efifb, we are
+	 * done here.
+	 */
+	if (!sup_np)
+		return 0;
+
+	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
+	of_node_put(sup_np);
+
+	/*
+	 * Return -ENODEV if the PCI graphics controller device hasn't been
+	 * registered yet.  This ensures that efifb isn't allowed to probe
+	 * and this function is retried again when new devices are
+	 * registered.
+	 */
+	if (!sup_dev)
+		return -ENODEV;
+
+	/*
+	 * If this fails, retrying this function at a later point won't
+	 * change anything. So, don't return an error after this.
+	 */
+	if (!device_link_add(dev, sup_dev, 0))
+		dev_warn(dev, "device_link_add() failed\n");
+
+	put_device(sup_dev);
+
+	return 0;
+}
+
+static const struct fwnode_operations efifb_fwnode_ops = {
+	.add_links = efifb_add_links,
+};
+
+static struct fwnode_handle efifb_fwnode = {
+	.ops = &efifb_fwnode_ops,
+};
+
 static int __init register_gop_device(void)
 {
-	void *pd;
+	struct platform_device *pd;
+	int err;
 
 	if (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)
 		return 0;
 
-	pd = platform_device_register_data(NULL, "efi-framebuffer", 0,
-					   &screen_info, sizeof(screen_info));
-	return PTR_ERR_OR_ZERO(pd);
+	pd = platform_device_alloc("efi-framebuffer", 0);
+	if (!pd)
+		return -ENOMEM;
+
+	if (IS_ENABLED(CONFIG_PCI))
+		pd->dev.fwnode = &efifb_fwnode;
+
+	err = platform_device_add_data(pd, &screen_info, sizeof(screen_info));
+	if (err)
+		return err;
+
+	return platform_device_add(pd);
 }
 subsys_initcall(register_gop_device);

commit 16993c0f0a43213e23666ea40e9163887f593ac7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:21 2019 -0800

    arm/efi: EFI soft reservation to memblock
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose".
    
    The proposed Linux behavior for specific purpose memory is that it is
    reserved for direct-access (device-dax) by default and not available for
    any kernel usage, not even as an OOM fallback.  Later, through udev
    scripts or another init mechanism, these device-dax claimed ranges can
    be reconfigured and hot-added to the available System-RAM with a unique
    node identifier. This device-dax management scheme implements "soft" in
    the "soft reserved" designation by allowing some or all of the
    reservation to be recovered as typical memory. This policy can be
    disabled at compile-time with CONFIG_EFI_SOFT_RESERVE=n, or runtime with
    efi=nosoftreserve.
    
    For this patch, update the ARM paths that consider
    EFI_CONVENTIONAL_MEMORY to optionally take the EFI_MEMORY_SP attribute
    into account as a reservation indicator. Publish the soft reservation as
    IORES_DESC_SOFT_RESERVED memory, similar to x86.
    
    (Based on an original patch by Ard)
    
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 311cd349a862..904fa09e6a6b 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -163,6 +163,15 @@ static __init int is_usable_memory(efi_memory_desc_t *md)
 	case EFI_BOOT_SERVICES_DATA:
 	case EFI_CONVENTIONAL_MEMORY:
 	case EFI_PERSISTENT_MEMORY:
+		/*
+		 * Special purpose memory is 'soft reserved', which means it
+		 * is set aside initially, but can be hotplugged back in or
+		 * be assigned to the dax driver after boot.
+		 */
+		if (efi_soft_reserve_enabled() &&
+		    (md->attribute & EFI_MEMORY_SP))
+			return false;
+
 		/*
 		 * According to the spec, these regions are no longer reserved
 		 * after calling ExitBootServices(). However, we can only use

commit 4febfb8dd08b6f8bafc19f3f9e382a477425b578
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Feb 2 10:41:15 2019 +0100

    efi: Replace GPL license boilerplate with SPDX headers
    
    Replace all GPL license blurbs with an equivalent SPDX header (most
    files are GPLv2, some are GPLv2+). While at it, drop some outdated
    header changelogs as well.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Alexander Graf <agraf@suse.de>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 1a6a77df8a5e..311cd349a862 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Extensible Firmware Interface
  *
  * Based on Extensible Firmware Interface Specification version 2.4
  *
  * Copyright (C) 2013 - 2015 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #define pr_fmt(fmt)	"efi: " fmt

commit 33412b8673135b18ea42beb7f5117ed0091798b6
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Nov 14 09:55:41 2018 -0800

    efi/arm: Revert deferred unmap of early memmap mapping
    
    Commit:
    
      3ea86495aef2 ("efi/arm: preserve early mapping of UEFI memory map longer for BGRT")
    
    deferred the unmap of the early mapping of the UEFI memory map to
    accommodate the ACPI BGRT code, which looks up the memory type that
    backs the BGRT table to validate it against the requirements of the UEFI spec.
    
    Unfortunately, this causes problems on ARM, which does not permit
    early mappings to persist after paging_init() is called, resulting
    in a WARN() splat. Since we don't support the BGRT table on ARM anway,
    let's revert ARM to the old behaviour, which is to take down the
    early mapping at the end of efi_init().
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 3ea86495aef2 ("efi/arm: preserve early mapping of UEFI memory ...")
    Link: http://lkml.kernel.org/r/20181114175544.12860-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 388a929baf95..1a6a77df8a5e 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -265,6 +265,10 @@ void __init efi_init(void)
 				    (params.mmap & ~PAGE_MASK)));
 
 	init_screen_info();
+
+	/* ARM does not permit early mappings to persist across paging_init() */
+	if (IS_ENABLED(CONFIG_ARM))
+		efi_memmap_unmap();
 }
 
 static int __init register_gop_device(void)

commit 3ea86495aef2f6de26b7cb1599ba350dd6a0c521
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Jul 23 10:57:30 2018 +0900

    efi/arm: preserve early mapping of UEFI memory map longer for BGRT
    
    The BGRT code validates the contents of the table against the UEFI
    memory map, and so it expects it to be mapped when the code runs.
    
    On ARM, this is currently not the case, since we tear down the early
    mapping after efi_init() completes, and only create the permanent
    mapping in arm_enable_runtime_services(), which executes as an early
    initcall, but still leaves a window where the UEFI memory map is not
    mapped.
    
    So move the call to efi_memmap_unmap() from efi_init() to
    arm_enable_runtime_services().
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    [will: fold in EFI_MEMMAP attribute check from Ard]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index b5214c143fee..388a929baf95 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -259,7 +259,6 @@ void __init efi_init(void)
 
 	reserve_regions();
 	efi_esrt_init();
-	efi_memmap_unmap();
 
 	memblock_reserve(params.mmap & PAGE_MASK,
 			 PAGE_ALIGN(params.mmap_size +

commit d7dc899abefb4412388a5d3ec690070197d07d20
Author: Stefan Agner <stefan@agner.ch>
Date:   Thu Jun 14 15:28:02 2018 -0700

    treewide: use PHYS_ADDR_MAX to avoid type casting ULLONG_MAX
    
    With PHYS_ADDR_MAX there is now a type safe variant for all bits set.
    Make use of it.
    
    Patch created using a semantic patch as follows:
    
    // <smpl>
    @@
    typedef phys_addr_t;
    @@
    -(phys_addr_t)ULLONG_MAX
    +PHYS_ADDR_MAX
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20180419214204.19322-1-stefan@agner.ch
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>     [arm64]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 80d1a885def5..b5214c143fee 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -193,7 +193,7 @@ static __init void reserve_regions(void)
 	 * uses its own memory map instead.
 	 */
 	memblock_dump_all();
-	memblock_remove(0, (phys_addr_t)ULLONG_MAX);
+	memblock_remove(0, PHYS_ADDR_MAX);
 
 	for_each_efi_memory_desc(md) {
 		paddr = md->phys_addr;

commit 9a9de5c044be14c3337ef45174ac8baa568a0f93
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 18 20:49:38 2017 +0100

    efi/arm/arm64: Add missing assignment of efi.config_table
    
    The ARM EFI init code never assigns the config_table member of the
    efi struct, which means the sysfs device node is missing, and other
    in-kernel users will not work correctly. So add the missing assignment.
    
    Note that, for now, the runtime and fw_vendor members are still
    omitted. This is deliberate: exposing physical addresses via sysfs nodes
    encourages behavior that we would like to avoid on ARM (given how it is
    more finicky about using correct memory attributes when mapping memory
    in userland that may be mapped by the kernel already as well).
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170818194947.19347-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 0aa4ce7b4fbb..80d1a885def5 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -145,6 +145,9 @@ static int __init uefi_init(void)
 					 sizeof(efi_config_table_t),
 					 arch_tables);
 
+	if (!retval)
+		efi.config_table = (unsigned long)efi.systab->tables;
+
 	early_memunmap(config_tables, table_size);
 out:
 	early_memunmap(efi.systab,  sizeof(efi_system_table_t));

commit f56ab9a5b73ca2aee777ccdf2d355ae2dd31db5a
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 18 20:49:34 2017 +0100

    efi/arm: Don't mark ACPI reclaim memory as MEMBLOCK_NOMAP
    
    On ARM, regions of memory that are described by UEFI as having special
    significance to the firmware itself are omitted from the linear mapping.
    This is necessary since we cannot guarantee that alternate mappings of
    the same physical region will use attributes that are compatible with
    the ones we use for the linear mapping, and aliases with mismatched
    attributes are prohibited by the architecture.
    
    The above does not apply to ACPI reclaim regions: such regions have no
    special significance to the firmware, and it is up to the OS to decide
    whether or not to preserve them after it has consumed their contents,
    and for how long, after which time the OS can use the memory in any way
    it likes. In the Linux case, such regions are preserved indefinitely,
    and are simply treated the same way as other 'reserved' memory types.
    
    Punching holes into the linear mapping causes page table fragmentation,
    which increases TLB pressure, and so we should avoid doing so if we can.
    So add a special case for regions of type EFI_ACPI_RECLAIM_MEMORY, and
    memblock_reserve() them instead of marking them MEMBLOCK_NOMAP.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170818194947.19347-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 1027d7b44358..0aa4ce7b4fbb 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -159,6 +159,7 @@ static __init int is_usable_memory(efi_memory_desc_t *md)
 	switch (md->type) {
 	case EFI_LOADER_CODE:
 	case EFI_LOADER_DATA:
+	case EFI_ACPI_RECLAIM_MEMORY:
 	case EFI_BOOT_SERVICES_CODE:
 	case EFI_BOOT_SERVICES_DATA:
 	case EFI_CONVENTIONAL_MEMORY:
@@ -211,6 +212,10 @@ static __init void reserve_regions(void)
 
 			if (!is_usable_memory(md))
 				memblock_mark_nomap(paddr, size);
+
+			/* keep ACPI reclaim memory intact for kexec etc. */
+			if (md->type == EFI_ACPI_RECLAIM_MEMORY)
+				memblock_reserve(paddr, size);
 		}
 	}
 }

commit 3a6b6c6fb23667fa383053bd5259aabc96468571
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Jan 31 13:21:35 2017 +0000

    efi: Make EFI_MEMORY_ATTRIBUTES_TABLE initialization common across all architectures
    
    Since EFI_PROPERTIES_TABLE and EFI_MEMORY_ATTRIBUTES_TABLE deal with
    updating memory region attributes, it makes sense to call
    EFI_MEMORY_ATTRIBUTES_TABLE initialization function from the same place
    as EFI_PROPERTIES_TABLE. This also moves the EFI_MEMORY_ATTRIBUTES_TABLE
    initialization code to a more generic efi initialization path rather
    than ARM specific efi initialization. This is important because
    EFI_MEMORY_ATTRIBUTES_TABLE will be supported by x86 as well.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-4-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index f853ad2c4ca0..1027d7b44358 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -250,7 +250,6 @@ void __init efi_init(void)
 	}
 
 	reserve_regions();
-	efi_memattr_init();
 	efi_esrt_init();
 	efi_memmap_unmap();
 

commit 0709a008c9fadc176500ece7395b8b5b8de143e3
Author: Yisheng Xie <xieyisheng1@huawei.com>
Date:   Tue Oct 18 15:33:13 2016 +0100

    efi/arm*: Fix efi_init() error handling
    
    There's an early memmap() leak in the efi_init() error path, fix it.
    
    Signed-off-by: Yisheng Xie <xieyisheng1@huawei.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161018143318.15673-4-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 8efe13075c92..f853ad2c4ca0 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -244,8 +244,10 @@ void __init efi_init(void)
 	     "Unexpected EFI_MEMORY_DESCRIPTOR version %ld",
 	      efi.memmap.desc_version);
 
-	if (uefi_init() < 0)
+	if (uefi_init() < 0) {
+		efi_memmap_unmap();
 		return;
+	}
 
 	reserve_regions();
 	efi_memattr_init();

commit cb82cce7035ec22a69ab3bd4d2fe6729527ce1ca
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Aug 25 18:17:09 2016 +0200

    efi/arm64: Treat regions with WT/WC set but WB cleared as memory
    
    Currently, memory regions are only recorded in the memblock memory table
    if they have the EFI_MEMORY_WB memory type attribute set. In case the
    region is of a reserved type, it is also marked as MEMBLOCK_NOMAP, which
    will leave it out of the linear mapping.
    
    However, memory regions may legally have the EFI_MEMORY_WT or EFI_MEMORY_WC
    attributes set, and the EFI_MEMORY_WB cleared, in which case the region in
    question is obviously backed by normal memory, but is not recorded in the
    memblock memory table at all. Since it would be useful to be able to
    identify any UEFI reported memory region using memblock_is_memory(), it
    makes sense to add all memory to the memblock memory table, and simply mark
    it as MEMBLOCK_NOMAP if it lacks the EFI_MEMORY_WB attribute.
    
    While implementing this, let's refactor the code slightly to make it easier
    to understand: replace is_normal_ram() with is_memory(), and make it return
    true for each region that has any of the WB|WT|WC bits set. (This follows
    the AArch64 bindings in the UEFI spec, which state that those are the
    attributes that map to normal memory)
    
    Also, replace is_reserve_region() with is_usable_memory(), and only invoke
    it if the region in question was identified as memory by is_memory() in the
    first place. The net result is the same (only reserved regions that are
    backed by memory end up in the memblock memory table with the MEMBLOCK_NOMAP
    flag set) but carried out in a more straightforward way.
    
    Finally, we remove the trailing asterisk in the EFI debug output. Keeping it
    clutters the code, and it serves no real purpose now that we no longer
    temporarily reserve BootServices code and data regions like we did in the
    early days of EFI support on arm64 Linux (which it inherited from the x86
    implementation)
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Leif Lindholm <leif.lindholm@linaro.org>
    Tested-by: James Morse <james.morse@arm.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index e0a511d4074f..8efe13075c92 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -26,9 +26,9 @@
 
 u64 efi_system_table;
 
-static int __init is_normal_ram(efi_memory_desc_t *md)
+static int __init is_memory(efi_memory_desc_t *md)
 {
-	if (md->attribute & EFI_MEMORY_WB)
+	if (md->attribute & (EFI_MEMORY_WB|EFI_MEMORY_WT|EFI_MEMORY_WC))
 		return 1;
 	return 0;
 }
@@ -152,9 +152,9 @@ static int __init uefi_init(void)
 }
 
 /*
- * Return true for RAM regions we want to permanently reserve.
+ * Return true for regions that can be used as System RAM.
  */
-static __init int is_reserve_region(efi_memory_desc_t *md)
+static __init int is_usable_memory(efi_memory_desc_t *md)
 {
 	switch (md->type) {
 	case EFI_LOADER_CODE:
@@ -163,18 +163,22 @@ static __init int is_reserve_region(efi_memory_desc_t *md)
 	case EFI_BOOT_SERVICES_DATA:
 	case EFI_CONVENTIONAL_MEMORY:
 	case EFI_PERSISTENT_MEMORY:
-		return 0;
+		/*
+		 * According to the spec, these regions are no longer reserved
+		 * after calling ExitBootServices(). However, we can only use
+		 * them as System RAM if they can be mapped writeback cacheable.
+		 */
+		return (md->attribute & EFI_MEMORY_WB);
 	default:
 		break;
 	}
-	return is_normal_ram(md);
+	return false;
 }
 
 static __init void reserve_regions(void)
 {
 	efi_memory_desc_t *md;
 	u64 paddr, npages, size;
-	int resv;
 
 	if (efi_enabled(EFI_DBG))
 		pr_info("Processing EFI memory map:\n");
@@ -191,25 +195,23 @@ static __init void reserve_regions(void)
 		paddr = md->phys_addr;
 		npages = md->num_pages;
 
-		resv = is_reserve_region(md);
 		if (efi_enabled(EFI_DBG)) {
 			char buf[64];
 
-			pr_info("  0x%012llx-0x%012llx %s%s\n",
+			pr_info("  0x%012llx-0x%012llx %s\n",
 				paddr, paddr + (npages << EFI_PAGE_SHIFT) - 1,
-				efi_md_typeattr_format(buf, sizeof(buf), md),
-				resv ? "*" : "");
+				efi_md_typeattr_format(buf, sizeof(buf), md));
 		}
 
 		memrange_efi_to_native(&paddr, &npages);
 		size = npages << PAGE_SHIFT;
 
-		if (is_normal_ram(md))
+		if (is_memory(md)) {
 			early_init_dt_add_memory_arch(paddr, size);
 
-		if (resv)
-			memblock_mark_nomap(paddr, size);
-
+			if (!is_usable_memory(md))
+				memblock_mark_nomap(paddr, size);
+		}
 	}
 }
 

commit 2ead3084e3fc37d42f379cca8753b458d8f9ba25
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Jul 11 21:00:46 2016 +0200

    efi/arm*: esrt: Add missing call to efi_esrt_init()
    
    ESRT support is built by default for all architectures that define
    CONFIG_EFI. However, this support was not wired up yet for ARM/arm64,
    since efi_esrt_init() was never called. So add the missing call.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 5a2df3fefccc..e0a511d4074f 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -247,6 +247,7 @@ void __init efi_init(void)
 
 	reserve_regions();
 	efi_memattr_init();
+	efi_esrt_init();
 	efi_memmap_unmap();
 
 	memblock_reserve(params.mmap & PAGE_MASK,

commit 9479c7cebfb568f8b8b424be7f1cac120e9eea95
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Feb 26 21:22:05 2016 +0000

    efi: Refactor efi_memmap_init_early() into arch-neutral code
    
    Every EFI architecture apart from ia64 needs to setup the EFI memory
    map at efi.memmap, and the code for doing that is essentially the same
    across all implementations. Therefore, it makes sense to factor this
    out into the common code under drivers/firmware/efi/.
    
    The only slight variation is the data structure out of which we pull
    the initial memory map information, such as physical address, memory
    descriptor size and version, etc. We can address this by passing a
    generic data structure (struct efi_memory_map_data) as the argument to
    efi_memmap_init_early() which contains the minimum info required for
    initialising the memory map.
    
    In the process, this patch also fixes a few undesirable implementation
    differences:
    
     - ARM and arm64 were failing to clear the EFI_MEMMAP bit when
       unmapping the early EFI memory map. EFI_MEMMAP indicates whether
       the EFI memory map is mapped (not the regions contained within) and
       can be traversed.  It's more correct to set the bit as soon as we
       memremap() the passed in EFI memmap.
    
     - Rename efi_unmmap_memmap() to efi_memmap_unmap() to adhere to the
       regular naming scheme.
    
    This patch also uses a read-write mapping for the memory map instead
    of the read-only mapping currently used on ARM and arm64. x86 needs
    the ability to update the memory map in-place when assigning virtual
    addresses to regions (efi_map_region()) and tagging regions when
    reserving boot services (efi_reserve_boot_services()).
    
    There's no way for the generic fake_mem code to know which mapping to
    use without introducing some arch-specific constant/hook, so just use
    read-write since read-only is of dubious value for the EFI memory map.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index c49d50e68aee..5a2df3fefccc 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -211,12 +211,11 @@ static __init void reserve_regions(void)
 			memblock_mark_nomap(paddr, size);
 
 	}
-
-	set_bit(EFI_MEMMAP, &efi.flags);
 }
 
 void __init efi_init(void)
 {
+	struct efi_memory_map_data data;
 	struct efi_fdt_params params;
 
 	/* Grab UEFI information placed in FDT by stub */
@@ -225,9 +224,12 @@ void __init efi_init(void)
 
 	efi_system_table = params.system_table;
 
-	efi.memmap.phys_map = params.mmap;
-	efi.memmap.map = early_memremap_ro(params.mmap, params.mmap_size);
-	if (efi.memmap.map == NULL) {
+	data.desc_version = params.desc_ver;
+	data.desc_size = params.desc_size;
+	data.size = params.mmap_size;
+	data.phys_map = params.mmap;
+
+	if (efi_memmap_init_early(&data) < 0) {
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only
 		* description of memory we have, so there is little point in
@@ -235,9 +237,6 @@ void __init efi_init(void)
 		*/
 		panic("Unable to map EFI memory map.\n");
 	}
-	efi.memmap.map_end = efi.memmap.map + params.mmap_size;
-	efi.memmap.desc_size = params.desc_size;
-	efi.memmap.desc_version = params.desc_ver;
 
 	WARN(efi.memmap.desc_version != 1,
 	     "Unexpected EFI_MEMORY_DESCRIPTOR version %ld",
@@ -248,7 +247,7 @@ void __init efi_init(void)
 
 	reserve_regions();
 	efi_memattr_init();
-	early_memunmap(efi.memmap.map, params.mmap_size);
+	efi_memmap_unmap();
 
 	memblock_reserve(params.mmap & PAGE_MASK,
 			 PAGE_ALIGN(params.mmap_size +

commit c75343972b79ef5bd44c498a63b326e37470bbfc
Author: Dennis Chen <dennis.chen@arm.com>
Date:   Tue May 31 11:23:44 2016 +0100

    efi/arm: Fix the format of EFI debug messages
    
    When both EFI and memblock debugging is enabled on the kernel command line:
    
      'efi=debug memblock=debug'
    
    .. the debug messages for early_con look the following way:
    
     [    0.000000] efi:   0x0000e1050000-0x0000e105ffff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x0000e1300000-0x0000e1300fff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x0000e8200000-0x0000e827ffff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x008000000000-0x008001e7ffff [Runtime Data       |RUN|  |  |  |  |  |  |   |WB|WT|WC|UC]
     [    0.000000] memblock_add: [0x00008000000000-0x00008001e7ffff] flags 0x0 early_init_dt_add_memory_arch+0x54/0x5c
     [    0.000000] *
     ...
    
    Note the misplaced '*' line, which happened because the memblock debug message
    was printed while the EFI debug message was still being constructed..
    
    This patch fixes the output to be the expected:
    
     [    0.000000] efi:   0x0000e1050000-0x0000e105ffff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x0000e1300000-0x0000e1300fff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x0000e8200000-0x0000e827ffff [Memory Mapped I/O  |RUN|  |  |  |  |  |  |   |  |  |  |UC]
     [    0.000000] efi:   0x008000000000-0x008001e7ffff [Runtime Data       |RUN|  |  |  |  |  |  |   |WB|WT|WC|UC]*
     [    0.000000] memblock_add: [0x00008000000000-0x00008001e7ffff] flags 0x0 early_init_dt_add_memory_arch+0x54/0x5c
     ...
    
    Note how the '*' is now in the proper EFI debug message line.
    
    Signed-off-by: Dennis Chen <dennis.chen@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steve Capper <steve.capper@arm.com>
    Cc: Steve McIntyre <steve@einval.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1464690224-4503-3-git-send-email-matt@codeblueprint.co.uk
    [ Made the changelog more readable. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index a850cbc48d8d..c49d50e68aee 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -174,6 +174,7 @@ static __init void reserve_regions(void)
 {
 	efi_memory_desc_t *md;
 	u64 paddr, npages, size;
+	int resv;
 
 	if (efi_enabled(EFI_DBG))
 		pr_info("Processing EFI memory map:\n");
@@ -190,12 +191,14 @@ static __init void reserve_regions(void)
 		paddr = md->phys_addr;
 		npages = md->num_pages;
 
+		resv = is_reserve_region(md);
 		if (efi_enabled(EFI_DBG)) {
 			char buf[64];
 
-			pr_info("  0x%012llx-0x%012llx %s",
+			pr_info("  0x%012llx-0x%012llx %s%s\n",
 				paddr, paddr + (npages << EFI_PAGE_SHIFT) - 1,
-				efi_md_typeattr_format(buf, sizeof(buf), md));
+				efi_md_typeattr_format(buf, sizeof(buf), md),
+				resv ? "*" : "");
 		}
 
 		memrange_efi_to_native(&paddr, &npages);
@@ -204,14 +207,9 @@ static __init void reserve_regions(void)
 		if (is_normal_ram(md))
 			early_init_dt_add_memory_arch(paddr, size);
 
-		if (is_reserve_region(md)) {
+		if (resv)
 			memblock_mark_nomap(paddr, size);
-			if (efi_enabled(EFI_DBG))
-				pr_cont("*");
-		}
 
-		if (efi_enabled(EFI_DBG))
-			pr_cont("\n");
 	}
 
 	set_bit(EFI_MEMMAP, &efi.flags);

commit be092017b6ffbd013f481f915632db6aa9fc3ca3
Merge: fb6363e9f4ee e6d9a5254333
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 16 17:17:24 2016 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Will Deacon:
    
     - virt_to_page/page_address optimisations
    
     - support for NUMA systems described using device-tree
    
     - support for hibernate/suspend-to-disk
    
     - proper support for maxcpus= command line parameter
    
     - detection and graceful handling of AArch64-only CPUs
    
     - miscellaneous cleanups and non-critical fixes
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (92 commits)
      arm64: do not enforce strict 16 byte alignment to stack pointer
      arm64: kernel: Fix incorrect brk randomization
      arm64: cpuinfo: Missing NULL terminator in compat_hwcap_str
      arm64: secondary_start_kernel: Remove unnecessary barrier
      arm64: Ensure pmd_present() returns false after pmd_mknotpresent()
      arm64: Replace hard-coded values in the pmd/pud_bad() macros
      arm64: Implement pmdp_set_access_flags() for hardware AF/DBM
      arm64: Fix typo in the pmdp_huge_get_and_clear() definition
      arm64: mm: remove unnecessary EXPORT_SYMBOL_GPL
      arm64: always use STRICT_MM_TYPECHECKS
      arm64: kvm: Fix kvm teardown for systems using the extended idmap
      arm64: kaslr: increase randomization granularity
      arm64: kconfig: drop CONFIG_RTC_LIB dependency
      arm64: make ARCH_SUPPORTS_DEBUG_PAGEALLOC depend on !HIBERNATION
      arm64: hibernate: Refuse to hibernate if the boot cpu is offline
      arm64: kernel: Add support for hibernate/suspend-to-disk
      PM / Hibernate: Call flush_icache_range() on pages restored in-place
      arm64: Add new asm macro copy_page
      arm64: Promote KERNEL_START/KERNEL_END definitions to a header file
      arm64: kernel: Include _AC definition in page.h
      ...

commit 249f7632162980b286f30166436471f8ba81fc1e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:07:02 2016 +0100

    efi/arm-init: Reserve rather than unmap the memory map for ARM as well
    
    Now that ARM has a fully functional memremap() implementation, there is
    no longer a need to remove the UEFI memory map from the linear mapping
    in order to be able to create a permanent mapping for it using generic
    code.
    
    So remove the 'IS_ENABLED(CONFIG_ARM)' conditional we added in:
    
    7cc8cbcf82d1 ("efi/arm64: Don't apply MEMBLOCK_NOMAP to UEFI memory map mapping")
    
    ... and revert to using memblock_reserve() for both ARM and arm64.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-31-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 7a3318dd4319..ef90f0c4b70a 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -244,20 +244,9 @@ void __init efi_init(void)
 	efi_memattr_init();
 	early_memunmap(efi.memmap.map, params.mmap_size);
 
-	if (IS_ENABLED(CONFIG_ARM)) {
-		/*
-		 * ARM currently does not allow ioremap_cache() to be called on
-		 * memory regions that are covered by struct page. So remove the
-		 * UEFI memory map from the linear mapping.
-		 */
-		memblock_mark_nomap(params.mmap & PAGE_MASK,
-				    PAGE_ALIGN(params.mmap_size +
-					       (params.mmap & ~PAGE_MASK)));
-	} else {
-		memblock_reserve(params.mmap & PAGE_MASK,
-				 PAGE_ALIGN(params.mmap_size +
-					    (params.mmap & ~PAGE_MASK)));
-	}
+	memblock_reserve(params.mmap & PAGE_MASK,
+			 PAGE_ALIGN(params.mmap_size +
+				    (params.mmap & ~PAGE_MASK)));
 
 	init_screen_info();
 }

commit e3271c96ca7d01957b03b5f1e2bdc00e08fd7160
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:55 2016 +0100

    efi/arm*: Wire up 'struct screen_info' to efi-framebuffer platform device
    
    This adds code to the ARM and arm64 EFI init routines to expose a platform
    device of type 'efi-framebuffer' if 'struct screen_info' has been populated
    appropriately from the GOP protocol by the stub. Since the framebuffer may
    potentially be located in system RAM, make sure that the region is reserved
    and marked MEMBLOCK_NOMAP.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-24-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index ac95dd8b119f..7a3318dd4319 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -19,6 +19,7 @@
 #include <linux/mm_types.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/platform_device.h>
 #include <linux/screen_info.h>
 
 #include <asm/efi.h>
@@ -78,6 +79,10 @@ static void __init init_screen_info(void)
 		screen_info.orig_video_cols = 80;
 		screen_info.orig_video_lines = 25;
 	}
+
+	if (screen_info.orig_video_isVGA == VIDEO_TYPE_EFI &&
+	    memblock_is_map_memory(screen_info.lfb_base))
+		memblock_mark_nomap(screen_info.lfb_base, screen_info.lfb_size);
 }
 
 static int __init uefi_init(void)
@@ -256,3 +261,16 @@ void __init efi_init(void)
 
 	init_screen_info();
 }
+
+static int __init register_gop_device(void)
+{
+	void *pd;
+
+	if (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)
+		return 0;
+
+	pd = platform_device_register_data(NULL, "efi-framebuffer", 0,
+					   &screen_info, sizeof(screen_info));
+	return PTR_ERR_OR_ZERO(pd);
+}
+subsys_initcall(register_gop_device);

commit 801820bee9bccb7c156af2b95c7208f428a06ae7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:53 2016 +0100

    efi/arm/libstub: Make screen_info accessible to the UEFI stub
    
    In order to hand over the framebuffer described by the GOP protocol and
    discovered by the UEFI stub, make struct screen_info accessible by the
    stub. This involves allocating a loader data buffer and passing it to the
    kernel proper via a UEFI Configuration Table, since the UEFI stub executes
    in the context of the decompressor, and cannot access the kernel's copy of
    struct screen_info directly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-22-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 909d974d35d9..ac95dd8b119f 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -11,12 +11,15 @@
  *
  */
 
+#define pr_fmt(fmt)	"efi: " fmt
+
 #include <linux/efi.h>
 #include <linux/init.h>
 #include <linux/memblock.h>
 #include <linux/mm_types.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/screen_info.h>
 
 #include <asm/efi.h>
 
@@ -51,6 +54,32 @@ static phys_addr_t efi_to_phys(unsigned long addr)
 	return addr;
 }
 
+static __initdata unsigned long screen_info_table = EFI_INVALID_TABLE_ADDR;
+
+static __initdata efi_config_table_type_t arch_tables[] = {
+	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, NULL, &screen_info_table},
+	{NULL_GUID, NULL, NULL}
+};
+
+static void __init init_screen_info(void)
+{
+	struct screen_info *si;
+
+	if (screen_info_table != EFI_INVALID_TABLE_ADDR) {
+		si = early_memremap_ro(screen_info_table, sizeof(*si));
+		if (!si) {
+			pr_err("Could not map screen_info config table\n");
+			return;
+		}
+		screen_info = *si;
+		early_memunmap(si, sizeof(*si));
+
+		/* dummycon on ARM needs non-zero values for columns/lines */
+		screen_info.orig_video_cols = 80;
+		screen_info.orig_video_lines = 25;
+	}
+}
+
 static int __init uefi_init(void)
 {
 	efi_char16_t *c16;
@@ -108,7 +137,8 @@ static int __init uefi_init(void)
 		goto out;
 	}
 	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
-					 sizeof(efi_config_table_t), NULL);
+					 sizeof(efi_config_table_t),
+					 arch_tables);
 
 	early_memunmap(config_tables, table_size);
 out:
@@ -223,4 +253,6 @@ void __init efi_init(void)
 				 PAGE_ALIGN(params.mmap_size +
 					    (params.mmap & ~PAGE_MASK)));
 	}
+
+	init_screen_info();
 }

commit 789957ef72f976cb325e9057225fc4e9c4513060
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:46 2016 +0100

    efi/arm*: Take the Memory Attributes table into account
    
    Call into the generic memory attributes table support code at the
    appropriate times during the init sequence so that the UEFI Runtime
    Services region are mapped according to the strict permissions it
    specifies.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-15-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index a84dddb54c14..909d974d35d9 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -206,6 +206,7 @@ void __init efi_init(void)
 		return;
 
 	reserve_regions();
+	efi_memattr_init();
 	early_memunmap(efi.memmap.map, params.mmap_size);
 
 	if (IS_ENABLED(CONFIG_ARM)) {

commit 0d054ad96e97dcd8966e9333eabcc7a466672f70
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:40 2016 +0100

    efi: Check EFI_MEMORY_DESCRIPTOR version explicitly
    
    Our efi_memory_desc_t type is based on EFI_MEMORY_DESCRIPTOR version 1 in
    the UEFI spec. No version updates are expected, but since we are about to
    introduce support for new firmware tables that use the same descriptor
    type, it makes sense to at least warn if we encounter other versions.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-9-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 90a9b473e45c..a84dddb54c14 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -198,6 +198,10 @@ void __init efi_init(void)
 	efi.memmap.desc_size = params.desc_size;
 	efi.memmap.desc_version = params.desc_ver;
 
+	WARN(efi.memmap.desc_version != 1,
+	     "Unexpected EFI_MEMORY_DESCRIPTOR version %ld",
+	      efi.memmap.desc_version);
+
 	if (uefi_init() < 0)
 		return;
 

commit 884f4f66ffd6ffe632f3a8be4e6d10a858afdc37
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:39 2016 +0100

    efi: Remove global 'memmap' EFI memory map
    
    Abolish the poorly named EFI memory map, 'memmap'. It is shadowed by a
    bunch of local definitions in various files and having two ways to
    access the EFI memory map ('efi.memmap' vs. 'memmap') is rather
    confusing.
    
    Furthermore, IA64 doesn't even provide this global object, which has
    caused issues when trying to write generic EFI memmap code.
    
    Replace all occurrences with efi.memmap, and convert the remaining
    iterator code to use for_each_efi_mem_desc().
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Luck, Tony <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-8-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index d5f6b0ca521e..90a9b473e45c 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -20,8 +20,6 @@
 
 #include <asm/efi.h>
 
-struct efi_memory_map memmap;
-
 u64 efi_system_table;
 
 static int __init is_normal_ram(efi_memory_desc_t *md)
@@ -40,7 +38,7 @@ static phys_addr_t efi_to_phys(unsigned long addr)
 {
 	efi_memory_desc_t *md;
 
-	for_each_efi_memory_desc_in_map(&memmap, md) {
+	for_each_efi_memory_desc(md) {
 		if (!(md->attribute & EFI_MEMORY_RUNTIME))
 			continue;
 		if (md->virt_addr == 0)
@@ -145,7 +143,7 @@ static __init void reserve_regions(void)
 	if (efi_enabled(EFI_DBG))
 		pr_info("Processing EFI memory map:\n");
 
-	for_each_efi_memory_desc_in_map(&memmap, md) {
+	for_each_efi_memory_desc(md) {
 		paddr = md->phys_addr;
 		npages = md->num_pages;
 
@@ -186,9 +184,9 @@ void __init efi_init(void)
 
 	efi_system_table = params.system_table;
 
-	memmap.phys_map = params.mmap;
-	memmap.map = early_memremap_ro(params.mmap, params.mmap_size);
-	if (memmap.map == NULL) {
+	efi.memmap.phys_map = params.mmap;
+	efi.memmap.map = early_memremap_ro(params.mmap, params.mmap_size);
+	if (efi.memmap.map == NULL) {
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only
 		* description of memory we have, so there is little point in
@@ -196,15 +194,15 @@ void __init efi_init(void)
 		*/
 		panic("Unable to map EFI memory map.\n");
 	}
-	memmap.map_end = memmap.map + params.mmap_size;
-	memmap.desc_size = params.desc_size;
-	memmap.desc_version = params.desc_ver;
+	efi.memmap.map_end = efi.memmap.map + params.mmap_size;
+	efi.memmap.desc_size = params.desc_size;
+	efi.memmap.desc_version = params.desc_ver;
 
 	if (uefi_init() < 0)
 		return;
 
 	reserve_regions();
-	early_memunmap(memmap.map, params.mmap_size);
+	early_memunmap(efi.memmap.map, params.mmap_size);
 
 	if (IS_ENABLED(CONFIG_ARM)) {
 		/*

commit 78ce248faa3c46e24e9bd42db3ab3650659f16dd
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:38 2016 +0100

    efi: Iterate over efi.memmap in for_each_efi_memory_desc()
    
    Most of the users of for_each_efi_memory_desc() are equally happy
    iterating over the EFI memory map in efi.memmap instead of 'memmap',
    since the former is usually a pointer to the latter.
    
    For those users that want to specify an EFI memory map other than
    efi.memmap, that can be done using for_each_efi_memory_desc_in_map().
    One such example is in the libstub code where the firmware is queried
    directly for the memory map, it gets iterated over, and then freed.
    
    This change goes part of the way toward deleting the global 'memmap'
    variable, which is not universally available on all architectures
    (notably IA64) and is rather poorly named.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-7-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 008ed1993b72..d5f6b0ca521e 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -40,7 +40,7 @@ static phys_addr_t efi_to_phys(unsigned long addr)
 {
 	efi_memory_desc_t *md;
 
-	for_each_efi_memory_desc(&memmap, md) {
+	for_each_efi_memory_desc_in_map(&memmap, md) {
 		if (!(md->attribute & EFI_MEMORY_RUNTIME))
 			continue;
 		if (md->virt_addr == 0)
@@ -145,7 +145,7 @@ static __init void reserve_regions(void)
 	if (efi_enabled(EFI_DBG))
 		pr_info("Processing EFI memory map:\n");
 
-	for_each_efi_memory_desc(&memmap, md) {
+	for_each_efi_memory_desc_in_map(&memmap, md) {
 		paddr = md->phys_addr;
 		npages = md->num_pages;
 

commit 14c43be60166981f0b1f034ad9c59252c6f99e0d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:34 2016 +0100

    efi/arm*: Drop writable mapping of the UEFI System table
    
    Commit:
    
      2eec5dedf770 ("efi/arm-init: Use read-only early mappings")
    
    updated the early ARM UEFI init code to create the temporary, early
    mapping of the UEFI System table using read-only attributes, as a
    hardening measure against inadvertent modification.
    
    However, this still leaves the permanent, writable mapping of the UEFI
    System table, which is only ever referenced during invocations of UEFI
    Runtime Services, at which time the UEFI virtual mapping is available,
    which also covers the system table. (This is guaranteed by the fact that
    SetVirtualAddressMap(), which is a runtime service itself, converts
    various entries in the table to their virtual equivalents, which implies
    that the table must be covered by a RuntimeServicesData region that has
    the EFI_MEMORY_RUNTIME attribute.)
    
    So instead of creating this permanent mapping, record the virtual address
    of the system table inside the UEFI virtual mapping, and dereference that
    when accessing the table. This protects the contents of the system table
    from inadvertent (or deliberate) modification when no UEFI Runtime
    Services calls are in progress.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-3-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 8714f8c271ba..008ed1993b72 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -85,6 +85,8 @@ static int __init uefi_init(void)
 			efi.systab->hdr.revision >> 16,
 			efi.systab->hdr.revision & 0xffff);
 
+	efi.runtime_version = efi.systab->hdr.revision;
+
 	/* Show what we know for posterity */
 	c16 = early_memremap_ro(efi_to_phys(efi.systab->fw_vendor),
 				sizeof(vendor) * sizeof(efi_char16_t));

commit 7464b6e3a5fb213e7826d2fde4a2daf05abb6822
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 18 10:34:19 2016 +0200

    efi: ARM: avoid warning about phys_addr_t cast
    
    memblock_remove() takes a phys_addr_t, which may be narrower than 64 bits,
    causing a harmless warning:
    
    drivers/firmware/efi/arm-init.c: In function 'reserve_regions':
    include/linux/kernel.h:29:20: error: large integer implicitly truncated to unsigned type [-Werror=overflow]
     #define ULLONG_MAX (~0ULL)
                        ^
    drivers/firmware/efi/arm-init.c:152:21: note: in expansion of macro 'ULLONG_MAX'
      memblock_remove(0, ULLONG_MAX);
    
    This adds an explicit typecast to avoid the warning
    
    Fixes: 500899c2cc3e ("efi: ARM/arm64: ignore DT memory nodes instead of removing them")
    Acked-by Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 5d6945b761dc..ca708fb18c1d 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -149,7 +149,7 @@ static __init void reserve_regions(void)
 	 * uses its own memory map instead.
 	 */
 	memblock_dump_all();
-	memblock_remove(0, ULLONG_MAX);
+	memblock_remove(0, (phys_addr_t)ULLONG_MAX);
 
 	for_each_efi_memory_desc(&memmap, md) {
 		paddr = md->phys_addr;

commit 500899c2cc3e3f06140373b587a69d30650f2d9d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Apr 8 15:50:23 2016 -0700

    efi: ARM/arm64: ignore DT memory nodes instead of removing them
    
    There are two problems with the UEFI stub DT memory node removal
    routine:
    - it deletes nodes as it traverses the tree, which happens to work
      but is not supported, as deletion invalidates the node iterator;
    - deleting memory nodes entirely may discard annotations in the form
      of additional properties on the nodes.
    
    Since the discovery of DT memory nodes occurs strictly before the
    UEFI init sequence, we can simply clear the memblock memory table
    before parsing the UEFI memory map. This way, it is no longer
    necessary to remove the nodes, so we can remove that logic from the
    stub as well.
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Steve Capper <steve.capper@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index aa1f743152a2..5d6945b761dc 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -143,6 +143,14 @@ static __init void reserve_regions(void)
 	if (efi_enabled(EFI_DBG))
 		pr_info("Processing EFI memory map:\n");
 
+	/*
+	 * Discard memblocks discovered so far: if there are any at this
+	 * point, they originate from memory nodes in the DT, and UEFI
+	 * uses its own memory map instead.
+	 */
+	memblock_dump_all();
+	memblock_remove(0, ULLONG_MAX);
+
 	for_each_efi_memory_desc(&memmap, md) {
 		paddr = md->phys_addr;
 		npages = md->num_pages;

commit 7cc8cbcf82d165dd658d89a7a287140948e76413
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Mar 30 09:46:23 2016 +0200

    efi/arm64: Don't apply MEMBLOCK_NOMAP to UEFI memory map mapping
    
    Commit 4dffbfc48d65 ("arm64/efi: mark UEFI reserved regions as
    MEMBLOCK_NOMAP") updated the mapping logic of both the RuntimeServices
    regions as well as the kernel's copy of the UEFI memory map to set the
    MEMBLOCK_NOMAP flag, which causes these regions to be omitted from the
    kernel direct mapping, and from being covered by a struct page.
    For the RuntimeServices regions, this is an obvious win, since the contents
    of these regions have significance to the firmware executable code itself,
    and are mapped in the EFI page tables using attributes that are described in
    the UEFI memory map, and which may differ from the attributes we use for
    mapping system RAM. It also prevents the contents from being modified
    inadvertently, since the EFI page tables are only live during runtime
    service invocations.
    
    None of these concerns apply to the allocation that covers the UEFI memory
    map, since it is entirely owned by the kernel. Setting the MEMBLOCK_NOMAP on
    the region did allow us to use ioremap_cache() to map it both on arm64 and
    on ARM, since the latter does not allow ioremap_cache() to be used on
    regions that are covered by a struct page.
    
    The ioremap_cache() on ARM restriction will be lifted in the v4.7 timeframe,
    but in the mean time, it has been reported that commit 4dffbfc48d65 causes
    a regression on 64k granule kernels. This is due to the fact that, given
    the 64 KB page size, the region that we end up removing from the kernel
    direct mapping is rounded up to 64 KB, and this 64 KB page frame may be
    shared with the initrd when booting via GRUB (which does not align its
    EFI_LOADER_DATA allocations to 64 KB like the stub does). This will crash
    the kernel as soon as it tries to access the initrd.
    
    Since the issue is specific to arm64, revert back to memblock_reserve()'ing
    the UEFI memory map when running on arm64. This is a temporary fix for v4.5
    and v4.6, and will be superseded in the v4.7 timeframe when we will be able
    to move back to memblock_reserve() unconditionally.
    
    Fixes: 4dffbfc48d65 ("arm64/efi: mark UEFI reserved regions as MEMBLOCK_NOMAP")
    Reported-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Mark Langsdorf <mlangsdo@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.5
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index aa1f743152a2..8714f8c271ba 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -203,7 +203,19 @@ void __init efi_init(void)
 
 	reserve_regions();
 	early_memunmap(memmap.map, params.mmap_size);
-	memblock_mark_nomap(params.mmap & PAGE_MASK,
-			    PAGE_ALIGN(params.mmap_size +
-				       (params.mmap & ~PAGE_MASK)));
+
+	if (IS_ENABLED(CONFIG_ARM)) {
+		/*
+		 * ARM currently does not allow ioremap_cache() to be called on
+		 * memory regions that are covered by struct page. So remove the
+		 * UEFI memory map from the linear mapping.
+		 */
+		memblock_mark_nomap(params.mmap & PAGE_MASK,
+				    PAGE_ALIGN(params.mmap_size +
+					       (params.mmap & ~PAGE_MASK)));
+	} else {
+		memblock_reserve(params.mmap & PAGE_MASK,
+				 PAGE_ALIGN(params.mmap_size +
+					    (params.mmap & ~PAGE_MASK)));
+	}
 }

commit 2eec5dedf770dc85c1fdf6b86873165e61bb1fff
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Feb 17 12:36:00 2016 +0000

    efi/arm-init: Use read-only early mappings
    
    The early mappings of the EFI system table contents and the UEFI memory
    map are read-only from the OS point of view. So map them read-only to
    protect them from inadvertent modification.
    
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1455712566-16727-8-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index 9e15d571b53c..aa1f743152a2 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -61,8 +61,8 @@ static int __init uefi_init(void)
 	char vendor[100] = "unknown";
 	int i, retval;
 
-	efi.systab = early_memremap(efi_system_table,
-				    sizeof(efi_system_table_t));
+	efi.systab = early_memremap_ro(efi_system_table,
+				       sizeof(efi_system_table_t));
 	if (efi.systab == NULL) {
 		pr_warn("Unable to map EFI system table.\n");
 		return -ENOMEM;
@@ -86,8 +86,8 @@ static int __init uefi_init(void)
 			efi.systab->hdr.revision & 0xffff);
 
 	/* Show what we know for posterity */
-	c16 = early_memremap(efi_to_phys(efi.systab->fw_vendor),
-			     sizeof(vendor) * sizeof(efi_char16_t));
+	c16 = early_memremap_ro(efi_to_phys(efi.systab->fw_vendor),
+				sizeof(vendor) * sizeof(efi_char16_t));
 	if (c16) {
 		for (i = 0; i < (int) sizeof(vendor) - 1 && *c16; ++i)
 			vendor[i] = c16[i];
@@ -100,8 +100,8 @@ static int __init uefi_init(void)
 		efi.systab->hdr.revision & 0xffff, vendor);
 
 	table_size = sizeof(efi_config_table_64_t) * efi.systab->nr_tables;
-	config_tables = early_memremap(efi_to_phys(efi.systab->tables),
-				       table_size);
+	config_tables = early_memremap_ro(efi_to_phys(efi.systab->tables),
+					  table_size);
 	if (config_tables == NULL) {
 		pr_warn("Unable to map EFI config table array.\n");
 		retval = -ENOMEM;
@@ -185,7 +185,7 @@ void __init efi_init(void)
 	efi_system_table = params.system_table;
 
 	memmap.phys_map = params.mmap;
-	memmap.map = early_memremap(params.mmap, params.mmap_size);
+	memmap.map = early_memremap_ro(params.mmap, params.mmap_size);
 	if (memmap.map == NULL) {
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only

commit f7d924894265794f447ea799dd853400749b5a22
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Nov 30 13:28:19 2015 +0100

    arm64/efi: refactor EFI init and runtime code for reuse by 32-bit ARM
    
    This refactors the EFI init and runtime code that will be shared
    between arm64 and ARM so that it can be built for both archs.
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
index ffdd76a51929..9e15d571b53c 100644
--- a/drivers/firmware/efi/arm-init.c
+++ b/drivers/firmware/efi/arm-init.c
@@ -57,7 +57,7 @@ static int __init uefi_init(void)
 {
 	efi_char16_t *c16;
 	void *config_tables;
-	u64 table_size;
+	size_t table_size;
 	char vendor[100] = "unknown";
 	int i, retval;
 
@@ -69,7 +69,8 @@ static int __init uefi_init(void)
 	}
 
 	set_bit(EFI_BOOT, &efi.flags);
-	set_bit(EFI_64BIT, &efi.flags);
+	if (IS_ENABLED(CONFIG_64BIT))
+		set_bit(EFI_64BIT, &efi.flags);
 
 	/*
 	 * Verify the EFI Table
@@ -107,7 +108,7 @@ static int __init uefi_init(void)
 		goto out;
 	}
 	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
-					 sizeof(efi_config_table_64_t), NULL);
+					 sizeof(efi_config_table_t), NULL);
 
 	early_memunmap(config_tables, table_size);
 out:

commit e5bc22a42e4d46cc203fdfb6d2c76202b08666a0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Nov 30 13:28:18 2015 +0100

    arm64/efi: split off EFI init and runtime code for reuse by 32-bit ARM
    
    This splits off the early EFI init and runtime code that
    - discovers the EFI params and the memory map from the FDT, and installs
      the memblocks and config tables.
    - prepares and installs the EFI page tables so that UEFI Runtime Services
      can be invoked at the virtual address installed by the stub.
    
    This will allow it to be reused for 32-bit ARM.
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c
new file mode 100644
index 000000000000..ffdd76a51929
--- /dev/null
+++ b/drivers/firmware/efi/arm-init.c
@@ -0,0 +1,208 @@
+/*
+ * Extensible Firmware Interface
+ *
+ * Based on Extensible Firmware Interface Specification version 2.4
+ *
+ * Copyright (C) 2013 - 2015 Linaro Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/efi.h>
+#include <linux/init.h>
+#include <linux/memblock.h>
+#include <linux/mm_types.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+
+#include <asm/efi.h>
+
+struct efi_memory_map memmap;
+
+u64 efi_system_table;
+
+static int __init is_normal_ram(efi_memory_desc_t *md)
+{
+	if (md->attribute & EFI_MEMORY_WB)
+		return 1;
+	return 0;
+}
+
+/*
+ * Translate a EFI virtual address into a physical address: this is necessary,
+ * as some data members of the EFI system table are virtually remapped after
+ * SetVirtualAddressMap() has been called.
+ */
+static phys_addr_t efi_to_phys(unsigned long addr)
+{
+	efi_memory_desc_t *md;
+
+	for_each_efi_memory_desc(&memmap, md) {
+		if (!(md->attribute & EFI_MEMORY_RUNTIME))
+			continue;
+		if (md->virt_addr == 0)
+			/* no virtual mapping has been installed by the stub */
+			break;
+		if (md->virt_addr <= addr &&
+		    (addr - md->virt_addr) < (md->num_pages << EFI_PAGE_SHIFT))
+			return md->phys_addr + addr - md->virt_addr;
+	}
+	return addr;
+}
+
+static int __init uefi_init(void)
+{
+	efi_char16_t *c16;
+	void *config_tables;
+	u64 table_size;
+	char vendor[100] = "unknown";
+	int i, retval;
+
+	efi.systab = early_memremap(efi_system_table,
+				    sizeof(efi_system_table_t));
+	if (efi.systab == NULL) {
+		pr_warn("Unable to map EFI system table.\n");
+		return -ENOMEM;
+	}
+
+	set_bit(EFI_BOOT, &efi.flags);
+	set_bit(EFI_64BIT, &efi.flags);
+
+	/*
+	 * Verify the EFI Table
+	 */
+	if (efi.systab->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE) {
+		pr_err("System table signature incorrect\n");
+		retval = -EINVAL;
+		goto out;
+	}
+	if ((efi.systab->hdr.revision >> 16) < 2)
+		pr_warn("Warning: EFI system table version %d.%02d, expected 2.00 or greater\n",
+			efi.systab->hdr.revision >> 16,
+			efi.systab->hdr.revision & 0xffff);
+
+	/* Show what we know for posterity */
+	c16 = early_memremap(efi_to_phys(efi.systab->fw_vendor),
+			     sizeof(vendor) * sizeof(efi_char16_t));
+	if (c16) {
+		for (i = 0; i < (int) sizeof(vendor) - 1 && *c16; ++i)
+			vendor[i] = c16[i];
+		vendor[i] = '\0';
+		early_memunmap(c16, sizeof(vendor) * sizeof(efi_char16_t));
+	}
+
+	pr_info("EFI v%u.%.02u by %s\n",
+		efi.systab->hdr.revision >> 16,
+		efi.systab->hdr.revision & 0xffff, vendor);
+
+	table_size = sizeof(efi_config_table_64_t) * efi.systab->nr_tables;
+	config_tables = early_memremap(efi_to_phys(efi.systab->tables),
+				       table_size);
+	if (config_tables == NULL) {
+		pr_warn("Unable to map EFI config table array.\n");
+		retval = -ENOMEM;
+		goto out;
+	}
+	retval = efi_config_parse_tables(config_tables, efi.systab->nr_tables,
+					 sizeof(efi_config_table_64_t), NULL);
+
+	early_memunmap(config_tables, table_size);
+out:
+	early_memunmap(efi.systab,  sizeof(efi_system_table_t));
+	return retval;
+}
+
+/*
+ * Return true for RAM regions we want to permanently reserve.
+ */
+static __init int is_reserve_region(efi_memory_desc_t *md)
+{
+	switch (md->type) {
+	case EFI_LOADER_CODE:
+	case EFI_LOADER_DATA:
+	case EFI_BOOT_SERVICES_CODE:
+	case EFI_BOOT_SERVICES_DATA:
+	case EFI_CONVENTIONAL_MEMORY:
+	case EFI_PERSISTENT_MEMORY:
+		return 0;
+	default:
+		break;
+	}
+	return is_normal_ram(md);
+}
+
+static __init void reserve_regions(void)
+{
+	efi_memory_desc_t *md;
+	u64 paddr, npages, size;
+
+	if (efi_enabled(EFI_DBG))
+		pr_info("Processing EFI memory map:\n");
+
+	for_each_efi_memory_desc(&memmap, md) {
+		paddr = md->phys_addr;
+		npages = md->num_pages;
+
+		if (efi_enabled(EFI_DBG)) {
+			char buf[64];
+
+			pr_info("  0x%012llx-0x%012llx %s",
+				paddr, paddr + (npages << EFI_PAGE_SHIFT) - 1,
+				efi_md_typeattr_format(buf, sizeof(buf), md));
+		}
+
+		memrange_efi_to_native(&paddr, &npages);
+		size = npages << PAGE_SHIFT;
+
+		if (is_normal_ram(md))
+			early_init_dt_add_memory_arch(paddr, size);
+
+		if (is_reserve_region(md)) {
+			memblock_mark_nomap(paddr, size);
+			if (efi_enabled(EFI_DBG))
+				pr_cont("*");
+		}
+
+		if (efi_enabled(EFI_DBG))
+			pr_cont("\n");
+	}
+
+	set_bit(EFI_MEMMAP, &efi.flags);
+}
+
+void __init efi_init(void)
+{
+	struct efi_fdt_params params;
+
+	/* Grab UEFI information placed in FDT by stub */
+	if (!efi_get_fdt_params(&params))
+		return;
+
+	efi_system_table = params.system_table;
+
+	memmap.phys_map = params.mmap;
+	memmap.map = early_memremap(params.mmap, params.mmap_size);
+	if (memmap.map == NULL) {
+		/*
+		* If we are booting via UEFI, the UEFI memory map is the only
+		* description of memory we have, so there is little point in
+		* proceeding if we cannot access it.
+		*/
+		panic("Unable to map EFI memory map.\n");
+	}
+	memmap.map_end = memmap.map + params.mmap_size;
+	memmap.desc_size = params.desc_size;
+	memmap.desc_version = params.desc_ver;
+
+	if (uefi_init() < 0)
+		return;
+
+	reserve_regions();
+	early_memunmap(memmap.map, params.mmap_size);
+	memblock_mark_nomap(params.mmap & PAGE_MASK,
+			    PAGE_ALIGN(params.mmap_size +
+				       (params.mmap & ~PAGE_MASK)));
+}
