commit da785a87787c97823d12107a4f0ec7adcc2a78d9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jun 16 19:31:39 2020 +0300

    ARM: bcm2835: Fix integer overflow in rpi_firmware_print_firmware_revision()
    
    time64_t is 64-bit width type, we are not supposed to supply lesser ones
    as in the case of rpi_firmware_print_firmware_revision() after the commit
    4a60f58ee002 ("ARM: bcm2835: Switch to use %ptT"). Use temporary variable
    of time64_t type to correctly handle lesser types.
    
    Fixes: 4a60f58ee002 ("ARM: bcm2835: Switch to use %ptT")
    Reported-by: Stefan Wahren <wahrenst@gmx.net>
    Reported-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Revieved-by: Petr Mladek <pmladek@suse.com>
    Tested-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Link: https://lore.kernel.org/r/20200616163139.4229-1-andriy.shevchenko@linux.intel.com

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index ef8098856a47..625c8fdceabf 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -181,6 +181,7 @@ EXPORT_SYMBOL_GPL(rpi_firmware_property);
 static void
 rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
 {
+	time64_t date_and_time;
 	u32 packet;
 	int ret = rpi_firmware_property(fw,
 					RPI_FIRMWARE_GET_FIRMWARE_REVISION,
@@ -189,7 +190,9 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
 	if (ret)
 		return;
 
-	dev_info(fw->cl.dev, "Attached to firmware from %ptT\n", &packet);
+	/* This is not compatible with y2038 */
+	date_and_time = packet;
+	dev_info(fw->cl.dev, "Attached to firmware from %ptT\n", &date_and_time);
 }
 
 static void

commit 3925c3bbdf886f1ddf64461b9b380e1bb36f90c1
Merge: 9fa88c5d3f5e 2bd81cd04a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 11:01:58 2020 -0700

    Merge tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Program MPS for RCiEP devices (Ashok Raj)
    
       - Fix pci_register_host_bridge() device_register() error handling
         (Rob Herring)
    
       - Fix pci_host_bridge struct device release/free handling (Rob
         Herring)
    
      Resource management:
    
       - Allow resizing BARs for devices on root bus (Ard Biesheuvel)
    
      Power management:
    
       - Reduce Thunderbolt resume time by working around devices that don't
         support DLL Link Active reporting (Mika Westerberg)
    
       - Work around a Pericom USB controller OHCI/EHCI PME# defect
         (Kai-Heng Feng)
    
      Virtualization:
    
       - Add ACS quirk for Intel Root Complex Integrated Endpoints (Ashok
         Raj)
    
       - Avoid FLR for AMD Starship USB 3.0 (Kevin Buettner)
    
       - Avoid FLR for AMD Matisse HD Audio & USB 3.0 (Marcos Scriven)
    
      Error handling:
    
       - Use only _OSC (not HEST FIRMWARE_FIRST) to determine AER ownership
         (Alexandru Gagniuc, Kuppuswamy Sathyanarayanan)
    
       - Reduce verbosity by logging only ACPI_NOTIFY_DISCONNECT_RECOVER
         events (Kuppuswamy Sathyanarayanan)
    
       - Don't enable AER by default in Kconfig (Bjorn Helgaas)
    
      Peer-to-peer DMA:
    
       - Add AMD Zen Raven and Renoir Root Ports to whitelist (Alex Deucher)
    
      ASPM:
    
       - Allow ASPM on links to PCIe-to-PCI/PCI-X Bridges (Kai-Heng Feng)
    
      Endpoint framework:
    
       - Fix DMA channel release in test (Kunihiko Hayashi)
    
       - Add page size as argument to pci_epc_mem_init() (Lad Prabhakar)
    
       - Add support to handle multiple base for mapping outbound memory
         (Lad Prabhakar)
    
      Generic host bridge driver:
    
       - Support building as module (Rob Herring)
    
       - Eliminate pci_host_common_probe wrappers (Rob Herring)
    
      Amlogic Meson PCIe controller driver:
    
       - Don't use FAST_LINK_MODE to set up link (Marc Zyngier)
    
      Broadcom STB PCIe controller driver:
    
       - Disable ASPM L0s if 'aspm-no-l0s' in DT (Jim Quinlan)
    
       - Fix clk_put() error (Jim Quinlan)
    
       - Fix window register offset (Jim Quinlan)
    
       - Assert fundamental reset on initialization (Nicolas Saenz Julienne)
    
       - Add notify xHCI reset property (Nicolas Saenz Julienne)
    
       - Add init routine for Raspberry Pi 4 VL805 USB controller (Nicolas
         Saenz Julienne)
    
       - Sync with Raspberry Pi 4 firmware for VL805 initialization (Nicolas
         Saenz Julienne)
    
      Cadence PCIe controller driver:
    
       - Remove "cdns,max-outbound-regions" DT property (replaced by
         "ranges") (Kishon Vijay Abraham I)
    
       - Read 32-bit (not 16-bit) Vendor ID/Device ID property from DT
         (Kishon Vijay Abraham I)
    
      Marvell Aardvark PCIe controller driver:
    
       - Improve link training (Marek Behún)
    
       - Add PHY support (Marek Behún)
    
       - Add "phys", "max-link-speed", "reset-gpios" to dt-binding (Marek
         Behún)
    
       - Train link immediately after enabling training to work around
         detection issues with some cards (Pali Rohár)
    
       - Issue PERST via GPIO to work around detection issues (Pali Rohár)
    
       - Don't blindly enable ASPM L0s (Pali Rohár)
    
       - Replace custom macros by standard linux/pci_regs.h macros (Pali
         Rohár)
    
      Microsoft Hyper-V host bridge driver:
    
       - Fix probe failure path to release resource (Wei Hu)
    
       - Retry PCI bus D0 entry on invalid device state for kdump (Wei Hu)
    
      Renesas R-Car PCIe controller driver:
    
       - Fix incorrect programming of OB windows (Andrew Murray)
    
       - Add suspend/resume (Kazufumi Ikeda)
    
       - Rename pcie-rcar.c to pcie-rcar-host.c (Lad Prabhakar)
    
       - Add endpoint controller driver (Lad Prabhakar)
    
       - Fix PCIEPAMR mask calculation (Lad Prabhakar)
    
       - Add r8a77961 to DT binding (Yoshihiro Shimoda)
    
      Socionext UniPhier Pro5 controller driver:
    
       - Add endpoint controller driver (Kunihiko Hayashi)
    
      Synopsys DesignWare PCIe controller driver:
    
       - Program outbound ATU upper limit register (Alan Mikhak)
    
       - Fix inner MSI IRQ domain registration (Marc Zyngier)
    
      Miscellaneous:
    
       - Check for platform_get_irq() failure consistently (negative return
         means failure) (Aman Sharma)
    
       - Fix several runtime PM get/put imbalances (Dinghao Liu)
    
       - Use flexible-array and struct_size() helpers for code cleanup
         (Gustavo A. R. Silva)
    
       - Update & fix issues in bridge emulation of PCIe registers (Jon
         Derrick)
    
       - Add macros for bridge window names (PCI_BRIDGE_IO_WINDOW, etc)
         (Krzysztof Wilczyński)
    
       - Work around Intel PCH MROMs that have invalid BARs (Xiaochun Lee)"
    
    * tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (100 commits)
      PCI: uniphier: Add Socionext UniPhier Pro5 PCIe endpoint controller driver
      PCI: Add ACS quirk for Intel Root Complex Integrated Endpoints
      PCI/DPC: Print IRQ number used by port
      PCI/AER: Use "aer" variable for capability offset
      PCI/AER: Remove redundant dev->aer_cap checks
      PCI/AER: Remove redundant pci_is_pcie() checks
      PCI/AER: Remove HEST/FIRMWARE_FIRST parsing for AER ownership
      PCI: tegra: Fix runtime PM imbalance on error
      PCI: vmd: Filter resource type bits from shadow register
      PCI: tegra194: Fix runtime PM imbalance on error
      dt-bindings: PCI: Add UniPhier PCIe endpoint controller description
      PCI: hv: Use struct_size() helper
      PCI: Rename _DSM constants to align with spec
      PCI: Avoid FLR for AMD Starship USB 3.0
      PCI: Avoid FLR for AMD Matisse HD Audio & USB 3.0
      x86/PCI: Drop unused xen_register_pirq() gsi_override parameter
      PCI: dwc: Use private data pointer of "struct irq_domain" to get pcie_port
      PCI: amlogic: meson: Don't use FAST_LINK_MODE to set up link
      PCI: dwc: Fix inner MSI IRQ domain registration
      PCI: dwc: pci-dra7xx: Use devm_platform_ioremap_resource_byname()
      ...

commit 4a60f58ee00266ebee652e991954e48d060ea950
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 15 20:00:45 2020 +0300

    ARM: bcm2835: Switch to use %ptT
    
    Use %ptT instead of open coded variant to print content of
    time64_t type in human readable format.
    
    Link: https://lore.kernel.org/r/20200415170046.33374-3-andriy.shevchenko@linux.intel.com
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Rewieved-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index da26a584dca0..a3e85186f8e6 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -182,16 +182,10 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
 					RPI_FIRMWARE_GET_FIRMWARE_REVISION,
 					&packet, sizeof(packet));
 
-	if (ret == 0) {
-		struct tm tm;
-
-		time64_to_tm(packet, 0, &tm);
+	if (ret)
+		return;
 
-		dev_info(fw->cl.dev,
-			 "Attached to firmware from %04ld-%02d-%02d %02d:%02d\n",
-			 tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
-			 tm.tm_hour, tm.tm_min);
-	}
+	dev_info(fw->cl.dev, "Attached to firmware from %ptT\n", &packet);
 }
 
 static void

commit fbbc5ff3f7f9f4cad562e530ae2cf5d8964fe6d3
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Tue May 5 18:13:15 2020 +0200

    firmware: raspberrypi: Introduce vl805 init routine
    
    The Raspberry Pi 4 gets its USB functionality from VL805, a PCIe chip
    that implements xHCI. After a PCI reset, VL805's firmware may either be
    loaded directly from an EEPROM or, if not present, by the SoC's
    co-processor, VideoCore. RPi4's VideoCore OS contains both the non public
    firmware load logic and the VL805 firmware blob. The function this patch
    introduces triggers the aforementioned process.
    
    Link: https://lore.kernel.org/r/20200505161318.26200-3-nsaenzjulienne@suse.de
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index da26a584dca0..a166ad0cec2c 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -12,6 +12,8 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
 #include <soc/bcm2835/raspberrypi-firmware.h>
 
 #define MBOX_MSG(chan, data28)		(((data28) & ~0xf) | ((chan) & 0xf))
@@ -19,6 +21,8 @@
 #define MBOX_DATA28(msg)		((msg) & ~0xf)
 #define MBOX_CHAN_PROPERTY		8
 
+#define VL805_PCI_CONFIG_VERSION_OFFSET		0x50
+
 static struct platform_device *rpi_hwmon;
 static struct platform_device *rpi_clk;
 
@@ -286,6 +290,63 @@ struct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node)
 }
 EXPORT_SYMBOL_GPL(rpi_firmware_get);
 
+/*
+ * The Raspberry Pi 4 gets its USB functionality from VL805, a PCIe chip that
+ * implements xHCI. After a PCI reset, VL805's firmware may either be loaded
+ * directly from an EEPROM or, if not present, by the SoC's co-processor,
+ * VideoCore. RPi4's VideoCore OS contains both the non public firmware load
+ * logic and the VL805 firmware blob. This function triggers the aforementioned
+ * process.
+ */
+int rpi_firmware_init_vl805(struct pci_dev *pdev)
+{
+	struct device_node *fw_np;
+	struct rpi_firmware *fw;
+	u32 dev_addr, version;
+	int ret;
+
+	fw_np = of_find_compatible_node(NULL, NULL,
+					"raspberrypi,bcm2835-firmware");
+	if (!fw_np)
+		return 0;
+
+	fw = rpi_firmware_get(fw_np);
+	of_node_put(fw_np);
+	if (!fw)
+		return -ENODEV;
+
+	/*
+	 * Make sure we don't trigger a firmware load unnecessarily.
+	 *
+	 * If something went wrong with PCI, this whole exercise would be
+	 * futile as VideoCore expects from us a configured PCI bus. Just take
+	 * the faulty version (likely ~0) and let xHCI's registration fail
+	 * further down the line.
+	 */
+	pci_read_config_dword(pdev, VL805_PCI_CONFIG_VERSION_OFFSET, &version);
+	if (version)
+		goto exit;
+
+	dev_addr = pdev->bus->number << 20 | PCI_SLOT(pdev->devfn) << 15 |
+		   PCI_FUNC(pdev->devfn) << 12;
+
+	ret = rpi_firmware_property(fw, RPI_FIRMWARE_NOTIFY_XHCI_RESET,
+				    &dev_addr, sizeof(dev_addr));
+	if (ret)
+		return ret;
+
+	/* Wait for vl805 to startup */
+	usleep_range(200, 1000);
+
+	pci_read_config_dword(pdev, VL805_PCI_CONFIG_VERSION_OFFSET,
+			      &version);
+exit:
+	pci_info(pdev, "VL805 firmware version %08x\n", version);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rpi_firmware_init_vl805);
+
 static const struct of_device_id rpi_firmware_of_match[] = {
 	{ .compatible = "raspberrypi,bcm2835-firmware", },
 	{},

commit 91f2cf4a6b2131016b1ae9c9500245f0572112c7
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Wed Jun 12 20:24:55 2019 +0200

    firmware: raspberrypi: register clk device
    
    Since clk-raspberrypi is tied to the VC4 firmware instead of particular
    hardware it's registration should be performed by the firmware driver.
    
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index 61be15d9df7d..da26a584dca0 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -20,6 +20,7 @@
 #define MBOX_CHAN_PROPERTY		8
 
 static struct platform_device *rpi_hwmon;
+static struct platform_device *rpi_clk;
 
 struct rpi_firmware {
 	struct mbox_client cl;
@@ -207,6 +208,12 @@ rpi_register_hwmon_driver(struct device *dev, struct rpi_firmware *fw)
 						  -1, NULL, 0);
 }
 
+static void rpi_register_clk_driver(struct device *dev)
+{
+	rpi_clk = platform_device_register_data(dev, "raspberrypi-clk",
+						-1, NULL, 0);
+}
+
 static int rpi_firmware_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -234,6 +241,7 @@ static int rpi_firmware_probe(struct platform_device *pdev)
 
 	rpi_firmware_print_firmware_revision(fw);
 	rpi_register_hwmon_driver(dev, fw);
+	rpi_register_clk_driver(dev);
 
 	return 0;
 }
@@ -254,6 +262,8 @@ static int rpi_firmware_remove(struct platform_device *pdev)
 
 	platform_device_unregister(rpi_hwmon);
 	rpi_hwmon = NULL;
+	platform_device_unregister(rpi_clk);
+	rpi_clk = NULL;
 	mbox_free_channel(fw->chan);
 
 	return 0;

commit b80ec7c0ef8de5d04b893310ecae29219143a454
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Fri Dec 7 19:21:11 2018 +0100

    firmware: raspberrypi: notify VC4 firmware of a reboot
    
    The firmware-owned GPIO expander on RPi 3 B+ must be in same state
    after a reboot as initial power on. Otherwise this would cause a
    network boot failure of the BOOTROM. So inform the VC4 firmware to restore
    the expander before doing a reboot.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Phil Elwell <phil@raspberrypi.org>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index a13558154ac3..61be15d9df7d 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -238,6 +238,16 @@ static int rpi_firmware_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static void rpi_firmware_shutdown(struct platform_device *pdev)
+{
+	struct rpi_firmware *fw = platform_get_drvdata(pdev);
+
+	if (!fw)
+		return;
+
+	rpi_firmware_property(fw, RPI_FIRMWARE_NOTIFY_REBOOT, NULL, 0);
+}
+
 static int rpi_firmware_remove(struct platform_device *pdev)
 {
 	struct rpi_firmware *fw = platform_get_drvdata(pdev);
@@ -278,6 +288,7 @@ static struct platform_driver rpi_firmware_driver = {
 		.of_match_table = rpi_firmware_of_match,
 	},
 	.probe		= rpi_firmware_probe,
+	.shutdown	= rpi_firmware_shutdown,
 	.remove		= rpi_firmware_remove,
 };
 module_platform_driver(rpi_firmware_driver);

commit 502b431cda801645fd73857f7b47a4666de3cb62
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Mon Oct 22 22:26:24 2018 +0200

    firmware: raspberrypi: Switch to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management.
    
    Cc: Eric Anholt <eric@anholt.net>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index d3f7d1434657..a13558154ac3 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Defines interfaces for interacting wtih the Raspberry Pi firmware's
  * property channel.
  *
  * Copyright © 2015 Broadcom
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/dma-mapping.h>

commit 91c6ada69f396e663acb2b713e8acb8a9463557d
Author: James Hughes <james.hughes@raspberrypi.org>
Date:   Fri Nov 16 14:39:07 2018 +0000

    firmware: raspberrypi: Fix firmware calls with large buffers
    
    Commit a1547e0bca51 ("firmware: raspberrypi: Remove VLA usage")
    moved away from VLA's to a fixed maximum size for mailbox data.
    However, some mailbox calls use larger data buffers
    than the maximum allowed in that change. This fix therefor
    moves from using fixed buffers to kmalloc to ensure all sizes
    are catered for.
    
    There is some documentation, which is somewhat out of date,
    on the mailbox calls here :
    https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface
    
    Fixes: a1547e0bca51 ("firmware: raspberrypi: Remove VLA usage")
    
    Signed-off-by: James Hughes <james.hughes@raspberrypi.org>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index bf45ac450954..d3f7d1434657 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 #include <soc/bcm2835/raspberrypi-firmware.h>
 
 #define MBOX_MSG(chan, data28)		(((data28) & ~0xf) | ((chan) & 0xf))
@@ -21,8 +22,6 @@
 #define MBOX_DATA28(msg)		((msg) & ~0xf)
 #define MBOX_CHAN_PROPERTY		8
 
-#define MAX_RPI_FW_PROP_BUF_SIZE	32
-
 static struct platform_device *rpi_hwmon;
 
 struct rpi_firmware {
@@ -148,28 +147,30 @@ EXPORT_SYMBOL_GPL(rpi_firmware_property_list);
 int rpi_firmware_property(struct rpi_firmware *fw,
 			  u32 tag, void *tag_data, size_t buf_size)
 {
-	/* Single tags are very small (generally 8 bytes), so the
-	 * stack should be safe.
-	 */
-	u8 data[sizeof(struct rpi_firmware_property_tag_header) +
-		MAX_RPI_FW_PROP_BUF_SIZE];
-	struct rpi_firmware_property_tag_header *header =
-		(struct rpi_firmware_property_tag_header *)data;
+	struct rpi_firmware_property_tag_header *header;
 	int ret;
 
-	if (WARN_ON(buf_size > sizeof(data) - sizeof(*header)))
-		return -EINVAL;
+	/* Some mailboxes can use over 1k bytes. Rather than checking
+	 * size and using stack or kmalloc depending on requirements,
+	 * just use kmalloc. Mailboxes don't get called enough to worry
+	 * too much about the time taken in the allocation.
+	 */
+	void *data = kmalloc(sizeof(*header) + buf_size, GFP_KERNEL);
 
+	if (!data)
+		return -ENOMEM;
+
+	header = data;
 	header->tag = tag;
 	header->buf_size = buf_size;
 	header->req_resp_size = 0;
-	memcpy(data + sizeof(struct rpi_firmware_property_tag_header),
-	       tag_data, buf_size);
+	memcpy(data + sizeof(*header), tag_data, buf_size);
+
+	ret = rpi_firmware_property_list(fw, data, buf_size + sizeof(*header));
+
+	memcpy(tag_data, data + sizeof(*header), buf_size);
 
-	ret = rpi_firmware_property_list(fw, &data, buf_size + sizeof(*header));
-	memcpy(tag_data,
-	       data + sizeof(struct rpi_firmware_property_tag_header),
-	       buf_size);
+	kfree(data);
 
 	return ret;
 }

commit 0829187b17d8019f9bb40c56d47f37b1991a2189
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sat Oct 6 13:31:56 2018 +0200

    firmware: raspberrypi: Define timeout for transactions
    
    We should never assume to get a reply from the firmware otherwise
    the call could block forever and the user don't get informed. So
    define a timeout of 1 sec and print a stacktrace once in the unlikely
    case the timeout expired.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index a200a2174611..bf45ac450954 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -56,8 +56,12 @@ rpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)
 	reinit_completion(&fw->c);
 	ret = mbox_send_message(fw->chan, &message);
 	if (ret >= 0) {
-		wait_for_completion(&fw->c);
-		ret = 0;
+		if (wait_for_completion_timeout(&fw->c, HZ)) {
+			ret = 0;
+		} else {
+			ret = -ETIMEDOUT;
+			WARN_ONCE(1, "Firmware transaction timeout");
+		}
 	} else {
 		dev_err(fw->cl.dev, "mbox_send_message returned %d\n", ret);
 	}

commit a1547e0bca519b92b09ac5530c6accb7c3f69d1a
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jun 29 11:44:50 2018 -0700

    firmware: raspberrypi: Remove VLA usage
    
    In the quest to remove all stack VLA usage from the kernel[1], this
    removes the VLA in favor of a maximum size and adds a sanity check.
    Existing callers of the firmware interface never need more than 24
    bytes (struct gpio_set_config). This chooses 32 just to stay ahead
    of future growth.
    
    v2: Fix the length passed to rpi_firmware_property_list (by anholt,
        acked by Kees).
    
    [1] https://lkml.kernel.org/r/CA+55aFzCG-zNmZwX4A2FQpadafLfEzK6CC=qPXydAacU1RqZWA@mail.gmail.com
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index 0602626bf72d..a200a2174611 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -21,6 +21,8 @@
 #define MBOX_DATA28(msg)		((msg) & ~0xf)
 #define MBOX_CHAN_PROPERTY		8
 
+#define MAX_RPI_FW_PROP_BUF_SIZE	32
+
 static struct platform_device *rpi_hwmon;
 
 struct rpi_firmware {
@@ -145,18 +147,22 @@ int rpi_firmware_property(struct rpi_firmware *fw,
 	/* Single tags are very small (generally 8 bytes), so the
 	 * stack should be safe.
 	 */
-	u8 data[buf_size + sizeof(struct rpi_firmware_property_tag_header)];
+	u8 data[sizeof(struct rpi_firmware_property_tag_header) +
+		MAX_RPI_FW_PROP_BUF_SIZE];
 	struct rpi_firmware_property_tag_header *header =
 		(struct rpi_firmware_property_tag_header *)data;
 	int ret;
 
+	if (WARN_ON(buf_size > sizeof(data) - sizeof(*header)))
+		return -EINVAL;
+
 	header->tag = tag;
 	header->buf_size = buf_size;
 	header->req_resp_size = 0;
 	memcpy(data + sizeof(struct rpi_firmware_property_tag_header),
 	       tag_data, buf_size);
 
-	ret = rpi_firmware_property_list(fw, &data, sizeof(data));
+	ret = rpi_firmware_property_list(fw, &data, buf_size + sizeof(*header));
 	memcpy(tag_data,
 	       data + sizeof(struct rpi_firmware_property_tag_header),
 	       buf_size);

commit 70eea1bbb5561154e62b322904b685acb0e52d3e
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Fri May 25 21:24:36 2018 +0200

    firmware: raspberrypi: Register hwmon driver
    
    Since the raspberrypi-hwmon driver is tied to the VC4 firmware instead of
    particular hardware its registration should be in the firmware driver.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index 6692888f04cf..0602626bf72d 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -21,6 +21,8 @@
 #define MBOX_DATA28(msg)		((msg) & ~0xf)
 #define MBOX_CHAN_PROPERTY		8
 
+static struct platform_device *rpi_hwmon;
+
 struct rpi_firmware {
 	struct mbox_client cl;
 	struct mbox_chan *chan; /* The property channel. */
@@ -183,6 +185,20 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
 	}
 }
 
+static void
+rpi_register_hwmon_driver(struct device *dev, struct rpi_firmware *fw)
+{
+	u32 packet;
+	int ret = rpi_firmware_property(fw, RPI_FIRMWARE_GET_THROTTLED,
+					&packet, sizeof(packet));
+
+	if (ret)
+		return;
+
+	rpi_hwmon = platform_device_register_data(dev, "raspberrypi-hwmon",
+						  -1, NULL, 0);
+}
+
 static int rpi_firmware_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -209,6 +225,7 @@ static int rpi_firmware_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, fw);
 
 	rpi_firmware_print_firmware_revision(fw);
+	rpi_register_hwmon_driver(dev, fw);
 
 	return 0;
 }
@@ -217,6 +234,8 @@ static int rpi_firmware_remove(struct platform_device *pdev)
 {
 	struct rpi_firmware *fw = platform_get_drvdata(pdev);
 
+	platform_device_unregister(rpi_hwmon);
+	rpi_hwmon = NULL;
 	mbox_free_channel(fw->chan);
 
 	return 0;

commit 9107ee6a50b81180f29a9f6588b21917dde2abdd
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 27 12:57:14 2017 +0100

    firmware: raspberrypi: print time using time64_t
    
    The firmware timestamp is an unsigned 32-bit value, but we copy it into
    a signed 32-bit variable, so we can theoretically get an overflow in
    the calculation when the timestamp is between 2038 and 2106.
    
    This changes the temporary variable to time64_t and changes the deprecated
    time_to_tm() over to time64_to_tm() accordingly.
    
    There is still an overflow in y2106, but that is a limitation of the
    firmware interface, not a kernel problem.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
index dd506cd3a5b8..6692888f04cf 100644
--- a/drivers/firmware/raspberrypi.c
+++ b/drivers/firmware/raspberrypi.c
@@ -174,7 +174,7 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
 	if (ret == 0) {
 		struct tm tm;
 
-		time_to_tm(packet, 0, &tm);
+		time64_to_tm(packet, 0, &tm);
 
 		dev_info(fw->cl.dev,
 			 "Attached to firmware from %04ld-%02d-%02d %02d:%02d\n",

commit 4e3d60656a7235b6b6e86d7ef48b0394276c35b5
Author: Eric Anholt <eric@anholt.net>
Date:   Thu Feb 26 10:08:06 2015 +0000

    ARM: bcm2835: Add the Raspberry Pi firmware driver
    
    This gives us a function for making mailbox property channel requests
    of the firmware, which is most notable in that it will let us get and
    set clock rates.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>

diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
new file mode 100644
index 000000000000..dd506cd3a5b8
--- /dev/null
+++ b/drivers/firmware/raspberrypi.c
@@ -0,0 +1,260 @@
+/*
+ * Defines interfaces for interacting wtih the Raspberry Pi firmware's
+ * property channel.
+ *
+ * Copyright © 2015 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <soc/bcm2835/raspberrypi-firmware.h>
+
+#define MBOX_MSG(chan, data28)		(((data28) & ~0xf) | ((chan) & 0xf))
+#define MBOX_CHAN(msg)			((msg) & 0xf)
+#define MBOX_DATA28(msg)		((msg) & ~0xf)
+#define MBOX_CHAN_PROPERTY		8
+
+struct rpi_firmware {
+	struct mbox_client cl;
+	struct mbox_chan *chan; /* The property channel. */
+	struct completion c;
+	u32 enabled;
+};
+
+static DEFINE_MUTEX(transaction_lock);
+
+static void response_callback(struct mbox_client *cl, void *msg)
+{
+	struct rpi_firmware *fw = container_of(cl, struct rpi_firmware, cl);
+	complete(&fw->c);
+}
+
+/*
+ * Sends a request to the firmware through the BCM2835 mailbox driver,
+ * and synchronously waits for the reply.
+ */
+static int
+rpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)
+{
+	u32 message = MBOX_MSG(chan, data);
+	int ret;
+
+	WARN_ON(data & 0xf);
+
+	mutex_lock(&transaction_lock);
+	reinit_completion(&fw->c);
+	ret = mbox_send_message(fw->chan, &message);
+	if (ret >= 0) {
+		wait_for_completion(&fw->c);
+		ret = 0;
+	} else {
+		dev_err(fw->cl.dev, "mbox_send_message returned %d\n", ret);
+	}
+	mutex_unlock(&transaction_lock);
+
+	return ret;
+}
+
+/**
+ * rpi_firmware_property_list - Submit firmware property list
+ * @fw:		Pointer to firmware structure from rpi_firmware_get().
+ * @data:	Buffer holding tags.
+ * @tag_size:	Size of tags buffer.
+ *
+ * Submits a set of concatenated tags to the VPU firmware through the
+ * mailbox property interface.
+ *
+ * The buffer header and the ending tag are added by this function and
+ * don't need to be supplied, just the actual tags for your operation.
+ * See struct rpi_firmware_property_tag_header for the per-tag
+ * structure.
+ */
+int rpi_firmware_property_list(struct rpi_firmware *fw,
+			       void *data, size_t tag_size)
+{
+	size_t size = tag_size + 12;
+	u32 *buf;
+	dma_addr_t bus_addr;
+	int ret;
+
+	/* Packets are processed a dword at a time. */
+	if (size & 3)
+		return -EINVAL;
+
+	buf = dma_alloc_coherent(fw->cl.dev, PAGE_ALIGN(size), &bus_addr,
+				 GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+
+	/* The firmware will error out without parsing in this case. */
+	WARN_ON(size >= 1024 * 1024);
+
+	buf[0] = size;
+	buf[1] = RPI_FIRMWARE_STATUS_REQUEST;
+	memcpy(&buf[2], data, tag_size);
+	buf[size / 4 - 1] = RPI_FIRMWARE_PROPERTY_END;
+	wmb();
+
+	ret = rpi_firmware_transaction(fw, MBOX_CHAN_PROPERTY, bus_addr);
+
+	rmb();
+	memcpy(data, &buf[2], tag_size);
+	if (ret == 0 && buf[1] != RPI_FIRMWARE_STATUS_SUCCESS) {
+		/*
+		 * The tag name here might not be the one causing the
+		 * error, if there were multiple tags in the request.
+		 * But single-tag is the most common, so go with it.
+		 */
+		dev_err(fw->cl.dev, "Request 0x%08x returned status 0x%08x\n",
+			buf[2], buf[1]);
+		ret = -EINVAL;
+	}
+
+	dma_free_coherent(fw->cl.dev, PAGE_ALIGN(size), buf, bus_addr);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rpi_firmware_property_list);
+
+/**
+ * rpi_firmware_property - Submit single firmware property
+ * @fw:		Pointer to firmware structure from rpi_firmware_get().
+ * @tag:	One of enum_mbox_property_tag.
+ * @tag_data:	Tag data buffer.
+ * @buf_size:	Buffer size.
+ *
+ * Submits a single tag to the VPU firmware through the mailbox
+ * property interface.
+ *
+ * This is a convenience wrapper around
+ * rpi_firmware_property_list() to avoid some of the
+ * boilerplate in property calls.
+ */
+int rpi_firmware_property(struct rpi_firmware *fw,
+			  u32 tag, void *tag_data, size_t buf_size)
+{
+	/* Single tags are very small (generally 8 bytes), so the
+	 * stack should be safe.
+	 */
+	u8 data[buf_size + sizeof(struct rpi_firmware_property_tag_header)];
+	struct rpi_firmware_property_tag_header *header =
+		(struct rpi_firmware_property_tag_header *)data;
+	int ret;
+
+	header->tag = tag;
+	header->buf_size = buf_size;
+	header->req_resp_size = 0;
+	memcpy(data + sizeof(struct rpi_firmware_property_tag_header),
+	       tag_data, buf_size);
+
+	ret = rpi_firmware_property_list(fw, &data, sizeof(data));
+	memcpy(tag_data,
+	       data + sizeof(struct rpi_firmware_property_tag_header),
+	       buf_size);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rpi_firmware_property);
+
+static void
+rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
+{
+	u32 packet;
+	int ret = rpi_firmware_property(fw,
+					RPI_FIRMWARE_GET_FIRMWARE_REVISION,
+					&packet, sizeof(packet));
+
+	if (ret == 0) {
+		struct tm tm;
+
+		time_to_tm(packet, 0, &tm);
+
+		dev_info(fw->cl.dev,
+			 "Attached to firmware from %04ld-%02d-%02d %02d:%02d\n",
+			 tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			 tm.tm_hour, tm.tm_min);
+	}
+}
+
+static int rpi_firmware_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rpi_firmware *fw;
+
+	fw = devm_kzalloc(dev, sizeof(*fw), GFP_KERNEL);
+	if (!fw)
+		return -ENOMEM;
+
+	fw->cl.dev = dev;
+	fw->cl.rx_callback = response_callback;
+	fw->cl.tx_block = true;
+
+	fw->chan = mbox_request_channel(&fw->cl, 0);
+	if (IS_ERR(fw->chan)) {
+		int ret = PTR_ERR(fw->chan);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to get mbox channel: %d\n", ret);
+		return ret;
+	}
+
+	init_completion(&fw->c);
+
+	platform_set_drvdata(pdev, fw);
+
+	rpi_firmware_print_firmware_revision(fw);
+
+	return 0;
+}
+
+static int rpi_firmware_remove(struct platform_device *pdev)
+{
+	struct rpi_firmware *fw = platform_get_drvdata(pdev);
+
+	mbox_free_channel(fw->chan);
+
+	return 0;
+}
+
+/**
+ * rpi_firmware_get - Get pointer to rpi_firmware structure.
+ * @firmware_node:    Pointer to the firmware Device Tree node.
+ *
+ * Returns NULL is the firmware device is not ready.
+ */
+struct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node)
+{
+	struct platform_device *pdev = of_find_device_by_node(firmware_node);
+
+	if (!pdev)
+		return NULL;
+
+	return platform_get_drvdata(pdev);
+}
+EXPORT_SYMBOL_GPL(rpi_firmware_get);
+
+static const struct of_device_id rpi_firmware_of_match[] = {
+	{ .compatible = "raspberrypi,bcm2835-firmware", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rpi_firmware_of_match);
+
+static struct platform_driver rpi_firmware_driver = {
+	.driver = {
+		.name = "raspberrypi-firmware",
+		.of_match_table = rpi_firmware_of_match,
+	},
+	.probe		= rpi_firmware_probe,
+	.remove		= rpi_firmware_remove,
+};
+module_platform_driver(rpi_firmware_driver);
+
+MODULE_AUTHOR("Eric Anholt <eric@anholt.net>");
+MODULE_DESCRIPTION("Raspberry Pi firmware driver");
+MODULE_LICENSE("GPL v2");
