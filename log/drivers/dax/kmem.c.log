commit 8a725e4694b52ffad755500277d36f3b2eb34755
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jun 4 16:48:48 2020 -0700

    device-dax: add memory via add_memory_driver_managed()
    
    Currently, when adding memory, we create entries in /sys/firmware/memmap/
    as "System RAM".  This will lead to kexec-tools to add that memory to the
    fixed-up initial memmap for a kexec kernel (loaded via kexec_load()).  The
    memory will be considered initial System RAM by the kexec'd kernel and can
    no longer be reconfigured.  This is not what happens during a real reboot.
    
    Let's add our memory via add_memory_driver_managed() now, so we won't
    create entries in /sys/firmware/memmap/ and indicate the memory as "System
    RAM (kmem)" in /proc/iomem.  This allows everybody (especially
    kexec-tools) to identify that this memory is special and has to be treated
    differently than ordinary (hotplugged) System RAM.
    
    Before configuring the namespace:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-33fffffff : namespace0.0
            3280000000-32ffffffff : PCI Bus 0000:00
    
    After configuring the namespace:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              148200000-33fffffff : dax0.0
            3280000000-32ffffffff : PCI Bus 0000:00
    
    After loading kmem before this change:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              150000000-33fffffff : dax0.0
                150000000-33fffffff : System RAM
            3280000000-32ffffffff : PCI Bus 0000:00
    
    After loading kmem after this change:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              150000000-33fffffff : dax0.0
                150000000-33fffffff : System RAM (kmem)
            3280000000-32ffffffff : PCI Bus 0000:00
    
    After a proper reboot:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              148200000-33fffffff : dax0.0
            3280000000-32ffffffff : PCI Bus 0000:00
    
    Within the kexec kernel before this change:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              150000000-33fffffff : System RAM
            3280000000-32ffffffff : PCI Bus 0000:00
    
    Within the kexec kernel after this change:
            [root@localhost ~]# cat /proc/iomem
            ...
            140000000-33fffffff : Persistent Memory
              140000000-1481fffff : namespace0.0
              148200000-33fffffff : dax0.0
            3280000000-32ffffffff : PCI Bus 0000:00
    
    /sys/firmware/memmap/ before this change:
            0000000000000000-000000000009fc00 (System RAM)
            000000000009fc00-00000000000a0000 (Reserved)
            00000000000f0000-0000000000100000 (Reserved)
            0000000000100000-00000000bffdf000 (System RAM)
            00000000bffdf000-00000000c0000000 (Reserved)
            00000000feffc000-00000000ff000000 (Reserved)
            00000000fffc0000-0000000100000000 (Reserved)
            0000000100000000-0000000140000000 (System RAM)
            0000000150000000-0000000340000000 (System RAM)
    
    /sys/firmware/memmap/ after a proper reboot:
            0000000000000000-000000000009fc00 (System RAM)
            000000000009fc00-00000000000a0000 (Reserved)
            00000000000f0000-0000000000100000 (Reserved)
            0000000000100000-00000000bffdf000 (System RAM)
            00000000bffdf000-00000000c0000000 (Reserved)
            00000000feffc000-00000000ff000000 (Reserved)
            00000000fffc0000-0000000100000000 (Reserved)
            0000000100000000-0000000140000000 (System RAM)
    
    /sys/firmware/memmap/ after this change:
            0000000000000000-000000000009fc00 (System RAM)
            000000000009fc00-00000000000a0000 (Reserved)
            00000000000f0000-0000000000100000 (Reserved)
            0000000000100000-00000000bffdf000 (System RAM)
            00000000bffdf000-00000000c0000000 (Reserved)
            00000000feffc000-00000000ff000000 (Reserved)
            00000000fffc0000-0000000100000000 (Reserved)
            0000000100000000-0000000140000000 (System RAM)
    
    kexec-tools already seem to basically ignore any System RAM that's not on
    top level when searching for areas to place kexec images - but also for
    determining crash areas to dump via kdump.  Changing the resource name
    won't have an impact.
    
    Handle unloading of the driver after memory hotremove failed properly, by
    duplicating the string if necessary.
    
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Pankaj Gupta <pankaj.gupta.linux@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Pankaj Gupta <pankaj.gupta.linux@gmail.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Link: http://lkml.kernel.org/r/20200508084217.9160-5-david@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/dax/kmem.c b/drivers/dax/kmem.c
index 1e678bdf5aed..275aa5f87399 100644
--- a/drivers/dax/kmem.c
+++ b/drivers/dax/kmem.c
@@ -14,6 +14,11 @@
 #include "dax-private.h"
 #include "bus.h"
 
+/* Memory resource name used for add_memory_driver_managed(). */
+static const char *kmem_name;
+/* Set if any memory will remain added when the driver will be unloaded. */
+static bool any_hotremove_failed;
+
 int dev_dax_kmem_probe(struct device *dev)
 {
 	struct dev_dax *dev_dax = to_dev_dax(dev);
@@ -70,7 +75,12 @@ int dev_dax_kmem_probe(struct device *dev)
 	 */
 	new_res->flags = IORESOURCE_SYSTEM_RAM;
 
-	rc = add_memory(numa_node, new_res->start, resource_size(new_res));
+	/*
+	 * Ensure that future kexec'd kernels will not treat this as RAM
+	 * automatically.
+	 */
+	rc = add_memory_driver_managed(numa_node, new_res->start,
+				       resource_size(new_res), kmem_name);
 	if (rc) {
 		release_resource(new_res);
 		kfree(new_res);
@@ -100,6 +110,7 @@ static int dev_dax_kmem_remove(struct device *dev)
 	 */
 	rc = remove_memory(dev_dax->target_node, kmem_start, kmem_size);
 	if (rc) {
+		any_hotremove_failed = true;
 		dev_err(dev,
 			"DAX region %pR cannot be hotremoved until the next reboot\n",
 			res);
@@ -124,6 +135,7 @@ static int dev_dax_kmem_remove(struct device *dev)
 	 * permanently pinned as reserved by the unreleased
 	 * request_mem_region().
 	 */
+	any_hotremove_failed = true;
 	return 0;
 }
 #endif /* CONFIG_MEMORY_HOTREMOVE */
@@ -137,12 +149,24 @@ static struct dax_device_driver device_dax_kmem_driver = {
 
 static int __init dax_kmem_init(void)
 {
-	return dax_driver_register(&device_dax_kmem_driver);
+	int rc;
+
+	/* Resource name is permanently allocated if any hotremove fails. */
+	kmem_name = kstrdup_const("System RAM (kmem)", GFP_KERNEL);
+	if (!kmem_name)
+		return -ENOMEM;
+
+	rc = dax_driver_register(&device_dax_kmem_driver);
+	if (rc)
+		kfree_const(kmem_name);
+	return rc;
 }
 
 static void __exit dax_kmem_exit(void)
 {
 	dax_driver_unregister(&device_dax_kmem_driver);
+	if (!any_hotremove_failed)
+		kfree_const(kmem_name);
 }
 
 MODULE_AUTHOR("Intel Corporation");

commit 60858c00e5f018eda711a3aa84cf62214ef62d61
Author: David Hildenbrand <david@redhat.com>
Date:   Fri May 22 22:22:42 2020 -0700

    device-dax: don't leak kernel memory to user space after unloading kmem
    
    Assume we have kmem configured and loaded:
    
      [root@localhost ~]# cat /proc/iomem
      ...
      140000000-33fffffff : Persistent Memory$
        140000000-1481fffff : namespace0.0
        150000000-33fffffff : dax0.0
          150000000-33fffffff : System RAM
    
    Assume we try to unload kmem. This force-unloading will work, even if
    memory cannot get removed from the system.
    
      [root@localhost ~]# rmmod kmem
      [   86.380228] removing memory fails, because memory [0x0000000150000000-0x0000000157ffffff] is onlined
      ...
      [   86.431225] kmem dax0.0: DAX region [mem 0x150000000-0x33fffffff] cannot be hotremoved until the next reboot
    
    Now, we can reconfigure the namespace:
    
      [root@localhost ~]# ndctl create-namespace --force --reconfig=namespace0.0 --mode=devdax
      [  131.409351] nd_pmem namespace0.0: could not reserve region [mem 0x140000000-0x33fffffff]dax
      [  131.410147] nd_pmem: probe of namespace0.0 failed with error -16namespace0.0 --mode=devdax
      ...
    
    This fails as expected due to the busy memory resource, and the memory
    cannot be used.  However, the dax0.0 device is removed, and along its
    name.
    
    The name of the memory resource now points at freed memory (name of the
    device):
    
      [root@localhost ~]# cat /proc/iomem
      ...
      140000000-33fffffff : Persistent Memory
        140000000-1481fffff : namespace0.0
        150000000-33fffffff : �_�^7_��/_��wR��WQ���^��� ...
        150000000-33fffffff : System RAM
    
    We have to make sure to duplicate the string.  While at it, remove the
    superfluous setting of the name and fixup a stale comment.
    
    Fixes: 9f960da72b25 ("device-dax: "Hotremove" persistent memory that is used like normal RAM")
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: <stable@vger.kernel.org>    [5.3]
    Link: http://lkml.kernel.org/r/20200508084217.9160-2-david@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/dax/kmem.c b/drivers/dax/kmem.c
index 3d0a7e702c94..1e678bdf5aed 100644
--- a/drivers/dax/kmem.c
+++ b/drivers/dax/kmem.c
@@ -22,6 +22,7 @@ int dev_dax_kmem_probe(struct device *dev)
 	resource_size_t kmem_size;
 	resource_size_t kmem_end;
 	struct resource *new_res;
+	const char *new_res_name;
 	int numa_node;
 	int rc;
 
@@ -48,11 +49,16 @@ int dev_dax_kmem_probe(struct device *dev)
 	kmem_size &= ~(memory_block_size_bytes() - 1);
 	kmem_end = kmem_start + kmem_size;
 
-	/* Region is permanently reserved.  Hot-remove not yet implemented. */
-	new_res = request_mem_region(kmem_start, kmem_size, dev_name(dev));
+	new_res_name = kstrdup(dev_name(dev), GFP_KERNEL);
+	if (!new_res_name)
+		return -ENOMEM;
+
+	/* Region is permanently reserved if hotremove fails. */
+	new_res = request_mem_region(kmem_start, kmem_size, new_res_name);
 	if (!new_res) {
 		dev_warn(dev, "could not reserve region [%pa-%pa]\n",
 			 &kmem_start, &kmem_end);
+		kfree(new_res_name);
 		return -EBUSY;
 	}
 
@@ -63,12 +69,12 @@ int dev_dax_kmem_probe(struct device *dev)
 	 * unknown to us that will break add_memory() below.
 	 */
 	new_res->flags = IORESOURCE_SYSTEM_RAM;
-	new_res->name = dev_name(dev);
 
 	rc = add_memory(numa_node, new_res->start, resource_size(new_res));
 	if (rc) {
 		release_resource(new_res);
 		kfree(new_res);
+		kfree(new_res_name);
 		return rc;
 	}
 	dev_dax->dax_kmem_res = new_res;
@@ -83,6 +89,7 @@ static int dev_dax_kmem_remove(struct device *dev)
 	struct resource *res = dev_dax->dax_kmem_res;
 	resource_size_t kmem_start = res->start;
 	resource_size_t kmem_size = resource_size(res);
+	const char *res_name = res->name;
 	int rc;
 
 	/*
@@ -102,6 +109,7 @@ static int dev_dax_kmem_remove(struct device *dev)
 	/* Release and free dax resources */
 	release_resource(res);
 	kfree(res);
+	kfree(res_name);
 	dev_dax->dax_kmem_res = NULL;
 
 	return 0;

commit 9f960da72b25054163cf555e622dcdc3b8ccc488
Author: Pavel Tatashin <pasha.tatashin@soleen.com>
Date:   Tue Jul 16 16:30:35 2019 -0700

    device-dax: "Hotremove" persistent memory that is used like normal RAM
    
    It is now allowed to use persistent memory like a regular RAM, but
    currently there is no way to remove this memory until machine is
    rebooted.
    
    This work expands the functionality to also allows hotremoving
    previously hotplugged persistent memory, and recover the device for use
    for other purposes.
    
    To hotremove persistent memory, the management software must first
    offline all memory blocks of dax region, and than unbind it from
    device-dax/kmem driver.  So, operations should look like this:
    
      echo offline > /sys/devices/system/memory/memoryN/state
      ...
      echo dax0.0 > /sys/bus/dax/drivers/kmem/unbind
    
    Note: if unbind is done without offlining memory beforehand, it won't be
    possible to do dax0.0 hotremove, and dax's memory is going to be part of
    System RAM until reboot.
    
    Link: http://lkml.kernel.org/r/20190517215438.6487-4-pasha.tatashin@soleen.com
    Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Reviewed-by: David Hildenbrand <david@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Ross Zwisler <zwisler@kernel.org>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jérôme Glisse <jglisse@redhat.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/dax/kmem.c b/drivers/dax/kmem.c
index 4c0131857133..3d0a7e702c94 100644
--- a/drivers/dax/kmem.c
+++ b/drivers/dax/kmem.c
@@ -71,21 +71,54 @@ int dev_dax_kmem_probe(struct device *dev)
 		kfree(new_res);
 		return rc;
 	}
+	dev_dax->dax_kmem_res = new_res;
 
 	return 0;
 }
 
+#ifdef CONFIG_MEMORY_HOTREMOVE
+static int dev_dax_kmem_remove(struct device *dev)
+{
+	struct dev_dax *dev_dax = to_dev_dax(dev);
+	struct resource *res = dev_dax->dax_kmem_res;
+	resource_size_t kmem_start = res->start;
+	resource_size_t kmem_size = resource_size(res);
+	int rc;
+
+	/*
+	 * We have one shot for removing memory, if some memory blocks were not
+	 * offline prior to calling this function remove_memory() will fail, and
+	 * there is no way to hotremove this memory until reboot because device
+	 * unbind will succeed even if we return failure.
+	 */
+	rc = remove_memory(dev_dax->target_node, kmem_start, kmem_size);
+	if (rc) {
+		dev_err(dev,
+			"DAX region %pR cannot be hotremoved until the next reboot\n",
+			res);
+		return rc;
+	}
+
+	/* Release and free dax resources */
+	release_resource(res);
+	kfree(res);
+	dev_dax->dax_kmem_res = NULL;
+
+	return 0;
+}
+#else
 static int dev_dax_kmem_remove(struct device *dev)
 {
 	/*
-	 * Purposely leak the request_mem_region() for the device-dax
-	 * range and return '0' to ->remove() attempts. The removal of
-	 * the device from the driver always succeeds, but the region
-	 * is permanently pinned as reserved by the unreleased
+	 * Without hotremove purposely leak the request_mem_region() for the
+	 * device-dax range and return '0' to ->remove() attempts. The removal
+	 * of the device from the driver always succeeds, but the region is
+	 * permanently pinned as reserved by the unreleased
 	 * request_mem_region().
 	 */
 	return 0;
 }
+#endif /* CONFIG_MEMORY_HOTREMOVE */
 
 static struct dax_device_driver device_dax_kmem_driver = {
 	.drv = {

commit 31e4ca92a7dd4cdebd7fe1456b3b0b6ace9a816f
Author: Pavel Tatashin <pasha.tatashin@soleen.com>
Date:   Tue Jul 16 16:30:27 2019 -0700

    device-dax: fix memory and resource leak if hotplug fails
    
    Patch series ""Hotremove" persistent memory", v6.
    
    Recently, adding a persistent memory to be used like a regular RAM was
    added to Linux.  This work extends this functionality to also allow hot
    removing persistent memory.
    
    We (Microsoft) have an important use case for this functionality.
    
    The requirement is for physical machines with small amount of RAM (~8G)
    to be able to reboot in a very short period of time (<1s).  Yet, there
    is a userland state that is expensive to recreate (~2G).
    
    The solution is to boot machines with 2G preserved for persistent
    memory.
    
    Copy the state, and hotadd the persistent memory so machine still has
    all 8G available for runtime.  Before reboot, offline and hotremove
    device-dax 2G, copy the memory that is needed to be preserved to pmem0
    device, and reboot.
    
    The series of operations look like this:
    
    1. After boot restore /dev/pmem0 to ramdisk to be consumed by apps.
       and free ramdisk.
    2. Convert raw pmem0 to devdax
       ndctl create-namespace --mode devdax --map mem -e namespace0.0 -f
    3. Hotadd to System RAM
       echo dax0.0 > /sys/bus/dax/drivers/device_dax/unbind
       echo dax0.0 > /sys/bus/dax/drivers/kmem/new_id
       echo online_movable > /sys/devices/system/memoryXXX/state
    4. Before reboot hotremove device-dax memory from System RAM
       echo offline > /sys/devices/system/memoryXXX/state
       echo dax0.0 > /sys/bus/dax/drivers/kmem/unbind
    5. Create raw pmem0 device
       ndctl create-namespace --mode raw  -e namespace0.0 -f
    6. Copy the state that was stored by apps to ramdisk to pmem device
    7. Do kexec reboot or reboot through firmware if firmware does not
       zero memory in pmem0 region (These machines have only regular
       volatile memory). So to have pmem0 device either memmap kernel
       parameter is used, or devices nodes in dtb are specified.
    
    This patch (of 3):
    
    When add_memory() fails, the resource and the memory should be freed.
    
    Link: http://lkml.kernel.org/r/20190517215438.6487-2-pasha.tatashin@soleen.com
    Fixes: c221c0b0308f ("device-dax: "Hotplug" persistent memory for use like normal RAM")
    Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Reviewed-by: Dave Hansen <dave.hansen@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Jérôme Glisse <jglisse@redhat.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Ross Zwisler <zwisler@kernel.org>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/dax/kmem.c b/drivers/dax/kmem.c
index a02318c6d28a..4c0131857133 100644
--- a/drivers/dax/kmem.c
+++ b/drivers/dax/kmem.c
@@ -66,8 +66,11 @@ int dev_dax_kmem_probe(struct device *dev)
 	new_res->name = dev_name(dev);
 
 	rc = add_memory(numa_node, new_res->start, resource_size(new_res));
-	if (rc)
+	if (rc) {
+		release_resource(new_res);
+		kfree(new_res);
 		return rc;
+	}
 
 	return 0;
 }

commit c221c0b0308fd01d9fb33a16f64d2fd95f8830a4
Author: Dave Hansen <dave.hansen@linux.intel.com>
Date:   Mon Feb 25 10:57:40 2019 -0800

    device-dax: "Hotplug" persistent memory for use like normal RAM
    
    This is intended for use with NVDIMMs that are physically persistent
    (physically like flash) so that they can be used as a cost-effective
    RAM replacement.  Intel Optane DC persistent memory is one
    implementation of this kind of NVDIMM.
    
    Currently, a persistent memory region is "owned" by a device driver,
    either the "Direct DAX" or "Filesystem DAX" drivers.  These drivers
    allow applications to explicitly use persistent memory, generally
    by being modified to use special, new libraries. (DIMM-based
    persistent memory hardware/software is described in great detail
    here: Documentation/nvdimm/nvdimm.txt).
    
    However, this limits persistent memory use to applications which
    *have* been modified.  To make it more broadly usable, this driver
    "hotplugs" memory into the kernel, to be managed and used just like
    normal RAM would be.
    
    To make this work, management software must remove the device from
    being controlled by the "Device DAX" infrastructure:
    
            echo dax0.0 > /sys/bus/dax/drivers/device_dax/unbind
    
    and then tell the new driver that it can bind to the device:
    
            echo dax0.0 > /sys/bus/dax/drivers/kmem/new_id
    
    After this, there will be a number of new memory sections visible
    in sysfs that can be onlined, or that may get onlined by existing
    udev-initiated memory hotplug rules.
    
    This rebinding procedure is currently a one-way trip.  Once memory
    is bound to "kmem", it's there permanently and can not be
    unbound and assigned back to device_dax.
    
    The kmem driver will never bind to a dax device unless the device
    is *explicitly* bound to the driver.  There are two reasons for
    this: One, since it is a one-way trip, it can not be undone if
    bound incorrectly.  Two, the kmem driver destroys data on the
    device.  Think of if you had good data on a pmem device.  It
    would be catastrophic if you compile-in "kmem", but leave out
    the "device_dax" driver.  kmem would take over the device and
    write volatile data all over your good data.
    
    This inherits any existing NUMA information for the newly-added
    memory from the persistent memory device that came from the
    firmware.  On Intel platforms, the firmware has guarantees that
    require each socket's persistent memory to be in a separate
    memory-only NUMA node.  That means that this patch is not expected
    to create NUMA nodes, but will simply hotplug memory into existing
    nodes.
    
    Because NUMA nodes are created, the existing NUMA APIs and tools
    are sufficient to create policies for applications or memory areas
    to have affinity for or an aversion to using this memory.
    
    There is currently some metadata at the beginning of pmem regions.
    The section-size memory hotplug restrictions, plus this small
    reserved area can cause the "loss" of a section or two of capacity.
    This should be fixable in follow-on patches.  But, as a first step,
    losing 256MB of memory (worst case) out of hundreds of gigabytes
    is a good tradeoff vs. the required code to fix this up precisely.
    This calculation is also the reason we export
    memory_block_size_bytes().
    
    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Ross Zwisler <zwisler@kernel.org>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: linux-nvdimm@lists.01.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mm@kvack.org
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dax/kmem.c b/drivers/dax/kmem.c
new file mode 100644
index 000000000000..a02318c6d28a
--- /dev/null
+++ b/drivers/dax/kmem.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2016-2019 Intel Corporation. All rights reserved. */
+#include <linux/memremap.h>
+#include <linux/pagemap.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/pfn_t.h>
+#include <linux/slab.h>
+#include <linux/dax.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include "dax-private.h"
+#include "bus.h"
+
+int dev_dax_kmem_probe(struct device *dev)
+{
+	struct dev_dax *dev_dax = to_dev_dax(dev);
+	struct resource *res = &dev_dax->region->res;
+	resource_size_t kmem_start;
+	resource_size_t kmem_size;
+	resource_size_t kmem_end;
+	struct resource *new_res;
+	int numa_node;
+	int rc;
+
+	/*
+	 * Ensure good NUMA information for the persistent memory.
+	 * Without this check, there is a risk that slow memory
+	 * could be mixed in a node with faster memory, causing
+	 * unavoidable performance issues.
+	 */
+	numa_node = dev_dax->target_node;
+	if (numa_node < 0) {
+		dev_warn(dev, "rejecting DAX region %pR with invalid node: %d\n",
+			 res, numa_node);
+		return -EINVAL;
+	}
+
+	/* Hotplug starting at the beginning of the next block: */
+	kmem_start = ALIGN(res->start, memory_block_size_bytes());
+
+	kmem_size = resource_size(res);
+	/* Adjust the size down to compensate for moving up kmem_start: */
+	kmem_size -= kmem_start - res->start;
+	/* Align the size down to cover only complete blocks: */
+	kmem_size &= ~(memory_block_size_bytes() - 1);
+	kmem_end = kmem_start + kmem_size;
+
+	/* Region is permanently reserved.  Hot-remove not yet implemented. */
+	new_res = request_mem_region(kmem_start, kmem_size, dev_name(dev));
+	if (!new_res) {
+		dev_warn(dev, "could not reserve region [%pa-%pa]\n",
+			 &kmem_start, &kmem_end);
+		return -EBUSY;
+	}
+
+	/*
+	 * Set flags appropriate for System RAM.  Leave ..._BUSY clear
+	 * so that add_memory() can add a child resource.  Do not
+	 * inherit flags from the parent since it may set new flags
+	 * unknown to us that will break add_memory() below.
+	 */
+	new_res->flags = IORESOURCE_SYSTEM_RAM;
+	new_res->name = dev_name(dev);
+
+	rc = add_memory(numa_node, new_res->start, resource_size(new_res));
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int dev_dax_kmem_remove(struct device *dev)
+{
+	/*
+	 * Purposely leak the request_mem_region() for the device-dax
+	 * range and return '0' to ->remove() attempts. The removal of
+	 * the device from the driver always succeeds, but the region
+	 * is permanently pinned as reserved by the unreleased
+	 * request_mem_region().
+	 */
+	return 0;
+}
+
+static struct dax_device_driver device_dax_kmem_driver = {
+	.drv = {
+		.probe = dev_dax_kmem_probe,
+		.remove = dev_dax_kmem_remove,
+	},
+};
+
+static int __init dax_kmem_init(void)
+{
+	return dax_driver_register(&device_dax_kmem_driver);
+}
+
+static void __exit dax_kmem_exit(void)
+{
+	dax_driver_unregister(&device_dax_kmem_driver);
+}
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL v2");
+module_init(dax_kmem_init);
+module_exit(dax_kmem_exit);
+MODULE_ALIAS_DAX_DEVICE(0);
