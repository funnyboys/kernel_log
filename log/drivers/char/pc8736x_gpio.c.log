commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 5f4be88c0dfc..c39a836ebd15 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* linux/drivers/char/pc8736x_gpio.c
 
    National Semiconductor PC8736x GPIO driver.  Allows a user space

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 3f79a9fb6b1b..5f4be88c0dfc 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -20,7 +20,7 @@
 #include <linux/mutex.h>
 #include <linux/nsc_gpio.h>
 #include <linux/platform_device.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #define DEVNAME "pc8736x_gpio"
 

commit 1b3c16556a386fa019c48783f0f615fb416cb53b
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Oct 23 13:24:09 2012 +0800

    pc8736x_gpio: use platform_device_unregister in pc8736x_gpio_cleanup()
    
    platform_device_unregister() only calls platform_device_del() and
    platform_device_put(), thus use platform_device_unregister() to
    simplify the code.
    
    Also the documents in platform.c shows that platform_device_del
    and platform_device_put must _only_ be externally called in error
    cases.  All other usage is a bug.
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index b304ec052501..3f79a9fb6b1b 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -345,8 +345,7 @@ static void __exit pc8736x_gpio_cleanup(void)
 	unregister_chrdev_region(MKDEV(major,0), PC8736X_GPIO_CT);
 	release_region(pc8736x_gpio_base, PC8736X_GPIO_RANGE);
 
-	platform_device_del(pdev);
-	platform_device_put(pdev);
+	platform_device_unregister(pdev);
 }
 
 module_init(pc8736x_gpio_init);

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 8ecbcc174c15..b304ec052501 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -234,6 +234,7 @@ static const struct file_operations pc8736x_gpio_fileops = {
 	.open	= pc8736x_gpio_open,
 	.write	= nsc_gpio_write,
 	.read	= nsc_gpio_read,
+	.llseek = no_llseek,
 };
 
 static void __init pc8736x_init_shadow(void)

commit 71d69bc2c0202f438669073d849999d2f6b6ca31
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 10 15:56:00 2009 +0200

    drivers: Remove BKL from pc8736x_gpio
    
    cycle_kernel_lock() was added during the big BKL pushdown. It should
    ensure the serializiation against driver init code. In this case there
    is nothing to serialize. Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <20091010153350.127093710@linutronix.de>
    Acked-by: Jim Cromie <jim.cromie@gmail.com>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 3f7da8cf3a80..8ecbcc174c15 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -20,7 +20,6 @@
 #include <linux/mutex.h>
 #include <linux/nsc_gpio.h>
 #include <linux/platform_device.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 
 #define DEVNAME "pc8736x_gpio"
@@ -223,7 +222,6 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 	unsigned m = iminor(inode);
 	file->private_data = &pc8736x_gpio_ops;
 
-	cycle_kernel_lock();
 	dev_dbg(&pdev->dev, "open %d\n", m);
 
 	if (m >= PC8736X_GPIO_CT)

commit b64fd291acd8c921b4757faed1d4dded31c27edf
Author: Andre Haupt <andre@bitwigglers.org>
Date:   Sat Oct 18 20:28:33 2008 -0700

    pc8736x_gpio: add support for PC87365 chips
    
    This is only compile tested, because I do not own appropriate hardware.
    
    Signed-off-by: Andre Haupt <andre@bitwigglers.org>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index b930de50407a..3f7da8cf3a80 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -41,7 +41,8 @@ static u8 pc8736x_gpio_shadow[4];
 #define SIO_BASE2       0x4E	/* alt command-reg to check */
 
 #define SIO_SID		0x20	/* SuperI/O ID Register */
-#define SIO_SID_VALUE	0xe9	/* Expected value in SuperI/O ID Register */
+#define SIO_SID_PC87365	0xe5	/* Expected value in ID Register for PC87365 */
+#define SIO_SID_PC87366	0xe9	/* Expected value in ID Register for PC87366 */
 
 #define SIO_CF1		0x21	/* chip config, bit0 is chip enable */
 
@@ -91,13 +92,17 @@ static inline int superio_inb(int addr)
 
 static int pc8736x_superio_present(void)
 {
+	int id;
+
 	/* try the 2 possible values, read a hardware reg to verify */
 	superio_cmd = SIO_BASE1;
-	if (superio_inb(SIO_SID) == SIO_SID_VALUE)
+	id = superio_inb(SIO_SID);
+	if (id == SIO_SID_PC87365 || id == SIO_SID_PC87366)
 		return superio_cmd;
 
 	superio_cmd = SIO_BASE2;
-	if (superio_inb(SIO_SID) == SIO_SID_VALUE)
+	id = superio_inb(SIO_SID);
+	if (id == SIO_SID_PC87365 || id == SIO_SID_PC87366)
 		return superio_cmd;
 
 	return 0;

commit f2b9857eee17797541b845782ade4d7a9d50f843
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Sun May 18 15:32:43 2008 -0600

    Add a bunch of cycle_kernel_lock() calls
    
    All of the open() functions which don't need the BKL on their face may
    still depend on its acquisition to serialize opens against driver
    initialization.  So make those functions acquire then release the BKL to be
    on the safe side.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 8715dc9f4a53..b930de50407a 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -20,6 +20,7 @@
 #include <linux/mutex.h>
 #include <linux/nsc_gpio.h>
 #include <linux/platform_device.h>
+#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 
 #define DEVNAME "pc8736x_gpio"
@@ -212,12 +213,12 @@ static struct nsc_gpio_ops pc8736x_gpio_ops = {
 	.gpio_current	= pc8736x_gpio_current
 };
 
-/* No BKL needed here; no global resources accessed */
 static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
 	file->private_data = &pc8736x_gpio_ops;
 
+	cycle_kernel_lock();
 	dev_dbg(&pdev->dev, "open %d\n", m);
 
 	if (m >= PC8736X_GPIO_CT)

commit d21c95c569c462da20d491b75d0a45bd70ddc1bf
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri May 16 13:40:30 2008 -0600

    Add "no BKL needed" comments to several drivers
    
    This documents the fact that somebody looked at the relevant open()
    functions and concluded that, due to their trivial nature, no locking was
    needed.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index ecfaf180e5bd..8715dc9f4a53 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -212,6 +212,7 @@ static struct nsc_gpio_ops pc8736x_gpio_ops = {
 	.gpio_current	= pc8736x_gpio_current
 };
 
+/* No BKL needed here; no global resources accessed */
 static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);

commit 6299a2dec89d22940e36832f15c0addfb77e6910
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Sep 29 01:59:05 2006 -0700

    [PATCH] drivers/char/pc8736x_gpio.c: remove unused static functions
    
    drivers/char/pc8736x_gpio.c:192: warning: #pc8736x_gpio_set_high# defined but not used
    drivers/char/pc8736x_gpio.c:197: warning: #pc8736x_gpio_set_low# defined but not used
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 84e5a68635f1..ecfaf180e5bd 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -188,16 +188,6 @@ static void pc8736x_gpio_set(unsigned minor, int val)
 	pc8736x_gpio_shadow[port] = val;
 }
 
-static void pc8736x_gpio_set_high(unsigned index)
-{
-	pc8736x_gpio_set(index, 1);
-}
-
-static void pc8736x_gpio_set_low(unsigned index)
-{
-	pc8736x_gpio_set(index, 0);
-}
-
 static int pc8736x_gpio_current(unsigned minor)
 {
 	int port, bit;

commit 5e44ef238b7eb607532e89249e7b2523faf77a92
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jul 30 03:03:07 2006 -0700

    [PATCH] drivers/char/pc8736x_gpio.c: unexport a static struct
    
    A static struct mustn't be exported.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 645eb81cb5a9..84e5a68635f1 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -221,7 +221,6 @@ static struct nsc_gpio_ops pc8736x_gpio_ops = {
 	.gpio_change	= pc8736x_gpio_change,
 	.gpio_current	= pc8736x_gpio_current
 };
-EXPORT_SYMBOL(pc8736x_gpio_ops);
 
 static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 {

commit 2e8f7a3128bb8fac8351a994f1fc325717899308
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:26 2006 -0700

    [PATCH] gpio: rename exported vtables to better match purpose
    
    - rename EXPORTed gpio vtables from {scx200,pc8736x}_access to _gpio_ops new
      name is much closer to the vtable-name struct nsc_gpio_ops, should be
      clearer.  Also rename the _fops vtable var to _fileops to better
      disambiguate it from the gpio vtable.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 0b235a90beef..645eb81cb5a9 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -212,7 +212,7 @@ static void pc8736x_gpio_change(unsigned index)
 	pc8736x_gpio_set(index, !pc8736x_gpio_current(index));
 }
 
-static struct nsc_gpio_ops pc8736x_access = {
+static struct nsc_gpio_ops pc8736x_gpio_ops = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= pc8736x_gpio_configure,
 	.gpio_dump	= nsc_gpio_dump,
@@ -221,11 +221,12 @@ static struct nsc_gpio_ops pc8736x_access = {
 	.gpio_change	= pc8736x_gpio_change,
 	.gpio_current	= pc8736x_gpio_current
 };
+EXPORT_SYMBOL(pc8736x_gpio_ops);
 
 static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
-	file->private_data = &pc8736x_access;
+	file->private_data = &pc8736x_gpio_ops;
 
 	dev_dbg(&pdev->dev, "open %d\n", m);
 
@@ -234,7 +235,7 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 	return nonseekable_open(inode, file);
 }
 
-static const struct file_operations pc8736x_gpio_fops = {
+static const struct file_operations pc8736x_gpio_fileops = {
 	.owner	= THIS_MODULE,
 	.open	= pc8736x_gpio_open,
 	.write	= nsc_gpio_write,
@@ -276,7 +277,7 @@ static int __init pc8736x_gpio_init(void)
 		dev_err(&pdev->dev, "no device found\n");
 		goto undo_platform_dev_add;
 	}
-	pc8736x_access.dev = &pdev->dev;
+	pc8736x_gpio_ops.dev = &pdev->dev;
 
 	/* Verify that chip and it's GPIO unit are both enabled.
 	   My BIOS does this, so I take minimum action here
@@ -326,7 +327,7 @@ static int __init pc8736x_gpio_init(void)
 	pc8736x_init_shadow();
 
 	/* ignore minor errs, and succeed */
-	cdev_init(&pc8736x_gpio_cdev, &pc8736x_gpio_fops);
+	cdev_init(&pc8736x_gpio_cdev, &pc8736x_gpio_fileops);
 	cdev_add(&pc8736x_gpio_cdev, devid, PC8736X_GPIO_CT);
 
 	return 0;
@@ -353,7 +354,5 @@ static void __exit pc8736x_gpio_cleanup(void)
 	platform_device_put(pdev);
 }
 
-EXPORT_SYMBOL(pc8736x_access);
-
 module_init(pc8736x_gpio_init);
 module_exit(pc8736x_gpio_cleanup);

commit 91e260b80d2fec559877f399dfc36b554f207874
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:25 2006 -0700

    [PATCH] gpio: drop vtable members .gpio_set_high .gpio_set_low gpio_set is enough
    
    drops gpio_set_high, gpio_set_low from the nsc_gpio_ops vtable.  While we
    can't drop them from scx200_gpio (or can we?), we dont need them for new users
    of the exported vtable; gpio_set(1), gpio_set(0) work fine.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 11bd78c80628..0b235a90beef 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -218,8 +218,6 @@ static struct nsc_gpio_ops pc8736x_access = {
 	.gpio_dump	= nsc_gpio_dump,
 	.gpio_get	= pc8736x_gpio_get,
 	.gpio_set	= pc8736x_gpio_set,
-	.gpio_set_high	= pc8736x_gpio_set_high,
-	.gpio_set_low	= pc8736x_gpio_set_low,
 	.gpio_change	= pc8736x_gpio_change,
 	.gpio_current	= pc8736x_gpio_current
 };

commit babcfade47371eea81fd7f24d892b5ff5b1786ea
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Mon Jul 10 04:45:37 2006 -0700

    [PATCH] pc8736x_gpio: fix re-modprobe errors: fix/finish cdev-init
    
    - Switch from register_chrdev() to   (register|alloc)_chrdev_region().
    
    - use a cdev.  This was intended for original patchset, but was
      overlooked.
    
      We use a single cdev for all pins (minor device-numbers), as gleaned
      from cs5535_gpio, and in contrast to whats currently done in scx200_gpio
      (which I'll fix soon)
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index bfc45e0cc602..11bd78c80628 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -259,7 +259,8 @@ static struct cdev pc8736x_gpio_cdev;
 
 static int __init pc8736x_gpio_init(void)
 {
-	int rc = 0;
+	int rc;
+	dev_t devid;
 
 	pdev = platform_device_alloc(DEVNAME, 0);
 	if (!pdev)
@@ -307,7 +308,14 @@ static int __init pc8736x_gpio_init(void)
 	}
 	dev_info(&pdev->dev, "GPIO ioport %x reserved\n", pc8736x_gpio_base);
 
-	rc = register_chrdev(major, DEVNAME, &pc8736x_gpio_fops);
+	if (major) {
+		devid = MKDEV(major, 0);
+		rc = register_chrdev_region(devid, PC8736X_GPIO_CT, DEVNAME);
+	} else {
+		rc = alloc_chrdev_region(&devid, 0, PC8736X_GPIO_CT, DEVNAME);
+		major = MAJOR(devid);
+	}
+
 	if (rc < 0) {
 		dev_err(&pdev->dev, "register-chrdev failed: %d\n", rc);
 		goto undo_request_region;
@@ -318,6 +326,11 @@ static int __init pc8736x_gpio_init(void)
 	}
 
 	pc8736x_init_shadow();
+
+	/* ignore minor errs, and succeed */
+	cdev_init(&pc8736x_gpio_cdev, &pc8736x_gpio_fops);
+	cdev_add(&pc8736x_gpio_cdev, devid, PC8736X_GPIO_CT);
+
 	return 0;
 
 undo_request_region:

commit 27385085f19a9bc9b147905554e6e2509fdaceb2
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Mon Jul 10 04:45:36 2006 -0700

    [PATCH] pc8736x_gpio: fix re-modprobe errors: undo region reservation
    
    Fix module-init-func by repairing usage of platform_device_del/put in
    module-exit-func.  IOW, it imitates Ingo's 'mishaps' patch, which fixed the
    module-init-func's undo handling.
    
    Also fixes lack of release_region to undo the earlier registration.
    
    Also starts to 'use a cdev' which was originally intended (its present in
    scx200_gpio).  Code compiles and runs, exhibits a lesser error than
    previously.  (re-register-chrdev fails)
    
    Since I had to add "include <linux/cdev.h>", I went ahead and made 2
    tweaks that fell into diff-context-window:
    - remove include <linux/config.h>      everyone's doing it
    - copyright updates - current date is 'wrong'
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 5b09efcf60a6..bfc45e0cc602 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -3,18 +3,18 @@
    National Semiconductor PC8736x GPIO driver.  Allows a user space
    process to play with the GPIO pins.
 
-   Copyright (c) 2005 Jim Cromie <jim.cromie@gmail.com>
+   Copyright (c) 2005,2006 Jim Cromie <jim.cromie@gmail.com>
 
    adapted from linux/drivers/char/scx200_gpio.c
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>,
 */
 
-#include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/cdev.h>
 #include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/mutex.h>
@@ -255,6 +255,8 @@ static void __init pc8736x_init_shadow(void)
 
 }
 
+static struct cdev pc8736x_gpio_cdev;
+
 static int __init pc8736x_gpio_init(void)
 {
 	int rc = 0;
@@ -308,7 +310,7 @@ static int __init pc8736x_gpio_init(void)
 	rc = register_chrdev(major, DEVNAME, &pc8736x_gpio_fops);
 	if (rc < 0) {
 		dev_err(&pdev->dev, "register-chrdev failed: %d\n", rc);
-		goto undo_platform_dev_add;
+		goto undo_request_region;
 	}
 	if (!major) {
 		major = rc;
@@ -318,6 +320,8 @@ static int __init pc8736x_gpio_init(void)
 	pc8736x_init_shadow();
 	return 0;
 
+undo_request_region:
+	release_region(pc8736x_gpio_base, PC8736X_GPIO_RANGE);
 undo_platform_dev_add:
 	platform_device_del(pdev);
 undo_platform_dev_alloc:
@@ -328,11 +332,14 @@ static int __init pc8736x_gpio_init(void)
 
 static void __exit pc8736x_gpio_cleanup(void)
 {
-	dev_dbg(&pdev->dev, " cleanup\n");
+	dev_dbg(&pdev->dev, "cleanup\n");
 
-	release_region(pc8736x_gpio_base, 16);
+	cdev_del(&pc8736x_gpio_cdev);
+	unregister_chrdev_region(MKDEV(major,0), PC8736X_GPIO_CT);
+	release_region(pc8736x_gpio_base, PC8736X_GPIO_RANGE);
 
-	unregister_chrdev(major, DEVNAME);
+	platform_device_del(pdev);
+	platform_device_put(pdev);
 }
 
 EXPORT_SYMBOL(pc8736x_access);

commit 4f197842d0f3dd994882407f8760f2eda9005191
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Mon Jul 10 04:45:35 2006 -0700

    [PATCH] pc8736x_gpio: fix re-modprobe errors: define and use constants
    
    add constant defines - preparatory patch
    
    - adds #define CONSTs  for max-pin,  gpio-addr-range (for reserving region)
    - fix wrong max-pin check in gpio_open()
    - add 'Winbond' to module description.  NSC sold the product, Winbond
      has supported us / lm-sensors
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 4005ee0aa11e..5b09efcf60a6 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -25,7 +25,7 @@
 #define DEVNAME "pc8736x_gpio"
 
 MODULE_AUTHOR("Jim Cromie <jim.cromie@gmail.com>");
-MODULE_DESCRIPTION("NatSemi PC-8736x GPIO Pin Driver");
+MODULE_DESCRIPTION("NatSemi/Winbond PC-8736x GPIO Pin Driver");
 MODULE_LICENSE("GPL");
 
 static int major;		/* default to dynamic major */
@@ -38,14 +38,14 @@ static u8 pc8736x_gpio_shadow[4];
 
 #define SIO_BASE1       0x2E	/* 1st command-reg to check */
 #define SIO_BASE2       0x4E	/* alt command-reg to check */
-#define SIO_BASE_OFFSET 0x20
 
 #define SIO_SID		0x20	/* SuperI/O ID Register */
 #define SIO_SID_VALUE	0xe9	/* Expected value in SuperI/O ID Register */
 
 #define SIO_CF1		0x21	/* chip config, bit0 is chip enable */
 
-#define PC8736X_GPIO_SIZE	16
+#define PC8736X_GPIO_RANGE	16 /* ioaddr range */
+#define PC8736X_GPIO_CT		32 /* minors matching 4 8 bit ports */
 
 #define SIO_UNIT_SEL	0x7	/* unit select reg */
 #define SIO_UNIT_ACT	0x30	/* unit enable */
@@ -231,7 +231,7 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 
 	dev_dbg(&pdev->dev, "open %d\n", m);
 
-	if (m > 63)
+	if (m >= PC8736X_GPIO_CT)
 		return -EINVAL;
 	return nonseekable_open(inode, file);
 }
@@ -297,7 +297,7 @@ static int __init pc8736x_gpio_init(void)
 	pc8736x_gpio_base = (superio_inb(SIO_BASE_HADDR) << 8
 			     | superio_inb(SIO_BASE_LADDR));
 
-	if (!request_region(pc8736x_gpio_base, 16, DEVNAME)) {
+	if (!request_region(pc8736x_gpio_base, PC8736X_GPIO_RANGE, DEVNAME)) {
 		rc = -ENODEV;
 		dev_err(&pdev->dev, "GPIO ioport %x busy\n",
 			pc8736x_gpio_base);

commit 62322d2554d2f9680c8ace7bbf1f97d8fa84ad1a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Jul 3 00:24:21 2006 -0700

    [PATCH] make more file_operation structs static
    
    Mark the static struct file_operations in drivers/char as const.  Making
    them const prevents accidental bugs, and moves them to the .rodata section
    so that they no longer do any false sharing; in addition with the proper
    debug option they are then protected against corruption..
    
    [akpm@osdl.org: build fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index c860de6a6fde..4005ee0aa11e 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -236,7 +236,7 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 	return nonseekable_open(inode, file);
 }
 
-static struct file_operations pc8736x_gpio_fops = {
+static const struct file_operations pc8736x_gpio_fops = {
 	.owner	= THIS_MODULE,
 	.open	= pc8736x_gpio_open,
 	.write	= nsc_gpio_write,

commit 1017f6afd578fe519d316d7148356703c04e8f03
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jun 30 01:55:29 2006 -0700

    [PATCH] fix platform_device_put/del mishaps
    
    This fixes drivers/char/pc8736x_gpio.c and drivers/char/scx200_gpio.c to
    use the platform_device_del/put ops correctly.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 1c706ccfdbb3..c860de6a6fde 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -319,9 +319,10 @@ static int __init pc8736x_gpio_init(void)
 	return 0;
 
 undo_platform_dev_add:
-	platform_device_put(pdev);
+	platform_device_del(pdev);
 undo_platform_dev_alloc:
-	kfree(pdev);
+	platform_device_put(pdev);
+
 	return rc;
 }
 

commit ec312310e43acd5bb8b49314c6d472bb60d2d30c
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:25 2006 -0700

    [PATCH] gpio-patchset-fixups: include linux/io.h
    
    Hmm.  Im somewhat ambivalent about this patch, since with it, driver wont
    build for vanilla 17 or older.
    
    Its also only 1/2 of your suggestion - when I tried it, I was building against
    vanilla 17, and asm/uaccess.h cause compilation failure.  Looking back, Im
    perplexed as to why linux/io.h didnt cause same failure ?!?
    
    use linux/io.h rather than asm/io.h
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 72dcf222f141..1c706ccfdbb3 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -15,12 +15,12 @@
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/mutex.h>
 #include <linux/nsc_gpio.h>
 #include <linux/platform_device.h>
 #include <asm/uaccess.h>
-#include <asm/io.h>
 
 #define DEVNAME "pc8736x_gpio"
 

commit 8bcf6135c3e8cdfab375f4041a48721483519eee
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:25 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: replace spinlocks w mutexes
    
    Replace spinlocks guarding gpio config ops with mutexes.  This is a me-too
    patch, and is justifiable insofar as mutexes have stricter semantics and
    better debugging support, so are preferred where they are applicable.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index b8183d508332..72dcf222f141 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -16,6 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/mutex.h>
 #include <linux/nsc_gpio.h>
 #include <linux/platform_device.h>
 #include <asm/uaccess.h>
@@ -31,7 +32,7 @@ static int major;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
-static DEFINE_SPINLOCK(pc8736x_gpio_config_lock);
+static DEFINE_MUTEX(pc8736x_gpio_config_lock);
 static unsigned pc8736x_gpio_base;
 static u8 pc8736x_gpio_shadow[4];
 
@@ -119,9 +120,8 @@ static inline u32 pc8736x_gpio_configure_fn(unsigned index, u32 mask, u32 bits,
 					    u32 func_slct)
 {
 	u32 config, new_config;
-	unsigned long flags;
 
-	spin_lock_irqsave(&pc8736x_gpio_config_lock, flags);
+	mutex_lock(&pc8736x_gpio_config_lock);
 
 	device_select(SIO_GPIO_UNIT);
 	select_pin(index);
@@ -133,7 +133,7 @@ static inline u32 pc8736x_gpio_configure_fn(unsigned index, u32 mask, u32 bits,
 	new_config = (config & mask) | bits;
 	superio_outb(func_slct, new_config);
 
-	spin_unlock_irqrestore(&pc8736x_gpio_config_lock, flags);
+	mutex_unlock(&pc8736x_gpio_config_lock);
 
 	return config;
 }

commit 6cad56fd884b7eb85ae193c94b688fe76680fcbf
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:24 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: fix gpio_current, use shadow regs
    
    Add a working gpio_current() to pc8736x_gpio.c (the previous implementation
    just threw a dev_warn), and fix gpio_change() to use gpio_current() rather
    than the incorrect (and temporary) gpio_get().  Initialize shadow-regs so this
    all works.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 48ff1fc8b06d..b8183d508332 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -33,6 +33,7 @@ MODULE_PARM_DESC(major, "Major device number");
 
 static DEFINE_SPINLOCK(pc8736x_gpio_config_lock);
 static unsigned pc8736x_gpio_base;
+static u8 pc8736x_gpio_shadow[4];
 
 #define SIO_BASE1       0x2E	/* 1st command-reg to check */
 #define SIO_BASE2       0x4E	/* alt command-reg to check */
@@ -184,6 +185,7 @@ static void pc8736x_gpio_set(unsigned minor, int val)
 	val = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_IN);
 
 	dev_dbg(&pdev->dev, "wrote %x, read: %x\n", curval, val);
+	pc8736x_gpio_shadow[port] = val;
 }
 
 static void pc8736x_gpio_set_high(unsigned index)
@@ -196,15 +198,18 @@ static void pc8736x_gpio_set_low(unsigned index)
 	pc8736x_gpio_set(index, 0);
 }
 
-static int pc8736x_gpio_current(unsigned index)
+static int pc8736x_gpio_current(unsigned minor)
 {
-	dev_warn(&pdev->dev, "pc8736x_gpio_current unimplemented\n");
-	return 0;
+	int port, bit;
+	minor &= 0x1f;
+	port = minor >> 3;
+	bit = minor & 7;
+	return ((pc8736x_gpio_shadow[port] >> bit) & 0x01);
 }
 
 static void pc8736x_gpio_change(unsigned index)
 {
-	pc8736x_gpio_set(index, !pc8736x_gpio_get(index));
+	pc8736x_gpio_set(index, !pc8736x_gpio_current(index));
 }
 
 static struct nsc_gpio_ops pc8736x_access = {
@@ -238,6 +243,18 @@ static struct file_operations pc8736x_gpio_fops = {
 	.read	= nsc_gpio_read,
 };
 
+static void __init pc8736x_init_shadow(void)
+{
+	int port;
+
+	/* read the current values driven on the GPIO signals */
+	for (port = 0; port < 4; ++port)
+		pc8736x_gpio_shadow[port]
+		    = inb_p(pc8736x_gpio_base + port_offset[port]
+			    + PORT_OUT);
+
+}
+
 static int __init pc8736x_gpio_init(void)
 {
 	int rc = 0;
@@ -317,5 +334,7 @@ static void __exit pc8736x_gpio_cleanup(void)
 	unregister_chrdev(major, DEVNAME);
 }
 
+EXPORT_SYMBOL(pc8736x_access);
+
 module_init(pc8736x_gpio_init);
 module_exit(pc8736x_gpio_cleanup);

commit f31000e573da052b6b8bcc21faff520b4e2eda7a
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:23 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: use dev_dbg in common module
    
    Use of dev_dbg() and friends is considered good practice.  dev_dbg() needs a
    struct device *devp, but nsc_gpio is only a helper module, so it doesnt
    have/need its own.  To provide devp to the user-modules (scx200 & pc8736x
    _gpio), we add it to the vtable, and set it during init.
    
    Also squeeze nsc_gpio_dump()'s format a little.
    
    [  199.259879]  pc8736x_gpio.0: io09: 0x0044 TS OD PUE  EDGE LO DEBOUNCE
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index b16fbef816c2..48ff1fc8b06d 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -207,8 +207,6 @@ static void pc8736x_gpio_change(unsigned index)
 	pc8736x_gpio_set(index, !pc8736x_gpio_get(index));
 }
 
-extern void nsc_gpio_dump(unsigned iminor);
-
 static struct nsc_gpio_ops pc8736x_access = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= pc8736x_gpio_configure,
@@ -260,6 +258,7 @@ static int __init pc8736x_gpio_init(void)
 		dev_err(&pdev->dev, "no device found\n");
 		goto undo_platform_dev_add;
 	}
+	pc8736x_access.dev = &pdev->dev;
 
 	/* Verify that chip and it's GPIO unit are both enabled.
 	   My BIOS does this, so I take minimum action here

commit 58b087cda1e9e46c7061c2282f92bd8e1970bfe7
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:22 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: add platform_device for use w dev_dbg
    
    Adds platform-device to (just introduced) driver, and uses it to replace many
    printks with dev_dbg() etc.  This could trivially be merged into previous
    patch, but this way matches better with the corresponding patch that does the
    same change to scx200_gpio.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
index 83f24279f54e..b16fbef816c2 100644
--- a/drivers/char/pc8736x_gpio.c
+++ b/drivers/char/pc8736x_gpio.c
@@ -17,13 +17,14 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/nsc_gpio.h>
+#include <linux/platform_device.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
-#define NAME "pc8736x_gpio"
+#define DEVNAME "pc8736x_gpio"
 
 MODULE_AUTHOR("Jim Cromie <jim.cromie@gmail.com>");
-MODULE_DESCRIPTION("NatSemi SCx200 GPIO Pin Driver");
+MODULE_DESCRIPTION("NatSemi PC-8736x GPIO Pin Driver");
 MODULE_LICENSE("GPL");
 
 static int major;		/* default to dynamic major */
@@ -42,6 +43,8 @@ static unsigned pc8736x_gpio_base;
 
 #define SIO_CF1		0x21	/* chip config, bit0 is chip enable */
 
+#define PC8736X_GPIO_SIZE	16
+
 #define SIO_UNIT_SEL	0x7	/* unit select reg */
 #define SIO_UNIT_ACT	0x30	/* unit enable */
 #define SIO_GPIO_UNIT	0x7	/* unit number of GPIO */
@@ -69,6 +72,8 @@ static int port_offset[] = { 0, 4, 8, 10 };	/* non-uniform offsets ! */
 #define PORT_EVT_EN	2
 #define PORT_EVT_STST	3
 
+static struct platform_device *pdev;  /* use in dev_*() */
+
 static inline void superio_outb(int addr, int val)
 {
 	outb_p(addr, superio_cmd);
@@ -148,9 +153,9 @@ static int pc8736x_gpio_get(unsigned minor)
 	val >>= bit;
 	val &= 1;
 
-	printk(KERN_INFO NAME ": _gpio_get(%d from %x bit %d) == val %d\n",
-	       minor, pc8736x_gpio_base + port_offset[port] + PORT_IN, bit,
-	       val);
+	dev_dbg(&pdev->dev, "_gpio_get(%d from %x bit %d) == val %d\n",
+		minor, pc8736x_gpio_base + port_offset[port] + PORT_IN, bit,
+		val);
 
 	return val;
 }
@@ -164,22 +169,21 @@ static void pc8736x_gpio_set(unsigned minor, int val)
 	bit = minor & 7;
 	curval = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_OUT);
 
-	printk(KERN_INFO NAME
-	       ": addr:%x cur:%x bit-pos:%d cur-bit:%x + new:%d -> bit-new:%d\n",
-	       pc8736x_gpio_base + port_offset[port] + PORT_OUT,
-	       curval, bit, (curval & ~(1 << bit)), val, (val << bit));
+	dev_dbg(&pdev->dev, "addr:%x cur:%x bit-pos:%d cur-bit:%x + new:%d -> bit-new:%d\n",
+		pc8736x_gpio_base + port_offset[port] + PORT_OUT,
+		curval, bit, (curval & ~(1 << bit)), val, (val << bit));
 
 	val = (curval & ~(1 << bit)) | (val << bit);
 
-	printk(KERN_INFO NAME ": gpio_set(minor:%d port:%d bit:%d"
-	       ") %2x -> %2x\n", minor, port, bit, curval, val);
+	dev_dbg(&pdev->dev, "gpio_set(minor:%d port:%d bit:%d)"
+		" %2x -> %2x\n", minor, port, bit, curval, val);
 
 	outb_p(val, pc8736x_gpio_base + port_offset[port] + PORT_OUT);
 
 	curval = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_OUT);
 	val = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_IN);
 
-	printk(KERN_INFO NAME ": wrote %x, read: %x\n", curval, val);
+	dev_dbg(&pdev->dev, "wrote %x, read: %x\n", curval, val);
 }
 
 static void pc8736x_gpio_set_high(unsigned index)
@@ -194,7 +198,7 @@ static void pc8736x_gpio_set_low(unsigned index)
 
 static int pc8736x_gpio_current(unsigned index)
 {
-	printk(KERN_WARNING NAME ": pc8736x_gpio_current unimplemented\n");
+	dev_warn(&pdev->dev, "pc8736x_gpio_current unimplemented\n");
 	return 0;
 }
 
@@ -222,7 +226,7 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 	unsigned m = iminor(inode);
 	file->private_data = &pc8736x_access;
 
-	printk(KERN_NOTICE NAME " open %d\n", m);
+	dev_dbg(&pdev->dev, "open %d\n", m);
 
 	if (m > 63)
 		return -EINVAL;
@@ -230,21 +234,31 @@ static int pc8736x_gpio_open(struct inode *inode, struct file *file)
 }
 
 static struct file_operations pc8736x_gpio_fops = {
-	.owner = THIS_MODULE,
-	.open = pc8736x_gpio_open,
-	.write = nsc_gpio_write,
-	.read = nsc_gpio_read,
+	.owner	= THIS_MODULE,
+	.open	= pc8736x_gpio_open,
+	.write	= nsc_gpio_write,
+	.read	= nsc_gpio_read,
 };
 
 static int __init pc8736x_gpio_init(void)
 {
-	int r, rc;
+	int rc = 0;
+
+	pdev = platform_device_alloc(DEVNAME, 0);
+	if (!pdev)
+		return -ENOMEM;
 
-	printk(KERN_DEBUG NAME " initializing\n");
+	rc = platform_device_add(pdev);
+	if (rc) {
+		rc = -ENODEV;
+		goto undo_platform_dev_alloc;
+	}
+	dev_info(&pdev->dev, "NatSemi pc8736x GPIO Driver Initializing\n");
 
 	if (!pc8736x_superio_present()) {
-		printk(KERN_ERR NAME ": no device found\n");
-		return -ENODEV;
+		rc = -ENODEV;
+		dev_err(&pdev->dev, "no device found\n");
+		goto undo_platform_dev_add;
 	}
 
 	/* Verify that chip and it's GPIO unit are both enabled.
@@ -252,44 +266,56 @@ static int __init pc8736x_gpio_init(void)
 	 */
 	rc = superio_inb(SIO_CF1);
 	if (!(rc & 0x01)) {
-		printk(KERN_ERR NAME ": device not enabled\n");
-		return -ENODEV;
+		rc = -ENODEV;
+		dev_err(&pdev->dev, "device not enabled\n");
+		goto undo_platform_dev_add;
 	}
 	device_select(SIO_GPIO_UNIT);
 	if (!superio_inb(SIO_UNIT_ACT)) {
-		printk(KERN_ERR NAME ": GPIO unit not enabled\n");
-		return -ENODEV;
+		rc = -ENODEV;
+		dev_err(&pdev->dev, "GPIO unit not enabled\n");
+		goto undo_platform_dev_add;
 	}
 
-	/* read GPIO unit base address */
+	/* read the GPIO unit base addr that chip responds to */
 	pc8736x_gpio_base = (superio_inb(SIO_BASE_HADDR) << 8
 			     | superio_inb(SIO_BASE_LADDR));
 
-	if (request_region(pc8736x_gpio_base, 16, NAME))
-		printk(KERN_INFO NAME ": GPIO ioport %x reserved\n",
-		       pc8736x_gpio_base);
+	if (!request_region(pc8736x_gpio_base, 16, DEVNAME)) {
+		rc = -ENODEV;
+		dev_err(&pdev->dev, "GPIO ioport %x busy\n",
+			pc8736x_gpio_base);
+		goto undo_platform_dev_add;
+	}
+	dev_info(&pdev->dev, "GPIO ioport %x reserved\n", pc8736x_gpio_base);
 
-	r = register_chrdev(major, NAME, &pc8736x_gpio_fops);
-	if (r < 0) {
-		printk(KERN_ERR NAME ": unable to register character device\n");
-		return r;
+	rc = register_chrdev(major, DEVNAME, &pc8736x_gpio_fops);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "register-chrdev failed: %d\n", rc);
+		goto undo_platform_dev_add;
 	}
 	if (!major) {
-		major = r;
-		printk(KERN_DEBUG NAME ": got dynamic major %d\n", major);
+		major = rc;
+		dev_dbg(&pdev->dev, "got dynamic major %d\n", major);
 	}
 
 	pc8736x_init_shadow();
 	return 0;
+
+undo_platform_dev_add:
+	platform_device_put(pdev);
+undo_platform_dev_alloc:
+	kfree(pdev);
+	return rc;
 }
 
 static void __exit pc8736x_gpio_cleanup(void)
 {
-	printk(KERN_DEBUG NAME " cleanup\n");
+	dev_dbg(&pdev->dev, " cleanup\n");
 
 	release_region(pc8736x_gpio_base, 16);
 
-	unregister_chrdev(major, NAME);
+	unregister_chrdev(major, DEVNAME);
 }
 
 module_init(pc8736x_gpio_init);

commit 681a3e7dab868a8c390724494e8b79dc596b9e0f
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:21 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: add new pc8736x_gpio module
    
    Add the brand new pc8736x_gpio driver.  This is mostly based upon
    scx200_gpio.c, but the platform_dev is treated separately, since its fairly
    big too.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/pc8736x_gpio.c b/drivers/char/pc8736x_gpio.c
new file mode 100644
index 000000000000..83f24279f54e
--- /dev/null
+++ b/drivers/char/pc8736x_gpio.c
@@ -0,0 +1,296 @@
+/* linux/drivers/char/pc8736x_gpio.c
+
+   National Semiconductor PC8736x GPIO driver.  Allows a user space
+   process to play with the GPIO pins.
+
+   Copyright (c) 2005 Jim Cromie <jim.cromie@gmail.com>
+
+   adapted from linux/drivers/char/scx200_gpio.c
+   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>,
+*/
+
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/nsc_gpio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define NAME "pc8736x_gpio"
+
+MODULE_AUTHOR("Jim Cromie <jim.cromie@gmail.com>");
+MODULE_DESCRIPTION("NatSemi SCx200 GPIO Pin Driver");
+MODULE_LICENSE("GPL");
+
+static int major;		/* default to dynamic major */
+module_param(major, int, 0);
+MODULE_PARM_DESC(major, "Major device number");
+
+static DEFINE_SPINLOCK(pc8736x_gpio_config_lock);
+static unsigned pc8736x_gpio_base;
+
+#define SIO_BASE1       0x2E	/* 1st command-reg to check */
+#define SIO_BASE2       0x4E	/* alt command-reg to check */
+#define SIO_BASE_OFFSET 0x20
+
+#define SIO_SID		0x20	/* SuperI/O ID Register */
+#define SIO_SID_VALUE	0xe9	/* Expected value in SuperI/O ID Register */
+
+#define SIO_CF1		0x21	/* chip config, bit0 is chip enable */
+
+#define SIO_UNIT_SEL	0x7	/* unit select reg */
+#define SIO_UNIT_ACT	0x30	/* unit enable */
+#define SIO_GPIO_UNIT	0x7	/* unit number of GPIO */
+#define SIO_VLM_UNIT	0x0D
+#define SIO_TMS_UNIT	0x0E
+
+/* config-space addrs to read/write each unit's runtime addr */
+#define SIO_BASE_HADDR		0x60
+#define SIO_BASE_LADDR		0x61
+
+/* GPIO config-space pin-control addresses */
+#define SIO_GPIO_PIN_SELECT	0xF0
+#define SIO_GPIO_PIN_CONFIG     0xF1
+#define SIO_GPIO_PIN_EVENT      0xF2
+
+static unsigned char superio_cmd = 0;
+static unsigned char selected_device = 0xFF;	/* bogus start val */
+
+/* GPIO port runtime access, functionality */
+static int port_offset[] = { 0, 4, 8, 10 };	/* non-uniform offsets ! */
+/* static int event_capable[] = { 1, 1, 0, 0 };   ports 2,3 are hobbled */
+
+#define PORT_OUT	0
+#define PORT_IN		1
+#define PORT_EVT_EN	2
+#define PORT_EVT_STST	3
+
+static inline void superio_outb(int addr, int val)
+{
+	outb_p(addr, superio_cmd);
+	outb_p(val, superio_cmd + 1);
+}
+
+static inline int superio_inb(int addr)
+{
+	outb_p(addr, superio_cmd);
+	return inb_p(superio_cmd + 1);
+}
+
+static int pc8736x_superio_present(void)
+{
+	/* try the 2 possible values, read a hardware reg to verify */
+	superio_cmd = SIO_BASE1;
+	if (superio_inb(SIO_SID) == SIO_SID_VALUE)
+		return superio_cmd;
+
+	superio_cmd = SIO_BASE2;
+	if (superio_inb(SIO_SID) == SIO_SID_VALUE)
+		return superio_cmd;
+
+	return 0;
+}
+
+static void device_select(unsigned devldn)
+{
+	superio_outb(SIO_UNIT_SEL, devldn);
+	selected_device = devldn;
+}
+
+static void select_pin(unsigned iminor)
+{
+	/* select GPIO port/pin from device minor number */
+	device_select(SIO_GPIO_UNIT);
+	superio_outb(SIO_GPIO_PIN_SELECT,
+		     ((iminor << 1) & 0xF0) | (iminor & 0x7));
+}
+
+static inline u32 pc8736x_gpio_configure_fn(unsigned index, u32 mask, u32 bits,
+					    u32 func_slct)
+{
+	u32 config, new_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pc8736x_gpio_config_lock, flags);
+
+	device_select(SIO_GPIO_UNIT);
+	select_pin(index);
+
+	/* read current config value */
+	config = superio_inb(func_slct);
+
+	/* set new config */
+	new_config = (config & mask) | bits;
+	superio_outb(func_slct, new_config);
+
+	spin_unlock_irqrestore(&pc8736x_gpio_config_lock, flags);
+
+	return config;
+}
+
+static u32 pc8736x_gpio_configure(unsigned index, u32 mask, u32 bits)
+{
+	return pc8736x_gpio_configure_fn(index, mask, bits,
+					 SIO_GPIO_PIN_CONFIG);
+}
+
+static int pc8736x_gpio_get(unsigned minor)
+{
+	int port, bit, val;
+
+	port = minor >> 3;
+	bit = minor & 7;
+	val = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_IN);
+	val >>= bit;
+	val &= 1;
+
+	printk(KERN_INFO NAME ": _gpio_get(%d from %x bit %d) == val %d\n",
+	       minor, pc8736x_gpio_base + port_offset[port] + PORT_IN, bit,
+	       val);
+
+	return val;
+}
+
+static void pc8736x_gpio_set(unsigned minor, int val)
+{
+	int port, bit, curval;
+
+	minor &= 0x1f;
+	port = minor >> 3;
+	bit = minor & 7;
+	curval = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_OUT);
+
+	printk(KERN_INFO NAME
+	       ": addr:%x cur:%x bit-pos:%d cur-bit:%x + new:%d -> bit-new:%d\n",
+	       pc8736x_gpio_base + port_offset[port] + PORT_OUT,
+	       curval, bit, (curval & ~(1 << bit)), val, (val << bit));
+
+	val = (curval & ~(1 << bit)) | (val << bit);
+
+	printk(KERN_INFO NAME ": gpio_set(minor:%d port:%d bit:%d"
+	       ") %2x -> %2x\n", minor, port, bit, curval, val);
+
+	outb_p(val, pc8736x_gpio_base + port_offset[port] + PORT_OUT);
+
+	curval = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_OUT);
+	val = inb_p(pc8736x_gpio_base + port_offset[port] + PORT_IN);
+
+	printk(KERN_INFO NAME ": wrote %x, read: %x\n", curval, val);
+}
+
+static void pc8736x_gpio_set_high(unsigned index)
+{
+	pc8736x_gpio_set(index, 1);
+}
+
+static void pc8736x_gpio_set_low(unsigned index)
+{
+	pc8736x_gpio_set(index, 0);
+}
+
+static int pc8736x_gpio_current(unsigned index)
+{
+	printk(KERN_WARNING NAME ": pc8736x_gpio_current unimplemented\n");
+	return 0;
+}
+
+static void pc8736x_gpio_change(unsigned index)
+{
+	pc8736x_gpio_set(index, !pc8736x_gpio_get(index));
+}
+
+extern void nsc_gpio_dump(unsigned iminor);
+
+static struct nsc_gpio_ops pc8736x_access = {
+	.owner		= THIS_MODULE,
+	.gpio_config	= pc8736x_gpio_configure,
+	.gpio_dump	= nsc_gpio_dump,
+	.gpio_get	= pc8736x_gpio_get,
+	.gpio_set	= pc8736x_gpio_set,
+	.gpio_set_high	= pc8736x_gpio_set_high,
+	.gpio_set_low	= pc8736x_gpio_set_low,
+	.gpio_change	= pc8736x_gpio_change,
+	.gpio_current	= pc8736x_gpio_current
+};
+
+static int pc8736x_gpio_open(struct inode *inode, struct file *file)
+{
+	unsigned m = iminor(inode);
+	file->private_data = &pc8736x_access;
+
+	printk(KERN_NOTICE NAME " open %d\n", m);
+
+	if (m > 63)
+		return -EINVAL;
+	return nonseekable_open(inode, file);
+}
+
+static struct file_operations pc8736x_gpio_fops = {
+	.owner = THIS_MODULE,
+	.open = pc8736x_gpio_open,
+	.write = nsc_gpio_write,
+	.read = nsc_gpio_read,
+};
+
+static int __init pc8736x_gpio_init(void)
+{
+	int r, rc;
+
+	printk(KERN_DEBUG NAME " initializing\n");
+
+	if (!pc8736x_superio_present()) {
+		printk(KERN_ERR NAME ": no device found\n");
+		return -ENODEV;
+	}
+
+	/* Verify that chip and it's GPIO unit are both enabled.
+	   My BIOS does this, so I take minimum action here
+	 */
+	rc = superio_inb(SIO_CF1);
+	if (!(rc & 0x01)) {
+		printk(KERN_ERR NAME ": device not enabled\n");
+		return -ENODEV;
+	}
+	device_select(SIO_GPIO_UNIT);
+	if (!superio_inb(SIO_UNIT_ACT)) {
+		printk(KERN_ERR NAME ": GPIO unit not enabled\n");
+		return -ENODEV;
+	}
+
+	/* read GPIO unit base address */
+	pc8736x_gpio_base = (superio_inb(SIO_BASE_HADDR) << 8
+			     | superio_inb(SIO_BASE_LADDR));
+
+	if (request_region(pc8736x_gpio_base, 16, NAME))
+		printk(KERN_INFO NAME ": GPIO ioport %x reserved\n",
+		       pc8736x_gpio_base);
+
+	r = register_chrdev(major, NAME, &pc8736x_gpio_fops);
+	if (r < 0) {
+		printk(KERN_ERR NAME ": unable to register character device\n");
+		return r;
+	}
+	if (!major) {
+		major = r;
+		printk(KERN_DEBUG NAME ": got dynamic major %d\n", major);
+	}
+
+	pc8736x_init_shadow();
+	return 0;
+}
+
+static void __exit pc8736x_gpio_cleanup(void)
+{
+	printk(KERN_DEBUG NAME " cleanup\n");
+
+	release_region(pc8736x_gpio_base, 16);
+
+	unregister_chrdev(major, NAME);
+}
+
+module_init(pc8736x_gpio_init);
+module_exit(pc8736x_gpio_cleanup);
