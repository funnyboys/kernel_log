commit d73236383eb1cd4b7b65c33a09f0ed45f6781f40
Author: Corey Minyard <cminyard@mvista.com>
Date:   Wed Apr 24 08:32:02 2019 -0500

    ipmi: Add the i2c-addr property for SSIF interfaces
    
    This is required for SSIF to work.
    
    There was no way to know if the interface being added was SI
    or SSIF from the platform data, but that was required so the
    i2c-addr is only added for SSIF interfaces.  So add a field
    for that.
    
    Also rework the logic a bit so that ipmi-type is not set
    for SSIF interfaces, as it is not necessary for that.
    
    Fixes: 3cd83bac481d ("ipmi: Consolidate the adding of platform devices")
    Reported-by: Kamlakant Patel <kamlakantp@marvell.com>
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Cc: stable@vger.kernel.org # 5.1

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 682221eebd66..f6ece7569504 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -83,6 +83,7 @@ static void __init ipmi_hardcode_init_one(const char *si_type_str,
 
 	memset(&p, 0, sizeof(p));
 
+	p.iftype = IPMI_PLAT_IF_SI;
 	if (!si_type_str || !*si_type_str || strcmp(si_type_str, "kcs") == 0) {
 		p.type = SI_KCS;
 	} else if (strcmp(si_type_str, "smic") == 0) {

commit a885bcfd152f97b25005298ab2d6b741aed9b49c
Author: Tony Camuso <tcamuso@redhat.com>
Date:   Tue Apr 9 15:20:03 2019 -0400

    ipmi: ipmi_si_hardcode.c: init si_type array to fix a crash
    
    The intended behavior of function ipmi_hardcode_init_one() is to default
    to kcs interface when no type argument is presented when initializing
    ipmi with hard coded addresses.
    
    However, the array of char pointers allocated on the stack by function
    ipmi_hardcode_init() was not inited to zeroes, so it contained stack
    debris.
    
    Consequently, passing the cruft stored in this array to function
    ipmi_hardcode_init_one() caused a crash when it was unable to detect
    that the char * being passed was nonsense and tried to access the
    address specified by the bogus pointer.
    
    The fix is simply to initialize the si_type array to zeroes, so if
    there were no type argument given to at the command line, function
    ipmi_hardcode_init_one() could properly default to the kcs interface.
    
    Signed-off-by: Tony Camuso <tcamuso@redhat.com>
    Message-Id: <1554837603-40299-1-git-send-email-tcamuso@redhat.com>
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 01946cad3d13..682221eebd66 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -118,6 +118,8 @@ void __init ipmi_hardcode_init(void)
 	char *str;
 	char *si_type[SI_MAX_PARMS];
 
+	memset(si_type, 0, sizeof(si_type));
+
 	/* Parse out the si_type string into its components. */
 	str = si_type_str;
 	if (*str != '\0') {

commit e17c657100d592115fcfad27472cd611fd74b861
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Feb 21 17:41:47 2019 -0600

    ipmi_si: Consolidate scanning the platform bus
    
    The same basic code was in two places.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 540b0871bff0..01946cad3d13 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -144,23 +144,9 @@ void __init ipmi_hardcode_init(void)
 }
 
 
-static int pdev_match_name(struct device *dev, void *data)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-
-	return strcmp(pdev->name, "hardcode-ipmi-si") == 0;
-}
-
 void ipmi_si_hardcode_exit(void)
 {
-	struct device *dev;
-
-	while ((dev = bus_find_device(&platform_bus_type, NULL, NULL,
-				      pdev_match_name))) {
-		struct platform_device *pdev = to_platform_device(dev);
-
-		platform_device_unregister(pdev);
-	}
+	ipmi_remove_platform_device_by_name("hardcode-ipmi-si");
 }
 
 /*

commit 1a84df2df8ebb1083cb57be6808fbf36d9cabe0e
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Feb 21 17:04:17 2019 -0600

    ipmi_si: Remove hardcode IPMI devices by scanning the platform bus
    
    Instead of keeping track of each one, just scan the platform bus
    for hardcode devices and remove them.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index cb58298d80f5..540b0871bff0 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -74,8 +74,6 @@ MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
 		 " overridden by this parm.  This is an array indexed"
 		 " by interface number.");
 
-static struct platform_device *ipmi_hc_pdevs[SI_MAX_PARMS];
-
 static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  unsigned int i,
 					  unsigned long addr,
@@ -111,7 +109,7 @@ static void __init ipmi_hardcode_init_one(const char *si_type_str,
 	p.addr = addr;
 	p.space = addr_space;
 
-	ipmi_hc_pdevs[i] = ipmi_platform_add("hardcode-ipmi-si", i, &p);
+	ipmi_platform_add("hardcode-ipmi-si", i, &p);
 }
 
 void __init ipmi_hardcode_init(void)
@@ -145,13 +143,23 @@ void __init ipmi_hardcode_init(void)
 	}
 }
 
+
+static int pdev_match_name(struct device *dev, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return strcmp(pdev->name, "hardcode-ipmi-si") == 0;
+}
+
 void ipmi_si_hardcode_exit(void)
 {
-	unsigned int i;
+	struct device *dev;
 
-	for (i = 0; i < SI_MAX_PARMS; i++) {
-		if (ipmi_hc_pdevs[i])
-			platform_device_unregister(ipmi_hc_pdevs[i]);
+	while ((dev = bus_find_device(&platform_bus_type, NULL, NULL,
+				      pdev_match_name))) {
+		struct platform_device *pdev = to_platform_device(dev);
+
+		platform_device_unregister(pdev);
 	}
 }
 

commit 3cd83bac481dc4fde8bedf09c8aecb3652e7e547
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Feb 21 14:21:17 2019 -0600

    ipmi: Consolidate the adding of platform devices
    
    It was being done in two different places now that hard-coded devices
    use platform devices, and it's about to be three with hotmod switching
    to platform devices.  So put the code in one place.
    
    This required some rework on some interfaces to make the type space
    clean.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 86ac9b8a3219..cb58298d80f5 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -5,6 +5,7 @@
 #include <linux/moduleparam.h>
 #include <linux/platform_device.h>
 #include "ipmi_si.h"
+#include "ipmi_plat_data.h"
 
 /*
  * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
@@ -78,121 +79,39 @@ static struct platform_device *ipmi_hc_pdevs[SI_MAX_PARMS];
 static void __init ipmi_hardcode_init_one(const char *si_type_str,
 					  unsigned int i,
 					  unsigned long addr,
-					  unsigned int flags)
+					  enum ipmi_addr_space addr_space)
 {
-	struct platform_device *pdev;
-	unsigned int num_r = 1, size;
-	struct resource r[4];
-	struct property_entry p[6];
-	enum si_type si_type;
-	unsigned int regspacing, regsize;
-	int rv;
+	struct ipmi_plat_data p;
 
-	memset(p, 0, sizeof(p));
-	memset(r, 0, sizeof(r));
+	memset(&p, 0, sizeof(p));
 
 	if (!si_type_str || !*si_type_str || strcmp(si_type_str, "kcs") == 0) {
-		size = 2;
-		si_type = SI_KCS;
+		p.type = SI_KCS;
 	} else if (strcmp(si_type_str, "smic") == 0) {
-		size = 2;
-		si_type = SI_SMIC;
+		p.type = SI_SMIC;
 	} else if (strcmp(si_type_str, "bt") == 0) {
-		size = 3;
-		si_type = SI_BT;
+		p.type = SI_BT;
 	} else if (strcmp(si_type_str, "invalid") == 0) {
 		/*
 		 * Allow a firmware-specified interface to be
 		 * disabled.
 		 */
-		size = 1;
-		si_type = SI_TYPE_INVALID;
+		p.type = SI_TYPE_INVALID;
 	} else {
 		pr_warn("Interface type specified for interface %d, was invalid: %s\n",
 			i, si_type_str);
 		return;
 	}
 
-	regsize = regsizes[i];
-	if (regsize == 0)
-		regsize = DEFAULT_REGSIZE;
+	p.regsize = regsizes[i];
+	p.slave_addr = slave_addrs[i];
+	p.addr_source = SI_HARDCODED;
+	p.regshift = regshifts[i];
+	p.regsize = regsizes[i];
+	p.addr = addr;
+	p.space = addr_space;
 
-	p[0] = PROPERTY_ENTRY_U8("ipmi-type", si_type);
-	p[1] = PROPERTY_ENTRY_U8("slave-addr", slave_addrs[i]);
-	p[2] = PROPERTY_ENTRY_U8("addr-source", SI_HARDCODED);
-	p[3] = PROPERTY_ENTRY_U8("reg-shift", regshifts[i]);
-	p[4] = PROPERTY_ENTRY_U8("reg-size", regsize);
-	/* Last entry must be left NULL to terminate it. */
-
-	/*
-	 * Register spacing is derived from the resources in
-	 * the IPMI platform code.
-	 */
-	regspacing = regspacings[i];
-	if (regspacing == 0)
-		regspacing = regsize;
-
-	r[0].start = addr;
-	r[0].end = r[0].start + regsize - 1;
-	r[0].name = "IPMI Address 1";
-	r[0].flags = flags;
-
-	if (size > 1) {
-		r[1].start = r[0].start + regspacing;
-		r[1].end = r[1].start + regsize - 1;
-		r[1].name = "IPMI Address 2";
-		r[1].flags = flags;
-		num_r++;
-	}
-
-	if (size > 2) {
-		r[2].start = r[1].start + regspacing;
-		r[2].end = r[2].start + regsize - 1;
-		r[2].name = "IPMI Address 3";
-		r[2].flags = flags;
-		num_r++;
-	}
-
-	if (irqs[i]) {
-		r[num_r].start = irqs[i];
-		r[num_r].end = irqs[i];
-		r[num_r].name = "IPMI IRQ";
-		r[num_r].flags = IORESOURCE_IRQ;
-		num_r++;
-	}
-
-	pdev = platform_device_alloc("hardcode-ipmi-si", i);
-	if (!pdev) {
-		pr_err("Error allocating IPMI platform device %d\n", i);
-		return;
-	}
-
-	rv = platform_device_add_resources(pdev, r, num_r);
-	if (rv) {
-		dev_err(&pdev->dev,
-			"Unable to add hard-code resources: %d\n", rv);
-		goto err;
-	}
-
-	rv = platform_device_add_properties(pdev, p);
-	if (rv) {
-		dev_err(&pdev->dev,
-			"Unable to add hard-code properties: %d\n", rv);
-		goto err;
-	}
-
-	rv = platform_device_add(pdev);
-	if (rv) {
-		dev_err(&pdev->dev,
-			"Unable to add hard-code device: %d\n", rv);
-		goto err;
-	}
-
-	ipmi_hc_pdevs[i] = pdev;
-	return;
-
-err:
-	platform_device_put(pdev);
+	ipmi_hc_pdevs[i] = ipmi_platform_add("hardcode-ipmi-si", i, &p);
 }
 
 void __init ipmi_hardcode_init(void)
@@ -219,10 +138,10 @@ void __init ipmi_hardcode_init(void)
 	for (i = 0; i < SI_MAX_PARMS; i++) {
 		if (i < num_ports && ports[i])
 			ipmi_hardcode_init_one(si_type[i], i, ports[i],
-					       IORESOURCE_IO);
+					       IPMI_IO_ADDR_SPACE);
 		if (i < num_addrs && addrs[i])
 			ipmi_hardcode_init_one(si_type[i], i, addrs[i],
-					       IORESOURCE_MEM);
+					       IPMI_MEM_ADDR_SPACE);
 	}
 }
 

commit f6296bdc49c4d3794b5a3ef0012fc0889e2f3f94
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Feb 21 12:53:00 2019 -0600

    ipmi_si: Rename addr_type to addr_space to match what it does
    
    Make the naming consistent, and make the values an enum.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 1e5783961b0d..86ac9b8a3219 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -240,11 +240,11 @@ void ipmi_si_hardcode_exit(void)
  * Returns true of the given address exists as a hardcoded address,
  * false if not.
  */
-int ipmi_si_hardcode_match(int addr_type, unsigned long addr)
+int ipmi_si_hardcode_match(int addr_space, unsigned long addr)
 {
 	unsigned int i;
 
-	if (addr_type == IPMI_IO_ADDR_SPACE) {
+	if (addr_space == IPMI_IO_ADDR_SPACE) {
 		for (i = 0; i < num_ports; i++) {
 			if (ports[i] == addr)
 				return 1;

commit 41b766d661bf94a364960862cfc248a78313dbd3
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Feb 21 12:10:07 2019 -0600

    ipmi_si: Fix crash when using hard-coded device
    
    When excuting a command like:
      modprobe ipmi_si ports=0xffc0e3 type=bt
    The system would get an oops.
    
    The trouble here is that ipmi_si_hardcode_find_bmc() is called before
    ipmi_si_platform_init(), but initialization of the hard-coded device
    creates an IPMI platform device, which won't be initialized yet.
    
    The real trouble is that hard-coded devices aren't created with
    any device, and the fixup is done later.  So do it right, create the
    hard-coded devices as normal platform devices.
    
    This required adding some new resource types to the IPMI platform
    code for passing information required by the hard-coded device
    and adding some code to remove the hard-coded platform devices
    on module removal.
    
    To enforce the "hard-coded devices passed by the user take priority
    over firmware devices" rule, some special code was added to check
    and see if a hard-coded device already exists.
    
    Reported-by: Yang Yingliang <yangyingliang@huawei.com>
    Cc: stable@vger.kernel.org # v4.15+
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Tested-by: Yang Yingliang <yangyingliang@huawei.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 487642809c58..1e5783961b0d 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -3,6 +3,7 @@
 #define pr_fmt(fmt) "ipmi_hardcode: " fmt
 
 #include <linux/moduleparam.h>
+#include <linux/platform_device.h>
 #include "ipmi_si.h"
 
 /*
@@ -12,23 +13,22 @@
 
 #define SI_MAX_PARMS 4
 
-static char          *si_type[SI_MAX_PARMS];
 #define MAX_SI_TYPE_STR 30
-static char          si_type_str[MAX_SI_TYPE_STR];
+static char          si_type_str[MAX_SI_TYPE_STR] __initdata;
 static unsigned long addrs[SI_MAX_PARMS];
 static unsigned int num_addrs;
 static unsigned int  ports[SI_MAX_PARMS];
 static unsigned int num_ports;
-static int           irqs[SI_MAX_PARMS];
-static unsigned int num_irqs;
-static int           regspacings[SI_MAX_PARMS];
-static unsigned int num_regspacings;
-static int           regsizes[SI_MAX_PARMS];
-static unsigned int num_regsizes;
-static int           regshifts[SI_MAX_PARMS];
-static unsigned int num_regshifts;
-static int slave_addrs[SI_MAX_PARMS]; /* Leaving 0 chooses the default value */
-static unsigned int num_slave_addrs;
+static int           irqs[SI_MAX_PARMS] __initdata;
+static unsigned int num_irqs __initdata;
+static int           regspacings[SI_MAX_PARMS] __initdata;
+static unsigned int num_regspacings __initdata;
+static int           regsizes[SI_MAX_PARMS] __initdata;
+static unsigned int num_regsizes __initdata;
+static int           regshifts[SI_MAX_PARMS] __initdata;
+static unsigned int num_regshifts __initdata;
+static int slave_addrs[SI_MAX_PARMS] __initdata;
+static unsigned int num_slave_addrs __initdata;
 
 module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
 MODULE_PARM_DESC(type, "Defines the type of each interface, each"
@@ -73,12 +73,133 @@ MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
 		 " overridden by this parm.  This is an array indexed"
 		 " by interface number.");
 
-int ipmi_si_hardcode_find_bmc(void)
+static struct platform_device *ipmi_hc_pdevs[SI_MAX_PARMS];
+
+static void __init ipmi_hardcode_init_one(const char *si_type_str,
+					  unsigned int i,
+					  unsigned long addr,
+					  unsigned int flags)
 {
-	int ret = -ENODEV;
-	int             i;
-	struct si_sm_io io;
+	struct platform_device *pdev;
+	unsigned int num_r = 1, size;
+	struct resource r[4];
+	struct property_entry p[6];
+	enum si_type si_type;
+	unsigned int regspacing, regsize;
+	int rv;
+
+	memset(p, 0, sizeof(p));
+	memset(r, 0, sizeof(r));
+
+	if (!si_type_str || !*si_type_str || strcmp(si_type_str, "kcs") == 0) {
+		size = 2;
+		si_type = SI_KCS;
+	} else if (strcmp(si_type_str, "smic") == 0) {
+		size = 2;
+		si_type = SI_SMIC;
+	} else if (strcmp(si_type_str, "bt") == 0) {
+		size = 3;
+		si_type = SI_BT;
+	} else if (strcmp(si_type_str, "invalid") == 0) {
+		/*
+		 * Allow a firmware-specified interface to be
+		 * disabled.
+		 */
+		size = 1;
+		si_type = SI_TYPE_INVALID;
+	} else {
+		pr_warn("Interface type specified for interface %d, was invalid: %s\n",
+			i, si_type_str);
+		return;
+	}
+
+	regsize = regsizes[i];
+	if (regsize == 0)
+		regsize = DEFAULT_REGSIZE;
+
+	p[0] = PROPERTY_ENTRY_U8("ipmi-type", si_type);
+	p[1] = PROPERTY_ENTRY_U8("slave-addr", slave_addrs[i]);
+	p[2] = PROPERTY_ENTRY_U8("addr-source", SI_HARDCODED);
+	p[3] = PROPERTY_ENTRY_U8("reg-shift", regshifts[i]);
+	p[4] = PROPERTY_ENTRY_U8("reg-size", regsize);
+	/* Last entry must be left NULL to terminate it. */
+
+	/*
+	 * Register spacing is derived from the resources in
+	 * the IPMI platform code.
+	 */
+	regspacing = regspacings[i];
+	if (regspacing == 0)
+		regspacing = regsize;
+
+	r[0].start = addr;
+	r[0].end = r[0].start + regsize - 1;
+	r[0].name = "IPMI Address 1";
+	r[0].flags = flags;
+
+	if (size > 1) {
+		r[1].start = r[0].start + regspacing;
+		r[1].end = r[1].start + regsize - 1;
+		r[1].name = "IPMI Address 2";
+		r[1].flags = flags;
+		num_r++;
+	}
+
+	if (size > 2) {
+		r[2].start = r[1].start + regspacing;
+		r[2].end = r[2].start + regsize - 1;
+		r[2].name = "IPMI Address 3";
+		r[2].flags = flags;
+		num_r++;
+	}
+
+	if (irqs[i]) {
+		r[num_r].start = irqs[i];
+		r[num_r].end = irqs[i];
+		r[num_r].name = "IPMI IRQ";
+		r[num_r].flags = IORESOURCE_IRQ;
+		num_r++;
+	}
+
+	pdev = platform_device_alloc("hardcode-ipmi-si", i);
+	if (!pdev) {
+		pr_err("Error allocating IPMI platform device %d\n", i);
+		return;
+	}
+
+	rv = platform_device_add_resources(pdev, r, num_r);
+	if (rv) {
+		dev_err(&pdev->dev,
+			"Unable to add hard-code resources: %d\n", rv);
+		goto err;
+	}
+
+	rv = platform_device_add_properties(pdev, p);
+	if (rv) {
+		dev_err(&pdev->dev,
+			"Unable to add hard-code properties: %d\n", rv);
+		goto err;
+	}
+
+	rv = platform_device_add(pdev);
+	if (rv) {
+		dev_err(&pdev->dev,
+			"Unable to add hard-code device: %d\n", rv);
+		goto err;
+	}
+
+	ipmi_hc_pdevs[i] = pdev;
+	return;
+
+err:
+	platform_device_put(pdev);
+}
+
+void __init ipmi_hardcode_init(void)
+{
+	unsigned int i;
 	char *str;
+	char *si_type[SI_MAX_PARMS];
 
 	/* Parse out the si_type string into its components. */
 	str = si_type_str;
@@ -95,54 +216,45 @@ int ipmi_si_hardcode_find_bmc(void)
 		}
 	}
 
-	memset(&io, 0, sizeof(io));
 	for (i = 0; i < SI_MAX_PARMS; i++) {
-		if (!ports[i] && !addrs[i])
-			continue;
-
-		io.addr_source = SI_HARDCODED;
-		pr_info("probing via hardcoded address\n");
-
-		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
-			io.si_type = SI_KCS;
-		} else if (strcmp(si_type[i], "smic") == 0) {
-			io.si_type = SI_SMIC;
-		} else if (strcmp(si_type[i], "bt") == 0) {
-			io.si_type = SI_BT;
-		} else {
-			pr_warn("Interface type specified for interface %d, was invalid: %s\n",
-				i, si_type[i]);
-			continue;
-		}
+		if (i < num_ports && ports[i])
+			ipmi_hardcode_init_one(si_type[i], i, ports[i],
+					       IORESOURCE_IO);
+		if (i < num_addrs && addrs[i])
+			ipmi_hardcode_init_one(si_type[i], i, addrs[i],
+					       IORESOURCE_MEM);
+	}
+}
 
-		if (ports[i]) {
-			/* An I/O port */
-			io.addr_data = ports[i];
-			io.addr_type = IPMI_IO_ADDR_SPACE;
-		} else if (addrs[i]) {
-			/* A memory port */
-			io.addr_data = addrs[i];
-			io.addr_type = IPMI_MEM_ADDR_SPACE;
-		} else {
-			pr_warn("Interface type specified for interface %d, but port and address were not set or set to zero\n",
-				i);
-			continue;
-		}
+void ipmi_si_hardcode_exit(void)
+{
+	unsigned int i;
 
-		io.addr = NULL;
-		io.regspacing = regspacings[i];
-		if (!io.regspacing)
-			io.regspacing = DEFAULT_REGSPACING;
-		io.regsize = regsizes[i];
-		if (!io.regsize)
-			io.regsize = DEFAULT_REGSIZE;
-		io.regshift = regshifts[i];
-		io.irq = irqs[i];
-		if (io.irq)
-			io.irq_setup = ipmi_std_irq_setup;
-		io.slave_addr = slave_addrs[i];
-
-		ret = ipmi_si_add_smi(&io);
+	for (i = 0; i < SI_MAX_PARMS; i++) {
+		if (ipmi_hc_pdevs[i])
+			platform_device_unregister(ipmi_hc_pdevs[i]);
 	}
-	return ret;
+}
+
+/*
+ * Returns true of the given address exists as a hardcoded address,
+ * false if not.
+ */
+int ipmi_si_hardcode_match(int addr_type, unsigned long addr)
+{
+	unsigned int i;
+
+	if (addr_type == IPMI_IO_ADDR_SPACE) {
+		for (i = 0; i < num_ports; i++) {
+			if (ports[i] == addr)
+				return 1;
+		}
+	} else {
+		for (i = 0; i < num_addrs; i++) {
+			if (addrs[i] == addr)
+				return 1;
+		}
+	}
+
+	return 0;
 }

commit 25880f7d61a4f2fdda29cadae55985431df82c5c
Author: Joe Perches <joe@perches.com>
Date:   Wed May 9 08:15:48 2018 -0700

    ipmi: Use more common logging styles
    
    Add and use #define pr_fmt/dev_fmt, and remove #define PFX
    
    This also prefixes some messages that were not previously prefixed.
    
    Miscellanea:
    
    o Convert printk(KERN_<level> to pr_<level>(
    o Use %s, __func__ where appropriate
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 10219f24546b..487642809c58 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -1,9 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0+
 
+#define pr_fmt(fmt) "ipmi_hardcode: " fmt
+
 #include <linux/moduleparam.h>
 #include "ipmi_si.h"
 
-#define PFX "ipmi_hardcode: "
 /*
  * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
  * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.
@@ -100,7 +101,7 @@ int ipmi_si_hardcode_find_bmc(void)
 			continue;
 
 		io.addr_source = SI_HARDCODED;
-		pr_info(PFX "probing via hardcoded address\n");
+		pr_info("probing via hardcoded address\n");
 
 		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 			io.si_type = SI_KCS;
@@ -109,7 +110,7 @@ int ipmi_si_hardcode_find_bmc(void)
 		} else if (strcmp(si_type[i], "bt") == 0) {
 			io.si_type = SI_BT;
 		} else {
-			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
+			pr_warn("Interface type specified for interface %d, was invalid: %s\n",
 				i, si_type[i]);
 			continue;
 		}
@@ -123,7 +124,7 @@ int ipmi_si_hardcode_find_bmc(void)
 			io.addr_data = addrs[i];
 			io.addr_type = IPMI_MEM_ADDR_SPACE;
 		} else {
-			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
+			pr_warn("Interface type specified for interface %d, but port and address were not set or set to zero\n",
 				i);
 			continue;
 		}

commit 243ac21035176ac9692c1308a9f3b8f6a4e5d733
Author: Corey Minyard <cminyard@mvista.com>
Date:   Tue Feb 20 07:30:22 2018 -0600

    ipmi: Add or fix SPDX-License-Identifier in all files
    
    And get rid of the license text that is no longer necessary.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Alistair Popple <alistair@popple.id.au>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Rocky Craig <rocky.craig@hp.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index fa9a4780de36..10219f24546b 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 
 #include <linux/moduleparam.h>
 #include "ipmi_si.h"

commit 7a4533087ccbf736396bcbf816e0e45266c4313b
Author: Corey Minyard <cminyard@mvista.com>
Date:   Tue Sep 12 22:46:29 2017 -0500

    ipmi_si: Move hardcode handling to a separate file.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
new file mode 100644
index 000000000000..fa9a4780de36
--- /dev/null
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -0,0 +1,146 @@
+
+#include <linux/moduleparam.h>
+#include "ipmi_si.h"
+
+#define PFX "ipmi_hardcode: "
+/*
+ * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
+ * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.
+ */
+
+#define SI_MAX_PARMS 4
+
+static char          *si_type[SI_MAX_PARMS];
+#define MAX_SI_TYPE_STR 30
+static char          si_type_str[MAX_SI_TYPE_STR];
+static unsigned long addrs[SI_MAX_PARMS];
+static unsigned int num_addrs;
+static unsigned int  ports[SI_MAX_PARMS];
+static unsigned int num_ports;
+static int           irqs[SI_MAX_PARMS];
+static unsigned int num_irqs;
+static int           regspacings[SI_MAX_PARMS];
+static unsigned int num_regspacings;
+static int           regsizes[SI_MAX_PARMS];
+static unsigned int num_regsizes;
+static int           regshifts[SI_MAX_PARMS];
+static unsigned int num_regshifts;
+static int slave_addrs[SI_MAX_PARMS]; /* Leaving 0 chooses the default value */
+static unsigned int num_slave_addrs;
+
+module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
+MODULE_PARM_DESC(type, "Defines the type of each interface, each"
+		 " interface separated by commas.  The types are 'kcs',"
+		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
+		 " the first interface to kcs and the second to bt");
+module_param_hw_array(addrs, ulong, iomem, &num_addrs, 0);
+MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is in memory.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(ports, uint, ioport, &num_ports, 0);
+MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is a port.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(irqs, int, irq, &num_irqs, 0);
+MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " has an interrupt.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(regspacings, int, other, &num_regspacings, 0);
+MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
+		 " and each successive register used by the interface.  For"
+		 " instance, if the start address is 0xca2 and the spacing"
+		 " is 2, then the second address is at 0xca4.  Defaults"
+		 " to 1.");
+module_param_hw_array(regsizes, int, other, &num_regsizes, 0);
+MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
+		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
+		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
+		 " the 8-bit IPMI register has to be read from a larger"
+		 " register.");
+module_param_hw_array(regshifts, int, other, &num_regshifts, 0);
+MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
+		 " IPMI register, in bits.  For instance, if the data"
+		 " is read from a 32-bit word and the IPMI data is in"
+		 " bit 8-15, then the shift would be 8");
+module_param_hw_array(slave_addrs, int, other, &num_slave_addrs, 0);
+MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
+		 " the controller.  Normally this is 0x20, but can be"
+		 " overridden by this parm.  This is an array indexed"
+		 " by interface number.");
+
+int ipmi_si_hardcode_find_bmc(void)
+{
+	int ret = -ENODEV;
+	int             i;
+	struct si_sm_io io;
+	char *str;
+
+	/* Parse out the si_type string into its components. */
+	str = si_type_str;
+	if (*str != '\0') {
+		for (i = 0; (i < SI_MAX_PARMS) && (*str != '\0'); i++) {
+			si_type[i] = str;
+			str = strchr(str, ',');
+			if (str) {
+				*str = '\0';
+				str++;
+			} else {
+				break;
+			}
+		}
+	}
+
+	memset(&io, 0, sizeof(io));
+	for (i = 0; i < SI_MAX_PARMS; i++) {
+		if (!ports[i] && !addrs[i])
+			continue;
+
+		io.addr_source = SI_HARDCODED;
+		pr_info(PFX "probing via hardcoded address\n");
+
+		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
+			io.si_type = SI_KCS;
+		} else if (strcmp(si_type[i], "smic") == 0) {
+			io.si_type = SI_SMIC;
+		} else if (strcmp(si_type[i], "bt") == 0) {
+			io.si_type = SI_BT;
+		} else {
+			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
+				i, si_type[i]);
+			continue;
+		}
+
+		if (ports[i]) {
+			/* An I/O port */
+			io.addr_data = ports[i];
+			io.addr_type = IPMI_IO_ADDR_SPACE;
+		} else if (addrs[i]) {
+			/* A memory port */
+			io.addr_data = addrs[i];
+			io.addr_type = IPMI_MEM_ADDR_SPACE;
+		} else {
+			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
+				i);
+			continue;
+		}
+
+		io.addr = NULL;
+		io.regspacing = regspacings[i];
+		if (!io.regspacing)
+			io.regspacing = DEFAULT_REGSPACING;
+		io.regsize = regsizes[i];
+		if (!io.regsize)
+			io.regsize = DEFAULT_REGSIZE;
+		io.regshift = regshifts[i];
+		io.irq = irqs[i];
+		if (io.irq)
+			io.irq_setup = ipmi_std_irq_setup;
+		io.slave_addr = slave_addrs[i];
+
+		ret = ipmi_si_add_smi(&io);
+	}
+	return ret;
+}
