commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 4e2d00cb0d81..da5b30771418 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Implementation of the Xen vTPM device frontend
  *
  * Author:  Daniel De Graaf <dgdegra@tycho.nsa.gov>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2,
- * as published by the Free Software Foundation.
  */
 #include <linux/errno.h>
 #include <linux/err.h>

commit b34b77a99b1a4ccccb54f2c4c6ef982d6b008c15
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Tue Nov 6 19:04:30 2018 +0200

    tpm: declare struct tpm_header
    
    Declare struct tpm_header that replaces struct tpm_input_header and
    struct tpm_output_header.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Tested-by: Stefan Berger <stefanb@linux.ibm.com>
    Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
    Reviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Tested-by: Alexander Steffen <Alexander.Steffen@infineon.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 5a327eb7f63a..4e2d00cb0d81 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -163,7 +163,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 	wmb();
 	notify_remote_via_evtchn(priv->evtchn);
 
-	ordinal = be32_to_cpu(((struct tpm_input_header*)buf)->ordinal);
+	ordinal = be32_to_cpu(((struct tpm_header *)buf)->ordinal);
 	duration = tpm_calc_ordinal_duration(chip, ordinal);
 
 	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, duration,

commit f5595f5baa30e009bf54d0d7653a9a0cc465be60
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Fri Feb 8 18:30:58 2019 +0200

    tpm: Unify the send callback behaviour
    
    The send() callback should never return length as it does not in every
    driver except tpm_crb in the success case. The reason is that the main
    transmit functionality only cares about whether the transmit was
    successful or not and ignores the count completely.
    
    Suggested-by: Stefan Berger <stefanb@linux.ibm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
    Tested-by: Alexander Steffen <Alexander.Steffen@infineon.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index b150f87f38f5..5a327eb7f63a 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -173,7 +173,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 		return -ETIME;
 	}
 
-	return count;
+	return 0;
 }
 
 static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)

commit e487a0f52301293152a6f8c4e217f2a11dd808e3
Author: Dr. Greg Wettstein <greg@wind.enjellic.com>
Date:   Mon Sep 17 18:53:33 2018 -0400

    tpm: Restore functionality to xen vtpm driver.
    
    Functionality of the xen-tpmfront driver was lost secondary to
    the introduction of xenbus multi-page support in commit ccc9d90a9a8b
    ("xenbus_client: Extend interface to support multi-page ring").
    
    In this commit pointer to location of where the shared page address
    is stored was being passed to the xenbus_grant_ring() function rather
    then the address of the shared page itself. This resulted in a situation
    where the driver would attach to the vtpm-stubdom but any attempt
    to send a command to the stub domain would timeout.
    
    A diagnostic finding for this regression is the following error
    message being generated when the xen-tpmfront driver probes for a
    device:
    
    <3>vtpm vtpm-0: tpm_transmit: tpm_send: error -62
    
    <3>vtpm vtpm-0: A TPM error (-62) occurred attempting to determine
    the timeouts
    
    This fix is relevant to all kernels from 4.1 forward which is the
    release in which multi-page xenbus support was introduced.
    
    Daniel De Graaf formulated the fix by code inspection after the
    regression point was located.
    
    Fixes: ccc9d90a9a8b ("xenbus_client: Extend interface to support multi-page ring")
    Signed-off-by: Dr. Greg Wettstein <greg@enjellic.com>
    
    [boris: Updated commit message, added Fixes tag]
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: stable@vger.kernel.org # v4.1+
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 911475d36800..b150f87f38f5 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -264,7 +264,7 @@ static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
 		return -ENOMEM;
 	}
 
-	rv = xenbus_grant_ring(dev, &priv->shr, 1, &gref);
+	rv = xenbus_grant_ring(dev, priv->shr, 1, &gref);
 	if (rv < 0)
 		return rv;
 

commit 87cdfdd19aefcf639507ce96ae8f403539a8ba29
Author: Nayna Jain <nayna@linux.vnet.ibm.com>
Date:   Tue Oct 17 16:32:29 2017 -0400

    tpm: move wait_for_tpm_stat() to respective driver files
    
    The function wait_for_tpm_stat() is currently defined in
    tpm-interface file. It is a hardware specific function used
    only by tpm_tis and xen-tpmfront, so it is removed from
    tpm-interface.c and defined in respective driver files.
    
    Suggested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Nayna Jain <nayna@linux.vnet.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 656e8af95d52..911475d36800 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -10,6 +10,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
+#include <linux/freezer.h>
 #include <xen/xen.h>
 #include <xen/events.h>
 #include <xen/interface/io/tpmif.h>
@@ -39,6 +40,66 @@ enum status_bits {
 	VTPM_STATUS_CANCELED = 0x8,
 };
 
+static bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,
+					bool check_cancel, bool *canceled)
+{
+	u8 status = chip->ops->status(chip);
+
+	*canceled = false;
+	if ((status & mask) == mask)
+		return true;
+	if (check_cancel && chip->ops->req_canceled(chip, status)) {
+		*canceled = true;
+		return true;
+	}
+	return false;
+}
+
+static int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,
+		unsigned long timeout, wait_queue_head_t *queue,
+		bool check_cancel)
+{
+	unsigned long stop;
+	long rc;
+	u8 status;
+	bool canceled = false;
+
+	/* check current status */
+	status = chip->ops->status(chip);
+	if ((status & mask) == mask)
+		return 0;
+
+	stop = jiffies + timeout;
+
+	if (chip->flags & TPM_CHIP_FLAG_IRQ) {
+again:
+		timeout = stop - jiffies;
+		if ((long)timeout <= 0)
+			return -ETIME;
+		rc = wait_event_interruptible_timeout(*queue,
+			wait_for_tpm_stat_cond(chip, mask, check_cancel,
+					       &canceled),
+			timeout);
+		if (rc > 0) {
+			if (canceled)
+				return -ECANCELED;
+			return 0;
+		}
+		if (rc == -ERESTARTSYS && freezing(current)) {
+			clear_thread_flag(TIF_SIGPENDING);
+			goto again;
+		}
+	} else {
+		do {
+			tpm_msleep(TPM_TIMEOUT);
+			status = chip->ops->status(chip);
+			if ((status & mask) == mask)
+				return 0;
+		} while (time_before(jiffies, stop));
+	}
+	return -ETIME;
+}
+
 static u8 vtpm_status(struct tpm_chip *chip)
 {
 	struct tpm_private *priv = dev_get_drvdata(&chip->dev);

commit 5cec5bacd37784a1596d2f8fea377212948a0bf4
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Feb 5 22:39:37 2017 +0100

    tpm xen: drop unneeded chip variable
    
    The call that used chip was dropped in 1f0f30e404b3.  Drop the
    leftover declaration and initialization.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 5aaa268f3a78..656e8af95d52 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -289,7 +289,6 @@ static int tpmfront_probe(struct xenbus_device *dev,
 		const struct xenbus_device_id *id)
 {
 	struct tpm_private *priv;
-	struct tpm_chip *chip;
 	int rv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
@@ -306,7 +305,6 @@ static int tpmfront_probe(struct xenbus_device *dev,
 
 	rv = setup_ring(dev, priv);
 	if (rv) {
-		chip = dev_get_drvdata(&dev->dev);
 		ring_free(priv);
 		return rv;
 	}

commit 683b96f4d1d132fcefa4a0bd11916649800d7361
Merge: 0f1d6dfe03ca 50523a29d900
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 14 13:57:44 2016 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Generally pretty quiet for this release. Highlights:
    
      Yama:
       - allow ptrace access for original parent after re-parenting
    
      TPM:
       - add documentation
       - many bugfixes & cleanups
       - define a generic open() method for ascii & bios measurements
    
      Integrity:
       - Harden against malformed xattrs
    
      SELinux:
       - bugfixes & cleanups
    
      Smack:
       - Remove unnecessary smack_known_invalid label
       - Do not apply star label in smack_setprocattr hook
       - parse mnt opts after privileges check (fixes unpriv DoS vuln)"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (56 commits)
      Yama: allow access for the current ptrace parent
      tpm: adjust return value of tpm_read_log
      tpm: vtpm_proxy: conditionally call tpm_chip_unregister
      tpm: Fix handling of missing event log
      tpm: Check the bios_dir entry for NULL before accessing it
      tpm: return -ENODEV if np is not set
      tpm: cleanup of printk error messages
      tpm: replace of_find_node_by_name() with dev of_node property
      tpm: redefine read_log() to handle ACPI/OF at runtime
      tpm: fix the missing .owner in tpm_bios_measurements_ops
      tpm: have event log use the tpm_chip
      tpm: drop tpm1_chip_register(/unregister)
      tpm: replace dynamically allocated bios_dir with a static array
      tpm: replace symbolic permission with octal for securityfs files
      char: tpm: fix kerneldoc tpm2_unseal_trusted name typo
      tpm_tis: Allow tpm_tis to be bound using DT
      tpm, tpm_vtpm_proxy: add kdoc comments for VTPM_PROXY_IOC_NEW_DEV
      tpm: Only call pm_runtime_get_sync if device has a parent
      tpm: define a generic open() method for ascii & bios measurements
      Documentation: tpm: add the Physical TPM device tree binding documentation
      ...

commit 1f0f30e404b3d8f4597a2d9b77fba55452f8fd0e
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Wed Oct 26 16:28:45 2016 -0600

    tpm xen: Remove bogus tpm_chip_unregister
    
    tpm_chip_unregister can only be called after tpm_chip_register.
    devm manages the allocation so no unwind is needed here.
    
    Cc: stable@vger.kernel.org
    Fixes: afb5abc262e96 ("tpm: two-phase chip management functions")
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 62028f483bba..a2ab00831df1 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -307,7 +307,6 @@ static int tpmfront_probe(struct xenbus_device *dev,
 	rv = setup_ring(dev, priv);
 	if (rv) {
 		chip = dev_get_drvdata(&dev->dev);
-		tpm_chip_unregister(chip);
 		ring_free(priv);
 		return rv;
 	}

commit 0240933469ea4cc1aa1c32867349c4aa718fe264
Author: Juergen Gross <jgross@suse.com>
Date:   Mon Oct 31 14:58:40 2016 +0100

    xen: make use of xenbus_read_unsigned() in xen-tpmfront
    
    Use xenbus_read_unsigned() instead of xenbus_scanf() when possible.
    This requires to change the type of one read from int to unsigned,
    but this case has been wrong before: negative values are not allowed
    for the modified case.
    
    Cc: peterhuewe@gmx.de
    Cc: tpmdd@selhorst.net
    Cc: jarkko.sakkinen@linux.intel.com
    Cc: jgunthorpe@obsidianresearch.com
    Cc: tpmdd-devel@lists.sourceforge.net
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Acked-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 62028f483bba..50072cc4fe5c 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -337,18 +337,14 @@ static int tpmfront_resume(struct xenbus_device *dev)
 static void backend_changed(struct xenbus_device *dev,
 		enum xenbus_state backend_state)
 {
-	int val;
-
 	switch (backend_state) {
 	case XenbusStateInitialised:
 	case XenbusStateConnected:
 		if (dev->state == XenbusStateConnected)
 			break;
 
-		if (xenbus_scanf(XBT_NIL, dev->otherend,
-				"feature-protocol-v2", "%d", &val) < 0)
-			val = 0;
-		if (!val) {
+		if (!xenbus_read_unsigned(dev->otherend, "feature-protocol-v2",
+					  0)) {
 			xenbus_dev_fatal(dev, -EINVAL,
 					"vTPM protocol 2 required");
 			return;

commit 9e0d39d8a6a0a8805d05fba22e3fbe80b5c8c4cb
Author: Christophe Ricard <christophe.ricard@gmail.com>
Date:   Thu Mar 31 22:57:00 2016 +0200

    tpm: Remove useless priv field in struct tpm_vendor_specific
    
    Remove useless priv field in struct tpm_vendor_specific and take benefit
    of chip->dev.driver_data.  As priv is the latest field available in
    struct tpm_vendor_specific, remove any reference to that structure.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 1b28f96f3766..62028f483bba 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -41,7 +41,7 @@ enum status_bits {
 
 static u8 vtpm_status(struct tpm_chip *chip)
 {
-	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	switch (priv->shr->state) {
 	case VTPM_STATE_IDLE:
 		return VTPM_STATUS_IDLE | VTPM_STATUS_CANCELED;
@@ -62,7 +62,7 @@ static bool vtpm_req_canceled(struct tpm_chip *chip, u8 status)
 
 static void vtpm_cancel(struct tpm_chip *chip)
 {
-	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	priv->shr->state = VTPM_STATE_CANCEL;
 	wmb();
 	notify_remote_via_evtchn(priv->evtchn);
@@ -75,7 +75,7 @@ static unsigned int shr_data_offset(struct vtpm_shared_page *shr)
 
 static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 {
-	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	struct vtpm_shared_page *shr = priv->shr;
 	unsigned int offset = shr_data_offset(shr);
 
@@ -117,7 +117,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 
 static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
-	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	struct vtpm_shared_page *shr = priv->shr;
 	unsigned int offset = shr_data_offset(shr);
 	size_t length = shr->length;
@@ -184,7 +184,7 @@ static int setup_chip(struct device *dev, struct tpm_private *priv)
 	init_waitqueue_head(&priv->read_queue);
 
 	priv->chip = chip;
-	TPM_VPRIV(chip) = priv;
+	dev_set_drvdata(&chip->dev, priv);
 
 	return 0;
 }
@@ -320,10 +320,10 @@ static int tpmfront_probe(struct xenbus_device *dev,
 static int tpmfront_remove(struct xenbus_device *dev)
 {
 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
-	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	tpm_chip_unregister(chip);
 	ring_free(priv);
-	TPM_VPRIV(chip) = NULL;
+	dev_set_drvdata(&chip->dev, NULL);
 	return 0;
 }
 

commit af782f339a5d6ea202652c9f06880e1a28c43813
Author: Christophe Ricard <christophe.ricard@gmail.com>
Date:   Thu Mar 31 22:56:59 2016 +0200

    tpm: Move tpm_vendor_specific data related with PTP specification to tpm_chip
    
    Move tpm_vendor_specific data related to TCG PTP specification to tpm_chip.
    
    Move all fields directly linked with well known TCG concepts and used in
    TPM drivers (tpm_i2c_atmel, tpm_i2c_infineon, tpm_i2c_nuvoton, tpm_tis
    and xen-tpmfront) as well as in TPM core files (tpm-sysfs, tpm-interface
    and tpm2-cmd) in tpm_chip.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index cca89d9f004e..1b28f96f3766 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -89,7 +89,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 		return -EINVAL;
 
 	/* Wait for completion of any existing command or cancellation */
-	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->vendor.timeout_c,
+	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->timeout_c,
 			&priv->read_queue, true) < 0) {
 		vtpm_cancel(chip);
 		return -ETIME;
@@ -126,7 +126,7 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 		return -ECANCELED;
 
 	/* In theory the wait at the end of _send makes this one unnecessary */
-	if (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->vendor.timeout_c,
+	if (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->timeout_c,
 			&priv->read_queue, true) < 0) {
 		vtpm_cancel(chip);
 		return -ETIME;

commit 6e599f6f261fe61582e6bedcc0aff924ac5da614
Author: Christophe Ricard <christophe.ricard@gmail.com>
Date:   Thu Mar 31 22:56:57 2016 +0200

    tpm: drop 'read_queue' from struct tpm_vendor_specific
    
    Dropped the field 'read_queue' from struct tpm_vendor_specific and make it
    available to the various private structures in the drivers.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 329941d7764c..cca89d9f004e 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -29,6 +29,7 @@ struct tpm_private {
 	int ring_ref;
 	domid_t backend_id;
 	int irq;
+	wait_queue_head_t read_queue;
 };
 
 enum status_bits {
@@ -89,7 +90,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 
 	/* Wait for completion of any existing command or cancellation */
 	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->vendor.timeout_c,
-			&chip->vendor.read_queue, true) < 0) {
+			&priv->read_queue, true) < 0) {
 		vtpm_cancel(chip);
 		return -ETIME;
 	}
@@ -105,7 +106,7 @@ static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 	duration = tpm_calc_ordinal_duration(chip, ordinal);
 
 	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, duration,
-			&chip->vendor.read_queue, true) < 0) {
+			&priv->read_queue, true) < 0) {
 		/* got a signal or timeout, try to cancel */
 		vtpm_cancel(chip);
 		return -ETIME;
@@ -126,7 +127,7 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 
 	/* In theory the wait at the end of _send makes this one unnecessary */
 	if (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->vendor.timeout_c,
-			&chip->vendor.read_queue, true) < 0) {
+			&priv->read_queue, true) < 0) {
 		vtpm_cancel(chip);
 		return -ETIME;
 	}
@@ -162,7 +163,7 @@ static irqreturn_t tpmif_interrupt(int dummy, void *dev_id)
 	switch (priv->shr->state) {
 	case VTPM_STATE_IDLE:
 	case VTPM_STATE_FINISH:
-		wake_up_interruptible(&priv->chip->vendor.read_queue);
+		wake_up_interruptible(&priv->read_queue);
 		break;
 	case VTPM_STATE_SUBMIT:
 	case VTPM_STATE_CANCEL:
@@ -180,7 +181,7 @@ static int setup_chip(struct device *dev, struct tpm_private *priv)
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
 
-	init_waitqueue_head(&chip->vendor.read_queue);
+	init_waitqueue_head(&priv->read_queue);
 
 	priv->chip = chip;
 	TPM_VPRIV(chip) = priv;

commit 570a36097f302c0bae4fb5478f1287b9b3626155
Author: Christophe Ricard <christophe.ricard@gmail.com>
Date:   Thu Mar 31 22:56:56 2016 +0200

    tpm: drop 'irq' from struct tpm_vendor_specific
    
    Dropped the field 'irq' from struct tpm_vendor_specific and make it
    available to the various private structures in the drivers using irqs.
    
    A dedicated flag TPM_CHIP_FLAG_IRQ is added for the upper layers.
    
    In st33zp24, struct st33zp24_dev declaration is moved to st33zp24.h in
    order to make accessible irq from other phy's(i2c, spi).
    
    In tpm_i2c_nuvoton, chip->vendor.priv is not directly allocated. We can
    access irq field from priv_data in a cleaner way.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 3111f2778079..329941d7764c 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -28,6 +28,7 @@ struct tpm_private {
 	unsigned int evtchn;
 	int ring_ref;
 	domid_t backend_id;
+	int irq;
 };
 
 enum status_bits {
@@ -217,7 +218,7 @@ static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
 		xenbus_dev_fatal(dev, rv, "allocating TPM irq");
 		return rv;
 	}
-	priv->chip->vendor.irq = rv;
+	priv->irq = rv;
 
  again:
 	rv = xenbus_transaction_start(&xbt);
@@ -277,8 +278,8 @@ static void ring_free(struct tpm_private *priv)
 	else
 		free_page((unsigned long)priv->shr);
 
-	if (priv->chip && priv->chip->vendor.irq)
-		unbind_from_irqhandler(priv->chip->vendor.irq, priv);
+	if (priv->irq)
+		unbind_from_irqhandler(priv->irq, priv);
 
 	kfree(priv);
 }

commit ccc9d90a9a8b5c4ad7e9708ec41f75ff9e98d61d
Author: Wei Liu <wei.liu2@citrix.com>
Date:   Fri Apr 3 14:44:59 2015 +0800

    xenbus_client: Extend interface to support multi-page ring
    
    Originally Xen PV drivers only use single-page ring to pass along
    information. This might limit the throughput between frontend and
    backend.
    
    The patch extends Xenbus driver to support multi-page ring, which in
    general should improve throughput if ring is the bottleneck. Changes to
    various frontend / backend to adapt to the new interface are also
    included.
    
    Affected Xen drivers:
    * blkfront/back
    * netfront/back
    * pcifront/back
    * scsifront/back
    * vtpmfront
    
    The interface is documented, as before, in xenbus_client.c.
    
    Signed-off-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
    Signed-off-by: Bob Liu <bob.liu@oracle.com>
    Cc: Konrad Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index c3b4f5a5ac10..3111f2778079 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -193,6 +193,7 @@ static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
 	struct xenbus_transaction xbt;
 	const char *message = NULL;
 	int rv;
+	grant_ref_t gref;
 
 	priv->shr = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
 	if (!priv->shr) {
@@ -200,11 +201,11 @@ static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
 		return -ENOMEM;
 	}
 
-	rv = xenbus_grant_ring(dev, virt_to_mfn(priv->shr));
+	rv = xenbus_grant_ring(dev, &priv->shr, 1, &gref);
 	if (rv < 0)
 		return rv;
 
-	priv->ring_ref = rv;
+	priv->ring_ref = gref;
 
 	rv = xenbus_alloc_evtchn(dev, &priv->evtchn);
 	if (rv)

commit afb5abc262e962089ef2d7c2bbf71bb6f53a2a78
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Fri Dec 12 11:46:34 2014 -0800

    tpm: two-phase chip management functions
    
    tpm_register_hardware() and tpm_remove_hardware() are called often
    before initializing the device. The problem is that the device might
    not be fully initialized when it comes visible to the user space.
    
    This patch resolves the issue by diving initialization into two
    parts:
    
    - tpmm_chip_alloc() creates struct tpm_chip.
    
    - tpm_chip_register() sets up the character device and sysfs
      attributes.
    
    The framework takes care of freeing struct tpm_chip by using the devres
    API. The broken release callback has been wiped. ACPI drivers do not
    ever get this callback.
    
    Regards to Jason Gunthorpe for carefully reviewing this part of the
    code.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jasob Gunthorpe <jason.gunthorpe@obsidianresearch.com>
    Reviewed-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
    Tested-by: Scot Doyle <lkml14@scotdoyle.com>
    Tested-by: Peter Huewe <peterhuewe@gmx.de>
    [phuewe: update to upstream changes]
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 441b44e54226..c3b4f5a5ac10 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -175,9 +175,9 @@ static int setup_chip(struct device *dev, struct tpm_private *priv)
 {
 	struct tpm_chip *chip;
 
-	chip = tpm_register_hardware(dev, &tpm_vtpm);
-	if (!chip)
-		return -ENODEV;
+	chip = tpmm_chip_alloc(dev, &tpm_vtpm);
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
 
 	init_waitqueue_head(&chip->vendor.read_queue);
 
@@ -286,6 +286,7 @@ static int tpmfront_probe(struct xenbus_device *dev,
 		const struct xenbus_device_id *id)
 {
 	struct tpm_private *priv;
+	struct tpm_chip *chip;
 	int rv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
@@ -302,21 +303,22 @@ static int tpmfront_probe(struct xenbus_device *dev,
 
 	rv = setup_ring(dev, priv);
 	if (rv) {
-		tpm_remove_hardware(&dev->dev);
+		chip = dev_get_drvdata(&dev->dev);
+		tpm_chip_unregister(chip);
 		ring_free(priv);
 		return rv;
 	}
 
 	tpm_get_timeouts(priv->chip);
 
-	return rv;
+	return tpm_chip_register(priv->chip);
 }
 
 static int tpmfront_remove(struct xenbus_device *dev)
 {
 	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
 	struct tpm_private *priv = TPM_VPRIV(chip);
-	tpm_remove_hardware(&dev->dev);
+	tpm_chip_unregister(chip);
 	ring_free(priv);
 	TPM_VPRIV(chip) = NULL;
 	return 0;

commit 95afae481414cbdb0567bf82d5e5077c3ac9da20
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon Sep 8 17:30:41 2014 +0100

    xen: remove DEFINE_XENBUS_DRIVER() macro
    
    The DEFINE_XENBUS_DRIVER() macro looks a bit weird and causes sparse
    errors.
    
    Replace the uses with standard structure definitions instead.  This is
    similar to pci and usb device registration.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 2064b4527040..441b44e54226 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -367,12 +367,13 @@ static const struct xenbus_device_id tpmfront_ids[] = {
 };
 MODULE_ALIAS("xen:vtpm");
 
-static DEFINE_XENBUS_DRIVER(tpmfront, ,
-		.probe = tpmfront_probe,
-		.remove = tpmfront_remove,
-		.resume = tpmfront_resume,
-		.otherend_changed = backend_changed,
-	);
+static struct xenbus_driver tpmfront_driver = {
+	.ids = tpmfront_ids,
+	.probe = tpmfront_probe,
+	.remove = tpmfront_remove,
+	.resume = tpmfront_resume,
+	.otherend_changed = backend_changed,
+};
 
 static int __init xen_tpmfront_init(void)
 {

commit 84621c9b18d0bb6cb267e3395c7f3131ecf4d39c
Merge: 7ebd3faa9b5b c9f6e9977e38
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 22 22:00:18 2014 -0800

    Merge tag 'stable/for-linus-3.14-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull Xen updates from Konrad Rzeszutek Wilk:
     "Two major features that Xen community is excited about:
    
      The first is event channel scalability by David Vrabel - we switch
      over from an two-level per-cpu bitmap of events (IRQs) - to an FIFO
      queue with priorities.  This lets us be able to handle more events,
      have lower latency, and better scalability.  Good stuff.
    
      The other is PVH by Mukesh Rathor.  In short, PV is a mode where the
      kernel lets the hypervisor program page-tables, segments, etc.  With
      EPT/NPT capabilities in current processors, the overhead of doing this
      in an HVM (Hardware Virtual Machine) container is much lower than the
      hypervisor doing it for us.
    
      In short we let a PV guest run without doing page-table, segment,
      syscall, etc updates through the hypervisor - instead it is all done
      within the guest container.  It is a "hybrid" PV - hence the 'PVH'
      name - a PV guest within an HVM container.
    
      The major benefits are less code to deal with - for example we only
      use one function from the the pv_mmu_ops (which has 39 function
      calls); faster performance for syscall (no context switches into the
      hypervisor); less traps on various operations; etc.
    
      It is still being baked - the ABI is not yet set in stone.  But it is
      pretty awesome and we are excited about it.
    
      Lastly, there are some changes to ARM code - you should get a simple
      conflict which has been resolved in #linux-next.
    
      In short, this pull has awesome features.
    
      Features:
       - FIFO event channels.  Key advantages: support for over 100,000
         events (2^17), 16 different event priorities, improved fairness in
         event latency through the use of FIFOs.
       - Xen PVH support.  "It’s a fully PV kernel mode, running with
         paravirtualized disk and network, paravirtualized interrupts and
         timers, no emulated devices of any kind (and thus no qemu), no BIOS
         or legacy boot — but instead of requiring PV MMU, it uses the HVM
         hardware extensions to virtualize the pagetables, as well as system
         calls and other privileged operations." (from "The
         Paravirtualization Spectrum, Part 2: From poles to a spectrum")
    
      Bug-fixes:
       - Fixes in balloon driver (refactor and make it work under ARM)
       - Allow xenfb to be used in HVM guests.
       - Allow xen_platform_pci=0 to work properly.
       - Refactors in event channels"
    
    * tag 'stable/for-linus-3.14-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip: (52 commits)
      xen/pvh: Set X86_CR0_WP and others in CR0 (v2)
      MAINTAINERS: add git repository for Xen
      xen/pvh: Use 'depend' instead of 'select'.
      xen: delete new instances of __cpuinit usage
      xen/fb: allow xenfb initialization for hvm guests
      xen/evtchn_fifo: fix error return code in evtchn_fifo_setup()
      xen-platform: fix error return code in platform_pci_init()
      xen/pvh: remove duplicated include from enlighten.c
      xen/pvh: Fix compile issues with xen_pvh_domain()
      xen: Use dev_is_pci() to check whether it is pci device
      xen/grant-table: Force to use v1 of grants.
      xen/pvh: Support ParaVirtualized Hardware extensions (v3).
      xen/pvh: Piggyback on PVHVM XenBus.
      xen/pvh: Piggyback on PVHVM for grant driver (v4)
      xen/grant: Implement an grant frame array struct (v3).
      xen/grant-table: Refactor gnttab_init
      xen/grants: Remove gnttab_max_grant_frames dependency on gnttab_init.
      xen/pvh: Piggyback on PVHVM for event channels (v2)
      xen/pvh: Update E820 to work with PVH (v2)
      xen/pvh: Secondary VCPU bringup (non-bootup CPUs)
      ...

commit 01ad1fa75dd243909d62dba25a93254b20d5fe81
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Tue Nov 26 13:30:43 2013 -0700

    tpm: Create a tpm_class_ops structure and use it in the drivers
    
    This replaces the static initialization of a tpm_vendor_specific
    structure in the drivers with the standard Linux idiom of providing
    a const structure of function pointers.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Reviewed-by: Joel Schopp <jschopp@linux.vnet.ibm.com>
    Reviewed-by: Ashley Lai <adlai@linux.vnet.ibm.com>
    [phuewe: did apply manually due to commit
    191ffc6bde3 tpm/tpm_i2c_atmel: fix coccinelle warnings]
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index d4f6b5213443..92b097064df5 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -143,7 +143,7 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 	return length;
 }
 
-static const struct tpm_vendor_specific tpm_vtpm = {
+static const struct tpm_class_ops tpm_vtpm = {
 	.status = vtpm_status,
 	.recv = vtpm_recv,
 	.send = vtpm_send,

commit 1e3b73a95793555860512008035f6822406a2a79
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Tue Nov 26 13:30:42 2013 -0700

    tpm: Pull all driver sysfs code into tpm-sysfs.c
    
    The tpm core now sets up and controls all sysfs attributes, instead
    of having each driver have a unique take on it.
    
    All drivers now now have a uniform set of attributes, and no sysfs
    related entry points are exported from the tpm core module.
    
    This also uses the new method used to declare sysfs attributes
    with DEVICE_ATTR_RO and 'struct attribute *'
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    [phuewe: had to apply the tpm_i2c_atmel part manually due to commit
    191ffc6bde3fc tpm/tpm_i2c_atmel: fix coccinelle warnings]
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index e3c7c0154515..d4f6b5213443 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -143,36 +143,6 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 	return length;
 }
 
-static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
-static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
-static DEVICE_ATTR(enabled, S_IRUGO, tpm_show_enabled, NULL);
-static DEVICE_ATTR(active, S_IRUGO, tpm_show_active, NULL);
-static DEVICE_ATTR(owned, S_IRUGO, tpm_show_owned, NULL);
-static DEVICE_ATTR(temp_deactivated, S_IRUGO, tpm_show_temp_deactivated,
-		NULL);
-static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
-static DEVICE_ATTR(cancel, S_IWUSR | S_IWGRP, NULL, tpm_store_cancel);
-static DEVICE_ATTR(durations, S_IRUGO, tpm_show_durations, NULL);
-static DEVICE_ATTR(timeouts, S_IRUGO, tpm_show_timeouts, NULL);
-
-static struct attribute *vtpm_attrs[] = {
-	&dev_attr_pubek.attr,
-	&dev_attr_pcrs.attr,
-	&dev_attr_enabled.attr,
-	&dev_attr_active.attr,
-	&dev_attr_owned.attr,
-	&dev_attr_temp_deactivated.attr,
-	&dev_attr_caps.attr,
-	&dev_attr_cancel.attr,
-	&dev_attr_durations.attr,
-	&dev_attr_timeouts.attr,
-	NULL,
-};
-
-static struct attribute_group vtpm_attr_grp = {
-	.attrs = vtpm_attrs,
-};
-
 static const struct tpm_vendor_specific tpm_vtpm = {
 	.status = vtpm_status,
 	.recv = vtpm_recv,
@@ -181,7 +151,6 @@ static const struct tpm_vendor_specific tpm_vtpm = {
 	.req_complete_mask = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,
 	.req_complete_val  = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,
 	.req_canceled      = vtpm_req_canceled,
-	.attr_group = &vtpm_attr_grp,
 };
 
 static irqreturn_t tpmif_interrupt(int dummy, void *dev_id)

commit afdba32e2a9ea729a9f9f280dbf6c718773c7ded
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Tue Nov 26 13:30:40 2013 -0700

    tpm: Pull everything related to /dev/tpmX into tpm-dev.c
    
    CLASS-dev.c is a common idiom for Linux subsystems
    
    This pulls all the code related to the miscdev into tpm-dev.c and makes it
    static. The identical file_operation structs in the drivers are purged and the
    tpm common code unconditionally creates the miscdev.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Reviewed-by: Joel Schopp <jschopp@linux.vnet.ibm.com>
    Reviewed-by: Ashley Lai <adlai@linux.vnet.ibm.com>
    [phuewe:
    tpm_dev_release is now used only in this file, thus the EXPORT_SYMBOL
    can be dropped and the function be marked as static.
    It has no other in-kernel users]
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index c8ff4df81779..e3c7c0154515 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -143,15 +143,6 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 	return length;
 }
 
-static const struct file_operations vtpm_ops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.open = tpm_open,
-	.read = tpm_read,
-	.write = tpm_write,
-	.release = tpm_release,
-};
-
 static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
 static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
 static DEVICE_ATTR(enabled, S_IRUGO, tpm_show_enabled, NULL);
@@ -191,9 +182,6 @@ static const struct tpm_vendor_specific tpm_vtpm = {
 	.req_complete_val  = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,
 	.req_canceled      = vtpm_req_canceled,
 	.attr_group = &vtpm_attr_grp,
-	.miscdev = {
-		.fops = &vtpm_ops,
-	},
 };
 
 static irqreturn_t tpmif_interrupt(int dummy, void *dev_id)

commit 51c71a3bbaca868043cc45b3ad3786dd48a90235
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Nov 26 15:05:40 2013 -0500

    xen/pvhvm: If xen_platform_pci=0 is set don't blow up (v4).
    
    The user has the option of disabling the platform driver:
    00:02.0 Unassigned class [ff80]: XenSource, Inc. Xen Platform Device (rev 01)
    
    which is used to unplug the emulated drivers (IDE, Realtek 8169, etc)
    and allow the PV drivers to take over. If the user wishes
    to disable that they can set:
    
      xen_platform_pci=0
      (in the guest config file)
    
    or
      xen_emul_unplug=never
      (on the Linux command line)
    
    except it does not work properly. The PV drivers still try to
    load and since the Xen platform driver is not run - and it
    has not initialized the grant tables, most of the PV drivers
    stumble upon:
    
    input: Xen Virtual Keyboard as /devices/virtual/input/input5
    input: Xen Virtual Pointer as /devices/virtual/input/input6M
    ------------[ cut here ]------------
    kernel BUG at /home/konrad/ssd/konrad/linux/drivers/xen/grant-table.c:1206!
    invalid opcode: 0000 [#1] SMP
    Modules linked in: xen_kbdfront(+) xenfs xen_privcmd
    CPU: 6 PID: 1389 Comm: modprobe Not tainted 3.13.0-rc1upstream-00021-ga6c892b-dirty #1
    Hardware name: Xen HVM domU, BIOS 4.4-unstable 11/26/2013
    RIP: 0010:[<ffffffff813ddc40>]  [<ffffffff813ddc40>] get_free_entries+0x2e0/0x300
    Call Trace:
     [<ffffffff8150d9a3>] ? evdev_connect+0x1e3/0x240
     [<ffffffff813ddd0e>] gnttab_grant_foreign_access+0x2e/0x70
     [<ffffffffa0010081>] xenkbd_connect_backend+0x41/0x290 [xen_kbdfront]
     [<ffffffffa0010a12>] xenkbd_probe+0x2f2/0x324 [xen_kbdfront]
     [<ffffffff813e5757>] xenbus_dev_probe+0x77/0x130
     [<ffffffff813e7217>] xenbus_frontend_dev_probe+0x47/0x50
     [<ffffffff8145e9a9>] driver_probe_device+0x89/0x230
     [<ffffffff8145ebeb>] __driver_attach+0x9b/0xa0
     [<ffffffff8145eb50>] ? driver_probe_device+0x230/0x230
     [<ffffffff8145eb50>] ? driver_probe_device+0x230/0x230
     [<ffffffff8145cf1c>] bus_for_each_dev+0x8c/0xb0
     [<ffffffff8145e7d9>] driver_attach+0x19/0x20
     [<ffffffff8145e260>] bus_add_driver+0x1a0/0x220
     [<ffffffff8145f1ff>] driver_register+0x5f/0xf0
     [<ffffffff813e55c5>] xenbus_register_driver_common+0x15/0x20
     [<ffffffff813e76b3>] xenbus_register_frontend+0x23/0x40
     [<ffffffffa0015000>] ? 0xffffffffa0014fff
     [<ffffffffa001502b>] xenkbd_init+0x2b/0x1000 [xen_kbdfront]
     [<ffffffff81002049>] do_one_initcall+0x49/0x170
    
    .. snip..
    
    which is hardly nice. This patch fixes this by having each
    PV driver check for:
     - if running in PV, then it is fine to execute (as that is their
       native environment).
     - if running in HVM, check if user wanted 'xen_emul_unplug=never',
       in which case bail out and don't load any PV drivers.
     - if running in HVM, and if PCI device 5853:0001 (xen_platform_pci)
       does not exist, then bail out and not load PV drivers.
     - (v2) if running in HVM, and if the user wanted 'xen_emul_unplug=ide-disks',
       then bail out for all PV devices _except_ the block one.
       Ditto for the network one ('nics').
     - (v2) if running in HVM, and if the user wanted 'xen_emul_unplug=unnecessary'
       then load block PV driver, and also setup the legacy IDE paths.
       In (v3) make it actually load PV drivers.
    
    Reported-by: Sander Eikelenboom <linux@eikelenboom.it
    Reported-by: Anthony PERARD <anthony.perard@citrix.com>
    Reported-and-Tested-by: Fabio Fantoni <fabio.fantoni@m2r.biz>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    [v2: Add extra logic to handle the myrid ways 'xen_emul_unplug'
    can be used per Ian and Stefano suggestion]
    [v3: Make the unnecessary case work properly]
    [v4: s/disks/ide-disks/ spotted by Fabio]
    Reviewed-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [for PCI parts]
    CC: stable@vger.kernel.org

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index c8ff4df81779..62e7d383fa64 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -17,6 +17,7 @@
 #include <xen/xenbus.h>
 #include <xen/page.h>
 #include "tpm.h"
+#include <xen/platform_pci.h>
 
 struct tpm_private {
 	struct tpm_chip *chip;
@@ -421,6 +422,9 @@ static int __init xen_tpmfront_init(void)
 	if (!xen_domain())
 		return -ENODEV;
 
+	if (!xen_has_pv_devices())
+		return -ENODEV;
+
 	return xenbus_register_frontend(&tpmfront_driver);
 }
 module_init(xen_tpmfront_init);

commit 78dc53c422172a317adb0776dfb687057ffa28b7
Merge: 3eaded86ac3e 62fe318256be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 21 19:46:00 2013 -0800

    Merge branch 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "In this patchset, we finally get an SELinux update, with Paul Moore
      taking over as maintainer of that code.
    
      Also a significant update for the Keys subsystem, as well as
      maintenance updates to Smack, IMA, TPM, and Apparmor"
    
    and since I wanted to know more about the updates to key handling,
    here's the explanation from David Howells on that:
    
     "Okay.  There are a number of separate bits.  I'll go over the big bits
      and the odd important other bit, most of the smaller bits are just
      fixes and cleanups.  If you want the small bits accounting for, I can
      do that too.
    
       (1) Keyring capacity expansion.
    
            KEYS: Consolidate the concept of an 'index key' for key access
            KEYS: Introduce a search context structure
            KEYS: Search for auth-key by name rather than target key ID
            Add a generic associative array implementation.
            KEYS: Expand the capacity of a keyring
    
         Several of the patches are providing an expansion of the capacity of a
         keyring.  Currently, the maximum size of a keyring payload is one page.
         Subtract a small header and then divide up into pointers, that only gives
         you ~500 pointers on an x86_64 box.  However, since the NFS idmapper uses
         a keyring to store ID mapping data, that has proven to be insufficient to
         the cause.
    
         Whatever data structure I use to handle the keyring payload, it can only
         store pointers to keys, not the keys themselves because several keyrings
         may point to a single key.  This precludes inserting, say, and rb_node
         struct into the key struct for this purpose.
    
         I could make an rbtree of records such that each record has an rb_node
         and a key pointer, but that would use four words of space per key stored
         in the keyring.  It would, however, be able to use much existing code.
    
         I selected instead a non-rebalancing radix-tree type approach as that
         could have a better space-used/key-pointer ratio.  I could have used the
         radix tree implementation that we already have and insert keys into it by
         their serial numbers, but that means any sort of search must iterate over
         the whole radix tree.  Further, its nodes are a bit on the capacious side
         for what I want - especially given that key serial numbers are randomly
         allocated, thus leaving a lot of empty space in the tree.
    
         So what I have is an associative array that internally is a radix-tree
         with 16 pointers per node where the index key is constructed from the key
         type pointer and the key description.  This means that an exact lookup by
         type+description is very fast as this tells us how to navigate directly to
         the target key.
    
         I made the data structure general in lib/assoc_array.c as far as it is
         concerned, its index key is just a sequence of bits that leads to a
         pointer.  It's possible that someone else will be able to make use of it
         also.  FS-Cache might, for example.
    
       (2) Mark keys as 'trusted' and keyrings as 'trusted only'.
    
            KEYS: verify a certificate is signed by a 'trusted' key
            KEYS: Make the system 'trusted' keyring viewable by userspace
            KEYS: Add a 'trusted' flag and a 'trusted only' flag
            KEYS: Separate the kernel signature checking keyring from module signing
    
         These patches allow keys carrying asymmetric public keys to be marked as
         being 'trusted' and allow keyrings to be marked as only permitting the
         addition or linkage of trusted keys.
    
         Keys loaded from hardware during kernel boot or compiled into the kernel
         during build are marked as being trusted automatically.  New keys can be
         loaded at runtime with add_key().  They are checked against the system
         keyring contents and if their signatures can be validated with keys that
         are already marked trusted, then they are marked trusted also and can
         thus be added into the master keyring.
    
         Patches from Mimi Zohar make this usable with the IMA keyrings also.
    
       (3) Remove the date checks on the key used to validate a module signature.
    
            X.509: Remove certificate date checks
    
         It's not reasonable to reject a signature just because the key that it was
         generated with is no longer valid datewise - especially if the kernel
         hasn't yet managed to set the system clock when the first module is
         loaded - so just remove those checks.
    
       (4) Make it simpler to deal with additional X.509 being loaded into the kernel.
    
            KEYS: Load *.x509 files into kernel keyring
            KEYS: Have make canonicalise the paths of the X.509 certs better to deduplicate
    
         The builder of the kernel now just places files with the extension ".x509"
         into the kernel source or build trees and they're concatenated by the
         kernel build and stuffed into the appropriate section.
    
       (5) Add support for userspace kerberos to use keyrings.
    
            KEYS: Add per-user_namespace registers for persistent per-UID kerberos caches
            KEYS: Implement a big key type that can save to tmpfs
    
         Fedora went to, by default, storing kerberos tickets and tokens in tmpfs.
         We looked at storing it in keyrings instead as that confers certain
         advantages such as tickets being automatically deleted after a certain
         amount of time and the ability for the kernel to get at these tokens more
         easily.
    
         To make this work, two things were needed:
    
         (a) A way for the tickets to persist beyond the lifetime of all a user's
             sessions so that cron-driven processes can still use them.
    
             The problem is that a user's session keyrings are deleted when the
             session that spawned them logs out and the user's user keyring is
             deleted when the UID is deleted (typically when the last log out
             happens), so neither of these places is suitable.
    
             I've added a system keyring into which a 'persistent' keyring is
             created for each UID on request.  Each time a user requests their
             persistent keyring, the expiry time on it is set anew.  If the user
             doesn't ask for it for, say, three days, the keyring is automatically
             expired and garbage collected using the existing gc.  All the kerberos
             tokens it held are then also gc'd.
    
         (b) A key type that can hold really big tickets (up to 1MB in size).
    
             The problem is that Active Directory can return huge tickets with lots
             of auxiliary data attached.  We don't, however, want to eat up huge
             tracts of unswappable kernel space for this, so if the ticket is
             greater than a certain size, we create a swappable shmem file and dump
             the contents in there and just live with the fact we then have an
             inode and a dentry overhead.  If the ticket is smaller than that, we
             slap it in a kmalloc()'d buffer"
    
    * 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (121 commits)
      KEYS: Fix keyring content gc scanner
      KEYS: Fix error handling in big_key instantiation
      KEYS: Fix UID check in keyctl_get_persistent()
      KEYS: The RSA public key algorithm needs to select MPILIB
      ima: define '_ima' as a builtin 'trusted' keyring
      ima: extend the measurement list to include the file signature
      kernel/system_certificate.S: use real contents instead of macro GLOBAL()
      KEYS: fix error return code in big_key_instantiate()
      KEYS: Fix keyring quota misaccounting on key replacement and unlink
      KEYS: Fix a race between negating a key and reading the error set
      KEYS: Make BIG_KEYS boolean
      apparmor: remove the "task" arg from may_change_ptraced_domain()
      apparmor: remove parent task info from audit logging
      apparmor: remove tsk field from the apparmor_audit_struct
      apparmor: fix capability to not use the current task, during reporting
      Smack: Ptrace access check mode
      ima: provide hash algo info in the xattr
      ima: enable support for larger default filedata hash algorithms
      ima: define kernel parameter 'ima_template=' to change configured default
      ima: add Kconfig default measurement list template
      ...

commit d0a40174efb0b9d232ccd1cf127cb90a2120f55b
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Sat Oct 5 11:40:19 2013 -0600

    tpm: Remove redundant dev_set_drvdata
    
    TPM drivers should not call dev_set_drvdata (or aliases), only the core
    code is allowed to call dev_set_drvdata, and it does it during
    tpm_register_hardware.
    
    These extra sets are harmless, but are an anti-pattern that many drivers
    have copied.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Reviewed-by: Joel Schopp <jschopp@linux.vnet.ibm.com>
    Reviewed-by: Peter Huewe <peterhuewe@gmx.de>
    Acked-by: Ashley Lai <adlai@linux.vnet.ibm.com>
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 7a7929ba2658..9b483705694e 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -386,8 +386,6 @@ static int tpmfront_probe(struct xenbus_device *dev,
 
 	tpm_get_timeouts(priv->chip);
 
-	dev_set_drvdata(&dev->dev, priv->chip);
-
 	return rv;
 }
 

commit 8702c675319b838346a4fbaf4bbb783a563fa9a6
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Oct 10 14:38:27 2013 +0000

    tpm: xen-tpmfront: fix missing declaration of xen_domain
    
    xen-tpmfront fails to build on arm64 with the following error:
    
    drivers/char/tpm/xen-tpmfront.c: In function ‘xen_tpmfront_init’:
    drivers/char/tpm/xen-tpmfront.c:422:2: error: implicit declaration of function ‘xen_domain’ [-Werror=implicit-function-declaration]
    
    Add include of xen/xen.h to fix this.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Ashley Lai <adlai@linux.vnet.ibm.com>
    Acked-by: Ashley Lai <adlai@linux.vnet.ibm.com>
    Cc: Leonidas Da Silva Barbosa <leosilva@linux.vnet.ibm.com>
    Cc: Rajiv Andrade <mail@srajiv.net>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Cc: Sirrix AG <tpmdd@sirrix.com>
    Cc: tpmdd-devel@lists.sourceforge.net

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 06189e55b4e5..94c280d36e8b 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -10,6 +10,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
+#include <xen/xen.h>
 #include <xen/events.h>
 #include <xen/interface/io/tpmif.h>
 #include <xen/grant_table.h>

commit bf4a7c054be1306dcee5d4f5028eb66caf714037
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Mon Sep 23 14:54:15 2013 -0600

    tpm: xen-tpmfront: Remove the locality sysfs attribute
    
    Upon deeper review it was agreed to remove the driver-unique
    'locality' sysfs attribute before it is present in a released
    kernel.
    
    The attribute was introduced in e2683957fb268c6b29316fd9e7191e13239a30a5
    during the 3.12 merge window, so this patch needs to go in before
    3.12 is released.
    
    The hope is to have a well defined locality API that all the other
    locality aware drivers can use, perhaps in 3.13.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Daniel De Graaf <dgdegra@tycho.nsa.gov>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 6f2fe2b0ae56..06189e55b4e5 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -142,32 +142,6 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 	return length;
 }
 
-ssize_t tpm_show_locality(struct device *dev, struct device_attribute *attr,
-			  char *buf)
-{
-	struct tpm_chip *chip = dev_get_drvdata(dev);
-	struct tpm_private *priv = TPM_VPRIV(chip);
-	u8 locality = priv->shr->locality;
-
-	return sprintf(buf, "%d\n", locality);
-}
-
-ssize_t tpm_store_locality(struct device *dev, struct device_attribute *attr,
-			const char *buf, size_t len)
-{
-	struct tpm_chip *chip = dev_get_drvdata(dev);
-	struct tpm_private *priv = TPM_VPRIV(chip);
-	u8 val;
-
-	int rv = kstrtou8(buf, 0, &val);
-	if (rv)
-		return rv;
-
-	priv->shr->locality = val;
-
-	return len;
-}
-
 static const struct file_operations vtpm_ops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
@@ -188,8 +162,6 @@ static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
 static DEVICE_ATTR(cancel, S_IWUSR | S_IWGRP, NULL, tpm_store_cancel);
 static DEVICE_ATTR(durations, S_IRUGO, tpm_show_durations, NULL);
 static DEVICE_ATTR(timeouts, S_IRUGO, tpm_show_timeouts, NULL);
-static DEVICE_ATTR(locality, S_IRUGO | S_IWUSR, tpm_show_locality,
-		tpm_store_locality);
 
 static struct attribute *vtpm_attrs[] = {
 	&dev_attr_pubek.attr,
@@ -202,7 +174,6 @@ static struct attribute *vtpm_attrs[] = {
 	&dev_attr_cancel.attr,
 	&dev_attr_durations.attr,
 	&dev_attr_timeouts.attr,
-	&dev_attr_locality.attr,
 	NULL,
 };
 

commit 56be88954bdb3d77619a786bf301af01efb2b057
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Mon Sep 23 12:14:33 2013 -0600

    tpm: xen-tpmfront: Fix default durations
    
    All the default durations were being set to 10 minutes which is
    way too long for the timeouts. Normal values for the longest
    duration are around 5 mins, and short duration ar around .5s.
    
    Further, these are just the default, tpm_get_timeouts will set
    them to values from the TPM (or throw an error).
    
    Just remove them.
    
    Acked-by: Daniel De Graaf <dgdegra@tycho.nsa.gov>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 7a7929ba2658..6f2fe2b0ae56 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -210,8 +210,6 @@ static struct attribute_group vtpm_attr_grp = {
 	.attrs = vtpm_attrs,
 };
 
-#define TPM_LONG_TIMEOUT   (10 * 60 * HZ)
-
 static const struct tpm_vendor_specific tpm_vtpm = {
 	.status = vtpm_status,
 	.recv = vtpm_recv,
@@ -224,11 +222,6 @@ static const struct tpm_vendor_specific tpm_vtpm = {
 	.miscdev = {
 		.fops = &vtpm_ops,
 	},
-	.duration = {
-		TPM_LONG_TIMEOUT,
-		TPM_LONG_TIMEOUT,
-		TPM_LONG_TIMEOUT,
-	},
 };
 
 static irqreturn_t tpmif_interrupt(int dummy, void *dev_id)

commit e2683957fb268c6b29316fd9e7191e13239a30a5
Author: Daniel De Graaf <dgdegra@tycho.nsa.gov>
Date:   Tue Jul 30 13:29:47 2013 -0400

    drivers/tpm: add xen tpmfront interface
    
    This is a complete rewrite of the Xen TPM frontend driver, taking
    advantage of a simplified frontend/backend interface and adding support
    for cancellation and timeouts.  The backend for this driver is provided
    by a vTPM stub domain using the interface in Xen 4.3.
    
    Signed-off-by: Daniel De Graaf <dgdegra@tycho.nsa.gov>
    Acked-by: Matthew Fioravante <matthew.fioravante@jhuapl.edu>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Peter Huewe <peterhuewe@gmx.de>
    Reviewed-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
new file mode 100644
index 000000000000..7a7929ba2658
--- /dev/null
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -0,0 +1,473 @@
+/*
+ * Implementation of the Xen vTPM device frontend
+ *
+ * Author:  Daniel De Graaf <dgdegra@tycho.nsa.gov>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2,
+ * as published by the Free Software Foundation.
+ */
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <xen/events.h>
+#include <xen/interface/io/tpmif.h>
+#include <xen/grant_table.h>
+#include <xen/xenbus.h>
+#include <xen/page.h>
+#include "tpm.h"
+
+struct tpm_private {
+	struct tpm_chip *chip;
+	struct xenbus_device *dev;
+
+	struct vtpm_shared_page *shr;
+
+	unsigned int evtchn;
+	int ring_ref;
+	domid_t backend_id;
+};
+
+enum status_bits {
+	VTPM_STATUS_RUNNING  = 0x1,
+	VTPM_STATUS_IDLE     = 0x2,
+	VTPM_STATUS_RESULT   = 0x4,
+	VTPM_STATUS_CANCELED = 0x8,
+};
+
+static u8 vtpm_status(struct tpm_chip *chip)
+{
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	switch (priv->shr->state) {
+	case VTPM_STATE_IDLE:
+		return VTPM_STATUS_IDLE | VTPM_STATUS_CANCELED;
+	case VTPM_STATE_FINISH:
+		return VTPM_STATUS_IDLE | VTPM_STATUS_RESULT;
+	case VTPM_STATE_SUBMIT:
+	case VTPM_STATE_CANCEL: /* cancel requested, not yet canceled */
+		return VTPM_STATUS_RUNNING;
+	default:
+		return 0;
+	}
+}
+
+static bool vtpm_req_canceled(struct tpm_chip *chip, u8 status)
+{
+	return status & VTPM_STATUS_CANCELED;
+}
+
+static void vtpm_cancel(struct tpm_chip *chip)
+{
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	priv->shr->state = VTPM_STATE_CANCEL;
+	wmb();
+	notify_remote_via_evtchn(priv->evtchn);
+}
+
+static unsigned int shr_data_offset(struct vtpm_shared_page *shr)
+{
+	return sizeof(*shr) + sizeof(u32) * shr->nr_extra_pages;
+}
+
+static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
+{
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct vtpm_shared_page *shr = priv->shr;
+	unsigned int offset = shr_data_offset(shr);
+
+	u32 ordinal;
+	unsigned long duration;
+
+	if (offset > PAGE_SIZE)
+		return -EINVAL;
+
+	if (offset + count > PAGE_SIZE)
+		return -EINVAL;
+
+	/* Wait for completion of any existing command or cancellation */
+	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->vendor.timeout_c,
+			&chip->vendor.read_queue, true) < 0) {
+		vtpm_cancel(chip);
+		return -ETIME;
+	}
+
+	memcpy(offset + (u8 *)shr, buf, count);
+	shr->length = count;
+	barrier();
+	shr->state = VTPM_STATE_SUBMIT;
+	wmb();
+	notify_remote_via_evtchn(priv->evtchn);
+
+	ordinal = be32_to_cpu(((struct tpm_input_header*)buf)->ordinal);
+	duration = tpm_calc_ordinal_duration(chip, ordinal);
+
+	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, duration,
+			&chip->vendor.read_queue, true) < 0) {
+		/* got a signal or timeout, try to cancel */
+		vtpm_cancel(chip);
+		return -ETIME;
+	}
+
+	return count;
+}
+
+static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
+{
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	struct vtpm_shared_page *shr = priv->shr;
+	unsigned int offset = shr_data_offset(shr);
+	size_t length = shr->length;
+
+	if (shr->state == VTPM_STATE_IDLE)
+		return -ECANCELED;
+
+	/* In theory the wait at the end of _send makes this one unnecessary */
+	if (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->vendor.timeout_c,
+			&chip->vendor.read_queue, true) < 0) {
+		vtpm_cancel(chip);
+		return -ETIME;
+	}
+
+	if (offset > PAGE_SIZE)
+		return -EIO;
+
+	if (offset + length > PAGE_SIZE)
+		length = PAGE_SIZE - offset;
+
+	if (length > count)
+		length = count;
+
+	memcpy(buf, offset + (u8 *)shr, length);
+
+	return length;
+}
+
+ssize_t tpm_show_locality(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct tpm_chip *chip = dev_get_drvdata(dev);
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	u8 locality = priv->shr->locality;
+
+	return sprintf(buf, "%d\n", locality);
+}
+
+ssize_t tpm_store_locality(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct tpm_chip *chip = dev_get_drvdata(dev);
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	u8 val;
+
+	int rv = kstrtou8(buf, 0, &val);
+	if (rv)
+		return rv;
+
+	priv->shr->locality = val;
+
+	return len;
+}
+
+static const struct file_operations vtpm_ops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = tpm_open,
+	.read = tpm_read,
+	.write = tpm_write,
+	.release = tpm_release,
+};
+
+static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
+static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
+static DEVICE_ATTR(enabled, S_IRUGO, tpm_show_enabled, NULL);
+static DEVICE_ATTR(active, S_IRUGO, tpm_show_active, NULL);
+static DEVICE_ATTR(owned, S_IRUGO, tpm_show_owned, NULL);
+static DEVICE_ATTR(temp_deactivated, S_IRUGO, tpm_show_temp_deactivated,
+		NULL);
+static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
+static DEVICE_ATTR(cancel, S_IWUSR | S_IWGRP, NULL, tpm_store_cancel);
+static DEVICE_ATTR(durations, S_IRUGO, tpm_show_durations, NULL);
+static DEVICE_ATTR(timeouts, S_IRUGO, tpm_show_timeouts, NULL);
+static DEVICE_ATTR(locality, S_IRUGO | S_IWUSR, tpm_show_locality,
+		tpm_store_locality);
+
+static struct attribute *vtpm_attrs[] = {
+	&dev_attr_pubek.attr,
+	&dev_attr_pcrs.attr,
+	&dev_attr_enabled.attr,
+	&dev_attr_active.attr,
+	&dev_attr_owned.attr,
+	&dev_attr_temp_deactivated.attr,
+	&dev_attr_caps.attr,
+	&dev_attr_cancel.attr,
+	&dev_attr_durations.attr,
+	&dev_attr_timeouts.attr,
+	&dev_attr_locality.attr,
+	NULL,
+};
+
+static struct attribute_group vtpm_attr_grp = {
+	.attrs = vtpm_attrs,
+};
+
+#define TPM_LONG_TIMEOUT   (10 * 60 * HZ)
+
+static const struct tpm_vendor_specific tpm_vtpm = {
+	.status = vtpm_status,
+	.recv = vtpm_recv,
+	.send = vtpm_send,
+	.cancel = vtpm_cancel,
+	.req_complete_mask = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,
+	.req_complete_val  = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,
+	.req_canceled      = vtpm_req_canceled,
+	.attr_group = &vtpm_attr_grp,
+	.miscdev = {
+		.fops = &vtpm_ops,
+	},
+	.duration = {
+		TPM_LONG_TIMEOUT,
+		TPM_LONG_TIMEOUT,
+		TPM_LONG_TIMEOUT,
+	},
+};
+
+static irqreturn_t tpmif_interrupt(int dummy, void *dev_id)
+{
+	struct tpm_private *priv = dev_id;
+
+	switch (priv->shr->state) {
+	case VTPM_STATE_IDLE:
+	case VTPM_STATE_FINISH:
+		wake_up_interruptible(&priv->chip->vendor.read_queue);
+		break;
+	case VTPM_STATE_SUBMIT:
+	case VTPM_STATE_CANCEL:
+	default:
+		break;
+	}
+	return IRQ_HANDLED;
+}
+
+static int setup_chip(struct device *dev, struct tpm_private *priv)
+{
+	struct tpm_chip *chip;
+
+	chip = tpm_register_hardware(dev, &tpm_vtpm);
+	if (!chip)
+		return -ENODEV;
+
+	init_waitqueue_head(&chip->vendor.read_queue);
+
+	priv->chip = chip;
+	TPM_VPRIV(chip) = priv;
+
+	return 0;
+}
+
+/* caller must clean up in case of errors */
+static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
+{
+	struct xenbus_transaction xbt;
+	const char *message = NULL;
+	int rv;
+
+	priv->shr = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
+	if (!priv->shr) {
+		xenbus_dev_fatal(dev, -ENOMEM, "allocating shared ring");
+		return -ENOMEM;
+	}
+
+	rv = xenbus_grant_ring(dev, virt_to_mfn(priv->shr));
+	if (rv < 0)
+		return rv;
+
+	priv->ring_ref = rv;
+
+	rv = xenbus_alloc_evtchn(dev, &priv->evtchn);
+	if (rv)
+		return rv;
+
+	rv = bind_evtchn_to_irqhandler(priv->evtchn, tpmif_interrupt, 0,
+				       "tpmif", priv);
+	if (rv <= 0) {
+		xenbus_dev_fatal(dev, rv, "allocating TPM irq");
+		return rv;
+	}
+	priv->chip->vendor.irq = rv;
+
+ again:
+	rv = xenbus_transaction_start(&xbt);
+	if (rv) {
+		xenbus_dev_fatal(dev, rv, "starting transaction");
+		return rv;
+	}
+
+	rv = xenbus_printf(xbt, dev->nodename,
+			"ring-ref", "%u", priv->ring_ref);
+	if (rv) {
+		message = "writing ring-ref";
+		goto abort_transaction;
+	}
+
+	rv = xenbus_printf(xbt, dev->nodename, "event-channel", "%u",
+			priv->evtchn);
+	if (rv) {
+		message = "writing event-channel";
+		goto abort_transaction;
+	}
+
+	rv = xenbus_printf(xbt, dev->nodename, "feature-protocol-v2", "1");
+	if (rv) {
+		message = "writing feature-protocol-v2";
+		goto abort_transaction;
+	}
+
+	rv = xenbus_transaction_end(xbt, 0);
+	if (rv == -EAGAIN)
+		goto again;
+	if (rv) {
+		xenbus_dev_fatal(dev, rv, "completing transaction");
+		return rv;
+	}
+
+	xenbus_switch_state(dev, XenbusStateInitialised);
+
+	return 0;
+
+ abort_transaction:
+	xenbus_transaction_end(xbt, 1);
+	if (message)
+		xenbus_dev_error(dev, rv, "%s", message);
+
+	return rv;
+}
+
+static void ring_free(struct tpm_private *priv)
+{
+	if (!priv)
+		return;
+
+	if (priv->ring_ref)
+		gnttab_end_foreign_access(priv->ring_ref, 0,
+				(unsigned long)priv->shr);
+	else
+		free_page((unsigned long)priv->shr);
+
+	if (priv->chip && priv->chip->vendor.irq)
+		unbind_from_irqhandler(priv->chip->vendor.irq, priv);
+
+	kfree(priv);
+}
+
+static int tpmfront_probe(struct xenbus_device *dev,
+		const struct xenbus_device_id *id)
+{
+	struct tpm_private *priv;
+	int rv;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		xenbus_dev_fatal(dev, -ENOMEM, "allocating priv structure");
+		return -ENOMEM;
+	}
+
+	rv = setup_chip(&dev->dev, priv);
+	if (rv) {
+		kfree(priv);
+		return rv;
+	}
+
+	rv = setup_ring(dev, priv);
+	if (rv) {
+		tpm_remove_hardware(&dev->dev);
+		ring_free(priv);
+		return rv;
+	}
+
+	tpm_get_timeouts(priv->chip);
+
+	dev_set_drvdata(&dev->dev, priv->chip);
+
+	return rv;
+}
+
+static int tpmfront_remove(struct xenbus_device *dev)
+{
+	struct tpm_chip *chip = dev_get_drvdata(&dev->dev);
+	struct tpm_private *priv = TPM_VPRIV(chip);
+	tpm_remove_hardware(&dev->dev);
+	ring_free(priv);
+	TPM_VPRIV(chip) = NULL;
+	return 0;
+}
+
+static int tpmfront_resume(struct xenbus_device *dev)
+{
+	/* A suspend/resume/migrate will interrupt a vTPM anyway */
+	tpmfront_remove(dev);
+	return tpmfront_probe(dev, NULL);
+}
+
+static void backend_changed(struct xenbus_device *dev,
+		enum xenbus_state backend_state)
+{
+	int val;
+
+	switch (backend_state) {
+	case XenbusStateInitialised:
+	case XenbusStateConnected:
+		if (dev->state == XenbusStateConnected)
+			break;
+
+		if (xenbus_scanf(XBT_NIL, dev->otherend,
+				"feature-protocol-v2", "%d", &val) < 0)
+			val = 0;
+		if (!val) {
+			xenbus_dev_fatal(dev, -EINVAL,
+					"vTPM protocol 2 required");
+			return;
+		}
+		xenbus_switch_state(dev, XenbusStateConnected);
+		break;
+
+	case XenbusStateClosing:
+	case XenbusStateClosed:
+		device_unregister(&dev->dev);
+		xenbus_frontend_closed(dev);
+		break;
+	default:
+		break;
+	}
+}
+
+static const struct xenbus_device_id tpmfront_ids[] = {
+	{ "vtpm" },
+	{ "" }
+};
+MODULE_ALIAS("xen:vtpm");
+
+static DEFINE_XENBUS_DRIVER(tpmfront, ,
+		.probe = tpmfront_probe,
+		.remove = tpmfront_remove,
+		.resume = tpmfront_resume,
+		.otherend_changed = backend_changed,
+	);
+
+static int __init xen_tpmfront_init(void)
+{
+	if (!xen_domain())
+		return -ENODEV;
+
+	return xenbus_register_frontend(&tpmfront_driver);
+}
+module_init(xen_tpmfront_init);
+
+static void __exit xen_tpmfront_exit(void)
+{
+	xenbus_unregister_driver(&tpmfront_driver);
+}
+module_exit(xen_tpmfront_exit);
+
+MODULE_AUTHOR("Daniel De Graaf <dgdegra@tycho.nsa.gov>");
+MODULE_DESCRIPTION("Xen vTPM Driver");
+MODULE_LICENSE("GPL");
