commit 7f904d7e1f3ec7c2de47c024a5a5c30988b54703
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:38 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 505
    
    Based on 1 normalized pattern(s):
    
      gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 58 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081207.556988620@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
index 0c751a79bbed..7a0a7051a06f 100644
--- a/drivers/char/tpm/tpmrm-dev.c
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -1,7 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2017 James.Bottomley@HansenPartnership.com
- *
- * GPLv2
  */
 #include <linux/slab.h>
 #include "tpm-dev.h"

commit 9e1b74a63f7760b525295161fc608b19b8ee19c4
Author: Tadeusz Struk <tadeusz.struk@intel.com>
Date:   Mon Sep 10 10:18:33 2018 -0700

    tpm: add support for nonblocking operation
    
    Currently the TPM driver only supports blocking calls, which doesn't allow
    asynchronous IO operations to the TPM hardware.
    This patch changes it and adds support for nonblocking write and a new poll
    function to enable applications, which want to take advantage of this.
    
    Tested-by: Philip Tricca <philip.b.tricca@intel.com>
    Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off--by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
index 96006c6b9696..0c751a79bbed 100644
--- a/drivers/char/tpm/tpmrm-dev.c
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -51,5 +51,6 @@ const struct file_operations tpmrm_fops = {
 	.open = tpmrm_open,
 	.read = tpm_common_read,
 	.write = tpm_common_write,
+	.poll = tpm_common_poll,
 	.release = tpmrm_release,
 };

commit c3d477a725ef6b3d17609d5dafc644cccc070cb9
Author: Tadeusz Struk <tadeusz.struk@intel.com>
Date:   Mon Sep 10 10:18:28 2018 -0700

    tpm: add ptr to the tpm_space struct to file_priv
    
    Add a ptr to struct tpm_space to the file_priv and consolidate
    of the write operations for the two interfaces.
    
    Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Tested-by: Philip Tricca <philip.b.tricca@intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off--by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
index 1a0e97a5da5a..96006c6b9696 100644
--- a/drivers/char/tpm/tpmrm-dev.c
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -28,7 +28,7 @@ static int tpmrm_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	}
 
-	tpm_common_open(file, chip, &priv->priv);
+	tpm_common_open(file, chip, &priv->priv, &priv->space);
 
 	return 0;
 }
@@ -45,21 +45,11 @@ static int tpmrm_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static ssize_t tpmrm_write(struct file *file, const char __user *buf,
-		   size_t size, loff_t *off)
-{
-	struct file_priv *fpriv = file->private_data;
-	struct tpmrm_priv *priv = container_of(fpriv, struct tpmrm_priv, priv);
-
-	return tpm_common_write(file, buf, size, off, &priv->space);
-}
-
 const struct file_operations tpmrm_fops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
 	.open = tpmrm_open,
 	.read = tpm_common_read,
-	.write = tpmrm_write,
+	.write = tpm_common_write,
 	.release = tpmrm_release,
 };
-

commit 5e9fefd26b47205e423b23c3f0a41b068c84fa1d
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu May 25 07:43:05 2017 +0200

    tpm, tpmrm: Mark tpmrm_write as static
    
    sparse complains that tpmrm_write can be made static, and since it is
    right we make it static.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
index c636e7fdd1f5..1a0e97a5da5a 100644
--- a/drivers/char/tpm/tpmrm-dev.c
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -45,7 +45,7 @@ static int tpmrm_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-ssize_t tpmrm_write(struct file *file, const char __user *buf,
+static ssize_t tpmrm_write(struct file *file, const char __user *buf,
 		   size_t size, loff_t *off)
 {
 	struct file_priv *fpriv = file->private_data;

commit 4d57856a21ed2abe33412e0526cc84bdcf67ea08
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 31 15:47:31 2017 -0800

    tpm2: add session handle context saving and restoring to the space code
    
    Sessions are different from transient objects in that their handles
    may not be virtualized (because they're used for some hmac
    calculations).  Additionally when a session is context saved, a
    vestigial memory remains in the TPM and if it is also flushed, that
    will be lost and the session context will refuse to load next time, so
    the code is updated to flush only transient objects after a context
    save.  Add a separate array (chip->session_tbl) to save and restore
    sessions by handle.  Use the failure of a context save or load to
    signal that the session has been flushed from the TPM and we can
    remove its memory from chip->session_tbl.
    
    Sessions are also isolated during each instance of a tpm space.  This
    means that spaces shouldn't be able to see each other's sessions and
    is enforced by ensuring that a space user may only refer to sessions
    handles that are present in their own chip->session_tbl.  Finally when
    a space is closed, all the sessions belonging to it should be flushed
    so the handles may be re-used by other spaces.
    
    Note that if we get a session save or load error, all sessions are
    effectively flushed.  Even though we restore the session buffer, all
    the old sessions will refuse to load after the flush and they'll be
    purged from our session memory.  This means that while transient
    context handling is still soft in the face of errors, session handling
    is hard (any failure of the model means all sessions are lost).
    
    Fixes-from: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
index 630bddce65a8..c636e7fdd1f5 100644
--- a/drivers/char/tpm/tpmrm-dev.c
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -39,7 +39,7 @@ static int tpmrm_release(struct inode *inode, struct file *file)
 	struct tpmrm_priv *priv = container_of(fpriv, struct tpmrm_priv, priv);
 
 	tpm_common_release(file, fpriv);
-	tpm2_del_space(&priv->space);
+	tpm2_del_space(fpriv->chip, &priv->space);
 	kfree(priv);
 
 	return 0;

commit fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 3 09:07:32 2017 -0800

    tpm: expose spaces via a device link /dev/tpmrm<n>
    
    Currently the tpm spaces are not exposed to userspace.  Make this
    exposure via a separate device, which can now be opened multiple times
    because each read/write transaction goes separately via the space.
    
    Concurrency is protected by the chip->tpm_mutex for each read/write
    transaction separately.  The TPM is cleared of all transient objects
    by the time the mutex is dropped, so there should be no interference
    between the kernel and userspace.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/drivers/char/tpm/tpmrm-dev.c b/drivers/char/tpm/tpmrm-dev.c
new file mode 100644
index 000000000000..630bddce65a8
--- /dev/null
+++ b/drivers/char/tpm/tpmrm-dev.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 James.Bottomley@HansenPartnership.com
+ *
+ * GPLv2
+ */
+#include <linux/slab.h>
+#include "tpm-dev.h"
+
+struct tpmrm_priv {
+	struct file_priv priv;
+	struct tpm_space space;
+};
+
+static int tpmrm_open(struct inode *inode, struct file *file)
+{
+	struct tpm_chip *chip;
+	struct tpmrm_priv *priv;
+	int rc;
+
+	chip = container_of(inode->i_cdev, struct tpm_chip, cdevs);
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	rc = tpm2_init_space(&priv->space);
+	if (rc) {
+		kfree(priv);
+		return -ENOMEM;
+	}
+
+	tpm_common_open(file, chip, &priv->priv);
+
+	return 0;
+}
+
+static int tpmrm_release(struct inode *inode, struct file *file)
+{
+	struct file_priv *fpriv = file->private_data;
+	struct tpmrm_priv *priv = container_of(fpriv, struct tpmrm_priv, priv);
+
+	tpm_common_release(file, fpriv);
+	tpm2_del_space(&priv->space);
+	kfree(priv);
+
+	return 0;
+}
+
+ssize_t tpmrm_write(struct file *file, const char __user *buf,
+		   size_t size, loff_t *off)
+{
+	struct file_priv *fpriv = file->private_data;
+	struct tpmrm_priv *priv = container_of(fpriv, struct tpmrm_priv, priv);
+
+	return tpm_common_write(file, buf, size, off, &priv->space);
+}
+
+const struct file_operations tpmrm_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = tpmrm_open,
+	.read = tpm_common_read,
+	.write = tpmrm_write,
+	.release = tpmrm_release,
+};
+
