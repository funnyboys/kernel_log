commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 88b4cbee4dac..20bf5f78a362 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -108,7 +108,8 @@ static int ati_create_gatt_pages(int nr_tables)
 	int retval = 0;
 	int i;
 
-	tables = kzalloc((nr_tables + 1) * sizeof(struct ati_page_map *),GFP_KERNEL);
+	tables = kcalloc(nr_tables + 1, sizeof(struct ati_page_map *),
+			 GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
 

commit 11cdae9a5f21d88a4465fb655639578a9a6c80c5
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Aug 1 21:31:52 2017 +0530

    agp: ati: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 0b5ec7af2414..88b4cbee4dac 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -540,7 +540,7 @@ static void agp_ati_remove(struct pci_dev *pdev)
 	agp_put_bridge(bridge);
 }
 
-static struct pci_device_id agp_ati_pci_table[] = {
+static const struct pci_device_id agp_ati_pci_table[] = {
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,

commit e47036b45a3f02d35648d4683b9e26f26a60e231
Author: Laura Abbott <labbott@redhat.com>
Date:   Mon May 8 15:58:14 2017 -0700

    agp: use set_memory.h header
    
    set_memory_* functions have moved to set_memory.h.  Switch to this
    explicitly.
    
    Link: http://lkml.kernel.org/r/1488920133-27229-7-git-send-email-labbott@redhat.com
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 75a9786a77e6..0b5ec7af2414 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -10,6 +10,7 @@
 #include <linux/slab.h>
 #include <linux/agp_backend.h>
 #include <asm/agp.h>
+#include <asm/set_memory.h>
 #include "agp.h"
 
 #define ATI_GART_MMBASE_BAR	1

commit bd8136d397c72e16d61810bb71d92656acfc66e6
Author: Dave Jones <davej@redhat.com>
Date:   Fri Dec 19 11:23:50 2014 -0500

    agp: Fix up email address & attributions in AGP MODULE_AUTHOR tags
    
    - Remove soon-to-be-dead @redhat address.
    - Jeff Hartmann wrote the bulk of the original backend code, and should
      at least get a mention in the MODULE_AUTHOR for backend.o
    - Various people at Intel have done a lot more work than myself on the
      intel-* drivers, so again, mention that.
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 18a7a6baa304..75a9786a77e6 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -579,6 +579,6 @@ static void __exit agp_ati_cleanup(void)
 module_init(agp_ati_init);
 module_exit(agp_ati_cleanup);
 
-MODULE_AUTHOR("Dave Jones <davej@redhat.com>");
+MODULE_AUTHOR("Dave Jones");
 MODULE_LICENSE("GPL and additional rights");
 

commit 167b1f049008b367a9003a6a8df090af4282a6b0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 6 16:15:31 2014 -0700

    agp/ati: Use PCI_COMMAND instead of hard-coded 4
    
    We're accessing the PCI_COMMAND register here, so use the appropriate
    #define.  The bit we're writing (1 << 14) isn't defined by the PCI or PCIe
    spec, so we don't have a name for it.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index ba83c11186ce..18a7a6baa304 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -221,8 +221,8 @@ static int ati_configure(void)
 	readl(ati_generic_private.registers+ATI_GART_FEATURE_ID);	/* PCI Posting.*/
 
 	/* SIGNALED_SYSTEM_ERROR @ NB_STATUS */
-	pci_read_config_dword(agp_bridge->dev, 4, &temp);
-	pci_write_config_dword(agp_bridge->dev, 4, temp | (1<<14));
+	pci_read_config_dword(agp_bridge->dev, PCI_COMMAND, &temp);
+	pci_write_config_dword(agp_bridge->dev, PCI_COMMAND, temp | (1<<14));
 
 	/* Write out the address of the gatt table */
 	writel(agp_bridge->gatt_bus_addr, ati_generic_private.registers+ATI_GART_BASE);

commit d68c5a271727e09ce4a26ea8b85cbb852e06650f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 6 15:21:16 2014 -0700

    agp: Use pci_resource_start() to get CPU physical address for BAR
    
    amd_irongate_configure(), ati_configure(), and nvidia_configure() call
    ioremap() on an address read directly from a BAR.  But a BAR contains a
    bus address, and ioremap() expects a CPU physical address.  Use
    pci_resource_start() to obtain the physical address.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 53cb310d433e..ba83c11186ce 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -12,7 +12,7 @@
 #include <asm/agp.h>
 #include "agp.h"
 
-#define ATI_GART_MMBASE_ADDR	0x14
+#define ATI_GART_MMBASE_BAR	1
 #define ATI_RS100_APSIZE	0xac
 #define ATI_RS100_IG_AGPMODE	0xb0
 #define ATI_RS300_APSIZE	0xf8
@@ -196,12 +196,12 @@ static void ati_cleanup(void)
 
 static int ati_configure(void)
 {
+	phys_addr_t reg;
 	u32 temp;
 
 	/* Get the memory mapped registers */
-	pci_read_config_dword(agp_bridge->dev, ATI_GART_MMBASE_ADDR, &temp);
-	temp = (temp & 0xfffff000);
-	ati_generic_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);
+	reg = pci_resource_start(agp_bridge->dev, ATI_GART_MMBASE_BAR);
+	ati_generic_private.registers = (volatile u8 __iomem *) ioremap(reg, 4096);
 
 	if (!ati_generic_private.registers)
 		return -ENOMEM;

commit e501b3d87f003dfad8fcbd0f55ae17ea52495a56
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 3 18:26:58 2014 -0700

    agp: Support 64-bit APBASE
    
    Per the AGP 3.0 spec, APBASE is a standard PCI BAR and may be either 32
    bits or 64 bits wide.  Many drivers read APBASE directly, but they only
    handled 32-bit BARs.
    
    The PCI core reads APBASE at enumeration-time.  Use pci_bus_address()
    instead of reading it again in the driver.  This works correctly for both
    32-bit and 64-bit BARs.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 03c1dc1ab552..53cb310d433e 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -211,10 +211,10 @@ static int ati_configure(void)
 	else
 		pci_write_config_dword(agp_bridge->dev, ATI_RS300_IG_AGPMODE, 0x20000);
 
-	/* address to map too */
+	/* address to map to */
 	/*
-	pci_read_config_dword(agp_bridge.dev, AGP_APBASE, &temp);
-	agp_bridge.gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+	agp_bridge.gart_bus_addr = pci_bus_address(agp_bridge.dev,
+						   AGP_APERTURE_BAR);
 	printk(KERN_INFO PFX "IGP320 gart_bus_addr: %x\n", agp_bridge.gart_bus_addr);
 	*/
 	writel(0x60000, ati_generic_private.registers+ATI_GART_FEATURE_ID);
@@ -385,8 +385,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 	 * This is a bus address even on the alpha, b/c its
 	 * used to program the agp master not the cpu
 	 */
-	pci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);
-	addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+	addr = pci_bus_address(agp_bridge->dev, AGP_APERTURE_BAR);
 	agp_bridge->gart_bus_addr = addr;
 
 	/* Calculate the agp offset */

commit 433555031e5f4aeb893ea9fe9c3df9df9d566cd4
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Jun 27 20:52:36 2013 +0800

    char/agp: replace numeric with standard PM state macros
    
    Use standard PM state macros PCI_Dx instead of numeric 0/1/2..
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 0628d7b65c71..03c1dc1ab552 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -236,14 +236,14 @@ static int ati_configure(void)
 static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	pci_save_state(dev);
-	pci_set_power_state(dev, 3);
+	pci_set_power_state(dev, PCI_D3hot);
 
 	return 0;
 }
 
 static int agp_ati_resume(struct pci_dev *dev)
 {
-	pci_set_power_state(dev, 0);
+	pci_set_power_state(dev, PCI_D0);
 	pci_restore_state(dev);
 
 	return ati_configure();

commit bcd2982a0e2af8d0506271b439af4b568fc33fdc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:12:08 2012 -0800

    Drivers: char: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index ed0433576e74..0628d7b65c71 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -490,8 +490,7 @@ static struct agp_device_ids ati_agp_device_ids[] =
 	{ }, /* dummy final entry, always present */
 };
 
-static int __devinit agp_ati_probe(struct pci_dev *pdev,
-				   const struct pci_device_id *ent)
+static int agp_ati_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct agp_device_ids *devs = ati_agp_device_ids;
 	struct agp_bridge_data *bridge;

commit 39af33fc458543fd6daaf154e109eba22ab89a8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:26 2012 -0500

    char: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Mattia Dongili <malattia@linux.it>
    Cc: Kent Yoder <key@linux.vnet.ibm.com>
    Cc: Rajiv Andrade <mail@srajiv.net>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Cc: Sirrix AG <tpmdd@sirrix.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: openipmi-developer@lists.sourceforge.net
    Cc: platform-driver-x86@vger.kernel.org
    Cc: tpmdd-devel@lists.sourceforge.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index d1c4c2340713..ed0433576e74 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -533,7 +533,7 @@ static int __devinit agp_ati_probe(struct pci_dev *pdev,
 	return agp_add_bridge(bridge);
 }
 
-static void __devexit agp_ati_remove(struct pci_dev *pdev)
+static void agp_ati_remove(struct pci_dev *pdev)
 {
 	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
 

commit 0bbed20e0518f6b9d46b7fe2bd044e3398a6dc40
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:24:36 2012 -0500

    char: remove use of __devinitdata
    
    CONFIG_HOTPLUG is going away as an option so __devinitdata is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Kent Yoder <key@linux.vnet.ibm.com>
    Cc: Rajiv Andrade <mail@srajiv.net>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Cc: Sirrix AG <tpmdd@sirrix.com>
    Cc: openipmi-developer@lists.sourceforge.net
    Cc: tpmdd-devel@lists.sourceforge.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index dc30e2243494..d1c4c2340713 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -445,7 +445,7 @@ static const struct agp_bridge_driver ati_generic_bridge = {
 };
 
 
-static struct agp_device_ids ati_agp_device_ids[] __devinitdata =
+static struct agp_device_ids ati_agp_device_ids[] =
 {
 	{
 		.device_id	= PCI_DEVICE_ID_ATI_RS100,

commit 61cf059325a30995a78c5001db2ed2a8ab1d4c36
Author: Jerome Glisse <jglisse@redhat.com>
Date:   Tue Apr 20 17:43:34 2010 +0200

    agp: use scratch page on memory remove and at GATT creation V4
    
    Convert most AGP chipset to use scratch page as default entries.
    This help avoiding GPU querying 0 address and trigger computer
    fault. With KMS and memory manager we bind/unbind AGP memory
    constantly and it seems that some GPU are still doing AGP
    traffic even after GPU report being idle with the memory segment.
    
    Tested (radeon GPU KMS + Xorg + compiz + glxgears + quake3) on :
    - SIS 1039:0001 & 1039:0003
    - Intel 865 8086:2571
    
    Compile tested for other bridges
    
    V2 enable scratch page on uninorth
    V3 fix unbound check in uninorth insert memory (Michel Dänzer)
    V4 rebase on top of drm-next branch with the lastest intel AGP
       changeset (stable should use version V3 of the patch)
    
    Signed-off-by: Jerome Glisse <jglisse@redhat.com>
    Signed-off-by: Michel Dänzer <michel@daenzer.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 3b2ecbe86ebe..dc30e2243494 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -341,6 +341,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 {
 	struct aper_size_info_lvl2 *value;
 	struct ati_page_map page_dir;
+	unsigned long __iomem *cur_gatt;
 	unsigned long addr;
 	int retval;
 	u32 temp;
@@ -395,6 +396,12 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */
 	}
 
+	for (i = 0; i < value->num_entries; i++) {
+		addr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;
+		cur_gatt = GET_GATT(addr);
+		writel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));
+	}
+
 	return 0;
 }
 
@@ -415,6 +422,7 @@ static const struct agp_bridge_driver ati_generic_bridge = {
 	.aperture_sizes		= ati_generic_sizes,
 	.size_type		= LVL2_APER_SIZE,
 	.num_aperture_sizes	= 7,
+	.needs_scratch_page	= true,
 	.configure		= ati_configure,
 	.fetch_size		= ati_fetch_size,
 	.cleanup		= ati_cleanup,

commit 6a12235c7d2d75c7d94b9afcaaecd422ff845ce0
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Wed Jul 29 10:25:58 2009 +0100

    agp: kill phys_to_gart() and gart_to_phys()
    
    There seems to be no reason for these -- they're a 1:1 mapping on all
    platforms.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 59ebd60c1b60..3b2ecbe86ebe 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -302,7 +302,7 @@ static int ati_insert_memory(struct agp_memory * mem,
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		writel(agp_bridge->driver->mask_memory(agp_bridge,	
-						       phys_to_gart(page_to_phys(mem->pages[i])),
+						       page_to_phys(mem->pages[i]),
 						       mem->type),
 		       cur_gatt+GET_GATT_OFF(addr));
 	}
@@ -360,7 +360,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *) page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_gart(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);
 
 	/* Write out the size register */
 	current_size = A_SIZE_LVL2(agp_bridge->current_size);
@@ -390,7 +390,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 
 	/* Calculate the agp offset */
 	for (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
-		writel(virt_to_gart(ati_generic_private.gatt_pages[i]->real) | 1,
+		writel(virt_to_phys(ati_generic_private.gatt_pages[i]->real) | 1,
 			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
 		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */
 	}

commit 2a4ceb6d3e6a566cb4a9dc8f974177f031d27cd7
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Jul 27 10:27:29 2009 +0100

    agp: Switch mask_memory() method to take address argument again, not page
    
    In commit 07613ba2 ("agp: switch AGP to use page array instead of
    unsigned long array") we switched the mask_memory() method to take a
    'struct page *' instead of an address. This is painful, because in some
    cases it has to be an IOMMU-mapped virtual bus address (in fact,
    shouldn't it _always_ be a dma_addr_t returned from pci_map_xxx(), and
    we just happen to get lucky most of the time?)
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 33656e144cc5..59ebd60c1b60 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -302,7 +302,8 @@ static int ati_insert_memory(struct agp_memory * mem,
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		writel(agp_bridge->driver->mask_memory(agp_bridge,	
-						       mem->pages[i], mem->type),
+						       phys_to_gart(page_to_phys(mem->pages[i])),
+						       mem->type),
 		       cur_gatt+GET_GATT_OFF(addr));
 	}
 	readl(GET_GATT(agp_bridge->gart_bus_addr)); /* PCI posting */

commit a95fe463e73b8c7b2d97606ac86ce261f1270726
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 19 10:52:57 2009 +1000

    agp: add user mapping support to ATI AGP bridge.
    
    This should fix TTM/KMS on some of the original ATI IGP chipsets.
    (rs100/rs200)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 4d38baa209f5..33656e144cc5 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -269,12 +269,17 @@ static int ati_insert_memory(struct agp_memory * mem,
 	int i, j, num_entries;
 	unsigned long __iomem *cur_gatt;
 	unsigned long addr;
+	int mask_type;
 
 	num_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;
 
-	if (type != 0 || mem->type != 0)
+	mask_type = agp_generic_type_to_mask_type(mem->bridge, type);
+	if (mask_type != 0 || type != mem->type)
 		return -EINVAL;
 
+	if (mem->page_count == 0)
+		return 0;
+
 	if ((pg_start + mem->page_count) > num_entries)
 		return -EINVAL;
 
@@ -299,8 +304,8 @@ static int ati_insert_memory(struct agp_memory * mem,
 		writel(agp_bridge->driver->mask_memory(agp_bridge,	
 						       mem->pages[i], mem->type),
 		       cur_gatt+GET_GATT_OFF(addr));
-		readl(cur_gatt+GET_GATT_OFF(addr));	/* PCI Posting. */
 	}
+	readl(GET_GATT(agp_bridge->gart_bus_addr)); /* PCI posting */
 	agp_bridge->driver->tlb_flush(mem);
 	return 0;
 }
@@ -311,17 +316,22 @@ static int ati_remove_memory(struct agp_memory * mem, off_t pg_start,
 	int i;
 	unsigned long __iomem *cur_gatt;
 	unsigned long addr;
+	int mask_type;
 
-	if (type != 0 || mem->type != 0)
+	mask_type = agp_generic_type_to_mask_type(mem->bridge, type);
+	if (mask_type != 0 || type != mem->type)
 		return -EINVAL;
 
+	if (mem->page_count == 0)
+		return 0;
+
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
 		addr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		writel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));
-		readl(cur_gatt+GET_GATT_OFF(addr)); /* PCI Posting. */
 	}
 
+	readl(GET_GATT(agp_bridge->gart_bus_addr)); /* PCI posting */
 	agp_bridge->driver->tlb_flush(mem);
 	return 0;
 }

commit 07613ba2f464f59949266f4337b75b91eb610795
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 12 14:11:41 2009 +1000

    agp: switch AGP to use page array instead of unsigned long array
    
    This switches AGP to use an array of pages for tracking the
    pages allocated to the GART. This should enable GEM on PAE to work
    a lot better as we can pass highmem pages to the PAT code and it will
    do the right thing with them.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index f1537eece07f..4d38baa209f5 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -296,8 +296,9 @@ static int ati_insert_memory(struct agp_memory * mem,
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
-		writel(agp_bridge->driver->mask_memory(agp_bridge,
-			mem->memory[i], mem->type), cur_gatt+GET_GATT_OFF(addr));
+		writel(agp_bridge->driver->mask_memory(agp_bridge,	
+						       mem->pages[i], mem->type),
+		       cur_gatt+GET_GATT_OFF(addr));
 		readl(cur_gatt+GET_GATT_OFF(addr));	/* PCI Posting. */
 	}
 	agp_bridge->driver->tlb_flush(mem);

commit f4432c5caec5fa95ea7eefd00f8e6cee17e2e023
Author: Dave Jones <davej@redhat.com>
Date:   Mon Oct 20 13:31:45 2008 -0400

    Update email addresses.
    
    Update assorted email addresses and related info to point
    to a single current, valid address.
    
    additionally
    - trivial CREDITS entry updates. (Not that this file means much any more)
    - remove arjans dead redhat.com address from powernow driver
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index ae2791b926b9..f1537eece07f 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -561,6 +561,6 @@ static void __exit agp_ati_cleanup(void)
 module_init(agp_ati_init);
 module_exit(agp_ati_cleanup);
 
-MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
+MODULE_AUTHOR("Dave Jones <davej@redhat.com>");
 MODULE_LICENSE("GPL and additional rights");
 

commit 5f310b63781f6777bf4e812570560ec0f8ea42d8
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Aug 21 19:15:46 2008 +0200

    agp: enable optimized agp_alloc_pages methods
    
    The pageattr-array patch that you currently have in tip/master only
    enables it for intel-agp, not the others. The attached enables it for
    all drivers currently directly using agp_generic_alloc_page() and
    agp_generic_destroy_page() (ocal driver is amd-k7-agp).
    
    The new agp_generic_alloc_pages() interface uses the also new
    pageattr array interface API. This makes all AGP drivers that
    up to now used generic_{alloc,destroy}_page() use it.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 6ecbcafb34b1..ae2791b926b9 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -418,7 +418,9 @@ static const struct agp_bridge_driver ati_generic_bridge = {
 	.alloc_by_type		= agp_generic_alloc_by_type,
 	.free_by_type		= agp_generic_free_by_type,
 	.agp_alloc_page		= agp_generic_alloc_page,
+	.agp_alloc_pages	= agp_generic_alloc_pages,
 	.agp_destroy_page	= agp_generic_destroy_page,
+	.agp_destroy_pages	= agp_generic_destroy_pages,
 	.agp_type_to_mask_type  = agp_generic_type_to_mask_type,
 };
 

commit e3cf69511a2c5369c58f6fd6a065de152c3d4b22
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Jul 30 12:26:51 2008 -0700

    agp: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 3a4566c0d84f..6ecbcafb34b1 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -486,8 +486,8 @@ static int __devinit agp_ati_probe(struct pci_dev *pdev,
 			goto found;
 	}
 
-	printk(KERN_ERR PFX
-	     "Unsupported Ati chipset (device id: %04x)\n", pdev->device);
+	dev_err(&pdev->dev, "unsupported Ati chipset [%04x/%04x])\n",
+		pdev->vendor, pdev->device);
 	return -ENODEV;
 
 found:
@@ -500,8 +500,7 @@ static int __devinit agp_ati_probe(struct pci_dev *pdev,
 
 	bridge->driver = &ati_generic_bridge;
 
-	printk(KERN_INFO PFX "Detected Ati %s chipset\n",
-			devs[j].chipset_name);
+	dev_info(&pdev->dev, "Ati %s chipset\n", devs[j].chipset_name);
 
 	/* Fill in the mode register */
 	pci_read_config_dword(pdev,

commit c72580129209aaa509ace81c1f2ee1caa9c9774b
Author: Joe Perches <joe@perches.com>
Date:   Wed Mar 26 14:10:02 2008 -0700

    drivers/char/agp - use bool
    
    Use boolean in AGP instead of having own TRUE/FALSE
    
    --
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 07b4d8ff56e5..3a4566c0d84f 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -287,10 +287,10 @@ static int ati_insert_memory(struct agp_memory * mem,
 		j++;
 	}
 
-	if (mem->is_flushed == FALSE) {
+	if (!mem->is_flushed) {
 		/*CACHE_FLUSH(); */
 		global_cache_flush();
-		mem->is_flushed = TRUE;
+		mem->is_flushed = true;
 	}
 
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {

commit df0bcab2c66ac876d5e80864fca5cce944a44540
Author: Amit Kucheria <amit.kucheria@ubuntu.com>
Date:   Thu Jun 12 15:21:26 2008 -0700

    agp: add support for Radeon Mobility 9000 chipset
    
    Addresses https://bugs.edge.launchpad.net/ubuntu/+source/linux-source-2.6.22/+bug/178634
    
    Signed-off-by: Amit Kucheria <amit.kucheria@ubuntu.com>
    Signed-off-by: maximilian attems <max@stro.at>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 55c97f623242..07b4d8ff56e5 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -457,6 +457,10 @@ static struct agp_device_ids ati_agp_device_ids[] __devinitdata =
 		.device_id	= PCI_DEVICE_ID_ATI_RS300_200,
 		.chipset_name	= "IGP9100/M",
 	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS350_133,
+		.chipset_name	= "IGP9000/M",
+	},
 	{
 		.device_id	= PCI_DEVICE_ID_ATI_RS350_200,
 		.chipset_name	= "IGP9100/M",

commit 44a207fc66c13c82f627178f9f858b8f3e76028f
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Feb 20 10:37:08 2008 +1000

    agp: fix missing casts that produced a warning.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 9ac3bef3bb7a..55c97f623242 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -60,7 +60,7 @@ static int ati_create_page_map(struct ati_page_map *page_map)
 	if (page_map->real == NULL)
 		return -ENOMEM;
 
-	set_memory_uc(page_map->real, 1);
+	set_memory_uc((unsigned long)page_map->real, 1);
 	err = map_page_into_agp(virt_to_page(page_map->real));
 	page_map->remapped = page_map->real;
 
@@ -76,7 +76,7 @@ static int ati_create_page_map(struct ati_page_map *page_map)
 static void ati_free_page_map(struct ati_page_map *page_map)
 {
 	unmap_page_from_agp(virt_to_page(page_map->real));
-	set_memory_wb(page_map->real, 1);
+	set_memory_wb((unsigned long)page_map->real, 1);
 	free_page((unsigned long) page_map->real);
 }
 

commit fcea424d31868a78366ad5ee0cb3cc2a4cbe689b
Author: Arjan van dev Ven <arjan@linux.intel.com>
Date:   Wed Feb 6 05:16:00 2008 +0100

    fix historic ioremap() abuse in AGP
    
    Several AGP drivers right now use ioremap_nocache() on kernel ram in order
    to turn a page of regular memory uncached.
    
    There are two problems with this:
    
        1) This is a total nightmare for the ioremap() implementation to keep
           various mappings of the same page coherent.
    
        2) It's a total nightmare for the AGP code since it adds a ton of
           complexity in terms of keeping track of 2 different pointers to
           the same thing, in terms of error handling etc etc.
    
    This patch fixes this by making the AGP drivers use the new
    set_memory_XX APIs instead.
    
    Note: amd-k7-agp.c is built on Alpha too, and generic.c is built
    on ia64 as well, which do not yet have the set_memory_*() APIs,
    so for them some we have a few ugly #ifdefs - hopefully they'll
    be fixed soon.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 2d46b713c8f2..9ac3bef3bb7a 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -60,18 +60,9 @@ static int ati_create_page_map(struct ati_page_map *page_map)
 	if (page_map->real == NULL)
 		return -ENOMEM;
 
-	SetPageReserved(virt_to_page(page_map->real));
+	set_memory_uc(page_map->real, 1);
 	err = map_page_into_agp(virt_to_page(page_map->real));
-	page_map->remapped = ioremap_nocache(virt_to_gart(page_map->real),
-					    PAGE_SIZE);
-	if (page_map->remapped == NULL || err) {
-		ClearPageReserved(virt_to_page(page_map->real));
-		free_page((unsigned long) page_map->real);
-		page_map->real = NULL;
-		return -ENOMEM;
-	}
-	/*CACHE_FLUSH();*/
-	global_cache_flush();
+	page_map->remapped = page_map->real;
 
 	for (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {
 		writel(agp_bridge->scratch_page, page_map->remapped+i);
@@ -85,8 +76,7 @@ static int ati_create_page_map(struct ati_page_map *page_map)
 static void ati_free_page_map(struct ati_page_map *page_map)
 {
 	unmap_page_from_agp(virt_to_page(page_map->real));
-	iounmap(page_map->remapped);
-	ClearPageReserved(virt_to_page(page_map->real));
+	set_memory_wb(page_map->real, 1);
 	free_page((unsigned long) page_map->real);
 }
 

commit 5bdbc7dc2c07d507b41bffdadc2c8cc13b2d4326
Author: Scott Thompson <postfail at hushmail.com>
Date:   Sat Aug 25 18:14:00 2007 +1000

    agp: balance ioremap checks
    
    patchset against 2.6.23-rc3.
    corrects missing ioremap return checks and balancing on iounmap calls, integrated changes per list
    recommendations on the original set of patches..
    
    Signed-off-by: Scott Thompson <postfail <at> hushmail.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index da7513d7b4e7..2d46b713c8f2 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -213,6 +213,9 @@ static int ati_configure(void)
 	temp = (temp & 0xfffff000);
 	ati_generic_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);
 
+	if (!ati_generic_private.registers)
+		return -ENOMEM;
+
 	if (is_r200())
 		pci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);
 	else

commit 190644e180794208bc638179f4d5940fe419bf9c
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Sat Jul 21 17:39:11 2007 +0200

    Fix "use after free" / "double free" bug in ati_create_gatt_pages / ati_free_gatt_pages
    
    Hi,
    
    Coverity spotted a "use after free" bug in
    drivers/char/agp/ati-agp.c::ati_create_gatt_pages().
    
    The same one that was in
      drivers/char/agp/amd-k7-agp.c::amd_create_gatt_pages()
    
    The problem is this:
           If "entry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);"
    fails, then there's a loop in the function to free all entries
    allocated so far and break out of the allocation loop. That in itself
    is pretty sane, but then the (now freed) 'tables' is assigned to
    ati_generic_private.gatt_pages and 'retval' is set to -ENOMEM which
    causes ati_free_gatt_pages(); to be called at the end of the function.
    The problem with this is that ati_free_gatt_pages() will then loop
    'ati_generic_private.num_tables' times and try to free each entry in
    tables[] - this is bad since tables has already been freed and
    furthermore it will call kfree(tables) at the end - a double free.
    
    This patch removes the freeing loop in ati_create_gatt_pages() and
    instead relies entirely on the call to ati_free_gatt_pages() to free
    everything we allocated in case of an error. It also sets
    ati_generic_private.num_tables to the actual number of entries
    allocated instead of just using the value passed in from the caller -
    this ensures that ati_free_gatt_pages() will only attempt to free
    stuff that was actually allocated.
    
    Note: I'm in no way intimate with this code and I have no way to
    actually test this patch (besides compile test it), so while I've
    tried to be careful in reading the code and make sure the patch
    does the right thing an ACK from someone who actually knows the
    code in-depth would be very much appreciated.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 780e59e588ad..da7513d7b4e7 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -123,21 +123,16 @@ static int ati_create_gatt_pages(int nr_tables)
 
 	for (i = 0; i < nr_tables; i++) {
 		entry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);
+		tables[i] = entry;
 		if (entry == NULL) {
-			while (i > 0) {
-				kfree(tables[i-1]);
-				i--;
-			}
-			kfree(tables);
 			retval = -ENOMEM;
 			break;
 		}
-		tables[i] = entry;
 		retval = ati_create_page_map(entry);
 		if (retval != 0)
 			break;
 	}
-	ati_generic_private.num_tables = nr_tables;
+	ati_generic_private.num_tables = i;
 	ati_generic_private.gatt_pages = tables;
 
 	if (retval != 0)

commit e5524f355a0d272ba5233537a896a668db1f3008
Author: Dave Jones <davej@redhat.com>
Date:   Thu Feb 22 18:41:28 2007 -0500

    [AGPGART] Further constification.
    
    Make agp_bridge_driver->aperture_sizes and ->masks const.
    Also agp_bridge_data->driver
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 77c9ad68fba9..780e59e588ad 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -24,7 +24,7 @@
 #define ATI_GART_CACHE_ENTRY_CNTRL	0x10
 
 
-static struct aper_size_info_lvl2 ati_generic_sizes[7] =
+static const struct aper_size_info_lvl2 ati_generic_sizes[7] =
 {
 	{2048, 524288, 0x0000000c},
 	{1024, 262144, 0x0000000a},
@@ -410,7 +410,7 @@ static int ati_free_gatt_table(struct agp_bridge_data *bridge)
 	return 0;
 }
 
-static struct agp_bridge_driver ati_generic_bridge = {
+static const struct agp_bridge_driver ati_generic_bridge = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= ati_generic_sizes,
 	.size_type		= LVL2_APER_SIZE,

commit a030ce4477baa06dd9c037ccd3c8d171aac9ed44
Author: Thomas Hellstrom <thomas@tungstengraphics.com>
Date:   Tue Jan 23 10:33:43 2007 +0100

    [AGPGART] Allow drm-populated agp memory types
    
    This patch allows drm to populate an agpgart structure with pages of its own.
    It's needed for the new drm memory manager which dynamically flips pages in and out of AGP.
    
    The patch modifies the generic functions as well as the intel agp driver. The intel drm driver is
    currently the only one supporting the new memory manager.
    
    Other agp drivers may need some minor fixing up once they have a corresponding memory manager enabled drm driver.
    
    AGP memory types >= AGP_USER_TYPES are not populated by the agpgart driver, but the drm is expected
    to do that, as well as taking care of cache- and tlb flushing when needed.
    
    It's not possible to request these types from user space using agpgart ioctls.
    
    The Intel driver also gets a new memory type for pages that can be bound cached to the intel GTT.
    
    Signed-off-by: Thomas Hellstrom <thomas@tungstengraphics.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 9987dc2e0c3f..77c9ad68fba9 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -431,6 +431,7 @@ static struct agp_bridge_driver ati_generic_bridge = {
 	.free_by_type		= agp_generic_free_by_type,
 	.agp_alloc_page		= agp_generic_alloc_page,
 	.agp_destroy_page	= agp_generic_destroy_page,
+	.agp_type_to_mask_type  = agp_generic_type_to_mask_type,
 };
 
 

commit 7707ea3b784195315366e6e4b5c73ca6933ff9b0
Author: Dave Jones <davej@redhat.com>
Date:   Sun Jan 28 17:50:17 2007 -0500

    [AGPGART] Remove pointless assignment.
    
    No point in clearing local pointers then returning.
    Also fix up some CodingStyle nits.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 0994d3534447..9987dc2e0c3f 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -124,18 +124,18 @@ static int ati_create_gatt_pages(int nr_tables)
 	for (i = 0; i < nr_tables; i++) {
 		entry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);
 		if (entry == NULL) {
-			while (i>0) {
-				kfree (tables[i-1]);
+			while (i > 0) {
+				kfree(tables[i-1]);
 				i--;
 			}
-			kfree (tables);
-			tables = NULL;
+			kfree(tables);
 			retval = -ENOMEM;
 			break;
 		}
 		tables[i] = entry;
 		retval = ati_create_page_map(entry);
-		if (retval != 0) break;
+		if (retval != 0)
+			break;
 	}
 	ati_generic_private.num_tables = nr_tables;
 	ati_generic_private.gatt_pages = tables;

commit 87a17f31a3bc9bf0c7e7493add19ef200e741248
Author: Dave Jones <davej@redhat.com>
Date:   Sun Jan 28 17:41:37 2007 -0500

    [AGPGART] Remove pointless typedef in ati-agp
    
    This seems to exist just to save people typing 'struct' a few times,
    and doesn't provide any additional value.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index f244c6682738..0994d3534447 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -41,18 +41,18 @@ static struct gatt_mask ati_generic_masks[] =
 };
 
 
-typedef struct _ati_page_map {
+struct ati_page_map {
 	unsigned long *real;
 	unsigned long __iomem *remapped;
-} ati_page_map;
+};
 
 static struct _ati_generic_private {
 	volatile u8 __iomem *registers;
-	ati_page_map **gatt_pages;
+	struct ati_page_map **gatt_pages;
 	int num_tables;
 } ati_generic_private;
 
-static int ati_create_page_map(ati_page_map *page_map)
+static int ati_create_page_map(struct ati_page_map *page_map)
 {
 	int i, err = 0;
 
@@ -82,7 +82,7 @@ static int ati_create_page_map(ati_page_map *page_map)
 }
 
 
-static void ati_free_page_map(ati_page_map *page_map)
+static void ati_free_page_map(struct ati_page_map *page_map)
 {
 	unmap_page_from_agp(virt_to_page(page_map->real));
 	iounmap(page_map->remapped);
@@ -94,8 +94,8 @@ static void ati_free_page_map(ati_page_map *page_map)
 static void ati_free_gatt_pages(void)
 {
 	int i;
-	ati_page_map **tables;
-	ati_page_map *entry;
+	struct ati_page_map **tables;
+	struct ati_page_map *entry;
 
 	tables = ati_generic_private.gatt_pages;
 	for (i = 0; i < ati_generic_private.num_tables; i++) {
@@ -112,17 +112,17 @@ static void ati_free_gatt_pages(void)
 
 static int ati_create_gatt_pages(int nr_tables)
 {
-	ati_page_map **tables;
-	ati_page_map *entry;
+	struct ati_page_map **tables;
+	struct ati_page_map *entry;
 	int retval = 0;
 	int i;
 
-	tables = kzalloc((nr_tables + 1) * sizeof(ati_page_map *),GFP_KERNEL);
+	tables = kzalloc((nr_tables + 1) * sizeof(struct ati_page_map *),GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
 
 	for (i = 0; i < nr_tables; i++) {
-		entry = kzalloc(sizeof(ati_page_map), GFP_KERNEL);
+		entry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);
 		if (entry == NULL) {
 			while (i>0) {
 				kfree (tables[i-1]);
@@ -340,7 +340,7 @@ static int ati_remove_memory(struct agp_memory * mem, off_t pg_start,
 static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 {
 	struct aper_size_info_lvl2 *value;
-	ati_page_map page_dir;
+	struct ati_page_map page_dir;
 	unsigned long addr;
 	int retval;
 	u32 temp;
@@ -400,7 +400,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 
 static int ati_free_gatt_table(struct agp_bridge_data *bridge)
 {
-	ati_page_map page_dir;
+	struct ati_page_map page_dir;
 
 	page_dir.real = (unsigned long *)agp_bridge->gatt_table_real;
 	page_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;

commit 55b4d6a52195a8f277ffddf755ddaff359878f41
Merge: adf8a2871506 1f1332f727c3
Author: Dave Jones <davej@redhat.com>
Date:   Thu Jun 29 16:01:54 2006 -0400

    Merge ../linus
    
    Conflicts:
    
            drivers/char/agp/Kconfig

commit d6e05edc59ecd79e8badf440c0d295a979bdfa3e
Author: Andreas Mohr <andi@lisas.de>
Date:   Mon Jun 26 18:35:02 2006 +0200

    spelling fixes
    
    acquired (aquired)
    contiguous (contigious)
    successful (succesful, succesfull)
    surprise (suprise)
    whether (weather)
    some other misspellings
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 06fd10ba0c5e..160564345993 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -261,7 +261,7 @@ static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
 #endif
 
 /*
- *Since we don't need contigious memory we just try
+ *Since we don't need contiguous memory we just try
  * to get the gatt table once
  */
 

commit b3818ed446fc41db41b5a38d934ac2b69fd2e0aa
Author: Dave Jones <davej@redhat.com>
Date:   Wed Jun 21 13:10:26 2006 -0400

    [AGPGART] Compile fix for ati-agp
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 34bbd41f062a..d712078ed822 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -248,14 +248,14 @@ static int ati_configure(void)
 static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	pci_save_state(dev);
-	pci_set_power_state (pdev, 3);
+	pci_set_power_state(dev, 3);
 
 	return 0;
 }
 
 static int agp_ati_resume(struct pci_dev *dev)
 {
-	pci_set_power_state (pdev, 0);
+	pci_set_power_state(dev, 0);
 	pci_restore_state(dev);
 
 	return ati_configure();

commit a4aec2622340e356e7dcd0e8fd05378dacb71c89
Author: Dave Jones <davej@redhat.com>
Date:   Tue Jun 20 00:42:04 2006 -0400

    [AGPGART] Suspend/Resume improvements for ATI AGP
    
    Based on patches in the Ubuntu kernel.
    
    Signed-off-by: Ben Collins <bcollins@ubuntu.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 6db9b7f436aa..34bbd41f062a 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -245,18 +245,20 @@ static int ati_configure(void)
 
 
 #ifdef CONFIG_PM
-static int agp_ati_resume(struct pci_dev *dev)
+static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	pci_restore_state(dev);
+	pci_save_state(dev);
+	pci_set_power_state (pdev, 3);
 
-	return ati_configure();
+	return 0;
 }
 
-static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
+static int agp_ati_resume(struct pci_dev *dev)
 {
-	pci_save_state(dev);
+	pci_set_power_state (pdev, 0);
+	pci_restore_state(dev);
 
-	return 0;
+	return ati_configure();
 }
 #endif
 
@@ -545,8 +547,8 @@ static struct pci_driver agp_ati_pci_driver = {
 	.probe		= agp_ati_probe,
 	.remove		= agp_ati_remove,
 #ifdef CONFIG_PM
-	.resume		= agp_ati_resume,
 	.suspend	= agp_ati_suspend,
+	.resume		= agp_ati_resume,
 #endif
 };
 

commit 89d17b9604ae502392e119dbdbf43f6067745715
Author: Dave Jones <davej@redhat.com>
Date:   Tue Jun 20 00:39:19 2006 -0400

    [AGPGART] Whitespace cleanups for ati-agp
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 06fd10ba0c5e..6db9b7f436aa 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -41,7 +41,6 @@ static struct gatt_mask ati_generic_masks[] =
 };
 
 
-
 typedef struct _ati_page_map {
 	unsigned long *real;
 	unsigned long __iomem *remapped;
@@ -141,7 +140,8 @@ static int ati_create_gatt_pages(int nr_tables)
 	ati_generic_private.num_tables = nr_tables;
 	ati_generic_private.gatt_pages = tables;
 
-	if (retval != 0) ati_free_gatt_pages();
+	if (retval != 0)
+		ati_free_gatt_pages();
 
 	return retval;
 }
@@ -219,16 +219,16 @@ static int ati_configure(void)
 	ati_generic_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);
 
 	if (is_r200())
-       	pci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);
+		pci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);
 	else
 		pci_write_config_dword(agp_bridge->dev, ATI_RS300_IG_AGPMODE, 0x20000);
 
 	/* address to map too */
-        /*
+	/*
 	pci_read_config_dword(agp_bridge.dev, AGP_APBASE, &temp);
 	agp_bridge.gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
 	printk(KERN_INFO PFX "IGP320 gart_bus_addr: %x\n", agp_bridge.gart_bus_addr);
-        */
+	*/
 	writel(0x60000, ati_generic_private.registers+ATI_GART_FEATURE_ID);
 	readl(ati_generic_private.registers+ATI_GART_FEATURE_ID);	/* PCI Posting.*/
 
@@ -321,9 +321,9 @@ static int ati_remove_memory(struct agp_memory * mem, off_t pg_start,
 	unsigned long __iomem *cur_gatt;
 	unsigned long addr;
 
-	if (type != 0 || mem->type != 0) {
+	if (type != 0 || mem->type != 0)
 		return -EINVAL;
-	}
+
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
 		addr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
@@ -502,9 +502,8 @@ static int __devinit agp_ati_probe(struct pci_dev *pdev,
 
 	bridge->dev = pdev;
 	bridge->capndx = cap_ptr;
-	
-	bridge->driver = &ati_generic_bridge;
 
+	bridge->driver = &ati_generic_bridge;
 
 	printk(KERN_INFO PFX "Detected Ati %s chipset\n",
 			devs[j].chipset_name);

commit 9d1ef8a64e21e57109be45a7345b09cf913e4b0e
Author: Dave Jones <davej@redhat.com>
Date:   Wed Mar 1 14:23:14 2006 -0500

    [AGPGART] ATI RS350 support.
    
    From: Julien Tous <julien.tous@gmail.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 4a26a2a01c2f..06fd10ba0c5e 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -466,6 +466,10 @@ static struct agp_device_ids ati_agp_device_ids[] __devinitdata =
 		.device_id	= PCI_DEVICE_ID_ATI_RS300_200,
 		.chipset_name	= "IGP9100/M",
 	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS350_200,
+		.chipset_name	= "IGP9100/M",
+	},
 	{ }, /* dummy final entry, always present */
 };
 

commit 6a92a4e0d201aea6d7c83f100d77310676b2e049
Author: Dave Jones <davej@redhat.com>
Date:   Tue Feb 28 00:54:25 2006 -0500

    [AGPGART] Lots of CodingStyle/whitespace cleanups.
    
    Eliminate trailing whitespace.
    s/if(/if (/
    s/for(/for (/
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 5b74c36c116c..4a26a2a01c2f 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -74,7 +74,7 @@ static int ati_create_page_map(ati_page_map *page_map)
 	/*CACHE_FLUSH();*/
 	global_cache_flush();
 
-	for(i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {
+	for (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {
 		writel(agp_bridge->scratch_page, page_map->remapped+i);
 		readl(page_map->remapped+i);	/* PCI Posting. */
 	}
@@ -99,7 +99,7 @@ static void ati_free_gatt_pages(void)
 	ati_page_map *entry;
 
 	tables = ati_generic_private.gatt_pages;
-	for(i = 0; i < ati_generic_private.num_tables; i++) {
+	for (i = 0; i < ati_generic_private.num_tables; i++) {
 		entry = tables[i];
 		if (entry != NULL) {
 			if (entry->real != NULL)
@@ -387,7 +387,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 	agp_bridge->gart_bus_addr = addr;
 
 	/* Calculate the agp offset */
-	for(i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
+	for (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
 		writel(virt_to_gart(ati_generic_private.gatt_pages[i]->real) | 1,
 			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
 		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */

commit 5dda4986752b531d89d49c218682e42c63ef1d61
Author: akpm@osdl.org <akpm@osdl.org>
Date:   Tue Jan 3 23:00:59 2006 -0800

    [AGPGART] Suspend/Resume support for ATI GART
    
    Add suspend/resume support for the ati-agp module
    
    Signed-off-by: Jaco Kroon <jaco@kroon.co.za>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 53372a83b675..5b74c36c116c 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -244,6 +244,22 @@ static int ati_configure(void)
 }
 
 
+#ifdef CONFIG_PM
+static int agp_ati_resume(struct pci_dev *dev)
+{
+	pci_restore_state(dev);
+
+	return ati_configure();
+}
+
+static int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+
+	return 0;
+}
+#endif
+
 /*
  *Since we don't need contigious memory we just try
  * to get the gatt table once
@@ -525,6 +541,10 @@ static struct pci_driver agp_ati_pci_driver = {
 	.id_table	= agp_ati_pci_table,
 	.probe		= agp_ati_probe,
 	.remove		= agp_ati_remove,
+#ifdef CONFIG_PM
+	.resume		= agp_ati_resume,
+	.suspend	= agp_ati_suspend,
+#endif
 };
 
 static int __init agp_ati_init(void)

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index fbd415565463..53372a83b675 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -521,7 +521,6 @@ static struct pci_device_id agp_ati_pci_table[] = {
 MODULE_DEVICE_TABLE(pci, agp_ati_pci_table);
 
 static struct pci_driver agp_ati_pci_driver = {
-	.owner		= THIS_MODULE,
 	.name		= "agpgart-ati",
 	.id_table	= agp_ati_pci_table,
 	.probe		= agp_ati_probe,

commit 7079060f3e86ea4c1d4e9c1e356592ef9dcaaa1f
Merge: 3f00d3e8fb96 0a1cc0b6a4ab
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Nov 7 13:26:58 2005 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/davej/agpgart

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index e572ced9100a..0b6e72642d6e 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -6,6 +6,8 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
 #include <linux/agp_backend.h>
 #include <asm/agp.h>
 #include "agp.h"

commit ea248bcaadd5bafe4217357e1e511ac55639bcf3
Author: Dave Jones <davej@redhat.com>
Date:   Mon Oct 24 20:20:11 2005 -0700

    [AGPGART] Set .owner field of struct pci_driver.
    
    From: Laurent Riffard <laurent.riffard@free.fr>
    
    This updates .owner field of struct pci_driver.
    
    This allows SYSFS to create the symlink from the driver to the module which
    provides it.
    
    $ tree /sys/bus/pci/drivers/agpgart-via/
    /sys/bus/pci/drivers/agpgart-via/
    |-- 0000:00:00.0 -> ../../../../devices/pci0000:00/0000:00:00.0
    |-- bind
    |-- module -> ../../../../module/via_agp
    |-- new_id
    `-- unbind
    
    Signed-off-by: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 109582ab3704..9e9ad8cbf296 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -519,6 +519,7 @@ static struct pci_device_id agp_ati_pci_table[] = {
 MODULE_DEVICE_TABLE(pci, agp_ati_pci_table);
 
 static struct pci_driver agp_ati_pci_driver = {
+	.owner		= THIS_MODULE,
 	.name		= "agpgart-ati",
 	.id_table	= agp_ati_pci_table,
 	.probe		= agp_ati_probe,

commit 0ea27d9f2fb5b998063323bff47ab87891ced9e2
Author: Dave Jones <davej@redhat.com>
Date:   Thu Oct 20 15:12:16 2005 -0700

    [AGPGART] Replace kmalloc+memset's with kzalloc's
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index e572ced9100a..109582ab3704 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -116,14 +116,12 @@ static int ati_create_gatt_pages(int nr_tables)
 	int retval = 0;
 	int i;
 
-	tables = kmalloc((nr_tables + 1) * sizeof(ati_page_map *),
-			 GFP_KERNEL);
+	tables = kzalloc((nr_tables + 1) * sizeof(ati_page_map *),GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
 
-	memset(tables, 0, sizeof(ati_page_map *) * (nr_tables + 1));
 	for (i = 0; i < nr_tables; i++) {
-		entry = kmalloc(sizeof(ati_page_map), GFP_KERNEL);
+		entry = kzalloc(sizeof(ati_page_map), GFP_KERNEL);
 		if (entry == NULL) {
 			while (i>0) {
 				kfree (tables[i-1]);
@@ -134,7 +132,6 @@ static int ati_create_gatt_pages(int nr_tables)
 			retval = -ENOMEM;
 			break;
 		}
-		memset(entry, 0, sizeof(ati_page_map));
 		tables[i] = entry;
 		retval = ati_create_page_map(entry);
 		if (retval != 0) break;

commit 07eee78ea8ba2d0b7b20551c35a3e7dd158d50bb
Author: Keir Fraser <Keir.Fraser@cl.cam.ac.uk>
Date:   Wed Mar 30 13:17:04 2005 -0800

    [PATCH] AGP fix for Xen VMM
    
    When Linux is running on the Xen virtual machine monitor, physical
    addresses are virtualised and cannot be directly referenced by the AGP
    GART.  This patch fixes the GART driver for Xen by adding a layer of
    abstraction between physical addresses and 'GART addresses'.
    
    Architecture-specific functions are also defined for allocating and freeing
    the GATT.  Xen requires this to ensure that table really is contiguous from
    the point of view of the GART.
    
    These extra interface functions are defined as 'no-ops' for all existing
    architectures that use the GART driver.
    
    Signed-off-by: Keir Fraser <keir@xensource.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index a65f8827c283..e572ced9100a 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -61,7 +61,7 @@ static int ati_create_page_map(ati_page_map *page_map)
 
 	SetPageReserved(virt_to_page(page_map->real));
 	err = map_page_into_agp(virt_to_page(page_map->real));
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+	page_map->remapped = ioremap_nocache(virt_to_gart(page_map->real),
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL || err) {
 		ClearPageReserved(virt_to_page(page_map->real));
@@ -343,7 +343,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *) page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_bus(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_gart(page_dir.real);
 
 	/* Write out the size register */
 	current_size = A_SIZE_LVL2(agp_bridge->current_size);
@@ -373,7 +373,7 @@ static int ati_create_gatt_table(struct agp_bridge_data *bridge)
 
 	/* Calculate the agp offset */
 	for(i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
-		writel(virt_to_bus(ati_generic_private.gatt_pages[i]->real) | 1,
+		writel(virt_to_gart(ati_generic_private.gatt_pages[i]->real) | 1,
 			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
 		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */
 	}

commit 408b664a7d394a5e4315fbd14aca49b042cb2b08
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun May 1 08:59:29 2005 -0700

    [PATCH] make lots of things static
    
    Another large rollup of various patches from Adrian which make things static
    where they were needlessly exported.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 757dde006fc9..a65f8827c283 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -393,7 +393,7 @@ static int ati_free_gatt_table(struct agp_bridge_data *bridge)
 	return 0;
 }
 
-struct agp_bridge_driver ati_generic_bridge = {
+static struct agp_bridge_driver ati_generic_bridge = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= ati_generic_sizes,
 	.size_type		= LVL2_APER_SIZE,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
new file mode 100644
index 000000000000..757dde006fc9
--- /dev/null
+++ b/drivers/char/agp/ati-agp.c
@@ -0,0 +1,548 @@
+/*
+ * ATi AGPGART routines.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/agp_backend.h>
+#include <asm/agp.h>
+#include "agp.h"
+
+#define ATI_GART_MMBASE_ADDR	0x14
+#define ATI_RS100_APSIZE	0xac
+#define ATI_RS100_IG_AGPMODE	0xb0
+#define ATI_RS300_APSIZE	0xf8
+#define ATI_RS300_IG_AGPMODE	0xfc
+#define ATI_GART_FEATURE_ID		0x00
+#define ATI_GART_BASE			0x04
+#define ATI_GART_CACHE_SZBASE		0x08
+#define ATI_GART_CACHE_CNTRL		0x0c
+#define ATI_GART_CACHE_ENTRY_CNTRL	0x10
+
+
+static struct aper_size_info_lvl2 ati_generic_sizes[7] =
+{
+	{2048, 524288, 0x0000000c},
+	{1024, 262144, 0x0000000a},
+	{512, 131072, 0x00000008},
+	{256, 65536, 0x00000006},
+	{128, 32768, 0x00000004},
+	{64, 16384, 0x00000002},
+	{32, 8192, 0x00000000}
+};
+
+static struct gatt_mask ati_generic_masks[] =
+{
+	{ .mask = 1, .type = 0}
+};
+
+
+
+typedef struct _ati_page_map {
+	unsigned long *real;
+	unsigned long __iomem *remapped;
+} ati_page_map;
+
+static struct _ati_generic_private {
+	volatile u8 __iomem *registers;
+	ati_page_map **gatt_pages;
+	int num_tables;
+} ati_generic_private;
+
+static int ati_create_page_map(ati_page_map *page_map)
+{
+	int i, err = 0;
+
+	page_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);
+	if (page_map->real == NULL)
+		return -ENOMEM;
+
+	SetPageReserved(virt_to_page(page_map->real));
+	err = map_page_into_agp(virt_to_page(page_map->real));
+	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+					    PAGE_SIZE);
+	if (page_map->remapped == NULL || err) {
+		ClearPageReserved(virt_to_page(page_map->real));
+		free_page((unsigned long) page_map->real);
+		page_map->real = NULL;
+		return -ENOMEM;
+	}
+	/*CACHE_FLUSH();*/
+	global_cache_flush();
+
+	for(i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {
+		writel(agp_bridge->scratch_page, page_map->remapped+i);
+		readl(page_map->remapped+i);	/* PCI Posting. */
+	}
+
+	return 0;
+}
+
+
+static void ati_free_page_map(ati_page_map *page_map)
+{
+	unmap_page_from_agp(virt_to_page(page_map->real));
+	iounmap(page_map->remapped);
+	ClearPageReserved(virt_to_page(page_map->real));
+	free_page((unsigned long) page_map->real);
+}
+
+
+static void ati_free_gatt_pages(void)
+{
+	int i;
+	ati_page_map **tables;
+	ati_page_map *entry;
+
+	tables = ati_generic_private.gatt_pages;
+	for(i = 0; i < ati_generic_private.num_tables; i++) {
+		entry = tables[i];
+		if (entry != NULL) {
+			if (entry->real != NULL)
+				ati_free_page_map(entry);
+			kfree(entry);
+		}
+	}
+	kfree(tables);
+}
+
+
+static int ati_create_gatt_pages(int nr_tables)
+{
+	ati_page_map **tables;
+	ati_page_map *entry;
+	int retval = 0;
+	int i;
+
+	tables = kmalloc((nr_tables + 1) * sizeof(ati_page_map *),
+			 GFP_KERNEL);
+	if (tables == NULL)
+		return -ENOMEM;
+
+	memset(tables, 0, sizeof(ati_page_map *) * (nr_tables + 1));
+	for (i = 0; i < nr_tables; i++) {
+		entry = kmalloc(sizeof(ati_page_map), GFP_KERNEL);
+		if (entry == NULL) {
+			while (i>0) {
+				kfree (tables[i-1]);
+				i--;
+			}
+			kfree (tables);
+			tables = NULL;
+			retval = -ENOMEM;
+			break;
+		}
+		memset(entry, 0, sizeof(ati_page_map));
+		tables[i] = entry;
+		retval = ati_create_page_map(entry);
+		if (retval != 0) break;
+	}
+	ati_generic_private.num_tables = nr_tables;
+	ati_generic_private.gatt_pages = tables;
+
+	if (retval != 0) ati_free_gatt_pages();
+
+	return retval;
+}
+
+static int is_r200(void)
+{
+	if ((agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS100) ||
+	    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200) ||
+	    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200_B) ||
+	    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS250))
+		return 1;
+	return 0;
+}
+
+static int ati_fetch_size(void)
+{
+	int i;
+	u32 temp;
+	struct aper_size_info_lvl2 *values;
+
+	if (is_r200())
+		pci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);
+	else
+		pci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);
+
+	temp = (temp & 0x0000000e);
+	values = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);
+	for (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {
+		if (temp == values[i].size_value) {
+			agp_bridge->previous_size =
+			    agp_bridge->current_size = (void *) (values + i);
+
+			agp_bridge->aperture_size_idx = i;
+			return values[i].size;
+		}
+	}
+
+	return 0;
+}
+
+static void ati_tlbflush(struct agp_memory * mem)
+{
+	writel(1, ati_generic_private.registers+ATI_GART_CACHE_CNTRL);
+	readl(ati_generic_private.registers+ATI_GART_CACHE_CNTRL);	/* PCI Posting. */
+}
+
+static void ati_cleanup(void)
+{
+	struct aper_size_info_lvl2 *previous_size;
+	u32 temp;
+
+	previous_size = A_SIZE_LVL2(agp_bridge->previous_size);
+
+	/* Write back the previous size and disable gart translation */
+	if (is_r200()) {
+		pci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);
+		temp = ((temp & ~(0x0000000f)) | previous_size->size_value);
+		pci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);
+	} else {
+		pci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);
+		temp = ((temp & ~(0x0000000f)) | previous_size->size_value);
+		pci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);
+	}
+	iounmap((volatile u8 __iomem *)ati_generic_private.registers);
+}
+
+
+static int ati_configure(void)
+{
+	u32 temp;
+
+	/* Get the memory mapped registers */
+	pci_read_config_dword(agp_bridge->dev, ATI_GART_MMBASE_ADDR, &temp);
+	temp = (temp & 0xfffff000);
+	ati_generic_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);
+
+	if (is_r200())
+       	pci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);
+	else
+		pci_write_config_dword(agp_bridge->dev, ATI_RS300_IG_AGPMODE, 0x20000);
+
+	/* address to map too */
+        /*
+	pci_read_config_dword(agp_bridge.dev, AGP_APBASE, &temp);
+	agp_bridge.gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+	printk(KERN_INFO PFX "IGP320 gart_bus_addr: %x\n", agp_bridge.gart_bus_addr);
+        */
+	writel(0x60000, ati_generic_private.registers+ATI_GART_FEATURE_ID);
+	readl(ati_generic_private.registers+ATI_GART_FEATURE_ID);	/* PCI Posting.*/
+
+	/* SIGNALED_SYSTEM_ERROR @ NB_STATUS */
+	pci_read_config_dword(agp_bridge->dev, 4, &temp);
+	pci_write_config_dword(agp_bridge->dev, 4, temp | (1<<14));
+
+	/* Write out the address of the gatt table */
+	writel(agp_bridge->gatt_bus_addr, ati_generic_private.registers+ATI_GART_BASE);
+	readl(ati_generic_private.registers+ATI_GART_BASE);	/* PCI Posting. */
+
+	return 0;
+}
+
+
+/*
+ *Since we don't need contigious memory we just try
+ * to get the gatt table once
+ */
+
+#define GET_PAGE_DIR_OFF(addr) (addr >> 22)
+#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr) - \
+	GET_PAGE_DIR_OFF(agp_bridge->gart_bus_addr))
+#define GET_GATT_OFF(addr) ((addr & 0x003ff000) >> 12)
+#undef  GET_GATT
+#define GET_GATT(addr) (ati_generic_private.gatt_pages[\
+	GET_PAGE_DIR_IDX(addr)]->remapped)
+
+static int ati_insert_memory(struct agp_memory * mem,
+			     off_t pg_start, int type)
+{
+	int i, j, num_entries;
+	unsigned long __iomem *cur_gatt;
+	unsigned long addr;
+
+	num_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;
+
+	if (type != 0 || mem->type != 0)
+		return -EINVAL;
+
+	if ((pg_start + mem->page_count) > num_entries)
+		return -EINVAL;
+
+	j = pg_start;
+	while (j < (pg_start + mem->page_count)) {
+		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
+		cur_gatt = GET_GATT(addr);
+		if (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))
+			return -EBUSY;
+		j++;
+	}
+
+	if (mem->is_flushed == FALSE) {
+		/*CACHE_FLUSH(); */
+		global_cache_flush();
+		mem->is_flushed = TRUE;
+	}
+
+	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
+		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
+		cur_gatt = GET_GATT(addr);
+		writel(agp_bridge->driver->mask_memory(agp_bridge,
+			mem->memory[i], mem->type), cur_gatt+GET_GATT_OFF(addr));
+		readl(cur_gatt+GET_GATT_OFF(addr));	/* PCI Posting. */
+	}
+	agp_bridge->driver->tlb_flush(mem);
+	return 0;
+}
+
+static int ati_remove_memory(struct agp_memory * mem, off_t pg_start,
+			     int type)
+{
+	int i;
+	unsigned long __iomem *cur_gatt;
+	unsigned long addr;
+
+	if (type != 0 || mem->type != 0) {
+		return -EINVAL;
+	}
+	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
+		addr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;
+		cur_gatt = GET_GATT(addr);
+		writel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));
+		readl(cur_gatt+GET_GATT_OFF(addr)); /* PCI Posting. */
+	}
+
+	agp_bridge->driver->tlb_flush(mem);
+	return 0;
+}
+
+static int ati_create_gatt_table(struct agp_bridge_data *bridge)
+{
+	struct aper_size_info_lvl2 *value;
+	ati_page_map page_dir;
+	unsigned long addr;
+	int retval;
+	u32 temp;
+	int i;
+	struct aper_size_info_lvl2 *current_size;
+
+	value = A_SIZE_LVL2(agp_bridge->current_size);
+	retval = ati_create_page_map(&page_dir);
+	if (retval != 0)
+		return retval;
+
+	retval = ati_create_gatt_pages(value->num_entries / 1024);
+	if (retval != 0) {
+		ati_free_page_map(&page_dir);
+		return retval;
+	}
+
+	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
+	agp_bridge->gatt_table = (u32 __iomem *) page_dir.remapped;
+	agp_bridge->gatt_bus_addr = virt_to_bus(page_dir.real);
+
+	/* Write out the size register */
+	current_size = A_SIZE_LVL2(agp_bridge->current_size);
+
+	if (is_r200()) {
+		pci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);
+		temp = (((temp & ~(0x0000000e)) | current_size->size_value)
+			| 0x00000001);
+		pci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);
+		pci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);
+	} else {
+		pci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);
+		temp = (((temp & ~(0x0000000e)) | current_size->size_value)
+			| 0x00000001);
+		pci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);
+		pci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);
+	}
+
+	/*
+	 * Get the address for the gart region.
+	 * This is a bus address even on the alpha, b/c its
+	 * used to program the agp master not the cpu
+	 */
+	pci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);
+	addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+	agp_bridge->gart_bus_addr = addr;
+
+	/* Calculate the agp offset */
+	for(i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
+		writel(virt_to_bus(ati_generic_private.gatt_pages[i]->real) | 1,
+			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
+		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */
+	}
+
+	return 0;
+}
+
+static int ati_free_gatt_table(struct agp_bridge_data *bridge)
+{
+	ati_page_map page_dir;
+
+	page_dir.real = (unsigned long *)agp_bridge->gatt_table_real;
+	page_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;
+
+	ati_free_gatt_pages();
+	ati_free_page_map(&page_dir);
+	return 0;
+}
+
+struct agp_bridge_driver ati_generic_bridge = {
+	.owner			= THIS_MODULE,
+	.aperture_sizes		= ati_generic_sizes,
+	.size_type		= LVL2_APER_SIZE,
+	.num_aperture_sizes	= 7,
+	.configure		= ati_configure,
+	.fetch_size		= ati_fetch_size,
+	.cleanup		= ati_cleanup,
+	.tlb_flush		= ati_tlbflush,
+	.mask_memory		= agp_generic_mask_memory,
+	.masks			= ati_generic_masks,
+	.agp_enable		= agp_generic_enable,
+	.cache_flush		= global_cache_flush,
+	.create_gatt_table	= ati_create_gatt_table,
+	.free_gatt_table	= ati_free_gatt_table,
+	.insert_memory		= ati_insert_memory,
+	.remove_memory		= ati_remove_memory,
+	.alloc_by_type		= agp_generic_alloc_by_type,
+	.free_by_type		= agp_generic_free_by_type,
+	.agp_alloc_page		= agp_generic_alloc_page,
+	.agp_destroy_page	= agp_generic_destroy_page,
+};
+
+
+static struct agp_device_ids ati_agp_device_ids[] __devinitdata =
+{
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS100,
+		.chipset_name	= "IGP320/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS200,
+		.chipset_name	= "IGP330/340/345/350/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS200_B,
+		.chipset_name	= "IGP345M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS250,
+		.chipset_name	= "IGP7000/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS300_100,
+		.chipset_name	= "IGP9100/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS300_133,
+		.chipset_name	= "IGP9100/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS300_166,
+		.chipset_name	= "IGP9100/M",
+	},
+	{
+		.device_id	= PCI_DEVICE_ID_ATI_RS300_200,
+		.chipset_name	= "IGP9100/M",
+	},
+	{ }, /* dummy final entry, always present */
+};
+
+static int __devinit agp_ati_probe(struct pci_dev *pdev,
+				   const struct pci_device_id *ent)
+{
+	struct agp_device_ids *devs = ati_agp_device_ids;
+	struct agp_bridge_data *bridge;
+	u8 cap_ptr;
+	int j;
+
+	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
+	if (!cap_ptr)
+		return -ENODEV;
+
+	/* probe for known chipsets */
+	for (j = 0; devs[j].chipset_name; j++) {
+		if (pdev->device == devs[j].device_id)
+			goto found;
+	}
+
+	printk(KERN_ERR PFX
+	     "Unsupported Ati chipset (device id: %04x)\n", pdev->device);
+	return -ENODEV;
+
+found:
+	bridge = agp_alloc_bridge();
+	if (!bridge)
+		return -ENOMEM;
+
+	bridge->dev = pdev;
+	bridge->capndx = cap_ptr;
+	
+	bridge->driver = &ati_generic_bridge;
+
+
+	printk(KERN_INFO PFX "Detected Ati %s chipset\n",
+			devs[j].chipset_name);
+
+	/* Fill in the mode register */
+	pci_read_config_dword(pdev,
+			bridge->capndx+PCI_AGP_STATUS,
+			&bridge->mode);
+
+	pci_set_drvdata(pdev, bridge);
+	return agp_add_bridge(bridge);
+}
+
+static void __devexit agp_ati_remove(struct pci_dev *pdev)
+{
+	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
+
+	agp_remove_bridge(bridge);
+	agp_put_bridge(bridge);
+}
+
+static struct pci_device_id agp_ati_pci_table[] = {
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_ATI,
+	.device		= PCI_ANY_ID,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(pci, agp_ati_pci_table);
+
+static struct pci_driver agp_ati_pci_driver = {
+	.name		= "agpgart-ati",
+	.id_table	= agp_ati_pci_table,
+	.probe		= agp_ati_probe,
+	.remove		= agp_ati_remove,
+};
+
+static int __init agp_ati_init(void)
+{
+	if (agp_off)
+		return -EINVAL;
+	return pci_register_driver(&agp_ati_pci_driver);
+}
+
+static void __exit agp_ati_cleanup(void)
+{
+	pci_unregister_driver(&agp_ati_pci_driver);
+}
+
+module_init(agp_ati_init);
+module_exit(agp_ati_cleanup);
+
+MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
+MODULE_LICENSE("GPL and additional rights");
+
