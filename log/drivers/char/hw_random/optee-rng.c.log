commit 1c8414dadb8c5668ee4d20d7dfbb478db52d1ab0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 22 15:58:08 2020 +0300

    hwrng: optee - Use UUID API for exporting the UUID
    
    There is export_uuid() function which exports uuid_t to the u8 array.
    Use it instead of open coding variant.
    
    This allows to hide the uuid_t internals.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/optee-rng.c b/drivers/char/hw_random/optee-rng.c
index ddfbabaa5f8f..49b2e02537dd 100644
--- a/drivers/char/hw_random/optee-rng.c
+++ b/drivers/char/hw_random/optee-rng.c
@@ -226,7 +226,7 @@ static int optee_rng_probe(struct device *dev)
 		return -ENODEV;
 
 	/* Open session with hwrng Trusted App */
-	memcpy(sess_arg.uuid, rng_device->id.uuid.b, TEE_IOCTL_UUID_LEN);
+	export_uuid(sess_arg.uuid, &rng_device->id.uuid);
 	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
 	sess_arg.num_params = 0;
 

commit 4f640201a8aebcee053712828f5457aee9909cc8
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Feb 20 09:34:58 2019 +0000

    hwrng: make symbol 'optee_rng_id_table' static
    
    Fixes the following sparse warning:
    
    drivers/char/hw_random/optee-rng.c:265:35: warning:
     symbol 'optee_rng_id_table' was not declared. Should it be static?
    
    Fixes: 5fe8b1cc6a03 ("hwrng: add OP-TEE based rng driver")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/char/hw_random/optee-rng.c b/drivers/char/hw_random/optee-rng.c
index d3581ce85cb3..ddfbabaa5f8f 100644
--- a/drivers/char/hw_random/optee-rng.c
+++ b/drivers/char/hw_random/optee-rng.c
@@ -270,7 +270,7 @@ static int optee_rng_remove(struct device *dev)
 	return 0;
 }
 
-const struct tee_client_device_id optee_rng_id_table[] = {
+static const struct tee_client_device_id optee_rng_id_table[] = {
 	{UUID_INIT(0xab7a617c, 0xb8e7, 0x4d8f,
 		   0x83, 0x01, 0xd0, 0x9b, 0x61, 0x03, 0x6b, 0x64)},
 	{}

commit 8deed847445a8fb619689988a24c0f8df1369a58
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Feb 19 14:33:02 2019 +0800

    hwrng: Fix unsigned comparison with less than zero
    
    The return from the call to tee_client_invoke_func can be a
    negative error code however this is being assigned to an
    unsigned variable 'ret' hence the check is always false.
    Fix this by making 'ret' an int.
    
    Detected by Coccinelle ("Unsigned expression compared with zero:
    ret < 0")
    
    Fixes: 5fe8b1cc6a03 ("hwrng: add OP-TEE based rng driver")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/char/hw_random/optee-rng.c b/drivers/char/hw_random/optee-rng.c
index 46f4bcd28c41..d3581ce85cb3 100644
--- a/drivers/char/hw_random/optee-rng.c
+++ b/drivers/char/hw_random/optee-rng.c
@@ -73,7 +73,7 @@ struct optee_rng_private {
 static size_t get_optee_rng_data(struct optee_rng_private *pvt_data,
 				 void *buf, size_t req_size)
 {
-	u32 ret = 0;
+	int ret = 0;
 	u8 *rng_data = NULL;
 	size_t rng_size = 0;
 	struct tee_ioctl_invoke_arg inv_arg;
@@ -175,7 +175,7 @@ static struct optee_rng_private pvt_data = {
 
 static int get_optee_rng_info(struct device *dev)
 {
-	u32 ret = 0;
+	int ret = 0;
 	struct tee_ioctl_invoke_arg inv_arg;
 	struct tee_param param[4];
 

commit 56410c0cb43e26a94af094aceab45a5ea38a1a38
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Mon Feb 18 20:22:40 2019 -0700

    hwrng: optee: Initialize some structs using memset instead of braces
    
    Clang warns:
    
    drivers/char/hw_random/optee-rng.c:80:31: warning: suggest braces around
    initialization of subobject [-Wmissing-braces]
            struct tee_param param[4] = {0};
                                         ^
                                         {}
    drivers/char/hw_random/optee-rng.c:177:31: warning: suggest braces
    around initialization of subobject [-Wmissing-braces]
            struct tee_param param[4] = {0};
                                         ^
                                         {}
    drivers/char/hw_random/optee-rng.c:212:48: warning: suggest braces
    around initialization of subobject [-Wmissing-braces]
            struct tee_ioctl_open_session_arg sess_arg = {0};
                                                          ^
                                                          {}
    3 warnings generated.
    
    One way to fix these warnings is to add additional braces like Clang
    suggests; however, there has been a bit of push back from some
    maintainers, who just prefer memset as it is unambiguous, doesn't
    depend on a particular compiler version, and properly initializes all
    subobjects [1][2]. Do that here so there are no more warnings.
    
    [1]: https://lore.kernel.org/lkml/022e41c0-8465-dc7a-a45c-64187ecd9684@amd.com/
    [2]: https://lore.kernel.org/lkml/20181128.215241.702406654469517539.davem@davemloft.net/
    
    Fixes: 5fe8b1cc6a03 ("hwrng: add OP-TEE based rng driver")
    Link: https://github.com/ClangBuiltLinux/linux/issues/369
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/char/hw_random/optee-rng.c b/drivers/char/hw_random/optee-rng.c
index 2b9fc8ac5500..46f4bcd28c41 100644
--- a/drivers/char/hw_random/optee-rng.c
+++ b/drivers/char/hw_random/optee-rng.c
@@ -76,8 +76,11 @@ static size_t get_optee_rng_data(struct optee_rng_private *pvt_data,
 	u32 ret = 0;
 	u8 *rng_data = NULL;
 	size_t rng_size = 0;
-	struct tee_ioctl_invoke_arg inv_arg = {0};
-	struct tee_param param[4] = {0};
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
 
 	/* Invoke TA_CMD_GET_ENTROPY function of Trusted App */
 	inv_arg.func = TA_CMD_GET_ENTROPY;
@@ -173,8 +176,11 @@ static struct optee_rng_private pvt_data = {
 static int get_optee_rng_info(struct device *dev)
 {
 	u32 ret = 0;
-	struct tee_ioctl_invoke_arg inv_arg = {0};
-	struct tee_param param[4] = {0};
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
 
 	/* Invoke TA_CMD_GET_RNG_INFO function of Trusted App */
 	inv_arg.func = TA_CMD_GET_RNG_INFO;
@@ -209,7 +215,9 @@ static int optee_rng_probe(struct device *dev)
 {
 	struct tee_client_device *rng_device = to_tee_client_device(dev);
 	int ret = 0, err = -ENODEV;
-	struct tee_ioctl_open_session_arg sess_arg = {0};
+	struct tee_ioctl_open_session_arg sess_arg;
+
+	memset(&sess_arg, 0, sizeof(sess_arg));
 
 	/* Open context with TEE driver */
 	pvt_data.ctx = tee_client_open_context(NULL, optee_ctx_match, NULL,

commit 5fe8b1cc6a03c46b3061e808256d39dcebd0d0f0
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Tue Jan 29 11:19:38 2019 +0530

    hwrng: add OP-TEE based rng driver
    
    On ARM SoC's with TrustZone enabled, peripherals like entropy sources
    might not be accessible to normal world (linux in this case) and rather
    accessible to secure world (OP-TEE in this case) only. So this driver
    aims to provides a generic interface to OP-TEE based random number
    generator service.
    
    This driver registers on TEE bus to interact with OP-TEE based rng
    device/service.
    
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/drivers/char/hw_random/optee-rng.c b/drivers/char/hw_random/optee-rng.c
new file mode 100644
index 000000000000..2b9fc8ac5500
--- /dev/null
+++ b/drivers/char/hw_random/optee-rng.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2019 Linaro Ltd.
+ */
+
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/hw_random.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/uuid.h>
+
+#define DRIVER_NAME "optee-rng"
+
+#define TEE_ERROR_HEALTH_TEST_FAIL	0x00000001
+
+/*
+ * TA_CMD_GET_ENTROPY - Get Entropy from RNG
+ *
+ * param[0] (inout memref) - Entropy buffer memory reference
+ * param[1] unused
+ * param[2] unused
+ * param[3] unused
+ *
+ * Result:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_NOT_SUPPORTED - Requested entropy size greater than size of pool
+ * TEE_ERROR_HEALTH_TEST_FAIL - Continuous health testing failed
+ */
+#define TA_CMD_GET_ENTROPY		0x0
+
+/*
+ * TA_CMD_GET_RNG_INFO - Get RNG information
+ *
+ * param[0] (out value) - value.a: RNG data-rate in bytes per second
+ *                        value.b: Quality/Entropy per 1024 bit of data
+ * param[1] unused
+ * param[2] unused
+ * param[3] unused
+ *
+ * Result:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ */
+#define TA_CMD_GET_RNG_INFO		0x1
+
+#define MAX_ENTROPY_REQ_SZ		(4 * 1024)
+
+/**
+ * struct optee_rng_private - OP-TEE Random Number Generator private data
+ * @dev:		OP-TEE based RNG device.
+ * @ctx:		OP-TEE context handler.
+ * @session_id:		RNG TA session identifier.
+ * @data_rate:		RNG data rate.
+ * @entropy_shm_pool:	Memory pool shared with RNG device.
+ * @optee_rng:		OP-TEE RNG driver structure.
+ */
+struct optee_rng_private {
+	struct device *dev;
+	struct tee_context *ctx;
+	u32 session_id;
+	u32 data_rate;
+	struct tee_shm *entropy_shm_pool;
+	struct hwrng optee_rng;
+};
+
+#define to_optee_rng_private(r) \
+		container_of(r, struct optee_rng_private, optee_rng)
+
+static size_t get_optee_rng_data(struct optee_rng_private *pvt_data,
+				 void *buf, size_t req_size)
+{
+	u32 ret = 0;
+	u8 *rng_data = NULL;
+	size_t rng_size = 0;
+	struct tee_ioctl_invoke_arg inv_arg = {0};
+	struct tee_param param[4] = {0};
+
+	/* Invoke TA_CMD_GET_ENTROPY function of Trusted App */
+	inv_arg.func = TA_CMD_GET_ENTROPY;
+	inv_arg.session = pvt_data->session_id;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	param[0].u.memref.shm = pvt_data->entropy_shm_pool;
+	param[0].u.memref.size = req_size;
+	param[0].u.memref.shm_offs = 0;
+
+	ret = tee_client_invoke_func(pvt_data->ctx, &inv_arg, param);
+	if ((ret < 0) || (inv_arg.ret != 0)) {
+		dev_err(pvt_data->dev, "TA_CMD_GET_ENTROPY invoke err: %x\n",
+			inv_arg.ret);
+		return 0;
+	}
+
+	rng_data = tee_shm_get_va(pvt_data->entropy_shm_pool, 0);
+	if (IS_ERR(rng_data)) {
+		dev_err(pvt_data->dev, "tee_shm_get_va failed\n");
+		return 0;
+	}
+
+	rng_size = param[0].u.memref.size;
+	memcpy(buf, rng_data, rng_size);
+
+	return rng_size;
+}
+
+static int optee_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)
+{
+	struct optee_rng_private *pvt_data = to_optee_rng_private(rng);
+	size_t read = 0, rng_size = 0;
+	int timeout = 1;
+	u8 *data = buf;
+
+	if (max > MAX_ENTROPY_REQ_SZ)
+		max = MAX_ENTROPY_REQ_SZ;
+
+	while (read == 0) {
+		rng_size = get_optee_rng_data(pvt_data, data, (max - read));
+
+		data += rng_size;
+		read += rng_size;
+
+		if (wait) {
+			if (timeout-- == 0)
+				return read;
+			msleep((1000 * (max - read)) / pvt_data->data_rate);
+		} else {
+			return read;
+		}
+	}
+
+	return read;
+}
+
+static int optee_rng_init(struct hwrng *rng)
+{
+	struct optee_rng_private *pvt_data = to_optee_rng_private(rng);
+	struct tee_shm *entropy_shm_pool = NULL;
+
+	entropy_shm_pool = tee_shm_alloc(pvt_data->ctx, MAX_ENTROPY_REQ_SZ,
+					 TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
+	if (IS_ERR(entropy_shm_pool)) {
+		dev_err(pvt_data->dev, "tee_shm_alloc failed\n");
+		return PTR_ERR(entropy_shm_pool);
+	}
+
+	pvt_data->entropy_shm_pool = entropy_shm_pool;
+
+	return 0;
+}
+
+static void optee_rng_cleanup(struct hwrng *rng)
+{
+	struct optee_rng_private *pvt_data = to_optee_rng_private(rng);
+
+	tee_shm_free(pvt_data->entropy_shm_pool);
+}
+
+static struct optee_rng_private pvt_data = {
+	.optee_rng = {
+		.name		= DRIVER_NAME,
+		.init		= optee_rng_init,
+		.cleanup	= optee_rng_cleanup,
+		.read		= optee_rng_read,
+	}
+};
+
+static int get_optee_rng_info(struct device *dev)
+{
+	u32 ret = 0;
+	struct tee_ioctl_invoke_arg inv_arg = {0};
+	struct tee_param param[4] = {0};
+
+	/* Invoke TA_CMD_GET_RNG_INFO function of Trusted App */
+	inv_arg.func = TA_CMD_GET_RNG_INFO;
+	inv_arg.session = pvt_data.session_id;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	ret = tee_client_invoke_func(pvt_data.ctx, &inv_arg, param);
+	if ((ret < 0) || (inv_arg.ret != 0)) {
+		dev_err(dev, "TA_CMD_GET_RNG_INFO invoke err: %x\n",
+			inv_arg.ret);
+		return -EINVAL;
+	}
+
+	pvt_data.data_rate = param[0].u.value.a;
+	pvt_data.optee_rng.quality = param[0].u.value.b;
+
+	return 0;
+}
+
+static int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)
+{
+	if (ver->impl_id == TEE_IMPL_ID_OPTEE)
+		return 1;
+	else
+		return 0;
+}
+
+static int optee_rng_probe(struct device *dev)
+{
+	struct tee_client_device *rng_device = to_tee_client_device(dev);
+	int ret = 0, err = -ENODEV;
+	struct tee_ioctl_open_session_arg sess_arg = {0};
+
+	/* Open context with TEE driver */
+	pvt_data.ctx = tee_client_open_context(NULL, optee_ctx_match, NULL,
+					       NULL);
+	if (IS_ERR(pvt_data.ctx))
+		return -ENODEV;
+
+	/* Open session with hwrng Trusted App */
+	memcpy(sess_arg.uuid, rng_device->id.uuid.b, TEE_IOCTL_UUID_LEN);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+	sess_arg.num_params = 0;
+
+	ret = tee_client_open_session(pvt_data.ctx, &sess_arg, NULL);
+	if ((ret < 0) || (sess_arg.ret != 0)) {
+		dev_err(dev, "tee_client_open_session failed, err: %x\n",
+			sess_arg.ret);
+		err = -EINVAL;
+		goto out_ctx;
+	}
+	pvt_data.session_id = sess_arg.session;
+
+	err = get_optee_rng_info(dev);
+	if (err)
+		goto out_sess;
+
+	err = hwrng_register(&pvt_data.optee_rng);
+	if (err) {
+		dev_err(dev, "hwrng registration failed (%d)\n", err);
+		goto out_sess;
+	}
+
+	pvt_data.dev = dev;
+
+	return 0;
+
+out_sess:
+	tee_client_close_session(pvt_data.ctx, pvt_data.session_id);
+out_ctx:
+	tee_client_close_context(pvt_data.ctx);
+
+	return err;
+}
+
+static int optee_rng_remove(struct device *dev)
+{
+	hwrng_unregister(&pvt_data.optee_rng);
+	tee_client_close_session(pvt_data.ctx, pvt_data.session_id);
+	tee_client_close_context(pvt_data.ctx);
+
+	return 0;
+}
+
+const struct tee_client_device_id optee_rng_id_table[] = {
+	{UUID_INIT(0xab7a617c, 0xb8e7, 0x4d8f,
+		   0x83, 0x01, 0xd0, 0x9b, 0x61, 0x03, 0x6b, 0x64)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(tee, optee_rng_id_table);
+
+static struct tee_client_driver optee_rng_driver = {
+	.id_table	= optee_rng_id_table,
+	.driver		= {
+		.name		= DRIVER_NAME,
+		.bus		= &tee_bus_type,
+		.probe		= optee_rng_probe,
+		.remove		= optee_rng_remove,
+	},
+};
+
+static int __init optee_rng_mod_init(void)
+{
+	return driver_register(&optee_rng_driver.driver);
+}
+
+static void __exit optee_rng_mod_exit(void)
+{
+	driver_unregister(&optee_rng_driver.driver);
+}
+
+module_init(optee_rng_mod_init);
+module_exit(optee_rng_mod_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sumit Garg <sumit.garg@linaro.org>");
+MODULE_DESCRIPTION("OP-TEE based random number generator driver");
