commit 0f95b09a5f624964d520c8f6a2674090fb98ae25
Author: Stefan Wahren <wahrenst@gmx.net>
Date:   Tue Nov 19 19:16:20 2019 -0800

    hwrng: iproc-rng200 - Add support for BCM2711
    
    BCM2711 features a RNG200 hardware random number generator block.
    So make the driver available.
    
    Signed-off-by: Stefan Wahren <wahrenst@gmx.net>
    Signed-off-by: Stephen Brennan <stephen@brennan.io>
    Reviewed-by: Matthias Brugger <mbrugger@suse.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 899ff25f4f28..32d9fe61a225 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -213,6 +213,7 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id iproc_rng200_of_match[] = {
+	{ .compatible = "brcm,bcm2711-rng200", },
 	{ .compatible = "brcm,bcm7211-rng200", },
 	{ .compatible = "brcm,bcm7278-rng200", },
 	{ .compatible = "brcm,iproc-rng200", },

commit a68b931932c5574aa5bd459529c766ba577c72b3
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Sep 18 09:09:22 2019 +0200

    hwrng: iproc-rng200 - Use devm_platform_ioremap_resource() in iproc_rng200_probe()
    
    Simplify this function implementation by using a known wrapper function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Reviewed-by: Ray Jui <ray.jui@broadcom.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 92be1c0ab99f..899ff25f4f28 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -181,7 +181,6 @@ static void iproc_rng200_cleanup(struct hwrng *rng)
 static int iproc_rng200_probe(struct platform_device *pdev)
 {
 	struct iproc_rng200_dev *priv;
-	struct resource *res;
 	struct device *dev = &pdev->dev;
 	int ret;
 
@@ -190,13 +189,7 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	/* Map peripheral */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(dev, "failed to get rng resources\n");
-		return -EINVAL;
-	}
-
-	priv->base = devm_ioremap_resource(dev, res);
+	priv->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->base)) {
 		dev_err(dev, "failed to remap rng regs\n");
 		return PTR_ERR(priv->base);

commit 1fa6d053b2a53b1979fc12000be41646be379503
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri May 10 10:31:11 2019 -0700

    hwrng: iproc-rng200 - Add support for 7211
    
    BCM7211 features a RNG200 hardware random number generator block, add
    support for this chip by matching the chip-specific compatible string.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 8b5a20b35293..92be1c0ab99f 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -220,6 +220,7 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id iproc_rng200_of_match[] = {
+	{ .compatible = "brcm,bcm7211-rng200", },
 	{ .compatible = "brcm,bcm7278-rng200", },
 	{ .compatible = "brcm,iproc-rng200", },
 	{},

commit c3577f6100ca43261cd1d00cd46fde014c5b51ad
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Nov 1 16:20:06 2017 -0700

    hwrng: iproc-rng200 - Add support for BCM7278
    
    BCM7278 features a RNG200 hardware random number generator block, add
    support for this chip by matching the chip-specific compatible string
    and extending the Kconfig dependencies to allow building on ARCH_BRCMSTB
    (base platform for 7278).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 3eaf7cb96d36..8b5a20b35293 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -220,6 +220,7 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id iproc_rng200_of_match[] = {
+	{ .compatible = "brcm,bcm7278-rng200", },
 	{ .compatible = "brcm,iproc-rng200", },
 	{},
 };

commit 73b3862127e71d8cc7677b07ccc5adff0c0179bd
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Mar 12 14:00:07 2015 -0700

    hwrng: iproc-rng200 - make use of devm_hwrng_register
    
    This allows us to get rid of driver's remove() method.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 2dbaf5c52f35..3eaf7cb96d36 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -208,29 +208,17 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 	priv->rng.cleanup = iproc_rng200_cleanup,
 
 	/* Register driver */
-	ret = hwrng_register(&priv->rng);
+	ret = devm_hwrng_register(dev, &priv->rng);
 	if (ret) {
 		dev_err(dev, "hwrng registration failed\n");
 		return ret;
 	}
 
-	platform_set_drvdata(pdev, priv);
-
 	dev_info(dev, "hwrng registered\n");
 
 	return 0;
 }
 
-static int iproc_rng200_remove(struct platform_device *pdev)
-{
-	struct iproc_rng200_dev *priv = platform_get_drvdata(pdev);
-
-	/* Unregister driver */
-	hwrng_unregister(&priv->rng);
-
-	return 0;
-}
-
 static const struct of_device_id iproc_rng200_of_match[] = {
 	{ .compatible = "brcm,iproc-rng200", },
 	{},
@@ -243,7 +231,6 @@ static struct platform_driver iproc_rng200_driver = {
 		.of_match_table = iproc_rng200_of_match,
 	},
 	.probe		= iproc_rng200_probe,
-	.remove		= iproc_rng200_remove,
 };
 module_platform_driver(iproc_rng200_driver);
 

commit ef0a1b26499f61b2453dd0c454aedee687edf31c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Mar 12 14:00:06 2015 -0700

    hwrng: iproc-rng200 - do not use static structure
    
    Instead of using static hwrng structure that is reused between
    binds/unbinds of the device let's embed it into driver's private
    structure that we allocate. This way we are guaranteed not to stumble
    onto something left from previous bind attempt.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
index 276cb8a93bac..2dbaf5c52f35 100644
--- a/drivers/char/hw_random/iproc-rng200.c
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -48,9 +48,12 @@
 #define RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK		0x000000FF
 
 struct iproc_rng200_dev {
-	void __iomem			*base;
+	struct hwrng rng;
+	void __iomem *base;
 };
 
+#define to_rng_priv(rng)	container_of(rng, struct iproc_rng200_dev, rng)
+
 static void iproc_rng200_restart(void __iomem *rng_base)
 {
 	uint32_t val;
@@ -89,11 +92,11 @@ static void iproc_rng200_restart(void __iomem *rng_base)
 }
 
 static int iproc_rng200_read(struct hwrng *rng, void *buf, size_t max,
-			       bool wait)
+			     bool wait)
 {
-	uint32_t status;
+	struct iproc_rng200_dev *priv = to_rng_priv(rng);
 	uint32_t num_remaining = max;
-	struct iproc_rng200_dev *priv = (struct iproc_rng200_dev *)rng->priv;
+	uint32_t status;
 
 	#define MAX_RESETS_PER_READ	1
 	uint32_t num_resets = 0;
@@ -151,10 +154,8 @@ static int iproc_rng200_read(struct hwrng *rng, void *buf, size_t max,
 
 static int iproc_rng200_init(struct hwrng *rng)
 {
+	struct iproc_rng200_dev *priv = to_rng_priv(rng);
 	uint32_t val;
-	struct iproc_rng200_dev *priv;
-
-	priv = (struct iproc_rng200_dev *)rng->priv;
 
 	/* Setup RNG. */
 	val = ioread32(priv->base + RNG_CTRL_OFFSET);
@@ -167,10 +168,8 @@ static int iproc_rng200_init(struct hwrng *rng)
 
 static void iproc_rng200_cleanup(struct hwrng *rng)
 {
+	struct iproc_rng200_dev *priv = to_rng_priv(rng);
 	uint32_t val;
-	struct iproc_rng200_dev *priv;
-
-	priv = (struct iproc_rng200_dev *)rng->priv;
 
 	/* Disable RNG hardware */
 	val = ioread32(priv->base + RNG_CTRL_OFFSET);
@@ -179,13 +178,6 @@ static void iproc_rng200_cleanup(struct hwrng *rng)
 	iowrite32(val, priv->base + RNG_CTRL_OFFSET);
 }
 
-static struct hwrng iproc_rng200_ops = {
-	.name		= "iproc-rng200",
-	.read		= iproc_rng200_read,
-	.init		= iproc_rng200_init,
-	.cleanup	= iproc_rng200_cleanup,
-};
-
 static int iproc_rng200_probe(struct platform_device *pdev)
 {
 	struct iproc_rng200_dev *priv;
@@ -193,13 +185,10 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	int ret;
 
-	priv = devm_kzalloc(dev, sizeof(struct iproc_rng200_dev), GFP_KERNEL);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	iproc_rng200_ops.priv = (unsigned long)priv;
-	platform_set_drvdata(pdev, priv);
-
 	/* Map peripheral */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -213,13 +202,20 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->base);
 	}
 
+	priv->rng.name = "iproc-rng200",
+	priv->rng.read = iproc_rng200_read,
+	priv->rng.init = iproc_rng200_init,
+	priv->rng.cleanup = iproc_rng200_cleanup,
+
 	/* Register driver */
-	ret = hwrng_register(&iproc_rng200_ops);
+	ret = hwrng_register(&priv->rng);
 	if (ret) {
 		dev_err(dev, "hwrng registration failed\n");
 		return ret;
 	}
 
+	platform_set_drvdata(pdev, priv);
+
 	dev_info(dev, "hwrng registered\n");
 
 	return 0;
@@ -227,8 +223,10 @@ static int iproc_rng200_probe(struct platform_device *pdev)
 
 static int iproc_rng200_remove(struct platform_device *pdev)
 {
+	struct iproc_rng200_dev *priv = platform_get_drvdata(pdev);
+
 	/* Unregister driver */
-	hwrng_unregister(&iproc_rng200_ops);
+	hwrng_unregister(&priv->rng);
 
 	return 0;
 }

commit c83d45d5685f63e02f4b038e20450a28232d4da2
Author: Scott Branden <sbranden@broadcom.com>
Date:   Wed Mar 4 12:42:14 2015 -0800

    hwrng: iproc-rng200 - Add Broadcom IPROC RNG driver
    
    This adds a driver for random number generator present on Broadcom
    IPROC devices.
    
    Reviewed-by: Ray Jui <rjui@broadcom.com>
    Signed-off-by: Scott Branden <sbranden@broadcom.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/iproc-rng200.c b/drivers/char/hw_random/iproc-rng200.c
new file mode 100644
index 000000000000..276cb8a93bac
--- /dev/null
+++ b/drivers/char/hw_random/iproc-rng200.c
@@ -0,0 +1,254 @@
+/*
+* Copyright (C) 2015 Broadcom Corporation
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+/*
+ * DESCRIPTION: The Broadcom iProc RNG200 Driver
+ */
+
+#include <linux/hw_random.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+/* Registers */
+#define RNG_CTRL_OFFSET					0x00
+#define RNG_CTRL_RNG_RBGEN_MASK				0x00001FFF
+#define RNG_CTRL_RNG_RBGEN_ENABLE			0x00000001
+#define RNG_CTRL_RNG_RBGEN_DISABLE			0x00000000
+
+#define RNG_SOFT_RESET_OFFSET				0x04
+#define RNG_SOFT_RESET					0x00000001
+
+#define RBG_SOFT_RESET_OFFSET				0x08
+#define RBG_SOFT_RESET					0x00000001
+
+#define RNG_INT_STATUS_OFFSET				0x18
+#define RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK	0x80000000
+#define RNG_INT_STATUS_STARTUP_TRANSITIONS_MET_IRQ_MASK	0x00020000
+#define RNG_INT_STATUS_NIST_FAIL_IRQ_MASK		0x00000020
+#define RNG_INT_STATUS_TOTAL_BITS_COUNT_IRQ_MASK	0x00000001
+
+#define RNG_FIFO_DATA_OFFSET				0x20
+
+#define RNG_FIFO_COUNT_OFFSET				0x24
+#define RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK		0x000000FF
+
+struct iproc_rng200_dev {
+	void __iomem			*base;
+};
+
+static void iproc_rng200_restart(void __iomem *rng_base)
+{
+	uint32_t val;
+
+	/* Disable RBG */
+	val = ioread32(rng_base + RNG_CTRL_OFFSET);
+	val &= ~RNG_CTRL_RNG_RBGEN_MASK;
+	val |= RNG_CTRL_RNG_RBGEN_DISABLE;
+	iowrite32(val, rng_base + RNG_CTRL_OFFSET);
+
+	/* Clear all interrupt status */
+	iowrite32(0xFFFFFFFFUL, rng_base + RNG_INT_STATUS_OFFSET);
+
+	/* Reset RNG and RBG */
+	val = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);
+	val |= RBG_SOFT_RESET;
+	iowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);
+
+	val = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);
+	val |= RNG_SOFT_RESET;
+	iowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);
+
+	val = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);
+	val &= ~RNG_SOFT_RESET;
+	iowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);
+
+	val = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);
+	val &= ~RBG_SOFT_RESET;
+	iowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);
+
+	/* Enable RBG */
+	val = ioread32(rng_base + RNG_CTRL_OFFSET);
+	val &= ~RNG_CTRL_RNG_RBGEN_MASK;
+	val |= RNG_CTRL_RNG_RBGEN_ENABLE;
+	iowrite32(val, rng_base + RNG_CTRL_OFFSET);
+}
+
+static int iproc_rng200_read(struct hwrng *rng, void *buf, size_t max,
+			       bool wait)
+{
+	uint32_t status;
+	uint32_t num_remaining = max;
+	struct iproc_rng200_dev *priv = (struct iproc_rng200_dev *)rng->priv;
+
+	#define MAX_RESETS_PER_READ	1
+	uint32_t num_resets = 0;
+
+	#define MAX_IDLE_TIME	(1 * HZ)
+	unsigned long idle_endtime = jiffies + MAX_IDLE_TIME;
+
+	while ((num_remaining > 0) && time_before(jiffies, idle_endtime)) {
+
+		/* Is RNG sane? If not, reset it. */
+		status = ioread32(priv->base + RNG_INT_STATUS_OFFSET);
+		if ((status & (RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK |
+			RNG_INT_STATUS_NIST_FAIL_IRQ_MASK)) != 0) {
+
+			if (num_resets >= MAX_RESETS_PER_READ)
+				return max - num_remaining;
+
+			iproc_rng200_restart(priv->base);
+			num_resets++;
+		}
+
+		/* Are there any random numbers available? */
+		if ((ioread32(priv->base + RNG_FIFO_COUNT_OFFSET) &
+				RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK) > 0) {
+
+			if (num_remaining >= sizeof(uint32_t)) {
+				/* Buffer has room to store entire word */
+				*(uint32_t *)buf = ioread32(priv->base +
+							RNG_FIFO_DATA_OFFSET);
+				buf += sizeof(uint32_t);
+				num_remaining -= sizeof(uint32_t);
+			} else {
+				/* Buffer can only store partial word */
+				uint32_t rnd_number = ioread32(priv->base +
+							RNG_FIFO_DATA_OFFSET);
+				memcpy(buf, &rnd_number, num_remaining);
+				buf += num_remaining;
+				num_remaining = 0;
+			}
+
+			/* Reset the IDLE timeout */
+			idle_endtime = jiffies + MAX_IDLE_TIME;
+		} else {
+			if (!wait)
+				/* Cannot wait, return immediately */
+				return max - num_remaining;
+
+			/* Can wait, give others chance to run */
+			usleep_range(min(num_remaining * 10, 500U), 500);
+		}
+	}
+
+	return max - num_remaining;
+}
+
+static int iproc_rng200_init(struct hwrng *rng)
+{
+	uint32_t val;
+	struct iproc_rng200_dev *priv;
+
+	priv = (struct iproc_rng200_dev *)rng->priv;
+
+	/* Setup RNG. */
+	val = ioread32(priv->base + RNG_CTRL_OFFSET);
+	val &= ~RNG_CTRL_RNG_RBGEN_MASK;
+	val |= RNG_CTRL_RNG_RBGEN_ENABLE;
+	iowrite32(val, priv->base + RNG_CTRL_OFFSET);
+
+	return 0;
+}
+
+static void iproc_rng200_cleanup(struct hwrng *rng)
+{
+	uint32_t val;
+	struct iproc_rng200_dev *priv;
+
+	priv = (struct iproc_rng200_dev *)rng->priv;
+
+	/* Disable RNG hardware */
+	val = ioread32(priv->base + RNG_CTRL_OFFSET);
+	val &= ~RNG_CTRL_RNG_RBGEN_MASK;
+	val |= RNG_CTRL_RNG_RBGEN_DISABLE;
+	iowrite32(val, priv->base + RNG_CTRL_OFFSET);
+}
+
+static struct hwrng iproc_rng200_ops = {
+	.name		= "iproc-rng200",
+	.read		= iproc_rng200_read,
+	.init		= iproc_rng200_init,
+	.cleanup	= iproc_rng200_cleanup,
+};
+
+static int iproc_rng200_probe(struct platform_device *pdev)
+{
+	struct iproc_rng200_dev *priv;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(struct iproc_rng200_dev), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	iproc_rng200_ops.priv = (unsigned long)priv;
+	platform_set_drvdata(pdev, priv);
+
+	/* Map peripheral */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get rng resources\n");
+		return -EINVAL;
+	}
+
+	priv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base)) {
+		dev_err(dev, "failed to remap rng regs\n");
+		return PTR_ERR(priv->base);
+	}
+
+	/* Register driver */
+	ret = hwrng_register(&iproc_rng200_ops);
+	if (ret) {
+		dev_err(dev, "hwrng registration failed\n");
+		return ret;
+	}
+
+	dev_info(dev, "hwrng registered\n");
+
+	return 0;
+}
+
+static int iproc_rng200_remove(struct platform_device *pdev)
+{
+	/* Unregister driver */
+	hwrng_unregister(&iproc_rng200_ops);
+
+	return 0;
+}
+
+static const struct of_device_id iproc_rng200_of_match[] = {
+	{ .compatible = "brcm,iproc-rng200", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, iproc_rng200_of_match);
+
+static struct platform_driver iproc_rng200_driver = {
+	.driver = {
+		.name		= "iproc-rng200",
+		.of_match_table = iproc_rng200_of_match,
+	},
+	.probe		= iproc_rng200_probe,
+	.remove		= iproc_rng200_remove,
+};
+module_platform_driver(iproc_rng200_driver);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("iProc RNG200 Random Number Generator driver");
+MODULE_LICENSE("GPL v2");
