commit 45586c7078d42b932c5399953d21746800083691
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Feb 3 17:37:45 2020 -0800

    treewide: remove redundant IS_ERR() before error code check
    
    'PTR_ERR(p) == -E*' is a stronger condition than IS_ERR(p).
    Hence, IS_ERR(p) is unneeded.
    
    The semantic patch that generates this commit is as follows:
    
    // <smpl>
    @@
    expression ptr;
    constant error_code;
    @@
    -IS_ERR(ptr) && (PTR_ERR(ptr) == - error_code)
    +PTR_ERR(ptr) == - error_code
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20200106045833.1725-1-masahiroy@kernel.org
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Acked-by: Stephen Boyd <sboyd@kernel.org> [drivers/clk/clk.c]
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com> [GPIO]
    Acked-by: Wolfram Sang <wsa@the-dreams.de> [drivers/i2c]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [acpi/scan.c]
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Eric Biggers <ebiggers@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index d2a5791eb49f..cbf5eaea662c 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -157,7 +157,7 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 	/* Clock is optional on most platforms */
 	priv->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(priv->clk) && PTR_ERR(priv->clk) == -EPROBE_DEFER)
+	if (PTR_ERR(priv->clk) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
 	priv->rng.name = pdev->name;

commit 3e46bd34970632cdd948669c2fc8c9e8ace0c738
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Oct 16 18:46:10 2019 +0800

    hwrng: bcm2835 - use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index f759790c3cdb..d2a5791eb49f 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -142,7 +142,6 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	struct device_node *np = dev->of_node;
 	const struct of_device_id *rng_id;
 	struct bcm2835_rng_priv *priv;
-	struct resource *r;
 	int err;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -151,10 +150,8 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, priv);
 
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
 	/* map peripheral */
-	priv->base = devm_ioremap_resource(dev, r);
+	priv->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->base))
 		return PTR_ERR(priv->base);
 

commit 984798de671a927ac73da31096a150df42e6aaf3
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Feb 19 13:16:08 2019 +0100

    hwrng: bcm2835 - fix probe as platform device
    
    BCM63XX (MIPS) does not use device tree, so there cannot be any
    of_device_id, causing the driver to fail on probe:
    
    [    0.904564] bcm2835-rng: probe of bcm63xx-rng failed with error -22
    
    Fix this by checking for match data only if we are probing from device
    tree.
    
    Fixes: 8705f24f7b57 ("hwrng: bcm2835 - Enable BCM2835 RNG to work on BCM63xx platforms")
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 256b0b1d0f26..f759790c3cdb 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -168,14 +168,16 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	priv->rng.read = bcm2835_rng_read;
 	priv->rng.cleanup = bcm2835_rng_cleanup;
 
-	rng_id = of_match_node(bcm2835_rng_of_match, np);
-	if (!rng_id)
-		return -EINVAL;
-
-	/* Check for rng init function, execute it */
-	of_data = rng_id->data;
-	if (of_data)
-		priv->mask_interrupts = of_data->mask_interrupts;
+	if (dev_of_node(dev)) {
+		rng_id = of_match_node(bcm2835_rng_of_match, np);
+		if (!rng_id)
+			return -EINVAL;
+
+		/* Check for rng init function, execute it */
+		of_data = rng_id->data;
+		if (of_data)
+			priv->mask_interrupts = of_data->mask_interrupts;
+	}
 
 	/* register driver */
 	err = devm_hwrng_register(dev, &priv->rng);

commit 05ba88468b7d85c50d0945446248e0fcda7536bb
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sat Nov 10 15:51:16 2018 +0100

    hwrng: bcm2835 - Switch to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management. While we are at this fix the comment style, too.
    
    Cc: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 6767d965c36c..256b0b1d0f26 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -1,10 +1,7 @@
-/**
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (c) 2010-2012 Broadcom. All rights reserved.
  * Copyright (c) 2013 Lubomir Rintel
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License ("GPL")
- * version 2, as published by the Free Software Foundation.
  */
 
 #include <linux/hw_random.h>

commit 7b4c5d30d0bd2b22c09d4d993a76e0973a873891
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Mon Feb 12 21:11:36 2018 +0100

    hwrng: bcm2835 - Handle deferred clock properly
    
    In case the probe of the clock is deferred, we would assume it is
    optional. This is wrong, so defer the probe of this driver until
    the clock is available.
    
    Fixes: 791af4f4907a ("hwrng: bcm2835 - Manage an optional clock")
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 7a84cec30c3a..6767d965c36c 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -163,6 +163,8 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 	/* Clock is optional on most platforms */
 	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk) && PTR_ERR(priv->clk) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
 
 	priv->rng.name = pdev->name;
 	priv->rng.init = bcm2835_rng_init;

commit c4fc5d6d0b3750a17e3ee032f2c47620bed4e25a
Author: weiyongjun \(A\) <weiyongjun1@huawei.com>
Date:   Wed Jan 17 11:40:34 2018 +0000

    hwrng: bcm2835 - Remove redundant dev_err call in bcm2835_rng_probe()
    
    There is a error message within devm_ioremap_resource
    already, so remove the dev_err call to avoid redundant
    error message.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 25e56311a197..7a84cec30c3a 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -158,10 +158,8 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 	/* map peripheral */
 	priv->base = devm_ioremap_resource(dev, r);
-	if (IS_ERR(priv->base)) {
-		dev_err(dev, "failed to remap rng regs");
+	if (IS_ERR(priv->base))
 		return PTR_ERR(priv->base);
-	}
 
 	/* Clock is optional on most platforms */
 	priv->clk = devm_clk_get(dev, NULL);

commit 8705f24f7b575f8fe1fe52764ea5774db51e3cf8
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:48 2017 -0800

    hwrng: bcm2835 - Enable BCM2835 RNG to work on BCM63xx platforms
    
    We have now incorporated all necessary functionality for the BCM63xx
    platforms to successfully migrate over bcm2835-rng, so add the final
    bits: Kconfig selection and proper platform_device device type matching
    to keep the same platform device name for registration to work.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 6dd8f48701b5..25e56311a197 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -134,6 +134,7 @@ static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
 	{ .compatible = "brcm,bcm-nsp-rng", .data = &nsp_rng_of_data },
 	{ .compatible = "brcm,bcm5301x-rng", .data = &nsp_rng_of_data },
+	{ .compatible = "brcm,bcm6368-rng"},
 	{},
 };
 
@@ -165,7 +166,7 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	/* Clock is optional on most platforms */
 	priv->clk = devm_clk_get(dev, NULL);
 
-	priv->rng.name = "bcm2835-rng";
+	priv->rng.name = pdev->name;
 	priv->rng.init = bcm2835_rng_init;
 	priv->rng.read = bcm2835_rng_read;
 	priv->rng.cleanup = bcm2835_rng_cleanup;
@@ -191,12 +192,20 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 MODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);
 
+static struct platform_device_id bcm2835_rng_devtype[] = {
+	{ .name = "bcm2835-rng" },
+	{ .name = "bcm63xx-rng" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, bcm2835_rng_devtype);
+
 static struct platform_driver bcm2835_rng_driver = {
 	.driver = {
 		.name = "bcm2835-rng",
 		.of_match_table = bcm2835_rng_of_match,
 	},
 	.probe		= bcm2835_rng_probe,
+	.id_table	= bcm2835_rng_devtype,
 };
 module_platform_driver(bcm2835_rng_driver);
 

commit 6f09359a6810d1c903c97231803ef4518a3f7558
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:46 2017 -0800

    hwrng: bcm2835 - Add Broadcom MIPS I/O accessors
    
    Broadcom MIPS HW is always strapped to match the system-wide endian such
    that all I/O access to this RNG block is done with the native CPU
    endian, account for that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 3a607472687d..6dd8f48701b5 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -44,13 +44,22 @@ static inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)
 
 static inline u32 rng_readl(struct bcm2835_rng_priv *priv, u32 offset)
 {
-	return readl(priv->base + offset);
+	/* MIPS chips strapped for BE will automagically configure the
+	 * peripheral registers for CPU-native byte order.
+	 */
+	if (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))
+		return __raw_readl(priv->base + offset);
+	else
+		return readl(priv->base + offset);
 }
 
 static inline void rng_writel(struct bcm2835_rng_priv *priv, u32 val,
 			      u32 offset)
 {
-	writel(val, priv->base + offset);
+	if (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))
+		__raw_writel(val, priv->base + offset);
+	else
+		writel(val, priv->base + offset);
 }
 
 static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,

commit abd42026eab99691d8ab9e1cd417553cfadf9b76
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:45 2017 -0800

    hwrng: bcm2835 - Abstract I/O accessors
    
    In preparation for allowing BCM63xx to use this driver, we abstract I/O
    accessors such that we can easily change those later on.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 99b56fd5482c..3a607472687d 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -42,6 +42,17 @@ static inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)
 	return container_of(rng, struct bcm2835_rng_priv, rng);
 }
 
+static inline u32 rng_readl(struct bcm2835_rng_priv *priv, u32 offset)
+{
+	return readl(priv->base + offset);
+}
+
+static inline void rng_writel(struct bcm2835_rng_priv *priv, u32 val,
+			      u32 offset)
+{
+	writel(val, priv->base + offset);
+}
+
 static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 			       bool wait)
 {
@@ -49,18 +60,18 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 	u32 max_words = max / sizeof(u32);
 	u32 num_words, count;
 
-	while ((__raw_readl(priv->base + RNG_STATUS) >> 24) == 0) {
+	while ((rng_readl(priv, RNG_STATUS) >> 24) == 0) {
 		if (!wait)
 			return 0;
 		cpu_relax();
 	}
 
-	num_words = readl(priv->base + RNG_STATUS) >> 24;
+	num_words = rng_readl(priv, RNG_STATUS) >> 24;
 	if (num_words > max_words)
 		num_words = max_words;
 
 	for (count = 0; count < num_words; count++)
-		((u32 *)buf)[count] = readl(priv->base + RNG_DATA);
+		((u32 *)buf)[count] = rng_readl(priv, RNG_DATA);
 
 	return num_words * sizeof(u32);
 }
@@ -79,14 +90,14 @@ static int bcm2835_rng_init(struct hwrng *rng)
 
 	if (priv->mask_interrupts) {
 		/* mask the interrupt */
-		val = readl(priv->base + RNG_INT_MASK);
+		val = rng_readl(priv, RNG_INT_MASK);
 		val |= RNG_INT_OFF;
-		writel(val, priv->base + RNG_INT_MASK);
+		rng_writel(priv, val, RNG_INT_MASK);
 	}
 
 	/* set warm-up count & enable */
-	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
-	__raw_writel(RNG_RBGEN, priv->base + RNG_CTRL);
+	rng_writel(priv, RNG_WARMUP_COUNT, RNG_STATUS);
+	rng_writel(priv, RNG_RBGEN, RNG_CTRL);
 
 	return ret;
 }
@@ -96,7 +107,7 @@ static void bcm2835_rng_cleanup(struct hwrng *rng)
 	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
 
 	/* disable rng hardware */
-	__raw_writel(0, priv->base + RNG_CTRL);
+	rng_writel(priv, 0, RNG_CTRL);
 
 	if (!IS_ERR(priv->clk))
 		clk_disable_unprepare(priv->clk);

commit 791af4f4907a8bee879713cb19fa90e6369f8386
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:44 2017 -0800

    hwrng: bcm2835 - Manage an optional clock
    
    One of the last steps before bcm63xx-rng can be eliminated is to manage
    a clock during hwrng::init and hwrng::cleanup, so fetch it in the probe
    function, and manage it during these two steps when valid.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index ed20e0b6b7ae..99b56fd5482c 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -15,6 +15,7 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/printk.h>
+#include <linux/clk.h>
 
 #define RNG_CTRL	0x0
 #define RNG_STATUS	0x4
@@ -33,6 +34,7 @@ struct bcm2835_rng_priv {
 	struct hwrng rng;
 	void __iomem *base;
 	bool mask_interrupts;
+	struct clk *clk;
 };
 
 static inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)
@@ -66,8 +68,15 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 static int bcm2835_rng_init(struct hwrng *rng)
 {
 	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
+	int ret = 0;
 	u32 val;
 
+	if (!IS_ERR(priv->clk)) {
+		ret = clk_prepare_enable(priv->clk);
+		if (ret)
+			return ret;
+	}
+
 	if (priv->mask_interrupts) {
 		/* mask the interrupt */
 		val = readl(priv->base + RNG_INT_MASK);
@@ -79,7 +88,7 @@ static int bcm2835_rng_init(struct hwrng *rng)
 	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
 	__raw_writel(RNG_RBGEN, priv->base + RNG_CTRL);
 
-	return 0;
+	return ret;
 }
 
 static void bcm2835_rng_cleanup(struct hwrng *rng)
@@ -88,6 +97,9 @@ static void bcm2835_rng_cleanup(struct hwrng *rng)
 
 	/* disable rng hardware */
 	__raw_writel(0, priv->base + RNG_CTRL);
+
+	if (!IS_ERR(priv->clk))
+		clk_disable_unprepare(priv->clk);
 }
 
 struct bcm2835_rng_of_data {
@@ -130,6 +142,9 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->base);
 	}
 
+	/* Clock is optional on most platforms */
+	priv->clk = devm_clk_get(dev, NULL);
+
 	priv->rng.name = "bcm2835-rng";
 	priv->rng.init = bcm2835_rng_init;
 	priv->rng.read = bcm2835_rng_read;

commit 04b154fa86afb6ccfd38ef9b563c098b13f5984d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:43 2017 -0800

    hwrng: bcm2835 - Rework interrupt masking
    
    The interrupt masking done for Northstart Plus and Northstar (BCM5301X)
    is moved from being a function pointer mapped to of_device_id::data into
    a proper part of the hwrng::init callback. While at it, we also make the
    of_data be a proper structure indicating the platform specifics, since
    the day we need to add a second type of platform information, we would
    have to do that anyway.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 67b9bd3be28d..ed20e0b6b7ae 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -32,18 +32,9 @@
 struct bcm2835_rng_priv {
 	struct hwrng rng;
 	void __iomem *base;
+	bool mask_interrupts;
 };
 
-static void __init nsp_rng_init(void __iomem *base)
-{
-	u32 val;
-
-	/* mask the interrupt */
-	val = readl(base + RNG_INT_MASK);
-	val |= RNG_INT_OFF;
-	writel(val, base + RNG_INT_MASK);
-}
-
 static inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)
 {
 	return container_of(rng, struct bcm2835_rng_priv, rng);
@@ -75,6 +66,14 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 static int bcm2835_rng_init(struct hwrng *rng)
 {
 	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
+	u32 val;
+
+	if (priv->mask_interrupts) {
+		/* mask the interrupt */
+		val = readl(priv->base + RNG_INT_MASK);
+		val |= RNG_INT_OFF;
+		writel(val, priv->base + RNG_INT_MASK);
+	}
 
 	/* set warm-up count & enable */
 	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
@@ -91,18 +90,26 @@ static void bcm2835_rng_cleanup(struct hwrng *rng)
 	__raw_writel(0, priv->base + RNG_CTRL);
 }
 
+struct bcm2835_rng_of_data {
+	bool mask_interrupts;
+};
+
+static const struct bcm2835_rng_of_data nsp_rng_of_data = {
+	.mask_interrupts = true,
+};
+
 static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
-	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
-	{ .compatible = "brcm,bcm5301x-rng", .data = nsp_rng_init},
+	{ .compatible = "brcm,bcm-nsp-rng", .data = &nsp_rng_of_data },
+	{ .compatible = "brcm,bcm5301x-rng", .data = &nsp_rng_of_data },
 	{},
 };
 
 static int bcm2835_rng_probe(struct platform_device *pdev)
 {
+	const struct bcm2835_rng_of_data *of_data;
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
-	void (*rng_setup)(void __iomem *base);
 	const struct of_device_id *rng_id;
 	struct bcm2835_rng_priv *priv;
 	struct resource *r;
@@ -133,9 +140,9 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 		return -EINVAL;
 
 	/* Check for rng init function, execute it */
-	rng_setup = rng_id->data;
-	if (rng_setup)
-		rng_setup(priv->base);
+	of_data = rng_id->data;
+	if (of_data)
+		priv->mask_interrupts = of_data->mask_interrupts;
 
 	/* register driver */
 	err = devm_hwrng_register(dev, &priv->rng);

commit 16a4c04b3729910f864512a1150fee5ad19efb4a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:42 2017 -0800

    hwrng: bcm2835 - Use device managed helpers
    
    Now that we have moved the RNG disabling into a hwrng::cleanup callback,
    we can use the device managed registration operation and remove our
    remove callback since it won't do anything necessary.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 4d0356110b1b..67b9bd3be28d 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -138,7 +138,7 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 		rng_setup(priv->base);
 
 	/* register driver */
-	err = hwrng_register(&priv->rng);
+	err = devm_hwrng_register(dev, &priv->rng);
 	if (err)
 		dev_err(dev, "hwrng registration failed\n");
 	else
@@ -147,16 +147,6 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int bcm2835_rng_remove(struct platform_device *pdev)
-{
-	struct bcm2835_rng_priv *priv = platform_get_drvdata(pdev);
-
-	/* unregister driver */
-	hwrng_unregister(&priv->rng);
-
-	return 0;
-}
-
 MODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);
 
 static struct platform_driver bcm2835_rng_driver = {
@@ -165,7 +155,6 @@ static struct platform_driver bcm2835_rng_driver = {
 		.of_match_table = bcm2835_rng_of_match,
 	},
 	.probe		= bcm2835_rng_probe,
-	.remove		= bcm2835_rng_remove,
 };
 module_platform_driver(bcm2835_rng_driver);
 

commit ec94bca7be6b29c1aebf2e1e95855ee6ca0d5d62
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:41 2017 -0800

    hwrng: bcm2835 - Implementation cleanup callback
    
    We should be disabling the RNG in a hwrng::cleanup callback if we are
    not longer the system selected RNG, not wait until the device driver is
    removed.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 82000a637504..4d0356110b1b 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -83,6 +83,14 @@ static int bcm2835_rng_init(struct hwrng *rng)
 	return 0;
 }
 
+static void bcm2835_rng_cleanup(struct hwrng *rng)
+{
+	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
+
+	/* disable rng hardware */
+	__raw_writel(0, priv->base + RNG_CTRL);
+}
+
 static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
 	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
@@ -118,6 +126,7 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	priv->rng.name = "bcm2835-rng";
 	priv->rng.init = bcm2835_rng_init;
 	priv->rng.read = bcm2835_rng_read;
+	priv->rng.cleanup = bcm2835_rng_cleanup;
 
 	rng_id = of_match_node(bcm2835_rng_of_match, np);
 	if (!rng_id)
@@ -142,9 +151,6 @@ static int bcm2835_rng_remove(struct platform_device *pdev)
 {
 	struct bcm2835_rng_priv *priv = platform_get_drvdata(pdev);
 
-	/* disable rng hardware */
-	__raw_writel(0, priv->base + RNG_CTRL);
-
 	/* unregister driver */
 	hwrng_unregister(&priv->rng);
 

commit a815777553826079929e0910fcf3fda9a1e8438b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:40 2017 -0800

    hwrng: bcm2835 - Move enabling to hwrng::init
    
    We should be moving the enabling of the HWRNG into a hwrng::init
    callback since we can be disabled and enabled every time a different
    hwrng is selected in the system.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 0d72147ab45b..82000a637504 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -72,6 +72,17 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 	return num_words * sizeof(u32);
 }
 
+static int bcm2835_rng_init(struct hwrng *rng)
+{
+	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
+
+	/* set warm-up count & enable */
+	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
+	__raw_writel(RNG_RBGEN, priv->base + RNG_CTRL);
+
+	return 0;
+}
+
 static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
 	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
@@ -105,6 +116,7 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	}
 
 	priv->rng.name = "bcm2835-rng";
+	priv->rng.init = bcm2835_rng_init;
 	priv->rng.read = bcm2835_rng_read;
 
 	rng_id = of_match_node(bcm2835_rng_of_match, np);
@@ -116,10 +128,6 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	if (rng_setup)
 		rng_setup(priv->base);
 
-	/* set warm-up count & enable */
-	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
-	__raw_writel(RNG_RBGEN, priv->base + RNG_CTRL);
-
 	/* register driver */
 	err = hwrng_register(&priv->rng);
 	if (err)

commit b788479f68263fbb191daa5b2007de45f0548a72
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:39 2017 -0800

    hwrng: bcm2835 - Define a driver private context
    
    Instead of making hwrng::priv host the base register address, define a
    driver private context, make it per platform device instance and pass it
    down the different functions.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index a818418a7e4c..0d72147ab45b 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -29,6 +29,11 @@
 
 #define RNG_INT_OFF	0x1
 
+struct bcm2835_rng_priv {
+	struct hwrng rng;
+	void __iomem *base;
+};
+
 static void __init nsp_rng_init(void __iomem *base)
 {
 	u32 val;
@@ -39,34 +44,34 @@ static void __init nsp_rng_init(void __iomem *base)
 	writel(val, base + RNG_INT_MASK);
 }
 
+static inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)
+{
+	return container_of(rng, struct bcm2835_rng_priv, rng);
+}
+
 static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 			       bool wait)
 {
-	void __iomem *rng_base = (void __iomem *)rng->priv;
+	struct bcm2835_rng_priv *priv = to_rng_priv(rng);
 	u32 max_words = max / sizeof(u32);
 	u32 num_words, count;
 
-	while ((__raw_readl(rng_base + RNG_STATUS) >> 24) == 0) {
+	while ((__raw_readl(priv->base + RNG_STATUS) >> 24) == 0) {
 		if (!wait)
 			return 0;
 		cpu_relax();
 	}
 
-	num_words = readl(rng_base + RNG_STATUS) >> 24;
+	num_words = readl(priv->base + RNG_STATUS) >> 24;
 	if (num_words > max_words)
 		num_words = max_words;
 
 	for (count = 0; count < num_words; count++)
-		((u32 *)buf)[count] = readl(rng_base + RNG_DATA);
+		((u32 *)buf)[count] = readl(priv->base + RNG_DATA);
 
 	return num_words * sizeof(u32);
 }
 
-static struct hwrng bcm2835_rng_ops = {
-	.name	= "bcm2835",
-	.read	= bcm2835_rng_read,
-};
-
 static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
 	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
@@ -80,19 +85,27 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	struct device_node *np = dev->of_node;
 	void (*rng_setup)(void __iomem *base);
 	const struct of_device_id *rng_id;
-	void __iomem *rng_base;
+	struct bcm2835_rng_priv *priv;
 	struct resource *r;
 	int err;
 
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
 	/* map peripheral */
-	rng_base = devm_ioremap_resource(dev, r);
-	if (IS_ERR(rng_base)) {
+	priv->base = devm_ioremap_resource(dev, r);
+	if (IS_ERR(priv->base)) {
 		dev_err(dev, "failed to remap rng regs");
-		return PTR_ERR(rng_base);
+		return PTR_ERR(priv->base);
 	}
-	bcm2835_rng_ops.priv = (unsigned long)rng_base;
+
+	priv->rng.name = "bcm2835-rng";
+	priv->rng.read = bcm2835_rng_read;
 
 	rng_id = of_match_node(bcm2835_rng_of_match, np);
 	if (!rng_id)
@@ -101,14 +114,14 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	/* Check for rng init function, execute it */
 	rng_setup = rng_id->data;
 	if (rng_setup)
-		rng_setup(rng_base);
+		rng_setup(priv->base);
 
 	/* set warm-up count & enable */
-	__raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);
-	__raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);
+	__raw_writel(RNG_WARMUP_COUNT, priv->base + RNG_STATUS);
+	__raw_writel(RNG_RBGEN, priv->base + RNG_CTRL);
 
 	/* register driver */
-	err = hwrng_register(&bcm2835_rng_ops);
+	err = hwrng_register(&priv->rng);
 	if (err)
 		dev_err(dev, "hwrng registration failed\n");
 	else
@@ -119,13 +132,13 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 static int bcm2835_rng_remove(struct platform_device *pdev)
 {
-	void __iomem *rng_base = (void __iomem *)bcm2835_rng_ops.priv;
+	struct bcm2835_rng_priv *priv = platform_get_drvdata(pdev);
 
 	/* disable rng hardware */
-	__raw_writel(0, rng_base + RNG_CTRL);
+	__raw_writel(0, priv->base + RNG_CTRL);
 
 	/* unregister driver */
-	hwrng_unregister(&bcm2835_rng_ops);
+	hwrng_unregister(&priv->rng);
 
 	return 0;
 }

commit 21bb0ef43c11184961792790919d6daf9823e57a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 7 16:44:38 2017 -0800

    hwrng: bcm2835 - Obtain base register via resource
    
    In preparation for consolidating bcm63xx-rng into bcm2835-rng, make sure
    that we obtain the base register via platform_get_resource() since we
    need to support the non-DT enabled MIPS-based BCM63xx DSL SoCs.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 574211a49549..a818418a7e4c 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -81,21 +81,23 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	void (*rng_setup)(void __iomem *base);
 	const struct of_device_id *rng_id;
 	void __iomem *rng_base;
+	struct resource *r;
 	int err;
 
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
 	/* map peripheral */
-	rng_base = of_iomap(np, 0);
-	if (!rng_base) {
+	rng_base = devm_ioremap_resource(dev, r);
+	if (IS_ERR(rng_base)) {
 		dev_err(dev, "failed to remap rng regs");
-		return -ENODEV;
+		return PTR_ERR(rng_base);
 	}
 	bcm2835_rng_ops.priv = (unsigned long)rng_base;
 
 	rng_id = of_match_node(bcm2835_rng_of_match, np);
-	if (!rng_id) {
-		iounmap(rng_base);
+	if (!rng_id)
 		return -EINVAL;
-	}
+
 	/* Check for rng init function, execute it */
 	rng_setup = rng_id->data;
 	if (rng_setup)
@@ -107,10 +109,9 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 
 	/* register driver */
 	err = hwrng_register(&bcm2835_rng_ops);
-	if (err) {
+	if (err)
 		dev_err(dev, "hwrng registration failed\n");
-		iounmap(rng_base);
-	} else
+	else
 		dev_info(dev, "hwrng registered\n");
 
 	return err;
@@ -125,7 +126,6 @@ static int bcm2835_rng_remove(struct platform_device *pdev)
 
 	/* unregister driver */
 	hwrng_unregister(&bcm2835_rng_ops);
-	iounmap(rng_base);
 
 	return 0;
 }

commit da59c51cf2201b6b242bdea320fcfe7b8d331900
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Aug 29 22:40:16 2016 +0530

    hwrng: bcm2835 - handle of_iomap failures
    
    Check return value of of_iomap and handle errors correctly.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index af2149273fe0..574211a49549 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -92,9 +92,10 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	bcm2835_rng_ops.priv = (unsigned long)rng_base;
 
 	rng_id = of_match_node(bcm2835_rng_of_match, np);
-	if (!rng_id)
+	if (!rng_id) {
+		iounmap(rng_base);
 		return -EINVAL;
-
+	}
 	/* Check for rng init function, execute it */
 	rng_setup = rng_id->data;
 	if (rng_setup)

commit 52140993d4fccde6004df9e282a81580d9d5e4da
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Jun 22 17:27:02 2016 -0700

    hwrng: bcm2835 - Add support for Broadcom BCM5301x
    
    The Broadcom BCM5301x SoCs (Northstar) utilize the same random number
    generator peripheral as Northstar Plus and BCM2835, but just like the
    NSP SoC, we need to enable the interrupt.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 75ca820730be..af2149273fe0 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -70,6 +70,7 @@ static struct hwrng bcm2835_rng_ops = {
 static const struct of_device_id bcm2835_rng_of_match[] = {
 	{ .compatible = "brcm,bcm2835-rng"},
 	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
+	{ .compatible = "brcm,bcm5301x-rng", .data = nsp_rng_init},
 	{},
 };
 

commit 4f8de65bab611a68f40355ac9169edb4d0d33974
Author: Yendapally Reddy Dhananjaya Reddy <yendapally.reddy@broadcom.com>
Date:   Fri May 27 06:10:41 2016 -0400

    hwrng: bcm2835 - Read as much data as available
    
    Read the requested number of data from the fifo
    
    Signed-off-by: Yendapally Reddy Dhananjaya Reddy <yendapally.reddy@broadcom.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index b1e8b7847e9a..75ca820730be 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -43,6 +43,8 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 			       bool wait)
 {
 	void __iomem *rng_base = (void __iomem *)rng->priv;
+	u32 max_words = max / sizeof(u32);
+	u32 num_words, count;
 
 	while ((__raw_readl(rng_base + RNG_STATUS) >> 24) == 0) {
 		if (!wait)
@@ -50,8 +52,14 @@ static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 		cpu_relax();
 	}
 
-	*(u32 *)buf = __raw_readl(rng_base + RNG_DATA);
-	return sizeof(u32);
+	num_words = readl(rng_base + RNG_STATUS) >> 24;
+	if (num_words > max_words)
+		num_words = max_words;
+
+	for (count = 0; count < num_words; count++)
+		((u32 *)buf)[count] = readl(rng_base + RNG_DATA);
+
+	return num_words * sizeof(u32);
 }
 
 static struct hwrng bcm2835_rng_ops = {

commit 422a7491459b4d989259cd94fd21f4fbde382930
Author: Yendapally Reddy Dhananjaya Reddy <yendapally.reddy@broadcom.com>
Date:   Fri May 27 06:10:39 2016 -0400

    hwrng: bcm2835 - Support Broadcom NSP SoC rng
    
    This supports the random number generator available in NSP SoC.
    Masks the rng interrupt for NSP.
    
    Signed-off-by: Yendapally Reddy Dhananjaya Reddy <yendapally.reddy@broadcom.com>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 7192ec25f667..b1e8b7847e9a 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -19,6 +19,7 @@
 #define RNG_CTRL	0x0
 #define RNG_STATUS	0x4
 #define RNG_DATA	0x8
+#define RNG_INT_MASK	0x10
 
 /* enable rng */
 #define RNG_RBGEN	0x1
@@ -26,6 +27,18 @@
 /* the initial numbers generated are "less random" so will be discarded */
 #define RNG_WARMUP_COUNT 0x40000
 
+#define RNG_INT_OFF	0x1
+
+static void __init nsp_rng_init(void __iomem *base)
+{
+	u32 val;
+
+	/* mask the interrupt */
+	val = readl(base + RNG_INT_MASK);
+	val |= RNG_INT_OFF;
+	writel(val, base + RNG_INT_MASK);
+}
+
 static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
 			       bool wait)
 {
@@ -46,10 +59,18 @@ static struct hwrng bcm2835_rng_ops = {
 	.read	= bcm2835_rng_read,
 };
 
+static const struct of_device_id bcm2835_rng_of_match[] = {
+	{ .compatible = "brcm,bcm2835-rng"},
+	{ .compatible = "brcm,bcm-nsp-rng", .data = nsp_rng_init},
+	{},
+};
+
 static int bcm2835_rng_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
+	void (*rng_setup)(void __iomem *base);
+	const struct of_device_id *rng_id;
 	void __iomem *rng_base;
 	int err;
 
@@ -61,6 +82,15 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	}
 	bcm2835_rng_ops.priv = (unsigned long)rng_base;
 
+	rng_id = of_match_node(bcm2835_rng_of_match, np);
+	if (!rng_id)
+		return -EINVAL;
+
+	/* Check for rng init function, execute it */
+	rng_setup = rng_id->data;
+	if (rng_setup)
+		rng_setup(rng_base);
+
 	/* set warm-up count & enable */
 	__raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);
 	__raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);
@@ -90,10 +120,6 @@ static int bcm2835_rng_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id bcm2835_rng_of_match[] = {
-	{ .compatible = "brcm,bcm2835-rng", },
-	{},
-};
 MODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);
 
 static struct platform_driver bcm2835_rng_driver = {

commit eff54802fe981a378555aebd86af0d11e83899ff
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:20 2014 +0200

    char: hw_random: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index e900961cdd2e..7192ec25f667 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -99,7 +99,6 @@ MODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);
 static struct platform_driver bcm2835_rng_driver = {
 	.driver = {
 		.name = "bcm2835-rng",
-		.owner = THIS_MODULE,
 		.of_match_table = bcm2835_rng_of_match,
 	},
 	.probe		= bcm2835_rng_probe,

commit eb4a5346e777784f1b5ae9fd0c29b96344bdc3ae
Author: Matt Porter <mporter@linaro.org>
Date:   Thu Apr 10 15:22:10 2014 -0400

    hwrng: bcm2835 - fix oops when rng h/w is accessed during registration
    
    Commit "d9e7972 hwrng: add randomness to system from rng sources"
    exposed a bug in the bcm2835-rng driver resulting in boot failure
    on Raspberry Pi due to the following oops:
    
    [   28.261523] BUG: soft lockup - CPU#0 stuck for 23s! [swapper:1]
    [   28.271058]
    [   28.275958] CPU: 0 PID: 1 Comm: swapper Not tainted 3.14.0+ #11
    [   28.285374] task: db480000 ti: db484000 task.ti: db484000
    [   28.294279] PC is at bcm2835_rng_read+0x28/0x48
    [   28.302276] LR is at hwrng_register+0x1a8/0x238
    .
    .
    .
    
    The RNG h/w is not completely initialized and enabled before
    hwrng_register() is called and so the bcm2835_rng_read() fails.
    Fix this by making the warmup/enable writes before registering
    the RNG source with the hwrng core.
    
    Signed-off-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 8c3b255e629a..e900961cdd2e 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -61,18 +61,18 @@ static int bcm2835_rng_probe(struct platform_device *pdev)
 	}
 	bcm2835_rng_ops.priv = (unsigned long)rng_base;
 
+	/* set warm-up count & enable */
+	__raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);
+	__raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);
+
 	/* register driver */
 	err = hwrng_register(&bcm2835_rng_ops);
 	if (err) {
 		dev_err(dev, "hwrng registration failed\n");
 		iounmap(rng_base);
-	} else {
+	} else
 		dev_info(dev, "hwrng registered\n");
 
-		/* set warm-up count & enable */
-		__raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);
-		__raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);
-	}
 	return err;
 }
 

commit 4c020b032b8a15966e1207b71144ffbb75697e29
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:59 2014 -0500

    drivers/char: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Peter Huewe <peterhuewe@gmx.de>
    Cc: Ashley Lai <ashley@ashleylai.com>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index 43577ca780e3..8c3b255e629a 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -8,7 +8,6 @@
  */
 
 #include <linux/hw_random.h>
-#include <linux/init.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/module.h>

commit 22e8099f4f6621b8d165e238cdef2a1cf655e159
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 23 15:39:50 2013 +0200

    hwrng: bcm2835: fix MODULE_LICENSE tag
    
    The MODULE_LICENSE macro invocation must use either "GPL" or "GPL v2",
    but not "GPLv2" in order to be detected by the module loader.
    
    This fixes the allmodconfig build error:
    
    FATAL: modpost: GPL-incompatible module bcm2835-rng.ko uses GPL-only symbol 'platform_driver_unregister'
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk>
    Cc: Dom Cobley <popcornmix@gmail.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: linux-rpi-kernel@lists.infradead.org
    Cc: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
index eb7f14725ebd..43577ca780e3 100644
--- a/drivers/char/hw_random/bcm2835-rng.c
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -110,4 +110,4 @@ module_platform_driver(bcm2835_rng_driver);
 
 MODULE_AUTHOR("Lubomir Rintel <lkundrak@v3.sk>");
 MODULE_DESCRIPTION("BCM2835 Random Number Generator (RNG) driver");
-MODULE_LICENSE("GPLv2");
+MODULE_LICENSE("GPL v2");

commit 8c4196a2fd7c31acd6d02d9921f7896b8f160c92
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Thu Mar 28 07:19:38 2013 +0100

    hwrng: bcm2835 - Add Broadcom BCM2835 RNG driver
    
    This adds a driver for random number generator present on Broadcom BCM2835 SoC,
    used in Raspberry Pi and Roku 2 devices.
    
    Signed-off-by: Dom Cobley <popcornmix@gmail.com>
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: linux-rpi-kernel@lists.infradead.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/bcm2835-rng.c b/drivers/char/hw_random/bcm2835-rng.c
new file mode 100644
index 000000000000..eb7f14725ebd
--- /dev/null
+++ b/drivers/char/hw_random/bcm2835-rng.c
@@ -0,0 +1,113 @@
+/**
+ * Copyright (c) 2010-2012 Broadcom. All rights reserved.
+ * Copyright (c) 2013 Lubomir Rintel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License ("GPL")
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/hw_random.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define RNG_CTRL	0x0
+#define RNG_STATUS	0x4
+#define RNG_DATA	0x8
+
+/* enable rng */
+#define RNG_RBGEN	0x1
+
+/* the initial numbers generated are "less random" so will be discarded */
+#define RNG_WARMUP_COUNT 0x40000
+
+static int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,
+			       bool wait)
+{
+	void __iomem *rng_base = (void __iomem *)rng->priv;
+
+	while ((__raw_readl(rng_base + RNG_STATUS) >> 24) == 0) {
+		if (!wait)
+			return 0;
+		cpu_relax();
+	}
+
+	*(u32 *)buf = __raw_readl(rng_base + RNG_DATA);
+	return sizeof(u32);
+}
+
+static struct hwrng bcm2835_rng_ops = {
+	.name	= "bcm2835",
+	.read	= bcm2835_rng_read,
+};
+
+static int bcm2835_rng_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *rng_base;
+	int err;
+
+	/* map peripheral */
+	rng_base = of_iomap(np, 0);
+	if (!rng_base) {
+		dev_err(dev, "failed to remap rng regs");
+		return -ENODEV;
+	}
+	bcm2835_rng_ops.priv = (unsigned long)rng_base;
+
+	/* register driver */
+	err = hwrng_register(&bcm2835_rng_ops);
+	if (err) {
+		dev_err(dev, "hwrng registration failed\n");
+		iounmap(rng_base);
+	} else {
+		dev_info(dev, "hwrng registered\n");
+
+		/* set warm-up count & enable */
+		__raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);
+		__raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);
+	}
+	return err;
+}
+
+static int bcm2835_rng_remove(struct platform_device *pdev)
+{
+	void __iomem *rng_base = (void __iomem *)bcm2835_rng_ops.priv;
+
+	/* disable rng hardware */
+	__raw_writel(0, rng_base + RNG_CTRL);
+
+	/* unregister driver */
+	hwrng_unregister(&bcm2835_rng_ops);
+	iounmap(rng_base);
+
+	return 0;
+}
+
+static const struct of_device_id bcm2835_rng_of_match[] = {
+	{ .compatible = "brcm,bcm2835-rng", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);
+
+static struct platform_driver bcm2835_rng_driver = {
+	.driver = {
+		.name = "bcm2835-rng",
+		.owner = THIS_MODULE,
+		.of_match_table = bcm2835_rng_of_match,
+	},
+	.probe		= bcm2835_rng_probe,
+	.remove		= bcm2835_rng_remove,
+};
+module_platform_driver(bcm2835_rng_driver);
+
+MODULE_AUTHOR("Lubomir Rintel <lkundrak@v3.sk>");
+MODULE_DESCRIPTION("BCM2835 Random Number Generator (RNG) driver");
+MODULE_LICENSE("GPLv2");
